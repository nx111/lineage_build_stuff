From 9c1e56fdf4822b75c647c5ce45c00d47097bd56f Mon Sep 17 00:00:00 2001
From: Paul Keith <javelinanddart@gmail.com>
Date: Sun, 3 Feb 2019 18:49:23 -0600
Subject: [PATCH 4/4] sdk: Allow using named services for HIDL features

* In case devices want to override a default impl that
  (for some reason) is returning true in isSupported()

Change-Id: If1fae7387644aefe290975973e8f0e9051b3c58f
---
 lineage/res/res/values/config.xml             |  8 +++
 lineage/res/res/values/symbols.xml            |  3 ++
 .../hardware/LineageHardwareManager.java      | 54 +++++++++++++------
 3 files changed, 49 insertions(+), 16 deletions(-)

diff --git a/lineage/res/res/values/config.xml b/lineage/res/res/values/config.xml
index 1bead47..561ae6f 100644
--- a/lineage/res/res/values/config.xml
+++ b/lineage/res/res/values/config.xml
@@ -248,4 +248,12 @@
     <!-- Whether device needs to wait for Qualcomm MPCTL service to start
          before setting power profiles on boot. -->
     <bool name="config_waitForMpctlOnBoot">false</bool>
+
+    <!-- HIDL Service Names.
+         If the device registers a service with a name rather than using
+         default, for whatever reason, this can be used to select it.
+         Format is $feature:name, where $feature is a feature constant in
+         LineageHardwareManager. If unmapped, the default service is used -->
+    <string-array name="config_serviceNameMappings" translatable="false">
+    </string-array>
 </resources>
diff --git a/lineage/res/res/values/symbols.xml b/lineage/res/res/values/symbols.xml
index da41026..104cb0f 100644
--- a/lineage/res/res/values/symbols.xml
+++ b/lineage/res/res/values/symbols.xml
@@ -187,4 +187,7 @@
 
     <!-- Notch -->
     <java-symbol type="bool" name="config_haveNotch" />
+
+    <!-- HIDL -->
+    <java-symbol type="array" name="config_serviceNameMappings" />
 </resources>
diff --git a/sdk/src/java/lineageos/hardware/LineageHardwareManager.java b/sdk/src/java/lineageos/hardware/LineageHardwareManager.java
index 33a62cd..eb4dc0d 100644
--- a/sdk/src/java/lineageos/hardware/LineageHardwareManager.java
+++ b/sdk/src/java/lineageos/hardware/LineageHardwareManager.java
@@ -179,6 +179,7 @@ public final class LineageHardwareManager {
 
     // HIDL hals
     private HashMap<Integer, IBase> mHIDLMap = new HashMap<Integer, IBase>();
+    private HashMap<Integer, String> mHIDLNameMap = new HashMap<Integer, String>();
 
     /**
      * @hide to prevent subclassing from outside of the framework
@@ -199,10 +200,10 @@ public final class LineageHardwareManager {
                     " SystemServer init");
         }
 
-        final String[] mappings = mContext.getResources().getStringArray(
+        final String[] modeMappings = mContext.getResources().getStringArray(
                 org.lineageos.platform.internal.R.array.config_displayModeMappings);
-        if (mappings != null && mappings.length > 0) {
-            for (String mapping : mappings) {
+        if (modeMappings != null && modeMappings.length > 0) {
+            for (String mapping : modeMappings) {
                 String[] split = mapping.split(":");
                 if (split.length == 2) {
                     mDisplayModeMappings.put(split[0], split[1]);
@@ -211,6 +212,26 @@ public final class LineageHardwareManager {
         }
         mFilterDisplayModes = mContext.getResources().getBoolean(
                 org.lineageos.platform.internal.R.bool.config_filterDisplayModes);
+
+        final String[] serviceMappings = mContext.getResources().getStringArray(
+                org.lineageos.platform.internal.R.array.config_serviceNameMappings);
+        if (serviceMappings != null && serviceMappings.length > 0) {
+            for (String mapping : serviceMappings) {
+                String[] split = mapping.split(":");
+                if (split.length == 2) {
+                    int feature = 0;
+                    try {
+                        Field f = getClass().getField(split[0]);
+                        if (f != null) {
+                            feature = (int) f.get(null);
+                        }
+                    } catch (NoSuchFieldException | IllegalAccessException e) {
+                        continue;
+                    }
+                    mHIDLNameMap.put(feature, split[1]);
+                }
+            }
+        }
     }
 
     /**
@@ -267,34 +288,35 @@ public final class LineageHardwareManager {
     }
 
     private IBase getHIDLService(int feature) {
+        String name = mHIDLNameMap.containsKey(feature) ? mHIDLNameMap.get(feature) : "default";
         try {
             switch (feature) {
                 case FEATURE_ADAPTIVE_BACKLIGHT:
-                    return IAdaptiveBacklight.getService(true);
+                    return IAdaptiveBacklight.getService(name, true);
                 case FEATURE_AUTO_CONTRAST:
-                    return IAutoContrast.getService(true);
+                    return IAutoContrast.getService(name, true);
                 case FEATURE_COLOR_BALANCE:
-                    return IColorBalance.getService(true);
+                    return IColorBalance.getService(name, true);
                 case FEATURE_COLOR_ENHANCEMENT:
-                    return IColorEnhancement.getService(true);
+                    return IColorEnhancement.getService(name, true);
                 case FEATURE_DISPLAY_COLOR_CALIBRATION:
-                    return IDisplayColorCalibration.getService(true);
+                    return IDisplayColorCalibration.getService(name, true);
                 case FEATURE_DISPLAY_MODES:
-                    return IDisplayModes.getService(true);
+                    return IDisplayModes.getService(name, true);
                 case FEATURE_PICTURE_ADJUSTMENT:
-                    return IPictureAdjustment.getService(true);
+                    return IPictureAdjustment.getService(name, true);
                 case FEATURE_READING_ENHANCEMENT:
-                    return IReadingEnhancement.getService(true);
+                    return IReadingEnhancement.getService(name, true);
                 case FEATURE_SUNLIGHT_ENHANCEMENT:
-                    return ISunlightEnhancement.getService(true);
+                    return ISunlightEnhancement.getService(name, true);
                 case FEATURE_HIGH_TOUCH_SENSITIVITY:
-                    return IGloveMode.getService(true);
+                    return IGloveMode.getService(name, true);
                 case FEATURE_KEY_DISABLE:
-                    return IKeyDisabler.getService(true);
+                    return IKeyDisabler.getService(name, true);
                 case FEATURE_TOUCH_HOVERING:
-                    return IStylusMode.getService(true);
+                    return IStylusMode.getService(name, true);
                 case FEATURE_TOUCHSCREEN_GESTURES:
-                    return ITouchscreenGesture.getService(true);
+                    return ITouchscreenGesture.getService(name, true);
             }
         } catch (NoSuchElementException | RemoteException e) {
         }
-- 
2.17.1

