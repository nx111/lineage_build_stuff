From aeec8e6d4f9776daca8a066882972a045c936f7d Mon Sep 17 00:00:00 2001
From: Paul Keith <javelinanddart@gmail.com>
Date: Thu, 7 Feb 2019 12:40:27 -0600
Subject: [PATCH 3/3] sdk: LineageHardwareService: Add fallback to HWC2

* We can't talk to DisplayTransformManager in C++, so
  we must have a fallback in the SDK itself for HWC2
* While we're at it, fix the size of the int array created
  in getDisplayColorCalibration() to be 5 rather than 6

Change-Id: Ic524f7d60ae1585efed3fba676cf3301dcaecd7f
---
 .../internal/LineageHardwareService.java      | 82 ++++++++++++++++++-
 1 file changed, 78 insertions(+), 4 deletions(-)

diff --git a/lineage/lib/main/java/org/lineageos/platform/internal/LineageHardwareService.java b/lineage/lib/main/java/org/lineageos/platform/internal/LineageHardwareService.java
index 4672d14..beb3a72 100644
--- a/lineage/lib/main/java/org/lineageos/platform/internal/LineageHardwareService.java
+++ b/lineage/lib/main/java/org/lineageos/platform/internal/LineageHardwareService.java
@@ -25,6 +25,8 @@ import android.os.UserHandle;
 import android.util.Log;
 import android.util.Range;
 
+import com.android.server.display.DisplayTransformManager;
+import com.android.server.LocalServices;
 import com.android.server.SystemService;
 
 import lineageos.app.LineageContextConstants;
@@ -54,6 +56,9 @@ import org.lineageos.hardware.TouchscreenGestures;
 import org.lineageos.hardware.TouchscreenHovering;
 import org.lineageos.hardware.VibratorHW;
 
+import static com.android.server.display.DisplayTransformManager.LEVEL_COLOR_MATRIX_NIGHT_DISPLAY;
+import static com.android.server.display.DisplayTransformManager.LEVEL_COLOR_MATRIX_GRAYSCALE;
+
 /** @hide */
 public class LineageHardwareService extends LineageSystemService {
 
@@ -98,9 +103,42 @@ public class LineageHardwareService extends LineageSystemService {
 
     private class LegacyLineageHardware implements LineageHardwareInterface {
 
+        private final int MIN = 0;
+        private final int MAX = 255;
+
+        /**
+         * Matrix and offset used for converting color to grayscale.
+         * Copied from com.android.server.accessibility.DisplayAdjustmentUtils.MATRIX_GRAYSCALE
+         */
+        private final float[] MATRIX_GRAYSCALE = {
+            .2126f, .2126f, .2126f, 0,
+            .7152f, .7152f, .7152f, 0,
+            .0722f, .0722f, .0722f, 0,
+                 0,      0,      0, 1
+        };
+
+        /** Full color matrix and offset */
+        private final float[] MATRIX_NORMAL = {
+            1, 0, 0, 0,
+            0, 1, 0, 0,
+            0, 0, 1, 0,
+            0, 0, 0, 1
+        };
+
+        private final int LEVEL_COLOR_MATRIX_CALIB = LEVEL_COLOR_MATRIX_NIGHT_DISPLAY + 1;
+        private final int LEVEL_COLOR_MATRIX_READING = LEVEL_COLOR_MATRIX_GRAYSCALE + 1;
+
+        private boolean mAcceleratedTransform;
+        private DisplayTransformManager mDTMService;
+
+        private int[] mCurColors = { MAX, MAX, MAX };
+        private boolean mReadingEnhancementEnabled;
+
         private int mSupportedFeatures = 0;
 
         public LegacyLineageHardware() {
+            mAcceleratedTransform = mContext.getResources().getBoolean(
+                    com.android.internal.R.bool.config_setColorTransformAccelerated);
             if (AdaptiveBacklight.isSupported())
                 mSupportedFeatures |= LineageHardwareManager.FEATURE_ADAPTIVE_BACKLIGHT;
             if (ColorEnhancement.isSupported())
@@ -129,6 +167,11 @@ public class LineageHardwareService extends LineageSystemService {
                 mSupportedFeatures |= LineageHardwareManager.FEATURE_PICTURE_ADJUSTMENT;
             if (TouchscreenGestures.isSupported())
                 mSupportedFeatures |= LineageHardwareManager.FEATURE_TOUCHSCREEN_GESTURES;
+            if (mAcceleratedTransform) {
+                mDTMService = LocalServices.getService(DisplayTransformManager.class);
+                mSupportedFeatures |= LineageHardwareManager.FEATURE_DISPLAY_COLOR_CALIBRATION;
+                mSupportedFeatures |= LineageHardwareManager.FEATURE_READING_ENHANCEMENT;
+            }
         }
 
         public int getSupportedFeatures() {
@@ -148,6 +191,8 @@ public class LineageHardwareService extends LineageSystemService {
                 case LineageHardwareManager.FEATURE_KEY_DISABLE:
                     return KeyDisabler.isActive();
                 case LineageHardwareManager.FEATURE_READING_ENHANCEMENT:
+                    if (mAcceleratedTransform)
+                        return mReadingEnhancementEnabled;
                     return ReadingEnhancement.isEnabled();
                 case LineageHardwareManager.FEATURE_SUNLIGHT_ENHANCEMENT:
                     return SunlightEnhancement.isEnabled();
@@ -172,6 +217,12 @@ public class LineageHardwareService extends LineageSystemService {
                 case LineageHardwareManager.FEATURE_KEY_DISABLE:
                     return KeyDisabler.setActive(enable);
                 case LineageHardwareManager.FEATURE_READING_ENHANCEMENT:
+                    if (mAcceleratedTransform) {
+                        mReadingEnhancementEnabled = enable;
+                        mDTMService.setColorMatrix(LEVEL_COLOR_MATRIX_READING,
+                                enable ? MATRIX_GRAYSCALE : MATRIX_NORMAL);
+                        return true;
+                    }
                     return ReadingEnhancement.setEnabled(enable);
                 case LineageHardwareManager.FEATURE_SUNLIGHT_ENHANCEMENT:
                     return SunlightEnhancement.setEnabled(enable);
@@ -210,24 +261,47 @@ public class LineageHardwareService extends LineageSystemService {
             return builder.toString();
         }
 
+        private float[] rgbToMatrix(int[] rgb) {
+            float[] mat = new float[16];
+
+            for (int i = 0; i < 3; i++) {
+                // Sanity check
+                if (rgb[i] > MAX)
+                    rgb[i] = MAX;
+                else if (rgb[i] < MIN)
+                    rgb[i] = MIN;
+
+                mat[i * 5] = (float)rgb[i] / (float)MAX;
+            }
+
+            mat[15] = 1.0f;
+            return mat;
+        }
+
         public int[] getDisplayColorCalibration() {
-            int[] rgb = splitStringToInt(DisplayColorCalibration.getCurColors(), " ");
+            int[] rgb = mAcceleratedTransform ? mCurColors :
+                    splitStringToInt(DisplayColorCalibration.getCurColors(), " ");
             if (rgb == null || rgb.length != 3) {
                 Log.e(TAG, "Invalid color calibration string");
                 return null;
             }
-            int[] currentCalibration = new int[6];
+            int[] currentCalibration = new int[5];
             currentCalibration[LineageHardwareManager.COLOR_CALIBRATION_RED_INDEX] = rgb[0];
             currentCalibration[LineageHardwareManager.COLOR_CALIBRATION_GREEN_INDEX] = rgb[1];
             currentCalibration[LineageHardwareManager.COLOR_CALIBRATION_BLUE_INDEX] = rgb[2];
             currentCalibration[LineageHardwareManager.COLOR_CALIBRATION_MIN_INDEX] =
-                DisplayColorCalibration.getMinValue();
+                mAcceleratedTransform ? MIN : DisplayColorCalibration.getMinValue();
             currentCalibration[LineageHardwareManager.COLOR_CALIBRATION_MAX_INDEX] =
-                DisplayColorCalibration.getMaxValue();
+                mAcceleratedTransform ? MAX : DisplayColorCalibration.getMaxValue();
             return currentCalibration;
         }
 
         public boolean setDisplayColorCalibration(int[] rgb) {
+            if (mAcceleratedTransform) {
+                mCurColors = rgb;
+                mDTMService.setColorMatrix(LEVEL_COLOR_MATRIX_CALIB, rgbToMatrix(rgb));
+                return true;
+            }
             return DisplayColorCalibration.setColors(rgbToString(rgb));
         }
 
-- 
2.17.1

