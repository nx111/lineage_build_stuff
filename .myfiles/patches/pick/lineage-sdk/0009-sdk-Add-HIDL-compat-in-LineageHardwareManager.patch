From 7448d83b8b8464f8f5fc48040b190e3c97520ee9 Mon Sep 17 00:00:00 2001
From: Paul Keith <javelinanddart@gmail.com>
Date: Fri, 18 Jan 2019 17:58:26 +0100
Subject: [PATCH 09/11] sdk: Add HIDL compat in LineageHardwareManager

* While we're at it, hide the use of getSupportedFeatures(),
  since it only works for lineagehw java features, not hidl
* Cleanup some minor styling/organization issues

Change-Id: I905010bc7c6d7d8578eeca501be23f665127aa27
---
 Android.bp                                    |  12 +-
 api/lineage_current.txt                       |   2 -
 .../internal/LineageHardwareService.java      |   4 +-
 .../java/lineageos/hardware/HIDLHelper.java   |  87 ++++
 .../hardware/LineageHardwareManager.java      | 464 ++++++++++++++++--
 5 files changed, 527 insertions(+), 42 deletions(-)
 create mode 100644 sdk/src/java/lineageos/hardware/HIDLHelper.java

diff --git a/Android.bp b/Android.bp
index 6fbd4da..a68b149 100644
--- a/Android.bp
+++ b/Android.bp
@@ -1,5 +1,5 @@
 //
-// Copyright (C) 2018 The LineageOS Project
+// Copyright (C) 2018-2019 The LineageOS Project
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -61,6 +61,11 @@ lineage_sdk_LOCAL_JAVA_LIBRARIES = [
     "android-support-v14-preference",
 ]
 
+lineage_sdk_LOCAL_STATIC_JAVA_LIBRARIES = [
+    "vendor.lineage.livedisplay-V2.0-java",
+    "vendor.lineage.touch-V1.0-java",
+]
+
 // READ ME: ########################################################
 //
 // When updating this list of aidl files, consider if that aidl is
@@ -74,7 +79,7 @@ lineage_sdk_LOCAL_JAVA_LIBRARIES = [
 
 java_library {
     name: "org.lineageos.platform",
-    static_libs: ["telephony-ext"],
+    static_libs: ["telephony-ext"] + lineage_sdk_LOCAL_STATIC_JAVA_LIBRARIES,
 
     libs: [
         "services",
@@ -101,7 +106,7 @@ java_library {
 java_library_static {
     name: "org.lineageos.platform.internal",
     required: ["services"],
-    static_libs: ["telephony-ext"],
+    static_libs: ["telephony-ext"] + lineage_sdk_LOCAL_STATIC_JAVA_LIBRARIES,
     libs: lineage_sdk_LOCAL_JAVA_LIBRARIES,
 
     srcs: [
@@ -125,6 +130,7 @@ java_library_static {
     name: "org.lineageos.platform.sdk",
     required: ["services"],
     libs: lineage_sdk_LOCAL_JAVA_LIBRARIES,
+    static_libs: lineage_sdk_LOCAL_STATIC_JAVA_LIBRARIES,
 
     srcs: [
         lineage_sdk_src + "/**/*.java",
diff --git a/api/lineage_current.txt b/api/lineage_current.txt
index a92dea8..ec3212f 100644
--- a/api/lineage_current.txt
+++ b/api/lineage_current.txt
@@ -182,14 +182,12 @@ package lineageos.hardware {
     method public lineageos.hardware.DisplayMode getDefaultDisplayMode();
     method public lineageos.hardware.HSIC getDefaultPictureAdjustment();
     method public int[] getDisplayColorCalibration();
-    method public int getDisplayColorCalibrationDefault();
     method public int getDisplayColorCalibrationMax();
     method public int getDisplayColorCalibrationMin();
     method public lineageos.hardware.DisplayMode[] getDisplayModes();
     method public static lineageos.hardware.LineageHardwareManager getInstance(android.content.Context);
     method public lineageos.hardware.HSIC getPictureAdjustment();
     method public java.util.List<android.util.Range<java.lang.Float>> getPictureAdjustmentRanges();
-    method public int getSupportedFeatures();
     method public lineageos.hardware.TouchscreenGesture[] getTouchscreenGestures();
     method public int getVibratorDefaultIntensity();
     method public int getVibratorIntensity();
diff --git a/lineage/lib/main/java/org/lineageos/platform/internal/LineageHardwareService.java b/lineage/lib/main/java/org/lineageos/platform/internal/LineageHardwareService.java
index c1e0aeb..f856d7e 100644
--- a/lineage/lib/main/java/org/lineageos/platform/internal/LineageHardwareService.java
+++ b/lineage/lib/main/java/org/lineageos/platform/internal/LineageHardwareService.java
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2015-2016 The CyanogenMod Project
- *               2017-2018 The LineageOS Project
+ *               2017-2019 The LineageOS Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -225,8 +225,6 @@ public class LineageHardwareService extends LineageSystemService {
             currentCalibration[LineageHardwareManager.COLOR_CALIBRATION_RED_INDEX] = rgb[0];
             currentCalibration[LineageHardwareManager.COLOR_CALIBRATION_GREEN_INDEX] = rgb[1];
             currentCalibration[LineageHardwareManager.COLOR_CALIBRATION_BLUE_INDEX] = rgb[2];
-            currentCalibration[LineageHardwareManager.COLOR_CALIBRATION_DEFAULT_INDEX] =
-                DisplayColorCalibration.getDefValue();
             currentCalibration[LineageHardwareManager.COLOR_CALIBRATION_MIN_INDEX] =
                 DisplayColorCalibration.getMinValue();
             currentCalibration[LineageHardwareManager.COLOR_CALIBRATION_MAX_INDEX] =
diff --git a/sdk/src/java/lineageos/hardware/HIDLHelper.java b/sdk/src/java/lineageos/hardware/HIDLHelper.java
new file mode 100644
index 0000000..6ca202c
--- /dev/null
+++ b/sdk/src/java/lineageos/hardware/HIDLHelper.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2019 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package lineageos.hardware;
+
+import android.util.Range;
+
+import lineageos.hardware.DisplayMode;
+import lineageos.hardware.HSIC;
+import lineageos.hardware.TouchscreenGesture;
+
+import java.util.ArrayList;
+
+class HIDLHelper {
+
+    public static DisplayMode[] fromHIDLModes(
+            ArrayList<vendor.lineage.livedisplay.V2_0.DisplayMode> modes) {
+        int size = modes.size();
+        DisplayMode[] r = new DisplayMode[size];
+        for (int i = 0; i < size; i++) {
+            vendor.lineage.livedisplay.V2_0.DisplayMode m = modes.get(i);
+            r[i] = new DisplayMode(m.id, m.name);
+        }
+        return r;
+    }
+
+    public static DisplayMode fromHIDLMode(
+            vendor.lineage.livedisplay.V2_0.DisplayMode mode) {
+        return new DisplayMode(mode.id, mode.name);
+    }
+
+    public static HSIC fromHIDLHSIC(vendor.lineage.livedisplay.V2_0.HSIC hsic) {
+        return new HSIC(hsic.hue, hsic.saturation, hsic.intensity,
+                hsic.contrast, hsic.saturationThreshold);
+    }
+
+    public static vendor.lineage.livedisplay.V2_0.HSIC toHIDLHSIC(HSIC hsic) {
+        vendor.lineage.livedisplay.V2_0.HSIC h = new vendor.lineage.livedisplay.V2_0.HSIC();
+        h.hue = hsic.getHue();
+        h.saturation = hsic.getSaturation();
+        h.intensity = hsic.getIntensity();
+        h.contrast = hsic.getContrast();
+        h.saturationThreshold = hsic.getSaturationThreshold();
+        return h;
+    }
+
+    public static Range<Integer> fromHIDLRange(vendor.lineage.livedisplay.V2_0.Range range) {
+        return new Range(range.min, range.max);
+    }
+
+    public static Range<Float> fromHIDLRange(vendor.lineage.livedisplay.V2_0.FloatRange range) {
+        return new Range(range.min, range.max);
+    }
+
+    public static TouchscreenGesture[] fromHIDLGestures(
+            ArrayList<vendor.lineage.touch.V1_0.Gesture> gestures) {
+        int size = gestures.size();
+        TouchscreenGesture[] r = new TouchscreenGesture[size];
+        for (int i = 0; i < size; i++) {
+            vendor.lineage.touch.V1_0.Gesture g = gestures.get(i);
+            r[i] = new TouchscreenGesture(g.id, g.name, g.keycode);
+        }
+        return r;
+    }
+
+    public static vendor.lineage.touch.V1_0.Gesture toHIDLGesture(TouchscreenGesture gesture) {
+        vendor.lineage.touch.V1_0.Gesture g = new vendor.lineage.touch.V1_0.Gesture();
+        g.id = gesture.id;
+        g.name = gesture.name;
+        g.keycode = gesture.keycode;
+        return g;
+    }
+
+}
diff --git a/sdk/src/java/lineageos/hardware/LineageHardwareManager.java b/sdk/src/java/lineageos/hardware/LineageHardwareManager.java
index c09dbec..313a9f1 100644
--- a/sdk/src/java/lineageos/hardware/LineageHardwareManager.java
+++ b/sdk/src/java/lineageos/hardware/LineageHardwareManager.java
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2015-2016 The CyanogenMod Project
- *               2017-2018 The LineageOS Project
+ *               2017-2019 The LineageOS Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,6 +17,7 @@
 package lineageos.hardware;
 
 import android.content.Context;
+import android.hidl.base.V1_0.IBase;
 import android.os.IBinder;
 import android.os.RemoteException;
 import android.os.ServiceManager;
@@ -25,15 +26,37 @@ import android.util.Range;
 
 import com.android.internal.annotations.VisibleForTesting;
 
+import com.android.internal.util.ArrayUtils;
+
 import lineageos.app.LineageContextConstants;
+import lineageos.hardware.DisplayMode;
+import lineageos.hardware.HIDLHelper;
 import lineageos.hardware.HSIC;
+import lineageos.hardware.TouchscreenGesture;
+
+import vendor.lineage.livedisplay.V2_0.IAdaptiveBacklight;
+import vendor.lineage.livedisplay.V2_0.IAutoContrast;
+import vendor.lineage.livedisplay.V2_0.IColorBalance;
+import vendor.lineage.livedisplay.V2_0.IColorEnhancement;
+import vendor.lineage.livedisplay.V2_0.IDisplayColorCalibration;
+import vendor.lineage.livedisplay.V2_0.IDisplayModes;
+import vendor.lineage.livedisplay.V2_0.IPictureAdjustment;
+import vendor.lineage.livedisplay.V2_0.IReadingEnhancement;
+import vendor.lineage.livedisplay.V2_0.ISunlightEnhancement;
+import vendor.lineage.touch.V1_0.IGloveMode;
+import vendor.lineage.touch.V1_0.IKeyDisabler;
+import vendor.lineage.touch.V1_0.IStylusMode;
+import vendor.lineage.touch.V1_0.ITouchscreenGesture;
 
 import java.io.UnsupportedEncodingException;
 import java.lang.IllegalArgumentException;
 import java.lang.reflect.Field;
 import java.nio.ByteBuffer;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.HashMap;
 import java.util.List;
+import java.util.NoSuchElementException;
 
 /**
  * Manages access to LineageOS hardware extensions
@@ -46,14 +69,9 @@ import java.util.List;
 public final class LineageHardwareManager {
     private static final String TAG = "LineageHardwareManager";
 
-    private static ILineageHardwareService sService;
-
-    private Context mContext;
-
-    /* The VisibleForTesting annotation is to ensure Proguard doesn't remove these
-     * fields, as they might be used via reflection. When the @Keep annotation in
-     * the support library is properly handled in the platform, we should change this.
-     */
+    // The VisibleForTesting annotation is to ensure Proguard doesn't remove these
+    // fields, as they might be used via reflection. When the @Keep annotation in
+    // the support library is properly handled in the platform, we should change this.
 
     /**
      * Adaptive backlight support (this refers to technologies like NVIDIA SmartDimmer,
@@ -151,8 +169,14 @@ public final class LineageHardwareManager {
         FEATURE_READING_ENHANCEMENT
     );
 
+    private static ILineageHardwareService sService;
     private static LineageHardwareManager sLineageHardwareManagerInstance;
 
+    private Context mContext;
+
+    // HIDL hals
+    private HashMap<Integer, IBase> mHIDLMap;
+
     /**
      * @hide to prevent subclassing from outside of the framework
      */
@@ -171,6 +195,75 @@ public final class LineageHardwareManager {
                     " crashed, was not started, or the interface has been called to early in" +
                     " SystemServer init");
         }
+
+        mHIDLMap = new HashMap<Integer, IBase>();
+
+        try {
+            IAdaptiveBacklight adaptiveBacklight = IAdaptiveBacklight.getService(true);
+            mHIDLMap.put(FEATURE_ADAPTIVE_BACKLIGHT, adaptiveBacklight);
+        } catch (NoSuchElementException | RemoteException e) {
+        }
+        try {
+            IAutoContrast autoContrast = IAutoContrast.getService(true);
+            mHIDLMap.put(FEATURE_AUTO_CONTRAST, autoContrast);
+        } catch (NoSuchElementException | RemoteException e) {
+        }
+        try {
+            IColorBalance colorBalance = IColorBalance.getService(true);
+            mHIDLMap.put(FEATURE_COLOR_BALANCE, colorBalance);
+        } catch (NoSuchElementException | RemoteException e) {
+        }
+        try {
+            IColorEnhancement colorEnhancement = IColorEnhancement.getService(true);
+            mHIDLMap.put(FEATURE_COLOR_ENHANCEMENT, colorEnhancement);
+        } catch (NoSuchElementException | RemoteException e) {
+        }
+        try {
+            IDisplayColorCalibration displayColorCalibration =
+                    IDisplayColorCalibration.getService(true);
+            mHIDLMap.put(FEATURE_DISPLAY_COLOR_CALIBRATION, displayColorCalibration);
+        } catch (NoSuchElementException | RemoteException e) {
+        }
+        try {
+            IDisplayModes displayModes = IDisplayModes.getService(true);
+            mHIDLMap.put(FEATURE_DISPLAY_MODES, displayModes);
+        } catch (NoSuchElementException | RemoteException e) {
+        }
+        try {
+            IPictureAdjustment pictureAdjustment = IPictureAdjustment.getService(true);
+            mHIDLMap.put(FEATURE_PICTURE_ADJUSTMENT, pictureAdjustment);
+        } catch (NoSuchElementException | RemoteException e) {
+        }
+        try {
+            IReadingEnhancement readingEnhancement = IReadingEnhancement.getService(true);
+            mHIDLMap.put(FEATURE_READING_ENHANCEMENT, readingEnhancement);
+        } catch (NoSuchElementException | RemoteException e) {
+        }
+        try {
+            ISunlightEnhancement sunlightEnhancement = ISunlightEnhancement.getService(true);
+            mHIDLMap.put(FEATURE_SUNLIGHT_ENHANCEMENT, sunlightEnhancement);
+        } catch (NoSuchElementException | RemoteException e) {
+        }
+        try {
+            IGloveMode gloveMode = IGloveMode.getService(true);
+            mHIDLMap.put(FEATURE_HIGH_TOUCH_SENSITIVITY, gloveMode);
+        } catch (NoSuchElementException | RemoteException e) {
+        }
+        try {
+            IKeyDisabler keyDisabler = IKeyDisabler.getService(true);
+            mHIDLMap.put(FEATURE_KEY_DISABLE, keyDisabler);
+        } catch (NoSuchElementException | RemoteException e) {
+        }
+        try {
+            IStylusMode stylusMode = IStylusMode.getService(true);
+            mHIDLMap.put(FEATURE_TOUCH_HOVERING, stylusMode);
+        } catch (NoSuchElementException | RemoteException e) {
+        }
+        try {
+            ITouchscreenGesture touchscreenGesture = ITouchscreenGesture.getService(true);
+            mHIDLMap.put(FEATURE_TOUCHSCREEN_GESTURES, touchscreenGesture);
+        } catch (NoSuchElementException | RemoteException e) {
+        }
     }
 
     /**
@@ -179,6 +272,8 @@ public final class LineageHardwareManager {
      * @return {@link LineageHardwareManager}
      */
     public static LineageHardwareManager getInstance(Context context) {
+        context.enforceCallingOrSelfPermission(
+                lineageos.platform.Manifest.permission.HARDWARE_ABSTRACTION_ACCESS, null);
         if (sLineageHardwareManagerInstance == null) {
             sLineageHardwareManagerInstance = new LineageHardwareManager(context);
         }
@@ -200,6 +295,7 @@ public final class LineageHardwareManager {
 
     /**
      * @return the supported features bitmask
+     * @hide
      */
     public int getSupportedFeatures() {
         try {
@@ -219,6 +315,14 @@ public final class LineageHardwareManager {
      * @return true if the feature is supported, false otherwise.
      */
     public boolean isSupported(int feature) {
+        return isSupportedHIDL(feature) || isSupportedLegacy(feature);
+    }
+
+    private boolean isSupportedHIDL(int feature) {
+        return mHIDLMap.containsKey(feature);
+    }
+
+    private boolean isSupportedLegacy(int feature) {
         return feature == (getSupportedFeatures() & feature);
     }
 
@@ -256,6 +360,68 @@ public final class LineageHardwareManager {
             throw new IllegalArgumentException(feature + " is not a boolean");
         }
 
+        if (isSupportedHIDL(feature)) {
+            IBase obj = mHIDLMap.get(feature);
+            switch (feature) {
+                case FEATURE_ADAPTIVE_BACKLIGHT:
+                    IAdaptiveBacklight adaptiveBacklight = (IAdaptiveBacklight) obj;
+                    try {
+                        return adaptiveBacklight.isEnabled();
+                    } catch (RemoteException e) {
+                        return false;
+                    }
+                case FEATURE_AUTO_CONTRAST:
+                    IAutoContrast autoContrast = (IAutoContrast) obj;
+                    try {
+                        return autoContrast.isEnabled();
+                    } catch (RemoteException e) {
+                        return false;
+                    }
+               case FEATURE_COLOR_ENHANCEMENT:
+                    IColorEnhancement colorEnhancement = (IColorEnhancement) obj;
+                    try {
+                        return colorEnhancement.isEnabled();
+                    } catch (RemoteException e) {
+                        return false;
+                    }
+               case FEATURE_HIGH_TOUCH_SENSITIVITY:
+                    IGloveMode gloveMode = (IGloveMode) obj;
+                    try {
+                        return gloveMode.isEnabled();
+                    } catch (RemoteException e) {
+                        return false;
+                    }
+               case FEATURE_KEY_DISABLE:
+                    IKeyDisabler keyDisabler = (IKeyDisabler) obj;
+                    try {
+                        return keyDisabler.isEnabled();
+                    } catch (RemoteException e) {
+                        return false;
+                    }
+               case FEATURE_SUNLIGHT_ENHANCEMENT:
+                    ISunlightEnhancement sunlightEnhancement = (ISunlightEnhancement) obj;
+                    try {
+                        return sunlightEnhancement.isEnabled();
+                    } catch (RemoteException e) {
+                        return false;
+                    }
+               case FEATURE_TOUCH_HOVERING:
+                    IStylusMode stylusMode = (IStylusMode) obj;
+                    try {
+                        return stylusMode.isEnabled();
+                    } catch (RemoteException e) {
+                        return false;
+                    }
+               case FEATURE_READING_ENHANCEMENT:
+                    IReadingEnhancement readingEnhancement = (IReadingEnhancement) obj;
+                    try {
+                        return readingEnhancement.isEnabled();
+                    } catch (RemoteException e) {
+                        return false;
+                    }
+            }
+        }
+
         try {
             if (checkService()) {
                 return sService.get(feature);
@@ -280,6 +446,68 @@ public final class LineageHardwareManager {
             throw new IllegalArgumentException(feature + " is not a boolean");
         }
 
+        if (isSupportedHIDL(feature)) {
+            IBase obj = mHIDLMap.get(feature);
+            switch (feature) {
+                case FEATURE_ADAPTIVE_BACKLIGHT:
+                    IAdaptiveBacklight adaptiveBacklight = (IAdaptiveBacklight) obj;
+                    try {
+                        return adaptiveBacklight.setEnabled(enable);
+                    } catch (RemoteException e) {
+                        return false;
+                    }
+                case FEATURE_AUTO_CONTRAST:
+                    IAutoContrast autoContrast = (IAutoContrast) obj;
+                    try {
+                        return autoContrast.setEnabled(enable);
+                    } catch (RemoteException e) {
+                        return false;
+                    }
+               case FEATURE_COLOR_ENHANCEMENT:
+                    IColorEnhancement colorEnhancement = (IColorEnhancement) obj;
+                    try {
+                        return colorEnhancement.setEnabled(enable);
+                    } catch (RemoteException e) {
+                        return false;
+                    }
+               case FEATURE_HIGH_TOUCH_SENSITIVITY:
+                    IGloveMode gloveMode = (IGloveMode) obj;
+                    try {
+                        return gloveMode.setEnabled(enable);
+                    } catch (RemoteException e) {
+                        return false;
+                    }
+               case FEATURE_KEY_DISABLE:
+                    IKeyDisabler keyDisabler = (IKeyDisabler) obj;
+                    try {
+                        return keyDisabler.setEnabled(enable);
+                    } catch (RemoteException e) {
+                        return false;
+                    }
+               case FEATURE_SUNLIGHT_ENHANCEMENT:
+                    ISunlightEnhancement sunlightEnhancement = (ISunlightEnhancement) obj;
+                    try {
+                        return sunlightEnhancement.setEnabled(enable);
+                    } catch (RemoteException e) {
+                        return false;
+                    }
+               case FEATURE_TOUCH_HOVERING:
+                    IStylusMode stylusMode = (IStylusMode) obj;
+                    try {
+                        return stylusMode.setEnabled(enable);
+                    } catch (RemoteException e) {
+                        return false;
+                    }
+               case FEATURE_READING_ENHANCEMENT:
+                    IReadingEnhancement readingEnhancement = (IReadingEnhancement) obj;
+                    try {
+                        return readingEnhancement.setEnabled(enable);
+                    } catch (RemoteException e) {
+                        return false;
+                    }
+            }
+        }
+
         try {
             if (checkService()) {
                 return sService.set(feature, enable);
@@ -396,17 +624,23 @@ public final class LineageHardwareManager {
     /**
      * {@hide}
      */
-    public static final int COLOR_CALIBRATION_DEFAULT_INDEX = 3;
-    /**
-     * {@hide}
-     */
-    public static final int COLOR_CALIBRATION_MIN_INDEX = 4;
+    public static final int COLOR_CALIBRATION_MIN_INDEX = 3;
     /**
      * {@hide}
      */
-    public static final int COLOR_CALIBRATION_MAX_INDEX = 5;
+    public static final int COLOR_CALIBRATION_MAX_INDEX = 4;
 
     private int[] getDisplayColorCalibrationArray() {
+        if (isSupportedHIDL(FEATURE_DISPLAY_COLOR_CALIBRATION)) {
+            IDisplayColorCalibration displayColorCalibration = (IDisplayColorCalibration)
+                    mHIDLMap.get(FEATURE_DISPLAY_COLOR_CALIBRATION);
+            try {
+                return ArrayUtils.convertToIntArray(displayColorCalibration.getCalibration());
+            } catch (RemoteException e) {
+                return null;
+            }
+        }
+
         try {
             if (checkService()) {
                 return sService.getDisplayColorCalibration();
@@ -427,24 +661,37 @@ public final class LineageHardwareManager {
         return Arrays.copyOf(arr, 3);
     }
 
-    /**
-     * @return the default value for all colors
-     */
-    public int getDisplayColorCalibrationDefault() {
-        return getArrayValue(getDisplayColorCalibrationArray(), COLOR_CALIBRATION_DEFAULT_INDEX, 0);
-    }
-
     /**
      * @return The minimum value for all colors
      */
     public int getDisplayColorCalibrationMin() {
+        if (isSupportedHIDL(FEATURE_DISPLAY_COLOR_CALIBRATION)) {
+            IDisplayColorCalibration displayColorCalibration = (IDisplayColorCalibration)
+                    mHIDLMap.get(FEATURE_DISPLAY_COLOR_CALIBRATION);
+            try {
+                return displayColorCalibration.getMinValue();
+            } catch (RemoteException e) {
+                return 0;
+            }
+        }
+
         return getArrayValue(getDisplayColorCalibrationArray(), COLOR_CALIBRATION_MIN_INDEX, 0);
     }
 
     /**
-     * @return The minimum value for all colors
+     * @return The maximum value for all colors
      */
     public int getDisplayColorCalibrationMax() {
+        if (isSupportedHIDL(FEATURE_DISPLAY_COLOR_CALIBRATION)) {
+            IDisplayColorCalibration displayColorCalibration = (IDisplayColorCalibration)
+                    mHIDLMap.get(FEATURE_DISPLAY_COLOR_CALIBRATION);
+            try {
+                return displayColorCalibration.getMaxValue();
+            } catch (RemoteException e) {
+                return 0;
+            }
+        }
+
         return getArrayValue(getDisplayColorCalibrationArray(), COLOR_CALIBRATION_MAX_INDEX, 0);
     }
 
@@ -458,6 +705,17 @@ public final class LineageHardwareManager {
      * @return true on success, false otherwise.
      */
     public boolean setDisplayColorCalibration(int[] rgb) {
+        if (isSupportedHIDL(FEATURE_DISPLAY_COLOR_CALIBRATION)) {
+            IDisplayColorCalibration displayColorCalibration = (IDisplayColorCalibration)
+                    mHIDLMap.get(FEATURE_DISPLAY_COLOR_CALIBRATION);
+            try {
+                return displayColorCalibration.setCalibration(
+                       new ArrayList<Integer>(Arrays.asList(rgb[0], rgb[1], rgb[2])));
+            } catch (RemoteException e) {
+                return false;
+            }
+        }
+
         try {
             if (checkService()) {
                 return sService.setDisplayColorCalibration(rgb);
@@ -472,6 +730,10 @@ public final class LineageHardwareManager {
      * is enabled.
      */
     public boolean requireAdaptiveBacklightForSunlightEnhancement() {
+        if (isSupportedHIDL(FEATURE_SUNLIGHT_ENHANCEMENT)) {
+            return false;
+        }
+
         try {
             if (checkService()) {
                 return sService.requireAdaptiveBacklightForSunlightEnhancement();
@@ -485,6 +747,10 @@ public final class LineageHardwareManager {
      * @return true if this implementation does it's own lux metering
      */
     public boolean isSunlightEnhancementSelfManaged() {
+        if (isSupportedHIDL(FEATURE_SUNLIGHT_ENHANCEMENT)) {
+            return false;
+        }
+
         try {
             if (checkService()) {
                 return sService.isSunlightEnhancementSelfManaged();
@@ -498,6 +764,15 @@ public final class LineageHardwareManager {
      * @return a list of available display modes on the devices
      */
     public DisplayMode[] getDisplayModes() {
+        if (isSupportedHIDL(FEATURE_DISPLAY_MODES)) {
+            IDisplayModes displayModes = (IDisplayModes) mHIDLMap.get(FEATURE_DISPLAY_MODES);
+            try {
+                return HIDLHelper.fromHIDLModes(displayModes.getDisplayModes());
+            } catch (RemoteException e) {
+                return null;
+            }
+        }
+
         try {
             if (checkService()) {
                 return sService.getDisplayModes();
@@ -511,6 +786,15 @@ public final class LineageHardwareManager {
      * @return the currently active display mode
      */
     public DisplayMode getCurrentDisplayMode() {
+        if (isSupportedHIDL(FEATURE_DISPLAY_MODES)) {
+            IDisplayModes displayModes = (IDisplayModes) mHIDLMap.get(FEATURE_DISPLAY_MODES);
+            try {
+                return HIDLHelper.fromHIDLMode(displayModes.getCurrentDisplayMode());
+            } catch (RemoteException e) {
+                return null;
+            }
+        }
+
         try {
             if (checkService()) {
                 return sService.getCurrentDisplayMode();
@@ -524,6 +808,15 @@ public final class LineageHardwareManager {
      * @return the default display mode to be set on boot
      */
     public DisplayMode getDefaultDisplayMode() {
+        if (isSupportedHIDL(FEATURE_DISPLAY_MODES)) {
+            IDisplayModes displayModes = (IDisplayModes) mHIDLMap.get(FEATURE_DISPLAY_MODES);
+            try {
+                return HIDLHelper.fromHIDLMode(displayModes.getDefaultDisplayMode());
+            } catch (RemoteException e) {
+                return null;
+            }
+        }
+
         try {
             if (checkService()) {
                 return sService.getDefaultDisplayMode();
@@ -537,6 +830,15 @@ public final class LineageHardwareManager {
      * @return true if setting the mode was successful
      */
     public boolean setDisplayMode(DisplayMode mode, boolean makeDefault) {
+        if (isSupportedHIDL(FEATURE_DISPLAY_MODES)) {
+            IDisplayModes displayModes = (IDisplayModes) mHIDLMap.get(FEATURE_DISPLAY_MODES);
+            try {
+                return displayModes.setDisplayMode(mode.id, makeDefault);
+            } catch (RemoteException e) {
+                return false;
+            }
+        }
+
         try {
             if (checkService()) {
                 return sService.setDisplayMode(mode, makeDefault);
@@ -550,6 +852,15 @@ public final class LineageHardwareManager {
      * @return the available range for color temperature adjustments
      */
     public Range<Integer> getColorBalanceRange() {
+        if (isSupportedHIDL(FEATURE_COLOR_BALANCE)) {
+            IColorBalance colorBalance = (IColorBalance) mHIDLMap.get(FEATURE_COLOR_BALANCE);
+            try {
+                return HIDLHelper.fromHIDLRange(colorBalance.getColorBalanceRange());
+            } catch (RemoteException e) {
+                return new Range<Integer>(0, 0);
+            }
+        }
+
         int min = 0;
         int max = 0;
         try {
@@ -566,6 +877,15 @@ public final class LineageHardwareManager {
      * @return the current color balance value
      */
     public int getColorBalance() {
+        if (isSupportedHIDL(FEATURE_COLOR_BALANCE)) {
+            IColorBalance colorBalance = (IColorBalance) mHIDLMap.get(FEATURE_COLOR_BALANCE);
+            try {
+                return colorBalance.getColorBalance();
+            } catch (RemoteException e) {
+                return 0;
+            }
+        }
+
         try {
             if (checkService()) {
                 return sService.getColorBalance();
@@ -583,6 +903,15 @@ public final class LineageHardwareManager {
      * @return true if success
      */
     public boolean setColorBalance(int value) {
+        if (isSupportedHIDL(FEATURE_COLOR_BALANCE)) {
+            IColorBalance colorBalance = (IColorBalance) mHIDLMap.get(FEATURE_COLOR_BALANCE);
+            try {
+                return colorBalance.setColorBalance(value);
+            } catch (RemoteException e) {
+                return false;
+            }
+        }
+
         try {
             if (checkService()) {
                 return sService.setColorBalance(value);
@@ -598,6 +927,16 @@ public final class LineageHardwareManager {
      * @return HSIC object with current settings
      */
     public HSIC getPictureAdjustment() {
+        if (isSupportedHIDL(FEATURE_PICTURE_ADJUSTMENT)) {
+            IPictureAdjustment pictureAdjustment = (IPictureAdjustment)
+                    mHIDLMap.get(FEATURE_PICTURE_ADJUSTMENT);
+            try {
+                return HIDLHelper.fromHIDLHSIC(pictureAdjustment.getPictureAdjustment());
+            } catch (RemoteException e) {
+                return null;
+            }
+        }
+
         try {
             if (checkService()) {
                 return sService.getPictureAdjustment();
@@ -613,6 +952,16 @@ public final class LineageHardwareManager {
      * @return HSIC object with default settings
      */
     public HSIC getDefaultPictureAdjustment() {
+        if (isSupportedHIDL(FEATURE_PICTURE_ADJUSTMENT)) {
+            IPictureAdjustment pictureAdjustment = (IPictureAdjustment)
+                    mHIDLMap.get(FEATURE_PICTURE_ADJUSTMENT);
+            try {
+                return HIDLHelper.fromHIDLHSIC(pictureAdjustment.getDefaultPictureAdjustment());
+            } catch (RemoteException e) {
+                return null;
+            }
+        }
+
         try {
             if (checkService()) {
                 return sService.getDefaultPictureAdjustment();
@@ -629,6 +978,16 @@ public final class LineageHardwareManager {
      * @return true if success
      */
     public boolean setPictureAdjustment(final HSIC hsic) {
+        if (isSupportedHIDL(FEATURE_PICTURE_ADJUSTMENT)) {
+            IPictureAdjustment pictureAdjustment = (IPictureAdjustment)
+                    mHIDLMap.get(FEATURE_PICTURE_ADJUSTMENT);
+            try {
+                return pictureAdjustment.setPictureAdjustment(HIDLHelper.toHIDLHSIC(hsic));
+            } catch (RemoteException e) {
+                return false;
+            }
+        }
+
         try {
             if (checkService()) {
                 return sService.setPictureAdjustment(hsic);
@@ -644,6 +1003,21 @@ public final class LineageHardwareManager {
      * @return range list
      */
     public List<Range<Float>> getPictureAdjustmentRanges() {
+        if (isSupportedHIDL(FEATURE_PICTURE_ADJUSTMENT)) {
+            IPictureAdjustment pictureAdjustment = (IPictureAdjustment)
+                    mHIDLMap.get(FEATURE_PICTURE_ADJUSTMENT);
+            try {
+                return Arrays.asList(
+                        HIDLHelper.fromHIDLRange(pictureAdjustment.getHueRange()),
+                        HIDLHelper.fromHIDLRange(pictureAdjustment.getSaturationRange()),
+                        HIDLHelper.fromHIDLRange(pictureAdjustment.getIntensityRange()),
+                        HIDLHelper.fromHIDLRange(pictureAdjustment.getContrastRange()),
+                        HIDLHelper.fromHIDLRange(pictureAdjustment.getSaturationThresholdRange()));
+            } catch (RemoteException e) {
+                return null;
+            }
+        }
+
         try {
             if (checkService()) {
                 float[] ranges = sService.getPictureAdjustmentRanges();
@@ -662,21 +1036,20 @@ public final class LineageHardwareManager {
         return null;
     }
 
-    /**
-     * @return true if service is valid
-     */
-    private boolean checkService() {
-        if (sService == null) {
-            Log.w(TAG, "not connected to LineageHardwareManagerService");
-            return false;
-        }
-        return true;
-    }
-
     /**
      * @return a list of available touchscreen gestures on the devices
      */
     public TouchscreenGesture[] getTouchscreenGestures() {
+        if (isSupportedHIDL(FEATURE_TOUCHSCREEN_GESTURES)) {
+            ITouchscreenGesture touchscreenGesture = (ITouchscreenGesture)
+                    mHIDLMap.get(FEATURE_TOUCHSCREEN_GESTURES);
+            try {
+                return HIDLHelper.fromHIDLGestures(touchscreenGesture.getSupportedGestures());
+            } catch (RemoteException e){
+                return null;
+            }
+        }
+
         try {
             if (checkService()) {
                 return sService.getTouchscreenGestures();
@@ -691,6 +1064,17 @@ public final class LineageHardwareManager {
      */
     public boolean setTouchscreenGestureEnabled(
             TouchscreenGesture gesture, boolean state) {
+        if (isSupportedHIDL(FEATURE_TOUCHSCREEN_GESTURES)) {
+            ITouchscreenGesture touchscreenGesture = (ITouchscreenGesture)
+                    mHIDLMap.get(FEATURE_TOUCHSCREEN_GESTURES);
+            try {
+                return touchscreenGesture.setGestureEnabled(
+                        HIDLHelper.toHIDLGesture(gesture), state);
+            } catch (RemoteException e){
+                return false;
+            }
+        }
+
         try {
             if (checkService()) {
                 return sService.setTouchscreenGestureEnabled(gesture, state);
@@ -699,4 +1083,16 @@ public final class LineageHardwareManager {
         }
         return false;
     }
+
+    /**
+     * @return true if service is valid
+     */
+    private boolean checkService() {
+        if (sService == null) {
+            Log.w(TAG, "not connected to LineageHardwareManagerService");
+            return false;
+        }
+        return true;
+    }
+
 }
-- 
2.17.1

