From d5c1f50192b214ef9b0e074402d0b1d1603cfe6b Mon Sep 17 00:00:00 2001
From: Luca Stefani <luca.stefani.ge1@gmail.com>
Date: Tue, 5 Feb 2019 09:44:41 +0100
Subject: [PATCH 4/4] Squash of
 github/lineage-16.0(8f9050344)..lineage-16.0-android-9.0.0_r31(fcb8875a0) (DO
 NOT SUBMIT)

Ajay Panicker (1):
 - AVRCP: Change notification variable when the interim response is sent

Android Build Merger (Role) (48):
 - [automerger] DO NOT MERGE - Check data length when parsing AVRCP
   vendor specific command responses am: 8148397ca2
 - [automerger] DO NOT MERGE - Check data length when parsing AVRCP
   vendor specific command responses am: 8148397ca2 am: 1f7ced7d2f
 - [automerger] DO NOT MERGE - Check data length when parsing AVRCP
   vendor specific command responses am: 8148397ca2 am: 1f7ced7d2f am:
   33b88d2e2f
 - [automerger] DO NOT MERGE - Check data length when parsing AVRCP
   vendor specific command responses am: 8148397ca2 am: 1f7ced7d2f am:
   33b88d2e2f am: 81bfd4b649
 - [automerger] DO NOT MERGE - Check data length when parsing AVRCP
   vendor specific command responses am: 8148397ca2 am: 1f7ced7d2f am:
   33b88d2e2f am: 81bfd4b649 skipped: 06c4724c91
 - [automerger] DO NOT MERGE - Check AVRCP data length when parsing
   inside avrc_ctrl_pars_vendor_rsp() am: b4cf8416bf
 - [automerger] DO NOT MERGE - Check AVRCP data length when parsing
   inside avrc_ctrl_pars_vendor_rsp() am: b4cf8416bf am: c0e2026eb1
 - [automerger] DO NOT MERGE - Check AVRCP data length when parsing
   inside avrc_ctrl_pars_vendor_rsp() am: b4cf8416bf am: c0e2026eb1 am:
   eb2615a683
 - [automerger] DO NOT MERGE - Check AVRCP data length when parsing
   inside avrc_ctrl_pars_vendor_rsp() am: b4cf8416bf am: c0e2026eb1 am:
   eb2615a683 am: 38a6087b6a
 - [automerger] DO NOT MERGE - Check AVRCP data length when parsing
   inside avrc_ctrl_pars_vendor_rsp() am: b4cf8416bf am: c0e2026eb1 am:
   eb2615a683 am: 38a6087b6a skipped: df71e4a376
 - [automerger] DO NOT MERGE - Check SDU lower bound before allocate
   p_data am: 87bcda81b8
 - [automerger] DO NOT MERGE - Check SDU lower bound before allocate
   p_data am: 87bcda81b8 am: 8e31e9abb4
 - [automerger] DO NOT MERGE - Check SDU lower bound before allocate
   p_data am: 87bcda81b8 am: 8e31e9abb4 am: e51a7b9760
 - [automerger] DO NOT MERGE - Check SDU lower bound before allocate
   p_data am: 87bcda81b8 am: 8e31e9abb4 am: e51a7b9760 am: 90248f8fb3
 - [automerger] DO NOT MERGE - Check SDU lower bound before allocate
   p_data am: 87bcda81b8 am: 8e31e9abb4 am: e51a7b9760 am: 90248f8fb3
   skipped: b3bef4683a
 - [automerger] Fix possible OOB read in process_service_search_rsp am:
   b6fa6e4fff
 - [automerger] Fix possible OOB read in process_service_search_rsp am:
   b6fa6e4fff am: 8c06d18eea
 - [automerger] Fix possible OOB read in process_service_search_rsp am:
   b6fa6e4fff am: 8c06d18eea am: dd2fbd1c21
 - [automerger] Fix possible OOB read in process_service_search_rsp am:
   b6fa6e4fff am: 8c06d18eea am: dd2fbd1c21 am: ea12ddddf5
 - [automerger] Fix possible OOB read in process_service_search_rsp am:
   b6fa6e4fff am: 8c06d18eea am: dd2fbd1c21 am: ea12ddddf5 skipped:
   3d2f54aa0f
 - [automerger] DO NOT MERGE: Fix possible OOB when AVDT data channel
   recive ACL data am: ad4098c340
 - [automerger] DO NOT MERGE: Fix possible OOB when AVDT data channel
   recive ACL data am: ad4098c340 am: 8ee587afbb
 - [automerger] DO NOT MERGE: Fix possible OOB when AVDT data channel
   recive ACL data am: ad4098c340 am: 8ee587afbb am: bf3c65e987
 - [automerger] DO NOT MERGE: Fix possible OOB when AVDT data channel
   recive ACL data am: ad4098c340 am: 8ee587afbb am: bf3c65e987 am:
   6055cb79e5
 - [automerger] DO NOT MERGE: Fix possible OOB when AVDT data channel
   recive ACL data am: ad4098c340 am: 8ee587afbb am: bf3c65e987 am:
   6055cb79e5 skipped: 36f3c8f9f3
 - [automerger] DO NOT MERGE: HH: Check parameter length in
   bta_hh_ctrl_dat_act am: a4a11e1981
 - [automerger] DO NOT MERGE: HH: Check parameter length in
   bta_hh_ctrl_dat_act am: a4a11e1981 am: 9172befdc8
 - [automerger] DO NOT MERGE: HH: Check parameter length in
   bta_hh_ctrl_dat_act am: a4a11e1981 am: 9172befdc8 am: 13e8d7ad1c
 - [automerger] DO NOT MERGE: HH: Check parameter length in
   bta_hh_ctrl_dat_act am: a4a11e1981 am: 9172befdc8 am: 13e8d7ad1c am:
   d474c386ef
 - [automerger] DO NOT MERGE: HH: Check parameter length in
   bta_hh_ctrl_dat_act am: a4a11e1981 am: 9172befdc8 am: 13e8d7ad1c am:
   d474c386ef skipped: 0ea657053e
 - [automerger] DO NOT MERGE: MCAP: Check response length in
   mca_ccb_hdl_rsp am: 840f70ca1e
 - [automerger] DO NOT MERGE: MCAP: Check response length in
   mca_ccb_hdl_rsp am: 840f70ca1e am: c1f3afedf3
 - [automerger] DO NOT MERGE: MCAP: Check response length in
   mca_ccb_hdl_rsp am: 840f70ca1e am: c1f3afedf3 am: 3f5160f5aa
 - [automerger] DO NOT MERGE: MCAP: Check response length in
   mca_ccb_hdl_rsp am: 840f70ca1e am: c1f3afedf3 am: 3f5160f5aa am:
   0f2de3c3df
 - [automerger] DO NOT MERGE: MCAP: Check response length in
   mca_ccb_hdl_rsp am: 840f70ca1e am: c1f3afedf3 am: 3f5160f5aa am:
   0f2de3c3df skipped: a3dbdeece2
 - [automerger] DO NOT MERGE: SDP: Check p_end in save_attr_seq and
   add_attr am: 2091fe7501
 - [automerger] DO NOT MERGE: SDP: Check p_end in save_attr_seq and
   add_attr am: 2091fe7501 am: 4494b9be43
 - [automerger] DO NOT MERGE: SDP: Check p_end in save_attr_seq and
   add_attr am: 2091fe7501 am: 4494b9be43 am: 07b95830b3
 - [automerger] DO NOT MERGE: SDP: Check p_end in save_attr_seq and
   add_attr am: 2091fe7501 am: 4494b9be43 am: 07b95830b3 am: e50ffa7119
 - [automerger] DO NOT MERGE: SDP: Check p_end in save_attr_seq and
   add_attr am: 2091fe7501 am: 4494b9be43 am: 07b95830b3 am: e50ffa7119
   skipped: fc00aa02bf
 - [automerger] DO NOT MERGE HFP: Check AT command buffer boundary
   during parsing am: aea10aec7f
 - [automerger] DO NOT MERGE HFP: Check AT command buffer boundary
   during parsing am: aea10aec7f am: 289b3fa863
 - [automerger] DO NOT MERGE HFP: Check AT command buffer boundary
   during parsing am: aea10aec7f am: 289b3fa863 skipped: 04ade0fdc0
 - [automerger skipped] DO NOT MERGE HFP: Check AT command buffer
   boundary during parsing skipped: 163dec2ae1
 - [automerger skipped] DO NOT MERGE HFP: Check AT command buffer
   boundary during parsing skipped: 163dec2ae1 skipped: 9805ed7a7a
 - [automerger skipped] DO NOT MERGE HFP: Check AT command buffer
   boundary during parsing skipped: 163dec2ae1 skipped: 9805ed7a7a
   skipped: f9606e1d89
 - [automerger skipped] DO NOT MERGE HFP: Check AT command buffer
   boundary during parsing skipped: 163dec2ae1 skipped: 9805ed7a7a
   skipped: f9606e1d89 skipped: c96313fb2c
 - [automerger skipped] DO NOT MERGE HFP: Check AT command buffer
   boundary during parsing skipped: 163dec2ae1 skipped: 9805ed7a7a
   skipped: f9606e1d89 skipped: c96313fb2c skipped: 9c2fb57cee

Cheney Ni (4):
 - Revert "Fix OOB in avrc_pars_browse_rsp"
 - Revert "Fix OOB in avrc_pars_browse_rsp" am: 6d1c4974bf
 - Revert "Fix OOB in avrc_pars_browse_rsp" am: 6d1c4974bf am:
   1e5b0037f8
 - Revert "Fix OOB in avrc_pars_browse_rsp" am: 6d1c4974bf am:
   1e5b0037f8 am: 40cbdde492

Chienyuan (15):
 - HFP: Check AT command buffer boundary during parsing
 - DO NOT MERGE HFP: Check AT command buffer boundary during parsing
 - DO NOT MERGE HFP: Check AT command buffer boundary during parsing
 - DO NOT MERGE HFP: Check AT command buffer boundary during parsing
 - DO NOT MERGE HFP: Check AT command buffer boundary during parsing
 - Merge changes from topic
   "Check-AT-command-buffer-boundary-during-parsing" into oc-dev am:
   97ed603b62
 - Merge changes from topic
   "Check-AT-command-buffer-boundary-during-parsing" into oc-dev am:
   97ed603b62 am: e81dc3a461
 - Merge changes from topic
   "Check-AT-command-buffer-boundary-during-parsing" into oc-dev am:
   97ed603b62 am: e81dc3a461 am: 92892e3f98
 - [automerger skipped] Merge "DO NOT MERGE HFP: Check AT command buffer
   boundary during parsing" into oc-mr1-dev am: cfaf7a9792  -s ours
 - [automerger skipped] DO NOT MERGE HFP: Check AT command buffer
   boundary during parsing skipped: 163dec2ae1 skipped: 9805ed7a7a
   skipped: f9606e1d89 skipped: c96313fb2c skipped: 9c2fb57cee am:
   18515721e5  -s ours
 - [automerger skipped] DO NOT MERGE HFP: Check AT command buffer
   boundary during parsing skipped: 163dec2ae1 skipped: 9805ed7a7a
   skipped: f9606e1d89 skipped: c96313fb2c skipped: 9c2fb57cee am:
   18515721e5  -s ours am: 6408abcd83  -s ours
 - [automerger skipped] DO NOT MERGE HFP: Check AT command buffer
   boundary during parsing skipped: 163dec2ae1 skipped: 9805ed7a7a
   skipped: f9606e1d89 skipped: c96313fb2c skipped: 9c2fb57cee am:
   18515721e5  -s ours am: 6408abcd83  -s ours am: bfe3eda2bb  -s ours
 - Merge "DO NOT MERGE HFP: Check AT command buffer boundary during
   parsing" into oc-dev am: 6bc3fa5698
 - [automerger skipped] Merge "DO NOT MERGE HFP: Check AT command buffer
   boundary during parsing" into oc-dev am: 6bc3fa5698 am: 2a2dc33454
   -s ours
 - [automerger skipped] Merge "DO NOT MERGE HFP: Check AT command buffer
   boundary during parsing" into oc-dev am: 6bc3fa5698 am: 2a2dc33454
   -s ours am: efa804ed44  -s ours

Hansong Zhang (6):
 - HID Device: Fix OOB in register_app
 - Hearing Aid: Clean up GATT on disconnect
 - DO NOT MERGE Hearing Aid: Add JNI API for add/remove whitelist
 - HIDD: Check descriptor length and increase buffer
 - Hearing Aid: Use valid COC service id
 - Merge "HFP: Check AT command buffer boundary during parsing" into
   pi-dev

Jakub Pawlowski (12):
 - Hearing Aid - codec switching
 - Send volume just once when starting the stream.
 - Fix possible OOB read
 - Fix possible OOB read in process_service_search_rsp
 - Fix possible OOB read am: 6e6c347e79
 - Fix possible OOB read am: 6e6c347e79 am: bd361ff770
 - Fix possible OOB read am: 6e6c347e79 am: bd361ff770 am: 58a0027263
 - [automerger skipped] [automerger] Fix possible OOB read in
   process_service_search_rsp am: b6fa6e4fff am: 8c06d18eea am:
   dd2fbd1c21 am: ea12ddddf5 skipped: 3d2f54aa0f am: 572fa878ff  -s ours
 - [automerger skipped] [automerger] Fix possible OOB read in
   process_service_search_rsp am: b6fa6e4fff am: 8c06d18eea am:
   dd2fbd1c21 am: ea12ddddf5 skipped: 3d2f54aa0f am: 572fa878ff  -s ours
   am: 2a054eb8de  -s ours
 - [automerger skipped] [automerger] Fix possible OOB read in
   process_service_search_rsp am: b6fa6e4fff am: 8c06d18eea am:
   dd2fbd1c21 am: ea12ddddf5 skipped: 3d2f54aa0f am: 572fa878ff  -s ours
   am: 2a054eb8de  -s ours am: 2667debc95  -s ours
 - Fix potential usage of freed memory in btif_hl_proc_sdp_query_cfm
 - Fix buffer overflow in btif_dm_data_copy

Luca Stefani (1):
 - Merge tag 'android-9.0.0_r31' into lineage-16.0-android-9.0.0_r31

Myles Watson (30):
 - bta: Pass the correct UUID array size in bta_ag_do_disc
 - HH: Check parameter length in bta_hh_ctrl_dat_act
 - MCAP: Check response length in mca_ccb_hdl_rsp
 - SDP: Check p_end in save_attr_seq and add_attr
 - DO NOT MERGE: HH: Check parameter length in bta_hh_ctrl_dat_act
 - DO NOT MERGE: HH: Check parameter length in bta_hh_ctrl_dat_act
 - DO NOT MERGE: MCAP: Check response length in mca_ccb_hdl_rsp
 - DO NOT MERGE: MCAP: Check response length in mca_ccb_hdl_rsp
 - DO NOT MERGE: SDP: Check p_end in save_attr_seq and add_attr
 - Merge changes from topic "am-a8794701-2d32-4392-bf6f-9d00a3751e39"
   into oc-dev am: 6d6c82d9e0
 - Merge "DO NOT MERGE: MCAP: Check response length in mca_ccb_hdl_rsp"
   into oc-dev am: 7d38013232
 - Merge changes from topic "am-3290ac2a-4a57-4151-aaf8-9695d2ed6348"
   into oc-dev am: 74749c1996
 - Merge changes from topic "am-a8794701-2d32-4392-bf6f-9d00a3751e39"
   into oc-dev am: 6d6c82d9e0 am: a9291d7c8b
 - Merge "DO NOT MERGE: MCAP: Check response length in mca_ccb_hdl_rsp"
   into oc-dev am: 7d38013232 am: c5c82d09b4
 - Merge changes from topic "am-3290ac2a-4a57-4151-aaf8-9695d2ed6348"
   into oc-dev am: 74749c1996 am: 28c5c4ab20
 - Merge changes from topic "am-a8794701-2d32-4392-bf6f-9d00a3751e39"
   into oc-dev am: 6d6c82d9e0 am: a9291d7c8b am: cdbadeb96d
 - [automerger skipped] Merge "DO NOT MERGE: MCAP: Check response length
   in mca_ccb_hdl_rsp" into oc-dev am: 7d38013232 am: c5c82d09b4 am:
   b713c179e8  -s ours
 - Merge changes from topic "am-3290ac2a-4a57-4151-aaf8-9695d2ed6348"
   into oc-dev am: 74749c1996 am: 28c5c4ab20 am: adb9ed0d35
 - DO NOT MERGE: SDP: Check p_end in save_attr_seq and add_attr
 - DO NOT MERGE: SDP: Check p_end in save_attr_seq and add_attr
 - [automerger skipped] Merge "DO NOT MERGE: SDP: Check p_end in
   save_attr_seq and add_attr" into oc-mr1-dev am: f2f5d9ebf2  -s ours
 - Merge changes from topic "am-154171ba-0805-48c6-88cf-c592ee3cf37c"
   into oc-dev am: 518c50aaa9
 - Merge "DO NOT MERGE: HH: Check parameter length in
   bta_hh_ctrl_dat_act" into oc-dev am: f6dc20ea52
 - Merge changes from topic "am-154171ba-0805-48c6-88cf-c592ee3cf37c"
   into oc-dev am: 518c50aaa9 am: e476de0364
 - Merge "DO NOT MERGE: HH: Check parameter length in
   bta_hh_ctrl_dat_act" into oc-dev am: f6dc20ea52 am: 0e1c94b72d
 - Merge changes from topic "am-154171ba-0805-48c6-88cf-c592ee3cf37c"
   into oc-dev am: 518c50aaa9 am: e476de0364 am: 999d3d078f
 - [automerger skipped] Merge "DO NOT MERGE: HH: Check parameter length
   in bta_hh_ctrl_dat_act" into oc-dev am: f6dc20ea52 am: 0e1c94b72d am:
   a8fcbbcc01  -s ours
 - [automerger skipped] Merge "DO NOT MERGE: SDP: Check p_end in
   save_attr_seq and add_attr" into oc-dev am: f90160ea4f  -s ours
 - [automerger skipped] Merge "DO NOT MERGE: SDP: Check p_end in
   save_attr_seq and add_attr" into oc-dev am: f90160ea4f  -s ours am:
   d2e1ff8307  -s ours
 - [automerger skipped] Merge "DO NOT MERGE: SDP: Check p_end in
   save_attr_seq and add_attr" into oc-dev am: f90160ea4f  -s ours am:
   d2e1ff8307  -s ours am: 4e8ad23c80  -s ours

Pavlin Radoslavov (18):
 - Check data length when parsing AVRCP vendor specific command
   responses
 - Check AVRCP data length when parsing inside
   avrc_ctrl_pars_vendor_rsp()
 - DO NOT MERGE - Check AVRCP data length when parsing inside
   avrc_ctrl_pars_vendor_rsp()
 - DO NOT MERGE - Check data length when parsing AVRCP vendor specific
   command responses
 - DO NOT MERGE - Check AVRCP data length when parsing inside
   avrc_ctrl_pars_vendor_rsp()
 - DO NOT MERGE - Check AVRCP data length when parsing inside
   avrc_ctrl_pars_vendor_rsp() am: 2692408d05
 - Merge changes from topic
   "bt-security-avrc_ctrl_pars_vendor_rsp-length-check-nyc-dev" into
   oc-dev am: 5e20d5088c
 - Merge changes from topic
   "bt-security-avrc_pars_vendor_rsp-length-check-nyc-dev" into oc-dev
   am: a57a887b16
 - Merge "Check data length when parsing AVRCP vendor specific command
   responses" into oc-dev am: 03e6de3be8
 - DO NOT MERGE - Check AVRCP data length when parsing inside
   avrc_ctrl_pars_vendor_rsp() am: 2692408d05 am: 90d9589f1e
 - Merge changes from topic
   "bt-security-avrc_ctrl_pars_vendor_rsp-length-check-nyc-dev" into
   oc-dev am: 5e20d5088c am: afc8839cea
 - Merge changes from topic
   "bt-security-avrc_pars_vendor_rsp-length-check-nyc-dev" into oc-dev
   am: a57a887b16 am: 0c13a140c9
 - Merge "Check data length when parsing AVRCP vendor specific command
   responses" into oc-dev am: 03e6de3be8 am: 36e56d4b33
 - [automerger skipped] DO NOT MERGE - Check AVRCP data length when
   parsing inside avrc_ctrl_pars_vendor_rsp() am: 2692408d05 am:
   90d9589f1e am: 746df692f0  -s ours
 - Merge changes from topic
   "bt-security-avrc_ctrl_pars_vendor_rsp-length-check-nyc-dev" into
   oc-dev am: 5e20d5088c am: afc8839cea am: 9b86fdb58e
 - Merge changes from topic
   "bt-security-avrc_pars_vendor_rsp-length-check-nyc-dev" into oc-dev
   am: a57a887b16 am: 0c13a140c9 am: 8dd01ede32
 - Merge "Check data length when parsing AVRCP vendor specific command
   responses" into oc-dev am: 03e6de3be8 am: 36e56d4b33 am: e03c093530
 - Run the wakelock JNI callbacks on the JNI thread

Stanley Tng (5):
 - Hearing Aid: codec and connection interval switching
 - Clear connection update pending flag when disconnected
 - Hearing Aid: use correct Data Length and MediaType
 - Add more Hearing Aid Profile logs
 - Fix Spurious Hearing Aid Start and Stop Cmds

TreeHugger Robot (71):
 - Merge "DO NOT MERGE Fix OOB read before buffer length check" into
   nyc-dev
 - Merge changes from topic "am-a988fd47-73ee-44e9-929f-5374e8851656"
   into nyc-dr1-dev
 - Merge changes from topic "am-a988fd47-73ee-44e9-929f-5374e8851656"
   into nyc-mr1-dev
 - Merge changes from topic "am-a988fd47-73ee-44e9-929f-5374e8851656"
   into cw-f-dev
 - Merge changes from topic "am-a988fd47-73ee-44e9-929f-5374e8851656"
   into nyc-mr2-dev
 - Merge "DO NOT MERGE Check packet length in bta_av_proc_meta_cmd" into
   nyc-dev
 - Merge changes from topic "am-c2d9879f-e9d2-44f3-9012-53037ab580a0"
   into nyc-dr1-dev
 - Merge changes from topic "am-c2d9879f-e9d2-44f3-9012-53037ab580a0"
   into nyc-mr1-dev
 - Merge changes from topic "am-c2d9879f-e9d2-44f3-9012-53037ab580a0"
   into cw-f-dev
 - Merge changes from topic "am-c2d9879f-e9d2-44f3-9012-53037ab580a0"
   into nyc-mr2-dev
 - Merge "DO NOT MERGE: Add missing AVRCP message length checks inside
   avrc_msg_cback" into nyc-dev
 - Merge changes from topic "bt-avrcp-check-avrc_msg_cback-nyc-dev" into
   nyc-dr1-dev
 - Merge changes from topic "bt-avrcp-check-avrc_msg_cback-nyc-dev" into
   nyc-mr1-dev
 - Merge changes from topic "bt-avrcp-check-avrc_msg_cback-nyc-dev" into
   cw-f-dev
 - Merge changes from topic "bt-avrcp-check-avrc_msg_cback-nyc-dev" into
   nyc-mr2-dev
 - Merge "DO NOT MERGE Add packet length check in smp_proc_master_id"
   into nyc-dev
 - Merge changes from topic "am-df95a56f-528f-434c-972e-bb492348a21a"
   into nyc-dr1-dev
 - Merge changes from topic "am-df95a56f-528f-434c-972e-bb492348a21a"
   into nyc-mr1-dev
 - Merge changes from topic "am-df95a56f-528f-434c-972e-bb492348a21a"
   into cw-f-dev
 - Merge changes from topic "am-df95a56f-528f-434c-972e-bb492348a21a"
   into nyc-mr2-dev
 - Merge "Checks the SMP length to fix OOB read" into nyc-dev
 - Merge changes from topic "am-dcf0c368-3f3f-440a-998e-f94bd1924189"
   into nyc-dr1-dev
 - Merge changes from topic "am-dcf0c368-3f3f-440a-998e-f94bd1924189"
   into nyc-mr1-dev
 - Merge changes from topic "am-dcf0c368-3f3f-440a-998e-f94bd1924189"
   into cw-f-dev
 - Merge changes from topic "am-dcf0c368-3f3f-440a-998e-f94bd1924189"
   into nyc-mr2-dev
 - Merge "HID Device: Fix OOB in register_app" into pi-dev
 - Merge changes from topic
   "bt-security-avrc_ctrl_pars_vendor_rsp-length-check-nyc-dev" into
   oc-dev
 - Merge changes from topic
   "bt-security-avrc_pars_vendor_rsp-length-check-nyc-dev" into oc-dev
 - Merge "DO NOT MERGE - Check data length when parsing AVRCP vendor
   specific command responses" into nyc-dev
 - Merge changes from topic
   "bt-security-avrc_pars_vendor_rsp-length-check-nyc-dev" into
   nyc-dr1-dev
 - Merge changes from topic
   "bt-security-avrc_pars_vendor_rsp-length-check-nyc-dev" into
   nyc-mr1-dev
 - Merge changes from topic
   "bt-security-avrc_pars_vendor_rsp-length-check-nyc-dev" into cw-f-dev
 - Merge changes from topic
   "bt-security-avrc_pars_vendor_rsp-length-check-nyc-dev" into
   nyc-mr2-dev
 - Merge "Check data length when parsing AVRCP vendor specific command
   responses" into oc-dev
 - Merge "Check SDU lower bound before allocate p_data" into pi-dev
 - Merge "DO NOT MERGE - Check SDU lower bound before allocate p_data"
   into oc-mr1-dev
 - Merge "DO NOT MERGE - Check SDU lower bound before allocate p_data"
   into oc-dev
 - Merge "bta: Pass the correct UUID array size in bta_ag_do_disc" into
   pi-dev
 - Merge "HIDD: Check descriptor length and increase buffer" into pi-dev
 - Merge changes from topic "am-6595535a-66ae-4551-9774-048441013dbf"
   into oc-dev
 - Merge "DO NOT MERGE: Fix possible OOB when AVDT data channel recive
   ACL data" into oc-dev
 - Merge changes from topic "am-a8794701-2d32-4392-bf6f-9d00a3751e39"
   into nyc-mr1-dev
 - Merge changes from topic "am-a8794701-2d32-4392-bf6f-9d00a3751e39"
   into cw-f-dev
 - Merge changes from topic "am-a8794701-2d32-4392-bf6f-9d00a3751e39"
   into nyc-mr2-dev
 - Merge changes from topic "am-a8794701-2d32-4392-bf6f-9d00a3751e39"
   into nyc-dr1-dev
 - Merge changes from topic "am-a8794701-2d32-4392-bf6f-9d00a3751e39"
   into oc-dev
 - Merge "DO NOT MERGE: MCAP: Check response length in mca_ccb_hdl_rsp"
   into oc-dev
 - Merge changes from topic "am-3290ac2a-4a57-4151-aaf8-9695d2ed6348"
   into oc-dev
 - Merge changes from topic "am-3290ac2a-4a57-4151-aaf8-9695d2ed6348"
   into nyc-mr1-dev
 - Merge changes from topic "am-3290ac2a-4a57-4151-aaf8-9695d2ed6348"
   into cw-f-dev
 - Merge changes from topic "am-3290ac2a-4a57-4151-aaf8-9695d2ed6348"
   into nyc-mr2-dev
 - Merge changes from topic "am-3290ac2a-4a57-4151-aaf8-9695d2ed6348"
   into nyc-dr1-dev
 - Merge "SDP: Check p_end in save_attr_seq and add_attr" into pi-dev
 - Merge "MCAP: Check response length in mca_ccb_hdl_rsp" into pi-dev
 - Merge changes from topic
   "Check-AT-command-buffer-boundary-during-parsing" into oc-dev
 - Merge "DO NOT MERGE HFP: Check AT command buffer boundary during
   parsing" into nyc-mr1-dev
 - Merge changes from topic
   "Check-AT-command-buffer-boundary-during-parsing" into cw-f-dev
 - Merge changes from topic
   "Check-AT-command-buffer-boundary-during-parsing" into nyc-mr2-dev
 - Merge "DO NOT MERGE: SDP: Check p_end in save_attr_seq and add_attr"
   into oc-mr1-dev
 - Merge changes from topic "am-154171ba-0805-48c6-88cf-c592ee3cf37c"
   into oc-dev
 - Merge changes from topic "am-154171ba-0805-48c6-88cf-c592ee3cf37c"
   into nyc-dr1-dev
 - Merge changes from topic "am-154171ba-0805-48c6-88cf-c592ee3cf37c"
   into nyc-mr1-dev
 - Merge changes from topic "am-154171ba-0805-48c6-88cf-c592ee3cf37c"
   into cw-f-dev
 - Merge changes from topic "am-154171ba-0805-48c6-88cf-c592ee3cf37c"
   into nyc-mr2-dev
 - Merge "DO NOT MERGE: HH: Check parameter length in
   bta_hh_ctrl_dat_act" into oc-dev
 - Merge "HH: Check parameter length in bta_hh_ctrl_dat_act" into pi-dev
 - Merge "DO NOT MERGE HFP: Check AT command buffer boundary during
   parsing" into oc-mr1-dev
 - Merge "DO NOT MERGE: SDP: Check p_end in save_attr_seq and add_attr"
   into oc-dev
 - Merge "DO NOT MERGE HFP: Check AT command buffer boundary during
   parsing" into oc-dev
 - Merge "AVRCP: Change notification variable when the interim response
   is sent" into pi-dev
 - Merge "Hearing Aid: Combine audio from stereo to mono when only one
   side connect" into pi-dev

Ugo Yu (27):
 - Check SDU lower bound before allocate p_data
 - DO NOT MERGE - Check SDU lower bound before allocate p_data
 - DO NOT MERGE - Check SDU lower bound before allocate p_data
 - DO NOT MERGE - Check SDU lower bound before allocate p_data
 - [automerger] DO NOT MERGE - Check SDU lower bound before allocate
   p_data am: 87bcda81b8 am: 8e31e9abb4 am: e51a7b9760 am: 90248f8fb3
   skipped: b3bef4683a am: c5baf9ac24
 - [automerger] DO NOT MERGE - Check SDU lower bound before allocate
   p_data am: 87bcda81b8 am: 8e31e9abb4 am: e51a7b9760 am: 90248f8fb3
   skipped: b3bef4683a am: c5baf9ac24 am: 9bcb338d3d
 - [automerger skipped] [automerger] DO NOT MERGE - Check SDU lower
   bound before allocate p_data am: 87bcda81b8 am: 8e31e9abb4 am:
   e51a7b9760 am: 90248f8fb3 skipped: b3bef4683a am: c5baf9ac24 am:
   9bcb338d3d am: 247c18200e  -s ours
 - [automerger skipped] Merge "DO NOT MERGE - Check SDU lower bound
   before allocate p_data" into oc-mr1-dev am: 3298d1457d  -s ours
 - [automerger skipped] Merge "DO NOT MERGE - Check SDU lower bound
   before allocate p_data" into oc-dev am: bc5bd697c9  -s ours
 - [automerger skipped] Merge "DO NOT MERGE - Check SDU lower bound
   before allocate p_data" into oc-dev am: bc5bd697c9  -s ours am:
   77175af80b  -s ours
 - [automerger skipped] Merge "DO NOT MERGE - Check SDU lower bound
   before allocate p_data" into oc-dev am: bc5bd697c9  -s ours am:
   77175af80b  -s ours am: 8be1e6fac4  -s ours
 - Fix possible OOB when AVDT data channel recive ACL data
 - DO NOT MERGE: Fix possible OOB when AVDT data channel recive ACL data
 - DO NOT MERGE: Fix possible OOB when AVDT data channel recive ACL data
 - Fix OOB in avrc_pars_browse_rsp
 - [automerger skipped] DO NOT MERGE: Fix possible OOB when AVDT data
   channel recive ACL data am: f349ff0c65  -s ours
 - Fix OOB in avrc_pars_browse_rsp am: 32a33dc12d
 - Merge changes from topic "am-6595535a-66ae-4551-9774-048441013dbf"
   into oc-dev am: 31d6e17ffa
 - Fix OOB in avrc_pars_browse_rsp am: 32a33dc12d am: 8fe5c0bc2a
 - Merge changes from topic "am-6595535a-66ae-4551-9774-048441013dbf"
   into oc-dev am: 31d6e17ffa am: c59c3fa0b2
 - Fix OOB in avrc_pars_browse_rsp am: 32a33dc12d am: 8fe5c0bc2a am:
   3c9dbf8a41
 - Merge changes from topic "am-6595535a-66ae-4551-9774-048441013dbf"
   into oc-dev am: 31d6e17ffa am: c59c3fa0b2 am: 617a844b22
 - DO NOT MERGE: Fix possible OOB when AVDT data channel recive ACL data
 - [automerger skipped] Merge "DO NOT MERGE: Fix possible OOB when AVDT
   data channel recive ACL data" into oc-dev am: 5b3764ada2  -s ours
 - [automerger skipped] Merge "DO NOT MERGE: Fix possible OOB when AVDT
   data channel recive ACL data" into oc-dev am: 5b3764ada2  -s ours am:
   d23783330e  -s ours
 - [automerger skipped] Merge "DO NOT MERGE: Fix possible OOB when AVDT
   data channel recive ACL data" into oc-dev am: 5b3764ada2  -s ours am:
   d23783330e  -s ours am: 5a706ef567  -s ours
 - Add OOB check in avrc_pars_browse_rsp

android-build-team Robot (12):
 - Snap for 5044688 from d65f697c011cc6e5eaad767de3ec726cfd25b27f to
   pi-qpr2-release
 - Snap for 5053079 from 94993095994a541a33a0a3c61ac5ac33dc5aec53 to
   pi-qpr2-release
 - Snap for 5053079 from 94993095994a541a33a0a3c61ac5ac33dc5aec53 to
   pi-qpr2-release
 - Merge "Snap for 5053079 from 94993095994a541a33a0a3c61ac5ac33dc5aec53
   to pi-qpr2-release" into pi-qpr2-release
 - Snap for 5058880 from ab4453774e9b8b5c87c9d3da5a84145cf0f43540 to
   pi-qpr2-release
 - Snap for 5066295 from 71a55dd26eea6f2e3433b29c3ed33909055463b5 to
   pi-qpr2-release
 - Snap for 5073521 from b17fcf9c9848401d22e83e996bd51b651892a4d3 to
   pi-qpr2-release
 - Snap for 5087486 from cac96c646fac463a9c894ad702bd4428863c9400 to
   pi-qpr2-release
 - Snap for 5115288 from 6a27baad580a40375c8a72cecfc2d0697bff1cf8 to
   pi-qpr2-release
 - Snap for 5117340 from ae04da547f76b34b193dcf8db27504ec11f08e7e to
   pi-qpr2-release
 - Snap for 5130385 from 3c0a7052f7b1012b1e7d5b372a3049d0b7602dc3 to
   pi-qpr2-release
 - Merge cherrypicks of [5704859, 5705300, 5704034, 5704195, 5705082,
   5704058, 5704059, 5704932, 5705340, 5705341, 5705342, 5705343,
   5705344, 5705361, 5705362, 5705363, 5705364, 5704870, 5704196,
   5705083, 5701785, 5701786, 5701787, 5704035, 5705261, 5705281,
   5704036, 5704037, 5704038, 5704871, 5704933, 5704872, 5705347,
   5705262, 5704934] into pi-qpr2-release

weichinweng (2):
 - Stop A2DP stream when shutting down A2DP source.
 - Hearing Aid: Combine audio from stereo to mono when only one side
   connect

Change-Id: I711015d45a8b5301a5e56631631da030fb7f617b

Change-Id: Idf60707e7d55bdee89ef5edfc3ce3c8a724b4a8a
---
 audio_a2dp_hw/src/audio_a2dp_hw.cc          |   2 +
 bta/hearing_aid/hearing_aid.cc              | 430 +++++++++++++++-----
 bta/hearing_aid/hearing_aid_audio_source.cc |  47 ++-
 bta/hl/bta_hl_main.cc                       |   5 +-
 bta/include/bta_closure_api.h               |   2 +
 bta/include/bta_hearing_aid_api.h           |   9 +-
 bta/sys/bta_sys_main.cc                     |  31 ++
 btif/include/btif_storage.h                 |   3 +
 btif/src/btif_a2dp_source.cc                |   3 +-
 btif/src/btif_hearing_aid.cc                |  16 +
 btif/src/btif_hl.cc                         |   4 +
 btif/src/btif_storage.cc                    |   7 +
 include/hardware/bt_hearing_aid.h           |   6 +
 profile/avrcp/device.cc                     |  41 +-
 profile/avrcp/tests/avrcp_device_test.cc    | 298 +++++++++++++-
 stack/avrc/avrc_pars_ct.cc                  | 100 +++--
 stack/include/btm_api_types.h               |   4 +-
 stack/smp/smp_act.cc                        |  67 ++-
 stack/smp/smp_utils.cc                      |  28 +-
 19 files changed, 884 insertions(+), 219 deletions(-)

diff --git a/audio_a2dp_hw/src/audio_a2dp_hw.cc b/audio_a2dp_hw/src/audio_a2dp_hw.cc
index 7b82dd96e..0adacaa77 100644
--- a/audio_a2dp_hw/src/audio_a2dp_hw.cc
+++ b/audio_a2dp_hw/src/audio_a2dp_hw.cc
@@ -1684,6 +1684,8 @@ static void adev_close_output_stream(struct audio_hw_device* dev,
   struct a2dp_audio_device* a2dp_dev = (struct a2dp_audio_device*)dev;
   struct a2dp_stream_out* out = (struct a2dp_stream_out*)stream;
 
+  INFO("%s: state %d", __func__, out->common.state);
+
   // prevent interference with adev_set_parameters.
   std::lock_guard<std::recursive_mutex> lock(*a2dp_dev->mutex);
   {
diff --git a/bta/hearing_aid/hearing_aid.cc b/bta/hearing_aid/hearing_aid.cc
index 87795422d..364318412 100644
--- a/bta/hearing_aid/hearing_aid.cc
+++ b/bta/hearing_aid/hearing_aid.cc
@@ -25,6 +25,7 @@
 #include "embdrv/g722/g722_enc_dec.h"
 #include "gap_api.h"
 #include "gatt_api.h"
+#include "osi/include/properties.h"
 
 #include <base/bind.h>
 #include <base/logging.h>
@@ -36,6 +37,13 @@ using base::Closure;
 using bluetooth::Uuid;
 using bluetooth::hearing_aid::ConnectionState;
 
+// The MIN_CE_LEN parameter for Connection Parameters based on the current
+// Connection Interval
+constexpr uint16_t MIN_CE_LEN_10MS_CI = 0x0006;
+constexpr uint16_t MIN_CE_LEN_20MS_CI = 0x000C;
+constexpr uint16_t CONNECTION_INTERVAL_10MS_PARAM = 0x0008;
+constexpr uint16_t CONNECTION_INTERVAL_20MS_PARAM = 0x0010;
+
 void btif_storage_add_hearing_aid(const RawAddress& address, uint16_t psm,
                                   uint8_t capabilities, uint16_t codecs,
                                   uint16_t audio_control_point_handle,
@@ -59,6 +67,9 @@ constexpr uint8_t CONTROL_POINT_OP_STOP = 0x02;
 constexpr int8_t VOLUME_UNKNOWN = 127;
 constexpr int8_t VOLUME_MIN = -127;
 
+// audio type
+constexpr uint8_t AUDIOTYPE_UNKNOWN = 0x00;
+
 namespace {
 
 // clang-format off
@@ -70,8 +81,6 @@ Uuid VOLUME_UUID               = Uuid::FromString("00e4ca9e-ab14-41e4-8823-f9e70
 Uuid LE_PSM_UUID               = Uuid::FromString("2d410339-82b6-42aa-b34e-e2e01df8cc1a");
 // clang-format on
 
-constexpr uint16_t MIN_CE_LEN_1M = 0x0006;
-
 void hearingaid_gattc_callback(tBTA_GATTC_EVT event, tBTA_GATTC* p_data);
 void encryption_callback(const RawAddress*, tGATT_TRANSPORT, void*,
                          tBTM_STATUS);
@@ -108,6 +117,13 @@ class HearingAidImpl;
 HearingAidImpl* instance;
 HearingAidAudioReceiver* audioReceiver;
 
+/** Possible states for the Connection Update status */
+typedef enum {
+  NONE,      // Connection Update not pending or has completed
+  AWAITING,  // Waiting for start the Connection Update operation
+  STARTED    // Connection Update has started
+} connection_update_status_t;
+
 struct HearingDevice {
   RawAddress address;
   /* This is true only during first connection to profile, until we store the
@@ -120,13 +136,17 @@ struct HearingDevice {
 
   /* For two hearing aids, you must update their parameters one after another,
    * not simulteanously, to ensure start of connection events for both devices
-   * are far from each other. This flag means that this device is waiting for
-   * update of parameters, that should happen after "LE Connection Update
+   * are far from each other. This status tracks whether this device is waiting
+   * for update of parameters, that should happen after "LE Connection Update
    * Complete" event
    */
-  bool connection_update_pending;
+  connection_update_status_t connection_update_status;
+  uint16_t requested_connection_interval;
 
-  /* if true, we are connected, L2CAP socket is open, we can stream audio*/
+  /* if true, we are connected, L2CAP socket is open, we can stream audio.
+     However, the actual audio stream also depends on whether the
+     Audio Service has resumed.
+   */
   bool accepting_audio;
 
   uint16_t conn_id;
@@ -142,6 +162,11 @@ struct HearingDevice {
   uint16_t codecs;
 
   AudioStats audio_stats;
+  /* Keep tracks of whether the "Start Cmd" has been send to this device. When
+     the "Stop Cmd" is send or when this device disconnects, then this flag is
+     cleared. Please note that the "Start Cmd" is not send during device
+     connection in the case when the audio is suspended. */
+  bool playback_started;
 
   HearingDevice(const RawAddress& address, uint16_t psm, uint8_t capabilities,
                 uint16_t codecs, uint16_t audio_control_point_handle,
@@ -150,7 +175,7 @@ struct HearingDevice {
       : address(address),
         first_connection(false),
         connecting_actively(false),
-        connection_update_pending(false),
+        connection_update_status(NONE),
         accepting_audio(false),
         conn_id(0),
         gap_handle(0),
@@ -161,17 +186,19 @@ struct HearingDevice {
         hi_sync_id(hiSyncId),
         render_delay(render_delay),
         preparation_delay(preparation_delay),
-        codecs(codecs) {}
+        codecs(codecs),
+        playback_started(false) {}
 
   HearingDevice(const RawAddress& address, bool first_connection)
       : address(address),
         first_connection(first_connection),
         connecting_actively(first_connection),
-        connection_update_pending(false),
+        connection_update_status(NONE),
         accepting_audio(false),
         conn_id(0),
         gap_handle(0),
-        psm(0) {}
+        psm(0),
+        playback_started(false) {}
 
   HearingDevice() { HearingDevice(RawAddress::kEmpty, false); }
 
@@ -227,9 +254,9 @@ class HearingDevices {
     return (iter == devices.end()) ? nullptr : &(*iter);
   }
 
-  bool IsAnyConnectionUpdatePending() {
+  bool IsAnyConnectionUpdateStarted() {
     for (const auto& d : devices) {
-      if (d.connection_update_pending) return true;
+      if (d.connection_update_status == STARTED) return true;
     }
 
     return false;
@@ -244,16 +271,33 @@ g722_encode_state_t* encoder_state_left = nullptr;
 g722_encode_state_t* encoder_state_right = nullptr;
 
 class HearingAidImpl : public HearingAid {
+ private:
+  // Keep track of whether the Audio Service has resumed audio playback
+  bool audio_running;
+
  public:
   virtual ~HearingAidImpl() = default;
 
   HearingAidImpl(bluetooth::hearing_aid::HearingAidCallbacks* callbacks,
                  Closure initCb)
-      : gatt_if(0),
+      : audio_running(false),
+        gatt_if(0),
         seq_counter(0),
         current_volume(VOLUME_UNKNOWN),
-        callbacks(callbacks) {
-    DVLOG(2) << __func__;
+        callbacks(callbacks),
+        codec_in_use(0) {
+    default_data_interval_ms = (uint16_t)osi_property_get_int32(
+        "persist.bluetooth.hearingaid.interval", (int32_t)HA_INTERVAL_20_MS);
+    if ((default_data_interval_ms != HA_INTERVAL_10_MS) &&
+        (default_data_interval_ms != HA_INTERVAL_20_MS)) {
+      LOG(ERROR) << __func__
+                 << ": invalid interval=" << default_data_interval_ms
+                 << "ms. Overwriting back to default";
+      default_data_interval_ms = HA_INTERVAL_20_MS;
+    }
+    VLOG(2) << __func__
+            << ", default_data_interval_ms=" << default_data_interval_ms;
+
     BTA_GATTC_AppRegister(
         hearingaid_gattc_callback,
         base::Bind(
@@ -269,12 +313,50 @@ class HearingAidImpl : public HearingAid {
             initCb));
   }
 
+  uint16_t UpdateBleConnParams(const RawAddress& address) {
+    /* List of parameters that depends on the chosen Connection Interval */
+    uint16_t min_ce_len;
+    uint16_t connection_interval;
+
+    switch (default_data_interval_ms) {
+      case HA_INTERVAL_10_MS:
+        min_ce_len = MIN_CE_LEN_10MS_CI;
+        connection_interval = CONNECTION_INTERVAL_10MS_PARAM;
+        break;
+      case HA_INTERVAL_20_MS:
+        min_ce_len = MIN_CE_LEN_20MS_CI;
+        connection_interval = CONNECTION_INTERVAL_20MS_PARAM;
+        break;
+      default:
+        LOG(ERROR) << __func__ << ":Error: invalid default_data_interval_ms="
+                   << default_data_interval_ms;
+        min_ce_len = MIN_CE_LEN_10MS_CI;
+        connection_interval = CONNECTION_INTERVAL_10MS_PARAM;
+    }
+
+    L2CA_UpdateBleConnParams(address, connection_interval, connection_interval,
+                             0x000A, 0x0064 /*1s*/, min_ce_len, min_ce_len);
+    return connection_interval;
+  }
+
   void Connect(const RawAddress& address) override {
     DVLOG(2) << __func__ << " " << address;
     hearingDevices.Add(HearingDevice(address, true));
     BTA_GATTC_Open(gatt_if, address, true, GATT_TRANSPORT_LE, false);
   }
 
+  void AddToWhiteList(const RawAddress& address) override {
+    VLOG(2) << __func__ << " address: " << address;
+    hearingDevices.Add(HearingDevice(address, true));
+    BTA_GATTC_Open(gatt_if, address, false, GATT_TRANSPORT_LE, false);
+    BTA_DmBleStartAutoConn();
+  }
+
+  void RemoveFromWhiteList(const RawAddress& address) override {
+    VLOG(2) << __func__ << " address: " << address;
+    BTA_GATTC_CancelOpen(gatt_if, address, false);
+  }
+
   void AddFromStorage(const RawAddress& address, uint16_t psm,
                       uint8_t capabilities, uint16_t codecs,
                       uint16_t audio_control_point_handle,
@@ -305,7 +387,7 @@ class HearingAidImpl : public HearingAid {
   void OnGattConnected(tGATT_STATUS status, uint16_t conn_id,
                        tGATT_IF client_if, RawAddress address,
                        tBTA_TRANSPORT transport, uint16_t mtu) {
-    VLOG(2) << __func__ << " " << address;
+    VLOG(2) << __func__ << ": address=" << address << ", conn_id=" << conn_id;
 
     HearingDevice* hearingDevice = hearingDevices.FindByAddress(address);
     if (!hearingDevice) {
@@ -334,18 +416,20 @@ class HearingAidImpl : public HearingAid {
      * to move anchor point of both connections away from each other, to make
      * sure we'll be able to fit all the data we want in one connection event.
      */
-    bool any_update_pending = hearingDevices.IsAnyConnectionUpdatePending();
+    bool any_update_pending = hearingDevices.IsAnyConnectionUpdateStarted();
     // mark the device as pending connection update. If we don't start the
     // update now, it'll be started once current device finishes.
-    hearingDevice->connection_update_pending = true;
     if (!any_update_pending) {
-      L2CA_UpdateBleConnParams(address, 0x0008, 0x0008, 0x000A, 0x0064 /*1s*/,
-                               MIN_CE_LEN_1M, MIN_CE_LEN_1M);
+      hearingDevice->connection_update_status = STARTED;
+      hearingDevice->requested_connection_interval =
+          UpdateBleConnParams(address);
+    } else {
+      hearingDevice->connection_update_status = AWAITING;
     }
 
     // Set data length
     // TODO(jpawlowski: for 16khz only 87 is required, optimize
-    BTM_SetBleDataLength(address, 147);
+    BTM_SetBleDataLength(address, 167);
 
     tBTM_SEC_DEV_REC* p_dev_rec = btm_find_dev(address);
     if (p_dev_rec) {
@@ -379,19 +463,45 @@ class HearingAidImpl : public HearingAid {
     OnEncryptionComplete(address, true);
   }
 
-  void OnConnectionUpdateComplete(uint16_t conn_id) {
+  void OnConnectionUpdateComplete(uint16_t conn_id, tBTA_GATTC* p_data) {
     HearingDevice* hearingDevice = hearingDevices.FindByConnId(conn_id);
     if (!hearingDevice) {
       DVLOG(2) << "Skipping unknown device, conn_id=" << loghex(conn_id);
       return;
     }
 
-    hearingDevice->connection_update_pending = false;
+    if (p_data) {
+      if ((p_data->conn_update.status == 0) &&
+          (hearingDevice->requested_connection_interval !=
+           p_data->conn_update.interval)) {
+        LOG(WARNING) << __func__ << ": Ignored. Different connection interval="
+                     << p_data->conn_update.interval << ", expected="
+                     << hearingDevice->requested_connection_interval
+                     << ", conn_id=" << conn_id;
+        return;
+      }
+      LOG(INFO) << __func__ << ": interval=" << p_data->conn_update.interval
+                << ": status=" << loghex(p_data->conn_update.status)
+                << ", conn_id=" << conn_id;
+    }
+
+    if (hearingDevice->connection_update_status != STARTED) {
+      // TODO: We may get extra connection updates during service discovery and
+      // these updates are not accounted for.
+      LOG(INFO) << __func__
+                << ": Unexpected connection update complete. Expecting "
+                   "state=STARTED but current="
+                << hearingDevice->connection_update_status
+                << ", conn_id=" << conn_id
+                << ", device=" << hearingDevice->address;
+    }
+    hearingDevice->connection_update_status = NONE;
 
     for (auto& device : hearingDevices.devices) {
-      if (device.conn_id && device.connection_update_pending) {
-        L2CA_UpdateBleConnParams(device.address, 0x0008, 0x0008, 0x000A,
-                                 0x0064 /*1s*/, MIN_CE_LEN_1M, MIN_CE_LEN_1M);
+      if (device.conn_id && (device.connection_update_status == AWAITING)) {
+        device.connection_update_status = STARTED;
+        device.requested_connection_interval =
+            UpdateBleConnParams(device.address);
         return;
       }
     }
@@ -557,6 +667,49 @@ class HearingAidImpl : public HearingAid {
     }
   }
 
+  uint16_t CalcCompressedAudioPacketSize(uint16_t codec_type,
+                                         int connection_interval) {
+    int sample_rate;
+
+    const int sample_bit_rate = 16;  /* 16 bits per sample */
+    const int compression_ratio = 4; /* G.722 has a 4:1 compression ratio */
+    if (codec_type == CODEC_G722_24KHZ) {
+      sample_rate = 24000;
+    } else {
+      sample_rate = 16000;
+    }
+
+    // compressed_data_packet_size is the size in bytes of the compressed audio
+    // data buffer that is generated for each connection interval.
+    uint32_t compressed_data_packet_size =
+        (sample_rate * connection_interval * (sample_bit_rate / 8) /
+         compression_ratio) /
+        1000;
+    return ((uint16_t)compressed_data_packet_size);
+  }
+
+  void ChooseCodec(const HearingDevice& hearingDevice) {
+    if (codec_in_use) return;
+
+    // use the best codec available for this pair of devices.
+    uint16_t codecs = hearingDevice.codecs;
+    if (hearingDevice.hi_sync_id != 0) {
+      for (const auto& device : hearingDevices.devices) {
+        if (device.hi_sync_id != hearingDevice.hi_sync_id) continue;
+
+        codecs &= device.codecs;
+      }
+    }
+
+    if ((codecs & (1 << CODEC_G722_24KHZ)) &&
+        controller_get_interface()->supports_ble_2m_phy() &&
+        default_data_interval_ms == HA_INTERVAL_10_MS) {
+      codec_in_use = CODEC_G722_24KHZ;
+    } else if (codecs & (1 << CODEC_G722_16KHZ)) {
+      codec_in_use = CODEC_G722_16KHZ;
+    }
+  }
+
   void OnAudioStatus(uint16_t conn_id, tGATT_STATUS status, uint16_t handle,
                      uint16_t len, uint8_t* value, void* data) {
     DVLOG(2) << __func__ << " " << base::HexEncode(value, len);
@@ -590,8 +743,11 @@ class HearingAidImpl : public HearingAid {
   void ConnectSocket(HearingDevice* hearingDevice) {
     tL2CAP_CFG_INFO cfg_info = tL2CAP_CFG_INFO{.mtu = 512};
 
+    uint8_t service_id = hearingDevice->isLeft()
+                             ? BTM_SEC_SERVICE_HEARING_AID_LEFT
+                             : BTM_SEC_SERVICE_HEARING_AID_RIGHT;
     uint16_t gap_handle = GAP_ConnOpen(
-        "", 0, false, &hearingDevice->address, hearingDevice->psm,
+        "", service_id, false, &hearingDevice->address, hearingDevice->psm,
         514 /* MPS */, &cfg_info, nullptr,
         BTM_SEC_NONE /* TODO: request security ? */, L2CAP_FCR_LE_COC_MODE,
         HearingAidImpl::GapCallbackStatic, BT_TRANSPORT_LE);
@@ -648,16 +804,20 @@ class HearingAidImpl : public HearingAid {
       hearingDevice->first_connection = false;
     }
 
-    SendStart(*hearingDevice);
+    ChooseCodec(*hearingDevice);
+
+    SendStart(hearingDevice);
 
     hearingDevice->accepting_audio = true;
     LOG(INFO) << __func__ << ": address=" << address
-              << ", hi_sync_id=" << loghex(hearingDevice->hi_sync_id);
+              << ", hi_sync_id=" << loghex(hearingDevice->hi_sync_id)
+              << ", codec_in_use=" << loghex(codec_in_use);
+
+    StartSendingAudio(*hearingDevice);
+
     callbacks->OnDeviceAvailable(hearingDevice->capabilities,
                                  hearingDevice->hi_sync_id, address);
     callbacks->OnConnectionState(ConnectionState::CONNECTED, address);
-
-    StartSendingAudio(*hearingDevice);
   }
 
   void StartSendingAudio(const HearingDevice& hearingDevice) {
@@ -678,40 +838,52 @@ class HearingAidImpl : public HearingAid {
         }
       }
 
-      if ((codecs & (1 << CODEC_G722_24KHZ)) &&
-          controller_get_interface()->supports_ble_2m_phy()) {
-        codec_in_use = CODEC_G722_24KHZ;
+      CodecConfiguration codec;
+      if (codec_in_use == CODEC_G722_24KHZ) {
         codec.sample_rate = 24000;
-        codec.bit_rate = 16;
-        codec.data_interval_ms = 10;
-      } else if (codecs & (1 << CODEC_G722_16KHZ)) {
-        codec_in_use = CODEC_G722_16KHZ;
+      } else {
         codec.sample_rate = 16000;
-        codec.bit_rate = 16;
-        codec.data_interval_ms = 10;
       }
+      codec.bit_rate = 16;
+      codec.data_interval_ms = default_data_interval_ms;
 
-      // TODO: remove once we implement support for other codecs
-      codec_in_use = CODEC_G722_16KHZ;
       HearingAidAudioSource::Start(codec, audioReceiver);
     }
   }
 
   void OnAudioSuspend() {
-    DVLOG(2) << __func__;
+    if (!audio_running) {
+      LOG(WARNING) << __func__ << ": Unexpected audio suspend";
+    } else {
+      LOG(INFO) << __func__ << ": audio_running=" << audio_running;
+    }
+    audio_running = false;
 
     std::vector<uint8_t> stop({CONTROL_POINT_OP_STOP});
-    for (const auto& device : hearingDevices.devices) {
+    for (auto& device : hearingDevices.devices) {
       if (!device.accepting_audio) continue;
 
-      BtaGattQueue::WriteCharacteristic(device.conn_id,
-                                        device.audio_control_point_handle, stop,
-                                        GATT_WRITE, nullptr, nullptr);
+      if (!device.playback_started) {
+        LOG(WARNING) << __func__
+                     << ": Playback not started, skip send Stop cmd, device="
+                     << device.address;
+      } else {
+        LOG(INFO) << __func__ << ": send Stop cmd, device=" << device.address;
+        device.playback_started = false;
+        BtaGattQueue::WriteCharacteristic(device.conn_id,
+                                          device.audio_control_point_handle,
+                                          stop, GATT_WRITE, nullptr, nullptr);
+      }
     }
   }
 
   void OnAudioResume() {
-    DVLOG(2) << __func__;
+    if (audio_running) {
+      LOG(ERROR) << __func__ << ": Unexpected Audio Resume";
+    } else {
+      LOG(INFO) << __func__ << ": audio_running=" << audio_running;
+    }
+    audio_running = true;
 
     // TODO: shall we also reset the encoder ?
     if (encoder_state_left != nullptr) {
@@ -722,30 +894,43 @@ class HearingAidImpl : public HearingAid {
     }
     seq_counter = 0;
 
-    for (const auto& device : hearingDevices.devices) {
+    for (auto& device : hearingDevices.devices) {
       if (!device.accepting_audio) continue;
-      SendStart(device);
+      SendStart(&device);
     }
   }
 
-  void SendStart(const HearingDevice& device) {
+  void SendStart(HearingDevice* device) {
     std::vector<uint8_t> start({CONTROL_POINT_OP_START, codec_in_use,
-                                0x02 /* media */, (uint8_t)current_volume});
+                                AUDIOTYPE_UNKNOWN, (uint8_t)current_volume});
 
-    if (current_volume == VOLUME_UNKNOWN) start[3] = (uint8_t)VOLUME_MIN;
+    if (!audio_running) {
+      if (!device->playback_started) {
+        LOG(INFO) << __func__
+                  << ": Skip Send Start since audio is not running, device="
+                  << device->address;
+      } else {
+        LOG(ERROR) << __func__
+                   << ": Audio not running but Playback has started, device="
+                   << device->address;
+      }
+      return;
+    }
 
-    BtaGattQueue::WriteCharacteristic(device.conn_id,
-                                      device.audio_control_point_handle, start,
-                                      GATT_WRITE, nullptr, nullptr);
+    if (current_volume == VOLUME_UNKNOWN) start[3] = (uint8_t)VOLUME_MIN;
 
-    // TODO(jpawlowski): this will be removed, once test devices get volume
-    // from start reqest
-    if (current_volume != VOLUME_UNKNOWN) {
-      std::vector<uint8_t> volume_value(
-          {static_cast<unsigned char>(current_volume)});
-      BtaGattQueue::WriteCharacteristic(device.conn_id, device.volume_handle,
-                                        volume_value, GATT_WRITE_NO_RSP,
-                                        nullptr, nullptr);
+    if (device->playback_started) {
+      LOG(ERROR) << __func__
+                 << ": Playback already started, skip send Start cmd, device="
+                 << device->address;
+    } else {
+      LOG(INFO) << __func__ << ": send Start cmd, volume=" << loghex(start[3])
+                << ", audio type=" << loghex(start[2])
+                << ", device=" << device->address;
+      device->playback_started = true;
+      BtaGattQueue::WriteCharacteristic(device->conn_id,
+                                        device->audio_control_point_handle,
+                                        start, GATT_WRITE, nullptr, nullptr);
     }
   }
 
@@ -760,20 +945,6 @@ class HearingAidImpl : public HearingAid {
     if (num_samples % 2 != 0)
       LOG(FATAL) << "num_samples is not even: " << num_samples;
 
-    std::vector<uint16_t> chan_left;
-    std::vector<uint16_t> chan_right;
-    // TODO: encode data into G.722 left/right or mono.
-    for (int i = 0; i < num_samples; i++) {
-      const uint8_t* sample = data.data() + i * 4;
-
-      uint16_t left = (int16_t)((*(sample + 1) << 8) + *sample) >> 1;
-      chan_left.push_back(left);
-
-      sample += 2;
-      uint16_t right = (int16_t)((*(sample + 1) << 8) + *sample) >> 1;
-      chan_right.push_back(right);
-    }
-
     // TODO: we should cache left/right and current state, instad of recomputing
     // it for each packet, 100 times a second.
     HearingDevice* left = nullptr;
@@ -793,6 +964,34 @@ class HearingAidImpl : public HearingAid {
       return;
     }
 
+    std::vector<uint16_t> chan_left;
+    std::vector<uint16_t> chan_right;
+    if (left == nullptr || right == nullptr) {
+      for (int i = 0; i < num_samples; i++) {
+        const uint8_t* sample = data.data() + i * 4;
+
+        int16_t left = (int16_t)((*(sample + 1) << 8) + *sample) >> 1;
+
+        sample += 2;
+        int16_t right = (int16_t)((*(sample + 1) << 8) + *sample) >> 1;
+
+        uint16_t mono_data = (int16_t)(((uint32_t)left + (uint32_t)right) >> 1);
+        chan_left.push_back(mono_data);
+        chan_right.push_back(mono_data);
+      }
+    } else {
+      for (int i = 0; i < num_samples; i++) {
+        const uint8_t* sample = data.data() + i * 4;
+
+        uint16_t left = (int16_t)((*(sample + 1) << 8) + *sample) >> 1;
+        chan_left.push_back(left);
+
+        sample += 2;
+        uint16_t right = (int16_t)((*(sample + 1) << 8) + *sample) >> 1;
+        chan_right.push_back(right);
+      }
+    }
+
     // TODO: monural, binarual check
 
     // divide encoded data into packets, add header, send.
@@ -802,7 +1001,9 @@ class HearingAidImpl : public HearingAid {
     // TODO: this should basically fit the encoded data, tune the size later
     std::vector<uint8_t> encoded_data_left;
     if (left) {
-      encoded_data_left.resize(2000);
+      // TODO: instead of a magic number, we need to figure out the correct
+      // buffer size
+      encoded_data_left.resize(4000);
       int encoded_size =
           g722_encode(encoder_state_left, encoded_data_left.data(),
                       (const int16_t*)chan_left.data(), chan_left.size());
@@ -822,7 +1023,9 @@ class HearingAidImpl : public HearingAid {
 
     std::vector<uint8_t> encoded_data_right;
     if (right) {
-      encoded_data_right.resize(2000);
+      // TODO: instead of a magic number, we need to figure out the correct
+      // buffer size
+      encoded_data_right.resize(4000);
       int encoded_size =
           g722_encode(encoder_state_right, encoded_data_right.data(),
                       (const int16_t*)chan_right.data(), chan_right.size());
@@ -843,15 +1046,8 @@ class HearingAidImpl : public HearingAid {
     size_t encoded_data_size =
         std::max(encoded_data_left.size(), encoded_data_right.size());
 
-    // TODO: make it also dependent on the interval, when we support intervals
-    // different than 10ms
-    uint16_t packet_size;
-
-    if (codec_in_use == CODEC_G722_24KHZ) {
-      packet_size = 120;
-    } else /* if (codec_in_use == CODEC_G722_16KHZ) */ {
-      packet_size = 80;
-    }
+    uint16_t packet_size =
+        CalcCompressedAudioPacketSize(codec_in_use, default_data_interval_ms);
 
     for (size_t i = 0; i < encoded_data_size; i += packet_size) {
       if (left) {
@@ -870,6 +1066,12 @@ class HearingAidImpl : public HearingAid {
 
   void SendAudio(uint8_t* encoded_data, uint16_t packet_size,
                  HearingDevice* hearingAid) {
+    if (!hearingAid->playback_started) {
+      LOG(INFO) << __func__
+                << ": Playback not started, device=" << hearingAid->address;
+      return;
+    }
+
     BT_HDR* audio_packet = malloc_l2cap_buf(packet_size + 1);
     uint8_t* p = get_l2cap_sdu_start_ptr(audio_packet);
     *p = seq_counter;
@@ -888,7 +1090,7 @@ class HearingAidImpl : public HearingAid {
   void GapCallback(uint16_t gap_handle, uint16_t event, tGAP_CB_DATA* data) {
     HearingDevice* hearingDevice = hearingDevices.FindByGapHandle(gap_handle);
     if (!hearingDevice) {
-      DVLOG(2) << "Skipping unknown device, gap_handle=" << gap_handle;
+      LOG(INFO) << "Skipping unknown device, gap_handle=" << gap_handle;
       return;
     }
 
@@ -904,9 +1106,12 @@ class HearingAidImpl : public HearingAid {
 
       // TODO: handle properly!
       case GAP_EVT_CONN_CLOSED:
-        DVLOG(2) << "GAP_EVT_CONN_CLOSED";
+        LOG(INFO) << __func__
+                  << ": GAP_EVT_CONN_CLOSED: " << hearingDevice->address
+                  << ", playback_started=" << hearingDevice->playback_started;
         hearingDevice->accepting_audio = false;
         hearingDevice->gap_handle = 0;
+        hearingDevice->playback_started = false;
         break;
       case GAP_EVT_CONN_DATA_AVAIL: {
         DVLOG(2) << "GAP_EVT_CONN_DATA_AVAIL";
@@ -1005,6 +1210,10 @@ class HearingAidImpl : public HearingAid {
     bool connected = hearingDevice->accepting_audio;
     hearingDevice->accepting_audio = false;
 
+    LOG(INFO) << "GAP_EVT_CONN_CLOSED: " << hearingDevice->address
+              << ", playback_started=" << hearingDevice->playback_started;
+    hearingDevice->playback_started = false;
+
     if (hearingDevice->connecting_actively) {
       // cancel pending direct connect
       BTA_GATTC_CancelOpen(gatt_if, address, true);
@@ -1022,6 +1231,8 @@ class HearingAidImpl : public HearingAid {
     // cancel autoconnect
     BTA_GATTC_CancelOpen(gatt_if, address, false);
 
+    DoDisconnectCleanUp(hearingDevice);
+
     hearingDevices.Remove(address);
 
     if (connected)
@@ -1037,14 +1248,32 @@ class HearingAidImpl : public HearingAid {
       return;
     }
 
-    hearingDevice->accepting_audio = false;
-    hearingDevice->conn_id = 0;
-
-    BtaGattQueue::Clean(conn_id);
+    DoDisconnectCleanUp(hearingDevice);
 
     callbacks->OnConnectionState(ConnectionState::DISCONNECTED, remote_bda);
   }
 
+  void DoDisconnectCleanUp(HearingDevice* hearingDevice) {
+    if (hearingDevice->connection_update_status != NONE) {
+      LOG(INFO) << __func__ << ": connection update not completed. Current="
+                << hearingDevice->connection_update_status
+                << ", device=" << hearingDevice->address;
+
+      if (hearingDevice->connection_update_status == STARTED) {
+        OnConnectionUpdateComplete(hearingDevice->conn_id, NULL);
+      }
+      hearingDevice->connection_update_status = NONE;
+    }
+
+    BtaGattQueue::Clean(hearingDevice->conn_id);
+
+    hearingDevice->accepting_audio = false;
+    hearingDevice->conn_id = 0;
+    LOG(INFO) << __func__ << ": device=" << hearingDevice->address
+              << ", playback_started=" << hearingDevice->playback_started;
+    hearingDevice->playback_started = false;
+  }
+
   void SetVolume(int8_t volume) override {
     VLOG(2) << __func__ << ": " << +volume;
     current_volume = volume;
@@ -1080,7 +1309,8 @@ class HearingAidImpl : public HearingAid {
 
   /* currently used codec */
   uint8_t codec_in_use;
-  CodecConfiguration codec;
+
+  uint16_t default_data_interval_ms;
 
   HearingDevices hearingDevices;
 };
@@ -1125,7 +1355,7 @@ void hearingaid_gattc_callback(tBTA_GATTC_EVT event, tBTA_GATTC* p_data) {
 
     case BTA_GATTC_CONN_UPDATE_EVT:
       if (!instance) return;
-      instance->OnConnectionUpdateComplete(p_data->conn_update.conn_id);
+      instance->OnConnectionUpdateComplete(p_data->conn_update.conn_id, p_data);
       break;
 
     default:
@@ -1146,12 +1376,14 @@ class HearingAidAudioReceiverImpl : public HearingAidAudioReceiver {
   void OnAudioDataReady(const std::vector<uint8_t>& data) override {
     if (instance) instance->OnAudioDataReady(data);
   }
-  void OnAudioSuspend() override {
+  void OnAudioSuspend(std::promise<void> do_suspend_promise) override {
     if (instance) instance->OnAudioSuspend();
+    do_suspend_promise.set_value();
   }
 
-  void OnAudioResume() override {
+  void OnAudioResume(std::promise<void> do_resume_promise) override {
     if (instance) instance->OnAudioResume();
+    do_resume_promise.set_value();
   }
 };
 
diff --git a/bta/hearing_aid/hearing_aid_audio_source.cc b/bta/hearing_aid/hearing_aid_audio_source.cc
index 947caaf9e..48eaea3e3 100644
--- a/bta/hearing_aid/hearing_aid_audio_source.cc
+++ b/bta/hearing_aid/hearing_aid_audio_source.cc
@@ -17,6 +17,7 @@
  ******************************************************************************/
 
 #include "audio_hearing_aid_hw/include/audio_hearing_aid_hw.h"
+#include "bta_closure_api.h"
 #include "bta_hearing_aid_api.h"
 #include "osi/include/alarm.h"
 #include "uipc.h"
@@ -28,9 +29,9 @@ using base::FilePath;
 extern const char* audio_ha_hw_dump_ctrl_event(tHEARING_AID_CTRL_CMD event);
 
 namespace {
-int bit_rate = 16;
-int sample_rate = 16000;
-int data_interval_ms = 10 /* msec */;
+int bit_rate = -1;
+int sample_rate = -1;
+int data_interval_ms = -1;
 int num_channels = 2;
 alarm_t* audio_timer = nullptr;
 
@@ -94,6 +95,11 @@ void hearing_aid_data_cb(tUIPC_CH_ID, tUIPC_EVENT event) {
       UIPC_Ioctl(*uipc_hearing_aid, UIPC_CH_ID_AV_AUDIO, UIPC_SET_READ_POLL_TMO,
                  reinterpret_cast<void*>(0));
 
+      if (data_interval_ms != HA_INTERVAL_10_MS &&
+          data_interval_ms != HA_INTERVAL_20_MS) {
+        LOG(FATAL) << " Unsupported data interval: " << data_interval_ms;
+      }
+
       audio_timer = alarm_new_periodic("hearing_aid_data_timer");
       alarm_set_on_mloop(audio_timer, data_interval_ms, send_audio_data,
                          nullptr);
@@ -124,7 +130,7 @@ void hearing_aid_recv_ctrl_data() {
     return;
   }
 
-  VLOG(2) << __func__ << " " << audio_ha_hw_dump_ctrl_event(cmd);
+  LOG(INFO) << __func__ << " " << audio_ha_hw_dump_ctrl_event(cmd);
   //  a2dp_cmd_pending = cmd;
 
   switch (cmd) {
@@ -133,7 +139,17 @@ void hearing_aid_recv_ctrl_data() {
       break;
 
     case HEARING_AID_CTRL_CMD_START:
-      if (localAudioReceiver) localAudioReceiver->OnAudioResume();
+      if (localAudioReceiver) {
+        // Call OnAudioResume and block till it returns.
+        std::promise<void> do_resume_promise;
+        std::future<void> do_resume_future = do_resume_promise.get_future();
+        do_in_bta_thread_once(
+            FROM_HERE, base::BindOnce(&HearingAidAudioReceiver::OnAudioResume,
+                                      base::Unretained(localAudioReceiver),
+                                      std::move(do_resume_promise)));
+        do_resume_future.wait();
+      }
+
       // timer is restarted in UIPC_Open
       UIPC_Open(*uipc_hearing_aid, UIPC_CH_ID_AV_AUDIO, hearing_aid_data_cb,
                 HEARING_AID_DATA_PATH);
@@ -146,7 +162,16 @@ void hearing_aid_recv_ctrl_data() {
 
     case HEARING_AID_CTRL_CMD_SUSPEND:
       if (audio_timer) alarm_cancel(audio_timer);
-      if (localAudioReceiver) localAudioReceiver->OnAudioSuspend();
+      if (localAudioReceiver) {
+        // Call OnAudioSuspend and block till it returns.
+        std::promise<void> do_suspend_promise;
+        std::future<void> do_suspend_future = do_suspend_promise.get_future();
+        do_in_bta_thread_once(
+            FROM_HERE, base::BindOnce(&HearingAidAudioReceiver::OnAudioSuspend,
+                                      base::Unretained(localAudioReceiver),
+                                      std::move(do_suspend_promise)));
+        do_suspend_future.wait();
+      }
       hearing_aid_send_ack(HEARING_AID_CTRL_ACK_SUCCESS);
       break;
 
@@ -240,8 +265,9 @@ void hearing_aid_recv_ctrl_data() {
       hearing_aid_send_ack(HEARING_AID_CTRL_ACK_FAILURE);
       break;
   }
-  VLOG(2) << __func__ << " a2dp-ctrl-cmd : " << audio_ha_hw_dump_ctrl_event(cmd)
-          << " DONE";
+  LOG(INFO) << __func__
+            << " a2dp-ctrl-cmd : " << audio_ha_hw_dump_ctrl_event(cmd)
+            << " DONE";
 }
 
 void hearing_aid_ctrl_cb(tUIPC_CH_ID, tUIPC_EVENT event) {
@@ -266,6 +292,11 @@ void HearingAidAudioSource::Start(const CodecConfiguration& codecConfiguration,
                                   HearingAidAudioReceiver* audioReceiver) {
   localAudioReceiver = audioReceiver;
   VLOG(2) << "Hearing Aid UIPC Open";
+
+  bit_rate = codecConfiguration.bit_rate;
+  sample_rate = codecConfiguration.sample_rate;
+  data_interval_ms = codecConfiguration.data_interval_ms;
+
   stats.Reset();
 }
 
diff --git a/bta/hl/bta_hl_main.cc b/bta/hl/bta_hl_main.cc
index dcd08151f..c224a76e6 100644
--- a/bta/hl/bta_hl_main.cc
+++ b/bta/hl/bta_hl_main.cc
@@ -1404,14 +1404,13 @@ static void bta_hl_sdp_query_results(UNUSED_ATTR tBTA_HL_CB* p_cb,
   tBTA_HL_MCL_CB* p_mcb = BTA_HL_GET_MCL_CB_PTR(app_idx, mcl_idx);
   tBTA_HL_SDP* p_sdp = NULL;
   uint16_t event;
-  bool release_sdp_buf = false;
 
   event = p_data->hdr.event;
 
   if (event == BTA_HL_SDP_QUERY_OK_EVT) {
+    // this is freed in btif_hl_proc_sdp_query_cfm
     p_sdp = (tBTA_HL_SDP*)osi_malloc(sizeof(tBTA_HL_SDP));
     memcpy(p_sdp, &p_mcb->sdp, sizeof(tBTA_HL_SDP));
-    release_sdp_buf = true;
   } else {
     status = BTA_HL_STATUS_SDP_FAIL;
   }
@@ -1430,8 +1429,6 @@ static void bta_hl_sdp_query_results(UNUSED_ATTR tBTA_HL_CB* p_cb,
                              p_mcb->bd_addr, p_sdp, status);
   p_acb->p_cback(BTA_HL_SDP_QUERY_CFM_EVT, (tBTA_HL*)&evt_data);
 
-  if (release_sdp_buf) osi_free_and_reset((void**)&p_sdp);
-
   if (p_data->cch_sdp.release_mcl_cb) {
     memset(p_mcb, 0, sizeof(tBTA_HL_MCL_CB));
   } else {
diff --git a/bta/include/bta_closure_api.h b/bta/include/bta_closure_api.h
index a4c0188cf..c57f07f4b 100644
--- a/bta/include/bta_closure_api.h
+++ b/bta/include/bta_closure_api.h
@@ -34,5 +34,7 @@
  */
 bt_status_t do_in_bta_thread(const tracked_objects::Location& from_here,
                              const base::Closure& task);
+bt_status_t do_in_bta_thread_once(const tracked_objects::Location& from_here,
+                                  base::OnceClosure task);
 
 #endif /* BTA_CLOSURE_API_H */
diff --git a/bta/include/bta_hearing_aid_api.h b/bta/include/bta_hearing_aid_api.h
index 96ad7e67c..659506030 100644
--- a/bta/include/bta_hearing_aid_api.h
+++ b/bta/include/bta_hearing_aid_api.h
@@ -20,15 +20,18 @@
 
 #include <base/callback_forward.h>
 #include <hardware/bt_hearing_aid.h>
+#include <future>
 
+constexpr uint16_t HA_INTERVAL_10_MS = 10;
+constexpr uint16_t HA_INTERVAL_20_MS = 20;
 
 /** Implementations of HearingAid will also implement this interface */
 class HearingAidAudioReceiver {
  public:
   virtual ~HearingAidAudioReceiver() = default;
   virtual void OnAudioDataReady(const std::vector<uint8_t>& data) = 0;
-  virtual void OnAudioSuspend();
-  virtual void OnAudioResume();
+  virtual void OnAudioSuspend(std::promise<void> do_suspend_promise);
+  virtual void OnAudioResume(std::promise<void> do_resume_promise);
 };
 
 class HearingAid {
@@ -53,6 +56,8 @@ class HearingAid {
 
   virtual void Connect(const RawAddress& address) = 0;
   virtual void Disconnect(const RawAddress& address) = 0;
+  virtual void AddToWhiteList(const RawAddress& address) = 0;
+  virtual void RemoveFromWhiteList(const RawAddress& address) = 0;
   virtual void SetVolume(int8_t volume) = 0;
 };
 
diff --git a/bta/sys/bta_sys_main.cc b/bta/sys/bta_sys_main.cc
index bdedcde78..dda3977bc 100644
--- a/bta/sys/bta_sys_main.cc
+++ b/bta/sys/bta_sys_main.cc
@@ -572,6 +572,37 @@ bt_status_t do_in_bta_thread(const tracked_objects::Location& from_here,
   return BT_STATUS_SUCCESS;
 }
 
+/*******************************************************************************
+ *
+ * Function         do_in_bta_thread_once
+ *
+ * Description      Post a closure to be ran in the bta thread once
+ *
+ * Returns          BT_STATUS_SUCCESS on success
+ *
+ ******************************************************************************/
+bt_status_t do_in_bta_thread_once(const tracked_objects::Location& from_here,
+                                  base::OnceClosure task) {
+  base::MessageLoop* bta_message_loop = get_message_loop();
+  if (!bta_message_loop) {
+    APPL_TRACE_ERROR("%s: MessageLooper not initialized", __func__);
+    return BT_STATUS_FAIL;
+  }
+
+  scoped_refptr<base::SingleThreadTaskRunner> task_runner =
+      bta_message_loop->task_runner();
+  if (!task_runner.get()) {
+    APPL_TRACE_ERROR("%s: task runner is dead", __func__);
+    return BT_STATUS_FAIL;
+  }
+
+  if (!task_runner->PostTask(from_here, std::move(task))) {
+    APPL_TRACE_ERROR("%s: Post task to task runner failed!", __func__);
+    return BT_STATUS_FAIL;
+  }
+  return BT_STATUS_SUCCESS;
+}
+
 /*******************************************************************************
  *
  * Function         bta_sys_start_timer
diff --git a/btif/include/btif_storage.h b/btif/include/btif_storage.h
index fb906737e..07d29c81a 100644
--- a/btif/include/btif_storage.h
+++ b/btif/include/btif_storage.h
@@ -201,6 +201,9 @@ void btif_storage_load_bonded_hearing_aids();
 /** Deletes the bonded hearing aid device info from NVRAM */
 void btif_storage_remove_hearing_aid(const RawAddress& address);
 
+/** Add the hearing aid device to white list */
+void btif_storage_add_hearing_aid_to_white_list(const RawAddress& address);
+
 /** Remove the hearing aid device from white list */
 void btif_storage_remove_hearing_aid_white_list(const RawAddress& address);
 
diff --git a/btif/src/btif_a2dp_source.cc b/btif/src/btif_a2dp_source.cc
index efd842b7f..78e5a4ea1 100644
--- a/btif/src/btif_a2dp_source.cc
+++ b/btif/src/btif_a2dp_source.cc
@@ -529,7 +529,8 @@ static void btif_a2dp_source_end_session_delayed(
     BluetoothMetricsLogger::GetInstance()->LogBluetoothSessionEnd(
         system_bt_osi::DISCONNECT_REASON_UNKNOWN, 0);
   }
-  if (btif_a2dp_source_cb.State() == BtifA2dpSource::kStateRunning) {
+  if ((btif_a2dp_source_cb.State() == BtifA2dpSource::kStateRunning) ||
+      (btif_a2dp_source_cb.State() == BtifA2dpSource::kStateShuttingDown)) {
     btif_av_stream_stop(peer_address);
   } else {
     LOG_ERROR(LOG_TAG, "%s: A2DP Source media task is not running", __func__);
diff --git a/btif/src/btif_hearing_aid.cc b/btif/src/btif_hearing_aid.cc
index 48aab95ee..74db790e1 100644
--- a/btif/src/btif_hearing_aid.cc
+++ b/btif/src/btif_hearing_aid.cc
@@ -95,6 +95,22 @@ class HearingAidInterfaceImpl
         FROM_HERE, Bind(&btif_storage_remove_hearing_aid_white_list, address));
   }
 
+  void AddToWhiteList(const RawAddress& address) override {
+    DVLOG(2) << __func__ << " address: " << address;
+    do_in_bta_thread(FROM_HERE, Bind(&HearingAid::AddToWhiteList,
+                                     Unretained(HearingAid::Get()), address));
+    do_in_jni_thread(
+        FROM_HERE, Bind(&btif_storage_add_hearing_aid_to_white_list, address));
+  }
+
+  void RemoveFromWhiteList(const RawAddress& address) override {
+    DVLOG(2) << __func__ << " address: " << address;
+    do_in_bta_thread(FROM_HERE, Bind(&HearingAid::RemoveFromWhiteList,
+                                     Unretained(HearingAid::Get()), address));
+    do_in_jni_thread(
+        FROM_HERE, Bind(&btif_storage_remove_hearing_aid_white_list, address));
+  }
+
   void SetVolume(int8_t volume) override {
     DVLOG(2) << __func__ << " volume: " << +volume;
     do_in_bta_thread(FROM_HERE, Bind(&HearingAid::SetVolume,
diff --git a/btif/src/btif_hl.cc b/btif/src/btif_hl.cc
index a317f7955..184dbf4eb 100644
--- a/btif/src/btif_hl.cc
+++ b/btif/src/btif_hl.cc
@@ -2128,6 +2128,10 @@ static bool btif_hl_proc_sdp_query_cfm(tBTA_HL* p_data) {
       }
     }
   }
+
+  // this was allocated in bta_hl_sdp_query_results
+  osi_free_and_reset((void**)&p_data->sdp_query_cfm.p_sdp);
+
   return status;
 }
 
diff --git a/btif/src/btif_storage.cc b/btif/src/btif_storage.cc
index 13dd58de7..f64875ee6 100644
--- a/btif/src/btif_storage.cc
+++ b/btif/src/btif_storage.cc
@@ -1479,6 +1479,13 @@ void btif_storage_remove_hearing_aid(const RawAddress& address) {
   btif_config_save();
 }
 
+/** Add the hearing aid device to white list */
+void btif_storage_add_hearing_aid_to_white_list(const RawAddress& address) {
+  std::string addrstr = address.ToString();
+
+  btif_config_set_int(addrstr, HEARING_AID_IS_WHITE_LISTED, true);
+}
+
 /** Remove the hearing aid device from white list */
 void btif_storage_remove_hearing_aid_white_list(const RawAddress& address) {
   std::string addrstr = address.ToString();
diff --git a/include/hardware/bt_hearing_aid.h b/include/hardware/bt_hearing_aid.h
index a54f82aea..7ab0dc757 100644
--- a/include/hardware/bt_hearing_aid.h
+++ b/include/hardware/bt_hearing_aid.h
@@ -59,6 +59,12 @@ class HearingAidInterface {
   /** Disconnect from Hearing Aid */
   virtual void Disconnect(const RawAddress& address) = 0;
 
+  /** Add a hearing aid device to white list */
+  virtual void AddToWhiteList(const RawAddress& address) = 0;
+
+  /** Remove a hearing aid device from white list */
+  virtual void RemoveFromWhiteList(const RawAddress& address) = 0;
+
   /** Set the volume */
   virtual void SetVolume(int8_t volume) = 0;
 
diff --git a/profile/avrcp/device.cc b/profile/avrcp/device.cc
index 9a31ef3f6..9b25fac03 100644
--- a/profile/avrcp/device.cc
+++ b/profile/avrcp/device.cc
@@ -194,21 +194,18 @@ void Device::HandleNotification(
 
   switch (pkt->GetEventRegistered()) {
     case Event::TRACK_CHANGED: {
-      track_changed_ = Notification(true, label);
       media_interface_->GetNowPlayingList(
           base::Bind(&Device::TrackChangedNotificationResponse,
                      weak_ptr_factory_.GetWeakPtr(), label, true));
     } break;
 
     case Event::PLAYBACK_STATUS_CHANGED: {
-      play_status_changed_ = Notification(true, label);
       media_interface_->GetPlayStatus(
           base::Bind(&Device::PlaybackStatusNotificationResponse,
                      weak_ptr_factory_.GetWeakPtr(), label, true));
     } break;
 
     case Event::PLAYBACK_POS_CHANGED: {
-      play_pos_changed_ = Notification(true, label);
       play_pos_interval_ = pkt->GetInterval();
       media_interface_->GetPlayStatus(
           base::Bind(&Device::PlaybackPosNotificationResponse,
@@ -216,13 +213,15 @@ void Device::HandleNotification(
     } break;
 
     case Event::NOW_PLAYING_CONTENT_CHANGED: {
-      now_playing_changed_ = Notification(true, label);
-      media_interface_->GetNowPlayingList(base::Bind(
-          &Device::HandleNowPlayingNotificationResponse,
-          weak_ptr_factory_.GetWeakPtr(), now_playing_changed_.second, true));
+      media_interface_->GetNowPlayingList(
+          base::Bind(&Device::HandleNowPlayingNotificationResponse,
+                     weak_ptr_factory_.GetWeakPtr(), label, true));
     } break;
 
     case Event::AVAILABLE_PLAYERS_CHANGED: {
+      // TODO (apanicke): If we make a separate handler function for this, make
+      // sure to register the notification in the interim response.
+
       // Respond immediately since this notification doesn't require any info
       avail_players_changed_ = Notification(true, label);
       auto response =
@@ -232,13 +231,15 @@ void Device::HandleNotification(
     } break;
 
     case Event::ADDRESSED_PLAYER_CHANGED: {
-      addr_player_changed_ = Notification(true, label);
       media_interface_->GetMediaPlayerList(
           base::Bind(&Device::AddressedPlayerNotificationResponse,
                      weak_ptr_factory_.GetWeakPtr(), label, true));
     } break;
 
     case Event::UIDS_CHANGED: {
+      // TODO (apanicke): If we make a separate handler function for this, make
+      // sure to register the notification in the interim response.
+
       // Respond immediately since this notification doesn't require any info
       uids_changed_ = Notification(true, label);
       auto response =
@@ -351,7 +352,9 @@ void Device::TrackChangedNotificationResponse(uint8_t label, bool interim,
   DEVICE_VLOG(1) << __func__;
   uint64_t uid = 0;
 
-  if (!track_changed_.first) {
+  if (interim) {
+    track_changed_ = Notification(true, label);
+  } else if (!track_changed_.first) {
     DEVICE_VLOG(0) << __func__ << ": Device not registered for update";
     return;
   }
@@ -391,7 +394,9 @@ void Device::PlaybackStatusNotificationResponse(uint8_t label, bool interim,
   DEVICE_VLOG(1) << __func__;
   if (status.state == PlayState::PAUSED) play_pos_update_cb_.Cancel();
 
-  if (!play_status_changed_.first) {
+  if (interim) {
+    play_status_changed_ = Notification(true, label);
+  } else if (!play_status_changed_.first) {
     DEVICE_VLOG(0) << __func__ << ": Device not registered for update";
     return;
   }
@@ -422,7 +427,9 @@ void Device::PlaybackPosNotificationResponse(uint8_t label, bool interim,
                                              PlayStatus status) {
   DEVICE_VLOG(4) << __func__;
 
-  if (!play_pos_changed_.first) {
+  if (interim) {
+    play_pos_changed_ = Notification(true, label);
+  } else if (!play_pos_changed_.first) {
     DEVICE_VLOG(3) << __func__ << ": Device not registered for update";
     return;
   }
@@ -465,6 +472,14 @@ void Device::AddressedPlayerNotificationResponse(
     std::vector<MediaPlayerInfo> /* unused */) {
   DEVICE_VLOG(1) << __func__
                  << ": curr_player_id=" << (unsigned int)curr_player;
+
+  if (interim) {
+    addr_player_changed_ = Notification(true, label);
+  } else if (!addr_player_changed_.first) {
+    DEVICE_VLOG(3) << __func__ << ": Device not registered for update";
+    return;
+  }
+
   // If there is no set browsed player, use the current addressed player as the
   // default NOTE: Using any browsing commands before the browsed player is set
   // is a violation of the AVRCP Spec but there are some carkits that try too
@@ -1184,7 +1199,9 @@ void Device::HandleNowPlayingUpdate() {
 void Device::HandleNowPlayingNotificationResponse(
     uint8_t label, bool interim, std::string curr_song_id,
     std::vector<SongInfo> song_list) {
-  if (!now_playing_changed_.first) {
+  if (interim) {
+    now_playing_changed_ = Notification(true, label);
+  } else if (!now_playing_changed_.first) {
     LOG(WARNING) << "Device is not registered for now playing updates";
     return;
   }
diff --git a/profile/avrcp/tests/avrcp_device_test.cc b/profile/avrcp/tests/avrcp_device_test.cc
index 56f03e4f4..1a9f29a70 100644
--- a/profile/avrcp/tests/avrcp_device_test.cc
+++ b/profile/avrcp/tests/avrcp_device_test.cc
@@ -45,6 +45,7 @@ using ::testing::MockFunction;
 using ::testing::Mock;
 using ::testing::NiceMock;
 using ::testing::Return;
+using ::testing::SaveArg;
 
 bool get_pts_avrcp_test(void) { return false; }
 
@@ -189,7 +190,9 @@ TEST_F(AvrcpDeviceTest, playPositionTest) {
 
   test_device->RegisterInterfaces(&interface, &a2dp_interface, nullptr);
 
-  PlayStatus status1 = {0x1234, 0x5678, PlayState::PLAYING};
+  // TODO (apanicke): Add an underlying message loop so we can test the playing
+  // state.
+  PlayStatus status1 = {0x1234, 0x5678, PlayState::PAUSED};
   PlayStatus status2 = {0x5678, 0x9ABC, PlayState::STOPPED};
 
   EXPECT_CALL(interface, GetPlayStatus(_))
@@ -201,28 +204,311 @@ TEST_F(AvrcpDeviceTest, playPositionTest) {
   EXPECT_CALL(a2dp_interface, active_peer())
       .WillRepeatedly(Return(test_device->GetAddress()));
 
-  // Test the interim response for play status changed
+  // Test the interim response for play position changed
   auto interim_response =
-      RegisterNotificationResponseBuilder::MakePlaybackStatusBuilder(
-          true, PlayState::PLAYING);
+      RegisterNotificationResponseBuilder::MakePlaybackPositionBuilder(true,
+                                                                       0x1234);
   EXPECT_CALL(response_cb,
               Call(1, false, matchPacket(std::move(interim_response))))
       .Times(1);
 
   auto request = RegisterNotificationRequestBuilder::MakeBuilder(
-      Event::PLAYBACK_STATUS_CHANGED, 0);
+      Event::PLAYBACK_POS_CHANGED, 0);
   auto pkt = TestAvrcpPacket::Make();
   request->Serialize(pkt);
   SendMessage(1, pkt);
 
-  // Test the changed response for play status changed
+  // Test the changed response for play position changed
+  auto changed_response =
+      RegisterNotificationResponseBuilder::MakePlaybackPositionBuilder(false,
+                                                                       0x5678);
+  EXPECT_CALL(response_cb,
+              Call(1, false, matchPacket(std::move(changed_response))))
+      .Times(1);
+  test_device->HandlePlayPosUpdate();
+}
+
+TEST_F(AvrcpDeviceTest, trackChangedBeforeInterimTest) {
+  MockMediaInterface interface;
+  NiceMock<MockA2dpInterface> a2dp_interface;
+
+  test_device->RegisterInterfaces(&interface, &a2dp_interface, nullptr);
+
+  // Pretend the device is active
+  EXPECT_CALL(a2dp_interface, active_peer())
+      .WillRepeatedly(Return(test_device->GetAddress()));
+
+  SongInfo info = {"test_id",
+                   {// The attribute map
+                    AttributeEntry(Attribute::TITLE, "Test Song"),
+                    AttributeEntry(Attribute::ARTIST_NAME, "Test Artist"),
+                    AttributeEntry(Attribute::ALBUM_NAME, "Test Album"),
+                    AttributeEntry(Attribute::TRACK_NUMBER, "1"),
+                    AttributeEntry(Attribute::TOTAL_NUMBER_OF_TRACKS, "2"),
+                    AttributeEntry(Attribute::GENRE, "Test Genre"),
+                    AttributeEntry(Attribute::PLAYING_TIME, "1000")}};
+  std::vector<SongInfo> list = {info};
+
+  MediaInterface::NowPlayingCallback interim_cb;
+  MediaInterface::NowPlayingCallback changed_cb;
+
+  EXPECT_CALL(interface, GetNowPlayingList(_))
+      .Times(2)
+      .WillOnce(SaveArg<0>(&interim_cb))
+      .WillOnce(SaveArg<0>(&changed_cb));
+
+  // Test that the changed response doesn't get sent before the interim
+  ::testing::InSequence s;
+  auto interim_response =
+      RegisterNotificationResponseBuilder::MakeTrackChangedBuilder(true, 0x01);
+  EXPECT_CALL(response_cb,
+              Call(1, false, matchPacket(std::move(interim_response))))
+      .Times(1);
+  auto changed_response =
+      RegisterNotificationResponseBuilder::MakeTrackChangedBuilder(false, 0x01);
+  EXPECT_CALL(response_cb,
+              Call(1, false, matchPacket(std::move(changed_response))))
+      .Times(1);
+
+  // Register for the update, sets interim_cb
+  auto request =
+      RegisterNotificationRequestBuilder::MakeBuilder(Event::TRACK_CHANGED, 0);
+  auto pkt = TestAvrcpPacket::Make();
+  request->Serialize(pkt);
+  SendMessage(1, pkt);
+
+  // Try to send track changed update, should fail and do nothing
+  test_device->HandleTrackUpdate();
+
+  // Send the interim response
+  interim_cb.Run("test_id", list);
+
+  // Try to send track changed update, should succeed
+  test_device->HandleTrackUpdate();
+  changed_cb.Run("test_id", list);
+}
+
+TEST_F(AvrcpDeviceTest, playStatusChangedBeforeInterimTest) {
+  MockMediaInterface interface;
+  NiceMock<MockA2dpInterface> a2dp_interface;
+
+  // Pretend the device is active
+  EXPECT_CALL(a2dp_interface, active_peer())
+      .WillRepeatedly(Return(test_device->GetAddress()));
+
+  test_device->RegisterInterfaces(&interface, &a2dp_interface, nullptr);
+
+  MediaInterface::PlayStatusCallback interim_cb;
+  MediaInterface::PlayStatusCallback changed_cb;
+
+  EXPECT_CALL(interface, GetPlayStatus(_))
+      .Times(2)
+      .WillOnce(SaveArg<0>(&interim_cb))
+      .WillOnce(SaveArg<0>(&changed_cb));
+
+  // Test that the changed response doesn't get sent before the interim
+  ::testing::InSequence s;
+  auto interim_response =
+      RegisterNotificationResponseBuilder::MakePlaybackStatusBuilder(
+          true, PlayState::PLAYING);
+  EXPECT_CALL(response_cb,
+              Call(1, false, matchPacket(std::move(interim_response))))
+      .Times(1);
   auto changed_response =
       RegisterNotificationResponseBuilder::MakePlaybackStatusBuilder(
           false, PlayState::STOPPED);
   EXPECT_CALL(response_cb,
               Call(1, false, matchPacket(std::move(changed_response))))
       .Times(1);
+
+  // Send the registration packet
+  auto request = RegisterNotificationRequestBuilder::MakeBuilder(
+      Event::PLAYBACK_STATUS_CHANGED, 0);
+  auto pkt = TestAvrcpPacket::Make();
+  request->Serialize(pkt);
+  SendMessage(1, pkt);
+
+  // Send a play status update, should be ignored since the interim response
+  // hasn't been sent yet.
+  test_device->HandlePlayStatusUpdate();
+
+  // Send the interim response.
+  PlayStatus status1 = {0x1234, 0x5678, PlayState::PLAYING};
+  interim_cb.Run(status1);
+
+  // Send the changed response, should succeed this time
   test_device->HandlePlayStatusUpdate();
+  PlayStatus status2 = {0x1234, 0x5678, PlayState::STOPPED};
+  changed_cb.Run(status2);
+}
+
+TEST_F(AvrcpDeviceTest, playPositionChangedBeforeInterimTest) {
+  MockMediaInterface interface;
+  NiceMock<MockA2dpInterface> a2dp_interface;
+
+  // Pretend the device is active
+  EXPECT_CALL(a2dp_interface, active_peer())
+      .WillRepeatedly(Return(test_device->GetAddress()));
+
+  test_device->RegisterInterfaces(&interface, &a2dp_interface, nullptr);
+
+  MediaInterface::PlayStatusCallback interim_cb;
+  MediaInterface::PlayStatusCallback changed_cb;
+
+  EXPECT_CALL(interface, GetPlayStatus(_))
+      .Times(2)
+      .WillOnce(SaveArg<0>(&interim_cb))
+      .WillOnce(SaveArg<0>(&changed_cb));
+
+  // Test that the changed response doesn't get sent before the interim
+  ::testing::InSequence s;
+  auto interim_response =
+      RegisterNotificationResponseBuilder::MakePlaybackPositionBuilder(true,
+                                                                       0x1234);
+  EXPECT_CALL(response_cb,
+              Call(1, false, matchPacket(std::move(interim_response))))
+      .Times(1);
+  auto changed_response =
+      RegisterNotificationResponseBuilder::MakePlaybackPositionBuilder(false,
+                                                                       0x5678);
+  EXPECT_CALL(response_cb,
+              Call(1, false, matchPacket(std::move(changed_response))))
+      .Times(1);
+
+  // Send the registration packet
+  auto request = RegisterNotificationRequestBuilder::MakeBuilder(
+      Event::PLAYBACK_POS_CHANGED, 0);
+  auto pkt = TestAvrcpPacket::Make();
+  request->Serialize(pkt);
+  SendMessage(1, pkt);
+
+  // Send a play position update, should be ignored since the notification
+  // isn't registered since no interim response has been sent.
+  test_device->HandlePlayPosUpdate();
+
+  // Run the interim callback for GetPlayStatus which should be pointing to the
+  // GetPlayStatus call made by the update.
+  PlayStatus status1 = {0x1234, 0x5678, PlayState::PAUSED};
+  interim_cb.Run(status1);
+
+  // Send a play position update, this one should succeed.
+  test_device->HandlePlayPosUpdate();
+  PlayStatus status2 = {0x5678, 0x9ABC, PlayState::STOPPED};
+  changed_cb.Run(status2);
+}
+
+TEST_F(AvrcpDeviceTest, nowPlayingChangedBeforeInterim) {
+  MockMediaInterface interface;
+  NiceMock<MockA2dpInterface> a2dp_interface;
+
+  test_device->RegisterInterfaces(&interface, &a2dp_interface, nullptr);
+
+  SongInfo info = {"test_id",
+                   {// The attribute map
+                    AttributeEntry(Attribute::TITLE, "Test Song"),
+                    AttributeEntry(Attribute::ARTIST_NAME, "Test Artist"),
+                    AttributeEntry(Attribute::ALBUM_NAME, "Test Album"),
+                    AttributeEntry(Attribute::TRACK_NUMBER, "1"),
+                    AttributeEntry(Attribute::TOTAL_NUMBER_OF_TRACKS, "2"),
+                    AttributeEntry(Attribute::GENRE, "Test Genre"),
+                    AttributeEntry(Attribute::PLAYING_TIME, "1000")}};
+  std::vector<SongInfo> list = {info};
+
+  MediaInterface::NowPlayingCallback interim_cb;
+  MediaInterface::NowPlayingCallback changed_cb;
+
+  EXPECT_CALL(interface, GetNowPlayingList(_))
+      .Times(2)
+      .WillOnce(SaveArg<0>(&interim_cb))
+      .WillOnce(SaveArg<0>(&changed_cb));
+
+  // Test that the changed response doesn't get sent before the interim
+  ::testing::InSequence s;
+  auto interim_response =
+      RegisterNotificationResponseBuilder::MakeNowPlayingBuilder(true);
+  EXPECT_CALL(response_cb,
+              Call(1, false, matchPacket(std::move(interim_response))))
+      .Times(1);
+  auto changed_response =
+      RegisterNotificationResponseBuilder::MakeNowPlayingBuilder(false);
+  EXPECT_CALL(response_cb,
+              Call(1, false, matchPacket(std::move(changed_response))))
+      .Times(1);
+
+  // Send the registration packet
+  auto request = RegisterNotificationRequestBuilder::MakeBuilder(
+      Event::NOW_PLAYING_CONTENT_CHANGED, 0);
+  auto pkt = TestAvrcpPacket::Make();
+  request->Serialize(pkt);
+  SendMessage(1, pkt);
+
+  // Send now playing changed, should fail since the interim response hasn't
+  // been sent
+  test_device->HandleNowPlayingUpdate();
+
+  // Send the data needed for the interim response
+  interim_cb.Run("test_id", list);
+
+  // Send now playing changed, should succeed
+  test_device->HandleNowPlayingUpdate();
+  changed_cb.Run("test_id", list);
+}
+
+TEST_F(AvrcpDeviceTest, addressPlayerChangedBeforeInterim) {
+  MockMediaInterface interface;
+  NiceMock<MockA2dpInterface> a2dp_interface;
+
+  test_device->RegisterInterfaces(&interface, &a2dp_interface, nullptr);
+
+  MediaInterface::MediaListCallback interim_cb;
+  MediaInterface::MediaListCallback changed_cb;
+
+  EXPECT_CALL(interface, GetMediaPlayerList(_))
+      .Times(2)
+      .WillOnce(SaveArg<0>(&interim_cb))
+      .WillOnce(SaveArg<0>(&changed_cb));
+
+  // Test that the changed response doesn't get sent before the interim
+  ::testing::InSequence s;
+  auto interim_response =
+      RegisterNotificationResponseBuilder::MakeAddressedPlayerBuilder(true, 0,
+                                                                      0);
+  EXPECT_CALL(response_cb,
+              Call(1, false, matchPacket(std::move(interim_response))))
+      .Times(1);
+  auto changed_response =
+      RegisterNotificationResponseBuilder::MakeAddressedPlayerBuilder(false, 0,
+                                                                      0);
+  EXPECT_CALL(response_cb,
+              Call(1, false, matchPacket(std::move(changed_response))))
+      .Times(1);
+  // TODO (apanicke): Remove this expectation once b/110957802 is fixed and
+  // we don't try to reject notifications that aren't registered.
+  auto rejected_response = RejectBuilder::MakeBuilder(
+      CommandPdu::REGISTER_NOTIFICATION, Status::ADDRESSED_PLAYER_CHANGED);
+  EXPECT_CALL(response_cb,
+              Call(_, false, matchPacket(std::move(rejected_response))))
+      .Times(4);
+
+  // Send the registration packet
+  auto request = RegisterNotificationRequestBuilder::MakeBuilder(
+      Event::ADDRESSED_PLAYER_CHANGED, 0);
+  auto pkt = TestAvrcpPacket::Make();
+  request->Serialize(pkt);
+  SendMessage(1, pkt);
+
+  // Send addressed player update, should fail since the interim response
+  // hasn't been sent
+  test_device->HandleAddressedPlayerUpdate();
+
+  // Send the data needed for the interim response
+  MediaPlayerInfo info = {0, "Test Player", true};
+  std::vector<MediaPlayerInfo> list = {info};
+  interim_cb.Run(0, list);
+
+  // Send addressed player update, should succeed
+  test_device->HandleAddressedPlayerUpdate();
+  changed_cb.Run(0, list);
 }
 
 TEST_F(AvrcpDeviceTest, nowPlayingTest) {
diff --git a/stack/avrc/avrc_pars_ct.cc b/stack/avrc/avrc_pars_ct.cc
index a7a42a599..2b7761810 100644
--- a/stack/avrc/avrc_pars_ct.cc
+++ b/stack/avrc/avrc_pars_ct.cc
@@ -220,69 +220,88 @@ static tAVRC_STS avrc_pars_browse_rsp(tAVRC_MSG_BROWSE* p_msg,
   uint8_t* p = p_msg->p_browse_data;
 
   /* read the pdu */
+  if (p_msg->browse_len < 3) {
+    android_errorWriteLog(0x534e4554, "111451066");
+    AVRC_TRACE_WARNING("%s: message length %d too short: must be at least 3",
+                       __func__, p_msg->browse_len);
+    return AVRC_STS_BAD_PARAM;
+  }
   BE_STREAM_TO_UINT8(pdu, p);
   uint16_t pkt_len;
+  int min_len = 0;
   /* read the entire packet len */
   BE_STREAM_TO_UINT16(pkt_len, p);
 
-  AVRC_TRACE_DEBUG("%s pdu %d", __func__, pdu);
+  AVRC_TRACE_DEBUG("%s pdu:%d, pkt_len:%d", __func__, pdu, pkt_len);
 
-  /* used to track how much we have read, if we cannot read anymore but the
-   * packet says so then we have a malformed packet. Also vice versa. */
-  uint16_t pkt_len_read = 0;
+  if (p_msg->browse_len < (pkt_len + 3)) {
+    android_errorWriteLog(0x534e4554, "111451066");
+    AVRC_TRACE_WARNING("%s: message length %d too short: must be at least %d",
+                       __func__, p_msg->browse_len, pkt_len + 3);
+    return AVRC_STS_INTERNAL_ERR;
+  }
 
   switch (pdu) {
     case AVRC_PDU_GET_FOLDER_ITEMS: {
       tAVRC_GET_ITEMS_RSP* get_item_rsp = &(p_rsp->get_items);
       /* Copy back the PDU */
       get_item_rsp->pdu = pdu;
+
+      min_len += 1;
+      if (pkt_len < min_len) goto browse_length_error;
       /* read the status */
       BE_STREAM_TO_UINT8(get_item_rsp->status, p);
+      if (get_item_rsp->status != AVRC_STS_NO_ERROR) {
+        AVRC_TRACE_WARNING("%s returning error %d", __func__,
+                           get_item_rsp->status);
+        return get_item_rsp->status;
+      }
+
+      min_len += 4;
+      if (pkt_len < min_len) goto browse_length_error;
       /* read the UID counter */
       BE_STREAM_TO_UINT16(get_item_rsp->uid_counter, p);
       /* read the number of items */
       BE_STREAM_TO_UINT16(get_item_rsp->item_count, p);
-      pkt_len_read += 5;
 
       AVRC_TRACE_DEBUG(
           "%s pdu %d status %d pkt_len %d uid counter %d item count %d",
           __func__, get_item_rsp->pdu, get_item_rsp->status, pkt_len,
           get_item_rsp->uid_counter, get_item_rsp->item_count);
 
-      if (get_item_rsp->status != AVRC_STS_NO_ERROR) {
-        AVRC_TRACE_WARNING("%s returning error %d", __func__,
-                           get_item_rsp->status);
-        return get_item_rsp->status;
-      }
-
       /* get each of the items */
       get_item_rsp->p_item_list = (tAVRC_ITEM*)osi_malloc(
           get_item_rsp->item_count * (sizeof(tAVRC_ITEM)));
       tAVRC_ITEM* curr_item = get_item_rsp->p_item_list;
       for (int i = 0; i < get_item_rsp->item_count; i++) {
+        min_len += 1;
+        if (pkt_len < min_len) goto browse_length_error;
         BE_STREAM_TO_UINT8(curr_item->item_type, p);
-        pkt_len_read += 1;
         AVRC_TRACE_DEBUG("%s item type %d", __func__, curr_item->item_type);
         switch (curr_item->item_type) {
           case AVRC_ITEM_PLAYER: {
             /* Handle player */
             tAVRC_ITEM_PLAYER* player = &(curr_item->u.player);
             uint8_t player_len;
+            min_len += 10 + AVRC_FEATURE_MASK_SIZE;
+            if (pkt_len < min_len) goto browse_length_error;
             BE_STREAM_TO_UINT16(player_len, p);
             BE_STREAM_TO_UINT16(player->player_id, p);
             BE_STREAM_TO_UINT8(player->major_type, p);
             BE_STREAM_TO_UINT32(player->sub_type, p);
             BE_STREAM_TO_UINT8(player->play_status, p);
             BE_STREAM_TO_ARRAY(p, player->features, AVRC_FEATURE_MASK_SIZE);
-            pkt_len_read += (10 + AVRC_FEATURE_MASK_SIZE);
 
             /* read str */
+            min_len += 4;
+            if (pkt_len < min_len) goto browse_length_error;
             BE_STREAM_TO_UINT16(player->name.charset_id, p);
             BE_STREAM_TO_UINT16(player->name.str_len, p);
+            min_len += player->name.str_len;
+            if (pkt_len < min_len) goto browse_length_error;
             player->name.p_str = (uint8_t*)osi_malloc(
                 (player->name.str_len + 1) * sizeof(uint8_t));
             BE_STREAM_TO_ARRAY(p, player->name.p_str, player->name.str_len);
-            pkt_len_read += (4 + player->name.str_len);
             AVRC_TRACE_DEBUG(
                 "%s type %d id %d mtype %d stype %d ps %d cs %d name len %d",
                 __func__, curr_item->item_type, player->player_id,
@@ -293,20 +312,24 @@ static tAVRC_STS avrc_pars_browse_rsp(tAVRC_MSG_BROWSE* p_msg,
           case AVRC_ITEM_FOLDER: {
             tAVRC_ITEM_FOLDER* folder = &(curr_item->u.folder);
             uint16_t folder_len;
+            min_len += 4 + AVRC_UID_SIZE;
+            if (pkt_len < min_len) goto browse_length_error;
             BE_STREAM_TO_UINT16(folder_len, p);
 
             BE_STREAM_TO_ARRAY(p, folder->uid, AVRC_UID_SIZE);
             BE_STREAM_TO_UINT8(folder->type, p);
             BE_STREAM_TO_UINT8(folder->playable, p);
-            pkt_len_read += (4 + AVRC_UID_SIZE);
 
             /* read str, encoding to be handled by upper layers */
+            min_len += 4;
+            if (pkt_len < min_len) goto browse_length_error;
             BE_STREAM_TO_UINT16(folder->name.charset_id, p);
             BE_STREAM_TO_UINT16(folder->name.str_len, p);
+            min_len += folder->name.str_len;
+            if (pkt_len < min_len) goto browse_length_error;
             folder->name.p_str = (uint8_t*)osi_malloc(
                 (folder->name.str_len + 1) * sizeof(uint8_t));
             BE_STREAM_TO_ARRAY(p, folder->name.p_str, folder->name.str_len);
-            pkt_len_read += (4 + folder->name.str_len);
             AVRC_TRACE_DEBUG("%s type %d playable %d cs %d name len %d",
                              __func__, folder->type, folder->playable,
                              folder->name.charset_id, folder->name.str_len);
@@ -315,14 +338,19 @@ static tAVRC_STS avrc_pars_browse_rsp(tAVRC_MSG_BROWSE* p_msg,
           case AVRC_ITEM_MEDIA: {
             tAVRC_ITEM_MEDIA* media = &(curr_item->u.media);
             uint8_t media_len;
+            min_len += 3 + AVRC_UID_SIZE;
+            if (pkt_len < min_len) goto browse_length_error;
             BE_STREAM_TO_UINT16(media_len, p);
             BE_STREAM_TO_ARRAY(p, media->uid, AVRC_UID_SIZE);
             BE_STREAM_TO_UINT8(media->type, p);
-            pkt_len_read += (3 + AVRC_UID_SIZE);
 
             /* read str, encoding to be handled by upper layers */
+            min_len += 4;
+            if (pkt_len < min_len) goto browse_length_error;
             BE_STREAM_TO_UINT16(media->name.charset_id, p);
             BE_STREAM_TO_UINT16(media->name.str_len, p);
+            min_len += 1 + media->name.str_len;
+            if (pkt_len < min_len) goto browse_length_error;
             media->name.p_str =
                 (uint8_t*)osi_malloc((media->name.str_len) * sizeof(uint8_t));
             BE_STREAM_TO_ARRAY(p, media->name.p_str, media->name.str_len);
@@ -331,22 +359,24 @@ static tAVRC_STS avrc_pars_browse_rsp(tAVRC_MSG_BROWSE* p_msg,
             AVRC_TRACE_DEBUG("%s media type %d charset id %d len %d attr ct %d",
                              __func__, media->type, media->name.charset_id,
                              media->name.str_len, media->attr_count);
-            pkt_len_read += (5 + media->name.str_len);
 
             media->p_attr_list = (tAVRC_ATTR_ENTRY*)osi_malloc(
                 media->attr_count * sizeof(tAVRC_ATTR_ENTRY));
             for (int jk = 0; jk < media->attr_count; jk++) {
               tAVRC_ATTR_ENTRY* attr_entry = &(media->p_attr_list[jk]);
+              min_len += 8;
+              if (pkt_len < min_len) goto browse_length_error;
               BE_STREAM_TO_UINT32(attr_entry->attr_id, p);
 
               /* Parse the name now */
               BE_STREAM_TO_UINT16(attr_entry->name.charset_id, p);
               BE_STREAM_TO_UINT16(attr_entry->name.str_len, p);
+              min_len += attr_entry->name.str_len;
+              if (pkt_len < min_len) goto browse_length_error;
               attr_entry->name.p_str = (uint8_t*)osi_malloc(
                   attr_entry->name.str_len * sizeof(uint8_t));
               BE_STREAM_TO_ARRAY(p, attr_entry->name.p_str,
                                  attr_entry->name.str_len);
-              pkt_len_read += (8 + attr_entry->name.str_len);
               AVRC_TRACE_DEBUG("%s media attr id %d cs %d name len %d",
                                __func__, attr_entry->attr_id,
                                attr_entry->name.charset_id,
@@ -360,14 +390,8 @@ static tAVRC_STS avrc_pars_browse_rsp(tAVRC_MSG_BROWSE* p_msg,
             return AVRC_STS_INTERNAL_ERR;
         }
 
-        /* we check if we have overrun */
-        if (pkt_len_read > pkt_len) {
-          AVRC_TRACE_ERROR("%s overflow in read pkt_len %d pkt_len_read %d",
-                           __func__, pkt_len, pkt_len_read);
-          return AVRC_STS_BAD_CMD;
-        }
-        AVRC_TRACE_DEBUG("%s pkt_len %d pkt_len_read %d", __func__, pkt_len,
-                         pkt_len_read);
+        AVRC_TRACE_DEBUG("%s pkt_len %d min_len %d", __func__, pkt_len,
+                         min_len);
 
         /* advance to populate the next item */
         curr_item++;
@@ -377,13 +401,14 @@ static tAVRC_STS avrc_pars_browse_rsp(tAVRC_MSG_BROWSE* p_msg,
 
     case AVRC_PDU_CHANGE_PATH: {
       tAVRC_CHG_PATH_RSP* change_path_rsp = &(p_rsp->chg_path);
+      min_len += 5;
+      if (pkt_len < min_len) goto browse_length_error;
       /* Copyback the PDU */
       change_path_rsp->pdu = pdu;
       /* Read the status */
       BE_STREAM_TO_UINT8(change_path_rsp->status, p);
       /* Read the number of items in folder */
       BE_STREAM_TO_UINT32(change_path_rsp->num_items, p);
-      pkt_len_read += 5;
 
       AVRC_TRACE_DEBUG("%s pdu %d status %d item count %d", __func__,
                        change_path_rsp->pdu, change_path_rsp->status,
@@ -397,6 +422,8 @@ static tAVRC_STS avrc_pars_browse_rsp(tAVRC_MSG_BROWSE* p_msg,
       set_br_pl_rsp->pdu = pdu;
 
       /* Read the status */
+      min_len += 10;
+      if (pkt_len < min_len) goto browse_length_error;
       BE_STREAM_TO_UINT8(set_br_pl_rsp->status, p);
 
       if (set_br_pl_rsp->status != AVRC_STS_NO_ERROR) {
@@ -413,7 +440,6 @@ static tAVRC_STS avrc_pars_browse_rsp(tAVRC_MSG_BROWSE* p_msg,
           "%s AVRC_PDU_SET_BROWSED_PLAYER status %d items %d cs %d depth %d",
           __func__, set_br_pl_rsp->status, set_br_pl_rsp->num_items,
           set_br_pl_rsp->charset_id, set_br_pl_rsp->folder_depth);
-      pkt_len_read += 10;
 
       set_br_pl_rsp->p_folders = (tAVRC_NAME*)osi_malloc(
           set_br_pl_rsp->num_items * sizeof(tAVRC_NAME));
@@ -421,13 +447,16 @@ static tAVRC_STS avrc_pars_browse_rsp(tAVRC_MSG_BROWSE* p_msg,
       /* Read each of the folder in the depth */
       for (uint32_t i = 0; i < set_br_pl_rsp->folder_depth; i++) {
         tAVRC_NAME* folder_name = &(set_br_pl_rsp->p_folders[i]);
+        min_len += 2;
+        if (pkt_len < min_len) goto browse_length_error;
         BE_STREAM_TO_UINT16(folder_name->str_len, p);
+        min_len += folder_name->str_len;
+        if (pkt_len < min_len) goto browse_length_error;
         AVRC_TRACE_DEBUG("%s AVRC_PDU_SET_BROWSED_PLAYER item: %d len: %d",
                          __func__, i, folder_name->str_len);
         folder_name->p_str =
             (uint8_t*)osi_malloc((folder_name->str_len + 1) * sizeof(uint8_t));
         BE_STREAM_TO_ARRAY(p, folder_name->p_str, folder_name->str_len);
-        pkt_len_read += (2 + folder_name->str_len);
       }
       break;
     }
@@ -436,12 +465,13 @@ static tAVRC_STS avrc_pars_browse_rsp(tAVRC_MSG_BROWSE* p_msg,
       AVRC_TRACE_ERROR("%s pdu %d not handled", __func__, pdu);
   }
 
-  if (pkt_len != pkt_len_read) {
-    AVRC_TRACE_ERROR("%s finished pkt_len %d pkt_len_read %d", __func__,
-                     pkt_len, pkt_len_read);
-    return AVRC_STS_BAD_CMD;
-  }
   return status;
+
+browse_length_error:
+  android_errorWriteLog(0x534e4554, "111451066");
+  AVRC_TRACE_WARNING("%s: invalid parameter length %d: must be at least %d",
+                     __func__, pkt_len, min_len);
+  return AVRC_STS_BAD_CMD;
 }
 
 /*******************************************************************************
diff --git a/stack/include/btm_api_types.h b/stack/include/btm_api_types.h
index df7b64da6..8cc94859d 100644
--- a/stack/include/btm_api_types.h
+++ b/stack/include/btm_api_types.h
@@ -1192,9 +1192,11 @@ typedef uint8_t tBTM_LINK_KEY_TYPE;
 #define BTM_SEC_SERVICE_HIDD_SEC_CTRL 51
 #define BTM_SEC_SERVICE_HIDD_NOSEC_CTRL 52
 #define BTM_SEC_SERVICE_HIDD_INTR 53
+#define BTM_SEC_SERVICE_HEARING_AID_LEFT 54
+#define BTM_SEC_SERVICE_HEARING_AID_RIGHT 55
 
 /* Update these as services are added */
-#define BTM_SEC_SERVICE_FIRST_EMPTY 54
+#define BTM_SEC_SERVICE_FIRST_EMPTY 56
 
 #ifndef BTM_SEC_MAX_SERVICES
 #define BTM_SEC_MAX_SERVICES 75
diff --git a/stack/smp/smp_act.cc b/stack/smp/smp_act.cc
index 15dfae108..b775d5d49 100644
--- a/stack/smp/smp_act.cc
+++ b/stack/smp/smp_act.cc
@@ -341,7 +341,7 @@ void smp_send_keypress_notification(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
  * Description  send encryption information command.
  ******************************************************************************/
 void smp_send_enc_info(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
-  tBTM_LE_LENC_KEYS le_key;
+  tBTM_LE_KEY_VALUE le_key;
 
   SMP_TRACE_DEBUG("%s: p_cb->loc_enc_size = %d", __func__, p_cb->loc_enc_size);
   smp_update_key_mask(p_cb, SMP_SEC_KEY_TYPE_ENC, false);
@@ -350,15 +350,14 @@ void smp_send_enc_info(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
   smp_send_cmd(SMP_OPCODE_MASTER_ID, p_cb);
 
   /* save the DIV and key size information when acting as slave device */
-  memcpy(le_key.ltk, p_cb->ltk, BT_OCTET16_LEN);
-  le_key.div = p_cb->div;
-  le_key.key_size = p_cb->loc_enc_size;
-  le_key.sec_level = p_cb->sec_level;
+  memcpy(le_key.lenc_key.ltk, p_cb->ltk, BT_OCTET16_LEN);
+  le_key.lenc_key.div = p_cb->div;
+  le_key.lenc_key.key_size = p_cb->loc_enc_size;
+  le_key.lenc_key.sec_level = p_cb->sec_level;
 
   if ((p_cb->peer_auth_req & SMP_AUTH_BOND) &&
       (p_cb->loc_auth_req & SMP_AUTH_BOND))
-    btm_sec_save_le_key(p_cb->pairing_bda, BTM_LE_KEY_LENC,
-                        (tBTM_LE_KEY_VALUE*)&le_key, true);
+    btm_sec_save_le_key(p_cb->pairing_bda, BTM_LE_KEY_LENC, &le_key, true);
 
   SMP_TRACE_WARNING("%s", __func__);
 
@@ -390,17 +389,16 @@ void smp_send_id_info(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
  * Description  send CSRK command.
  ******************************************************************************/
 void smp_send_csrk_info(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
-  tBTM_LE_LCSRK_KEYS key;
+  tBTM_LE_KEY_VALUE key;
   SMP_TRACE_DEBUG("%s", __func__);
   smp_update_key_mask(p_cb, SMP_SEC_KEY_TYPE_CSRK, false);
 
   if (smp_send_cmd(SMP_OPCODE_SIGN_INFO, p_cb)) {
-    key.div = p_cb->div;
-    key.sec_level = p_cb->sec_level;
-    key.counter = 0; /* initialize the local counter */
-    memcpy(key.csrk, p_cb->csrk, BT_OCTET16_LEN);
-    btm_sec_save_le_key(p_cb->pairing_bda, BTM_LE_KEY_LCSRK,
-                        (tBTM_LE_KEY_VALUE*)&key, true);
+    key.lcsrk_key.div = p_cb->div;
+    key.lcsrk_key.sec_level = p_cb->sec_level;
+    key.lcsrk_key.counter = 0; /* initialize the local counter */
+    memcpy(key.lcsrk_key.csrk, p_cb->csrk, BT_OCTET16_LEN);
+    btm_sec_save_le_key(p_cb->pairing_bda, BTM_LE_KEY_LCSRK, &key, true);
   }
 
   smp_key_distribution_by_transport(p_cb, NULL);
@@ -935,7 +933,7 @@ void smp_proc_enc_info(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
  ******************************************************************************/
 void smp_proc_master_id(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
   uint8_t* p = p_data->p_data;
-  tBTM_LE_PENC_KEYS le_key;
+  tBTM_LE_KEY_VALUE le_key;
 
   SMP_TRACE_DEBUG("%s", __func__);
 
@@ -948,18 +946,17 @@ void smp_proc_master_id(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
 
   smp_update_key_mask(p_cb, SMP_SEC_KEY_TYPE_ENC, true);
 
-  STREAM_TO_UINT16(le_key.ediv, p);
-  STREAM_TO_ARRAY(le_key.rand, p, BT_OCTET8_LEN);
+  STREAM_TO_UINT16(le_key.penc_key.ediv, p);
+  STREAM_TO_ARRAY(le_key.penc_key.rand, p, BT_OCTET8_LEN);
 
   /* store the encryption keys from peer device */
-  memcpy(le_key.ltk, p_cb->ltk, BT_OCTET16_LEN);
-  le_key.sec_level = p_cb->sec_level;
-  le_key.key_size = p_cb->loc_enc_size;
+  memcpy(le_key.penc_key.ltk, p_cb->ltk, BT_OCTET16_LEN);
+  le_key.penc_key.sec_level = p_cb->sec_level;
+  le_key.penc_key.key_size = p_cb->loc_enc_size;
 
   if ((p_cb->peer_auth_req & SMP_AUTH_BOND) &&
       (p_cb->loc_auth_req & SMP_AUTH_BOND))
-    btm_sec_save_le_key(p_cb->pairing_bda, BTM_LE_KEY_PENC,
-                        (tBTM_LE_KEY_VALUE*)&le_key, true);
+    btm_sec_save_le_key(p_cb->pairing_bda, BTM_LE_KEY_PENC, &le_key, true);
 
   smp_key_distribution(p_cb, NULL);
 }
@@ -991,25 +988,24 @@ void smp_proc_id_info(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
  ******************************************************************************/
 void smp_proc_id_addr(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
   uint8_t* p = p_data->p_data;
-  tBTM_LE_PID_KEYS pid_key;
+  tBTM_LE_KEY_VALUE pid_key;
 
   SMP_TRACE_DEBUG("%s", __func__);
   smp_update_key_mask(p_cb, SMP_SEC_KEY_TYPE_ID, true);
 
-  STREAM_TO_UINT8(pid_key.addr_type, p);
-  STREAM_TO_BDADDR(pid_key.static_addr, p);
-  memcpy(pid_key.irk, p_cb->tk, BT_OCTET16_LEN);
+  STREAM_TO_UINT8(pid_key.pid_key.addr_type, p);
+  STREAM_TO_BDADDR(pid_key.pid_key.static_addr, p);
+  memcpy(pid_key.pid_key.irk, p_cb->tk, BT_OCTET16_LEN);
 
   /* to use as BD_ADDR for lk derived from ltk */
   p_cb->id_addr_rcvd = true;
-  p_cb->id_addr_type = pid_key.addr_type;
-  p_cb->id_addr = pid_key.static_addr;
+  p_cb->id_addr_type = pid_key.pid_key.addr_type;
+  p_cb->id_addr = pid_key.pid_key.static_addr;
 
   /* store the ID key from peer device */
   if ((p_cb->peer_auth_req & SMP_AUTH_BOND) &&
       (p_cb->loc_auth_req & SMP_AUTH_BOND))
-    btm_sec_save_le_key(p_cb->pairing_bda, BTM_LE_KEY_PID,
-                        (tBTM_LE_KEY_VALUE*)&pid_key, true);
+    btm_sec_save_le_key(p_cb->pairing_bda, BTM_LE_KEY_PID, &pid_key, true);
   smp_key_distribution_by_transport(p_cb, NULL);
 }
 
@@ -1018,24 +1014,23 @@ void smp_proc_id_addr(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
  * Description  process security information from peer device
  ******************************************************************************/
 void smp_proc_srk_info(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
-  tBTM_LE_PCSRK_KEYS le_key;
+  tBTM_LE_KEY_VALUE le_key;
 
   SMP_TRACE_DEBUG("%s", __func__);
   smp_update_key_mask(p_cb, SMP_SEC_KEY_TYPE_CSRK, true);
 
   /* save CSRK to security record */
-  le_key.sec_level = p_cb->sec_level;
+  le_key.pcsrk_key.sec_level = p_cb->sec_level;
 
   /* get peer CSRK */
-  maybe_non_aligned_memcpy(le_key.csrk, p_data->p_data, BT_OCTET16_LEN);
+  maybe_non_aligned_memcpy(le_key.pcsrk_key.csrk, p_data->p_data, BT_OCTET16_LEN);
 
   /* initialize the peer counter */
-  le_key.counter = 0;
+  le_key.pcsrk_key.counter = 0;
 
   if ((p_cb->peer_auth_req & SMP_AUTH_BOND) &&
       (p_cb->loc_auth_req & SMP_AUTH_BOND))
-    btm_sec_save_le_key(p_cb->pairing_bda, BTM_LE_KEY_PCSRK,
-                        (tBTM_LE_KEY_VALUE*)&le_key, true);
+    btm_sec_save_le_key(p_cb->pairing_bda, BTM_LE_KEY_PCSRK, &le_key, true);
   smp_key_distribution_by_transport(p_cb, NULL);
 }
 
diff --git a/stack/smp/smp_utils.cc b/stack/smp/smp_utils.cc
index 2bd0b2469..5027e3d97 100644
--- a/stack/smp/smp_utils.cc
+++ b/stack/smp/smp_utils.cc
@@ -1436,25 +1436,23 @@ bool smp_check_commitment(tSMP_CB* p_cb) {
  *
  ******************************************************************************/
 void smp_save_secure_connections_long_term_key(tSMP_CB* p_cb) {
-  tBTM_LE_LENC_KEYS lle_key;
-  tBTM_LE_PENC_KEYS ple_key;
+  tBTM_LE_KEY_VALUE lle_key;
+  tBTM_LE_KEY_VALUE ple_key;
 
   SMP_TRACE_DEBUG("%s-Save LTK as local LTK key", __func__);
-  memcpy(lle_key.ltk, p_cb->ltk, BT_OCTET16_LEN);
-  lle_key.div = 0;
-  lle_key.key_size = p_cb->loc_enc_size;
-  lle_key.sec_level = p_cb->sec_level;
-  btm_sec_save_le_key(p_cb->pairing_bda, BTM_LE_KEY_LENC,
-                      (tBTM_LE_KEY_VALUE*)&lle_key, true);
+  memcpy(lle_key.lenc_key.ltk, p_cb->ltk, BT_OCTET16_LEN);
+  lle_key.lenc_key.div = 0;
+  lle_key.lenc_key.key_size = p_cb->loc_enc_size;
+  lle_key.lenc_key.sec_level = p_cb->sec_level;
+  btm_sec_save_le_key(p_cb->pairing_bda, BTM_LE_KEY_LENC, &lle_key, true);
 
   SMP_TRACE_DEBUG("%s-Save LTK as peer LTK key", __func__);
-  ple_key.ediv = 0;
-  memset(ple_key.rand, 0, BT_OCTET8_LEN);
-  memcpy(ple_key.ltk, p_cb->ltk, BT_OCTET16_LEN);
-  ple_key.sec_level = p_cb->sec_level;
-  ple_key.key_size = p_cb->loc_enc_size;
-  btm_sec_save_le_key(p_cb->pairing_bda, BTM_LE_KEY_PENC,
-                      (tBTM_LE_KEY_VALUE*)&ple_key, true);
+  ple_key.penc_key.ediv = 0;
+  memset(ple_key.penc_key.rand, 0, BT_OCTET8_LEN);
+  memcpy(ple_key.penc_key.ltk, p_cb->ltk, BT_OCTET16_LEN);
+  ple_key.penc_key.sec_level = p_cb->sec_level;
+  ple_key.penc_key.key_size = p_cb->loc_enc_size;
+  btm_sec_save_le_key(p_cb->pairing_bda, BTM_LE_KEY_PENC, &ple_key, true);
 }
 
 /*******************************************************************************
-- 
2.17.1

