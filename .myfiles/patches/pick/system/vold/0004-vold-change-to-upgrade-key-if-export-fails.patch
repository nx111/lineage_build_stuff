From 3f6d1b7d2e50ba797fdafe0d5f0b145ae52deee9 Mon Sep 17 00:00:00 2001
From: Smita Ghosh <smitag@codeaurora.org>
Date: Fri, 11 Jan 2019 10:38:09 -0800
Subject: [PATCH 4/4] vold: change to upgrade key if export fails

Add support to upgrade key when export fails
with KEY_REQUIRES_UPGRADE.

CRs-Fixed: 2365225
Change-Id: I6b886929bd549920e42624261a63510a4b6a1ceb
---
 KeyStorage.cpp | 26 ++++++++++++++++++++++----
 Keymaster.cpp  |  8 ++++----
 Keymaster.h    |  2 +-
 3 files changed, 27 insertions(+), 9 deletions(-)

diff --git a/KeyStorage.cpp b/KeyStorage.cpp
index f8faed0..fd1598e 100644
--- a/KeyStorage.cpp
+++ b/KeyStorage.cpp
@@ -162,10 +162,28 @@ bool getEphemeralWrappedKey(km::KeyFormat format, KeyBuffer& kmKey, KeyBuffer* k
     std::string key_temp;
     Keymaster keymaster;
     if (!keymaster) return false;
-    if (!keymaster.exportKey(format, kmKey, "!", "!", &key_temp)) return false;
-    *key = KeyBuffer(key_temp.size());
-    memcpy(reinterpret_cast<void*>(key->data()), key_temp.c_str(), key->size());
-    return true;
+
+    //Export once, if upgrade needed, upgrade and export again
+    bool export_again = true;
+    while (export_again) {
+        export_again = false;
+        auto ret = keymaster.exportKey(format, kmKey, "!", "!", &key_temp);
+        if (ret == km::ErrorCode::OK) {
+            *key = KeyBuffer(key_temp.size());
+            memcpy(reinterpret_cast<void*>(key->data()), key_temp.c_str(), key->size());
+            return true;
+        }
+        if (ret != km::ErrorCode::KEY_REQUIRES_UPGRADE) return false;
+        LOG(DEBUG) << "Upgrading key";
+        std::string kmKeyStr(reinterpret_cast<const char*>(kmKey.data()), kmKey.size());
+        std::string newKey;
+        if (!keymaster.upgradeKey(kmKeyStr, km::AuthorizationSet(), &newKey)) return false;
+        memcpy(reinterpret_cast<void*>(kmKey.data()), newKey.c_str(), kmKey.size());
+        LOG(INFO) << "Key upgraded";
+        export_again = true;
+    }
+    //Should never come here
+    return false;
 }
 
 static std::pair<km::AuthorizationSet, km::HardwareAuthToken> beginParams(
diff --git a/Keymaster.cpp b/Keymaster.cpp
index ab39ef8..706181d 100644
--- a/Keymaster.cpp
+++ b/Keymaster.cpp
@@ -138,7 +138,7 @@ bool Keymaster::generateKey(const km::AuthorizationSet& inParams, std::string* k
     return true;
 }
 
-bool Keymaster::exportKey(km::KeyFormat format, KeyBuffer& kmKey, const std::string& clientId,
+km::ErrorCode Keymaster::exportKey(km::KeyFormat format, KeyBuffer& kmKey, const std::string& clientId,
                           const std::string& appData, std::string* key) {
     auto kmKeyBlob = km::support::blob2hidlVec(std::string(kmKey.data(), kmKey.size()));
     auto emptyAssign = NULL;
@@ -155,13 +155,13 @@ bool Keymaster::exportKey(km::KeyFormat format, KeyBuffer& kmKey, const std::str
     auto error = mDevice->exportKey(format, kmKeyBlob, kmClientId, kmAppData, hidlCb);
     if (!error.isOk()) {
         LOG(ERROR) << "export_key failed: " << error.description();
-        return false;
+        return km::ErrorCode::UNKNOWN_ERROR;
     }
     if (km_error != km::ErrorCode::OK) {
         LOG(ERROR) << "export_key failed, code " << int32_t(km_error);
-        return false;
+        return km_error;
     }
-    return true;
+    return km::ErrorCode::OK;
 }
 
 bool Keymaster::deleteKey(const std::string& key) {
diff --git a/Keymaster.h b/Keymaster.h
index c0ec4d3..e513095 100644
--- a/Keymaster.h
+++ b/Keymaster.h
@@ -103,7 +103,7 @@ class Keymaster {
     // Generate a key in the keymaster from the given params.
     bool generateKey(const km::AuthorizationSet& inParams, std::string* key);
     // Export a key from keymaster.
-    bool exportKey(km::KeyFormat format, KeyBuffer& kmKey, const std::string& clientId,
+    km::ErrorCode exportKey(km::KeyFormat format, KeyBuffer& kmKey, const std::string& clientId,
                    const std::string& appData, std::string* key);
     // If the keymaster supports it, permanently delete a key.
     bool deleteKey(const std::string& key);
-- 
2.17.1

