From c57772cfc06dc2b46676a7716da047107e8579e9 Mon Sep 17 00:00:00 2001
From: Tom Marshall <tdm@cyngn.com>
Date: Mon, 16 Nov 2015 13:48:28 -0800
Subject: [PATCH 14/44] recovery: bu: Implement backup/restore

Change-Id: I9e684868ce15aaaed3a40338dadc20b003b50ade
---
 Android.mk  |  48 ++++++-
 backup.cpp  | 197 +++++++++++++++++++++++++++
 bu.cpp      | 382 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 bu.h        |  54 ++++++++
 restore.cpp | 239 ++++++++++++++++++++++++++++++++
 5 files changed, 919 insertions(+), 1 deletion(-)
 create mode 100644 backup.cpp
 create mode 100644 bu.cpp
 create mode 100644 bu.h
 create mode 100644 restore.cpp

diff --git a/Android.mk b/Android.mk
index b5a24ff1..2c333e7b 100644
--- a/Android.mk
+++ b/Android.mk
@@ -272,7 +272,8 @@ endif
 
 LOCAL_REQUIRED_MODULES += \
     toybox_static \
-    recovery_mkshrc
+    recovery_mkshrc \
+    bu_recovery
 
 # Symlinks
 RECOVERY_TOOLS := \
@@ -302,6 +303,51 @@ LOCAL_SRC_FILES := etc/mkshrc
 LOCAL_MODULE_STEM := mkshrc
 include $(BUILD_PREBUILT)
 
+include $(CLEAR_VARS)
+LOCAL_MODULE := bu_recovery
+LOCAL_MODULE_STEM := bu
+LOCAL_MODULE_TAGS := optional
+LOCAL_MODULE_PATH := $(TARGET_RECOVERY_ROOT_OUT)/sbin
+LOCAL_FORCE_STATIC_EXECUTABLE := true
+LOCAL_SRC_FILES := \
+    bu.cpp \
+    backup.cpp \
+    restore.cpp \
+    roots.cpp
+LOCAL_CFLAGS += -DMINIVOLD
+LOCAL_CFLAGS += -Wno-unused-parameter
+LOCAL_STATIC_LIBRARIES += \
+    libext4_utils \
+    libsparse \
+    libmounts \
+    libz \
+    libminadbd \
+    libminui \
+    libfs_mgr \
+    libtar \
+    libcrypto \
+    libbase \
+    libcutils \
+    libutils \
+    liblog \
+    libselinux \
+    libm \
+    libc
+
+LOCAL_C_INCLUDES += \
+    system/core/fs_mgr/include \
+    system/core/include \
+    system/core/libcutils \
+    system/extras/ext4_utils \
+    system/vold \
+    external/libtar \
+    external/libtar/listhash \
+    external/openssl/include \
+    external/zlib \
+    bionic/libc/bionic
+
+include $(BUILD_EXECUTABLE)
+
 # Minizip static library
 include $(CLEAR_VARS)
 LOCAL_MODULE := libminizip_static
diff --git a/backup.cpp b/backup.cpp
new file mode 100644
index 00000000..70c5bb45
--- /dev/null
+++ b/backup.cpp
@@ -0,0 +1,197 @@
+#include <stdlib.h>
+#include <stdio.h>
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <dirent.h>
+#include <sys/vfs.h>
+#include <time.h>
+
+#include "cutils/properties.h"
+
+#include <fs_mgr.h>
+#include "roots.h"
+
+#include "bu.h"
+
+using namespace android;
+
+static int append_sod(const char* opt_hash)
+{
+    const char* key;
+    char value[PROPERTY_VALUE_MAX];
+    char sodbuf[PROP_LINE_LEN*10];
+    char* p = sodbuf;
+
+    key = "hash.name";
+    strcpy(value, opt_hash);
+    p += sprintf(p, "%s=%s\n", key, value);
+
+    key = "ro.product.device";
+    property_get(key, value, "");
+    p += sprintf(p, "%s=%s\n", key, value);
+
+    for (int i = 0; i < MAX_PART; ++i) {
+        partspec* part = part_get(i);
+        if (!part)
+            break;
+        int fd = open(part->vol->blk_device, O_RDONLY);
+        part->size = part->used = lseek64(fd, 0, SEEK_END);
+        close(fd);
+        p += sprintf(p, "fs.%s.size=%llu\n", part->name, (unsigned long long)part->size);
+        p += sprintf(p, "fs.%s.used=%llu\n", part->name, (unsigned long long)part->used);
+    }
+
+    int rc = tar_append_file_contents(tar, "SOD", 0600,
+            getuid(), getgid(), sodbuf, p-sodbuf);
+    return rc;
+}
+
+static int append_eod(const char* opt_hash)
+{
+    char eodbuf[PROP_LINE_LEN*10];
+    char* p = eodbuf;
+    int n;
+
+    p += sprintf(p, "hash.datalen=%lu\n", (unsigned long)hash_datalen);
+
+    unsigned char digest[HASH_MAX_LENGTH];
+    char hexdigest[HASH_MAX_STRING_LENGTH];
+
+    if (!strcasecmp(opt_hash, "sha1")) {
+        SHA1_Final(digest, &sha_ctx);
+        for (n = 0; n < SHA_DIGEST_LENGTH; ++n) {
+            sprintf(hexdigest+2*n, "%02x", digest[n]);
+        }
+        p += sprintf(p, "hash.value=%s\n", hexdigest);
+    }
+    else { // default to md5
+        MD5_Final(digest, &md5_ctx);
+        for (n = 0; n < MD5_DIGEST_LENGTH; ++n) {
+            sprintf(hexdigest+2*n, "%02x", digest[n]);
+        }
+        p += sprintf(p, "hash.value=%s\n", hexdigest);
+    }
+
+    int rc = tar_append_file_contents(tar, "EOD", 0600,
+            getuid(), getgid(), eodbuf, p-eodbuf);
+    return rc;
+}
+
+static int tar_append_device_contents(TAR* t, const char* devname, const char* savename)
+{
+    struct stat st;
+    memset(&st, 0, sizeof(st));
+    if (lstat(devname, &st) != 0) {
+        logmsg("tar_append_device_contents: lstat %s failed\n", devname);
+        return -1;
+    }
+    st.st_mode = 0644 | S_IFREG;
+
+    int fd = open(devname, O_RDONLY);
+    if (fd < 0) {
+        logmsg("tar_append_device_contents: open %s failed\n", devname);
+        return -1;
+    }
+    st.st_size = lseek64(fd, 0, SEEK_END);
+    close(fd);
+
+    th_set_from_stat(t, &st);
+    th_set_path(t, savename);
+    if (th_write(t) != 0) {
+        logmsg("tar_append_device_contents: th_write failed\n");
+        return -1;
+    }
+    if (tar_append_regfile(t, devname) != 0) {
+        logmsg("tar_append_device_contents: tar_append_regfile %s failed\n", devname);
+        return -1;
+    }
+    return 0;
+}
+
+int do_backup(int argc, char **argv)
+{
+    int rc = 1;
+    int n;
+    int i;
+
+    const char* opt_compress = "gzip";
+    const char* opt_hash = "md5";
+
+    int optidx = 0;
+    while (optidx < argc && argv[optidx][0] == '-' && argv[optidx][1] == '-') {
+        char* optname = &argv[optidx][2];
+        ++optidx;
+        char* optval = strchr(optname, '=');
+        if (optval) {
+            *optval = '\0';
+            ++optval;
+        }
+        else {
+            if (optidx >= argc) {
+                logmsg("No argument to --%s\n", optname);
+                return -1;
+            }
+            optval = argv[optidx];
+            ++optidx;
+        }
+        if (!strcmp(optname, "compress")) {
+            opt_compress = optval;
+            logmsg("do_backup: compress=%s\n", opt_compress);
+        }
+        else if (!strcmp(optname, "hash")) {
+            opt_hash = optval;
+            logmsg("do_backup: hash=%s\n", opt_hash);
+        }
+        else {
+            logmsg("do_backup: invalid option name \"%s\"\n", optname);
+            return -1;
+        }
+    }
+    for (n = optidx; n < argc; ++n) {
+        const char* partname = argv[n];
+        if (*partname == '-')
+            ++partname;
+        if (part_add(partname) != 0) {
+            logmsg("Failed to add partition %s\n", partname);
+            return -1;
+        }
+    }
+
+    rc = create_tar(adb_ofd, opt_compress, "w");
+    if (rc != 0) {
+        logmsg("do_backup: cannot open tar stream\n");
+        return rc;
+    }
+
+    append_sod(opt_hash);
+
+    hash_name = strdup(opt_hash);
+
+    for (i = 0; i < MAX_PART; ++i) {
+        partspec* curpart = part_get(i);
+        if (!curpart)
+            break;
+
+        part_set(curpart);
+        rc = tar_append_device_contents(tar, curpart->vol->blk_device, curpart->name);
+    }
+
+    free(hash_name);
+    hash_name = NULL;
+
+    append_eod(opt_hash);
+
+    tar_append_eof(tar);
+
+    if (opt_compress)
+        gzflush(gzf, Z_FINISH);
+
+    logmsg("backup complete: rc=%d\n", rc);
+
+    return rc;
+}
+
diff --git a/bu.cpp b/bu.cpp
new file mode 100644
index 00000000..aeb92775
--- /dev/null
+++ b/bu.cpp
@@ -0,0 +1,382 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdarg.h>
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <dirent.h>
+#include <sys/vfs.h>
+
+#include <cutils/properties.h>
+#include <cutils/log.h>
+
+#include <selinux/label.h>
+
+#include <fs_mgr.h>
+#include "roots.h"
+
+#include "bu.h"
+
+#define PATHNAME_RC "/tmp/burc"
+
+#define PATHNAME_XCOMP_ENABLE "/sys/fs/xcomp/enable"
+
+using namespace std;
+
+using namespace android;
+
+struct selabel_handle *sehandle;
+
+int adb_ifd;
+int adb_ofd;
+TAR* tar;
+gzFile gzf;
+
+char* hash_name;
+size_t hash_datalen;
+SHA_CTX sha_ctx;
+MD5_CTX md5_ctx;
+
+void
+ui_print(const char* format, ...) {
+    char buffer[256];
+
+    va_list ap;
+    va_start(ap, format);
+    vsnprintf(buffer, sizeof(buffer), format, ap);
+    va_end(ap);
+
+    fputs(buffer, stdout);
+}
+
+void logmsg(const char *fmt, ...)
+{
+    char msg[1024];
+    FILE* fp;
+    va_list ap;
+
+    va_start(ap, fmt);
+    vsnprintf(msg, sizeof(msg), fmt, ap);
+    va_end(ap);
+
+    fp = fopen("/tmp/bu.log", "a");
+    if (fp) {
+        fprintf(fp, "[%d] %s", getpid(), msg);
+        fclose(fp);
+    }
+}
+
+static int xcomp_enable_get(void)
+{
+    int val = 0;
+    int fd;
+    char buf[12+1+1];
+
+    fd = open(PATHNAME_XCOMP_ENABLE, O_RDONLY);
+    if (fd < 0)
+        return 0;
+    memset(buf, 0, sizeof(buf));
+    if (read(fd, buf, sizeof(buf)) > 0) {
+        val = atoi(buf);
+    }
+    close(fd);
+    return val;
+}
+
+static void xcomp_enable_set(int val)
+{
+    int fd;
+    char buf[12+1+1];
+    int len;
+
+    fd = open(PATHNAME_XCOMP_ENABLE, O_RDWR);
+    if (fd < 0)
+        return;
+    len = sprintf(buf, "%d\n", val);
+    write(fd, buf, len);
+    close(fd);
+}
+
+static partspec partlist[MAX_PART];
+static partspec* curpart;
+
+int part_add(const char* name)
+{
+    Volume* vol = NULL;
+    char* path = NULL;
+    int i;
+
+    path = (char*)malloc(1+strlen(name)+1);
+    sprintf(path, "/%s", name);
+    vol = volume_for_mount_point(path);
+    if (vol == NULL || vol->fs_type == NULL) {
+        logmsg("missing vol info for %s, ignoring\n", name);
+        goto err;
+    }
+
+    for (i = 0; i < MAX_PART; ++i) {
+        if (partlist[i].name == NULL) {
+            partlist[i].name = strdup(name);
+            partlist[i].path = path;
+            partlist[i].vol = vol;
+            logmsg("part_add: i=%d, name=%s, path=%s\n", i, name, path);
+            return 0;
+        }
+        if (strcmp(partlist[i].name, name) == 0) {
+            logmsg("duplicate partition %s, ignoring\n", name);
+            goto err;
+        }
+    }
+
+err:
+    free(path);
+    return -1;
+}
+
+partspec* part_get(int i)
+{
+    if (i >= 0 && i < MAX_PART) {
+        if (partlist[i].name != NULL) {
+            return &partlist[i];
+        }
+    }
+    return NULL;
+}
+
+partspec* part_find(const char* name)
+{
+    for (int i = 0; i < MAX_PART; ++i) {
+        if (partlist[i].name && !strcmp(name, partlist[i].name)) {
+            return &partlist[i];
+        }
+    }
+    return NULL;
+}
+
+void part_set(partspec* part)
+{
+    curpart = part;
+    curpart->off = 0;
+}
+
+int update_progress(uint64_t off)
+{
+    static time_t last_time = 0;
+    static int last_pct = 0;
+    if (curpart) {
+        curpart->off += off;
+        time_t now = time(NULL);
+        int pct = min(100, (int)((uint64_t)100*curpart->off/curpart->used));
+        if (now != last_time && pct != last_pct) {
+            char msg[256];
+            sprintf(msg, "%s: %d%% complete", curpart->name, pct);
+            ui_print(msg);
+            last_time = now;
+            last_pct = pct;
+        }
+    }
+    return 0;
+}
+
+static int tar_cb_open(const char* path, int mode, ...)
+{
+    errno = EINVAL;
+    return -1;
+}
+
+static int tar_cb_close(int fd)
+{
+    return 0;
+}
+
+static ssize_t tar_cb_read(int fd, void* buf, size_t len)
+{
+    ssize_t nread;
+    nread = ::read(fd, buf, len);
+    if (nread > 0 && hash_name) {
+        SHA1_Update(&sha_ctx, (u_char*)buf, nread);
+        MD5_Update(&md5_ctx, buf, nread);
+        hash_datalen += nread;
+    }
+    update_progress(nread);
+    return nread;
+}
+
+static ssize_t tar_cb_write(int fd, const void* buf, size_t len)
+{
+    ssize_t written = 0;
+
+    if (hash_name) {
+        SHA1_Update(&sha_ctx, (u_char*)buf, len);
+        MD5_Update(&md5_ctx, buf, len);
+        hash_datalen += len;
+    }
+
+    while (len > 0) {
+        ssize_t n = ::write(fd, buf, len);
+        if (n < 0) {
+            logmsg("tar_cb_write: error: n=%d\n", n);
+            return n;
+        }
+        if (n == 0)
+            break;
+        buf = (const char *)buf + n;
+        len -= n;
+        written += n;
+    }
+    update_progress(written);
+    return written;
+}
+
+static tartype_t tar_io = {
+    tar_cb_open,
+    tar_cb_close,
+    tar_cb_read,
+    tar_cb_write
+};
+
+static ssize_t tar_gz_cb_read(int fd, void* buf, size_t len)
+{
+    int nread;
+    nread = gzread(gzf, buf, len);
+    if (nread > 0 && hash_name) {
+        SHA1_Update(&sha_ctx, (u_char*)buf, nread);
+        MD5_Update(&md5_ctx, buf, nread);
+        hash_datalen += nread;
+    }
+    update_progress(nread);
+    return nread;
+}
+
+static ssize_t tar_gz_cb_write(int fd, const void* buf, size_t len)
+{
+    ssize_t written = 0;
+
+    if (hash_name) {
+        SHA1_Update(&sha_ctx, (u_char*)buf, len);
+        MD5_Update(&md5_ctx, buf, len);
+        hash_datalen += len;
+    }
+
+    while (len > 0) {
+        ssize_t n = gzwrite(gzf, buf, len);
+        if (n < 0) {
+            logmsg("tar_gz_cb_write: error: n=%d\n", n);
+            return n;
+        }
+        if (n == 0)
+            break;
+        buf = (const char *)buf + n;
+        len -= n;
+        written += n;
+    }
+    update_progress(written);
+    return written;
+}
+
+static tartype_t tar_io_gz = {
+    tar_cb_open,
+    tar_cb_close,
+    tar_gz_cb_read,
+    tar_gz_cb_write
+};
+
+int create_tar(int fd, const char* compress, const char* mode)
+{
+    int rc = -1;
+
+    SHA1_Init(&sha_ctx);
+    MD5_Init(&md5_ctx);
+
+    if (!compress || strcasecmp(compress, "none") == 0) {
+        rc = tar_fdopen(&tar, fd, "foobar", &tar_io,
+                0, /* oflags: unused */
+                0, /* mode: unused */
+                TAR_GNU | TAR_STORE_SELINUX /* options */);
+    }
+    else if (strcasecmp(compress, "gzip") == 0) {
+        gzf = gzdopen(fd, mode);
+        if (gzf != NULL) {
+            rc = tar_fdopen(&tar, 0, "foobar", &tar_io_gz,
+                    0, /* oflags: unused */
+                    0, /* mode: unused */
+                    TAR_GNU | TAR_STORE_SELINUX /* options */);
+        }
+    }
+    return rc;
+}
+
+static void do_exit(int rc)
+{
+    char rcstr[80];
+    int len;
+    len = sprintf(rcstr, "%d\n", rc);
+
+    unlink(PATHNAME_RC);
+    int fd = open(PATHNAME_RC, O_RDWR|O_CREAT, 0644);
+    write(fd, rcstr, len);
+    close(fd);
+    exit(rc);
+}
+
+int main(int argc, char **argv)
+{
+    int rc = 1;
+    int xcomp_enable;
+
+    const char* logfile = "/tmp/recovery.log";
+    adb_ifd = dup(STDIN_FILENO);
+    adb_ofd = dup(STDOUT_FILENO);
+    freopen(logfile, "a", stdout); setbuf(stdout, NULL);
+    freopen(logfile, "a", stderr); setbuf(stderr, NULL);
+
+    logmsg("bu: invoked with %d args\n", argc);
+
+    if (argc < 2) {
+        logmsg("Not enough args (%d)\n", argc);
+        do_exit(1);
+    }
+
+    // progname args...
+    int optidx = 1;
+    const char* opname = argv[optidx++];
+
+    struct selinux_opt seopts[] = {
+      { SELABEL_OPT_PATH, "/file_contexts" }
+    };
+    sehandle = selabel_open(SELABEL_CTX_FILE, seopts, 1);
+
+    xcomp_enable = xcomp_enable_get();
+    xcomp_enable_set(0);
+
+    load_volume_table();
+
+    if (!strcmp(opname, "backup")) {
+        ui_print("Backup in progress...");
+        rc = do_backup(argc-optidx, &argv[optidx]);
+    }
+    else if (!strcmp(opname, "restore")) {
+        ui_print("Restore in progress...");
+        rc = do_restore(argc-optidx, &argv[optidx]);
+    }
+    else {
+        logmsg("Unknown operation %s\n", opname);
+        rc = 1;
+    }
+
+    xcomp_enable_set(xcomp_enable);
+
+    close(adb_ofd);
+    close(adb_ifd);
+
+    sleep(1);
+
+    logmsg("bu exiting\n");
+
+    do_exit(rc);
+
+    return rc;
+}
diff --git a/bu.h b/bu.h
new file mode 100644
index 00000000..15ab7454
--- /dev/null
+++ b/bu.h
@@ -0,0 +1,54 @@
+#include <utils/String8.h>
+
+#include <lib/libtar.h>
+#include <zlib.h>
+
+extern "C" {
+#include <openssl/sha.h>
+#include <openssl/md5.h>
+#ifndef MD5_DIGEST_STRING_LENGTH
+#define MD5_DIGEST_STRING_LENGTH (MD5_DIGEST_LENGTH*2+1)
+#endif
+#ifndef SHA_DIGEST_STRING_LENGTH
+#define SHA_DIGEST_STRING_LENGTH (SHA_DIGEST_LENGTH*2+1)
+#endif
+}
+
+#define HASH_MAX_LENGTH SHA_DIGEST_LENGTH
+#define HASH_MAX_STRING_LENGTH SHA_DIGEST_STRING_LENGTH
+
+#define PROP_LINE_LEN (PROPERTY_KEY_MAX+1+PROPERTY_VALUE_MAX+1+1)
+
+extern int adb_ifd;
+extern int adb_ofd;
+extern TAR* tar;
+extern gzFile gzf;
+
+extern char* hash_name;
+extern size_t hash_datalen;
+extern SHA_CTX sha_ctx;
+extern MD5_CTX md5_ctx;
+
+struct partspec {
+    char*       name;
+    char*       path;
+    Volume*     vol;
+    uint64_t    size;
+    uint64_t    used;
+    uint64_t    off;
+};
+#define MAX_PART 8
+
+extern void logmsg(const char* fmt, ...);
+
+extern int part_add(const char* name);
+extern partspec* part_get(int i);
+extern partspec* part_find(const char* name);
+extern void part_set(partspec* part);
+
+extern int update_progress(uint64_t off);
+
+extern int create_tar(int fd, const char* compress, const char* mode);
+
+extern int do_backup(int argc, char** argv);
+extern int do_restore(int argc, char** argv);
diff --git a/restore.cpp b/restore.cpp
new file mode 100644
index 00000000..4bdbaf46
--- /dev/null
+++ b/restore.cpp
@@ -0,0 +1,239 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdarg.h>
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <dirent.h>
+#include <sys/vfs.h>
+
+#include <cutils/properties.h>
+
+#include <lib/libtar.h>
+#include <zlib.h>
+
+#include <fs_mgr.h>
+#include "roots.h"
+
+#include "bu.h"
+
+using namespace android;
+
+static int verify_sod()
+{
+    const char* key;
+    char value[PROPERTY_VALUE_MAX];
+    char sodbuf[PROP_LINE_LEN*10];
+    size_t len;
+
+    len = sizeof(sodbuf);
+    if (tar_extract_file_contents(tar, sodbuf, &len) != 0) {
+        logmsg("tar_verify_sod: failed to extract file\n");
+        return -1;
+    }
+
+    char val_hashname[PROPERTY_VALUE_MAX];
+    memset(val_hashname, 0, sizeof(val_hashname));
+    char val_product[PROPERTY_VALUE_MAX];
+    memset(val_product, 0, sizeof(val_product));
+    char* p = sodbuf;
+    char* q;
+    while ((q = strchr(p, '\n')) != NULL) {
+        char* key = p;
+        *q = '\0';
+        logmsg("verify_sod: line=%s\n", p);
+        p = q+1;
+        char* val = strchr(key, '=');
+        if (val) {
+            *val = '\0';
+            ++val;
+            if (strcmp(key, "hash.name") == 0) {
+                strncpy(val_hashname, val, sizeof(val_hashname));
+            }
+            if (strcmp(key, "ro.product.device") == 0) {
+                strncpy(val_product, val, sizeof(val_product));
+            }
+            if (strncmp(key, "fs.", 3) == 0) {
+                char* name = key+3;
+                char* attr = strchr(name, '.');
+                if (attr) {
+                    *attr = '\0';
+                    ++attr;
+                    part_add(name);
+                    struct partspec* part = part_find(name);
+                    if (!strcmp(attr, "size")) {
+                        part->size = strtoul(val, NULL, 0);
+                    }
+                    if (!strcmp(attr, "used")) {
+                        part->used = strtoul(val, NULL, 0);
+                    }
+                }
+            }
+        }
+    }
+
+    if (!val_hashname[0]) {
+        logmsg("verify_sod: did not find hash.name\n");
+        return -1;
+    }
+    hash_name = strdup(val_hashname);
+
+    if (!val_product[0]) {
+        logmsg("verify_sod: did not find ro.product.device\n");
+        return -1;
+    }
+    key = "ro.product.device";
+    property_get(key, value, "");
+    if (strcmp(val_product, value) != 0) {
+        logmsg("verify_sod: product does not match\n");
+        return -1;
+    }
+
+    return 0;
+}
+
+static int verify_eod(size_t actual_hash_datalen,
+        SHA_CTX* actual_sha_ctx, MD5_CTX* actual_md5_ctx)
+{
+    int rc = -1;
+    char eodbuf[PROP_LINE_LEN*10];
+    size_t len;
+
+    len = sizeof(eodbuf);
+    if (tar_extract_file_contents(tar, eodbuf, &len) != 0) {
+        logmsg("verify_eod: failed to extract file\n");
+        return -1;
+    }
+
+    size_t reported_datalen = 0;
+    char reported_hash[HASH_MAX_STRING_LENGTH];
+    memset(reported_hash, 0, sizeof(reported_hash));
+    char* p = eodbuf;
+    char* q;
+    while ((q = strchr(p, '\n')) != NULL) {
+        char* key = p;
+        *q = '\0';
+        logmsg("verify_eod: line=%s\n", p);
+        p = q+1;
+        char* val = strchr(key, '=');
+        if (val) {
+            *val = '\0';
+            ++val;
+            if (strcmp(key, "hash.datalen") == 0) {
+                reported_datalen = strtoul(val, NULL, 0);
+            }
+            if (strcmp(key, "hash.value") == 0) {
+                memset(reported_hash, 0, sizeof(reported_hash));
+                strncpy(reported_hash, val, sizeof(reported_hash));
+            }
+        }
+    }
+
+    unsigned char digest[HASH_MAX_LENGTH];
+    char hexdigest[HASH_MAX_STRING_LENGTH];
+
+    int n;
+    if (hash_name != NULL && !strcasecmp(hash_name, "sha1")) {
+        SHA1_Final(digest, actual_sha_ctx);
+         for (n = 0; n < SHA_DIGEST_LENGTH; ++n) {
+             sprintf(hexdigest+2*n, "%02x", digest[n]);
+         }
+    }
+    else { // default to md5
+        MD5_Final(digest, actual_md5_ctx);
+        for (n = 0; n < MD5_DIGEST_LENGTH; ++n) {
+            sprintf(hexdigest+2*n, "%02x", digest[n]);
+        }
+    }
+
+    logmsg("verify_eod: expected=%d,%s\n", actual_hash_datalen, hexdigest);
+
+    logmsg("verify_eod: reported=%d,%s\n", reported_datalen, reported_hash);
+
+    if ((reported_datalen == actual_hash_datalen) &&
+            (memcmp(hexdigest, reported_hash, strlen(hexdigest)) == 0)) {
+        rc = 0;
+    }
+
+    return rc;
+}
+
+int do_restore(int argc, char **argv)
+{
+    int rc = 0;
+    ssize_t len;
+    const char* compress = "none";
+    char buf[512];
+
+    len = recv(adb_ifd, buf, sizeof(buf), MSG_PEEK);
+    if (len < 0) {
+        logmsg("do_restore: peek failed (%d:%s)\n", rc, strerror(errno));
+        return -1;
+    }
+    if (len < 2) {
+        logmsg("do_restore: peek returned %d\n", len);
+        return -1;
+    }
+    if (buf[0] == 0x1f && buf[1] == 0x8b) {
+        logmsg("do_restore: is gzip\n");
+        compress = "gzip";
+    }
+
+    create_tar(adb_ifd, compress, "r");
+
+    size_t save_hash_datalen;
+    SHA_CTX save_sha_ctx;
+    MD5_CTX save_md5_ctx;
+
+    while (1) {
+        save_hash_datalen = hash_datalen;
+        memcpy(&save_sha_ctx, &sha_ctx, sizeof(SHA_CTX));
+        memcpy(&save_md5_ctx, &md5_ctx, sizeof(MD5_CTX));
+        rc = th_read(tar);
+        if (rc != 0) {
+            if (rc == 1) { // EOF
+                rc = 0;
+            }
+            break;
+        }
+        char* pathname = th_get_pathname(tar);
+        logmsg("do_restore: extract %s\n", pathname);
+        if (!strcmp(pathname, "SOD")) {
+            rc = verify_sod();
+            logmsg("do_restore: tar_verify_sod returned %d\n", rc);
+        }
+        else if (!strcmp(pathname, "EOD")) {
+            rc = verify_eod(save_hash_datalen, &save_sha_ctx, &save_md5_ctx);
+            logmsg("do_restore: tar_verify_eod returned %d\n", rc);
+        }
+        else {
+            char mnt[PATH_MAX];
+            snprintf(mnt, sizeof(mnt), "/%s", pathname);
+            Volume* vol = volume_for_mount_point(mnt);
+            if (vol != NULL && vol->fs_type != NULL) {
+                partspec* curpart = part_find(pathname);
+                part_set(curpart);
+                rc = tar_extract_file(tar, vol->blk_device);
+            }
+            else {
+                logmsg("do_restore: cannot find volume for %s\n", mnt);
+            }
+        }
+        free(pathname);
+        if (rc != 0) {
+            logmsg("do_restore: extract failed, rc=%d\n", rc);
+            break;
+        }
+    }
+
+    tar_close(tar);
+    logmsg("do_restore: rc=%d\n", rc);
+
+    free(hash_name);
+    hash_name = NULL;
+
+    return rc;
+}
-- 
2.17.1

