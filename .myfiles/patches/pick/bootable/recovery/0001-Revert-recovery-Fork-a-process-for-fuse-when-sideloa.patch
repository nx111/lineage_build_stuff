From 3f4cabe5c6861332b1b59f6c5c718c52f6f29933 Mon Sep 17 00:00:00 2001
From: Tom Marshall <tdm.code@gmail.com>
Date: Fri, 8 Sep 2017 21:51:49 +0000
Subject: [PATCH 01/44] Revert "recovery: Fork a process for fuse when
 sideloading from SD card."

This reverts commit cdcf28f54f085520a96f4f9e480b8df324c5decb.

Change-Id: Ib62aa4a8439a1fab7db681730bf75ff35e41106a
---
 fuse_sdcard_provider.cpp | 74 ++++++++++++++++++++++++++++++++++------
 fuse_sdcard_provider.h   |  3 +-
 recovery.cpp             | 61 +++------------------------------
 3 files changed, 69 insertions(+), 69 deletions(-)

diff --git a/fuse_sdcard_provider.cpp b/fuse_sdcard_provider.cpp
index 46bdf177..81f927d2 100644
--- a/fuse_sdcard_provider.cpp
+++ b/fuse_sdcard_provider.cpp
@@ -21,6 +21,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <pthread.h>
 #include <sys/mount.h>
 #include <sys/stat.h>
 #include <unistd.h>
@@ -54,30 +55,81 @@ static int read_block_file(const file_data& fd, uint32_t block, uint8_t* buffer,
   return 0;
 }
 
-bool start_sdcard_fuse(const char* path) {
+struct token {
+    pthread_t th;
+    const char* path;
+    int result;
+};
+
+static void* run_sdcard_fuse(void* cookie) {
+  token* t = reinterpret_cast<token*>(cookie);
+
   struct stat sb;
-  if (stat(path, &sb) == -1) {
-    fprintf(stderr, "failed to stat %s: %s\n", path, strerror(errno));
-    return false;
+  if (stat(t->path, &sb) < 0) {
+    fprintf(stderr, "failed to stat %s: %s\n", t->path, strerror(errno));
+    t->result = -1;
+    return nullptr;
   }
 
-  file_data fd;
-  fd.fd = open(path, O_RDONLY);
-  if (fd.fd == -1) {
-    fprintf(stderr, "failed to open %s: %s\n", path, strerror(errno));
-    return false;
+  struct file_data fd;
+  struct provider_vtab vtab;
+
+  fd.fd = open(t->path, O_RDONLY);
+  if (fd.fd < 0) {
+    fprintf(stderr, "failed to open %s: %s\n", t->path, strerror(errno));
+    t->result = -1;
+    return nullptr;
   }
   fd.file_size = sb.st_size;
   fd.block_size = 65536;
 
-  provider_vtab vtab;
   vtab.read_block = std::bind(&read_block_file, fd, std::placeholders::_1, std::placeholders::_2,
                               std::placeholders::_3);
   vtab.close = [&fd]() { close(fd.fd); };
 
+  t->result = run_fuse_sideload(vtab, fd.file_size, fd.block_size);
+  return nullptr;
+}
+
+// How long (in seconds) we wait for the fuse-provided package file to
+// appear, before timing out.
+#define SDCARD_INSTALL_TIMEOUT 10
+
+void* start_sdcard_fuse(const char* path) {
+  token* t = new token;
+
+  t->path = path;
+  pthread_create(&(t->th), NULL, run_sdcard_fuse, t);
+
+  struct stat st;
+  int i;
+  for (i = 0; i < SDCARD_INSTALL_TIMEOUT; ++i) {
+    if (stat(FUSE_SIDELOAD_HOST_PATHNAME, &st) != 0) {
+      if (errno == ENOENT && i < SDCARD_INSTALL_TIMEOUT-1) {
+        sleep(1);
+        continue;
+      } else {
+        return nullptr;
+      }
+    }
+  }
+
   // The installation process expects to find the sdcard unmounted. Unmount it with MNT_DETACH so
   // that our open file continues to work but new references see it as unmounted.
   umount2("/sdcard", MNT_DETACH);
 
-  return run_fuse_sideload(vtab, fd.file_size, fd.block_size) == 0;
+  return t;
+}
+
+void finish_sdcard_fuse(void* cookie) {
+  if (cookie == NULL) return;
+  token* t = reinterpret_cast<token*>(cookie);
+
+  // Calling stat() on this magic filename signals the fuse
+  // filesystem to shut down.
+  struct stat st;
+  stat(FUSE_SIDELOAD_HOST_EXIT_PATHNAME, &st);
+
+  pthread_join(t->th, nullptr);
+  delete t;
 }
diff --git a/fuse_sdcard_provider.h b/fuse_sdcard_provider.h
index bdc60f2b..dc2982ca 100644
--- a/fuse_sdcard_provider.h
+++ b/fuse_sdcard_provider.h
@@ -17,6 +17,7 @@
 #ifndef __FUSE_SDCARD_PROVIDER_H
 #define __FUSE_SDCARD_PROVIDER_H
 
-bool start_sdcard_fuse(const char* path);
+void* start_sdcard_fuse(const char* path);
+void finish_sdcard_fuse(void* token);
 
 #endif
diff --git a/recovery.cpp b/recovery.cpp
index 07ec5cfb..3f8d5456 100644
--- a/recovery.cpp
+++ b/recovery.cpp
@@ -30,7 +30,6 @@
 #include <sys/klog.h>
 #include <sys/stat.h>
 #include <sys/types.h>
-#include <sys/wait.h>
 #include <time.h>
 #include <unistd.h>
 
@@ -1034,10 +1033,6 @@ static void run_graphics_test() {
   ui->ShowText(true);
 }
 
-// How long (in seconds) we wait for the fuse-provided package file to
-// appear, before timing out.
-#define SDCARD_INSTALL_TIMEOUT 10
-
 static int apply_from_sdcard(Device* device, bool* wipe_cache) {
     modified_flash = true;
 
@@ -1055,62 +1050,14 @@ static int apply_from_sdcard(Device* device, bool* wipe_cache) {
 
     ui->Print("\n-- Install %s ...\n", path.c_str());
     set_sdcard_update_bootloader_message();
+    void* token = start_sdcard_fuse(path.c_str());
 
-    // We used to use fuse in a thread as opposed to a process. Since accessing
-    // through fuse involves going from kernel to userspace to kernel, it leads
-    // to deadlock when a page fault occurs. (Bug: 26313124)
-    pid_t child;
-    if ((child = fork()) == 0) {
-        bool status = start_sdcard_fuse(path.c_str());
-
-        _exit(status ? EXIT_SUCCESS : EXIT_FAILURE);
-    }
-
-    // FUSE_SIDELOAD_HOST_PATHNAME will start to exist once the fuse in child
-    // process is ready.
-    int result = INSTALL_ERROR;
-    int status;
-    bool waited = false;
-    for (int i = 0; i < SDCARD_INSTALL_TIMEOUT; ++i) {
-        if (waitpid(child, &status, WNOHANG) == -1) {
-            result = INSTALL_ERROR;
-            waited = true;
-            break;
-        }
-
-        struct stat sb;
-        if (stat(FUSE_SIDELOAD_HOST_PATHNAME, &sb) == -1) {
-            if (errno == ENOENT && i < SDCARD_INSTALL_TIMEOUT-1) {
-                sleep(1);
-                continue;
-            } else {
-                LOG(ERROR) << "Timed out waiting for the fuse-provided package.";
-                result = INSTALL_ERROR;
-                kill(child, SIGKILL);
-                break;
-            }
-        }
-
-        result = install_package(FUSE_SIDELOAD_HOST_PATHNAME, wipe_cache,
+    int status = install_package(FUSE_SIDELOAD_HOST_PATHNAME, wipe_cache,
                                  TEMPORARY_INSTALL_FILE, false, 0/*retry_count*/);
-        break;
-    }
-
-    if (!waited) {
-        // Calling stat() on this magic filename signals the fuse
-        // filesystem to shut down.
-        struct stat sb;
-        stat(FUSE_SIDELOAD_HOST_EXIT_PATHNAME, &sb);
-
-        waitpid(child, &status, 0);
-    }
-
-    if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {
-        LOG(ERROR) << "Error exit from the fuse process: " << WEXITSTATUS(status);
-    }
 
+    finish_sdcard_fuse(token);
     ensure_path_unmounted(SDCARD_ROOT);
-    return result;
+    return status;
 }
 
 // Returns REBOOT, SHUTDOWN, or REBOOT_BOOTLOADER. Returning NO_ACTION means to take the default,
-- 
2.17.1

