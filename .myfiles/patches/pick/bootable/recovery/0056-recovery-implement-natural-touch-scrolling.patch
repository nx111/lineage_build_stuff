From 23f00794050f64f841b54916e0e47abf27ae7062 Mon Sep 17 00:00:00 2001
From: Alessandro Astone <ales.astone@gmail.com>
Date: Thu, 28 Mar 2019 22:02:02 +0100
Subject: [PATCH 56/62] recovery: implement natural touch scrolling

Change-Id: Ieedfc3a56cd341583700bfad31993879eb312ba6
---
 device.cpp    |  5 +++++
 device.h      |  2 ++
 recovery.cpp  |  6 ++++++
 screen_ui.cpp | 22 ++++++++++++++++++++++
 screen_ui.h   |  1 +
 stub_ui.h     |  1 +
 ui.cpp        |  2 +-
 ui.h          |  6 ++++++
 8 files changed, 44 insertions(+), 1 deletion(-)

diff --git a/device.cpp b/device.cpp
index 07d8f570..f1d2a3b7 100644
--- a/device.cpp
+++ b/device.cpp
@@ -168,6 +168,11 @@ int Device::HandleMenuKey(int key, bool visible) {
     case KEY_SEARCH:
       return kHighlightUp;
 
+    case KEY_SCROLLUP:
+        return kScrollUp;
+    case KEY_SCROLLDOWN:
+        return kScrollDown;
+
     case KEY_ENTER:
     case KEY_POWER:
     case BTN_MOUSE:
diff --git a/device.h b/device.h
index 4f36d754..86f9074a 100644
--- a/device.h
+++ b/device.h
@@ -100,6 +100,8 @@ class Device {
   static const int kGoBack = -5;
   static const int kGoHome = -6;
   static const int kRefresh = -7;
+  static const int kScrollUp = -8;
+  static const int kScrollDown = -9;
 
   // Called before and after we do a wipe data/factory reset operation, either via a reboot from the
   // main system with the --wipe_data flag, or when the user boots into recovery image manually and
diff --git a/recovery.cpp b/recovery.cpp
index 380f4f5d..ec677e9a 100644
--- a/recovery.cpp
+++ b/recovery.cpp
@@ -779,6 +779,12 @@ int get_menu_selection(bool menu_is_main,
         case Device::kHighlightDown:
           selected = ui->SelectMenu(++selected);
           break;
+        case Device::kScrollUp:
+          selected = ui->ScrollMenu(-1);
+          break;
+        case Device::kScrollDown:
+          selected = ui->ScrollMenu(1);
+          break;
         case Device::kInvokeItem:
           chosen_item = selected;
           if (chosen_item < 0) {
diff --git a/screen_ui.cpp b/screen_ui.cpp
index a1e23eba..858d420b 100644
--- a/screen_ui.cpp
+++ b/screen_ui.cpp
@@ -1266,6 +1266,28 @@ int ScreenRecoveryUI::SelectMenu(const Point& point) {
   return sel;
 }
 
+int ScreenRecoveryUI::ScrollMenu(int updown) {
+  pthread_mutex_lock(&updateMutex);
+  if ((updown > 0 && menu_show_start + menu_show_count < (int)menu_items_.size()) ||
+      (updown < 0 && menu_show_start > 0)) {
+    menu_show_start += updown;
+
+    /* We can receive a kInvokeItem event from a different source than touch,
+       like from Power button. For this reason, selection should not get out of
+       the screen. Constrain it to the first or last visible item of the list */
+    if (menu_sel < menu_show_start) {
+      menu_sel = menu_show_start;
+    }
+    else if(menu_sel >= menu_show_start + menu_show_count) {
+      menu_sel = menu_show_start + menu_show_count - 1;
+    }
+
+    update_screen_locked();
+  }
+  pthread_mutex_unlock(&updateMutex);
+  return menu_sel;
+}
+
 void ScreenRecoveryUI::EndMenu() {
   pthread_mutex_lock(&updateMutex);
   if (show_menu && text_rows_ > 0 && text_cols_ > 0) {
diff --git a/screen_ui.h b/screen_ui.h
index 51da1d82..3db6258a 100644
--- a/screen_ui.h
+++ b/screen_ui.h
@@ -104,6 +104,7 @@ class ScreenRecoveryUI : public RecoveryUI {
                  int initial_selection) override;
   int SelectMenu(int sel) override;
   int SelectMenu(const Point& point) override;
+  int ScrollMenu(int updown) override;
   void EndMenu() override;
 
   bool MenuShowing() const { return show_menu; }
diff --git a/stub_ui.h b/stub_ui.h
index acd87036..c9d1fd7d 100644
--- a/stub_ui.h
+++ b/stub_ui.h
@@ -66,6 +66,7 @@ class StubRecoveryUI : public RecoveryUI {
   int SelectMenu(const Point& /* point */) override {
     return 0;
   }
+  int ScrollMenu(int /* updown */) override { return 0; }
   void EndMenu() override {}
 
   bool MenuShowing() const { return true; }
diff --git a/ui.cpp b/ui.cpp
index 7526864a..02505329 100644
--- a/ui.cpp
+++ b/ui.cpp
@@ -246,7 +246,7 @@ void RecoveryUI::OnTouchTrack() {
     if (MenuShowing() && MenuScrollable()) {
       while (abs(touch_pos_.y() - touch_track_.y()) >= MenuItemHeight()) {
         int dy = touch_pos_.y() - touch_track_.y();
-        int key = (dy < 0) ? KEY_VOLUMEUP : KEY_VOLUMEDOWN;
+        int key = (dy < 0) ? KEY_SCROLLDOWN : KEY_SCROLLUP; // natural scrolling
         ProcessKey(key, 1); // press key
         ProcessKey(key, 0); // and release it
         int sgn = (dy > 0) - (dy < 0);
diff --git a/ui.h b/ui.h
index 0867848f..2d88fabc 100644
--- a/ui.h
+++ b/ui.h
@@ -234,6 +234,12 @@ class RecoveryUI {
   virtual int SelectMenu(int sel) = 0;
   virtual int SelectMenu(const Point& point) = 0;
 
+  // Scroll the view by increasing or lowering the first shown item
+  // If updown < 0, scroll up by |updown| items. If updown > 0, scroll down by |updown| items
+  // Returns the selected item, since scrolling past a selected item will change the selection to
+  // the closest on screen item
+  virtual int ScrollMenu(int updown) = 0;
+
   // Ends menu mode, resetting the text overlay so that ui_print() statements will be displayed.
   virtual void EndMenu() = 0;
 
-- 
2.17.1

