From 1c0b292c45bfcc42973bb86be751245bffc0f1bd Mon Sep 17 00:00:00 2001
From: Tom Marshall <tdm.code@gmail.com>
Date: Thu, 1 Mar 2018 23:51:51 +0100
Subject: [PATCH 35/44] recovery: Fix redraws, flickering, and animation

Rewrite screen drawing code to behave as follows:

 * draw_screen_locked has exactly two code paths: menu and non-menu.
    Non-menu code path draws background, foreground, and text.
 * Define screen background as the stage marker.
 * Define screen foreground as either the animation and progress bar
   or the icon and text.
 * Restore redraw optimizations in update_progress_locked.
 * Get rid of spurious screen updates.  The screen is only updated
    in StartMenu, SelectMenu, Redraw, and the progress thread.
 * Various changes and fixes to support the above.

Additionally:

 * Show error text on screen after failed install.
 * Rewrite graphics test code to better exercise the above.

Change-Id: I598bb11d5eef28275a6501cd44d514afe9939885
---
 recovery.cpp  |  28 ++++----
 screen_ui.cpp | 175 ++++++++++++++++++++++++++++----------------------
 screen_ui.h   |   4 +-
 stub_ui.h     |   1 +
 ui.cpp        |   2 +-
 ui.h          |   2 +
 wear_ui.cpp   |   4 +-
 7 files changed, 119 insertions(+), 97 deletions(-)

diff --git a/recovery.cpp b/recovery.cpp
index bf517664..855e9466 100644
--- a/recovery.cpp
+++ b/recovery.cpp
@@ -1166,36 +1166,31 @@ static int choose_recovery_file(Device* device) {
 }
 
 static void run_graphics_test() {
-  // Switch to graphics screen.
-  ui->ShowText(false);
-
-  ui->SetProgressType(RecoveryUI::INDETERMINATE);
-  ui->SetBackground(RecoveryUI::INSTALLING_UPDATE);
-  sleep(1);
-
   ui->SetBackground(RecoveryUI::ERROR);
+  ui->Redraw();
   sleep(1);
 
-  ui->SetBackground(RecoveryUI::NO_COMMAND);
+  ui->SetBackground(RecoveryUI::INSTALLING_UPDATE);
+  ui->Redraw();
   sleep(1);
 
   ui->SetBackground(RecoveryUI::ERASING);
+  ui->Redraw();
   sleep(1);
 
-  // Calling SetBackground() after SetStage() to trigger a redraw.
   ui->SetStage(1, 3);
-  ui->SetBackground(RecoveryUI::INSTALLING_UPDATE);
+  ui->Redraw();
   sleep(1);
   ui->SetStage(2, 3);
-  ui->SetBackground(RecoveryUI::INSTALLING_UPDATE);
+  ui->Redraw();
   sleep(1);
   ui->SetStage(3, 3);
-  ui->SetBackground(RecoveryUI::INSTALLING_UPDATE);
+  ui->Redraw();
   sleep(1);
 
   ui->SetStage(-1, -1);
-  ui->SetBackground(RecoveryUI::INSTALLING_UPDATE);
 
+  ui->SetBackground(RecoveryUI::INSTALLING_UPDATE);
   ui->SetProgressType(RecoveryUI::DETERMINATE);
   ui->ShowProgress(1.0, 10.0);
   float fraction = 0.0;
@@ -1204,8 +1199,6 @@ static void run_graphics_test() {
     ui->SetProgress(fraction);
     usleep(100000);
   }
-
-  ui->ShowText(true);
 }
 
 static int apply_from_storage(Device* device, VolumeInfo& vi, bool* wipe_cache) {
@@ -1383,9 +1376,13 @@ static Device::BuiltinAction prompt_and_wait(Device* device, int status) {
             }
 
             if (status != INSTALL_SUCCESS) {
+              ui->SetProgressType(RecoveryUI::EMPTY);
               ui->SetBackground(RecoveryUI::ERROR);
               ui->Print("Installation aborted.\n");
+              ui->Redraw();
               copy_logs();
+              ui->FlushKeys();
+              ui->WaitInputEvent();
             } else if (!ui->IsTextVisible()) {
               return Device::NO_ACTION;  // reboot if logs aren't visible
             } else {
@@ -1962,6 +1959,7 @@ int main(int argc, char **argv) {
   if (status == INSTALL_ERROR || status == INSTALL_CORRUPT) {
     ui->SetBackground(RecoveryUI::ERROR);
     if (!ui->IsTextVisible()) {
+      ui->Redraw();
       sleep(5);
     }
   }
diff --git a/screen_ui.cpp b/screen_ui.cpp
index 35ce6eaf..e24dafb7 100644
--- a/screen_ui.cpp
+++ b/screen_ui.cpp
@@ -159,7 +159,7 @@ GRSurface* ScreenRecoveryUI::GetCurrentFrame() const {
   if (currentIcon == INSTALLING_UPDATE || currentIcon == ERASING) {
     return intro_done ? loopFrames[current_frame] : introFrames[current_frame];
   }
-  return error_icon;
+  return nullptr;
 }
 
 GRSurface* ScreenRecoveryUI::GetCurrentText() const {
@@ -222,80 +222,94 @@ int ScreenRecoveryUI::GetProgressBaseline() const {
   return ScreenHeight() - bottom_gap - gr_get_height(progressBarFill);
 }
 
-// Clear the screen and draw the currently selected background icon (if any).
-// Should only be called with updateMutex locked.
+// Draw the currently selected stage icon(s) (if any).
+// Does not flip pages. Should only be called with updateMutex locked.
 void ScreenRecoveryUI::draw_background_locked() {
-  pagesIdentical = false;
-  gr_color(0, 0, 0, 255);
-  gr_clear();
-  if (currentIcon != NONE) {
+  if (currentIcon != NONE && currentIcon != NO_COMMAND) {
     if (max_stage != -1) {
       int stage_height = gr_get_height(stageMarkerEmpty);
       int stage_width = gr_get_width(stageMarkerEmpty);
-      int x = kMarginWidth + (ScreenWidth() - max_stage * gr_get_width(stageMarkerEmpty)) / 2;
-      int y = kMarginHeight + ScreenHeight() - stage_height;
+      int stage_x = kMarginWidth + (ScreenWidth() - max_stage * gr_get_width(stageMarkerEmpty)) / 2;
+      int stage_y = kMarginHeight;
       for (int i = 0; i < max_stage; ++i) {
         GRSurface* stage_surface = (i < stage) ? stageMarkerFill : stageMarkerEmpty;
-        DrawSurface(stage_surface, 0, 0, stage_width, stage_height, x, y);
-        x += stage_width;
+        DrawSurface(stage_surface, 0, 0, stage_width, stage_height, stage_x, stage_y);
+        stage_x += stage_width;
       }
     }
-
-    GRSurface* text_surface = GetCurrentText();
-    int text_x = kMarginWidth + (ScreenWidth() - gr_get_width(text_surface)) / 2;
-    int text_y = kMarginHeight + GetTextBaseline();
-    gr_color(255, 255, 255, 255);
-    DrawTextIcon(text_x, text_y, text_surface);
   }
 }
 
-// Draws the animation and progress bar (if any) on the screen. Does not flip pages. Should only be
-// called with updateMutex locked.
-void ScreenRecoveryUI::draw_foreground_locked() {
-  if (currentIcon != NONE && currentIcon != NO_COMMAND) {
-    gr_color(0, 0, 0, 255);
-    gr_clear();
-    GRSurface* frame = GetCurrentFrame();
+// Draws either the animation and progress bar or the currently
+// selected icon and text on the screen.
+// Does not flip pages. Should only be called with updateMutex locked.
+void ScreenRecoveryUI::draw_foreground_locked(int& y) {
+  GRSurface* frame = GetCurrentFrame();
+  if (frame) {
+    // Show animation frame and progress bar
     int frame_width = gr_get_width(frame);
     int frame_height = gr_get_height(frame);
     int frame_x = kMarginWidth + (ScreenWidth() - frame_width) / 2;
     int frame_y = kMarginHeight + GetAnimationBaseline();
     DrawSurface(frame, 0, 0, frame_width, frame_height, frame_x, frame_y);
-  }
+    y = frame_y + frame_height;
 
-  if (progressBarType != EMPTY) {
-    int width = gr_get_width(progressBarEmpty);
-    int height = gr_get_height(progressBarEmpty);
+    if (progressBarType != EMPTY) {
+      int width = gr_get_width(progressBarEmpty);
+      int height = gr_get_height(progressBarEmpty);
 
-    int progress_x = kMarginWidth + (ScreenWidth() - width) / 2;
-    int progress_y = kMarginHeight + GetProgressBaseline();
+      int progress_x = kMarginWidth + (ScreenWidth() - width) / 2;
+      int progress_y = kMarginHeight + GetProgressBaseline();
 
-    // Erase behind the progress bar (in case this was a progress-only update)
-    gr_color(0, 0, 0, 255);
-    DrawFill(progress_x, progress_y, width, height);
+      // Erase behind the progress bar (in case this was a progress-only update)
+      gr_color(0, 0, 0, 255);
+      DrawFill(progress_x, progress_y, width, height);
 
-    if (progressBarType == DETERMINATE) {
-      float p = progressScopeStart + progress * progressScopeSize;
-      int pos = static_cast<int>(p * width);
+      if (progressBarType == DETERMINATE) {
+        float p = progressScopeStart + progress * progressScopeSize;
+        int pos = static_cast<int>(p * width);
 
-      if (rtl_locale_) {
-        // Fill the progress bar from right to left.
-        if (pos > 0) {
-          DrawSurface(progressBarFill, width - pos, 0, pos, height, progress_x + width - pos,
-                      progress_y);
-        }
-        if (pos < width - 1) {
-          DrawSurface(progressBarEmpty, 0, 0, width - pos, height, progress_x, progress_y);
-        }
-      } else {
-        // Fill the progress bar from left to right.
-        if (pos > 0) {
-          DrawSurface(progressBarFill, 0, 0, pos, height, progress_x, progress_y);
-        }
-        if (pos < width - 1) {
-          DrawSurface(progressBarEmpty, pos, 0, width - pos, height, progress_x + pos, progress_y);
+        if (rtl_locale_) {
+          // Fill the progress bar from right to left.
+          if (pos > 0) {
+            DrawSurface(progressBarFill, width - pos, 0, pos, height, progress_x + width - pos,
+                        progress_y);
+          }
+          if (pos < width - 1) {
+            DrawSurface(progressBarEmpty, 0, 0, width - pos, height, progress_x, progress_y);
+          }
+        } else {
+          // Fill the progress bar from left to right.
+          if (pos > 0) {
+            DrawSurface(progressBarFill, 0, 0, pos, height, progress_x, progress_y);
+          }
+          if (pos < width - 1) {
+            DrawSurface(progressBarEmpty, pos, 0, width - pos, height, progress_x + pos, progress_y);
+          }
         }
       }
+      y = progress_y + height;
+    }
+  }
+  else {
+    // Show icon and text
+    if (currentIcon != NONE && currentIcon != NO_COMMAND) {
+      GRSurface* icon_surface = error_icon;
+      int icon_width = gr_get_width(icon_surface);
+      int icon_height = gr_get_height(icon_surface);
+      int icon_x = kMarginWidth + (gr_fb_width() - icon_width) / 2;
+      int icon_y = kMarginHeight + GetAnimationBaseline();
+      gr_blit(icon_surface, 0, 0, icon_width, icon_height, icon_x, icon_y);
+
+      GRSurface* text_surface = GetCurrentText();
+      int text_width = gr_get_width(text_surface);
+      int text_height = gr_get_height(text_surface);
+      int text_x = kMarginWidth + (gr_fb_width() - text_width) / 2;
+      int text_y = kMarginHeight + GetTextBaseline();
+      gr_color(255, 255, 255, 255);
+      gr_texticon(text_x, text_y, text_surface);
+
+      y = text_y + text_height;
     }
   }
 }
@@ -691,12 +705,7 @@ void ScreenRecoveryUI::draw_grid_menu_locked(int& y) {
 // Redraws everything on the screen. Does not flip pages. Should only be called with updateMutex
 // locked.
 void ScreenRecoveryUI::draw_screen_locked() {
-  if (!show_text) {
-    draw_background_locked();
-    draw_foreground_locked();
-    return;
-  }
-
+  pagesIdentical = false;
   gr_color(0, 0, 0, 255);
   gr_clear();
 
@@ -726,16 +735,21 @@ void ScreenRecoveryUI::draw_screen_locked() {
     }
   }
   else {
-    // Display from the bottom up, until we hit the top of the screen, the bottom of the menu, or
-    // we've displayed the entire text buffer.
-    SetColor(LOG);
-    int row = (text_rows_ - 1) % text_rows_;
-    size_t count = 0;
-    for (int ty = gr_fb_height() - kMarginHeight - char_height_; ty >= y && count < text_rows_;
-         ty -= char_height_, ++count) {
-      DrawTextLine(kMarginWidth, ty, text_[row], false);
-      --row;
-      if (row < 0) row = text_rows_ - 1;
+    draw_background_locked();
+    draw_foreground_locked(y);
+
+    if (show_text) {
+      // Display from the bottom up, until we hit the top of the screen, the
+      // bottom of the foreground, or we've displayed the entire text buffer.
+      SetColor(LOG);
+      int row = (text_rows_ - 1) % text_rows_;
+      size_t count = 0;
+      for (int ty = gr_fb_height() - kMarginHeight - char_height_; ty >= y && count < text_rows_;
+           ty -= char_height_, ++count) {
+        DrawTextLine(kMarginWidth, ty, text_[row], false);
+        --row;
+        if (row < 0) row = text_rows_ - 1;
+      }
     }
   }
 }
@@ -750,7 +764,14 @@ void ScreenRecoveryUI::update_screen_locked() {
 // Updates only the progress bar, if possible, otherwise redraws the screen.
 // Should only be called with updateMutex locked.
 void ScreenRecoveryUI::update_progress_locked() {
-  draw_foreground_locked();
+  if (!pagesIdentical) {
+    draw_screen_locked();
+    pagesIdentical = true;
+  }
+  else {
+    int y = kMarginHeight;
+    draw_foreground_locked(y);
+  }
   gr_flip();
 }
 
@@ -846,7 +867,6 @@ void ScreenRecoveryUI::SetSystemUpdateText(bool security_update) {
   } else {
     LoadLocalizedBitmap("installing_text", &installing_text);
   }
-  Redraw();
 }
 
 bool ScreenRecoveryUI::InitTextParams() {
@@ -953,7 +973,6 @@ void ScreenRecoveryUI::SetBackground(Icon icon) {
 
   if (icon != currentIcon) {
     currentIcon = icon;
-    update_screen_locked();
   }
 
   pthread_mutex_unlock(&updateMutex);
@@ -963,14 +982,14 @@ void ScreenRecoveryUI::SetProgressType(ProgressType type) {
   pthread_mutex_lock(&updateMutex);
   if (progressBarType != type) {
     progressBarType = type;
+    progressScopeStart = 0;
+    progressScopeSize = 0;
+    progress = 0;
     if (progressBarType != EMPTY) {
+      update_screen_locked();
       pthread_create(&progress_thread_, nullptr, ProgressThreadStartRoutine, this);
     }
   }
-  progressScopeStart = 0;
-  progressScopeSize = 0;
-  progress = 0;
-  update_progress_locked();
   pthread_mutex_unlock(&updateMutex);
 }
 
@@ -1028,7 +1047,6 @@ void ScreenRecoveryUI::PrintV(const char* fmt, bool copy_to_stdout, va_list ap)
       if (*ptr != '\n') text_[text_row_][text_col_++] = *ptr;
     }
     text_[text_row_][text_col_] = '\0';
-    update_screen_locked();
   }
   pthread_mutex_unlock(&updateMutex);
 }
@@ -1131,6 +1149,9 @@ int ScreenRecoveryUI::ShowFile(const char* filename) {
     return -1;
   }
 
+  Icon oldIcon = currentIcon;
+  currentIcon = NONE;
+
   char** old_text = text_;
   size_t old_text_col = text_col_;
   size_t old_text_row = text_row_;
@@ -1145,6 +1166,7 @@ int ScreenRecoveryUI::ShowFile(const char* filename) {
   text_ = old_text;
   text_col_ = old_text_col;
   text_row_ = old_text_row;
+  currentIcon = oldIcon;
   return key;
 }
 
@@ -1273,7 +1295,6 @@ void ScreenRecoveryUI::ShowText(bool visible) {
   pthread_mutex_lock(&updateMutex);
   show_text = visible;
   if (show_text) show_text_ever = true;
-  update_screen_locked();
   pthread_mutex_unlock(&updateMutex);
 }
 
diff --git a/screen_ui.h b/screen_ui.h
index b5b5031a..51da1d82 100644
--- a/screen_ui.h
+++ b/screen_ui.h
@@ -113,7 +113,7 @@ class ScreenRecoveryUI : public RecoveryUI {
 
   void KeyLongPress(int) override;
 
-  void Redraw();
+  void Redraw() override;
 
   void SetColor(UIElement e) const;
 
@@ -136,7 +136,7 @@ class ScreenRecoveryUI : public RecoveryUI {
   virtual bool InitTextParams();
 
   virtual void draw_background_locked();
-  virtual void draw_foreground_locked();
+  virtual void draw_foreground_locked(int& y);
   virtual void draw_statusbar_locked();
   virtual void draw_header_locked(int& y);
   virtual void draw_text_menu_locked(int& y);
diff --git a/stub_ui.h b/stub_ui.h
index 5364d984..acd87036 100644
--- a/stub_ui.h
+++ b/stub_ui.h
@@ -52,6 +52,7 @@ class StubRecoveryUI : public RecoveryUI {
   }
   void PrintOnScreenOnly(const char* /* fmt */, ...) override {}
   int ShowFile(const char* /* filename */) override { return -1; }
+  void Redraw() override {}
 
   // menu display
   void StartMenu(bool /* is_main */,
diff --git a/ui.cpp b/ui.cpp
index e000bb3f..99fa7f40 100644
--- a/ui.cpp
+++ b/ui.cpp
@@ -532,7 +532,6 @@ RecoveryUI::InputEvent RecoveryUI::WaitInputEvent() {
 
     int rc = 0;
     while (event_queue_len == 0 && rc != ETIMEDOUT) {
-      Print(""); // Force screen update
       struct timespec key_timeout;
       gettimeofday(&now, nullptr);
       key_timeout.tv_sec = now.tv_sec + 1;
@@ -546,6 +545,7 @@ RecoveryUI::InputEvent RecoveryUI::WaitInputEvent() {
         }
         if (key_timeout.tv_sec <= timeout.tv_sec) {
           rc = 0;
+          ui->Redraw();
         }
       }
     }
diff --git a/ui.h b/ui.h
index 18088d15..0867848f 100644
--- a/ui.h
+++ b/ui.h
@@ -152,6 +152,8 @@ class RecoveryUI {
 
   virtual int ShowFile(const char* filename) = 0;
 
+  virtual void Redraw() = 0;
+
   // --- event handling ---
 
   enum event_type_t { EVENT_TYPE_NONE, EVENT_TYPE_KEY, EVENT_TYPE_TOUCH };
diff --git a/wear_ui.cpp b/wear_ui.cpp
index 98cd156a..3580333e 100644
--- a/wear_ui.cpp
+++ b/wear_ui.cpp
@@ -71,15 +71,15 @@ static const char* SWIPE_HELP[] = {
 // TODO merge drawing routines with screen_ui
 void WearRecoveryUI::draw_screen_locked() {
   char cur_selection_str[50];
+  int y = kMarginHeight;
 
   draw_background_locked();
   if (!show_text) {
-    draw_foreground_locked();
+    draw_foreground_locked(y);
   } else {
     SetColor(TEXT_FILL);
     gr_fill(0, 0, gr_fb_width(), gr_fb_height());
 
-    int y = kMarginHeight;
     int x = kMarginWidth;
     if (show_menu) {
       std::string recovery_fingerprint =
-- 
2.17.1

