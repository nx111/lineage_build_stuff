From 72d16374cedb88e3c86027a95008511779d27790 Mon Sep 17 00:00:00 2001
From: Luca Stefani <luca.stefani.ge1@gmail.com>
Date: Tue, 5 Feb 2019 09:34:29 +0100
Subject: [PATCH] Squash of
 github/lineage-16.0(ac96e5bf49)..lineage-16.0-android-9.0.0_r31(4b321e001b)
 (DO NOT SUBMIT)

David Brazdil (1):
 - Only warn if a pre-P app overrides inlined methods at runtime

Jesse Schettler (2):
 - Change FATAL message to WARNING message in FindClass
 - Change ART FindClass method name to GetClass

Luca Stefani (1):
 - Merge tag 'android-9.0.0_r31' into lineage-16.0-android-9.0.0_r31

Nicolas Geoffray (1):
 - Fix ARM code generator for Select.

TreeHugger Robot (1):
 - Merge "Fix ARM code generator for Select." into pi-dev

Vladimir Marko (2):
 - Fix VecLoad/Int16/StringCharAt.
 - Remove some SIMD recognition code.

android-build-team Robot (3):
 - Snap for 5044688 from b4cf9134a3b2cf9c743a88db131e0bd8b08b2904 to
   pi-qpr2-release
 - Snap for 5087486 from e654da321d83c169f8e995d5134d135c951a3177 to
   pi-qpr2-release
 - Snap for 5135467 from f51e6147e09580dbd1f1065d873fd906cf5a33ca to
   pi-qpr2-release

Change-Id: I8e32c5b1a2266b88a6eaa947ef923aad647de6cc

Change-Id: I86aeeb11d44bbe98d11cb31bd1ad0722abebd3ae
---
 .../optimizing/code_generator_arm_vixl.cc     |  61 ++---
 .../optimizing/code_generator_vector_arm64.cc |   2 +-
 .../optimizing/code_generator_vector_x86.cc   |   2 +-
 .../code_generator_vector_x86_64.cc           |   2 +-
 compiler/optimizing/loop_optimization.cc      | 104 +--------
 compiler/optimizing/loop_optimization.h       |  12 +-
 runtime/entrypoints/entrypoint_utils-inl.h    |  20 +-
 .../src/Main.java                             |  19 ++
 .../651-checker-byte-simd-minmax/expected.txt |   1 -
 test/651-checker-byte-simd-minmax/info.txt    |   1 -
 .../src/Main.java                             | 196 ----------------
 .../651-checker-char-simd-minmax/expected.txt |   1 -
 test/651-checker-char-simd-minmax/info.txt    |   1 -
 .../src/Main.java                             | 132 -----------
 .../expected.txt                              |   1 -
 test/651-checker-double-simd-minmax/info.txt  |   1 -
 .../src/Main.java                             | 126 -----------
 .../expected.txt                              |   1 -
 test/651-checker-float-simd-minmax/info.txt   |   1 -
 .../src/Main.java                             | 126 -----------
 test/651-checker-int-simd-minmax/expected.txt |   1 -
 test/651-checker-int-simd-minmax/info.txt     |   1 -
 .../651-checker-int-simd-minmax/src/Main.java | 104 ---------
 .../651-checker-long-simd-minmax/expected.txt |   1 -
 test/651-checker-long-simd-minmax/info.txt    |   1 -
 .../src/Main.java                             | 121 ----------
 .../expected.txt                              |   1 -
 test/651-checker-short-simd-minmax/info.txt   |   1 -
 .../src/Main.java                             | 210 ------------------
 test/661-checker-simd-reduc/src/Main.java     | 168 --------------
 test/684-select-condition/expected.txt        |   0
 test/684-select-condition/info.txt            |   1 +
 test/684-select-condition/src/Main.java       |  83 +++++++
 test/ti-agent/jni_binder.cc                   |   6 +-
 test/ti-agent/jni_binder.h                    |   2 +-
 35 files changed, 169 insertions(+), 1342 deletions(-)
 delete mode 100644 test/651-checker-byte-simd-minmax/expected.txt
 delete mode 100644 test/651-checker-byte-simd-minmax/info.txt
 delete mode 100644 test/651-checker-byte-simd-minmax/src/Main.java
 delete mode 100644 test/651-checker-char-simd-minmax/expected.txt
 delete mode 100644 test/651-checker-char-simd-minmax/info.txt
 delete mode 100644 test/651-checker-char-simd-minmax/src/Main.java
 delete mode 100644 test/651-checker-double-simd-minmax/expected.txt
 delete mode 100644 test/651-checker-double-simd-minmax/info.txt
 delete mode 100644 test/651-checker-double-simd-minmax/src/Main.java
 delete mode 100644 test/651-checker-float-simd-minmax/expected.txt
 delete mode 100644 test/651-checker-float-simd-minmax/info.txt
 delete mode 100644 test/651-checker-float-simd-minmax/src/Main.java
 delete mode 100644 test/651-checker-int-simd-minmax/expected.txt
 delete mode 100644 test/651-checker-int-simd-minmax/info.txt
 delete mode 100644 test/651-checker-int-simd-minmax/src/Main.java
 delete mode 100644 test/651-checker-long-simd-minmax/expected.txt
 delete mode 100644 test/651-checker-long-simd-minmax/info.txt
 delete mode 100644 test/651-checker-long-simd-minmax/src/Main.java
 delete mode 100644 test/651-checker-short-simd-minmax/expected.txt
 delete mode 100644 test/651-checker-short-simd-minmax/info.txt
 delete mode 100644 test/651-checker-short-simd-minmax/src/Main.java
 create mode 100644 test/684-select-condition/expected.txt
 create mode 100644 test/684-select-condition/info.txt
 create mode 100644 test/684-select-condition/src/Main.java

diff --git a/compiler/optimizing/code_generator_arm_vixl.cc b/compiler/optimizing/code_generator_arm_vixl.cc
index 2f495fc15f..2452139d42 100644
--- a/compiler/optimizing/code_generator_arm_vixl.cc
+++ b/compiler/optimizing/code_generator_arm_vixl.cc
@@ -3078,6 +3078,18 @@ void InstructionCodeGeneratorARMVIXL::VisitSelect(HSelect* select) {
   const Location first = locations->InAt(0);
   const Location out = locations->Out();
   const Location second = locations->InAt(1);
+
+  // In the unlucky case the output of this instruction overlaps
+  // with an input of an "emitted-at-use-site" condition, and
+  // the output of this instruction is not one of its inputs, we'll
+  // need to fallback to branches instead of conditional ARM instructions.
+  bool output_overlaps_with_condition_inputs =
+      !IsBooleanValueOrMaterializedCondition(condition) &&
+      !out.Equals(first) &&
+      !out.Equals(second) &&
+      (condition->GetLocations()->InAt(0).Equals(out) ||
+       condition->GetLocations()->InAt(1).Equals(out));
+  DCHECK(!output_overlaps_with_condition_inputs || condition->IsCondition());
   Location src;
 
   if (condition->IsIntConstant()) {
@@ -3091,7 +3103,7 @@ void InstructionCodeGeneratorARMVIXL::VisitSelect(HSelect* select) {
     return;
   }
 
-  if (!DataType::IsFloatingPointType(type)) {
+  if (!DataType::IsFloatingPointType(type) && !output_overlaps_with_condition_inputs) {
     bool invert = false;
 
     if (out.Equals(second)) {
@@ -3163,6 +3175,7 @@ void InstructionCodeGeneratorARMVIXL::VisitSelect(HSelect* select) {
   vixl32::Label* false_target = nullptr;
   vixl32::Label* true_target = nullptr;
   vixl32::Label select_end;
+  vixl32::Label other_case;
   vixl32::Label* const target = codegen_->GetFinalLabel(select, &select_end);
 
   if (out.Equals(second)) {
@@ -3173,12 +3186,21 @@ void InstructionCodeGeneratorARMVIXL::VisitSelect(HSelect* select) {
     src = second;
 
     if (!out.Equals(first)) {
-      codegen_->MoveLocation(out, first, type);
+      if (output_overlaps_with_condition_inputs) {
+        false_target = &other_case;
+      } else {
+        codegen_->MoveLocation(out, first, type);
+      }
     }
   }
 
   GenerateTestAndBranch(select, 2, true_target, false_target, /* far_target */ false);
   codegen_->MoveLocation(out, src, type);
+  if (output_overlaps_with_condition_inputs) {
+    __ B(target);
+    __ Bind(&other_case);
+    codegen_->MoveLocation(out, first, type);
+  }
 
   if (select_end.IsReferenced()) {
     __ Bind(&select_end);
@@ -3277,31 +3299,16 @@ void CodeGeneratorARMVIXL::GenerateConditionWithZero(IfCondition condition,
 void LocationsBuilderARMVIXL::HandleCondition(HCondition* cond) {
   LocationSummary* locations =
       new (GetGraph()->GetAllocator()) LocationSummary(cond, LocationSummary::kNoCall);
-  // Handle the long/FP comparisons made in instruction simplification.
-  switch (cond->InputAt(0)->GetType()) {
-    case DataType::Type::kInt64:
-      locations->SetInAt(0, Location::RequiresRegister());
-      locations->SetInAt(1, Location::RegisterOrConstant(cond->InputAt(1)));
-      if (!cond->IsEmittedAtUseSite()) {
-        locations->SetOut(Location::RequiresRegister(), Location::kNoOutputOverlap);
-      }
-      break;
-
-    case DataType::Type::kFloat32:
-    case DataType::Type::kFloat64:
-      locations->SetInAt(0, Location::RequiresFpuRegister());
-      locations->SetInAt(1, ArithmeticZeroOrFpuRegister(cond->InputAt(1)));
-      if (!cond->IsEmittedAtUseSite()) {
-        locations->SetOut(Location::RequiresRegister(), Location::kNoOutputOverlap);
-      }
-      break;
-
-    default:
-      locations->SetInAt(0, Location::RequiresRegister());
-      locations->SetInAt(1, Location::RegisterOrConstant(cond->InputAt(1)));
-      if (!cond->IsEmittedAtUseSite()) {
-        locations->SetOut(Location::RequiresRegister(), Location::kNoOutputOverlap);
-      }
+  const DataType::Type type = cond->InputAt(0)->GetType();
+  if (DataType::IsFloatingPointType(type)) {
+    locations->SetInAt(0, Location::RequiresFpuRegister());
+    locations->SetInAt(1, ArithmeticZeroOrFpuRegister(cond->InputAt(1)));
+  } else {
+    locations->SetInAt(0, Location::RequiresRegister());
+    locations->SetInAt(1, Location::RegisterOrConstant(cond->InputAt(1)));
+  }
+  if (!cond->IsEmittedAtUseSite()) {
+    locations->SetOut(Location::RequiresRegister(), Location::kNoOutputOverlap);
   }
 }
 
diff --git a/compiler/optimizing/code_generator_vector_arm64.cc b/compiler/optimizing/code_generator_vector_arm64.cc
index 174efdf115..1cfdf54816 100644
--- a/compiler/optimizing/code_generator_vector_arm64.cc
+++ b/compiler/optimizing/code_generator_vector_arm64.cc
@@ -1290,6 +1290,7 @@ void InstructionCodeGeneratorARM64::VisitVecLoad(HVecLoad* instruction) {
   Register scratch;
 
   switch (instruction->GetPackedType()) {
+    case DataType::Type::kInt16:  // (short) s.charAt(.) can yield HVecLoad/Int16/StringCharAt.
     case DataType::Type::kUint16:
       DCHECK_EQ(8u, instruction->GetVectorLength());
       // Special handling of compressed/uncompressed string load.
@@ -1321,7 +1322,6 @@ void InstructionCodeGeneratorARM64::VisitVecLoad(HVecLoad* instruction) {
     case DataType::Type::kBool:
     case DataType::Type::kUint8:
     case DataType::Type::kInt8:
-    case DataType::Type::kInt16:
     case DataType::Type::kInt32:
     case DataType::Type::kFloat32:
     case DataType::Type::kInt64:
diff --git a/compiler/optimizing/code_generator_vector_x86.cc b/compiler/optimizing/code_generator_vector_x86.cc
index f2ffccc887..4945328e2b 100644
--- a/compiler/optimizing/code_generator_vector_x86.cc
+++ b/compiler/optimizing/code_generator_vector_x86.cc
@@ -1141,6 +1141,7 @@ void InstructionCodeGeneratorX86::VisitVecLoad(HVecLoad* instruction) {
   XmmRegister reg = locations->Out().AsFpuRegister<XmmRegister>();
   bool is_aligned16 = instruction->GetAlignment().IsAlignedAt(16);
   switch (instruction->GetPackedType()) {
+    case DataType::Type::kInt16:  // (short) s.charAt(.) can yield HVecLoad/Int16/StringCharAt.
     case DataType::Type::kUint16:
       DCHECK_EQ(8u, instruction->GetVectorLength());
       // Special handling of compressed/uncompressed string load.
@@ -1168,7 +1169,6 @@ void InstructionCodeGeneratorX86::VisitVecLoad(HVecLoad* instruction) {
     case DataType::Type::kBool:
     case DataType::Type::kUint8:
     case DataType::Type::kInt8:
-    case DataType::Type::kInt16:
     case DataType::Type::kInt32:
     case DataType::Type::kInt64:
       DCHECK_LE(2u, instruction->GetVectorLength());
diff --git a/compiler/optimizing/code_generator_vector_x86_64.cc b/compiler/optimizing/code_generator_vector_x86_64.cc
index e2b0485f89..a77c7d6838 100644
--- a/compiler/optimizing/code_generator_vector_x86_64.cc
+++ b/compiler/optimizing/code_generator_vector_x86_64.cc
@@ -1114,6 +1114,7 @@ void InstructionCodeGeneratorX86_64::VisitVecLoad(HVecLoad* instruction) {
   XmmRegister reg = locations->Out().AsFpuRegister<XmmRegister>();
   bool is_aligned16 = instruction->GetAlignment().IsAlignedAt(16);
   switch (instruction->GetPackedType()) {
+    case DataType::Type::kInt16:  // (short) s.charAt(.) can yield HVecLoad/Int16/StringCharAt.
     case DataType::Type::kUint16:
       DCHECK_EQ(8u, instruction->GetVectorLength());
       // Special handling of compressed/uncompressed string load.
@@ -1141,7 +1142,6 @@ void InstructionCodeGeneratorX86_64::VisitVecLoad(HVecLoad* instruction) {
     case DataType::Type::kBool:
     case DataType::Type::kUint8:
     case DataType::Type::kInt8:
-    case DataType::Type::kInt16:
     case DataType::Type::kInt32:
     case DataType::Type::kInt64:
       DCHECK_LE(2u, instruction->GetVectorLength());
diff --git a/compiler/optimizing/loop_optimization.cc b/compiler/optimizing/loop_optimization.cc
index 899496328e..9f278a9f4e 100644
--- a/compiler/optimizing/loop_optimization.cc
+++ b/compiler/optimizing/loop_optimization.cc
@@ -334,29 +334,12 @@ static bool IsAddConst(HInstruction* instruction,
 // Detect reductions of the following forms,
 //   x = x_phi + ..
 //   x = x_phi - ..
-//   x = max(x_phi, ..)
-//   x = min(x_phi, ..)
 static bool HasReductionFormat(HInstruction* reduction, HInstruction* phi) {
   if (reduction->IsAdd()) {
     return (reduction->InputAt(0) == phi && reduction->InputAt(1) != phi) ||
            (reduction->InputAt(0) != phi && reduction->InputAt(1) == phi);
   } else if (reduction->IsSub()) {
     return (reduction->InputAt(0) == phi && reduction->InputAt(1) != phi);
-  } else if (reduction->IsInvokeStaticOrDirect()) {
-    switch (reduction->AsInvokeStaticOrDirect()->GetIntrinsic()) {
-      case Intrinsics::kMathMinIntInt:
-      case Intrinsics::kMathMinLongLong:
-      case Intrinsics::kMathMinFloatFloat:
-      case Intrinsics::kMathMinDoubleDouble:
-      case Intrinsics::kMathMaxIntInt:
-      case Intrinsics::kMathMaxLongLong:
-      case Intrinsics::kMathMaxFloatFloat:
-      case Intrinsics::kMathMaxDoubleDouble:
-        return (reduction->InputAt(0) == phi && reduction->InputAt(1) != phi) ||
-               (reduction->InputAt(0) != phi && reduction->InputAt(1) == phi);
-      default:
-        return false;
-    }
   }
   return false;
 }
@@ -365,10 +348,6 @@ static bool HasReductionFormat(HInstruction* reduction, HInstruction* phi) {
 static HVecReduce::ReductionKind GetReductionKind(HVecOperation* reduction) {
   if (reduction->IsVecAdd() || reduction->IsVecSub() || reduction->IsVecSADAccumulate()) {
     return HVecReduce::kSum;
-  } else if (reduction->IsVecMin()) {
-    return HVecReduce::kMin;
-  } else if (reduction->IsVecMax()) {
-    return HVecReduce::kMax;
   }
   LOG(FATAL) << "Unsupported SIMD reduction " << reduction->GetId();
   UNREACHABLE();
@@ -1124,7 +1103,6 @@ bool HLoopOptimization::VectorizeDef(LoopNode* node,
   return !IsUsedOutsideLoop(node->loop_info, instruction) && !instruction->DoesAnyWrite();
 }
 
-// TODO: saturation arithmetic.
 bool HLoopOptimization::VectorizeUse(LoopNode* node,
                                      HInstruction* instruction,
                                      bool generate_code,
@@ -1331,43 +1309,6 @@ bool HLoopOptimization::VectorizeUse(LoopNode* node,
         }
         return false;
       }
-      case Intrinsics::kMathMinIntInt:
-      case Intrinsics::kMathMinLongLong:
-      case Intrinsics::kMathMinFloatFloat:
-      case Intrinsics::kMathMinDoubleDouble:
-      case Intrinsics::kMathMaxIntInt:
-      case Intrinsics::kMathMaxLongLong:
-      case Intrinsics::kMathMaxFloatFloat:
-      case Intrinsics::kMathMaxDoubleDouble: {
-        // Deal with vector restrictions.
-        HInstruction* opa = instruction->InputAt(0);
-        HInstruction* opb = instruction->InputAt(1);
-        HInstruction* r = opa;
-        HInstruction* s = opb;
-        bool is_unsigned = false;
-        if (HasVectorRestrictions(restrictions, kNoMinMax)) {
-          return false;
-        } else if (HasVectorRestrictions(restrictions, kNoHiBits) &&
-                   !IsNarrowerOperands(opa, opb, type, &r, &s, &is_unsigned)) {
-          return false;  // reject, unless all operands are same-extension narrower
-        }
-        // Accept MIN/MAX(x, y) for vectorizable operands.
-        DCHECK(r != nullptr);
-        DCHECK(s != nullptr);
-        if (generate_code && vector_mode_ != kVector) {  // de-idiom
-          r = opa;
-          s = opb;
-        }
-        if (VectorizeUse(node, r, generate_code, type, restrictions) &&
-            VectorizeUse(node, s, generate_code, type, restrictions)) {
-          if (generate_code) {
-            GenerateVecOp(
-                instruction, vector_map_->Get(r), vector_map_->Get(s), type, is_unsigned);
-          }
-          return true;
-        }
-        return false;
-      }
       default:
         return false;
     }  // switch
@@ -1426,7 +1367,7 @@ bool HLoopOptimization::TrySetVectorType(DataType::Type type, uint64_t* restrict
           *restrictions |= kNoDiv;
           return TrySetVectorLength(4);
         case DataType::Type::kInt64:
-          *restrictions |= kNoDiv | kNoMul | kNoMinMax;
+          *restrictions |= kNoDiv | kNoMul;
           return TrySetVectorLength(2);
         case DataType::Type::kFloat32:
           *restrictions |= kNoReduction;
@@ -1456,13 +1397,13 @@ bool HLoopOptimization::TrySetVectorType(DataType::Type type, uint64_t* restrict
             *restrictions |= kNoDiv | kNoSAD;
             return TrySetVectorLength(4);
           case DataType::Type::kInt64:
-            *restrictions |= kNoMul | kNoDiv | kNoShr | kNoAbs | kNoMinMax | kNoSAD;
+            *restrictions |= kNoMul | kNoDiv | kNoShr | kNoAbs | kNoSAD;
             return TrySetVectorLength(2);
           case DataType::Type::kFloat32:
-            *restrictions |= kNoMinMax | kNoReduction;  // minmax: -0.0 vs +0.0
+            *restrictions |= kNoReduction;
             return TrySetVectorLength(4);
           case DataType::Type::kFloat64:
-            *restrictions |= kNoMinMax | kNoReduction;  // minmax: -0.0 vs +0.0
+            *restrictions |= kNoReduction;
             return TrySetVectorLength(2);
           default:
             break;
@@ -1488,10 +1429,10 @@ bool HLoopOptimization::TrySetVectorType(DataType::Type type, uint64_t* restrict
             *restrictions |= kNoDiv;
             return TrySetVectorLength(2);
           case DataType::Type::kFloat32:
-            *restrictions |= kNoMinMax | kNoReduction;  // min/max(x, NaN)
+            *restrictions |= kNoReduction;
             return TrySetVectorLength(4);
           case DataType::Type::kFloat64:
-            *restrictions |= kNoMinMax | kNoReduction;  // min/max(x, NaN)
+            *restrictions |= kNoReduction;
             return TrySetVectorLength(2);
           default:
             break;
@@ -1517,10 +1458,10 @@ bool HLoopOptimization::TrySetVectorType(DataType::Type type, uint64_t* restrict
             *restrictions |= kNoDiv;
             return TrySetVectorLength(2);
           case DataType::Type::kFloat32:
-            *restrictions |= kNoMinMax | kNoReduction;  // min/max(x, NaN)
+            *restrictions |= kNoReduction;
             return TrySetVectorLength(4);
           case DataType::Type::kFloat64:
-            *restrictions |= kNoMinMax | kNoReduction;  // min/max(x, NaN)
+            *restrictions |= kNoReduction;
             return TrySetVectorLength(2);
           default:
             break;
@@ -1745,8 +1686,7 @@ HInstruction* HLoopOptimization::ReduceAndExtractIfNeeded(HInstruction* instruct
 void HLoopOptimization::GenerateVecOp(HInstruction* org,
                                       HInstruction* opa,
                                       HInstruction* opb,
-                                      DataType::Type type,
-                                      bool is_unsigned) {
+                                      DataType::Type type) {
   uint32_t dex_pc = org->GetDexPc();
   HInstruction* vector = nullptr;
   DataType::Type org_type = org->GetType();
@@ -1823,32 +1763,6 @@ void HLoopOptimization::GenerateVecOp(HInstruction* org,
             vector = new (global_allocator_)
                 HVecAbs(global_allocator_, opa, type, vector_length_, dex_pc);
             break;
-          case Intrinsics::kMathMinIntInt:
-          case Intrinsics::kMathMinLongLong:
-          case Intrinsics::kMathMinFloatFloat:
-          case Intrinsics::kMathMinDoubleDouble: {
-            vector = new (global_allocator_)
-                HVecMin(global_allocator_,
-                        opa,
-                        opb,
-                        HVecOperation::ToProperType(type, is_unsigned),
-                        vector_length_,
-                        dex_pc);
-            break;
-          }
-          case Intrinsics::kMathMaxIntInt:
-          case Intrinsics::kMathMaxLongLong:
-          case Intrinsics::kMathMaxFloatFloat:
-          case Intrinsics::kMathMaxDoubleDouble: {
-            vector = new (global_allocator_)
-                HVecMax(global_allocator_,
-                        opa,
-                        opb,
-                        HVecOperation::ToProperType(type, is_unsigned),
-                        vector_length_,
-                        dex_pc);
-            break;
-          }
           default:
             LOG(FATAL) << "Unsupported SIMD intrinsic " << org->GetId();
             UNREACHABLE();
diff --git a/compiler/optimizing/loop_optimization.h b/compiler/optimizing/loop_optimization.h
index a707ad1358..d70751037b 100644
--- a/compiler/optimizing/loop_optimization.h
+++ b/compiler/optimizing/loop_optimization.h
@@ -75,11 +75,10 @@ class HLoopOptimization : public HOptimization {
     kNoSignedHAdd    = 1 << 5,   // no signed halving add
     kNoUnroundedHAdd = 1 << 6,   // no unrounded halving add
     kNoAbs           = 1 << 7,   // no absolute value
-    kNoMinMax        = 1 << 8,   // no min/max
-    kNoStringCharAt  = 1 << 9,   // no StringCharAt
-    kNoReduction     = 1 << 10,  // no reduction
-    kNoSAD           = 1 << 11,  // no sum of absolute differences (SAD)
-    kNoWideSAD       = 1 << 12,  // no sum of absolute differences (SAD) with operand widening
+    kNoStringCharAt  = 1 << 8,   // no StringCharAt
+    kNoReduction     = 1 << 9,   // no reduction
+    kNoSAD           = 1 << 10,  // no sum of absolute differences (SAD)
+    kNoWideSAD       = 1 << 11,  // no sum of absolute differences (SAD) with operand widening
   };
 
   /*
@@ -173,8 +172,7 @@ class HLoopOptimization : public HOptimization {
   void GenerateVecOp(HInstruction* org,
                      HInstruction* opa,
                      HInstruction* opb,
-                     DataType::Type type,
-                     bool is_unsigned = false);
+                     DataType::Type type);
 
   // Vectorization idioms.
   bool VectorizeHalvingAddIdiom(LoopNode* node,
diff --git a/runtime/entrypoints/entrypoint_utils-inl.h b/runtime/entrypoints/entrypoint_utils-inl.h
index 137eb4fe1e..79536168bf 100644
--- a/runtime/entrypoints/entrypoint_utils-inl.h
+++ b/runtime/entrypoints/entrypoint_utils-inl.h
@@ -91,15 +91,17 @@ inline ArtMethod* GetResolvedMethod(ArtMethod* outer_method,
       // even going back from boot image methods to the same oat file. However, this is
       // not currently implemented in the compiler. Therefore crossing dex file boundary
       // indicates that the inlined definition is not the same as the one used at runtime.
-      LOG(FATAL) << "Inlined method resolution crossed dex file boundary: from "
-                 << method->PrettyMethod()
-                 << " in " << method->GetDexFile()->GetLocation() << "/"
-                 << static_cast<const void*>(method->GetDexFile())
-                 << " to " << inlined_method->PrettyMethod()
-                 << " in " << inlined_method->GetDexFile()->GetLocation() << "/"
-                 << static_cast<const void*>(inlined_method->GetDexFile()) << ". "
-                 << "This must be due to duplicate classes or playing wrongly with class loaders";
-      UNREACHABLE();
+      bool target_sdk_pre_p = Runtime::Current()->GetTargetSdkVersion() < 28;
+      LOG(target_sdk_pre_p ? WARNING : FATAL)
+          << "Inlined method resolution crossed dex file boundary: from "
+          << method->PrettyMethod()
+          << " in " << method->GetDexFile()->GetLocation() << "/"
+          << static_cast<const void*>(method->GetDexFile())
+          << " to " << inlined_method->PrettyMethod()
+          << " in " << inlined_method->GetDexFile()->GetLocation() << "/"
+          << static_cast<const void*>(inlined_method->GetDexFile()) << ". "
+          << "This must be due to duplicate classes or playing wrongly with class loaders. "
+          << "The runtime is in an unsafe state.";
     }
     method = inlined_method;
   }
diff --git a/test/623-checker-loop-regressions/src/Main.java b/test/623-checker-loop-regressions/src/Main.java
index ff6e335b7f..4097e33564 100644
--- a/test/623-checker-loop-regressions/src/Main.java
+++ b/test/623-checker-loop-regressions/src/Main.java
@@ -304,6 +304,19 @@ public class Main {
     }
   }
 
+  /// CHECK-START-ARM: void Main.$noinline$stringToShorts(short[], java.lang.String) loop_optimization (after)
+  /// CHECK-NOT: VecLoad
+
+  /// CHECK-START-ARM64: void Main.$noinline$stringToShorts(short[], java.lang.String) loop_optimization (after)
+  /// CHECK-DAG: VecLoad  loop:<<Loop:B\d+>> outer_loop:none
+  /// CHECK-DAG: VecStore loop:<<Loop>>      outer_loop:none
+  private static void $noinline$stringToShorts(short[] dest, String src) {
+    int min = Math.min(dest.length, src.length());
+    for (int i = 0; i < min; ++i) {
+      dest[i] = (short) src.charAt(i);
+    }
+  }
+
   // A strange function that does not inline.
   private static void $noinline$foo(boolean x, int n) {
     if (n < 0)
@@ -684,6 +697,12 @@ public class Main {
       expectEquals(aa[i], cc.charAt(i));
     }
 
+    short[] s2s = new short[12];
+    $noinline$stringToShorts(s2s, "abcdefghijkl");
+    for (int i = 0; i < s2s.length; ++i) {
+      expectEquals((short) "abcdefghijkl".charAt(i), s2s[i]);
+    }
+
     envUsesInCond();
 
     short[] dd = new short[23];
diff --git a/test/651-checker-byte-simd-minmax/expected.txt b/test/651-checker-byte-simd-minmax/expected.txt
deleted file mode 100644
index b0aad4deb5..0000000000
--- a/test/651-checker-byte-simd-minmax/expected.txt
+++ /dev/null
@@ -1 +0,0 @@
-passed
diff --git a/test/651-checker-byte-simd-minmax/info.txt b/test/651-checker-byte-simd-minmax/info.txt
deleted file mode 100644
index 73af1242c0..0000000000
--- a/test/651-checker-byte-simd-minmax/info.txt
+++ /dev/null
@@ -1 +0,0 @@
-Functional tests on min/max SIMD vectorization.
diff --git a/test/651-checker-byte-simd-minmax/src/Main.java b/test/651-checker-byte-simd-minmax/src/Main.java
deleted file mode 100644
index 45949ae90a..0000000000
--- a/test/651-checker-byte-simd-minmax/src/Main.java
+++ /dev/null
@@ -1,196 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * Tests for MIN/MAX vectorization.
- */
-public class Main {
-
-  /// CHECK-START: void Main.doitMin(byte[], byte[], byte[]) loop_optimization (before)
-  /// CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get1:b\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Get2:b\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Min:i\d+>>  InvokeStaticOrDirect [<<Get1>>,<<Get2>>] intrinsic:MathMinIntInt loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG: <<Cnv:b\d+>>  TypeConversion [<<Min>>]            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
-  //
-  /// CHECK-START-{ARM,ARM64,MIPS64}: void Main.doitMin(byte[], byte[], byte[]) loop_optimization (after)
-  /// CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Min:d\d+>>  VecMin [<<Get1>>,<<Get2>>] packed_type:Int8 loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG:               VecStore [{{l\d+}},{{i\d+}},<<Min>>] loop:<<Loop>>      outer_loop:none
-  private static void doitMin(byte[] x, byte[] y, byte[] z) {
-    int min = Math.min(x.length, Math.min(y.length, z.length));
-    for (int i = 0; i < min; i++) {
-      x[i] = (byte) Math.min(y[i], z[i]);
-    }
-  }
-
-  /// CHECK-START: void Main.doitMinUnsigned(byte[], byte[], byte[]) instruction_simplifier (before)
-  /// CHECK-DAG: <<I255:i\d+>> IntConstant 255                     loop:none
-  /// CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get1:b\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Get2:b\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<And1:i\d+>> And [<<Get1>>,<<I255>>]             loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<And2:i\d+>> And [<<Get2>>,<<I255>>]             loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Min:i\d+>>  InvokeStaticOrDirect [<<And1>>,<<And2>>] intrinsic:MathMinIntInt loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG: <<Cnv:b\d+>>  TypeConversion [<<Min>>]            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:               ArraySet [{{l\d+}},{{i\d+}},<<Cnv>>] loop:<<Loop>>      outer_loop:none
-  //
-  /// CHECK-START: void Main.doitMinUnsigned(byte[], byte[], byte[]) loop_optimization (before)
-  /// CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get1:a\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Get2:a\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Min:i\d+>>  InvokeStaticOrDirect [<<Get1>>,<<Get2>>] intrinsic:MathMinIntInt loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG: <<Cnv:b\d+>>  TypeConversion [<<Min>>]            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
-  //
-  /// CHECK-START-{ARM,ARM64,MIPS64}: void Main.doitMinUnsigned(byte[], byte[], byte[]) loop_optimization (after)
-  /// CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Min:d\d+>>  VecMin [<<Get1>>,<<Get2>>] packed_type:Uint8 loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG:               VecStore [{{l\d+}},{{i\d+}},<<Min>>] loop:<<Loop>>      outer_loop:none
-  private static void doitMinUnsigned(byte[] x, byte[] y, byte[] z) {
-    int min = Math.min(x.length, Math.min(y.length, z.length));
-    for (int i = 0; i < min; i++) {
-      x[i] = (byte) Math.min(y[i] & 0xff, z[i] & 0xff);
-    }
-  }
-
-  /// CHECK-START: void Main.doitMax(byte[], byte[], byte[]) loop_optimization (before)
-  /// CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get1:b\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Get2:b\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Max:i\d+>>  InvokeStaticOrDirect [<<Get1>>,<<Get2>>] intrinsic:MathMaxIntInt loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG: <<Cnv:b\d+>>  TypeConversion [<<Max>>]            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
-  //
-  /// CHECK-START-{ARM,ARM64,MIPS64}: void Main.doitMax(byte[], byte[], byte[]) loop_optimization (after)
-  /// CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Max:d\d+>>  VecMax [<<Get1>>,<<Get2>>] packed_type:Int8 loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG:               VecStore [{{l\d+}},{{i\d+}},<<Max>>] loop:<<Loop>>      outer_loop:none
-  private static void doitMax(byte[] x, byte[] y, byte[] z) {
-    int min = Math.min(x.length, Math.min(y.length, z.length));
-    for (int i = 0; i < min; i++) {
-      x[i] = (byte) Math.max(y[i], z[i]);
-    }
-  }
-
-  /// CHECK-START: void Main.doitMaxUnsigned(byte[], byte[], byte[]) instruction_simplifier (before)
-  /// CHECK-DAG: <<I255:i\d+>> IntConstant 255                     loop:none
-  /// CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get1:b\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Get2:b\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<And1:i\d+>> And [<<Get1>>,<<I255>>]             loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<And2:i\d+>> And [<<Get2>>,<<I255>>]             loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Max:i\d+>>  InvokeStaticOrDirect [<<And1>>,<<And2>>] intrinsic:MathMaxIntInt loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG: <<Cnv:b\d+>>  TypeConversion [<<Max>>]            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:               ArraySet [{{l\d+}},{{i\d+}},<<Cnv>>] loop:<<Loop>>      outer_loop:none
-  //
-  /// CHECK-START: void Main.doitMaxUnsigned(byte[], byte[], byte[]) loop_optimization (before)
-  /// CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get1:a\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Get2:a\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Max:i\d+>>  InvokeStaticOrDirect [<<Get1>>,<<Get2>>] intrinsic:MathMaxIntInt loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG: <<Cnv:b\d+>>  TypeConversion [<<Max>>]            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
-  //
-  /// CHECK-START-{ARM,ARM64,MIPS64}: void Main.doitMaxUnsigned(byte[], byte[], byte[]) loop_optimization (after)
-  /// CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop:B\d+>>      outer_loop:none
-  /// CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Max:d\d+>>  VecMax [<<Get1>>,<<Get2>>] packed_type:Uint8 loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG:               VecStore [{{l\d+}},{{i\d+}},<<Max>>] loop:<<Loop>>      outer_loop:none
-  private static void doitMaxUnsigned(byte[] x, byte[] y, byte[] z) {
-    int min = Math.min(x.length, Math.min(y.length, z.length));
-    for (int i = 0; i < min; i++) {
-      x[i] = (byte) Math.max(y[i] & 0xff, z[i] & 0xff);
-    }
-  }
-
-  /// CHECK-START: void Main.doitMin100(byte[], byte[]) loop_optimization (before)
-  /// CHECK-DAG: <<I100:i\d+>> IntConstant 100                     loop:none
-  /// CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get:b\d+>>  ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Min:i\d+>>  InvokeStaticOrDirect [<<Get>>,<<I100>>] intrinsic:MathMinIntInt loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG: <<Cnv:b\d+>>  TypeConversion [<<Min>>]            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
-  //
-  /// CHECK-START-{ARM64,MIPS64}: void Main.doitMin100(byte[], byte[]) loop_optimization (after)
-  /// CHECK-DAG: <<I100:i\d+>> IntConstant 100                      loop:none
-  /// CHECK-DAG: <<Repl:d\d+>> VecReplicateScalar [<<I100>>]        loop:none
-  /// CHECK-DAG: <<Get:d\d+>>  VecLoad                              loop:<<Loop:B\d+>>  outer_loop:none
-  /// CHECK-DAG: <<Min:d\d+>>  VecMin [<<Get>>,<<Repl>>] packed_type:Int8 loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG:               VecStore [{{l\d+}},{{i\d+}},<<Min>>] loop:<<Loop>>       outer_loop:none
-  private static void doitMin100(byte[] x, byte[] y) {
-    int min = Math.min(x.length, y.length);
-    for (int i = 0; i < min; i++) {
-      x[i] = (byte) Math.min(y[i], 100);
-    }
-  }
-
-  public static void main(String[] args) {
-    // Initialize cross-values for all possible values.
-    int total = 256 * 256;
-    byte[] x = new byte[total];
-    byte[] y = new byte[total];
-    byte[] z = new byte[total];
-    int k = 0;
-    for (int i = 0; i < 256; i++) {
-      for (int j = 0; j < 256; j++) {
-        x[k] = 0;
-        y[k] = (byte) i;
-        z[k] = (byte) j;
-        k++;
-      }
-    }
-
-    // And test.
-    doitMin(x, y, z);
-    for (int i = 0; i < total; i++) {
-      byte expected = (byte) Math.min(y[i], z[i]);
-      expectEquals(expected, x[i]);
-    }
-    doitMinUnsigned(x, y, z);
-    for (int i = 0; i < total; i++) {
-      byte expected = (byte) Math.min(y[i] & 0xff, z[i] & 0xff);
-      expectEquals(expected, x[i]);
-    }
-    doitMax(x, y, z);
-    for (int i = 0; i < total; i++) {
-      byte expected = (byte) Math.max(y[i], z[i]);
-      expectEquals(expected, x[i]);
-    }
-    doitMaxUnsigned(x, y, z);
-    for (int i = 0; i < total; i++) {
-      byte expected = (byte) Math.max(y[i] & 0xff, z[i] & 0xff);
-      expectEquals(expected, x[i]);
-    }
-    doitMin100(x, y);
-    for (int i = 0; i < total; i++) {
-      byte expected = (byte) Math.min(y[i], 100);
-      expectEquals(expected, x[i]);
-    }
-
-    System.out.println("passed");
-  }
-
-  private static void expectEquals(byte expected, byte result) {
-    if (expected != result) {
-      throw new Error("Expected: " + expected + ", found: " + result);
-    }
-  }
-}
diff --git a/test/651-checker-char-simd-minmax/expected.txt b/test/651-checker-char-simd-minmax/expected.txt
deleted file mode 100644
index b0aad4deb5..0000000000
--- a/test/651-checker-char-simd-minmax/expected.txt
+++ /dev/null
@@ -1 +0,0 @@
-passed
diff --git a/test/651-checker-char-simd-minmax/info.txt b/test/651-checker-char-simd-minmax/info.txt
deleted file mode 100644
index 73af1242c0..0000000000
--- a/test/651-checker-char-simd-minmax/info.txt
+++ /dev/null
@@ -1 +0,0 @@
-Functional tests on min/max SIMD vectorization.
diff --git a/test/651-checker-char-simd-minmax/src/Main.java b/test/651-checker-char-simd-minmax/src/Main.java
deleted file mode 100644
index 9b056094a3..0000000000
--- a/test/651-checker-char-simd-minmax/src/Main.java
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * Tests for MIN/MAX vectorization.
- */
-public class Main {
-
-  /// CHECK-START: void Main.doitMin(char[], char[], char[]) loop_optimization (before)
-  /// CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get1:c\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Get2:c\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Min:i\d+>>  InvokeStaticOrDirect [<<Get1>>,<<Get2>>] intrinsic:MathMinIntInt loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG: <<Cnv:c\d+>>  TypeConversion [<<Min>>]            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
-  //
-  /// CHECK-START-{ARM,ARM64,MIPS64}: void Main.doitMin(char[], char[], char[]) loop_optimization (after)
-  /// CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Min:d\d+>>  VecMin [<<Get1>>,<<Get2>>] packed_type:Uint16 loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG:               VecStore [{{l\d+}},{{i\d+}},<<Min>>] loop:<<Loop>>      outer_loop:none
-  private static void doitMin(char[] x, char[] y, char[] z) {
-    int min = Math.min(x.length, Math.min(y.length, z.length));
-    for (int i = 0; i < min; i++) {
-      x[i] = (char) Math.min(y[i], z[i]);
-    }
-  }
-
-  /// CHECK-START: void Main.doitMax(char[], char[], char[]) loop_optimization (before)
-  /// CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get1:c\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Get2:c\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Max:i\d+>>  InvokeStaticOrDirect [<<Get1>>,<<Get2>>] intrinsic:MathMaxIntInt loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG: <<Cnv:c\d+>>  TypeConversion [<<Max>>]            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
-  //
-  /// CHECK-START-{ARM,ARM64,MIPS64}: void Main.doitMax(char[], char[], char[]) loop_optimization (after)
-  /// CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Max:d\d+>>  VecMax [<<Get1>>,<<Get2>>] packed_type:Uint16 loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG:               VecStore [{{l\d+}},{{i\d+}},<<Max>>] loop:<<Loop>>      outer_loop:none
-  private static void doitMax(char[] x, char[] y, char[] z) {
-    int min = Math.min(x.length, Math.min(y.length, z.length));
-    for (int i = 0; i < min; i++) {
-      x[i] = (char) Math.max(y[i], z[i]);
-    }
-  }
-
-  /// CHECK-START: void Main.doitMin100(char[], char[]) loop_optimization (before)
-  /// CHECK-DAG: <<I100:i\d+>> IntConstant 100                     loop:none
-  /// CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get:c\d+>>  ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Min:i\d+>>  InvokeStaticOrDirect [<<Get>>,<<I100>>] intrinsic:MathMinIntInt loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG: <<Cnv:c\d+>>  TypeConversion [<<Min>>]            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
-  //
-  /// CHECK-START-{ARM64,MIPS64}: void Main.doitMin100(char[], char[]) loop_optimization (after)
-  /// CHECK-DAG: <<I100:i\d+>> IntConstant 100                      loop:none
-  /// CHECK-DAG: <<Repl:d\d+>> VecReplicateScalar [<<I100>>]        loop:none
-  /// CHECK-DAG: <<Get:d\d+>>  VecLoad                              loop:<<Loop:B\d+>>    outer_loop:none
-  /// CHECK-DAG: <<Min:d\d+>>  VecMin [<<Get>>,<<Repl>>] packed_type:Uint16 loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG:               VecStore [{{l\d+}},{{i\d+}},<<Min>>] loop:<<Loop>>         outer_loop:none
-  private static void doitMin100(char[] x, char[] y) {
-    int min = Math.min(x.length, y.length);
-    for (int i = 0; i < min; i++) {
-      x[i] = (char) Math.min(y[i], 100);
-    }
-  }
-
-  public static void main(String[] args) {
-    char[] interesting = {
-      0x0000, 0x0001, 0x007f, 0x0080, 0x0081, 0x00ff,
-      0x0100, 0x0101, 0x017f, 0x0180, 0x0181, 0x01ff,
-      0x7f00, 0x7f01, 0x7f7f, 0x7f80, 0x7f81, 0x7fff,
-      0x8000, 0x8001, 0x807f, 0x8080, 0x8081, 0x80ff,
-      0x8100, 0x8101, 0x817f, 0x8180, 0x8181, 0x81ff,
-      0xff00, 0xff01, 0xff7f, 0xff80, 0xff81, 0xffff
-    };
-    // Initialize cross-values for the interesting values.
-    int total = interesting.length * interesting.length;
-    char[] x = new char[total];
-    char[] y = new char[total];
-    char[] z = new char[total];
-    int k = 0;
-    for (int i = 0; i < interesting.length; i++) {
-      for (int j = 0; j < interesting.length; j++) {
-        x[k] = 0;
-        y[k] = interesting[i];
-        z[k] = interesting[j];
-        k++;
-      }
-    }
-
-    // And test.
-    doitMin(x, y, z);
-    for (int i = 0; i < total; i++) {
-      char expected = (char) Math.min(y[i], z[i]);
-      expectEquals(expected, x[i]);
-    }
-    doitMax(x, y, z);
-    for (int i = 0; i < total; i++) {
-      char expected = (char) Math.max(y[i], z[i]);
-      expectEquals(expected, x[i]);
-    }
-    doitMin100(x, y);
-    for (int i = 0; i < total; i++) {
-      char expected = (char) Math.min(y[i], 100);
-      expectEquals(expected, x[i]);
-    }
-
-    System.out.println("passed");
-  }
-
-  private static void expectEquals(char expected, char result) {
-    if (expected != result) {
-      throw new Error("Expected: " + expected + ", found: " + result);
-    }
-  }
-}
diff --git a/test/651-checker-double-simd-minmax/expected.txt b/test/651-checker-double-simd-minmax/expected.txt
deleted file mode 100644
index b0aad4deb5..0000000000
--- a/test/651-checker-double-simd-minmax/expected.txt
+++ /dev/null
@@ -1 +0,0 @@
-passed
diff --git a/test/651-checker-double-simd-minmax/info.txt b/test/651-checker-double-simd-minmax/info.txt
deleted file mode 100644
index 73af1242c0..0000000000
--- a/test/651-checker-double-simd-minmax/info.txt
+++ /dev/null
@@ -1 +0,0 @@
-Functional tests on min/max SIMD vectorization.
diff --git a/test/651-checker-double-simd-minmax/src/Main.java b/test/651-checker-double-simd-minmax/src/Main.java
deleted file mode 100644
index 6b12e7e63c..0000000000
--- a/test/651-checker-double-simd-minmax/src/Main.java
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * Tests for MIN/MAX vectorization.
- */
-public class Main {
-
-  /// CHECK-START: void Main.doitMin(double[], double[], double[]) loop_optimization (before)
-  /// CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get1:d\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Get2:d\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Min:d\d+>>  InvokeStaticOrDirect [<<Get1>>,<<Get2>>] intrinsic:MathMinDoubleDouble loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Min>>] loop:<<Loop>>      outer_loop:none
-  //
-  // TODO x86: 0.0 vs -0.0?
-  // TODO MIPS64: min(x, NaN)?
-  //
-  /// CHECK-START-ARM64: void Main.doitMin(double[], double[], double[]) loop_optimization (after)
-  /// CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Min:d\d+>>  VecMin [<<Get1>>,<<Get2>>]           loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:               VecStore [{{l\d+}},{{i\d+}},<<Min>>] loop:<<Loop>>      outer_loop:none
-  private static void doitMin(double[] x, double[] y, double[] z) {
-    int min = Math.min(x.length, Math.min(y.length, z.length));
-    for (int i = 0; i < min; i++) {
-      x[i] = Math.min(y[i], z[i]);
-    }
-  }
-
-  /// CHECK-START: void Main.doitMax(double[], double[], double[]) loop_optimization (before)
-  /// CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get1:d\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Get2:d\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Max:d\d+>>  InvokeStaticOrDirect [<<Get1>>,<<Get2>>] intrinsic:MathMaxDoubleDouble loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Max>>] loop:<<Loop>>      outer_loop:none
-  //
-  // TODO x86: 0.0 vs -0.0?
-  // TODO MIPS64: max(x, NaN)?
-  //
-  /// CHECK-START-ARM64: void Main.doitMax(double[], double[], double[]) loop_optimization (after)
-  /// CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Max:d\d+>>  VecMax [<<Get1>>,<<Get2>>]           loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:               VecStore [{{l\d+}},{{i\d+}},<<Max>>] loop:<<Loop>>      outer_loop:none
-  private static void doitMax(double[] x, double[] y, double[] z) {
-    int min = Math.min(x.length, Math.min(y.length, z.length));
-    for (int i = 0; i < min; i++) {
-      x[i] = Math.max(y[i], z[i]);
-    }
-  }
-
-  public static void main(String[] args) {
-    double[] interesting = {
-      -0.0f,
-      +0.0f,
-      -1.0f,
-      +1.0f,
-      -3.14f,
-      +3.14f,
-      -100.0f,
-      +100.0f,
-      -4444.44f,
-      +4444.44f,
-      Double.MIN_NORMAL,
-      Double.MIN_VALUE,
-      Double.MAX_VALUE,
-      Double.NEGATIVE_INFINITY,
-      Double.POSITIVE_INFINITY,
-      Double.NaN
-    };
-    // Initialize cross-values for the interesting values.
-    int total = interesting.length * interesting.length;
-    double[] x = new double[total];
-    double[] y = new double[total];
-    double[] z = new double[total];
-    int k = 0;
-    for (int i = 0; i < interesting.length; i++) {
-      for (int j = 0; j < interesting.length; j++) {
-        x[k] = 0;
-        y[k] = interesting[i];
-        z[k] = interesting[j];
-        k++;
-      }
-    }
-
-    // And test.
-    doitMin(x, y, z);
-    for (int i = 0; i < total; i++) {
-      double expected = Math.min(y[i], z[i]);
-      expectEquals(expected, x[i]);
-    }
-    doitMax(x, y, z);
-    for (int i = 0; i < total; i++) {
-      double expected = Math.max(y[i], z[i]);
-      expectEquals(expected, x[i]);
-    }
-
-    System.out.println("passed");
-  }
-
-  private static void expectEquals(double expected, double result) {
-    // Tests the bits directly. This distinguishes correctly between +0.0
-    // and -0.0 and returns a canonical representation for all NaN.
-    long expected_bits = Double.doubleToLongBits(expected);
-    long result_bits = Double.doubleToLongBits(result);
-    if (expected_bits != result_bits) {
-      throw new Error("Expected: " + expected +
-          "(0x" + Long.toHexString(expected_bits) + "), found: " + result +
-          "(0x" + Long.toHexString(result_bits) + ")");
-    }
-  }
-}
diff --git a/test/651-checker-float-simd-minmax/expected.txt b/test/651-checker-float-simd-minmax/expected.txt
deleted file mode 100644
index b0aad4deb5..0000000000
--- a/test/651-checker-float-simd-minmax/expected.txt
+++ /dev/null
@@ -1 +0,0 @@
-passed
diff --git a/test/651-checker-float-simd-minmax/info.txt b/test/651-checker-float-simd-minmax/info.txt
deleted file mode 100644
index 73af1242c0..0000000000
--- a/test/651-checker-float-simd-minmax/info.txt
+++ /dev/null
@@ -1 +0,0 @@
-Functional tests on min/max SIMD vectorization.
diff --git a/test/651-checker-float-simd-minmax/src/Main.java b/test/651-checker-float-simd-minmax/src/Main.java
deleted file mode 100644
index 278a9c9367..0000000000
--- a/test/651-checker-float-simd-minmax/src/Main.java
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * Tests for MIN/MAX vectorization.
- */
-public class Main {
-
-  /// CHECK-START: void Main.doitMin(float[], float[], float[]) loop_optimization (before)
-  /// CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get1:f\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Get2:f\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Min:f\d+>>  InvokeStaticOrDirect [<<Get1>>,<<Get2>>] intrinsic:MathMinFloatFloat loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Min>>] loop:<<Loop>>      outer_loop:none
-  //
-  // TODO x86: 0.0 vs -0.0?
-  // TODO MIPS64: min(x, NaN)?
-  //
-  /// CHECK-START-ARM64: void Main.doitMin(float[], float[], float[]) loop_optimization (after)
-  /// CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Min:d\d+>>  VecMin [<<Get1>>,<<Get2>>]           loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:               VecStore [{{l\d+}},{{i\d+}},<<Min>>] loop:<<Loop>>      outer_loop:none
-  private static void doitMin(float[] x, float[] y, float[] z) {
-    int min = Math.min(x.length, Math.min(y.length, z.length));
-    for (int i = 0; i < min; i++) {
-      x[i] = Math.min(y[i], z[i]);
-    }
-  }
-
-  /// CHECK-START: void Main.doitMax(float[], float[], float[]) loop_optimization (before)
-  /// CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get1:f\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Get2:f\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Max:f\d+>>  InvokeStaticOrDirect [<<Get1>>,<<Get2>>] intrinsic:MathMaxFloatFloat loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Max>>] loop:<<Loop>>      outer_loop:none
-  //
-  // TODO x86: 0.0 vs -0.0?
-  // TODO MIPS64: max(x, NaN)?
-  //
-  /// CHECK-START-ARM64: void Main.doitMax(float[], float[], float[]) loop_optimization (after)
-  /// CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Max:d\d+>>  VecMax [<<Get1>>,<<Get2>>]           loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:               VecStore [{{l\d+}},{{i\d+}},<<Max>>] loop:<<Loop>>      outer_loop:none
-  private static void doitMax(float[] x, float[] y, float[] z) {
-    int min = Math.min(x.length, Math.min(y.length, z.length));
-    for (int i = 0; i < min; i++) {
-      x[i] = Math.max(y[i], z[i]);
-    }
-  }
-
-  public static void main(String[] args) {
-    float[] interesting = {
-      -0.0f,
-      +0.0f,
-      -1.0f,
-      +1.0f,
-      -3.14f,
-      +3.14f,
-      -100.0f,
-      +100.0f,
-      -4444.44f,
-      +4444.44f,
-      Float.MIN_NORMAL,
-      Float.MIN_VALUE,
-      Float.MAX_VALUE,
-      Float.NEGATIVE_INFINITY,
-      Float.POSITIVE_INFINITY,
-      Float.NaN
-    };
-    // Initialize cross-values for the interesting values.
-    int total = interesting.length * interesting.length;
-    float[] x = new float[total];
-    float[] y = new float[total];
-    float[] z = new float[total];
-    int k = 0;
-    for (int i = 0; i < interesting.length; i++) {
-      for (int j = 0; j < interesting.length; j++) {
-        x[k] = 0;
-        y[k] = interesting[i];
-        z[k] = interesting[j];
-        k++;
-      }
-    }
-
-    // And test.
-    doitMin(x, y, z);
-    for (int i = 0; i < total; i++) {
-      float expected = Math.min(y[i], z[i]);
-      expectEquals(expected, x[i]);
-    }
-    doitMax(x, y, z);
-    for (int i = 0; i < total; i++) {
-      float expected = Math.max(y[i], z[i]);
-      expectEquals(expected, x[i]);
-    }
-
-    System.out.println("passed");
-  }
-
-  private static void expectEquals(float expected, float result) {
-    // Tests the bits directly. This distinguishes correctly between +0.0
-    // and -0.0 and returns a canonical representation for all NaN.
-    int expected_bits = Float.floatToIntBits(expected);
-    int result_bits = Float.floatToIntBits(result);
-    if (expected_bits != result_bits) {
-      throw new Error("Expected: " + expected +
-          "(0x" + Integer.toHexString(expected_bits) + "), found: " + result +
-          "(0x" + Integer.toHexString(result_bits) + ")");
-    }
-  }
-}
diff --git a/test/651-checker-int-simd-minmax/expected.txt b/test/651-checker-int-simd-minmax/expected.txt
deleted file mode 100644
index b0aad4deb5..0000000000
--- a/test/651-checker-int-simd-minmax/expected.txt
+++ /dev/null
@@ -1 +0,0 @@
-passed
diff --git a/test/651-checker-int-simd-minmax/info.txt b/test/651-checker-int-simd-minmax/info.txt
deleted file mode 100644
index 73af1242c0..0000000000
--- a/test/651-checker-int-simd-minmax/info.txt
+++ /dev/null
@@ -1 +0,0 @@
-Functional tests on min/max SIMD vectorization.
diff --git a/test/651-checker-int-simd-minmax/src/Main.java b/test/651-checker-int-simd-minmax/src/Main.java
deleted file mode 100644
index cfa0ae7dca..0000000000
--- a/test/651-checker-int-simd-minmax/src/Main.java
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * Tests for MIN/MAX vectorization.
- */
-public class Main {
-
-  /// CHECK-START: void Main.doitMin(int[], int[], int[]) loop_optimization (before)
-  /// CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get1:i\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Get2:i\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Min:i\d+>>  InvokeStaticOrDirect [<<Get1>>,<<Get2>>] intrinsic:MathMinIntInt loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Min>>] loop:<<Loop>>      outer_loop:none
-  //
-  /// CHECK-START-{ARM,ARM64,MIPS64}: void Main.doitMin(int[], int[], int[]) loop_optimization (after)
-  /// CHECK-DAG: <<Get1:d\d+>> VecLoad                                      loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get2:d\d+>> VecLoad                                      loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Min:d\d+>>  VecMin [<<Get1>>,<<Get2>>] packed_type:Int32 loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:               VecStore [{{l\d+}},{{i\d+}},<<Min>>]         loop:<<Loop>>      outer_loop:none
-  private static void doitMin(int[] x, int[] y, int[] z) {
-    int min = Math.min(x.length, Math.min(y.length, z.length));
-    for (int i = 0; i < min; i++) {
-      x[i] = Math.min(y[i], z[i]);
-    }
-  }
-
-  /// CHECK-START: void Main.doitMax(int[], int[], int[]) loop_optimization (before)
-  /// CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get1:i\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Get2:i\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Max:i\d+>>  InvokeStaticOrDirect [<<Get1>>,<<Get2>>] intrinsic:MathMaxIntInt loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Max>>] loop:<<Loop>>      outer_loop:none
-  //
-  /// CHECK-START-{ARM,ARM64,MIPS64}: void Main.doitMax(int[], int[], int[]) loop_optimization (after)
-  /// CHECK-DAG: <<Get1:d\d+>> VecLoad                                      loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get2:d\d+>> VecLoad                                      loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Max:d\d+>>  VecMax [<<Get1>>,<<Get2>>] packed_type:Int32 loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:               VecStore [{{l\d+}},{{i\d+}},<<Max>>]         loop:<<Loop>>      outer_loop:none
-  private static void doitMax(int[] x, int[] y, int[] z) {
-    int min = Math.min(x.length, Math.min(y.length, z.length));
-    for (int i = 0; i < min; i++) {
-      x[i] = Math.max(y[i], z[i]);
-    }
-  }
-
-  public static void main(String[] args) {
-    int[] interesting = {
-      0x00000000, 0x00000001, 0x00007fff, 0x00008000, 0x00008001, 0x0000ffff,
-      0x00010000, 0x00010001, 0x00017fff, 0x00018000, 0x00018001, 0x0001ffff,
-      0x7fff0000, 0x7fff0001, 0x7fff7fff, 0x7fff8000, 0x7fff8001, 0x7fffffff,
-      0x80000000, 0x80000001, 0x80007fff, 0x80008000, 0x80008001, 0x8000ffff,
-      0x80010000, 0x80010001, 0x80017fff, 0x80018000, 0x80018001, 0x8001ffff,
-      0xffff0000, 0xffff0001, 0xffff7fff, 0xffff8000, 0xffff8001, 0xffffffff
-    };
-    // Initialize cross-values for the interesting values.
-    int total = interesting.length * interesting.length;
-    int[] x = new int[total];
-    int[] y = new int[total];
-    int[] z = new int[total];
-    int k = 0;
-    for (int i = 0; i < interesting.length; i++) {
-      for (int j = 0; j < interesting.length; j++) {
-        x[k] = 0;
-        y[k] = interesting[i];
-        z[k] = interesting[j];
-        k++;
-      }
-    }
-
-    // And test.
-    doitMin(x, y, z);
-    for (int i = 0; i < total; i++) {
-      int expected = Math.min(y[i], z[i]);
-      expectEquals(expected, x[i]);
-    }
-    doitMax(x, y, z);
-    for (int i = 0; i < total; i++) {
-      int expected = Math.max(y[i], z[i]);
-      expectEquals(expected, x[i]);
-    }
-
-    System.out.println("passed");
-  }
-
-  private static void expectEquals(int expected, int result) {
-    if (expected != result) {
-      throw new Error("Expected: " + expected + ", found: " + result);
-    }
-  }
-}
diff --git a/test/651-checker-long-simd-minmax/expected.txt b/test/651-checker-long-simd-minmax/expected.txt
deleted file mode 100644
index b0aad4deb5..0000000000
--- a/test/651-checker-long-simd-minmax/expected.txt
+++ /dev/null
@@ -1 +0,0 @@
-passed
diff --git a/test/651-checker-long-simd-minmax/info.txt b/test/651-checker-long-simd-minmax/info.txt
deleted file mode 100644
index 73af1242c0..0000000000
--- a/test/651-checker-long-simd-minmax/info.txt
+++ /dev/null
@@ -1 +0,0 @@
-Functional tests on min/max SIMD vectorization.
diff --git a/test/651-checker-long-simd-minmax/src/Main.java b/test/651-checker-long-simd-minmax/src/Main.java
deleted file mode 100644
index 458cb8bf1b..0000000000
--- a/test/651-checker-long-simd-minmax/src/Main.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * Tests for MIN/MAX vectorization.
- */
-public class Main {
-
-  /// CHECK-START: void Main.doitMin(long[], long[], long[]) loop_optimization (before)
-  /// CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get1:j\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Get2:j\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Min:j\d+>>  InvokeStaticOrDirect [<<Get1>>,<<Get2>>] intrinsic:MathMinLongLong loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Min>>] loop:<<Loop>>      outer_loop:none
-  //
-  // Not directly supported for longs.
-  //
-  /// CHECK-START-ARM64: void Main.doitMin(long[], long[], long[]) loop_optimization (after)
-  /// CHECK-NOT: VecMin
-  //
-  /// CHECK-START-MIPS64: void Main.doitMin(long[], long[], long[]) loop_optimization (after)
-  /// CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Min:d\d+>>  VecMin [<<Get1>>,<<Get2>>]           loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:               VecStore [{{l\d+}},{{i\d+}},<<Min>>] loop:<<Loop>>      outer_loop:none
-
-  private static void doitMin(long[] x, long[] y, long[] z) {
-    int min = Math.min(x.length, Math.min(y.length, z.length));
-    for (int i = 0; i < min; i++) {
-      x[i] = Math.min(y[i], z[i]);
-    }
-  }
-
-  /// CHECK-START: void Main.doitMax(long[], long[], long[]) loop_optimization (before)
-  /// CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get1:j\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Get2:j\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Max:j\d+>>  InvokeStaticOrDirect [<<Get1>>,<<Get2>>] intrinsic:MathMaxLongLong loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Max>>] loop:<<Loop>>      outer_loop:none
-  //
-  // Not directly supported for longs.
-  //
-  /// CHECK-START-ARM64: void Main.doitMax(long[], long[], long[]) loop_optimization (after)
-  /// CHECK-NOT: VecMax
-  //
-  /// CHECK-START-MIPS64: void Main.doitMax(long[], long[], long[]) loop_optimization (after)
-  /// CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Max:d\d+>>  VecMax [<<Get1>>,<<Get2>>]           loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:               VecStore [{{l\d+}},{{i\d+}},<<Max>>] loop:<<Loop>>      outer_loop:none
-  private static void doitMax(long[] x, long[] y, long[] z) {
-    int min = Math.min(x.length, Math.min(y.length, z.length));
-    for (int i = 0; i < min; i++) {
-      x[i] = Math.max(y[i], z[i]);
-    }
-  }
-
-  public static void main(String[] args) {
-    long[] interesting = {
-      0x0000000000000000L, 0x0000000000000001L, 0x000000007fffffffL,
-      0x0000000080000000L, 0x0000000080000001L, 0x00000000ffffffffL,
-      0x0000000100000000L, 0x0000000100000001L, 0x000000017fffffffL,
-      0x0000000180000000L, 0x0000000180000001L, 0x00000001ffffffffL,
-      0x7fffffff00000000L, 0x7fffffff00000001L, 0x7fffffff7fffffffL,
-      0x7fffffff80000000L, 0x7fffffff80000001L, 0x7fffffffffffffffL,
-      0x8000000000000000L, 0x8000000000000001L, 0x800000007fffffffL,
-      0x8000000080000000L, 0x8000000080000001L, 0x80000000ffffffffL,
-      0x8000000100000000L, 0x8000000100000001L, 0x800000017fffffffL,
-      0x8000000180000000L, 0x8000000180000001L, 0x80000001ffffffffL,
-      0xffffffff00000000L, 0xffffffff00000001L, 0xffffffff7fffffffL,
-      0xffffffff80000000L, 0xffffffff80000001L, 0xffffffffffffffffL
-    };
-    // Initialize cross-values for the interesting values.
-    int total = interesting.length * interesting.length;
-    long[] x = new long[total];
-    long[] y = new long[total];
-    long[] z = new long[total];
-    int k = 0;
-    for (int i = 0; i < interesting.length; i++) {
-      for (int j = 0; j < interesting.length; j++) {
-        x[k] = 0;
-        y[k] = interesting[i];
-        z[k] = interesting[j];
-        k++;
-      }
-    }
-
-    // And test.
-    doitMin(x, y, z);
-    for (int i = 0; i < total; i++) {
-      long expected = Math.min(y[i], z[i]);
-      expectEquals(expected, x[i]);
-    }
-    doitMax(x, y, z);
-    for (int i = 0; i < total; i++) {
-      long expected = Math.max(y[i], z[i]);
-      expectEquals(expected, x[i]);
-    }
-
-    System.out.println("passed");
-  }
-
-  private static void expectEquals(long expected, long result) {
-    if (expected != result) {
-      throw new Error("Expected: " + expected + ", found: " + result);
-    }
-  }
-}
diff --git a/test/651-checker-short-simd-minmax/expected.txt b/test/651-checker-short-simd-minmax/expected.txt
deleted file mode 100644
index b0aad4deb5..0000000000
--- a/test/651-checker-short-simd-minmax/expected.txt
+++ /dev/null
@@ -1 +0,0 @@
-passed
diff --git a/test/651-checker-short-simd-minmax/info.txt b/test/651-checker-short-simd-minmax/info.txt
deleted file mode 100644
index 73af1242c0..0000000000
--- a/test/651-checker-short-simd-minmax/info.txt
+++ /dev/null
@@ -1 +0,0 @@
-Functional tests on min/max SIMD vectorization.
diff --git a/test/651-checker-short-simd-minmax/src/Main.java b/test/651-checker-short-simd-minmax/src/Main.java
deleted file mode 100644
index 5f10adab79..0000000000
--- a/test/651-checker-short-simd-minmax/src/Main.java
+++ /dev/null
@@ -1,210 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * Tests for MIN/MAX vectorization.
- */
-public class Main {
-
-  /// CHECK-START: void Main.doitMin(short[], short[], short[]) loop_optimization (before)
-  /// CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get1:s\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Get2:s\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Min:i\d+>>  InvokeStaticOrDirect [<<Get1>>,<<Get2>>] intrinsic:MathMinIntInt loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG: <<Cnv:s\d+>>  TypeConversion [<<Min>>]            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
-  //
-  /// CHECK-START-{ARM,ARM64,MIPS64}: void Main.doitMin(short[], short[], short[]) loop_optimization (after)
-  /// CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop:B\d+>>    outer_loop:none
-  /// CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>         outer_loop:none
-  /// CHECK-DAG: <<Min:d\d+>>  VecMin [<<Get1>>,<<Get2>>] packed_type:Int16 loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG:               VecStore [{{l\d+}},{{i\d+}},<<Min>>] loop:<<Loop>>         outer_loop:none
-  private static void doitMin(short[] x, short[] y, short[] z) {
-    int min = Math.min(x.length, Math.min(y.length, z.length));
-    for (int i = 0; i < min; i++) {
-      x[i] = (short) Math.min(y[i], z[i]);
-    }
-  }
-
-  /// CHECK-START: void Main.doitMinUnsigned(short[], short[], short[]) instruction_simplifier (before)
-  /// CHECK-DAG: <<IMAX:i\d+>> IntConstant 65535                   loop:none
-  /// CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get1:s\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Get2:s\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<And1:i\d+>> And [<<Get1>>,<<IMAX>>]             loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<And2:i\d+>> And [<<Get2>>,<<IMAX>>]             loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Min:i\d+>>  InvokeStaticOrDirect [<<And1>>,<<And2>>] intrinsic:MathMinIntInt loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG: <<Cnv:s\d+>>  TypeConversion [<<Min>>]            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:               ArraySet [{{l\d+}},{{i\d+}},<<Cnv>>] loop:<<Loop>>      outer_loop:none
-  //
-  /// CHECK-START: void Main.doitMinUnsigned(short[], short[], short[]) loop_optimization (before)
-  /// CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get1:c\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Get2:c\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Min:i\d+>>  InvokeStaticOrDirect [<<Get1>>,<<Get2>>] intrinsic:MathMinIntInt loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG: <<Cnv:s\d+>>  TypeConversion [<<Min>>]            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
-  //
-  /// CHECK-START-{ARM,ARM64,MIPS64}: void Main.doitMinUnsigned(short[], short[], short[]) loop_optimization (after)
-  /// CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop:B\d+>>     outer_loop:none
-  /// CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>          outer_loop:none
-  /// CHECK-DAG: <<Min:d\d+>>  VecMin [<<Get1>>,<<Get2>>] packed_type:Uint16 loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG:               VecStore [{{l\d+}},{{i\d+}},<<Min>>] loop:<<Loop>>          outer_loop:none
-  private static void doitMinUnsigned(short[] x, short[] y, short[] z) {
-    int min = Math.min(x.length, Math.min(y.length, z.length));
-    for (int i = 0; i < min; i++) {
-      x[i] = (short) Math.min(y[i] & 0xffff, z[i] & 0xffff);
-    }
-  }
-
-  /// CHECK-START: void Main.doitMax(short[], short[], short[]) loop_optimization (before)
-  /// CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get1:s\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Get2:s\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Max:i\d+>>  InvokeStaticOrDirect [<<Get1>>,<<Get2>>] intrinsic:MathMaxIntInt loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG: <<Cnv:s\d+>>  TypeConversion [<<Max>>]            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
-  //
-  /// CHECK-START-{ARM,ARM64,MIPS64}: void Main.doitMax(short[], short[], short[]) loop_optimization (after)
-  /// CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop:B\d+>>    outer_loop:none
-  /// CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>         outer_loop:none
-  /// CHECK-DAG: <<Max:d\d+>>  VecMax [<<Get1>>,<<Get2>>] packed_type:Int16 loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG:               VecStore [{{l\d+}},{{i\d+}},<<Max>>] loop:<<Loop>>         outer_loop:none
-  private static void doitMax(short[] x, short[] y, short[] z) {
-    int min = Math.min(x.length, Math.min(y.length, z.length));
-    for (int i = 0; i < min; i++) {
-      x[i] = (short) Math.max(y[i], z[i]);
-    }
-  }
-
-  /// CHECK-START: void Main.doitMaxUnsigned(short[], short[], short[]) instruction_simplifier (before)
-  /// CHECK-DAG: <<IMAX:i\d+>> IntConstant 65535                   loop:none
-  /// CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get1:s\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Get2:s\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<And1:i\d+>> And [<<Get1>>,<<IMAX>>]             loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<And2:i\d+>> And [<<Get2>>,<<IMAX>>]             loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Max:i\d+>>  InvokeStaticOrDirect [<<And1>>,<<And2>>] intrinsic:MathMaxIntInt loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG: <<Cnv:s\d+>>  TypeConversion [<<Max>>]            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:               ArraySet [{{l\d+}},{{i\d+}},<<Cnv>>] loop:<<Loop>>      outer_loop:none
-  //
-  /// CHECK-START: void Main.doitMaxUnsigned(short[], short[], short[]) loop_optimization (before)
-  /// CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get1:c\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Get2:c\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Max:i\d+>>  InvokeStaticOrDirect [<<Get1>>,<<Get2>>] intrinsic:MathMaxIntInt loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG: <<Cnv:s\d+>>  TypeConversion [<<Max>>]            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
-  //
-  /// CHECK-START-{ARM,ARM64,MIPS64}: void Main.doitMaxUnsigned(short[], short[], short[]) loop_optimization (after)
-  /// CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop:B\d+>>     outer_loop:none
-  /// CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>          outer_loop:none
-  /// CHECK-DAG: <<Max:d\d+>>  VecMax [<<Get1>>,<<Get2>>] packed_type:Uint16 loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG:               VecStore [{{l\d+}},{{i\d+}},<<Max>>] loop:<<Loop>>          outer_loop:none
-  private static void doitMaxUnsigned(short[] x, short[] y, short[] z) {
-    int min = Math.min(x.length, Math.min(y.length, z.length));
-    for (int i = 0; i < min; i++) {
-      x[i] = (short) Math.max(y[i] & 0xffff, z[i] & 0xffff);
-    }
-  }
-
-  /// CHECK-START: void Main.doitMin100(short[], short[]) loop_optimization (before)
-  /// CHECK-DAG: <<I100:i\d+>> IntConstant 100                     loop:none
-  /// CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Get:s\d+>>  ArrayGet                            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Min:i\d+>>  InvokeStaticOrDirect [<<Get>>,<<I100>>] intrinsic:MathMinIntInt loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG: <<Cnv:s\d+>>  TypeConversion [<<Min>>]            loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
-  //
-  /// CHECK-START-{ARM64,MIPS64}: void Main.doitMin100(short[], short[]) loop_optimization (after)
-  /// CHECK-DAG: <<I100:i\d+>> IntConstant 100                      loop:none
-  /// CHECK-DAG: <<Repl:d\d+>> VecReplicateScalar [<<I100>>]        loop:none
-  /// CHECK-DAG: <<Get:d\d+>>  VecLoad                              loop:<<Loop:B\d+>>   outer_loop:none
-  /// CHECK-DAG: <<Min:d\d+>>  VecMin [<<Get>>,<<Repl>>] packed_type:Int16 loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG:               VecStore [{{l\d+}},{{i\d+}},<<Min>>] loop:<<Loop>>        outer_loop:none
-  private static void doitMin100(short[] x, short[] y) {
-    int min = Math.min(x.length, y.length);
-    for (int i = 0; i < min; i++) {
-      x[i] = (short) Math.min(y[i], 100);
-    }
-  }
-
-  public static void main(String[] args) {
-    short[] interesting = {
-      (short) 0x0000, (short) 0x0001, (short) 0x007f,
-      (short) 0x0080, (short) 0x0081, (short) 0x00ff,
-      (short) 0x0100, (short) 0x0101, (short) 0x017f,
-      (short) 0x0180, (short) 0x0181, (short) 0x01ff,
-      (short) 0x7f00, (short) 0x7f01, (short) 0x7f7f,
-      (short) 0x7f80, (short) 0x7f81, (short) 0x7fff,
-      (short) 0x8000, (short) 0x8001, (short) 0x807f,
-      (short) 0x8080, (short) 0x8081, (short) 0x80ff,
-      (short) 0x8100, (short) 0x8101, (short) 0x817f,
-      (short) 0x8180, (short) 0x8181, (short) 0x81ff,
-      (short) 0xff00, (short) 0xff01, (short) 0xff7f,
-      (short) 0xff80, (short) 0xff81, (short) 0xffff
-    };
-    // Initialize cross-values for the interesting values.
-    int total = interesting.length * interesting.length;
-    short[] x = new short[total];
-    short[] y = new short[total];
-    short[] z = new short[total];
-    int k = 0;
-    for (int i = 0; i < interesting.length; i++) {
-      for (int j = 0; j < interesting.length; j++) {
-        x[k] = 0;
-        y[k] = interesting[i];
-        z[k] = interesting[j];
-        k++;
-      }
-    }
-
-    // And test.
-    doitMin(x, y, z);
-    for (int i = 0; i < total; i++) {
-      short expected = (short) Math.min(y[i], z[i]);
-      expectEquals(expected, x[i]);
-    }
-    doitMinUnsigned(x, y, z);
-    for (int i = 0; i < total; i++) {
-      short expected = (short) Math.min(y[i] & 0xffff, z[i] & 0xffff);
-      expectEquals(expected, x[i]);
-    }
-    doitMax(x, y, z);
-    for (int i = 0; i < total; i++) {
-      short expected = (short) Math.max(y[i], z[i]);
-      expectEquals(expected, x[i]);
-    }
-    doitMaxUnsigned(x, y, z);
-    for (int i = 0; i < total; i++) {
-      short expected = (short) Math.max(y[i] & 0xffff, z[i] & 0xffff);
-      expectEquals(expected, x[i]);
-    }
-    doitMin100(x, y);
-    for (int i = 0; i < total; i++) {
-      short expected = (short) Math.min(y[i], 100);
-      expectEquals(expected, x[i]);
-    }
-
-    System.out.println("passed");
-  }
-
-  private static void expectEquals(short expected, short result) {
-    if (expected != result) {
-      throw new Error("Expected: " + expected + ", found: " + result);
-    }
-  }
-}
diff --git a/test/661-checker-simd-reduc/src/Main.java b/test/661-checker-simd-reduc/src/Main.java
index 3a0a0495c4..eff2018078 100644
--- a/test/661-checker-simd-reduc/src/Main.java
+++ b/test/661-checker-simd-reduc/src/Main.java
@@ -347,126 +347,6 @@ public class Main {
     return sum;
   }
 
-  private static byte reductionMinByte(byte[] x) {
-    byte min = Byte.MAX_VALUE;
-    for (int i = 0; i < x.length; i++) {
-      min = (byte) Math.min(min, x[i]);
-    }
-    return min;
-  }
-
-  private static short reductionMinShort(short[] x) {
-    short min = Short.MAX_VALUE;
-    for (int i = 0; i < x.length; i++) {
-      min = (short) Math.min(min, x[i]);
-    }
-    return min;
-  }
-
-  private static char reductionMinChar(char[] x) {
-    char min = Character.MAX_VALUE;
-    for (int i = 0; i < x.length; i++) {
-      min = (char) Math.min(min, x[i]);
-    }
-    return min;
-  }
-
-  /// CHECK-START: int Main.reductionMinInt(int[]) loop_optimization (before)
-  /// CHECK-DAG: <<Cons0:i\d+>>  IntConstant 0                 loop:none
-  /// CHECK-DAG: <<Cons1:i\d+>>  IntConstant 1                 loop:none
-  /// CHECK-DAG: <<ConsM:i\d+>>  IntConstant 2147483647        loop:none
-  /// CHECK-DAG: <<Phi1:i\d+>>   Phi [<<Cons0>>,{{i\d+}}]      loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Phi2:i\d+>>   Phi [<<ConsM>>,{{i\d+}}]      loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Get:i\d+>>    ArrayGet [{{l\d+}},<<Phi1>>]  loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:                 InvokeStaticOrDirect [<<Phi2>>,<<Get>>] intrinsic:MathMinIntInt loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG:                 Add [<<Phi1>>,<<Cons1>>]      loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:                 Return [<<Phi2>>]             loop:none
-  //
-  /// CHECK-START-{ARM,ARM64,MIPS64}: int Main.reductionMinInt(int[]) loop_optimization (after)
-  /// CHECK-DAG: <<Cons:i\d+>>   IntConstant {{2|4}}           loop:none
-  /// CHECK-DAG: <<Set:d\d+>>    VecReplicateScalar [{{i\d+}}] loop:none
-  /// CHECK-DAG: <<Phi:d\d+>>    Phi [<<Set>>,{{d\d+}}]        loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Load:d\d+>>   VecLoad [{{l\d+}},<<I:i\d+>>] loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:                 VecMin [<<Phi>>,<<Load>>]     loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:                 Add [<<I>>,<<Cons>>]          loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Red:d\d+>>    VecReduce [<<Phi>>]           loop:none
-  /// CHECK-DAG: <<Extr:i\d+>>   VecExtractScalar [<<Red>>]    loop:none
-  private static int reductionMinInt(int[] x) {
-    int min = Integer.MAX_VALUE;
-    for (int i = 0; i < x.length; i++) {
-      min = Math.min(min, x[i]);
-    }
-    return min;
-  }
-
-  private static long reductionMinLong(long[] x) {
-    long min = Long.MAX_VALUE;
-    for (int i = 0; i < x.length; i++) {
-      min = Math.min(min, x[i]);
-    }
-    return min;
-  }
-
-  private static byte reductionMaxByte(byte[] x) {
-    byte max = Byte.MIN_VALUE;
-    for (int i = 0; i < x.length; i++) {
-      max = (byte) Math.max(max, x[i]);
-    }
-    return max;
-  }
-
-  private static short reductionMaxShort(short[] x) {
-    short max = Short.MIN_VALUE;
-    for (int i = 0; i < x.length; i++) {
-      max = (short) Math.max(max, x[i]);
-    }
-    return max;
-  }
-
-  private static char reductionMaxChar(char[] x) {
-    char max = Character.MIN_VALUE;
-    for (int i = 0; i < x.length; i++) {
-      max = (char) Math.max(max, x[i]);
-    }
-    return max;
-  }
-
-  /// CHECK-START: int Main.reductionMaxInt(int[]) loop_optimization (before)
-  /// CHECK-DAG: <<Cons0:i\d+>>  IntConstant 0                 loop:none
-  /// CHECK-DAG: <<Cons1:i\d+>>  IntConstant 1                 loop:none
-  /// CHECK-DAG: <<ConsM:i\d+>>  IntConstant -2147483648       loop:none
-  /// CHECK-DAG: <<Phi1:i\d+>>   Phi [<<Cons0>>,{{i\d+}}]      loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Phi2:i\d+>>   Phi [<<ConsM>>,{{i\d+}}]      loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Get:i\d+>>    ArrayGet [{{l\d+}},<<Phi1>>]  loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:                 InvokeStaticOrDirect [<<Phi2>>,<<Get>>] intrinsic:MathMaxIntInt loop:<<Loop>> outer_loop:none
-  /// CHECK-DAG:                 Add [<<Phi1>>,<<Cons1>>]      loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:                 Return [<<Phi2>>]             loop:none
-  //
-  /// CHECK-START-{ARM,ARM64,MIPS64}: int Main.reductionMaxInt(int[]) loop_optimization (after)
-  /// CHECK-DAG: <<Cons:i\d+>>   IntConstant {{2|4}}           loop:none
-  /// CHECK-DAG: <<Set:d\d+>>    VecReplicateScalar [{{i\d+}}] loop:none
-  /// CHECK-DAG: <<Phi:d\d+>>    Phi [<<Set>>,{{d\d+}}]        loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG: <<Load:d\d+>>   VecLoad [{{l\d+}},<<I:i\d+>>] loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:                 VecMax [<<Phi>>,<<Load>>]     loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG:                 Add [<<I>>,<<Cons>>]          loop:<<Loop>>      outer_loop:none
-  /// CHECK-DAG: <<Red:d\d+>>    VecReduce [<<Phi>>]           loop:none
-  /// CHECK-DAG: <<Extr:i\d+>>   VecExtractScalar [<<Red>>]    loop:none
-  private static int reductionMaxInt(int[] x) {
-    int max = Integer.MIN_VALUE;
-    for (int i = 0; i < x.length; i++) {
-      max = Math.max(max, x[i]);
-    }
-    return max;
-  }
-
-  private static long reductionMaxLong(long[] x) {
-    long max = Long.MIN_VALUE;
-    for (int i = 0; i < x.length; i++) {
-      max = Math.max(max, x[i]);
-    }
-    return max;
-  }
-
   //
   // A few special cases.
   //
@@ -491,24 +371,6 @@ public class Main {
     return sum;
   }
 
-  private static int reductionMinInt10(int[] x) {
-    int min = Integer.MAX_VALUE;
-    // Amenable to complete unrolling.
-    for (int i = 10; i <= 10; i++) {
-      min = Math.min(min, x[i]);
-    }
-    return min;
-  }
-
-  private static int reductionMaxInt10(int[] x) {
-    int max = Integer.MIN_VALUE;
-    // Amenable to complete unrolling.
-    for (int i = 10; i <= 10; i++) {
-      max = Math.max(max, x[i]);
-    }
-    return max;
-  }
-
   //
   // Main driver.
   //
@@ -587,40 +449,10 @@ public class Main {
     expectEquals(27466, reductionMinusChar(xc));
     expectEquals(-365750, reductionMinusInt(xi));
     expectEquals(-365750L, reductionMinusLong(xl));
-    expectEquals(-128, reductionMinByte(xb));
-    expectEquals(-17, reductionMinShort(xs));
-    expectEquals(1, reductionMinChar(xc));
-    expectEquals(-17, reductionMinInt(xi));
-    expectEquals(-17L, reductionMinLong(xl));
-    expectEquals(3, reductionMinByte(xpb));
-    expectEquals(3, reductionMinShort(xps));
-    expectEquals(3, reductionMinChar(xpc));
-    expectEquals(3, reductionMinInt(xpi));
-    expectEquals(3L, reductionMinLong(xpl));
-    expectEquals(-103, reductionMinByte(xnb));
-    expectEquals(-103, reductionMinShort(xns));
-    expectEquals(-103, reductionMinInt(xni));
-    expectEquals(-103L, reductionMinLong(xnl));
-    expectEquals(127, reductionMaxByte(xb));
-    expectEquals(1480, reductionMaxShort(xs));
-    expectEquals(65534, reductionMaxChar(xc));
-    expectEquals(1480, reductionMaxInt(xi));
-    expectEquals(1480L, reductionMaxLong(xl));
-    expectEquals(102, reductionMaxByte(xpb));
-    expectEquals(102, reductionMaxShort(xps));
-    expectEquals(102, reductionMaxChar(xpc));
-    expectEquals(102, reductionMaxInt(xpi));
-    expectEquals(102L, reductionMaxLong(xpl));
-    expectEquals(-4, reductionMaxByte(xnb));
-    expectEquals(-4, reductionMaxShort(xns));
-    expectEquals(-4, reductionMaxInt(xni));
-    expectEquals(-4L, reductionMaxLong(xnl));
 
     // Test special cases.
     expectEquals(13, reductionInt10(xi));
     expectEquals(-13, reductionMinusInt10(xi));
-    expectEquals(13, reductionMinInt10(xi));
-    expectEquals(13, reductionMaxInt10(xi));
 
     System.out.println("passed");
   }
diff --git a/test/684-select-condition/expected.txt b/test/684-select-condition/expected.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/684-select-condition/info.txt b/test/684-select-condition/info.txt
new file mode 100644
index 0000000000..f9d4acda4e
--- /dev/null
+++ b/test/684-select-condition/info.txt
@@ -0,0 +1 @@
+Regression test for a bug in ARM's code generator for HSelect.
diff --git a/test/684-select-condition/src/Main.java b/test/684-select-condition/src/Main.java
new file mode 100644
index 0000000000..196ff1a362
--- /dev/null
+++ b/test/684-select-condition/src/Main.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class Main {
+
+  public static void main(String args[]) {
+    doFloatingPointTest("1", "1.0");
+    doFloatingPointTest("4", "2.0");
+    checkValue(String.valueOf(doIntegerTest1(4)), "0");
+    checkValue(String.valueOf(doIntegerTest2(4)), "4");
+
+    // Another variant of the floating point test, but less brittle.
+    staticField = 1;
+    checkValue(String.valueOf($noinline$test()), "1.0");
+    staticField = 4;
+    checkValue(String.valueOf($noinline$test()), "2.0");
+  }
+
+  // This code is a reduced version of the original reproducer. The arm
+  // code generator used to generate wrong code for it. Note that this
+  // test is very brittle and a simple change in it could cause the compiler
+  // to not trip.
+  public static void doFloatingPointTest(String s, String expected) {
+    float a = (float)Integer.valueOf(s);
+    a = a < 2.0f ? a : 2.0f;
+    checkValue("" + a, expected);
+  }
+
+  // The compiler used to trip on the two following methods. The test there
+  // is very brittle and requires not running constant folding after
+  // load/store elimination.
+  public static int doIntegerTest1(int param) {
+    Main main = new Main();
+    main.field = 0;
+    return (main.field == 0) ? 0 : param;
+  }
+
+  public static int doIntegerTest2(int param) {
+    Main main = new Main();
+    main.field = 0;
+    return (main.field != 0) ? 0 : param;
+  }
+
+  public static void checkValue(String actual, String expected) {
+    if (!expected.equals(actual)) {
+      throw new Error("Expected " + expected + ", got " + actual);
+    }
+  }
+
+  static void $noinline$nothing() {}
+  static int $noinline$getField() { return staticField; }
+
+  static float $noinline$test() {
+    // The 2.0f shall be materialized for GreaterThanOrEqual at the beginning of the method;
+    // since the following call clobbers caller-saves, it is allocated to s16.
+    // r0(field) = InvokeStaticOrDirect[]
+    int one = $noinline$getField();
+    // s0(a_1) = TypeConversion[r0(one)]
+    float a = (float)one;
+    // s16(a_2) = Select[s0(a_1), C(2.0f), GreaterThanOrEqual[s0(a_1), s16(2.0f)]]
+    a = a < 2.0f ? a : 2.0f;
+    // The following call is added to clobber caller-saves, forcing the output of the Select
+    // to be allocated to s16.
+    $noinline$nothing();
+    return a;
+  }
+
+  int field;
+  static int staticField;
+}
diff --git a/test/ti-agent/jni_binder.cc b/test/ti-agent/jni_binder.cc
index 32236deba4..a115c22930 100644
--- a/test/ti-agent/jni_binder.cc
+++ b/test/ti-agent/jni_binder.cc
@@ -174,7 +174,7 @@ static jclass FindClassWithClassLoader(JNIEnv* env, const char* class_name, jobj
                                                          class_loader));
 }
 
-jclass FindClass(jvmtiEnv* jvmti_env, JNIEnv* env, const char* class_name, jobject class_loader) {
+jclass GetClass(jvmtiEnv* jvmti_env, JNIEnv* env, const char* class_name, jobject class_loader) {
   if (class_loader != nullptr) {
     return FindClassWithClassLoader(env, class_name, class_loader);
   }
@@ -223,7 +223,7 @@ jclass FindClass(jvmtiEnv* jvmti_env, JNIEnv* env, const char* class_name, jobje
   }
 
   // TODO: Implement scanning *all* classloaders.
-  LOG(FATAL) << "Unimplemented";
+  LOG(WARNING) << "Scanning all classloaders unimplemented";
 
   return nullptr;
 }
@@ -251,7 +251,7 @@ void BindFunctionsOnClass(jvmtiEnv* jvmti_env, JNIEnv* env, jclass klass) {
 
 void BindFunctions(jvmtiEnv* jvmti_env, JNIEnv* env, const char* class_name, jobject class_loader) {
   // Use JNI to load the class.
-  ScopedLocalRef<jclass> klass(env, FindClass(jvmti_env, env, class_name, class_loader));
+  ScopedLocalRef<jclass> klass(env, GetClass(jvmti_env, env, class_name, class_loader));
   CHECK(klass.get() != nullptr) << class_name;
   BindFunctionsOnClass(jvmti_env, env, klass.get());
 }
diff --git a/test/ti-agent/jni_binder.h b/test/ti-agent/jni_binder.h
index e998dc561c..3d2ff9c47a 100644
--- a/test/ti-agent/jni_binder.h
+++ b/test/ti-agent/jni_binder.h
@@ -24,7 +24,7 @@ namespace art {
 
 // Find the given classname. First try the implied classloader, then the system classloader,
 // then use JVMTI to find all classloaders.
-jclass FindClass(jvmtiEnv* jvmti_env, JNIEnv* env, const char* class_name, jobject class_loader);
+jclass GetClass(jvmtiEnv* jvmti_env, JNIEnv* env, const char* class_name, jobject class_loader);
 
 // Load the class through JNI. Inspect it, find all native methods. Construct the corresponding
 // mangled name, run dlsym and bind the method.
-- 
2.17.1

