From d0e073580e5bed9a2a2ecb98b3c5587a376cc273 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Sun, 20 Oct 2013 23:48:00 -0700
Subject: [PATCH 18/47] appops: Privacy Guard for P (1/2)

Squashed commit of all PG-related features including superuser

   Authors:
   - Sam Mortimer
   - Danesh Mondegarian
   - Jorge Ruesga
   - Diogo Ferreira
   - Roman Birg
   - Adnan Begovic
   - Chirayu Desai
   - Lars Greiss
   - Steve Kondik
   - CodeAurora

Pulled together from:

Author: Danesh M <daneshm90@gmail.com>
Date:   Thu Sep 5 19:23:15 2013 -0700

    Privacy Guard : Reimplement backed by AppOps

    Re-implements privacy guard to use appops.

    Change-Id: I2b52e8cf0d6e126fb156f83df885b5551503cd9d

Author: Shashank Mittal <mittals@codeaurora.org>
Date:   Fri Aug 16 01:09:28 2013 -0700

    AppOpsService: Add MODE_ASK support to AppOps.

    Add support for new mode(MODE_ASK) in AppOpsService to show a permission
    dialog box to user to confirm user permission before allowing or ignoring
    that operation.

    All strict operations (defined in AppOpsManager) are going to be in
    MODE_ASK by default.

    Operations will be moved to MODE_ALLOWED or MODE_IGNORED according to
    user's choice.

    Change-Id: I1314125a2b8be558e422e4a9eea0ff066c21bf94

Author: Shashank Mittal <mittals@codeaurora.org>
Date:   Tue Sep 3 19:23:10 2013 -0700

    wifi: Confirm user permission before toggling wifi.

    Check user permissions before enabling/disabling wifi.

    Change-Id: I1ddae6e47f42b6d3fc831c2c135ece75cf9e935d

Author: Shashank Mittal <mittals@codeaurora.org>
Date:   Thu Sep 5 17:24:44 2013 -0700

    AppOps: Add Bluetooth enable control into AppOps

    Check user permission before enabling bluetooth.

    Change-Id: Iefa4ea3319b33b2639beaf38d261d83649bbcf85

Author: Sam Mortimer <sam@mortimer.me.uk>
Date:   Wed Oct 2 22:06:42 2013 -0700

    [2/2] AppOps: Add per Op allowed and ignored counters

    Change-Id: Ifb3d25e17dbab082b816a0a655b4796a83af336b

Author: Jorge Ruesga <jorge@ruesga.com>
Date:   Sat Jan 4 01:34:39 2014 +0100

    privacyguard: Share privacy package name between activity stacks

    AOSP 4.4 now has a stack supervisor with differents activity stacks for home and focus activities.
    Every ActivityStack instance has a ref to this supervisor. Just share the privacy guard package name
    throught the supervisor.

    JIRA: CYAN-2874
    Issue: https://jira.cyanogenmod.org/browse/CYAN-2874

Author: Steve Kondik <shade@chemlab.org>
Date:   Sun Feb 23 19:23:31 2014 +0100

    Use MODE_ASK as the default ops mode in Privacy Guard

    * Prompting the user is far more useful as a default behavior. The
      choice will be remembered after the first request.

Author: Steve Kondik <shade@chemlab.org>
Date:   Tue Feb 25 13:11:12 2014 +0100

    Relocate and cleanup new app ops features and PGify it

Author: Shashank Mittal <mittals@codeaurora.org>
Date:   Wed Dec 4 12:32:12 2013 -0800

    [2/2] Framework AppOps: Add BOOT_COMPLETED operation.

    Add BOOT_COMPLETED operation in AppOps.

    This operation is used to allow user to control auto start of
    applications and services at bootup.

    Change-Id: Ie8488ec1b4683c8617ca569cfc858709f0d35ba2

Author: Sam Mortimer <sam@mortimer.me.uk>
Date:   Mon Dec 8 13:51:02 2014 -0800

    Frameworks: Redirect appops strings to string references

    adapted to reflect new permission indices and codes

    Change-Id: Iba9a45838ee8eb7f5cb6ec6d29776574c86e84b6

Author: Kun Liang <kunliang@codeaurora.org>
Date:   Thu May 15 14:52:15 2014 +0800

    AppOps: Add nfc enable control into AppOps

    Check user permission before enabling nfc.

    Change-Id: Ia84e33c299e4fdecfd66ee933d9e7d37ed29c340

Author: Kun Liang <kunliang@codeaurora.org>
Date:   Thu Dec 11 12:57:33 2014 +0800

    AppOps: fix deadlock issue when showing dialog

    WindowManagerService need call PowerManagerService to release
    wakelock. The Notifier in PowerManagerService need call AppOpsService
    to notify holding wakelock ops is finished.  Meanwhile, AppOpsService
    may need call WindowManagerService to show dialog. This scenario
    will lead to deadlock issue.
    To move showing dialog action out of lock section to fix this issue.
    Since only UI work is moved out of lock area, it is supposed to be
    safe.

    Change-Id: I3f2bf4b9c9d81914cfd3c0fc3fc76d0b4a06a1f6
    CRs-fixed: 786466

Author: Diogo Ferreira <defer@cyngn.com>
Date:   Mon Dec 15 12:07:42 2014 +0000

    appops: Add support for SU

    This patch adds support for superuser app-ops control. The end-goal
    is to better prepare superuser for the multi-user experience while
    also replacing the superuser app with existing components.

    Change-Id: I52acf98a39f18f12a23f4f902a39ae3f7c5b4895

Author: Diogo Ferreira <defer@cyngn.com>
Date:   Wed Dec 17 17:16:16 2014 +0000

    su: Add an indicator when a 'su' session is active

    This adds an indicator to the statusbar that is visible whenever a root
    session is active, akin to the fine location icon.

    Change-Id: I669fcc87e2b7a3201308170d7727ec5fb0e00e2b

Author: Diogo Ferreira <defer@cyngn.com>
Date:   Wed Jan 14 08:44:03 2015 +0000

    appops: Disassociate appops requests from notification broadcasts

    The AppOpsService is essentially a manager for a set of counters
    and permissions. Each operation request has the potential to change
    the state and, as such, access to such state is synchronized.

    We are whitnessing deadlocks caused by the broadcast and, in fact,
    while we want to notify superuser changes eventually, it does not
    have to be synchronous with the app ops request. This patch uses the
    request to schedule the notification on a handler, leaving the locking
    semantics of appops intact.

    Change-Id: I94f6dd2c66b9492f95d3c9ffb438b3e6417007d7

Author: Lars Greiss <kufikugel@googlemail.com>
Date:   Sat Apr 25 03:01:35 2015 +0300

    Launch app privacy settings when tapping on PG notification (1/2)

    Based on https://github.com/SlimRoms/frameworks_base/commit/97ccae06cd0ad1aa366c3a70e8e744277c409b06

    JIRA: CYAN-6077
    Change-Id: I8632e8c944c1d5d7ad2fb2a2276bae5fe2d4a0a0

Author: Roman Birg <roman@cyngn.com>
Date:   Tue Oct 27 11:52:53 2015 -0700

    AppOps: fix wifi scan op

    There's no direct permission tied to it and fix the op-to-switch entry.

    Change-Id: I661ef6707ba50adb371e3223a91880c4838df669
    Signed-off-by: Roman Birg <roman@cyngn.com>

Author: Roman Birg <roman@cyngn.com>
Date:   Thu Oct 29 12:59:14 2015 -0700

    add missing app ops to string array

    Also added op codes to prevent further mismatches.

    Change-Id: I6e20cc5bcabe6a3216cec47d984768bf12cf4311
    Signed-off-by: Roman Birg <roman@cyngn.com>

Author: Roman Birg <roman@cyngn.com>
Date:   Mon Nov 2 09:50:47 2015 -0800

    AppOps: relax some system appops for systemui

    Grant wifi, bt, boot_complete, nfc, and data changes for systemui.

    Also remove the bluetooth permission tied to the bluetooth_change op -
    it is not always directly tied to BLUETOOTH or BLUETOOTH_ADMIN, so we
    can't force one there.

    Change-Id: Ib042dc34b0763b2d84a57baa71dc9fa995724d64
    Signed-off-by: Roman Birg <roman@cyngn.com>

Author: Chirayu Desai <cdesai@cyanogenmod.org>
Date:   Mon Dec 7 14:10:44 2015 -0800

    Allow disabling the privacy guard notification - port from cm-12.1 (2/3)

    Change-Id: Iab0288f50685220c8be0c11ea5075f91ec1bbe32

Author: Gabriele M <moto.falcon.git@gmail.com>
Date:   Wed Jan 6 18:27:32 2016 +0100

    Align checkbox and description in permission confirmation dialog

    Change-Id: I9a9ab3a3f59e3d56fc774174ba37d9e191698fe5

Author: Adnan Begovic <adnan@cyngn.com>
Date:   Mon May 23 16:06:10 2016 -0700

    appops: Implement concept of delayedcount.

     High frequency request ops will be delayed until their ignore count
     ceiling is met. This is to mitigate the overloading the main activity
     manager service handler and having watchdog kill our service.

     Google play services likes to share its uid with numerous packages to avoid
     having to grant permissions from the users perspective and thus is the worst
     example of overloading this queue -- so, to not encourage bad behavior,
     we move them to the back of the line. NOTE: these values are magic, and may need
     tuning. Ideally we'd want a ringbuffer or token bucket here to do proper rate
     limiting.

    Change-Id: I5c3e88807abc80f9700dd68dcecd87dac4626de7
    TICKET: CYNGNOS-2869

Author: Adnan Begovic <adnan@cyngn.com>
Date:   Tue May 24 18:17:03 2016 -0700

    appops: Respect screen interactivity before creating dialogs.

      If the device's screen is currently off, do not queue ask
      runnables who cannot be interacted with. Since these events
      are gating mechanisms for closing an IPC loop, they need to
      happen when the user is interacting with the device.

      Likewise, on screen off, clear the queue of every op as they
      become unnecessary.

    Change-Id: Ie930d200839c9408e882510c6bc3ede37ea889ef
    TICKET: CYNGNOS-2869

Author: Gabriele M <moto.falcon.git@gmail.com>
Date:   Tue Jul 25 18:47:06 2017 +0200

    AppOps: Prevent deadlock when making note of applications

    If noteOperation() is called with ActivityManagerService locked,
    AppOpsService won't be able to show the PermissionDialog, causing
    noteOperation() to wait indefinitely. Keep a reference to the
    current ActivityManagerService instance so that we can check
    whether showing the PermissionDialog is safe or not.

    Even though there's currently no code path that causes startOperation()
    to be called with ActivityManagerService locked, add the same check
    there to prevent the same from happening in future.

    BUGBASH-17

    Change-Id: I118aac6ddf91774a038d73047162cfdb8395e58d

Author: Gabriele M <moto.falcon.git@gmail.com>
Date:   Sun Aug 6 13:08:33 2017 +0200

    Change visibility of the Privacy Guard ops set

    Change-Id: Iafcf058f5e2074982bf45f8c82ef8d027b9358f0

Author: Unpublished <unpublished@gmx.net>
Date:   Tue Oct 24 21:09:31 2017 +0200

    We don't want to feel deprecated...

    use official api instead of deprecated internal method that prints an
    error everytime we call it

    Change-Id: Ie00efe5f514ff8db2b82eeade3a588a17af8cfb4

Author: Jane Manchun Wong <jane@wongmjane.com>
Date:   Wed Mar 1 23:37:58 2017 -0500

    Remove Cid from PrivacyGuard's notification icon

    Change-Id: I5dfe6c2d10e9dd1a022e50e02f72151b1b8a520e

Author: Zhao Wei Liew <zhaoweiliew@gmail.com>
Date:   Tue Sep 6 21:33:57 2016 +0800

    core: Import some PG string improvements from CM 13.0

    This commit partially squashes the following commits:

    c682ba59897babbaef606a8c7dafbe2ca7202989
    core: String improvements from cm-12.1

    7450f84953cf5aaf6b17a7d36be37e625a17f4de
    String update, change wording from "Mobile" to "Cellular"

    Change-Id: I0616eb06f48813814b4005e9b60358669f69b0c8

Author: MSe1969 <mse1969@posteo.de>
Date:   Fri, 16 Nov 2018 20:14:56 +0100

    ClipboardService: Restore different method calls to
    AppOps to fix PG

    Commit 34ffba62b351abf4710a9e64ed345658d2069c37 'Limit instant app access
    to clipboard' (AOSP Bug-ID: 34231507) has introduced the new method
    'clipboardAccessAllowed', which replaces all AppOps calls. However, whilst
    the previous coding made use of the methods checkOp, noteOp and
    checkOpNoThrow, the new method only uses method 'checkOp'. Different from
    'noteOp', the 'checkOp' call only performs a check without setting the
    counter or initializing the Op.

    As a consequence, ClipBoard access did not show up any longer in Lineage's
    Privacy Guard, hence users couldn't control anymore the apps accordingly.

    This change aims at restoring the former call behavior by extending the
    'clipboardAccessAllowed' method with a parameter to specify the AppOp
    calling method according to the former code, which fixes the Privacy Guard
    issue.

    Change-Id: I4db7b4f043eb39068cd7a6346a0eb645648cfada

Author: Danny Baumann <dannybaumann@web.de>
Date:   Tue Dec 18 13:30:00 2018 +0100

    AppOpsService: Fix deadlock

    * When an app had access to external storage and was then set
      to "always ask" or "denied", the app could cause a deadlock
      on ActivityManager, resulting in a soft reboot

    Change-Id: I4341a321562c6ced00215218968f019bfb5f4443

Author: Michael W <baddaemon87@gmail.com>
Date:   Tue Dec 25 11:15:49 2018 +0100

    AppOpsService: Fix another possible deadlock

    * A possible race condition with the isInteractive() calls
      can result in a deadlock resulting in a soft reboot
    * Use a broadcast receiver instead and listen for screen
      state changes
    * Use AppOpsService.this for the synchronized part,
      otherwise the lock is essentially useless.
    * Move the whole content of the receiver under the lock so the
      relevant assignment of mIsInteractive is also synchronized
    * Idea by Danny Baumann <dannybaumann@web.de>

    Change-Id: I3c5a70cf67c3d0b3b9855a598d3d29e17c1aaedc

Change-Id: I5414dd0be6a81e143f5035e58709ac4258c93616
---
 config/hiddenapi-private-dex.txt              |   6 +-
 core/java/android/app/AppOpsManager.java      | 366 ++++++++++-
 core/java/android/os/UserManager.java         |  13 +
 core/java/android/provider/Settings.java      |  13 +
 .../android/internal/app/IAppOpsService.aidl  |   7 +
 .../drawable/stat_notify_privacy_guard.xml    |  11 +
 .../layout/permission_confirmation_dialog.xml |  45 ++
 core/res/res/values/cm_strings.xml            |  96 ++-
 core/res/res/values/config.xml                |   2 +
 core/res/res/values/lineage_arrays.xml        | 189 ++++++
 core/res/res/values/lineage_symbols.xml       |  14 +
 .../SystemUI/res/drawable/stat_sys_su.xml     |  14 +
 .../src/com/android/systemui/Dependency.java  |   4 +
 .../statusbar/phone/PhoneStatusBarPolicy.java |  19 +
 .../statusbar/policy/SuController.java        |  27 +
 .../statusbar/policy/SuControllerImpl.java    | 121 ++++
 .../com/android/server/AppOpsService.java     | 601 ++++++++++++++++--
 .../server/BluetoothManagerService.java       |  10 +
 .../com/android/server/PermissionDialog.java  | 177 ++++++
 .../server/PermissionDialogReqQueue.java      | 102 +++
 .../server/am/ActivityManagerService.java     |  74 ++-
 .../com/android/server/am/ActivityRecord.java |  30 +
 .../server/am/ActivityStackSupervisor.java    |   3 +
 .../com/android/server/am/UserController.java |   4 +-
 .../server/clipboard/ClipboardService.java    |  40 +-
 .../server/pm/PackageManagerService.java      |  17 +
 .../android/server/pm/UserManagerService.java |   2 +
 .../server/pm/UserRestrictionsUtils.java      |   6 +-
 .../android/telephony/TelephonyManager.java   |  12 +
 29 files changed, 1935 insertions(+), 90 deletions(-)
 create mode 100644 core/res/res/drawable/stat_notify_privacy_guard.xml
 create mode 100644 core/res/res/layout/permission_confirmation_dialog.xml
 create mode 100644 core/res/res/values/lineage_arrays.xml
 create mode 100644 packages/SystemUI/res/drawable/stat_sys_su.xml
 create mode 100644 packages/SystemUI/src/com/android/systemui/statusbar/policy/SuController.java
 create mode 100644 packages/SystemUI/src/com/android/systemui/statusbar/policy/SuControllerImpl.java
 create mode 100644 services/core/java/com/android/server/PermissionDialog.java
 create mode 100644 services/core/java/com/android/server/PermissionDialogReqQueue.java

diff --git a/config/hiddenapi-private-dex.txt b/config/hiddenapi-private-dex.txt
index 2c4865514c2..f61c1a531b0 100644
--- a/config/hiddenapi-private-dex.txt
+++ b/config/hiddenapi-private-dex.txt
@@ -4421,9 +4421,9 @@ Landroid/app/AppOpsManager$OnOpChangedInternalListener;
 Landroid/app/AppOpsManager$OnOpChangedInternalListener;-><init>()V
 Landroid/app/AppOpsManager$OnOpChangedInternalListener;->onOpChanged(ILjava/lang/String;)V
 Landroid/app/AppOpsManager$OpEntry;
-Landroid/app/AppOpsManager$OpEntry;-><init>(IIJJIILjava/lang/String;)V
-Landroid/app/AppOpsManager$OpEntry;-><init>(II[J[JIILjava/lang/String;)V
-Landroid/app/AppOpsManager$OpEntry;-><init>(II[J[JIZILjava/lang/String;)V
+Landroid/app/AppOpsManager$OpEntry;-><init>(IIJJIILjava/lang/String;II)V
+Landroid/app/AppOpsManager$OpEntry;-><init>(II[J[JIILjava/lang/String;II)V
+Landroid/app/AppOpsManager$OpEntry;-><init>(II[J[JIZILjava/lang/String;II)V
 Landroid/app/AppOpsManager$OpEntry;-><init>(Landroid/os/Parcel;)V
 Landroid/app/AppOpsManager$OpEntry;->CREATOR:Landroid/os/Parcelable$Creator;
 Landroid/app/AppOpsManager$OpEntry;->getDuration()I
diff --git a/core/java/android/app/AppOpsManager.java b/core/java/android/app/AppOpsManager.java
index c58b91e39d0..a112cafb3b5 100644
--- a/core/java/android/app/AppOpsManager.java
+++ b/core/java/android/app/AppOpsManager.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2012 The Android Open Source Project
+ * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -118,6 +119,12 @@ public class AppOpsManager {
      */
     public static final int MODE_FOREGROUND = 4;
 
+    /**
+     * @hide Result from {@link #checkOp}, {@link #noteOp}, {@link #startOp}:
+     * AppOps Service should show a dialog box on screen to get user permission.
+     */
+    public static final int MODE_ASK = 5;
+
     /**
      * Flag for {@link #startWatchingMode(String, String, int, OnOpChangedListener)}:
      * Also get reports if the foreground state of an op's uid changes.  This only works
@@ -135,6 +142,7 @@ public class AppOpsManager {
             "deny",         // MODE_ERRORED
             "default",      // MODE_DEFAULT
             "foreground",   // MODE_FOREGROUND
+            "ask",          // MODE_ASK
     };
 
     /**
@@ -188,7 +196,8 @@ public class AppOpsManager {
     // when adding one of these:
     //  - increment _NUM_OP
     //  - define an OPSTR_* constant (marked as @SystemApi)
-    //  - add rows to sOpToSwitch, sOpToString, sOpNames, sOpToPerms, sOpDefault
+    //  - add rows to sOpToSwitch, sOpToString, sOpNames, sOpToPerms, sOpDefault,
+    //    sOpDefaultStrictMode, sOpToOpString, sOpStrictMode.
     //  - add descriptive strings to Settings/res/values/arrays.xml
     //  - add the op to the appropriate template in AppOpsState.OpsTemplate (settings app)
 
@@ -352,8 +361,18 @@ public class AppOpsManager {
     public static final int OP_START_FOREGROUND = 76;
     /** @hide */
     public static final int OP_BLUETOOTH_SCAN = 77;
-    /** @hide */
-    public static final int _NUM_OP = 78;
+    /** @hide Bluetooth state change */
+    public static final int OP_BLUETOOTH_CHANGE = 78;
+    /** @hide Boot completed */
+    public static final int OP_BOOT_COMPLETED = 79;
+    /** @hide NFC state change */
+    public static final int OP_NFC_CHANGE = 80;
+    /** @hide Data connect state change */
+    public static final int OP_DATA_CONNECT_CHANGE = 81;
+    /** @hide SU access */
+    public static final int OP_SU = 82;
+    /** @hide */
+    public static final int _NUM_OP = 83;
 
     /** Access to coarse location information. */
     public static final String OPSTR_COARSE_LOCATION = "android:coarse_location";
@@ -597,6 +616,17 @@ public class AppOpsManager {
     public static final String OPSTR_START_FOREGROUND = "android:start_foreground";
     /** @hide */
     public static final String OPSTR_BLUETOOTH_SCAN = "android:bluetooth_scan";
+    /** @hide */
+    public static final String OPSTR_BLUETOOTH_CHANGE = "android:bluetooth_change";
+    /** @hide */
+    public static final String OPSTR_BOOT_COMPLETED = "android:boot_completed";
+    /** @hide */
+    public static final String OPSTR_NFC_CHANGE = "android:nfc_change";
+    /** @hide */
+    public static final String OPSTR_DATA_CONNECT_CHANGE = "android:data_connect_change";
+
+    /** @hide */
+    public static final String OPSTR_SU = "android:su";
 
     // Warning: If an permission is added here it also has to be added to
     // com.android.packageinstaller.permission.utils.EventLogger
@@ -646,6 +676,7 @@ public class AppOpsManager {
             OP_WRITE_SETTINGS,
             OP_REQUEST_INSTALL_PACKAGES,
             OP_START_FOREGROUND,
+            OP_SU
     };
 
     /**
@@ -667,7 +698,7 @@ public class AppOpsManager {
             OP_WRITE_CALL_LOG,                  // WRITE_CALL_LOG
             OP_READ_CALENDAR,                   // READ_CALENDAR
             OP_WRITE_CALENDAR,                  // WRITE_CALENDAR
-            OP_COARSE_LOCATION,                 // WIFI_SCAN
+            OP_WIFI_SCAN,                       // WIFI_SCAN
             OP_POST_NOTIFICATION,               // POST_NOTIFICATION
             OP_COARSE_LOCATION,                 // NEIGHBORING_CELLS
             OP_CALL_PHONE,                      // CALL_PHONE
@@ -734,7 +765,12 @@ public class AppOpsManager {
             OP_ACCEPT_HANDOVER,                 // ACCEPT_HANDOVER
             OP_MANAGE_IPSEC_TUNNELS,            // MANAGE_IPSEC_HANDOVERS
             OP_START_FOREGROUND,                // START_FOREGROUND
-            OP_COARSE_LOCATION,                 // BLUETOOTH_SCAN
+            OP_BLUETOOTH_SCAN,                  // BLUETOOTH_SCAN
+            OP_BLUETOOTH_CHANGE,                // BLUETOOTH_CHANGE
+            OP_BOOT_COMPLETED,                  // BOOT_COMPLETED
+            OP_NFC_CHANGE,                      // NFC_CHANGE
+            OP_DATA_CONNECT_CHANGE,             // DATA_CONNECT_CHANGE
+            OP_SU,                              // SU
     };
 
     /**
@@ -819,6 +855,11 @@ public class AppOpsManager {
             OPSTR_MANAGE_IPSEC_TUNNELS,
             OPSTR_START_FOREGROUND,
             OPSTR_BLUETOOTH_SCAN,
+            OPSTR_BLUETOOTH_CHANGE,
+            OPSTR_BOOT_COMPLETED,
+            OPSTR_NFC_CHANGE,
+            OPSTR_DATA_CONNECT_CHANGE,
+            OPSTR_SU,
     };
 
     /**
@@ -904,6 +945,11 @@ public class AppOpsManager {
             "MANAGE_IPSEC_TUNNELS",
             "START_FOREGROUND",
             "BLUETOOTH_SCAN",
+            "BLUETOOTH_CHANGE",
+            "BOOT_COMPLETED",
+            "NFC_CHANGE",
+            "DATA_CONNECT_CHANGE",
+            "SU",
     };
 
     /**
@@ -921,7 +967,7 @@ public class AppOpsManager {
             android.Manifest.permission.WRITE_CALL_LOG,
             android.Manifest.permission.READ_CALENDAR,
             android.Manifest.permission.WRITE_CALENDAR,
-            android.Manifest.permission.ACCESS_WIFI_STATE,
+            null, // no permission for wifi scan available
             null, // no permission required for notifications
             null, // neighboring cells shares the coarse location perm
             android.Manifest.permission.CALL_PHONE,
@@ -989,6 +1035,11 @@ public class AppOpsManager {
             null, // no permission for OP_MANAGE_IPSEC_TUNNELS
             Manifest.permission.FOREGROUND_SERVICE,
             null, // no permission for OP_BLUETOOTH_SCAN
+            null,
+            Manifest.permission.RECEIVE_BOOT_COMPLETED,
+            Manifest.permission.NFC,
+            null,
+            null, // no permission for OP_SU
     };
 
     /**
@@ -1075,6 +1126,11 @@ public class AppOpsManager {
             null, // MANAGE_IPSEC_TUNNELS
             null, // START_FOREGROUND
             null, // maybe should be UserManager.DISALLOW_SHARE_LOCATION, //BLUETOOTH_SCAN
+            null, // BLUETOOTH_CHANGE
+            null, // BOOT_COMPLETED
+            null, // NFC_CHANGE
+            null, // DATA_CONNECT_CHANGE
+            UserManager.DISALLOW_SU, // SU TODO: this should really be investigated.
     };
 
     /**
@@ -1160,6 +1216,11 @@ public class AppOpsManager {
             false, // MANAGE_IPSEC_HANDOVERS
             false, // START_FOREGROUND
             true, // BLUETOOTH_SCAN
+            true, // BLUETOOTH_CHANGE
+            true, // BOOT_COMPLETED
+            true, // NFC_CHANGE
+            true, // DATA_CONNECT_CHANGE
+            false, // SU
     };
 
     /**
@@ -1244,6 +1305,190 @@ public class AppOpsManager {
             AppOpsManager.MODE_ERRORED,  // MANAGE_IPSEC_TUNNELS
             AppOpsManager.MODE_ALLOWED,  // OP_START_FOREGROUND
             AppOpsManager.MODE_ALLOWED,  // OP_BLUETOOTH_SCAN
+            AppOpsManager.MODE_ALLOWED,  // OP_BLUETOOTH_CHANGE
+            AppOpsManager.MODE_ALLOWED,  // OP_BOOT_COMPLETED
+            AppOpsManager.MODE_ALLOWED,  // OP_NFC_CHANGE
+            AppOpsManager.MODE_ALLOWED,  // OP_DATA_CONNECT_CHANGE
+            AppOpsManager.MODE_ASK,      // OP_SU
+    };
+
+    /**
+     * This specifies the default mode for each strict operation.
+     */
+
+    private static int[] sOpDefaultStrictMode = new int[] {
+            AppOpsManager.MODE_ASK,     // OP_COARSE_LOCATION
+            AppOpsManager.MODE_ASK,     // OP_FINE_LOCATION
+            AppOpsManager.MODE_ASK,     // OP_GPS
+            AppOpsManager.MODE_ALLOWED, // OP_VIBRATE
+            AppOpsManager.MODE_ASK,     // OP_READ_CONTACTS
+            AppOpsManager.MODE_ASK,     // OP_WRITE_CONTACTS
+            AppOpsManager.MODE_ASK,     // OP_READ_CALL_LOG
+            AppOpsManager.MODE_ASK,     // OP_WRITE_CALL_LOG
+            AppOpsManager.MODE_ALLOWED, // OP_READ_CALENDAR
+            AppOpsManager.MODE_ALLOWED, // OP_WRITE_CALENDAR
+            AppOpsManager.MODE_ASK,     // OP_WIFI_SCAN
+            AppOpsManager.MODE_ALLOWED, // OP_POST_NOTIFICATION
+            AppOpsManager.MODE_ALLOWED, // OP_NEIGHBORING_CELLS
+            AppOpsManager.MODE_ASK,     // OP_CALL_PHONE
+            AppOpsManager.MODE_ASK,     // OP_READ_SMS
+            AppOpsManager.MODE_ASK,     // OP_WRITE_SMS
+            AppOpsManager.MODE_ASK,     // OP_RECEIVE_SMS
+            AppOpsManager.MODE_ALLOWED, // OP_RECEIVE_EMERGECY_SMS
+            AppOpsManager.MODE_ASK,     // OP_RECEIVE_MMS
+            AppOpsManager.MODE_ALLOWED, // OP_RECEIVE_WAP_PUSH
+            AppOpsManager.MODE_ASK,     // OP_SEND_SMS
+            AppOpsManager.MODE_ALLOWED, // OP_READ_ICC_SMS
+            AppOpsManager.MODE_ALLOWED, // OP_WRITE_ICC_SMS
+            AppOpsManager.MODE_ALLOWED, // OP_WRITE_SETTINGS
+            AppOpsManager.MODE_ALLOWED, // OP_SYSTEM_ALERT_WINDOW
+            AppOpsManager.MODE_ALLOWED, // OP_ACCESS_NOTIFICATIONS
+            AppOpsManager.MODE_ASK,     // OP_CAMERA
+            AppOpsManager.MODE_ASK,     // OP_RECORD_AUDIO
+            AppOpsManager.MODE_ALLOWED, // OP_PLAY_AUDIO
+            AppOpsManager.MODE_ALLOWED, // OP_READ_CLIPBOARD
+            AppOpsManager.MODE_ALLOWED, // OP_WRITE_CLIPBOARD
+            AppOpsManager.MODE_ALLOWED, // OP_TAKE_MEDIA_BUTTONS
+            AppOpsManager.MODE_ALLOWED, // OP_TAKE_AUDIO_FOCUS
+            AppOpsManager.MODE_ALLOWED, // OP_AUDIO_MASTER_VOLUME
+            AppOpsManager.MODE_ALLOWED, // OP_AUDIO_VOICE_VOLUME
+            AppOpsManager.MODE_ALLOWED, // OP_AUDIO_RING_VOLUME
+            AppOpsManager.MODE_ALLOWED, // OP_AUDIO_MEDIA_VOLUME
+            AppOpsManager.MODE_ALLOWED, // OP_AUDIO_ALARM_VOLUME
+            AppOpsManager.MODE_ALLOWED, // OP_AUDIO_NOTIFICATION_VOLUME
+            AppOpsManager.MODE_ALLOWED, // OP_AUDIO_BLUETOOTH_VOLUME
+            AppOpsManager.MODE_ALLOWED, // OP_WAKE_LOCK
+            AppOpsManager.MODE_ALLOWED, // OP_MONITOR_LOCATION
+            AppOpsManager.MODE_ASK,     // OP_MONITOR_HIGH_POWER_LOCATION
+            AppOpsManager.MODE_DEFAULT, // OP_GET_USAGE_STATS
+            AppOpsManager.MODE_ALLOWED, // OP_MUTE_MICROPHONE
+            AppOpsManager.MODE_ALLOWED, // OP_TOAST_WINDOW
+            AppOpsManager.MODE_IGNORED, // OP_PROJECT_MEDIA
+            AppOpsManager.MODE_IGNORED, // OP_ACTIVATE_VPN
+            AppOpsManager.MODE_ALLOWED, // OP WALLPAPER
+            AppOpsManager.MODE_ALLOWED, // OP_ASSIST_STRUCTURE
+            AppOpsManager.MODE_ALLOWED, // OP_ASSIST_SCREENSHOT
+            AppOpsManager.MODE_ALLOWED, // OP_READ_PHONE_STATE
+            AppOpsManager.MODE_ALLOWED, // OP_ADD_VOICEMAIL
+            AppOpsManager.MODE_ALLOWED, // OP_USE_SIP
+            AppOpsManager.MODE_ALLOWED, // OP_PROCESS_OUTGOING_CALLS
+            AppOpsManager.MODE_ALLOWED, // OP_USE_FINGERPRINT
+            AppOpsManager.MODE_ALLOWED, // OP_BODY_SENSORS
+            AppOpsManager.MODE_ALLOWED, // OP_READ_CELL_BROADCASTS
+            AppOpsManager.MODE_ERRORED, // OP_MOCK_LOCATION
+            AppOpsManager.MODE_ALLOWED, // OP_READ_EXTERNAL_STORAGE
+            AppOpsManager.MODE_ALLOWED, // OP_WRITE_EXTERNAL_STORAGE
+            AppOpsManager.MODE_ALLOWED, // OP_TURN_ON_SCREEN
+            AppOpsManager.MODE_ALLOWED, // OP_GET_ACCOUNTS
+            AppOpsManager.MODE_ASK,     // MODE_RUN_IN_BACKGROUND
+            AppOpsManager.MODE_ALLOWED, // OP_AUDIO_ACCESSIBILITY_VOLUME
+            AppOpsManager.MODE_ALLOWED, // READ_PHONE_NUMBERS
+            AppOpsManager.MODE_DEFAULT, // OP_REQUEST_INSTALL_PACKAGES
+            AppOpsManager.MODE_ALLOWED, // OP_PICTURE_IN_PICTURE
+            AppOpsManager.MODE_DEFAULT, // OP_INSTANT_APP_START_FOREGROUND
+            AppOpsManager.MODE_ALLOWED, // ANSWER_PHONE_CALLS
+            AppOpsManager.MODE_ASK,     // OP_RUN_ANY_IN_BACKGROUND
+            AppOpsManager.MODE_ALLOWED, // OP_CHANGE_WIFI_STATE
+            AppOpsManager.MODE_ALLOWED, // REQUEST_DELETE_PACKAGES
+            AppOpsManager.MODE_ALLOWED, // OP_BIND_ACCESSIBILITY_SERVICE
+            AppOpsManager.MODE_ALLOWED, // ACCEPT_HANDOVER
+            AppOpsManager.MODE_ERRORED, // MANAGE_IPSEC_TUNNELS
+            AppOpsManager.MODE_ALLOWED, // OP_START_FOREGROUND
+            AppOpsManager.MODE_ALLOWED, // OP_BLUETOOTH_SCAN
+            AppOpsManager.MODE_ASK,     // OP_BLUETOOTH_CHANGE
+            AppOpsManager.MODE_ASK,     // OP_BOOT_COMPLETED
+            AppOpsManager.MODE_ASK,     // OP_NFC_CHANGE
+            AppOpsManager.MODE_ASK,     // OP_DATA_CONNECT_CHANGE
+            AppOpsManager.MODE_ASK,     // OP_SU
+    };
+
+    /**
+     * This specifies if operation is in strict mode.
+     */
+    private final static boolean[] sOpStrictMode = new boolean[] {
+            true,  // COARSE_LOCATION
+            true,  // FINE_LOCATION
+            true,  // GPS
+            false, // VIBRATE
+            true,  // READ_CONTACTS
+            true,  // WRITE_CONTACTS
+            true,  // READ_CALL_LOG
+            true,  // WRITE_CALL_LOG
+            false, // READ_CALENDAR
+            false, // WRITE_CALENDAR
+            true,  // WIFI_SCAN
+            false, // POST_NOTIFICATION
+            false, // NEIGHBORING_CELLS
+            true,  // CALL_PHONE
+            true,  // READ_SMS
+            true,  // WRITE_SMS
+            true,  // RECEIVE_SMS
+            false, // RECEIVE_EMERGECY_SMS
+            true,  // RECEIVE_MMS
+            false, // RECEIVE_WAP_PUSH
+            true,  // SEND_SMS
+            true,  // READ_ICC_SMS
+            true,  // WRITE_ICC_SMS
+            true,  // WRITE_SETTINGS
+            false, // SYSTEM_ALERT_WINDOW
+            false, // ACCESS_NOTIFICATIONS
+            true,  // CAMERA
+            true,  // RECORD_AUDIO
+            true,  // PLAY_AUDIO
+            false, // READ_CLIPBOARD
+            false, // WRITE_CLIPBOARD
+            true,  // TAKE_MEDIA_BUTTONS
+            true,  // TAKE_AUDIO_FOCUS
+            false, // AUDIO_MASTER_VOLUME
+            false, // AUDIO_VOICE_VOLUME
+            false, // AUDIO_RING_VOLUME
+            false, // AUDIO_MEDIA_VOLUME
+            false, // AUDIO_ALARM_VOLUME
+            false, // AUDIO_NOTIFICATION_VOLUME
+            false, // AUDIO_BLUETOOTH_VOLUME
+            false, // WAKE_LOCK
+            true,  // MONITOR_LOCATION
+            true,  // MONITOR_HIGH_POWER_LOCATION
+            true,  // GET_USAGE_STATS
+            false, // MUTE_MICROPHONE
+            false, // TOAST_WINDOW
+            true,  // PROJECT_MEDIA
+            false, // ACTIVATE_VPN
+            false, // WALLPAPER
+            false, // ASSIST_STRUCTURE
+            false, // ASSIST_SCREENSHOT
+            true,  // READ_PHONE_STATE
+            true,  // ADD_VOICEMAIL
+            true,  // USE_SIP
+            true,  // PROCESS_OUTGOING_CALLS
+            true,  // USE_FINGERPRINT
+            true,  // BODY_SENSORS
+            false, // READ_CELL_BROADCASTS
+            true,  // MOCK_LOCATION
+            true,  // READ_EXTERNAL_STORAGE
+            true,  // WRITE_EXTERNAL_STORAGE
+            false, // TURN_ON_SCREEN
+            false, // GET_ACCOUNTS
+            true,  // RUN_IN_BACKGROUND
+            false, // AUDIO_ACCESSIBILITY_VOLUME
+            true,  // READ_PHONE_NUMBERS
+            true,  // REQUEST_INSTALL_PACKAGES
+            true,  // ENTER_PICTURE_IN_PICTURE_ON_HIDE
+            true,  // INSTANT_APP_START_FOREGROUND
+            false, // ANSWER_PHONE_CALLS
+            true,  // OP_RUN_ANY_IN_BACKGROUND
+            false, // OP_CHANGE_WIFI_STATE
+            false, // OP_REQUEST_DELETE_PACKAGES
+            false, // OP_BIND_ACCESSIBILITY_SERVICE
+            false, // ACCEPT_HANDOVER
+            false, // MANAGE_IPSEC_HANDOVERS
+            false, // START_FOREGROUND
+            true,  // BLUETOOTH_SCAN
+            true,  // BLUETOOTH_CHANGE
+            true,  // BOOT_COMPLETED
+            true,  // NFC_CHANGE
+            true,  // DATA_CONNECT_CHANGE
+            true,  // SU
     };
 
     /**
@@ -1332,6 +1577,11 @@ public class AppOpsManager {
             false, // MANAGE_IPSEC_TUNNELS
             false, // START_FOREGROUND
             false, // BLUETOOTH_SCAN
+            false, // OP_BLUETOOTH_CHANGE
+            false, // OP_BOOT_COMPLETED
+            false, // OP_NFC_CHANGE
+            false, // OP_DATA_CONNECT_CHANGE
+            false, // OP_SU
     };
 
     /**
@@ -1344,6 +1594,20 @@ public class AppOpsManager {
      */
     private static HashMap<String, Integer> sPermToOp = new HashMap<>();
 
+    private static HashMap<String, Integer> sNameToOp = new HashMap<String, Integer>();
+
+    /**
+     * App op guard states.
+     * @hide
+     */
+    public static final int[] PRIVACY_GUARD_OP_STATES = new int[] {
+            OP_COARSE_LOCATION,
+            OP_READ_CALL_LOG,
+            OP_READ_CONTACTS,
+            OP_READ_CALENDAR,
+            OP_READ_SMS,
+    };
+
     static {
         if (sOpToSwitch.length != _NUM_OP) {
             throw new IllegalStateException("sOpToSwitch length " + sOpToSwitch.length
@@ -1365,6 +1629,10 @@ public class AppOpsManager {
             throw new IllegalStateException("sOpDefaultMode length " + sOpDefaultMode.length
                     + " should be " + _NUM_OP);
         }
+        if (sOpDefaultStrictMode.length != _NUM_OP) {
+            throw new IllegalStateException("sOpDefaultStrictMode length "
+                    + sOpDefaultStrictMode.length + " should be " + _NUM_OP);
+        }
         if (sOpDisableReset.length != _NUM_OP) {
             throw new IllegalStateException("sOpDisableReset length " + sOpDisableReset.length
                     + " should be " + _NUM_OP);
@@ -1377,6 +1645,10 @@ public class AppOpsManager {
             throw new IllegalStateException("sOpAllowSYstemRestrictionsBypass length "
                     + sOpRestrictions.length + " should be " + _NUM_OP);
         }
+        if (sOpStrictMode.length != _NUM_OP) {
+            throw new IllegalStateException("sOpStrictMode length " + sOpStrictMode.length
+                    + " should be " + _NUM_OP);
+        }
         for (int i=0; i<_NUM_OP; i++) {
             if (sOpToString[i] != null) {
                 sOpStrToOp.put(sOpToString[i], i);
@@ -1387,6 +1659,9 @@ public class AppOpsManager {
                 sPermToOp.put(sOpPerms[op], op);
             }
         }
+        for (int i=0; i<_NUM_OP; i++) {
+            sNameToOp.put(sOpNames[i], i);
+        }
     }
 
     /**
@@ -1418,6 +1693,15 @@ public class AppOpsManager {
         throw new IllegalArgumentException("Unknown operation string: " + op);
     }
 
+    /**
+     * Map a non-localized name for the operation back to the Op number
+     * @hide
+     */
+    public static int nameToOp(String name) {
+        Integer val = sNameToOp.get(name);
+        return val != null ? val : OP_NONE;
+    }
+
     /**
      * Retrieve the permission associated with an operation, or null if there is not one.
      * @hide
@@ -1458,10 +1742,17 @@ public class AppOpsManager {
      * Retrieve the default mode for the operation.
      * @hide
      */
-    public static int opToDefaultMode(int op) {
+    public static int opToDefaultMode(int op, boolean isStrict) {
+        if (isStrict) {
+            return sOpDefaultStrictMode[op];
+        }
         return sOpDefaultMode[op];
     }
 
+    public static int opToDefaultMode(int op) {
+        return opToDefaultMode(op, false);
+    }
+
     /**
      * Retrieve the human readable mode.
      * @hide
@@ -1557,9 +1848,11 @@ public class AppOpsManager {
         private final int mProxyUid;
         private final boolean mRunning;
         private final String mProxyPackageName;
+        private final int mAllowedCount;
+        private final int mIgnoredCount;
 
         public OpEntry(int op, int mode, long time, long rejectTime, int duration,
-                int proxyUid, String proxyPackage) {
+                int proxyUid, String proxyPackage, int allowedCount, int ignoredCount) {
             mOp = op;
             mMode = mode;
             mTimes = new long[_NUM_UID_STATE];
@@ -1570,10 +1863,13 @@ public class AppOpsManager {
             mRunning = duration == -1;
             mProxyUid = proxyUid;
             mProxyPackageName = proxyPackage;
+            mAllowedCount = allowedCount;
+            mIgnoredCount = ignoredCount;
         }
 
         public OpEntry(int op, int mode, long[] times, long[] rejectTimes, int duration,
-                boolean running, int proxyUid, String proxyPackage) {
+                boolean running, int proxyUid, String proxyPackage,
+                int allowedCount, int ignoredCount) {
             mOp = op;
             mMode = mode;
             mTimes = new long[_NUM_UID_STATE];
@@ -1584,11 +1880,14 @@ public class AppOpsManager {
             mRunning = running;
             mProxyUid = proxyUid;
             mProxyPackageName = proxyPackage;
+            mAllowedCount = allowedCount;
+            mIgnoredCount = ignoredCount;
         }
 
         public OpEntry(int op, int mode, long[] times, long[] rejectTimes, int duration,
-                int proxyUid, String proxyPackage) {
-            this(op, mode, times, rejectTimes, duration, duration == -1, proxyUid, proxyPackage);
+                int proxyUid, String proxyPackage, int allowedCount, int ignoredCount) {
+            this(op, mode, times, rejectTimes, duration, duration == -1, proxyUid, proxyPackage,
+                    allowedCount, ignoredCount);
         }
 
         public int getOp() {
@@ -1655,6 +1954,14 @@ public class AppOpsManager {
             return mProxyPackageName;
         }
 
+        public int getAllowedCount() {
+            return mAllowedCount;
+        }
+
+        public int getIgnoredCount() {
+            return mIgnoredCount;
+        }
+
         @Override
         public int describeContents() {
             return 0;
@@ -1670,6 +1977,8 @@ public class AppOpsManager {
             dest.writeBoolean(mRunning);
             dest.writeInt(mProxyUid);
             dest.writeString(mProxyPackageName);
+            dest.writeInt(mAllowedCount);
+            dest.writeInt(mIgnoredCount);
         }
 
         OpEntry(Parcel source) {
@@ -1681,6 +1990,8 @@ public class AppOpsManager {
             mRunning = source.readBoolean();
             mProxyUid = source.readInt();
             mProxyPackageName = source.readString();
+            mAllowedCount = source.readInt();
+            mIgnoredCount = source.readInt();
         }
 
         public static final Creator<OpEntry> CREATOR = new Creator<OpEntry>() {
@@ -2589,4 +2900,37 @@ public class AppOpsManager {
         }
         return time;
     }
+
+    /**
+     * Check if op in strict mode
+     * @hide
+     */
+    public static boolean isStrictOp(int code) {
+        return sOpStrictMode[code];
+    }
+
+    /** @hide */
+    public boolean getPrivacyGuardSettingForPackage(int uid, String packageName) {
+        try {
+            return mService.getPrivacyGuardSettingForPackage(uid, packageName);
+        } catch (RemoteException e) {
+        }
+        return false;
+    }
+
+    /** @hide */
+    public void setPrivacyGuardSettingForPackage(int uid, String packageName, boolean state) {
+        try {
+            mService.setPrivacyGuardSettingForPackage(uid, packageName, state);
+        } catch (RemoteException e) {
+        }
+    }
+
+    /** @hide */
+    public void resetCounters() {
+        try {
+            mService.resetCounters();
+        } catch (RemoteException e) {
+        }
+    }
 }
diff --git a/core/java/android/os/UserManager.java b/core/java/android/os/UserManager.java
index b5918519d87..dc006513798 100644
--- a/core/java/android/os/UserManager.java
+++ b/core/java/android/os/UserManager.java
@@ -961,6 +961,19 @@ public class UserManager {
      */
     public static final String DISALLOW_PRINTING = "no_printing";
 
+    /**
+     * Specifies whether the user is allowed to use SU commands.
+     *
+     * The default value is <code>false</code>.
+     *
+     * <p/>Key for user restrictions.
+     * <p/>Type: Boolean
+     * @see #setUserRestrictions(Bundle)
+     * @see #getUserRestrictions()
+     * @hide
+     */
+    public static final String DISALLOW_SU = "no_su";
+
     /**
      * Application restriction key that is used to indicate the pending arrival
      * of real restrictions for the app.
diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index be9e5b8d403..e8ab68b3493 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -897,6 +897,19 @@ public final class Settings {
     public static final String ACTION_IGNORE_BACKGROUND_DATA_RESTRICTIONS_SETTINGS =
             "android.settings.IGNORE_BACKGROUND_DATA_RESTRICTIONS_SETTINGS";
 
+    /**
+     * @hide
+     * Activity Action: Show the "app ops" details screen.
+     * <p>
+     * Input: The Intent's data URI specifies the application package name
+     * to be shown, with the "package" scheme.  That is "package:com.my.app".
+     * <p>
+     * Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_APP_OPS_DETAILS_SETTINGS =
+            "android.settings.APP_OPS_DETAILS_SETTINGS";
+
     /**
      * @hide
      * Activity Action: Show the "app ops" settings screen.
diff --git a/core/java/com/android/internal/app/IAppOpsService.aidl b/core/java/com/android/internal/app/IAppOpsService.aidl
index 0ed97247712..c2a1a343213 100644
--- a/core/java/com/android/internal/app/IAppOpsService.aidl
+++ b/core/java/com/android/internal/app/IAppOpsService.aidl
@@ -56,4 +56,11 @@ interface IAppOpsService {
     boolean isOperationActive(int code, int uid, String packageName);
 
     void startWatchingModeWithFlags(int op, String packageName, int flags, IAppOpsCallback callback);
+
+    // Privacy guard methods
+    boolean getPrivacyGuardSettingForPackage(int uid, String packageName);
+    void setPrivacyGuardSettingForPackage(int uid, String packageName, boolean state);
+
+    // AppOps accounting
+    void resetCounters();
 }
diff --git a/core/res/res/drawable/stat_notify_privacy_guard.xml b/core/res/res/drawable/stat_notify_privacy_guard.xml
new file mode 100644
index 00000000000..de3aa7711b1
--- /dev/null
+++ b/core/res/res/drawable/stat_notify_privacy_guard.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="26dp"
+    android:height="24dp"
+    android:viewportWidth="26"
+    android:viewportHeight="24">
+
+    <path
+        android:pathData="M21.539,8.978c-0.132,2.629-0.803,5.264-2.162,7.534  c-1.186,1.991-2.889,3.675-4.905,4.82c-0.459,0.259-0.932,0.494-1.427,0.676c-0.061,0.029-0.122-0.014-0.18-0.032 c-1.047-0.415-2.019-1.006-2.909-1.693c-1.807-1.397-3.239-3.263-4.151-5.356c-0.725-1.651-1.137-3.429-1.297-5.222 C4.33,7.77,4.442,5.816,4.73,3.896c0.601,0.053,1.207,0.031,1.807-0.017c1.309-0.115,2.596-0.41,3.849-0.799 c0.888-0.283,1.766-0.604,2.611-0.999c1.13,0.523,2.311,0.935,3.512,1.26c1.549,0.412,3.157,0.666,4.763,0.562 c0.116,0.846,0.216,1.695,0.261,2.548c0.002,0.241,0.042,0.481,0.037,0.723C21.574,7.776,21.594,8.379,21.539,8.978z"
+        android:fillColor="#FFFFFFFF" />
+</vector>
diff --git a/core/res/res/layout/permission_confirmation_dialog.xml b/core/res/res/layout/permission_confirmation_dialog.xml
new file mode 100644
index 00000000000..7f31a9cbd78
--- /dev/null
+++ b/core/res/res/layout/permission_confirmation_dialog.xml
@@ -0,0 +1,45 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/*
+** Copyright (c) 2013, The Linux Foundation. All rights reserved.
+** Not a Contribution.
+**
+** Copyright 2012 The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+
+<LinearLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/parentPanel"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:paddingStart="16dp"
+    android:paddingEnd="16dp"
+    android:orientation="vertical">
+
+    <TextView android:id="@+id/permission_text"
+        style="?android:attr/textAppearanceMedium"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:paddingStart="8dp"
+        android:paddingTop="16dip"
+        android:paddingBottom="16dip" />
+
+    <CheckBox android:id="@+id/permission_remember_choice_checkbox"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:text="@string/permission_remember_choice" />
+
+</LinearLayout>
diff --git a/core/res/res/values/cm_strings.xml b/core/res/res/values/cm_strings.xml
index a5a33bc633d..301131e2663 100644
--- a/core/res/res/values/cm_strings.xml
+++ b/core/res/res/values/cm_strings.xml
@@ -25,4 +25,98 @@
     <!-- ADB notification message-->
     <string name="adb_active_generic_notification_message">Touch to disable debugging.</string>
 
- </resources>
+    <!-- App ops requests -->
+    <string name="app_ops_access_camera">access the camera</string>
+    <string name="app_ops_access_location">access your location</string>
+    <string name="app_ops_access_notifications">read your notifications</string>
+    <string name="app_ops_activate_vpn">activate a VPN</string>
+    <string name="app_ops_add_voicemail">add a voicemail</string>
+    <string name="app_ops_app_start_foreground">start instant app in foreground</string>
+    <string name="app_ops_assist_screenshot">take a screenshot</string>
+    <string name="app_ops_assist_structure">use assist structure</string>
+    <string name="app_ops_audio_accessibility_volume">audio accessibility volume</string>
+    <string name="app_ops_auto_start">start at power up</string>
+    <string name="app_ops_bind_accessibility_service">bind accessibility service</string>
+    <string name="app_ops_bluetooth_scan">bluetooth scan</string>
+    <string name="app_ops_change_wallpaper">change the wallpaper</string>
+    <string name="app_ops_delete_call_log">delete your call log</string>
+    <string name="app_ops_delete_contacts">delete your contacts</string>
+    <string name="app_ops_delete_mms">delete your MMS messages</string>
+    <string name="app_ops_delete_sms">delete your SMS messages</string>
+    <string name="app_ops_draw_on_top">draw windows on top</string>
+    <string name="app_ops_get_accounts">get device accounts</string>
+    <string name="app_ops_get_usage_stats">get app usage stats</string>
+    <string name="app_ops_accept_handover">handover of a call from another app</string>
+    <string name="app_ops_install_packages">install packages</string>
+    <string name="app_ops_keep_device_awake">keep your device awake</string>
+    <string name="app_ops_manage_ipsec_tunnels">manage ipsec tunnels</string>
+    <string name="app_ops_make_phone_call">make a phone call</string>
+    <string name="app_ops_mock_location">mock your location</string>
+    <string name="app_ops_modify_calendar">update your calendar</string>
+    <string name="app_ops_modify_call_log">update the call log</string>
+    <string name="app_ops_modify_clipboard">modify the clipboard</string>
+    <string name="app_ops_modify_contacts">update your contacts</string>
+    <string name="app_ops_modify_settings">update system settings</string>
+    <string name="app_ops_mute_unmute_microphone">mute/unmute the microphone</string>
+    <string name="app_ops_phone_calls">answer phone calls</string>
+    <string name="app_ops_picture_in_picture">use picture in picture</string>
+    <string name="app_ops_play_audio">play audio</string>
+    <string name="app_ops_post_notification">post a notification</string>
+    <string name="app_ops_project_media">project media</string>
+    <string name="app_ops_read_calendar">read your calendar</string>
+    <string name="app_ops_read_call_log">read the call log</string>
+    <string name="app_ops_read_cell_broadcasts">read cell broadcasts</string>
+    <string name="app_ops_read_clipboard">read the clipboard</string>
+    <string name="app_ops_read_contacts">read your contacts</string>
+    <string name="app_ops_read_external_storage">read external storage</string>
+    <string name="app_ops_read_mms">read your MMS messages</string>
+    <string name="app_ops_read_phone_numbers">read phone numbers</string>
+    <string name="app_ops_read_phone_state">access phone state</string>
+    <string name="app_ops_read_sms">read your SMS messages</string>
+    <string name="app_ops_receive_sms">receive an SMS message</string>
+    <string name="app_ops_receive_emergency_broadcast">receive an emergency broadcast message</string>
+    <string name="app_ops_record_audio">record audio</string>
+    <string name="app_ops_request_delete_packages">request delete packages</string>
+    <string name="app_ops_run_in_background">run in background</string>
+    <string name="app_ops_run_any_in_background">run any in background</string>
+    <string name="app_ops_scan_wifi">scan Wi-Fi networks</string>
+    <string name="app_ops_send_mms">send an MMS message</string>
+    <string name="app_ops_send_sms">send an SMS message</string>
+    <string name="app_ops_start_at_bootup">start at power up</string>
+    <string name="app_ops_start_foreground">start foreground</string>
+    <string name="app_ops_su">get root access</string>
+    <string name="app_ops_toast_window">display toast messages</string>
+    <string name="app_ops_toggle_bluetooth">toggle Bluetooth</string>
+    <string name="app_ops_toggle_mobile_data">toggle cellular data</string>
+    <string name="app_ops_toggle_nfc">toggle NFC</string>
+    <string name="app_ops_toggle_wifi">toggle Wi-Fi</string>
+    <string name="app_ops_turn_on_screen">turn the screen on</string>
+    <string name="app_ops_use_alarm_volume">control alarm volume</string>
+    <string name="app_ops_use_audio_focus">control the audio focus</string>
+    <string name="app_ops_use_bluetooth_volume">control the Bluetooth volume</string>
+    <string name="app_ops_use_body_sensors">use body sensors</string>
+    <string name="app_ops_use_fingerprint">use fingerprint</string>
+    <string name="app_ops_use_master_volume">control the master volume</string>
+    <string name="app_ops_use_media_buttons">use the media buttons</string>
+    <string name="app_ops_use_media_volume">control the media volume</string>
+    <string name="app_ops_use_notification_volume">control the notification volume</string>
+    <string name="app_ops_use_ring_volume">control the ringtone volume</string>
+    <string name="app_ops_use_vibrate">use haptic feedback</string>
+    <string name="app_ops_use_voice_volume">control the voice call volume</string>
+    <string name="app_ops_wifi_change">change Wi-Fi state</string>
+    <string name="app_ops_write_external_storage">write external storage</string>
+    <string name="app_ops_write_mms">write an MMS message</string>
+    <string name="app_ops_write_sms">write an SMS message</string>
+
+    <!-- Privacy Guard -->
+    <string name="permlab_changePrivacyGuardState">enable or disable Privacy Guard</string>
+    <string name="permdesc_changePrivacyGuardState">Allows the app to change whether another app runs with Privacy Guard. When an app is running with Privacy Guard, it will not have access to personal data such as contacts, call logs, or messages.</string>
+    <string name="privacy_guard_notification">Privacy Guard active</string>
+    <string name="privacy_guard_notification_detail"><xliff:g id="app">%1$s</xliff:g> will not be able to access personal data</string>
+    <string name="privacy_guard_dialog_title">Privacy Guard</string>
+    <string name="privacy_guard_dialog_summary"><xliff:g id="app">%1$s</xliff:g> would like to <xliff:g id="op">%2$s</xliff:g>.</string>
+
+    <!-- Text of the checkbox for the permission confirmation dialog to remember the user's choice. [CHAR LIMIT=40] -->
+    <string name="permission_remember_choice">Remember my choice</string>
+
+</resources>
diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 166418c0cb5..b131a2504f0 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -56,6 +56,7 @@
         <item><xliff:g id="id">@string/status_bar_mobile</xliff:g></item>
         <item><xliff:g id="id">@string/status_bar_airplane</xliff:g></item>
         <item><xliff:g id="id">@string/status_bar_battery</xliff:g></item>
+        <item><xliff:g id="id">@string/status_bar_su</xliff:g></item>
     </string-array>
 
     <string translatable="false" name="status_bar_rotate">rotate</string>
@@ -88,6 +89,7 @@
     <string translatable="false" name="status_bar_vpn">vpn</string>
     <string translatable="false" name="status_bar_ethernet">ethernet</string>
     <string translatable="false" name="status_bar_airplane">airplane</string>
+    <string translatable="false" name="status_bar_su">su</string>
 
     <!-- Flag indicating whether the surface flinger has limited
          alpha compositing functionality in hardware.  If set, the window
diff --git a/core/res/res/values/lineage_arrays.xml b/core/res/res/values/lineage_arrays.xml
new file mode 100644
index 00000000000..58567d1c8bd
--- /dev/null
+++ b/core/res/res/values/lineage_arrays.xml
@@ -0,0 +1,189 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+     Copyright (C) 2012-2015 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+
+    <!-- Do not translate. App ops request strings -->
+    <string-array name="app_ops_labels" translatable="false">
+        <!-- OP_COARSE_LOCATION -->
+        <item>@string/app_ops_access_location</item>
+        <!-- OP_FINE_LOCATION -->
+        <item>@string/app_ops_access_location</item>
+        <!-- OP_GPS -->
+        <item>@string/app_ops_access_location</item>
+        <!-- OP_VIBRATE -->
+        <item>@string/app_ops_use_vibrate</item>
+        <!-- OP_READ_CONTACTS -->
+        <item>@string/app_ops_read_contacts</item>
+        <!-- OP_WRITE_CONTACTS -->
+        <item>@string/app_ops_modify_contacts</item>
+        <!-- OP_READ_CALL_LOG -->
+        <item>@string/app_ops_read_call_log</item>
+        <!-- OP_WRITE_CALL_LOG -->
+        <item>@string/app_ops_modify_call_log</item>
+        <!-- OP_READ_CALENDAR -->
+        <item>@string/app_ops_read_calendar</item>
+        <!-- OP_WRITE_CALENDAR -->
+        <item>@string/app_ops_modify_calendar</item>
+        <!-- OP_WIFI_SCAN -->
+        <item>@string/app_ops_scan_wifi</item>
+        <!-- OP_POST_NOTIFICATION -->
+        <item>@string/app_ops_post_notification</item>
+        <!-- OP_NEIGHBORING_CELLS -->
+        <item>@string/app_ops_access_location</item>
+        <!-- OP_CALL_PHONE -->
+        <item>@string/app_ops_make_phone_call</item>
+        <!-- OP_READ_SMS -->
+        <item>@string/app_ops_read_sms</item>
+        <!-- OP_WRITE_SMS -->
+        <item>@string/app_ops_write_sms</item>
+        '<!-- OP_RECEIVE_SMS -->
+        <item>@string/app_ops_receive_sms</item>
+        <!-- OPSTR_RECEIVE_EMERGENCY_BROADCAST -->
+        <item>@string/app_ops_receive_emergency_broadcast</item>
+        <!-- OP_RECEIVE_MMS -->
+        <item>@string/app_ops_receive_sms</item>
+        <!-- OP_RECEIVE_WAP_PUSH -->
+        <item>@string/app_ops_receive_sms</item>
+        <!-- OP_SEND_SMS -->
+        <item>@string/app_ops_send_sms</item>
+        <!-- OP_READ_ICC_SMS -->
+        <item>@string/app_ops_read_sms</item>
+        <!-- OP_WRITE_ICC_SMS -->
+        <item>@string/app_ops_write_sms</item>
+        <!-- OP_WRITE_SETTINGS -->
+        <item>@string/app_ops_modify_settings</item>
+        <!-- OP_SYSTEM_ALERT_WINDOW -->
+        <item>@string/app_ops_draw_on_top</item>
+        <!-- OP_ACCESS_NOTIFICATIONS -->
+        <item>@string/app_ops_access_notifications</item>
+        <!-- OP_CAMERA -->
+        <item>@string/app_ops_access_camera</item>
+        <!-- OP_RECORD_AUDIO -->
+        <item>@string/app_ops_record_audio</item>
+        <!-- OP_PLAY_AUDIO -->
+        <item>@string/app_ops_play_audio</item>
+        <!-- OP_READ_CLIPBOARD -->
+        <item>@string/app_ops_read_clipboard</item>
+        <!-- OP_WRITE_CLIPBOARD -->
+        <item>@string/app_ops_modify_clipboard</item>
+        <!-- OP_TAKE_MEDIA_BUTTONS -->
+        <item>@string/app_ops_use_media_buttons</item>
+        <!-- OP_TAKE_AUDIO_FOCUS -->
+        <item>@string/app_ops_use_audio_focus</item>
+        <!-- OP_AUDIO_MASTER_VOLUME -->
+        <item>@string/app_ops_use_master_volume</item>
+        <!-- OP_AUDIO_VOICE_VOLUME -->
+        <item>@string/app_ops_use_voice_volume</item>
+        <!-- OP_AUDIO_RING_VOLUME -->
+        <item>@string/app_ops_use_ring_volume</item>
+        <!-- OP_AUDIO_MEDIA_VOLUME -->
+        <item>@string/app_ops_use_media_volume</item>
+        <!-- OP_AUDIO_ALARM_VOLUME -->
+        <item>@string/app_ops_use_alarm_volume</item>
+        <!-- OP_AUDIO_NOTIFICATION_VOLUME -->
+        <item>@string/app_ops_use_notification_volume</item>
+        <!-- OP_AUDIO_BLUETOOTH_VOLUME -->
+        <item>@string/app_ops_use_bluetooth_volume</item>
+        <!-- OP_WAKE_LOCK -->
+        <item>@string/app_ops_keep_device_awake</item>
+        <!-- OP_MONITOR_LOCATION -->
+        <item>@string/app_ops_access_location</item>
+        <!-- OP_MONITOR_HIGH_POWER_LOCATION -->
+        <item>@string/app_ops_access_location</item>
+        <!-- OP_GET_USAGE_STATS -->
+        <item>@string/app_ops_get_usage_stats</item>
+        <!-- OP_MUTE_MICROPHONE -->
+        <item>@string/app_ops_mute_unmute_microphone</item>
+        <!-- OP_TOAST_WINDOW -->
+        <item>@string/app_ops_toast_window</item>
+        <!-- OP_PROJECT_MEDIA -->
+        <item>@string/app_ops_project_media</item>
+        <!-- OP_ACTIVATE_VPN -->
+        <item>@string/app_ops_activate_vpn</item>
+        <!-- OP_WRITE_WALLPAPER -->
+        <item>@string/app_ops_change_wallpaper</item>
+        <!-- OP_ASSIST_STRUCTURE -->
+        <item>@string/app_ops_assist_structure</item>
+        <!-- OP_ASSIST_SCREENSHOT -->
+        <item>@string/app_ops_assist_screenshot</item>
+        <!-- OP_READ_PHONE_STATE -->
+        <item>@string/app_ops_read_phone_state</item>
+        <!-- OP_ADD_VOICEMAIL -->
+        <item>@string/app_ops_add_voicemail</item>
+        <!-- OP_USE_SIP -->
+        <item>@string/app_ops_make_phone_call</item>
+        <!-- OP_PROCESS_OUTGOING_CALLS -->
+        <item>@string/app_ops_make_phone_call</item>
+        <!-- OP_USE_FINGERPRINT -->
+        <item>@string/app_ops_use_fingerprint</item>
+        <!-- OP_BODY_SENSORS -->
+        <item>@string/app_ops_use_body_sensors</item>
+        <!-- OP_READ_CELL_BROADCASTS -->
+        <item>@string/app_ops_read_cell_broadcasts</item>
+        <!-- OP_MOCK_LOCATION -->
+        <item>@string/app_ops_mock_location</item>
+        <!-- OP_READ_EXTERNAL_STORAGE -->
+        <item>@string/app_ops_read_external_storage</item>
+        <!-- OP_WRITE_EXTERNAL_STORAGE -->
+        <item>@string/app_ops_write_external_storage</item>
+        <!-- OP_TURN_SCREEN_ON -->
+        <item>@string/app_ops_turn_on_screen</item>
+        <!-- OP_GET_ACCOUNTS -->
+        <item>@string/app_ops_get_accounts</item>
+        <!-- OP_RUN_IN_BACKGROUND -->
+        <item>@string/app_ops_run_in_background</item>
+        <!-- OP_AUDIO_ACCESSIBILITY_VOLUME -->
+        <item>@string/app_ops_audio_accessibility_volume</item>
+        <!-- OP_READ_PHONE_NUMBERS -->
+        <item>@string/app_ops_read_phone_numbers</item>
+        <!-- OP_REQUEST_INSTALL_PACKAGES -->
+        <item>@string/app_ops_install_packages</item>
+        <!-- OP_PICTURE_IN_PICTURE -->
+        <item>@string/app_ops_picture_in_picture</item>
+        <!-- OP_INSTANT_APP_START_FOREGROUND -->
+        <item>@string/app_ops_app_start_foreground</item>
+        <!-- OP_ANSWER_PHONE_CALLS -->
+        <item>@string/app_ops_phone_calls</item>
+        <!-- OP_RUN_ANY_IN_BACKGROUND -->
+        <item>@string/app_ops_run_any_in_background</item>
+        <!-- OP_CHANGE_WIFI_STATE -->
+        <item>@string/app_ops_wifi_change</item>
+        <!-- OP_REQUEST_DELETE_PACKAGES -->
+        <item>@string/app_ops_request_delete_packages</item>
+        <!-- OP_BIND_ACCESSIBILITY_SERVICE -->
+        <item>@string/app_ops_bind_accessibility_service</item>
+        <!-- OP_ACCEPT_HANDOVER -->
+        <item>@string/app_ops_accept_handover</item>
+        <!-- OP_MANAGE_IPSEC_TUNNELS -->
+        <item>@string/app_ops_manage_ipsec_tunnels</item>
+        <!-- OP_START_FOREGROUND -->
+        <item>@string/app_ops_start_foreground</item>
+        <!-- OP_BLUETOOTH_SCAN -->
+        <item>@string/app_ops_bluetooth_scan</item>
+        <!-- OP_BLUETOOTH_CHANGE -->
+        <item>@string/app_ops_toggle_bluetooth</item>
+        <!-- OP_BOOT_COMPLETED -->
+        <item>@string/app_ops_start_at_bootup</item>
+        <!-- OP_NFC_CHANGE -->
+        <item>@string/app_ops_toggle_nfc</item>
+        <!-- OP_DATA_CONNECT_CHANGE -->
+        <item>@string/app_ops_toggle_mobile_data</item>
+        <!-- OP_SU -->
+        <item>@string/app_ops_su</item>
+    </string-array>
+
+</resources>
diff --git a/core/res/res/values/lineage_symbols.xml b/core/res/res/values/lineage_symbols.xml
index bd1aee330be..6ad2aae2b46 100644
--- a/core/res/res/values/lineage_symbols.xml
+++ b/core/res/res/values/lineage_symbols.xml
@@ -31,6 +31,20 @@
     <java-symbol type="array" name="config_disabledComponents" />
     <java-symbol type="array" name="config_forceEnabledComponents" />
 
+    <!-- Privacy Guard -->
+    <java-symbol type="drawable" name="stat_notify_privacy_guard" />
+    <java-symbol type="string" name="privacy_guard_notification" />
+    <java-symbol type="string" name="privacy_guard_notification_detail" />
+    <java-symbol type="string" name="privacy_guard_dialog_title" />
+    <java-symbol type="string" name="privacy_guard_dialog_summary" />
+    <java-symbol type="id" name="permission_text" />
+    <java-symbol type="id" name="permission_remember_choice_checkbox" />
+    <java-symbol type="string" name="allow" />
+    <java-symbol type="string" name="deny" />
+    <java-symbol type="layout" name="permission_confirmation_dialog" />
+    <java-symbol type="array" name="app_ops_labels" />
+    <java-symbol type="string" name="status_bar_su" />
+
     <!-- Whether notify fingerprint client of successful cancelled authentication -->
     <java-symbol type="bool" name="config_notifyClientOnFingerprintCancelSuccess" />
 
diff --git a/packages/SystemUI/res/drawable/stat_sys_su.xml b/packages/SystemUI/res/drawable/stat_sys_su.xml
new file mode 100644
index 00000000000..8e3e65f5730
--- /dev/null
+++ b/packages/SystemUI/res/drawable/stat_sys_su.xml
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="utf-8"?>
+<inset xmlns:android="http://schemas.android.com/apk/res/android"
+    android:insetLeft="2.5dp"
+    android:insetRight="2.5dp">
+    <vector
+        android:width="17dp"
+        android:height="17dp"
+        android:viewportWidth="19.3"
+        android:viewportHeight="24.0">
+        <path
+            android:fillColor="#FFFFFFFF"
+            android:pathData="M12.49,15.934h-2.373L9.24,21H6.966l0.89-5.066H5.051v-2.089h3.163l0.63-3.584H5.977V8.148h3.238 l0.902-5.141h2.261l-0.902,5.141h2.373l0.914-5.141h2.261l-0.902,5.141h2.719v2.113h-3.089l-0.63,3.584h2.78v2.089h-3.139L13.874,21 H11.6L12.49,15.934Z M10.488,13.845h2.36l0.63-3.584h-2.373L10.488,13.845z" />
+    </vector>
+</inset>
diff --git a/packages/SystemUI/src/com/android/systemui/Dependency.java b/packages/SystemUI/src/com/android/systemui/Dependency.java
index 9c9f0218d74..c4ac1aae421 100644
--- a/packages/SystemUI/src/com/android/systemui/Dependency.java
+++ b/packages/SystemUI/src/com/android/systemui/Dependency.java
@@ -89,6 +89,8 @@ import com.android.systemui.statusbar.policy.RotationLockController;
 import com.android.systemui.statusbar.policy.RotationLockControllerImpl;
 import com.android.systemui.statusbar.policy.SecurityController;
 import com.android.systemui.statusbar.policy.SecurityControllerImpl;
+import com.android.systemui.statusbar.policy.SuController;
+import com.android.systemui.statusbar.policy.SuControllerImpl;
 import com.android.systemui.statusbar.policy.UserInfoController;
 import com.android.systemui.statusbar.policy.UserInfoControllerImpl;
 import com.android.systemui.statusbar.policy.UserSwitcherController;
@@ -328,6 +330,8 @@ public class Dependency extends SystemUI {
         mProviders.put(IStatusBarService.class, () -> IStatusBarService.Stub.asInterface(
                 ServiceManager.getService(Context.STATUS_BAR_SERVICE)));
 
+        mProviders.put(SuController.class,() -> new SuControllerImpl(mContext));
+
         // Put all dependencies above here so the factory can override them if it wants.
         SystemUIFactory.getInstance().injectDependencies(mProviders, mContext);
 
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarPolicy.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarPolicy.java
index cd28b934caa..bfe394023ee 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarPolicy.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarPolicy.java
@@ -86,6 +86,7 @@ import com.android.systemui.statusbar.policy.LocationController.LocationChangeCa
 import com.android.systemui.statusbar.policy.NextAlarmController;
 import com.android.systemui.statusbar.policy.RotationLockController;
 import com.android.systemui.statusbar.policy.RotationLockController.RotationLockControllerCallback;
+import com.android.systemui.statusbar.policy.SuController;
 import com.android.systemui.statusbar.policy.UserInfoController;
 import com.android.systemui.statusbar.policy.ZenModeController;
 import com.android.systemui.util.NotificationChannels;
@@ -119,6 +120,7 @@ public class PhoneStatusBarPolicy implements Callback, Callbacks,
     private final String mSlotHeadset;
     private final String mSlotDataSaver;
     private final String mSlotLocation;
+    private final String mSlotSu;
 
     private final Context mContext;
     private final Handler mHandler = new Handler();
@@ -137,6 +139,7 @@ public class PhoneStatusBarPolicy implements Callback, Callbacks,
     private final LocationController mLocationController;
     private final ArraySet<Pair<String, Integer>> mCurrentNotifs = new ArraySet<>();
     private final UiOffloadThread mUiOffloadThread = Dependency.get(UiOffloadThread.class);
+    private final SuController mSuController;
 
     // Assume it's all good unless we hear otherwise.  We don't always seem
     // to get broadcasts that it *is* there.
@@ -168,6 +171,7 @@ public class PhoneStatusBarPolicy implements Callback, Callbacks,
         mProvisionedController = Dependency.get(DeviceProvisionedController.class);
         mKeyguardMonitor = Dependency.get(KeyguardMonitor.class);
         mLocationController = Dependency.get(LocationController.class);
+        mSuController = Dependency.get(SuController.class);
 
         mSlotCast = context.getString(com.android.internal.R.string.status_bar_cast);
         mSlotHotspot = context.getString(com.android.internal.R.string.status_bar_hotspot);
@@ -182,6 +186,7 @@ public class PhoneStatusBarPolicy implements Callback, Callbacks,
         mSlotHeadset = context.getString(com.android.internal.R.string.status_bar_headset);
         mSlotDataSaver = context.getString(com.android.internal.R.string.status_bar_data_saver);
         mSlotLocation = context.getString(com.android.internal.R.string.status_bar_location);
+        mSlotSu = context.getString(com.android.internal.R.string.status_bar_su);
 
         // listen for broadcasts
         IntentFilter filter = new IntentFilter();
@@ -231,6 +236,10 @@ public class PhoneStatusBarPolicy implements Callback, Callbacks,
                 mContext.getString(R.string.accessibility_status_bar_hotspot));
         mIconController.setIconVisibility(mSlotHotspot, mHotspot.isHotspotEnabled());
 
+        // su
+        mIconController.setIcon(mSlotSu, R.drawable.stat_sys_su, null);
+        mIconController.setIconVisibility(mSlotSu, mSuController.getSessionCount() > 0);
+
         // managed profile
         mIconController.setIcon(mSlotManagedProfile, R.drawable.stat_sys_managed_profile_status,
                 mContext.getString(R.string.accessibility_managed_profile));
@@ -247,6 +256,7 @@ public class PhoneStatusBarPolicy implements Callback, Callbacks,
         mZenController.addCallback(this);
         mCast.addCallback(mCastCallback);
         mHotspot.addCallback(mHotspotCallback);
+        mSuController.addCallback(mSuCallback);
         mNextAlarmController.addCallback(mNextAlarmCallback);
         mDataSaver.addCallback(this);
         mKeyguardMonitor.addCallback(this);
@@ -275,6 +285,7 @@ public class PhoneStatusBarPolicy implements Callback, Callbacks,
         mZenController.removeCallback(this);
         mCast.removeCallback(mCastCallback);
         mHotspot.removeCallback(mHotspotCallback);
+        mSuController.removeCallback(mSuCallback);
         mNextAlarmController.removeCallback(mNextAlarmCallback);
         mDataSaver.removeCallback(this);
         mKeyguardMonitor.removeCallback(this);
@@ -723,6 +734,14 @@ public class PhoneStatusBarPolicy implements Callback, Callbacks,
         }
     };
 
+
+    private final SuController.Callback mSuCallback = new SuController.Callback() {
+        @Override
+        public void onSuSessionsChanged(int sessionCount) {
+            mIconController.setIconVisibility(mSlotSu, sessionCount > 0);
+        }
+    };
+
     private final CastController.Callback mCastCallback = new CastController.Callback() {
         @Override
         public void onCastDevicesChanged() {
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/policy/SuController.java b/packages/SystemUI/src/com/android/systemui/statusbar/policy/SuController.java
new file mode 100644
index 00000000000..d3575c57387
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/policy/SuController.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2014 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.systemui.statusbar.policy;
+
+public interface SuController {
+    void addCallback(Callback callback);
+    void removeCallback(Callback callback);
+    int getSessionCount();
+
+    public interface Callback {
+        void onSuSessionsChanged(int sessionCount);
+    }
+}
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/policy/SuControllerImpl.java b/packages/SystemUI/src/com/android/systemui/statusbar/policy/SuControllerImpl.java
new file mode 100644
index 00000000000..d2661e5b66f
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/policy/SuControllerImpl.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2014 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.systemui.statusbar.policy;
+
+import android.app.AppOpsManager;
+import android.content.Context;
+import android.os.Handler;
+import android.util.Log;
+
+import com.android.systemui.R;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * A controller to manage changes to superuser-related states and update the views accordingly.
+ */
+public class SuControllerImpl implements SuController, AppOpsManager.OnOpActiveChangedListener {
+    private static final String TAG = "SuControllerImpl";
+    private static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);
+
+    private static final int[] SU_OPS = new int[] { AppOpsManager.OP_SU };
+
+    private ArrayList<Callback> mCallbacks = new ArrayList<Callback>();
+
+    private AppOpsManager mAppOpsManager;
+    private Set<String> mActivePackages = new HashSet<>();
+    private Handler mHandler = new Handler();
+
+    public SuControllerImpl(Context context) {
+        mAppOpsManager = context.getSystemService(AppOpsManager.class);
+    }
+
+    @Override
+    public void addCallback(Callback callback) {
+        synchronized (mCallbacks) {
+            if (mCallbacks.isEmpty()) {
+                mAppOpsManager.startWatchingActive(SU_OPS, this);
+
+                synchronized (mActivePackages) {
+                    mActivePackages.clear();
+                    initActivePackagesLocked();
+                }
+            }
+            mCallbacks.add(callback);
+            callback.onSuSessionsChanged(mActivePackages.size());
+        }
+    }
+
+    @Override
+    public void removeCallback(Callback callback) {
+        synchronized (mCallbacks) {
+            mCallbacks.remove(callback);
+            if (mCallbacks.isEmpty()) {
+                mAppOpsManager.stopWatchingActive(this);
+            }
+        }
+    }
+
+    @Override
+    public int getSessionCount() {
+        synchronized (mActivePackages) {
+            return mActivePackages.size();
+        }
+    }
+
+    private void initActivePackagesLocked() {
+
+        List<AppOpsManager.PackageOps> packages = mAppOpsManager.getPackagesForOps(SU_OPS);
+        if (packages != null) {
+            for (AppOpsManager.PackageOps ops : packages) {
+                if (mAppOpsManager.isOperationActive(AppOpsManager.OP_SU,
+                        ops.getUid(), ops.getPackageName())) {
+                    mActivePackages.add(ops.getPackageName());
+                }
+            }
+        }
+    }
+
+    private void fireCallbacks(int sessionCount) {
+        synchronized (mCallbacks) {
+            for (Callback callback : mCallbacks) {
+                callback.onSuSessionsChanged(sessionCount);
+            }
+        }
+    }
+
+    @Override
+    public void onOpActiveChanged(int op, int uid, String packageName, boolean active) {
+        if (DEBUG) Log.d(TAG, "SU active changed for " + packageName + " to " + active);
+        int oldCount, newCount;
+        synchronized (mActivePackages) {
+            oldCount = mActivePackages.size();
+            if (active) {
+                mActivePackages.add(packageName);
+            } else {
+                mActivePackages.remove(packageName);
+            }
+            newCount = mActivePackages.size();
+        }
+        if (oldCount != newCount) {
+            mHandler.post(() -> fireCallbacks(newCount));
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/AppOpsService.java b/services/core/java/com/android/server/AppOpsService.java
index 786d757557d..20d0e20a270 100644
--- a/services/core/java/com/android/server/AppOpsService.java
+++ b/services/core/java/com/android/server/AppOpsService.java
@@ -1,4 +1,7 @@
 /*
+ * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ *
  * Copyright (C) 2012 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -22,8 +25,12 @@ import android.app.ActivityThread;
 import android.app.AppGlobals;
 import android.app.AppOpsManager;
 import android.app.AppOpsManagerInternal;
+import android.app.Dialog;
+import android.content.BroadcastReceiver;
 import android.content.ContentResolver;
 import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.IPackageManager;
 import android.content.pm.PackageManager;
@@ -37,6 +44,7 @@ import android.os.Binder;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.IBinder;
+import android.os.Looper;
 import android.os.Process;
 import android.os.RemoteException;
 import android.os.ResultReceiver;
@@ -70,6 +78,8 @@ import com.android.internal.util.FastXmlSerializer;
 import com.android.internal.util.Preconditions;
 import com.android.internal.util.XmlUtils;
 import com.android.internal.util.function.pooled.PooledLambda;
+import com.android.server.am.ActivityManagerService;
+import com.android.server.PermissionDialogReqQueue.PermissionDialogReq;
 
 import libcore.util.EmptyArray;
 
@@ -84,6 +94,7 @@ import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.PrintWriter;
+import java.lang.Math;
 import java.nio.charset.StandardCharsets;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
@@ -170,9 +181,19 @@ public class AppOpsService extends IAppOpsService.Stub {
             "rc",       // UID_STATE_CACHED
     };
 
+    // Rate limiting thresholds for ask operations
+    public static final int RATE_LIMIT_OP_COUNT = 3;
+    public static final int RATE_LIMIT_OPS_TOTAL_PKG_COUNT = 4;
+    public static final int RATE_LIMIT_OP_DELAY_CEILING = 10;
+
     Context mContext;
     final AtomicFile mFile;
     final Handler mHandler;
+    final Looper mLooper;
+
+    private boolean mIsInteractive = true;
+
+    private final ActivityManagerService mActivityManagerService;
 
     private final AppOpsManagerInternalImpl mAppOpsManagerInternal
             = new AppOpsManagerInternalImpl();
@@ -315,6 +336,9 @@ public class AppOpsService extends IAppOpsService.Stub {
         public SparseBooleanArray foregroundOps;
         public boolean hasForegroundWatchers;
 
+        public int pendingAskOp;
+        public boolean receivedPendingAskResponse;
+
         public UidState(int uid) {
             this.uid = uid;
         }
@@ -387,11 +411,13 @@ public class AppOpsService extends IAppOpsService.Stub {
         final String packageName;
         final UidState uidState;
         final boolean isPrivileged;
+        long startRealtime;
 
         Ops(String _packageName, UidState _uidState, boolean _isPrivileged) {
             packageName = _packageName;
             uidState = _uidState;
             isPrivileged = _isPrivileged;
+            startRealtime = 0;
         }
     }
 
@@ -408,6 +434,13 @@ public class AppOpsService extends IAppOpsService.Stub {
         long rejectTime[] = new long[_NUM_UID_STATE];
         int startNesting;
         long startRealtime;
+        int noteOpCount;
+        int startOpCount;
+        PermissionDialogReqQueue dialogReqQueue;
+        final ArrayList<IBinder> clientTokens;
+        public int allowedCount;
+        public int ignoredCount;
+        int delayedCount;
 
         Op(UidState _uidState, String _packageName, int _op) {
             uidState = _uidState;
@@ -415,6 +448,18 @@ public class AppOpsService extends IAppOpsService.Stub {
             packageName = _packageName;
             op = _op;
             mode = AppOpsManager.opToDefaultMode(op);
+            dialogReqQueue = new PermissionDialogReqQueue();
+            clientTokens = new ArrayList<IBinder>();
+        }
+
+        Op(UidState _uidState, String _packageName, int _op, int _mode) {
+            uidState = _uidState;
+            uid = _uidState.uid;
+            packageName = _packageName;
+            op = _op;
+            mode = _mode;
+            dialogReqQueue = new PermissionDialogReqQueue();
+            clientTokens = new ArrayList<IBinder>();
         }
 
         boolean hasAnyTime() {
@@ -573,11 +618,13 @@ public class AppOpsService extends IAppOpsService.Stub {
         }
     }
 
-    public AppOpsService(File storagePath, Handler handler) {
+    public AppOpsService(File storagePath, Handler handler, ActivityManagerService service) {
         LockGuard.installLock(this, LockGuard.INDEX_APP_OPS);
         mFile = new AtomicFile(storagePath, "appops");
         mHandler = handler;
         mConstants = new Constants(mHandler);
+        mLooper = Looper.myLooper();
+        mActivityManagerService = service;
         readState();
     }
 
@@ -590,6 +637,11 @@ public class AppOpsService extends IAppOpsService.Stub {
     public void systemReady() {
         mConstants.startMonitoring(mContext.getContentResolver());
 
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(Intent.ACTION_SCREEN_ON);
+        filter.addAction(Intent.ACTION_SCREEN_OFF);
+        mContext.registerReceiver(mIntentReceiver, filter);
+
         synchronized (this) {
             boolean changed = false;
             for (int i = mUidStates.size() - 1; i >= 0; i--) {
@@ -663,15 +715,48 @@ public class AppOpsService extends IAppOpsService.Stub {
                         if (Process.isIsolated(uid)) {
                             return Zygote.MOUNT_EXTERNAL_NONE;
                         }
-                        if (noteOperation(AppOpsManager.OP_READ_EXTERNAL_STORAGE, uid,
-                                packageName) != AppOpsManager.MODE_ALLOWED) {
+                        synchronized (AppOpsService.this) {
+                            UidState uidState = getUidStateLocked(uid, false);
+                            if (uidState != null && uidState.receivedPendingAskResponse) {
+                                int op = uidState.pendingAskOp;
+                                boolean write = op == AppOpsManager.OP_WRITE_EXTERNAL_STORAGE;
+
+                                if (DEBUG) Slog.d(TAG, "getMountMode: allowing "
+                                        + (write ? "write" : "read") + " for uid "
+                                        + uid + " package " + packageName
+                                        + " due to previous response");
+
+                                uidState.pendingAskOp = 0;
+                                uidState.receivedPendingAskResponse = false;
+                                return write
+                                        ? Zygote.MOUNT_EXTERNAL_WRITE : Zygote.MOUNT_EXTERNAL_READ;
+                            }
+                        }
+                        int readResult = check(AppOpsManager.OP_READ_EXTERNAL_STORAGE,
+                                uid, packageName);
+                        if (readResult == AppOpsManager.MODE_IGNORED) {
                             return Zygote.MOUNT_EXTERNAL_NONE;
                         }
-                        if (noteOperation(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE, uid,
-                                packageName) != AppOpsManager.MODE_ALLOWED) {
+                        int writeResult = check(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,
+                                uid, packageName);
+                        if (DEBUG) Slog.d(TAG, "getMountMode: read result " + readResult
+                                + " write result " + writeResult + " for uid " + uid
+                                + " package " + packageName);
+
+                        if (writeResult == AppOpsManager.MODE_ALLOWED) {
+                            return Zygote.MOUNT_EXTERNAL_WRITE;
+                        } else if (writeResult == AppOpsManager.MODE_ASK) {
+                            scheduleAskOperation(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,
+                                    uid, packageName);
+                            return readResult == AppOpsManager.MODE_ALLOWED
+                                    ? Zygote.MOUNT_EXTERNAL_READ : Zygote.MOUNT_EXTERNAL_NONE;
+                        } else if (readResult == AppOpsManager.MODE_ALLOWED) {
                             return Zygote.MOUNT_EXTERNAL_READ;
+                        } else if (readResult == AppOpsManager.MODE_ASK) {
+                            scheduleAskOperation(AppOpsManager.OP_READ_EXTERNAL_STORAGE,
+                                    uid, packageName);
                         }
-                        return Zygote.MOUNT_EXTERNAL_WRITE;
+                        return Zygote.MOUNT_EXTERNAL_NONE;
                     }
 
                     @Override
@@ -680,9 +765,85 @@ public class AppOpsService extends IAppOpsService.Stub {
                         return mountMode == Zygote.MOUNT_EXTERNAL_READ
                                 || mountMode == Zygote.MOUNT_EXTERNAL_WRITE;
                     }
+
+                    private int check(int code, int uid, String packageName) {
+                        verifyIncomingUid(uid);
+                        verifyIncomingOp(code);
+                        String resolvedPackageName = resolvePackageName(uid, packageName);
+                        if (resolvedPackageName == null) {
+                            return AppOpsManager.MODE_IGNORED;
+                        }
+                        return noteOperationUnchecked(code, uid,
+                                resolvedPackageName, 0, null, true);
+                    }
+
+                    private void scheduleAskOperation(int code, int uid, String packageName) {
+                        synchronized (AppOpsService.this) {
+                            UidState uidState = getUidStateLocked(uid, true);
+                            uidState.pendingAskOp = code;
+                            uidState.receivedPendingAskResponse = false;
+                            // Schedule noteOperation which will trigger the dialog
+                            // NOTE: needs to happen in background thread, as otherwise main thread
+                            //       will block due to scheduling the dialog and waiting for it in
+                            //       the same thread
+                            AsyncTask<Void, Void, Void> task = new AsyncTask<Void, Void, Void>() {
+                                @Override protected Void doInBackground(Void... params) {
+                                    noteOperation(code, uid, packageName);
+                                    return null;
+                                }
+                            };
+                            task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void[])null);
+                        }
+                    }
                 });
     }
 
+    private BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            if (action.equals(Intent.ACTION_SCREEN_ON)) {
+                synchronized (AppOpsService.this) {
+                    mIsInteractive = true;
+                }
+            } else if (action.equals(Intent.ACTION_SCREEN_OFF)) {
+                synchronized (AppOpsService.this) {
+                    for (int i = mUidStates.size() - 1; i >= 0; i--) {
+                        UidState uidState = mUidStates.valueAt(i);
+
+                        ArrayMap<String, Ops> packages = uidState.pkgOps;
+                        if (packages == null) {
+                            continue;
+                        }
+
+                        Iterator<Map.Entry<String, Ops>> it = packages.entrySet().iterator();
+                        while (it.hasNext()) {
+                            Map.Entry<String, Ops> ent = it.next();
+                            Ops pkgOps = ent.getValue();
+                            for (int j = pkgOps.size() - 1; j >= 0; j--) {
+                                Op curOp = pkgOps.valueAt(j);
+                                if (DEBUG) Slog.d(TAG, "Ignoring " + curOp.packageName + " request "
+                                        + curOp.op);
+                                curOp.dialogReqQueue.ignore();
+                            }
+                        }
+                    }
+                    mIsInteractive = false;
+                }
+            }
+        }
+    };
+
+    public void handlePackageResumed(int uid, String packageName) {
+       synchronized (this) {
+            Ops ops = getOpsRawLocked(uid, packageName, true, false);
+            if (ops == null) {
+                return;
+            }
+            ops.startRealtime = SystemClock.elapsedRealtime();
+       }
+    }
+
     public void packageRemoved(int uid, String packageName) {
         synchronized (this) {
             UidState uidState = mUidStates.get(uid);
@@ -812,13 +973,14 @@ public class AppOpsService extends IAppOpsService.Stub {
             resOps = new ArrayList<>();
             for (int j=0; j<pkgOps.size(); j++) {
                 Op curOp = pkgOps.valueAt(j);
+                curOp.startRealtime = pkgOps.startRealtime;
                 final boolean running = curOp.duration == -1;
                 long duration = running
                         ? (elapsedNow - curOp.startRealtime)
                         : curOp.duration;
                 resOps.add(new AppOpsManager.OpEntry(curOp.op, curOp.mode, curOp.time,
                         curOp.rejectTime, (int) duration, running, curOp.proxyUid,
-                        curOp.proxyPackageName));
+                        curOp.proxyPackageName, curOp.allowedCount, curOp.ignoredCount));
             }
         } else {
             for (int j=0; j<ops.length; j++) {
@@ -827,13 +989,14 @@ public class AppOpsService extends IAppOpsService.Stub {
                     if (resOps == null) {
                         resOps = new ArrayList<>();
                     }
+                    curOp.startRealtime = pkgOps.startRealtime;
                     final boolean running = curOp.duration == -1;
                     final long duration = running
                             ? (elapsedNow - curOp.startRealtime)
                             : curOp.duration;
                     resOps.add(new AppOpsManager.OpEntry(curOp.op, curOp.mode, curOp.time,
                             curOp.rejectTime, (int) duration, running, curOp.proxyUid,
-                            curOp.proxyPackageName));
+                            curOp.proxyPackageName, curOp.allowedCount, curOp.ignoredCount));
                 }
             }
         }
@@ -846,7 +1009,7 @@ public class AppOpsService extends IAppOpsService.Stub {
             resOps = new ArrayList<>();
             for (int j=0; j<uidOps.size(); j++) {
                 resOps.add(new AppOpsManager.OpEntry(uidOps.keyAt(j), uidOps.valueAt(j),
-                        0, 0, 0, -1, null));
+                        0, 0, 0, -1, null, 0, 0));
             }
         } else {
             for (int j=0; j<ops.length; j++) {
@@ -856,7 +1019,7 @@ public class AppOpsService extends IAppOpsService.Stub {
                         resOps = new ArrayList<>();
                     }
                     resOps.add(new AppOpsManager.OpEntry(uidOps.keyAt(index), uidOps.valueAt(index),
-                            0, 0, 0, -1, null));
+                            0, 0, 0, -1, null, 0, 0));
                 }
             }
         }
@@ -990,7 +1153,8 @@ public class AppOpsService extends IAppOpsService.Stub {
         code = AppOpsManager.opToSwitch(code);
 
         synchronized (this) {
-            final int defaultMode = AppOpsManager.opToDefaultMode(code);
+            final int defaultMode = AppOpsManager.opToDefaultMode(code,
+                    AppOpsManager.isStrictOp(code));
 
             UidState uidState = getUidStateLocked(uid, false);
             if (uidState == null) {
@@ -1539,7 +1703,7 @@ public class AppOpsService extends IAppOpsService.Stub {
             return AppOpsManager.MODE_IGNORED;
         }
         final int proxyMode = noteOperationUnchecked(code, proxyUid,
-                resolveProxyPackageName, -1, null);
+                resolveProxyPackageName, -1, null, false);
         if (proxyMode != AppOpsManager.MODE_ALLOWED || Binder.getCallingUid() == proxiedUid) {
             return proxyMode;
         }
@@ -1548,7 +1712,7 @@ public class AppOpsService extends IAppOpsService.Stub {
             return AppOpsManager.MODE_IGNORED;
         }
         return noteOperationUnchecked(code, proxiedUid, resolveProxiedPackageName,
-                proxyMode, resolveProxyPackageName);
+                proxyMode, resolveProxyPackageName, false);
     }
 
     @Override
@@ -1559,11 +1723,12 @@ public class AppOpsService extends IAppOpsService.Stub {
         if (resolvedPackageName == null) {
             return AppOpsManager.MODE_IGNORED;
         }
-        return noteOperationUnchecked(code, uid, resolvedPackageName, 0, null);
+        return noteOperationUnchecked(code, uid, resolvedPackageName, 0, null, false);
     }
 
     private int noteOperationUnchecked(int code, int uid, String packageName,
-            int proxyUid, String proxyPackageName) {
+            int proxyUid, String proxyPackageName, boolean avoidAskMode) {
+        PermissionDialogReq req = null;
         synchronized (this) {
             final Ops ops = getOpsRawLocked(uid, packageName, true /* edit */,
                     false /* uidMismatchExpected */);
@@ -1574,6 +1739,7 @@ public class AppOpsService extends IAppOpsService.Stub {
             }
             final Op op = getOpLocked(ops, code, true);
             if (isOpRestrictedLocked(uid, code, packageName)) {
+                op.ignoredCount++;
                 return AppOpsManager.MODE_IGNORED;
             }
             final UidState uidState = ops.uidState;
@@ -1598,22 +1764,93 @@ public class AppOpsService extends IAppOpsService.Stub {
             } else {
                 final Op switchOp = switchCode != code ? getOpLocked(ops, switchCode, true) : op;
                 final int mode = switchOp.getMode();
-                if (mode != AppOpsManager.MODE_ALLOWED) {
+                if (mode != AppOpsManager.MODE_ALLOWED && mode != AppOpsManager.MODE_ASK) {
                     if (DEBUG) Slog.d(TAG, "noteOperation: reject #" + mode + " for code "
                             + switchCode + " (" + code + ") uid " + uid + " package "
                             + packageName);
                     op.rejectTime[uidState.state] = System.currentTimeMillis();
+                    op.ignoredCount++;
                     return mode;
+                } else if (mode == AppOpsManager.MODE_ASK) {
+                    if (Looper.myLooper() == mLooper || Thread.holdsLock(mActivityManagerService)) {
+                        Slog.e(TAG, "noteOperation: this method will deadlock if called" +
+                               " from the main thread. (Code: " + code + " uid: " + uid +
+                               " package: " + packageName + ")");
+                        return mode;
+                    } else if (avoidAskMode) {
+                        return mode;
+                    }
+
+                    if (DEBUG) {
+                            Slog.d(TAG, "Package " + op.packageName + " has " + op.noteOpCount
+                                    + " requests and " + op.startOpCount + " start requests with "
+                                    + op.ignoredCount + " ignored at " + Arrays.toString(op.time) +
+                                    " with a duration of " + op.duration +
+                                    " while being delayed " + op.delayedCount + " times");
+                            Slog.d(TAG, "Total pkops for " + ops.packageName + " "
+                                    + ops.uidState.pkgOps.size());
+                    }
+
+                    // We don't need ask everytime, just after app resume.
+                    // Check once and remember the choice for 5 minutes.
+                    final long lastcheck = Math.max(op.time[uidState.state],
+                            op.rejectTime[uidState.state]);
+                    if (lastcheck > ops.startRealtime &&
+                            lastcheck < (ops.startRealtime + 5 * 60 * 1000L)) {
+                        return op.time[uidState.state] >= op.rejectTime[uidState.state]
+                                ? AppOpsManager.MODE_ALLOWED : AppOpsManager.MODE_IGNORED;
+                    }
+
+                    // First drop all request events if the device is not interactive, next check
+                    // what the global pkg ops count for the package, then check op scoped count.
+                    // High frequency request ops will be delayed until their delay count ceiling
+                    // is met. This is to mitigate the overloading the main activity manager
+                    // service handler and having watchdog kill our service.
+                    // Google Play services likes to share its uid with numerous packages to avoid
+                    // having to grant permissions from the users perspective and thus is the worst
+                    // example of overloading this queue -- so, to not encourage bad behavior,
+                    // we move them to the back of the line.
+                    //
+                    // NOTE: these values are magic, and may need tuning. Ideally we'd want a
+                    // ringbuffer or token bucket here to do proper rate limiting.
+                    if (mIsInteractive &&
+                            (ops.uidState.pkgOps.size() < RATE_LIMIT_OPS_TOTAL_PKG_COUNT
+                              && op.noteOpCount < RATE_LIMIT_OP_COUNT
+                              || op.delayedCount > RATE_LIMIT_OP_DELAY_CEILING)) {
+
+                        // Reset delayed count, most ops will never need this
+                        if (op.delayedCount > 0) {
+                            if (DEBUG) Slog.d(TAG, "Resetting delayed count for " + op.packageName);
+                            op.delayedCount = 0;
+                        }
+
+                        op.noteOpCount++;
+                        req = askOperationLocked(code, uid, packageName, switchOp);
+                    } else {
+                        if (mIsInteractive) {
+                            op.delayedCount++;
+                        }
+                        op.ignoredCount++;
+                        return AppOpsManager.MODE_IGNORED;
+                    }
                 }
             }
-            if (DEBUG) Slog.d(TAG, "noteOperation: allowing code " + code + " uid " + uid
-                    + " package " + packageName);
-            op.time[uidState.state] = System.currentTimeMillis();
-            op.rejectTime[uidState.state] = 0;
-            op.proxyUid = proxyUid;
-            op.proxyPackageName = proxyPackageName;
-            return AppOpsManager.MODE_ALLOWED;
+            if (req == null) {
+                if (DEBUG) Slog.d(TAG, "noteOperation: allowing code " + code + " uid " + uid
+                        + " package " + packageName);
+                op.time[uidState.state] = System.currentTimeMillis();
+                op.rejectTime[uidState.state] = 0;
+                op.proxyUid = proxyUid;
+                op.proxyPackageName = proxyPackageName;
+                op.allowedCount++;
+                return AppOpsManager.MODE_ALLOWED;
+            }
         }
+
+        if (DEBUG) Slog.d(TAG, "noteOperation: waiting for result code " + code + " uid " + uid
+                + " package " + packageName);
+
+        return req.get();
     }
 
     @Override
@@ -1670,6 +1907,7 @@ public class AppOpsService extends IAppOpsService.Stub {
     @Override
     public int startOperation(IBinder token, int code, int uid, String packageName,
             boolean startIfModeDefault) {
+        final PermissionDialogReq req;
         verifyIncomingUid(uid);
         verifyIncomingOp(code);
         String resolvedPackageName = resolvePackageName(uid, packageName);
@@ -1687,51 +1925,63 @@ public class AppOpsService extends IAppOpsService.Stub {
             }
             final Op op = getOpLocked(ops, code, true);
             if (isOpRestrictedLocked(uid, code, resolvedPackageName)) {
+                op.ignoredCount++;
                 return AppOpsManager.MODE_IGNORED;
             }
             final int switchCode = AppOpsManager.opToSwitch(code);
             final UidState uidState = ops.uidState;
-            // If there is a non-default per UID policy (we set UID op mode only if
-            // non-default) it takes over, otherwise use the per package policy.
-            if (uidState.opModes != null && uidState.opModes.indexOfKey(switchCode) >= 0) {
-                final int uidMode = uidState.evalMode(uidState.opModes.get(switchCode));
-                if (uidMode != AppOpsManager.MODE_ALLOWED
-                        && (!startIfModeDefault || uidMode != AppOpsManager.MODE_DEFAULT)) {
+            if (uidState.opModes != null) {
+                final int uidMode = uidState.opModes.get(switchCode);
+                if (uidMode != AppOpsManager.MODE_ALLOWED) {
                     if (DEBUG) Slog.d(TAG, "noteOperation: uid reject #" + uidMode + " for code "
                             + switchCode + " (" + code + ") uid " + uid + " package "
                             + resolvedPackageName);
                     op.rejectTime[uidState.state] = System.currentTimeMillis();
                     return uidMode;
                 }
+            }
+            final Op switchOp = switchCode != code ? getOpLocked(ops, switchCode, true) : op;
+            final int mode = switchOp.getMode();
+            if (mode != AppOpsManager.MODE_ALLOWED && mode != AppOpsManager.MODE_ASK) {
+                if (DEBUG) Slog.d(TAG, "startOperation: reject #" + op.mode + " for code "
+                        + switchCode + " (" + code + ") uid " + uid + " package "
+                        + resolvedPackageName);
+                op.rejectTime[uidState.state] = System.currentTimeMillis();
+                op.ignoredCount++;
+                return mode;
+            } else if (mode == AppOpsManager.MODE_ALLOWED) {
+                if (DEBUG) Slog.d(TAG, "startOperation: allowing code " + code + " uid " + uid
+                        + " package " + resolvedPackageName);
+                if (op.startNesting == 0) {
+                    op.startRealtime = SystemClock.elapsedRealtime();
+                    op.time[uidState.state] = System.currentTimeMillis();
+                    op.rejectTime[uidState.state] = 0;
+                    op.duration = -1;
+                    op.allowedCount++;
+                    scheduleOpActiveChangedIfNeededLocked(code, uid, packageName, true);
+                }
+                op.startNesting++;
+                uidState.startNesting++;
+                if (client.mStartedOps != null) {
+                    client.mStartedOps.add(op);
+                }
+                return AppOpsManager.MODE_ALLOWED;
             } else {
-                final Op switchOp = switchCode != code ? getOpLocked(ops, switchCode, true) : op;
-                final int mode = switchOp.getMode();
-                if (mode != AppOpsManager.MODE_ALLOWED
-                        && (!startIfModeDefault || mode != AppOpsManager.MODE_DEFAULT)) {
-                    if (DEBUG) Slog.d(TAG, "startOperation: reject #" + mode + " for code "
-                            + switchCode + " (" + code + ") uid " + uid + " package "
-                            + resolvedPackageName);
-                    op.rejectTime[uidState.state] = System.currentTimeMillis();
+                if (Looper.myLooper() == mLooper || Thread.holdsLock(mActivityManagerService)) {
+                    Slog.e(TAG, "startOperation: this method will deadlock if called" +
+                            " from the main thread. (Code: " + code + " uid: " + uid +
+                            " package: " + resolvedPackageName + ")");
                     return mode;
                 }
-            }
-            if (DEBUG) Slog.d(TAG, "startOperation: allowing code " + code + " uid " + uid
-                    + " package " + resolvedPackageName);
-            if (op.startNesting == 0) {
-                op.startRealtime = SystemClock.elapsedRealtime();
-                op.time[uidState.state] = System.currentTimeMillis();
-                op.rejectTime[uidState.state] = 0;
-                op.duration = -1;
-                scheduleOpActiveChangedIfNeededLocked(code, uid, packageName, true);
-            }
-            op.startNesting++;
-            uidState.startNesting++;
-            if (client.mStartedOps != null) {
-                client.mStartedOps.add(op);
+                if (DEBUG) Slog.d(TAG, "startOperation: asking for code " + code
+                        + " uid " + uid + " package " + resolvedPackageName);
+                op.startOpCount++;
+                IBinder clientToken = client.mAppToken;
+                op.clientTokens.add(clientToken);
+                req = askOperationLocked(code, uid, resolvedPackageName, switchOp);
             }
         }
-
-        return AppOpsManager.MODE_ALLOWED;
+        return req.get();
     }
 
     @Override
@@ -1854,6 +2104,10 @@ public class AppOpsService extends IAppOpsService.Stub {
     }
 
     private void verifyIncomingUid(int uid) {
+        if (Binder.getCallingUid() == 0) {
+            // Allow root to delegate uid operations.
+            return;
+        }
         if (uid == Binder.getCallingUid()) {
             return;
         }
@@ -2283,15 +2537,46 @@ public class AppOpsService extends IAppOpsService.Stub {
                     uidState.pkgOps = new ArrayMap<>();
                 }
 
-                Op op = new Op(uidState, pkgName,
-                        Integer.parseInt(parser.getAttributeValue(null, "n")));
+                int code = Integer.parseInt(parser.getAttributeValue(null, "n"));
+                // use op name string if it exists
+                String codeNameStr = parser.getAttributeValue(null, "ns");
+                if (codeNameStr != null) {
+                    // returns OP_NONE if it could not be mapped
+                    code = AppOpsManager.nameToOp(codeNameStr);
+                }
+                // skip op codes that are out of bounds
+                if (code == AppOpsManager.OP_NONE || code >= AppOpsManager._NUM_OP) {
+                    continue;
+                }
+
+                Op op = new Op(uidState, pkgName, code, AppOpsManager.MODE_ERRORED);
+
+                String mode = parser.getAttributeValue(null, "m");
+                if (mode != null) {
+                    op.mode = Integer.parseInt(mode);
+                } else {
+                    String defaultMode = parser.getAttributeValue(null, "dm");
+                    if (defaultMode != null) {
+                        op.mode = Integer.parseInt(defaultMode);
+                    } else {
+                        op.mode = AppOpsManager.opToDefaultMode(code);
+                    }
+                }
 
                 for (int i = parser.getAttributeCount()-1; i >= 0; i--) {
                     final String name = parser.getAttributeName(i);
                     final String value = parser.getAttributeValue(i);
                     switch (name) {
+                        case "ac":
+                            op.allowedCount = Integer.parseInt(value);
+                            break;
+                        case "ic":
+                            op.ignoredCount = Integer.parseInt(value);
+                            break;
+                        case "dm":
                         case "m":
-                            op.mode = Integer.parseInt(value);
+                        case "n":
+                        case "ns":
                             break;
                         case "d":
                             op.duration = Integer.parseInt(value);
@@ -2445,8 +2730,12 @@ public class AppOpsService extends IAppOpsService.Stub {
                             AppOpsManager.OpEntry op = ops.get(j);
                             out.startTag(null, "op");
                             out.attribute(null, "n", Integer.toString(op.getOp()));
-                            if (op.getMode() != AppOpsManager.opToDefaultMode(op.getOp())) {
+                            out.attribute(null, "ns", AppOpsManager.opToName(op.getOp()));
+                            int defaultMode = AppOpsManager.opToDefaultMode(op.getOp());
+                            if (op.getMode() != defaultMode) {
                                 out.attribute(null, "m", Integer.toString(op.getMode()));
+                            } else {
+                                out.attribute(null, "dm", Integer.toString(defaultMode));
                             }
                             for (int k = 0; k < _NUM_UID_STATE; k++) {
                                 final long time = op.getLastTimeFor(k);
@@ -2472,6 +2761,14 @@ public class AppOpsService extends IAppOpsService.Stub {
                             if (proxyPackageName != null) {
                                 out.attribute(null, "pp", proxyPackageName);
                             }
+                            int allowed = op.getAllowedCount();
+                            if (allowed != 0) {
+                                out.attribute(null, "ac", Integer.toString(allowed));
+                            }
+                            int ignored = op.getIgnoredCount();
+                            if (ignored != 0) {
+                                out.attribute(null, "ic", Integer.toString(ignored));
+                            }
                             out.endTag(null, "op");
                         }
                         out.endTag(null, "uid");
@@ -3566,6 +3863,150 @@ public class AppOpsService extends IAppOpsService.Stub {
         }
     }
 
+    final class AskRunnable implements Runnable {
+        private final PermissionDialogReq mRequest;
+
+        public AskRunnable(PermissionDialogReq request) {
+            super();
+            mRequest = request;
+        }
+
+        @Override
+        public void run() {
+            final PermissionDialogReqQueue queue = mRequest.mOp.dialogReqQueue;
+            synchronized (AppOpsService.this) {
+                Slog.e(TAG, "Creating dialog box");
+                queue.register(AppOpsService.this, mRequest);
+            }
+            queue.showDialog();
+        }
+    }
+
+    private PermissionDialogReq askOperationLocked(int code, int uid, String packageName, Op op) {
+        PermissionDialogReq request = new PermissionDialogReq(op);
+        mHandler.post(new AskRunnable(request));
+        return request;
+    }
+
+    private void printOperationLocked(Op op, int mode, String operation) {
+        if (op != null) {
+            int switchCode = AppOpsManager.opToSwitch(op.op);
+            if (mode == AppOpsManager.MODE_IGNORED) {
+                if (DEBUG) Slog.d(TAG, operation + ": reject #" + mode + " for code "
+                        + switchCode + " (" + op.op + ") uid " + op.uid + " package "
+                        + op.packageName);
+            } else if (mode == AppOpsManager.MODE_ALLOWED) {
+                if (DEBUG) Slog.d(TAG, operation + ": allowing code " + op.op + " uid "
+                    + op.uid + " package " + op.packageName);
+            }
+        }
+    }
+
+    private void recordOperationLocked(int code, int uid, String packageName, int mode) {
+        Op op = getOpLocked(code, uid, packageName, false);
+        UidState uidState = getUidStateLocked(uid, false);
+        if (op != null && uidState != null) {
+            if (op.noteOpCount != 0) {
+                printOperationLocked(op, mode, "noteOperartion");
+            }
+            if (op.startOpCount != 0) {
+                printOperationLocked(op, mode, "startOperation");
+            }
+            if (mode == AppOpsManager.MODE_IGNORED) {
+                op.rejectTime[uidState.state] = System.currentTimeMillis();
+            } else if (mode == AppOpsManager.MODE_ALLOWED) {
+                if (op.noteOpCount != 0) {
+                    op.time[uidState.state] = System.currentTimeMillis();
+                    op.rejectTime[uidState.state] = 0;
+                }
+                if (op.startOpCount != 0) {
+                    if (op.startNesting == 0) {
+                        op.time[uidState.state] = System.currentTimeMillis();
+                        op.rejectTime[uidState.state] = 0;
+                        op.duration = -1;
+                        scheduleOpActiveChangedIfNeededLocked(code, uid, packageName, true);
+                    }
+                    op.startNesting = op.startNesting + op.startOpCount;
+                    while (op.clientTokens.size() != 0) {
+                        IBinder clientToken = op.clientTokens.get(0);
+                        ClientState client = mClients.get(clientToken);
+                        if (client != null) {
+                            if (client.mStartedOps != null) {
+                                client.mStartedOps.add(op);
+                            }
+                        }
+                        op.clientTokens.remove(0);
+                    }
+                }
+            }
+            op.clientTokens.clear();
+            op.startOpCount = 0;
+            op.noteOpCount = 0;
+        }
+    }
+
+    public void notifyOperation(int code, int uid, String packageName, int mode, boolean remember) {
+        if (DEBUG) Slog.d(TAG, "notifyOperation("
+                + code + ", " + uid + ", " + packageName + ", " + mode + ")");
+
+        verifyIncomingUid(uid);
+        verifyIncomingOp(code);
+        ArraySet<ModeCallback> repCbs = null;
+        int switchCode = AppOpsManager.opToSwitch(code);
+        boolean needsPolicyUpdate = false;
+        synchronized (this) {
+            recordOperationLocked(code, uid, packageName, mode);
+            Op op = getOpLocked(switchCode, uid, packageName, true);
+            if (op != null) {
+                // Send result to all waiting client
+                op.dialogReqQueue.dismissAndNotify(mode);
+                if (remember && op.mode != mode) {
+                    op.mode = mode;
+                    ArraySet<ModeCallback> cbs = mOpModeWatchers.get(switchCode);
+                    if (cbs != null) {
+                        if (repCbs == null) {
+                            repCbs = new ArraySet<ModeCallback>();
+                        }
+                        repCbs.addAll(cbs);
+                    }
+                    cbs = mPackageModeWatchers.get(packageName);
+                    if (cbs != null) {
+                        if (repCbs == null) {
+                            repCbs = new ArraySet<ModeCallback>();
+                        }
+                        repCbs.addAll(cbs);
+                    }
+                    if (mode == AppOpsManager.opToDefaultMode(op.op)) {
+                        // If going into the default mode, prune this op
+                        // if there is nothing else interesting in it.
+                        pruneOp(op, uid, packageName);
+                    }
+                    scheduleWriteLocked();
+                }
+            }
+            UidState uidState = getUidStateLocked(uid, false);
+            if (uidState != null && uidState.pendingAskOp == code) {
+                if (mode == AppOpsManager.MODE_ALLOWED) {
+                    uidState.receivedPendingAskResponse = true;
+                    needsPolicyUpdate = true;
+                } else {
+                    uidState.pendingAskOp = 0;
+                    uidState.receivedPendingAskResponse = false;
+                }
+            }
+        }
+        if (repCbs != null) {
+            mHandler.sendMessage(PooledLambda.obtainMessage(
+                    AppOpsService::notifyOpChanged,
+                    this, repCbs, code, uid, packageName));
+        }
+        if (needsPolicyUpdate) {
+            StorageManagerInternal storageManagerInternal =
+                LocalServices.getService(StorageManagerInternal.class);
+            storageManagerInternal.onExternalStoragePolicyChanged(uid, packageName);
+        }
+    }
+
     private static String resolvePackageName(int uid, String packageName)  {
         if (uid == Process.ROOT_UID) {
             return "root";
@@ -3776,4 +4217,50 @@ public class AppOpsService extends IAppOpsService.Stub {
             }
         }
     }
+
+    @Override
+    public boolean getPrivacyGuardSettingForPackage(int uid, String packageName) {
+        for (int op : AppOpsManager.PRIVACY_GUARD_OP_STATES) {
+            int switchOp = AppOpsManager.opToSwitch(op);
+            int mode = checkOperation(op, uid, packageName);
+            if (mode != AppOpsManager.MODE_ALLOWED && mode != AppOpsManager.MODE_IGNORED) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    @Override
+    public void setPrivacyGuardSettingForPackage(int uid, String packageName, boolean state) {
+        for (int op : AppOpsManager.PRIVACY_GUARD_OP_STATES) {
+            int switchOp = AppOpsManager.opToSwitch(op);
+            setMode(switchOp, uid, packageName, state
+                    ? AppOpsManager.MODE_ASK : AppOpsManager.MODE_ALLOWED);
+        }
+    }
+
+    @Override
+    public void resetCounters() {
+        mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,
+                Binder.getCallingPid(), Binder.getCallingUid(), null);
+        synchronized (this) {
+            for (int i = 0; i < mUidStates.size(); i++) {
+                final UidState uidState = mUidStates.valueAt(i);
+                if (uidState.pkgOps == null) {
+                    continue;
+                }
+                for (Map.Entry<String, Ops> ent : uidState.pkgOps.entrySet()) {
+                    String packageName = ent.getKey();
+                    Ops pkgOps = ent.getValue();
+                    for (int j = 0; j < pkgOps.size(); j++) {
+                        Op curOp = pkgOps.valueAt(j);
+                        curOp.allowedCount = 0;
+                        curOp.ignoredCount = 0;
+                    }
+                }
+            }
+            // ensure the counter reset persists
+            scheduleWriteLocked();
+        }
+    }
 }
diff --git a/services/core/java/com/android/server/BluetoothManagerService.java b/services/core/java/com/android/server/BluetoothManagerService.java
index aa426d3cd31..4a60e1305bf 100644
--- a/services/core/java/com/android/server/BluetoothManagerService.java
+++ b/services/core/java/com/android/server/BluetoothManagerService.java
@@ -1,4 +1,7 @@
 /*
+ * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ *
  * Copyright (C) 2012 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -19,6 +22,7 @@ package com.android.server;
 import android.Manifest;
 import android.app.ActivityManager;
 import android.app.AppGlobals;
+import android.app.AppOpsManager;
 import android.bluetooth.BluetoothAdapter;
 import android.bluetooth.BluetoothProfile;
 import android.bluetooth.BluetoothProtoEnums;
@@ -883,6 +887,12 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
                     + mBinding + " mState = " + BluetoothAdapter.nameForState(mState));
         }
 
+        AppOpsManager appOps = mContext.getSystemService(AppOpsManager.class);
+        if (appOps.noteOp(AppOpsManager.OP_BLUETOOTH_CHANGE, callingUid, packageName)
+                != AppOpsManager.MODE_ALLOWED) {
+            return false;
+        }
+
         synchronized (mReceiver) {
             mQuietEnableExternal = false;
             mEnableExternal = true;
diff --git a/services/core/java/com/android/server/PermissionDialog.java b/services/core/java/com/android/server/PermissionDialog.java
new file mode 100644
index 00000000000..94af32f7ee7
--- /dev/null
+++ b/services/core/java/com/android/server/PermissionDialog.java
@@ -0,0 +1,177 @@
+/*
+ * Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ *
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server;
+
+import android.app.AlertDialog;
+import android.app.AppOpsManager;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.content.res.Resources;
+import android.os.Handler;
+import android.os.Message;
+import android.view.KeyEvent;
+import android.view.View;
+import android.view.WindowManager;
+import android.widget.CheckBox;
+import android.widget.TextView;
+
+import com.android.internal.R;
+
+public class PermissionDialog extends AlertDialog {
+    private final static String TAG = "PermissionDialog";
+
+    private final AppOpsService mService;
+    private final String mPackageName;
+    private final int mCode;
+    private View  mView;
+    private CheckBox mChoice;
+    private int mUid;
+    final CharSequence[] mOpLabels;
+    private Context mContext;
+    private boolean mConsuming;
+
+    // Event 'what' codes
+    private static final int MSG_START = 1;
+    private static final int MSG_ALLOWED = 2;
+    private static final int MSG_IGNORED = 3;
+    private static final int MSG_IGNORED_TIMEOUT = 4;
+
+    // 15s timeout, then we automatically dismiss the permission dialog.
+    // Otherwise, it may cause watchdog timeout sometimes.
+    private static final long DISMISS_TIMEOUT = 1000 * 15 * 1;
+
+    private final Handler mHandler = new Handler() {
+        @Override
+        public void handleMessage(Message msg) {
+            if (msg.what == MSG_START) {
+                mConsuming = false;
+                setEnabled(true);
+            } else {
+                int mode;
+                boolean remember = mChoice.isChecked();
+                switch (msg.what) {
+                    case MSG_ALLOWED:
+                        mode = AppOpsManager.MODE_ALLOWED;
+                        break;
+                    case MSG_IGNORED:
+                        mode = AppOpsManager.MODE_IGNORED;
+                        break;
+                    default:
+                        mode = AppOpsManager.MODE_IGNORED;
+                        remember = false;
+                        break;
+                }
+                mService.notifyOperation(mCode, mUid, mPackageName, mode, remember);
+                dismiss();
+            }
+        }
+    };
+
+    public PermissionDialog(Context context, AppOpsService service,
+            int code, int uid, String packageName) {
+        super(context, com.android.internal.R.style.Theme_Dialog_AppError);
+
+        mContext = context;
+        Resources res = context.getResources();
+
+        mService = service;
+        mCode = code;
+        mPackageName = packageName;
+        mUid = uid;
+        mOpLabels = res.getTextArray(com.android.internal.R.array.app_ops_labels);
+
+        getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
+        getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,
+                WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);
+
+        setTitle(res.getString(com.android.internal.R.string.privacy_guard_dialog_title));
+        setIconAttribute(R.attr.alertDialogIcon);
+        setCancelable(false);
+
+        setButton(DialogInterface.BUTTON_POSITIVE,
+                res.getString(com.android.internal.R.string.allow),
+                mHandler.obtainMessage(MSG_ALLOWED));
+
+        setButton(DialogInterface.BUTTON_NEGATIVE,
+                res.getString(com.android.internal.R.string.deny),
+                mHandler.obtainMessage(MSG_IGNORED));
+
+        final CharSequence appName = getAppName(mPackageName);
+        WindowManager.LayoutParams attrs = getWindow().getAttributes();
+        attrs.setTitle("Permission info: " + appName);
+        attrs.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_SYSTEM_ERROR
+                | WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;
+        getWindow().setAttributes(attrs);
+
+        mView = getLayoutInflater().inflate(
+                com.android.internal.R.layout.permission_confirmation_dialog, null);
+        TextView tv = (TextView) mView.findViewById(com.android.internal.R.id.permission_text);
+        mChoice = (CheckBox) mView.findViewById(
+                com.android.internal.R.id.permission_remember_choice_checkbox);
+        tv.setText(mContext.getString(com.android.internal.R.string.privacy_guard_dialog_summary,
+                appName, mOpLabels[mCode]));
+        setView(mView);
+
+        // After the timeout, pretend the user clicked the quit button
+        mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_IGNORED_TIMEOUT), DISMISS_TIMEOUT);
+    }
+
+    public void ignore() {
+        mHandler.sendMessage(mHandler.obtainMessage(MSG_IGNORED_TIMEOUT));
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+        setEnabled(false);
+        mHandler.sendMessage(mHandler.obtainMessage(MSG_START));
+    }
+
+    @Override
+    public boolean dispatchKeyEvent(KeyEvent event) {
+        if (mConsuming) {
+            return true;
+        }
+        return super.dispatchKeyEvent(event);
+    }
+
+    private CharSequence getAppName(String packageName) {
+        try {
+            PackageManager pm = mContext.getPackageManager();
+            ApplicationInfo appInfo = pm.getApplicationInfo(packageName,
+                    PackageManager.GET_DISABLED_COMPONENTS
+                    | PackageManager.GET_UNINSTALLED_PACKAGES);
+            return pm.getApplicationLabel(appInfo);
+        } catch (PackageManager.NameNotFoundException e) {
+            // fall through to returning package name
+        }
+        return packageName;
+    }
+
+    private void setEnabled(boolean enabled) {
+        View pos = getButton(DialogInterface.BUTTON_POSITIVE);
+        pos.setEnabled(enabled);
+
+        View neg = getButton(DialogInterface.BUTTON_NEGATIVE);
+        neg.setEnabled(enabled);
+    }
+}
diff --git a/services/core/java/com/android/server/PermissionDialogReqQueue.java b/services/core/java/com/android/server/PermissionDialogReqQueue.java
new file mode 100644
index 00000000000..be72286a6ae
--- /dev/null
+++ b/services/core/java/com/android/server/PermissionDialogReqQueue.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ *
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server;
+
+import android.app.ActivityThread;
+import android.content.Context;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class PermissionDialogReqQueue {
+    public final static class PermissionDialogReq {
+        boolean mHasResult = false;
+        int mResult;
+        final AppOpsService.Op mOp;
+
+        public PermissionDialogReq(final AppOpsService.Op op) {
+            mOp = op;
+        }
+
+        public void set(int res) {
+            synchronized (this) {
+                mHasResult = true;
+                mResult = res;
+                notifyAll();
+            }
+        }
+
+        public int get() {
+            synchronized (this) {
+                while (!mHasResult) {
+                    try {
+                        wait();
+                    } catch (InterruptedException e) {
+                    }
+                }
+            }
+            return mResult;
+        }
+
+    }
+
+    private PermissionDialog mDialog = null;
+    private List<PermissionDialogReq> resultList = new ArrayList<>();
+
+    public void register(AppOpsService service, PermissionDialogReq req) {
+        synchronized (this) {
+            resultList.add(req);
+        }
+        if (mDialog == null) {
+            final Context context = ActivityThread.currentActivityThread().getSystemUiContext();
+            mDialog = new PermissionDialog(context, service,
+                    req.mOp.op, req.mOp.uid, req.mOp.packageName);
+        }
+    }
+
+    public void showDialog() {
+        if (mDialog != null) {
+            mDialog.show();
+        }
+    }
+
+    public void dismissAndNotify(int mode) {
+        if (mDialog == null) {
+            return;
+        }
+        synchronized (this) {
+            while (resultList.size() != 0) {
+                PermissionDialogReq res = resultList.get(0);
+                res.set(mode);
+                resultList.remove(0);
+            }
+        }
+        if (mDialog.isShowing()) {
+            mDialog.dismiss();
+        }
+        mDialog = null;
+    }
+
+    public void ignore() {
+        if (mDialog != null) {
+            mDialog.ignore();
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/am/ActivityManagerService.java b/services/core/java/com/android/server/am/ActivityManagerService.java
index 03d56ebcb12..2c6e6890b35 100644
--- a/services/core/java/com/android/server/am/ActivityManagerService.java
+++ b/services/core/java/com/android/server/am/ActivityManagerService.java
@@ -1938,6 +1938,9 @@ public class ActivityManagerService extends IActivityManager.Stub
     static final int SERVICE_FOREGROUND_CRASH_MSG = 69;
     static final int DISPATCH_OOM_ADJ_OBSERVER_MSG = 70;
 
+    static final int POST_PRIVACY_NOTIFICATION_MSG = 90;
+    static final int CANCEL_PRIVACY_NOTIFICATION_MSG = 91;
+
     static final int FIRST_ACTIVITY_STACK_MSG = 100;
     static final int FIRST_BROADCAST_QUEUE_MSG = 200;
     static final int FIRST_COMPAT_MODE_MSG = 300;
@@ -2575,6 +2578,67 @@ public class ActivityManagerService extends IActivityManager.Stub
                 // it is finished we make sure it is reset to its default.
                 mUserIsMonkey = false;
             } break;
+            case POST_PRIVACY_NOTIFICATION_MSG: {
+                INotificationManager inm = NotificationManager.getService();
+                if (inm == null) {
+                    return;
+                }
+
+                ActivityRecord root = (ActivityRecord) msg.obj;
+                ProcessRecord process = root.app;
+                if (process == null) {
+                    return;
+                }
+
+                try {
+                    Context context = mContext.createPackageContext(process.info.packageName, 0);
+                    String text = mContext.getString(R.string.privacy_guard_notification_detail,
+                            context.getApplicationInfo().loadLabel(context.getPackageManager()));
+                    String title = mContext.getString(R.string.privacy_guard_notification);
+
+                    Intent infoIntent = new Intent(Settings.ACTION_APP_OPS_DETAILS_SETTINGS,
+                            Uri.fromParts("package", root.packageName, null));
+
+                    Notification.Builder builder = new Notification.Builder(mContext,
+                            SystemNotificationChannels.SECURITY);
+                    builder.setSmallIcon(com.android.internal.R.drawable.stat_notify_privacy_guard)
+                            .setOngoing(true)
+                            .setPriority(Notification.PRIORITY_LOW)
+                            .setContentTitle(title)
+                            .setContentText(text)
+                            .setContentIntent(PendingIntent.getActivityAsUser(mContext, 0,
+                                    infoIntent, PendingIntent.FLAG_CANCEL_CURRENT, null,
+                                    new UserHandle(root.userId)));
+                    Notification notification = builder.build();
+
+                    try {
+                        int[] outId = new int[1];
+                        inm.enqueueNotificationWithTag("android", "android", null,
+                                R.string.privacy_guard_notification,
+                                notification, root.userId);
+                    } catch (RuntimeException e) {
+                        Slog.w(ActivityManagerService.TAG,
+                                "Error showing notification for privacy guard", e);
+                    } catch (RemoteException e) {
+                    }
+                } catch (NameNotFoundException e) {
+                    Slog.w(TAG, "Unable to create context for privacy guard notification", e);
+                }
+            } break;
+            case CANCEL_PRIVACY_NOTIFICATION_MSG: {
+                INotificationManager inm = NotificationManager.getService();
+                if (inm == null) {
+                    return;
+                }
+                try {
+                    inm.cancelNotificationWithTag("android", null,
+                            R.string.privacy_guard_notification,  msg.arg1);
+                } catch (RuntimeException e) {
+                    Slog.w(ActivityManagerService.TAG,
+                            "Error canceling notification for service", e);
+                } catch (RemoteException e) {
+                }
+            } break;
             case IDLE_UIDS_MSG: {
                 idleUids();
             } break;
@@ -3032,7 +3096,7 @@ public class ActivityManagerService extends IActivityManager.Stub
         mActivityStartController = null;
         mAppErrors = null;
         mAppWarnings = null;
-        mAppOpsService = mInjector.getAppOpsService(null, null);
+        mAppOpsService = mInjector.getAppOpsService(null, null, this);
         mBatteryStatsService = null;
         mCompatModePackages = null;
         mConstants = null;
@@ -3124,7 +3188,8 @@ public class ActivityManagerService extends IActivityManager.Stub
 
         mProcessStats = new ProcessStatsService(this, new File(systemDir, "procstats"));
 
-        mAppOpsService = mInjector.getAppOpsService(new File(systemDir, "appops.xml"), mHandler);
+        mAppOpsService = mInjector.getAppOpsService(new File(systemDir, "appops.xml"), mHandler,
+                this);
 
         mGrantFile = new AtomicFile(new File(systemDir, "urigrants.xml"), "uri-grants");
 
@@ -27238,8 +27303,9 @@ public class ActivityManagerService extends IActivityManager.Stub
             return null;
         }
 
-        public AppOpsService getAppOpsService(File file, Handler handler) {
-            return new AppOpsService(file, handler);
+        public AppOpsService getAppOpsService(File file, Handler handler,
+                ActivityManagerService service) {
+            return new AppOpsService(file, handler, service);
         }
 
         public Handler getUiHandler(ActivityManagerService service) {
diff --git a/services/core/java/com/android/server/am/ActivityRecord.java b/services/core/java/com/android/server/am/ActivityRecord.java
index a94f22d5d4b..447e76f1f91 100644
--- a/services/core/java/com/android/server/am/ActivityRecord.java
+++ b/services/core/java/com/android/server/am/ActivityRecord.java
@@ -191,6 +191,8 @@ import com.android.server.wm.AppWindowContainerListener;
 import com.android.server.wm.ConfigurationContainer;
 import com.android.server.wm.TaskWindowContainerController;
 
+import lineageos.providers.LineageSettings;
+
 import org.xmlpull.v1.XmlPullParser;
 import org.xmlpull.v1.XmlPullParserException;
 import org.xmlpull.v1.XmlSerializer;
@@ -1893,6 +1895,34 @@ final class ActivityRecord extends ConfigurationContainer implements AppWindowCo
             // pause and then resume again later, which will result in a double life-cycle event.
             stack.checkReadyForSleep();
         }
+
+        service.mAppOpsService.handlePackageResumed(this.app.uid, this.packageName);
+        updatePrivacyGuardNotificationLocked();
+    }
+
+    private final void updatePrivacyGuardNotificationLocked() {
+        String privacyGuardPackageName = mStackSupervisor.mPrivacyGuardPackageName;
+        if (privacyGuardPackageName != null && privacyGuardPackageName.equals(this.packageName)) {
+            return;
+        }
+
+        boolean privacy = service.mAppOpsService.getPrivacyGuardSettingForPackage(
+                this.app.uid, this.packageName);
+        boolean privacyNotification = LineageSettings.Secure.getInt(
+                service.mContext.getContentResolver(),
+                LineageSettings.Secure.PRIVACY_GUARD_NOTIFICATION, 1) == 1;
+
+        if (privacyGuardPackageName != null && !privacy) {
+            Message msg = service.mHandler.obtainMessage(
+                    ActivityManagerService.CANCEL_PRIVACY_NOTIFICATION_MSG, this.userId);
+            msg.sendToTarget();
+            mStackSupervisor.mPrivacyGuardPackageName = null;
+        } else if (privacy && privacyNotification) {
+            Message msg = service.mHandler.obtainMessage(
+                    ActivityManagerService.POST_PRIVACY_NOTIFICATION_MSG, this);
+            msg.sendToTarget();
+            mStackSupervisor.mPrivacyGuardPackageName = this.packageName;
+        }
     }
 
     final void activityStoppedLocked(Bundle newIcicle, PersistableBundle newPersistentState,
diff --git a/services/core/java/com/android/server/am/ActivityStackSupervisor.java b/services/core/java/com/android/server/am/ActivityStackSupervisor.java
index 2ae056fe18a..715d9c5d9d5 100644
--- a/services/core/java/com/android/server/am/ActivityStackSupervisor.java
+++ b/services/core/java/com/android/server/am/ActivityStackSupervisor.java
@@ -394,6 +394,9 @@ public class ActivityStackSupervisor extends ConfigurationContainer implements D
     /** Set when a power hint has started, but not ended. */
     private boolean mPowerHintSent;
 
+    /** Is Privacy Guard currently enabled? Shared between ActivityStacks. */
+    String mPrivacyGuardPackageName = null;
+
     /**
      * We don't want to allow the device to go to sleep while in the process
      * of launching an activity.  This is primarily to allow alarm intent
diff --git a/services/core/java/com/android/server/am/UserController.java b/services/core/java/com/android/server/am/UserController.java
index 5e981ebde01..c5514bd82e6 100644
--- a/services/core/java/com/android/server/am/UserController.java
+++ b/services/core/java/com/android/server/am/UserController.java
@@ -357,7 +357,7 @@ class UserController implements Handler.Callback {
                     | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
             mInjector.broadcastIntent(intent, null, resultTo, 0, null, null,
                     new String[]{android.Manifest.permission.RECEIVE_BOOT_COMPLETED},
-                    AppOpsManager.OP_NONE, null, true, false, MY_PID, SYSTEM_UID, userId);
+                    AppOpsManager.OP_BOOT_COMPLETED, null, true, false, MY_PID, SYSTEM_UID, userId);
         }
 
         // We need to delay unlocking managed profiles until the parent user
@@ -557,7 +557,7 @@ class UserController implements Handler.Callback {
                     }
                 }, 0, null, null,
                 new String[]{android.Manifest.permission.RECEIVE_BOOT_COMPLETED},
-                AppOpsManager.OP_NONE, null, true, false, MY_PID, SYSTEM_UID, userId);
+                AppOpsManager.OP_BOOT_COMPLETED, null, true, false, MY_PID, SYSTEM_UID, userId);
     }
 
     int restartUser(final int userId, final boolean foreground) {
diff --git a/services/core/java/com/android/server/clipboard/ClipboardService.java b/services/core/java/com/android/server/clipboard/ClipboardService.java
index 5db20b02910..daf06557c51 100644
--- a/services/core/java/com/android/server/clipboard/ClipboardService.java
+++ b/services/core/java/com/android/server/clipboard/ClipboardService.java
@@ -152,6 +152,11 @@ public class ClipboardService extends SystemService {
 
     private final SparseArray<PerUserClipboard> mClipboards = new SparseArray<>();
 
+    /* AppOps check variants for the clipboardAccessAllowed method */
+    private static final int APPOP_NOTE = 1;    /** Call AppOps.noteOp method */
+    private static final int APPOP_CHECK = 2;   /** Call AppOps.checkOp method */
+    private static final int APPOP_NOTHROW = 3; /** Call AppOps.checkOpNoThrow method */
+
     /**
      * Instantiates the clipboard.
      */
@@ -252,7 +257,7 @@ public class ClipboardService extends SystemService {
                 }
                 final int callingUid = Binder.getCallingUid();
                 if (!clipboardAccessAllowed(AppOpsManager.OP_WRITE_CLIPBOARD, callingPackage,
-                            callingUid)) {
+                            callingUid, APPOP_NOTE)) {
                     return;
                 }
                 checkDataOwnerLocked(clip, callingUid);
@@ -265,7 +270,7 @@ public class ClipboardService extends SystemService {
             synchronized (this) {
                 final int callingUid = Binder.getCallingUid();
                 if (!clipboardAccessAllowed(AppOpsManager.OP_WRITE_CLIPBOARD, callingPackage,
-                        callingUid)) {
+                        callingUid, APPOP_NOTHROW)) {
                     return;
                 }
                 setPrimaryClipInternal(null, callingUid);
@@ -276,7 +281,7 @@ public class ClipboardService extends SystemService {
         public ClipData getPrimaryClip(String pkg) {
             synchronized (this) {
                 if (!clipboardAccessAllowed(AppOpsManager.OP_READ_CLIPBOARD, pkg,
-                            Binder.getCallingUid()) || isDeviceLocked()) {
+                            Binder.getCallingUid(), APPOP_NOTE) || isDeviceLocked()) {
                     return null;
                 }
                 addActiveOwnerLocked(Binder.getCallingUid(), pkg);
@@ -288,7 +293,7 @@ public class ClipboardService extends SystemService {
         public ClipDescription getPrimaryClipDescription(String callingPackage) {
             synchronized (this) {
                 if (!clipboardAccessAllowed(AppOpsManager.OP_READ_CLIPBOARD, callingPackage,
-                            Binder.getCallingUid()) || isDeviceLocked()) {
+                            Binder.getCallingUid(), APPOP_CHECK) || isDeviceLocked()) {
                     return null;
                 }
                 PerUserClipboard clipboard = getClipboard();
@@ -300,7 +305,7 @@ public class ClipboardService extends SystemService {
         public boolean hasPrimaryClip(String callingPackage) {
             synchronized (this) {
                 if (!clipboardAccessAllowed(AppOpsManager.OP_READ_CLIPBOARD, callingPackage,
-                            Binder.getCallingUid()) || isDeviceLocked()) {
+                            Binder.getCallingUid(), APPOP_CHECK) || isDeviceLocked()) {
                     return false;
                 }
                 return getClipboard().primaryClip != null;
@@ -327,7 +332,7 @@ public class ClipboardService extends SystemService {
         public boolean hasClipboardText(String callingPackage) {
             synchronized (this) {
                 if (!clipboardAccessAllowed(AppOpsManager.OP_READ_CLIPBOARD, callingPackage,
-                            Binder.getCallingUid()) || isDeviceLocked()) {
+                            Binder.getCallingUid(), APPOP_CHECK) || isDeviceLocked()) {
                     return false;
                 }
                 PerUserClipboard clipboard = getClipboard();
@@ -464,7 +469,7 @@ public class ClipboardService extends SystemService {
                             clipboard.primaryClipListeners.getBroadcastCookie(i);
 
                     if (clipboardAccessAllowed(AppOpsManager.OP_READ_CLIPBOARD, li.mPackageName,
-                                li.mUid)) {
+                                li.mUid, APPOP_NOTHROW)) {
                         clipboard.primaryClipListeners.getBroadcastItem(i)
                                 .dispatchPrimaryClipChanged();
                     }
@@ -619,9 +624,24 @@ public class ClipboardService extends SystemService {
         }
     }
 
-    private boolean clipboardAccessAllowed(int op, String callingPackage, int callingUid) {
-        // Check the AppOp.
-        if (mAppOps.noteOp(op, callingUid, callingPackage) != AppOpsManager.MODE_ALLOWED) {
+    private boolean clipboardAccessAllowed(int op, String callingPackage,
+            int callingUid, int appOpMethod) {
+        int appOpResult;
+
+        // Check the AppOp depending on the specified method.
+        switch (appOpMethod) {
+            case APPOP_NOTE:
+                appOpResult = mAppOps.noteOp(op, callingUid, callingPackage);
+                break;
+            case APPOP_NOTHROW:
+                appOpResult = mAppOps.checkOpNoThrow(op, callingUid, callingPackage);
+                break;
+            default:
+                appOpResult = mAppOps.checkOp(op, callingUid, callingPackage);
+                break;
+        }
+
+        if (appOpResult != AppOpsManager.MODE_ALLOWED) {
             return false;
         }
         try {
diff --git a/services/core/java/com/android/server/pm/PackageManagerService.java b/services/core/java/com/android/server/pm/PackageManagerService.java
index 3d39b4cfae6..9b50a1545a5 100644
--- a/services/core/java/com/android/server/pm/PackageManagerService.java
+++ b/services/core/java/com/android/server/pm/PackageManagerService.java
@@ -325,6 +325,8 @@ import dalvik.system.VMRuntime;
 
 import libcore.io.IoUtils;
 
+import lineageos.providers.LineageSettings;
+
 import org.xmlpull.v1.XmlPullParser;
 import org.xmlpull.v1.XmlPullParserException;
 import org.xmlpull.v1.XmlSerializer;
@@ -1239,6 +1241,8 @@ public class PackageManagerService extends IPackageManager.Stub
 
     ArrayList<ComponentName> mDisabledComponentsList;
 
+    private AppOpsManager mAppOps;
+
     // Set of pending broadcasts for aggregating enable/disable of components.
     static class PendingPackageBroadcasts {
         // for each user id, a map of <package name -> components within that package>
@@ -2158,6 +2162,17 @@ public class PackageManagerService extends IPackageManager.Stub
                 notifyPackageAdded(packageName);
             }
 
+            if (!update && !isSystemApp(res.pkg)) {
+                boolean privacyGuard = LineageSettings.Secure.getIntForUser(
+                        mContext.getContentResolver(),
+                        LineageSettings.Secure.PRIVACY_GUARD_DEFAULT,
+                        0, UserHandle.USER_CURRENT) == 1;
+                if (privacyGuard) {
+                    mAppOps.setPrivacyGuardSettingForPackage(res.pkg.applicationInfo.uid,
+                            res.pkg.applicationInfo.packageName, true);
+                }
+            }
+
             // Log current value of "unknown sources" setting
             EventLog.writeEvent(EventLogTags.UNKNOWN_SOURCES_ENABLED,
                     getUnknownSourcesSettings());
@@ -2468,6 +2483,8 @@ public class PackageManagerService extends IPackageManager.Stub
         mSettings.addSharedUserLPw("android.uid.se", SE_UID,
                 ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);
 
+        mAppOps = context.getSystemService(AppOpsManager.class);
+
         String separateProcesses = SystemProperties.get("debug.separate_processes");
         if (separateProcesses != null && separateProcesses.length() > 0) {
             if ("*".equals(separateProcesses)) {
diff --git a/services/core/java/com/android/server/pm/UserManagerService.java b/services/core/java/com/android/server/pm/UserManagerService.java
index cac6383ff3d..1a22a84908f 100644
--- a/services/core/java/com/android/server/pm/UserManagerService.java
+++ b/services/core/java/com/android/server/pm/UserManagerService.java
@@ -1358,6 +1358,7 @@ public class UserManagerService extends IUserManager.Stub {
                 mGuestRestrictions.putBoolean(UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES, true);
                 mGuestRestrictions.putBoolean(UserManager.DISALLOW_OUTGOING_CALLS, true);
                 mGuestRestrictions.putBoolean(UserManager.DISALLOW_SMS, true);
+                mGuestRestrictions.putBoolean(UserManager.DISALLOW_SU, true);
             }
         }
     }
@@ -3878,6 +3879,7 @@ public class UserManagerService extends IUserManager.Stub {
             if (user != null && !user.isAdmin() && !user.isDemo()) {
                 setUserRestriction(UserManager.DISALLOW_SMS, true, user.id);
                 setUserRestriction(UserManager.DISALLOW_OUTGOING_CALLS, true, user.id);
+                setUserRestriction(UserManager.DISALLOW_SU, true, user.id);
             }
             return user;
         }
diff --git a/services/core/java/com/android/server/pm/UserRestrictionsUtils.java b/services/core/java/com/android/server/pm/UserRestrictionsUtils.java
index 9ca02bad50b..975545db440 100644
--- a/services/core/java/com/android/server/pm/UserRestrictionsUtils.java
+++ b/services/core/java/com/android/server/pm/UserRestrictionsUtils.java
@@ -126,7 +126,8 @@ public class UserRestrictionsUtils {
             UserManager.DISALLOW_SHARE_INTO_MANAGED_PROFILE,
             UserManager.DISALLOW_AMBIENT_DISPLAY,
             UserManager.DISALLOW_CONFIG_SCREEN_TIMEOUT,
-            UserManager.DISALLOW_PRINTING
+            UserManager.DISALLOW_PRINTING,
+            UserManager.DISALLOW_SU
     });
 
     /**
@@ -155,7 +156,8 @@ public class UserRestrictionsUtils {
             UserManager.DISALLOW_SAFE_BOOT,
             UserManager.DISALLOW_CREATE_WINDOWS,
             UserManager.DISALLOW_DATA_ROAMING,
-            UserManager.DISALLOW_AIRPLANE_MODE
+            UserManager.DISALLOW_AIRPLANE_MODE,
+            UserManager.DISALLOW_SU
     );
 
     /**
diff --git a/telephony/java/android/telephony/TelephonyManager.java b/telephony/java/android/telephony/TelephonyManager.java
index 37cdb52f7a3..4d4d8b38eb6 100644
--- a/telephony/java/android/telephony/TelephonyManager.java
+++ b/telephony/java/android/telephony/TelephonyManager.java
@@ -1,4 +1,7 @@
 /*
+ * Copyright (c) 2014, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ *
  * Copyright (C) 2008 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -30,6 +33,7 @@ import android.annotation.SystemService;
 import android.annotation.TestApi;
 import android.annotation.WorkerThread;
 import android.app.ActivityThread;
+import android.app.AppOpsManager;
 import android.app.PendingIntent;
 import android.content.Context;
 import android.content.Intent;
@@ -6436,6 +6440,14 @@ public class TelephonyManager {
     public void setDataEnabled(int subId, boolean enable) {
         try {
             Log.d(TAG, "setDataEnabled: enabled=" + enable);
+            AppOpsManager appOps = mContext.getSystemService(AppOpsManager.class);
+            if (enable) {
+                if (appOps.noteOp(AppOpsManager.OP_DATA_CONNECT_CHANGE)
+                        != AppOpsManager.MODE_ALLOWED) {
+                    Log.w(TAG, "Permission denied by user.");
+                    return;
+                }
+            }
             ITelephony telephony = getITelephony();
             if (telephony != null)
                 telephony.setUserDataEnabled(subId, enable);
-- 
2.17.1

