From 5d12ee2646aad66f62765a33cf27c204b9eee52a Mon Sep 17 00:00:00 2001
From: Vachounet <vachounet@live.fr>
Date: Mon, 3 Dec 2018 14:31:52 +0100
Subject: [PATCH 18/35] Battery: update mod support to P

Change-Id: Iff477569fcba3e5b3d9ccb5ebb8d1b750fb531e5
Signed-off-by: Erfan Abdi <erfangplus@gmail.com>

# Conflicts:
#	core/java/android/os/BatteryManager.java
#	services/core/java/com/android/server/BatteryService.java
---
 core/java/android/os/BatteryManager.java      |  18 +
 .../com/android/server/BatteryService.java    | 128 ++++-
 .../health/V1_0/BatteryProperties.java        | 105 ++++
 .../hardware/health/V1_0/IMotHealth.java      | 511 ++++++++++++++++++
 .../health/V1_0/PowerSupplyModType.java       |  54 ++
 5 files changed, 812 insertions(+), 4 deletions(-)
 create mode 100644 services/core/java/motorola/hardware/health/V1_0/BatteryProperties.java
 create mode 100644 services/core/java/motorola/hardware/health/V1_0/IMotHealth.java
 create mode 100644 services/core/java/motorola/hardware/health/V1_0/PowerSupplyModType.java

diff --git a/core/java/android/os/BatteryManager.java b/core/java/android/os/BatteryManager.java
index 954071a0ee9..5207fafa8ec 100644
--- a/core/java/android/os/BatteryManager.java
+++ b/core/java/android/os/BatteryManager.java
@@ -156,6 +156,24 @@ public class BatteryManager {
     @SystemApi
     public static final String EXTRA_EVENT_TIMESTAMP = "android.os.extra.EVENT_TIMESTAMP";
 
+    public static final String EXTRA_MOD_FLAG = "mod_flag";
+    public static final String EXTRA_MOD_LEVEL = "mod_level";
+    public static final String EXTRA_MOD_POWER_SOURCE = "mod_psrc";
+    public static final String EXTRA_MOD_STATUS = "mod_status";
+    public static final String EXTRA_MOD_TYPE = "mod_type";
+    public static final String EXTRA_PLUGGED_RAW = "plugged_raw";
+
+    public static final int BATTERY_PROPERTY_MOD_CHARGE_FULL = 100;
+
+    public static final int MOD_POWER_SOURCE_BATTERY = 1;
+    public static final int MOD_POWER_SOURCE_BATTERY_TURBO = 5;
+    public static final int MOD_POWER_SOURCE_NONE = 0;
+    public static final int MOD_POWER_SOURCE_NONE_TURBO = 4;
+    public static final int MOD_POWER_SOURCE_WIRED = 2;
+    public static final int MOD_POWER_SOURCE_WIRED_TURBO = 6;
+    public static final int MOD_POWER_SOURCE_WIRELESS = 3;
+    public static final int MOD_POWER_SOURCE_WIRELESS_TURBO = 7;
+
     // values for "status" field in the ACTION_BATTERY_CHANGED Intent
     public static final int BATTERY_STATUS_UNKNOWN = Constants.BATTERY_STATUS_UNKNOWN;
     public static final int BATTERY_STATUS_CHARGING = Constants.BATTERY_STATUS_CHARGING;
diff --git a/services/core/java/com/android/server/BatteryService.java b/services/core/java/com/android/server/BatteryService.java
index 95fbee99f8b..da3dda8b16b 100644
--- a/services/core/java/com/android/server/BatteryService.java
+++ b/services/core/java/com/android/server/BatteryService.java
@@ -52,6 +52,7 @@ import android.os.ServiceManager;
 import android.os.ShellCallback;
 import android.os.ShellCommand;
 import android.os.SystemClock;
+import android.os.SystemProperties;
 import android.os.Trace;
 import android.os.UEventObserver;
 import android.os.UserHandle;
@@ -86,6 +87,9 @@ import java.util.NoSuchElementException;
 import java.util.Objects;
 import java.util.concurrent.atomic.AtomicReference;
 
+import motorola.hardware.health.V1_0.BatteryProperties;
+import motorola.hardware.health.V1_0.IMotHealth;
+
 /**
  * <p>BatteryService monitors the charging status, and charge level of the device
  * battery.  When these values change this service broadcasts the new values
@@ -119,7 +123,7 @@ import java.util.concurrent.atomic.AtomicReference;
 public final class BatteryService extends SystemService {
     private static final String TAG = BatteryService.class.getSimpleName();
 
-    private static final boolean DEBUG = false;
+    private static final boolean DEBUG = true;
 
     private static final int BATTERY_SCALE = 100;    // battery capacity is a percentage
 
@@ -127,6 +131,9 @@ public final class BatteryService extends SystemService {
     private static final long BATTERY_LEVEL_CHANGE_THROTTLE_MS = 60_000;
     private static final int MAX_BATTERY_LEVELS_QUEUE_SIZE = 100;
 
+    private static final int MOD_TYPE_EMERGENCY = 3;
+    private static final int MOD_TYPE_SUPPLEMENTAL = 2;
+
     // Used locally for determining when to make a last ditch effort to log
     // discharge stats before the device dies.
     private int mCriticalBatteryLevel;
@@ -195,6 +202,15 @@ public final class BatteryService extends SystemService {
 
     private MetricsLogger mMetricsLogger;
 
+    private BatteryProperties mBatteryModProps;
+    private IMotHealth mMotHealthService = null;
+
+    private int mLastModFlag;
+    private int mLastModLevel;
+    private int mLastModPowerSource;
+    private int mLastModStatus;
+    private int mLastModType;
+
     private LineageBatteryLights mLineageBatteryLights;
 
     public BatteryService(Context context) {
@@ -234,6 +250,19 @@ public final class BatteryService extends SystemService {
             invalidChargerObserver.startObserving(
                     "DEVPATH=/devices/virtual/switch/invalid_charger");
         }
+        mBatteryModProps = new BatteryProperties();
+        mBatteryModProps.modLevel = -1;
+        mBatteryModProps.modStatus = 1;
+        mBatteryModProps.modFlag = 0;
+        mBatteryModProps.modType = 0;
+        mBatteryModProps.modPowerSource = 0;
+        try {
+            mMotHealthService = IMotHealth.getService();
+        } catch (RemoteException e) {
+            Slog.e(TAG, "health: cannot get service. (RemoteException)");
+        } catch (NoSuchElementException e2) {
+            Slog.e(TAG, "mothealth: cannot get service. (no supported health HAL service)");
+        }
     }
 
     @Override
@@ -353,6 +382,9 @@ public final class BatteryService extends SystemService {
         if ((plugTypeSet & BatteryManager.BATTERY_PLUGGED_WIRELESS) != 0 && mHealthInfo.chargerWirelessOnline) {
             return true;
         }
+        if ((plugTypeSet & 8) != 0 && mPlugType == 8 && isModBatteryActive()) {
+            return true;
+        }
         return false;
     }
 
@@ -417,6 +449,13 @@ public final class BatteryService extends SystemService {
         traceBegin("HealthInfoUpdate");
         synchronized (mLock) {
             if (!mUpdatesStopped) {
+                if (mMotHealthService != null) {
+                    try {
+                        mBatteryModProps = mMotHealthService.getModBatteryProperties();
+                    } catch (RemoteException e) {
+                        Slog.e(TAG, "getModBatteryProperties fail!");
+                    }
+                }
                 mHealthInfo = info.legacy;
                 // Process the new values.
                 processValuesLocked(false);
@@ -460,6 +499,8 @@ public final class BatteryService extends SystemService {
             mPlugType = BatteryManager.BATTERY_PLUGGED_USB;
         } else if (mHealthInfo.chargerWirelessOnline) {
             mPlugType = BatteryManager.BATTERY_PLUGGED_WIRELESS;
+        } else if (supplementalOrEmergencyModOnline()) {
+            mPlugType = 8;
         } else {
             mPlugType = BATTERY_PLUGGED_NONE;
         }
@@ -474,7 +515,7 @@ public final class BatteryService extends SystemService {
         // Let the battery stats keep track of the current level.
         try {
             mBatteryStats.setBatteryState(mHealthInfo.batteryStatus, mHealthInfo.batteryHealth,
-                    mPlugType, mHealthInfo.batteryLevel, mHealthInfo.batteryTemperature,
+                    maybeTranslatePlugType(mPlugType), mHealthInfo.batteryLevel - mBatteryModProps.modFlag, mHealthInfo.batteryTemperature,
                     mHealthInfo.batteryVoltage, mHealthInfo.batteryChargeCounter,
                     mHealthInfo.batteryFullCharge);
         } catch (RemoteException e) {
@@ -494,7 +535,12 @@ public final class BatteryService extends SystemService {
                 mHealthInfo.maxChargingCurrent != mLastMaxChargingCurrent ||
                 mHealthInfo.maxChargingVoltage != mLastMaxChargingVoltage ||
                 mHealthInfo.batteryChargeCounter != mLastChargeCounter ||
-                mInvalidCharger != mLastInvalidCharger)) {
+                mInvalidCharger != mLastInvalidCharger ||
+                mBatteryModProps.modLevel != mLastModLevel ||
+                mBatteryModProps.modStatus != mLastModStatus ||
+                mBatteryModProps.modFlag != mLastModFlag ||
+                mBatteryModProps.modType != mLastModType ||
+                mBatteryModProps.modPowerSource != mLastModPowerSource)) {
 
             if (mPlugType != mLastPlugType) {
                 if (mLastPlugType == BATTERY_PLUGGED_NONE) {
@@ -665,6 +711,11 @@ public final class BatteryService extends SystemService {
             mLastChargeCounter = mHealthInfo.batteryChargeCounter;
             mLastBatteryLevelCritical = mBatteryLevelCritical;
             mLastInvalidCharger = mInvalidCharger;
+            mLastModLevel = mBatteryModProps.modLevel;
+            mLastModStatus = mBatteryModProps.modStatus;
+            mLastModFlag = mBatteryModProps.modFlag;
+            mLastModType = mBatteryModProps.modType;
+            mLastModPowerSource = mBatteryModProps.modPowerSource;
         }
     }
 
@@ -684,7 +735,7 @@ public final class BatteryService extends SystemService {
         intent.putExtra(BatteryManager.EXTRA_BATTERY_LOW, mSentLowBatteryBroadcast);
         intent.putExtra(BatteryManager.EXTRA_SCALE, BATTERY_SCALE);
         intent.putExtra(BatteryManager.EXTRA_ICON_SMALL, icon);
-        intent.putExtra(BatteryManager.EXTRA_PLUGGED, mPlugType);
+        intent.putExtra(BatteryManager.EXTRA_PLUGGED, maybeTranslatePlugType(mPlugType));
         intent.putExtra(BatteryManager.EXTRA_VOLTAGE, mHealthInfo.batteryVoltage);
         intent.putExtra(BatteryManager.EXTRA_TEMPERATURE, mHealthInfo.batteryTemperature);
         intent.putExtra(BatteryManager.EXTRA_TECHNOLOGY, mHealthInfo.batteryTechnology);
@@ -692,6 +743,12 @@ public final class BatteryService extends SystemService {
         intent.putExtra(BatteryManager.EXTRA_MAX_CHARGING_CURRENT, mHealthInfo.maxChargingCurrent);
         intent.putExtra(BatteryManager.EXTRA_MAX_CHARGING_VOLTAGE, mHealthInfo.maxChargingVoltage);
         intent.putExtra(BatteryManager.EXTRA_CHARGE_COUNTER, mHealthInfo.batteryChargeCounter);
+        intent.putExtra("mod_level", mBatteryModProps.modLevel);
+        intent.putExtra("mod_status", mBatteryModProps.modStatus);
+        intent.putExtra("mod_flag", mBatteryModProps.modFlag);
+        intent.putExtra("plugged_raw", mPlugType);
+        intent.putExtra("mod_type", mBatteryModProps.modType);
+        intent.putExtra("mod_psrc", mBatteryModProps.modPowerSource);
         if (DEBUG) {
             Slog.d(TAG, "Sending ACTION_BATTERY_CHANGED. scale:" + BATTERY_SCALE
                     + ", info:" + mHealthInfo.toString());
@@ -1053,6 +1110,51 @@ public final class BatteryService extends SystemService {
         Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
     }
 
+    private int maybeTranslatePlugType(int plugType) {
+        if (plugType != 8) {
+            return plugType;
+        }
+        if (mHealthInfo.batteryStatus == 2) {
+            return 1;
+        }
+        return 0;
+    }
+    
+    private boolean supplementalOrEmergencyModOnline() {
+        return mBatteryModProps.modLevel > 0 && (mBatteryModProps.modType == 2 || mBatteryModProps.modType == 3);
+    }
+    
+    private boolean isModBatteryActive() {
+        String str;
+        if (DEBUG) {
+            str = TAG;
+            StringBuilder stringBuilder = new StringBuilder();
+            stringBuilder.append("isModBatteryActive: modLevel=");
+            stringBuilder.append(mBatteryModProps.modLevel);
+            stringBuilder.append(", modType=");
+            stringBuilder.append(mBatteryModProps.modType);
+            Slog.d(str, stringBuilder.toString());
+        }
+        if (mBatteryModProps.modLevel <= 0 || mBatteryModProps.modType != 2) {
+            return false;
+        }
+        str = SystemProperties.get("sys.mod.batterymode");
+        if (DEBUG) {
+            String str2 = TAG;
+            StringBuilder stringBuilder2 = new StringBuilder();
+            stringBuilder2.append("isModBatteryActive:  Battery Mode is ");
+            stringBuilder2.append(str);
+            Slog.d(str2, stringBuilder2.toString());
+        }
+        if ("0".equals(str)) {
+            return true;
+        }
+        if (!"2".equals(str) && mHealthInfo.batteryLevel <= 80) {
+            return true;
+        }
+        return false;
+    }
+
     private synchronized void updateLedPulse() {
         mLed.updateLightsLocked();
     }
@@ -1235,6 +1337,24 @@ public final class BatteryService extends SystemService {
                             if (result == Result.SUCCESS) prop.setLong(value);
                         });
                         break;
+                    case 100:
+                        if (mMotHealthService == null) {
+                            outResult.value = 1;
+                            break;
+                        }
+                        int value = mMotHealthService.getChargeFull();
+                        if (value != -2) {
+                            value = 0;
+                        }
+                        outResult.value = value;
+                        if (outResult.value == 0) {
+                            prop.setLong((long) value);
+                            break;
+                        }
+                        break;
+                    case 101:
+                        outResult.value = 1;
+                        break;
                 }
                 return outResult.value;
             } finally {
diff --git a/services/core/java/motorola/hardware/health/V1_0/BatteryProperties.java b/services/core/java/motorola/hardware/health/V1_0/BatteryProperties.java
new file mode 100644
index 00000000000..f6880e4e4ea
--- /dev/null
+++ b/services/core/java/motorola/hardware/health/V1_0/BatteryProperties.java
@@ -0,0 +1,105 @@
+package motorola.hardware.health.V1_0;
+
+import android.os.HidlSupport;
+import android.os.HwBlob;
+import android.os.HwParcel;
+import java.util.ArrayList;
+import java.util.Objects;
+
+public final class BatteryProperties {
+    public int modFlag;
+    public int modLevel;
+    public int modPowerSource;
+    public int modStatus;
+    public int modType;
+
+    public final boolean equals(Object otherObject) {
+        if (this == otherObject) {
+            return true;
+        }
+        if (otherObject == null || otherObject.getClass() != BatteryProperties.class) {
+            return false;
+        }
+        BatteryProperties other = (BatteryProperties) otherObject;
+        if (this.modLevel == other.modLevel && this.modStatus == other.modStatus && this.modFlag == other.modFlag && this.modType == other.modType && this.modPowerSource == other.modPowerSource) {
+            return true;
+        }
+        return false;
+    }
+
+    public final int hashCode() {
+        return Objects.hash(new Object[]{Integer.valueOf(HidlSupport.deepHashCode(Integer.valueOf(this.modLevel))), Integer.valueOf(HidlSupport.deepHashCode(Integer.valueOf(this.modStatus))), Integer.valueOf(HidlSupport.deepHashCode(Integer.valueOf(this.modFlag))), Integer.valueOf(HidlSupport.deepHashCode(Integer.valueOf(this.modType))), Integer.valueOf(HidlSupport.deepHashCode(Integer.valueOf(this.modPowerSource)))});
+    }
+
+    public final String toString() {
+        StringBuilder builder = new StringBuilder();
+        builder.append("{");
+        builder.append(".modLevel = ");
+        builder.append(this.modLevel);
+        builder.append(", .modStatus = ");
+        builder.append(this.modStatus);
+        builder.append(", .modFlag = ");
+        builder.append(this.modFlag);
+        builder.append(", .modType = ");
+        builder.append(this.modType);
+        builder.append(", .modPowerSource = ");
+        builder.append(this.modPowerSource);
+        builder.append("}");
+        return builder.toString();
+    }
+
+    public final void readFromParcel(HwParcel parcel) {
+        readEmbeddedFromParcel(parcel, parcel.readBuffer(20), 0);
+    }
+
+    public static final ArrayList<BatteryProperties> readVectorFromParcel(HwParcel parcel) {
+        ArrayList<BatteryProperties> _hidl_vec = new ArrayList();
+        HwBlob _hidl_blob = parcel.readBuffer(16);
+        int _hidl_vec_size = _hidl_blob.getInt32(8);
+        HwBlob childBlob = parcel.readEmbeddedBuffer((long) (_hidl_vec_size * 20), _hidl_blob.handle(), 0, true);
+        _hidl_vec.clear();
+        for (int _hidl_index_0 = 0; _hidl_index_0 < _hidl_vec_size; _hidl_index_0++) {
+            BatteryProperties _hidl_vec_element = new BatteryProperties();
+            _hidl_vec_element.readEmbeddedFromParcel(parcel, childBlob, (long) (_hidl_index_0 * 20));
+            _hidl_vec.add(_hidl_vec_element);
+        }
+        return _hidl_vec;
+    }
+
+    public final void readEmbeddedFromParcel(HwParcel parcel, HwBlob _hidl_blob, long _hidl_offset) {
+        this.modLevel = _hidl_blob.getInt32(0 + _hidl_offset);
+        this.modStatus = _hidl_blob.getInt32(4 + _hidl_offset);
+        this.modFlag = _hidl_blob.getInt32(8 + _hidl_offset);
+        this.modType = _hidl_blob.getInt32(12 + _hidl_offset);
+        this.modPowerSource = _hidl_blob.getInt32(16 + _hidl_offset);
+    }
+
+    public final void writeToParcel(HwParcel parcel) {
+        HwBlob _hidl_blob = new HwBlob(20);
+        writeEmbeddedToBlob(_hidl_blob, 0);
+        parcel.writeBuffer(_hidl_blob);
+    }
+
+    public static final void writeVectorToParcel(HwParcel parcel, ArrayList<BatteryProperties> _hidl_vec) {
+        HwBlob _hidl_blob = new HwBlob(16);
+        int _hidl_vec_size = _hidl_vec.size();
+        _hidl_blob.putInt32(8, _hidl_vec_size);
+        int _hidl_index_0 = 0;
+        _hidl_blob.putBool(12, false);
+        HwBlob childBlob = new HwBlob(_hidl_vec_size * 20);
+        while (_hidl_index_0 < _hidl_vec_size) {
+            ((BatteryProperties) _hidl_vec.get(_hidl_index_0)).writeEmbeddedToBlob(childBlob, (long) (_hidl_index_0 * 20));
+            _hidl_index_0++;
+        }
+        _hidl_blob.putBlob(0, childBlob);
+        parcel.writeBuffer(_hidl_blob);
+    }
+
+    public final void writeEmbeddedToBlob(HwBlob _hidl_blob, long _hidl_offset) {
+        _hidl_blob.putInt32(0 + _hidl_offset, this.modLevel);
+        _hidl_blob.putInt32(4 + _hidl_offset, this.modStatus);
+        _hidl_blob.putInt32(8 + _hidl_offset, this.modFlag);
+        _hidl_blob.putInt32(12 + _hidl_offset, this.modType);
+        _hidl_blob.putInt32(16 + _hidl_offset, this.modPowerSource);
+    }
+}
diff --git a/services/core/java/motorola/hardware/health/V1_0/IMotHealth.java b/services/core/java/motorola/hardware/health/V1_0/IMotHealth.java
new file mode 100644
index 00000000000..a5473607cc8
--- /dev/null
+++ b/services/core/java/motorola/hardware/health/V1_0/IMotHealth.java
@@ -0,0 +1,511 @@
+package motorola.hardware.health.V1_0;
+
+import android.hidl.base.V1_0.DebugInfo;
+import android.hidl.base.V1_0.IBase;
+import android.os.HidlSupport;
+import android.os.HwBinder;
+import android.os.HwBlob;
+import android.os.HwParcel;
+import android.os.IHwBinder;
+import android.os.IHwBinder.DeathRecipient;
+import android.os.IHwInterface;
+import android.os.RemoteException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.Objects;
+
+public interface IMotHealth extends IBase {
+    public static final String kInterfaceName = "motorola.hardware.health@1.0::IMotHealth";
+
+    public static final class Proxy implements IMotHealth {
+        private IHwBinder mRemote;
+
+        public Proxy(IHwBinder remote) {
+            this.mRemote = (IHwBinder) Objects.requireNonNull(remote);
+        }
+
+        public IHwBinder asBinder() {
+            return this.mRemote;
+        }
+
+        public String toString() {
+            try {
+                StringBuilder stringBuilder = new StringBuilder();
+                stringBuilder.append(interfaceDescriptor());
+                stringBuilder.append("@Proxy");
+                return stringBuilder.toString();
+            } catch (RemoteException e) {
+                return "[class or subclass of motorola.hardware.health@1.0::IMotHealth]@Proxy";
+            }
+        }
+
+        public final boolean equals(Object other) {
+            return HidlSupport.interfacesEqual(this, other);
+        }
+
+        public final int hashCode() {
+            return asBinder().hashCode();
+        }
+
+        public int getChargeFull() throws RemoteException {
+            HwParcel _hidl_request = new HwParcel();
+            _hidl_request.writeInterfaceToken(IMotHealth.kInterfaceName);
+            HwParcel _hidl_reply = new HwParcel();
+            try {
+                this.mRemote.transact(1, _hidl_request, _hidl_reply, 0);
+                _hidl_reply.verifySuccess();
+                _hidl_request.releaseTemporaryStorage();
+                int _hidl_out_value = _hidl_reply.readInt32();
+                return _hidl_out_value;
+            } finally {
+                _hidl_reply.release();
+            }
+        }
+
+        public BatteryProperties getModBatteryProperties() throws RemoteException {
+            HwParcel _hidl_request = new HwParcel();
+            _hidl_request.writeInterfaceToken(IMotHealth.kInterfaceName);
+            HwParcel _hidl_reply = new HwParcel();
+            try {
+                this.mRemote.transact(2, _hidl_request, _hidl_reply, 0);
+                _hidl_reply.verifySuccess();
+                _hidl_request.releaseTemporaryStorage();
+                BatteryProperties _hidl_out_props = new BatteryProperties();
+                _hidl_out_props.readFromParcel(_hidl_reply);
+                return _hidl_out_props;
+            } finally {
+                _hidl_reply.release();
+            }
+        }
+
+        public ArrayList<String> interfaceChain() throws RemoteException {
+            HwParcel _hidl_request = new HwParcel();
+            _hidl_request.writeInterfaceToken(IBase.kInterfaceName);
+            HwParcel _hidl_reply = new HwParcel();
+            try {
+                this.mRemote.transact(256067662, _hidl_request, _hidl_reply, 0);
+                _hidl_reply.verifySuccess();
+                _hidl_request.releaseTemporaryStorage();
+                ArrayList<String> _hidl_out_descriptors = _hidl_reply.readStringVector();
+                return _hidl_out_descriptors;
+            } finally {
+                _hidl_reply.release();
+            }
+        }
+
+        public String interfaceDescriptor() throws RemoteException {
+            HwParcel _hidl_request = new HwParcel();
+            _hidl_request.writeInterfaceToken(IBase.kInterfaceName);
+            HwParcel _hidl_reply = new HwParcel();
+            try {
+                this.mRemote.transact(256136003, _hidl_request, _hidl_reply, 0);
+                _hidl_reply.verifySuccess();
+                _hidl_request.releaseTemporaryStorage();
+                String _hidl_out_descriptor = _hidl_reply.readString();
+                return _hidl_out_descriptor;
+            } finally {
+                _hidl_reply.release();
+            }
+        }
+
+        public ArrayList<byte[]> getHashChain() throws RemoteException {
+            HwParcel _hidl_request = new HwParcel();
+            _hidl_request.writeInterfaceToken(IBase.kInterfaceName);
+            HwParcel _hidl_reply = new HwParcel();
+            try {
+                int _hidl_index_0 = 0;
+                this.mRemote.transact(256398152, _hidl_request, _hidl_reply, 0);
+                _hidl_reply.verifySuccess();
+                _hidl_request.releaseTemporaryStorage();
+                ArrayList<byte[]> _hidl_out_hashchain = new ArrayList();
+                HwBlob _hidl_blob = _hidl_reply.readBuffer(16);
+                int _hidl_vec_size = _hidl_blob.getInt32(8);
+                HwBlob childBlob = _hidl_reply.readEmbeddedBuffer((long) (_hidl_vec_size * 32), _hidl_blob.handle(), 0, true);
+                _hidl_out_hashchain.clear();
+                while (true) {
+                    int _hidl_index_02 = _hidl_index_0;
+                    if (_hidl_index_02 >= _hidl_vec_size) {
+                        break;
+                    }
+                    byte[] _hidl_vec_element = new byte[32];
+                    childBlob.copyToInt8Array((long) (_hidl_index_02 * 32), _hidl_vec_element, 32);
+                    _hidl_out_hashchain.add(_hidl_vec_element);
+                    _hidl_index_0 = _hidl_index_02 + 1;
+                }
+                return _hidl_out_hashchain;
+            } finally {
+                _hidl_reply.release();
+            }
+        }
+
+        public void setHALInstrumentation() throws RemoteException {
+            HwParcel _hidl_request = new HwParcel();
+            _hidl_request.writeInterfaceToken(IBase.kInterfaceName);
+            HwParcel _hidl_reply = new HwParcel();
+            try {
+                this.mRemote.transact(256462420, _hidl_request, _hidl_reply, 1);
+                _hidl_request.releaseTemporaryStorage();
+            } finally {
+                _hidl_reply.release();
+            }
+        }
+
+        public boolean linkToDeath(DeathRecipient recipient, long cookie) throws RemoteException {
+            return this.mRemote.linkToDeath(recipient, cookie);
+        }
+
+        public void ping() throws RemoteException {
+            HwParcel _hidl_request = new HwParcel();
+            _hidl_request.writeInterfaceToken(IBase.kInterfaceName);
+            HwParcel _hidl_reply = new HwParcel();
+            try {
+                this.mRemote.transact(256921159, _hidl_request, _hidl_reply, 0);
+                _hidl_reply.verifySuccess();
+                _hidl_request.releaseTemporaryStorage();
+            } finally {
+                _hidl_reply.release();
+            }
+        }
+
+        public DebugInfo getDebugInfo() throws RemoteException {
+            HwParcel _hidl_request = new HwParcel();
+            _hidl_request.writeInterfaceToken(IBase.kInterfaceName);
+            HwParcel _hidl_reply = new HwParcel();
+            try {
+                this.mRemote.transact(257049926, _hidl_request, _hidl_reply, 0);
+                _hidl_reply.verifySuccess();
+                _hidl_request.releaseTemporaryStorage();
+                DebugInfo _hidl_out_info = new DebugInfo();
+                _hidl_out_info.readFromParcel(_hidl_reply);
+                return _hidl_out_info;
+            } finally {
+                _hidl_reply.release();
+            }
+        }
+
+        public void notifySyspropsChanged() throws RemoteException {
+            HwParcel _hidl_request = new HwParcel();
+            _hidl_request.writeInterfaceToken(IBase.kInterfaceName);
+            HwParcel _hidl_reply = new HwParcel();
+            try {
+                this.mRemote.transact(257120595, _hidl_request, _hidl_reply, 1);
+                _hidl_request.releaseTemporaryStorage();
+            } finally {
+                _hidl_reply.release();
+            }
+        }
+
+        public boolean unlinkToDeath(DeathRecipient recipient) throws RemoteException {
+            return this.mRemote.unlinkToDeath(recipient);
+        }
+    }
+
+    public static abstract class Stub extends HwBinder implements IMotHealth {
+        public IHwBinder asBinder() {
+            return this;
+        }
+
+        public final ArrayList<String> interfaceChain() {
+            return new ArrayList(Arrays.asList(new String[]{IMotHealth.kInterfaceName, IBase.kInterfaceName}));
+        }
+
+        public final String interfaceDescriptor() {
+            return IMotHealth.kInterfaceName;
+        }
+
+        public final ArrayList<byte[]> getHashChain() {
+            return new ArrayList(Arrays.asList(new byte[][]{new byte[]{(byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0}, new byte[]{(byte) -67, (byte) -38, (byte) -74, (byte) 24, (byte) 77, (byte) 122, (byte) 52, (byte) 109, (byte) -90, (byte) -96, (byte) 125, (byte) -64, (byte) -126, (byte) -116, (byte) -15, (byte) -102, (byte) 105, (byte) 111, (byte) 76, (byte) -86, (byte) 54, (byte) 17, (byte) -59, (byte) 31, (byte) 46, (byte) 20, (byte) 86, (byte) 90, (byte) 20, (byte) -76, (byte) 15, (byte) -39}}));
+        }
+
+        public final void setHALInstrumentation() {
+        }
+
+        public final boolean linkToDeath(DeathRecipient recipient, long cookie) {
+            return true;
+        }
+
+        public final void ping() {
+        }
+
+        public final DebugInfo getDebugInfo() {
+            DebugInfo info = new DebugInfo();
+            info.pid = HidlSupport.getPidIfSharable();
+            info.ptr = 0;
+            info.arch = 0;
+            return info;
+        }
+
+        public final void notifySyspropsChanged() {
+            HwBinder.enableInstrumentation();
+        }
+
+        public final boolean unlinkToDeath(DeathRecipient recipient) {
+            return true;
+        }
+
+        public IHwInterface queryLocalInterface(String descriptor) {
+            if (IMotHealth.kInterfaceName.equals(descriptor)) {
+                return this;
+            }
+            return null;
+        }
+
+        public void registerAsService(String serviceName) throws RemoteException {
+            registerService(serviceName);
+        }
+
+        public String toString() {
+            StringBuilder stringBuilder = new StringBuilder();
+            stringBuilder.append(interfaceDescriptor());
+            stringBuilder.append("@Stub");
+            return stringBuilder.toString();
+        }
+
+        public void onTransact(int _hidl_code, HwParcel _hidl_request, HwParcel _hidl_reply, int _hidl_flags) throws RemoteException {
+            int _hidl_is_oneway = 0;
+            boolean _hidl_is_oneway2 = true;
+            boolean _hidl_is_oneway3 = false;
+            switch (_hidl_code) {
+                case 1:
+                    if ((_hidl_flags & 1) == 0) {
+                        _hidl_is_oneway2 = false;
+                    }
+                    if (_hidl_is_oneway2) {
+                        _hidl_reply.writeStatus(Integer.MIN_VALUE);
+                        _hidl_reply.send();
+                        return;
+                    }
+                    _hidl_request.enforceInterface(IMotHealth.kInterfaceName);
+                    int _hidl_out_value = getChargeFull();
+                    _hidl_reply.writeStatus(0);
+                    _hidl_reply.writeInt32(_hidl_out_value);
+                    _hidl_reply.send();
+                    return;
+                case 2:
+                    if ((_hidl_flags & 1) == 0) {
+                        _hidl_is_oneway2 = false;
+                    }
+                    if (_hidl_is_oneway2) {
+                        _hidl_reply.writeStatus(Integer.MIN_VALUE);
+                        _hidl_reply.send();
+                        return;
+                    }
+                    _hidl_request.enforceInterface(IMotHealth.kInterfaceName);
+                    BatteryProperties _hidl_out_props = getModBatteryProperties();
+                    _hidl_reply.writeStatus(0);
+                    _hidl_out_props.writeToParcel(_hidl_reply);
+                    _hidl_reply.send();
+                    return;
+                case 256067662:
+                    if ((_hidl_flags & 1) == 0) {
+                        _hidl_is_oneway2 = false;
+                    }
+                    if (_hidl_is_oneway2) {
+                        _hidl_reply.writeStatus(Integer.MIN_VALUE);
+                        _hidl_reply.send();
+                        return;
+                    }
+                    _hidl_request.enforceInterface(IBase.kInterfaceName);
+                    ArrayList _hidl_out_descriptors = interfaceChain();
+                    _hidl_reply.writeStatus(0);
+                    _hidl_reply.writeStringVector(_hidl_out_descriptors);
+                    _hidl_reply.send();
+                    return;
+                case 256131655:
+                    if ((_hidl_flags & 1) == 0) {
+                        _hidl_is_oneway2 = false;
+                    }
+                    if (_hidl_is_oneway2) {
+                        _hidl_reply.writeStatus(Integer.MIN_VALUE);
+                        _hidl_reply.send();
+                        return;
+                    }
+                    _hidl_request.enforceInterface(IBase.kInterfaceName);
+                    _hidl_reply.writeStatus(0);
+                    _hidl_reply.send();
+                    return;
+                case 256136003:
+                    if ((_hidl_flags & 1) == 0) {
+                        _hidl_is_oneway2 = false;
+                    }
+                    if (_hidl_is_oneway2) {
+                        _hidl_reply.writeStatus(Integer.MIN_VALUE);
+                        _hidl_reply.send();
+                        return;
+                    }
+                    _hidl_request.enforceInterface(IBase.kInterfaceName);
+                    String _hidl_out_descriptor = interfaceDescriptor();
+                    _hidl_reply.writeStatus(0);
+                    _hidl_reply.writeString(_hidl_out_descriptor);
+                    _hidl_reply.send();
+                    return;
+                case 256398152:
+                    if ((_hidl_flags & 1) == 0) {
+                        _hidl_is_oneway2 = false;
+                    }
+                    if (_hidl_is_oneway2) {
+                        _hidl_reply.writeStatus(Integer.MIN_VALUE);
+                        _hidl_reply.send();
+                        return;
+                    }
+                    _hidl_request.enforceInterface(IBase.kInterfaceName);
+                    ArrayList<byte[]> _hidl_out_hashchain = getHashChain();
+                    _hidl_reply.writeStatus(0);
+                    HwBlob _hidl_blob = new HwBlob(16);
+                    int _hidl_vec_size = _hidl_out_hashchain.size();
+                    _hidl_blob.putInt32(8, _hidl_vec_size);
+                    _hidl_blob.putBool(12, false);
+                    HwBlob childBlob = new HwBlob(_hidl_vec_size * 32);
+                    while (_hidl_is_oneway < _hidl_vec_size) {
+                        childBlob.putInt8Array((long) (_hidl_is_oneway * 32), (byte[]) _hidl_out_hashchain.get(_hidl_is_oneway));
+                        _hidl_is_oneway++;
+                    }
+                    _hidl_blob.putBlob(0, childBlob);
+                    _hidl_reply.writeBuffer(_hidl_blob);
+                    _hidl_reply.send();
+                    return;
+                case 256462420:
+                    if ((_hidl_flags & 1) != 0) {
+                        _hidl_is_oneway3 = true;
+                    }
+                    if (!_hidl_is_oneway3) {
+                        _hidl_reply.writeStatus(Integer.MIN_VALUE);
+                        _hidl_reply.send();
+                        return;
+                    }
+                    _hidl_request.enforceInterface(IBase.kInterfaceName);
+                    setHALInstrumentation();
+                    return;
+                case 256660548:
+                    if ((_hidl_flags & 1) != 0) {
+                        _hidl_is_oneway3 = true;
+                    }
+                    if (_hidl_is_oneway3) {
+                        _hidl_reply.writeStatus(Integer.MIN_VALUE);
+                        _hidl_reply.send();
+                        return;
+                    }
+                    return;
+                case 256921159:
+                    if ((_hidl_flags & 1) == 0) {
+                        _hidl_is_oneway2 = false;
+                    }
+                    if (_hidl_is_oneway2) {
+                        _hidl_reply.writeStatus(Integer.MIN_VALUE);
+                        _hidl_reply.send();
+                        return;
+                    }
+                    _hidl_request.enforceInterface(IBase.kInterfaceName);
+                    ping();
+                    _hidl_reply.writeStatus(0);
+                    _hidl_reply.send();
+                    return;
+                case 257049926:
+                    if ((_hidl_flags & 1) == 0) {
+                        _hidl_is_oneway2 = false;
+                    }
+                    if (_hidl_is_oneway2) {
+                        _hidl_reply.writeStatus(Integer.MIN_VALUE);
+                        _hidl_reply.send();
+                        return;
+                    }
+                    _hidl_request.enforceInterface(IBase.kInterfaceName);
+                    DebugInfo _hidl_out_info = getDebugInfo();
+                    _hidl_reply.writeStatus(0);
+                    _hidl_out_info.writeToParcel(_hidl_reply);
+                    _hidl_reply.send();
+                    return;
+                case 257120595:
+                    if ((_hidl_flags & 1) != 0) {
+                        _hidl_is_oneway3 = true;
+                    }
+                    if (!_hidl_is_oneway3) {
+                        _hidl_reply.writeStatus(Integer.MIN_VALUE);
+                        _hidl_reply.send();
+                        return;
+                    }
+                    _hidl_request.enforceInterface(IBase.kInterfaceName);
+                    notifySyspropsChanged();
+                    return;
+                case 257250372:
+                    if ((_hidl_flags & 1) != 0) {
+                        _hidl_is_oneway3 = true;
+                    }
+                    if (_hidl_is_oneway3) {
+                        _hidl_reply.writeStatus(Integer.MIN_VALUE);
+                        _hidl_reply.send();
+                        return;
+                    }
+                    return;
+                default:
+                    return;
+            }
+        }
+    }
+
+    IHwBinder asBinder();
+
+    int getChargeFull() throws RemoteException;
+
+    DebugInfo getDebugInfo() throws RemoteException;
+
+    ArrayList<byte[]> getHashChain() throws RemoteException;
+
+    BatteryProperties getModBatteryProperties() throws RemoteException;
+
+    ArrayList<String> interfaceChain() throws RemoteException;
+
+    String interfaceDescriptor() throws RemoteException;
+
+    boolean linkToDeath(DeathRecipient deathRecipient, long j) throws RemoteException;
+
+    void notifySyspropsChanged() throws RemoteException;
+
+    void ping() throws RemoteException;
+
+    void setHALInstrumentation() throws RemoteException;
+
+    boolean unlinkToDeath(DeathRecipient deathRecipient) throws RemoteException;
+
+    static IMotHealth asInterface(IHwBinder binder) {
+        if (binder == null) {
+            return null;
+        }
+        IHwInterface iface = binder.queryLocalInterface(kInterfaceName);
+        if (iface != null && (iface instanceof IMotHealth)) {
+            return (IMotHealth) iface;
+        }
+        IMotHealth proxy = new Proxy(binder);
+        try {
+            Iterator it = proxy.interfaceChain().iterator();
+            while (it.hasNext()) {
+                if (((String) it.next()).equals(kInterfaceName)) {
+                    return proxy;
+                }
+            }
+        } catch (RemoteException e) {
+        }
+        return null;
+    }
+
+    static IMotHealth castFrom(IHwInterface iface) {
+        return iface == null ? null : asInterface(iface.asBinder());
+    }
+
+    static IMotHealth getService(String serviceName, boolean retry) throws RemoteException {
+        return asInterface(HwBinder.getService(kInterfaceName, serviceName, retry));
+    }
+
+    static IMotHealth getService(boolean retry) throws RemoteException {
+        return getService("default", retry);
+    }
+
+    static IMotHealth getService(String serviceName) throws RemoteException {
+        return asInterface(HwBinder.getService(kInterfaceName, serviceName));
+    }
+
+    static IMotHealth getService() throws RemoteException {
+        return getService("default");
+    }
+}
diff --git a/services/core/java/motorola/hardware/health/V1_0/PowerSupplyModType.java b/services/core/java/motorola/hardware/health/V1_0/PowerSupplyModType.java
new file mode 100644
index 00000000000..3f6a4f8c3ad
--- /dev/null
+++ b/services/core/java/motorola/hardware/health/V1_0/PowerSupplyModType.java
@@ -0,0 +1,54 @@
+package motorola.hardware.health.V1_0;
+
+import java.util.ArrayList;
+
+public final class PowerSupplyModType {
+    public static final int POWER_SUPPLY_MOD_TYPE_EMERGENCY = 3;
+    public static final int POWER_SUPPLY_MOD_TYPE_REMOTE = 1;
+    public static final int POWER_SUPPLY_MOD_TYPE_SUPPLEMENTAL = 2;
+    public static final int POWER_SUPPLY_MOD_TYPE_UNKNOWN = 0;
+
+    public static final String toString(int o) {
+        if (o == 0) {
+            return "POWER_SUPPLY_MOD_TYPE_UNKNOWN";
+        }
+        if (o == 1) {
+            return "POWER_SUPPLY_MOD_TYPE_REMOTE";
+        }
+        if (o == 2) {
+            return "POWER_SUPPLY_MOD_TYPE_SUPPLEMENTAL";
+        }
+        if (o == 3) {
+            return "POWER_SUPPLY_MOD_TYPE_EMERGENCY";
+        }
+        StringBuilder stringBuilder = new StringBuilder();
+        stringBuilder.append("0x");
+        stringBuilder.append(Integer.toHexString(o));
+        return stringBuilder.toString();
+    }
+
+    public static final String dumpBitfield(int o) {
+        ArrayList<String> list = new ArrayList();
+        int flipped = 0;
+        list.add("POWER_SUPPLY_MOD_TYPE_UNKNOWN");
+        if ((o & 1) == 1) {
+            list.add("POWER_SUPPLY_MOD_TYPE_REMOTE");
+            flipped = 0 | 1;
+        }
+        if ((o & 2) == 2) {
+            list.add("POWER_SUPPLY_MOD_TYPE_SUPPLEMENTAL");
+            flipped |= 2;
+        }
+        if ((o & 3) == 3) {
+            list.add("POWER_SUPPLY_MOD_TYPE_EMERGENCY");
+            flipped |= 3;
+        }
+        if (o != flipped) {
+            StringBuilder stringBuilder = new StringBuilder();
+            stringBuilder.append("0x");
+            stringBuilder.append(Integer.toHexString((~flipped) & o));
+            list.add(stringBuilder.toString());
+        }
+        return String.join(" | ", list);
+    }
+}
-- 
2.17.1

