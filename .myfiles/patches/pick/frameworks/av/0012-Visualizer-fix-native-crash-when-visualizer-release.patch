From 42aba233556284386e4fa3b448097ea2b5f85083 Mon Sep 17 00:00:00 2001
From: zengjing <zengjing@xiaomi.com>
Date: Sat, 29 Sep 2018 13:25:35 +0800
Subject: [PATCH 12/12] Visualizer: fix native crash when visualizer release

When the Visualizer effect is released, synchronous wait for the CaptureThread can
cause ANR in an app. This is why an asynchronous 'release' method is introduced which
is used by Visualizer.release() method on the Java side. Since CaptureThread may still
be running while the the last reference to the Visualizer instance is released,
CaptureThread now holds a strong reference to the Visualizer, which it releases
upon exit from the thread loop.

The 'release' method does not check for 'enabled' status because setEnabled(false)
may fail due to audioserver calling AudioFlinger::EffectHandle::setControl to
hold control.

Test: CTS VisualizerTest
Change-Id: I8d936f0f79540345d3e3675f6129bb942a08e423
Signed-off-by: zengjing <zengjing@xiaomi.com>
---
 media/libmedia/Visualizer.cpp             | 23 ++++++++++++++++++++---
 media/libmedia/include/media/Visualizer.h |  5 +++--
 2 files changed, 23 insertions(+), 5 deletions(-)

diff --git a/media/libmedia/Visualizer.cpp b/media/libmedia/Visualizer.cpp
index 4984b18b7..cb8d3750b 100644
--- a/media/libmedia/Visualizer.cpp
+++ b/media/libmedia/Visualizer.cpp
@@ -56,6 +56,19 @@ Visualizer::~Visualizer()
     setCaptureCallBack(NULL, NULL, 0, 0);
 }
 
+void Visualizer::release()
+{
+    ALOGV("Visualizer::release()");
+    setEnabled(false);
+    Mutex::Autolock _l(mCaptureLock);
+
+    mCaptureThread.clear();
+    mCaptureCallBack = NULL;
+    mCaptureCbkUser = NULL;
+    mCaptureFlags = 0;
+    mCaptureRate = 0;
+}
+
 status_t Visualizer::setEnabled(bool enabled)
 {
     Mutex::Autolock _l(mCaptureLock);
@@ -115,7 +128,7 @@ status_t Visualizer::setCaptureCallBack(capture_cbk_t cbk, void* user, uint32_t
     mCaptureRate = rate;
 
     if (cbk != NULL) {
-        mCaptureThread = new CaptureThread(*this, rate, ((flags & CAPTURE_CALL_JAVA) != 0));
+        mCaptureThread = new CaptureThread(this, rate, ((flags & CAPTURE_CALL_JAVA) != 0));
     }
     ALOGV("setCaptureCallBack() rate: %d thread %p flags 0x%08x",
             rate, mCaptureThread.get(), mCaptureFlags);
@@ -402,7 +415,7 @@ void Visualizer::controlStatusChanged(bool controlGranted) {
 
 //-------------------------------------------------------------------------
 
-Visualizer::CaptureThread::CaptureThread(Visualizer& receiver, uint32_t captureRate,
+Visualizer::CaptureThread::CaptureThread(Visualizer* receiver, uint32_t captureRate,
         bool bCanCallJava)
     : Thread(bCanCallJava), mReceiver(receiver)
 {
@@ -413,10 +426,14 @@ Visualizer::CaptureThread::CaptureThread(Visualizer& receiver, uint32_t captureR
 bool Visualizer::CaptureThread::threadLoop()
 {
     ALOGV("CaptureThread %p enter", this);
+    sp<Visualizer> receiver = mReceiver.promote();
+    if (receiver == NULL) {
+        return false;
+    }
     while (!exitPending())
     {
         usleep(mSleepTimeUs);
-        mReceiver.periodicCapture();
+        receiver->periodicCapture();
     }
     ALOGV("CaptureThread %p exiting", this);
     return false;
diff --git a/media/libmedia/include/media/Visualizer.h b/media/libmedia/include/media/Visualizer.h
index f8f4f507b..8078e369e 100644
--- a/media/libmedia/include/media/Visualizer.h
+++ b/media/libmedia/include/media/Visualizer.h
@@ -131,6 +131,7 @@ public:
     // getCaptureSize() but the length of the FFT is half of the size (both parts of the spectrum
     // are returned
     status_t getFft(uint8_t *fft);
+    void release();
 
 protected:
     // from IEffectClient
@@ -146,12 +147,12 @@ private:
     class CaptureThread : public Thread
     {
     public:
-        CaptureThread(Visualizer& receiver, uint32_t captureRate, bool bCanCallJava = false);
+        CaptureThread(Visualizer* visualizer, uint32_t captureRate, bool bCanCallJava = false);
 
     private:
         friend class Visualizer;
         virtual bool        threadLoop();
-        Visualizer& mReceiver;
+        wp<Visualizer> mReceiver;
         Mutex       mLock;
         uint32_t mSleepTimeUs;
     };
-- 
2.17.1

