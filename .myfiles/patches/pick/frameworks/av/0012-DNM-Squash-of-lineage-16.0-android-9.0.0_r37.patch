From 8a9502ffdb36c951a07043741fada416905d470d Mon Sep 17 00:00:00 2001
From: Luca Stefani <luca.stefani.ge1@gmail.com>
Date: Tue, 7 May 2019 19:51:15 +0200
Subject: [PATCH 12/12] [DNM] Squash of lineage-16.0-android-9.0.0_r37

Squashed commit of the following:

commit a24ab5c987af6e14a8e92970630f4ae19091eebd
Merge: bdd6d24fb ea5aa166f
Author: android-build-team Robot <android-build-team-robot@google.com>
Date:   Wed Mar 13 18:05:36 2019 +0000

    Merge cherrypicks of [6716922, 6716923, 6716413, 6717023, 6717024, 6716716, 6715859, 6717160, 6717161, 6717162, 6717163, 6716295, 6717141, 6717181, 6717183, 6717184, 6717185, 6714937, 6717028, 6716717, 6716927, 6717200, 6717029, 6717030, 6717031, 6717032, 6717033, 6716928, 6717034, 6717035, 6716929, 6717201, 6716930, 6712377, 6712378, 6716643, 6717164, 6712379] into pi-qpr3-release

    Change-Id: I8c4d6fee1f25241a504ee9e24ce039ab66253126

commit ea5aa166f8a0399cf1ab91b0dc864e01728e3888
Author: Ray Essick <essick@google.com>
Date:   Tue Feb 26 15:47:01 2019 -0800

    Reserve enough space for RTSP CSD

    make parameters to GetSizeWidth() reflect values being used in
    corresponding EncodeSize() invocations so we won't overflow the buffer.

    Bug: 123701862
    Test: y
    Change-Id: I78596176e6042c95582494a8ae1b9c3160bf5955
    (cherry picked from commit c025be8ce5f1b34bdf293ac367685c969bd430ba)

commit bdd6d24fb00005fded1d0bb89a7a1875010b651c
Merge: a504d888d bd6dc4645
Author: android-build-team Robot <android-build-team-robot@google.com>
Date:   Wed Feb 27 04:06:00 2019 +0000

    Snap for 5339334 from bd6dc464586edade39b3bcac6f6f0d3b2d5d1077 to pi-qpr3-release

    Change-Id: Id6e65d59c8f170c39a0d4f92615dc0bd87d1ac5f

commit bd6dc464586edade39b3bcac6f6f0d3b2d5d1077
Author: zengjing <zengjing@xiaomi.com>
Date:   Sat Sep 29 13:25:35 2018 +0800

    Visualizer: fix native crash when visualizer release

    When the Visualizer effect is released, synchronous wait for the CaptureThread can
    cause ANR in an app. This is why an asynchronous 'release' method is introduced which
    is used by Visualizer.release() method on the Java side. Since CaptureThread may still
    be running while the the last reference to the Visualizer instance is released,
    CaptureThread now holds a strong reference to the Visualizer, which it releases
    upon exit from the thread loop.

    The 'release' method does not check for 'enabled' status because setEnabled(false)
    may fail due to audioserver calling AudioFlinger::EffectHandle::setControl to
    hold control.

    Bug: 124833084
    Test: CTS VisualizerTest
    Change-Id: I8d936f0f79540345d3e3675f6129bb942a08e423
    Merged-In: I8d936f0f79540345d3e3675f6129bb942a08e423
    Signed-off-by: zengjing <zengjing@xiaomi.com>

commit a504d888d4cc53d8067bb67f9d7f1c063ca54a93
Merge: 06c5d5353 b6a54df73
Author: Andy Hung <hunga@google.com>
Date:   Fri Jan 11 11:19:34 2019 -0800

    AudioFlinger: put effect desc lookup under mutex for createEffect am: a41770b682 am: ef52b30f9c
    am: b6a54df739

    Change-Id: I26faa1f350066134fcb13cbc7b03b33ff3b9374f

commit b6a54df739810e5f963b7357c7e79ff72188a4b2
Merge: 31a8d4407 ef52b30f9
Author: Andy Hung <hunga@google.com>
Date:   Fri Jan 11 11:10:17 2019 -0800

    AudioFlinger: put effect desc lookup under mutex for createEffect am: a41770b682
    am: ef52b30f9c

    Change-Id: Ibdaceaa5cf8934a531e68d6f0d74d52d9b67200c

commit ef52b30f9cc947ce2bbfcdab59e33bccb967d5df
Merge: 093bba3a2 a41770b68
Author: Andy Hung <hunga@google.com>
Date:   Fri Jan 11 11:01:11 2019 -0800

    AudioFlinger: put effect desc lookup under mutex for createEffect
    am: a41770b682

    Change-Id: I496c058113e7f5b36d049cca1a978e191b987142

commit a41770b682117fdfc20236fbc45d975099f9147a
Author: Andy Hung <hunga@google.com>
Date:   Thu Jan 10 13:27:31 2019 -0800

    AudioFlinger: put effect desc lookup under mutex for createEffect

    Test: native poc
    Bug: 122309228
    Change-Id: I48333c69f5c1b1bf1b98f57eb813ec39e074f3a7
    Merged-In: I9d339a7d6d81161065e1adaf427dd2d3430436c2

commit 06c5d535332898944d627b6e114d1f39ae3e6c86
Author: Mikhail Naganov <mnaganov@google.com>
Date:   Fri Dec 14 10:48:17 2018 -0800

    audioserver: Use '_exit' instead of 'exit' in HalDeathHandler

    Using 'exit' from an RPC threadpool thread is not safe, as 'exit'
    runs atexit handlers that destroy global objects. This can interfere
    with code still running on other threads.

    '_exit' does not run atexit handlers, just terminates the process.

    Bug: 116665972
    Test: kill android.hardware.audio@2.0-service, check logcat
    Change-Id: I5391a659e359e0ca5bba580f1c51dea5df3ea562
    (cherry picked from commit 5beb4810060cda2afea1c89f98caf5c337763c0a)

commit 77f8cbf779fdfb4b0189617983e52bf87a77baf9
Merge: 8080a75d1 31a8d4407
Author: Phil Burk <philburk@google.com>
Date:   Thu Jan 3 15:00:03 2019 -0800

    [automerger skipped] RESTRICT AUTOMERGE: aaudio: improve test_atomic_fifo
    am: 31a8d44075 -s ours
    am skip reason: subject contains skip directive

    Change-Id: I9d76f28e8613e6747733ac8722c8ed3170b6eb25

commit 8080a75d1de71554048689ddb0d24a3d62ddd73b
Merge: 23cb3afb4 d1fc53ca8
Author: Phil Burk <philburk@google.com>
Date:   Thu Jan 3 14:59:43 2019 -0800

    [automerger skipped] RESTRICT AUTOMERGE: aaudio: Fix converting negative FIFO counters to index
    am: d1fc53ca84 -s ours
    am skip reason: subject contains skip directive

    Change-Id: Ic460f91b80a5a5c77309e006a07e5546a3841705

commit 23cb3afb48136e833c721024c955a1d3570af158
Merge: 63fa96e59 685607be8
Author: Phil Burk <philburk@google.com>
Date:   Thu Jan 3 14:59:16 2019 -0800

    [automerger skipped] RESTRICT AUTOMERGE: aaudio: fix FIFO wrapround frame counts
    am: 685607be81 -s ours
    am skip reason: subject contains skip directive

    Change-Id: I752d73ca01f173c26def655f4661d1af8e1e9d68

commit 63fa96e59d959192fbd5b688dbac7a71bbbb4616
Merge: 88a689308 fcdc02782
Author: Bryan Ferris <bferris@google.com>
Date:   Thu Jan 3 22:45:50 2019 +0000

    Merge "RESTRICT AUTOMERGE: aaudio: improve test_atomic_fifo" into pi-dev

commit 88a6893083e80feabc37281dc661c8ad41e0d2fb
Merge: 4339a80b5 f4f814276
Author: Bryan Ferris <bferris@google.com>
Date:   Thu Jan 3 22:45:46 2019 +0000

    Merge "RESTRICT AUTOMERGE: aaudio: Fix converting negative FIFO counters to index" into pi-dev

commit 31a8d44075f37f75d5912d79a43d777587b2d695
Author: Phil Burk <philburk@google.com>
Date:   Mon Dec 3 10:10:21 2018 -0800

    RESTRICT AUTOMERGE: aaudio: improve test_atomic_fifo

    Check for the effects of setting a bogus counter.
    Check for writes to memory surrounding the FIFO.
    Check for negative array indices.

    Bug: 120789744
    Test: this is a test
    Change-Id: Ia30cdef7f9d60f0a98b9af964cb3b3159df37dc9

commit d1fc53ca84b3d8d074fb27e192dea8204c1fb221
Author: Phil Burk <philburk@google.com>
Date:   Mon Dec 3 14:16:46 2018 -0800

    RESTRICT AUTOMERGE: aaudio: Fix converting negative FIFO counters to index

    The index into the FIFO is calculated by using:

        counter % capacity

    But the counter is signed and when it is negative the
    modulo can have a negative result. That can cause
    a negative array index and an access out of bounds.

    This is not normally a problem because the counter
    is 64 bits and it will not overflow until the audio
    has run for a few million years. But a hacker might
    be able to modify this internal counter and force
    an error.

    The solution involves casting to a uint64_t before doing
    the modulo.

    Note that there may still be a discontinuity when the
    counter wraps from -1 to 0. But that will not result
    in an out-of-bounds access. It may cause a noise but
    an app could simply create a noise directly. So that is
    not considered an exploit.

    Bug: 120789744
    Test: test_atomic_fifo.cpp
    Change-Id: I6fe57bcb44528d29b5edb817c592e5e9a8aaf8eb

commit fcdc02782c939aac336da48f8859ba1dccae3806
Author: Phil Burk <philburk@google.com>
Date:   Mon Dec 3 10:10:21 2018 -0800

    RESTRICT AUTOMERGE: aaudio: improve test_atomic_fifo

    Check for the effects of setting a bogus counter.
    Check for writes to memory surrounding the FIFO.
    Check for negative array indices.

    Bug: 120789744
    Test: this is a test
    Change-Id: Ia30cdef7f9d60f0a98b9af964cb3b3159df37dc9

commit 685607be811e6d5fffc407d71a2703de9c351969
Author: Phil Burk <philburk@google.com>
Date:   Fri Apr 20 17:24:38 2018 -0700

    RESTRICT AUTOMERGE: aaudio: fix FIFO wrapround frame counts

    The number of frames in the second part was incorrect
    when it wrapped past the end of the FIFO.

    Bug: 78139448
    Bug: 120789744
    Test: adb shell aaudio_loopback -c2 -C2 -tm -m2 -Pl -pn
    Change-Id: Ib6a22f30f0ee5321444c6d6137d9488943c34f3d

commit f4f81427681d2a736fc9b783dd967bc0661cca73
Author: Phil Burk <philburk@google.com>
Date:   Mon Dec 3 14:16:46 2018 -0800

    RESTRICT AUTOMERGE: aaudio: Fix converting negative FIFO counters to index

    The index into the FIFO is calculated by using:

        counter % capacity

    But the counter is signed and when it is negative the
    modulo can have a negative result. That can cause
    a negative array index and an access out of bounds.

    This is not normally a problem because the counter
    is 64 bits and it will not overflow until the audio
    has run for a few million years. But a hacker might
    be able to modify this internal counter and force
    an error.

    The solution involves casting to a uint64_t before doing
    the modulo.

    Note that there may still be a discontinuity when the
    counter wraps from -1 to 0. But that will not result
    in an out-of-bounds access. It may cause a noise but
    an app could simply create a noise directly. So that is
    not considered an exploit.

    Bug: 120789744
    Test: test_atomic_fifo.cpp
    Change-Id: I6fe57bcb44528d29b5edb817c592e5e9a8aaf8eb

commit 4339a80b5a1722bfc7d4103388d082957b7de38e
Author: Pawin Vongmasa <pawin@google.com>
Date:   Tue Aug 21 13:49:35 2018 -0700

    Relax error handling in MediaCodecsXmlParser

    Test: m stagefright && adb sync && adb shell stagefright -p

    Bug: 111892331
    Bug: 117647173
    Change-Id: I5febae71d18d5085232a0d1375e497e7386f1c81
    Merged-In: I5febae71d18d5085232a0d1375e497e7386f1c81

commit b7afce9ef7d9c4cd5181501447663921617f560e
Author: Nobuaki Tanaka <nobuaki.xb.tanaka@sony.com>
Date:   Wed Sep 12 16:22:17 2018 +0900

    Support to play the various tones as per the Indian standard

    To play the following tones as per Indian standards.
     - Dial tone
     - Busy tone
     - Congestion tone
     - Call waiting tone
     - Ringing tone

    Bug: 117161543
    Bug: 118655632
    Test: Play each tone in indian locale

    (cherry picked from commit f4a4005adb8340b2883d0b6771bcebac5c9c75b5)

    Change-Id: I6358b18bf23fa21b6fd0a6e3ff4d296b2df6e69d

Change-Id: I3eb6d492f03ab8a340d57711308b6e8381bdef3d
---
 media/libstagefright/rtsp/APacketSource.cpp   |   4 +-
 .../xmlparser/MediaCodecsXmlParser.cpp        | 183 ++++++++++--------
 2 files changed, 101 insertions(+), 86 deletions(-)

diff --git a/media/libstagefright/rtsp/APacketSource.cpp b/media/libstagefright/rtsp/APacketSource.cpp
index 201a5dfee..c5605b416 100644
--- a/media/libstagefright/rtsp/APacketSource.cpp
+++ b/media/libstagefright/rtsp/APacketSource.cpp
@@ -376,8 +376,8 @@ static sp<ABuffer> MakeMPEG4VideoCodecSpecificData(
     ALOGI("VOL dimensions = %dx%d", *width, *height);
 
     size_t len1 = config->size() + GetSizeWidth(config->size()) + 1;
-    size_t len2 = len1 + GetSizeWidth(len1) + 1 + 13;
-    size_t len3 = len2 + GetSizeWidth(len2) + 1 + 3;
+    size_t len2 = len1 + GetSizeWidth(len1 + 13) + 1 + 13;
+    size_t len3 = len2 + GetSizeWidth(len2 + 3) + 1 + 3;
 
     sp<ABuffer> csd = new ABuffer(len3);
     uint8_t *dst = csd->data();
diff --git a/media/libstagefright/xmlparser/MediaCodecsXmlParser.cpp b/media/libstagefright/xmlparser/MediaCodecsXmlParser.cpp
index ffd30eaf4..d98e123ea 100644
--- a/media/libstagefright/xmlparser/MediaCodecsXmlParser.cpp
+++ b/media/libstagefright/xmlparser/MediaCodecsXmlParser.cpp
@@ -91,18 +91,18 @@ bool parseBoolean(const char* s) {
 status_t limitFoundMissingAttr(const char* name, const char *attr, bool found = true) {
     ALOGE("limit '%s' with %s'%s' attribute", name,
             (found ? "" : "no "), attr);
-    return -EINVAL;
+    return BAD_VALUE;
 }
 
 status_t limitError(const char* name, const char *msg) {
     ALOGE("limit '%s' %s", name, msg);
-    return -EINVAL;
+    return BAD_VALUE;
 }
 
 status_t limitInvalidAttr(const char* name, const char* attr, const char* value) {
     ALOGE("limit '%s' with invalid '%s' attribute (%s)", name,
             attr, value);
-    return -EINVAL;
+    return BAD_VALUE;
 }
 
 }; // unnamed namespace
@@ -231,12 +231,12 @@ status_t MediaCodecsXmlParser::includeXMLFile(const char **attrs) {
     while (attrs[i] != nullptr) {
         if (strEq(attrs[i], "href")) {
             if (attrs[++i] == nullptr) {
-                return -EINVAL;
+                return BAD_VALUE;
             }
             href = attrs[i];
         } else {
             ALOGE("includeXMLFile: unrecognized attribute: %s", attrs[i]);
-            return -EINVAL;
+            return BAD_VALUE;
         }
         ++i;
     }
@@ -251,32 +251,32 @@ status_t MediaCodecsXmlParser::includeXMLFile(const char **attrs) {
             continue;
         }
         ALOGE("invalid include file name: %s", href);
-        return -EINVAL;
+        return BAD_VALUE;
     }
 
     std::string filename = href;
     if (filename.compare(0, 13, "media_codecs_") != 0 ||
             filename.compare(filename.size() - 4, 4, ".xml") != 0) {
         ALOGE("invalid include file name: %s", href);
-        return -EINVAL;
+        return BAD_VALUE;
     }
     filename.insert(0, mHrefBase);
 
+    status_t oldParsingStatus = mParsingStatus;
+
     parseXMLFile(filename.c_str());
-    return mParsingStatus;
+
+    status_t newParsingStatus = mParsingStatus;
+    mParsingStatus = oldParsingStatus;
+    return newParsingStatus;
 }
 
 void MediaCodecsXmlParser::startElementHandler(
         const char *name, const char **attrs) {
-    if (mParsingStatus != OK) {
-        return;
-    }
-
     bool inType = true;
 
     if (strEq(name, "Include")) {
-        mParsingStatus = includeXMLFile(attrs);
-        if (mParsingStatus == OK) {
+        if (includeXMLFile(attrs) == OK) {
             mSectionStack.push_back(mCurrentSection);
             mCurrentSection = SECTION_INCLUDE;
         }
@@ -299,7 +299,7 @@ void MediaCodecsXmlParser::startElementHandler(
         case SECTION_SETTINGS:
         {
             if (strEq(name, "Setting")) {
-                mParsingStatus = addSettingFromAttributes(attrs);
+                (void)addSettingFromAttributes(attrs);
             }
             break;
         }
@@ -307,9 +307,7 @@ void MediaCodecsXmlParser::startElementHandler(
         case SECTION_DECODERS:
         {
             if (strEq(name, "MediaCodec")) {
-                mParsingStatus =
-                    addMediaCodecFromAttributes(false /* encoder */, attrs);
-
+                (void)addMediaCodecFromAttributes(false /* encoder */, attrs);
                 mCurrentSection = SECTION_DECODER;
             }
             break;
@@ -318,9 +316,7 @@ void MediaCodecsXmlParser::startElementHandler(
         case SECTION_ENCODERS:
         {
             if (strEq(name, "MediaCodec")) {
-                mParsingStatus =
-                    addMediaCodecFromAttributes(true /* encoder */, attrs);
-
+                (void)addMediaCodecFromAttributes(true /* encoder */, attrs);
                 mCurrentSection = SECTION_ENCODER;
             }
             break;
@@ -330,9 +326,9 @@ void MediaCodecsXmlParser::startElementHandler(
         case SECTION_ENCODER:
         {
             if (strEq(name, "Quirk")) {
-                mParsingStatus = addQuirk(attrs);
+                (void)addQuirk(attrs);
             } else if (strEq(name, "Type")) {
-                mParsingStatus = addTypeFromAttributes(attrs,
+                (void)addTypeFromAttributes(attrs,
                         (mCurrentSection == SECTION_ENCODER));
                 mCurrentSection =
                         (mCurrentSection == SECTION_DECODER ?
@@ -352,9 +348,9 @@ void MediaCodecsXmlParser::startElementHandler(
                     (strEq(name, "Limit") || strEq(name, "Feature"))) {
                 ALOGW("ignoring %s specified outside of a Type", name);
             } else if (strEq(name, "Limit")) {
-                mParsingStatus = addLimit(attrs);
+                (void)addLimit(attrs);
             } else if (strEq(name, "Feature")) {
-                mParsingStatus = addFeature(attrs);
+                (void)addFeature(attrs);
             }
             break;
         }
@@ -366,10 +362,6 @@ void MediaCodecsXmlParser::startElementHandler(
 }
 
 void MediaCodecsXmlParser::endElementHandler(const char *name) {
-    if (mParsingStatus != OK) {
-        return;
-    }
-
     switch (mCurrentSection) {
         case SECTION_SETTINGS:
         {
@@ -451,31 +443,31 @@ status_t MediaCodecsXmlParser::addSettingFromAttributes(const char **attrs) {
         if (strEq(attrs[i], "name")) {
             if (attrs[++i] == nullptr) {
                 ALOGE("addSettingFromAttributes: name is null");
-                return -EINVAL;
+                return BAD_VALUE;
             }
             name = attrs[i];
         } else if (strEq(attrs[i], "value")) {
             if (attrs[++i] == nullptr) {
                 ALOGE("addSettingFromAttributes: value is null");
-                return -EINVAL;
+                return BAD_VALUE;
             }
             value = attrs[i];
         } else if (strEq(attrs[i], "update")) {
             if (attrs[++i] == nullptr) {
                 ALOGE("addSettingFromAttributes: update is null");
-                return -EINVAL;
+                return BAD_VALUE;
             }
             update = attrs[i];
         } else {
             ALOGE("addSettingFromAttributes: unrecognized attribute: %s", attrs[i]);
-            return -EINVAL;
+            return BAD_VALUE;
         }
         ++i;
     }
 
     if (name == nullptr || value == nullptr) {
         ALOGE("addSettingFromAttributes: name or value unspecified");
-        return -EINVAL;
+        return BAD_VALUE;
     }
 
     // Boolean values are converted to "0" or "1".
@@ -488,7 +480,7 @@ status_t MediaCodecsXmlParser::addSettingFromAttributes(const char **attrs) {
     if (attribute == mServiceAttributeMap.end()) { // New attribute name
         if (mUpdate) {
             ALOGE("addSettingFromAttributes: updating non-existing setting");
-            return -EINVAL;
+            return BAD_VALUE;
         }
         mServiceAttributeMap.insert(Attribute(name, value));
     } else { // Existing attribute name
@@ -512,39 +504,40 @@ status_t MediaCodecsXmlParser::addMediaCodecFromAttributes(
         if (strEq(attrs[i], "name")) {
             if (attrs[++i] == nullptr) {
                 ALOGE("addMediaCodecFromAttributes: name is null");
-                return -EINVAL;
+                return BAD_VALUE;
             }
             name = attrs[i];
         } else if (strEq(attrs[i], "type")) {
             if (attrs[++i] == nullptr) {
                 ALOGE("addMediaCodecFromAttributes: type is null");
-                return -EINVAL;
+                return BAD_VALUE;
             }
             type = attrs[i];
         } else if (strEq(attrs[i], "update")) {
             if (attrs[++i] == nullptr) {
                 ALOGE("addMediaCodecFromAttributes: update is null");
-                return -EINVAL;
+                return BAD_VALUE;
             }
             update = attrs[i];
         } else {
             ALOGE("addMediaCodecFromAttributes: unrecognized attribute: %s", attrs[i]);
-            return -EINVAL;
+            return BAD_VALUE;
         }
         ++i;
     }
 
     if (name == nullptr) {
         ALOGE("addMediaCodecFromAttributes: name not found");
-        return -EINVAL;
+        return BAD_VALUE;
     }
 
     mUpdate = (update != nullptr) && parseBoolean(update);
     mCurrentCodec = mCodecMap.find(name);
     if (mCurrentCodec == mCodecMap.end()) { // New codec name
         if (mUpdate) {
-            ALOGE("addMediaCodecFromAttributes: updating non-existing codec");
-            return -EINVAL;
+            ALOGW("addMediaCodecFromAttributes: cannot update "
+                  "non-existing codec \"%s\".", name);
+            return BAD_VALUE;
         }
         // Create a new codec in mCodecMap
         mCurrentCodec = mCodecMap.insert(
@@ -559,18 +552,26 @@ status_t MediaCodecsXmlParser::addMediaCodecFromAttributes(
         mCurrentCodec->second.order = mCodecCounter++;
     } else { // Existing codec name
         if (!mUpdate) {
-            ALOGE("addMediaCodecFromAttributes: adding existing codec");
-            return -EINVAL;
+            ALOGW("addMediaCodecFromAttributes: trying to add "
+                  "existing codec \"%s\"", name);
+            return ALREADY_EXISTS;
         }
         if (type != nullptr) {
             mCurrentType = mCurrentCodec->second.typeMap.find(type);
             if (mCurrentType == mCurrentCodec->second.typeMap.end()) {
-                ALOGE("addMediaCodecFromAttributes: updating non-existing type");
-                return -EINVAL;
+                ALOGE("addMediaCodecFromAttributes: cannot update "
+                      "non-existing type \"%s\" for codec \"%s\"",
+                        type, name);
+                return BAD_VALUE;
             }
         } else {
             // This should happen only when the codec has at most one type.
             mCurrentType = mCurrentCodec->second.typeMap.begin();
+            if (mCurrentType == mCurrentCodec->second.typeMap.end()) {
+                ALOGE("addMediaCodecFromAttributes: cannot update "
+                      "codec \"%s\" without type specified", name);
+                return BAD_VALUE;
+            }
         }
     }
 
@@ -578,6 +579,10 @@ status_t MediaCodecsXmlParser::addMediaCodecFromAttributes(
 }
 
 status_t MediaCodecsXmlParser::addQuirk(const char **attrs) {
+    if (mCurrentCodec == mCodecMap.end()) {
+        return BAD_VALUE;
+    }
+
     const char *name = nullptr;
 
     size_t i = 0;
@@ -585,19 +590,19 @@ status_t MediaCodecsXmlParser::addQuirk(const char **attrs) {
         if (strEq(attrs[i], "name")) {
             if (attrs[++i] == nullptr) {
                 ALOGE("addQuirk: name is null");
-                return -EINVAL;
+                return BAD_VALUE;
             }
             name = attrs[i];
         } else {
             ALOGE("addQuirk: unrecognized attribute: %s", attrs[i]);
-            return -EINVAL;
+            return BAD_VALUE;
         }
         ++i;
     }
 
     if (name == nullptr) {
         ALOGE("addQuirk: name not found");
-        return -EINVAL;
+        return BAD_VALUE;
     }
 
     mCurrentCodec->second.quirkSet.emplace(name);
@@ -605,6 +610,10 @@ status_t MediaCodecsXmlParser::addQuirk(const char **attrs) {
 }
 
 status_t MediaCodecsXmlParser::addTypeFromAttributes(const char **attrs, bool encoder) {
+    if (mCurrentCodec == mCodecMap.end()) {
+        return BAD_VALUE;
+    }
+
     const char *name = nullptr;
     const char *update = nullptr;
 
@@ -613,42 +622,51 @@ status_t MediaCodecsXmlParser::addTypeFromAttributes(const char **attrs, bool en
         if (strEq(attrs[i], "name")) {
             if (attrs[++i] == nullptr) {
                 ALOGE("addTypeFromAttributes: name is null");
-                return -EINVAL;
+                return BAD_VALUE;
             }
             name = attrs[i];
         } else if (strEq(attrs[i], "update")) {
             if (attrs[++i] == nullptr) {
                 ALOGE("addTypeFromAttributes: update is null");
-                return -EINVAL;
+                return BAD_VALUE;
             }
             update = attrs[i];
         } else {
             ALOGE("addTypeFromAttributes: unrecognized attribute: %s", attrs[i]);
-            return -EINVAL;
+            return BAD_VALUE;
         }
         ++i;
     }
 
     if (name == nullptr) {
-        return -EINVAL;
+        return BAD_VALUE;
     }
 
     mCurrentCodec->second.isEncoder = encoder;
     mCurrentType = mCurrentCodec->second.typeMap.find(name);
     if (!mUpdate) {
         if (mCurrentType != mCurrentCodec->second.typeMap.end()) {
-            ALOGE("addTypeFromAttributes: re-defining existing type without update");
-            return -EINVAL;
+            ALOGW("addTypeFromAttributes: trying to update "
+                  "existing type \"%s\"", name);
+            return ALREADY_EXISTS;
         }
         mCurrentType = mCurrentCodec->second.typeMap.insert(
                 Type(name, AttributeMap())).first;
     } else if (mCurrentType == mCurrentCodec->second.typeMap.end()) {
         ALOGE("addTypeFromAttributes: updating non-existing type");
+        return BAD_VALUE;
     }
     return OK;
 }
 
 status_t MediaCodecsXmlParser::addLimit(const char **attrs) {
+    if (mCurrentCodec == mCodecMap.end()) {
+        return BAD_VALUE;
+    }
+    if (mCurrentType == mCurrentCodec->second.typeMap.end()) {
+        return BAD_VALUE;
+    }
+
     const char* a_name = nullptr;
     const char* a_default = nullptr;
     const char* a_in = nullptr;
@@ -664,78 +682,73 @@ status_t MediaCodecsXmlParser::addLimit(const char **attrs) {
         if (strEq(attrs[i], "name")) {
             if (attrs[++i] == nullptr) {
                 ALOGE("addLimit: name is null");
-                return -EINVAL;
+                return BAD_VALUE;
             }
             a_name = attrs[i];
         } else if (strEq(attrs[i], "default")) {
             if (attrs[++i] == nullptr) {
                 ALOGE("addLimit: default is null");
-                return -EINVAL;
+                return BAD_VALUE;
             }
             a_default = attrs[i];
         } else if (strEq(attrs[i], "in")) {
             if (attrs[++i] == nullptr) {
                 ALOGE("addLimit: in is null");
-                return -EINVAL;
+                return BAD_VALUE;
             }
             a_in = attrs[i];
         } else if (strEq(attrs[i], "max")) {
             if (attrs[++i] == nullptr) {
                 ALOGE("addLimit: max is null");
-                return -EINVAL;
+                return BAD_VALUE;
             }
             a_max = attrs[i];
         } else if (strEq(attrs[i], "min")) {
             if (attrs[++i] == nullptr) {
                 ALOGE("addLimit: min is null");
-                return -EINVAL;
+                return BAD_VALUE;
             }
             a_min = attrs[i];
         } else if (strEq(attrs[i], "range")) {
             if (attrs[++i] == nullptr) {
                 ALOGE("addLimit: range is null");
-                return -EINVAL;
+                return BAD_VALUE;
             }
             a_range = attrs[i];
         } else if (strEq(attrs[i], "ranges")) {
             if (attrs[++i] == nullptr) {
                 ALOGE("addLimit: ranges is null");
-                return -EINVAL;
+                return BAD_VALUE;
             }
             a_ranges = attrs[i];
         } else if (strEq(attrs[i], "scale")) {
             if (attrs[++i] == nullptr) {
                 ALOGE("addLimit: scale is null");
-                return -EINVAL;
+                return BAD_VALUE;
             }
             a_scale = attrs[i];
         } else if (strEq(attrs[i], "value")) {
             if (attrs[++i] == nullptr) {
                 ALOGE("addLimit: value is null");
-                return -EINVAL;
+                return BAD_VALUE;
             }
             a_value = attrs[i];
         } else {
             ALOGE("addLimit: unrecognized limit: %s", attrs[i]);
-            return -EINVAL;
+            return BAD_VALUE;
         }
         ++i;
     }
 
     if (a_name == nullptr) {
         ALOGE("limit with no 'name' attribute");
-        return -EINVAL;
+        return BAD_VALUE;
     }
 
     // size, blocks, bitrate, frame-rate, blocks-per-second, aspect-ratio,
     // measured-frame-rate, measured-blocks-per-second: range
     // quality: range + default + [scale]
     // complexity: range + default
-    if (mCurrentType == mCurrentCodec->second.typeMap.end()) {
-        ALOGW("ignoring null type");
-        return OK;
-    }
-
     std::string range;
     if (strEq(a_name, "aspect-ratio") ||
             strEq(a_name, "bitrate") ||
@@ -879,6 +892,13 @@ status_t MediaCodecsXmlParser::addLimit(const char **attrs) {
 }
 
 status_t MediaCodecsXmlParser::addFeature(const char **attrs) {
+    if (mCurrentCodec == mCodecMap.end()) {
+        return BAD_VALUE;
+    }
+    if (mCurrentType == mCurrentCodec->second.typeMap.end()) {
+        return BAD_VALUE;
+    }
+
     size_t i = 0;
     const char *name = nullptr;
     int32_t optional = -1;
@@ -889,30 +909,30 @@ status_t MediaCodecsXmlParser::addFeature(const char **attrs) {
         if (strEq(attrs[i], "name")) {
             if (attrs[++i] == nullptr) {
                 ALOGE("addFeature: name is null");
-                return -EINVAL;
+                return BAD_VALUE;
             }
             name = attrs[i];
         } else if (strEq(attrs[i], "optional")) {
             if (attrs[++i] == nullptr) {
                 ALOGE("addFeature: optional is null");
-                return -EINVAL;
+                return BAD_VALUE;
             }
             optional = parseBoolean(attrs[i]) ? 1 : 0;
         } else if (strEq(attrs[i], "required")) {
             if (attrs[++i] == nullptr) {
                 ALOGE("addFeature: required is null");
-                return -EINVAL;
+                return BAD_VALUE;
             }
             required = parseBoolean(attrs[i]) ? 1 : 0;
         } else if (strEq(attrs[i], "value")) {
             if (attrs[++i] == nullptr) {
                 ALOGE("addFeature: value is null");
-                return -EINVAL;
+                return BAD_VALUE;
             }
             value = attrs[i];
         } else {
             ALOGE("addFeature: unrecognized attribute: %s", attrs[i]);
-            return -EINVAL;
+            return BAD_VALUE;
         }
         ++i;
     }
@@ -920,23 +940,18 @@ status_t MediaCodecsXmlParser::addFeature(const char **attrs) {
     // Every feature must have a name.
     if (name == nullptr) {
         ALOGE("feature with no 'name' attribute");
-        return -EINVAL;
-    }
-
-    if (mCurrentType == mCurrentCodec->second.typeMap.end()) {
-        ALOGW("ignoring null type");
-        return OK;
+        return BAD_VALUE;
     }
 
     if ((optional != -1) || (required != -1)) {
         if (optional == required) {
             ALOGE("feature '%s' is both/neither optional and required", name);
-            return -EINVAL;
+            return BAD_VALUE;
         }
         if ((optional == 1) || (required == 1)) {
             if (value != nullptr) {
                 ALOGE("feature '%s' cannot have extra 'value'", name);
-                return -EINVAL;
+                return BAD_VALUE;
             }
             mCurrentType->second[std::string("feature-") + name] =
                     optional == 1 ? "0" : "1";
-- 
2.17.1

