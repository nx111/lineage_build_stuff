From 376a2a05edb0e6fce84fc10b05f04744c1b04165 Mon Sep 17 00:00:00 2001
From: Luca Stefani <luca.stefani.ge1@gmail.com>
Date: Tue, 5 Feb 2019 09:36:51 +0100
Subject: [PATCH 2/2] Squash of
 github/lineage-16.0(abd1297d9)..lineage-16.0-android-9.0.0_r31(721eeaf51) (DO
 NOT SUBMIT)

Ecco Park (1):
 - passpoint: skip NAI realms match in case of 3GPP element match

Etan Cohen (5):
 - [RTT] Add NPE checks for invalid MAC addresses from Aware
 - Merge "[RTT] Add NPE checks for invalid MAC addresses from Aware"
   into pi-dev
 - Add dumpsys and log messages to help debug Carrier Wi-Fi
 - Add dumpsys to help debug Carrier Wi-Fi
 - [Carrier Wi-Fi] Reset config identity on reboot or SIM in/out

Jong Wook Kim (2):
 - Log when wifi is turned on/off in metrics
 - Merge "Log when wifi is turned on/off in metrics" into pi-dev

Luca Stefani (1):
 - Merge tag 'android-9.0.0_r31' into lineage-16.0-android-9.0.0_r31

Oscar Shu (1):
 - Merge "Metrics for wifi link layer stats usage" into pi-dev

TreeHugger Robot (1):
 - Merge "Add dumpsys to help debug Carrier Wi-Fi" into pi-dev

android-build-team Robot (7):
 - Snap for 5053079 from c26d2bfdf8ff6f5049bd599349dbd46e5e053fb4 to
   pi-qpr2-release
 - Snap for 5053079 from c26d2bfdf8ff6f5049bd599349dbd46e5e053fb4 to
   pi-qpr2-release
 - Merge "Snap for 5053079 from c26d2bfdf8ff6f5049bd599349dbd46e5e053fb4
   to pi-qpr2-release" into pi-qpr2-release
 - Snap for 5066295 from f68286f2d979a3631050b09d33da84aad4644730 to
   pi-qpr2-release
 - Snap for 5115288 from 1ce443488506186656621ad28dbc5da21d2873d8 to
   pi-qpr2-release
 - Snap for 5130385 from 0a5ff7a2f1f875bb1346bcdec5926ba77a605f34 to
   pi-qpr2-release
 - Merge cherrypicks of [5656146, 5653357, 5656373, 5656227, 5656421,
   5654207, 5654208, 5654209, 5654210, 5656164, 5656412, 5656413,
   5656355, 5656356, 5656357, 5655631, 5655632, 5656165, 5656166,
   5656167, 5656168, 5656376, 5656422, 5656147, 5656148, 5656149] into
   pi-qpr2-release

xshu (1):
 - Metrics for wifi link layer stats usage

Change-Id: Iba58f90775e621754349473a5ed0bd66167817f8

Change-Id: I9b1c5bfd054c42876dd621247e236c3ea31db08a
---
 .../server/wifi/CarrierNetworkConfig.java     |  42 ++-
 .../server/wifi/WifiConfigManager.java        |  18 +-
 .../server/wifi/WifiConnectivityManager.java  |   1 +
 .../com/android/server/wifi/WifiInjector.java |   1 +
 .../com/android/server/wifi/WifiMetrics.java  |  64 +++-
 .../android/server/wifi/WifiStateMachine.java |   7 +-
 .../wifi/hotspot2/PasspointProvider.java      |  27 +-
 .../server/wifi/rtt/RttServiceImpl.java       |   8 +-
 .../android/server/wifi/WifiMetricsTest.java  |  99 +++++-
 .../server/wifi/WifiStateMachineTest.java     |  10 +
 .../wifi/hotspot2/PasspointProviderTest.java  | 294 +++++++++++++++---
 .../server/wifi/rtt/RttServiceImplTest.java   |  15 +-
 12 files changed, 506 insertions(+), 80 deletions(-)

diff --git a/service/java/com/android/server/wifi/CarrierNetworkConfig.java b/service/java/com/android/server/wifi/CarrierNetworkConfig.java
index 91e22afe1..cf39e0a7b 100644
--- a/service/java/com/android/server/wifi/CarrierNetworkConfig.java
+++ b/service/java/com/android/server/wifi/CarrierNetworkConfig.java
@@ -36,6 +36,9 @@ import android.telephony.TelephonyManager;
 import android.util.Base64;
 import android.util.Log;
 
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -52,8 +55,18 @@ public class CarrierNetworkConfig {
     private static final int CONFIG_ELEMENT_SIZE = 2;
     private static final Uri CONTENT_URI = Uri.parse("content://carrier_information/carrier");
 
+    private boolean mDbg = false;
+
     private final Map<String, NetworkInfo> mCarrierNetworkMap;
     private boolean mIsCarrierImsiEncryptionInfoAvailable = false;
+    private ImsiEncryptionInfo mLastImsiEncryptionInfo = null; // used for dumpsys only
+
+    /**
+     * Enable/disable verbose logging.
+     */
+    public void enableVerboseLogging(int verbose) {
+        mDbg = verbose > 0;
+    }
 
     public CarrierNetworkConfig(@NonNull Context context, @NonNull Looper looper,
             @NonNull FrameworkFacade framework) {
@@ -125,9 +138,9 @@ public class CarrierNetworkConfig {
             return false;
         }
         try {
-            ImsiEncryptionInfo imsiEncryptionInfo = telephonyManager
+            mLastImsiEncryptionInfo = telephonyManager
                     .getCarrierInfoForImsiEncryption(TelephonyManager.KEY_TYPE_WLAN);
-            if (imsiEncryptionInfo == null) {
+            if (mLastImsiEncryptionInfo == null) {
                 return false;
             }
         } catch (RuntimeException e) {
@@ -149,6 +162,12 @@ public class CarrierNetworkConfig {
             mEapType = eapType;
             mCarrierName = carrierName;
         }
+
+        @Override
+        public String toString() {
+            return new StringBuffer("NetworkInfo: eap=").append(mEapType).append(
+                    ", carrier=").append(mCarrierName).toString();
+        }
     }
 
     /**
@@ -203,6 +222,10 @@ public class CarrierNetworkConfig {
         }
         String[] networkConfigs = carrierConfig.getStringArray(
                 CarrierConfigManager.KEY_CARRIER_WIFI_STRING_ARRAY);
+        if (mDbg) {
+            Log.v(TAG, "processNetworkConfig: networkConfigs="
+                    + Arrays.deepToString(networkConfigs));
+        }
         if (networkConfigs == null) {
             return;
         }
@@ -224,9 +247,11 @@ public class CarrierNetworkConfig {
                 }
                 mCarrierNetworkMap.put(ssid, new NetworkInfo(eapType, carrierName));
             } catch (NumberFormatException e) {
-                Log.e(TAG, "Failed to parse EAP type: " + e.getMessage());
+                Log.e(TAG, "Failed to parse EAP type: '" + configArr[EAP_TYPE_INDEX] + "' "
+                        + e.getMessage());
             } catch (IllegalArgumentException e) {
-                Log.e(TAG, "Failed to decode SSID: " + e.getMessage());
+                Log.e(TAG, "Failed to decode SSID: '" + configArr[ENCODED_SSID_INDEX] + "' "
+                        + e.getMessage());
             }
         }
     }
@@ -249,4 +274,13 @@ public class CarrierNetworkConfig {
         }
         return -1;
     }
+
+    /** Dump state. */
+    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        pw.println(TAG + ": ");
+        pw.println("mCarrierNetworkMap=" + mCarrierNetworkMap);
+        pw.println("mIsCarrierImsiEncryptionInfoAvailable="
+                + mIsCarrierImsiEncryptionInfoAvailable);
+        pw.println("mLastImsiEncryptionInfo=" + mLastImsiEncryptionInfo);
+    }
 }
diff --git a/service/java/com/android/server/wifi/WifiConfigManager.java b/service/java/com/android/server/wifi/WifiConfigManager.java
index 0b70dbf4e..7dc938b34 100644
--- a/service/java/com/android/server/wifi/WifiConfigManager.java
+++ b/service/java/com/android/server/wifi/WifiConfigManager.java
@@ -2470,13 +2470,23 @@ public class WifiConfigManager {
                     currentIdentity = TelephonyUtil.getSimIdentity(mTelephonyManager,
                         new TelephonyUtil(), config);
                 }
+                if (mVerboseLoggingEnabled) {
+                    Log.d(TAG, "New identity for config " + config + ": " + currentIdentity);
+                }
+
                 // Update the loaded config
                 if (currentIdentity == null) {
-                    Log.d(TAG, "Identity is null");
-                    return;
+                    Log.d(TAG, "Identity is null for config:" + config);
+                    break;
                 }
-                config.enterpriseConfig.setIdentity(currentIdentity.first);
-                if (config.enterpriseConfig.getEapMethod() != WifiEnterpriseConfig.Eap.PEAP) {
+
+                if (config.enterpriseConfig.getEapMethod() == WifiEnterpriseConfig.Eap.PEAP) {
+                    config.enterpriseConfig.setIdentity(currentIdentity.first);
+                    // do not reset anonymous identity since it may be dependent on user-entry
+                    // (i.e. cannot re-request on every reboot/SIM re-entry)
+                } else {
+                    // reset identity as well: supplicant will ask us for it
+                    config.enterpriseConfig.setIdentity("");
                     config.enterpriseConfig.setAnonymousIdentity("");
                 }
             }
diff --git a/service/java/com/android/server/wifi/WifiConnectivityManager.java b/service/java/com/android/server/wifi/WifiConnectivityManager.java
index 6e07254f5..24215617e 100644
--- a/service/java/com/android/server/wifi/WifiConnectivityManager.java
+++ b/service/java/com/android/server/wifi/WifiConnectivityManager.java
@@ -1457,5 +1457,6 @@ public class WifiConnectivityManager {
         pw.println("WifiConnectivityManager - Log End ----");
         mOpenNetworkNotifier.dump(fd, pw, args);
         mCarrierNetworkNotifier.dump(fd, pw, args);
+        mCarrierNetworkConfig.dump(fd, pw, args);
     }
 }
diff --git a/service/java/com/android/server/wifi/WifiInjector.java b/service/java/com/android/server/wifi/WifiInjector.java
index dbf730a73..89a7f45b4 100644
--- a/service/java/com/android/server/wifi/WifiInjector.java
+++ b/service/java/com/android/server/wifi/WifiInjector.java
@@ -326,6 +326,7 @@ public class WifiInjector {
         mHalDeviceManager.enableVerboseLogging(verbose);
         mScanRequestProxy.enableVerboseLogging(verbose);
         mWakeupController.enableVerboseLogging(verbose);
+        mCarrierNetworkConfig.enableVerboseLogging(verbose);
         LogcatLog.enableVerboseLogging(verbose);
     }
 
diff --git a/service/java/com/android/server/wifi/WifiMetrics.java b/service/java/com/android/server/wifi/WifiMetrics.java
index 15f65c980..440754137 100644
--- a/service/java/com/android/server/wifi/WifiMetrics.java
+++ b/service/java/com/android/server/wifi/WifiMetrics.java
@@ -29,7 +29,6 @@ import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
 import android.os.SystemProperties;
-
 import android.util.Base64;
 import android.util.Log;
 import android.util.Pair;
@@ -49,6 +48,7 @@ import com.android.server.wifi.nano.WifiMetricsProto.PnoScanMetrics;
 import com.android.server.wifi.nano.WifiMetricsProto.SoftApConnectedClientsEvent;
 import com.android.server.wifi.nano.WifiMetricsProto.StaEvent;
 import com.android.server.wifi.nano.WifiMetricsProto.StaEvent.ConfigInfo;
+import com.android.server.wifi.nano.WifiMetricsProto.WifiLinkLayerUsageStats;
 import com.android.server.wifi.nano.WifiMetricsProto.WpsMetrics;
 import com.android.server.wifi.rtt.RttMetrics;
 import com.android.server.wifi.util.InformationElementUtil;
@@ -115,12 +115,14 @@ public class WifiMetrics {
     private WifiAwareMetrics mWifiAwareMetrics;
     private RttMetrics mRttMetrics;
     private final PnoScanMetrics mPnoScanMetrics = new PnoScanMetrics();
+    private final WifiLinkLayerUsageStats mWifiLinkLayerUsageStats = new WifiLinkLayerUsageStats();
     private final WpsMetrics mWpsMetrics = new WpsMetrics();
     private Handler mHandler;
     private ScoringParams mScoringParams;
     private WifiConfigManager mWifiConfigManager;
     private WifiNetworkSelector mWifiNetworkSelector;
     private PasspointManager mPasspointManager;
+    private WifiLinkLayerStats mLastLinkLayerStats;
     /**
      * Metrics are stored within an instance of the WifiLog proto during runtime,
      * The ConnectionEvent, SystemStateEntries & ScanReturnEntries metrics are stored during
@@ -483,6 +485,45 @@ public class WifiMetrics {
         mPasspointManager = passpointManager;
     }
 
+    /**
+     * Increment cumulative counters for link layer stats.
+     * @param newStats
+     */
+    public void incrementWifiLinkLayerUsageStats(WifiLinkLayerStats newStats) {
+        if (newStats == null) {
+            return;
+        }
+        if (mLastLinkLayerStats == null) {
+            mLastLinkLayerStats = newStats;
+            return;
+        }
+        if (!newLinkLayerStatsIsValid(mLastLinkLayerStats, newStats)) {
+            // This could mean the radio chip is reset or the data is incorrectly reported.
+            // Don't increment any counts and discard the possibly corrupt |newStats| completely.
+            mLastLinkLayerStats = null;
+            return;
+        }
+        mWifiLinkLayerUsageStats.loggingDurationMs +=
+                (newStats.timeStampInMs - mLastLinkLayerStats.timeStampInMs);
+        mWifiLinkLayerUsageStats.radioOnTimeMs += (newStats.on_time - mLastLinkLayerStats.on_time);
+        mWifiLinkLayerUsageStats.radioTxTimeMs += (newStats.tx_time - mLastLinkLayerStats.tx_time);
+        mWifiLinkLayerUsageStats.radioRxTimeMs += (newStats.rx_time - mLastLinkLayerStats.rx_time);
+        mWifiLinkLayerUsageStats.radioScanTimeMs +=
+                (newStats.on_time_scan - mLastLinkLayerStats.on_time_scan);
+        mLastLinkLayerStats = newStats;
+    }
+
+    private boolean newLinkLayerStatsIsValid(WifiLinkLayerStats oldStats,
+            WifiLinkLayerStats newStats) {
+        if (newStats.on_time < oldStats.on_time
+                || newStats.tx_time < oldStats.tx_time
+                || newStats.rx_time < oldStats.rx_time
+                || newStats.on_time_scan < oldStats.on_time_scan) {
+            return false;
+        }
+        return true;
+    }
+
     /**
      * Increment total number of attempts to start a pno scan
      */
@@ -2092,6 +2133,17 @@ public class WifiMetrics {
                 pw.println("mPnoScanMetrics.numPnoFoundNetworkEvents="
                         + mPnoScanMetrics.numPnoFoundNetworkEvents);
 
+                pw.println("mWifiLinkLayerUsageStats.loggingDurationMs="
+                        + mWifiLinkLayerUsageStats.loggingDurationMs);
+                pw.println("mWifiLinkLayerUsageStats.radioOnTimeMs="
+                        + mWifiLinkLayerUsageStats.radioOnTimeMs);
+                pw.println("mWifiLinkLayerUsageStats.radioTxTimeMs="
+                        + mWifiLinkLayerUsageStats.radioTxTimeMs);
+                pw.println("mWifiLinkLayerUsageStats.radioRxTimeMs="
+                        + mWifiLinkLayerUsageStats.radioRxTimeMs);
+                pw.println("mWifiLinkLayerUsageStats.radioScanTimeMs="
+                        + mWifiLinkLayerUsageStats.radioScanTimeMs);
+
                 pw.println("mWifiLogProto.connectToNetworkNotificationCount="
                         + mConnectToNetworkNotificationCount.toString());
                 pw.println("mWifiLogProto.connectToNetworkNotificationActionCount="
@@ -2433,6 +2485,7 @@ public class WifiMetrics {
             mWifiLogProto.wifiRttLog = mRttMetrics.consolidateProto();
 
             mWifiLogProto.pnoScanMetrics = mPnoScanMetrics;
+            mWifiLogProto.wifiLinkLayerUsageStats = mWifiLinkLayerUsageStats;
 
             /**
              * Convert the SparseIntArray of "Connect to Network" notification types and counts to
@@ -2597,6 +2650,7 @@ public class WifiMetrics {
             mAvailableSavedPasspointProviderProfilesInScanHistogram.clear();
             mAvailableSavedPasspointProviderBssidsInScanHistogram.clear();
             mPnoScanMetrics.clear();
+            mWifiLinkLayerUsageStats.clear();
             mConnectToNetworkNotificationCount.clear();
             mConnectToNetworkNotificationActionCount.clear();
             mNumOpenNetworkRecommendationUpdates = 0;
@@ -2739,6 +2793,8 @@ public class WifiMetrics {
             case StaEvent.TYPE_FRAMEWORK_DISCONNECT:
             case StaEvent.TYPE_SCORE_BREACH:
             case StaEvent.TYPE_MAC_CHANGE:
+            case StaEvent.TYPE_WIFI_ENABLED:
+            case StaEvent.TYPE_WIFI_DISABLED:
                 break;
             default:
                 Log.e(TAG, "Unknown StaEvent:" + type);
@@ -2934,6 +2990,12 @@ public class WifiMetrics {
             case StaEvent.TYPE_MAC_CHANGE:
                 sb.append("MAC_CHANGE");
                 break;
+            case StaEvent.TYPE_WIFI_ENABLED:
+                sb.append("WIFI_ENABLED");
+                break;
+            case StaEvent.TYPE_WIFI_DISABLED:
+                sb.append("WIFI_DISABLED");
+                break;
             default:
                 sb.append("UNKNOWN " + event.type + ":");
                 break;
diff --git a/service/java/com/android/server/wifi/WifiStateMachine.java b/service/java/com/android/server/wifi/WifiStateMachine.java
index 066afec09..d0f77d670 100644
--- a/service/java/com/android/server/wifi/WifiStateMachine.java
+++ b/service/java/com/android/server/wifi/WifiStateMachine.java
@@ -3830,6 +3830,7 @@ public class WifiStateMachine extends StateMachine {
             mWifiConnectivityManager.setWifiEnabled(true);
             // Inform metrics that Wifi is Enabled (but not yet connected)
             mWifiMetrics.setWifiState(WifiMetricsProto.WifiLog.WIFI_DISCONNECTED);
+            mWifiMetrics.logStaEvent(StaEvent.TYPE_WIFI_ENABLED);
             // Inform p2p service that wifi is up and ready when applicable
             p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
             // Inform sar manager that wifi is Enabled
@@ -3847,6 +3848,7 @@ public class WifiStateMachine extends StateMachine {
             mWifiConnectivityManager.setWifiEnabled(false);
             // Inform metrics that Wifi is being disabled (Toggled, airplane enabled, etc)
             mWifiMetrics.setWifiState(WifiMetricsProto.WifiLog.WIFI_DISABLED);
+            mWifiMetrics.logStaEvent(StaEvent.TYPE_WIFI_DISABLED);
             // Inform sar manager that wifi is being disabled
             mSarManager.setClientWifiState(WifiManager.WIFI_STATE_DISABLED);
 
@@ -4043,6 +4045,7 @@ public class WifiStateMachine extends StateMachine {
                         Pair<String, String> identityPair =
                                 TelephonyUtil.getSimIdentity(getTelephonyManager(),
                                         new TelephonyUtil(), targetWificonfiguration);
+                        Log.i(TAG, "SUP_REQUEST_IDENTITY: identityPair=" + identityPair);
                         if (identityPair != null && identityPair.first != null) {
                             mWifiNative.simIdentityResponse(mInterfaceName, netId,
                                     identityPair.first, identityPair.second);
@@ -4861,7 +4864,9 @@ public class WifiStateMachine extends StateMachine {
                     break;
                 case CMD_RSSI_POLL:
                     if (message.arg1 == mRssiPollToken) {
-                        getWifiLinkLayerStats();
+                        WifiLinkLayerStats stats = getWifiLinkLayerStats();
+                        mWifiMetrics.incrementWifiLinkLayerUsageStats(stats);
+
                         // Get Info and continue polling
                         fetchRssiLinkSpeedAndFrequencyNative();
                         // Send the update score to network agent.
diff --git a/service/java/com/android/server/wifi/hotspot2/PasspointProvider.java b/service/java/com/android/server/wifi/hotspot2/PasspointProvider.java
index f86a938d7..6d09a29ca 100644
--- a/service/java/com/android/server/wifi/hotspot2/PasspointProvider.java
+++ b/service/java/com/android/server/wifi/hotspot2/PasspointProvider.java
@@ -259,24 +259,32 @@ public class PasspointProvider {
      */
     public PasspointMatch match(Map<ANQPElementType, ANQPElement> anqpElements,
             RoamingConsortium roamingConsortium) {
-        PasspointMatch providerMatch = matchProvider(anqpElements, roamingConsortium);
+        PasspointMatch providerMatch = matchProviderExceptFor3GPP(anqpElements, roamingConsortium);
+
+        // 3GPP Network matching.
+        if (providerMatch == PasspointMatch.None && ANQPMatcher.matchThreeGPPNetwork(
+                (ThreeGPPNetworkElement) anqpElements.get(ANQPElementType.ANQP3GPPNetwork),
+                mImsiParameter, mMatchingSIMImsiList)) {
+            return PasspointMatch.RoamingProvider;
+        }
 
         // Perform authentication match against the NAI Realm.
         int authMatch = ANQPMatcher.matchNAIRealm(
                 (NAIRealmElement) anqpElements.get(ANQPElementType.ANQPNAIRealm),
                 mConfig.getCredential().getRealm(), mEAPMethodID, mAuthParam);
 
-        // Auth mismatch, demote provider match.
+        // In case of Auth mismatch, demote provider match.
         if (authMatch == AuthMatch.NONE) {
             return PasspointMatch.None;
         }
 
-        // No realm match, return provider match as is.
+        // In case of no realm match, return provider match as is.
         if ((authMatch & AuthMatch.REALM) == 0) {
             return providerMatch;
         }
 
-        // Realm match, promote provider match to roaming if no other provider match is found.
+        // Promote the provider match to roaming provider if provider match is not found, but NAI
+        // realm is matched.
         return providerMatch == PasspointMatch.None ? PasspointMatch.RoamingProvider
                 : providerMatch;
     }
@@ -454,13 +462,14 @@ public class PasspointProvider {
     }
 
     /**
-     * Perform a provider match based on the given ANQP elements.
+     * Perform a provider match based on the given ANQP elements except for matching 3GPP Network.
      *
      * @param anqpElements List of ANQP elements
      * @param roamingConsortium Roaming Consortium information element from the AP
      * @return {@link PasspointMatch}
      */
-    private PasspointMatch matchProvider(Map<ANQPElementType, ANQPElement> anqpElements,
+    private PasspointMatch matchProviderExceptFor3GPP(
+            Map<ANQPElementType, ANQPElement> anqpElements,
             RoamingConsortium roamingConsortium) {
         // Domain name matching.
         if (ANQPMatcher.matchDomainName(
@@ -489,12 +498,6 @@ public class PasspointProvider {
             }
         }
 
-        // 3GPP Network matching.
-        if (ANQPMatcher.matchThreeGPPNetwork(
-                (ThreeGPPNetworkElement) anqpElements.get(ANQPElementType.ANQP3GPPNetwork),
-                mImsiParameter, mMatchingSIMImsiList)) {
-            return PasspointMatch.RoamingProvider;
-        }
         return PasspointMatch.None;
     }
 
diff --git a/service/java/com/android/server/wifi/rtt/RttServiceImpl.java b/service/java/com/android/server/wifi/rtt/RttServiceImpl.java
index 75e75aa0f..258bdb67f 100644
--- a/service/java/com/android/server/wifi/rtt/RttServiceImpl.java
+++ b/service/java/com/android/server/wifi/rtt/RttServiceImpl.java
@@ -1016,8 +1016,14 @@ public class RttServiceImpl extends IWifiRttManager.Stub {
             RangingRequest.Builder newRequestBuilder = new RangingRequest.Builder();
             for (ResponderConfig rttPeer : request.request.mRttPeers) {
                 if (rttPeer.peerHandle != null && rttPeer.macAddress == null) {
+                    byte[] mac = peerIdToMacMap.get(rttPeer.peerHandle.peerId);
+                    if (mac == null || mac.length != 6) {
+                        Log.e(TAG, "processReceivedAwarePeerMacAddresses: received an invalid MAC "
+                                + "address for peerId=" + rttPeer.peerHandle.peerId);
+                        continue;
+                    }
                     newRequestBuilder.addResponder(new ResponderConfig(
-                            MacAddress.fromBytes(peerIdToMacMap.get(rttPeer.peerHandle.peerId)),
+                            MacAddress.fromBytes(mac),
                             rttPeer.peerHandle, rttPeer.responderType, rttPeer.supports80211mc,
                             rttPeer.channelWidth, rttPeer.frequency, rttPeer.centerFreq0,
                             rttPeer.centerFreq1, rttPeer.preamble));
diff --git a/tests/wifitests/src/com/android/server/wifi/WifiMetricsTest.java b/tests/wifitests/src/com/android/server/wifi/WifiMetricsTest.java
index 5646efc62..7ff28b5a2 100644
--- a/tests/wifitests/src/com/android/server/wifi/WifiMetricsTest.java
+++ b/tests/wifitests/src/com/android/server/wifi/WifiMetricsTest.java
@@ -67,6 +67,7 @@ import java.util.BitSet;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Random;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
@@ -79,6 +80,7 @@ public class WifiMetricsTest {
     WifiMetrics mWifiMetrics;
     WifiMetricsProto.WifiLog mDecodedProto;
     TestLooper mTestLooper;
+    Random mRandom = new Random();
     @Mock Clock mClock;
     @Mock ScoringParams mScoringParams;
     @Mock WifiConfigManager mWcm;
@@ -1413,7 +1415,7 @@ public class WifiMetricsTest {
     private static final int ASSOC_TIMEOUT = 1;
     private static final int LOCAL_GEN = 1;
     private static final int AUTH_FAILURE_REASON = WifiManager.ERROR_AUTH_FAILURE_WRONG_PSWD;
-    private static final int NUM_TEST_STA_EVENTS = 16;
+    private static final int NUM_TEST_STA_EVENTS = 18;
     private static final String   sSSID = "\"SomeTestSsid\"";
     private static final WifiSsid sWifiSsid = WifiSsid.createFromAsciiEncoded(sSSID);
     private static final String   sBSSID = "01:02:03:04:05:06";
@@ -1463,7 +1465,9 @@ public class WifiMetricsTest {
         {StaEvent.TYPE_NETWORK_AGENT_VALID_NETWORK,     0,                          0},
         {StaEvent.TYPE_FRAMEWORK_DISCONNECT,            StaEvent.DISCONNECT_API,    0},
         {StaEvent.TYPE_SCORE_BREACH,                    0,                          0},
-        {StaEvent.TYPE_MAC_CHANGE,                      0,                          1}
+        {StaEvent.TYPE_MAC_CHANGE,                      0,                          1},
+        {StaEvent.TYPE_WIFI_ENABLED,                    0,                          0},
+        {StaEvent.TYPE_WIFI_DISABLED,                   0,                          0}
     };
     // Values used to generate the StaEvent log calls from WifiMonitor
     // <type>, <reason>, <status>, <local_gen>,
@@ -1500,7 +1504,11 @@ public class WifiMetricsTest {
         {StaEvent.TYPE_SCORE_BREACH,                    -1,            -1,         0,
             /**/                               0,             0,        0, 0},    /**/
         {StaEvent.TYPE_MAC_CHANGE,                      -1,            -1,         0,
-            /**/                               0,             0,        0, 1}     /**/
+            /**/                               0,             0,        0, 1},    /**/
+        {StaEvent.TYPE_WIFI_ENABLED,                    -1,            -1,         0,
+            /**/                               0,             0,        0, 0},    /**/
+        {StaEvent.TYPE_WIFI_DISABLED,                   -1,            -1,         0,
+            /**/                               0,             0,        0, 0}     /**/
     };
 
     /**
@@ -1977,4 +1985,89 @@ public class WifiMetricsTest {
         }
         return bitSet;
     }
+
+    private int nextRandInt() {
+        return mRandom.nextInt(10000);
+    }
+
+    private WifiLinkLayerStats nextRandomStats(WifiLinkLayerStats current) {
+        WifiLinkLayerStats out = new WifiLinkLayerStats();
+        out.timeStampInMs = current.timeStampInMs + nextRandInt();
+        out.on_time = current.on_time + nextRandInt();
+        out.tx_time = current.tx_time + nextRandInt();
+        out.rx_time = current.rx_time + nextRandInt();
+        out.on_time_scan = current.on_time_scan + nextRandInt();
+        return out;
+    }
+
+    private void assertWifiLinkLayerUsageHasDiff(WifiLinkLayerStats oldStats,
+            WifiLinkLayerStats newStats) {
+        assertEquals(newStats.timeStampInMs - oldStats.timeStampInMs,
+                mDecodedProto.wifiLinkLayerUsageStats.loggingDurationMs);
+        assertEquals(newStats.on_time - oldStats.on_time,
+                mDecodedProto.wifiLinkLayerUsageStats.radioOnTimeMs);
+        assertEquals(newStats.tx_time - oldStats.tx_time,
+                mDecodedProto.wifiLinkLayerUsageStats.radioTxTimeMs);
+        assertEquals(newStats.rx_time - oldStats.rx_time,
+                mDecodedProto.wifiLinkLayerUsageStats.radioRxTimeMs);
+        assertEquals(newStats.on_time_scan - oldStats.on_time_scan,
+                mDecodedProto.wifiLinkLayerUsageStats.radioScanTimeMs);
+    }
+
+    /**
+     * Verify that WifiMetrics is counting link layer usage correctly when given a series of
+     * valid input.
+     * @throws Exception
+     */
+    @Test
+    public void testWifiLinkLayerUsageStats() throws Exception {
+        WifiLinkLayerStats stat1 = nextRandomStats(new WifiLinkLayerStats());
+        WifiLinkLayerStats stat2 = nextRandomStats(stat1);
+        WifiLinkLayerStats stat3 = nextRandomStats(stat2);
+        mWifiMetrics.incrementWifiLinkLayerUsageStats(stat1);
+        mWifiMetrics.incrementWifiLinkLayerUsageStats(stat2);
+        mWifiMetrics.incrementWifiLinkLayerUsageStats(stat3);
+        dumpProtoAndDeserialize();
+
+        // After 2 increments, the counters should have difference between |stat1| and |stat3|
+        assertWifiLinkLayerUsageHasDiff(stat1, stat3);
+    }
+
+    /**
+     * Verify that null input is handled and wifi link layer usage stats are not incremented.
+     * @throws Exception
+     */
+    @Test
+    public void testWifiLinkLayerUsageStatsNullInput() throws Exception {
+        WifiLinkLayerStats stat1 = nextRandomStats(new WifiLinkLayerStats());
+        WifiLinkLayerStats stat2 = null;
+        mWifiMetrics.incrementWifiLinkLayerUsageStats(stat1);
+        mWifiMetrics.incrementWifiLinkLayerUsageStats(stat2);
+        dumpProtoAndDeserialize();
+
+        // Counter should be zero
+        assertWifiLinkLayerUsageHasDiff(stat1, stat1);
+    }
+
+    /**
+     * Verify that when the new data appears to be bad link layer usage stats are not being
+     * incremented and the buffered WifiLinkLayerStats get cleared.
+     * @throws Exception
+     */
+    @Test
+    public void testWifiLinkLayerUsageStatsChipReset() throws Exception {
+        WifiLinkLayerStats stat1 = nextRandomStats(new WifiLinkLayerStats());
+        WifiLinkLayerStats stat2 = nextRandomStats(stat1);
+        stat2.on_time = stat1.on_time - 1;
+        WifiLinkLayerStats stat3 = nextRandomStats(stat2);
+        WifiLinkLayerStats stat4 = nextRandomStats(stat3);
+        mWifiMetrics.incrementWifiLinkLayerUsageStats(stat1);
+        mWifiMetrics.incrementWifiLinkLayerUsageStats(stat2);
+        mWifiMetrics.incrementWifiLinkLayerUsageStats(stat3);
+        mWifiMetrics.incrementWifiLinkLayerUsageStats(stat4);
+        dumpProtoAndDeserialize();
+
+        // Should only count the difference between |stat3| and |stat4|
+        assertWifiLinkLayerUsageHasDiff(stat3, stat4);
+    }
 }
diff --git a/tests/wifitests/src/com/android/server/wifi/WifiStateMachineTest.java b/tests/wifitests/src/com/android/server/wifi/WifiStateMachineTest.java
index 90f3e0775..8154a02b9 100644
--- a/tests/wifitests/src/com/android/server/wifi/WifiStateMachineTest.java
+++ b/tests/wifitests/src/com/android/server/wifi/WifiStateMachineTest.java
@@ -95,6 +95,7 @@ import com.android.internal.util.StateMachine;
 import com.android.server.wifi.hotspot2.NetworkDetail;
 import com.android.server.wifi.hotspot2.PasspointManager;
 import com.android.server.wifi.hotspot2.PasspointProvisioningTestUtil;
+import com.android.server.wifi.nano.WifiMetricsProto;
 import com.android.server.wifi.nano.WifiMetricsProto.StaEvent;
 import com.android.server.wifi.p2p.WifiP2pServiceImpl;
 import com.android.server.wifi.util.WifiPermissionsUtil;
@@ -1836,6 +1837,7 @@ public class WifiStateMachineTest {
     public void testWifiInfoCleanedUpEnteringExitingConnectModeState() throws Exception {
         InOrder inOrder = inOrder(mWifiConnectivityManager);
         InOrder inOrderSarMgr = inOrder(mSarManager);
+        InOrder inOrderMetrics = inOrder(mWifiMetrics);
         Log.i(TAG, mWsm.getCurrentState().getName());
         String initialBSSID = "aa:bb:cc:dd:ee:ff";
         WifiInfo wifiInfo = mWsm.getWifiInfo();
@@ -1847,6 +1849,9 @@ public class WifiStateMachineTest {
         assertEquals(WifiManager.WIFI_STATE_ENABLED, mWsm.syncGetWifiState());
         inOrder.verify(mWifiConnectivityManager).setWifiEnabled(eq(true));
         inOrderSarMgr.verify(mSarManager).setClientWifiState(WifiManager.WIFI_STATE_ENABLED);
+        inOrderMetrics.verify(mWifiMetrics)
+                .setWifiState(WifiMetricsProto.WifiLog.WIFI_DISCONNECTED);
+        inOrderMetrics.verify(mWifiMetrics).logStaEvent(StaEvent.TYPE_WIFI_ENABLED);
         assertNull(wifiInfo.getBSSID());
 
         // Send a SUPPLICANT_STATE_CHANGE_EVENT, verify WifiInfo is updated
@@ -1867,6 +1872,8 @@ public class WifiStateMachineTest {
         assertEquals(WifiManager.WIFI_STATE_DISABLED, mWsm.syncGetWifiState());
         inOrder.verify(mWifiConnectivityManager).setWifiEnabled(eq(false));
         inOrderSarMgr.verify(mSarManager).setClientWifiState(WifiManager.WIFI_STATE_DISABLED);
+        inOrderMetrics.verify(mWifiMetrics).setWifiState(WifiMetricsProto.WifiLog.WIFI_DISABLED);
+        inOrderMetrics.verify(mWifiMetrics).logStaEvent(StaEvent.TYPE_WIFI_DISABLED);
         assertNull(wifiInfo.getBSSID());
         assertEquals(SupplicantState.DISCONNECTED, wifiInfo.getSupplicantState());
 
@@ -1888,6 +1895,9 @@ public class WifiStateMachineTest {
         assertEquals(WifiManager.WIFI_STATE_ENABLED, mWsm.syncGetWifiState());
         inOrder.verify(mWifiConnectivityManager).setWifiEnabled(eq(true));
         inOrderSarMgr.verify(mSarManager).setClientWifiState(WifiManager.WIFI_STATE_ENABLED);
+        inOrderMetrics.verify(mWifiMetrics)
+                .setWifiState(WifiMetricsProto.WifiLog.WIFI_DISCONNECTED);
+        inOrderMetrics.verify(mWifiMetrics).logStaEvent(StaEvent.TYPE_WIFI_ENABLED);
         assertEquals("DisconnectedState", getCurrentState().getName());
         assertEquals(SupplicantState.DISCONNECTED, wifiInfo.getSupplicantState());
         assertNull(wifiInfo.getBSSID());
diff --git a/tests/wifitests/src/com/android/server/wifi/hotspot2/PasspointProviderTest.java b/tests/wifitests/src/com/android/server/wifi/hotspot2/PasspointProviderTest.java
index 0055fbaaa..58496622f 100644
--- a/tests/wifitests/src/com/android/server/wifi/hotspot2/PasspointProviderTest.java
+++ b/tests/wifitests/src/com/android/server/wifi/hotspot2/PasspointProviderTest.java
@@ -47,8 +47,8 @@ import com.android.server.wifi.hotspot2.anqp.ThreeGPPNetworkElement;
 import com.android.server.wifi.hotspot2.anqp.eap.AuthParam;
 import com.android.server.wifi.hotspot2.anqp.eap.EAPMethod;
 import com.android.server.wifi.hotspot2.anqp.eap.NonEAPInnerAuth;
-
 import com.android.server.wifi.util.InformationElementUtil.RoamingConsortium;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.Mock;
@@ -447,7 +447,7 @@ public class PasspointProviderTest {
      * @throws Exception
      */
     @Test
-    public void match3GPPNetworkDomainName() throws Exception {
+    public void matchFQDNWith3GPPNetworkDomainName() throws Exception {
         String testImsi = "1234567890";
 
         // Setup test provider.
@@ -471,14 +471,57 @@ public class PasspointProviderTest {
             mProvider.match(anqpElementMap, mRoamingConsortium));
     }
 
+    /**
+     * Verify that a provider is a home provider when its FQDN, roaming consortium OI, and
+     * IMSI all matched against the ANQP elements, since we prefer matching home provider over
+     * roaming provider.
+     *
+     * @throws Exception
+     */
+    @Test
+    public void matchFQDNOverRoamingProvider() throws Exception {
+        // Setup test data.
+        String testDomain = "test.com";
+        String testImsi = "1234567890";
+        long[] providerRCOIs = new long[] {0x1234L, 0x2345L};
+        Long[] anqpRCOIs = new Long[] {0x1234L, 0x2133L};
+
+        // Setup test provider.
+        PasspointConfiguration config = new PasspointConfiguration();
+        HomeSp homeSp = new HomeSp();
+        homeSp.setFqdn(testDomain);
+        homeSp.setRoamingConsortiumOis(providerRCOIs);
+        config.setHomeSp(homeSp);
+        Credential credential = new Credential();
+        Credential.SimCredential simCredential = new Credential.SimCredential();
+        simCredential.setImsi(testImsi);
+        credential.setSimCredential(simCredential);
+        config.setCredential(credential);
+        when(mSimAccessor.getMatchingImsis(new IMSIParameter(testImsi, false)))
+                .thenReturn(Arrays.asList(new String[] {testImsi}));
+        mProvider = createProvider(config);
+
+        // Setup ANQP elements.
+        Map<ANQPElementType, ANQPElement> anqpElementMap = new HashMap<>();
+        anqpElementMap.put(ANQPElementType.ANQPDomName,
+                createDomainNameElement(new String[] {testDomain}));
+        anqpElementMap.put(ANQPElementType.ANQPRoamingConsortium,
+                createRoamingConsortiumElement(anqpRCOIs));
+        anqpElementMap.put(ANQPElementType.ANQP3GPPNetwork,
+                createThreeGPPNetworkElement(new String[] {"123456"}));
+
+        assertEquals(PasspointMatch.HomeProvider,
+                mProvider.match(anqpElementMap, mRoamingConsortium));
+    }
+
     /**
      * Verify that a provider is a roaming provider when a roaming consortium OI matches an OI
-     * in the roaming consortium ANQP element.
+     * in the roaming consortium ANQP element and no NAI realm is provided.
      *
      * @throws Exception
      */
     @Test
-    public void matchRoamingConsortium() throws Exception {
+    public void matchRoamingConsortiumWithoutNAIRealm() throws Exception {
         long[] providerRCOIs = new long[] {0x1234L, 0x2345L};
         Long[] anqpRCOIs = new Long[] {0x1234L, 0x2133L};
 
@@ -505,12 +548,87 @@ public class PasspointProviderTest {
 
     /**
      * Verify that a provider is a roaming provider when a roaming consortium OI matches an OI
-     * in the roaming consortium information element.
+     * in the roaming consortium ANQP element and the provider's credential matches the
+     * NAI realm provided.
+     *
+     * @throws Exception
+     */
+    @Test
+    public void matchRoamingConsortiumWithNAIRealmMatch() throws Exception {
+        long[] providerRCOIs = new long[] {0x1234L, 0x2345L};
+        Long[] anqpRCOIs = new Long[] {0x1234L, 0x2133L};
+        String testRealm = "realm.com";
+
+        // Setup test provider.
+        PasspointConfiguration config = new PasspointConfiguration();
+        HomeSp homeSp = new HomeSp();
+        homeSp.setRoamingConsortiumOis(providerRCOIs);
+        config.setHomeSp(homeSp);
+        Credential credential = new Credential();
+        credential.setRealm(testRealm);
+        Credential.UserCredential userCredential = new Credential.UserCredential();
+        userCredential.setNonEapInnerMethod(Credential.UserCredential.AUTH_METHOD_MSCHAPV2);
+        credential.setUserCredential(userCredential);
+        config.setCredential(credential);
+        mProvider = createProvider(config);
+
+        // Setup Roaming Consortium ANQP element.
+        Map<ANQPElementType, ANQPElement> anqpElementMap = new HashMap<>();
+        anqpElementMap.put(ANQPElementType.ANQPRoamingConsortium,
+                createRoamingConsortiumElement(anqpRCOIs));
+        anqpElementMap.put(ANQPElementType.ANQPNAIRealm,
+                createNAIRealmElement(testRealm, EAPConstants.EAP_TTLS,
+                        new NonEAPInnerAuth(NonEAPInnerAuth.AUTH_TYPE_MSCHAPV2)));
+
+        assertEquals(PasspointMatch.RoamingProvider,
+                mProvider.match(anqpElementMap, mRoamingConsortium));
+    }
+
+    /**
+     * Verify that there is no match when a roaming consortium OI matches an OI
+     * in the roaming consortium ANQP element and but NAI realm is not matched.
+     *
+     * @throws Exception
+     */
+    @Test
+    public void matchRoamingConsortiumWithNAIRealmMisMatch() throws Exception {
+        long[] providerRCOIs = new long[] {0x1234L, 0x2345L};
+        Long[] anqpRCOIs = new Long[] {0x1234L, 0x2133L};
+        String testRealm = "realm.com";
+
+        // Setup test provider.
+        PasspointConfiguration config = new PasspointConfiguration();
+        HomeSp homeSp = new HomeSp();
+        homeSp.setRoamingConsortiumOis(providerRCOIs);
+        config.setHomeSp(homeSp);
+        Credential credential = new Credential();
+        credential.setRealm(testRealm);
+        Credential.UserCredential userCredential = new Credential.UserCredential();
+        userCredential.setNonEapInnerMethod(Credential.UserCredential.AUTH_METHOD_MSCHAPV2);
+        credential.setUserCredential(userCredential);
+        config.setCredential(credential);
+        mProvider = createProvider(config);
+
+        // Setup Roaming Consortium ANQP element.
+        Map<ANQPElementType, ANQPElement> anqpElementMap = new HashMap<>();
+        anqpElementMap.put(ANQPElementType.ANQPRoamingConsortium,
+                createRoamingConsortiumElement(anqpRCOIs));
+        // Set up NAI with different EAP method
+        anqpElementMap.put(ANQPElementType.ANQPNAIRealm,
+                createNAIRealmElement(testRealm, EAPConstants.EAP_TLS, null));
+
+        assertEquals(PasspointMatch.None,
+                mProvider.match(anqpElementMap, mRoamingConsortium));
+    }
+
+    /**
+     * Verify that a provider is a roaming provider when a roaming consortium OI matches an OI
+     * in the roaming consortium information element and no NAI realm is provided.
      *
      * @throws Exception
      */
     @Test
-    public void matchRoamingConsortiumIe() throws Exception {
+    public void matchRoamingConsortiumIeWithoutNAIRealm() throws Exception {
         long[] providerRCOIs = new long[] {0x1234L, 0x2345L};
         long[] ieRCOIs = new long[] {0x1234L, 0x2133L};
 
@@ -537,7 +655,84 @@ public class PasspointProviderTest {
     }
 
     /**
-     * Verify that none of matched providers are not found when a roaming consortium OI doesn't
+     * Verify that a provider is a roaming provider when a roaming consortium OI matches an OI
+     * in the roaming consortium information element and the provider's credential matches the
+     * NAI realm provided.
+     *
+     * @throws Exception
+     */
+    @Test
+    public void matchRoamingConsortiumIeWithNAIRealmMatch() throws Exception {
+        long[] providerRCOIs = new long[] {0x1234L, 0x2345L};
+        long[] ieRCOIs = new long[] {0x1234L, 0x2133L};
+        String testRealm = "realm.com";
+
+        // Setup test provider.
+        PasspointConfiguration config = new PasspointConfiguration();
+        HomeSp homeSp = new HomeSp();
+        homeSp.setRoamingConsortiumOis(providerRCOIs);
+        config.setHomeSp(homeSp);
+        Credential credential = new Credential();
+        credential.setRealm(testRealm);
+        Credential.UserCredential userCredential = new Credential.UserCredential();
+        userCredential.setNonEapInnerMethod(Credential.UserCredential.AUTH_METHOD_MSCHAPV2);
+        credential.setUserCredential(userCredential);
+        config.setCredential(credential);
+        mProvider = createProvider(config);
+
+        // Setup Roaming Consortium ANQP element.
+        Map<ANQPElementType, ANQPElement> anqpElementMap = new HashMap<>();
+
+        // Setup Roaming Consortium Information element.
+        when(mRoamingConsortium.getRoamingConsortiums()).thenReturn(ieRCOIs);
+        anqpElementMap.put(ANQPElementType.ANQPNAIRealm,
+                createNAIRealmElement(testRealm, EAPConstants.EAP_TTLS,
+                        new NonEAPInnerAuth(NonEAPInnerAuth.AUTH_TYPE_MSCHAPV2)));
+
+        assertEquals(PasspointMatch.RoamingProvider,
+                mProvider.match(anqpElementMap, mRoamingConsortium));
+    }
+
+    /**
+     * Verify that there is no match when a roaming consortium OI matches an OI
+     * in the roaming consortium information element, but NAI realm is not matched.
+     *
+     * @throws Exception
+     */
+    @Test
+    public void matchRoamingConsortiumIeWithNAIRealmMismatch() throws Exception {
+        long[] providerRCOIs = new long[] {0x1234L, 0x2345L};
+        long[] ieRCOIs = new long[] {0x1234L, 0x2133L};
+        String testRealm = "realm.com";
+
+        // Setup test provider.
+        PasspointConfiguration config = new PasspointConfiguration();
+        HomeSp homeSp = new HomeSp();
+        homeSp.setRoamingConsortiumOis(providerRCOIs);
+        config.setHomeSp(homeSp);
+        Credential credential = new Credential();
+        credential.setRealm(testRealm);
+        Credential.UserCredential userCredential = new Credential.UserCredential();
+        userCredential.setNonEapInnerMethod(Credential.UserCredential.AUTH_METHOD_MSCHAPV2);
+        credential.setUserCredential(userCredential);
+        config.setCredential(credential);
+        mProvider = createProvider(config);
+
+        // Setup Roaming Consortium ANQP element.
+        Map<ANQPElementType, ANQPElement> anqpElementMap = new HashMap<>();
+
+        // Setup Roaming Consortium Information element.
+        when(mRoamingConsortium.getRoamingConsortiums()).thenReturn(ieRCOIs);
+        // Set up NAI with different EAP method
+        anqpElementMap.put(ANQPElementType.ANQPNAIRealm,
+                createNAIRealmElement(testRealm, EAPConstants.EAP_TLS, null));
+
+        assertEquals(PasspointMatch.None,
+                mProvider.match(anqpElementMap, mRoamingConsortium));
+    }
+
+    /**
+     * Verify that none of matched providers are found when a roaming consortium OI doesn't
      * matches an OI in the roaming consortium information element and
      * none of NAI realms match each other.
      *
@@ -571,15 +766,16 @@ public class PasspointProviderTest {
     }
 
     /**
-     * Verify that a provider is a roaming provider when the provider's IMSI parameter and an
-     * IMSI from the SIM card matches a MCC-MNC in the 3GPP Network ANQP element.
+     * Verify that a provider is a roaming provider when the provider's IMSI parameter and an IMSI
+     * from the SIM card matches a MCC-MNC in the 3GPP Network ANQP element regardless of NAI realm
+     * mismatch.
      *
      * @throws Exception
      */
     @Test
-    public void matchThreeGPPNetwork() throws Exception {
+    public void matchThreeGPPNetworkWithNAIRealmMismatch() throws Exception {
         String testImsi = "1234567890";
-
+        String testRealm = "realm.com";
         // Setup test provider.
         PasspointConfiguration config = new PasspointConfiguration();
         config.setHomeSp(new HomeSp());
@@ -597,84 +793,84 @@ public class PasspointProviderTest {
         anqpElementMap.put(ANQPElementType.ANQP3GPPNetwork,
                 createThreeGPPNetworkElement(new String[] {"123456"}));
 
+        // Setup NAI Realm ANQP element with different realm.
+        anqpElementMap.put(ANQPElementType.ANQPNAIRealm,
+                createNAIRealmElement(testRealm, EAPConstants.EAP_TTLS,
+                new NonEAPInnerAuth(NonEAPInnerAuth.AUTH_TYPE_MSCHAPV2)));
+
         assertEquals(PasspointMatch.RoamingProvider,
             mProvider.match(anqpElementMap, mRoamingConsortium));
     }
 
     /**
-     * Verify that a provider is a roaming provider when its credential matches a NAI realm in
-     * the NAI Realm ANQP element.
+     * Verify that a provider is a roaming provider when the provider's IMSI parameter and an IMSI
+     * from the SIM card matches a MCC-MNC in the 3GPP Network ANQP element regardless of NAI realm
+     * match.
      *
      * @throws Exception
      */
     @Test
-    public void matchNAIRealm() throws Exception {
+    public void matchThreeGPPNetworkWithNAIRealmMatch() throws Exception {
+        String testImsi = "1234567890";
         String testRealm = "realm.com";
-
         // Setup test provider.
         PasspointConfiguration config = new PasspointConfiguration();
         config.setHomeSp(new HomeSp());
         Credential credential = new Credential();
-        credential.setRealm(testRealm);
-        Credential.UserCredential userCredential = new Credential.UserCredential();
-        userCredential.setNonEapInnerMethod(Credential.UserCredential.AUTH_METHOD_MSCHAPV2);
-        credential.setUserCredential(userCredential);
+        Credential.SimCredential simCredential = new Credential.SimCredential();
+        simCredential.setImsi(testImsi);
+        credential.setSimCredential(simCredential);
         config.setCredential(credential);
+        credential.setRealm(testRealm);
+        when(mSimAccessor.getMatchingImsis(new IMSIParameter(testImsi, false)))
+                .thenReturn(Arrays.asList(new String[] {testImsi}));
         mProvider = createProvider(config);
 
-        // Setup NAI Realm ANQP element.
+        // Setup 3GPP Network ANQP element.
         Map<ANQPElementType, ANQPElement> anqpElementMap = new HashMap<>();
+        anqpElementMap.put(ANQPElementType.ANQP3GPPNetwork,
+                createThreeGPPNetworkElement(new String[] {"123456"}));
+
+        // Setup NAI Realm ANQP element with same realm.
         anqpElementMap.put(ANQPElementType.ANQPNAIRealm,
-                createNAIRealmElement(testRealm, EAPConstants.EAP_TTLS,
-                        new NonEAPInnerAuth(NonEAPInnerAuth.AUTH_TYPE_MSCHAPV2)));
+                createNAIRealmElement(testRealm, EAPConstants.EAP_AKA, null));
 
         assertEquals(PasspointMatch.RoamingProvider,
-            mProvider.match(anqpElementMap, mRoamingConsortium));
+                mProvider.match(anqpElementMap, mRoamingConsortium));
     }
 
     /**
-     * Verify that a provider is a home provider when its FQDN, roaming consortium OI, and
-     * IMSI all matched against the ANQP elements, since we prefer matching home provider over
-     * roaming provider.
+     * Verify that a provider is a roaming provider when its credential only matches a NAI realm in
+     * the NAI Realm ANQP element and not match for Domain Name, RoamingConsortium and 3GPP.
      *
      * @throws Exception
      */
     @Test
-    public void matchHomeOverRoamingProvider() throws Exception {
-        // Setup test data.
-        String testDomain = "test.com";
-        String testImsi = "1234567890";
-        long[] providerRCOIs = new long[] {0x1234L, 0x2345L};
-        Long[] anqpRCOIs = new Long[] {0x1234L, 0x2133L};
+    public void matchOnlyNAIRealmWithOtherInformationMismatch() throws Exception {
+        String testRealm = "realm.com";
 
         // Setup test provider.
         PasspointConfiguration config = new PasspointConfiguration();
-        HomeSp homeSp = new HomeSp();
-        homeSp.setFqdn(testDomain);
-        homeSp.setRoamingConsortiumOis(providerRCOIs);
-        config.setHomeSp(homeSp);
+        config.setHomeSp(new HomeSp());
         Credential credential = new Credential();
-        Credential.SimCredential simCredential = new Credential.SimCredential();
-        simCredential.setImsi(testImsi);
-        credential.setSimCredential(simCredential);
+        credential.setRealm(testRealm);
+        Credential.UserCredential userCredential = new Credential.UserCredential();
+        userCredential.setNonEapInnerMethod(Credential.UserCredential.AUTH_METHOD_MSCHAPV2);
+        credential.setUserCredential(userCredential);
         config.setCredential(credential);
-        when(mSimAccessor.getMatchingImsis(new IMSIParameter(testImsi, false)))
-                .thenReturn(Arrays.asList(new String[] {testImsi}));
         mProvider = createProvider(config);
 
-        // Setup ANQP elements.
+        // Setup NAI Realm ANQP element.
         Map<ANQPElementType, ANQPElement> anqpElementMap = new HashMap<>();
-        anqpElementMap.put(ANQPElementType.ANQPDomName,
-                createDomainNameElement(new String[] {testDomain}));
-        anqpElementMap.put(ANQPElementType.ANQPRoamingConsortium,
-                createRoamingConsortiumElement(anqpRCOIs));
-        anqpElementMap.put(ANQPElementType.ANQP3GPPNetwork,
-                createThreeGPPNetworkElement(new String[] {"123456"}));
+        anqpElementMap.put(ANQPElementType.ANQPNAIRealm,
+                createNAIRealmElement(testRealm, EAPConstants.EAP_TTLS,
+                        new NonEAPInnerAuth(NonEAPInnerAuth.AUTH_TYPE_MSCHAPV2)));
 
-        assertEquals(PasspointMatch.HomeProvider,
+        assertEquals(PasspointMatch.RoamingProvider,
             mProvider.match(anqpElementMap, mRoamingConsortium));
     }
 
+
     /**
      * Verify that an expected WifiConfiguration will be returned for a Passpoint provider
      * with an user credential.
diff --git a/tests/wifitests/src/com/android/server/wifi/rtt/RttServiceImplTest.java b/tests/wifitests/src/com/android/server/wifi/rtt/RttServiceImplTest.java
index d1c1b028b..e1f35239f 100644
--- a/tests/wifitests/src/com/android/server/wifi/rtt/RttServiceImplTest.java
+++ b/tests/wifitests/src/com/android/server/wifi/rtt/RttServiceImplTest.java
@@ -305,13 +305,16 @@ public class RttServiceImplTest {
         RangingRequest request = RttTestUtils.getDummyRangingRequest((byte) 0xA);
         PeerHandle peerHandle1 = new PeerHandle(1022);
         PeerHandle peerHandle2 = new PeerHandle(1023);
+        PeerHandle peerHandle3 = new PeerHandle(1024);
         request.mRttPeers.add(ResponderConfig.fromWifiAwarePeerHandleWithDefaults(peerHandle1));
         request.mRttPeers.add(ResponderConfig.fromWifiAwarePeerHandleWithDefaults(peerHandle2));
+        request.mRttPeers.add(ResponderConfig.fromWifiAwarePeerHandleWithDefaults(peerHandle3));
         Map<Integer, MacAddress> peerHandleToMacMap = new HashMap<>();
         MacAddress macAwarePeer1 = MacAddress.fromString("AA:BB:CC:DD:EE:FF");
         MacAddress macAwarePeer2 = MacAddress.fromString("BB:BB:BB:EE:EE:EE");
         peerHandleToMacMap.put(peerHandle1.peerId, macAwarePeer1);
         peerHandleToMacMap.put(peerHandle2.peerId, macAwarePeer2);
+        peerHandleToMacMap.put(peerHandle3.peerId, null); // bad answer from Aware (expired?)
 
         AwareTranslatePeerHandlesToMac answer = new AwareTranslatePeerHandlesToMac(mDefaultUid,
                 peerHandleToMacMap);
@@ -327,7 +330,8 @@ public class RttServiceImplTest {
 
         RangingRequest finalRequest = mRequestCaptor.getValue();
         assertNotEquals("Request to native is not null", null, finalRequest);
-        assertEquals("Size of request", request.mRttPeers.size(), finalRequest.mRttPeers.size());
+        assertEquals("Size of request", request.mRttPeers.size() - 1,
+                finalRequest.mRttPeers.size());
         assertEquals("Aware peer 1 MAC", macAwarePeer1,
                 finalRequest.mRttPeers.get(finalRequest.mRttPeers.size() - 2).macAddress);
         assertEquals("Aware peer 2 MAC", macAwarePeer2,
@@ -1452,12 +1456,13 @@ public class RttServiceImplTest {
 
             Map<Integer, byte[]> result = new HashMap<>();
             for (Integer peerId: peerIds) {
-                byte[] mac = mPeerIdToMacMap.get(peerId).toByteArray();
-                if (mac == null) {
-                    continue;
+                byte[] macBytes = null;
+                MacAddress macAddr = mPeerIdToMacMap.get(peerId);
+                if (macAddr != null) {
+                    macBytes = macAddr.toByteArray();
                 }
 
-                result.put(peerId, mac);
+                result.put(peerId, macBytes);
             }
 
             try {
-- 
2.17.1

