From adfcc69eff8168da9f5766838a707bd96d744ca8 Mon Sep 17 00:00:00 2001
From: Bruno Martins <bgcngm@gmail.com>
Date: Fri, 8 Mar 2019 00:03:20 +0000
Subject: [PATCH] [SQUASH][DNM] Merge tag 'LA.UM.7.3.r1-06900-sdm845.0' into
 HEAD

Change-Id: I24f43dbd5653a2201139addf11ea17b1e55a6caa
---
 Android.bp                                   |  107 +-
 README.md                                    |   28 +-
 extns/impl/hal_nxpnfc.h                      |   52 +-
 halimpl/dnld/phDnldNfc_Internal.cc           |    6 +
 halimpl/hal/phNxpNciHal.cc                   |  279 ++-
 halimpl/hal/phNxpNciHal_ext.cc               |   25 +-
 halimpl/libnfc-nxp-PN80T_example.conf        |   16 +
 halimpl/libnfc-nxp-PN80T_example_NCI2_0.conf |   20 +-
 halimpl/libnfc-nxp-PN81T_example.conf        |   45 +-
 halimpl/libnfc-nxp_RF-PN80T_example.conf     |    6 +-
 halimpl/libnfc-nxp_RF-PN81T_example.conf     |    6 +-
 halimpl/tml/phTmlNfc.cc                      |   21 +-
 halimpl/tml/phTmlNfc.h                       |    2 +
 halimpl/tml/phTmlNfc_i2c.cc                  |   52 +-
 halimpl/tml/phTmlNfc_i2c.h                   |    4 +-
 halimpl/tml/spi_spm.cc                       |    2 +-
 halimpl/utils/phNxpConfig.cpp                |   10 +
 halimpl/utils/phNxpConfig.h                  |   29 +-
 inc/IChannel.h                               |  101 +
 inc/data_types.h                             |   59 +
 inc/eSEClientIntf.h                          |   81 +
 inc/phNxpLog.h                               |  367 +++
 jcos_client/inc/JcDnld.h                     |   64 +
 jcos_client/inc/JcopOsDownload.h             |  155 ++
 jcos_client/src/JcDnld.cpp                   |  172 ++
 jcos_client/src/JcopOsDownload.cpp           | 1041 +++++++++
 ls_client/inc/LsClient.h                     |   70 +
 ls_client/inc/LsLib.h                        |  555 +++++
 ls_client/src/LsClient.cpp                   |  216 ++
 ls_client/src/LsLib.cpp                      | 2137 ++++++++++++++++++
 src/eSEClientIntf.cc                         |  286 +++
 src/phNxpLog.cc                              |  260 +++
 utils/phNxpConfig.cc                         | 1089 +++++++++
 utils/phNxpConfig.h                          |  142 ++
 utils/sparse_crc32.cc                        |  107 +
 utils/sparse_crc32.h                         |   24 +
 36 files changed, 7483 insertions(+), 153 deletions(-)
 create mode 100644 inc/IChannel.h
 create mode 100644 inc/data_types.h
 create mode 100644 inc/eSEClientIntf.h
 create mode 100644 inc/phNxpLog.h
 create mode 100644 jcos_client/inc/JcDnld.h
 create mode 100644 jcos_client/inc/JcopOsDownload.h
 create mode 100644 jcos_client/src/JcDnld.cpp
 create mode 100644 jcos_client/src/JcopOsDownload.cpp
 create mode 100644 ls_client/inc/LsClient.h
 create mode 100644 ls_client/inc/LsLib.h
 create mode 100644 ls_client/src/LsClient.cpp
 create mode 100644 ls_client/src/LsLib.cpp
 create mode 100644 src/eSEClientIntf.cc
 create mode 100644 src/phNxpLog.cc
 create mode 100644 utils/phNxpConfig.cc
 create mode 100644 utils/phNxpConfig.h
 create mode 100644 utils/sparse_crc32.cc
 create mode 100644 utils/sparse_crc32.h

diff --git a/Android.bp b/Android.bp
index 3eabbd8..24a30e8 100644
--- a/Android.bp
+++ b/Android.bp
@@ -1,3 +1,104 @@
+cc_library_headers {
+    name: "libese_client_headers",
+    export_include_dirs: [
+        "inc",
+        "jcos_client/inc",
+        "ls_client/inc",
+    ],
+    vendor_available: true,
+}
+
+cc_library_shared {
+
+    name: "se_nq_extn_client",
+    defaults: ["hidl_defaults"],
+    vendor: true,
+
+    srcs: [
+        "utils/phNxpConfig.cc",
+        "utils/sparse_crc32.cc",
+        "src/eSEClientIntf.cc",
+        "src/phNxpLog.cc"
+    ],
+
+    local_include_dirs: [
+        "inc",
+        "utils",
+        "jcos_client/inc",
+        "ls_client/inc",
+    ],
+    shared_libs: [
+        "libbase",
+        "libcutils",
+        "libdl",
+        "libhidlbase",
+        "liblog",
+        "libutils",
+        "libchrome",
+        "libdl",
+        "libhidlbase",
+    ],
+}
+
+cc_library_shared {
+
+    name: "jcos_nq_client",
+    defaults: ["hidl_defaults"],
+    vendor: true,
+
+    srcs: [
+        "jcos_client/src/JcDnld.cpp",
+        "jcos_client/src/JcopOsDownload.cpp",
+    ],
+
+    local_include_dirs: [
+        "inc",
+        "utils",
+        "jcos_client/inc",
+    ],
+    shared_libs: [
+        "libbase",
+        "libcutils",
+        "libdl",
+        "libhidlbase",
+        "liblog",
+        "libutils",
+        "libchrome",
+        "libdl",
+        "libhidlbase",
+    ],
+}
+
+cc_library_shared {
+
+    name: "ls_nq_client",
+    defaults: ["hidl_defaults"],
+    vendor: true,
+
+    srcs: [
+        "ls_client/src/LsClient.cpp",
+        "ls_client/src/LsLib.cpp",
+    ],
+
+    local_include_dirs: [
+        "inc",
+        "utils",
+        "ls_client/inc",
+    ],
+    shared_libs: [
+        "libbase",
+        "libcutils",
+        "libdl",
+        "libhidlbase",
+        "liblog",
+        "libutils",
+        "libchrome",
+        "libdl",
+        "libhidlbase",
+        "se_nq_extn_client"
+    ],
+}
+
 cc_library_shared {
     name: "nfc_nci.nqx.default",
     relative_install_path: "hw",
@@ -24,7 +125,6 @@ cc_library_shared {
         "libhardware_legacy",
         "libhidlbase",
         "libhidltransport",
-        "liblog",
         "libutils",
         "android.hardware.nfc@1.0",
         "android.hardware.nfc@1.1",
@@ -36,7 +136,6 @@ cc_library_shared {
         "halimpl/log",
         "halimpl/self-test",
         "halimpl/tml",
-        "halimpl/utils",
         "halimpl/src/include",
         "halimpl/configs",
     ],
@@ -44,6 +143,7 @@ cc_library_shared {
         "extns/impl",
         "halimpl/inc",
         "halimpl/common",
+        "halimpl/utils",
     ],
     header_libs: [
         "libhardware_headers",
@@ -90,7 +190,6 @@ cc_library_shared {
         "libhardware_legacy",
         "libhidlbase",
         "libhidltransport",
-        "liblog",
         "libutils",
         "android.hardware.nfc@1.0",
         "android.hardware.nfc@1.1",
@@ -102,7 +201,6 @@ cc_library_shared {
         "halimpl/log",
         "halimpl/self-test",
         "halimpl/tml",
-        "halimpl/utils",
         "halimpl/src/include",
         "halimpl/configs",
     ],
@@ -110,6 +208,7 @@ cc_library_shared {
         "extns/impl",
         "halimpl/inc",
         "halimpl/common",
+        "halimpl/utils",
     ],
     header_libs: [
         "libhardware_headers",
diff --git a/README.md b/README.md
index 29df7b3..9fe81f6 100644
--- a/README.md
+++ b/README.md
@@ -1,9 +1,32 @@
-# nfcandroid_nfc_hidlimpl
+# nfcandroid_nxp_ese_clients
+
+This Repo contains any additional information/files required to support the release
 
 ####Git Repository
 
 | DESCRIPTION        | CHECKOUT COMMAND          |
 | :-------------: |:-------------:| 
+| nfcandroid_nxp_ese_clients    |  git clone https://github.com/NXPNFCProject/nfcandroid_nxp_ese_clients.git |
+
+####Supported Versions on "master" Branch
+
+| Android Version        | NXP Release          | NXP Tag  |
+| :-------------: |:-------------:| :-----:|
+| android-p-preview 2               |  9.00.08 (SN100x) |  NFC_NCIHALx_AR2000.09.00.08_OpnSrc |
+| android-p-preview 2               |  9.00.0A (SN100x) |  NFC_NCIHALx_AR2000.09.00.0A_OpnSrc |
+| android-p-preview 2               |  9.00.0C (SN100x) |  NFC_NCIHALx_AR2000.09.00.0C_OpnSrc |
+| android-p-preview 2               |  9.00.0D (SN100x) |  NFC_NCIHALx_AR2000.09.00.0D_OpnSrc |
+| android-p-preview 2               |  9.00.0F (SN100x) |  NFC_NCIHALx_AR2000.09.00.0F_OpnSrc |
+| android-p-preview 2               |  9.00.11 (SN100x) |  NFC_NCIHALx_AR2000.09.00.11_OpnSrc |
+| android-p-preview 2               |  9.00.13 (SN100x) |  NFC_NCIHALx_AR2000.09.00.13_OpnSrc |
+| android-p-preview 2               |  9.00.15 (SN100x) |  NFC_NCIHALx_AR2000.09.00.15_OpnSrc |
+
+# nfcandroid_nfc_hidlimpl
+
+####Git Repository
+
+| DESCRIPTION        | CHECKOUT COMMAND          |
+| :-------------: |:-------------:|
 | nfcandroid_nfc_hidlimpl    |  git clone https://github.com/NXPNFCProject/nfcandroid_nfc_hidlimpl.git |
 
 ####Supported Versions on "br_android_ncihalx_row_p" Branch
@@ -11,3 +34,6 @@
 | Android Version        | NXP Release          | NXP Tag  |
 | :-------------: |:-------------:| :-----:|
 | android-p-preview 2               |  9.0.D (PN553) |  NFC_NCIHALx_AR00C0.9.0.D_OpnSrc |
+| android-9.0.0_r3              |  9.1.0 (PN557) |  NFC_NCIHALx_AR0800.9.1.0_OpnSrc |
+| android-9.0.0_r3              |  9.2.0 (PN81T/PN557) |  NFC_NCIHALx_AR1800.9.2.0_OpnSrc |
+| android-9.0.0_r3               |  9.3.0 (PN553) |  NFC_NCIHALx_AR0040.9.3.0_OpnSrc |
diff --git a/extns/impl/hal_nxpnfc.h b/extns/impl/hal_nxpnfc.h
index 6a4e2bb..5e4f5ca 100755
--- a/extns/impl/hal_nxpnfc.h
+++ b/extns/impl/hal_nxpnfc.h
@@ -17,6 +17,8 @@
  ******************************************************************************/
 #ifndef ANDROID_HARDWARE_HAL_NXPNFC_V1_0_H
 #define ANDROID_HARDWARE_HAL_NXPNFC_V1_0_H
+#include <vector>
+#include <string>
 
 #define NFC_NCI_NXP_PN54X_HARDWARE_MODULE_ID "nfc_nci.nqx"
 #define MAX_IOCTL_TRANSCEIVE_CMD_LEN 256
@@ -38,26 +40,27 @@ enum {
   HAL_NFC_IOCTL_NCI_TRANSCEIVE,
   HAL_NFC_IOCTL_P61_GET_ACCESS,
   HAL_NFC_IOCTL_P61_REL_ACCESS,
-  HAL_NFC_IOCTL_ESE_CHIP_RST,
-  HAL_NFC_IOCTL_REL_SVDD_WAIT,
-  HAL_NFC_IOCTL_SET_JCP_DWNLD_ENABLE,
-  HAL_NFC_IOCTL_SET_JCP_DWNLD_DISABLE,
-  HAL_NFC_IOCTL_SET_NFC_SERVICE_PID,
-  HAL_NFC_IOCTL_GET_FEATURE_LIST,
   HAL_NFC_IOCTL_P61_REL_ESE_PWR,
   HAL_NFC_IOCTL_P61_SET_ESE_PWR,
+  HAL_NFC_IOCTL_ESE_CHIP_RST,
   HAL_NFC_SET_SPM_PWR,
   HAL_NFC_INHIBIT_PWR_CNTRL,
+  HAL_NFC_IOCTL_REL_SVDD_WAIT,
+  HAL_NFC_IOCTL_SET_JCP_DWNLD_ENABLE,
   HAL_NFC_IOCTL_SPI_DWP_SYNC,
   HAL_NFC_IOCTL_RF_STATUS_UPDATE,
+  HAL_NFC_IOCTL_SET_JCP_DWNLD_DISABLE,
+  HAL_NFC_IOCTL_SET_NFC_SERVICE_PID,
   HAL_NFC_IOCTL_REL_DWP_WAIT,
+  HAL_NFC_IOCTL_GET_FEATURE_LIST,
   HAL_NFC_SET_POWER_SCHEME,
   HAL_NFC_GET_SPM_STATUS,
   HAL_NFC_GET_ESE_ACCESS,
   HAL_NFC_SET_DWNLD_STATUS,
   HAL_NFC_GET_NXP_CONFIG,
   HAL_NFC_IOCTL_RF_ACTION_NTF,
-  HAL_NFC_IOCTL_SET_TRANSIT_CONFIG
+  HAL_NFC_IOCTL_SET_TRANSIT_CONFIG,
+  HAL_NFC_IOCTL_NFCEE_SESSION_RESET
 };
 
 enum {
@@ -88,6 +91,41 @@ typedef struct {
   uint8_t uicc_wired_prt_mask;
   uint8_t wired_mode_rf_field_enable;
   uint8_t aid_block_route;
+
+  uint8_t esePowerDhControl;
+  uint8_t tagOpTimeout;
+  uint8_t loaderServiceVersion;
+  uint8_t defaultNfceeDiscTimeout;
+  uint8_t dualUiccEnable;
+  uint8_t ceRouteStrictDisable;
+  uint32_t osDownloadTimeoutValue;
+  uint8_t nxpDefaultSe;
+  uint8_t defaultAidRoute;
+  uint8_t defaultAidPwrState;
+  uint8_t defaultRoutePwrState;
+  uint8_t defaultOffHostPwrState;
+  uint8_t jcopDlAtBootEnable;
+  uint8_t defaultNfceeTimeout;
+  uint8_t nxpNfcChip;
+  uint8_t coreScrnOffAutonomousEnable;
+  uint8_t p61LsDefaultInterface;
+  uint8_t p61JcopDefaultInterface;
+  uint8_t agcDebugEnable;
+  uint8_t felicaCltPowerState;
+  uint32_t cmdRspTimeoutValue;
+  uint8_t checkDefaultProtoSeId;
+  uint8_t nfccPassiveListenTimeout;
+  uint32_t nfccStandbyTimeout;
+  uint32_t wmMaxWtxCount;
+  uint32_t nfccRfFieldEventTimeout;
+  uint8_t allowWiredInMifareDesfireClt;
+  uint8_t dwpIntfResetEnable;
+  uint8_t nxpLogHalLoglevel;
+  uint8_t nxpLogExtnsLogLevel;
+  uint8_t nxpLogTmlLogLevel;
+  uint8_t nxpLogFwDnldLogLevel;
+  uint8_t nxpLogNcixLogLevel;
+  uint8_t nxpLogNcirLogLevel;
 } nxp_nfc_config_t;
 /*
  * nfc_nci_ExtnRsp_t shall contain response for command sent in transceive
diff --git a/halimpl/dnld/phDnldNfc_Internal.cc b/halimpl/dnld/phDnldNfc_Internal.cc
index 3292f9c..6559fc5 100755
--- a/halimpl/dnld/phDnldNfc_Internal.cc
+++ b/halimpl/dnld/phDnldNfc_Internal.cc
@@ -232,6 +232,7 @@ static void phDnldNfc_ProcessSeqState(void* pContext,
         }
         pDlCtxt->tCurrState = phDnldNfc_StateSend;
       }
+      [[fallthrough]];
       case phDnldNfc_StateSend: {
         wStatus = phDnldNfc_BuildFramePkt(pDlCtxt);
 
@@ -280,6 +281,7 @@ static void phDnldNfc_ProcessSeqState(void* pContext,
           pDlCtxt->tCurrState = phDnldNfc_StateResponse;
         }
       }
+      [[fallthrough]];
       case phDnldNfc_StateTimer: {
         if (1 == (pDlCtxt->TimerInfo.TimerStatus)) /*Is Timer Running*/
         {
@@ -289,6 +291,7 @@ static void phDnldNfc_ProcessSeqState(void* pContext,
         }
         pDlCtxt->tCurrState = phDnldNfc_StateResponse;
       }
+      [[fallthrough]];
       case phDnldNfc_StateResponse: {
         if (NFCSTATUS_RF_TIMEOUT != (pDlCtxt->TimerInfo.wTimerExpStatus)) {
           /* Process response */
@@ -378,6 +381,7 @@ static void phDnldNfc_ProcessRWSeqState(void* pContext,
         }
         pDlCtxt->tCurrState = phDnldNfc_StateSend;
       }
+      [[fallthrough]];
       case phDnldNfc_StateSend: {
         if (false == pDlCtxt->bResendLastFrame) {
           wStatus = phDnldNfc_BuildFramePkt(pDlCtxt);
@@ -432,6 +436,7 @@ static void phDnldNfc_ProcessRWSeqState(void* pContext,
           pDlCtxt->tCurrState = phDnldNfc_StateResponse;
         }
       }
+      [[fallthrough]];
       case phDnldNfc_StateTimer: {
         if (1 == (pDlCtxt->TimerInfo.TimerStatus)) /*Is Timer Running*/
         {
@@ -441,6 +446,7 @@ static void phDnldNfc_ProcessRWSeqState(void* pContext,
         }
         pDlCtxt->tCurrState = phDnldNfc_StateResponse;
       }
+      [[fallthrough]];
       case phDnldNfc_StateResponse: {
         if (NFCSTATUS_RF_TIMEOUT != (pDlCtxt->TimerInfo.wTimerExpStatus)) {
           /* Process response */
diff --git a/halimpl/hal/phNxpNciHal.cc b/halimpl/hal/phNxpNciHal.cc
index 2f5562c..580801e 100644
--- a/halimpl/hal/phNxpNciHal.cc
+++ b/halimpl/hal/phNxpNciHal.cc
@@ -44,6 +44,7 @@ using android::base::WriteStringToFile;
 #define PN547C2_CLOCK_SETTING
 #undef PN547C2_FACTORY_RESET_DEBUG
 #define CORE_RES_STATUS_BYTE 3
+#define SIGNAL_TRIGGER_NOT_REQD 0x10
 
 const char RF_BLOCK_LIST[6][18] =
 {
@@ -78,7 +79,6 @@ static uint8_t config_access = false;
 static uint8_t config_success = true;
 static uint8_t fw_download_success = 0;
 static NFCSTATUS phNxpNciHal_FwDwnld(uint16_t aType);
-static NFCSTATUS phNxpNciHal_SendCmd(uint8_t cmd_len, uint8_t* pcmd_buff);
 /* NCI HAL Control structure */
 phNxpNciHal_Control_t nxpncihal_ctrl;
 
@@ -211,7 +211,6 @@ static void* phNxpNciHal_client_thread(void* arg) {
     if (p_nxpncihal_ctrl->thread_running == 0) {
       break;
     }
-
     switch (msg.eMsgType) {
       case PH_LIBNFC_DEFERREDCALL_MSG: {
         phLibNfc_DeferredCall_t* deferCall =
@@ -241,8 +240,8 @@ static void* phNxpNciHal_client_thread(void* arg) {
           /* Send the event */
           (*nxpncihal_ctrl.p_nfc_stack_cback)(HAL_NFC_CLOSE_CPLT_EVT,
                                               HAL_NFC_STATUS_OK);
-          phNxpNciHal_kill_client_thread(&nxpncihal_ctrl);
         }
+        phNxpNciHal_kill_client_thread(&nxpncihal_ctrl);
         REENTRANCE_UNLOCK();
         break;
       }
@@ -500,7 +499,7 @@ static NFCSTATUS phNxpNciHal_fw_download(void) {
     if (NFCSTATUS_SUCCESS != phNxpNciHal_fw_mw_ver_check()) {
       NXPLOG_NCIHAL_D("Chip Version Middleware Version mismatch!!!!");
       phOsalNfc_Timer_Cleanup();
-      phTmlNfc_Shutdown();
+      phTmlNfc_Shutdown_CleanUp();
       status = NFCSTATUS_FAILED;
     } else {
       NXPLOG_NCIHAL_E("FW download failed, Continue NFCC init");
@@ -518,7 +517,7 @@ static NFCSTATUS phNxpNciHal_fw_download(void) {
       (pphTmlNfc_TransactCompletionCb_t)&phNxpNciHal_read_complete, NULL);
   if (readRestoreStatus != NFCSTATUS_PENDING) {
     NXPLOG_NCIHAL_E("TML Read status error status = %x", readRestoreStatus);
-    readRestoreStatus = phTmlNfc_Shutdown();
+    readRestoreStatus = phTmlNfc_Shutdown_CleanUp();
     if (readRestoreStatus != NFCSTATUS_SUCCESS) {
       NXPLOG_NCIHAL_E("TML Shutdown failed. Status  = %x", readRestoreStatus);
     }
@@ -722,10 +721,6 @@ int phNxpNciHal_MinInit(nfc_stack_callback_t* p_cback,
   phOsalNfc_Config_t tOsalConfig;
   phTmlNfc_Config_t tTmlConfig;
   int init_retry_cnt = 0;
-  /*NCI_RESET_CMD*/
-  uint8_t cmd_reset_nci[] = {0x20, 0x00, 0x01, 0x01};
-  /*NCI_INIT_CMD*/
-  uint8_t cmd_init_nci[] = {0x20, 0x01, 0x00};
   uint8_t boot_mode = nxpncihal_ctrl.hal_boot_mode;
   char* nfc_dev_node = NULL;
   const uint16_t max_len = 260;
@@ -800,18 +795,25 @@ int phNxpNciHal_MinInit(nfc_stack_callback_t* p_cback,
           (pphTmlNfc_TransactCompletionCb_t)&phNxpNciHal_read_complete, NULL);
       if (status == NFCSTATUS_PENDING) {
         phNxpNciHal_ext_init();
-        do {
-          status = phNxpNciHal_SendCmd(sizeof(cmd_reset_nci), cmd_reset_nci);
-          if (status == NFCSTATUS_SUCCESS) {
-            status = phNxpNciHal_SendCmd(sizeof(cmd_init_nci), cmd_init_nci);
-          }
+        status = phNxpNciHal_nfcc_core_reset_init();
+        if (status != NFCSTATUS_SUCCESS) {
+          status = phNxpNciHal_FwDwnld(NFC_STATUS_NOT_INITIALIZED);
           if (status != NFCSTATUS_SUCCESS) {
-            (void)phNxpNciHal_power_cycle();
+            return NFCSTATUS_FAILED;
           } else {
-            break;
+            do {
+              status = phNxpNciHal_nfcc_core_reset_init();
+              if (status != NFCSTATUS_SUCCESS) {
+                (void)phNxpNciHal_power_cycle();
+              } else {
+                break;
+              }
+              init_retry_cnt++;
+            } while (init_retry_cnt < 0x03);
           }
-          init_retry_cnt++;
-        } while (init_retry_cnt < 0x03);
+        } else {
+          /*Do Nothing*/
+        }
       }
     }
     pthread_attr_destroy(&attr);
@@ -822,10 +824,9 @@ int phNxpNciHal_MinInit(nfc_stack_callback_t* p_cback,
     /* print message*/
     phNxpNciHal_core_MinInitialized_complete(status);
   } else {
-    phTmlNfc_Shutdown();
-  if (p_cback != NULL) {
-    (*p_cback)(HAL_NFC_OPEN_CPLT_EVT,
-               HAL_NFC_STATUS_FAILED);
+    phTmlNfc_Shutdown_CleanUp();
+    if (p_cback != NULL) {
+      (*p_cback)(HAL_NFC_OPEN_CPLT_EVT, HAL_NFC_STATUS_FAILED);
   }
     /* Report error status */
     nxpncihal_ctrl.p_nfc_stack_cback = NULL;
@@ -840,17 +841,6 @@ int phNxpNciHal_MinInit(nfc_stack_callback_t* p_cback,
   return status;
 }
 
-static NFCSTATUS phNxpNciHal_SendCmd(uint8_t cmd_len, uint8_t* pcmd_buff) {
-  int counter = 0x00;
-  NFCSTATUS status;
-  do {
-    status = NFCSTATUS_FAILED;
-    status = phNxpNciHal_send_ext_cmd(cmd_len, pcmd_buff);
-    counter++;
-  } while (counter < 0x03 && status != NFCSTATUS_SUCCESS);
-  return status;
-}
-
 /******************************************************************************
  * Function         phNxpNciHal_MinOpen
  *
@@ -870,7 +860,7 @@ int phNxpNciHal_MinOpen() {
   NFCSTATUS wConfigStatus = NFCSTATUS_SUCCESS;
   NFCSTATUS status = NFCSTATUS_SUCCESS;
   uint8_t boot_mode = nxpncihal_ctrl.hal_boot_mode;
-  uint8_t* nfc_dev_node = NULL;
+  char* nfc_dev_node = NULL;
   nxpncihal_ctrl.bIsForceFwDwnld = false;
   NXPLOG_NCIHAL_D("phNxpNci_MinOpen(): enter");
   /*NCI_INIT_CMD*/
@@ -935,16 +925,16 @@ int phNxpNciHal_MinOpen() {
   memset(mGetCfg_info, 0x00, sizeof(phNxpNci_getCfg_info_t));
 
   /*Read the nfc device node name*/
-  nfc_dev_node = (uint8_t*)nxp_malloc(max_len * sizeof(uint8_t));
+  nfc_dev_node = (char*)malloc(max_len * sizeof(char));
   if (nfc_dev_node == NULL) {
     NXPLOG_NCIHAL_E("malloc of nfc_dev_node failed ");
     goto minCleanAndreturn;
-  } else if (!GetNxpStrValue(NAME_NXP_NFC_DEV_NODE, (char*)nfc_dev_node,
+  } else if (!GetNxpStrValue(NAME_NXP_NFC_DEV_NODE, nfc_dev_node,
                              max_len)) {
     NXPLOG_NCIHAL_E(
         "Invalid nfc device node name keeping the default device node "
         "/dev/nq-nci");
-    strlcpy((char*)nfc_dev_node, "/dev/nq-nci", max_len);
+    strlcpy(nfc_dev_node, "/dev/nq-nci", max_len);
   }
 
   /* Configure hardware link */
@@ -968,15 +958,11 @@ int phNxpNciHal_MinOpen() {
   }
 
   /* Create the client thread */
-  pthread_attr_t attr;
-  pthread_attr_init(&attr);
-  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-  ret_val = pthread_create(&nxpncihal_ctrl.client_thread, &attr,
+  ret_val = pthread_create(&nxpncihal_ctrl.client_thread, NULL,
                            phNxpNciHal_client_thread, &nxpncihal_ctrl);
-  pthread_attr_destroy(&attr);
   if (ret_val != 0) {
     NXPLOG_NCIHAL_E("pthread_create failed");
-    wConfigStatus = phTmlNfc_Shutdown();
+    wConfigStatus = phTmlNfc_Shutdown_CleanUp();
     goto minCleanAndreturn;
   }
 
@@ -988,7 +974,7 @@ int phNxpNciHal_MinOpen() {
       (pphTmlNfc_TransactCompletionCb_t)&phNxpNciHal_read_complete, NULL);
   if (status != NFCSTATUS_PENDING) {
     NXPLOG_NCIHAL_E("TML Read status error status = %x", status);
-    wConfigStatus = phTmlNfc_Shutdown();
+    wConfigStatus = phTmlNfc_Shutdown_CleanUp();
     wConfigStatus = NFCSTATUS_FAILED;
     goto minCleanAndreturn;
   }
@@ -1013,7 +999,7 @@ init_retry:
       goto init_retry;
     } else
       init_retry_cnt = 0;
-    wConfigStatus = phTmlNfc_Shutdown();
+    wConfigStatus = phTmlNfc_Shutdown_CleanUp();
     wConfigStatus = NFCSTATUS_FAILED;
     goto minCleanAndreturn;
   }
@@ -1042,7 +1028,7 @@ init_retry:
       goto init_retry;
     } else
       init_retry_cnt = 0;
-    wConfigStatus = phTmlNfc_Shutdown();
+    wConfigStatus = phTmlNfc_Shutdown_CleanUp();
     wConfigStatus = NFCSTATUS_FAILED;
     goto minCleanAndreturn;
   }
@@ -1611,6 +1597,9 @@ int phNxpNciHal_core_initialized(uint8_t* p_core_init_rsp_params) {
   static uint8_t cmd_reset_nci[] = {0x20, 0x00, 0x01, 0x00};
   static uint8_t cmd_init_nci2_0[] = {0x20,0x01,0x02,0x00,0x00};
   static uint8_t cmd_get_cfg_dbg_info[] = {0x20, 0x03, 0x4, 0xA0, 0x1B, 0xA0, 0x27};
+  /*fix to disable mifare clt emulation for jcop v4.1*/
+  static uint8_t cmd_mf_clt_jcop_cfg[] = {0x20, 0x02, 0x05, 0x01,
+                                          0xA0, 0x6B, 0x01, 0x00};
 
   config_success = true;
   long bufflen = 260;
@@ -1728,17 +1717,19 @@ int phNxpNciHal_core_initialized(uint8_t* p_core_init_rsp_params) {
     goto retry_core_init;
   }
 
-    retlen = 0;
-
-    isfound = GetNxpByteArrayValue(NAME_NXP_CORE_STANDBY, (char *)buffer,
-                                   bufflen, &retlen);
-    if (retlen > 0) {
-      /* NXP ACT Proprietary Ext */
-      status = phNxpNciHal_send_ext_cmd(retlen, buffer);
+  retlen = 0;
+  if ((nfcFL.chipType == pn553) || (nfcFL.chipType == pn557)) {
+    if (GetNxpNumValue(NAME_NXP_MF_CLT_JCOP_CFG, (void *)&retlen,
+                       sizeof(retlen))) {
+      cmd_mf_clt_jcop_cfg[7] = 0x01 & retlen;
+      status = phNxpNciHal_send_ext_cmd(sizeof(cmd_mf_clt_jcop_cfg),
+                                        cmd_mf_clt_jcop_cfg);
       if (status != NFCSTATUS_SUCCESS) {
-        NXPLOG_NCIHAL_E("Stand by mode enable failed");
-        NXP_NCI_HAL_CORE_INIT_RECOVER(retry_core_init_cnt, retry_core_init);
+        NXPLOG_NCIHAL_E("cmd_mf_clt_jcop_cfg: Failed");
+        retry_core_init_cnt++;
+        goto retry_core_init;
       }
+    }
   }
 
   if(nfcFL.eseFL._ESE_SVDD_SYNC) {
@@ -2879,6 +2870,12 @@ close_and_return:
 
     status = phTmlNfc_Shutdown();
 
+    if (0 != pthread_join(nxpncihal_ctrl.client_thread, (void **)NULL)) {
+      NXPLOG_TML_E("Fail to kill client thread!");
+    }
+
+    phTmlNfc_CleanUp();
+
     phDal4Nfc_msgrelease(nxpncihal_ctrl.gDrvCfg.nClientId);
 
     memset(&nxpncihal_ctrl, 0x00, sizeof(nxpncihal_ctrl));
@@ -2914,6 +2911,7 @@ int phNxpNciHal_Minclose(void) {
   if (status != NFCSTATUS_SUCCESS) {
     NXPLOG_NCIHAL_E("NCI_CORE_RESET: Failed");
   }
+  sem_destroy(&nxpncihal_ctrl.syncSpiNfc);
   if (NULL != gpphTmlNfc_Context->pDevHandle) {
     phNxpNciHal_close_complete(NFCSTATUS_SUCCESS);
     /* Abort any pending read and write */
@@ -2924,6 +2922,12 @@ int phNxpNciHal_Minclose(void) {
 
     status = phTmlNfc_Shutdown();
 
+    if (0 != pthread_join(nxpncihal_ctrl.client_thread, (void **)NULL)) {
+      NXPLOG_TML_E("Fail to kill client thread!");
+    }
+
+    phTmlNfc_CleanUp();
+
     phDal4Nfc_msgrelease(nxpncihal_ctrl.gDrvCfg.nClientId);
 
     memset(&nxpncihal_ctrl, 0x00, sizeof(nxpncihal_ctrl));
@@ -2935,6 +2939,8 @@ int phNxpNciHal_Minclose(void) {
 
   phNxpNciHal_cleanup_monitor();
 
+  write_unlocked_status = NFCSTATUS_SUCCESS;
+  phNxpNciHal_release_info();
   /* Return success always */
   return NFCSTATUS_SUCCESS;
 }
@@ -2994,8 +3000,11 @@ int phNxpNciHal_configDiscShutdown(void) {
  ******************************************************************************/
 void phNxpNciHal_getNxpConfig(nfc_nci_IoctlInOutData_t *pInpOutData) {
   unsigned long num = 0;
+  memset(&pInpOutData->out.data.nxpConfigs, 0x00, sizeof(pInpOutData->out.data.nxpConfigs));
   if (GetNxpNumValue(NAME_NXP_ESE_LISTEN_TECH_MASK, &num, sizeof(num))) {
     pInpOutData->out.data.nxpConfigs.ese_listen_tech_mask = num;
+  }else {
+    pInpOutData->out.data.nxpConfigs.ese_listen_tech_mask = 0x07;
   }
   if (GetNxpNumValue(NAME_NXP_DEFAULT_NFCEE_DISC_TIMEOUT, &num, sizeof(num))) {
     pInpOutData->out.data.nxpConfigs.default_nfcee_disc_timeout = num;
@@ -3015,6 +3024,112 @@ void phNxpNciHal_getNxpConfig(nfc_nci_IoctlInOutData_t *pInpOutData) {
   if (GetNxpNumValue(NAME_AID_BLOCK_ROUTE, &num, sizeof(num))) {
     pInpOutData->out.data.nxpConfigs.aid_block_route = num;
   }
+  if (GetNxpNumValue(NAME_NXP_ESE_POWER_DH_CONTROL, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.esePowerDhControl = num;
+  }
+  if (GetNxpNumValue(NAME_NXP_SWP_RD_TAG_OP_TIMEOUT, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.tagOpTimeout = num;
+  }
+  if (GetNxpNumValue(NAME_NXP_LOADER_SERICE_VERSION, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.loaderServiceVersion = num;
+  }
+  if (GetNxpNumValue(NAME_NXP_DEFAULT_NFCEE_DISC_TIMEOUT, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.defaultNfceeDiscTimeout = num;
+  }
+  if (GetNxpNumValue(NAME_NXP_DUAL_UICC_ENABLE, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.dualUiccEnable = num;
+  }
+  if (GetNxpNumValue(NAME_NXP_CE_ROUTE_STRICT_DISABLE, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.ceRouteStrictDisable = num;
+  }
+  if (GetNxpNumValue(NAME_OS_DOWNLOAD_TIMEOUT_VALUE, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.osDownloadTimeoutValue = num;
+  }
+  if (GetNxpNumValue(NAME_NXP_DEFAULT_SE, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.nxpDefaultSe = num;
+  }
+  if (GetNxpNumValue(NAME_DEFAULT_AID_ROUTE, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.defaultAidRoute = num;
+  }
+  if (GetNxpNumValue(NAME_DEFAULT_AID_PWR_STATE, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.defaultAidPwrState = num;
+  }
+  if (GetNxpNumValue(NAME_DEFAULT_ROUTE_PWR_STATE, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.defaultRoutePwrState = num;
+  }
+  if (GetNxpNumValue(NAME_DEFAULT_OFFHOST_PWR_STATE, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.defaultOffHostPwrState = num;
+  }
+  if (GetNxpNumValue(NAME_NXP_JCOPDL_AT_BOOT_ENABLE, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.jcopDlAtBootEnable = num;
+  }
+  if (GetNxpNumValue(NAME_NXP_DEFAULT_NFCEE_TIMEOUT, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.defaultNfceeTimeout = num;
+  }
+  if (GetNxpNumValue(NAME_NXP_NFC_CHIP, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.nxpNfcChip = num;
+  }
+  if (GetNxpNumValue(NAME_NXP_CORE_SCRN_OFF_AUTONOMOUS_ENABLE, &num,
+                     sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.coreScrnOffAutonomousEnable = num;
+  }
+  if (GetNxpNumValue(NAME_NXP_P61_LS_DEFAULT_INTERFACE, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.p61LsDefaultInterface = num;
+  }
+  if (GetNxpNumValue(NAME_NXP_P61_JCOP_DEFAULT_INTERFACE, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.p61JcopDefaultInterface = num;
+  }
+  if (GetNxpNumValue(NAME_NXP_AGC_DEBUG_ENABLE, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.agcDebugEnable = num;
+  }
+  if (GetNxpNumValue(NAME_DEFAULT_FELICA_CLT_PWR_STATE, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.felicaCltPowerState = num;
+  } else {
+    pInpOutData->out.data.nxpConfigs.felicaCltPowerState = 0x3F;
+  }
+  if (GetNxpNumValue(NAME_NXP_HCEF_CMD_RSP_TIMEOUT_VALUE, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.cmdRspTimeoutValue = num;
+  }
+  if (GetNxpNumValue(NAME_CHECK_DEFAULT_PROTO_SE_ID, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.checkDefaultProtoSeId = num;
+  }
+  if (GetNxpNumValue(NAME_NXP_NFCC_PASSIVE_LISTEN_TIMEOUT, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.nfccPassiveListenTimeout = num;
+  }
+  if (GetNxpNumValue(NAME_NXP_NFCC_STANDBY_TIMEOUT, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.nfccStandbyTimeout = num;
+  }
+  if (GetNxpNumValue(NAME_NXP_WM_MAX_WTX_COUNT, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.wmMaxWtxCount = num;
+  }
+  if (GetNxpNumValue(NAME_NXP_NFCC_RF_FIELD_EVENT_TIMEOUT, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.nfccRfFieldEventTimeout = num;
+  }
+  if (GetNxpNumValue(NAME_NXP_ALLOW_WIRED_IN_MIFARE_DESFIRE_CLT, &num,
+                     sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.allowWiredInMifareDesfireClt = num;
+  }
+  if (GetNxpNumValue(NAME_NXP_DWP_INTF_RESET_ENABLE, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.dwpIntfResetEnable = num;
+  }
+  if (GetNxpNumValue(NAME_NXPLOG_HAL_LOGLEVEL, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.nxpLogHalLoglevel = num;
+  }
+  if (GetNxpNumValue(NAME_NXPLOG_EXTNS_LOGLEVEL, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.nxpLogExtnsLogLevel = num;
+  }
+  if (GetNxpNumValue(NAME_NXPLOG_TML_LOGLEVEL, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.nxpLogTmlLogLevel = num;
+  }
+  if (GetNxpNumValue(NAME_NXPLOG_FWDNLD_LOGLEVEL, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.nxpLogFwDnldLogLevel = num;
+  }
+  if (GetNxpNumValue(NAME_NXPLOG_NCIX_LOGLEVEL, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.nxpLogNcixLogLevel = num;
+  }
+  if (GetNxpNumValue(NAME_NXPLOG_NCIR_LOGLEVEL, &num, sizeof(num))) {
+    pInpOutData->out.data.nxpConfigs.nxpLogNcirLogLevel = num;
+  }
 }
 
 /******************************************************************************
@@ -3292,7 +3407,6 @@ int phNxpNciHal_ioctl(long arg, void* p_data) {
   phNxpNciHal_FwRfupdateInfo_t* FwRfInfo;
   NFCSTATUS fm_mw_ver_check = NFCSTATUS_FAILED;
   long level;
-
   if (nxpncihal_ctrl.halStatus == HAL_STATUS_CLOSE) {
     NFCSTATUS status = NFCSTATUS_FAILED;
     status = phNxpNciHal_MinOpen();
@@ -3302,10 +3416,9 @@ int phNxpNciHal_ioctl(long arg, void* p_data) {
         Success and 0x01 for Fail. */
         pInpOutData->out.data.nciRsp.p_rsp[3] = 0x01;
       }
+      return -1;
     }
-    return -1;
   }
-
   switch (arg) {
     case HAL_NFC_IOCTL_P61_IDLE_MODE:
         if(nfcFL.nfcNxpEse) {
@@ -3403,20 +3516,24 @@ int phNxpNciHal_ioctl(long arg, void* p_data) {
       break;
     case HAL_NFC_IOCTL_REL_SVDD_WAIT:
         if(nfcFL.nfcNxpEse && nfcFL.eseFL._ESE_SVDD_SYNC) {
-            status = phTmlNfc_rel_svdd_wait(gpphTmlNfc_Context->pDevHandle);
-            NXPLOG_NCIHAL_D("HAL_NFC_IOCTL_P61_REL_SVDD_WAIT retval = %d\n", status);
-            pInpOutData->out.data.status = status;
-            if (NFCSTATUS_SUCCESS == status) {
-                ret = 0;
+          status = phTmlNfc_rel_svdd_wait(gpphTmlNfc_Context->pDevHandle,
+                                          pInpOutData->inp.level);
+          NXPLOG_NCIHAL_D("HAL_NFC_IOCTL_P61_REL_SVDD_WAIT retval = %d\n",
+                          status);
+          pInpOutData->out.data.status = status;
+          if (NFCSTATUS_SUCCESS == status) {
+            ret = 0;
             }
         }
       break;
     case HAL_NFC_IOCTL_REL_DWP_WAIT:
         if(nfcFL.nfcNxpEse) {
-            status = phTmlNfc_rel_dwpOnOff_wait(gpphTmlNfc_Context->pDevHandle);
-            NXPLOG_NCIHAL_D("HAL_NFC_IOCTL_REL_DWP_ON_OFF_WAIT retval = %d\n", status);
-            if (NFCSTATUS_SUCCESS == status) {
-                ret = 0;
+          status = phTmlNfc_rel_dwpOnOff_wait(gpphTmlNfc_Context->pDevHandle,
+                                              pInpOutData->inp.level);
+          NXPLOG_NCIHAL_D("HAL_NFC_IOCTL_REL_DWP_ON_OFF_WAIT retval = %d\n",
+                          status);
+          if (NFCSTATUS_SUCCESS == status) {
+            ret = 0;
             }
         }
       break;
@@ -3577,8 +3694,17 @@ int phNxpNciHal_ioctl(long arg, void* p_data) {
     } break;
     case HAL_NFC_SET_SPM_PWR:
       level = pInpOutData->inp.level;
-      ret = phPalEse_spi_ioctl(phPalEse_e_ChipRst,
-                               gpphTmlNfc_Context->pDevHandle, level);
+      if (nfcFL.chipType == pn557) {
+        /*set a bit to indicate signal trigger from driver is not required for PN557*/
+        level |= SIGNAL_TRIGGER_NOT_REQD;
+        ret = phPalEse_spi_ioctl(phPalEse_e_ChipRst,
+                                 gpphTmlNfc_Context->pDevHandle, level);
+      } else {
+        ret = NFCSTATUS_FEATURE_NOT_SUPPORTED;
+      }
+      if ((nxpncihal_ctrl.halStatus == HAL_STATUS_MIN_OPEN) && (level == 0x00)) {
+        phNxpNciHal_Minclose();
+      }
       break;
     case HAL_NFC_SET_POWER_SCHEME:
       level = pInpOutData->inp.level;
@@ -3626,6 +3752,10 @@ int phNxpNciHal_ioctl(long arg, void* p_data) {
           pInpOutData->inp.data.transitConfig.val);
       ret = 0;
       break;
+    case HAL_NFC_IOCTL_NFCEE_SESSION_RESET:
+      phNxpNciHal_reset_nfcee_session(true);
+      ret = 0;
+      break;
     default:
       NXPLOG_NCIHAL_E("%s : Wrong arg = %ld", __func__, arg);
       break;
@@ -4214,8 +4344,6 @@ __attribute__((unused)) void phNxpNciHal_enable_i2c_fragmentation() {
  *
  ******************************************************************************/
 void phNxpNciHal_reset_nfcee_session(bool force_session_reset) {
-  struct stat st;
-  int ret = 0;
   size_t length;
 
   NFCSTATUS status = NFCSTATUS_FAILED;
@@ -4226,7 +4354,6 @@ void phNxpNciHal_reset_nfcee_session(bool force_session_reset) {
       return;
     }
   }
-  const char config_eseinfo_path[] = "/data/nfc/nfaStorage.bin1";
   uint8_t *reset_ese_session_identity_set;
   uint8_t ese_session_dyn_uicc_nv[] = {
             0x20, 0x02, 0x22, 0x03, 0xA0, 0xEA, 0x08, 0xFF, 0xFF, 0xFF,
@@ -4269,14 +4396,8 @@ void phNxpNciHal_reset_nfcee_session(bool force_session_reset) {
   static uint8_t reset_session_identity[] = {0x20, 0x03, 0x05, 0x02,
                                                  0xA0, 0xEA, 0xA0, 0xEB};
 #endif
-  if (stat(config_eseinfo_path, &st) == -1) {
-    NXPLOG_NCIHAL_D("%s file not present = %s", __func__, config_eseinfo_path);
-    ret = -1;
-  } else {
-    ret = 0;
-  }
 
-  if (ret == -1 || force_session_reset) {
+  if (force_session_reset) {
 #ifdef PN547C2_FACTORY_RESET_DEBUG
     /* NXP ACT Proprietary Ext */
     status = phNxpNciHal_send_ext_cmd(length, reset_session_identity);
diff --git a/halimpl/hal/phNxpNciHal_ext.cc b/halimpl/hal/phNxpNciHal_ext.cc
index bf09283..86149bb 100755
--- a/halimpl/hal/phNxpNciHal_ext.cc
+++ b/halimpl/hal/phNxpNciHal_ext.cc
@@ -23,6 +23,7 @@
 #include <phDnldNfc.h>
 #include "phNxpNciHal_nciParser.h"
 #include <phNxpNciHal_Adaptation.h>
+
 /* Timeout value to wait for response from PN548AD */
 #define HAL_EXTNS_WRITE_RSP_TIMEOUT (2500)
 
@@ -75,6 +76,7 @@ static void hal_extns_write_rsp_timeout_cb(uint32_t TimerId, void* pContext);
 #define PROPRIETARY_CMD_FELICA_READER_MODE 0xFE
 static uint8_t gFelicaReaderMode;
 static NFCSTATUS phNxpNciHal_ext_process_nfc_init_rsp(uint8_t* p_ntf, uint16_t* p_len);
+
 /*******************************************************************************
 **
 ** Function         phNxpNciHal_ext_init
@@ -246,7 +248,10 @@ NFCSTATUS phNxpNciHal_process_ext_rsp(uint8_t* p_ntf, uint16_t* p_len) {
         break;
     }
   }
-  phNxpNciHal_ext_process_nfc_init_rsp(p_ntf, p_len);
+
+  status = phNxpNciHal_ext_process_nfc_init_rsp(p_ntf, p_len);
+  if (status != NFCSTATUS_SUCCESS)
+    return status;
 
   if (p_ntf[0] == 0x61 && p_ntf[1] == 0x05 && p_ntf[2] == 0x15 &&
       p_ntf[4] == 0x01 && p_ntf[5] == 0x06 && p_ntf[6] == 0x06) {
@@ -475,9 +480,9 @@ static NFCSTATUS phNxpNciHal_ext_process_nfc_init_rsp(uint8_t* p_ntf, uint16_t*
         if(nxpncihal_ctrl.hal_ext_enabled == TRUE) {
           nxpncihal_ctrl.nci_info.wait_for_ntf = TRUE;
         }
-      } else if(p_ntf[2] == 0x03 && p_ntf[3] == 0x00){
-          NXPLOG_NCIHAL_D("CORE_RESET_RSP NCI1.0");
-          nxpncihal_ctrl.nci_info.nci_version = p_ntf[4];
+      } else if (p_ntf[2] == 0x03 && p_ntf[3] == 0x00) {
+        NXPLOG_NCIHAL_D("CORE_RESET_RSP NCI1.0");
+        nxpncihal_ctrl.nci_info.nci_version = p_ntf[4];
       }
     } else if (p_ntf[0] == NCI_MT_NTF && ((p_ntf[1] & NCI_OID_MASK) == NCI_MSG_CORE_RESET)) {
         if(p_ntf[3] == CORE_RESET_TRIGGER_TYPE_CORE_RESET_CMD_RECEIVED ||
@@ -626,6 +631,18 @@ static NFCSTATUS phNxpNciHal_process_ext_cmd_rsp(uint16_t cmd_len,
     }
   }
 
+  NXPLOG_NCIHAL_E("nxpncihal_ctrl.ext_cb_data.status 0x%x",
+                  nxpncihal_ctrl.ext_cb_data.status);
+
+  if (nxpncihal_ctrl.ext_cb_data.status != NFCSTATUS_SUCCESS &&
+      p_cmd[0] == 0x40 && p_cmd[1] == 0x00 && p_cmd[2] == 0x03 &&
+      p_cmd[3] != 0x00) {
+    NXPLOG_NCIHAL_E("Core Reset Syntax Error status=0x%x",
+                    nxpncihal_ctrl.ext_cb_data.status);
+    status = NFCSTATUS_FAILED;
+    goto clean_and_return;
+  }
+
   if (nxpncihal_ctrl.ext_cb_data.status != NFCSTATUS_SUCCESS &&
       p_cmd[0] != 0x2F && p_cmd[1] != 0x1 && p_cmd[2] == 0x01) {
     NXPLOG_NCIHAL_E(
diff --git a/halimpl/libnfc-nxp-PN80T_example.conf b/halimpl/libnfc-nxp-PN80T_example.conf
index fb89ce6..e2270d1 100644
--- a/halimpl/libnfc-nxp-PN80T_example.conf
+++ b/halimpl/libnfc-nxp-PN80T_example.conf
@@ -357,6 +357,16 @@ DEFAULT_OFFHOST_PWR_STATE=0x1B
 # bit pos 2 = Battery Off
 # bit pos 3 = Screen Lock
 # bit pos 4 = Screen Off
+DEFAULT_FELICA_CLT_PWR_STATE=0x1B
+
+###############################################################################
+#Set the SYS_CODE Power state :
+#This settings will be used when application does not set this parameter
+# bit pos 0 = Switch On
+# bit pos 1 = Switch Off
+# bit pos 2 = Battery Off
+# bit pos 3 = Screen Lock
+# bit pos 4 = Screen Off
 DEFAULT_SYS_CODE_PWR_STATE=0x1B
 
 ###############################################################################
@@ -612,3 +622,9 @@ PRESENCE_CHECK_ALGORITHM=2
 ISO_DEP_MAX_TRANSCEIVE=0xFEFF
 
 ###############################################################################
+# Disable Mifare CLT for JCOP4.1
+# Enable            0x01
+# Disable           0x00
+#NXP_MF_CLT_JCOP_CFG=0x01
+
+###############################################################################
diff --git a/halimpl/libnfc-nxp-PN80T_example_NCI2_0.conf b/halimpl/libnfc-nxp-PN80T_example_NCI2_0.conf
index 4c61fff..5218b97 100755
--- a/halimpl/libnfc-nxp-PN80T_example_NCI2_0.conf
+++ b/halimpl/libnfc-nxp-PN80T_example_NCI2_0.conf
@@ -280,8 +280,9 @@ DEFAULT_FELICA_CLT_ROUTE=0x01
 # bit pos 0 = Switch On
 # bit pos 1 = Switch Off
 # bit pos 2 = Battery Off
-# bit pos 3 = Screen Lock
-# bit pos 4 = Screen Off
+# bit pos 3 = Switched On Sub-State 1 : Screen is off and device is unlocked
+# bit pos 4 = Switched On Sub-State 2 : Screen is on and device is locked
+# bit pos 5 = Switched On Sub-State 3 : Screen is off and device is locked
 DEFAULT_AID_PWR_STATE=0x19
 
 ###############################################################################
@@ -290,8 +291,9 @@ DEFAULT_AID_PWR_STATE=0x19
 # bit pos 0 = Switch On
 # bit pos 1 = Switch Off
 # bit pos 2 = Battery Off
-# bit pos 3 = Screen Lock
-# bit pos 4 = Screen Off
+# bit pos 3 = Switched On Sub-State 1 : Screen is off and device is unlocked
+# bit pos 4 = Switched On Sub-State 2 : Screen is on and device is locked
+# bit pos 5 = Switched On Sub-State 3 : Screen is off and device is locked
 DEFAULT_DESFIRE_PWR_STATE=0x1B
 
 ###############################################################################
@@ -300,8 +302,9 @@ DEFAULT_DESFIRE_PWR_STATE=0x1B
 # bit pos 0 = Switch On
 # bit pos 1 = Switch Off
 # bit pos 2 = Battery Off
-# bit pos 3 = Screen Lock
-# bit pos 4 = Screen Off
+# bit pos 3 = Switched On Sub-State 1 : Screen is off and device is unlocked
+# bit pos 4 = Switched On Sub-State 2 : Screen is on and device is locked
+# bit pos 5 = Switched On Sub-State 3 : Screen is off and device is locked
 DEFAULT_MIFARE_CLT_PWR_STATE=0x1B
 
 ###############################################################################
@@ -310,8 +313,9 @@ DEFAULT_MIFARE_CLT_PWR_STATE=0x1B
 # bit pos 0 = Switch On
 # bit pos 1 = Switch Off
 # bit pos 2 = Battery Off
-# bit pos 3 = Screen Lock
-# bit pos 4 = Screen Off
+# bit pos 3 = Switched On Sub-State 1 : Screen is off and device is unlocked
+# bit pos 4 = Switched On Sub-State 2 : Screen is on and device is locked
+# bit pos 5 = Switched On Sub-State 3 : Screen is off and device is locked
 DEFAULT_FELICA_CLT_PWR_STATE=0x1B
 
 ###############################################################################
diff --git a/halimpl/libnfc-nxp-PN81T_example.conf b/halimpl/libnfc-nxp-PN81T_example.conf
index be3df05..1cf1eee 100644
--- a/halimpl/libnfc-nxp-PN81T_example.conf
+++ b/halimpl/libnfc-nxp-PN81T_example.conf
@@ -207,9 +207,9 @@ DEFAULT_SYS_CODE_ROUTE=0xC0
 # bit pos 0 = Switch On
 # bit pos 1 = Switch Off
 # bit pos 2 = Battery Off
-# bit pos 3 = Screen On lock
-# bit pos 4 = Screen off unlock
-# bit pos 5 = Screen Off lock
+# bit pos 3 = Switched On Sub-State 1 : Screen is off and device is unlocked
+# bit pos 4 = Switched On Sub-State 2 : Screen is on and device is locked
+# bit pos 5 = Switched On Sub-State 3 : Screen is off and device is locked
 DEFAULT_AID_PWR_STATE=0x39
 
 ###############################################################################
@@ -218,9 +218,9 @@ DEFAULT_AID_PWR_STATE=0x39
 # bit pos 0 = Switch On
 # bit pos 1 = Switch Off
 # bit pos 2 = Battery Off
-# bit pos 3 = Screen On lock
-# bit pos 4 = Screen off unlock
-# bit pos 5 = Screen Off lock
+# bit pos 3 = Switched On Sub-State 1 : Screen is off and device is unlocked
+# bit pos 4 = Switched On Sub-State 2 : Screen is on and device is locked
+# bit pos 5 = Switched On Sub-State 3 : Screen is off and device is locked
 DEFAULT_ROUTE_PWR_STATE=0x3B
 
 ###############################################################################
@@ -229,9 +229,9 @@ DEFAULT_ROUTE_PWR_STATE=0x3B
 # bit pos 0 = Switch On
 # bit pos 1 = Switch Off
 # bit pos 2 = Battery Off
-# bit pos 3 = Screen On lock
-# bit pos 4 = Screen off unlock
-# bit pos 5 = Screen Off lock
+# bit pos 3 = Switched On Sub-State 1 : Screen is off and device is unlocked
+# bit pos 4 = Switched On Sub-State 2 : Screen is on and device is locked
+# bit pos 5 = Switched On Sub-State 3 : Screen is off and device is locked
 DEFAULT_OFFHOST_PWR_STATE=0x3B
 
 ###############################################################################
@@ -240,9 +240,20 @@ DEFAULT_OFFHOST_PWR_STATE=0x3B
 # bit pos 0 = Switch On
 # bit pos 1 = Switch Off
 # bit pos 2 = Battery Off
-# bit pos 3 = Screen On lock
-# bit pos 4 = Screen off unlock
-# bit pos 5 = Screen Off lock
+# bit pos 3 = Switched On Sub-State 1 : Screen is off and device is unlocked
+# bit pos 4 = Switched On Sub-State 2 : Screen is on and device is locked
+# bit pos 5 = Switched On Sub-State 3 : Screen is off and device is locked
+DEFAULT_FELICA_CLT_PWR_STATE=0x3B
+
+###############################################################################
+#Set the SYS_CODE Power state :
+#This settings will be used when application does not set this parameter
+# bit pos 0 = Switch On
+# bit pos 1 = Switch Off
+# bit pos 2 = Battery Off
+# bit pos 3 = Switched On Sub-State 1 : Screen is off and device is unlocked
+# bit pos 4 = Switched On Sub-State 2 : Screen is on and device is locked
+# bit pos 5 = Switched On Sub-State 3 : Screen is off and device is locked
 DEFAULT_SYS_CODE_PWR_STATE=0x3B
 
 ###############################################################################
@@ -491,4 +502,14 @@ PRESENCE_CHECK_ALGORITHM=2
 # Extended APDU length for ISO_DEP
 ISO_DEP_MAX_TRANSCEIVE=0xFEFF
 
+###############################################################################
+# WiredSe Terminal name
+NXP_WIREDSE_TERMINAL_NAME="eSE3"
+
+###############################################################################
+# Disable Mifare CLT for JCOP4.1
+# Enable            0x01
+# Disable           0x00
+NXP_MF_CLT_JCOP_CFG=0x01
+
 ###############################################################################
\ No newline at end of file
diff --git a/halimpl/libnfc-nxp_RF-PN80T_example.conf b/halimpl/libnfc-nxp_RF-PN80T_example.conf
index 8aa6344..d7ccabc 100644
--- a/halimpl/libnfc-nxp_RF-PN80T_example.conf
+++ b/halimpl/libnfc-nxp_RF-PN80T_example.conf
@@ -50,7 +50,8 @@
 # UICC bit rate A0D1
 # SWP1A interface A0D4
 # DWP intf behavior config, SVDD Load activated by default if set to 0x31 A037
-NXP_CORE_CONF_EXTN={20, 02, 32, 0C,
+# For Symmetric baud rate  UICC's set A086 to 77
+NXP_CORE_CONF_EXTN={20, 02, 36, 0D,
     A0, EC, 01, 01,
     A0, ED, 01, 01,
     A0, 5E, 01, 01,
@@ -62,7 +63,8 @@ NXP_CORE_CONF_EXTN={20, 02, 32, 0C,
     A0, D8, 01, 02,
     A0, D5, 01, 0A,
     A0, B2, 01, 1E,
-    A0, 9F, 02, 08, 08
+    A0, 9F, 02, 08, 08,
+    A0, 86, 01, 77
    }
 #       A0, F2, 01, 01,
 #       A0, 40, 01, 01,
diff --git a/halimpl/libnfc-nxp_RF-PN81T_example.conf b/halimpl/libnfc-nxp_RF-PN81T_example.conf
index c71a106..53a8eb4 100644
--- a/halimpl/libnfc-nxp_RF-PN81T_example.conf
+++ b/halimpl/libnfc-nxp_RF-PN81T_example.conf
@@ -50,7 +50,8 @@
 # UICC bit rate A0D1
 # SWP1A interface A0D4
 # DWP intf behavior config, SVDD Load activated by default if set to 0x31 A037
-NXP_CORE_CONF_EXTN={20, 02, 36, 0D,
+# For Symmetric baud rate  UICC's set A086 to 77
+NXP_CORE_CONF_EXTN={20, 02, 3A, 0E,
     A0, EC, 01, 01,
     A0, ED, 01, 01,
     A0, 5E, 01, 01,
@@ -63,7 +64,8 @@ NXP_CORE_CONF_EXTN={20, 02, 36, 0D,
     A0, D5, 01, 0A,
     A0, B2, 01, 19,
     A0, 98, 01, 03,
-    A0, 9F, 02, 08, 08
+    A0, 9F, 02, 08, 08,
+    A0, 86, 01, 77
    }
 #       A0, F2, 01, 01,
 #       A0, 40, 01, 01,
diff --git a/halimpl/tml/phTmlNfc.cc b/halimpl/tml/phTmlNfc.cc
index 53713f5..19b96c1 100755
--- a/halimpl/tml/phTmlNfc.cc
+++ b/halimpl/tml/phTmlNfc.cc
@@ -47,7 +47,6 @@ phTmlNfc_i2cfragmentation_t fragmentation_enabled;
 phTmlNfc_Context_t* gpphTmlNfc_Context = NULL;
 /* Local Function prototypes */
 static NFCSTATUS phTmlNfc_StartThread(void);
-static void phTmlNfc_CleanUp(void);
 static void phTmlNfc_ReadDeferredCb(void* pParams);
 static void phTmlNfc_WriteDeferredCb(void* pParams);
 static void* phTmlNfc_TmlThread(void* pParam);
@@ -611,7 +610,7 @@ static void* phTmlNfc_TmlWriterThread(void* pParam) {
 ** Returns          None
 **
 *******************************************************************************/
-static void phTmlNfc_CleanUp(void) {
+void phTmlNfc_CleanUp(void) {
 
   if (NULL == gpphTmlNfc_Context) {
     return;
@@ -676,7 +675,6 @@ NFCSTATUS phTmlNfc_Shutdown(void) {
     }
     NXPLOG_TML_D("bThreadDone == 0");
 
-    phTmlNfc_CleanUp();
   } else {
     wShutdownStatus = PHNFCSTVAL(CID_NFC_TML, NFCSTATUS_NOT_INITIALISED);
   }
@@ -1235,3 +1233,20 @@ static int phTmlNfc_WaitReadInit(void) {
   }
   return ret;
 }
+
+/*******************************************************************************
+**
+** Function         phTmlNfc_Shutdown_CleanUp
+**
+** Description      wrapper function  for shutdown  and cleanup of resources
+**
+** Parameters       None
+**
+** Returns          NFCSTATUS
+**
+*******************************************************************************/
+NFCSTATUS phTmlNfc_Shutdown_CleanUp() {
+  NFCSTATUS wShutdownStatus = phTmlNfc_Shutdown();
+  phTmlNfc_CleanUp();
+  return wShutdownStatus;
+}
diff --git a/halimpl/tml/phTmlNfc.h b/halimpl/tml/phTmlNfc.h
index 429e8c3..8162d35 100644
--- a/halimpl/tml/phTmlNfc.h
+++ b/halimpl/tml/phTmlNfc.h
@@ -233,6 +233,8 @@ typedef enum {
 /* Function declarations */
 NFCSTATUS phTmlNfc_Init(pphTmlNfc_Config_t pConfig);
 NFCSTATUS phTmlNfc_Shutdown(void);
+NFCSTATUS phTmlNfc_Shutdown_CleanUp();
+void phTmlNfc_CleanUp(void);
 NFCSTATUS phTmlNfc_Write(uint8_t* pBuffer, uint16_t wLength,
                          pphTmlNfc_TransactCompletionCb_t pTmlWriteComplete,
                          void* pContext);
diff --git a/halimpl/tml/phTmlNfc_i2c.cc b/halimpl/tml/phTmlNfc_i2c.cc
index 3cbbe3b..0af5d57 100755
--- a/halimpl/tml/phTmlNfc_i2c.cc
+++ b/halimpl/tml/phTmlNfc_i2c.cc
@@ -540,12 +540,12 @@ NFCSTATUS phTmlNfc_get_ese_access(void* pDevHandle, long timeout) {
 ** Returns          success or failure
 **
 *******************************************************************************/
-NFCSTATUS phTmlNfc_rel_svdd_wait(void* pDevHandle) {
-    NXPLOG_TML_D("phTmlNfc_rel_svdd_wait()");
-    if(!nfcFL.nfcNxpEse && !nfcFL.eseFL._ESE_SVDD_SYNC) {
-        NXPLOG_TML_D("NxpEse and ESE_SVDD_SYNC not available. Returning");
-        return NFCSTATUS_FAILED;
-    }
+NFCSTATUS phTmlNfc_rel_svdd_wait(void *pDevHandle, long svddWaitStatus) {
+  NXPLOG_TML_D("phTmlNfc_rel_svdd_wait()");
+  if (!nfcFL.nfcNxpEse && !nfcFL.eseFL._ESE_SVDD_SYNC) {
+    NXPLOG_TML_D("NxpEse and ESE_SVDD_SYNC not available. Returning");
+    return NFCSTATUS_FAILED;
+  }
   int ret = -1;
   NFCSTATUS status = NFCSTATUS_SUCCESS;
   NXPLOG_TML_D("phTmlNfc_rel_svdd_wait(), enter ");
@@ -554,7 +554,7 @@ NFCSTATUS phTmlNfc_rel_svdd_wait(void* pDevHandle) {
     return NFCSTATUS_FAILED;
   }
 
-  ret = ioctl((intptr_t)pDevHandle, P544_REL_SVDD_WAIT);
+  ret = ioctl((intptr_t)pDevHandle, P544_REL_SVDD_WAIT, svddWaitStatus);
   if (ret < 0) {
     if (ret == -EBUSY)
       status = NFCSTATUS_BUSY;
@@ -589,26 +589,24 @@ bool_t getDownloadFlag(void) { return bFwDnldFlag; }
 ** Returns          success or failure
 **
 *******************************************************************************/
-NFCSTATUS phTmlNfc_rel_dwpOnOff_wait(void *pDevHandle)
-{
-    int ret = -1;
-    NFCSTATUS status = NFCSTATUS_SUCCESS;
-    NXPLOG_TML_D("phTmlNfc_rel_dwpOnOff_wait(), enter ");
-
-    if (NULL == pDevHandle)
-    {
-        return NFCSTATUS_FAILED;
-    }
+NFCSTATUS phTmlNfc_rel_dwpOnOff_wait(void *pDevHandle, long dwplinkActvStatus) {
+  int ret = -1;
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  NXPLOG_TML_D("phTmlNfc_rel_dwpOnOff_wait(), enter ");
 
-    ret = ioctl((intptr_t)pDevHandle, P544_REL_DWPONOFF_WAIT);
-    if (ret < 0)
-    {
-        if (ret == -EBUSY)
-            status = NFCSTATUS_BUSY;
-        else
-            status = NFCSTATUS_FAILED;
-    }
-    NXPLOG_TML_D("phTmlNfc_rel_dwpOnOff_wait(), exit  ret %d, status %d", ret, status);
-    return status;
+  if (NULL == pDevHandle) {
+    return NFCSTATUS_FAILED;
+  }
+
+  ret = ioctl((intptr_t)pDevHandle, P544_REL_DWPONOFF_WAIT, dwplinkActvStatus);
+  if (ret < 0) {
+    if (ret == -EBUSY)
+      status = NFCSTATUS_BUSY;
+    else
+      status = NFCSTATUS_FAILED;
+  }
+  NXPLOG_TML_D("phTmlNfc_rel_dwpOnOff_wait(), exit  ret %d, status %d", ret,
+               status);
+  return status;
 
 }
diff --git a/halimpl/tml/phTmlNfc_i2c.h b/halimpl/tml/phTmlNfc_i2c.h
index fa7231f..38523b0 100644
--- a/halimpl/tml/phTmlNfc_i2c.h
+++ b/halimpl/tml/phTmlNfc_i2c.h
@@ -47,8 +47,8 @@ NFCSTATUS phTmlNfc_set_pid(void* pDevHandle, long pid);
 NFCSTATUS phTmlNfc_set_power_scheme(void* pDevHandle, long id);
 NFCSTATUS phTmlNfc_get_ese_access(void* pDevHandle, long timeout);
 NFCSTATUS phTmlNfc_i2c_set_Jcop_dwnld_state(void* pDevHandle, long level);
-NFCSTATUS phTmlNfc_rel_svdd_wait(void* pDevHandle);
-NFCSTATUS phTmlNfc_rel_dwpOnOff_wait(void* pDevHandle);
+NFCSTATUS phTmlNfc_rel_svdd_wait(void *pDevHandle, long svddWaitStatus);
+NFCSTATUS phTmlNfc_rel_dwpOnOff_wait(void *pDevHandle, long dwplinkActvStatus);
 /*
  * SPI Request NFCC to enable p61 power, only in param
  * Only for SPI
diff --git a/halimpl/tml/spi_spm.cc b/halimpl/tml/spi_spm.cc
index fd03627..d12c26e 100755
--- a/halimpl/tml/spi_spm.cc
+++ b/halimpl/tml/spi_spm.cc
@@ -50,7 +50,7 @@ int phPalEse_spi_ioctl(phPalEse_ControlCode_t eControlCode, void *pDevHandle,
   }
   switch (eControlCode) {
     case phPalEse_e_ChipRst:
-      if (level == 1 || level == 0)
+      if ((level&0xF1) || (level&0xF0))
         ret = ioctl((intptr_t)pDevHandle, P61_SET_SPI_PWR, level);
       else
         ret = 0;
diff --git a/halimpl/utils/phNxpConfig.cpp b/halimpl/utils/phNxpConfig.cpp
index 2677c04..fdb4048 100644
--- a/halimpl/utils/phNxpConfig.cpp
+++ b/halimpl/utils/phNxpConfig.cpp
@@ -135,11 +135,14 @@ typedef enum
   TARGET_SDM660                        = 317, /**< SDM660 target */
   TARGET_SDM670                        = 336, /**< SDM670 target */
   TARGET_SDM710                        = 360, /**< SDM710 target */
+  TARGET_SDM712                        = 393, /**< SDM712 target */
+  TARGET_QCS605                        = 347, /**< QCS605 target */
   TARGET_SDM630                        = 318, /**< SDM630 target */
   TARGET_SDM632                        = 349, /**< SDM632 target */
   TARGET_SDM439                        = 353, /**< SDM439 target */
   TARGET_SDM429                        = 354, /**< SDM429 target */
   TARGET_SDM450                        = 338, /**< SDM450 target */
+  TARGET_SDM455                        = 385, /**< SDM455 target */
   TARGET_SDM845                        = 321, /**< SDM845 target */
   TARGET_DEFAULT                       = TARGET_GENERIC, /**< new targets */
   TARGET_INVALID                       = 0xFF
@@ -414,6 +417,8 @@ int CNfcConfig::getconfiguration_id (char * config_file)
         case TARGET_SDM845:
         case TARGET_SDM670:
         case TARGET_SDM710:
+        case TARGET_SDM712:
+        case TARGET_QCS605:
             if (!strncmp(nq_fw_ver, FW_MAJOR_NUM_NQ4xx, FW_MAJOR_NUM_LENGTH)) {
                 config_id = QRD_TYPE_NQ4XX;
                 strlcpy(config_file, config_name_qrd_NQ4XX, MAX_DATA_CONFIG_PATH_LEN);
@@ -425,6 +430,7 @@ int CNfcConfig::getconfiguration_id (char * config_file)
             break;
         case TARGET_SDM660:
         case TARGET_SDM630:
+        case TARGET_SDM455:
         case TARGET_MSM8998:
         case TARGET_MSM8997:
             if ((!strncmp(nq_chipid, NQ220, PROPERTY_VALUE_MAX)) || (!strncmp(nq_chipid, NQ210, PROPERTY_VALUE_MAX))) {
@@ -472,6 +478,8 @@ int CNfcConfig::getconfiguration_id (char * config_file)
         case TARGET_SDM845:
         case TARGET_SDM670:
         case TARGET_SDM710:
+        case TARGET_SDM712:
+        case TARGET_QCS605:
             if (!strncmp(nq_fw_ver, FW_MAJOR_NUM_NQ4xx, FW_MAJOR_NUM_LENGTH)) {
                 config_id = MTP_TYPE_NQ4XX;
                 strlcpy(config_file, config_name_mtp_NQ4XX, MAX_DATA_CONFIG_PATH_LEN);
@@ -483,6 +491,7 @@ int CNfcConfig::getconfiguration_id (char * config_file)
             break;
         case TARGET_SDM660:
         case TARGET_SDM630:
+        case TARGET_SDM455:
         case TARGET_MSM8998:
         case TARGET_MSM8997:
             if ((!strncmp(nq_chipid, NQ220, PROPERTY_VALUE_MAX)) || (!strncmp(nq_chipid, NQ210, PROPERTY_VALUE_MAX))) {
@@ -701,6 +710,7 @@ bool CNfcConfig::readConfig(const char* name, bool bResetContent) {
           break;
         }
       // fall through to numValue to handle numValue
+      [[fallthrough]];
 
       case NUM_VALUE:
         if (isDigit(c, base)) {
diff --git a/halimpl/utils/phNxpConfig.h b/halimpl/utils/phNxpConfig.h
index 350e75c..dabbb22 100644
--- a/halimpl/utils/phNxpConfig.h
+++ b/halimpl/utils/phNxpConfig.h
@@ -78,7 +78,6 @@ int updateNxpConfigTimestamp();
 #define NAME_NXP_CORE_CONF_EXTN "NXP_CORE_CONF_EXTN"
 #define NAME_NXP_CORE_CONF "NXP_CORE_CONF"
 #define NAME_NXP_CORE_MFCKEY_SETTING "NXP_CORE_MFCKEY_SETTING"
-#define NAME_NXP_CORE_STANDBY "NXP_CORE_STANDBY"
 #define NAME_NXP_NFC_PROFILE_EXTN "NXP_NFC_PROFILE_EXTN"
 #define NAME_NXP_CHINA_TIANJIN_RF_ENABLED "NXP_CHINA_TIANJIN_RF_ENABLED"
 #define NAME_NXP_CHINA_BLK_NUM_CHK_ENABLE "NXP_CN_TRANSIT_BLK_NUM_CHECK_ENABLE"
@@ -122,6 +121,34 @@ int updateNxpConfigTimestamp();
 #define NAME_NXP_UICC_WIRED_PRT_MASK "NXP_UICC_WIRED_PRT_MASK"
 #define NAME_NXP_WIRED_MODE_RF_FIELD_ENABLE "NXP_WIRED_MODE_RF_FIELD_ENABLE"
 #define NAME_AID_BLOCK_ROUTE "AID_BLOCK_ROUTE"
+#define NAME_NXP_WIREDSE_TERMINAL_NAME "NXP_WIREDSE_TERMINAL_NAME"
+#define NAME_NXP_SWP_RD_TAG_OP_TIMEOUT "NXP_SWP_RD_TAG_OP_TIMEOUT"
+#define NAME_NXP_LOADER_SERICE_VERSION "NXP_LOADER_SERVICE_VERSION"
+#define NAME_NXP_DUAL_UICC_ENABLE "NXP_DUAL_UICC_ENABLE"
+#define NAME_NXP_CE_ROUTE_STRICT_DISABLE "NXP_CE_ROUTE_STRICT_DISABLE"
+#define NAME_OS_DOWNLOAD_TIMEOUT_VALUE "OS_DOWNLOAD_TIMEOUT_VALUE"
+#define NAME_NXP_DEFAULT_SE "NXP_DEFAULT_SE"
+#define NAME_DEFAULT_AID_ROUTE "DEFAULT_AID_ROUTE"
+#define NAME_DEFAULT_AID_PWR_STATE "DEFAULT_AID_PWR_STATE"
+#define NAME_DEFAULT_ROUTE_PWR_STATE "DEFAULT_ROUTE_PWR_STATE"
+#define NAME_DEFAULT_OFFHOST_PWR_STATE "DEFAULT_OFFHOST_PWR_STATE"
+#define NAME_NXP_JCOPDL_AT_BOOT_ENABLE "NXP_JCOPDL_AT_BOOT_ENABLE"
+#define NAME_NXP_CORE_SCRN_OFF_AUTONOMOUS_ENABLE \
+  "NXP_CORE_SCRN_OFF_AUTONOMOUS_ENABLE"
+#define NAME_NXP_P61_LS_DEFAULT_INTERFACE "NXP_P61_LS_DEFAULT_INTERFACE"
+#define NAME_NXP_P61_JCOP_DEFAULT_INTERFACE "NXP_P61_JCOP_DEFAULT_INTERFACE"
+#define NAME_NXP_AGC_DEBUG_ENABLE "NXP_AGC_DEBUG_ENABLE"
+#define NAME_DEFAULT_FELICA_CLT_PWR_STATE "DEFAULT_FELICA_CLT_PWR_STATE"
+#define NAME_NXP_HCEF_CMD_RSP_TIMEOUT_VALUE "NXP_HCEF_CMD_RSP_TIMEOUT_VALUE"
+#define NAME_CHECK_DEFAULT_PROTO_SE_ID "NXP_CHECK_DEFAULT_PROTO_SE_ID"
+#define NAME_NXP_NFCC_PASSIVE_LISTEN_TIMEOUT "NXP_NFCC_PASSIVE_LISTEN_TIMEOUT"
+#define NAME_NXP_NFCC_STANDBY_TIMEOUT "NXP_NFCC_STANDBY_TIMEOUT"
+#define NAME_NXP_WM_MAX_WTX_COUNT "NXP_WM_MAX_WTX_COUNT"
+#define NAME_NXP_NFCC_RF_FIELD_EVENT_TIMEOUT "NXP_NFCC_RF_FIELD_EVENT_TIMEOUT"
+#define NAME_NXP_ALLOW_WIRED_IN_MIFARE_DESFIRE_CLT \
+  "NXP_ALLOW_WIRED_IN_MIFARE_DESFIRE_CLT"
+#define NAME_NXP_DWP_INTF_RESET_ENABLE "NXP_DWP_INTF_RESET_ENABLE"
+#define NAME_NXP_MF_CLT_JCOP_CFG "NXP_MF_CLT_JCOP_CFG"
 
 /**
  *  @brief defines the different config files used.
diff --git a/inc/IChannel.h b/inc/IChannel.h
new file mode 100644
index 0000000..274673b
--- /dev/null
+++ b/inc/IChannel.h
@@ -0,0 +1,101 @@
+ /*
+  * Copyright (C) 2015-2018 NXP Semiconductors
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+
+#ifndef ICHANNEL_H_
+#define ICHANNEL_H_
+
+#include "data_types.h"
+typedef enum InterfaceInfo{
+  INTF_NFC = 0,
+  INTF_SE =1,
+}IntfInfo;
+typedef struct IChannel
+{
+/*******************************************************************************
+**
+** Function:        Open
+**
+** Description:     Initialize the channel.
+**
+** Returns:         True if ok.
+**
+*******************************************************************************/
+int16_t (*open)();
+/*******************************************************************************
+**
+** Function:        close
+**
+** Description:     Close the channel.
+**
+** Returns:         True if ok.
+**
+*******************************************************************************/
+bool (*close)(int16_t mHandle);
+
+/*******************************************************************************
+**
+** Function:        transceive
+**
+** Description:     Send data to the secure element; read it's response.
+**                  xmitBuffer: Data to transmit.
+**                  xmitBufferSize: Length of data.
+**                  recvBuffer: Buffer to receive response.
+**                  recvBufferMaxSize: Maximum size of buffer.
+**                  recvBufferActualSize: Actual length of response.
+**                  timeoutMillisec: timeout in millisecond
+**
+** Returns:         True if ok.
+**
+*******************************************************************************/
+bool (*transceive) (uint8_t* xmitBuffer, int32_t xmitBufferSize, uint8_t* recvBuffer,
+                     int32_t recvBufferMaxSize, int32_t& recvBufferActualSize, int32_t timeoutMillisec);
+
+/*******************************************************************************
+**
+** Function:        doeSE_Reset
+**
+** Description:     Power OFF and ON to eSE
+**
+** Returns:         None.
+**
+*******************************************************************************/
+
+void (*doeSE_Reset)();
+/*******************************************************************************
+**
+** Function:        doeSE_JcopDownLoadReset
+**
+** Description:     Power OFF and ON to eSE during JCOP Update
+**
+** Returns:         None.
+**
+*******************************************************************************/
+
+void (*doeSE_JcopDownLoadReset)();
+/*******************************************************************************
+**
+** Variable:        tNfc_featureList
+**
+** Description:     NFCC and eSE feature flags
+**
+** Returns:         None.
+**
+*******************************************************************************/
+uint8_t (*getInterfaceInfo)();
+}IChannel_t;
+
+
+#endif /* ICHANNEL_H_ */
diff --git a/inc/data_types.h b/inc/data_types.h
new file mode 100644
index 0000000..fa2ddba
--- /dev/null
+++ b/inc/data_types.h
@@ -0,0 +1,59 @@
+ /*
+  * Copyright (C) 2015-2018 NXP Semiconductors
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+#ifndef DATA_TYPES_H
+#define DATA_TYPES_H
+#include <stdint.h>
+#include <stdbool.h>
+#ifndef NULL
+#define NULL     0
+#endif
+
+/*
+#ifndef false
+#define false  0
+#endif
+*/
+
+#ifndef FALSE
+#define FALSE  0
+#endif
+
+typedef uint32_t        TIME_STAMP;
+
+/*
+#ifndef true
+#define true   (!false)
+#endif
+*/
+
+#ifndef TRUE
+#define TRUE   (!FALSE)
+#endif
+
+typedef unsigned char   UBYTE;
+
+#define STATUS_SUCCESS     0x00
+#define STATUS_OK          0x00
+#define STATUS_UPTO_DATE   0x01
+#define STATUS_FAILED      0x03
+#define STATUS_INUSE       0x04
+#define STATUS_FILE_NOT_FOUND  0x05
+
+#define EE_ERROR_OPEN_FAIL -1
+
+typedef uint8_t tJBL_STATUS;
+
+#endif
diff --git a/inc/eSEClientIntf.h b/inc/eSEClientIntf.h
new file mode 100644
index 0000000..9c265c8
--- /dev/null
+++ b/inc/eSEClientIntf.h
@@ -0,0 +1,81 @@
+/*******************************************************************************
+ *
+ *  Copyright 2018 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#ifndef CLIENT_INTF_H_
+#define CLIENT_INTF_H_
+#include <pthread.h>
+#include <string>
+
+#define SEMS_STATUS_FAILED_SW1 0x63
+#define SEMS_STATUS_FAILED_SW2 0x40
+
+#define SEMS_STATUS_SUCCESS_SW1 0x90
+#define SEMS_STATUS_SUCCESS_SW2 0x00
+
+#define JCOP_UPDATE_3STEP_DONE 3
+
+typedef struct se_extns_entry{
+  uint8_t isJcopUpdateRequired;
+  uint8_t isLSUpdateRequired;
+  unsigned long int sJcopUpdateIntferface;
+  unsigned long int sLsUpdateIntferface;
+} se_extns_entry;
+
+typedef enum {
+  ESE_INTF_INVALID = 0,
+  ESE_INTF_NFC = 1,
+  ESE_INTF_SPI = 2
+}ESE_CLIENT_INTF;
+
+typedef enum {
+  SESTATUS_SUCCESS = (0x0000),
+  SESTATUS_FAILED = (0x0003),
+  SESTATUS_FILE_NOT_FOUND = (0x0005)
+} SESTATUS;
+
+typedef enum {
+  ESE_UPDATE_COMPLETED = 0,
+  ESE_UPDATE_STARTED,
+  ESE_JCOP_UPDATE_REQUIRED,
+  ESE_JCOP_UPDATE_COMPLETED,
+  ESE_LS_UPDATE_REQUIRED,
+  ESE_LS_UPDATE_COMPLETED
+}ese_update_state_t;
+
+extern bool nfc_debug_enabled;
+/*******************************************************************************
+**
+** Function:        checkeSEClientRequired
+**
+** Description:     Read the interface and condition for ese Update(JCOP download/LS download)
+**
+** Returns:         SUCCESS of ok
+**
+*******************************************************************************/
+uint8_t checkeSEClientRequired(ESE_CLIENT_INTF intf );
+
+uint8_t getJcopUpdateRequired();
+uint8_t getLsUpdateRequired();
+uint8_t getJcopUpdateIntf();
+uint8_t getLsUpdateIntf();
+bool geteSETerminalId(char*);
+bool geteUICCTerminalId(char*);
+bool getNfcSeTerminalId(char*);
+void setJcopUpdateRequired(uint8_t state);
+void setLsUpdateRequired(uint8_t  state);
+#endif /* CLIENT_INTF_H_ */
diff --git a/inc/phNxpLog.h b/inc/phNxpLog.h
new file mode 100644
index 0000000..ecbf6bb
--- /dev/null
+++ b/inc/phNxpLog.h
@@ -0,0 +1,367 @@
+/*
+ * Copyright (C) 2010-2014 NXP Semiconductors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#if !defined(NXPLOG__H_INCLUDED)
+#define NXPLOG__H_INCLUDED
+#include <log/log.h>
+
+typedef struct nci_log_level {
+  uint8_t global_log_level;
+  uint8_t extns_log_level;
+  uint8_t hal_log_level;
+  uint8_t dnld_log_level;
+  uint8_t tml_log_level;
+  uint8_t ncix_log_level;
+  uint8_t ncir_log_level;
+} nci_log_level_t;
+
+/* global log level Ref */
+extern nci_log_level_t gLog_level;
+extern bool nfc_debug_enabled;
+/* define log module included when compile */
+#define ENABLE_EXTNS_TRACES TRUE
+#define ENABLE_HAL_TRACES TRUE
+#define ENABLE_TML_TRACES TRUE
+#define ENABLE_FWDNLD_TRACES TRUE
+#define ENABLE_NCIX_TRACES TRUE
+#define ENABLE_NCIR_TRACES TRUE
+
+#define ENABLE_HCPX_TRACES FALSE
+#define ENABLE_HCPR_TRACES FALSE
+
+/* ####################### Set the log module name in .conf file
+ * ########################## */
+#define NAME_NXPLOG_EXTNS_LOGLEVEL "NXPLOG_EXTNS_LOGLEVEL"
+#define NAME_NXPLOG_HAL_LOGLEVEL "NXPLOG_NCIHAL_LOGLEVEL"
+#define NAME_NXPLOG_NCIX_LOGLEVEL "NXPLOG_NCIX_LOGLEVEL"
+#define NAME_NXPLOG_NCIR_LOGLEVEL "NXPLOG_NCIR_LOGLEVEL"
+#define NAME_NXPLOG_FWDNLD_LOGLEVEL "NXPLOG_FWDNLD_LOGLEVEL"
+#define NAME_NXPLOG_TML_LOGLEVEL "NXPLOG_TML_LOGLEVEL"
+
+/* ####################### Set the log module name by Android property
+ * ########################## */
+#define PROP_NAME_NXPLOG_GLOBAL_LOGLEVEL "nfc.nxp_log_level_global"
+#define PROP_NAME_NXPLOG_EXTNS_LOGLEVEL "nfc.nxp_log_level_extns"
+#define PROP_NAME_NXPLOG_HAL_LOGLEVEL "nfc.nxp_log_level_hal"
+#define PROP_NAME_NXPLOG_NCI_LOGLEVEL "nfc.nxp_log_level_nci"
+#define PROP_NAME_NXPLOG_FWDNLD_LOGLEVEL "nfc.nxp_log_level_dnld"
+#define PROP_NAME_NXPLOG_TML_LOGLEVEL "nfc.nxp_log_level_tml"
+
+/* ####################### Set the logging level for EVERY COMPONENT here
+ * ######################## :START: */
+#define NXPLOG_LOG_SILENT_LOGLEVEL 0x00
+#define NXPLOG_LOG_ERROR_LOGLEVEL 0x01
+#define NXPLOG_LOG_WARN_LOGLEVEL 0x02
+#define NXPLOG_LOG_DEBUG_LOGLEVEL 0x03
+/* ####################### Set the default logging level for EVERY COMPONENT
+ * here ########################## :END: */
+
+/* The Default log level for all the modules. */
+#define NXPLOG_DEFAULT_LOGLEVEL NXPLOG_LOG_ERROR_LOGLEVEL
+
+/* ################################################################################################################
+ */
+/* ############################################### Component Names
+ * ################################################ */
+/* ################################################################################################################
+ */
+
+extern const char* NXPLOG_ITEM_EXTNS;  /* Android logging tag for NxpExtns  */
+extern const char* NXPLOG_ITEM_NCIHAL; /* Android logging tag for NxpNciHal */
+extern const char* NXPLOG_ITEM_NCIX;   /* Android logging tag for NxpNciX   */
+extern const char* NXPLOG_ITEM_NCIR;   /* Android logging tag for NxpNciR   */
+extern const char* NXPLOG_ITEM_FWDNLD; /* Android logging tag for NxpFwDnld */
+extern const char* NXPLOG_ITEM_TML;    /* Android logging tag for NxpTml    */
+
+#ifdef NXP_HCI_REQ
+extern const char* NXPLOG_ITEM_HCPX; /* Android logging tag for NxpHcpX   */
+extern const char* NXPLOG_ITEM_HCPR; /* Android logging tag for NxpHcpR   */
+#endif                               /*NXP_HCI_REQ*/
+
+/* ######################################## Defines used for Logging data
+ * ######################################### */
+#ifdef NXP_VRBS_REQ
+#define NXPLOG_FUNC_ENTRY(COMP) \
+  LOG_PRI(ANDROID_LOG_VERBOSE, (COMP), "+:%s", (__func__))
+#define NXPLOG_FUNC_EXIT(COMP) \
+  LOG_PRI(ANDROID_LOG_VERBOSE, (COMP), "-:%s", (__func__))
+#endif /*NXP_VRBS_REQ*/
+
+/* ################################################################################################################
+ */
+/* ######################################## Logging APIs of actual modules
+ * ######################################## */
+/* ################################################################################################################
+ */
+/* Logging APIs used by NxpExtns module */
+#if (ENABLE_EXTNS_TRACES == TRUE)
+#define NXPLOG_EXTNS_D(...)                                       \
+  {                                                               \
+     if ((nfc_debug_enabled) ||                                   \
+      (gLog_level.extns_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL))  \
+      LOG_PRI(ANDROID_LOG_DEBUG, NXPLOG_ITEM_EXTNS, __VA_ARGS__); \
+  }
+#define NXPLOG_EXTNS_W(...)                                      \
+  {                                                              \
+     if ((nfc_debug_enabled) ||                                  \
+      (gLog_level.extns_log_level >= NXPLOG_LOG_WARN_LOGLEVEL))  \
+      LOG_PRI(ANDROID_LOG_WARN, NXPLOG_ITEM_EXTNS, __VA_ARGS__); \
+  }
+#define NXPLOG_EXTNS_E(...)                                       \
+  {                                                               \
+    if (gLog_level.extns_log_level >= NXPLOG_LOG_ERROR_LOGLEVEL)  \
+      LOG_PRI(ANDROID_LOG_ERROR, NXPLOG_ITEM_EXTNS, __VA_ARGS__); \
+  }
+#else
+#define NXPLOG_EXTNS_D(...)
+#define NXPLOG_EXTNS_W(...)
+#define NXPLOG_EXTNS_E(...)
+#endif /* Logging APIs used by NxpExtns module */
+
+/* Logging APIs used by NxpNciHal module */
+#if (ENABLE_HAL_TRACES == TRUE)
+#define NXPLOG_NCIHAL_D(...)                                       \
+  {                                                                \
+    if ((nfc_debug_enabled) ||                                     \
+      (gLog_level.hal_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL))     \
+      LOG_PRI(ANDROID_LOG_DEBUG, NXPLOG_ITEM_NCIHAL, __VA_ARGS__); \
+  }
+#define NXPLOG_NCIHAL_W(...)                                      \
+  {                                                               \
+    if ((nfc_debug_enabled) ||                                    \
+      (gLog_level.hal_log_level >= NXPLOG_LOG_WARN_LOGLEVEL))     \
+      LOG_PRI(ANDROID_LOG_WARN, NXPLOG_ITEM_NCIHAL, __VA_ARGS__); \
+  }
+#define NXPLOG_NCIHAL_E(...)                                       \
+  {                                                                \
+    if (gLog_level.hal_log_level >= NXPLOG_LOG_ERROR_LOGLEVEL)     \
+      LOG_PRI(ANDROID_LOG_ERROR, NXPLOG_ITEM_NCIHAL, __VA_ARGS__); \
+  }
+#else
+#define NXPLOG_NCIHAL_D(...)
+#define NXPLOG_NCIHAL_W(...)
+#define NXPLOG_NCIHAL_E(...)
+#endif /* Logging APIs used by HAL module */
+
+/* Logging APIs used by NxpNciX module */
+#if (ENABLE_NCIX_TRACES == TRUE)
+#define NXPLOG_NCIX_D(...)                                       \
+  {                                                              \
+    if ((nfc_debug_enabled) ||                                   \
+      (gLog_level.ncix_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL))  \
+      LOG_PRI(ANDROID_LOG_DEBUG, NXPLOG_ITEM_NCIX, __VA_ARGS__); \
+  }
+#define NXPLOG_NCIX_W(...)                                      \
+  {                                                             \
+     if ((nfc_debug_enabled) ||                                 \
+      (gLog_level.ncix_log_level >= NXPLOG_LOG_WARN_LOGLEVEL))  \
+      LOG_PRI(ANDROID_LOG_WARN, NXPLOG_ITEM_NCIX, __VA_ARGS__); \
+  }
+#define NXPLOG_NCIX_E(...)                                       \
+  {                                                              \
+    if (gLog_level.ncix_log_level >= NXPLOG_LOG_ERROR_LOGLEVEL)  \
+      LOG_PRI(ANDROID_LOG_ERROR, NXPLOG_ITEM_NCIX, __VA_ARGS__); \
+  }
+#else
+#define NXPLOG_NCIX_D(...)
+#define NXPLOG_NCIX_W(...)
+#define NXPLOG_NCIX_E(...)
+#endif /* Logging APIs used by NCIx module */
+
+/* Logging APIs used by NxpNciR module */
+#if (ENABLE_NCIR_TRACES == TRUE)
+#define NXPLOG_NCIR_D(...)                                       \
+  {                                                              \
+     if ((nfc_debug_enabled) ||                                  \
+      (gLog_level.ncir_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL))  \
+      LOG_PRI(ANDROID_LOG_DEBUG, NXPLOG_ITEM_NCIR, __VA_ARGS__); \
+  }
+#define NXPLOG_NCIR_W(...)                                      \
+  {                                                             \
+     if ((nfc_debug_enabled) ||                                 \
+      (gLog_level.ncir_log_level >= NXPLOG_LOG_WARN_LOGLEVEL))  \
+      LOG_PRI(ANDROID_LOG_WARN, NXPLOG_ITEM_NCIR, __VA_ARGS__); \
+  }
+#define NXPLOG_NCIR_E(...)                                       \
+  {                                                              \
+    if (gLog_level.ncir_log_level >= NXPLOG_LOG_ERROR_LOGLEVEL)  \
+      LOG_PRI(ANDROID_LOG_ERROR, NXPLOG_ITEM_NCIR, __VA_ARGS__); \
+  }
+#else
+#define NXPLOG_NCIR_D(...)
+#define NXPLOG_NCIR_W(...)
+#define NXPLOG_NCIR_E(...)
+#endif /* Logging APIs used by NCIR module */
+
+/* Logging APIs used by NxpFwDnld module */
+#if (ENABLE_FWDNLD_TRACES == TRUE)
+#define NXPLOG_FWDNLD_D(...)                                       \
+  {                                                                \
+     if ((nfc_debug_enabled) ||                                    \
+      (gLog_level.dnld_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL))    \
+      LOG_PRI(ANDROID_LOG_DEBUG, NXPLOG_ITEM_FWDNLD, __VA_ARGS__); \
+  }
+#define NXPLOG_FWDNLD_W(...)                                      \
+  {                                                               \
+     if ((nfc_debug_enabled) ||                                   \
+      (gLog_level.dnld_log_level >= NXPLOG_LOG_WARN_LOGLEVEL))    \
+      LOG_PRI(ANDROID_LOG_WARN, NXPLOG_ITEM_FWDNLD, __VA_ARGS__); \
+  }
+#define NXPLOG_FWDNLD_E(...)                                       \
+  {                                                                \
+    if (gLog_level.dnld_log_level >= NXPLOG_LOG_ERROR_LOGLEVEL)    \
+      LOG_PRI(ANDROID_LOG_ERROR, NXPLOG_ITEM_FWDNLD, __VA_ARGS__); \
+  }
+#else
+#define NXPLOG_FWDNLD_D(...)
+#define NXPLOG_FWDNLD_W(...)
+#define NXPLOG_FWDNLD_E(...)
+#endif /* Logging APIs used by NxpFwDnld module */
+
+/* Logging APIs used by NxpTml module */
+#if (ENABLE_TML_TRACES == TRUE)
+#define NXPLOG_TML_D(...)                                       \
+  {                                                             \
+     if ((nfc_debug_enabled) ||                                 \
+      (gLog_level.tml_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL))  \
+      LOG_PRI(ANDROID_LOG_DEBUG, NXPLOG_ITEM_TML, __VA_ARGS__); \
+  }
+#define NXPLOG_TML_W(...)                                      \
+  {                                                            \
+     if ((nfc_debug_enabled) ||                                \
+      (gLog_level.tml_log_level >= NXPLOG_LOG_WARN_LOGLEVEL))  \
+      LOG_PRI(ANDROID_LOG_WARN, NXPLOG_ITEM_TML, __VA_ARGS__); \
+  }
+#define NXPLOG_TML_E(...)                                       \
+  {                                                             \
+    if (gLog_level.tml_log_level >= NXPLOG_LOG_ERROR_LOGLEVEL)  \
+      LOG_PRI(ANDROID_LOG_ERROR, NXPLOG_ITEM_TML, __VA_ARGS__); \
+  }
+#else
+#define NXPLOG_TML_D(...)
+#define NXPLOG_TML_W(...)
+#define NXPLOG_TML_E(...)
+#endif /* Logging APIs used by NxpTml module */
+
+#ifdef NXP_HCI_REQ
+/* Logging APIs used by NxpHcpX module */
+#if (ENABLE_HCPX_TRACES == TRUE)
+#define NXPLOG_HCPX_D(...)                                         \
+  {                                                                \
+     if ((nfc_debug_enabled) ||                                    \
+      (gLog_level.dnld_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL))    \
+      LOG_PRI(ANDROID_LOG_DEBUG, NXPLOG_ITEM_FWDNLD, __VA_ARGS__); \
+  }
+#define NXPLOG_HCPX_W(...)                                        \
+  {                                                               \
+     if ((nfc_debug_enabled) ||                                   \
+      (gLog_level.dnld_log_level >= NXPLOG_LOG_WARN_LOGLEVEL))    \
+      LOG_PRI(ANDROID_LOG_WARN, NXPLOG_ITEM_FWDNLD, __VA_ARGS__); \
+  }
+#define NXPLOG_HCPX_E(...)                                         \
+  {                                                                \
+    if (gLog_level.dnld_log_level >= NXPLOG_LOG_ERROR_LOGLEVEL)    \
+      LOG_PRI(ANDROID_LOG_ERROR, NXPLOG_ITEM_FWDNLD, __VA_ARGS__); \
+  }
+#else
+#define NXPLOG_HCPX_D(...)
+#define NXPLOG_HCPX_W(...)
+#define NXPLOG_HCPX_E(...)
+#endif /* Logging APIs used by NxpHcpX module */
+
+/* Logging APIs used by NxpHcpR module */
+#if (ENABLE_HCPR_TRACES == TRUE)
+#define NXPLOG_HCPR_D(...)                                         \
+  {                                                                \
+     if ((nfc_debug_enabled) ||                                    \
+      (gLog_level.dnld_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL))    \
+      LOG_PRI(ANDROID_LOG_DEBUG, NXPLOG_ITEM_FWDNLD, __VA_ARGS__); \
+  }
+#define NXPLOG_HCPR_W(...)                                        \
+  {                                                               \
+     if ((nfc_debug_enabled) ||                                   \
+      (gLog_level.dnld_log_level >= NXPLOG_LOG_WARN_LOGLEVEL))    \
+      LOG_PRI(ANDROID_LOG_WARN, NXPLOG_ITEM_FWDNLD, __VA_ARGS__); \
+  }
+#define NXPLOG_HCPR_E(...)                                         \
+  {                                                                \
+    if (gLog_level.dnld_log_level >= NXPLOG_LOG_ERROR_LOGLEVEL)    \
+      LOG_PRI(ANDROID_LOG_ERROR, NXPLOG_ITEM_FWDNLD, __VA_ARGS__); \
+  }
+#else
+#define NXPLOG_HCPR_D(...)
+#define NXPLOG_HCPR_W(...)
+#define NXPLOG_HCPR_E(...)
+#endif /* Logging APIs used by NxpHcpR module */
+#endif /* NXP_HCI_REQ */
+
+#ifdef NXP_VRBS_REQ
+#if (ENABLE_EXTNS_TRACES == TRUE)
+#define NXPLOG_EXTNS_ENTRY() NXPLOG_FUNC_ENTRY(NXPLOG_ITEM_EXTNS)
+#define NXPLOG_EXTNS_EXIT() NXPLOG_FUNC_EXIT(NXPLOG_ITEM_EXTNS)
+#else
+#define NXPLOG_EXTNS_ENTRY()
+#define NXPLOG_EXTNS_EXIT()
+#endif
+
+#if (ENABLE_HAL_TRACES == TRUE)
+#define NXPLOG_NCIHAL_ENTRY() NXPLOG_FUNC_ENTRY(NXPLOG_ITEM_NCIHAL)
+#define NXPLOG_NCIHAL_EXIT() NXPLOG_FUNC_EXIT(NXPLOG_ITEM_NCIHAL)
+#else
+#define NXPLOG_NCIHAL_ENTRY()
+#define NXPLOG_NCIHAL_EXIT()
+#endif
+
+#if (ENABLE_NCIX_TRACES == TRUE)
+#define NXPLOG_NCIX_ENTRY() NXPLOG_FUNC_ENTRY(NXPLOG_ITEM_NCIX)
+#define NXPLOG_NCIX_EXIT() NXPLOG_FUNC_EXIT(NXPLOG_ITEM_NCIX)
+#else
+#define NXPLOG_NCIX_ENTRY()
+#define NXPLOG_NCIX_EXIT()
+#endif
+
+#if (ENABLE_NCIR_TRACES == TRUE)
+#define NXPLOG_NCIR_ENTRY() NXPLOG_FUNC_ENTRY(NXPLOG_ITEM_NCIR)
+#define NXPLOG_NCIR_EXIT() NXPLOG_FUNC_EXIT(NXPLOG_ITEM_NCIR)
+#else
+#define NXPLOG_NCIR_ENTRY()
+#define NXPLOG_NCIR_EXIT()
+#endif
+
+#ifdef NXP_HCI_REQ
+
+#if (ENABLE_HCPX_TRACES == TRUE)
+#define NXPLOG_HCPX_ENTRY() NXPLOG_FUNC_ENTRY(NXPLOG_ITEM_HCPX)
+#define NXPLOG_HCPX_EXIT() NXPLOG_FUNC_EXIT(NXPLOG_ITEM_HCPX)
+#else
+#define NXPLOG_HCPX_ENTRY()
+#define NXPLOG_HCPX_EXIT()
+#endif
+
+#if (ENABLE_HCPR_TRACES == TRUE)
+#define NXPLOG_HCPR_ENTRY() NXPLOG_FUNC_ENTRY(NXPLOG_ITEM_HCPR)
+#define NXPLOG_HCPR_EXIT() NXPLOG_FUNC_EXIT(NXPLOG_ITEM_HCPR)
+#else
+#define NXPLOG_HCPR_ENTRY()
+#define NXPLOG_HCPR_EXIT()
+#endif
+#endif /* NXP_HCI_REQ */
+
+#endif /* NXP_VRBS_REQ */
+
+void phNxpLog_InitializeLogLevel(void);
+
+#endif /* NXPLOG__H_INCLUDED */
diff --git a/jcos_client/inc/JcDnld.h b/jcos_client/inc/JcDnld.h
new file mode 100644
index 0000000..ac27342
--- /dev/null
+++ b/jcos_client/inc/JcDnld.h
@@ -0,0 +1,64 @@
+ /*
+  * Copyright (C) 2015-2018 NXP Semiconductors
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+
+#ifndef JCDNLD_H_
+#define JCDNLD_H_
+
+#include "IChannel.h"
+/*******************************************************************************
+**
+** Function:        JCDNLD_Init
+**
+** Description:     Initializes the JCOP library and opens the DWP communication channel
+**
+** Returns:         SUCCESS if ok.
+**
+*******************************************************************************/
+unsigned char JCDNLD_Init(IChannel *channel);
+
+/*******************************************************************************
+**
+** Function:        JCDNLD_StartDownload
+**
+** Description:     Starts the JCOP update
+**
+** Returns:         SUCCESS if ok.
+**
+*******************************************************************************/
+unsigned char JCDNLD_StartDownload();
+
+/*******************************************************************************
+**
+** Function:        JCDNLD_DeInit
+**
+** Description:     Deinitializes the JCOP Lib
+**
+** Returns:         true if ok.
+**
+*******************************************************************************/
+bool JCDNLD_DeInit();
+
+/*******************************************************************************
+**
+** Function:        JCDNLD_CheckVersion
+**
+** Description:     Check the existing JCOP OS version
+**
+** Returns:         true if ok.
+**
+*******************************************************************************/
+bool JCDNLD_CheckVersion();
+#endif
diff --git a/jcos_client/inc/JcopOsDownload.h b/jcos_client/inc/JcopOsDownload.h
new file mode 100644
index 0000000..9afca68
--- /dev/null
+++ b/jcos_client/inc/JcopOsDownload.h
@@ -0,0 +1,155 @@
+ /*
+  * Copyright (C) 2015-2018 NXP Semiconductors
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+
+#include "data_types.h"
+#include "IChannel.h"
+#include <stdio.h>
+
+typedef struct JcopOs_TranscieveInfo
+{
+    int32_t timeout;
+    uint8_t sRecvData[1024];
+    uint8_t *sSendData;
+    int32_t sSendlength;
+    int sRecvlength;
+}JcopOs_TranscieveInfo_t;
+
+typedef struct JcopOs_Version_Info
+{
+    uint8_t osid;
+    uint8_t ver1;
+    uint8_t ver0;
+    uint8_t OtherValid;
+    uint8_t ver_status;
+}JcopOs_Version_Info_t;
+typedef struct JcopOs_ImageInfo
+{
+    FILE *fp;
+    int   fls_size;
+    char  fls_path[256];
+    int   index;
+    uint8_t cur_state;
+    JcopOs_Version_Info_t    version_info;
+}JcopOs_ImageInfo_t;
+typedef struct JcopOs_Dwnld_Context
+{
+    JcopOs_Version_Info_t    version_info;
+    JcopOs_ImageInfo_t       Image_info;
+    JcopOs_TranscieveInfo_t  pJcopOs_TransInfo;
+    IChannel_t               *channel;
+}JcopOs_Dwnld_Context_t,*pJcopOs_Dwnld_Context_t;
+
+
+static uint8_t Trigger_APDU[] = {0x4F, 0x70, 0x80, 0x13, 0x04, 0xDE, 0xAD, 0xBE, 0xEF, 0x00};
+static uint8_t GetInfo_APDU[] = {0x00, //CLA
+                               0xA4, 0x04, 0x00, 0x0C, //INS, P1, P2, Lc
+                               0xD2, 0x76, 0x00, 0x00, 0x85, 0x41, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00,   //Data
+                               0x00 //Le
+                              };
+static uint8_t GetInfo_Data[] = {0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x72, 0x4F, 0x53};
+
+static uint8_t Uai_Trigger_APDU[] = {0x4F, 0x70, 0x80, 0x13, 0x04, 0x4A, 0x55, 0x41, 0x49, 0x00};
+static uint8_t Uai_GetInfo_APDU[] = {0x80,0xCA,0x00,0xFE,0x02,0xDF,0x43,0x00};
+
+#define OSID_OFFSET  9
+#define VER1_OFFSET  10
+#define VER0_OFFSET  11
+#define JCOPOS_HEADER_LEN 5
+
+#define JCOP_UPDATE_STATE0 0
+#define JCOP_UPDATE_STATE1 1
+#define JCOP_UPDATE_STATE2 2
+#define JCOP_UPDATE_STATE3 3
+#define JCOP_UPDATE_STATE_TRIGGER_APDU 4
+
+#define JCOP_MAX_RETRY_CNT 3
+//#define JCOP_INFO_PATH     "/data/vendor/nfc/jcop_info.txt"
+
+#define JCOP_MAX_BUF_SIZE 10240
+
+class JcopOsDwnld
+{
+public:
+
+/*******************************************************************************
+**
+** Function:        getInstance
+**
+** Description:     Get the SecureElement singleton object.
+**
+** Returns:         SecureElement object.
+**
+*******************************************************************************/
+static JcopOsDwnld* getInstance ();
+
+
+/*******************************************************************************
+**
+** Function:        getJcopOsFileInfo
+**
+** Description:     Verify all the updater files required for download
+**                  are present or not
+**
+** Returns:         True if ok.
+**
+*******************************************************************************/
+bool getJcopOsFileInfo();
+
+/*******************************************************************************
+**
+** Function:        initialize
+**
+** Description:     Initialize all member variables.
+**                  native: Native data.
+**
+** Returns:         True if ok.
+**
+*******************************************************************************/
+bool initialize (IChannel_t *channel);
+
+/*******************************************************************************
+**
+** Function:        finalize
+**
+** Description:     Release all resources.
+**
+** Returns:         None
+**
+*******************************************************************************/
+void finalize ();
+
+tJBL_STATUS JcopOs_Download();
+
+tJBL_STATUS TriggerApdu(JcopOs_ImageInfo_t* pVersionInfo, tJBL_STATUS status, JcopOs_TranscieveInfo_t* pTranscv_Info);
+
+tJBL_STATUS UaiTriggerApdu(JcopOs_ImageInfo_t* pVersionInfo, tJBL_STATUS status, JcopOs_TranscieveInfo_t* pTranscv_Info);
+
+tJBL_STATUS GetInfo(JcopOs_ImageInfo_t* pVersionInfo, tJBL_STATUS status, JcopOs_TranscieveInfo_t* pTranscv_Info);
+
+tJBL_STATUS load_JcopOS_image(JcopOs_ImageInfo_t *Os_info, tJBL_STATUS status, JcopOs_TranscieveInfo_t *pTranscv_Info);
+
+tJBL_STATUS JcopOs_update_seq_handler();
+
+tJBL_STATUS SendUAICmds(JcopOs_ImageInfo_t *Os_info, tJBL_STATUS status, JcopOs_TranscieveInfo_t *pTranscv_Info);
+
+IChannel_t *mchannel;
+
+private:
+static JcopOsDwnld sJcopDwnld;
+bool mIsInit;
+tJBL_STATUS GetJcopOsState(JcopOs_ImageInfo_t *Os_info, uint8_t *counter);
+tJBL_STATUS SetJcopOsState(JcopOs_ImageInfo_t *Os_info, uint8_t state);
+};
diff --git a/jcos_client/src/JcDnld.cpp b/jcos_client/src/JcDnld.cpp
new file mode 100644
index 0000000..b607e48
--- /dev/null
+++ b/jcos_client/src/JcDnld.cpp
@@ -0,0 +1,172 @@
+ /*
+  * Copyright (C) 2015-2018 NXP Semiconductors
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+#include <data_types.h>
+#include "JcDnld.h"
+#include "JcopOsDownload.h"
+
+using android::base::StringPrintf;
+
+JcopOsDwnld *jd;
+IChannel_t *channel;
+static bool inUse = false;
+static int16_t jcHandle;
+extern pJcopOs_Dwnld_Context_t gpJcopOs_Dwnld_Context;
+/*******************************************************************************
+**
+** Function:        JCDNLD_Init
+**
+** Description:     Initializes the JCOP library and opens the DWP communication channel
+**
+** Returns:         true if ok.
+**
+*******************************************************************************/
+tJBL_STATUS JCDNLD_Init(IChannel_t *channel)
+{
+    static const char fn[] = "JCDNLD_Init";
+    bool    stat = false;
+    jcHandle = EE_ERROR_OPEN_FAIL;
+    DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter", fn);
+
+    if (inUse == true)
+    {
+        return STATUS_INUSE;
+    }
+    else if(channel == NULL)
+    {
+        return STATUS_FAILED;
+    }
+    /*TODO: inUse assignment should be with protection like using semaphore*/
+    inUse = true;
+    jd = JcopOsDwnld::getInstance();
+    stat = jd->initialize (channel);
+    if(stat != true)
+    {
+        LOG(ERROR) << StringPrintf("%s: failed", fn);
+    }
+    else
+    {
+        if((channel != NULL) &&
+           (channel->open) != NULL)
+        {
+            jcHandle = channel->open();
+            if(jcHandle == EE_ERROR_OPEN_FAIL)
+            {
+                LOG(ERROR) << StringPrintf("%s:Open DWP communication is failed", fn);
+                stat = false;
+            }
+            else
+            {
+                LOG(ERROR) << StringPrintf("%s:Open DWP communication is success", fn);
+                stat = true;
+            }
+        }
+        else
+        {
+            LOG(ERROR) << StringPrintf("%s: NULL DWP channel", fn);
+            stat = false;
+        }
+    }
+    return (stat == true)?STATUS_OK:STATUS_FAILED;
+}
+
+/*******************************************************************************
+**
+** Function:        JCDNLD_StartDownload
+**
+** Description:     Starts the JCOP update
+**
+** Returns:         SUCCESS if ok.
+**
+*******************************************************************************/
+tJBL_STATUS JCDNLD_StartDownload()
+{
+    static const char fn[] = "JCDNLD_StartDownload";
+    DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Enter", fn);
+    tJBL_STATUS status = STATUS_FAILED;
+    status = jd->JcopOs_Download();
+    DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Exit; status=0x0%X", fn, status);
+    return status;
+}
+
+/*******************************************************************************
+**
+** Function:        JCDNLD_DeInit
+**
+** Description:     Deinitializes the JCOP Lib
+**
+** Returns:         true if ok.
+**
+*******************************************************************************/
+bool JCDNLD_DeInit()
+{
+    static const char fn[] = "JCDNLD_DeInit";
+    bool    stat = false;
+    DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter", fn);
+
+    if(gpJcopOs_Dwnld_Context != NULL)
+    {
+        channel = gpJcopOs_Dwnld_Context->channel;
+        if((channel != NULL) && (channel->doeSE_JcopDownLoadReset != NULL))
+        {
+            channel->doeSE_JcopDownLoadReset();
+            if(channel->close != NULL)
+            {
+                stat = channel->close(jcHandle);
+                if(stat != true)
+                {
+                    LOG(ERROR) << StringPrintf("%s:closing DWP channel is failed", fn);
+                }
+            }
+            else
+            {
+                LOG(ERROR) << StringPrintf("%s: NULL fp DWP_close", fn);
+                stat = false;
+            }
+        }
+    }
+    else
+    {
+        LOG(ERROR) << StringPrintf("%s: NULL dwnld context", fn);
+    }
+    jd->finalize();
+    /*TODO: inUse assignment should be with protection like using semaphore*/
+    inUse = false;
+    return stat;
+}
+
+/*******************************************************************************
+**
+** Function:        JCDNLD_CheckVersion
+**
+** Description:     Check the existing JCOP OS version
+**
+** Returns:         true if ok.
+**
+*******************************************************************************/
+bool JCDNLD_CheckVersion()
+{
+
+    /**
+     * Need to implement in case required
+     * */
+    return true;
+}
diff --git a/jcos_client/src/JcopOsDownload.cpp b/jcos_client/src/JcopOsDownload.cpp
new file mode 100644
index 0000000..d45e02c
--- /dev/null
+++ b/jcos_client/src/JcopOsDownload.cpp
@@ -0,0 +1,1041 @@
+ /*
+  * Copyright (C) 2015-2018 NXP Semiconductors
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+#include <semaphore.h>
+#include <JcopOsDownload.h>
+#include <IChannel.h>
+#include <errno.h>
+#include <string.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+
+using android::base::StringPrintf;
+
+JcopOsDwnld JcopOsDwnld::sJcopDwnld;
+static int32_t gTransceiveTimeout = 120000;
+uint8_t isUaiEnabled = false;
+uint8_t isPatchUpdate = false;
+
+tJBL_STATUS (JcopOsDwnld::*JcopOs_dwnld_seqhandler[])(
+            JcopOs_ImageInfo_t* pContext, tJBL_STATUS status, JcopOs_TranscieveInfo_t* pInfo)={
+       &JcopOsDwnld::UaiTriggerApdu,
+       &JcopOsDwnld::SendUAICmds,
+       &JcopOsDwnld::TriggerApdu,
+       &JcopOsDwnld::GetInfo,
+       &JcopOsDwnld::load_JcopOS_image,
+       &JcopOsDwnld::GetInfo,
+       &JcopOsDwnld::load_JcopOS_image,
+       &JcopOsDwnld::GetInfo,
+       &JcopOsDwnld::load_JcopOS_image,
+       NULL
+   };
+
+pJcopOs_Dwnld_Context_t gpJcopOs_Dwnld_Context = NULL;
+static const char *path[3] = {"/vendor/etc/JcopOs_Update1.apdu",
+                             "/vendor/etc/JcopOs_Update2.apdu",
+                             "/vendor/etc/JcopOs_Update3.apdu"};
+static const char *JCOP_INFO_PATH[2] = {"/data/vendor/nfc/jcop_info.txt",
+                            "/data/vendor/secure_element/jcop_info.txt"};
+
+static const char *uai_path[2] = {"/vendor/etc/cci.jcsh",
+                                  "/vendor/etc/jci.jcsh"};
+
+inline int FSCANF_BYTE(FILE *stream, const char *format, void* pVal)
+{
+    int Result = 0;
+
+    if((NULL != stream) && (NULL != format) && (NULL != pVal))
+    {
+        unsigned int dwVal;
+        unsigned char* pTmp = (unsigned char*)pVal;
+        Result = fscanf(stream, format, &dwVal);
+
+        (*pTmp) = (unsigned char)(dwVal & 0x000000FF);
+    }
+    return Result;
+}
+
+/*******************************************************************************
+**
+** Function:        getInstance
+**
+** Description:     Get the JcopOsDwnld singleton object.
+**
+** Returns:         JcopOsDwnld object.
+**
+*******************************************************************************/
+JcopOsDwnld* JcopOsDwnld::getInstance()
+{
+    JcopOsDwnld *jd = new JcopOsDwnld();
+    return jd;
+}
+
+/*******************************************************************************
+**
+** Function:        getJcopOsFileInfo
+**
+** Description:     Verify all the updater files required for download
+**                  are present or not
+**
+** Returns:         True if ok.
+**
+*******************************************************************************/
+bool JcopOsDwnld::getJcopOsFileInfo()
+{
+    static const char fn [] = "JcopOsDwnld::getJcopOsFileInfo";
+    bool status = true;
+    struct stat st;
+    isPatchUpdate = false;
+    int isFilepresent = 0;
+    DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Enter", fn);
+    for (int num = 0; num < 2; num++)
+    {
+        if (stat(uai_path[num], &st))
+        {
+            status = false;
+        }
+    }
+    /*If UAI specific files are present*/
+    if(status == true)
+    {
+        isUaiEnabled = true;
+        for (int num = 0; num < 3; num++)
+        {
+           if (stat(path[num], &st))
+              status = false;
+           else
+              isFilepresent++;
+        }
+        if(isFilepresent == 1 && status == false && !(stat(path[0], &st)))
+        {
+           isPatchUpdate = true;
+           status = true;
+        } else if(isFilepresent == 2 && status == false) {
+           isPatchUpdate = false;
+           status = false;
+        }
+    }
+    DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Exit Status %d", fn, status);
+    return status;
+}
+
+/*******************************************************************************
+**
+** Function:        initialize
+**
+** Description:     Initialize all member variables.
+**                  native: Native data.
+**
+** Returns:         True if ok.
+**
+*******************************************************************************/
+bool JcopOsDwnld::initialize (IChannel_t *channel)
+{
+    static const char fn [] = "JcopOsDwnld::initialize";
+    isUaiEnabled = false;
+    DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf ("%s: enter", fn);
+
+    if (!getJcopOsFileInfo())
+    {
+        DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: insufficient resources, file not present", fn);
+        return (false);
+    }
+    gpJcopOs_Dwnld_Context = (pJcopOs_Dwnld_Context_t)malloc(sizeof(JcopOs_Dwnld_Context_t));
+    if(gpJcopOs_Dwnld_Context != NULL)
+    {
+        memset((void *)gpJcopOs_Dwnld_Context, 0, (uint32_t)sizeof(JcopOs_Dwnld_Context_t));
+        gpJcopOs_Dwnld_Context->channel = (IChannel_t*)malloc(sizeof(IChannel_t));
+        if(gpJcopOs_Dwnld_Context->channel != NULL)
+        {
+            memset(gpJcopOs_Dwnld_Context->channel, 0, sizeof(IChannel_t));
+        }
+        else
+        {
+            DLOG_IF(INFO, nfc_debug_enabled)
+                << StringPrintf("%s: Memory allocation for IChannel is failed", fn);
+            return (false);
+        }
+        gpJcopOs_Dwnld_Context->pJcopOs_TransInfo.sSendData = (uint8_t*)malloc(sizeof(uint8_t)*JCOP_MAX_BUF_SIZE);
+        if(gpJcopOs_Dwnld_Context->pJcopOs_TransInfo.sSendData != NULL)
+        {
+            memset(gpJcopOs_Dwnld_Context->pJcopOs_TransInfo.sSendData, 0, JCOP_MAX_BUF_SIZE);
+        }
+        else
+        {
+            DLOG_IF(INFO, nfc_debug_enabled)
+                << StringPrintf("%s: Memory allocation for SendBuf is failed", fn);
+            return (false);
+        }
+    }
+    else
+    {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: Memory allocation failed", fn);
+        return (false);
+    }
+    mIsInit = true;
+    memcpy(gpJcopOs_Dwnld_Context->channel, channel, sizeof(IChannel_t));
+    DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf ("%s: exit", fn);
+    return (true);
+}
+/*******************************************************************************
+**
+** Function:        finalize
+**
+** Description:     Release all resources.
+**
+** Returns:         None
+**
+*******************************************************************************/
+void JcopOsDwnld::finalize ()
+{
+    static const char fn [] = "JcopOsDwnld::finalize";
+    DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf ("%s: enter", fn);
+    mIsInit       = false;
+    if(gpJcopOs_Dwnld_Context != NULL)
+    {
+        if(gpJcopOs_Dwnld_Context->channel != NULL)
+        {
+            free(gpJcopOs_Dwnld_Context->channel);
+            gpJcopOs_Dwnld_Context->channel = NULL;
+        }
+        if(gpJcopOs_Dwnld_Context->pJcopOs_TransInfo.sSendData != NULL)
+        {
+            free(gpJcopOs_Dwnld_Context->pJcopOs_TransInfo.sSendData);
+            gpJcopOs_Dwnld_Context->pJcopOs_TransInfo.sSendData = NULL;
+        }
+        free(gpJcopOs_Dwnld_Context);
+        gpJcopOs_Dwnld_Context = NULL;
+    }
+    DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf ("%s: exit", fn);
+}
+
+/*******************************************************************************
+**
+** Function:        JcopOs_Download
+**
+** Description:     Starts the OS download sequence
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tJBL_STATUS JcopOsDwnld::JcopOs_Download()
+{
+    static const char fn [] = "JcopOsDwnld::JcopOs_Download";
+    tJBL_STATUS wstatus = STATUS_FAILED;
+    uint8_t retry_cnt = 0x00;
+    DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Enter:", fn);
+    if(mIsInit == false)
+    {
+        DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf ("%s: JcopOs Dwnld is not initialized", fn);
+        wstatus = STATUS_FAILED;
+    }
+    else
+    {
+        do
+        {
+            wstatus = JcopOsDwnld::JcopOs_update_seq_handler();
+            if(wstatus == STATUS_FAILED)
+                retry_cnt++;
+            else
+                break;
+        }while(retry_cnt < JCOP_MAX_RETRY_CNT);
+    }
+    DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Exit; status = 0x%x", fn, wstatus);
+    return wstatus;
+}
+/*******************************************************************************
+**
+** Function:        JcopOs_update_seq_handler
+**
+** Description:     Performs the JcopOS download sequence
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tJBL_STATUS JcopOsDwnld::JcopOs_update_seq_handler()
+{
+    static const char fn[] = "JcopOsDwnld::JcopOs_update_seq_handler";
+    uint8_t seq_counter = 0;
+    JcopOs_ImageInfo_t update_info = (JcopOs_ImageInfo_t )gpJcopOs_Dwnld_Context->Image_info;
+    JcopOs_TranscieveInfo_t trans_info = (JcopOs_TranscieveInfo_t )gpJcopOs_Dwnld_Context->pJcopOs_TransInfo;
+    update_info.index = 0x00;
+    update_info.cur_state = 0x00;
+    tJBL_STATUS status = STATUS_FAILED;
+
+    DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter", fn);
+    status = GetJcopOsState(&update_info, &seq_counter);
+    if(status != STATUS_SUCCESS)
+    {
+        LOG(ERROR) << StringPrintf("Error in getting JcopOsState info");
+    }
+    else
+    {
+        LOG(ERROR) << StringPrintf("seq_counter %d", seq_counter);
+        while((JcopOs_dwnld_seqhandler[seq_counter]) != NULL )
+        {
+            status = STATUS_FAILED;
+            status = (*this.*(JcopOs_dwnld_seqhandler[seq_counter]))(&update_info, status, &trans_info );
+            if(STATUS_SUCCESS != status)
+            {
+                LOG(ERROR) << StringPrintf("%s: exiting; status=0x0%X", fn, status);
+                break;
+            }
+            seq_counter++;
+        }
+        if(status == STATUS_SUCCESS)
+        {
+          int32_t recvBufferActualSize = 0;
+          uint8_t select[] = {0, 0xA4, 0x04, 0, 0};
+          uint16_t handle = gpJcopOs_Dwnld_Context->channel->open();
+          usleep(100*1000);
+          LOG(ERROR) << StringPrintf("%s: Issue First APDU", fn);
+          gpJcopOs_Dwnld_Context->channel->transceive(select, sizeof(select),
+          trans_info.sRecvData, 1024, recvBufferActualSize, trans_info.timeout);
+
+          gpJcopOs_Dwnld_Context->channel->close(handle);
+        }
+    }
+    return status;
+}
+
+/*******************************************************************************
+**
+** Function:        TriggerApdu
+**
+** Description:     Switch to updater OS
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tJBL_STATUS JcopOsDwnld::TriggerApdu(JcopOs_ImageInfo_t* pVersionInfo, tJBL_STATUS status, JcopOs_TranscieveInfo_t* pTranscv_Info)
+{
+    static const char fn [] = "JcopOsDwnld::TriggerApdu";
+    bool stat = false;
+    IChannel_t *mchannel = gpJcopOs_Dwnld_Context->channel;
+    int32_t recvBufferActualSize = 0;
+
+    DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter;", fn);
+    if(pTranscv_Info == NULL ||
+       pVersionInfo == NULL)
+    {
+        DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Invalid parameter", fn);
+        status = STATUS_FAILED;
+    }
+    else
+    {
+        pTranscv_Info->timeout = gTransceiveTimeout;
+        pTranscv_Info->sSendlength = (int32_t)sizeof(Trigger_APDU);
+        pTranscv_Info->sRecvlength = 1024;//(int32_t)sizeof(int32_t);
+        memcpy(pTranscv_Info->sSendData, Trigger_APDU, pTranscv_Info->sSendlength);
+
+        DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Calling Secure Element Transceive", fn);
+        stat = mchannel->transceive (pTranscv_Info->sSendData,
+                                pTranscv_Info->sSendlength,
+                                pTranscv_Info->sRecvData,
+                                pTranscv_Info->sRecvlength,
+                                recvBufferActualSize,
+                                pTranscv_Info->timeout);
+        if (stat != true)
+        {
+            status = STATUS_FAILED;
+            LOG(ERROR) << StringPrintf("%s: SE transceive failed status = 0x%X", fn, status);//Stop JcopOs Update
+        }
+        else if(((pTranscv_Info->sRecvData[recvBufferActualSize-2] == 0x68) &&
+               (pTranscv_Info->sRecvData[recvBufferActualSize-1] == 0x81))||
+               ((pTranscv_Info->sRecvData[recvBufferActualSize-2] == 0x90) &&
+               (pTranscv_Info->sRecvData[recvBufferActualSize-1] == 0x00))||
+               ((pTranscv_Info->sRecvData[recvBufferActualSize-2] == 0x6F) &&
+               (pTranscv_Info->sRecvData[recvBufferActualSize-1] == 0x00)))
+        {
+            mchannel->doeSE_JcopDownLoadReset();
+            status = STATUS_OK;
+            DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Trigger APDU Transceive status = 0x%X", fn, status);
+        }
+        else
+        {
+            /* status {90, 00} */
+            status = STATUS_OK;
+        }
+    }
+    DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit; status = 0x%X", fn, status);
+    return status;
+}
+
+/*******************************************************************************
+**
+** Function:        SendUAICmds
+**
+** Description:     Perform UAI Authentication
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tJBL_STATUS JcopOsDwnld::SendUAICmds(JcopOs_ImageInfo_t* Os_info, tJBL_STATUS status, JcopOs_TranscieveInfo_t* pTranscv_Info)
+{
+    static const char fn [] = "JcopOsDwnld::SendUAICmds";
+    bool stat = false;
+    int wResult;
+    int32_t wIndex,wCount=0;
+    int32_t wLen;
+    IChannel_t *mchannel = gpJcopOs_Dwnld_Context->channel;
+    int32_t recvBufferActualSize = 0;
+    int i = 0;
+
+    DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter;", fn);
+
+    if(!isUaiEnabled)
+    {
+        goto exit;
+    }
+    if(pTranscv_Info == NULL ||
+               Os_info == NULL)
+    {
+        DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Invalid parameter", fn);
+        status = STATUS_FAILED;
+    }
+    for(i = 0; i < 2; i++)
+    {
+        Os_info->fp = fopen(uai_path[i], "r");
+        if (Os_info->fp == NULL) {
+            LOG(ERROR) << StringPrintf("Error opening CCI file <%s> for reading: %s",
+                        Os_info->fls_path, strerror(errno));
+            return STATUS_FILE_NOT_FOUND;
+        }
+        wResult = fseek(Os_info->fp, 0L, SEEK_END);
+        if (wResult) {
+            LOG(ERROR) << StringPrintf("Error seeking end CCI file %s", strerror(errno));
+            goto exit;
+        }
+        Os_info->fls_size = ftell(Os_info->fp);
+        if (Os_info->fls_size < 0) {
+            LOG(ERROR) << StringPrintf("Error ftelling file %s", strerror(errno));
+            goto exit;
+        }
+        wResult = fseek(Os_info->fp, 6L, SEEK_SET);
+        if (wResult) {
+            LOG(ERROR) << StringPrintf("Error seeking start image file %s", strerror(errno));
+            goto exit;
+        }
+        {
+            wIndex=0;
+            wLen=0;
+            wCount=0;
+            memset(pTranscv_Info->sSendData,0x00,JCOP_MAX_BUF_SIZE);
+            pTranscv_Info->sSendlength=0;
+
+            LOG(ERROR) << StringPrintf("%s; wIndex = 0", fn);
+            for(wCount =0; (wCount < 5 && !feof(Os_info->fp)); wCount++, wIndex++)
+            {
+                wResult = FSCANF_BYTE(Os_info->fp,"%2X",&pTranscv_Info->sSendData[wIndex]);
+            }
+            if(wResult != 0)
+            {
+                wLen = pTranscv_Info->sSendData[4];
+                LOG(ERROR) << StringPrintf("%s; Read 5byes success & len=%d", fn,wLen);
+                if(wLen == 0x00)
+                {
+                    LOG(ERROR) << StringPrintf("%s: Extended APDU", fn);
+                    wResult = FSCANF_BYTE(Os_info->fp,"%2X",&pTranscv_Info->sSendData[wIndex++]);
+                    wResult = FSCANF_BYTE(Os_info->fp,"%2X",&pTranscv_Info->sSendData[wIndex++]);
+                    wLen = ((pTranscv_Info->sSendData[5] << 8) | (pTranscv_Info->sSendData[6]));
+                }
+                for(wCount =0; (wCount < wLen && !feof(Os_info->fp)); wCount++, wIndex++)
+                {
+                    wResult = FSCANF_BYTE(Os_info->fp,"%2X",&pTranscv_Info->sSendData[wIndex]);
+                }
+            }
+            else
+            {
+                LOG(ERROR) << StringPrintf("%s: JcopOs image Read failed", fn);
+                goto exit;
+            }
+            pTranscv_Info->sSendlength = wIndex;
+            LOG(ERROR) << StringPrintf("%s: start transceive for length %d", fn, pTranscv_Info->sSendlength);
+            if((pTranscv_Info->sSendlength != 0x03) &&
+               (pTranscv_Info->sSendData[0] != 0x00) &&
+               (pTranscv_Info->sSendData[1] != 0x00))
+            {
+
+                stat = mchannel->transceive(pTranscv_Info->sSendData,
+                                        pTranscv_Info->sSendlength,
+                                        pTranscv_Info->sRecvData,
+                                        pTranscv_Info->sRecvlength,
+                                        recvBufferActualSize,
+                                        pTranscv_Info->timeout);
+            }
+            else
+            {
+                LOG(ERROR) << StringPrintf("%s: Invalid packet", fn);
+                goto exit;
+            }
+            if(stat != true)
+            {
+                LOG(ERROR) << StringPrintf("%s: Transceive failed; status=0x%X", fn, stat);
+                status = STATUS_FAILED;
+                goto exit;
+            }
+            else if(recvBufferActualSize != 0 &&
+                    pTranscv_Info->sRecvData[recvBufferActualSize-2] == 0x90 &&
+                    pTranscv_Info->sRecvData[recvBufferActualSize-1] == 0x00)
+            {
+                status = STATUS_SUCCESS;
+            }
+            else if(pTranscv_Info->sRecvData[recvBufferActualSize-2] == 0x6F &&
+                    pTranscv_Info->sRecvData[recvBufferActualSize-1] == 0x00)
+            {
+                LOG(ERROR) << StringPrintf("%s: JcopOs is already upto date-No update required exiting", fn);
+                Os_info->version_info.ver_status = STATUS_UPTO_DATE;
+                status = STATUS_FAILED;
+                break;
+            }
+            else
+            {
+                status = STATUS_FAILED;
+                LOG(ERROR) << StringPrintf("%s: pTranscv_Info->sRecvData[recvBufferActualSize-1] = 0x%x%x recvBufferActualSize = %d", fn,
+                		pTranscv_Info->sRecvData[recvBufferActualSize-2], pTranscv_Info->sRecvData[recvBufferActualSize-1],recvBufferActualSize);
+                LOG(ERROR) << StringPrintf("%s: Invalid response", fn);
+                goto exit;
+            }
+        }
+        wResult = fclose(Os_info->fp);
+    }
+exit:
+    LOG(ERROR) << StringPrintf("%s close fp and exit; status= 0x%X", fn,status);
+    mchannel->doeSE_JcopDownLoadReset();
+    if(status == STATUS_SUCCESS)
+        SetJcopOsState(Os_info, JCOP_UPDATE_STATE_TRIGGER_APDU);
+    else
+        wResult = fclose(Os_info->fp);
+
+    return status;
+}
+/*******************************************************************************
+**
+** Function:        UaiTriggerApdu
+**
+** Description:     Switch to updater OS
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tJBL_STATUS JcopOsDwnld::UaiTriggerApdu(JcopOs_ImageInfo_t* pVersionInfo, tJBL_STATUS status, JcopOs_TranscieveInfo_t* pTranscv_Info)
+{
+    static const char fn [] = "JcopOsDwnld::UaiTriggerApdu";
+    bool stat = false;
+    IChannel_t *mchannel = gpJcopOs_Dwnld_Context->channel;
+    int32_t recvBufferActualSize = 0;
+
+    DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter;", fn);
+
+    if(!isUaiEnabled)
+    {
+        return true;
+    }
+    if(pTranscv_Info == NULL ||
+       pVersionInfo == NULL)
+    {
+        DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Invalid parameter", fn);
+        status = STATUS_FAILED;
+    }
+    else
+    {
+        pTranscv_Info->timeout = gTransceiveTimeout;
+        pTranscv_Info->sSendlength = (int32_t)sizeof(Uai_Trigger_APDU);
+        pTranscv_Info->sRecvlength = 1024;//(int32_t)sizeof(int32_t);
+        memcpy(pTranscv_Info->sSendData, Uai_Trigger_APDU, pTranscv_Info->sSendlength);
+
+        DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Calling Secure Element Transceive", fn);
+        stat = mchannel->transceive (pTranscv_Info->sSendData,
+                                pTranscv_Info->sSendlength,
+                                pTranscv_Info->sRecvData,
+                                pTranscv_Info->sRecvlength,
+                                recvBufferActualSize,
+                                pTranscv_Info->timeout);
+        if (stat != true)
+        {
+            status = STATUS_FAILED;
+            LOG(ERROR) << StringPrintf("%s: SE transceive failed status = 0x%X", fn, status);//Stop JcopOs Update
+        }
+        else if(((pTranscv_Info->sRecvData[recvBufferActualSize-2] == 0x68) &&
+               (pTranscv_Info->sRecvData[recvBufferActualSize-1] == 0x81))||
+               ((pTranscv_Info->sRecvData[recvBufferActualSize-2] == 0x90) &&
+               (pTranscv_Info->sRecvData[recvBufferActualSize-1] == 0x00))||
+               ((pTranscv_Info->sRecvData[recvBufferActualSize-2] == 0x6F) &&
+               (pTranscv_Info->sRecvData[recvBufferActualSize-1] == 0x00)))
+        {
+            /*mchannel->doeSE_JcopDownLoadReset();*/
+            status = STATUS_OK;
+            DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Trigger APDU Transceive status = 0x%X", fn, status);
+        }
+        else
+        {
+            /* status {90, 00} */
+            status = STATUS_OK;
+        }
+    }
+    DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit; status = 0x%X", fn, status);
+    return status;
+}
+/*******************************************************************************
+**
+** Function:        GetInfo
+**
+** Description:     Get the JCOP OS info
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tJBL_STATUS JcopOsDwnld::GetInfo(JcopOs_ImageInfo_t* pImageInfo, tJBL_STATUS status, JcopOs_TranscieveInfo_t* pTranscv_Info)
+{
+    static const char fn [] = "JcopOsDwnld::GetInfo";
+
+    bool stat = false;
+    IChannel_t *mchannel = gpJcopOs_Dwnld_Context->channel;
+    int32_t recvBufferActualSize = 0;
+
+    DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter;", fn);
+
+    if(pTranscv_Info == NULL ||
+       pImageInfo == NULL)
+    {
+        DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Invalid parameter", fn);
+        status = STATUS_FAILED;
+    }
+    else
+    {
+        memcpy(pImageInfo->fls_path, (char *)path[pImageInfo->index], strlen(path[pImageInfo->index]));
+
+        memset(pTranscv_Info->sSendData, 0, JCOP_MAX_BUF_SIZE);
+        pTranscv_Info->timeout = gTransceiveTimeout;
+        if(isUaiEnabled)
+        {
+             pTranscv_Info->sSendlength = (uint32_t)sizeof(Uai_GetInfo_APDU);
+             memcpy(pTranscv_Info->sSendData, Uai_GetInfo_APDU, pTranscv_Info->sSendlength);
+        }else
+        {
+            pTranscv_Info->sSendlength = (uint32_t)sizeof(GetInfo_APDU);
+            memcpy(pTranscv_Info->sSendData, GetInfo_APDU, pTranscv_Info->sSendlength);
+        }
+        pTranscv_Info->sRecvlength = 1024;
+
+        DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Calling Secure Element Transceive", fn);
+        stat = mchannel->transceive (pTranscv_Info->sSendData,
+                                pTranscv_Info->sSendlength,
+                                pTranscv_Info->sRecvData,
+                                pTranscv_Info->sRecvlength,
+                                recvBufferActualSize,
+                                pTranscv_Info->timeout);
+        if (stat != true)
+        {
+            status = STATUS_FAILED;
+            pImageInfo->index =0;
+            LOG(ERROR) << StringPrintf("%s: SE transceive failed status = 0x%X", fn, status);//Stop JcopOs Update
+        }
+        else if((pTranscv_Info->sRecvData[recvBufferActualSize-2] == 0x90) &&
+                (pTranscv_Info->sRecvData[recvBufferActualSize-1] == 0x00))
+        {
+            pImageInfo->version_info.osid = pTranscv_Info->sRecvData[recvBufferActualSize-6];
+            pImageInfo->version_info.ver1 = pTranscv_Info->sRecvData[recvBufferActualSize-5];
+            pImageInfo->version_info.ver0 = pTranscv_Info->sRecvData[recvBufferActualSize-4];
+            pImageInfo->version_info.OtherValid = pTranscv_Info->sRecvData[recvBufferActualSize-3];
+#if 0
+            if((pImageInfo->index != 0) &&
+               (pImageInfo->version_info.osid == 0x01) &&
+               (pImageInfo->version_info.OtherValid == 0x11))
+            {
+                LOG(ERROR) << StringPrintf("3-Step update is not required");
+                memset(pImageInfo->fls_path,0,sizeof(pImageInfo->fls_path));
+                pImageInfo->index=0;
+            }
+            else
+#endif
+            {
+                LOG(ERROR) << StringPrintf("Starting 3-Step update");
+                memcpy(pImageInfo->fls_path, path[pImageInfo->index], sizeof(path[pImageInfo->index]));
+                pImageInfo->index++;
+            }
+            status = STATUS_OK;
+            DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: GetInfo Transceive status = 0x%X", fn, status);
+        }
+        else if((pTranscv_Info->sRecvData[recvBufferActualSize-2] == 0x6A) &&
+                (pTranscv_Info->sRecvData[recvBufferActualSize-1] == 0x82) &&
+                 pImageInfo->version_info.ver_status == STATUS_UPTO_DATE)
+        {
+            status = STATUS_UPTO_DATE;
+        }
+        else
+        {
+            status = STATUS_FAILED;
+            DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s; Invalid response for GetInfo", fn);
+        }
+    }
+
+    if (status == STATUS_FAILED)
+    {
+        DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s; status failed, doing reset...", fn);
+        mchannel->doeSE_JcopDownLoadReset();
+    }
+    DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit; status = 0x%X", fn, status);
+    return status;
+}
+/*******************************************************************************
+**
+** Function:        load_JcopOS_image
+**
+** Description:     Used to update the JCOP OS
+**                  Get Info function has to be called before this
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tJBL_STATUS JcopOsDwnld::load_JcopOS_image(JcopOs_ImageInfo_t *Os_info, tJBL_STATUS status, JcopOs_TranscieveInfo_t *pTranscv_Info)
+{
+    static const char fn [] = "JcopOsDwnld::load_JcopOS_image";
+    bool stat = false;
+    int wResult;
+    int32_t wIndex,wCount=0;
+    int32_t wLen;
+
+    IChannel_t *mchannel = gpJcopOs_Dwnld_Context->channel;
+    int32_t recvBufferActualSize = 0;
+    DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter", fn);
+    if(Os_info == NULL ||
+       pTranscv_Info == NULL)
+    {
+        LOG(ERROR) << StringPrintf("%s: invalid parameter", fn);
+        return status;
+    }
+    Os_info->fp = fopen(Os_info->fls_path, "r");
+
+    if (Os_info->fp == NULL) {
+        LOG(ERROR) << StringPrintf("Error opening OS image file <%s> for reading: %s",
+                    Os_info->fls_path, strerror(errno));
+        return STATUS_FILE_NOT_FOUND;
+    }
+    wResult = fseek(Os_info->fp, 0L, SEEK_END);
+    if (wResult) {
+        LOG(ERROR) << StringPrintf("Error seeking end OS image file %s", strerror(errno));
+        goto exit;
+    }
+    Os_info->fls_size = ftell(Os_info->fp);
+    if (Os_info->fls_size < 0) {
+        LOG(ERROR) << StringPrintf("Error ftelling file %s", strerror(errno));
+        goto exit;
+    }
+    wResult = fseek(Os_info->fp, 0L, SEEK_SET);
+    if (wResult) {
+        LOG(ERROR) << StringPrintf("Error seeking start image file %s", strerror(errno));
+        goto exit;
+    }
+    while(!feof(Os_info->fp))
+    {
+        LOG(ERROR) << StringPrintf("%s; Start of line processing", fn);
+
+        wIndex=0;
+        wLen=0;
+        wCount=0;
+        memset(pTranscv_Info->sSendData,0x00,JCOP_MAX_BUF_SIZE);
+        pTranscv_Info->sSendlength=0;
+
+        LOG(ERROR) << StringPrintf("%s; wIndex = 0", fn);
+        for(wCount =0; (wCount < 5 && !feof(Os_info->fp)); wCount++, wIndex++)
+        {
+            wResult = FSCANF_BYTE(Os_info->fp,"%2X",&pTranscv_Info->sSendData[wIndex]);
+        }
+        if(wResult != 0)
+        {
+            wLen = pTranscv_Info->sSendData[4];
+            LOG(ERROR) << StringPrintf("%s; Read 5byes success & len=%d", fn,wLen);
+            if(wLen == 0x00)
+            {
+                LOG(ERROR) << StringPrintf("%s: Extended APDU", fn);
+                wResult = FSCANF_BYTE(Os_info->fp,"%2X",&pTranscv_Info->sSendData[wIndex++]);
+                wResult = FSCANF_BYTE(Os_info->fp,"%2X",&pTranscv_Info->sSendData[wIndex++]);
+                wLen = ((pTranscv_Info->sSendData[5] << 8) | (pTranscv_Info->sSendData[6]));
+            }
+            for(wCount =0; (wCount < wLen && !feof(Os_info->fp)); wCount++, wIndex++)
+            {
+                wResult = FSCANF_BYTE(Os_info->fp,"%2X",&pTranscv_Info->sSendData[wIndex]);
+            }
+        }
+        else
+        {
+            LOG(ERROR) << StringPrintf("%s: JcopOs image Read failed", fn);
+            goto exit;
+        }
+
+        pTranscv_Info->sSendlength = wIndex;
+        LOG(ERROR) << StringPrintf("%s: start transceive for length %d", fn, pTranscv_Info->sSendlength);
+        if((pTranscv_Info->sSendlength != 0x03) &&
+           (pTranscv_Info->sSendData[0] != 0x00) &&
+           (pTranscv_Info->sSendData[1] != 0x00))
+        {
+
+            stat = mchannel->transceive(pTranscv_Info->sSendData,
+                                    pTranscv_Info->sSendlength,
+                                    pTranscv_Info->sRecvData,
+                                    pTranscv_Info->sRecvlength,
+                                    recvBufferActualSize,
+                                    pTranscv_Info->timeout);
+        }
+        else
+        {
+            LOG(ERROR) << StringPrintf("%s: Invalid packet", fn);
+            continue;
+        }
+        if(stat != true)
+        {
+            LOG(ERROR) << StringPrintf("%s: Transceive failed; status=0x%X", fn, stat);
+            status = STATUS_FAILED;
+            goto exit;
+        }
+        else if(recvBufferActualSize != 0 &&
+                pTranscv_Info->sRecvData[recvBufferActualSize-2] == 0x90 &&
+                pTranscv_Info->sRecvData[recvBufferActualSize-1] == 0x00)
+        {
+            //LOG(ERROR) << StringPrintf("%s: END transceive for length %d", fn, pTranscv_Info->sSendlength);
+            status = STATUS_SUCCESS;
+        }
+        else if(pTranscv_Info->sRecvData[recvBufferActualSize-2] == 0x6F &&
+                pTranscv_Info->sRecvData[recvBufferActualSize-1] == 0x00)
+        {
+            LOG(ERROR) << StringPrintf("%s: JcopOs is already upto date-No update required exiting", fn);
+            Os_info->version_info.ver_status = STATUS_UPTO_DATE;
+            status = STATUS_FAILED;
+            break;
+        }
+        else if(pTranscv_Info->sRecvData[recvBufferActualSize-2] == 0x6F &&
+                pTranscv_Info->sRecvData[recvBufferActualSize-1] == 0xA1)
+        {
+            LOG(ERROR) << StringPrintf("%s: JcopOs is already up to date-No update required exiting", fn);
+            Os_info->version_info.ver_status = STATUS_UPTO_DATE;
+            status = STATUS_UPTO_DATE;
+            break;
+        }
+        else
+        {
+            status = STATUS_FAILED;
+            LOG(ERROR) << StringPrintf("%s: Invalid response", fn);
+        }
+        LOG(ERROR) << StringPrintf("%s: Going for next line", fn);
+    }
+
+    if(status == STATUS_SUCCESS)
+    {
+        Os_info->cur_state++;
+        /*If Patch Update is required*/
+        if(isPatchUpdate)
+        {
+          /*Set the step to 3 to handle multiple
+          JCOP Patch update*/
+          Os_info->cur_state = 3;
+        }
+        SetJcopOsState(Os_info, Os_info->cur_state);
+    }
+
+exit:
+    mchannel->doeSE_JcopDownLoadReset();
+    LOG(ERROR) << StringPrintf("%s close fp and exit; status= 0x%X", fn,status);
+    wResult = fclose(Os_info->fp);
+    return status;
+}
+
+/*******************************************************************************
+**
+** Function:        GetJcopOsState
+**
+** Description:     Used to update the JCOP OS state
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tJBL_STATUS JcopOsDwnld::GetJcopOsState(JcopOs_ImageInfo_t *Os_info, uint8_t *counter)
+{
+    static const char fn [] = "JcopOsDwnld::GetJcopOsState";
+    tJBL_STATUS status = STATUS_SUCCESS;
+    FILE *fp;
+    uint8_t xx=0;
+    DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter", fn);
+    IChannel_t *mchannel = gpJcopOs_Dwnld_Context->channel;
+    if(Os_info == NULL)
+    {
+        LOG(ERROR) << StringPrintf("%s: invalid parameter", fn);
+        return STATUS_FAILED;
+    }
+    fp = fopen(JCOP_INFO_PATH[mchannel->getInterfaceInfo()], "r");
+
+
+    if (fp == NULL) {
+        LOG(ERROR) << StringPrintf("file <%s> not exits for reading- creating new file: %s",
+                JCOP_INFO_PATH[mchannel->getInterfaceInfo()], strerror(errno));
+        fp = fopen(JCOP_INFO_PATH[mchannel->getInterfaceInfo()], "w+");
+        if (fp == NULL)
+        {
+            LOG(ERROR) << StringPrintf("Error opening OS image file <%s> for reading: %s",
+              JCOP_INFO_PATH[mchannel->getInterfaceInfo()], strerror(errno));
+            return STATUS_FAILED;
+        }
+        fprintf(fp, "%u", xx);
+        fclose(fp);
+    }
+    else
+    {
+        FSCANF_BYTE(fp, "%u", &xx);
+        LOG(ERROR) << StringPrintf("JcopOsState %d", xx);
+        fclose(fp);
+    }
+
+    switch(xx)
+    {
+    case JCOP_UPDATE_STATE0:
+    case JCOP_UPDATE_STATE3:
+        LOG(ERROR) << StringPrintf("Starting update from UAI Authentication");
+        Os_info->index = JCOP_UPDATE_STATE0;
+        Os_info->cur_state = JCOP_UPDATE_STATE0;
+        *counter = 0;
+        break;
+    case JCOP_UPDATE_STATE1:
+        LOG(ERROR) << StringPrintf("Starting update from step2");
+        Os_info->index = JCOP_UPDATE_STATE1;
+        Os_info->cur_state = JCOP_UPDATE_STATE1;
+        *counter = 5;
+        break;
+    case JCOP_UPDATE_STATE2:
+        LOG(ERROR) << StringPrintf("Starting update from step3");
+        Os_info->index = JCOP_UPDATE_STATE2;
+        Os_info->cur_state = JCOP_UPDATE_STATE2;
+        *counter = 7;
+        break;
+    case JCOP_UPDATE_STATE_TRIGGER_APDU:
+        LOG(ERROR) << StringPrintf("Starting update from step1");
+        Os_info->index = JCOP_UPDATE_STATE0;
+        Os_info->cur_state = JCOP_UPDATE_STATE0;
+        *counter = 2;
+        break;
+    default:
+        LOG(ERROR) << StringPrintf("invalid state");
+        status = STATUS_FAILED;
+        break;
+    }
+    return status;
+}
+
+/*******************************************************************************
+**
+** Function:        SetJcopOsState
+**
+** Description:     Used to set the JCOP OS state
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tJBL_STATUS JcopOsDwnld::SetJcopOsState(JcopOs_ImageInfo_t *Os_info, uint8_t state)
+{
+    static const char fn [] = "JcopOsDwnld::SetJcopOsState";
+    tJBL_STATUS status = STATUS_FAILED;
+    FILE *fp;
+    DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter", fn);
+    IChannel_t *mchannel = gpJcopOs_Dwnld_Context->channel;
+    if(Os_info == NULL)
+    {
+        LOG(ERROR) << StringPrintf("%s: invalid parameter", fn);
+        return status;
+    }
+    fp = fopen(JCOP_INFO_PATH[mchannel->getInterfaceInfo()], "w");
+
+    if (fp == NULL) {
+      LOG(ERROR) << StringPrintf("Error opening OS image file <%s> for reading: %s",
+        JCOP_INFO_PATH[mchannel->getInterfaceInfo()], strerror(errno));
+    }
+    else
+    {
+        fprintf(fp, "%u", state);
+        fflush(fp);
+        LOG(ERROR) << StringPrintf("Current JcopOsState: %d", state);
+        status = STATUS_SUCCESS;
+    int fd=fileno(fp);
+    int ret = fdatasync(fd);
+        LOG(ERROR) << StringPrintf("ret value: %d", ret);
+        fclose(fp);
+    }
+    return status;
+}
+
+#if 0
+void *JcopOsDwnld::GetMemory(uint32_t size)
+{
+    void *pMem;
+    static const char fn [] = "JcopOsDwnld::GetMemory";
+    pMem = (void *)malloc(size);
+
+    if(pMem != NULL)
+    {
+        memset(pMem, 0, size);
+    }
+    else
+    {
+        DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: memory allocation failed", fn);
+    }
+    return pMem;
+}
+
+void JcopOsDwnld::FreeMemory(void *pMem)
+{
+    if(pMem != NULL)
+    {
+        free(pMem);
+        pMem = NULL;
+    }
+}
+
+#endif
diff --git a/ls_client/inc/LsClient.h b/ls_client/inc/LsClient.h
new file mode 100644
index 0000000..552e72c
--- /dev/null
+++ b/ls_client/inc/LsClient.h
@@ -0,0 +1,70 @@
+/*******************************************************************************
+ *
+ *  Copyright 2018 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include "../../inc/IChannel.h"
+
+#ifdef __cplusplus
+
+extern "C" {
+
+#endif
+#ifndef LSCLIENT_H_
+#define LSCLIENT_H_
+
+#define STATUS_SUCCESS 0x00
+#define STATUS_OK 0x00
+#define STATUS_FAILED 0x03
+#define STATUS_FILE_NOT_FOUND 0x05
+
+typedef uint8_t tLSC_STATUS;
+
+/*******************************************************************************
+**
+** Function:        LSC_Start
+**
+** Description:     Starts the LSC over DWP
+**
+** Returns:         SUCCESS if ok.
+**
+*******************************************************************************/
+unsigned char LSC_Start(const char* name, const char* dest, uint8_t* pdata,
+                        uint16_t len, uint8_t* respSW);
+
+/*******************************************************************************
+**
+** Function:        performLSDownload
+**
+** Description:     Perform LS during hal init
+**
+** Returns:         SUCCESS of ok
+**
+*******************************************************************************/
+tLSC_STATUS performLSDownload(IChannel_t* data);
+
+void* phLS_memset(void* buff, int val, size_t len);
+void* phLS_memcpy(void* dest, const void* src, size_t len);
+void* phLS_memalloc(uint32_t size);
+void  phLS_free(void* ptr);
+void* phLS_calloc(size_t datatype, size_t size);
+
+#endif /* LSCLIENT_H_ */
+
+#ifdef __cplusplus
+}
+
+#endif
diff --git a/ls_client/inc/LsLib.h b/ls_client/inc/LsLib.h
new file mode 100644
index 0000000..b4b09a2
--- /dev/null
+++ b/ls_client/inc/LsLib.h
@@ -0,0 +1,555 @@
+/*******************************************************************************
+ *
+ *  Copyright 2018 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *****************************************************************************/
+
+#ifndef LSC_H_
+#define LSC_H_
+
+#define NXP_LS_AID
+#include "LsClient.h"
+#include <stdio.h>
+#include "../../inc/IChannel.h"
+#include "phNxpConfig.h"
+
+typedef struct Lsc_ChannelInfo {
+  uint8_t channel_id;
+  bool isOpend;
+} Lsc_ChannelInfo_t;
+
+typedef struct Lsc_TranscieveInfo {
+  int32_t timeout;
+  uint8_t sRecvData[1024];
+  uint8_t sSendData[1024];
+  int32_t sSendlength;
+  int sRecvlength;
+  uint8_t sTemp_recvbuf[1024];
+} Lsc_TranscieveInfo_t;
+
+typedef struct Lsc_ImageInfo {
+  FILE* fp;
+  int fls_size;
+  char fls_path[384];
+  int bytes_read;
+  FILE* fResp;
+  int fls_RespSize;
+  char fls_RespPath[384];
+  int bytes_wrote;
+  Lsc_ChannelInfo_t Channel_Info[10];
+  uint8_t channel_cnt;
+} Lsc_ImageInfo_t;
+typedef enum {
+  LS_Default = 0x00,
+  LS_Cert = 0x7F21,
+  LS_Sign = 0x60,
+  LS_Comm = 0x40
+} Ls_TagType;
+
+typedef struct Lsc_lib_Context {
+  IChannel_t            *mchannel;
+  Lsc_ImageInfo_t Image_info;
+  Lsc_TranscieveInfo_t Transcv_Info;
+} Lsc_Dwnld_Context_t, *pLsc_Dwnld_Context_t;
+
+typedef struct phNxpLs_data {
+  uint32_t len;    /*!< length of the buffer */
+  uint8_t* p_data; /*!< pointer to a buffer */
+} phNxpLs_data;
+
+
+static uint8_t OpenChannel[] = {0x00, 0x70, 0x00, 0x00, 0x01};
+static uint8_t GetData[] = {0x80, 0xCA, 0x00, 0x46, 0x00};
+#ifndef NXP_LS_AID
+static uint8_t SelectLsc[] = {0x00, 0xA4, 0x04, 0x00, 0x0D, 0xA0,
+                              0x00, 0x00, 0x03, 0x96, 0x41, 0x4C,
+                              0x41, 0x01, 0x43, 0x4F, 0x52, 0x01};
+#else
+static uint8_t SelectLsc[] = {0xA4, 0x04, 0x00, 0x0E, 0xA0, 0x00,
+                              0x00, 0x03, 0x96, 0x54, 0x43, 0x00, 0x00,
+                              0x00, 0x01, 0x00, 0x0B, 0x00};
+
+static const uint8_t SelectSEMS[] = {0xA4, 0x04, 0x00, 0x0C, 0xA0, 0x00,
+                                    0x00, 0x01, 0x51, 0x53, 0x45, 0x4D,
+                                    0x53, 0x00, 0x00, 0x00};
+
+static const uint8_t SelectSEMSUpdater[] = {0xA4, 0x04, 0x00, 0x0C, 0xA0, 0x00,
+                                    0x00, 0x01, 0x51, 0x53, 0x45, 0x4D,
+                                    0x53, 0xFF, 0xFF, 0xFF};
+#endif
+
+/*LSC2*/
+#define NOOFAIDS 0x03
+#define LENOFAIDS 0x16
+#define NUM_LS_AIDS 0x03
+#define LEN_LS_AID 0x16
+#define LS_SELF_UPDATE_AID_IDX 2
+#ifndef NXP_LS_AID
+static uint8_t ArrayOfAIDs[NUM_LS_AIDS][LEN_LS_AID] = {
+    {0x12, 0x00, 0xA4, 0x04, 0x00, 0x0D, 0xA0, 0x00, 0x00, 0x03, 0x96, 0x41,
+     0x4C, 0x41, 0x01, 0x4C, 0x44, 0x52, 0x01, 0x00, 0x00, 0x00},
+    {0x12, 0x00, 0xA4, 0x04, 0x00, 0x0D, 0xA0, 0x00, 0x00, 0x03, 0x96, 0x41,
+     0x4C, 0x41, 0x01, 0x43, 0x4F, 0x52, 0x01, 0x00, 0x00, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};
+#else
+static uint8_t ArrayOfAIDs[NOOFAIDS][LENOFAIDS] = {
+    {0x14, 0x00, 0xA4, 0x04, 0x00, 0x0F, 0xA0, 0x00, 0x00, 0x03, 0x96, 0x54,
+     0x43, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0B, 0x00, 0x02, 0x00},
+    {0x14, 0x00, 0xA4, 0x04, 0x00, 0x0F, 0xA0, 0x00, 0x00, 0x03, 0x96, 0x54,
+     0x43, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0B, 0x00, 0x01, 0x00},
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};
+#endif
+#define TAG_CERTIFICATE 0x7F21
+#define TAG_LSES_RESP 0x4E
+#define TAG_LSES_RSPLEN 0x02
+#define TAG_SERIAL_NO 0x93
+#define TAG_LSRE_ID 0x42
+#define TAG_LSRE_SIGNID 0x45
+#define TAG_CERTFHOLD_ID 0x5F20
+#define TAG_KEY_USAGE 0x95
+#define TAG_EFF_DATE 0x5F25
+#define TAG_EXP_DATE 0x5F24
+#define TAG_CCM_PERMISSION 0x53
+#define TAG_SIG_RNS_COMP 0x5F37
+#define MAX_META_STRING_SIZE 0xFF
+
+#define TAG_LS_VER1 0x9F
+#define TAG_LS_VER2 0x08
+#define LS_DEFAULT_STATUS 0x6340
+#define LS_SUCCESS_STATUS 0x9000
+#define TAG_RE_KEYID 0x65
+
+#define LS_ABORT_SW1 0x69
+#define LS_ABORT_SW2 0x87
+//#define AID_MEM_PATH "/data/vendor/secure_element/AID_MEM.txt"
+//#define LS_STATUS_PATH "/data/vendor/secure_element/LS_Status.txt"
+#define LS_SRC_BACKUP "/data/vendor/secure_element/LS_Src_Backup.txt"
+#define LS_DST_BACKUP "/data/vendor/secure_element/LS_Dst_Backup.txt"
+#define MAX_CERT_LEN (255 + 137)
+
+/*LSC2*/
+
+#define JCOP3_WR
+#define MAX_SIZE 0xFF
+#define PARAM_P1_OFFSET 0x02
+#define FIRST_BLOCK 0x05
+#define LAST_BLOCK 0x84
+#define ONLY_BLOCK 0x85
+#define CLA_BYTE 0x80
+#define JSBL_HEADER_LEN 0x03
+#define LSC_CMD_HDR_LEN 0x02
+
+/* Definations for TAG ID's present in the script file*/
+#define TAG_SELECT_ID 0x6F
+#define TAG_LSC_ID 0x84
+#define TAG_PRO_DATA_ID 0xA5
+#define TAG_JSBL_HDR_ID 0x60
+#define TAG_JSBL_KEY_ID 0x61
+#define TAG_SIGNATURE_ID 0x41
+#define TAG_LSC_CMD_ID 0x40
+#define TAG_JSBL_CER_ID 0x44
+
+/*Definitions for Install for load*/
+#define INSTAL_LOAD_ID 0xE6
+#define LOAD_CMD_ID 0xE8
+#define LOAD_MORE_BLOCKS 0x00
+#define LOAD_LAST_BLOCK 0x80
+
+#define STORE_DATA_CLA 0x80
+#define STORE_DATA_INS 0xE2
+#define STORE_DATA_LEN 32
+#define STORE_DATA_TAG 0x4F
+static const char *AID_MEM_PATH[2] = {"/data/vendor/nfc/AID_MEM.txt",
+                                  "/data/vendor/secure_element/AID_MEM.txt"};
+static const char *LS_STATUS_PATH[2] = {"/data/vendor/nfc/LS_Status.txt",
+                                  "/data/vendor/secure_element/LS_Status.txt"};
+
+/*******************************************************************************
+**
+** Function:        initialize
+**
+** Description:     Initialize all member variables.
+**                  native: Native data.
+**
+** Returns:         True if ok.
+**
+*******************************************************************************/
+bool    initialize (IChannel_t *channel);
+
+/*******************************************************************************
+**
+** Function:        finalize
+**
+** Description:     Release all resources.
+**
+** Returns:         None
+**
+*******************************************************************************/
+void finalize();
+
+/*******************************************************************************
+**
+** Function:        Perform_LSC
+**
+** Description:     Performs the LSC download sequence
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tLSC_STATUS Perform_LSC(const char* path, const char* dest,
+                        const uint8_t* pdata, uint16_t len, uint8_t* respSW);
+
+/*******************************************************************************
+**
+** Function:        LSC_OpenChannel
+**
+** Description:     Creates the logical channel with lsc
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+static tLSC_STATUS LSC_OpenChannel(Lsc_ImageInfo_t* pContext,
+                                   tLSC_STATUS status,
+                                   Lsc_TranscieveInfo_t* pInfo)
+    __attribute__((unused));
+
+/*******************************************************************************
+**
+** Function:        LSC_SelectLsc
+**
+** Description:     Creates the logical channel with lsc
+**                  Channel_id will be used for any communication with Lsc
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+static tLSC_STATUS LSC_SelectLsc(Lsc_ImageInfo_t* pContext, tLSC_STATUS status,
+                                 Lsc_TranscieveInfo_t* pInfo)
+    __attribute__((unused));
+
+/*******************************************************************************
+**
+** Function:        LSC_StoreData
+**
+** Description:     It is used to provide the LSC with an Unique
+**                  Identifier of the Application that has triggered the LSC
+*script.
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+static tLSC_STATUS LSC_StoreData(Lsc_ImageInfo_t* pContext, tLSC_STATUS status,
+                                 Lsc_TranscieveInfo_t* pInfo)
+    __attribute__((unused));
+
+/*******************************************************************************
+**
+** Function:        LSC_loadapplet
+**
+** Description:     Reads the script from the file and sent to Lsc
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+static tLSC_STATUS LSC_loadapplet(Lsc_ImageInfo_t* Os_info, tLSC_STATUS status,
+                                  Lsc_TranscieveInfo_t* pTranscv_Info)
+    __attribute__((unused));
+
+/*******************************************************************************
+**
+** Function:        LSC_update_seq_handler
+**
+** Description:     Performs the LSC update sequence handler sequence
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+static tLSC_STATUS LSC_update_seq_handler(
+    tLSC_STATUS (*seq_handler[])(Lsc_ImageInfo_t* pContext, tLSC_STATUS status,
+                                 Lsc_TranscieveInfo_t* pInfo),
+    const char* name, const char* dest) __attribute__((unused));
+
+/*******************************************************************************
+**
+** Function:        Write_Response_To_OutFile
+**
+** Description:     Write the response to Out file
+**                  with length recvlen from buffer RecvData.
+**
+** Returns:         Success if OK
+**
+*******************************************************************************/
+tLSC_STATUS Write_Response_To_OutFile(Lsc_ImageInfo_t* image_info,
+                                      uint8_t* RecvData, int32_t recvlen,
+                                      Ls_TagType tType);
+
+/*******************************************************************************
+**
+** Function:        Check_Certificate_Tag
+**
+** Description:     Check certificate Tag presence in script
+**                  by 7F21 .
+**
+** Returns:         Success if Tag found
+**
+*******************************************************************************/
+tLSC_STATUS Check_Certificate_Tag(uint8_t* read_buf, uint16_t* offset1);
+
+/*******************************************************************************
+**
+** Function:        Check_SerialNo_Tag
+**
+** Description:     Check Serial number Tag presence in script
+**                  by 0x93 .
+**
+** Returns:         Success if Tag found
+**
+*******************************************************************************/
+tLSC_STATUS Check_SerialNo_Tag(uint8_t* read_buf, uint16_t* offset1);
+
+/*******************************************************************************
+**
+** Function:        Check_LSRootID_Tag
+**
+** Description:     Check LS root ID tag presence in script and compare with
+**                  select response root ID value.
+**
+** Returns:         Success if Tag found
+**
+*******************************************************************************/
+tLSC_STATUS Check_LSRootID_Tag(uint8_t* read_buf, uint16_t* offset1);
+
+/*******************************************************************************
+**
+** Function:        Check_CertHoldID_Tag
+**
+** Description:     Check certificate holder ID tag presence in script.
+**
+** Returns:         Success if Tag found
+**
+*******************************************************************************/
+tLSC_STATUS Check_CertHoldID_Tag(uint8_t* read_buf, uint16_t* offset1);
+
+/*******************************************************************************
+**
+** Function:        Check_Date_Tag
+**
+** Description:     Check date tags presence in script.
+**
+** Returns:         Success if Tag found
+**
+*******************************************************************************/
+tLSC_STATUS Check_Date_Tag(uint8_t* read_buf, uint16_t* offset1);
+
+/*******************************************************************************
+**
+** Function:        Check_45_Tag
+**
+** Description:     Check 45 tags presence in script and compare the value
+**                  with select response tag 45 value
+**
+** Returns:         Success if Tag found
+**
+*******************************************************************************/
+tLSC_STATUS Check_45_Tag(uint8_t* read_buf, uint16_t* offset1,
+                         uint8_t* tag45Len);
+
+/*******************************************************************************
+**
+** Function:        Certificate_Verification
+**
+** Description:     Perform the certificate verification by forwarding it to
+**                  LS applet.
+**
+** Returns:         Success if certificate is verified
+**
+*******************************************************************************/
+tLSC_STATUS Certificate_Verification(Lsc_ImageInfo_t* Os_info,
+                                     Lsc_TranscieveInfo_t* pTranscv_Info,
+                                     uint8_t* read_buf, uint16_t* offset1,
+                                     uint8_t* tag45Len);
+
+/*******************************************************************************
+**
+** Function:        Check_Complete_7F21_Tag
+**
+** Description:     Traverses the 7F21 tag for verification of each sub tag with
+**                  in the 7F21 tag.
+**
+** Returns:         Success if all tags are verified
+**
+*******************************************************************************/
+tLSC_STATUS Check_Complete_7F21_Tag(Lsc_ImageInfo_t* Os_info,
+                                    Lsc_TranscieveInfo_t* pTranscv_Info,
+                                    uint8_t* read_buf, uint16_t* offset);
+
+/*******************************************************************************
+**
+** Function:        LSC_UpdateExeStatus
+**
+** Description:     Updates LSC status to a file
+**
+** Returns:         true if success else false
+**
+*******************************************************************************/
+bool LSC_UpdateExeStatus(uint16_t status);
+
+/*******************************************************************************
+**
+** Function:        Get_LsStatus
+**
+** Description:     Interface to fetch Loader service client status to JNI,
+*Services
+**
+** Returns:         SUCCESS/FAILURE
+**
+*******************************************************************************/
+tLSC_STATUS Get_LsStatus(uint8_t* pVersion);
+
+/*******************************************************************************
+**
+** Function:        LSC_SendtoEse
+**
+** Description:     It is used to send the packet to p61
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tLSC_STATUS LSC_SendtoEse(Lsc_ImageInfo_t* Os_info, tLSC_STATUS status,
+                          Lsc_TranscieveInfo_t* pTranscv_Info);
+
+/*******************************************************************************
+**
+** Function:        LSC_SendtoLsc
+**
+** Description:     It is used to forward the packet to Lsc
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tLSC_STATUS LSC_SendtoLsc(Lsc_ImageInfo_t* Os_info, tLSC_STATUS status,
+                          Lsc_TranscieveInfo_t* pTranscv_Info,
+                          Ls_TagType tType);
+
+/*******************************************************************************
+**
+** Function:        LSC_CloseChannel
+**
+** Description:     Closes the previously opened logical channel
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tLSC_STATUS LSC_CloseChannel(Lsc_ImageInfo_t* Os_info, tLSC_STATUS status,
+                             Lsc_TranscieveInfo_t* pTranscv_Info);
+
+/*******************************************************************************
+**
+** Function:        LSC_ProcessResp
+**
+** Description:     Process the response packet received from Lsc
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tLSC_STATUS LSC_ProcessResp(Lsc_ImageInfo_t* image_info, int32_t recvlen,
+                            Lsc_TranscieveInfo_t* trans_info, Ls_TagType tType);
+
+/*******************************************************************************
+**
+** Function:        LSC_Check_KeyIdentifier
+**
+** Description:     Checks and validates certificate
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tLSC_STATUS LSC_Check_KeyIdentifier(Lsc_ImageInfo_t* Os_info,
+                                    tLSC_STATUS status,
+                                    Lsc_TranscieveInfo_t* pTranscv_Info,
+                                    uint8_t* temp_buf, tLSC_STATUS flag,
+                                    int32_t wNewLen);
+
+/*******************************************************************************
+**
+** Function:        LSC_ReadScript
+**
+** Description:     Reads the current line if the script
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tLSC_STATUS LSC_ReadScript(Lsc_ImageInfo_t* Os_info, uint8_t* read_buf);
+
+/*******************************************************************************
+**
+** Function:        Process_EseResponse
+**
+** Description:     It is used to process the received response packet from ESE
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tLSC_STATUS Process_EseResponse(Lsc_TranscieveInfo_t* pTranscv_Info,
+                                int32_t recv_len, Lsc_ImageInfo_t* Os_info);
+
+/*******************************************************************************
+**
+** Function:        Process_SelectRsp
+**
+** Description:     It is used to process the received response for SELECT LSC
+*cmd
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tLSC_STATUS Process_SelectRsp(uint8_t* Recv_data, int32_t Recv_len);
+
+/*******************************************************************************
+**
+** Function:        Numof_lengthbytes
+**
+** Description:     Checks the number of length bytes and assigns
+**                  length value to wLen.
+**
+** Returns:         Number of Length bytes
+**
+*******************************************************************************/
+uint8_t Numof_lengthbytes(uint8_t* read_buf, int32_t* wLen);
+
+#ifdef JCOP3_WR
+tLSC_STATUS Send_Backall_Loadcmds(Lsc_ImageInfo_t* Os_info, tLSC_STATUS status,
+                                  Lsc_TranscieveInfo_t* pTranscv_Info);
+
+tLSC_STATUS Bufferize_load_cmds(Lsc_ImageInfo_t* Os_info, tLSC_STATUS status,
+                                Lsc_TranscieveInfo_t* pTranscv_Info);
+#endif
+
+inline int FSCANF_BYTE(FILE* stream, const char* format, void* pVal) {
+  int Result = 0;
+
+  if ((NULL != stream) && (NULL != format) && (NULL != pVal)) {
+    unsigned int dwVal;
+    unsigned char* pTmp = (unsigned char*)pVal;
+    Result = fscanf(stream, format, &dwVal);
+
+    (*pTmp) = (unsigned char)(dwVal & 0x000000FF);
+  }
+  return Result;
+}
+
+#endif /*LSC_H*/
diff --git a/ls_client/src/LsClient.cpp b/ls_client/src/LsClient.cpp
new file mode 100644
index 0000000..6792dca
--- /dev/null
+++ b/ls_client/src/LsClient.cpp
@@ -0,0 +1,216 @@
+/******************************************************************************
+ *
+ *  Copyright 2018 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include "LsLib.h"
+#include "LsClient.h"
+#include <cutils/log.h>
+#include <dirent.h>
+#include <stdlib.h>
+#include <pthread.h>
+#include <string.h>
+#include <errno.h>
+
+/*static char gethex(const char *s, char **endptr);
+char *convert(const char *s, int *length);*/
+uint8_t datahex(char c);
+void updateLsAid(uint8_t intfInfo);
+//extern pLsc_Dwnld_Context_t gpLsc_Dwnld_Context;
+//static android::sp<ISecureElementHalCallback> cCallback;
+/*******************************************************************************
+**
+** Function:        LSC_Start
+**
+** Description:     Starts the LSC update over DWP
+**
+** Returns:         SUCCESS if ok.
+**
+*******************************************************************************/
+tLSC_STATUS LSC_Start(const char* name, const char* dest, uint8_t* pdata,
+                      uint16_t len, uint8_t* respSW) {
+  static const char fn[] = "LSC_Start";
+  tLSC_STATUS status = STATUS_FAILED;
+  if (name != NULL) {
+    ALOGE("%s: name is %s", fn, name);
+    ALOGE("%s: Dest is %s", fn, dest);
+    status = Perform_LSC(name, dest, pdata, len, respSW);
+  } else {
+    ALOGE("Invalid parameter");
+  }
+  ALOGE("%s: Exit; status=0x0%X", fn, status);
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function:        performLSDownload
+**
+** Description:     Perform LS during hal init
+**
+** Returns:         SUCCESS of ok
+**
+*******************************************************************************/
+tLSC_STATUS performLSDownload(IChannel_t* data) {
+  tLSC_STATUS status = STATUS_FAILED;
+
+  const char* lsUpdateBackupPath =
+      "/vendor/etc/loaderservice_updater.txt";
+  const char* lsUpdateBackupOutPath[2] =
+  {"/data/vendor/nfc/loaderservice_updater_out.txt",
+   "/data/vendor/secure_element/loaderservice_updater_out.txt",};
+  IChannel_t* mchannel = (IChannel_t*)data;
+
+  /*generated SHA-1 string for secureElementLS
+  This will remain constant as handled in secureElement HAL*/
+  char sha1[] = "6d583e84f2710e6b0f06beebc1a12a1083591373";
+  uint8_t hash[20] = {};
+
+  for (int i = 0; i < 40; i = i + 2) {
+    hash[i / 2] =
+        (((datahex(sha1[i]) & 0x0F) << 4) | (datahex(sha1[i + 1]) & 0x0F));
+  }
+  /*Check and update if any new LS AID is available*/
+  updateLsAid(mchannel->getInterfaceInfo());
+
+  if(!initialize ((IChannel_t*) data))
+    return status;
+
+
+  uint8_t resSW[4] = {0x4e, 0x02, 0x69, 0x87};
+  FILE* fIn, *fOut;
+  if ((fIn = fopen(lsUpdateBackupPath, "rb")) == NULL) {
+    ALOGE("%s Cannot open file %s\n", __func__, lsUpdateBackupPath);
+    ALOGE("%s Error : %s", __func__, strerror(errno));
+    return status;
+  } else {
+    ALOGD("%s File opened %s\n", __func__, lsUpdateBackupPath);
+    fseek(fIn, 0, SEEK_END);
+    long fsize = ftell(fIn);
+    rewind(fIn);
+
+    char* lsUpdateBuf = (char*)malloc(fsize + 1);
+    fread(lsUpdateBuf, fsize, 1, fIn);
+    fclose(fIn);
+
+    if ((fOut = fopen(lsUpdateBackupOutPath[mchannel->getInterfaceInfo()], "wb")) == NULL) {
+      ALOGE("%s Failed to open file %s\n", __func__,
+        lsUpdateBackupOutPath[mchannel->getInterfaceInfo()]);
+    } else {
+      ALOGD("%s File opened %s\n", __func__,
+        lsUpdateBackupOutPath[mchannel->getInterfaceInfo()]);
+
+      if ((long)fwrite(lsUpdateBuf, 1, fsize, fOut) != fsize) {
+        ALOGE("%s ERROR - Failed to write %ld bytes to file\n", __func__, fsize);
+      }
+
+      fclose(fOut);
+    }
+
+    status = LSC_Start(lsUpdateBackupPath, lsUpdateBackupOutPath[mchannel->getInterfaceInfo()],
+                       (uint8_t*)hash, (uint16_t)sizeof(hash), resSW);
+    resSW[0]=0x4e;
+    ALOGD("%s LSC_Start completed\n", __func__);
+    if (status == STATUS_SUCCESS) {
+      if (remove(lsUpdateBackupPath) == 0) {
+        ALOGD("%s  : %s file deleted successfully\n", __func__,
+              lsUpdateBackupPath);
+      } else {
+        ALOGD("%s  : %s file deletion failed!!!\n", __func__,
+              lsUpdateBackupPath);
+      }
+    }
+    free(lsUpdateBuf);
+  }
+  ALOGD("%s pthread_exit\n", __func__);
+
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function:        datahex
+**
+** Description:     Converts char to uint8_t
+**
+** Returns:         uint8_t variable
+**
+*******************************************************************************/
+uint8_t datahex(char c) {
+  uint8_t value = 0;
+  if (c >= '0' && c <= '9')
+    value = (c - '0');
+  else if (c >= 'A' && c <= 'F')
+    value = (10 + (c - 'A'));
+  else if (c >= 'a' && c <= 'f')
+    value = (10 + (c - 'a'));
+  return value;
+}
+
+/*******************************************************************************
+**
+** Function:        updateLsAid
+**
+** Description:     Store AID in LS_SELF_UPDATE_AID_IDX of ArrayOfAIDs if new LS
+**                  AID is available after LS Self Update
+**
+** Returns:         None
+**
+*******************************************************************************/
+void updateLsAid(uint8_t intfInfo) {
+  ALOGD_IF( "%s Enter\n", __func__);
+
+  FILE* fAID_MEM = NULL;
+  fAID_MEM = fopen(AID_MEM_PATH[intfInfo], "r");
+
+  if (fAID_MEM == NULL) {
+    ALOGE("%s: AID data file does not exists", __func__);
+    return;
+  }
+
+  uint8_t aidLen = 0x00;
+  int32_t wStatus = 0;
+
+  while (!(feof(fAID_MEM))) {
+    wStatus = FSCANF_BYTE(fAID_MEM, "%2x",
+                          &ArrayOfAIDs[LS_SELF_UPDATE_AID_IDX][aidLen++]);
+    if (wStatus == 0) {
+      ALOGE("%s: exit: Error during read AID data", __func__);
+      ArrayOfAIDs[LS_SELF_UPDATE_AID_IDX][0] = 0x00;
+      break;
+    }
+  }
+  if ((wStatus > 0x00) && (aidLen > 0x00)) {
+    ArrayOfAIDs[LS_SELF_UPDATE_AID_IDX][0] = aidLen - 1;
+  }
+  fclose(fAID_MEM);
+}
+
+void* phLS_memset(void* buff, int val, size_t len) {
+  return memset(buff, val, len);
+}
+
+void* phLS_memcpy(void* dest, const void* src, size_t len) {
+  return memcpy(dest, src, len);
+}
+
+void* phLS_memalloc(uint32_t size) { return malloc(size); }
+
+void phLS_free(void* ptr) { return free(ptr); }
+
+void* phLS_calloc(size_t datatype, size_t size) {
+  return calloc(datatype, size);
+}
diff --git a/ls_client/src/LsLib.cpp b/ls_client/src/LsLib.cpp
new file mode 100644
index 0000000..592bea0
--- /dev/null
+++ b/ls_client/src/LsLib.cpp
@@ -0,0 +1,2137 @@
+/*******************************************************************************
+ *
+ *  Copyright 2018 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include <cutils/log.h>
+#include <LsLib.h>
+#include <LsClient.h>
+#include <errno.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+pLsc_Dwnld_Context_t gpLsc_Dwnld_Context = NULL;
+static int32_t gTransceiveTimeout = 120000;
+#ifdef JCOP3_WR
+uint8_t Cmd_Buffer[64 * 1024];
+static int32_t cmd_count = 0;
+bool islastcmdLoad;
+bool SendBack_cmds = false;
+uint8_t* pBuffer;
+#endif
+bool mIsInit;
+uint8_t Select_Rsp[1024];
+uint8_t Jsbl_RefKey[256];
+uint8_t Jsbl_keylen;
+uint8_t StoreData[22];
+int Select_Rsp_Len;
+uint8_t lsVersionArr[2];
+uint8_t tag42Arr[17];
+uint8_t tag45Arr[9];
+uint8_t lsExecuteResp[4];
+uint8_t AID_ARRAY[22];
+int32_t resp_len = 0;
+FILE* fAID_MEM = NULL;
+FILE* fLS_STATUS = NULL;
+uint8_t lsGetStatusArr[2];
+phNxpLs_data cmdApdu;
+phNxpLs_data rspApdu;
+static tLSC_STATUS LSC_Transceive(phNxpLs_data* pCmd, phNxpLs_data* pRsp);
+tLSC_STATUS (*Applet_load_seqhandler[])(Lsc_ImageInfo_t* pContext,
+                                        tLSC_STATUS status,
+                                        Lsc_TranscieveInfo_t* pInfo) = {
+    LSC_OpenChannel, LSC_SelectLsc, LSC_StoreData, LSC_loadapplet, NULL};
+
+/*******************************************************************************
+**
+** Function:        initialize
+**
+** Description:     Initialize all member variables.
+**                  native: Native data.
+**
+** Returns:         True if ok.
+**
+*******************************************************************************/
+bool initialize (IChannel_t* channel)
+{
+    static const char fn [] = "Ala_initialize";
+
+    ALOGD ("%s: enter", fn);
+
+    gpLsc_Dwnld_Context = (pLsc_Dwnld_Context_t)malloc(sizeof(Lsc_Dwnld_Context_t));
+    if(gpLsc_Dwnld_Context != NULL)
+    {
+        memset((void *)gpLsc_Dwnld_Context, 0, (uint32_t)sizeof(Lsc_Dwnld_Context_t));
+    }
+    else
+    {
+        ALOGD("%s: Memory allocation failed", fn);
+        return (false);
+    }
+    gpLsc_Dwnld_Context->mchannel = channel;
+    if((channel != NULL) &&
+       (channel->open) != NULL)
+    {
+      if(channel->open() == STATUS_FAILED)
+      {
+        ALOGD ("%s: exit : channle open failed", fn);
+        return false;
+      }
+    }
+    else
+    {
+      ALOGD ("%s: exit : channel null", fn);
+      return false;
+    }
+    mIsInit = true;
+    ALOGD ("%s: exit : success", fn);
+    return (true);
+}
+
+/*******************************************************************************
+**
+** Function:        finalize
+**
+** Description:     Release all resources.
+**
+** Returns:         None
+**
+*******************************************************************************/
+void finalize() {
+  static const char fn[] = "Lsc_finalize";
+  ALOGD("%s: enter", fn);
+  mIsInit = false;
+  if (gpLsc_Dwnld_Context != NULL) {
+    free(gpLsc_Dwnld_Context);
+    gpLsc_Dwnld_Context = NULL;
+  }
+  ALOGD("%s: exit", fn);
+}
+
+/*******************************************************************************
+**
+** Function:        Perform_LSC
+**
+** Description:     Performs the LSC download sequence
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tLSC_STATUS Perform_LSC(const char* name, const char* dest,
+                        const uint8_t* pdata, uint16_t len, uint8_t* respSW) {
+  static const char fn[] = "Perform_LSC";
+  tLSC_STATUS status = STATUS_FAILED;
+  ALOGD("%s: enter; sha-len=%d", fn, len);
+  //mIsInit = true; Changed here HARI
+  if (mIsInit == false) {
+    ALOGD("%s: LSC lib is not initialized", fn);
+    status = STATUS_FAILED;
+  } else if ((pdata == NULL) || (len == 0x00)) {
+    ALOGD("%s: Invalid SHA-data", fn);
+  } else {
+    StoreData[0] = STORE_DATA_TAG;
+    StoreData[1] = len;
+    memcpy(&StoreData[2], pdata, len);
+    status = LSC_update_seq_handler(Applet_load_seqhandler, name, dest);
+    if ((status != STATUS_OK) && (lsExecuteResp[2] == 0x90) &&
+        (lsExecuteResp[3] == 0x00)) {
+      lsExecuteResp[2] = LS_ABORT_SW1;
+      lsExecuteResp[3] = LS_ABORT_SW2;
+    }
+    memcpy(&respSW[0], &lsExecuteResp[0], 4);
+    ALOGD("%s: lsExecuteScript Response SW=%2x%2x", fn, lsExecuteResp[2],
+          lsExecuteResp[3]);
+  }
+
+  ALOGD("%s: exit; status=0x0%x", fn, status);
+  return status;
+}
+/*******************************************************************************
+**
+** Function:        LSC_update_seq_handler
+**
+** Description:     Performs the LSC update sequence handler sequence
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tLSC_STATUS LSC_update_seq_handler(
+    tLSC_STATUS (*seq_handler[])(Lsc_ImageInfo_t* pContext, tLSC_STATUS status,
+                                 Lsc_TranscieveInfo_t* pInfo),
+    const char* name, const char* dest) {
+  static const char fn[] = "LSC_update_seq_handler";
+  uint16_t seq_counter = 0;
+  Lsc_ImageInfo_t update_info =
+      (Lsc_ImageInfo_t)gpLsc_Dwnld_Context->Image_info;
+  Lsc_TranscieveInfo_t trans_info =
+      (Lsc_TranscieveInfo_t)gpLsc_Dwnld_Context->Transcv_Info;
+  tLSC_STATUS status = STATUS_FAILED;
+  ALOGD("%s: enter", fn);
+
+  if (dest != NULL) {
+    strcat(update_info.fls_RespPath, dest);
+    ALOGD("Loader Service response data path/destination: %s", dest);
+    update_info.bytes_wrote = 0xAA;
+  } else {
+    update_info.bytes_wrote = 0x55;
+  }
+  if ((LSC_UpdateExeStatus(LS_DEFAULT_STATUS)) != true) {
+    return false;
+  }
+  // memcpy(update_info.fls_path, (char*)Lsc_path, sizeof(Lsc_path));
+  strcat(update_info.fls_path, name);
+  ALOGD("Selected applet to install is: %s", update_info.fls_path);
+
+  while ((seq_handler[seq_counter]) != NULL) {
+    status = STATUS_FAILED;
+    status = (*(seq_handler[seq_counter]))(&update_info, status, &trans_info);
+    if (STATUS_SUCCESS != status) {
+      ALOGE("%s: exiting; status=0x0%X", fn, status);
+      break;
+    }
+    seq_counter++;
+  }
+
+  LSC_CloseChannel(&update_info, STATUS_FAILED, &trans_info);
+  ALOGE("%s: exit; status=0x%x", fn, status);
+  return status;
+}
+/*******************************************************************************
+**
+** Function:        LSC_OpenChannel
+**
+** Description:     Creates the logical channel with lsc
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tLSC_STATUS LSC_OpenChannel(Lsc_ImageInfo_t* Os_info, tLSC_STATUS status,
+                            Lsc_TranscieveInfo_t* pTranscv_Info) {
+  static const char fn[] = "LSC_OpenChannel";
+  tLSC_STATUS transStat = STATUS_FAILED;
+  phNxpLs_data cmdApdu;
+  phNxpLs_data rspApdu;
+  Os_info->channel_cnt = 0x00;
+  ALOGD("%s: enter", fn);
+  if (Os_info == NULL || pTranscv_Info == NULL) {
+    ALOGD("%s: Invalid parameter", fn);
+  } else {
+    phLS_memset(&cmdApdu, 0x00, sizeof(phNxpLs_data));
+    phLS_memset(&rspApdu, 0x00, sizeof(phNxpLs_data));
+
+    cmdApdu.len = (int32_t)sizeof(OpenChannel);
+    cmdApdu.p_data = (uint8_t*)phLS_memalloc(cmdApdu.len * sizeof(uint8_t));
+    memcpy(cmdApdu.p_data, OpenChannel, cmdApdu.len);
+
+    ALOGD("%s: Calling Secure Element Transceive", fn);
+    transStat = LSC_Transceive(&cmdApdu, &rspApdu);
+
+    if (transStat != STATUS_SUCCESS && (rspApdu.len < 0x03)) {
+      if (rspApdu.len == 0x02)
+        memcpy(&lsExecuteResp[2], &rspApdu.p_data[rspApdu.len - 2], 2);
+      status = STATUS_FAILED;
+      ALOGE("%s: SE transceive failed status = 0x%X", fn, status);
+    } else if (((rspApdu.p_data[rspApdu.len - 2] != 0x90) &&
+                (rspApdu.p_data[rspApdu.len - 1] != 0x00))) {
+      memcpy(&lsExecuteResp[2], &rspApdu.p_data[rspApdu.len - 2], 2);
+      status = STATUS_FAILED;
+      ALOGE("%s: invalid response = 0x%X", fn, status);
+    } else {
+      uint8_t cnt = Os_info->channel_cnt;
+      Os_info->Channel_Info[cnt].channel_id = rspApdu.p_data[rspApdu.len - 3];
+      Os_info->Channel_Info[cnt].isOpend = true;
+      Os_info->channel_cnt++;
+      status = STATUS_OK;
+    }
+    phLS_free(cmdApdu.p_data);
+  }
+
+  ALOGE("%s: exit; status=0x%x", fn, status);
+  return status;
+}
+/*******************************************************************************
+**
+** Function:        LSC_SelectLsc
+**
+** Description:     Creates the logical channel with lsc
+**                  Channel_id will be used for any communication with Lsc
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tLSC_STATUS LSC_SelectLsc(Lsc_ImageInfo_t* Os_info, tLSC_STATUS status,
+                          Lsc_TranscieveInfo_t* pTranscv_Info) {
+  static const char fn[] = "LSC_SelectLsc";
+  tLSC_STATUS transStat = STATUS_FAILED;
+  phNxpLs_data cmdApdu;
+  phNxpLs_data rspApdu;
+  unsigned long semsPresent = 1;
+
+  if (Os_info == NULL || pTranscv_Info == NULL) {
+    ALOGD("%s: Invalid parameter", fn);
+  } else {
+    phLS_memset(&cmdApdu, 0x00, sizeof(phNxpLs_data));
+    phLS_memset(&rspApdu, 0x00, sizeof(phNxpLs_data));
+
+  GetNxpNumValue(NAME_NXP_SEMS_SUPPORTED, &semsPresent, sizeof(semsPresent));
+
+  if(semsPresent)
+  {
+    cmdApdu.len = (int32_t)(sizeof(SelectSEMS) + 1);
+    cmdApdu.p_data = (uint8_t*)phLS_memalloc(cmdApdu.len * sizeof(uint8_t));
+    cmdApdu.p_data[0] = Os_info->Channel_Info[0].channel_id;
+    memcpy(&(cmdApdu.p_data[1]), SelectSEMS, sizeof(SelectSEMS));
+  }
+  else
+  {
+    /*p_data will have channel_id (1 byte) + SelectLsc APDU*/
+    cmdApdu.len = (int32_t)(sizeof(SelectLsc) + 1);
+    cmdApdu.p_data = (uint8_t*)phLS_memalloc(cmdApdu.len * sizeof(uint8_t));
+    cmdApdu.p_data[0] = Os_info->Channel_Info[0].channel_id;
+    memcpy(&(cmdApdu.p_data[1]), SelectLsc, sizeof(SelectLsc));
+  }
+  ALOGD("%s: Calling Secure Element Transceive with Loader service AID", fn);
+
+  transStat = LSC_Transceive(&cmdApdu, &rspApdu);
+
+  if (transStat != STATUS_SUCCESS && (rspApdu.len == 0x00)) {
+    status = STATUS_FAILED;
+    ALOGE("%s: SE transceive failed status = 0x%X", fn, status);
+  } else if (((rspApdu.p_data[rspApdu.len - 2] == 0x90) &&
+                  (rspApdu.p_data[rspApdu.len - 1] == 0x00))) {
+    status = Process_SelectRsp(rspApdu.p_data, (rspApdu.len - 2));
+    if (status != STATUS_OK) {
+      ALOGE("%s: Select Lsc Rsp doesnt have a valid key; status = 0x%X", fn,
+        status);
+    }
+    } else if (((rspApdu.p_data[rspApdu.len - 2] != 0x90))) {
+    /*Copy the response SW in failure case*/
+    memcpy(&lsExecuteResp[2], &(rspApdu.p_data[rspApdu.len - 2]), 2);
+    }
+    else {
+    status = STATUS_FAILED;
+    }
+    if(status == STATUS_FAILED && semsPresent)
+    {
+      phLS_free(cmdApdu.p_data);
+      cmdApdu.len = (int32_t)(sizeof(SelectSEMSUpdater) + 1);
+      cmdApdu.p_data = (uint8_t*)phLS_memalloc(cmdApdu.len * sizeof(uint8_t));
+      cmdApdu.p_data[0] = Os_info->Channel_Info[0].channel_id;
+      memcpy(&(cmdApdu.p_data[1]), SelectSEMSUpdater, sizeof(SelectSEMSUpdater));
+      transStat = LSC_Transceive(&cmdApdu, &rspApdu);
+
+      if (transStat != STATUS_SUCCESS && (rspApdu.len == 0x00)) {
+        status = STATUS_FAILED;
+        ALOGE("%s: SE transceive failed status = 0x%X", fn, status);
+      } else if (((rspApdu.p_data[rspApdu.len - 2] == 0x90) &&
+                      (rspApdu.p_data[rspApdu.len - 1] == 0x00))) {
+        status = Process_SelectRsp(rspApdu.p_data, (rspApdu.len - 2));
+        if (status != STATUS_OK) {
+          ALOGE("%s: Select Lsc Rsp doesnt have a valid key; status = 0x%X", fn,
+            status);
+          }
+        } else if (((rspApdu.p_data[rspApdu.len - 2] != 0x90))) {
+          /*Copy the response SW in failure case*/
+          memcpy(&lsExecuteResp[2], &(rspApdu.p_data[rspApdu.len - 2]), 2);
+        }
+        else {
+        status = STATUS_FAILED;
+      }
+    }
+    phLS_free(cmdApdu.p_data);
+  }
+  ALOGE("%s: exit; status=0x%x", fn, status);
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function:        LSC_StoreData
+**
+** Description:     It is used to provide the LSC with an Unique
+**                  Identifier of the Application that has triggered the LSC
+*script.
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tLSC_STATUS LSC_StoreData(Lsc_ImageInfo_t* Os_info, tLSC_STATUS status,
+                          Lsc_TranscieveInfo_t* pTranscv_Info) {
+  static const char fn[] = "LSC_StoreData";
+  tLSC_STATUS transStat = STATUS_FAILED;
+  phNxpLs_data cmdApdu;
+  phNxpLs_data rspApdu;
+  int32_t xx = 0, len = 0;
+  ALOGD("%s: enter", fn);
+  if (Os_info == NULL || pTranscv_Info == NULL) {
+    ALOGD("%s: Invalid parameter", fn);
+  } else {
+    phLS_memset(&cmdApdu, 0x00, sizeof(phNxpLs_data));
+    phLS_memset(&rspApdu, 0x00, sizeof(phNxpLs_data));
+    cmdApdu.len = (int32_t)(5 + sizeof(StoreData));
+    cmdApdu.p_data = (uint8_t*)phLS_memalloc(cmdApdu.len * sizeof(uint8_t));
+
+    len = StoreData[1] + 2;  //+2 offset is for tag value and length byte
+    cmdApdu.p_data[xx++] =
+        STORE_DATA_CLA | (Os_info->Channel_Info[0].channel_id);
+    cmdApdu.p_data[xx++] = STORE_DATA_INS;
+    cmdApdu.p_data[xx++] = 0x00;  // P1
+    cmdApdu.p_data[xx++] = 0x00;  // P2
+    cmdApdu.p_data[xx++] = len;
+    memcpy(&(cmdApdu.p_data[xx]), StoreData, len);
+
+    ALOGD("%s: Calling Secure Element Transceive", fn);
+    transStat = LSC_Transceive(&cmdApdu, &rspApdu);
+
+    if ((transStat != STATUS_SUCCESS) && (rspApdu.len == 0x00)) {
+      status = STATUS_FAILED;
+      ALOGE("%s: SE transceive failed status = 0x%X", fn, status);
+    } else if ((rspApdu.p_data[rspApdu.len - 2] == 0x90) &&
+               (rspApdu.p_data[rspApdu.len - 1] == 0x00)) {
+      ALOGE("STORE CMD is successful");
+      status = STATUS_SUCCESS;
+    } else {
+      /*Copy the response SW in failure case*/
+      memcpy(&lsExecuteResp[2], &(rspApdu.p_data[rspApdu.len - 2]), 2);
+      status = STATUS_FAILED;
+    }
+  }
+  phLS_free(cmdApdu.p_data);
+  ALOGE("%s: exit; status=0x%x", fn, status);
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function:        LSC_loadapplet
+**
+** Description:     Reads the script from the file and sent to Lsc
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tLSC_STATUS LSC_loadapplet(Lsc_ImageInfo_t* Os_info, tLSC_STATUS status,
+                           Lsc_TranscieveInfo_t* pTranscv_Info) {
+  static const char fn[] = "LSC_loadapplet";
+  int wResult;
+  int32_t wLen = 0;
+  uint8_t temp_buf[1024];
+  uint8_t len_byte = 0, offset = 0;
+  Os_info->bytes_read = 0;
+  bool reachEOFCheck = false;
+  tLSC_STATUS tag40_found = STATUS_FAILED;
+  if (Os_info->bytes_wrote == 0xAA) {
+    Os_info->fResp = fopen(Os_info->fls_RespPath, "a+");
+    if (Os_info->fResp == NULL) {
+      ALOGE("Error opening response recording file <%s> for reading: %s",
+            Os_info->fls_RespPath, strerror(errno));
+      return status;
+    }
+    ALOGD("%s: Response OUT FILE path is successfully created", fn);
+  } else {
+    ALOGD("%s: Response Out file is optional as per input", fn);
+  }
+  ALOGD("%s: enter", fn);
+  if (Os_info == NULL || pTranscv_Info == NULL) {
+    ALOGE("%s: invalid parameter", fn);
+    return status;
+  }
+  Os_info->fp = fopen(Os_info->fls_path, "r");
+
+  if (Os_info->fp == NULL) {
+    ALOGE("Error opening OS image file <%s> for reading: %s", Os_info->fls_path,
+          strerror(errno));
+    return status;
+  }
+  wResult = fseek(Os_info->fp, 0L, SEEK_END);
+  if (wResult) {
+    ALOGE("Error seeking end OS image file %s", strerror(errno));
+    goto exit;
+  }
+  Os_info->fls_size = ftell(Os_info->fp);
+  ALOGE("fls_size=%d", Os_info->fls_size);
+  if (Os_info->fls_size < 0) {
+    ALOGE("Error ftelling file %s", strerror(errno));
+    goto exit;
+  }
+  wResult = fseek(Os_info->fp, 0L, SEEK_SET);
+  if (wResult) {
+    ALOGE("Error seeking start image file %s", strerror(errno));
+    goto exit;
+  }
+  status = LSC_Check_KeyIdentifier(Os_info, status, pTranscv_Info, NULL,
+                                   STATUS_FAILED, 0);
+  if (status != STATUS_OK) {
+    goto exit;
+  }
+  while (!feof(Os_info->fp) && (Os_info->bytes_read < Os_info->fls_size)) {
+    len_byte = 0x00;
+    offset = 0;
+    /*Check if the certificate/ is verified or not*/
+    if (status != STATUS_OK) {
+      goto exit;
+    }
+    memset(temp_buf, 0, sizeof(temp_buf));
+    ALOGE("%s; Start of line processing", fn);
+    status = LSC_ReadScript(Os_info, temp_buf);
+    if (status != STATUS_OK) {
+      goto exit;
+    } else if (status == STATUS_OK) {
+      /*Reset the flag in case further commands exists*/
+      reachEOFCheck = false;
+    }
+    if (temp_buf[offset] == TAG_LSC_CMD_ID) {
+      /*
+       * start sending the packet to Lsc
+       * */
+      offset = offset + 1;
+      len_byte = Numof_lengthbytes(&temp_buf[offset], &wLen);
+      /*If the len data not present or
+       * len is less than or equal to 32*/
+      if ((len_byte == 0) || (wLen <= 32))
+
+      {
+        ALOGE("Invalid length zero");
+        goto exit;
+      } else {
+        tag40_found = STATUS_OK;
+        offset = offset + len_byte;
+        pTranscv_Info->sSendlength = wLen;
+        memcpy(pTranscv_Info->sSendData, &temp_buf[offset], wLen);
+      }
+      status = LSC_SendtoLsc(Os_info, status, pTranscv_Info, LS_Comm);
+      if (status != STATUS_OK) {
+        /*When the switching of LS 6320 case*/
+        if (status == STATUS_FILE_NOT_FOUND) {
+          /*When 6320 occurs close the existing channels*/
+          LSC_CloseChannel(Os_info, status, pTranscv_Info);
+
+          status = STATUS_FAILED;
+          status = LSC_OpenChannel(Os_info, status, pTranscv_Info);
+          if (status == STATUS_OK) {
+            ALOGD("SUCCESS:Post Switching LS open channel");
+            status = STATUS_FAILED;
+            status = LSC_SelectLsc(Os_info, status, pTranscv_Info);
+            if (status == STATUS_OK) {
+              ALOGD("SUCCESS:Post Switching LS select");
+              status = STATUS_FAILED;
+              status = LSC_StoreData(Os_info, status, pTranscv_Info);
+              if (status == STATUS_OK) {
+                /*Enable certificate and signature verification*/
+                tag40_found = STATUS_OK;
+                lsExecuteResp[2] = 0x90;
+                lsExecuteResp[3] = 0x00;
+                reachEOFCheck = true;
+                continue;
+              }
+              ALOGE("Post Switching LS store data failure");
+            }
+            ALOGE("Post Switching LS select failure");
+          }
+          ALOGE("Post Switching LS failure");
+        }
+        ALOGE("Sending packet to lsc failed");
+        goto exit;
+      }
+    } else if ((temp_buf[offset] == (0x7F)) &&
+               (temp_buf[offset + 1] == (0x21))) {
+      ALOGD("TAGID: Encountered again certificate tag 7F21");
+      if (tag40_found == STATUS_OK) {
+        ALOGD("2nd Script processing starts with reselect");
+        status = STATUS_FAILED;
+        status = LSC_SelectLsc(Os_info, status, pTranscv_Info);
+        if (status == STATUS_OK) {
+          ALOGD("2nd Script select success next store data command");
+          status = STATUS_FAILED;
+          status = LSC_StoreData(Os_info, status, pTranscv_Info);
+          if (status == STATUS_OK) {
+            ALOGD(
+                "2nd Script store data success next certificate verification");
+            offset = offset + 2;
+            len_byte = Numof_lengthbytes(&temp_buf[offset], &wLen);
+            status = LSC_Check_KeyIdentifier(Os_info, status, pTranscv_Info,
+                                             temp_buf, STATUS_OK,
+                                             wLen + len_byte + 2);
+          }
+        }
+        /*If the certificate and signature is verified*/
+        if (status == STATUS_OK) {
+          /*If the certificate is verified for 6320 then new
+           * script starts*/
+          tag40_found = STATUS_FAILED;
+        }
+        /*If the certificate or signature verification failed*/
+        else {
+          goto exit;
+        }
+      }
+      /*Already certificate&Sginature verified previously skip 7f21& tag 60*/
+      else {
+        memset(temp_buf, 0, sizeof(temp_buf));
+        status = LSC_ReadScript(Os_info, temp_buf);
+        if (status != STATUS_OK) {
+          ALOGE("%s; Next Tag has to TAG 60 not found", fn);
+          goto exit;
+        }
+        if (temp_buf[offset] == TAG_JSBL_HDR_ID)
+          continue;
+        else
+          goto exit;
+      }
+    } else {
+      /*
+       * Invalid packet received in between stop processing packet
+       * return failed status
+       * */
+      status = STATUS_FAILED;
+      break;
+    }
+  }
+  if (Os_info->bytes_wrote == 0xAA) {
+    fclose(Os_info->fResp);
+  }
+  LSC_UpdateExeStatus(LS_SUCCESS_STATUS);
+  wResult = fclose(Os_info->fp);
+  ALOGE("%s exit;End of Load Applet; status=0x%x", fn, status);
+  return status;
+exit:
+  wResult = fclose(Os_info->fp);
+  if (Os_info->bytes_wrote == 0xAA) {
+    fclose(Os_info->fResp);
+  }
+  /*Script ends with SW 6320 and reached END OF FILE*/
+  if (reachEOFCheck == true) {
+    status = STATUS_OK;
+    LSC_UpdateExeStatus(LS_SUCCESS_STATUS);
+  }
+  ALOGE("%s close fp and exit; status= 0x%X", fn, status);
+  return status;
+}
+/*******************************************************************************
+**
+** Function:        LSC_Check_KeyIdentifier
+**
+** Description:     Checks and validates certificate
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tLSC_STATUS LSC_Check_KeyIdentifier(Lsc_ImageInfo_t* Os_info,
+                                    tLSC_STATUS status,
+                                    Lsc_TranscieveInfo_t* pTranscv_Info,
+                                    uint8_t* temp_buf, tLSC_STATUS flag,
+                                    int32_t wNewLen) {
+  static const char fn[] = "LSC_Check_KeyIdentifier";
+  uint16_t offset = 0x00, len_byte = 0;
+  status = STATUS_FAILED;
+  uint8_t read_buf[1024];
+  int32_t wLen;
+  uint8_t certf_found = STATUS_FAILED;
+  uint8_t sign_found = STATUS_FAILED;
+  ALOGD("%s: enter", fn);
+
+  while (!feof(Os_info->fp) && (Os_info->bytes_read < Os_info->fls_size)) {
+    offset = 0x00;
+    wLen = 0;
+    if (flag == STATUS_OK) {
+      /*If the 7F21 TAG is already read: After TAG 40*/
+      memcpy(read_buf, temp_buf, wNewLen);
+      status = STATUS_OK;
+      flag = STATUS_FAILED;
+    } else {
+      /*If the 7F21 TAG is not read: Before TAG 40*/
+      status = LSC_ReadScript(Os_info, read_buf);
+    }
+    if (status != STATUS_OK) return status;
+    if (STATUS_OK ==
+        Check_Complete_7F21_Tag(Os_info, pTranscv_Info, read_buf, &offset)) {
+      ALOGD("%s: Certificate is verified", fn);
+      certf_found = STATUS_OK;
+      break;
+    }
+    /*The Loader Service Client ignores all subsequent commands starting by tag
+     * 7F21 or tag 60 until the first command starting by tag 40 is
+     * found*/
+    else if (((read_buf[offset] == TAG_LSC_CMD_ID) &&
+              (certf_found != STATUS_OK))) {
+      ALOGE("%s: NOT FOUND Root entity identifier's certificate", fn);
+      status = STATUS_FAILED;
+      return status;
+    }
+  }
+  memset(read_buf, 0, sizeof(read_buf));
+  if (certf_found == STATUS_OK) {
+    offset = 0x00;
+    wLen = 0;
+    status = LSC_ReadScript(Os_info, read_buf);
+    if (status != STATUS_OK)
+      return status;
+    else
+      status = STATUS_FAILED;
+
+    if ((read_buf[offset] == TAG_JSBL_HDR_ID) &&
+        (certf_found != STATUS_FAILED) && (sign_found != STATUS_OK))
+
+    {
+      // TODO check the SElect cmd response and return status accordingly
+      ALOGD("TAGID: TAG_JSBL_HDR_ID");
+      offset = offset + 1;
+      len_byte = Numof_lengthbytes(&read_buf[offset], &wLen);
+      offset = offset + len_byte;
+      if (read_buf[offset] == TAG_SIGNATURE_ID) {
+        offset = offset + 1;
+        len_byte = Numof_lengthbytes(&read_buf[offset], &wLen);
+        offset = offset + len_byte;
+        ALOGE("TAGID: TAG_SIGNATURE_ID");
+
+        pTranscv_Info->sSendlength = wLen + 5;
+
+        pTranscv_Info->sSendData[0] = 0x00;
+        pTranscv_Info->sSendData[1] = 0xA0;
+        pTranscv_Info->sSendData[2] = 0x00;
+        pTranscv_Info->sSendData[3] = 0x00;
+        pTranscv_Info->sSendData[4] = wLen;
+
+        memcpy(&(pTranscv_Info->sSendData[5]), &read_buf[offset], wLen);
+        ALOGE("%s: start transceive for length %ld", fn,
+              (long)pTranscv_Info->sSendlength);
+        status = LSC_SendtoLsc(Os_info, status, pTranscv_Info, LS_Sign);
+        if (status != STATUS_OK) {
+          return status;
+        } else {
+          sign_found = STATUS_OK;
+        }
+      }
+    } else if (read_buf[offset] != TAG_JSBL_HDR_ID) {
+      status = STATUS_FAILED;
+    }
+  } else {
+    ALOGE("%s : Exit certificate verification failed", fn);
+  }
+
+  ALOGD("%s: exit: status=0x%x", fn, status);
+  return status;
+}
+/*******************************************************************************
+**
+** Function:        LSC_ReadScript
+**
+** Description:     Reads the current line if the script
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tLSC_STATUS LSC_ReadScript(Lsc_ImageInfo_t* Os_info, uint8_t* read_buf) {
+  static const char fn[] = "LSC_ReadScript";
+  int32_t wCount, wLen, wIndex = 0;
+  uint8_t len_byte = 0;
+  int wResult = 0;
+  tLSC_STATUS status = STATUS_FAILED;
+  int32_t lenOff = 1;
+  bool isMetaDatapresent = false;
+
+  ALOGD("%s: enter", fn);
+
+  for (wCount = 0; (wCount < 2 && !feof(Os_info->fp)); wCount++, wIndex++) {
+    wResult = FSCANF_BYTE(Os_info->fp, "%2X", (unsigned int*)&read_buf[wIndex]);
+
+    if(wResult == 0)
+    {
+      char metaString[MAX_META_STRING_SIZE];
+      char *ptr = fgets(metaString, sizeof(metaString), Os_info->fp);
+      if(ptr != NULL)
+      {
+        isMetaDatapresent = true;
+        ALOGD("MetaData = %s",ptr);
+        wCount = 0;
+        wIndex = 0;
+      }
+      else
+      {
+         break;
+      }
+    }
+    else
+    {
+      if(isMetaDatapresent)
+      {
+        isMetaDatapresent = false;
+        wCount = 0;
+        wIndex = 0;
+        read_buf[0] = read_buf[1];
+        ALOGD("End of MetaData");
+      }
+    }
+  }
+  if (wResult == 0) return STATUS_FAILED;
+
+  Os_info->bytes_read = Os_info->bytes_read + (wCount * 2);
+
+  if ((read_buf[0] == 0x7f) && (read_buf[1] == 0x21)) {
+    for (wCount = 0; (wCount < 1 && !feof(Os_info->fp)); wCount++, wIndex++) {
+      wResult =
+          FSCANF_BYTE(Os_info->fp, "%2X", (unsigned int*)&read_buf[wIndex]);
+    }
+    if (wResult == 0) {
+      ALOGE("%s: Exit Read Script failed in 7F21 ", fn);
+      return STATUS_FAILED;
+    }
+    /*Read_Script from wCount*2 to wCount*1 */
+    Os_info->bytes_read = Os_info->bytes_read + (wCount * 2);
+    lenOff = 2;
+  } else if ((read_buf[0] == 0x40) || (read_buf[0] == 0x60)) {
+    lenOff = 1;
+  }
+  /*If TAG is neither 7F21 nor 60 nor 40 then ABORT execution*/
+  else {
+    ALOGE("Invalid TAG 0x%X found in the script", read_buf[0]);
+    return STATUS_FAILED;
+  }
+
+  if (read_buf[lenOff] == 0x00) {
+    ALOGE("Invalid length zero");
+    len_byte = 0x00;
+    return STATUS_FAILED;
+  } else if ((read_buf[lenOff] & 0x80) == 0x80) {
+    len_byte = read_buf[lenOff] & 0x0F;
+    len_byte = len_byte + 1;  // 1 byte added for byte 0x81
+
+    ALOGD("%s: Length byte Read from 0x80 is 0x%x ", fn, len_byte);
+
+    if (len_byte == 0x02) {
+      for (wCount = 0; (wCount < 1 && !feof(Os_info->fp)); wCount++, wIndex++) {
+        wResult =
+            FSCANF_BYTE(Os_info->fp, "%2X", (unsigned int*)&read_buf[wIndex]);
+      }
+      if (wResult == 0) {
+        ALOGE("%s: Exit Read Script failed in length 0x02 ", fn);
+        return STATUS_FAILED;
+      }
+
+      wLen = read_buf[lenOff + 1];
+      Os_info->bytes_read = Os_info->bytes_read + (wCount * 2);
+      ALOGD("%s: Length of Read Script in len_byte= 0x02 is 0x%x ", fn, wLen);
+    } else if (len_byte == 0x03) {
+      for (wCount = 0; (wCount < 2 && !feof(Os_info->fp)); wCount++, wIndex++) {
+        wResult =
+            FSCANF_BYTE(Os_info->fp, "%2X", (unsigned int*)&read_buf[wIndex]);
+      }
+      if (wResult == 0) {
+        ALOGE("%s: Exit Read Script failed in length 0x03 ", fn);
+        return STATUS_FAILED;
+      }
+
+      Os_info->bytes_read = Os_info->bytes_read + (wCount * 2);
+      wLen = read_buf[lenOff + 1];  // Length of the packet send to LSC
+      wLen = ((wLen << 8) | (read_buf[lenOff + 2]));
+      ALOGD("%s: Length of Read Script in len_byte= 0x03 is 0x%x ", fn, wLen);
+    } else {
+      /*Need to provide the support if length is more than 2 bytes*/
+      ALOGE("Length recived is greater than 3");
+      return STATUS_FAILED;
+    }
+  } else {
+    len_byte = 0x01;
+    wLen = read_buf[lenOff];
+    ALOGE("%s: Length of Read Script in len_byte= 0x01 is 0x%x ", fn, wLen);
+  }
+
+  for (wCount = 0; (wCount < wLen && !feof(Os_info->fp)); wCount++, wIndex++) {
+    wResult = FSCANF_BYTE(Os_info->fp, "%2X", (unsigned int*)&read_buf[wIndex]);
+  }
+
+  if (wResult == 0) {
+    ALOGE("%s: Exit Read Script failed in fscanf function ", fn);
+    return status;
+  } else {
+    Os_info->bytes_read =
+        Os_info->bytes_read + (wCount * 2) + 1;  // not sure why 2 added
+    status = STATUS_OK;
+  }
+
+  ALOGD("%s: exit: status=0x%x; Num of bytes read=%d and index=%d", fn, status,
+        Os_info->bytes_read, wIndex);
+
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function:        LSC_SendtoEse
+**
+** Description:     It is used to send the packet to p61
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tLSC_STATUS LSC_SendtoEse(Lsc_ImageInfo_t* Os_info, tLSC_STATUS status,
+                          Lsc_TranscieveInfo_t* pTranscv_Info) {
+  static const char fn[] = "LSC_SendtoEse";
+  bool chanl_open_cmd = false;
+  tLSC_STATUS transStat = STATUS_FAILED;
+  status = STATUS_FAILED;
+  phNxpLs_data cmdApdu;
+  phNxpLs_data rspApdu;
+  int32_t recvBufferActualSize = 0;
+  ALOGD("%s: enter", fn);
+#ifdef JCOP3_WR
+  /*
+   * Bufferize_load_cmds function is implemented in JCOP
+   * */
+  status = Bufferize_load_cmds(Os_info, status, pTranscv_Info);
+  if (status != STATUS_FAILED) {
+#endif
+    if (pTranscv_Info->sSendData[1] == 0x70) {
+      if (pTranscv_Info->sSendData[2] == 0x00) {
+        ALOGE("Channel open");
+        chanl_open_cmd = true;
+      } else {
+        ALOGE("Channel close");
+        for (uint8_t cnt = 0; cnt < Os_info->channel_cnt; cnt++) {
+          if (Os_info->Channel_Info[cnt].channel_id ==
+              pTranscv_Info->sSendData[3]) {
+            ALOGE("Closed channel id = 0x0%x",
+                  Os_info->Channel_Info[cnt].channel_id);
+            Os_info->Channel_Info[cnt].isOpend = false;
+          }
+        }
+      }
+    }
+    phLS_memset(&cmdApdu, 0x00, sizeof(phNxpLs_data));
+    phLS_memset(&rspApdu, 0x00, sizeof(phNxpLs_data));
+
+    cmdApdu.len = (int32_t)(pTranscv_Info->sSendlength);
+    cmdApdu.p_data = (uint8_t*)phLS_memalloc(cmdApdu.len * sizeof(uint8_t));
+    memcpy(cmdApdu.p_data, pTranscv_Info->sSendData, cmdApdu.len);
+
+    transStat = LSC_Transceive(&cmdApdu, &rspApdu);
+
+    if (transStat != STATUS_SUCCESS) {
+      ALOGE("%s: Transceive failed; status=0x%X", fn, transStat);
+    } else {
+      if (chanl_open_cmd == true) {
+        if ((rspApdu.len == 0x03) &&
+            ((rspApdu.p_data[rspApdu.len - 2] == 0x90) &&
+             (rspApdu.p_data[rspApdu.len - 1] == 0x00))) {
+          ALOGE("open channel success");
+          uint8_t cnt = Os_info->channel_cnt;
+          Os_info->Channel_Info[cnt].channel_id =
+              rspApdu.p_data[rspApdu.len - 3];
+          Os_info->Channel_Info[cnt].isOpend = true;
+          Os_info->channel_cnt++;
+        } else {
+          ALOGE("channel open faield");
+        }
+      }
+      memcpy(pTranscv_Info->sRecvData, rspApdu.p_data, rspApdu.len);
+      status = Process_EseResponse(pTranscv_Info, rspApdu.len, Os_info);
+    }
+#ifdef JCOP3_WR
+  } else if (SendBack_cmds == false) {
+    /*
+     * Workaround for issue in JCOP
+     * Send the fake response back
+     * */
+    recvBufferActualSize = 0x03;
+    pTranscv_Info->sRecvData[0] = 0x00;
+    pTranscv_Info->sRecvData[1] = 0x90;
+    pTranscv_Info->sRecvData[2] = 0x00;
+    status = Process_EseResponse(pTranscv_Info, recvBufferActualSize, Os_info);
+  } else {
+    if (islastcmdLoad == true) {
+      status = Send_Backall_Loadcmds(Os_info, status, pTranscv_Info);
+      SendBack_cmds = false;
+    } else {
+      memset(Cmd_Buffer, 0, sizeof(Cmd_Buffer));
+      SendBack_cmds = false;
+      status = STATUS_FAILED;
+    }
+  }
+#endif
+  phLS_free(cmdApdu.p_data);
+  ALOGD("%s: exit: status=0x%x", fn, status);
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function:        LSC_SendtoLsc
+**
+** Description:     It is used to forward the packet to Lsc
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tLSC_STATUS LSC_SendtoLsc(Lsc_ImageInfo_t* Os_info, tLSC_STATUS status,
+                          Lsc_TranscieveInfo_t* pTranscv_Info,
+                          Ls_TagType tType) {
+  static const char fn[] = "LSC_SendtoLsc";
+  tLSC_STATUS transStat = STATUS_FAILED;
+  status = STATUS_FAILED;
+
+  phNxpLs_data cmdApdu;
+  phNxpLs_data rspApdu;
+  ALOGD("%s: enter", fn);
+  pTranscv_Info->sSendData[0] = (0x80 | Os_info->Channel_Info[0].channel_id);
+  pTranscv_Info->timeout = gTransceiveTimeout;
+  pTranscv_Info->sRecvlength = 1024;
+
+  phLS_memset(&cmdApdu, 0x00, sizeof(phNxpLs_data));
+  phLS_memset(&rspApdu, 0x00, sizeof(phNxpLs_data));
+  cmdApdu.len = pTranscv_Info->sSendlength;
+  cmdApdu.p_data = (uint8_t*)phLS_memalloc(cmdApdu.len * sizeof(uint8_t));
+  memcpy(cmdApdu.p_data, pTranscv_Info->sSendData, cmdApdu.len);
+
+  transStat = LSC_Transceive(&cmdApdu, &rspApdu);
+
+  if (transStat != STATUS_SUCCESS) {
+    ALOGE("%s: Transceive failed; status=0x%X", fn, transStat);
+  } else {
+    memcpy(pTranscv_Info->sRecvData, rspApdu.p_data, rspApdu.len);
+
+    status = LSC_ProcessResp(Os_info, rspApdu.len, pTranscv_Info, tType);
+  }
+  phLS_free(cmdApdu.p_data);
+  ALOGD("%s: exit: status=0x%x", fn, status);
+  return status;
+}
+/*******************************************************************************
+**
+** Function:        LSC_CloseChannel
+**
+** Description:     Closes the previously opened logical channel
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tLSC_STATUS LSC_CloseChannel(Lsc_ImageInfo_t* Os_info, tLSC_STATUS status,
+                             Lsc_TranscieveInfo_t* pTranscv_Info) {
+  static const char fn[] = "LSC_CloseChannel";
+  status = STATUS_FAILED;
+  tLSC_STATUS transStat = STATUS_FAILED;
+  phNxpLs_data cmdApdu;
+  phNxpLs_data rspApdu;
+  uint8_t xx = 0;
+  uint8_t cnt = 0;
+  ALOGD("%s: enter", fn);
+
+  if (Os_info == NULL || pTranscv_Info == NULL) {
+    ALOGE("Invalid parameter");
+  } else {
+    for (cnt = 0; (cnt < Os_info->channel_cnt); cnt++) {
+      phLS_memset(&cmdApdu, 0x00, sizeof(phNxpLs_data));
+      phLS_memset(&rspApdu, 0x00, sizeof(phNxpLs_data));
+
+      cmdApdu.len = 5;
+      cmdApdu.p_data =
+          (uint8_t*)phLS_memalloc(cmdApdu.len * sizeof(uint8_t));
+      if (Os_info->Channel_Info[cnt].isOpend == false) continue;
+      xx = 0;
+      cmdApdu.p_data[xx++] = Os_info->Channel_Info[cnt].channel_id;
+      cmdApdu.p_data[xx++] = 0x70;
+      cmdApdu.p_data[xx++] = 0x80;
+      cmdApdu.p_data[xx++] = Os_info->Channel_Info[cnt].channel_id;
+      cmdApdu.p_data[xx++] = 0x00;
+
+      transStat = LSC_Transceive(&cmdApdu, &rspApdu);
+
+      if (transStat != STATUS_SUCCESS && rspApdu.len < 2) {
+        ALOGE("%s: Transceive failed; status=0x%X", fn, transStat);
+      } else if ((rspApdu.p_data[rspApdu.len - 2] == 0x90) &&
+                 (rspApdu.p_data[rspApdu.len - 1] == 0x00)) {
+        ALOGE("Close channel id = 0x0%x is success",
+              Os_info->Channel_Info[cnt].channel_id);
+        status = STATUS_OK;
+      } else {
+        ALOGE("Close channel id = 0x0%x is failed",
+              Os_info->Channel_Info[cnt].channel_id);
+      }
+    }
+  }
+  phLS_free(cmdApdu.p_data);
+  ALOGD("%s: exit; status=0x0%x", fn, status);
+  return status;
+}
+/*******************************************************************************
+**
+** Function:        LSC_ProcessResp
+**
+** Description:     Process the response packet received from Lsc
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tLSC_STATUS LSC_ProcessResp(Lsc_ImageInfo_t* image_info, int32_t recvlen,
+                            Lsc_TranscieveInfo_t* trans_info,
+                            Ls_TagType tType) {
+  static const char fn[] = "LSC_ProcessResp";
+  tLSC_STATUS status = STATUS_FAILED;
+  static int32_t temp_len = 0;
+  uint8_t* RecvData = trans_info->sRecvData;
+  char sw[2];
+
+  ALOGD("%s: enter", fn);
+
+  if (RecvData == NULL && recvlen == 0x00) {
+    ALOGE("%s: Invalid parameter: status=0x%x", fn, status);
+    return status;
+  } else if (recvlen >= 2) {
+    sw[0] = RecvData[recvlen - 2];
+    sw[1] = RecvData[recvlen - 1];
+  } else {
+    ALOGE("%s: Invalid response; status=0x%x", fn, status);
+    return status;
+  }
+  /*Update the Global variable for storing response length*/
+  resp_len = recvlen;
+  if ((sw[0] != 0x63)) {
+    lsExecuteResp[2] = sw[0];
+    lsExecuteResp[3] = sw[1];
+    ALOGD("%s: Process Response SW; status = 0x%x", fn, sw[0]);
+    ALOGD("%s: Process Response SW; status = 0x%x", fn, sw[1]);
+  }
+  if ((recvlen == 0x02) && (sw[0] == 0x90) && (sw[1] == 0x00)) {
+    tLSC_STATUS wStatus = STATUS_FAILED;
+    ALOGE("%s: Before Write Response", fn);
+    wStatus = Write_Response_To_OutFile(image_info, RecvData, recvlen, tType);
+    if (wStatus != STATUS_FAILED) status = STATUS_OK;
+  } else if ((recvlen > 0x02) && (sw[0] == 0x90) && (sw[1] == 0x00)) {
+    tLSC_STATUS wStatus = STATUS_FAILED;
+    ALOGE("%s: Before Write Response", fn);
+    wStatus = Write_Response_To_OutFile(image_info, RecvData, recvlen, tType);
+    if (wStatus != STATUS_FAILED) status = STATUS_OK;
+  }
+
+  else if ((recvlen > 0x02) && (sw[0] == 0x63) && (sw[1] == 0x10)) {
+    if (temp_len != 0) {
+      memcpy((trans_info->sTemp_recvbuf + temp_len), RecvData, (recvlen - 2));
+      trans_info->sSendlength = temp_len + (recvlen - 2);
+      memcpy(trans_info->sSendData, trans_info->sTemp_recvbuf,
+             trans_info->sSendlength);
+      temp_len = 0;
+    } else {
+      memcpy(trans_info->sSendData, RecvData, (recvlen - 2));
+      trans_info->sSendlength = recvlen - 2;
+    }
+    status = LSC_SendtoEse(image_info, status, trans_info);
+  } else if ((recvlen > 0x02) && (sw[0] == 0x63) && (sw[1] == 0x20)) {
+    uint8_t respLen = 0;
+    int32_t wStatus = 0;
+
+    AID_ARRAY[0] = recvlen + 3;
+    AID_ARRAY[1] = 00;
+    AID_ARRAY[2] = 0xA4;
+    AID_ARRAY[3] = 0x04;
+    AID_ARRAY[4] = 0x00;
+    AID_ARRAY[5] = recvlen - 2;
+    memcpy(&AID_ARRAY[6], &RecvData[0], recvlen - 2);
+    //memcpy(&ArrayOfAIDs[2][0], &AID_ARRAY[0], recvlen + 4);
+    memcpy(&ArrayOfAIDs[LS_SELF_UPDATE_AID_IDX][0], &AID_ARRAY[0], recvlen + 4);
+
+    fAID_MEM = fopen(AID_MEM_PATH[gpLsc_Dwnld_Context->
+      mchannel->getInterfaceInfo()], "w");
+
+    if (fAID_MEM == NULL) {
+      ALOGE("Error opening AID data for writing: %s", strerror(errno));
+      return status;
+    }
+
+    /*Updating the AID_MEM with new value into AID file*/
+    while (respLen <= (recvlen + 4)) {
+      wStatus = fprintf(fAID_MEM, "%2x", AID_ARRAY[respLen++]);
+      if (wStatus != 2) {
+        ALOGE("%s: Invalid Response during fprintf; status=0x%x", fn, status);
+        fclose(fAID_MEM);
+        break;
+      }
+    }
+    if (wStatus == 2) {
+      status = STATUS_FILE_NOT_FOUND;
+    } else {
+      status = STATUS_FAILED;
+    }
+  } else if ((recvlen >= 0x02) &&
+             ((sw[0] != 0x90) && (sw[0] != 0x63) && (sw[0] != 0x61))) {
+    tLSC_STATUS wStatus = STATUS_FAILED;
+    wStatus = Write_Response_To_OutFile(image_info, RecvData, recvlen, tType);
+  }
+  ALOGD("%s: exit: status=0x%x", fn, status);
+  return status;
+}
+/*******************************************************************************
+**
+** Function:        Process_EseResponse
+**
+** Description:     It is used to process the received response packet from ESE
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tLSC_STATUS Process_EseResponse(Lsc_TranscieveInfo_t* pTranscv_Info,
+                                int32_t recv_len, Lsc_ImageInfo_t* Os_info) {
+  static const char fn[] = "Process_EseResponse";
+  tLSC_STATUS status = STATUS_OK;
+  uint8_t xx = 0;
+  ALOGD("%s: enter", fn);
+
+  pTranscv_Info->sSendData[xx++] =
+      (CLA_BYTE | Os_info->Channel_Info[0].channel_id);
+  pTranscv_Info->sSendData[xx++] = 0xA2;
+
+  if (recv_len <= 0xFF) {
+    pTranscv_Info->sSendData[xx++] = 0x80;
+    pTranscv_Info->sSendData[xx++] = 0x00;
+    pTranscv_Info->sSendData[xx++] = (uint8_t)recv_len;
+    memcpy(&(pTranscv_Info->sSendData[xx]), pTranscv_Info->sRecvData, recv_len);
+    pTranscv_Info->sSendlength = xx + recv_len;
+    status = LSC_SendtoLsc(Os_info, status, pTranscv_Info, LS_Comm);
+  } else {
+    while (recv_len > MAX_SIZE) {
+      xx = PARAM_P1_OFFSET;
+      pTranscv_Info->sSendData[xx++] = 0x00;
+      pTranscv_Info->sSendData[xx++] = 0x00;
+      pTranscv_Info->sSendData[xx++] = MAX_SIZE;
+      recv_len = recv_len - MAX_SIZE;
+      memcpy(&(pTranscv_Info->sSendData[xx]), pTranscv_Info->sRecvData,
+             MAX_SIZE);
+      pTranscv_Info->sSendlength = xx + MAX_SIZE;
+      /*Need not store Process eSE response's response in the out file so
+       * LS_Comm = 0*/
+      status = LSC_SendtoLsc(Os_info, status, pTranscv_Info, LS_Comm);
+      if (status != STATUS_OK) {
+        ALOGE("Sending packet to Lsc failed: status=0x%x", status);
+        return status;
+      }
+    }
+    xx = PARAM_P1_OFFSET;
+    pTranscv_Info->sSendData[xx++] = LAST_BLOCK;
+    pTranscv_Info->sSendData[xx++] = 0x01;
+    pTranscv_Info->sSendData[xx++] = recv_len;
+    memcpy(&(pTranscv_Info->sSendData[xx]), pTranscv_Info->sRecvData, recv_len);
+    pTranscv_Info->sSendlength = xx + recv_len;
+    status = LSC_SendtoLsc(Os_info, status, pTranscv_Info, LS_Comm);
+  }
+  ALOGD("%s: exit: status=0x%x", fn, status);
+  return status;
+}
+/*******************************************************************************
+**
+** Function:        Process_SelectRsp
+**
+** Description:     It is used to process the received response for SELECT LSC
+*cmd
+**
+** Returns:         Success if ok.
+**
+*******************************************************************************/
+tLSC_STATUS Process_SelectRsp(uint8_t* Recv_data, int32_t Recv_len) {
+  (void)Recv_len;
+  static const char fn[] = "Process_SelectRsp";
+  tLSC_STATUS status = STATUS_FAILED;
+  int i = 0, len = 0;
+  ALOGE("%s: enter", fn);
+
+  if (Recv_data[i] == TAG_SELECT_ID) {
+    ALOGD("TAG: TAG_SELECT_ID");
+    i = i + 1;
+    len = Recv_data[i];
+    i = i + 1;
+    if (Recv_data[i] == TAG_LSC_ID) {
+      ALOGD("TAG: TAG_LSC_ID");
+      i = i + 1;
+      len = Recv_data[i];
+      i = i + 1 + len;  // points to next tag name A5
+      // points to TAG 9F08 for LS application version
+      if ((Recv_data[i] == TAG_LS_VER1) && (Recv_data[i + 1] == TAG_LS_VER2)) {
+        uint8_t lsaVersionLen = 0;
+        ALOGD("TAG: TAG_LS_APPLICATION_VER");
+
+        i = i + 2;
+        lsaVersionLen = Recv_data[i];
+        // points to TAG 9F08 LS application version
+        i = i + 1;
+        memcpy(lsVersionArr, &Recv_data[i], lsaVersionLen);
+
+        // points to Identifier of the Root Entity key set identifier
+        i = i + lsaVersionLen;
+
+        if (Recv_data[i] == TAG_RE_KEYID) {
+          uint8_t rootEntityLen = 0;
+          i = i + 1;
+          rootEntityLen = Recv_data[i];
+
+          i = i + 1;
+          if (Recv_data[i] == TAG_LSRE_ID) {
+            uint8_t tag42Len = 0;
+            i = i + 1;
+            tag42Len = Recv_data[i];
+            // copy the data including length
+            memcpy(tag42Arr, &Recv_data[i], tag42Len + 1);
+            i = i + tag42Len + 1;
+            ALOGD("tag42Arr %s", tag42Arr);
+            if (Recv_data[i] == TAG_LSRE_SIGNID) {
+              uint8_t tag45Len = Recv_data[i + 1];
+              memcpy(tag45Arr, &Recv_data[i + 1], tag45Len + 1);
+              status = STATUS_OK;
+            } else {
+              ALOGE(
+                  "Invalid Root entity for TAG 45 = 0x%x; "
+                  "status=0x%x",
+                  Recv_data[i], status);
+              return status;
+            }
+          } else {
+            ALOGE(
+                "Invalid Root entity for TAG 42 = 0x%x; "
+                "status=0x%x",
+                Recv_data[i], status);
+            return status;
+          }
+        } else {
+          ALOGE(
+              "Invalid Root entity key set TAG ID = 0x%x; "
+              "status=0x%x",
+              Recv_data[i], status);
+          return status;
+        }
+      }
+    } else {
+      ALOGE("Invalid Loader Service AID TAG ID = 0x%x; status=0x%x",
+            Recv_data[i], status);
+      return status;
+    }
+  } else {
+    ALOGE("Invalid FCI TAG = 0x%x; status=0x%x", Recv_data[i], status);
+    return status;
+  }
+  ALOGE("%s: Exiting status = 0x%x", fn, status);
+  return status;
+}
+
+#ifdef JCOP3_WR
+tLSC_STATUS Bufferize_load_cmds(Lsc_ImageInfo_t* Os_info, tLSC_STATUS status,
+                                Lsc_TranscieveInfo_t* pTranscv_Info) {
+  (void)Os_info;
+  static const char fn[] = "Bufferize_load_cmds";
+  uint8_t Param_P2;
+  status = STATUS_FAILED;
+
+  if (cmd_count == 0x00) {
+    if ((pTranscv_Info->sSendData[1] == INSTAL_LOAD_ID) &&
+        (pTranscv_Info->sSendData[2] == PARAM_P1_OFFSET) &&
+        (pTranscv_Info->sSendData[3] == 0x00)) {
+      ALOGE("BUffer: install for load");
+      pBuffer[0] = pTranscv_Info->sSendlength;
+      memcpy(&pBuffer[1], &(pTranscv_Info->sSendData[0]),
+             pTranscv_Info->sSendlength);
+      pBuffer = pBuffer + pTranscv_Info->sSendlength + 1;
+      cmd_count++;
+    } else {
+      /*
+       * Do not buffer this cmd
+       * Send this command to eSE
+       * */
+      status = STATUS_OK;
+    }
+
+  } else {
+    Param_P2 = cmd_count - 1;
+    if ((pTranscv_Info->sSendData[1] == LOAD_CMD_ID) &&
+        (pTranscv_Info->sSendData[2] == LOAD_MORE_BLOCKS) &&
+        (pTranscv_Info->sSendData[3] == Param_P2)) {
+      ALOGE("BUffer: load");
+      pBuffer[0] = pTranscv_Info->sSendlength;
+      memcpy(&pBuffer[1], &(pTranscv_Info->sSendData[0]),
+             pTranscv_Info->sSendlength);
+      pBuffer = pBuffer + pTranscv_Info->sSendlength + 1;
+      cmd_count++;
+    } else if ((pTranscv_Info->sSendData[1] == LOAD_CMD_ID) &&
+               (pTranscv_Info->sSendData[2] == LOAD_LAST_BLOCK) &&
+               (pTranscv_Info->sSendData[3] == Param_P2)) {
+      ALOGE("BUffer: last load");
+      SendBack_cmds = true;
+      pBuffer[0] = pTranscv_Info->sSendlength;
+      memcpy(&pBuffer[1], &(pTranscv_Info->sSendData[0]),
+             pTranscv_Info->sSendlength);
+      pBuffer = pBuffer + pTranscv_Info->sSendlength + 1;
+      cmd_count++;
+      islastcmdLoad = true;
+    } else {
+      ALOGE("BUffer: Not a load cmd");
+      SendBack_cmds = true;
+      pBuffer[0] = pTranscv_Info->sSendlength;
+      memcpy(&pBuffer[1], &(pTranscv_Info->sSendData[0]),
+             pTranscv_Info->sSendlength);
+      pBuffer = pBuffer + pTranscv_Info->sSendlength + 1;
+      islastcmdLoad = false;
+      cmd_count++;
+    }
+  }
+  ALOGE("%s: exit; status=0x%x", fn, status);
+  return status;
+}
+
+tLSC_STATUS Send_Backall_Loadcmds(Lsc_ImageInfo_t* Os_info, tLSC_STATUS status,
+                                  Lsc_TranscieveInfo_t* pTranscv_Info) {
+  static const char fn[] = "Send_Backall_Loadcmds";
+  tLSC_STATUS transStat = STATUS_FAILED;
+  status = STATUS_FAILED;
+  phNxpLs_data cmdApdu;
+  phNxpLs_data rspApdu;
+  int32_t recvBufferActualSize = 0;
+  ALOGD("%s: enter", fn);
+  pBuffer = Cmd_Buffer;  // Points to start of first cmd to send
+  if (cmd_count == 0x00) {
+    ALOGE("No cmds stored to send to eSE");
+  } else {
+    while (cmd_count-- > 0) {
+      phLS_memset(&cmdApdu, 0x00, sizeof(phNxpLs_data));
+      phLS_memset(&rspApdu, 0x00, sizeof(phNxpLs_data));
+
+      cmdApdu.len = (int32_t)(pBuffer[0]);
+      cmdApdu.p_data =
+          (uint8_t*)phLS_memalloc(cmdApdu.len * sizeof(uint8_t));
+      pBuffer = pBuffer + 1 + cmdApdu.len;
+
+      memcpy(cmdApdu.p_data, &pBuffer[1], cmdApdu.len);
+
+      transStat = LSC_Transceive(&cmdApdu, &rspApdu);
+
+      memcpy(pTranscv_Info->sRecvData, rspApdu.p_data, rspApdu.len);
+      recvBufferActualSize = rspApdu.len;
+
+      if (transStat != STATUS_SUCCESS || (recvBufferActualSize < 2)) {
+        ALOGE("%s: Transceive failed; status=0x%X", fn, transStat);
+      } else if (cmd_count == 0x00)  // Last command in the buffer
+      {
+        if (islastcmdLoad == false) {
+          status =
+              Process_EseResponse(pTranscv_Info, recvBufferActualSize, Os_info);
+        } else if ((recvBufferActualSize == 0x02) &&
+                   (pTranscv_Info->sRecvData[recvBufferActualSize - 2] ==
+                    0x90) &&
+                   (pTranscv_Info->sRecvData[recvBufferActualSize - 1] ==
+                    0x00)) {
+          recvBufferActualSize = 0x03;
+          pTranscv_Info->sRecvData[0] = 0x00;
+          pTranscv_Info->sRecvData[1] = 0x90;
+          pTranscv_Info->sRecvData[2] = 0x00;
+          status =
+              Process_EseResponse(pTranscv_Info, recvBufferActualSize, Os_info);
+        } else {
+          status =
+              Process_EseResponse(pTranscv_Info, recvBufferActualSize, Os_info);
+        }
+      } else if ((recvBufferActualSize == 0x02) &&
+                 (pTranscv_Info->sRecvData[0] == 0x90) &&
+                 (pTranscv_Info->sRecvData[1] == 0x00)) {
+        /*Do not do anything
+         * send next command in the buffer*/
+      } else if ((recvBufferActualSize == 0x03) &&
+                 (pTranscv_Info->sRecvData[0] == 0x00) &&
+                 (pTranscv_Info->sRecvData[1] == 0x90) &&
+                 (pTranscv_Info->sRecvData[2] == 0x00)) {
+        /*Do not do anything
+         * Send next cmd in the buffer*/
+      } else if ((pTranscv_Info->sRecvData[recvBufferActualSize - 2] != 0x90) &&
+                 (pTranscv_Info->sRecvData[recvBufferActualSize - 1] != 0x00)) {
+        /*Error condition hence exiting the loop*/
+        status =
+            Process_EseResponse(pTranscv_Info, recvBufferActualSize, Os_info);
+        /*If the sending of Load fails reset the count*/
+        cmd_count = 0;
+        break;
+      }
+    }
+  }
+  memset(Cmd_Buffer, 0, sizeof(Cmd_Buffer));
+  pBuffer = Cmd_Buffer;  // point back to start of line
+  cmd_count = 0x00;
+  phLS_free(cmdApdu.p_data);
+  ALOGD("%s: exit: status=0x%x", fn, status);
+  return status;
+}
+#endif
+/*******************************************************************************
+**
+** Function:        Numof_lengthbytes
+**
+** Description:     Checks the number of length bytes and assigns
+**                  length value to wLen.
+**
+** Returns:         Number of Length bytes
+**
+*******************************************************************************/
+uint8_t Numof_lengthbytes(uint8_t* read_buf, int32_t* pLen) {
+  static const char fn[] = "Numof_lengthbytes";
+  uint8_t len_byte = 0, i = 0;
+  int32_t wLen = 0;
+  ALOGE("%s:enter", fn);
+
+  if (read_buf[i] == 0x00) {
+    ALOGE("Invalid length zero");
+    len_byte = 0x00;
+  } else if ((read_buf[i] & 0x80) == 0x80) {
+    len_byte = read_buf[i] & 0x0F;
+    len_byte = len_byte + 1;  // 1 byte added for byte 0x81
+  } else {
+    len_byte = 0x01;
+  }
+  /*
+   * To get the length of the value field
+   * */
+  switch (len_byte) {
+    case 0:
+      wLen = read_buf[0];
+      break;
+    case 1:
+      /*1st byte is the length*/
+      wLen = read_buf[0];
+      break;
+    case 2:
+      /*2nd byte is the length*/
+      wLen = read_buf[1];
+      break;
+    case 3:
+      /*1st and 2nd bytes are length*/
+      wLen = read_buf[1];
+      wLen = ((wLen << 8) | (read_buf[2]));
+      break;
+    case 4:
+      /*3bytes are the length*/
+      wLen = read_buf[1];
+      wLen = ((wLen << 16) | (read_buf[2] << 8));
+      wLen = (wLen | (read_buf[3]));
+      break;
+    default:
+      ALOGE("default case");
+      break;
+  }
+
+  *pLen = wLen;
+  ALOGE("%s:exit; len_bytes=0x0%x, Length=%d", fn, len_byte, *pLen);
+  return len_byte;
+}
+/*******************************************************************************
+**
+** Function:        Write_Response_To_OutFile
+**
+** Description:     Write the response to Out file
+**                  with length recvlen from buffer RecvData.
+**
+** Returns:         Success if OK
+**
+*******************************************************************************/
+tLSC_STATUS Write_Response_To_OutFile(Lsc_ImageInfo_t* image_info,
+                                      uint8_t* RecvData, int32_t recvlen,
+                                      Ls_TagType tType) {
+  int32_t respLen = 0;
+  tLSC_STATUS wStatus = STATUS_FAILED;
+  static const char fn[] = "Write_Response_to_OutFile";
+  int32_t status = 0;
+  uint8_t tagBuffer[12] = {0x61, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+  int32_t tag44Len = 0;
+  int32_t tag61Len = 0;
+  uint8_t tag43Len = 1;
+  uint8_t tag43off = 0;
+  uint8_t tag44off = 0;
+  uint8_t ucTag44[3] = {0x00, 0x00, 0x00};
+  uint8_t tagLen = 0;
+  uint8_t tempLen = 0;
+  /*If the Response out file is NULL or Other than LS commands*/
+  if ((image_info->bytes_wrote == 0x55) || (tType == LS_Default)) {
+    return STATUS_OK;
+  }
+  /*Certificate TAG occupies 2 bytes*/
+  if (tType == LS_Cert) {
+    tag43Len = 2;
+  }
+  ALOGE("%s: Enter", fn);
+
+  /* |TAG | LEN(BERTLV)|                                VAL |
+   * | 61 |      XX    |  TAG | LEN |     VAL    | TAG | LEN(BERTLV) |      VAL
+   *|
+   *                   |  43  | 1/2 | 7F21/60/40 | 44  | apduRespLen |
+   *apduResponse |
+   **/
+  if (recvlen < 0x80) {
+    tag44Len = 1;
+    ucTag44[0] = recvlen;
+    tag61Len = recvlen + 4 + tag43Len;
+
+    if (tag61Len & 0x80) {
+      tagBuffer[1] = 0x81;
+      tagBuffer[2] = tag61Len;
+      tag43off = 3;
+      tag44off = 5 + tag43Len;
+      tagLen = tag44off + 2;
+    } else {
+      tagBuffer[1] = tag61Len;
+      tag43off = 2;
+      tag44off = 4 + tag43Len;
+      tagLen = tag44off + 2;
+    }
+  } else if ((recvlen >= 0x80) && (recvlen <= 0xFF)) {
+    ucTag44[0] = 0x81;
+    ucTag44[1] = recvlen;
+    tag61Len = recvlen + 5 + tag43Len;
+    tag44Len = 2;
+
+    if ((tag61Len & 0xFF00) != 0) {
+      tagBuffer[1] = 0x82;
+      tagBuffer[2] = (tag61Len & 0xFF00) >> 8;
+      tagBuffer[3] = (tag61Len & 0xFF);
+      tag43off = 4;
+      tag44off = 6 + tag43Len;
+      tagLen = tag44off + 3;
+    } else {
+      tagBuffer[1] = 0x81;
+      tagBuffer[2] = (tag61Len & 0xFF);
+      tag43off = 3;
+      tag44off = 5 + tag43Len;
+      tagLen = tag44off + 3;
+    }
+  } else if ((recvlen > 0xFF) && (recvlen <= 0xFFFF)) {
+    ucTag44[0] = 0x82;
+    ucTag44[1] = (recvlen & 0xFF00) >> 8;
+    ucTag44[2] = (recvlen & 0xFF);
+    tag44Len = 3;
+
+    tag61Len = recvlen + 6 + tag43Len;
+
+    if ((tag61Len & 0xFF00) != 0) {
+      tagBuffer[1] = 0x82;
+      tagBuffer[2] = (tag61Len & 0xFF00) >> 8;
+      tagBuffer[3] = (tag61Len & 0xFF);
+      tag43off = 4;
+      tag44off = 6 + tag43Len;
+      tagLen = tag44off + 4;
+    }
+  }
+  tagBuffer[tag43off] = 0x43;
+  tagBuffer[tag43off + 1] = tag43Len;
+  tagBuffer[tag44off] = 0x44;
+  memcpy(&tagBuffer[tag44off + 1], &ucTag44[0], tag44Len);
+
+  if (tType == LS_Cert) {
+    tagBuffer[tag43off + 2] = 0x7F;
+    tagBuffer[tag43off + 3] = 0x21;
+  } else if (tType == LS_Sign) {
+    tagBuffer[tag43off + 2] = 0x60;
+  } else if (tType == LS_Comm) {
+    tagBuffer[tag43off + 2] = 0x40;
+  } else {
+    /*Do nothing*/
+  }
+  while (tempLen < tagLen) {
+    status = fprintf(image_info->fResp, "%02X", tagBuffer[tempLen++]);
+    if (status != 2) {
+      ALOGE("%s: Invalid Response during fprintf; status=0x%x", fn, (status));
+      wStatus = STATUS_FAILED;
+      break;
+    }
+  }
+  /*Updating the response data into out script*/
+  while (respLen < recvlen) {
+    status = fprintf(image_info->fResp, "%02X", RecvData[respLen++]);
+    if (status != 2) {
+      ALOGE("%s: Invalid Response during fprintf; status=0x%x", fn, (status));
+      wStatus = STATUS_FAILED;
+      break;
+    }
+  }
+  if (status == 2) {
+    fprintf(image_info->fResp, "%s\n", "");
+    ALOGE("%s: SUCCESS Response written to script out file; status=0x%x", fn,
+          (status));
+    wStatus = STATUS_OK;
+  }
+  fflush(image_info->fResp);
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function:        Check_Certificate_Tag
+**
+** Description:     Check certificate Tag presence in script
+**                  by 7F21 .
+**
+** Returns:         Success if Tag found
+**
+*******************************************************************************/
+tLSC_STATUS Check_Certificate_Tag(uint8_t* read_buf, uint16_t* offset1) {
+  tLSC_STATUS status = STATUS_FAILED;
+  uint16_t len_byte = 0;
+  int32_t wLen /*, recvBufferActualSize=0*/;
+  uint16_t offset = *offset1;
+
+  if (((read_buf[offset] << 8 | read_buf[offset + 1]) == TAG_CERTIFICATE)) {
+    ALOGD("TAGID: TAG_CERTIFICATE");
+    offset = offset + 2;
+    len_byte = Numof_lengthbytes(&read_buf[offset], &wLen);
+    offset = offset + len_byte;
+    *offset1 = offset;
+    if (wLen <= MAX_CERT_LEN) status = STATUS_OK;
+  }
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function:        Check_SerialNo_Tag
+**
+** Description:     Check Serial number Tag presence in script
+**                  by 0x93 .
+**
+** Returns:         Success if Tag found
+**
+*******************************************************************************/
+tLSC_STATUS Check_SerialNo_Tag(uint8_t* read_buf, uint16_t* offset1) {
+  tLSC_STATUS status = STATUS_FAILED;
+  uint16_t offset = *offset1;
+  static const char fn[] = "Check_SerialNo_Tag";
+
+  if (read_buf[offset] == TAG_SERIAL_NO) {
+    ALOGD("TAGID: TAG_SERIAL_NO");
+    uint8_t serNoLen = read_buf[offset + 1];
+    offset = offset + serNoLen + 2;
+    *offset1 = offset;
+    ALOGD("%s: TAG_LSROOT_ENTITY is %x", fn, read_buf[offset]);
+    status = STATUS_OK;
+  }
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function:        Check_LSRootID_Tag
+**
+** Description:     Check LS root ID tag presence in script and compare with
+**                  select response root ID value.
+**
+** Returns:         Success if Tag found
+**
+*******************************************************************************/
+tLSC_STATUS Check_LSRootID_Tag(uint8_t* read_buf, uint16_t* offset1) {
+  tLSC_STATUS status = STATUS_FAILED;
+  uint16_t offset = *offset1;
+
+  if (read_buf[offset] == TAG_LSRE_ID) {
+    ALOGD("TAGID: TAG_LSROOT_ENTITY");
+    if (tag42Arr[0] == read_buf[offset + 1]) {
+      uint8_t tag42Len = read_buf[offset + 1];
+      offset = offset + 2;
+      status = memcmp(&read_buf[offset], &tag42Arr[1], tag42Arr[0]);
+      ALOGD("LSC_Check_KeyIdentifier : TAG 42 verified");
+
+      if (status == STATUS_OK) {
+        ALOGD(
+            "LSC_Check_KeyIdentifier : Loader service root entity "
+            "ID is matched");
+        offset = offset + tag42Len;
+        *offset1 = offset;
+      }
+    }
+  }
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function:        Check_CertHoldID_Tag
+**
+** Description:     Check certificate holder ID tag presence in script.
+**
+** Returns:         Success if Tag found
+**
+*******************************************************************************/
+tLSC_STATUS Check_CertHoldID_Tag(uint8_t* read_buf, uint16_t* offset1) {
+  tLSC_STATUS status = STATUS_FAILED;
+  uint16_t offset = *offset1;
+
+  if ((read_buf[offset] << 8 | read_buf[offset + 1]) == TAG_CERTFHOLD_ID) {
+    uint8_t certfHoldIDLen = 0;
+    ALOGD("TAGID: TAG_CERTFHOLD_ID");
+    certfHoldIDLen = read_buf[offset + 2];
+    offset = offset + certfHoldIDLen + 3;
+    if (read_buf[offset] == TAG_KEY_USAGE) {
+      uint8_t keyusgLen = 0;
+      ALOGD("TAGID: TAG_KEY_USAGE");
+      keyusgLen = read_buf[offset + 1];
+      offset = offset + keyusgLen + 2;
+      *offset1 = offset;
+      status = STATUS_OK;
+    }
+  }
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function:        Check_Date_Tag
+**
+** Description:     Check date tags presence in script.
+**
+** Returns:         Success if Tag found
+**
+*******************************************************************************/
+tLSC_STATUS Check_Date_Tag(uint8_t* read_buf, uint16_t* offset1) {
+  tLSC_STATUS status = STATUS_OK;
+  uint16_t offset = *offset1;
+
+  if ((read_buf[offset] << 8 | read_buf[offset + 1]) == TAG_EFF_DATE) {
+    uint8_t effDateLen = read_buf[offset + 2];
+    offset = offset + 3 + effDateLen;
+    ALOGD("TAGID: TAG_EFF_DATE");
+    if ((read_buf[offset] << 8 | read_buf[offset + 1]) == TAG_EXP_DATE) {
+      uint8_t effExpLen = read_buf[offset + 2];
+      offset = offset + 3 + effExpLen;
+      ALOGD("TAGID: TAG_EXP_DATE");
+      status = STATUS_OK;
+    } else if (read_buf[offset] == TAG_LSRE_SIGNID) {
+      status = STATUS_OK;
+    }
+  } else if ((read_buf[offset] << 8 | read_buf[offset + 1]) == TAG_EXP_DATE) {
+    uint8_t effExpLen = read_buf[offset + 2];
+    offset = offset + 3 + effExpLen;
+    ALOGD("TAGID: TAG_EXP_DATE");
+    status = STATUS_OK;
+  } else if (read_buf[offset] == TAG_LSRE_SIGNID) {
+    status = STATUS_OK;
+  } else {
+    /*STATUS_FAILED*/
+  }
+  *offset1 = offset;
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function:        Check_45_Tag
+**
+** Description:     Check 45 tags presence in script and compare the value
+**                  with select response tag 45 value
+**
+** Returns:         Success if Tag found
+**
+*******************************************************************************/
+tLSC_STATUS Check_45_Tag(uint8_t* read_buf, uint16_t* offset1,
+                         uint8_t* tag45Len) {
+  tLSC_STATUS status = STATUS_FAILED;
+  uint16_t offset = *offset1;
+  if (read_buf[offset] == TAG_LSRE_SIGNID) {
+    *tag45Len = read_buf[offset + 1];
+    offset = offset + 2;
+    if (tag45Arr[0] == *tag45Len) {
+      status = memcmp(&read_buf[offset], &tag45Arr[1], tag45Arr[0]);
+      if (status == STATUS_OK) {
+        ALOGD("LSC_Check_KeyIdentifier : TAG 45 verified");
+        *offset1 = offset;
+      }
+    }
+  }
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function:        Certificate_Verification
+**
+** Description:     Perform the certificate verification by forwarding it to
+**                  LS applet.
+**
+** Returns:         Success if certificate is verified
+**
+*******************************************************************************/
+tLSC_STATUS Certificate_Verification(Lsc_ImageInfo_t* Os_info,
+                                     Lsc_TranscieveInfo_t* pTranscv_Info,
+                                     uint8_t* read_buf, uint16_t* offset1,
+                                     uint8_t* tag45Len) {
+  tLSC_STATUS status = STATUS_FAILED;
+  uint16_t offset = *offset1;
+  int32_t wCertfLen = (read_buf[2] << 8 | read_buf[3]);
+  tLSC_STATUS certf_found = STATUS_FAILED;
+  static const char fn[] = "Certificate_Verification";
+  uint8_t tag_len_byte = Numof_lengthbytes(&read_buf[2], &wCertfLen);
+
+  pTranscv_Info->sSendData[0] = 0x80;
+  pTranscv_Info->sSendData[1] = 0xA0;
+  pTranscv_Info->sSendData[2] = 0x01;
+  pTranscv_Info->sSendData[3] = 0x00;
+  /*If the certificate is less than 255 bytes*/
+  if (wCertfLen <= 251) {
+    uint8_t tag7f49Off = 0;
+    uint8_t u7f49Len = 0;
+    uint8_t tag5f37Len = 0;
+    ALOGD("Certificate is greater than 255");
+    offset = offset + *tag45Len;
+    ALOGD("%s: Before TAG_CCM_PERMISSION = %x", fn, read_buf[offset]);
+    if (read_buf[offset] == TAG_CCM_PERMISSION) {
+      int32_t tag53Len = 0;
+      uint8_t len_byte = 0;
+      offset = offset + 1;
+      len_byte = Numof_lengthbytes(&read_buf[offset], &tag53Len);
+      offset = offset + tag53Len + len_byte;
+      ALOGD("%s: Verified TAG TAG_CCM_PERMISSION = 0x53", fn);
+      if ((uint16_t)(read_buf[offset] << 8 | read_buf[offset + 1]) ==
+          TAG_SIG_RNS_COMP) {
+        tag7f49Off = offset;
+        u7f49Len = read_buf[offset + 2];
+        offset = offset + 3 + u7f49Len;
+        if (u7f49Len != 64) {
+          return STATUS_FAILED;
+        }
+        if ((uint16_t)(read_buf[offset] << 8 | read_buf[offset + 1]) ==
+            0x7f49) {
+          tag5f37Len = read_buf[offset + 2];
+          if (read_buf[offset + 3] != 0x86 || (read_buf[offset + 4] != 65)) {
+            return STATUS_FAILED;
+          }
+        } else {
+          return STATUS_FAILED;
+        }
+      } else {
+        return STATUS_FAILED;
+      }
+    } else {
+      return STATUS_FAILED;
+    }
+    pTranscv_Info->sSendData[4] = wCertfLen + 2 + tag_len_byte;
+    pTranscv_Info->sSendlength = wCertfLen + 7 + tag_len_byte;
+    memcpy(&(pTranscv_Info->sSendData[5]), &read_buf[0],
+           wCertfLen + 2 + tag_len_byte);
+
+    ALOGD("%s: start transceive for length %d", fn, pTranscv_Info->sSendlength);
+    status = LSC_SendtoLsc(Os_info, status, pTranscv_Info, LS_Cert);
+    if (status != STATUS_OK) {
+      return status;
+    } else {
+      certf_found = STATUS_OK;
+      ALOGD("Certificate is verified");
+      return status;
+    }
+  }
+  /*If the certificate is more than 255 bytes*/
+  else {
+    uint8_t tag7f49Off = 0;
+    uint8_t u7f49Len = 0;
+    uint8_t tag5f37Len = 0;
+    ALOGD("Certificate is greater than 255");
+    offset = offset + *tag45Len;
+    ALOGD("%s: Before TAG_CCM_PERMISSION = %x", fn, read_buf[offset]);
+    if (read_buf[offset] == TAG_CCM_PERMISSION) {
+      int32_t tag53Len = 0;
+      uint8_t len_byte = 0;
+      offset = offset + 1;
+      len_byte = Numof_lengthbytes(&read_buf[offset], &tag53Len);
+      offset = offset + tag53Len + len_byte;
+      ALOGD("%s: Verified TAG TAG_CCM_PERMISSION = 0x53", fn);
+      if ((uint16_t)(read_buf[offset] << 8 | read_buf[offset + 1]) ==
+          TAG_SIG_RNS_COMP) {
+        tag7f49Off = offset;
+        u7f49Len = read_buf[offset + 2];
+        offset = offset + 3 + u7f49Len;
+        if (u7f49Len != 64) {
+          return STATUS_FAILED;
+        }
+        if ((uint16_t)(read_buf[offset] << 8 | read_buf[offset + 1]) ==
+            0x7f49) {
+          tag5f37Len = read_buf[offset + 2];
+          if (read_buf[offset + 3] != 0x86 || (read_buf[offset + 4] != 65)) {
+            return STATUS_FAILED;
+          }
+        } else {
+          return STATUS_FAILED;
+        }
+        pTranscv_Info->sSendData[4] = tag7f49Off;
+        memcpy(&(pTranscv_Info->sSendData[5]), &read_buf[0], tag7f49Off);
+        pTranscv_Info->sSendlength = tag7f49Off + 5;
+        ALOGD("%s: start transceive for length %d", fn,
+              pTranscv_Info->sSendlength);
+
+        status = LSC_SendtoLsc(Os_info, status, pTranscv_Info, LS_Default);
+        if (status != STATUS_OK) {
+          uint8_t* RecvData = pTranscv_Info->sRecvData;
+          Write_Response_To_OutFile(Os_info, RecvData, resp_len, LS_Cert);
+          return status;
+        }
+
+        pTranscv_Info->sSendData[2] = 0x00;
+        pTranscv_Info->sSendData[4] = u7f49Len + tag5f37Len + 6;
+        memcpy(&(pTranscv_Info->sSendData[5]), &read_buf[tag7f49Off],
+               u7f49Len + tag5f37Len + 6);
+        pTranscv_Info->sSendlength = u7f49Len + tag5f37Len + 11;
+        ALOGD("%s: start transceive for length %d", fn,
+              pTranscv_Info->sSendlength);
+
+        status = LSC_SendtoLsc(Os_info, status, pTranscv_Info, LS_Cert);
+        if (status != STATUS_OK) {
+          return status;
+        } else {
+          ALOGD("Certificate is verified");
+          certf_found = STATUS_OK;
+          return status;
+        }
+      } else {
+        return STATUS_FAILED;
+      }
+    } else {
+      return STATUS_FAILED;
+    }
+  }
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function:        Check_Complete_7F21_Tag
+**
+** Description:     Traverses the 7F21 tag for verification of each sub tag with
+**                  in the 7F21 tag.
+**
+** Returns:         Success if all tags are verified
+**
+*******************************************************************************/
+tLSC_STATUS Check_Complete_7F21_Tag(Lsc_ImageInfo_t* Os_info,
+                                    Lsc_TranscieveInfo_t* pTranscv_Info,
+                                    uint8_t* read_buf, uint16_t* offset) {
+  static const char fn[] = "Check_Complete_7F21_Tag";
+
+  if (STATUS_OK == Check_Certificate_Tag(read_buf, offset)) {
+    if (STATUS_OK == Check_SerialNo_Tag(read_buf, offset)) {
+      if (STATUS_OK == Check_LSRootID_Tag(read_buf, offset)) {
+        if (STATUS_OK == Check_CertHoldID_Tag(read_buf, offset)) {
+          if (STATUS_OK == Check_Date_Tag(read_buf, offset)) {
+            uint8_t tag45Len = 0;
+            if (STATUS_OK == Check_45_Tag(read_buf, offset, &tag45Len)) {
+              if (STATUS_OK == Certificate_Verification(Os_info, pTranscv_Info,
+                                                        read_buf, offset,
+                                                        &tag45Len)) {
+                return STATUS_OK;
+              }
+            } else {
+              ALOGE("%s: FAILED in Check_45_Tag", fn);
+            }
+          } else {
+            ALOGE("%s: FAILED in Check_Date_Tag", fn);
+          }
+        } else {
+          ALOGE("%s: FAILED in Check_CertHoldID_Tag", fn);
+        }
+      } else {
+        ALOGE("%s: FAILED in Check_LSRootID_Tag", fn);
+      }
+    } else {
+      ALOGE("%s: FAILED in Check_SerialNo_Tag", fn);
+    }
+  } else {
+    ALOGE("%s: FAILED in Check_Certificate_Tag", fn);
+  }
+  return STATUS_FAILED;
+}
+
+/*******************************************************************************
+**
+** Function:        LSC_UpdateExeStatus
+**
+** Description:     Updates LSC status to a file
+**
+** Returns:         true if success else false
+**
+*******************************************************************************/
+bool LSC_UpdateExeStatus(uint16_t status) {
+  fLS_STATUS = fopen(LS_STATUS_PATH[gpLsc_Dwnld_Context->mchannel
+  ->getInterfaceInfo()], "w+");
+  ALOGD("enter: LSC_UpdateExeStatus");
+  if (fLS_STATUS == NULL) {
+    ALOGE("Error opening LS Status file for backup: %s", strerror(errno));
+    return false;
+  }
+  if ((fprintf(fLS_STATUS, "%04x", status)) != 4) {
+    ALOGE("Error updating LS Status backup: %s", strerror(errno));
+    fclose(fLS_STATUS);
+    return false;
+  }
+  ALOGD("exit: LSC_UpdateExeStatus");
+  fclose(fLS_STATUS);
+  return true;
+}
+
+/*******************************************************************************
+**
+** Function:        Get_LsStatus
+**
+** Description:     Interface to fetch Loader service client status to JNI,
+*Services
+**
+** Returns:         SUCCESS/FAILURE
+**
+*******************************************************************************/
+tLSC_STATUS Get_LsStatus(uint8_t* pStatus) {
+  tLSC_STATUS status = STATUS_FAILED;
+  uint8_t lsStatus[2] = {0x63, 0x40};
+  uint8_t loopcnt = 0;
+  fLS_STATUS = fopen(LS_STATUS_PATH[gpLsc_Dwnld_Context
+    ->mchannel->getInterfaceInfo()], "r");
+
+  if (fLS_STATUS == NULL) {
+    ALOGE("Error opening LS Status file for backup: %s", strerror(errno));
+    return status;
+  }
+  for (loopcnt = 0; loopcnt < 2; loopcnt++) {
+    if ((FSCANF_BYTE(fLS_STATUS, "%2x", &lsStatus[loopcnt])) == 0) {
+      ALOGE("Error updating LS Status backup: %s", strerror(errno));
+      fclose(fLS_STATUS);
+      return status;
+    }
+  }
+  ALOGD("enter: LSC_getLsStatus 0x%X 0x%X", lsStatus[0], lsStatus[1]);
+  memcpy(pStatus, lsStatus, 2);
+  fclose(fLS_STATUS);
+  return STATUS_OK;
+}
+
+static tLSC_STATUS LSC_Transceive(phNxpLs_data* pCmd, phNxpLs_data* pRsp)
+{
+  bool stat = false;
+  tLSC_STATUS status = STATUS_FAILED;
+  int32_t recvBufferActualSize = 0;
+  IChannel_t *mchannel = gpLsc_Dwnld_Context->mchannel;
+  Lsc_TranscieveInfo_t* pTranscv_Info = &gpLsc_Dwnld_Context->Transcv_Info;
+
+  pTranscv_Info->timeout = gTransceiveTimeout;
+  pTranscv_Info->sSendlength = pCmd->len;
+  pTranscv_Info->sRecvlength = 1024;//(int32_t)sizeof(int32_t);
+  
+  memcpy(pTranscv_Info->sSendData, pCmd->p_data, pTranscv_Info->sSendlength);
+  stat = mchannel->transceive (pTranscv_Info->sSendData,
+          pTranscv_Info->sSendlength,
+          pTranscv_Info->sRecvData,
+          pTranscv_Info->sRecvlength,
+          recvBufferActualSize,
+          pTranscv_Info->timeout);
+  if(stat == true)
+  {
+    pRsp->len = recvBufferActualSize;
+    //memcpy(pRsp->p_data, pTranscv_Info->sRecvData, recvBufferActualSize);
+    pRsp->p_data = pTranscv_Info->sRecvData;
+    status = STATUS_OK;
+  }
+  return status;
+
+}
diff --git a/src/eSEClientIntf.cc b/src/eSEClientIntf.cc
new file mode 100644
index 0000000..aa4bef9
--- /dev/null
+++ b/src/eSEClientIntf.cc
@@ -0,0 +1,286 @@
+/******************************************************************************
+ *
+ *  Copyright 2018 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include "eSEClientIntf.h"
+#include <cutils/log.h>
+#include <dirent.h>
+#include <stdlib.h>
+#include <pthread.h>
+#include <IChannel.h>
+#include <JcDnld.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <phNxpConfig.h>
+#include "phNxpConfig.h"
+#include <android-base/logging.h>
+#include <android-base/stringprintf.h>
+
+#define TERMINAL_LEN  5
+bool nfc_debug_enabled;
+void* performJCOS_Download_thread(void* data);
+IChannel_t Ch;
+static const char *path[3] = {"/vendor/etc/JcopOs_Update1.apdu",
+                             "/vendor/etc/JcopOs_Update2.apdu",
+                             "/vendor/etc/JcopOs_Update3.apdu"};
+
+static const char *uai_path[2] = {"/vendor/etc/cci.jcsh",
+                                  "/vendor/etc/jci.jcsh"};
+static const char *isSystemImgInfo[2] = {"/data/vendor/nfc/jcop_info.txt",
+                                         "/data/vendor/secure_element/jcop_info.txt"};
+static const char *lsUpdateBackupPath =
+"/vendor/etc/loaderservice_updater.txt";
+static const char *isFirstTimeLsUpdate[2] =
+{"/data/vendor/nfc/LS_Status.txt",
+ "/data/vendor/secure_element/LS_Status.txt"};
+se_extns_entry seExtn;
+
+static bool scriptUpdateRequired(ESE_CLIENT_INTF intf);
+static bool jcopOsUpdateRequired(ESE_CLIENT_INTF intf);
+/*******************************************************************************
+**
+** Function:        checkeSEClientUpdateRequired
+**
+** Description:     HAL service entry criteria is verified
+**                  Read the interface and condition for ese Update(JCOP download/LS download)
+**                  from the config file and file path and validate.
+**
+** Returns:         SUCCESS of ok
+**
+*******************************************************************************/
+uint8_t checkeSEClientRequired(ESE_CLIENT_INTF intf ) {
+  uint8_t status = SESTATUS_FAILED;
+  unsigned long int num;
+  bool isApduPresent = true;
+  bool isSystemImgUpdated = false;
+  bool isLsScriptPresent = true;
+  bool isFirstLsUpdate = false;
+  struct stat st;
+
+  LOG(ERROR) <<"Check_HalStart_Entry: enter:  ";
+  /*Check APDU files are present*/
+  for (int num = 0; num < 2; num++)
+  {
+    if (stat(uai_path[num], &st))
+    {
+      isApduPresent = false;
+    }
+  }
+  /*If UAI specific files are present*/
+  if(isApduPresent == true)
+  {
+    for (int num = 0; num < 1; num++)
+    {
+      if (stat(path[num], &st))
+      {
+        isApduPresent = false;
+      }
+    }
+  }
+  /*Check if OS udpate required*/
+  isSystemImgUpdated = jcopOsUpdateRequired(intf);
+
+  /*Check if LS script present*/
+  if(stat(lsUpdateBackupPath, &st))
+  {
+    isLsScriptPresent = false;
+  }
+  /*Check if LS update required*/
+  isFirstLsUpdate = scriptUpdateRequired(intf);
+
+  if(GetNxpNumValue(NAME_NXP_P61_JCOP_DEFAULT_INTERFACE, &num, sizeof(num))) {
+    seExtn.sJcopUpdateIntferface = num;
+  }
+  if(GetNxpNumValue(NAME_NXP_P61_LS_DEFAULT_INTERFACE, &num, sizeof(num))) {
+    seExtn.sLsUpdateIntferface = num;
+  }
+  if(GetNxpNumValue(NAME_NXP_LS_FORCE_UPDATE_REQUIRED, &num, sizeof(num))) {
+    seExtn.isLSUpdateRequired = num;
+  }
+  if(GetNxpNumValue(NAME_NXP_JCOP_FORCE_UPDATE_REQUIRED, &num, sizeof(num))) {
+    seExtn.isJcopUpdateRequired = num;
+  }
+  if(isApduPresent && seExtn.sJcopUpdateIntferface &&
+    ((isSystemImgUpdated && (intf == seExtn.sJcopUpdateIntferface))
+      || seExtn.isJcopUpdateRequired))
+  {
+    LOG(ERROR) <<" Jcop update required  ";
+    seExtn.isJcopUpdateRequired = true;
+  }
+  else
+  {
+    LOG(ERROR) <<"Jcop update not required  ";
+    seExtn.isJcopUpdateRequired = false;
+  }
+
+  if(isLsScriptPresent && seExtn.sLsUpdateIntferface &&
+    (seExtn.isLSUpdateRequired || (isFirstLsUpdate &&
+    (intf == seExtn.sLsUpdateIntferface))))
+  {
+    LOG(ERROR) <<" LS update required  ";
+    seExtn.isLSUpdateRequired = true;
+  }
+  else
+  {
+    LOG(ERROR) <<" LS update not required  ";
+    seExtn.isLSUpdateRequired = false;
+  }
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function:        scriptUpdateRequired
+**
+** Description:     Get SEMS script update required
+**
+** Returns:         TRUE/FALSE
+**
+*******************************************************************************/
+bool scriptUpdateRequired(ESE_CLIENT_INTF intf)
+{
+  bool mScriptUpdateRequired = false;
+  uint32_t status[2] = {SEMS_STATUS_FAILED_SW1, SEMS_STATUS_FAILED_SW2};
+  FILE* fLS_STATUS = fopen(isFirstTimeLsUpdate[intf-1], "r");
+
+  if (fLS_STATUS == NULL) {
+    LOG(ERROR) <<"Error opening status file";
+    mScriptUpdateRequired = true;
+  }
+  else {
+    if ((fscanf(fLS_STATUS, "%2x %2x", &status[0], &status[1])) == 0) {
+      LOG(ERROR) <<"Error reading status file:";
+      status[0] = SEMS_STATUS_FAILED_SW1;
+      status[1] = SEMS_STATUS_FAILED_SW2;
+    }
+    if(status[0] == SEMS_STATUS_SUCCESS_SW1 &&
+                  status[1] == SEMS_STATUS_SUCCESS_SW2) {
+      mScriptUpdateRequired = false;
+      LOG(ERROR) <<"Last script execution success";
+    }
+    else {
+      mScriptUpdateRequired = true;
+      LOG(ERROR) <<"Last script execution failed ";
+    }
+    fclose(fLS_STATUS);
+  }
+  return mScriptUpdateRequired;
+}
+/*******************************************************************************
+**
+** Function:        jcopOsUpdateRequired
+**
+** Description:     Get JCOP update required
+**
+** Returns:         TRUE/FALSE
+**
+*******************************************************************************/
+bool jcopOsUpdateRequired(ESE_CLIENT_INTF intf)
+{
+  bool isUpdateRequired = false;
+  uint32_t status = 0;
+  FILE* fp = fopen(isSystemImgInfo[intf-1], "r");
+
+  if (fp == NULL) {
+    LOG(ERROR) <<"jcopOsUpdateRequired : file not exits for reading";
+    isUpdateRequired = true;
+  }
+  else {
+    if (fscanf(fp, "%u", &status) == 0) {
+      LOG(ERROR) <<"jcop status read fail";
+      isUpdateRequired = true;
+    }
+    else {
+      LOG(ERROR) << "JcopOsState: "<< status;
+      if (status == JCOP_UPDATE_3STEP_DONE) {
+        isUpdateRequired = false;
+        LOG(ERROR) <<"jcopOsUpdateRequired : Jcop update completed";
+      }
+      else {
+        LOG(ERROR) << "jcopOsUpdateRequired : Jcop update required";
+        isUpdateRequired = true;
+      }
+    }
+    fclose(fp);
+  }
+  return isUpdateRequired;
+}
+
+uint8_t getJcopUpdateRequired()
+{
+  return seExtn.isJcopUpdateRequired;
+}
+uint8_t getLsUpdateRequired()
+{
+  return seExtn.isLSUpdateRequired;
+}
+uint8_t getJcopUpdateIntf()
+{
+  return seExtn.sJcopUpdateIntferface;
+}
+uint8_t getLsUpdateIntf()
+{
+  return seExtn.sLsUpdateIntferface;
+}
+
+void setJcopUpdateRequired(uint8_t state)
+{
+  seExtn.isJcopUpdateRequired = state;
+}
+
+void setLsUpdateRequired(uint8_t  state)
+{
+  seExtn.isLSUpdateRequired = state;
+}
+
+bool geteSETerminalId(char* val)
+{
+  bool ret = false;
+
+  if(GetNxpStrValue(NAME_NXP_SPI_SE_TERMINAL_NUM, val, TERMINAL_LEN))
+  {
+    LOG(ERROR) <<"eSETerminalId found";
+    ALOGE("eSETerminalId found val = %s ", val);
+
+    ret = true;
+  }
+  return ret;
+}
+
+bool geteUICCTerminalId(char* val)
+{
+  bool ret = false;
+
+  if(GetNxpStrValue(NAME_NXP_VISO_SE_TERMINAL_NUM, val, TERMINAL_LEN))
+  {
+    ALOGE("eUICCTerminalId found val = %s ", val);
+    ret = true;
+  }
+  return ret;
+}
+
+bool getNfcSeTerminalId(char* val)
+{
+  bool ret = false;
+
+  if(GetNxpStrValue(NAME_NXP_NFC_SE_TERMINAL_NUM, val, TERMINAL_LEN))
+  {
+    ALOGE("NfcSeTerminalId found val = %s ", val);
+    ret = true;
+  }
+  return ret;
+}
diff --git a/src/phNxpLog.cc b/src/phNxpLog.cc
new file mode 100644
index 0000000..c7f211f
--- /dev/null
+++ b/src/phNxpLog.cc
@@ -0,0 +1,260 @@
+/*
+ * Copyright (C) 2010-2014 NXP Semiconductors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#define LOG_TAG "NxpNfcHal"
+#include <stdio.h>
+#include <string.h>
+#if !defined(NXPLOG__H_INCLUDED)
+#include "phNxpConfig.h"
+#include "phNxpLog.h"
+#endif
+#include <cutils/properties.h>
+#include <log/log.h>
+
+const char* NXPLOG_ITEM_EXTNS = "NxpExtns";
+const char* NXPLOG_ITEM_NCIHAL = "NxpHal";
+const char* NXPLOG_ITEM_NCIX = "NxpNciX";
+const char* NXPLOG_ITEM_NCIR = "NxpNciR";
+const char* NXPLOG_ITEM_FWDNLD = "NxpFwDnld";
+const char* NXPLOG_ITEM_TML = "NxpTml";
+
+#ifdef NXP_HCI_REQ
+const char* NXPLOG_ITEM_HCPX = "NxpHcpX";
+const char* NXPLOG_ITEM_HCPR = "NxpHcpR";
+#endif /*NXP_HCI_REQ*/
+
+/* global log level structure */
+nci_log_level_t gLog_level;
+
+extern bool nfc_debug_enabled;
+
+/*******************************************************************************
+ *
+ * Function         phNxpLog_SetGlobalLogLevel
+ *
+ * Description      Sets the global log level for all modules.
+ *                  This value is set by Android property
+ *nfc.nxp_log_level_global.
+ *                  If value can be overridden by module log level.
+ *
+ * Returns          The value of global log level
+ *
+ ******************************************************************************/
+static uint8_t phNxpLog_SetGlobalLogLevel(void) {
+  uint8_t level = NXPLOG_DEFAULT_LOGLEVEL;
+  unsigned long num = 0;
+  char valueStr[PROPERTY_VALUE_MAX] = {0};
+
+  int len = property_get(PROP_NAME_NXPLOG_GLOBAL_LOGLEVEL, valueStr, "");
+  if (len > 0) {
+    /* let Android property override .conf variable */
+    sscanf(valueStr, "%lu", &num);
+    level = (unsigned char)num;
+  }
+  memset(&gLog_level, level, sizeof(nci_log_level_t));
+  return level;
+}
+
+/*******************************************************************************
+ *
+ * Function         phNxpLog_SetHALLogLevel
+ *
+ * Description      Sets the HAL layer log level.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void phNxpLog_SetHALLogLevel(uint8_t level) {
+  unsigned long num = 0;
+  int len;
+  char valueStr[PROPERTY_VALUE_MAX] = {0};
+
+  if (GetNxpNumValue(NAME_NXPLOG_HAL_LOGLEVEL, &num, sizeof(num))) {
+    gLog_level.hal_log_level =
+        (level > (unsigned char)num) ? level : (unsigned char)num;
+    ;
+  }
+
+  len = property_get(PROP_NAME_NXPLOG_HAL_LOGLEVEL, valueStr, "");
+  if (len > 0) {
+    /* let Android property override .conf variable */
+    sscanf(valueStr, "%lu", &num);
+    gLog_level.hal_log_level = (unsigned char)num;
+  }
+}
+
+/*******************************************************************************
+ *
+ * Function         phNxpLog_SetExtnsLogLevel
+ *
+ * Description      Sets the Extensions layer log level.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void phNxpLog_SetExtnsLogLevel(uint8_t level) {
+  unsigned long num = 0;
+  int len;
+  char valueStr[PROPERTY_VALUE_MAX] = {0};
+  if (GetNxpNumValue(NAME_NXPLOG_EXTNS_LOGLEVEL, &num, sizeof(num))) {
+    gLog_level.extns_log_level =
+        (level > (unsigned char)num) ? level : (unsigned char)num;
+    ;
+  }
+
+  len = property_get(PROP_NAME_NXPLOG_EXTNS_LOGLEVEL, valueStr, "");
+  if (len > 0) {
+    /* let Android property override .conf variable */
+    sscanf(valueStr, "%lu", &num);
+    gLog_level.extns_log_level = (unsigned char)num;
+  }
+}
+
+/*******************************************************************************
+ *
+ * Function         phNxpLog_SetTmlLogLevel
+ *
+ * Description      Sets the Tml layer log level.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void phNxpLog_SetTmlLogLevel(uint8_t level) {
+  unsigned long num = 0;
+  int len;
+  char valueStr[PROPERTY_VALUE_MAX] = {0};
+  if (GetNxpNumValue(NAME_NXPLOG_TML_LOGLEVEL, &num, sizeof(num))) {
+    gLog_level.tml_log_level =
+        (level > (unsigned char)num) ? level : (unsigned char)num;
+    ;
+  }
+
+  len = property_get(PROP_NAME_NXPLOG_TML_LOGLEVEL, valueStr, "");
+  if (len > 0) {
+    /* let Android property override .conf variable */
+    sscanf(valueStr, "%lu", &num);
+    gLog_level.tml_log_level = (unsigned char)num;
+  }
+}
+
+/*******************************************************************************
+ *
+ * Function         phNxpLog_SetDnldLogLevel
+ *
+ * Description      Sets the FW download layer log level.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void phNxpLog_SetDnldLogLevel(uint8_t level) {
+  unsigned long num = 0;
+  int len;
+  char valueStr[PROPERTY_VALUE_MAX] = {0};
+  if (GetNxpNumValue(NAME_NXPLOG_FWDNLD_LOGLEVEL, &num, sizeof(num))) {
+    gLog_level.dnld_log_level =
+        (level > (unsigned char)num) ? level : (unsigned char)num;
+    ;
+  }
+
+  len = property_get(PROP_NAME_NXPLOG_FWDNLD_LOGLEVEL, valueStr, "");
+  if (len > 0) {
+    /* let Android property override .conf variable */
+    sscanf(valueStr, "%lu", &num);
+    gLog_level.dnld_log_level = (unsigned char)num;
+  }
+}
+
+/*******************************************************************************
+ *
+ * Function         phNxpLog_SetNciTxLogLevel
+ *
+ * Description      Sets the NCI transaction layer log level.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void phNxpLog_SetNciTxLogLevel(uint8_t level) {
+  unsigned long num = 0;
+  int len;
+  char valueStr[PROPERTY_VALUE_MAX] = {0};
+  if (GetNxpNumValue(NAME_NXPLOG_NCIX_LOGLEVEL, &num, sizeof(num))) {
+    gLog_level.ncix_log_level =
+        (level > (unsigned char)num) ? level : (unsigned char)num;
+  }
+  if (GetNxpNumValue(NAME_NXPLOG_NCIR_LOGLEVEL, &num, sizeof(num))) {
+    gLog_level.ncir_log_level =
+        (level > (unsigned char)num) ? level : (unsigned char)num;
+    ;
+  }
+
+  len = property_get(PROP_NAME_NXPLOG_NCI_LOGLEVEL, valueStr, "");
+  if (len > 0) {
+    /* let Android property override .conf variable */
+    sscanf(valueStr, "%lu", &num);
+    gLog_level.ncix_log_level = (unsigned char)num;
+    gLog_level.ncir_log_level = (unsigned char)num;
+  }
+}
+
+/******************************************************************************
+ * Function         phNxpLog_InitializeLogLevel
+ *
+ * Description      Initialize and get log level of module from libnfc-nxp.conf
+ *or
+ *                  Android runtime properties.
+ *                  The Android property nfc.nxp_global_log_level is to
+ *                  define log level for all modules. Modules log level will
+ *overwide global level.
+ *                  The Android property will overwide the level
+ *                  in libnfc-nxp.conf
+ *
+ *                  Android property names:
+ *                      nfc.nxp_log_level_global    * defines log level for all
+ *modules
+ *                      nfc.nxp_log_level_extns     * extensions module log
+ *                      nfc.nxp_log_level_hal       * Hal module log
+ *                      nfc.nxp_log_level_dnld      * firmware download module
+ *log
+ *                      nfc.nxp_log_level_tml       * TML module log
+ *                      nfc.nxp_log_level_nci       * NCI transaction log
+ *
+ *                  Log Level values:
+ *                      NXPLOG_LOG_SILENT_LOGLEVEL  0        * No trace to show
+ *                      NXPLOG_LOG_ERROR_LOGLEVEL   1        * Show Error trace
+ *only
+ *                      NXPLOG_LOG_WARN_LOGLEVEL    2        * Show Warning
+ *trace and Error trace
+ *                      NXPLOG_LOG_DEBUG_LOGLEVEL   3        * Show all traces
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+void phNxpLog_InitializeLogLevel(void) {
+  uint8_t level = phNxpLog_SetGlobalLogLevel();
+  phNxpLog_SetHALLogLevel(level);
+  phNxpLog_SetExtnsLogLevel(level);
+  phNxpLog_SetTmlLogLevel(level);
+  phNxpLog_SetDnldLogLevel(level);
+  phNxpLog_SetNciTxLogLevel(level);
+
+  ALOGD_IF(nfc_debug_enabled,
+      "%s: global =%u, Fwdnld =%u, extns =%u, \
+                hal =%u, tml =%u, ncir =%u, \
+                ncix =%u",
+      __func__, gLog_level.global_log_level, gLog_level.dnld_log_level,
+      gLog_level.extns_log_level, gLog_level.hal_log_level,
+      gLog_level.tml_log_level, gLog_level.ncir_log_level,
+      gLog_level.ncix_log_level);
+}
diff --git a/utils/phNxpConfig.cc b/utils/phNxpConfig.cc
new file mode 100644
index 0000000..d212479
--- /dev/null
+++ b/utils/phNxpConfig.cc
@@ -0,0 +1,1089 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2011-2012 Broadcom Corporation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ *  The original Work has been changed by NXP Semiconductors.
+ *
+ *  Copyright (C) 2013-2018 NXP Semiconductors
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include <stdio.h>
+#include <sys/stat.h>
+#include <list>
+#include <string>
+#include <vector>
+#include <log/log.h>
+
+#include <phNxpConfig.h>
+#include <phNxpLog.h>
+#include "sparse_crc32.h"
+#if GENERIC_TARGET
+const char alternative_config_path[] = "/data/vendor/nfc/";
+#else
+const char alternative_config_path[] = "";
+#endif
+
+#if 1
+const char* transport_config_paths[] = {"/odm/etc/", "/vendor/etc/", "/etc/"};
+#else
+const char* transport_config_paths[] = {"res/"};
+#endif
+const int transport_config_path_size =
+    (sizeof(transport_config_paths) / sizeof(transport_config_paths[0]));
+
+#define config_name "libnfc-nxp.conf"
+#define extra_config_base "libnfc-"
+#define extra_config_ext ".conf"
+#define IsStringValue 0x80000000
+
+const char rf_config_timestamp_path[] =
+        "/data/vendor/nfc/libnfc-nxpRFConfigState.bin";
+const char tr_config_timestamp_path[] =
+    "/data/vendor/nfc/libnfc-nxpTransitConfigState.bin";
+const char config_timestamp_path[] =
+        "/data/vendor/nfc/libnfc-nxpConfigState.bin";
+/*const char default_nxp_config_path[] =
+        "/vendor/etc/libnfc-nxp.conf";*/
+const char nxp_rf_config_path[] =
+        "/system/vendor/libnfc-nxp_RF.conf";
+const char transit_config_path[] = "/data/vendor/nfc/libnfc-nxpTransit.conf";
+void readOptionalConfig(const char* optional);
+
+namespace {
+
+size_t readConfigFile(const char* fileName, uint8_t** p_data) {
+  FILE* fd = fopen(fileName, "rb");
+  if (fd == nullptr) return 0;
+
+  fseek(fd, 0L, SEEK_END);
+  const size_t file_size = ftell(fd);
+  rewind(fd);
+
+  uint8_t* buffer = new uint8_t[file_size];
+  size_t read = fread(buffer, file_size, 1, fd);
+  fclose(fd);
+
+  if (read == 1) {
+    *p_data = buffer;
+    return file_size;
+  }
+
+  delete[] buffer;
+  return 0;
+}
+
+}  // namespace
+
+using namespace ::std;
+
+class CNfcParam : public string {
+ public:
+  CNfcParam();
+  CNfcParam(const char* name, const string& value);
+  CNfcParam(const char* name, unsigned long value);
+  virtual ~CNfcParam();
+  unsigned long numValue() const { return m_numValue; }
+  const char* str_value() const { return m_str_value.c_str(); }
+  size_t str_len() const { return m_str_value.length(); }
+
+ private:
+  string m_str_value;
+  unsigned long m_numValue;
+};
+
+class CNfcConfig : public vector<const CNfcParam*> {
+ public:
+  virtual ~CNfcConfig();
+  static CNfcConfig& GetInstance();
+  friend void readOptionalConfig(const char* optional);
+  bool isModified();
+  void resetModified();
+  int updateTimestamp();
+  int checkTimestamp(const char* fileName, const char* fileTimeStamp);
+
+  bool getValue(const char* name, char* pValue, size_t len) const;
+  bool getValue(const char* name, unsigned long& rValue) const;
+  bool getValue(const char* name, unsigned short& rValue) const;
+  bool getValue(const char* name, char* pValue, long len, long* readlen) const;
+  const CNfcParam* find(const char* p_name) const;
+  void readNxpTransitConfig(const char* fileName) const;
+  void readNxpRFConfig(const char* fileName) const;
+  void clean();
+
+ private:
+  CNfcConfig();
+  bool readConfig(const char* name, bool bResetContent);
+  void moveFromList();
+  void moveToList();
+  void add(const CNfcParam* pParam);
+  void dump();
+  bool isAllowed(const char* name);
+  list<const CNfcParam*> m_list;
+  bool mValidFile;
+  uint32_t config_crc32_;
+  unsigned long m_timeStamp;
+  unsigned long m_timeStampRF;
+  unsigned long m_timeStampTransit;
+  string mCurrentFile;
+
+  unsigned long state;
+
+  inline bool Is(unsigned long f) { return (state & f) == f; }
+  inline void Set(unsigned long f) { state |= f; }
+  inline void Reset(unsigned long f) { state &= ~f; }
+};
+
+/*******************************************************************************
+**
+** Function:    isPrintable()
+**
+** Description: determine if 'c' is printable
+**
+** Returns:     1, if printable, otherwise 0
+**
+*******************************************************************************/
+inline bool isPrintable(char c) {
+  return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') ||
+         (c >= '0' && c <= '9') || c == '/' || c == '_' || c == '-' || c == '.';
+}
+
+/*******************************************************************************
+**
+** Function:    isDigit()
+**
+** Description: determine if 'c' is numeral digit
+**
+** Returns:     true, if numerical digit
+**
+*******************************************************************************/
+inline bool isDigit(char c, int base) {
+  if ('0' <= c && c <= '9') return true;
+  if (base == 16) {
+    if (('A' <= c && c <= 'F') || ('a' <= c && c <= 'f')) return true;
+  }
+  return false;
+}
+
+/*******************************************************************************
+**
+** Function:    getDigitValue()
+**
+** Description: return numerical value of a decimal or hex char
+**
+** Returns:     numerical value if decimal or hex char, otherwise 0
+**
+*******************************************************************************/
+inline int getDigitValue(char c, int base) {
+  if ('0' <= c && c <= '9') return c - '0';
+  if (base == 16) {
+    if ('A' <= c && c <= 'F')
+      return c - 'A' + 10;
+    else if ('a' <= c && c <= 'f')
+      return c - 'a' + 10;
+  }
+  return 0;
+}
+
+/*******************************************************************************
+**
+** Function:    findConfigFilePathFromTransportConfigPaths()
+**
+** Description: find a config file path with a given config name from transport
+**              config paths
+**
+** Returns:     none
+**
+*******************************************************************************/
+void findConfigFilePathFromTransportConfigPaths(const string& configName,
+                                                string& filePath) {
+  for (int i = 0; i < transport_config_path_size - 1; i++) {
+    filePath.assign(transport_config_paths[i]);
+    filePath += configName;
+    struct stat file_stat;
+    if (stat(filePath.c_str(), &file_stat) == 0 && S_ISREG(file_stat.st_mode)) {
+      return;
+    }
+  }
+  filePath.assign(transport_config_paths[transport_config_path_size - 1]);
+  filePath += configName;
+}
+
+/*******************************************************************************
+**
+** Function:    CNfcConfig::readConfig()
+**
+** Description: read Config settings and parse them into a linked list
+**              move the element from linked list to a array at the end
+**
+** Returns:     1, if there are any config data, 0 otherwise
+**
+*******************************************************************************/
+bool CNfcConfig::readConfig(const char* name, bool bResetContent) {
+  enum {
+    BEGIN_LINE = 1,
+    TOKEN,
+    STR_VALUE,
+    NUM_VALUE,
+    BEGIN_HEX,
+    BEGIN_QUOTE,
+    END_LINE
+  };
+
+  uint8_t* p_config = nullptr;
+  size_t config_size = readConfigFile(name, &p_config);
+  if (p_config == nullptr) {
+    ALOGE("%s Cannot open config file %s\n", __func__, name);
+    if (bResetContent) {
+      ALOGE("%s Using default value for all settings\n", __func__);
+      mValidFile = false;
+    }
+    return false;
+  }
+
+  string token;
+  string strValue;
+  unsigned long numValue = 0;
+  CNfcParam* pParam = NULL;
+  int i = 0;
+  int base = 0;
+  char c;
+  int bflag = 0;
+  state = BEGIN_LINE;
+
+  config_crc32_ = sparse_crc32(0, (const void*)p_config, (int)config_size);
+  mValidFile = true;
+  if (size() > 0) {
+    if (bResetContent)
+      clean();
+    else
+      moveToList();
+  }
+
+  for (size_t offset = 0; offset != config_size; ++offset) {
+    c = p_config[offset];
+    switch (state & 0xff) {
+      case BEGIN_LINE:
+        if (c == '#')
+          state = END_LINE;
+        else if (isPrintable(c)) {
+          i = 0;
+          token.erase();
+          strValue.erase();
+          state = TOKEN;
+          token.push_back(c);
+        }
+        break;
+      case TOKEN:
+        if (c == '=') {
+          token.push_back('\0');
+          state = BEGIN_QUOTE;
+        } else if (isPrintable(c))
+          token.push_back(c);
+        else
+          state = END_LINE;
+        break;
+      case BEGIN_QUOTE:
+        if (c == '"') {
+          state = STR_VALUE;
+          base = 0;
+        } else if (c == '0')
+          state = BEGIN_HEX;
+        else if (isDigit(c, 10)) {
+          state = NUM_VALUE;
+          base = 10;
+          numValue = getDigitValue(c, base);
+          i = 0;
+        } else if (c == '{') {
+          state = NUM_VALUE;
+          bflag = 1;
+          base = 16;
+          i = 0;
+          Set(IsStringValue);
+        } else
+          state = END_LINE;
+        break;
+      case BEGIN_HEX:
+        if (c == 'x' || c == 'X') {
+          state = NUM_VALUE;
+          base = 16;
+          numValue = 0;
+          i = 0;
+          break;
+        } else if (isDigit(c, 10)) {
+          state = NUM_VALUE;
+          base = 10;
+          numValue = getDigitValue(c, base);
+          break;
+        } else if (c != '\n' && c != '\r') {
+          state = END_LINE;
+          break;
+        }
+      // fall through to numValue to handle numValue
+
+      case NUM_VALUE:
+        if (isDigit(c, base)) {
+          numValue *= base;
+          numValue += getDigitValue(c, base);
+          ++i;
+        } else if (bflag == 1 &&
+                   (c == ' ' || c == '\r' || c == '\n' || c == '\t')) {
+          break;
+        } else if (base == 16 &&
+                   (c == ',' || c == ':' || c == '-' || c == ' ' || c == '}')) {
+          if (c == '}') {
+            bflag = 0;
+          }
+          if (i > 0) {
+            int n = (i + 1) / 2;
+            while (n-- > 0) {
+              numValue = numValue >> (n * 8);
+              unsigned char c = (numValue)&0xFF;
+              strValue.push_back(c);
+            }
+          }
+
+          Set(IsStringValue);
+          numValue = 0;
+          i = 0;
+        } else {
+          if (c == '\n' || c == '\r') {
+            if (bflag == 0) {
+              state = BEGIN_LINE;
+            }
+          } else {
+            if (bflag == 0) {
+              state = END_LINE;
+            }
+          }
+          if (Is(IsStringValue) && base == 16 && i > 0) {
+            int n = (i + 1) / 2;
+            while (n-- > 0) strValue.push_back(((numValue >> (n * 8)) & 0xFF));
+          }
+          if (strValue.length() > 0)
+            pParam = new CNfcParam(token.c_str(), strValue);
+          else
+            pParam = new CNfcParam(token.c_str(), numValue);
+          add(pParam);
+          strValue.erase();
+          numValue = 0;
+        }
+        break;
+      case STR_VALUE:
+        if (c == '"') {
+          strValue.push_back('\0');
+          state = END_LINE;
+          pParam = new CNfcParam(token.c_str(), strValue);
+          add(pParam);
+        } else if (isPrintable(c))
+          strValue.push_back(c);
+        break;
+      case END_LINE:
+        if (c == '\n' || c == '\r') state = BEGIN_LINE;
+        break;
+      default:
+        break;
+    }
+  }
+
+  delete[] p_config;
+
+  moveFromList();
+  return size() > 0;
+}
+
+/*******************************************************************************
+**
+** Function:    CNfcConfig::CNfcConfig()
+**
+** Description: class constructor
+**
+** Returns:     none
+**
+*******************************************************************************/
+CNfcConfig::CNfcConfig()
+    : mValidFile(true),
+      m_timeStamp(0),
+      m_timeStampRF(0),
+      m_timeStampTransit(0),
+      state(0) {}
+
+/*******************************************************************************
+**
+** Function:    CNfcConfig::~CNfcConfig()
+**
+** Description: class destructor
+**
+** Returns:     none
+**
+*******************************************************************************/
+CNfcConfig::~CNfcConfig() {}
+
+/*******************************************************************************
+**
+** Function:    CNfcConfig::GetInstance()
+**
+** Description: get class singleton object
+**
+** Returns:     none
+**
+*******************************************************************************/
+CNfcConfig& CNfcConfig::GetInstance() {
+  static CNfcConfig theInstance;
+
+  if (theInstance.size() == 0 && theInstance.mValidFile) {
+    string strPath;
+    if (alternative_config_path[0] != '\0') {
+      strPath.assign(alternative_config_path);
+      strPath += config_name;
+      theInstance.readConfig(strPath.c_str(), true);
+      if (!theInstance.empty()) {
+        return theInstance;
+      }
+    }
+    findConfigFilePathFromTransportConfigPaths(config_name, strPath);
+    theInstance.readConfig(strPath.c_str(), true);
+#if (NXP_EXTNS == TRUE)
+    readOptionalConfig("brcm");
+    theInstance.readNxpTransitConfig(transit_config_path);
+    theInstance.readNxpRFConfig(nxp_rf_config_path);
+#endif
+  }
+
+  return theInstance;
+}
+
+/*******************************************************************************
+**
+** Function:    CNfcConfig::getValue()
+**
+** Description: get a string value of a setting
+**
+** Returns:     true if setting exists
+**              false if setting does not exist
+**
+*******************************************************************************/
+bool CNfcConfig::getValue(const char* name, char* pValue, size_t len) const {
+  const CNfcParam* pParam = find(name);
+  if (pParam == NULL) return false;
+
+  if (pParam->str_len() > 0) {
+    memset(pValue, 0, len);
+    memcpy(pValue, pParam->str_value(), pParam->str_len());
+    return true;
+  }
+  return false;
+}
+
+bool CNfcConfig::getValue(const char* name, char* pValue, long len,
+                          long* readlen) const {
+  const CNfcParam* pParam = find(name);
+  if (pParam == NULL) return false;
+
+  if (pParam->str_len() > 0) {
+    if (pParam->str_len() <= (unsigned long)len) {
+      memset(pValue, 0, len);
+      memcpy(pValue, pParam->str_value(), pParam->str_len());
+      *readlen = pParam->str_len();
+    } else {
+      *readlen = -1;
+    }
+
+    return true;
+  }
+  return false;
+}
+
+/*******************************************************************************
+**
+** Function:    CNfcConfig::getValue()
+**
+** Description: get a long numerical value of a setting
+**
+** Returns:     true if setting exists
+**              false if setting does not exist
+**
+*******************************************************************************/
+bool CNfcConfig::getValue(const char* name, unsigned long& rValue) const {
+  const CNfcParam* pParam = find(name);
+  if (pParam == NULL) return false;
+
+  if (pParam->str_len() == 0) {
+    rValue = static_cast<unsigned long>(pParam->numValue());
+    return true;
+  }
+  return false;
+}
+
+/*******************************************************************************
+**
+** Function:    CNfcConfig::getValue()
+**
+** Description: get a short numerical value of a setting
+**
+** Returns:     true if setting exists
+**              false if setting does not exist
+**
+*******************************************************************************/
+bool CNfcConfig::getValue(const char* name, unsigned short& rValue) const {
+  const CNfcParam* pParam = find(name);
+  if (pParam == NULL) return false;
+
+  if (pParam->str_len() == 0) {
+    rValue = static_cast<unsigned short>(pParam->numValue());
+    return true;
+  }
+  return false;
+}
+
+/*******************************************************************************
+**
+** Function:    CNfcConfig::find()
+**
+** Description: search if a setting exist in the setting array
+**
+** Returns:     pointer to the setting object
+**
+*******************************************************************************/
+const CNfcParam* CNfcConfig::find(const char* p_name) const {
+  if (size() == 0) return NULL;
+
+  for (const_iterator it = begin(), itEnd = end(); it != itEnd; ++it) {
+    if (**it < p_name) {
+      continue;
+    } else if (**it == p_name) {
+      if ((*it)->str_len() > 0) {
+        NXPLOG_EXTNS_D("%s found %s=%s\n", __func__, p_name,
+                       (*it)->str_value());
+      } else {
+        NXPLOG_EXTNS_D("%s found %s=(0x%lx)\n", __func__, p_name,
+                       (*it)->numValue());
+      }
+      return *it;
+    } else
+      break;
+  }
+  return NULL;
+}
+
+/*******************************************************************************
+**
+** Function:    CNfcConfig::readNxpTransitConfig()
+**
+** Description: read Config settings from transit conf file
+**
+** Returns:     none
+**
+*******************************************************************************/
+void CNfcConfig::readNxpTransitConfig(const char* fileName) const {
+  ALOGD("readNxpTransitConfig-Enter..Reading %s", fileName);
+  CNfcConfig::GetInstance().readConfig(fileName, false);
+}
+
+/*******************************************************************************
+**
+** Function:    CNfcConfig::readNxpRFConfig()
+**
+** Description: read Config settings from RF conf file
+**
+** Returns:     none
+**
+*******************************************************************************/
+void CNfcConfig::readNxpRFConfig(const char* fileName) const {
+  ALOGD("readNxpRFConfig-Enter..Reading %s", fileName);
+  CNfcConfig::GetInstance().readConfig(fileName, false);
+}
+
+/*******************************************************************************
+**
+** Function:    CNfcConfig::clean()
+**
+** Description: reset the setting array
+**
+** Returns:     none
+**
+*******************************************************************************/
+void CNfcConfig::clean() {
+  if (size() == 0) return;
+
+  for (iterator it = begin(), itEnd = end(); it != itEnd; ++it) delete *it;
+  clear();
+}
+
+/*******************************************************************************
+**
+** Function:    CNfcConfig::Add()
+**
+** Description: add a setting object to the list
+**
+** Returns:     none
+**
+*******************************************************************************/
+void CNfcConfig::add(const CNfcParam* pParam) {
+  if (m_list.size() == 0) {
+    m_list.push_back(pParam);
+    return;
+  }
+  if ((mCurrentFile.find("nxpTransit") != std::string::npos) &&
+      !isAllowed(pParam->c_str())) {
+    ALOGD("%s Token restricted. Returning", __func__);
+    return;
+  }
+  for (list<const CNfcParam*>::iterator it = m_list.begin(),
+                                        itEnd = m_list.end();
+       it != itEnd; ++it) {
+    if (**it < pParam->c_str()) continue;
+    if (**it == pParam->c_str())
+      m_list.insert(m_list.erase(it), pParam);
+    else
+      m_list.insert(it, pParam);
+
+    return;
+  }
+  m_list.push_back(pParam);
+}
+/*******************************************************************************
+**
+** Function:    CNfcConfig::dump()
+**
+** Description: prints all elements in the list
+**
+** Returns:     none
+**
+*******************************************************************************/
+void CNfcConfig::dump() {
+  ALOGD("%s Enter", __func__);
+
+  for (list<const CNfcParam*>::iterator it = m_list.begin(),
+                                        itEnd = m_list.end();
+       it != itEnd; ++it) {
+    if ((*it)->str_len() > 0)
+      ALOGD("%s %s \t= %s", __func__, (*it)->c_str(), (*it)->str_value());
+    else
+      ALOGD("%s %s \t= (0x%0lX)\n", __func__, (*it)->c_str(),
+            (*it)->numValue());
+  }
+}
+/*******************************************************************************
+**
+** Function:    CNfcConfig::isAllowed()
+**
+** Description: checks if token update is allowed
+**
+** Returns:     true if allowed else false
+**
+*******************************************************************************/
+bool CNfcConfig::isAllowed(const char* name) {
+  string token(name);
+  bool stat = false;
+  if ((token.find("P2P_LISTEN_TECH_MASK") != std::string::npos) ||
+      (token.find("HOST_LISTEN_TECH_MASK") != std::string::npos) ||
+      (token.find("UICC_LISTEN_TECH_MASK") != std::string::npos) ||
+      (token.find("NXP_ESE_LISTEN_TECH_MASK") != std::string::npos) ||
+      (token.find("POLLING_TECH_MASK") != std::string::npos) ||
+      (token.find("NXP_RF_CONF_BLK") != std::string::npos) ||
+      (token.find("NXP_CN_TRANSIT_BLK_NUM_CHECK_ENABLE") !=
+       std::string::npos) ||
+      (token.find("NXP_FWD_FUNCTIONALITY_ENABLE") != std::string::npos))
+
+  {
+    stat = true;
+  }
+  return stat;
+}
+/*******************************************************************************
+**
+** Function:    CNfcConfig::moveFromList()
+**
+** Description: move the setting object from list to array
+**
+** Returns:     none
+**
+*******************************************************************************/
+void CNfcConfig::moveFromList() {
+  if (m_list.size() == 0) return;
+
+  for (list<const CNfcParam *>::iterator it = m_list.begin(),
+                                         itEnd = m_list.end();
+       it != itEnd; ++it)
+    push_back(*it);
+  m_list.clear();
+}
+
+/*******************************************************************************
+**
+** Function:    CNfcConfig::moveToList()
+**
+** Description: move the setting object from array to list
+**
+** Returns:     none
+**
+*******************************************************************************/
+void CNfcConfig::moveToList() {
+  if (m_list.size() != 0) m_list.clear();
+
+  for (iterator it = begin(), itEnd = end(); it != itEnd; ++it)
+    m_list.push_back(*it);
+  clear();
+}
+/*******************************************************************************
+**
+** Function:    CNfcConfig::checkTimestamp(const char* fileName,const char*
+*fileNameTime)
+**
+** Description: check if config file has modified
+**
+** Returns:     0 if not modified, 1 otherwise.
+**
+*******************************************************************************/
+int CNfcConfig::checkTimestamp(const char* fileName, const char* fileNameTime) {
+  FILE* fd;
+  struct stat st;
+  unsigned long value = 0, timeStamp = 0;
+  int ret = 0;
+  if (strcmp(config_timestamp_path, fileNameTime) == 0) {
+    timeStamp = m_timeStamp;
+  } else if (strcmp(rf_config_timestamp_path, fileNameTime) == 0) {
+    timeStamp = m_timeStampRF;
+  } else if (strcmp(tr_config_timestamp_path, fileNameTime) == 0) {
+    timeStamp = m_timeStampTransit;
+  } else
+    ALOGD("Invalid file \n");
+
+  if (stat(fileNameTime, &st) != 0) {
+    ALOGD("%s file not exist.\n", __func__);
+    if ((fd = fopen(fileNameTime, "w+")) != NULL) {
+      fwrite(&timeStamp, sizeof(unsigned long), 1, fd);
+      fclose(fd);
+    }
+    return 1;
+  } else {
+    fd = fopen(fileNameTime, "r+");
+    if (fd == NULL) {
+      ALOGE("%s Cannot open file %s\n", __func__, fileName);
+      return 1;
+    }
+    fread(&value, sizeof(unsigned long), 1, fd);
+    ret = (value != timeStamp) ? 1 : 0;
+    if (ret) {
+      ALOGD("Config File Modified Update timestamp");
+      fseek(fd, 0, SEEK_SET);
+      fwrite(&timeStamp, sizeof(unsigned long), 1, fd);
+    }
+    fclose(fd);
+  }
+  return ret;
+}
+/*******************************************************************************
+**
+** Function:    CNfcConfig::updateTimestamp()
+**
+** Description: update if config file has modified
+**
+** Returns:     0 if not modified, 1 otherwise.
+**
+*******************************************************************************/
+int CNfcConfig::updateTimestamp() {
+  FILE* fd;
+  struct stat st;
+  unsigned long value = 0;
+  int ret = 0;
+
+  if (stat(config_timestamp_path, &st) != 0) {
+    ALOGD("%s file %s not exist, creat it.\n", __func__, config_timestamp_path);
+    fd = fopen(config_timestamp_path, "w+");
+    if (fd != NULL) {
+      fwrite(&m_timeStamp, sizeof(unsigned long), 1, fd);
+      fclose(fd);
+    }
+    return 1;
+  } else {
+    fd = fopen(config_timestamp_path, "r+");
+    if (fd == NULL) {
+      ALOGE("%s Cannot open file %s\n", __func__, config_timestamp_path);
+      return 1;
+    }
+
+    fread(&value, sizeof(unsigned long), 1, fd);
+    ret = (value != m_timeStamp);
+    if (ret) {
+      fseek(fd, 0, SEEK_SET);
+      fwrite(&m_timeStamp, sizeof(unsigned long), 1, fd);
+    }
+    fclose(fd);
+  }
+  return ret;
+}
+
+bool CNfcConfig::isModified() {
+  FILE* fd = fopen(config_timestamp_path, "r+");
+  if (fd == nullptr) {
+    ALOGE("%s Unable to open file '%s' - assuming modified", __func__,
+          config_timestamp_path);
+    return true;
+  }
+
+  uint32_t stored_crc32 = 0;
+  fread(&stored_crc32, sizeof(uint32_t), 1, fd);
+  fclose(fd);
+
+  return stored_crc32 != config_crc32_;
+}
+
+void CNfcConfig::resetModified() {
+  FILE* fd = fopen(config_timestamp_path, "w+");
+  if (fd == nullptr) {
+    ALOGE("%s Unable to open file '%s' for writing", __func__,
+          config_timestamp_path);
+    return;
+  }
+
+  fwrite(&config_crc32_, sizeof(uint32_t), 1, fd);
+  fclose(fd);
+}
+
+/*******************************************************************************
+**
+** Function:    CNfcParam::CNfcParam()
+**
+** Description: class constructor
+**
+** Returns:     none
+**
+*******************************************************************************/
+CNfcParam::CNfcParam() : m_numValue(0) {}
+
+/*******************************************************************************
+**
+** Function:    CNfcParam::~CNfcParam()
+**
+** Description: class destructor
+**
+** Returns:     none
+**
+*******************************************************************************/
+CNfcParam::~CNfcParam() {}
+
+/*******************************************************************************
+**
+** Function:    CNfcParam::CNfcParam()
+**
+** Description: class copy constructor
+**
+** Returns:     none
+**
+*******************************************************************************/
+CNfcParam::CNfcParam(const char* name, const string& value)
+    : string(name), m_str_value(value), m_numValue(0) {}
+
+/*******************************************************************************
+**
+** Function:    CNfcParam::CNfcParam()
+**
+** Description: class copy constructor
+**
+** Returns:     none
+**
+*******************************************************************************/
+CNfcParam::CNfcParam(const char* name, unsigned long value)
+    : string(name), m_numValue(value) {}
+
+/*******************************************************************************
+**
+** Function:    readOptionalConfig()
+**
+** Description: read Config settings from an optional conf file
+**
+** Returns:     none
+**
+*******************************************************************************/
+void readOptionalConfig(const char* extra) {
+  string strPath;
+  string configName(extra_config_base);
+  configName += extra;
+  configName += extra_config_ext;
+
+  if (alternative_config_path[0] != '\0') {
+    strPath.assign(alternative_config_path);
+    strPath += configName;
+  } else {
+    findConfigFilePathFromTransportConfigPaths(configName, strPath);
+  }
+
+  CNfcConfig::GetInstance().readConfig(strPath.c_str(), false);
+}
+
+/*******************************************************************************
+**
+** Function:    GetStrValue
+**
+** Description: API function for getting a string value of a setting
+**
+** Returns:     True if found, otherwise False.
+**
+*******************************************************************************/
+extern "C" int GetNxpStrValue(const char* name, char* pValue,
+                              unsigned long len) {
+  CNfcConfig& rConfig = CNfcConfig::GetInstance();
+
+  return rConfig.getValue(name, pValue, len);
+}
+
+/*******************************************************************************
+**
+** Function:    GetByteArrayValue()
+**
+** Description: Read byte array value from the config file.
+**
+** Parameters:
+**              name - name of the config param to read.
+**              pValue  - pointer to input buffer.
+**              bufflen - input buffer length.
+**              len - out parameter to return the number of bytes read from
+**                    config file, return -1 in case bufflen is not enough.
+**
+** Returns:     TRUE[1] if config param name is found in the config file, else
+**              FALSE[0]
+**
+*******************************************************************************/
+extern "C" int GetNxpByteArrayValue(const char* name, char* pValue,
+                                    long bufflen, long* len) {
+  CNfcConfig& rConfig = CNfcConfig::GetInstance();
+
+  return rConfig.getValue(name, pValue, bufflen, len);
+}
+
+/*******************************************************************************
+**
+** Function:    GetNumValue
+**
+** Description: API function for getting a numerical value of a setting
+**
+** Returns:     true, if successful
+**
+*******************************************************************************/
+extern "C" int GetNxpNumValue(const char* name, void* pValue,
+                              unsigned long len) {
+  if (!pValue) return false;
+
+  CNfcConfig& rConfig = CNfcConfig::GetInstance();
+  const CNfcParam* pParam = rConfig.find(name);
+
+  if (pParam == NULL) return false;
+  unsigned long v = pParam->numValue();
+  if (v == 0 && pParam->str_len() > 0 && pParam->str_len() < 4) {
+    const unsigned char* p = (const unsigned char*)pParam->str_value();
+    for (unsigned int i = 0; i < pParam->str_len(); ++i) {
+      v *= 256;
+      v += *p++;
+    }
+  }
+  switch (len) {
+    case sizeof(unsigned long):
+      *(static_cast<unsigned long*>(pValue)) = (unsigned long)v;
+      break;
+    case sizeof(unsigned short):
+      *(static_cast<unsigned short*>(pValue)) = (unsigned short)v;
+      break;
+    case sizeof(unsigned char):
+      *(static_cast<unsigned char*>(pValue)) = (unsigned char)v;
+      break;
+    default:
+      return false;
+  }
+  return true;
+}
+
+/*******************************************************************************
+**
+** Function:    resetConfig
+**
+** Description: reset settings array
+**
+** Returns:     none
+**
+*******************************************************************************/
+extern "C" void resetNxpConfig()
+
+{
+  CNfcConfig& rConfig = CNfcConfig::GetInstance();
+
+  rConfig.clean();
+}
+
+/*******************************************************************************
+**
+** Function:    isNxpConfigModified()
+**
+** Description: check if config file has modified
+**
+** Returns:     0 if not modified, 1 otherwise.
+**
+*******************************************************************************/
+extern "C" int isNxpConfigModified() {
+  CNfcConfig& rConfig = CNfcConfig::GetInstance();
+  return rConfig.isModified();
+}
+
+/*******************************************************************************
+**
+** Function:    isNxpRFConfigModified()
+**
+** Description: check if config file has modified
+**
+** Returns:     0 if not modified, 1 otherwise.
+**
+*******************************************************************************/
+extern "C" int isNxpRFConfigModified() {
+  int retRF = 0, rettransit = 0, ret = 0;
+  CNfcConfig& rConfig = CNfcConfig::GetInstance();
+  retRF = rConfig.checkTimestamp(nxp_rf_config_path, rf_config_timestamp_path);
+  rettransit =
+      rConfig.checkTimestamp(transit_config_path, tr_config_timestamp_path);
+  ret = retRF | rettransit;
+  ALOGD("ret RF or Transit value %d", ret);
+  return ret;
+}
+
+/*******************************************************************************
+**
+** Function:    updateNxpConfigTimestamp()
+**
+** Description: update if config file has modified
+**
+** Returns:     0 if not modified, 1 otherwise.
+**
+*******************************************************************************/
+extern "C" int updateNxpConfigTimestamp() {
+  CNfcConfig& rConfig = CNfcConfig::GetInstance();
+  rConfig.resetModified();
+  return 0;
+}
diff --git a/utils/phNxpConfig.h b/utils/phNxpConfig.h
new file mode 100644
index 0000000..0dfae97
--- /dev/null
+++ b/utils/phNxpConfig.h
@@ -0,0 +1,142 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 1999-2012 Broadcom Corporation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ *  The original Work has been changed by NXP Semiconductors.
+ *
+ *  Copyright (C) 2013-2018 NXP Semiconductors
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int GetNxpStrValue(const char* name, char* p_value, unsigned long len);
+int GetNxpNumValue(const char* name, void* p_value, unsigned long len);
+int GetNxpByteArrayValue(const char* name, char* pValue, long bufflen,
+                         long* len);
+void resetNxpConfig(void);
+int isNxpRFConfigModified();
+int isNxpConfigModified();
+int updateNxpConfigTimestamp();
+
+#ifdef __cplusplus
+};
+#endif
+
+#define NAME_NXPLOG_EXTNS_LOGLEVEL "NXPLOG_EXTNS_LOGLEVEL"
+#define NAME_NXPLOG_NCIHAL_LOGLEVEL "NXPLOG_NCIHAL_LOGLEVEL"
+#define NAME_NXPLOG_NCIX_LOGLEVEL "NXPLOG_NCIX_LOGLEVEL"
+#define NAME_NXPLOG_NCIR_LOGLEVEL "NXPLOG_NCIR_LOGLEVEL"
+#define NAME_NXPLOG_FWDNLD_LOGLEVEL "NXPLOG_FWDNLD_LOGLEVEL"
+#define NAME_NXPLOG_TML_LOGLEVEL "NXPLOG_TML_LOGLEVEL"
+
+#define NAME_MIFARE_READER_ENABLE "MIFARE_READER_ENABLE"
+#define NAME_FW_STORAGE "FW_STORAGE"
+#define NAME_NXP_NFC_DEV_NODE "NXP_NFC_DEV_NODE"
+#define NAME_NXP_NFC_CHIP "NXP_NFC_CHIP"
+#define NAME_NXP_FW_NAME "NXP_FW_NAME"
+#define NAME_NXP_FW_TYPE "NXP_FW_TYPE"
+#define NAME_NXP_FW_PROTECION_OVERRIDE "NXP_FW_PROTECION_OVERRIDE"
+#define NAME_NXP_SYS_CLK_SRC_SEL "NXP_SYS_CLK_SRC_SEL"
+#define NAME_NXP_SYS_CLK_FREQ_SEL "NXP_SYS_CLK_FREQ_SEL"
+#define NAME_NXP_SYS_CLOCK_TO_CFG "NXP_SYS_CLOCK_TO_CFG"
+#define NAME_NXP_CLOCK_REQ_DELAY "NXP_CLOCK_REQ_DELAY"
+#define NAME_NXP_ACT_PROP_EXTN "NXP_ACT_PROP_EXTN"
+#define NAME_NXP_EXT_TVDD_CFG "NXP_EXT_TVDD_CFG"
+#define NAME_NXP_EXT_TVDD_CFG_1 "NXP_EXT_TVDD_CFG_1"
+#define NAME_NXP_EXT_TVDD_CFG_2 "NXP_EXT_TVDD_CFG_2"
+#define NAME_NXP_EXT_TVDD_CFG_3 "NXP_EXT_TVDD_CFG_3"
+#define NAME_NXP_RF_CONF_BLK_MAX "NXP_RF_CONF_MAX_NUM"
+#define NAME_NXP_CORE_CONF_EXTN "NXP_CORE_CONF_EXTN"
+#define NAME_NXP_CORE_CONF "NXP_CORE_CONF"
+#define NAME_NXP_NFC_PROFILE_EXTN "NXP_NFC_PROFILE_EXTN"
+#define NAME_NXP_CHINA_TIANJIN_RF_ENABLED "NXP_CHINA_TIANJIN_RF_ENABLED"
+#define NAME_NXP_CHINA_BLK_NUM_CHK_ENABLE "NXP_CN_TRANSIT_BLK_NUM_CHECK_ENABLE"
+#define NAME_NXP_CN_TRANSIT_CMA_BYPASSMODE_ENABLE  "NXP_CN_TRANSIT_CMA_BYPASSMODE_ENABLE"
+#define NAME_NXP_ESE_POWER_DH_CONTROL "NXP_ESE_POWER_DH_CONTROL"
+#define NAME_NXP_ESE_POWER_EXT_PMU "NXP_ESE_POWER_EXT_PMU"
+#define NAME_NXP_ESE_POWER_DH_CONTROL_CFG_1 "NXP_ESE_POWER_DH_CONTROL_CFG_1"
+#define NAME_NXP_SWP_SWITCH_TIMEOUT "NXP_SWP_SWITCH_TIMEOUT"
+#define NAME_NXP_SWP_FULL_PWR_ON "NXP_SWP_FULL_PWR_ON"
+#define NAME_NXP_CORE_RF_FIELD "NXP_CORE_RF_FIELD"
+#define NAME_NXP_NFC_MERGE_RF_PARAMS "NXP_NFC_MERGE_RF_PARAMS"
+#define NAME_NXP_I2C_FRAGMENTATION_ENABLED "NXP_I2C_FRAGMENTATION_ENABLED"
+#define NAME_NFC_DEBUG_ENABLED "NFC_DEBUG_ENABLED"
+#define NAME_AID_MATCHING_PLATFORM "AID_MATCHING_PLATFORM"
+#define NAME_NXP_TYPEA_UICC_BAUD_RATE "NXP_TYPEA_UICC_BAUD_RATE"
+#define NAME_NXP_TYPEB_UICC_BAUD_RATE "NXP_TYPEB_UICC_BAUD_RATE"
+#define NAME_NXP_SET_CONFIG_ALWAYS "NXP_SET_CONFIG_ALWAYS"
+#define NAME_NXP_PROP_BLACKLIST_ROUTING "NXP_PROP_BLACKLIST_ROUTING"
+#define NAME_NXP_WIREDMODE_RESUME_TIMEOUT "NXP_WIREDMODE_RESUME_TIMEOUT"
+#define NAME_NXP_UICC_LISTEN_TECH_MASK "UICC_LISTEN_TECH_MASK"
+#define NAME_NXP_ESE_LISTEN_TECH_MASK "NXP_ESE_LISTEN_TECH_MASK"
+#define NAME_NXP_SVDD_SYNC_OFF_DELAY "NXP_SVDD_SYNC_OFF_DELAY"
+#define NAME_NXP_CORE_PROP_SYSTEM_DEBUG "NXP_CORE_PROP_SYSTEM_DEBUG"
+#define NAME_NXP_NCI_PARSER_LIBRARY "NXP_NCI_PARSER_LIBRARY"
+#define NAME_NXP_DEFAULT_UICC2_SELECT "NXP_DEFAULT_UICC2_SELECT"
+#define NAME_NXP_ALWAYS_FW_UPDATE   "NXP_ALWAYS_FW_UPDATE"
+#define NAME_NXP_P61_JCOP_DEFAULT_INTERFACE "NXP_P61_JCOP_DEFAULT_INTERFACE"
+#define NAME_RF_STATUS_UPDATE_ENABLE "RF_STATUS_UPDATE_ENABLE"
+#define NAME_DEFAULT_ROUTE "DEFAULT_ROUTE"
+#define NAME_DEFAULT_SYS_CODE_ROUTE "DEFAULT_SYS_CODE_ROUTE"
+#define NAME_DEFAULT_SYS_CODE_PWR_STATE "DEFAULT_SYS_CODE_PWR_STATE"
+#define NAME_OFF_HOST_ESE_PIPE_ID "OFF_HOST_ESE_PIPE_ID"
+#define NAME_OFF_HOST_SIM_PIPE_ID "OFF_HOST_SIM_PIPE_ID"
+#define NAME_DEFAULT_OFFHOST_ROUTE "DEFAULT_OFFHOST_ROUTE"
+#define NAME_DEFAULT_NFCF_ROUTE "DEFAULT_NFCF_ROUTE"
+#define NAME_ISO_DEP_MAX_TRANSCEIVE "ISO_DEP_MAX_TRANSCEIVE"
+#define NAME_NFA_POLL_BAIL_OUT_MODE "NFA_POLL_BAIL_OUT_MODE"
+#define NAME_ACTIVE_SE "ACTIVE_SE"
+#define NAME_ACTIVE_SE_NFCF "ACTIVE_SE_NFCF"
+#define NAME_DEFAULT_FELICA_SYS_CODE_ROUTE "DEFAULT_FELICA_SYS_CODE_ROUTE"
+#define NAME_DEFAULT_ISODEP_ROUTE "DEFAULT_ISODEP_ROUTE"
+#define NAME_DEVICE_HOST_WHITE_LIST "DEVICE_HOST_WHITE_LIST"
+#define NAME_NFA_PROPRIETARY_CFG "NFA_PROPRIETARY_CFG"
+#define NAME_PRESENCE_CHECK_ALGORITHM "PRESENCE_CHECK_ALGORITHM"
+#define NAME_NXP_CORE_PROP_SYSTEM_DEBUG "NXP_CORE_PROP_SYSTEM_DEBUG"
+#define NAME_NXP_CORE_SCRN_OFF_AUTONOMOUS_ENABLE "NXP_CORE_SCRN_OFF_AUTONOMOUS_ENABLE"
+#define NAME_NXP_P61_LS_DEFAULT_INTERFACE "NXP_P61_LS_DEFAULT_INTERFACE"
+#define NAME_NXP_LS_FORCE_UPDATE_REQUIRED "NXP_LS_FORCE_UPDATE_REQUIRED"
+#define NAME_NXP_JCOP_FORCE_UPDATE_REQUIRED "NXP_JCOP_FORCE_UPDATE_REQUIRED"
+#define NAME_NXP_SEMS_SUPPORTED "NXP_GP_AMD_I_SEMS_SUPPORTED"
+#define NAME_NXP_SPI_SE_TERMINAL_NUM "NXP_SPI_SE_TERMINAL_NUM"
+#define NAME_NXP_VISO_SE_TERMINAL_NUM "NXP_VISO_SE_TERMINAL_NUM"
+#define NAME_NXP_NFC_SE_TERMINAL_NUM "NXP_NFC_SE_TERMINAL_NUM"
+
+/* default configuration */
+#define default_storage_location "/data/vendor/nfc"
+
+#endif
diff --git a/utils/sparse_crc32.cc b/utils/sparse_crc32.cc
new file mode 100644
index 0000000..d490daa
--- /dev/null
+++ b/utils/sparse_crc32.cc
@@ -0,0 +1,107 @@
+/*-
+ *  COPYRIGHT (C) 1986 Gary S. Brown.  You may use this program, or
+ *  code or tables extracted from it, as desired without restriction.
+ */
+
+/*
+ *  First, the polynomial itself and its table of feedback terms.  The
+ *  polynomial is
+ *  X^32+X^26+X^23+X^22+X^16+X^12+X^11+X^10+X^8+X^7+X^5+X^4+X^2+X^1+X^0
+ *
+ *  Note that we take it "backwards" and put the highest-order term in
+ *  the lowest-order bit.  The X^32 term is "implied"; the LSB is the
+ *  X^31 term, etc.  The X^0 term (usually shown as "+1") results in
+ *  the MSB being 1
+ *
+ *  Note that the usual hardware shift register implementation, which
+ *  is what we're using (we're merely optimizing it by doing eight-bit
+ *  chunks at a time) shifts bits into the lowest-order term.  In our
+ *  implementation, that means shifting towards the right.  Why do we
+ *  do it this way?  Because the calculated CRC must be transmitted in
+ *  order from highest-order term to lowest-order term.  UARTs transmit
+ *  characters in order from LSB to MSB.  By storing the CRC this way
+ *  we hand it to the UART in the order low-byte to high-byte; the UART
+ *  sends each low-bit to hight-bit; and the result is transmission bit
+ *  by bit from highest- to lowest-order term without requiring any bit
+ *  shuffling on our part.  Reception works similarly
+ *
+ *  The feedback terms table consists of 256, 32-bit entries.  Notes
+ *
+ *      The table can be generated at runtime if desired; code to do so
+ *      is shown later.  It might not be obvious, but the feedback
+ *      terms simply represent the results of eight shift/xor opera
+ *      tions for all combinations of data and CRC register values
+ *
+ *      The values must be right-shifted by eight bits by the "updcrc
+ *      logic; the shift must be unsigned (bring in zeroes).  On some
+ *      hardware you could probably optimize the shift in assembler by
+ *      using byte-swap instructions
+ *      polynomial $edb88320
+ *
+ *
+ * CRC32 code derived from work by Gary S. Brown.
+ */
+
+/* Code taken from FreeBSD 8 */
+#include <stdint.h>
+
+static uint32_t crc32_tab[] = {
+    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
+    0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
+    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
+    0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
+    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
+    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
+    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
+    0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
+    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
+    0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
+    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
+    0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
+    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
+    0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
+    0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
+    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
+    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
+    0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
+    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
+    0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
+    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
+    0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
+    0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
+    0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
+    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
+    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
+    0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
+    0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
+    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
+    0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
+    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
+    0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
+    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
+    0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
+    0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
+    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
+    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
+    0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
+    0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
+    0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
+    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
+    0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
+    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d};
+
+/*
+ * A function that calculates the CRC-32 based on the table above is
+ * given below for documentation purposes. An equivalent implementation
+ * of this function that's actually used in the kernel can be found
+ * in sys/libkern.h, where it can be inlined.
+ */
+
+uint32_t sparse_crc32(uint32_t crc_in, const void* buf, int size) {
+  const uint8_t* p = (const uint8_t*)buf;
+  uint32_t crc;
+
+  crc = crc_in ^ ~0U;
+  while (size--) crc = crc32_tab[(crc ^ *p++) & 0xFF] ^ (crc >> 8);
+  return crc ^ ~0U;
+}
diff --git a/utils/sparse_crc32.h b/utils/sparse_crc32.h
new file mode 100644
index 0000000..29fc9be
--- /dev/null
+++ b/utils/sparse_crc32.h
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _LIBSPARSE_SPARSE_CRC32_H_
+#define _LIBSPARSE_SPARSE_CRC32_H_
+
+#include <stdint.h>
+
+uint32_t sparse_crc32(uint32_t crc, const void* buf, int size);
+
+#endif
-- 
2.17.1

