From e74ab2958f3e937ce93ba739e0df51730d212779 Mon Sep 17 00:00:00 2001
From: Bruno Martins <bgcngm@gmail.com>
Date: Fri, 8 Mar 2019 00:02:48 +0000
Subject: [PATCH] [SQUASH][DNM] Merge tag 'LA.UM.7.3.r1-06900-sdm845.0' into
 HEAD

Change-Id: Id0bb2711d6f488f0ce6d548237707cc0c6de8227
---
 .clang-format                                 |    28 +
 Android.mk                                    |     2 +-
 AndroidManifest.xml                           |    40 +-
 OWNERS                                        |     2 +
 PREUPLOAD.cfg                                 |     5 +
 README.md                                     |    14 +
 nci/jni/Android.mk                            |    30 +-
 nci/jni/CondVar.cpp                           |   119 +-
 nci/jni/CondVar.h                             |   116 +-
 nci/jni/DataQueue.cpp                         |   140 +-
 nci/jni/DataQueue.h                           |   143 +-
 nci/jni/DwpChannel.cpp                        |   636 +-
 nci/jni/DwpChannel.h                          |   145 +-
 nci/jni/HciEventManager.cpp                   |   229 +
 nci/jni/HciEventManager.h                     |    44 +
 nci/jni/HciRFParams.cpp                       |   318 +-
 nci/jni/HciRFParams.h                         |   230 +-
 nci/jni/IntervalTimer.cpp                     |   124 +-
 nci/jni/IntervalTimer.h                       |    46 +-
 nci/jni/JavaClassConstants.h                  |    85 +-
 nci/jni/JcopManager.cpp                       |   387 +
 nci/jni/JcopManager.h                         |   272 +
 nci/jni/MposManager.cpp                       |   882 +
 nci/jni/MposManager.h                         |   356 +
 nci/jni/Mutex.cpp                             |    79 +-
 nci/jni/Mutex.h                               |   166 +-
 nci/jni/NativeLlcpConnectionlessSocket.cpp    |   363 +-
 nci/jni/NativeLlcpServiceSocket.cpp           |   158 +-
 nci/jni/NativeLlcpSocket.cpp                  |   190 +-
 nci/jni/NativeMposManager.cpp                 |   353 +
 nci/jni/NativeNfcAla.cpp                      |   817 +-
 nci/jni/NativeNfcManager.cpp                  | 16039 ++++++++--------
 nci/jni/NativeNfcTag.cpp                      |  3838 ++--
 nci/jni/NativeNxpFeature.cpp                  |  1701 +-
 nci/jni/NativeP2pDevice.cpp                   |    76 +-
 nci/jni/NativeSecureElement.cpp               |  1013 +-
 nci/jni/NfcJniUtil.cpp                        |   193 +-
 nci/jni/NfcJniUtil.h                          |   263 +-
 nci/jni/NfcTag.cpp                            |  2763 ++-
 nci/jni/NfcTag.h                              |  1290 +-
 nci/jni/PeerToPeer.cpp                        |  2450 ++-
 nci/jni/PeerToPeer.h                          |  1418 +-
 nci/jni/Pn544Interop.cpp                      |   135 +-
 nci/jni/Pn544Interop.h                        |     9 +-
 nci/jni/PowerSwitch.cpp                       |   516 +-
 nci/jni/PowerSwitch.h                         |   535 +-
 nci/jni/RouteDataSet.cpp                      |   393 +-
 nci/jni/RouteDataSet.h                        |   435 +-
 nci/jni/RoutingManager.cpp                    |  6030 +++---
 nci/jni/RoutingManager.h                      |   542 +-
 nci/jni/SecureElement.cpp                     |  7749 ++++----
 nci/jni/SecureElement.h                       |  1958 +-
 nci/jni/SyncEvent.h                           |   240 +-
 nci/jni/TransactionController.cpp             |   432 +-
 nci/jni/TransactionController.h               |   220 +-
 nci/jni/extns/pn54x/Android.mk                |     4 +
 nci/jni/extns/pn54x/inc/phNxpExtns.h          |    81 +-
 nci/jni/extns/pn54x/inc/phNxpExtns_Custom.h   |    89 +-
 .../extns/pn54x/src/common/phNciNfcTypes.h    |   359 +-
 nci/jni/extns/pn54x/src/common/phNfcCompId.h  |    43 +-
 nci/jni/extns/pn54x/src/common/phNfcStatus.h  |   160 +-
 nci/jni/extns/pn54x/src/common/phNfcTypes.h   |   382 +-
 .../pn54x/src/common/phNfcTypes_Mapping.h     |     1 -
 nci/jni/extns/pn54x/src/log/phNxpLog.c        |   271 -
 nci/jni/extns/pn54x/src/log/phNxpLog.cpp      |   281 +
 nci/jni/extns/pn54x/src/log/phNxpLog.h        |   322 +-
 nci/jni/extns/pn54x/src/mifare/phFriNfc.h     |    94 +-
 .../pn54x/src/mifare/phFriNfc_MifStdFormat.c  |  1385 --
 .../src/mifare/phFriNfc_MifStdFormat.cpp      |  1340 ++
 .../pn54x/src/mifare/phFriNfc_MifStdFormat.h  |   476 +-
 .../pn54x/src/mifare/phFriNfc_MifareStdMap.c  |  5867 ------
 .../src/mifare/phFriNfc_MifareStdMap.cpp      |  5140 +++++
 .../pn54x/src/mifare/phFriNfc_MifareStdMap.h  |   377 +-
 ...StdTimer.c => phFriNfc_MifareStdTimer.cpp} |   143 +-
 .../src/mifare/phFriNfc_MifareStdTimer.h      |    27 +-
 .../extns/pn54x/src/mifare/phFriNfc_NdefMap.h |   630 +-
 .../pn54x/src/mifare/phFriNfc_SmtCrdFmt.c     |   219 -
 .../pn54x/src/mifare/phFriNfc_SmtCrdFmt.cpp   |   218 +
 .../pn54x/src/mifare/phFriNfc_SmtCrdFmt.h     |   152 +-
 .../pn54x/src/mifare/phNxpExtns_MifareStd.c   |  2221 ---
 .../pn54x/src/mifare/phNxpExtns_MifareStd.cpp |  1993 ++
 .../pn54x/src/mifare/phNxpExtns_MifareStd.h   |   266 +-
 nci/jni/extns/pn54x/src/phNxpExtns.c          |   684 -
 nci/jni/extns/pn54x/src/phNxpExtns.cpp        |   631 +
 nci/jni/extns/pn54x/src/utils/phNxpConfig.cpp |  1552 --
 nci/jni/extns/pn54x/src/utils/phNxpConfig.h   |   101 +-
 .../extns/pn54x/src/utils/sparse_crc32.cpp    |   107 +
 nci/jni/extns/pn54x/src/utils/sparse_crc32.h  |    24 +
 .../android/nfc/dhimpl/NativeNfcManager.java  |   188 +-
 .../nfc/dhimpl/NativeNfcMposManager.java      |    43 +
 .../com/android/nfc/dhimpl/NativeNfcTag.java  |    17 +-
 .../gsma/nfc/internal/NxpNfcController.java   |   162 +-
 res/drawable/ic_weblink_nfc.xml               |    20 +
 res/layout/url_open_confirmation.xml          |    36 +
 res/values-af/live_cases.xml                  |    29 -
 res/values-af/provisioning.xml                |    25 -
 res/values-am/live_cases.xml                  |    29 -
 res/values-am/provisioning.xml                |    25 -
 res/values-ar/live_cases.xml                  |    29 -
 res/values-ar/provisioning.xml                |    25 -
 res/values-az/live_cases.xml                  |    29 -
 res/values-az/provisioning.xml                |    25 -
 res/values-b+sr+Latn/live_cases.xml           |    29 -
 res/values-b+sr+Latn/provisioning.xml         |    25 -
 res/values-be/live_cases.xml                  |    29 -
 res/values-be/provisioning.xml                |    25 -
 res/values-bg/live_cases.xml                  |    29 -
 res/values-bg/provisioning.xml                |    25 -
 res/values-bn/live_cases.xml                  |    29 -
 res/values-bn/provisioning.xml                |    25 -
 res/values-bs/live_cases.xml                  |    29 -
 res/values-bs/provisioning.xml                |    25 -
 res/values-ca/live_cases.xml                  |    29 -
 res/values-ca/provisioning.xml                |    25 -
 res/values-cs/live_cases.xml                  |    29 -
 res/values-cs/provisioning.xml                |    25 -
 res/values-da/live_cases.xml                  |    29 -
 res/values-da/provisioning.xml                |    25 -
 res/values-de/live_cases.xml                  |    29 -
 res/values-de/provisioning.xml                |    25 -
 res/values-el/live_cases.xml                  |    29 -
 res/values-el/provisioning.xml                |    25 -
 res/values-en-rAU/live_cases.xml              |    29 -
 res/values-en-rAU/provisioning.xml            |    25 -
 res/values-en-rGB/live_cases.xml              |    29 -
 res/values-en-rGB/provisioning.xml            |    25 -
 res/values-en-rIN/live_cases.xml              |    29 -
 res/values-en-rIN/provisioning.xml            |    25 -
 res/values-es-rUS/live_cases.xml              |    29 -
 res/values-es-rUS/provisioning.xml            |    25 -
 res/values-es/live_cases.xml                  |    29 -
 res/values-es/provisioning.xml                |    25 -
 res/values-et/live_cases.xml                  |    29 -
 res/values-et/provisioning.xml                |    25 -
 res/values-eu/live_cases.xml                  |    29 -
 res/values-eu/provisioning.xml                |    25 -
 res/values-fa/live_cases.xml                  |    29 -
 res/values-fa/provisioning.xml                |    25 -
 res/values-fi/live_cases.xml                  |    29 -
 res/values-fi/provisioning.xml                |    25 -
 res/values-fr-rCA/live_cases.xml              |    29 -
 res/values-fr-rCA/provisioning.xml            |    25 -
 res/values-fr/live_cases.xml                  |    29 -
 res/values-fr/provisioning.xml                |    25 -
 res/values-gl/live_cases.xml                  |    29 -
 res/values-gl/provisioning.xml                |    25 -
 res/values-gu/live_cases.xml                  |    29 -
 res/values-gu/provisioning.xml                |    25 -
 res/values-hi/live_cases.xml                  |    29 -
 res/values-hi/provisioning.xml                |    25 -
 res/values-hr/live_cases.xml                  |    29 -
 res/values-hr/provisioning.xml                |    25 -
 res/values-hu/live_cases.xml                  |    29 -
 res/values-hu/provisioning.xml                |    25 -
 res/values-hy/live_cases.xml                  |    29 -
 res/values-hy/provisioning.xml                |    25 -
 res/values-in/live_cases.xml                  |    29 -
 res/values-in/provisioning.xml                |    25 -
 res/values-is/live_cases.xml                  |    29 -
 res/values-is/provisioning.xml                |    25 -
 res/values-it/live_cases.xml                  |    29 -
 res/values-it/provisioning.xml                |    25 -
 res/values-iw/live_cases.xml                  |    29 -
 res/values-iw/provisioning.xml                |    25 -
 res/values-ja/live_cases.xml                  |    29 -
 res/values-ja/provisioning.xml                |    25 -
 res/values-ka/live_cases.xml                  |    29 -
 res/values-ka/provisioning.xml                |    25 -
 res/values-kk/live_cases.xml                  |    29 -
 res/values-kk/provisioning.xml                |    25 -
 res/values-km/live_cases.xml                  |    29 -
 res/values-km/provisioning.xml                |    25 -
 res/values-kn/live_cases.xml                  |    29 -
 res/values-kn/provisioning.xml                |    25 -
 res/values-ko/live_cases.xml                  |    29 -
 res/values-ko/provisioning.xml                |    25 -
 res/values-ky/live_cases.xml                  |    29 -
 res/values-ky/provisioning.xml                |    25 -
 res/values-lo/live_cases.xml                  |    29 -
 res/values-lo/provisioning.xml                |    25 -
 res/values-lt/live_cases.xml                  |    29 -
 res/values-lt/provisioning.xml                |    25 -
 res/values-lv/live_cases.xml                  |    29 -
 res/values-lv/provisioning.xml                |    25 -
 res/values-mk/live_cases.xml                  |    29 -
 res/values-mk/provisioning.xml                |    25 -
 res/values-ml/live_cases.xml                  |    29 -
 res/values-ml/provisioning.xml                |    25 -
 res/values-mn/live_cases.xml                  |    29 -
 res/values-mn/provisioning.xml                |    25 -
 res/values-mr/live_cases.xml                  |    29 -
 res/values-mr/provisioning.xml                |    25 -
 res/values-ms/live_cases.xml                  |    29 -
 res/values-ms/provisioning.xml                |    25 -
 res/values-my/live_cases.xml                  |    29 -
 res/values-my/provisioning.xml                |    25 -
 res/values-nb/live_cases.xml                  |    29 -
 res/values-nb/provisioning.xml                |    25 -
 res/values-ne/live_cases.xml                  |    29 -
 res/values-ne/provisioning.xml                |    25 -
 res/values-nl/live_cases.xml                  |    29 -
 res/values-nl/provisioning.xml                |    25 -
 res/values-pa/live_cases.xml                  |    29 -
 res/values-pa/provisioning.xml                |    25 -
 res/values-pl/live_cases.xml                  |    29 -
 res/values-pl/provisioning.xml                |    25 -
 res/values-pt-rPT/live_cases.xml              |    29 -
 res/values-pt-rPT/provisioning.xml            |    25 -
 res/values-pt/live_cases.xml                  |    29 -
 res/values-pt/provisioning.xml                |    25 -
 res/values-ro/live_cases.xml                  |    29 -
 res/values-ro/provisioning.xml                |    25 -
 res/values-ru/live_cases.xml                  |    29 -
 res/values-ru/provisioning.xml                |    25 -
 res/values-si/live_cases.xml                  |    29 -
 res/values-si/provisioning.xml                |    25 -
 res/values-sk/live_cases.xml                  |    29 -
 res/values-sk/provisioning.xml                |    25 -
 res/values-sl/live_cases.xml                  |    29 -
 res/values-sl/provisioning.xml                |    25 -
 res/values-sq/live_cases.xml                  |    29 -
 res/values-sq/provisioning.xml                |    25 -
 res/values-sr/live_cases.xml                  |    29 -
 res/values-sr/provisioning.xml                |    25 -
 res/values-sv/live_cases.xml                  |    29 -
 res/values-sv/provisioning.xml                |    25 -
 res/values-sw/live_cases.xml                  |    29 -
 res/values-sw/provisioning.xml                |    25 -
 res/values-ta/live_cases.xml                  |    29 -
 res/values-ta/provisioning.xml                |    25 -
 res/values-te/live_cases.xml                  |    29 -
 res/values-te/provisioning.xml                |    25 -
 res/values-th/live_cases.xml                  |    29 -
 res/values-th/provisioning.xml                |    25 -
 res/values-tl/live_cases.xml                  |    29 -
 res/values-tl/provisioning.xml                |    25 -
 res/values-tr/live_cases.xml                  |    29 -
 res/values-tr/provisioning.xml                |    25 -
 res/values-uk/live_cases.xml                  |    29 -
 res/values-uk/provisioning.xml                |    25 -
 res/values-ur/live_cases.xml                  |    29 -
 res/values-ur/provisioning.xml                |    25 -
 res/values-uz/live_cases.xml                  |    29 -
 res/values-uz/provisioning.xml                |    25 -
 res/values-vi/live_cases.xml                  |    29 -
 res/values-vi/provisioning.xml                |    25 -
 res/values-watch/drawables.xml                |     4 +
 res/values-zh-rCN/live_cases.xml              |    29 -
 res/values-zh-rCN/provisioning.xml            |    25 -
 res/values-zh-rHK/live_cases.xml              |    29 -
 res/values-zh-rHK/provisioning.xml            |    25 -
 res/values-zh-rTW/live_cases.xml              |    29 -
 res/values-zh-rTW/provisioning.xml            |    25 -
 res/values-zu/live_cases.xml                  |    29 -
 res/values-zu/provisioning.xml                |    25 -
 res/values/config.xml                         |     6 +
 res/values/live_cases.xml                     |     4 +-
 res/values/provisioning.xml                   |     2 +-
 res/values/strings.xml                        |    13 +
 src/com/android/nfc/BeamShareActivity.java    |     4 +
 .../ConfirmConnectToWifiNetworkActivity.java  |     1 +
 src/com/android/nfc/DeviceHost.java           |    41 +-
 src/com/android/nfc/DtaServiceConnector.java  |    26 +-
 src/com/android/nfc/NfcApplication.java       |     2 -
 .../android/nfc/NfcBootCompletedReceiver.java |    43 +
 src/com/android/nfc/NfcDispatcher.java        |   109 +-
 src/com/android/nfc/NfcService.java           |  2403 +--
 .../android/nfc/NfcWifiProtectedSetup.java    |    18 +-
 src/com/android/nfc/NfceeAccessControl.java   |   308 -
 src/com/android/nfc/P2pLinkManager.java       |    72 +-
 src/com/android/nfc/WiredSeService.cpp        |   182 +
 src/com/android/nfc/beam/BeamManager.java     |    13 +-
 .../android/nfc/beam/BeamReceiveService.java  |    24 +-
 src/com/android/nfc/beam/BeamSendService.java |    24 +-
 .../android/nfc/beam/BeamStatusReceiver.java  |     3 +
 .../android/nfc/beam/BeamTransferManager.java |     6 +-
 .../nfc/beam/BluetoothOppHandover.java        |     6 +-
 src/com/android/nfc/beam/MimeTypeUtil.java    |     7 +-
 src/com/android/nfc/beam/SendUi.java          |    39 +-
 .../nfc/cardemulation/AidRoutingManager.java  |    86 +-
 .../cardemulation/CardEmulationManager.java   |    60 +-
 .../cardemulation/DefaultRemovedActivity.java |    50 -
 .../cardemulation/EnabledNfcFServices.java    |     3 +-
 .../cardemulation/HostEmulationManager.java   |    29 +-
 .../nfc/cardemulation/RegisteredAidCache.java |    58 +-
 .../RegisteredT3tIdentifiersCache.java        |     2 +-
 .../SystemCodeRoutingManager.java             |    10 +-
 .../handover/BluetoothPeripheralHandover.java |    44 +-
 .../nfc/handover/ConfirmConnectActivity.java  |     4 +-
 .../nfc/handover/HandoverDataParser.java      |    15 +-
 .../android/nfc/handover/HandoverServer.java  |     2 +-
 .../handover/PeripheralHandoverService.java   |    52 +-
 .../android/nfc/ndefpush/NdefPushServer.java  |     2 +-
 src/com/android/nfc/snep/SnepMessage.java     |    58 +-
 src/com/android/nfc/snep/SnepMessenger.java   |    74 +-
 src/com/android/nfc/snep/SnepServer.java      |    26 +-
 .../android/nfc/sneptest/DtaSnepClient.java   |   106 +-
 .../nfc/sneptest/ExtDtaSnepServer.java        |   102 +-
 298 files changed, 43426 insertions(+), 47900 deletions(-)
 create mode 100644 .clang-format
 create mode 100644 OWNERS
 create mode 100644 PREUPLOAD.cfg
 mode change 100644 => 100755 nci/jni/Android.mk
 mode change 100644 => 100755 nci/jni/DwpChannel.cpp
 create mode 100755 nci/jni/HciEventManager.cpp
 create mode 100644 nci/jni/HciEventManager.h
 create mode 100644 nci/jni/JcopManager.cpp
 create mode 100644 nci/jni/JcopManager.h
 create mode 100644 nci/jni/MposManager.cpp
 create mode 100644 nci/jni/MposManager.h
 create mode 100644 nci/jni/NativeMposManager.cpp
 mode change 100644 => 100755 nci/jni/NativeSecureElement.cpp
 mode change 100644 => 100755 nci/jni/RoutingManager.cpp
 mode change 100644 => 100755 nci/jni/RoutingManager.h
 mode change 100644 => 100755 nci/jni/SecureElement.cpp
 delete mode 100644 nci/jni/extns/pn54x/src/log/phNxpLog.c
 create mode 100644 nci/jni/extns/pn54x/src/log/phNxpLog.cpp
 delete mode 100644 nci/jni/extns/pn54x/src/mifare/phFriNfc_MifStdFormat.c
 create mode 100644 nci/jni/extns/pn54x/src/mifare/phFriNfc_MifStdFormat.cpp
 delete mode 100644 nci/jni/extns/pn54x/src/mifare/phFriNfc_MifareStdMap.c
 create mode 100644 nci/jni/extns/pn54x/src/mifare/phFriNfc_MifareStdMap.cpp
 rename nci/jni/extns/pn54x/src/mifare/{phFriNfc_MifareStdTimer.c => phFriNfc_MifareStdTimer.cpp} (50%)
 delete mode 100644 nci/jni/extns/pn54x/src/mifare/phFriNfc_SmtCrdFmt.c
 create mode 100644 nci/jni/extns/pn54x/src/mifare/phFriNfc_SmtCrdFmt.cpp
 delete mode 100644 nci/jni/extns/pn54x/src/mifare/phNxpExtns_MifareStd.c
 create mode 100644 nci/jni/extns/pn54x/src/mifare/phNxpExtns_MifareStd.cpp
 delete mode 100644 nci/jni/extns/pn54x/src/phNxpExtns.c
 create mode 100644 nci/jni/extns/pn54x/src/phNxpExtns.cpp
 delete mode 100644 nci/jni/extns/pn54x/src/utils/phNxpConfig.cpp
 create mode 100644 nci/jni/extns/pn54x/src/utils/sparse_crc32.cpp
 create mode 100644 nci/jni/extns/pn54x/src/utils/sparse_crc32.h
 create mode 100644 nci/src/com/android/nfc/dhimpl/NativeNfcMposManager.java
 create mode 100644 res/drawable/ic_weblink_nfc.xml
 create mode 100644 res/layout/url_open_confirmation.xml
 delete mode 100644 res/values-af/live_cases.xml
 delete mode 100644 res/values-af/provisioning.xml
 delete mode 100644 res/values-am/live_cases.xml
 delete mode 100644 res/values-am/provisioning.xml
 delete mode 100644 res/values-ar/live_cases.xml
 delete mode 100644 res/values-ar/provisioning.xml
 delete mode 100644 res/values-az/live_cases.xml
 delete mode 100644 res/values-az/provisioning.xml
 delete mode 100644 res/values-b+sr+Latn/live_cases.xml
 delete mode 100644 res/values-b+sr+Latn/provisioning.xml
 delete mode 100644 res/values-be/live_cases.xml
 delete mode 100644 res/values-be/provisioning.xml
 delete mode 100644 res/values-bg/live_cases.xml
 delete mode 100644 res/values-bg/provisioning.xml
 delete mode 100644 res/values-bn/live_cases.xml
 delete mode 100644 res/values-bn/provisioning.xml
 delete mode 100644 res/values-bs/live_cases.xml
 delete mode 100644 res/values-bs/provisioning.xml
 delete mode 100644 res/values-ca/live_cases.xml
 delete mode 100644 res/values-ca/provisioning.xml
 delete mode 100644 res/values-cs/live_cases.xml
 delete mode 100644 res/values-cs/provisioning.xml
 delete mode 100644 res/values-da/live_cases.xml
 delete mode 100644 res/values-da/provisioning.xml
 delete mode 100644 res/values-de/live_cases.xml
 delete mode 100644 res/values-de/provisioning.xml
 delete mode 100644 res/values-el/live_cases.xml
 delete mode 100644 res/values-el/provisioning.xml
 delete mode 100644 res/values-en-rAU/live_cases.xml
 delete mode 100644 res/values-en-rAU/provisioning.xml
 delete mode 100644 res/values-en-rGB/live_cases.xml
 delete mode 100644 res/values-en-rGB/provisioning.xml
 delete mode 100644 res/values-en-rIN/live_cases.xml
 delete mode 100644 res/values-en-rIN/provisioning.xml
 delete mode 100644 res/values-es-rUS/live_cases.xml
 delete mode 100644 res/values-es-rUS/provisioning.xml
 delete mode 100644 res/values-es/live_cases.xml
 delete mode 100644 res/values-es/provisioning.xml
 delete mode 100644 res/values-et/live_cases.xml
 delete mode 100644 res/values-et/provisioning.xml
 delete mode 100644 res/values-eu/live_cases.xml
 delete mode 100644 res/values-eu/provisioning.xml
 delete mode 100644 res/values-fa/live_cases.xml
 delete mode 100644 res/values-fa/provisioning.xml
 delete mode 100644 res/values-fi/live_cases.xml
 delete mode 100644 res/values-fi/provisioning.xml
 delete mode 100644 res/values-fr-rCA/live_cases.xml
 delete mode 100644 res/values-fr-rCA/provisioning.xml
 delete mode 100644 res/values-fr/live_cases.xml
 delete mode 100644 res/values-fr/provisioning.xml
 delete mode 100644 res/values-gl/live_cases.xml
 delete mode 100644 res/values-gl/provisioning.xml
 delete mode 100644 res/values-gu/live_cases.xml
 delete mode 100644 res/values-gu/provisioning.xml
 delete mode 100644 res/values-hi/live_cases.xml
 delete mode 100644 res/values-hi/provisioning.xml
 delete mode 100644 res/values-hr/live_cases.xml
 delete mode 100644 res/values-hr/provisioning.xml
 delete mode 100644 res/values-hu/live_cases.xml
 delete mode 100644 res/values-hu/provisioning.xml
 delete mode 100644 res/values-hy/live_cases.xml
 delete mode 100644 res/values-hy/provisioning.xml
 delete mode 100644 res/values-in/live_cases.xml
 delete mode 100644 res/values-in/provisioning.xml
 delete mode 100644 res/values-is/live_cases.xml
 delete mode 100644 res/values-is/provisioning.xml
 delete mode 100644 res/values-it/live_cases.xml
 delete mode 100644 res/values-it/provisioning.xml
 delete mode 100644 res/values-iw/live_cases.xml
 delete mode 100644 res/values-iw/provisioning.xml
 delete mode 100644 res/values-ja/live_cases.xml
 delete mode 100644 res/values-ja/provisioning.xml
 delete mode 100644 res/values-ka/live_cases.xml
 delete mode 100644 res/values-ka/provisioning.xml
 delete mode 100644 res/values-kk/live_cases.xml
 delete mode 100644 res/values-kk/provisioning.xml
 delete mode 100644 res/values-km/live_cases.xml
 delete mode 100644 res/values-km/provisioning.xml
 delete mode 100644 res/values-kn/live_cases.xml
 delete mode 100644 res/values-kn/provisioning.xml
 delete mode 100644 res/values-ko/live_cases.xml
 delete mode 100644 res/values-ko/provisioning.xml
 delete mode 100644 res/values-ky/live_cases.xml
 delete mode 100644 res/values-ky/provisioning.xml
 delete mode 100644 res/values-lo/live_cases.xml
 delete mode 100644 res/values-lo/provisioning.xml
 delete mode 100644 res/values-lt/live_cases.xml
 delete mode 100644 res/values-lt/provisioning.xml
 delete mode 100644 res/values-lv/live_cases.xml
 delete mode 100644 res/values-lv/provisioning.xml
 delete mode 100644 res/values-mk/live_cases.xml
 delete mode 100644 res/values-mk/provisioning.xml
 delete mode 100644 res/values-ml/live_cases.xml
 delete mode 100644 res/values-ml/provisioning.xml
 delete mode 100644 res/values-mn/live_cases.xml
 delete mode 100644 res/values-mn/provisioning.xml
 delete mode 100644 res/values-mr/live_cases.xml
 delete mode 100644 res/values-mr/provisioning.xml
 delete mode 100644 res/values-ms/live_cases.xml
 delete mode 100644 res/values-ms/provisioning.xml
 delete mode 100644 res/values-my/live_cases.xml
 delete mode 100644 res/values-my/provisioning.xml
 delete mode 100644 res/values-nb/live_cases.xml
 delete mode 100644 res/values-nb/provisioning.xml
 delete mode 100644 res/values-ne/live_cases.xml
 delete mode 100644 res/values-ne/provisioning.xml
 delete mode 100644 res/values-nl/live_cases.xml
 delete mode 100644 res/values-nl/provisioning.xml
 delete mode 100644 res/values-pa/live_cases.xml
 delete mode 100644 res/values-pa/provisioning.xml
 delete mode 100644 res/values-pl/live_cases.xml
 delete mode 100644 res/values-pl/provisioning.xml
 delete mode 100644 res/values-pt-rPT/live_cases.xml
 delete mode 100644 res/values-pt-rPT/provisioning.xml
 delete mode 100644 res/values-pt/live_cases.xml
 delete mode 100644 res/values-pt/provisioning.xml
 delete mode 100644 res/values-ro/live_cases.xml
 delete mode 100644 res/values-ro/provisioning.xml
 delete mode 100644 res/values-ru/live_cases.xml
 delete mode 100644 res/values-ru/provisioning.xml
 delete mode 100644 res/values-si/live_cases.xml
 delete mode 100644 res/values-si/provisioning.xml
 delete mode 100644 res/values-sk/live_cases.xml
 delete mode 100644 res/values-sk/provisioning.xml
 delete mode 100644 res/values-sl/live_cases.xml
 delete mode 100644 res/values-sl/provisioning.xml
 delete mode 100644 res/values-sq/live_cases.xml
 delete mode 100644 res/values-sq/provisioning.xml
 delete mode 100644 res/values-sr/live_cases.xml
 delete mode 100644 res/values-sr/provisioning.xml
 delete mode 100644 res/values-sv/live_cases.xml
 delete mode 100644 res/values-sv/provisioning.xml
 delete mode 100644 res/values-sw/live_cases.xml
 delete mode 100644 res/values-sw/provisioning.xml
 delete mode 100644 res/values-ta/live_cases.xml
 delete mode 100644 res/values-ta/provisioning.xml
 delete mode 100644 res/values-te/live_cases.xml
 delete mode 100644 res/values-te/provisioning.xml
 delete mode 100644 res/values-th/live_cases.xml
 delete mode 100644 res/values-th/provisioning.xml
 delete mode 100644 res/values-tl/live_cases.xml
 delete mode 100644 res/values-tl/provisioning.xml
 delete mode 100644 res/values-tr/live_cases.xml
 delete mode 100644 res/values-tr/provisioning.xml
 delete mode 100644 res/values-uk/live_cases.xml
 delete mode 100644 res/values-uk/provisioning.xml
 delete mode 100644 res/values-ur/live_cases.xml
 delete mode 100644 res/values-ur/provisioning.xml
 delete mode 100644 res/values-uz/live_cases.xml
 delete mode 100644 res/values-uz/provisioning.xml
 delete mode 100644 res/values-vi/live_cases.xml
 delete mode 100644 res/values-vi/provisioning.xml
 create mode 100644 res/values-watch/drawables.xml
 delete mode 100644 res/values-zh-rCN/live_cases.xml
 delete mode 100644 res/values-zh-rCN/provisioning.xml
 delete mode 100644 res/values-zh-rHK/live_cases.xml
 delete mode 100644 res/values-zh-rHK/provisioning.xml
 delete mode 100644 res/values-zh-rTW/live_cases.xml
 delete mode 100644 res/values-zh-rTW/provisioning.xml
 delete mode 100644 res/values-zu/live_cases.xml
 delete mode 100644 res/values-zu/provisioning.xml
 create mode 100644 res/values/config.xml
 mode change 100644 => 100755 src/com/android/nfc/DeviceHost.java
 mode change 100644 => 100755 src/com/android/nfc/DtaServiceConnector.java
 create mode 100644 src/com/android/nfc/NfcBootCompletedReceiver.java
 mode change 100644 => 100755 src/com/android/nfc/NfcDispatcher.java
 delete mode 100644 src/com/android/nfc/NfceeAccessControl.java
 create mode 100644 src/com/android/nfc/WiredSeService.cpp
 mode change 100644 => 100755 src/com/android/nfc/cardemulation/CardEmulationManager.java
 delete mode 100644 src/com/android/nfc/cardemulation/DefaultRemovedActivity.java
 mode change 100644 => 100755 src/com/android/nfc/cardemulation/RegisteredAidCache.java

diff --git a/.clang-format b/.clang-format
new file mode 100644
index 00000000..686f0819
--- /dev/null
+++ b/.clang-format
@@ -0,0 +1,28 @@
+#
+# Copyright (C) 2016 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+#
+# Below are some minor deviations from the default Google style to
+# accommodate for handling of the large legacy code base.
+#
+
+BasedOnStyle: Google
+CommentPragmas: NOLINT:.*
+DerivePointerAlignment: false
+
+---
+Language: Java
+DisableFormat: true
\ No newline at end of file
diff --git a/Android.mk b/Android.mk
index bcd43983..24f9b0c1 100644
--- a/Android.mk
+++ b/Android.mk
@@ -20,7 +20,7 @@ LOCAL_CERTIFICATE := platform
 LOCAL_JNI_SHARED_LIBRARIES := libnqnfc_nci_jni
 LOCAL_JAVA_LIBRARIES := com.nxp.nfc.nq
 LOCAL_PROGUARD_ENABLED := disabled
-LOCAL_STATIC_JAVA_LIBRARIES := android-support-v4
+LOCAL_STATIC_JAVA_LIBRARIES := android-support-core-utils
 
 LOCAL_MODULE_OWNER := nxp
 LOCAL_PRIVATE_PLATFORM_APIS := true
diff --git a/AndroidManifest.xml b/AndroidManifest.xml
index b9e83254..d91d0d57 100644
--- a/AndroidManifest.xml
+++ b/AndroidManifest.xml
@@ -13,6 +13,22 @@
      See the License for the specific language governing permissions and
      limitations under the License.
 -->
+<!-- The original Work has been changed by NXP Semiconductors.
+
+     Copyright 2018 NXP
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+ -->
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
         package="com.android.nfc"
         android:sharedUserId="android.uid.nfc"
@@ -52,10 +68,19 @@
     <uses-permission android:name="android.permission.DISPATCH_NFC_MESSAGE" />
     <uses-permission android:name="android.permission.OVERRIDE_WIFI_CONFIG" />
     <uses-permission android:name="android.permission.DEVICE_POWER" />
+    <uses-permission android:name="android.permission.ACCESS_VR_MANAGER"/>
     <uses-permission android:name="android.permission.USER_ACTIVITY" />
+    <uses-permission android:name="android.permission.SEND_RECEIVE_STK_INTENT" />
     <uses-permission android:name="android.permission.BIND_RESOLVER_RANKER_SERVICE" />
+    <uses-permission android:name="android.permission.REQUEST_INSTALL_PACKAGES" />
     <protected-broadcast android:name="com.nxp.action.TRANSACTION_DETECTED" />
     <protected-broadcast android:name="com.gsma.services.nfc.action.TRANSACTION_EVENT" />
+    <protected-broadcast android:name="com.nxp.nfc_extras.action.NFC_MPOS_READER_MODE_RESTART" />
+    <protected-broadcast android:name="com.nxp.nfc_extras.action.NFC_MPOS_READER_MODE_TIMEOUT" />
+    <protected-broadcast android:name="com.nxp.nfc_extras.action.NFC_MPOS_READER_MODE_REMOVE_CARD" />
+    <protected-broadcast android:name="com.nxp.nfc_extras.action.NFC_MPOS_READER_MODE_STOP_SUCCESS" />
+    <protected-broadcast android:name="com.nxp.nfc_extras.action.NFC_MPOS_READER_MODE_START_FAIL" />
+    <protected-broadcast android:name="com.nxp.nfc_extras.action.NFC_MPOS_READER_MODE_START_SUCCESS" />
     <permission-group android:name ="com.gsma.services.nfc.permission"
                       android:label ="@string/permgrouplab_NFC"
                       android:description="@string/permgroupdesc_NFC"
@@ -75,6 +100,7 @@
                  android:killAfterRestore="false"
                  android:usesCleartextTraffic="false"
                  android:supportsRtl="true"
+                 android:hardwareAccelerated="false"
     >
         <meta-data android:name="com.google.android.backup.api_key"
             android:value="AEdPqrEAAAAIbiKKs0wlimxeJ9y8iRIaBOH6aeb2IurmZyBHvg" />
@@ -109,14 +135,6 @@
             android:multiprocess="true"
         />
 
-        <activity android:name=".cardemulation.DefaultRemovedActivity"
-            android:theme="@*android:style/Theme.Material.Dialog.Alert"
-            android:finishOnCloseSystemDialogs="true"
-            android:excludeFromRecents="true"
-            android:clearTaskOnLaunch="true"
-            android:multiprocess="true"
-        />
-
         <activity android:name=".cardemulation.TapAgainDialog"
             android:finishOnCloseSystemDialogs="true"
             android:excludeFromRecents="true"
@@ -167,6 +185,12 @@
             android:process=":beam"
         />
 
+        <receiver android:name=".NfcBootCompletedReceiver">
+            <intent-filter>
+                <action android:name="android.intent.action.BOOT_COMPLETED" />
+            </intent-filter>
+        </receiver>
+
         <service android:name=".handover.PeripheralHandoverService"
         />
         <uses-library android:name="com.nxp.nfc.nq"
diff --git a/OWNERS b/OWNERS
new file mode 100644
index 00000000..0cde1f54
--- /dev/null
+++ b/OWNERS
@@ -0,0 +1,2 @@
+eisenbach@google.com
+kandoiruchi@google.com
\ No newline at end of file
diff --git a/PREUPLOAD.cfg b/PREUPLOAD.cfg
new file mode 100644
index 00000000..213c93ac
--- /dev/null
+++ b/PREUPLOAD.cfg
@@ -0,0 +1,5 @@
+[Options]
+ignore_merged_commits = true
+
+[Builtin Hooks]
+clang_format = true
diff --git a/README.md b/README.md
index 46f881f6..253c00b1 100644
--- a/README.md
+++ b/README.md
@@ -42,3 +42,17 @@
 | android-o-preview2                     |  8.0.C_O (PN553/PN557) |  NFC_NCIHALx_AR1800.8.0.C_O_OpnSrc |
 | android-o-preview2                     |  8.0.13_O (PN553/PN557) |  NFC_NCIHALx_AR18C0.8.0.13_O_OpnSrc |
 | android-8.0.0_r4               |  8.1.0_O (PN553) |  NFC_NCIHALx_AR00C0.8.1.0_O_OpnSrc |
+| android-8.0.0_r4               |  8.2.0_O (PN557) |  NFC_NCIHALx_AR18C0.8.2.0_O_OpnSrc |
+| android-8.0.0_r4               |  8.2.3_O (PN557) |  NFC_NCIHALx_AR18C0.8.2.3_O_OpnSrc |
+| android-8.0.0_r4               |  8.3.0_O (PN548C2/PN551/PN553) |  NFC_NCIHALx_AR0054.8.3.0_O_OpnSrc |
+| android-8.0.0_r4               |  8.3.0_O (PN548C2/PN551) | NFC_NCIHALx_AR003C.8.3.0_O_OpnSrc  |
+| android-8.0.0_r4/android-8.1.0_r7              |  8.4.0_O (PN548C2/PN551/PN553/PN557) |  NFC_NCIHALx_AR00C0.8.4.0_OpnSrc |
+
+####Supported Versions on "br_android_ncihalx_row_p" Branch
+
+| Android Version        | NXP Release          | NXP Tag  |
+| :-------------: |:-------------:| :-----:|
+| android-p-preview 2               |  9.0.D (PN553) |  NFC_NCIHALx_AR00C0.9.0.D_OpnSrc |
+| android-9.0.0_r3              |  9.1.0 (PN557) |  NFC_NCIHALx_AR0800.9.1.0_OpnSrc |
+| android-9.0.0_r3              |  9.2.0 (PN81T/PN557) |  NFC_NCIHALx_AR1800.9.2.0_OpnSrc |
+| android-9.0.0_r3              |  9.3.0 (PN553) |  NFC_NCIHALx_AR0040.9.3.0_OpnSrc |
diff --git a/nci/jni/Android.mk b/nci/jni/Android.mk
old mode 100644
new mode 100755
index 2dc9600e..05c7df9f
--- a/nci/jni/Android.mk
+++ b/nci/jni/Android.mk
@@ -1,4 +1,5 @@
 VOB_COMPONENTS := vendor/nxp/opensource/commonsys/external/libnfc-nci/src
+LIBNFC_PATH := vendor/nxp/opensource/commonsys/external/libnfc-nci
 NFA := $(VOB_COMPONENTS)/nfa
 NFC := $(VOB_COMPONENTS)/nfc
 
@@ -12,7 +13,7 @@ ifneq ($(NCI_VERSION),)
 LOCAL_CFLAGS += -DNCI_VERSION=$(NCI_VERSION) -O0 -g
 endif
 
-LOCAL_CFLAGS += -Wall -Wextra -Wno-unused-parameter
+LOCAL_CFLAGS += -Wall -Wextra -Wno-unused-parameter -DDCHECK_ALWAYS_ON=TRUE
 
 #NXP PN547 Enable
 LOCAL_CFLAGS += -DNXP_EXTNS=TRUE
@@ -22,8 +23,6 @@ LOCAL_CFLAGS += -DNFC_NXP_HFO_SETTINGS=FALSE
 #Enable HCE-F specific
 LOCAL_CFLAGS += -DNXP_NFCC_HCE_F=TRUE
 
-NFC_NXP_ESE:= TRUE
-
 NFC_POWER_MANAGEMENT:= TRUE
 ifeq ($(NFC_POWER_MANAGEMENT),TRUE)
 LOCAL_CFLAGS += -DNFC_POWER_MANAGEMENT=TRUE
@@ -31,16 +30,13 @@ else
 LOCAL_CFLAGS += -DNFC_POWER_MANAGEMENT=FALSE
 endif
 
-ifeq ($(NFC_NXP_ESE),TRUE)
 LOCAL_CFLAGS += -DNXP_LDR_SVC_VER_2=TRUE
-else
-LOCAL_CFLAGS += -DNXP_LDR_SVC_VER_2=FALSE
-endif
 
 LOCAL_SRC_FILES := $(call all-subdir-cpp-files) $(call all-subdir-c-files)
 
 LOCAL_C_INCLUDES += \
     frameworks/native/include \
+    libnativehelper/include/nativehelper \
     $(NFA)/include \
     $(NFA)/brcm \
     $(NFC)/include \
@@ -50,12 +46,9 @@ LOCAL_C_INCLUDES += \
     $(VOB_COMPONENTS)/hal/int \
     $(VOB_COMPONENTS)/include \
     $(VOB_COMPONENTS)/gki/ulinux \
-    $(VOB_COMPONENTS)/gki/common
-
-ifeq ($(NFC_NXP_ESE),TRUE)
-LOCAL_C_INCLUDES += vendor/nxp/opensource/commonsys/external/libnfc-nci/p61-jcop-kit/include
-
-endif
+    $(VOB_COMPONENTS)/gki/common \
+    $(LIBNFC_PATH)/utils/include \
+    vendor/nxp/opensource/halimpl/extns/impl
 
 LOCAL_SHARED_LIBRARIES := \
     libicuuc \
@@ -63,11 +56,12 @@ LOCAL_SHARED_LIBRARIES := \
     libcutils \
     libutils \
     liblog \
-    libnqnfc-nci
-
-ifeq ($(NFC_NXP_ESE),TRUE)
-LOCAL_SHARED_LIBRARIES += libnqp61-jcop-kit
-endif
+    libnqnfc-nci \
+    libchrome \
+    libbase \
+    android.hardware.nfc@1.0 \
+    android.hardware.nfc@1.1 \
+    vendor.nxp.hardware.nfc@1.0
 
 #LOCAL_STATIC_LIBRARIES := libxml2
 ifeq (true,$(TARGET_IS_64_BIT))
diff --git a/nci/jni/CondVar.cpp b/nci/jni/CondVar.cpp
index 6c3ebb5c..2b00bc78 100644
--- a/nci/jni/CondVar.cpp
+++ b/nci/jni/CondVar.cpp
@@ -19,12 +19,12 @@
  */
 
 #include "CondVar.h"
-#include "NfcJniUtil.h"
-
-#include <log/log.h>
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
 #include <errno.h>
+#include "NfcJniUtil.h"
 
-
+using android::base::StringPrintf;
 /*******************************************************************************
 **
 ** Function:        CondVar
@@ -34,23 +34,20 @@
 ** Returns:         None.
 **
 *******************************************************************************/
-CondVar::CondVar ()
-{
-    pthread_condattr_t attr;
-    pthread_condattr_init(&attr);
-    pthread_condattr_setclock(&attr, CLOCK_MONOTONIC);
-    memset (&mCondition, 0, sizeof(mCondition));
-    int const res = pthread_cond_init (&mCondition, &attr);
-    if (res)
-    {
-        ALOGE("CondVar::CondVar: fail init; error=0x%X", res);
-    }
+CondVar::CondVar() {
+  pthread_condattr_t attr;
+  pthread_condattr_init(&attr);
+  pthread_condattr_setclock(&attr, CLOCK_MONOTONIC);
+  memset(&mCondition, 0, sizeof(mCondition));
+  int const res = pthread_cond_init(&mCondition, &attr);
+  if (res) {
+    LOG(ERROR) << StringPrintf("CondVar::CondVar: fail init; error=0x%X", res);
+  }
 #if (NXP_EXTNS == TRUE)
-    pthread_condattr_destroy(&attr);
+  pthread_condattr_destroy(&attr);
 #endif
 }
 
-
 /*******************************************************************************
 **
 ** Function:        ~CondVar
@@ -60,16 +57,14 @@ CondVar::CondVar ()
 ** Returns:         None.
 **
 *******************************************************************************/
-CondVar::~CondVar ()
-{
-    int const res = pthread_cond_destroy (&mCondition);
-    if (res)
-    {
-        ALOGE("CondVar::~CondVar: fail destroy; error=0x%X", res);
-    }
+CondVar::~CondVar() {
+  int const res = pthread_cond_destroy(&mCondition);
+  if (res) {
+    LOG(ERROR) << StringPrintf("CondVar::~CondVar: fail destroy; error=0x%X",
+                               res);
+  }
 }
 
-
 /*******************************************************************************
 **
 ** Function:        wait
@@ -79,16 +74,13 @@ CondVar::~CondVar ()
 ** Returns:         None.
 **
 *******************************************************************************/
-void CondVar::wait (Mutex& mutex)
-{
-    int const res = pthread_cond_wait (&mCondition, mutex.nativeHandle());
-    if (res)
-    {
-        ALOGE("CondVar::wait: fail wait; error=0x%X", res);
-    }
+void CondVar::wait(Mutex& mutex) {
+  int const res = pthread_cond_wait(&mCondition, mutex.nativeHandle());
+  if (res) {
+    LOG(ERROR) << StringPrintf("CondVar::wait: fail wait; error=0x%X", res);
+  }
 }
 
-
 /*******************************************************************************
 **
 ** Function:        wait
@@ -99,36 +91,32 @@ void CondVar::wait (Mutex& mutex)
 ** Returns:         True if wait is successful; false if timeout occurs.
 **
 *******************************************************************************/
-bool CondVar::wait (Mutex& mutex, long millisec)
-{
-    bool retVal = false;
-    struct timespec absoluteTime;
+bool CondVar::wait(Mutex& mutex, long millisec) {
+  bool retVal = false;
+  struct timespec absoluteTime;
 
-    if (clock_gettime (CLOCK_MONOTONIC, &absoluteTime) == -1)
-    {
-        ALOGE("CondVar::wait: fail get time; errno=0x%X", errno);
-    }
-    else
-    {
-        absoluteTime.tv_sec += millisec / 1000;
-        long ns = absoluteTime.tv_nsec + ((millisec % 1000) * 1000000);
-        if (ns > 1000000000)
-        {
-            absoluteTime.tv_sec++;
-            absoluteTime.tv_nsec = ns - 1000000000;
-        }
-        else
-            absoluteTime.tv_nsec = ns;
-    }
+  if (clock_gettime(CLOCK_MONOTONIC, &absoluteTime) == -1) {
+    LOG(ERROR) << StringPrintf("CondVar::wait: fail get time; errno=0x%X",
+                               errno);
+  } else {
+    absoluteTime.tv_sec += millisec / 1000;
+    long ns = absoluteTime.tv_nsec + ((millisec % 1000) * 1000000);
+    if (ns > 1000000000) {
+      absoluteTime.tv_sec++;
+      absoluteTime.tv_nsec = ns - 1000000000;
+    } else
+      absoluteTime.tv_nsec = ns;
+  }
 
-    int waitResult = pthread_cond_timedwait (&mCondition, mutex.nativeHandle(), &absoluteTime);
-    if ((waitResult != 0) && (waitResult != ETIMEDOUT))
-        ALOGE("CondVar::wait: fail timed wait; error=0x%X", waitResult);
-    retVal = (waitResult == 0); //waited successfully
-    return retVal;
+  int waitResult =
+      pthread_cond_timedwait(&mCondition, mutex.nativeHandle(), &absoluteTime);
+  if ((waitResult != 0) && (waitResult != ETIMEDOUT))
+    LOG(ERROR) << StringPrintf("CondVar::wait: fail timed wait; error=0x%X",
+                               waitResult);
+  retVal = (waitResult == 0);  // waited successfully
+  return retVal;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        notifyOne
@@ -138,11 +126,10 @@ bool CondVar::wait (Mutex& mutex, long millisec)
 ** Returns:         None.
 **
 *******************************************************************************/
-void CondVar::notifyOne ()
-{
-    int const res = pthread_cond_signal (&mCondition);
-    if (res)
-    {
-        ALOGE("CondVar::notifyOne: fail signal; error=0x%X", res);
-    }
+void CondVar::notifyOne() {
+  int const res = pthread_cond_signal(&mCondition);
+  if (res) {
+    LOG(ERROR) << StringPrintf("CondVar::notifyOne: fail signal; error=0x%X",
+                               res);
+  }
 }
diff --git a/nci/jni/CondVar.h b/nci/jni/CondVar.h
index c286d5ca..a2be51fe 100644
--- a/nci/jni/CondVar.h
+++ b/nci/jni/CondVar.h
@@ -22,70 +22,64 @@
 #include <pthread.h>
 #include "Mutex.h"
 
+class CondVar {
+ public:
+  /*******************************************************************************
+  **
+  ** Function:        CondVar
+  **
+  ** Description:     Initialize member variables.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  CondVar();
 
-class CondVar
-{
-public:
-    /*******************************************************************************
-    **
-    ** Function:        CondVar
-    **
-    ** Description:     Initialize member variables.
-    **
-    ** Returns:         None.
-    **
-    *******************************************************************************/
-    CondVar ();
+  /*******************************************************************************
+  **
+  ** Function:        ~CondVar
+  **
+  ** Description:     Cleanup all resources.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  ~CondVar();
 
+  /*******************************************************************************
+  **
+  ** Function:        wait
+  **
+  ** Description:     Block the caller and wait for a condition.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  void wait(Mutex& mutex);
 
-    /*******************************************************************************
-    **
-    ** Function:        ~CondVar
-    **
-    ** Description:     Cleanup all resources.
-    **
-    ** Returns:         None.
-    **
-    *******************************************************************************/
-    ~CondVar ();
+  /*******************************************************************************
+  **
+  ** Function:        wait
+  **
+  ** Description:     Block the caller and wait for a condition.
+  **                  millisec: Timeout in milliseconds.
+  **
+  ** Returns:         True if wait is successful; false if timeout occurs.
+  **
+  *******************************************************************************/
+  bool wait(Mutex& mutex, long millisec);
 
+  /*******************************************************************************
+  **
+  ** Function:        notifyOne
+  **
+  ** Description:     Unblock the waiting thread.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  void notifyOne();
 
-    /*******************************************************************************
-    **
-    ** Function:        wait
-    **
-    ** Description:     Block the caller and wait for a condition.
-    **
-    ** Returns:         None.
-    **
-    *******************************************************************************/
-    void wait (Mutex& mutex);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        wait
-    **
-    ** Description:     Block the caller and wait for a condition.
-    **                  millisec: Timeout in milliseconds.
-    **
-    ** Returns:         True if wait is successful; false if timeout occurs.
-    **
-    *******************************************************************************/
-    bool wait (Mutex& mutex, long millisec);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        notifyOne
-    **
-    ** Description:     Unblock the waiting thread.
-    **
-    ** Returns:         None.
-    **
-    *******************************************************************************/
-    void notifyOne ();
-
-private:
-    pthread_cond_t mCondition;
+ private:
+  pthread_cond_t mCondition;
 };
diff --git a/nci/jni/DataQueue.cpp b/nci/jni/DataQueue.cpp
index 855c1a5b..f417db70 100644
--- a/nci/jni/DataQueue.cpp
+++ b/nci/jni/DataQueue.cpp
@@ -19,10 +19,10 @@
  */
 
 #include "DataQueue.h"
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
 
-#include <log/log.h>
-
-
+using android::base::StringPrintf;
 /*******************************************************************************
 **
 ** Function:        DataQueue
@@ -32,10 +32,7 @@
 ** Returns:         None.
 **
 *******************************************************************************/
-DataQueue::DataQueue ()
-{
-}
-
+DataQueue::DataQueue() {}
 
 /*******************************************************************************
 **
@@ -46,28 +43,23 @@ DataQueue::DataQueue ()
 ** Returns:         None.
 **
 *******************************************************************************/
-DataQueue::~DataQueue ()
-{
-    mMutex.lock ();
-    while (mQueue.empty() == false)
-    {
-        tHeader* header = mQueue.front ();
-        mQueue.pop_front ();
-        free (header);
-    }
-    mMutex.unlock ();
+DataQueue::~DataQueue() {
+  mMutex.lock();
+  while (mQueue.empty() == false) {
+    tHeader* header = mQueue.front();
+    mQueue.pop_front();
+    free(header);
+  }
+  mMutex.unlock();
 }
 
-
-bool DataQueue::isEmpty()
-{
-    mMutex.lock ();
-    bool retval = mQueue.empty();
-    mMutex.unlock ();
-    return retval;
+bool DataQueue::isEmpty() {
+  mMutex.lock();
+  bool retval = mQueue.empty();
+  mMutex.unlock();
+  return retval;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        enqueue
@@ -79,35 +71,29 @@ bool DataQueue::isEmpty()
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-bool DataQueue::enqueue (uint8_t* data, uint16_t dataLen)
-{
-    if ((data == NULL) || (dataLen==0))
-        return false;
+bool DataQueue::enqueue(uint8_t* data, uint16_t dataLen) {
+  if ((data == NULL) || (dataLen == 0)) return false;
 
-    mMutex.lock ();
+  mMutex.lock();
 
-    bool retval = false;
-    tHeader* header = (tHeader*) malloc (sizeof(tHeader) + dataLen);
+  bool retval = false;
+  tHeader* header = (tHeader*)malloc(sizeof(tHeader) + dataLen);
 
-    if (header)
-    {
-        memset (header, 0, sizeof(tHeader));
-        header->mDataLen = dataLen;
-        memcpy (header+1, data, dataLen);
+  if (header) {
+    memset(header, 0, sizeof(tHeader));
+    header->mDataLen = dataLen;
+    memcpy(header + 1, data, dataLen);
 
-        mQueue.push_back (header);
+    mQueue.push_back(header);
 
-        retval = true;
-    }
-    else
-    {
-        ALOGE("DataQueue::enqueue: out of memory ?????");
-    }
-    mMutex.unlock ();
-    return retval;
+    retval = true;
+  } else {
+    LOG(ERROR) << StringPrintf("DataQueue::enqueue: out of memory ?????");
+  }
+  mMutex.unlock();
+  return retval;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        dequeue
@@ -120,37 +106,33 @@ bool DataQueue::enqueue (uint8_t* data, uint16_t dataLen)
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-bool DataQueue::dequeue (uint8_t* buffer, uint16_t bufferMaxLen, uint16_t& actualLen)
-{
-    mMutex.lock ();
-
-    tHeader* header = mQueue.front ();
-    bool retval = false;
-
-    if (header && buffer && (bufferMaxLen>0))
-    {
-        if (header->mDataLen <= bufferMaxLen)
-        {
-            //caller's buffer is big enough to store all data
-            actualLen = header->mDataLen;
-            char* src = (char*)(header) + sizeof(tHeader) + header->mOffset;
-            memcpy (buffer, src, actualLen);
-
-            mQueue.pop_front ();
-            free (header);
-        }
-        else
-        {
-            //caller's buffer is too small
-            actualLen = bufferMaxLen;
-            char* src = (char*)(header) + sizeof(tHeader) + header->mOffset;
-            memcpy (buffer, src, actualLen);
-            //adjust offset so the next dequeue() will get the remainder
-            header->mDataLen -= actualLen;
-            header->mOffset += actualLen;
-        }
-        retval = true;
+bool DataQueue::dequeue(uint8_t* buffer, uint16_t bufferMaxLen,
+                        uint16_t& actualLen) {
+  mMutex.lock();
+
+  tHeader* header = mQueue.front();
+  bool retval = false;
+
+  if (header && buffer && (bufferMaxLen > 0)) {
+    if (header->mDataLen <= bufferMaxLen) {
+      // caller's buffer is big enough to store all data
+      actualLen = header->mDataLen;
+      char* src = (char*)(header) + sizeof(tHeader) + header->mOffset;
+      memcpy(buffer, src, actualLen);
+
+      mQueue.pop_front();
+      free(header);
+    } else {
+      // caller's buffer is too small
+      actualLen = bufferMaxLen;
+      char* src = (char*)(header) + sizeof(tHeader) + header->mOffset;
+      memcpy(buffer, src, actualLen);
+      // adjust offset so the next dequeue() will get the remainder
+      header->mDataLen -= actualLen;
+      header->mOffset += actualLen;
     }
-    mMutex.unlock ();
-    return retval;
+    retval = true;
+  }
+  mMutex.unlock();
+  return retval;
 }
diff --git a/nci/jni/DataQueue.h b/nci/jni/DataQueue.h
index 44544775..d6dc85ae 100644
--- a/nci/jni/DataQueue.h
+++ b/nci/jni/DataQueue.h
@@ -19,88 +19,81 @@
  */
 
 #pragma once
-#include "NfcJniUtil.h"
-#include "gki.h"
-#include "Mutex.h"
 #include <cstdlib>
 #include <list>
+#include "Mutex.h"
+#include "NfcJniUtil.h"
+#include "gki.h"
 
+class DataQueue {
+ public:
+  /*******************************************************************************
+  **
+  ** Function:        DataQueue
+  **
+  ** Description:     Initialize member variables.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  DataQueue();
 
-class DataQueue
-{
-public:
-    /*******************************************************************************
-    **
-    ** Function:        DataQueue
-    **
-    ** Description:     Initialize member variables.
-    **
-    ** Returns:         None.
-    **
-    *******************************************************************************/
-    DataQueue ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        ~DataQueue
-    **
-    ** Description:      Release all resources.
-    **
-    ** Returns:         None.
-    **
-    *******************************************************************************/
-    ~DataQueue ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        enqueue
-    **
-    ** Description:     Append data to the queue.
-    **                  data: array of bytes
-    **                  dataLen: length of the data.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    bool enqueue (uint8_t* data, uint16_t dataLen);
-
+  /*******************************************************************************
+  **
+  ** Function:        ~DataQueue
+  **
+  ** Description:      Release all resources.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  ~DataQueue();
 
-    /*******************************************************************************
-    **
-    ** Function:        dequeue
-    **
-    ** Description:     Retrieve and remove data from the front of the queue.
-    **                  buffer: array to store the data.
-    **                  bufferMaxLen: maximum size of the buffer.
-    **                  actualLen: actual length of the data.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    bool dequeue (uint8_t* buffer, uint16_t bufferMaxLen, uint16_t& actualLen);
+  /*******************************************************************************
+  **
+  ** Function:        enqueue
+  **
+  ** Description:     Append data to the queue.
+  **                  data: array of bytes
+  **                  dataLen: length of the data.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool enqueue(uint8_t* data, uint16_t dataLen);
 
+  /*******************************************************************************
+  **
+  ** Function:        dequeue
+  **
+  ** Description:     Retrieve and remove data from the front of the queue.
+  **                  buffer: array to store the data.
+  **                  bufferMaxLen: maximum size of the buffer.
+  **                  actualLen: actual length of the data.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool dequeue(uint8_t* buffer, uint16_t bufferMaxLen, uint16_t& actualLen);
 
-    /*******************************************************************************
-    **
-    ** Function:        isEmpty
-    **
-    ** Description:     Whether the queue is empty.
-    **
-    ** Returns:         True if empty.
-    **
-    *******************************************************************************/
-    bool isEmpty();
+  /*******************************************************************************
+  **
+  ** Function:        isEmpty
+  **
+  ** Description:     Whether the queue is empty.
+  **
+  ** Returns:         True if empty.
+  **
+  *******************************************************************************/
+  bool isEmpty();
 
-private:
-    struct tHeader
-    {
-        uint16_t mDataLen; //number of octets of data
-        uint16_t mOffset; //offset of the first octet of data
-    };
-    typedef std::list<tHeader*> Queue;
+ private:
+  struct tHeader {
+    uint16_t mDataLen;  // number of octets of data
+    uint16_t mOffset;   // offset of the first octet of data
+  };
+  typedef std::list<tHeader*> Queue;
 
-    Queue mQueue;
-    Mutex mMutex;
+  Queue mQueue;
+  Mutex mMutex;
 };
diff --git a/nci/jni/DwpChannel.cpp b/nci/jni/DwpChannel.cpp
old mode 100644
new mode 100755
index f25f765d..4cc3090c
--- a/nci/jni/DwpChannel.cpp
+++ b/nci/jni/DwpChannel.cpp
@@ -13,24 +13,28 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
 #include "DwpChannel.h"
-#include "SecureElement.h"
-#include "RoutingManager.h"
 #include <cutils/log.h>
+#include "RoutingManager.h"
+#include "SecureElement.h"
 #include "config.h"
 #include "phNxpConfig.h"
+#include "nfc_config.h"
+using android::base::StringPrintf;
+static const int EE_ERROR_OPEN_FAIL = -1;
 
-static const int EE_ERROR_OPEN_FAIL =  -1;
+extern bool nfc_debug_enabled;
 
 bool IsWiredMode_Enable();
 bool eSE_connected = false;
 bool dwpChannelForceClose = false;
 DwpChannel DwpChannel::sDwpChannel;
-namespace android
-{
-    extern void checkforNfceeConfig();
-    extern int gMaxEERecoveryTimeout;
-}
+namespace android {
+extern void checkforNfceeConfig();
+extern int gMaxEERecoveryTimeout;
+}  // namespace android
 
 /*******************************************************************************
 **
@@ -41,65 +45,56 @@ namespace android
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-bool IsWiredMode_Enable()
-{
-    static const char fn [] = "DwpChannel::IsWiredMode_Enable";
-    ALOGV("%s: enter", fn);
-    SecureElement &se = SecureElement::getInstance();
-    tNFA_STATUS stat = NFA_STATUS_FAILED;
+bool IsWiredMode_Enable() {
+  static const char fn[] = "DwpChannel::IsWiredMode_Enable";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+  SecureElement& se = SecureElement::getInstance();
+  tNFA_STATUS stat = NFA_STATUS_FAILED;
 
-    uint8_t mActualNumEe  = nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED;
-    uint16_t meSE         = 0x4C0;
-    tNFA_EE_INFO EeInfo[mActualNumEe];
+  uint8_t mActualNumEe = nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED;
+  uint16_t meSE = 0x4C0;
+  tNFA_EE_INFO EeInfo[mActualNumEe];
 
 #if 0
     if(mIsInit == false)
     {
-        ALOGV("%s: JcopOs Dwnld is not initialized", fn);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: JcopOs Dwnld is not initialized", fn);
         goto TheEnd;
     }
 #endif
-    stat = NFA_EeGetInfo(&mActualNumEe, EeInfo);
-    if(stat == NFA_STATUS_OK)
-    {
-        for(int xx = 0; xx <  mActualNumEe; xx++)
-        {
-            ALOGI("xx=%d, ee_handle=0x0%x, status=0x0%x", xx, EeInfo[xx].ee_handle,EeInfo[xx].ee_status);
-            if (EeInfo[xx].ee_handle == meSE)
-            {
-                if(EeInfo[xx].ee_status == 0x00)
-                {
-                    stat = NFA_STATUS_OK;
-                    ALOGV("%s: status = 0x%x", fn, stat);
-                    break;
-                }
-                else if(EeInfo[xx].ee_status == 0x01)
-                {
-                    ALOGE("%s: Enable eSE-mode set ON", fn);
-                    se.SecEle_Modeset(0x01);
-                    usleep(2000 * 1000);
-                    stat = NFA_STATUS_OK;
-                    break;
-                }
-                else
-                {
-                    stat = NFA_STATUS_FAILED;
-                    break;
-                }
-            }
-            else
-            {
-                stat = NFA_STATUS_FAILED;
-            }
-
+  stat = NFA_EeGetInfo(&mActualNumEe, EeInfo);
+  if (stat == NFA_STATUS_OK) {
+    for (int xx = 0; xx < mActualNumEe; xx++) {
+      ALOGI("xx=%d, ee_handle=0x0%x, status=0x0%x", xx, EeInfo[xx].ee_handle,
+            EeInfo[xx].ee_status);
+      if (EeInfo[xx].ee_handle == meSE) {
+        if (EeInfo[xx].ee_status == 0x00) {
+          stat = NFA_STATUS_OK;
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("%s: status = 0x%x", fn, stat);
+          break;
+        } else if (EeInfo[xx].ee_status == 0x01) {
+          LOG(ERROR) << StringPrintf("%s: Enable eSE-mode set ON", fn);
+          se.SecEle_Modeset(0x01);
+          usleep(2000 * 1000);
+          stat = NFA_STATUS_OK;
+          break;
+        } else {
+          stat = NFA_STATUS_FAILED;
+          break;
         }
+      } else {
+        stat = NFA_STATUS_FAILED;
+      }
     }
-//TheEnd: /*commented to eliminate the label defined but not used warning*/
-    ALOGV("%s: exit; status = 0x%X", fn, stat);
-    if(stat == NFA_STATUS_OK)
-        return true;
-    else
-        return false;
+  }
+  // TheEnd: /*commented to eliminate the label defined but not used warning*/
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit; status = 0x%X", fn, stat);
+  if (stat == NFA_STATUS_OK)
+    return true;
+  else
+    return false;
 }
 
 /*******************************************************************************
@@ -112,66 +107,62 @@ bool IsWiredMode_Enable()
 **
 *******************************************************************************/
 
-int16_t open()
-{
-    static const char fn [] = "DwpChannel::open";
-    bool stat = false;
-    int16_t dwpHandle = EE_ERROR_OPEN_FAIL;
-    SecureElement &se = SecureElement::getInstance();
+int16_t open() {
+  static const char fn[] = "DwpChannel::open";
+  bool stat = false;
+  int16_t dwpHandle = EE_ERROR_OPEN_FAIL;
+  SecureElement& se = SecureElement::getInstance();
 
-    ALOGE("DwpChannel: Sec Element open Enter");
-if(nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION) {
+  LOG(ERROR) << StringPrintf("DwpChannel: Sec Element open Enter");
+  if (nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION) {
     DwpChannel::getInstance().Initialize();
-}
-    ALOGE("DwpChannel: Sec Element open Enter");
-    if (se.isBusy())
-    {
-        ALOGE("DwpChannel: SE is busy");
-        return EE_ERROR_OPEN_FAIL;
-    }
-
-    eSE_connected = IsWiredMode_Enable();
-    if(eSE_connected != true)
-    {
-        ALOGE("DwpChannel: Wired mode is not connected");
-        return EE_ERROR_OPEN_FAIL;
-    }
-
-    /*turn on the sec elem*/
-    stat = se.activate(SecureElement::ESE_ID);
-
-    if (stat)
-    {
-        //establish a pipe to sec elem
-        stat = se.connectEE();
-        if (!stat)
-        {
-          se.deactivate (0);
-        }else
-        {
-            dwpChannelForceClose = false;
-            dwpHandle = se.mActiveEeHandle;
-            if(nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME ==
-                    nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
-                /*NFCC shall keep secure element always powered on ;
-                 * however NFCC may deactivate communication link with
-                 * secure element.
-                 * NOTE: Since open() api does not call
-                 * nativeNfcSecureElement_doOpenSecureElementConnection()
-                 * and LS application can invoke
-                 * open(), POWER_ALWAYS_ON is needed.
-                 */
-                if(se.setNfccPwrConfig(se.POWER_ALWAYS_ON|se.COMM_LINK_ACTIVE) != NFA_STATUS_OK)
-                {
-                    ALOGV("%s: power link command failed", __func__);
-                }
-                se.SecEle_Modeset(0x01);
-            }
+  }
+  LOG(ERROR) << StringPrintf("DwpChannel: Sec Element open Enter");
+  if (se.isBusy()) {
+    LOG(ERROR) << StringPrintf("DwpChannel: SE is busy");
+    return EE_ERROR_OPEN_FAIL;
+  }
+
+  eSE_connected = IsWiredMode_Enable();
+  if (eSE_connected != true) {
+    LOG(ERROR) << StringPrintf("DwpChannel: Wired mode is not connected");
+    return EE_ERROR_OPEN_FAIL;
+  }
+
+  /*turn on the sec elem*/
+  stat = se.activate(SecureElement::ESE_ID);
+
+  if (stat) {
+    // establish a pipe to sec elem
+    stat = se.connectEE();
+    if (!stat) {
+      se.deactivate(0);
+    } else {
+      dwpChannelForceClose = false;
+      dwpHandle = se.mActiveEeHandle;
+      if (nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME ==
+          nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
+        /*NFCC shall keep secure element always powered on ;
+         * however NFCC may deactivate communication link with
+         * secure element.
+         * NOTE: Since open() api does not call
+         * nativeNfcSecureElement_doOpenSecureElementConnection()
+         * and LS application can invoke
+         * open(), POWER_ALWAYS_ON is needed.
+         */
+        if (se.setNfccPwrConfig(se.POWER_ALWAYS_ON | se.COMM_LINK_ACTIVE) !=
+            NFA_STATUS_OK) {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("%s: power link command failed", __func__);
         }
+        se.SecEle_Modeset(0x01);
+      }
     }
+  }
 
-    ALOGV("%s: Exit. dwpHandle = 0x%02x", fn,dwpHandle);
-    return dwpHandle;
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Exit. dwpHandle = 0x%02x", fn, dwpHandle);
+  return dwpHandle;
 }
 /*******************************************************************************
 **
@@ -183,66 +174,59 @@ if(nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION) {
 **
 *******************************************************************************/
 
-bool close(int16_t mHandle)
-{
-    static const char fn [] = "DwpChannel::close";
-    ALOGV("%s: enter", fn);
-    bool stat = false;
-    SecureElement &se = SecureElement::getInstance();
-    if(nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION) {
-        DwpChannel::getInstance().finalize();
-    }
-    if(mHandle == EE_ERROR_OPEN_FAIL)
-    {
-        ALOGV("%s: Channel access denied. Returning", fn);
-        return stat;
-    }
-    if(eSE_connected != true)
-        return true;
-
-#if(NXP_EXTNS == TRUE)
-    if(nfcFL.nfcNxpEse) {
-        se.NfccStandByOperation(STANDBY_MODE_ON);
-    }
+bool close(int16_t mHandle) {
+  static const char fn[] = "DwpChannel::close";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+  bool stat = false;
+  SecureElement& se = SecureElement::getInstance();
+  if (nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION) {
+    DwpChannel::getInstance().finalize();
+  }
+  if (mHandle == EE_ERROR_OPEN_FAIL) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Channel access denied. Returning", fn);
+    return stat;
+  }
+  if (eSE_connected != true) return true;
+
+#if (NXP_EXTNS == TRUE)
+  if (nfcFL.nfcNxpEse) {
+    se.NfccStandByOperation(STANDBY_MODE_ON);
+  }
 #endif
 
-    stat = se.disconnectEE (SecureElement::ESE_ID);
+  stat = se.disconnectEE(SecureElement::ESE_ID);
 
-    //if controller is not routing AND there is no pipe connected,
-    //then turn off the sec elem
-    if(((nfcFL.chipType == pn547C2) && (nfcFL.nfcNxpEse)) &&
-            (! se.isBusy())) {
-        se.deactivate (SecureElement::ESE_ID);
-    }
-     return stat;
+  // if controller is not routing AND there is no pipe connected,
+  // then turn off the sec elem
+  if (((nfcFL.chipType == pn547C2) && (nfcFL.nfcNxpEse)) && (!se.isBusy())) {
+    se.deactivate(SecureElement::ESE_ID);
+  }
+  return stat;
 }
 
-bool transceive (uint8_t* xmitBuffer, int32_t xmitBufferSize, uint8_t* recvBuffer,
-                 int32_t recvBufferMaxSize, int32_t& recvBufferActualSize, int32_t timeoutMillisec)
-{
-    static const char fn [] = "DwpChannel::transceive";
-    eTransceiveStatus stat = TRANSCEIVE_STATUS_FAILED;
-    SecureElement &se = SecureElement::getInstance();
-    ALOGV("%s: enter", fn);
-
-    /*When Nfc deinitialization triggered*/
-    if(dwpChannelForceClose == true)
-        return stat;
-
-    if(nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION && DwpChannel::getInstance().dwpChannelForceClose)
-    {
-        ALOGV("%s: exit", fn);
-        return stat;
-    }
-
-    stat = se.transceive (xmitBuffer,
-                          xmitBufferSize,
-                          recvBuffer,
-                          recvBufferMaxSize,
-                          recvBufferActualSize,
-                          timeoutMillisec);
-    ALOGV("%s: exit", fn);
-    return ((stat == TRANSCEIVE_STATUS_OK) ? true : false);
+bool transceive(uint8_t* xmitBuffer, int32_t xmitBufferSize,
+                uint8_t* recvBuffer, int32_t recvBufferMaxSize,
+                int32_t& recvBufferActualSize, int32_t timeoutMillisec) {
+  static const char fn[] = "DwpChannel::transceive";
+  eTransceiveStatus stat = TRANSCEIVE_STATUS_FAILED;
+  SecureElement& se = SecureElement::getInstance();
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+
+  /*When Nfc deinitialization triggered*/
+  if (dwpChannelForceClose == true) return stat;
+
+  if (nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION &&
+      DwpChannel::getInstance().dwpChannelForceClose) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
+    return stat;
+  }
+
+  stat =
+      se.transceive(xmitBuffer, xmitBufferSize, recvBuffer, recvBufferMaxSize,
+                    recvBufferActualSize, timeoutMillisec);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
+  return ((stat == TRANSCEIVE_STATUS_OK) ? true : false);
 }
 
 /*******************************************************************************
@@ -254,10 +238,7 @@ bool transceive (uint8_t* xmitBuffer, int32_t xmitBufferSize, uint8_t* recvBuffe
 ** Returns:         None.
 **
 *******************************************************************************/
-DwpChannel::DwpChannel ()
-    :dwpChannelForceClose(false)
-{
-}
+DwpChannel::DwpChannel() : dwpChannelForceClose(false) {}
 
 /*******************************************************************************
 **
@@ -268,9 +249,7 @@ DwpChannel::DwpChannel ()
 ** Returns:         None.
 **
 *******************************************************************************/
-DwpChannel::~DwpChannel ()
-{
-}
+DwpChannel::~DwpChannel() {}
 
 /*******************************************************************************
 **
@@ -281,10 +260,7 @@ DwpChannel::~DwpChannel ()
 ** Returns:         DwpChannel instance.
 **
 *******************************************************************************/
-DwpChannel& DwpChannel::getInstance()
-{
-    return sDwpChannel;
-}
+DwpChannel& DwpChannel::getInstance() { return sDwpChannel; }
 
 /*******************************************************************************
 **
@@ -295,10 +271,7 @@ DwpChannel& DwpChannel::getInstance()
 ** Returns:         None
 **
 *******************************************************************************/
-void DwpChannel::finalize()
-{
-    dwpChannelForceClose = false;
-}
+void DwpChannel::finalize() { dwpChannelForceClose = false; }
 
 /*******************************************************************************
 **
@@ -309,10 +282,7 @@ void DwpChannel::finalize()
 ** Returns:         None.
 **
 *******************************************************************************/
-void DwpChannel::Initialize()
-{
-    dwpChannelForceClose = false;
-}
+void DwpChannel::Initialize() { dwpChannelForceClose = false; }
 /*******************************************************************************
 **
 ** Function:        DwpChannel's force exit
@@ -322,55 +292,51 @@ void DwpChannel::Initialize()
 ** Returns:         None.
 **
 *******************************************************************************/
-void DwpChannel::forceClose()
-{
-    static const char fn [] = "DwpChannel::doDwpChannel_ForceExit";
-    ALOGV("%s: Enter:", fn);
-    if(!nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION) {
-        ALOGV("%s: ESE_JCOP_DWNLD_PROTECTION not available. Returning", fn);
-        return;
-    }
-    dwpChannelForceClose = true;
-    ALOGV("%s: Exit:", fn);
+void DwpChannel::forceClose() {
+  static const char fn[] = "DwpChannel::doDwpChannel_ForceExit";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Enter:", fn);
+  if (!nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: ESE_JCOP_DWNLD_PROTECTION not available. Returning", fn);
+    return;
+  }
+  dwpChannelForceClose = true;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Exit:", fn);
 }
 
-void doeSE_Reset(void)
-{
-    static const char fn [] = "DwpChannel::doeSE_Reset";
-    SecureElement &se = SecureElement::getInstance();
-    RoutingManager &rm = RoutingManager::getInstance();
-    ALOGV("%s: enter:", fn);
-
-    rm.mResetHandlerMutex.lock();
-    ALOGV("1st mode set calling");
-    se.SecEle_Modeset(0x00);
-    usleep(100 * 1000);
-    ALOGV("1st mode set called");
-    ALOGV("2nd mode set calling");
-
-    se.SecEle_Modeset(0x01);
-    ALOGV("2nd mode set called");
-
-    usleep(3000 * 1000);
-    rm.mResetHandlerMutex.unlock();
-    if((nfcFL.nfccFL._NFCEE_REMOVED_NTF_RECOVERY) &&
-            (RoutingManager::getInstance().is_ee_recovery_ongoing()))
-    {
-        ALOGE("%s: is_ee_recovery_ongoing ", fn);
-        SyncEventGuard guard (se.mEEdatapacketEvent);
-        se.mEEdatapacketEvent.wait(android::gMaxEERecoveryTimeout);
-    }
+void doeSE_Reset(void) {
+  static const char fn[] = "DwpChannel::doeSE_Reset";
+  SecureElement& se = SecureElement::getInstance();
+  RoutingManager& rm = RoutingManager::getInstance();
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter:", fn);
+
+  rm.mResetHandlerMutex.lock();
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("1st mode set calling");
+  se.SecEle_Modeset(0x00);
+  usleep(100 * 1000);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("1st mode set called");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("2nd mode set calling");
+
+  se.SecEle_Modeset(0x01);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("2nd mode set called");
+
+  usleep(3000 * 1000);
+  rm.mResetHandlerMutex.unlock();
+  if ((nfcFL.nfccFL._NFCEE_REMOVED_NTF_RECOVERY) &&
+      (RoutingManager::getInstance().is_ee_recovery_ongoing())) {
+    LOG(ERROR) << StringPrintf("%s: is_ee_recovery_ongoing ", fn);
+    SyncEventGuard guard(se.mEEdatapacketEvent);
+    se.mEEdatapacketEvent.wait(android::gMaxEERecoveryTimeout);
+  }
 }
-namespace android
-{
-    void doDwpChannel_ForceExit()
-    {
-        static const char fn [] = "DwpChannel::doDwpChannel_ForceExit";
-        ALOGV("%s: enter:", fn);
-        dwpChannelForceClose = true;
-        ALOGV("%s: exit", fn);
-    }
+namespace android {
+void doDwpChannel_ForceExit() {
+  static const char fn[] = "DwpChannel::doDwpChannel_ForceExit";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter:", fn);
+  dwpChannelForceClose = true;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
 }
+}  // namespace android
 /*******************************************************************************
 **
 ** Function:        doeSE_JcopDownLoadReset
@@ -381,115 +347,119 @@ namespace android
 ** Returns:         void.
 **
 *******************************************************************************/
-void doeSE_JcopDownLoadReset(void)
-{
-    static const char fn [] = "DwpChannel::JcopDownLoadReset";
-    /*tNFA_STATUS nfaStat = NFA_STATUS_FAILED;*/
-    SecureElement &se = SecureElement::getInstance();
-    RoutingManager &rm = RoutingManager::getInstance();
-    ALOGV("%s: enter:", fn);
-
-    rm.mResetHandlerMutex.lock();
-if (nfcFL.eseFL._ESE_RESET_METHOD && nfcFL.eseFL._ESE_POWER_MODE) {
+void doeSE_JcopDownLoadReset(void) {
+  static const char fn[] = "DwpChannel::JcopDownLoadReset";
+  /*tNFA_STATUS nfaStat = NFA_STATUS_FAILED;*/
+  SecureElement& se = SecureElement::getInstance();
+  RoutingManager& rm = RoutingManager::getInstance();
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter:", fn);
+
+  rm.mResetHandlerMutex.lock();
+  if (nfcFL.eseFL._ESE_RESET_METHOD && nfcFL.eseFL._ESE_POWER_MODE) {
     unsigned long int num = 0;
-    if (GetNxpNumValue (NAME_NXP_ESE_POWER_DH_CONTROL, (void*)&num, sizeof(num)) == true)
-    {
-        if(num ==1)
-        {
-            if(NFA_GetNCIVersion() == NCI_VERSION_2_0)
-            {
-                se.setNfccPwrConfig(se.NFCC_DECIDES);
-            }
-
-            ALOGV("1st mode set calling");
-            se.SecEle_Modeset(0x00);
-            usleep(100 * 1000);
-            ALOGV("1st mode set called");
-            ALOGV("2nd mode set calling");
-
-            if(NFA_GetNCIVersion() == NCI_VERSION_2_0)
-            {
-                se.setNfccPwrConfig(se.POWER_ALWAYS_ON|se.COMM_LINK_ACTIVE);
-            }
-
-            se.SecEle_Modeset(0x01);
-            ALOGV("2nd mode set called");
-            usleep(3000 * 1000);
-        }
-        else if(num ==2)
-        {
-            ALOGV("%s: eSE CHIP reset  on DWP Channel:", fn);
-            se.SecEle_Modeset(0x00);
-            usleep(100 * 1000);
-            se.eSE_Chip_Reset();
-            se.SecEle_Modeset(0x01);
-            ALOGV("Chip Reset DONE");
-            usleep(3000 * 1000);
-        }
-        else
-        {
-            ALOGV("%s: Invalid Power scheme:", fn);
-        }
-        /*
-        if( (num == 1) || (num == 2))
-        {
-            if((se.eSE_Compliancy == se.eSE_Compliancy_ETSI_12)&&(se.mDeletePipeHostId == 0xC0))
-            {
-                ALOGV("%s: Clear All pipes received.....Create pipe at APDU Gate:", fn);
-                se.mDeletePipeHostId = 0x00;
-                android ::checkforNfceeConfig();
-                SyncEventGuard guard (se.mCreatePipeEvent);
-                nfaStat = NFA_HciCreatePipe(NFA_HANDLE_GROUP_HCI,NFA_HCI_ETSI12_APDU_GATE,0xC0,NFA_HCI_ETSI12_APDU_GATE);
-                if(nfaStat == NFA_STATUS_OK)
-                {
-                    se.mCreatePipeEvent.wait();
-                    ALOGV("%s: Created pipe at APDU Gate Open the pipe!!!", fn);
-                    SyncEventGuard guard (se.mPipeOpenedEvent);
-                    nfaStat = NFA_STATUS_FAILED;
-                    se.mAbortEventWaitOk = false;
-                    nfaStat = NFA_HciOpenPipe(NFA_HANDLE_GROUP_HCI,se.mCreatedPipe);
-                    if(nfaStat == NFA_STATUS_OK)
-                    {
-                        se.mPipeOpenedEvent.wait();
-                        ALOGV("%s:Pipe at APDU Gate opened successfully!!!", fn);
-                        if(se.mAbortEventWaitOk == false)
-                        {
-                            SyncEventGuard guard (se.mAbortEvent);
-                            se.mAbortEvent.wait();
-                        }
-                        ALOGV("%s:ATR received successfully!!!", fn);
-                    }
-                    else
-                    {
-                        ALOGV("%s: fail open pipe; error=0x%X", fn, nfaStat);
-                    }
-                }
-                else
-                {
-                    ALOGE("%s: fail create pipe; error=0x%X", fn, nfaStat);
-                }
-            }
-        }
-             */
+    if (NfcConfig::hasKey(NAME_NXP_ESE_POWER_DH_CONTROL)) {
+      num = NfcConfig::getUnsigned(NAME_NXP_ESE_POWER_DH_CONTROL);
+      if (num == 1) {
+        if (NFA_GetNCIVersion() == NCI_VERSION_2_0) {
+          se.setNfccPwrConfig(se.NFCC_DECIDES);
         }
-    }
-    else {
-        ALOGV("1st mode set calling");
+
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("1st mode set calling");
         se.SecEle_Modeset(0x00);
         usleep(100 * 1000);
-        ALOGV("1st mode set called");
-        ALOGV("2nd mode set calling");
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("1st mode set called");
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("2nd mode set calling");
 
-        se.SecEle_Modeset(0x01);
-        ALOGV("2nd mode set called");
+        if (NFA_GetNCIVersion() == NCI_VERSION_2_0) {
+          se.setNfccPwrConfig(se.POWER_ALWAYS_ON | se.COMM_LINK_ACTIVE);
+        }
 
+        se.SecEle_Modeset(0x01);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("2nd mode set called");
+        usleep(3000 * 1000);
+      } else if (num == 2) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: eSE CHIP reset  on DWP Channel:", fn);
+        se.SecEle_Modeset(0x00);
+        usleep(100 * 1000);
+        se.eSE_Chip_Reset();
+        se.SecEle_Modeset(0x01);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Chip Reset DONE");
         usleep(3000 * 1000);
+      } else {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: Invalid Power scheme:", fn);
+      }
+      /*
+      if( (num == 1) || (num == 2))
+      {
+          if((se.eSE_Compliancy ==
+      se.eSE_Compliancy_ETSI_12)&&(se.mDeletePipeHostId == 0xC0))
+          {
+              DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Clear All
+      pipes received.....Create pipe at APDU Gate:", fn);
+              se.mDeletePipeHostId = 0x00;
+              android ::checkforNfceeConfig();
+              SyncEventGuard guard (se.mCreatePipeEvent);
+              nfaStat =
+      NFA_HciCreatePipe(NFA_HANDLE_GROUP_HCI,NFA_HCI_ETSI12_APDU_GATE,0xC0,NFA_HCI_ETSI12_APDU_GATE);
+              if(nfaStat == NFA_STATUS_OK)
+              {
+                  se.mCreatePipeEvent.wait();
+                  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Created
+      pipe at APDU Gate Open the pipe!!!", fn);
+                  SyncEventGuard guard (se.mPipeOpenedEvent);
+                  nfaStat = NFA_STATUS_FAILED;
+                  se.mAbortEventWaitOk = false;
+                  nfaStat =
+      NFA_HciOpenPipe(NFA_HANDLE_GROUP_HCI,se.mCreatedPipe);
+                  if(nfaStat == NFA_STATUS_OK)
+                  {
+                      se.mPipeOpenedEvent.wait();
+                      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s:Pipe
+      at APDU Gate opened successfully!!!", fn);
+                      if(se.mAbortEventWaitOk == false)
+                      {
+                          SyncEventGuard guard (se.mAbortEvent);
+                          se.mAbortEvent.wait();
+                      }
+                      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s:ATR
+      received successfully!!!", fn);
+                  }
+                  else
+                  {
+                      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: fail
+      open pipe; error=0x%X", fn, nfaStat);
+                  }
+              }
+              else
+              {
+                  LOG(ERROR) << StringPrintf("%s: fail create pipe; error=0x%X",
+      fn, nfaStat);
+              }
+          }
+      }
+           */
     }
-    rm.mResetHandlerMutex.unlock();
+  } else {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("1st mode set calling");
+    se.SecEle_Modeset(0x00);
+    usleep(100 * 1000);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("1st mode set called");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("2nd mode set calling");
 
-    if(nfcFL.nfccFL._NFCEE_REMOVED_NTF_RECOVERY && (RoutingManager::getInstance().is_ee_recovery_ongoing()))
-    {
-        SyncEventGuard guard (se.mEEdatapacketEvent);
-        se.mEEdatapacketEvent.wait(android::gMaxEERecoveryTimeout);
-    }
+    se.SecEle_Modeset(0x01);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("2nd mode set called");
+
+    usleep(3000 * 1000);
+  }
+  rm.mResetHandlerMutex.unlock();
+
+  if (nfcFL.nfccFL._NFCEE_REMOVED_NTF_RECOVERY &&
+      (RoutingManager::getInstance().is_ee_recovery_ongoing())) {
+    SyncEventGuard guard(se.mEEdatapacketEvent);
+    se.mEEdatapacketEvent.wait(android::gMaxEERecoveryTimeout);
+  }
 }
diff --git a/nci/jni/DwpChannel.h b/nci/jni/DwpChannel.h
index 771dbe3c..ecec64b7 100644
--- a/nci/jni/DwpChannel.h
+++ b/nci/jni/DwpChannel.h
@@ -14,87 +14,79 @@
  * limitations under the License.
  */
 
-extern "C"
-{
-    #include "nfa_ee_api.h"
-}
-#define ALOGV ALOGD
-class DwpChannel
-{
-public:
+#include "nfa_ee_api.h"
+class DwpChannel {
+ public:
+  /*******************************************************************************
+  **
+  ** Function:        DwpChannel's get class instance
+  **
+  ** Description:     Returns instance object of the class
+  **
+  ** Returns:         DwpChannel instance.
+  **
+  *******************************************************************************/
+  static DwpChannel& getInstance();
 
-/*******************************************************************************
-**
-** Function:        DwpChannel's get class instance
-**
-** Description:     Returns instance object of the class
-**
-** Returns:         DwpChannel instance.
-**
-*******************************************************************************/
-static DwpChannel& getInstance ();
-
-/*******************************************************************************
-**
-** Function:        DwpChannel's force exit
-**
-** Description:     Force exit of DWP channel
-**
-** Returns:         None.
-**
-*******************************************************************************/
-void forceClose();
-
-/*******************************************************************************
-**
-** Function:        finalize
-**
-** Description:     Release all resources.
-**
-** Returns:         None
-**
-*******************************************************************************/
-void finalize();
+  /*******************************************************************************
+  **
+  ** Function:        DwpChannel's force exit
+  **
+  ** Description:     Force exit of DWP channel
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  void forceClose();
 
-/*******************************************************************************
-**
-** Function:        initialize
-**
-** Description:     Initialize all member variables.
-**
-** Returns:         None.
-**
-*******************************************************************************/
-void Initialize();
-
-bool dwpChannelForceClose;
+  /*******************************************************************************
+  **
+  ** Function:        finalize
+  **
+  ** Description:     Release all resources.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void finalize();
 
-private:
+  /*******************************************************************************
+  **
+  ** Function:        initialize
+  **
+  ** Description:     Initialize all member variables.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  void Initialize();
 
-static DwpChannel sDwpChannel;
+  bool dwpChannelForceClose;
 
-/*******************************************************************************
-**
-** Function:        DwpChannel Constructor
-**
-** Description:     Class constructor
-**
-** Returns:         None.
-**
-*******************************************************************************/
-DwpChannel () ;
+ private:
+  static DwpChannel sDwpChannel;
 
-/*******************************************************************************
-**
-** Function:        DwpChannel Destructor
-**
-** Description:     Class destructor
-**
-** Returns:         None.
-**
-*******************************************************************************/
-~DwpChannel () ;
+  /*******************************************************************************
+  **
+  ** Function:        DwpChannel Constructor
+  **
+  ** Description:     Class constructor
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  DwpChannel();
 
+  /*******************************************************************************
+  **
+  ** Function:        DwpChannel Destructor
+  **
+  ** Description:     Class destructor
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  ~DwpChannel();
 };
 
 /*******************************************************************************
@@ -110,8 +102,9 @@ extern bool dwpChannelForceClose;
 int16_t open();
 bool close(int16_t mHandle);
 
-bool transceive (uint8_t* xmitBuffer, int32_t xmitBufferSize, uint8_t* recvBuffer,
-				 int32_t recvBufferMaxSize, int32_t& recvBufferActualSize, int32_t timeoutMillisec);
+bool transceive(uint8_t* xmitBuffer, int32_t xmitBufferSize,
+                uint8_t* recvBuffer, int32_t recvBufferMaxSize,
+                int32_t& recvBufferActualSize, int32_t timeoutMillisec);
 
 void doeSE_Reset();
 void doeSE_JcopDownLoadReset();
diff --git a/nci/jni/HciEventManager.cpp b/nci/jni/HciEventManager.cpp
new file mode 100755
index 00000000..81a89ea6
--- /dev/null
+++ b/nci/jni/HciEventManager.cpp
@@ -0,0 +1,229 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include "HciEventManager.h"
+#include "SecureElement.h"
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+#include <nativehelper/ScopedLocalRef.h>
+#include "JavaClassConstants.h"
+#include "NfcJniUtil.h"
+#include "nfc_config.h"
+
+extern bool nfc_debug_enabled;
+const char* APP_NAME = "NfcNci";
+uint8_t HciEventManager::sEsePipe;
+uint8_t HciEventManager::sSim1Pipe;
+uint8_t HciEventManager::sSim2Pipe;
+
+using android::base::StringPrintf;
+
+HciEventManager::HciEventManager() : mNativeData(nullptr) {}
+
+HciEventManager& HciEventManager::getInstance() {
+  static HciEventManager sHciEventManager;
+  return sHciEventManager;
+}
+
+void HciEventManager::initialize(nfc_jni_native_data* native) {
+  mNativeData = native;
+  tNFA_HCI_GET_GATE_PIPE_LIST gatePipeInfo;
+  gatePipeInfo.status = NFA_STATUS_FAILED;
+  bool isEseAvailable = false, isUicc1Avaialble = false,
+       isUicc2Avaialble = false;
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+  uint8_t ActualNumEe = nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED;
+  tNFA_EE_INFO mEeInfo[ActualNumEe];
+
+  if ((nfaStat = NFA_AllEeGetInfo(&ActualNumEe, mEeInfo)) != NFA_STATUS_OK) {
+    LOG(ERROR) << StringPrintf("%s: fail get info; error=0x%X", __func__,
+                               nfaStat);
+    ActualNumEe = 0;
+  } else {
+    for (int xx = 0; xx < ActualNumEe; xx++) {
+      if ((mEeInfo[xx].ee_handle == SecureElement::EE_HANDLE_0xF3) &&
+          (mEeInfo[xx].ee_status == 0x00)) {
+        isEseAvailable = true;
+      } else if ((mEeInfo[xx].ee_handle ==
+                  SecureElement::getInstance().EE_HANDLE_0xF4) &&
+                 (mEeInfo[xx].ee_status == 0x00)) {
+        isUicc1Avaialble = true;
+      } else if ((mEeInfo[xx].ee_handle == SecureElement::EE_HANDLE_0xF8) &&
+                 (mEeInfo[xx].ee_status == 0x00)) {
+        isUicc2Avaialble = true;
+      }
+    }
+  }
+
+  gatePipeInfo = SecureElement::getInstance().getGateAndPipeInfo();
+
+  if (gatePipeInfo.status == NFA_STATUS_OK) {
+    for (uint8_t xx = 0; xx < gatePipeInfo.num_uicc_created_pipes; xx++) {
+      if (isEseAvailable &&
+          (gatePipeInfo.uicc_created_pipe[xx].dest_host ==
+           (SecureElement::EE_HANDLE_0xF3 & ~NFA_HANDLE_GROUP_EE))) {
+        sEsePipe = gatePipeInfo.uicc_created_pipe[xx].pipe_id;
+      } else if (gatePipeInfo.uicc_created_pipe[xx].dest_host ==
+                 (SecureElement::getInstance().EE_HANDLE_0xF4 &
+                  ~NFA_HANDLE_GROUP_EE)) {
+        if (isUicc1Avaialble &&
+            gatePipeInfo.uicc_created_pipe[xx].pipe_id == 0x0A) {
+          sSim1Pipe = gatePipeInfo.uicc_created_pipe[xx].pipe_id;
+        } else if (isUicc2Avaialble &&
+                   gatePipeInfo.uicc_created_pipe[xx].pipe_id == 0x23) {
+          sSim2Pipe = gatePipeInfo.uicc_created_pipe[xx].pipe_id;
+        }
+      }
+    }
+  }
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: sEsePipe : 0x%0x   sSim1Pipe : 0x%0x  sSim2Pipe : 0x%0x", __func__,
+      sEsePipe, sSim1Pipe, sSim2Pipe);
+}
+
+void HciEventManager::notifyTransactionListenersOfAid(std::vector<uint8_t> aid,
+                                                      std::vector<uint8_t> data,
+                                                      std::string evtSrc) {
+  if (aid.empty()) {
+    return;
+  }
+
+  JNIEnv* e = NULL;
+  ScopedAttach attach(mNativeData->vm, &e);
+  CHECK(e);
+
+  ScopedLocalRef<jobject> aidJavaArray(e, e->NewByteArray(aid.size()));
+  CHECK(aidJavaArray.get());
+  e->SetByteArrayRegion((jbyteArray)aidJavaArray.get(), 0, aid.size(),
+                        (jbyte*)&aid[0]);
+  CHECK(!e->ExceptionCheck());
+
+  ScopedLocalRef<jobject> srcJavaString(e, e->NewStringUTF(evtSrc.c_str()));
+  CHECK(srcJavaString.get());
+
+  if (data.size() > 0) {
+    ScopedLocalRef<jobject> dataJavaArray(e, e->NewByteArray(data.size()));
+    CHECK(dataJavaArray.get());
+    e->SetByteArrayRegion((jbyteArray)dataJavaArray.get(), 0, data.size(),
+                          (jbyte*)&data[0]);
+    CHECK(!e->ExceptionCheck());
+    e->CallVoidMethod(mNativeData->manager,
+                      android::gCachedNfcManagerNotifyTransactionListeners,
+                      aidJavaArray.get(), dataJavaArray.get(),
+                      srcJavaString.get());
+  } else {
+    e->CallVoidMethod(mNativeData->manager,
+                      android::gCachedNfcManagerNotifyTransactionListeners,
+                      aidJavaArray.get(), NULL, srcJavaString.get());
+  }
+}
+
+/**
+ * BerTlv has the following format:
+ *
+ * byte1 byte2 byte3 byte4 byte5 byte6
+ * 00-7F   -    -     -     -     -
+ * 80    00-FF  -     -     -     -
+ * 81    0000-FFFF    -     -     -
+ * 82      000000-FFFFFF    -     -
+ * 83      00000000-FFFFFFFF      -
+ */
+std::vector<uint8_t> HciEventManager::getDataFromBerTlv(
+    std::vector<uint8_t> berTlv) {
+  if (berTlv.empty()) {
+    return std::vector<uint8_t>();
+  }
+  size_t lengthTag = berTlv[0];
+  DLOG_IF(INFO, nfc_debug_enabled) << "decodeBerTlv: berTlv[0]=" << berTlv[0];
+
+  /* As per ISO/IEC 7816, read the first byte to determine the length and
+   * the start index accordingly
+   */
+  if (lengthTag < 0x80 && berTlv.size() == (lengthTag + 1)) {
+    return std::vector<uint8_t>(berTlv.begin() + 1, berTlv.end());
+  } else if (lengthTag == 0x80 && berTlv.size() > 2) {
+    size_t length = berTlv[1];
+    if ((length + 2) == berTlv.size()) {
+      return std::vector<uint8_t>(berTlv.begin() + 2, berTlv.end());
+    }
+  } else if (lengthTag == 0x81 && berTlv.size() > 3) {
+    size_t length = ((berTlv[1] << 8) | berTlv[2]);
+    if ((length + 3) == berTlv.size()) {
+      return std::vector<uint8_t>(berTlv.begin() + 3, berTlv.end());
+    }
+  } else if (lengthTag == 0x82 && berTlv.size() > 4) {
+    size_t length = (berTlv[1] << 16) | (berTlv[2] << 8) | berTlv[3];
+    if ((length + 4) == berTlv.size()) {
+      return std::vector<uint8_t>(berTlv.begin() + 4, berTlv.end());
+    }
+  } else if (lengthTag == 0x83 && berTlv.size() > 5) {
+    size_t length =
+        (berTlv[1] << 24) | (berTlv[2] << 16) | (berTlv[3] << 8) | berTlv[4];
+    if ((length + 5) == berTlv.size()) {
+      return std::vector<uint8_t>(berTlv.begin() + 5, berTlv.end());
+    }
+  }
+  LOG(ERROR) << "Error in TLV length encoding!";
+  return std::vector<uint8_t>();
+}
+
+void HciEventManager::nfaHciEvtHandler(tNFA_HCI_EVT event,
+                                       tNFA_HCI_EVT_DATA* eventData) {
+  if (eventData == nullptr) {
+    return;
+  }
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("event=%d code=%d pipe=%d len=%d ", event,
+                      eventData->rcvd_evt.evt_code, eventData->rcvd_evt.pipe,
+                      eventData->rcvd_evt.evt_len);
+
+  std::string evtSrc;
+  if (eventData->rcvd_evt.pipe == sEsePipe) {
+    evtSrc = "eSE1";
+  } else if (eventData->rcvd_evt.pipe == sSim1Pipe) {
+    evtSrc = "SIM1";
+  } else if (eventData->rcvd_evt.pipe == sSim2Pipe) {
+    evtSrc = "SIM2";
+  }else {
+    LOG(ERROR) << "Incorrect Pipe Id";
+    return;
+  }
+
+  uint8_t* buff = eventData->rcvd_evt.p_evt_buf;
+  uint32_t buffLength = eventData->rcvd_evt.evt_len;
+  std::vector<uint8_t> event_buff(buff, buff + buffLength);
+  // Check the event and check if it contains the AID
+  if (event == NFA_HCI_EVENT_RCVD_EVT &&
+      eventData->rcvd_evt.evt_code == NFA_HCI_EVT_TRANSACTION &&
+      buffLength > 3 && event_buff[0] == 0x81) {
+    int aidlen = event_buff[1];
+    std::vector<uint8_t> aid(event_buff.begin() + 2,
+                             event_buff.begin() + aidlen + 2);
+
+    int32_t berTlvStart = aidlen + 2 + 1;
+    int32_t berTlvLen = buffLength - berTlvStart;
+    std::vector<uint8_t> data;
+    if (berTlvLen > 0 && event_buff[2 + aidlen] == 0x82) {
+      std::vector<uint8_t> berTlv(event_buff.begin() + berTlvStart,
+                                  event_buff.end());
+      // BERTLV decoding here, to support extended data length for params.
+      data = getInstance().getDataFromBerTlv(berTlv);
+    }
+    getInstance().notifyTransactionListenersOfAid(aid, data, evtSrc);
+  }
+}
+
+void HciEventManager::finalize() { mNativeData = NULL; }
diff --git a/nci/jni/HciEventManager.h b/nci/jni/HciEventManager.h
new file mode 100644
index 00000000..13d018e2
--- /dev/null
+++ b/nci/jni/HciEventManager.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#include "NfcJniUtil.h"
+#include "nfa_hci_api.h"
+#include "nfa_hci_defs.h"
+
+/**
+ * This class is used for receiving HCI events from libnfc-nci
+ * and forwarding the Transaction Events to NFC Service.
+ */
+class HciEventManager {
+ private:
+  nfc_jni_native_data* mNativeData;
+  static uint8_t sEsePipe;
+  static uint8_t sSim1Pipe;
+  static uint8_t sSim2Pipe;
+
+  HciEventManager();
+  std::vector<uint8_t> getDataFromBerTlv(std::vector<uint8_t> berTlv);
+  void notifyTransactionListenersOfAid(std::vector<uint8_t> aid,
+                                       std::vector<uint8_t> data,
+                                       std::string evtSrc);
+
+ public:
+  static HciEventManager& getInstance();
+  void initialize(nfc_jni_native_data* native);
+  void nfaHciEvtHandler(tNFA_HCI_EVT event, tNFA_HCI_EVT_DATA* eventData);
+  void finalize();
+};
diff --git a/nci/jni/HciRFParams.cpp b/nci/jni/HciRFParams.cpp
index 391a1b91..ded137e3 100644
--- a/nci/jni/HciRFParams.cpp
+++ b/nci/jni/HciRFParams.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 NXP Semiconductors
+ * Copyright (C) 2015-2018 NXP Semiconductors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,14 +14,18 @@
  * limitations under the License.
  */
 
-
 #include "HciRFParams.h"
+#include "SecureElement.h"
 
 #define VAL_START_IDX 4
 #define MAX_AID_SIZE 10
 #define MAX_APP_DATA_SIZE 15
 #define MAX_HIGHER_LAYER_RSP_SIZE 15
 
+#if (NXP_EXTNS == true)
+bool IsEseCeDisabled;
+#endif
+
 HciRFParams HciRFParams::sHciRFParams;
 
 /*******************************************************************************
@@ -33,29 +37,28 @@ HciRFParams HciRFParams::sHciRFParams;
  ** Returns:         None
  **
  *******************************************************************************/
-HciRFParams::HciRFParams ()
-{
-  memset (aATQA_CeA, 0, sizeof(aATQA_CeA));
-  memset (aATQB_CeB, 0, sizeof(aATQB_CeB));
-  memset (aApplicationData_CeA, 0, sizeof(aApplicationData_CeA));
-  memset (aDataRateMax_CeA, 0, sizeof(aDataRateMax_CeA));
-  memset (aDataRateMax_CeB, 0, sizeof(aDataRateMax_CeB));
-  memset (aHighLayerRsp_CeB_CeB, 0, sizeof(aHighLayerRsp_CeB_CeB));
-  memset (aPupiReg_CeB, 0, sizeof(aPupiReg_CeB));
-  memset (aUidReg_CeA, 0, sizeof(aUidReg_CeA));
-  bMode_CeA=0;
-  bUidRegSize_CeA=0;
-  bSak_CeA =0;
-  bApplicationDataSize_CeA=0;
-  bFWI_SFGI_CeA=0;
-  bCidSupport_CeA=0;
-  bCltSupport_CeA=0;
-  bPipeStatus_CeA=0;
-  bPipeStatus_CeB=0;
-  bMode_CeB=0;
-  bAfi_CeB=0;
-  bHighLayerRspSize_CeB=0;
-  mIsInit=false;
+HciRFParams::HciRFParams() {
+  memset(aATQA_CeA, 0, sizeof(aATQA_CeA));
+  memset(aATQB_CeB, 0, sizeof(aATQB_CeB));
+  memset(aApplicationData_CeA, 0, sizeof(aApplicationData_CeA));
+  memset(aDataRateMax_CeA, 0, sizeof(aDataRateMax_CeA));
+  memset(aDataRateMax_CeB, 0, sizeof(aDataRateMax_CeB));
+  memset(aHighLayerRsp_CeB_CeB, 0, sizeof(aHighLayerRsp_CeB_CeB));
+  memset(aPupiReg_CeB, 0, sizeof(aPupiReg_CeB));
+  memset(aUidReg_CeA, 0, sizeof(aUidReg_CeA));
+  bMode_CeA = 0;
+  bUidRegSize_CeA = 0;
+  bSak_CeA = 0;
+  bApplicationDataSize_CeA = 0;
+  bFWI_SFGI_CeA = 0;
+  bCidSupport_CeA = 0;
+  bCltSupport_CeA = 0;
+  bPipeStatus_CeA = 0;
+  bPipeStatus_CeB = 0;
+  bMode_CeB = 0;
+  bAfi_CeB = 0;
+  bHighLayerRspSize_CeB = 0;
+  mIsInit = false;
 }
 
 /*******************************************************************************
@@ -67,9 +70,7 @@ HciRFParams::HciRFParams ()
  ** Returns:         None
  **
  *******************************************************************************/
-HciRFParams::~HciRFParams ()
-{
-}
+HciRFParams::~HciRFParams() {}
 
 /*******************************************************************************
  **
@@ -80,10 +81,7 @@ HciRFParams::~HciRFParams ()
  ** Returns:         HciRFParams object.
  **
  *******************************************************************************/
-HciRFParams& HciRFParams::getInstance()
-{
-    return sHciRFParams;
-}
+HciRFParams& HciRFParams::getInstance() { return sHciRFParams; }
 
 /*******************************************************************************
  **
@@ -95,85 +93,95 @@ HciRFParams& HciRFParams::getInstance()
  ** Returns:         True if ok.
  **
  *******************************************************************************/
-bool HciRFParams::initialize ()
-{
-    static const char fn [] = "HciRFParams::initialize";
-    ALOGV("%s: enter", fn);
-
-    tNFA_PMID param_ids[] = {0xA0, 0xF0};
-    {
-        SyncEventGuard guard (android::sNfaGetConfigEvent);
-        tNFA_STATUS stat = NFA_GetConfig(0x01,param_ids);
-//        NFA_GetConfig(0x01,param_ids);
-        if(stat == NFA_STATUS_OK)
-        {
-            android::sNfaGetConfigEvent.wait();
-        }
-        else
-        {
-            return false;
-        }
+bool HciRFParams::initialize() {
+  static const char fn[] = "HciRFParams::initialize";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+
+  tNFA_PMID param_ids[] = {0xA0, 0xF0};
+  {
+    SyncEventGuard guard(android::sNfaGetConfigEvent);
+    tNFA_STATUS stat = NFA_GetConfig(0x01, param_ids);
+    //        NFA_GetConfig(0x01,param_ids);
+    if (stat == NFA_STATUS_OK) {
+      android::sNfaGetConfigEvent.wait();
+    } else {
+      return false;
     }
-    ALOGV("%s: status %x", __func__,get_config->status);
-    ALOGV("%s: tlv_size %d", __func__,get_config->tlv_size);
-    ALOGV("%s: param_tlvs %x", __func__,get_config->param_tlvs[0]);
+  }
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: status %x", __func__, get_config->status);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: tlv_size %d", __func__, get_config->tlv_size);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: param_tlvs %x", __func__, get_config->param_tlvs[0]);
 
-    uint8_t *params = get_config->param_tlvs;
-    params+=VAL_START_IDX;
+#if (NXP_EXTNS == true)
+  if ((get_config->param_tlvs[1] == 0xA0 &&
+       get_config->param_tlvs[2] == 0xF0) &&
+      (get_config->param_tlvs[5] == 0xFF ||
+       get_config->param_tlvs[43] == 0xFF) &&
+      SecureElement::getInstance().getEeStatus(ESE_HANDLE) ==
+          NFA_EE_STATUS_ACTIVE) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: CE with ESE is disabled", __func__);
+    IsEseCeDisabled = true;
+  }
+#endif
 
-    bPipeStatus_CeA = *params++;
-    bMode_CeA = *params++;
-    bUidRegSize_CeA = *params++;
+  uint8_t* params = get_config->param_tlvs;
+  params += VAL_START_IDX;
 
-    memcpy(aUidReg_CeA,params,bUidRegSize_CeA);
-    params += MAX_AID_SIZE;
+  bPipeStatus_CeA = *params++;
+  bMode_CeA = *params++;
+  bUidRegSize_CeA = *params++;
 
-    bSak_CeA = *params++;
+  memcpy(aUidReg_CeA, params, bUidRegSize_CeA);
+  params += MAX_AID_SIZE;
 
-    aATQA_CeA[0] = *params++;
-    aATQA_CeA[1] = *params++;
-    bApplicationDataSize_CeA = *params++;
+  bSak_CeA = *params++;
 
-    memcpy(aApplicationData_CeA,params,bApplicationDataSize_CeA);
-    params += MAX_APP_DATA_SIZE;
+  aATQA_CeA[0] = *params++;
+  aATQA_CeA[1] = *params++;
+  bApplicationDataSize_CeA = *params++;
 
-    bFWI_SFGI_CeA = *params++;
-    bCidSupport_CeA =  *params++;
-    bCltSupport_CeA =  *params++;
+  memcpy(aApplicationData_CeA, params, bApplicationDataSize_CeA);
+  params += MAX_APP_DATA_SIZE;
 
-    memcpy(aDataRateMax_CeA,params,0x03);
-    params += 3;
+  bFWI_SFGI_CeA = *params++;
+  bCidSupport_CeA = *params++;
+  bCltSupport_CeA = *params++;
 
-    bPipeStatus_CeB = *params++;
-    bMode_CeB = *params++;
-
-    if(nfcFL.chipType != pn547C2) {
-        aPupiRegDataSize_CeB = *params++;
-    }
-        aPupiRegDataSize_CeB = 4;
+  memcpy(aDataRateMax_CeA, params, 0x03);
+  params += 3;
 
+  bPipeStatus_CeB = *params++;
+  bMode_CeB = *params++;
 
-    memcpy(aPupiReg_CeB,params, aPupiRegDataSize_CeB);
-    params += aPupiRegDataSize_CeB;
+  if (nfcFL.chipType != pn547C2) {
+    aPupiRegDataSize_CeB = *params++;
+  }
+  aPupiRegDataSize_CeB = 4;
 
-    bAfi_CeB = *params++;
+  memcpy(aPupiReg_CeB, params, aPupiRegDataSize_CeB);
+  params += aPupiRegDataSize_CeB;
 
-    memcpy(aATQB_CeB,params,0x04);
-    params += 4;
+  bAfi_CeB = *params++;
 
-    bHighLayerRspSize_CeB = *params++;
+  memcpy(aATQB_CeB, params, 0x04);
+  params += 4;
 
-    memcpy(aHighLayerRsp_CeB_CeB,params,bHighLayerRspSize_CeB);
-    params += MAX_HIGHER_LAYER_RSP_SIZE;
+  bHighLayerRspSize_CeB = *params++;
 
-    memcpy(aDataRateMax_CeB,params,0x03);
-//    aDataRateMax_CeB[3];
+  memcpy(aHighLayerRsp_CeB_CeB, params, bHighLayerRspSize_CeB);
+  params += MAX_HIGHER_LAYER_RSP_SIZE;
 
+  memcpy(aDataRateMax_CeB, params, 0x03);
+  //    aDataRateMax_CeB[3];
 
-    mIsInit = true;
+  mIsInit = true;
 
-    ALOGV("%s: exit", fn);
-    return (true);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
+  return (true);
 }
 
 /*******************************************************************************
@@ -185,69 +193,97 @@ bool HciRFParams::initialize ()
  ** Returns:         None
  **
  *******************************************************************************/
-void HciRFParams::finalize ()
-{
-    static const char fn [] = "HciRFParams::finalize";
-    ALOGV("%s: enter", fn);
+void HciRFParams::finalize() {
+  static const char fn[] = "HciRFParams::finalize";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
 
-    mIsInit       = false;
+  mIsInit = false;
 
-    ALOGV("%s: exit", fn);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
 }
 
-
-void HciRFParams::connectionEventHandler (uint8_t event, tNFA_DM_CBACK_DATA* eventData)
-{
-//    static const char fn [] = "HciRFParams::connectionEventHandler";  /*commented to eliminate unused variable warning*/
-
-    switch (event)
-    {
-    case NFA_DM_GET_CONFIG_EVT:
-    {
-        get_config = (tNFA_GET_CONFIG*) eventData;
-//        SyncEventGuard guard (android::sNfaGetConfigEvent);
-//        android::sNfaGetConfigEvent.notifyOne ();
-    }
-    break;
-    }
+void HciRFParams::connectionEventHandler(uint8_t event,
+                                         tNFA_DM_CBACK_DATA* eventData) {
+  //    static const char fn [] = "HciRFParams::connectionEventHandler";
+  //    /*commented to eliminate unused variable warning*/
+
+  switch (event) {
+    case NFA_DM_GET_CONFIG_EVT: {
+      get_config = (tNFA_GET_CONFIG*)eventData;
+      //        SyncEventGuard guard (android::sNfaGetConfigEvent);
+      //        android::sNfaGetConfigEvent.notifyOne ();
+    } break;
+  }
 }
 
-void HciRFParams::getESeUid(uint8_t* uidbuff, uint8_t* uidlen)
-{
-    if(false == mIsInit || *uidlen < bUidRegSize_CeA || (uint8_t)NULL == *uidbuff)
-    {
-        *uidlen = 0x00;
-        *uidbuff = (uint8_t)NULL;
-    }
-
-    memcpy(uidbuff,aUidReg_CeA,bUidRegSize_CeA);
-    *uidlen = bUidRegSize_CeA;
+void HciRFParams::getESeUid(uint8_t* uidbuff, uint8_t* uidlen) {
+  if (false == mIsInit || *uidlen < bUidRegSize_CeA ||
+      (uint8_t)NULL == *uidbuff) {
+    *uidlen = 0x00;
+    *uidbuff = (uint8_t)NULL;
+  }
 
+  memcpy(uidbuff, aUidReg_CeA, bUidRegSize_CeA);
+  *uidlen = bUidRegSize_CeA;
 }
 
-uint8_t HciRFParams::getESeSak()
-{
-    if(false == mIsInit)
-    {
-        return 0x00;
-    }
+uint8_t HciRFParams::getESeSak() {
+  if (false == mIsInit) {
+    return 0x00;
+  }
 
-    return bSak_CeA;
+  return bSak_CeA;
 }
 
-bool HciRFParams::isTypeBSupported()
-{
-    bool status = false;
+bool HciRFParams::isTypeBSupported() {
+  bool status = false;
 
-    if(false == mIsInit)
-    {
-        return 0x00;
-    }
+  if (false == mIsInit) {
+    return 0x00;
+  }
+
+  if (bPipeStatus_CeB == 0x02 && bMode_CeB == 0x02) {
+    status = true;
+  }
+  return status;
+}
 
-    if(bPipeStatus_CeB == 0x02 &&
-            bMode_CeB == 0x02)
-    {
-        status = true;
+#if (NXP_EXTNS == TRUE)
+bool HciRFParams::isCeWithEseDisabled() {
+  static const char fn[] = "HciRFParams::isCeWithEseDisabled";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+  bool status = false;
+
+  tNFA_PMID param_ids[] = {0xA0, 0xF0};
+  {
+    SyncEventGuard guard(android::sNfaGetConfigEvent);
+    tNFA_STATUS stat = NFA_GetConfig(0x01, param_ids);
+    if (stat == NFA_STATUS_OK) {
+      android::sNfaGetConfigEvent.wait(500);
+    } else {
+      LOG(ERROR) << StringPrintf("%s: Get config is failed", __func__);
+      return status;
     }
-    return status;
+  }
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: status %x", __func__, get_config->status);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: tlv_size %d", __func__, get_config->tlv_size);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: param_tlvs %x", __func__, get_config->param_tlvs[0]);
+
+  if ((get_config->param_tlvs[1] == 0xA0 &&
+       get_config->param_tlvs[2] == 0xF0) &&
+      (get_config->param_tlvs[5] == 0xFF ||
+       get_config->param_tlvs[43] == 0xFF) &&
+      SecureElement::getInstance().getEeStatus(ESE_HANDLE) ==
+          NFA_EE_STATUS_ACTIVE) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: CE with ESE is disabled", __func__);
+    status = true;
+  }
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Exit status =%d", __func__, status);
+  return status;
 }
+#endif
diff --git a/nci/jni/HciRFParams.h b/nci/jni/HciRFParams.h
index 27ad1e3b..285fb485 100644
--- a/nci/jni/HciRFParams.h
+++ b/nci/jni/HciRFParams.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 NXP Semiconductors
+ * Copyright (C) 2015-2018 NXP Semiconductors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,129 +13,127 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-#include "_OverrideLog.h"
-#include "SyncEvent.h"
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
 #include <cstdlib>
 #include <cstring>
+#include "SyncEvent.h"
 
-extern "C"
-{
-    #include "nfa_api.h"
-}/*namespace android*/
+#include "nfa_api.h"
 
-namespace android {
+#if (NXP_EXTNS == TRUE)
+#define ESE_HANDLE 0x4C0
+#endif
 
-extern SyncEvent sNfaGetConfigEvent;
+using android::base::StringPrintf;
 
-}  // namespace android
+extern bool nfc_debug_enabled;
 
-class HciRFParams
-{
-public:
-    /*******************************************************************************
-    **
-    ** Function:        getInstance
-    **
-    ** Description:     Get the HciRFParams singleton object.
-    **
-    ** Returns:         HciRFParams object.
-    **
-    *******************************************************************************/
-    static HciRFParams& getInstance ();
-
-    /*******************************************************************************
-    **
-    ** Function:        initialize
-    **
-    ** Description:     Initialize all member variables.
-    **                  native: Native data.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    bool initialize ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        finalize
-    **
-    ** Description:     Release all resources.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void finalize ();
-
-    bool isTypeBSupported();
-
-    void connectionEventHandler (uint8_t dmEvent, tNFA_DM_CBACK_DATA* eventData);
-
-    void getESeUid(uint8_t* uidbuff, uint8_t* uidlen);
-    uint8_t getESeSak();
-
-private:
-
-    uint8_t bPipeStatus_CeA;
-    uint8_t bMode_CeA;
-    uint8_t bUidRegSize_CeA;
-    uint8_t aUidReg_CeA[10];
-    uint8_t bSak_CeA;
-    uint8_t aATQA_CeA[2];
-    uint8_t bApplicationDataSize_CeA;
-    uint8_t aApplicationData_CeA[15];
-    uint8_t bFWI_SFGI_CeA;
-    uint8_t bCidSupport_CeA;
-    uint8_t bCltSupport_CeA;
-    uint8_t aDataRateMax_CeA[3];
-    uint8_t bPipeStatus_CeB;
-    uint8_t bMode_CeB;
-    uint8_t aPupiRegDataSize_CeB;
-    uint8_t aPupiReg_CeB[4];
-    uint8_t bAfi_CeB;
-    uint8_t aATQB_CeB[4];
-    uint8_t bHighLayerRspSize_CeB;
-    uint8_t aHighLayerRsp_CeB_CeB[15];
-    uint8_t aDataRateMax_CeB[3];
-
-    tNFA_GET_CONFIG *get_config;
-
-    static HciRFParams sHciRFParams;
-
-    bool mIsInit;                // whether HciRFParams is initialized
-    SyncEvent mGetConfigEvent;
-
-
-    SyncEvent mUiccListenEvent;
-    SyncEvent mAidRegisterEvent;
-    SyncEvent mAidDegisterEvent;
-    SyncEvent mDataRecvEvent;
-
-
-    /*******************************************************************************
-    **
-    ** Function:        HciRFParams
-    **
-    ** Description:     Initialize member variables.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    HciRFParams ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        ~HciRFParams
-    **
-    ** Description:     Release all resources.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    ~HciRFParams ();
+namespace android {
 
+extern SyncEvent sNfaGetConfigEvent;
 
+}  // namespace android
 
+class HciRFParams {
+ public:
+  /*******************************************************************************
+  **
+  ** Function:        getInstance
+  **
+  ** Description:     Get the HciRFParams singleton object.
+  **
+  ** Returns:         HciRFParams object.
+  **
+  *******************************************************************************/
+  static HciRFParams& getInstance();
+
+  /*******************************************************************************
+  **
+  ** Function:        initialize
+  **
+  ** Description:     Initialize all member variables.
+  **                  native: Native data.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool initialize();
+
+  /*******************************************************************************
+  **
+  ** Function:        finalize
+  **
+  ** Description:     Release all resources.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void finalize();
+
+  bool isTypeBSupported();
+
+  void connectionEventHandler(uint8_t dmEvent, tNFA_DM_CBACK_DATA* eventData);
+
+  void getESeUid(uint8_t* uidbuff, uint8_t* uidlen);
+  uint8_t getESeSak();
+#if (NXP_EXTNS == TRUE)
+  bool isCeWithEseDisabled();
+#endif
+ private:
+  uint8_t bPipeStatus_CeA;
+  uint8_t bMode_CeA;
+  uint8_t bUidRegSize_CeA;
+  uint8_t aUidReg_CeA[10];
+  uint8_t bSak_CeA;
+  uint8_t aATQA_CeA[2];
+  uint8_t bApplicationDataSize_CeA;
+  uint8_t aApplicationData_CeA[15];
+  uint8_t bFWI_SFGI_CeA;
+  uint8_t bCidSupport_CeA;
+  uint8_t bCltSupport_CeA;
+  uint8_t aDataRateMax_CeA[3];
+  uint8_t bPipeStatus_CeB;
+  uint8_t bMode_CeB;
+  uint8_t aPupiRegDataSize_CeB;
+  uint8_t aPupiReg_CeB[4];
+  uint8_t bAfi_CeB;
+  uint8_t aATQB_CeB[4];
+  uint8_t bHighLayerRspSize_CeB;
+  uint8_t aHighLayerRsp_CeB_CeB[15];
+  uint8_t aDataRateMax_CeB[3];
+
+  tNFA_GET_CONFIG* get_config;
+
+  static HciRFParams sHciRFParams;
+
+  bool mIsInit;  // whether HciRFParams is initialized
+  SyncEvent mGetConfigEvent;
+
+  SyncEvent mUiccListenEvent;
+  SyncEvent mAidRegisterEvent;
+  SyncEvent mAidDegisterEvent;
+  SyncEvent mDataRecvEvent;
+
+  /*******************************************************************************
+  **
+  ** Function:        HciRFParams
+  **
+  ** Description:     Initialize member variables.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  HciRFParams();
+
+  /*******************************************************************************
+  **
+  ** Function:        ~HciRFParams
+  **
+  ** Description:     Release all resources.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  ~HciRFParams();
 };
diff --git a/nci/jni/IntervalTimer.cpp b/nci/jni/IntervalTimer.cpp
index e5644bdf..4f60b339 100644
--- a/nci/jni/IntervalTimer.cpp
+++ b/nci/jni/IntervalTimer.cpp
@@ -35,86 +35,80 @@
 /*
  *  Asynchronous interval timer.
  */
-#define LOG_TAG "IntervalTimer"
 
 #include "IntervalTimer.h"
-#include "_OverrideLog.h"
 #include <string.h>
 
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
 
-IntervalTimer::IntervalTimer()
-{
-    mTimerId = 0;
-    mCb = NULL;
-}
-
+using android::base::StringPrintf;
 
-bool IntervalTimer::set(int ms, TIMER_FUNC cb)
-{
-    if (mTimerId == 0)
-    {
-        if (cb == NULL)
-            return false;
-
-        if (!create(cb))
-            return false;
-    }
-    if (cb != mCb)
-    {
-        kill();
-        if (!create(cb))
-            return false;
-    }
-
-    int stat = 0;
-    struct itimerspec ts;
-    ts.it_value.tv_sec = ms / 1000;
-    ts.it_value.tv_nsec = (ms % 1000) * 1000000;
-
-    ts.it_interval.tv_sec = 0;
-    ts.it_interval.tv_nsec = 0;
-
-    stat = timer_settime(mTimerId, 0, &ts, 0);
-    if (stat == -1)
-        ALOGE("fail set timer");
-    return stat == 0;
+IntervalTimer::IntervalTimer() {
+  mTimerId = 0;
+  mCb = NULL;
 }
 
+bool IntervalTimer::set(int ms, TIMER_FUNC cb) {
+  if (mTimerId == 0) {
+    if (cb == NULL) return false;
 
-IntervalTimer::~IntervalTimer()
-{
+    if (!create(cb)) return false;
+  }
+  if (cb != mCb) {
     kill();
+    if (!create(cb)) return false;
+  }
+
+  int stat = 0;
+  struct itimerspec ts;
+  ts.it_value.tv_sec = ms / 1000;
+  ts.it_value.tv_nsec = (ms % 1000) * 1000000;
+
+  ts.it_interval.tv_sec = 0;
+  ts.it_interval.tv_nsec = 0;
+
+  stat = timer_settime(mTimerId, 0, &ts, 0);
+  if (stat == -1) LOG(ERROR) << StringPrintf("fail set timer");
+  return stat == 0;
 }
 
+IntervalTimer::~IntervalTimer() { kill(); }
+
+void IntervalTimer::kill() {
+  if (mTimerId == 0) return;
 
-void IntervalTimer::kill()
-{
-    if (mTimerId == 0)
-        return;
+  timer_delete(mTimerId);
+  mTimerId = 0;
+  mCb = NULL;
+}
 
-    timer_delete(mTimerId);
-    mTimerId = 0;
-    mCb = NULL;
+bool IntervalTimer::create(TIMER_FUNC cb) {
+  struct sigevent se;
+  memset(&se, 0, sizeof(struct sigevent));
+  int stat = 0;
+
+  /*
+   * Set the sigevent structure to cause the signal to be
+   * delivered by creating a new thread.
+   */
+  se.sigev_notify = SIGEV_THREAD;
+  se.sigev_value.sival_ptr = &mTimerId;
+  se.sigev_notify_function = cb;
+  se.sigev_notify_attributes = NULL;
+  mCb = cb;
+  stat = timer_create(CLOCK_MONOTONIC, &se, &mTimerId);
+  if (stat == -1) LOG(ERROR) << StringPrintf("fail create timer");
+  return stat == 0;
 }
 
+bool IntervalTimer::isRunning(void) {
+  if (mTimerId == 0) return false;
+
+  int stat = 0;
+  struct itimerspec ts;
 
-bool IntervalTimer::create(TIMER_FUNC cb)
-{
-    struct sigevent se;
-    memset(&se,0,sizeof(struct sigevent));
-    int stat = 0;
-
-    /*
-     * Set the sigevent structure to cause the signal to be
-     * delivered by creating a new thread.
-     */
-    se.sigev_notify = SIGEV_THREAD;
-    se.sigev_value.sival_ptr = &mTimerId;
-    se.sigev_notify_function = cb;
-    se.sigev_notify_attributes = NULL;
-    mCb = cb;
-    stat = timer_create(CLOCK_MONOTONIC, &se, &mTimerId);
-    if (stat == -1)
-        ALOGE("fail create timer");
-    return stat == 0;
+  stat = timer_gettime(mTimerId, &ts);
+  if (stat != 0) return false;
+  return ((ts.it_value.tv_sec > 0 || ts.it_value.tv_nsec > 0) ? true : false);
 }
diff --git a/nci/jni/IntervalTimer.h b/nci/jni/IntervalTimer.h
index 66e345d3..03049530 100644
--- a/nci/jni/IntervalTimer.h
+++ b/nci/jni/IntervalTimer.h
@@ -18,21 +18,41 @@
  *  Asynchronous interval timer.
  */
 
+/******************************************************************************
+ *
+ *  The original Work has been changed by NXP Semiconductors.
+ *
+ *  Copyright (C) 2018 NXP Semiconductors
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#pragma once
 #include <time.h>
 
+class IntervalTimer {
+ public:
+  typedef void (*TIMER_FUNC)(union sigval);
 
-class IntervalTimer
-{
-public:
-    typedef void (*TIMER_FUNC) (union sigval);
-
-    IntervalTimer();
-    ~IntervalTimer();
-    bool set(int ms, TIMER_FUNC cb);
-    void kill();
-    bool create(TIMER_FUNC );
+  IntervalTimer();
+  ~IntervalTimer();
+  bool set(int ms, TIMER_FUNC cb);
+  void kill();
+  bool create(TIMER_FUNC);
+  bool isRunning(void);  // This function returns true if a valid timer is
+                         // running(curTime > 0)
 
-private:
-    timer_t mTimerId;
-    TIMER_FUNC mCb;
+ private:
+  timer_t mTimerId;
+  TIMER_FUNC mCb;
 };
diff --git a/nci/jni/JavaClassConstants.h b/nci/jni/JavaClassConstants.h
index 4c60f32d..15ec917d 100644
--- a/nci/jni/JavaClassConstants.h
+++ b/nci/jni/JavaClassConstants.h
@@ -17,7 +17,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -33,51 +33,46 @@
  *
  ******************************************************************************/
 #pragma once
+#include "NfcJniUtil.h"
 
-
-namespace android
-{
-    extern jmethodID gCachedNfcManagerNotifyNdefMessageListeners;
-    extern jmethodID gCachedNfcManagerNotifyTransactionListeners;
-    extern jmethodID gCachedNfcManagerNotifyConnectivityListeners;
-    extern jmethodID gCachedNfcManagerNotifyEmvcoMultiCardDetectedListeners;
-    extern jmethodID gCachedNfcManagerNotifyLlcpLinkActivation;
-    extern jmethodID gCachedNfcManagerNotifyLlcpLinkDeactivated;
-    extern jmethodID gCachedNfcManagerNotifyLlcpFirstPacketReceived;
-    extern jmethodID gCachedNfcManagerNotifySeFieldActivated;
-    extern jmethodID gCachedNfcManagerNotifySeFieldDeactivated;
-    extern jmethodID gCachedNfcManagerNotifySeListenActivated;
-    extern jmethodID gCachedNfcManagerNotifySeListenDeactivated;
-    extern jmethodID gCachedNfcManagerNotifyUiccStatusEvent;
-    /*
-     * host-based card emulation
-     */
-    extern jmethodID gCachedNfcManagerNotifyHostEmuActivated;
-    extern jmethodID gCachedNfcManagerNotifyHostEmuData;
-#if(NXP_EXTNS == TRUE)
-#if(NXP_NFCC_HCE_F == TRUE)
-    extern jmethodID gCachedNfcManagerNotifyT3tConfigure;
-    extern jmethodID gCachedNfcManagerNotifyReRoutingEntry;
+namespace android {
+extern jmethodID gCachedNfcManagerNotifyNdefMessageListeners;
+extern jmethodID gCachedNfcManagerNotifyTransactionListeners;
+extern jmethodID gCachedNfcManagerNotifyConnectivityListeners;
+extern jmethodID gCachedNfcManagerNotifyEmvcoMultiCardDetectedListeners;
+extern jmethodID gCachedNfcManagerNotifyLlcpLinkActivation;
+extern jmethodID gCachedNfcManagerNotifyLlcpLinkDeactivated;
+extern jmethodID gCachedNfcManagerNotifyLlcpFirstPacketReceived;
+extern jmethodID gCachedNfcManagerNotifySeFieldActivated;
+extern jmethodID gCachedNfcManagerNotifySeFieldDeactivated;
+extern jmethodID gCachedNfcManagerNotifySeListenActivated;
+extern jmethodID gCachedNfcManagerNotifySeListenDeactivated;
+extern jmethodID gCachedNfcManagerNotifyUiccStatusEvent;
+/*
+ * host-based card emulation
+ */
+extern jmethodID gCachedNfcManagerNotifyHostEmuActivated;
+extern jmethodID gCachedNfcManagerNotifyHostEmuData;
+#if (NXP_EXTNS == TRUE)
+#if (NXP_NFCC_HCE_F == TRUE)
+extern jmethodID gCachedNfcManagerNotifyT3tConfigure;
+extern jmethodID gCachedNfcManagerNotifyReRoutingEntry;
 #endif
-    extern jmethodID gCachedNfcManagerNotifyDownloadInProgress;
-    extern jmethodID gCachedNfcManagerNotifyFwDwnldRequested;
+extern jmethodID gCachedNfcManagerNotifyDownloadInProgress;
+extern jmethodID gCachedNfcManagerNotifyFwDwnldRequested;
 #endif
-    extern jmethodID gCachedNfcManagerNotifyHostEmuDeactivated;
-    extern jmethodID gCachedNfcManagerNotifyAidRoutingTableFull;
-    extern jmethodID gCachedNfcManagerNotifySWPReaderRequested;
-    extern jmethodID gCachedNfcManagerNotifySWPReaderRequestedFail;
-    extern jmethodID gCachedNfcManagerNotifySWPReaderActivated;
-    extern jmethodID gCachedNfcManagerNotifySWPReaderTagRemove;
-    extern jmethodID gCachedNfcManagerNotifyETSIReaderModeStartConfig;
-    extern jmethodID gCachedNfcManagerNotifyETSIReaderModeStopConfig;
-    extern jmethodID gCachedNfcManagerNotifyETSIReaderModeSwpTimeout;
+extern jmethodID gCachedNfcManagerNotifyHostEmuDeactivated;
+extern jmethodID gCachedNfcManagerNotifyAidRoutingTableFull;
 
-    extern const char* gNativeP2pDeviceClassName;
-    extern const char* gNativeLlcpServiceSocketClassName;
-    extern const char* gNativeLlcpConnectionlessSocketClassName;
-    extern const char* gNativeLlcpSocketClassName;
-    extern const char* gNativeNfcTagClassName;
-    extern const char* gNativeNfcManagerClassName;
-    extern const char* gNativeNfcSecureElementClassName;
-    extern const char* gNativeNfcAlaClassName;
-}
+extern const char* gNativeP2pDeviceClassName;
+extern const char* gNativeLlcpServiceSocketClassName;
+extern const char* gNativeLlcpConnectionlessSocketClassName;
+extern const char* gNativeLlcpSocketClassName;
+extern const char* gNativeNfcTagClassName;
+extern const char* gNativeNfcManagerClassName;
+extern const char* gNativeNfcSecureElementClassName;
+#if (NXP_EXTNS == TRUE)
+extern const char* gNativeNfcAlaClassName;
+extern const char* gNativeNfcMposManagerClassName;
+#endif
+}  // namespace android
diff --git a/nci/jni/JcopManager.cpp b/nci/jni/JcopManager.cpp
new file mode 100644
index 00000000..d4c320d2
--- /dev/null
+++ b/nci/jni/JcopManager.cpp
@@ -0,0 +1,387 @@
+/*
+ * Copyright (C) 2017 NXP Semiconductors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+#include "JcopManager.h"
+#include <dlfcn.h>
+
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+
+JcopManager* JcopManager::mJcpMgr = NULL;
+static phJcop_Context_t g_mPhJcpCtxt;
+static phJcop_Context_t* pg_mPhJcpCtxt = &g_mPhJcpCtxt;
+static void* Pgpx_Jcop_handle = NULL;
+#define DL_STATUS_OK 0x00
+
+JcopManager::JcopManager() {}
+
+JcopManager::~JcopManager() {}
+
+/*******************************************************************************
+**
+** Function:        getInstance
+**
+** Description:     Get the JcopManager singleton object.
+**
+** Returns:         JcopManager object.
+**
+*******************************************************************************/
+JcopManager* JcopManager::getInstance() {
+  if (mJcpMgr == NULL) {
+    mJcpMgr = new JcopManager();
+  }
+  return mJcpMgr;
+}
+
+/*******************************************************************************
+**
+** Function:        deleteInstance
+**
+** Description:     Delete the JcopManager singleton object.
+**
+*******************************************************************************/
+void JcopManager::deleteInstance() {
+  if (mJcpMgr != NULL) {
+    delete mJcpMgr;
+    mJcpMgr = NULL;
+  }
+}
+
+/*******************************************************************************
+**
+** Function:        JcopInitialize
+**
+** Description:     Load the library and initialize the symbols and variables.
+**
+** Returns:         STATUS_OK if Success.
+**                  STATUS_FAILED if unSuccessfull
+**
+*******************************************************************************/
+tNFA_STATUS JcopManager::JcopInitialize() {
+  tNFA_STATUS wStatus = NFA_STATUS_OK;
+  // Getting pointer to JCOP module
+  Pgpx_Jcop_handle = dlopen("system/lib64/libp61-jcop-kit.so", RTLD_NOW);
+  if (Pgpx_Jcop_handle == NULL) {
+    LOG(ERROR) << StringPrintf(
+        "%s: Error : opening (system/lib64/libp61-jcop-kit.so) !!", __func__);
+    return NFA_STATUS_FAILED;
+  }
+  // Getting pointer to ALA_Init function
+  if ((pg_mPhJcpCtxt->ala_init =
+           (tJCOP_INIT_CBACK*)dlsym(Pgpx_Jcop_handle, "ALA_Init")) == NULL) {
+    LOG(ERROR) << StringPrintf(
+        "%s: Error while linking JCOP context (ALA_Init) !!", __func__);
+    return NFA_STATUS_FAILED;
+  }
+  // Getting pointer to ALA_Start function
+  if ((pg_mPhJcpCtxt->ala_start =
+           (tALA_START_CBACK*)dlsym(Pgpx_Jcop_handle, "ALA_Start")) == NULL) {
+    wStatus = NFA_STATUS_FAILED;
+    LOG(ERROR) << StringPrintf(
+        "%s: Error while linking JCOP context (ALA_Start) !!", __func__);
+  }
+
+#if (NXP_LDR_SVC_VER_2 == FALSE)
+  // Getting pointer to ALA_GetlistofApplets function
+  if ((pg_mPhJcpCtxt->ala_applets_list = (tALA_APPLET_LIST_CBACK*)dlsym(
+           Pgpx_Jcop_handle, "ALA_GetlistofApplets")) == NULL) {
+    wStatus = NFA_STATUS_FAILED;
+    LOG(ERROR) << StringPrintf(
+        "%s: Error while linking JCOP context (ALA_GetlistofApplets) !!",
+        __func__);
+  }
+  // Getting pointer to ALA_GetCertificateKey function
+  if ((pg_mPhJcpCtxt->ala_get_certkey = (tALA_GET_CERTKEY_CBACK*)dlsym(
+           Pgpx_Jcop_handle, "ALA_GetCertificateKey")) == NULL) {
+    wStatus = NFA_STATUS_FAILED;
+    LOG(ERROR) << StringPrintf(
+        "%s: Error while linking JCOP context (ALA_GetCertificateKey) !!",
+        __func__);
+  }
+#endif
+
+  // Getting pointer to ALA_DeInit function
+  if ((pg_mPhJcpCtxt->ala_deinit = (tJCOP_DEINIT_CBACK*)dlsym(
+           Pgpx_Jcop_handle, "ALA_DeInit")) == NULL) {
+    wStatus = NFA_STATUS_FAILED;
+    LOG(ERROR) << StringPrintf(
+        "%s: Error while linking JCOP context (ALA_DeInit) !!", __func__);
+  }
+  // Getting pointer to ALA_lsGetVersion function
+  if ((pg_mPhJcpCtxt->ala_lsgetversion = (tALA_LS_CBACK*)dlsym(
+           Pgpx_Jcop_handle, "ALA_lsGetVersion")) == NULL) {
+    wStatus = NFA_STATUS_FAILED;
+    LOG(ERROR) << StringPrintf(
+        "%s: Error while linking JCOP context (ALA_lsGetVersion) !!", __func__);
+  }
+  // Getting pointer to ALA_lsGetStatus function
+  if ((pg_mPhJcpCtxt->ala_lsgetstatus = (tALA_LS_CBACK*)dlsym(
+           Pgpx_Jcop_handle, "ALA_lsGetStatus")) == NULL) {
+    wStatus = NFA_STATUS_FAILED;
+    LOG(ERROR) << StringPrintf(
+        "%s: Error while linking JCOP context (ALA_lsGetStatus) !!", __func__);
+  }
+  // Getting pointer to ALA_lsGetAppletStatus function
+  if ((pg_mPhJcpCtxt->ala_lsgetappletstatus = (tALA_LS_CBACK*)dlsym(
+           Pgpx_Jcop_handle, "ALA_lsGetAppletStatus")) == NULL) {
+    wStatus = NFA_STATUS_FAILED;
+    LOG(ERROR) << StringPrintf(
+        "%s: Error while linking JCOP context (ALA_lsGetAppletStatus) !!",
+        __func__);
+  }
+  // Getting pointer to JCDNLD_Init function
+  if ((pg_mPhJcpCtxt->jcop_init =
+           (tJCOP_INIT_CBACK*)dlsym(Pgpx_Jcop_handle, "JCDNLD_Init")) == NULL) {
+    wStatus = NFA_STATUS_FAILED;
+    LOG(ERROR) << StringPrintf(
+        "%s: Error while linking JCOP context (JCDNLD_Init) !!", __func__);
+  }
+  // Getting pointer to JCDNLD_StartDownload function
+  if ((pg_mPhJcpCtxt->jcdnld_startdnld = (tJCDNLD_DWLD_CBACK*)dlsym(
+           Pgpx_Jcop_handle, "JCDNLD_StartDownload")) == NULL) {
+    wStatus = NFA_STATUS_FAILED;
+    LOG(ERROR) << StringPrintf(
+        "%s: Error while linking JCOP context (JCDNLD_StartDownload) !!",
+        __func__);
+  }
+  // Getting pointer to JCDNLD_DeInit function
+  if ((pg_mPhJcpCtxt->jcdnld_deinit = (tJCOP_DEINIT_CBACK*)dlsym(
+           Pgpx_Jcop_handle, "JCDNLD_DeInit")) == NULL) {
+    wStatus = NFA_STATUS_FAILED;
+    LOG(ERROR) << StringPrintf(
+        "%s: Error while linking JCOP context (JCDNLD_DeInit) !!", __func__);
+  }
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function:        JcopDeInitialize
+**
+** Description:     De-initialize the library
+**
+** Returns:         STATUS_OK if Success.
+**                  STATUS_FAILED if unSuccessfull
+**
+*******************************************************************************/
+tNFA_STATUS JcopManager::JcopDeInitialize() {
+  if (Pgpx_Jcop_handle != NULL) {
+    if ((dlclose(Pgpx_Jcop_handle)) != DL_STATUS_OK) {
+      LOG(ERROR) << StringPrintf(
+          "%s: Error : closing (system/lib64/libp61-jcop-kit.so) !!", __func__);
+      return NFA_STATUS_FAILED;
+    }
+  } else {
+    LOG(ERROR) << StringPrintf("%s: Invalid handle !!", __func__);
+  }
+  return NFA_STATUS_OK;
+}
+
+/*******************************************************************************
+**
+** Function:        AlaInitialize
+**
+** Description:     Initializes the ALA library and opens the DWP communication
+*channel
+**
+** Returns:         STATUS_OK if Success.
+**                  STATUS_FAILED if unSuccessfull
+**
+*******************************************************************************/
+tNFC_JBL_STATUS JcopManager::AlaInitialize(IChannel_t* channel) {
+  if (channel == NULL) {
+    LOG(ERROR) << StringPrintf("%s: Invalid handle !!", __func__);
+    return NFA_STATUS_FAILED;
+  }
+  return pg_mPhJcpCtxt->ala_init(channel);
+}
+
+/*******************************************************************************
+**
+** Function:        AlaDeInitialize
+**
+** Description:     Deinitializes the ALA Lib
+**
+** Returns:         True if ok.
+**
+*******************************************************************************/
+bool JcopManager::AlaDeInitialize() { return pg_mPhJcpCtxt->ala_deinit(); }
+
+/*******************************************************************************
+**
+** Function:        AlaStart
+**
+** Description:     Starts the ALA over DWP
+**
+** Returns:         STATUS_OK if Success.
+**                  STATUS_FAILED if unSuccessfull
+**
+*******************************************************************************/
+#if (NXP_LDR_SVC_VER_2 == TRUE)
+tNFC_JBL_STATUS JcopManager::AlaStart(const char* name, const char* dest,
+                                      uint8_t* pdata, uint16_t len,
+                                      uint8_t* respSW) {
+  if (!name || !dest || !pdata || !respSW) {
+    LOG(ERROR) << StringPrintf("%s: Invalid Params !!", __func__);
+    return NFA_STATUS_FAILED;
+  }
+  return pg_mPhJcpCtxt->ala_start(name, dest, pdata, len, respSW);
+}
+#else
+tNFC_JBL_STATUS JcopManager::AlaStart(const char* name, uint8_t* pdata,
+                                      uint16_t len) {
+  if (!name || !pdata) {
+    LOG(ERROR) << StringPrintf("%s: Invalid Params !!", __func__);
+    return NFA_STATUS_FAILED;
+  }
+  return pg_mPhJcpCtxt->ala_start(name, dest, pdata, len, respSW);
+}
+#endif
+
+#if (NXP_LDR_SVC_VER_2 == FALSE)
+/*******************************************************************************
+**
+** Function:        AlaGetlistofApplets
+**
+** Description:     list all the applets.
+**
+*******************************************************************************/
+void JcopManager::AlaGetlistofApplets(char* list[], uint8_t* num) {
+  if (!list || !num) {
+    LOG(ERROR) << StringPrintf("%s: Invalid Params !!", __func__);
+    return;
+  }
+  pg_mPhJcpCtxt->ala_applets_list(list, num);
+}
+
+/*******************************************************************************
+**
+** Function:        AlaGetCertificateKey
+**
+** Description:     Get the certification key
+**
+** Returns:         True if ok.
+**
+*******************************************************************************/
+tNFC_JBL_STATUS JcopManager::AlaGetCertificateKey(uint8_t* pKey,
+                                                  int32_t* pKeylen) {
+  if (!pKey || !pKeylen) {
+    LOG(ERROR) << StringPrintf("%s: Invalid Params !!", __func__);
+    return NFA_STATUS_FAILED;
+  }
+  return pg_mPhJcpCtxt->ala_get_certkey(pKey, pKeylen);
+}
+#endif
+
+/*******************************************************************************
+**
+** Function:        AlaLsGetVersion
+**
+** Description:     Get the version of the loader version
+**
+** Returns:         STATUS_OK if Success.
+**                  STATUS_FAILED if unSuccessfull
+**
+*******************************************************************************/
+tNFC_JBL_STATUS JcopManager::AlaLsGetVersion(uint8_t* pVersion) {
+  if (!pVersion) {
+    LOG(ERROR) << StringPrintf("%s: Invalid Params !!", __func__);
+    return NFA_STATUS_FAILED;
+  }
+  return pg_mPhJcpCtxt->ala_lsgetversion(pVersion);
+}
+
+/*******************************************************************************
+**
+** Function:        AlaLsGetAppletStatus
+**
+** Description:     Get the status of the loader service version
+**
+** Returns:         STATUS_OK if Success.
+**                  STATUS_FAILED if unSuccessfull
+**
+*******************************************************************************/
+tNFC_JBL_STATUS JcopManager::AlaLsGetAppletStatus(uint8_t* pVersion) {
+  if (!pVersion) {
+    LOG(ERROR) << StringPrintf("%s: Invalid Params !!", __func__);
+    return NFA_STATUS_FAILED;
+  }
+  return pg_mPhJcpCtxt->ala_lsgetappletstatus(pVersion);
+}
+
+/*******************************************************************************
+**
+** Function:        AlaLsGetAppletStatus
+**
+** Description:     Get the status of the loader service
+**
+** Returns:         STATUS_OK if Success.
+**                  STATUS_FAILED if unSuccessfull
+**
+*******************************************************************************/
+tNFC_JBL_STATUS JcopManager::AlaLsGetStatus(uint8_t* pVersion) {
+  if (!pVersion) {
+    LOG(ERROR) << StringPrintf("%s: Invalid Params !!", __func__);
+    return NFA_STATUS_FAILED;
+  }
+  return pg_mPhJcpCtxt->ala_lsgetstatus(pVersion);
+}
+
+/*******************************************************************************
+**
+** Function:        JCDnldInit
+**
+** Description:     Initializes the JCOP library and opens the DWP communication
+*channel
+**
+** Returns:         STATUS_OK if Success.
+**                  STATUS_FAILED if unSuccessfull
+**
+*******************************************************************************/
+tNFC_JBL_STATUS JcopManager::JCDnldInit(IChannel_t* channel) {
+  if (!channel) {
+    LOG(ERROR) << StringPrintf("%s: Invalid Params !!", __func__);
+    return NFA_STATUS_FAILED;
+  }
+  return pg_mPhJcpCtxt->jcop_init(channel);
+}
+
+/*******************************************************************************
+**
+** Function:        JCDnldStartDownload
+**
+** Description:     Starts the JCOP update
+**
+** Returns:         STATUS_OK if Success.
+**                  STATUS_FAILED if unSuccessfull
+**
+*******************************************************************************/
+tNFC_JBL_STATUS JcopManager::JCDnldStartDownload() {
+  return pg_mPhJcpCtxt->jcdnld_startdnld();
+}
+
+/*******************************************************************************
+**
+** Function:        JCDnldDeInit
+**
+** Description:     De-initializes the JCOP Library
+**
+** Returns:         True if ok.
+**
+*******************************************************************************/
+bool JcopManager::JCDnldDeInit() { return pg_mPhJcpCtxt->jcdnld_deinit(); }
diff --git a/nci/jni/JcopManager.h b/nci/jni/JcopManager.h
new file mode 100644
index 00000000..511d80db
--- /dev/null
+++ b/nci/jni/JcopManager.h
@@ -0,0 +1,272 @@
+/*
+ * Copyright (C) 2017 NXP Semiconductors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include "nfa_api.h"
+
+typedef struct IChannel {
+  int16_t (*open)();              /* Initialize the channel. */
+  bool (*close)(int16_t mHandle); /* Close the channel. */
+  bool (*transceive)(
+      uint8_t* xmitBuffer, int32_t xmitBufferSize, uint8_t* recvBuffer,
+      int32_t recvBufferMaxSize, int32_t& recvBufferActualSize,
+      int32_t timeoutMillisec); /* Send/receive data to the secure element*/
+  void (*doeSE_Reset)();        /* Power OFF and ON to eSE */
+  void (*doeSE_JcopDownLoadReset)(); /* Power OFF and ON to eSE during JCOP
+                                        Update */
+} IChannel_t;
+
+#define pJcopMgr (JcopManager::getInstance())
+typedef unsigned char(tJCOP_INIT_CBACK)(IChannel_t* channel);
+#if (NXP_LDR_SVC_VER_2 == TRUE)
+typedef unsigned char(tALA_START_CBACK)(const char* name, const char* dest,
+                                        uint8_t* pdata, uint16_t len,
+                                        uint8_t* respSW);
+#else
+typedef unsigned char(tALA_START_CBACK)(const char* name, uint8_t* pdata,
+                                        uint16_t len);
+typedef unsigned char(tALA_GET_CERTKEY_CBACK)(uint8_t* pKey, int32_t* pKeylen);
+typedef void(tALA_APPLET_LIST_CBACK)(char* list[], uint8_t* num);
+#endif
+typedef unsigned char(tALA_LS_CBACK)(uint8_t* pVersion);
+typedef unsigned char(tJCDNLD_DWLD_CBACK)();
+typedef bool(tJCOP_DEINIT_CBACK)();
+
+typedef struct phJcop_Context {
+  /* Call backs */
+  tJCOP_INIT_CBACK* jcop_init;
+  tJCOP_INIT_CBACK* ala_init;
+  tALA_START_CBACK* ala_start;
+#if (NXP_LDR_SVC_VER_2 == FALSE)
+  tALA_APPLET_LIST_CBACK* ala_applets_list;
+  tALA_GET_CERTKEY_CBACK* ala_get_certkey;
+#endif
+  tALA_LS_CBACK* ala_lsgetversion;
+  tALA_LS_CBACK* ala_lsgetstatus;
+  tALA_LS_CBACK* ala_lsgetappletstatus;
+  tJCDNLD_DWLD_CBACK* jcdnld_startdnld;
+  tJCOP_DEINIT_CBACK* ala_deinit;
+  tJCOP_DEINIT_CBACK* jcdnld_deinit;
+} phJcop_Context_t;
+typedef unsigned char tNFC_JBL_STATUS;
+
+class JcopManager {
+ private:
+  static JcopManager* mJcpMgr;
+  /*******************************************************************************
+  **
+  ** Function:        JcopManager
+  **
+  ** Description:     Initialize member variables.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  JcopManager();
+
+  /*******************************************************************************
+  **
+  ** Function:        ~JcopManager
+  **
+  ** Description:     Release all resources.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  ~JcopManager();
+
+ public:
+  /*******************************************************************************
+  **
+  ** Function:        getInstance
+  **
+  ** Description:     Get the JcopManager singleton object.
+  **
+  ** Returns:         JcopManager object.
+  **
+  *******************************************************************************/
+  static JcopManager* getInstance();
+
+  /*******************************************************************************
+  **
+  ** Function:        deleteInstance
+  **
+  ** Description:     Delete the JcopManager singleton object.
+  **
+  *******************************************************************************/
+  void deleteInstance();
+
+  /*******************************************************************************
+  **
+  ** Function:        JcopInitialize
+  **
+  ** Description:     Load the library and initialize the symbols and variables.
+  **
+  ** Returns:         STATUS_OK if Success.
+  **                  STATUS_FAILED if unSuccessfull
+  **
+  *******************************************************************************/
+  tNFA_STATUS JcopInitialize();
+
+  /*******************************************************************************
+  **
+  ** Function:        JcopDeInitialize
+  **
+  ** Description:     De-initialize the library
+  **
+  ** Returns:         STATUS_OK if Success.
+  **                  STATUS_FAILED if unSuccessfull
+  **
+  *******************************************************************************/
+  tNFA_STATUS JcopDeInitialize();
+
+  /*******************************************************************************
+  **
+  ** Function:        AlaInitialize
+  **
+  ** Description:     Initializes the ALA library and opens the DWP
+  *communication channel
+  **
+  ** Returns:         STATUS_OK if Success.
+  **                  STATUS_FAILED if unSuccessfull
+  **
+  *******************************************************************************/
+  tNFC_JBL_STATUS AlaInitialize(IChannel_t* channel);
+
+  /*******************************************************************************
+  **
+  ** Function:        AlaDeInitialize
+  **
+  ** Description:     Deinitializes the ALA Lib
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool AlaDeInitialize();
+
+/*******************************************************************************
+**
+** Function:        AlaStart
+**
+** Description:     Starts the ALA over DWP
+**
+** Returns:         STATUS_OK if Success.
+**                  STATUS_FAILED if unSuccessfull
+**
+*******************************************************************************/
+#if (NXP_LDR_SVC_VER_2 == TRUE)
+  tNFC_JBL_STATUS AlaStart(const char* name, const char* dest, uint8_t* pdata,
+                           uint16_t len, uint8_t* respSW);
+#else
+  tNFC_JBL_STATUS AlaStart(const char* name, uint8_t* pdata, uint16_t len);
+#endif
+
+  /*******************************************************************************
+  **
+  ** Function:        AlaLsGetVersion
+  **
+  ** Description:     Get the version of the loader version
+  **
+  ** Returns:         STATUS_OK if Success.
+  **                  STATUS_FAILED if unSuccessfull
+  **
+  *******************************************************************************/
+  tNFC_JBL_STATUS AlaLsGetVersion(uint8_t* pVersion);
+
+  /*******************************************************************************
+  **
+  ** Function:        AlaLsGetAppletStatus
+  **
+  ** Description:     Get the status of the loader service version
+  **
+  ** Returns:         STATUS_OK if Success.
+  **                  STATUS_FAILED if unSuccessfull
+  **
+  *******************************************************************************/
+  tNFC_JBL_STATUS AlaLsGetAppletStatus(uint8_t* pVersion);
+
+  /*******************************************************************************
+  **
+  ** Function:        AlaLsGetAppletStatus
+  **
+  ** Description:     Get the status of the loader service
+  **
+  ** Returns:         STATUS_OK if Success.
+  **                  STATUS_FAILED if unSuccessfull
+  **
+  *******************************************************************************/
+  tNFC_JBL_STATUS AlaLsGetStatus(uint8_t* pVersion);
+
+#if (NXP_LDR_SVC_VER_2 == FALSE)
+  /*******************************************************************************
+  **
+  ** Function:        AlaGetlistofApplets
+  **
+  ** Description:     list all the applets.
+  **
+  *******************************************************************************/
+
+  void AlaGetlistofApplets(char* list[], uint8_t* num);
+
+  /*******************************************************************************
+  **
+  ** Function:        AlaGetCertificateKey
+  **
+  ** Description:     Get the certification key
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  tNFC_JBL_STATUS AlaGetCertificateKey(uint8_t* pKey, int32_t* pKeylen);
+#endif
+
+  /*******************************************************************************
+  **
+  ** Function:        JCDnldInit
+  **
+  ** Description:     Initializes the JCOP library and opens the DWP
+  *communication channel
+  **
+  ** Returns:         STATUS_OK if Success.
+  **                  STATUS_FAILED if unSuccessfull
+  **
+  *******************************************************************************/
+  tNFC_JBL_STATUS JCDnldInit(IChannel_t* channel);
+
+  /*******************************************************************************
+  **
+  ** Function:        JCDnldStartDownload
+  **
+  ** Description:     Starts the JCOP update
+  **
+  ** Returns:         STATUS_OK if Success.
+  **                  STATUS_FAILED if unSuccessfull
+  **
+  *******************************************************************************/
+  tNFC_JBL_STATUS JCDnldStartDownload();
+
+  /*******************************************************************************
+  **
+  ** Function:        JCDnldDeInit
+  **
+  ** Description:     De-initializes the JCOP Library
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool JCDnldDeInit();
+};
diff --git a/nci/jni/MposManager.cpp b/nci/jni/MposManager.cpp
new file mode 100644
index 00000000..71dd2e3a
--- /dev/null
+++ b/nci/jni/MposManager.cpp
@@ -0,0 +1,882 @@
+/******************************************************************************
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  Copyright 2018 NXP
+ *
+ ******************************************************************************/
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+#include "MposManager.h"
+#include <ScopedLocalRef.h>
+#include "SecureElement.h"
+#include "TransactionController.h"
+#include "nfc_config.h"
+#include "phNxpConfig.h"
+
+using namespace android;
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+
+namespace android {
+extern tNFA_STATUS EmvCo_dosetPoll(jboolean enable);
+extern bool isDiscoveryStarted();
+extern void startRfDiscovery(bool isStart);
+}  // namespace android
+
+MposManager MposManager::mMposMgr;
+int32_t MposManager::mDiscNtfTimeout = 10;
+int32_t MposManager::mRdrTagOpTimeout = 20;
+jmethodID MposManager::gCachedMposManagerNotifyETSIReaderRequested;
+jmethodID MposManager::gCachedMposManagerNotifyETSIReaderRequestedFail;
+jmethodID MposManager::gCachedMposManagerNotifyETSIReaderModeStartConfig;
+jmethodID MposManager::gCachedMposManagerNotifyETSIReaderModeStopConfig;
+jmethodID MposManager::gCachedMposManagerNotifyETSIReaderModeSwpTimeout;
+jmethodID MposManager::gCachedMposManagerNotifyETSIReaderRestart;
+
+/*******************************************************************************
+**
+** Function:        initMposNativeStruct
+**
+** Description:     Used to initialize the Native MPOS notification methods
+**
+** Returns:         None.
+**
+*******************************************************************************/
+void MposManager::initMposNativeStruct(JNIEnv* e, jobject o) {
+  ScopedLocalRef<jclass> cls(e, e->GetObjectClass(o));
+
+  gCachedMposManagerNotifyETSIReaderRequested =
+      e->GetMethodID(cls.get(), "notifyETSIReaderRequested", "(ZZ)V");
+
+  gCachedMposManagerNotifyETSIReaderRequestedFail =
+      e->GetMethodID(cls.get(), "notifyETSIReaderRequestedFail", "(I)V");
+
+  gCachedMposManagerNotifyETSIReaderModeStartConfig =
+      e->GetMethodID(cls.get(), "notifyonETSIReaderModeStartConfig", "(I)V");
+
+  gCachedMposManagerNotifyETSIReaderModeStopConfig =
+      e->GetMethodID(cls.get(), "notifyonETSIReaderModeStopConfig", "(I)V");
+
+  gCachedMposManagerNotifyETSIReaderModeSwpTimeout =
+      e->GetMethodID(cls.get(), "notifyonETSIReaderModeSwpTimeout", "(I)V");
+
+  gCachedMposManagerNotifyETSIReaderRestart =
+      e->GetMethodID(cls.get(), "notifyonETSIReaderModeRestart", "()V");
+}
+
+/*******************************************************************************
+**
+** Function:        getInstance
+**
+** Description:     Get the SecureElement singleton object.
+**
+** Returns:         SecureElement object.
+**
+*******************************************************************************/
+MposManager& MposManager::getInstance() { return mMposMgr; }
+
+/*******************************************************************************
+**
+** Function:        initialize
+**
+** Description:     Initialize all member variables.
+**
+** Returns:         True if ok.
+**
+*******************************************************************************/
+bool MposManager::initialize(nfc_jni_native_data* native) {
+  mNativeData = native;
+  initializeReaderInfo();
+  mDiscNtfTimeout = NfcConfig::getUnsigned(NAME_NFA_DM_DISC_NTF_TIMEOUT);
+  if (NfcConfig::hasKey(NAME_NXP_SWP_RD_TAG_OP_TIMEOUT)) {
+    mRdrTagOpTimeout = NfcConfig::getUnsigned(NAME_NXP_SWP_RD_TAG_OP_TIMEOUT);
+  }
+  return true;
+}
+
+/*******************************************************************************
+**
+** Function:        initializeReaderInfo
+**
+** Description:     Initialize all MPOS member variables.
+**
+** Returns:         none.
+**
+*******************************************************************************/
+void MposManager::initializeReaderInfo() {
+  swp_rdr_req_ntf_info.mMutex.lock();
+  memset(&(swp_rdr_req_ntf_info.swp_rd_req_info), 0x00, sizeof(rd_swp_req_t));
+  memset(&(swp_rdr_req_ntf_info.swp_rd_req_current_info), 0x00,
+         sizeof(rd_swp_req_t));
+  swp_rdr_req_ntf_info.swp_rd_req_current_info.src = NFA_HANDLE_INVALID;
+  swp_rdr_req_ntf_info.swp_rd_req_info.src = NFA_HANDLE_INVALID;
+  swp_rdr_req_ntf_info.swp_rd_state = STATE_SE_RDR_MODE_STOPPED;
+  swp_rdr_req_ntf_info.mMutex.unlock();
+}
+
+/*******************************************************************************
+**
+** Function:        finalize
+**
+** Description:     Release all resources.
+**
+** Returns:         None
+**
+*******************************************************************************/
+void MposManager::finalize() {}
+
+/*******************************************************************************
+**
+** Function:        setDedicatedReaderMode
+**
+** Description:     Set/reset MPOS dedicated mode.
+**
+** Returns:         SUCCESS/FAILED/BUSY
+**
+*******************************************************************************/
+tNFA_STATUS MposManager::setDedicatedReaderMode(bool on) {
+  tNFA_STATUS status = NFA_STATUS_OK;
+  bool rfStat = false;
+  int32_t state;
+  SecureElement& se = SecureElement::getInstance();
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s:enter, Reader Mode %s", __FUNCTION__, on ? "ON" : "OFF");
+  if (se.isRfFieldOn() || se.isActivatedInListenMode()) {
+    status = NFA_STATUS_BUSY;
+  }
+
+  if (status == NFA_STATUS_OK) {
+    state = getEtsiReaederState();
+    rfStat = isDiscoveryStarted();
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%x, rfStat=%x", on, rfStat);
+    if (on) {
+      if (rfStat) {
+        startRfDiscovery(false);
+      }
+    } else {
+      if (state != STATE_SE_RDR_MODE_STOPPED) {
+        setEtsiReaederState(STATE_SE_RDR_MODE_STOP_CONFIG);
+        etsiInitConfig();
+        startRfDiscovery(false);
+        status = etsiResetReaderConfig();
+        setEtsiReaederState(STATE_SE_RDR_MODE_STOPPED);
+      }
+      initializeReaderInfo();
+    }
+  } else {
+    LOG(ERROR) << StringPrintf(
+        "Payment is in progress, aborting reader mode start");
+  }
+  return status;
+}
+/*******************************************************************************
+**
+** Function:        setEtsiReaederState
+**
+** Description:     Set the current ETSI Reader state
+**
+** Returns:         None
+**
+*******************************************************************************/
+void MposManager::setEtsiReaederState(se_rd_req_state_t newState) {
+  swp_rdr_req_ntf_info.mMutex.lock();
+  if (newState == STATE_SE_RDR_MODE_STOPPED) {
+    swp_rdr_req_ntf_info.swp_rd_req_current_info.tech_mask &=
+        ~NFA_TECHNOLOGY_MASK_A;
+    swp_rdr_req_ntf_info.swp_rd_req_current_info.tech_mask &=
+        ~NFA_TECHNOLOGY_MASK_B;
+
+    // If all the requested tech are removed, set the hande to invalid , so that
+    // next time poll add request can be handled
+
+    swp_rdr_req_ntf_info.swp_rd_req_current_info.src = NFA_HANDLE_INVALID;
+    swp_rdr_req_ntf_info.swp_rd_req_info =
+        swp_rdr_req_ntf_info.swp_rd_req_current_info;
+  }
+  swp_rdr_req_ntf_info.swp_rd_state = newState;
+  swp_rdr_req_ntf_info.mMutex.unlock();
+}
+
+/*******************************************************************************
+**
+** Function:        getEtsiReaederState
+**
+** Description:     Get the current ETSI Reader state
+**
+** Returns:         Current ETSI state
+**
+*******************************************************************************/
+se_rd_req_state_t MposManager::getEtsiReaederState() {
+  return swp_rdr_req_ntf_info.swp_rd_state;
+}
+
+/*******************************************************************************
+**
+** Function:        etsiInitConfig
+**
+** Description:     Chnage the ETSI state before start configuration
+**
+** Returns:         None
+**
+*******************************************************************************/
+void MposManager::etsiInitConfig() {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Enter", __func__);
+  swp_rdr_req_ntf_info.mMutex.lock();
+
+  if ((swp_rdr_req_ntf_info.swp_rd_state == STATE_SE_RDR_MODE_START_CONFIG) &&
+      ((swp_rdr_req_ntf_info.swp_rd_req_info.tech_mask &
+        NFA_TECHNOLOGY_MASK_A) ||
+       (swp_rdr_req_ntf_info.swp_rd_req_info.tech_mask &
+        NFA_TECHNOLOGY_MASK_B))) {
+    if ((swp_rdr_req_ntf_info.swp_rd_req_info.tech_mask &
+         NFA_TECHNOLOGY_MASK_A)) {
+      swp_rdr_req_ntf_info.swp_rd_req_current_info.tech_mask |=
+          NFA_TECHNOLOGY_MASK_A;
+    }
+
+    if ((swp_rdr_req_ntf_info.swp_rd_req_info.tech_mask &
+         NFA_TECHNOLOGY_MASK_B)) {
+      swp_rdr_req_ntf_info.swp_rd_req_current_info.tech_mask |=
+          NFA_TECHNOLOGY_MASK_B;
+    }
+
+    swp_rdr_req_ntf_info.swp_rd_req_current_info.src =
+        swp_rdr_req_ntf_info.swp_rd_req_info.src;
+    swp_rdr_req_ntf_info.swp_rd_state = STATE_SE_RDR_MODE_START_IN_PROGRESS;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: new ETSI state : STATE_SE_RDR_MODE_START_IN_PROGRESS", __func__);
+  } else if ((swp_rdr_req_ntf_info.swp_rd_state ==
+              STATE_SE_RDR_MODE_STOP_CONFIG) &&
+             (swp_rdr_req_ntf_info.swp_rd_req_current_info.src ==
+              swp_rdr_req_ntf_info.swp_rd_req_info.src)) {
+    // pTransactionController->transactionEnd(TRANSACTION_REQUESTOR(etsiReader));
+    swp_rdr_req_ntf_info.swp_rd_state = STATE_SE_RDR_MODE_STOP_IN_PROGRESS;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: new ETSI state : STATE_SE_RDR_MODE_STOP_IN_PROGRESS", __func__);
+  }
+  swp_rdr_req_ntf_info.mMutex.unlock();
+}
+
+/*******************************************************************************
+**
+** Function:        etsiReaderConfig
+**
+** Description:     Configuring to Emvco Profile
+**
+** Returns:         Status - NFA_STATUS_FAILED
+**                           NFA_STATUS_OK
+**                           NFA_STATUS_INVALID_PARAM
+**
+*******************************************************************************/
+tNFA_STATUS MposManager::etsiReaderConfig(int32_t eeHandle) {
+  tNFC_STATUS status = NFA_STATUS_FAILED;
+  SecureElement& se = SecureElement::getInstance();
+  jboolean enable = true;
+  const tNCI_DISCOVER_MAPS
+      nfc_interface_mapping_uicc[NFC_SWP_RD_NUM_INTERFACE_MAP] = {
+          /* Protocols that use Frame Interface do not need to be included in
+             the interface mapping */
+          {NCI_PROTOCOL_ISO_DEP, NCI_INTERFACE_MODE_POLL,
+           NCI_INTERFACE_UICC_DIRECT_STAT}};
+
+  const tNCI_DISCOVER_MAPS
+      nfc_interface_mapping_ese[NFC_SWP_RD_NUM_INTERFACE_MAP] = {
+          /* Protocols that use Frame Interface do not need to be included in
+             the interface mapping */
+          {NCI_PROTOCOL_ISO_DEP, NCI_INTERFACE_MODE_POLL,
+           NCI_INTERFACE_ESE_DIRECT_STAT}};
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Enter; eeHandle : 0x%4x", __func__, eeHandle);
+  /* Setting up the emvco poll profile*/
+  status = EmvCo_dosetPoll(enable);
+  if (status != NFA_STATUS_OK) {
+    LOG(ERROR) << StringPrintf("%s: fail enable polling; error=0x%X", __func__,
+                               status);
+    return status;
+  }
+
+  if (eeHandle == se.EE_HANDLE_0xF4)  // UICC
+  {
+    SyncEventGuard guard(mDiscMapEvent);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: mapping intf for UICC", __func__);
+    status = NFC_DiscoveryMap(NFC_SWP_RD_NUM_INTERFACE_MAP,
+                              (tNCI_DISCOVER_MAPS*)nfc_interface_mapping_uicc,
+                              MposManager::discoveryMapCb);
+    if (status != NFA_STATUS_OK) {
+      LOG(ERROR) << StringPrintf("%s: fail intf mapping for UICC; error=0x%X",
+                                 __func__, status);
+      return status;
+    }
+    status =
+        mDiscMapEvent.wait(NFC_CMD_TIMEOUT) ? NFA_STATUS_OK : NFA_STATUS_FAILED;
+  } else if (eeHandle == SecureElement::EE_HANDLE_0xF3) {  // ESE
+    SyncEventGuard guard(mDiscMapEvent);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: mapping intf for ESE", __func__);
+    status = NFC_DiscoveryMap(NFC_SWP_RD_NUM_INTERFACE_MAP,
+                              (tNCI_DISCOVER_MAPS*)nfc_interface_mapping_ese,
+                              MposManager::discoveryMapCb);
+    if (status != NFA_STATUS_OK) {
+      LOG(ERROR) << StringPrintf("%s: fail intf mapping for ESE; error=0x%X",
+                                 __func__, status);
+      return status;
+    }
+    status =
+        mDiscMapEvent.wait(NFC_CMD_TIMEOUT) ? NFA_STATUS_OK : NFA_STATUS_FAILED;
+  } else {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: UNKNOWN SOURCE!!! ", __func__);
+    return NFA_STATUS_FAILED;
+  }
+
+  return NFA_STATUS_OK;
+}
+
+/*******************************************************************************
+**
+** Function:        etsiResetReaderConfig
+**
+** Description:     Configuring from Emvco profile to Nfc forum profile
+**
+** Returns:         Status
+**
+*******************************************************************************/
+tNFA_STATUS MposManager::etsiResetReaderConfig() {
+  tNFC_STATUS status = NFA_STATUS_FAILED;
+  const tNCI_DISCOVER_MAPS
+      nfc_interface_mapping_default[NFC_NUM_INTERFACE_MAP] = {
+          /* Protocols that use Frame Interface do not need to be included in
+             the interface mapping */
+          {NCI_PROTOCOL_ISO_DEP, NCI_INTERFACE_MODE_POLL_N_LISTEN,
+           NCI_INTERFACE_ISO_DEP},
+          {NCI_PROTOCOL_NFC_DEP, NCI_INTERFACE_MODE_POLL_N_LISTEN,
+           NCI_INTERFACE_NFC_DEP},
+          {NCI_PROTOCOL_T3T, NCI_INTERFACE_MODE_LISTEN, NCI_INTERFACE_FRAME}};
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Enter", __func__);
+
+  status = EmvCo_dosetPoll(false);
+  if (status != NFA_STATUS_OK) {
+    LOG(ERROR) << StringPrintf("%s: fail enable polling; error=0x%X", __func__,
+                               status);
+    status = NFA_STATUS_FAILED;
+  } else {
+    SyncEventGuard guard(mDiscMapEvent);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: mapping intf for DH", __func__);
+    status =
+        NFC_DiscoveryMap(NFC_NUM_INTERFACE_MAP,
+                         (tNCI_DISCOVER_MAPS*)nfc_interface_mapping_default,
+                         MposManager::discoveryMapCb);
+    if (status != NFA_STATUS_OK) {
+      LOG(ERROR) << StringPrintf("%s: fail intf mapping for ESE; error=0x%X",
+                                 __func__, status);
+      return status;
+    }
+    status =
+        mDiscMapEvent.wait(NFC_CMD_TIMEOUT) ? NFA_STATUS_OK : NFA_STATUS_FAILED;
+  }
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function:        notifyEEReaderEvent
+**
+** Description:     Notify with the Reader event
+**
+** Returns:         None
+**
+*******************************************************************************/
+void MposManager::notifyEEReaderEvent(etsi_rd_event_t evt) {
+  SecureElement& se = SecureElement::getInstance();
+  struct timespec mLastRfFieldToggle = se.getLastRfFiledToggleTime();
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter; event=%x", __func__, evt);
+
+  swp_rdr_req_ntf_info.mMutex.lock();
+  int ret = clock_gettime(CLOCK_MONOTONIC, &mLastRfFieldToggle);
+  if (ret == -1) {
+    LOG(ERROR) << StringPrintf("%s: clock_gettime failed", __func__);
+    // There is no good choice here...
+  }
+  switch (evt) {
+    case ETSI_READER_START_SUCCESS:
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: ETSI_READER_START_SUCCESS", __func__);
+      {
+        mSwpReaderTimer.kill();
+        /*
+         * This is to give user a specific time window to wait for card to be
+         *found and
+         * Notify to user if no card found within the give interval of timeout.
+         *
+         *  configuring timeout.
+         * */
+        if (mRdrTagOpTimeout > 0)
+          mSwpReaderTimer.set(ONE_SECOND_MS * mRdrTagOpTimeout,
+                              MposManager::startStopSwpReaderProc);
+      }
+      break;
+    case ETSI_READER_ACTIVATED:
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: ETSI_READER_ACTIVATED", __func__);
+      break;
+    case ETSI_READER_STOP:
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: ETSI_READER_STOP", __func__);
+      pTransactionController->transactionEnd(TRANSACTION_REQUESTOR(etsiReader));
+
+      if (se.mIsWiredModeOpen) se.NfccStandByOperation(STANDBY_TIMER_START);
+      break;
+    default:
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: UNKNOWN EVENT ??", __func__);
+      break;
+  }
+
+  swp_rdr_req_ntf_info.mMutex.unlock();
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+}
+
+/*******************************************************************************
+**
+** Function:        notifyMPOSReaderEvent
+**
+** Description:     Notify the Reader current status event to NFC service
+**
+** Returns:         None
+**
+*******************************************************************************/
+void MposManager::notifyMPOSReaderEvent(mpos_rd_state_t aEvent) {
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter; event type is %s", __FUNCTION__,
+                      convertMposEventToString(aEvent));
+  JNIEnv* e = NULL;
+
+  ScopedAttach attach(mNativeData->vm, &e);
+  if (e == NULL) {
+    LOG(ERROR) << StringPrintf("%s: jni env is null", __FUNCTION__);
+    return;
+  }
+
+  switch (aEvent) {
+    case MPOS_READER_MODE_START:
+      e->CallVoidMethod(mNativeData->manager,
+                        gCachedMposManagerNotifyETSIReaderModeStartConfig,
+                        (uint16_t)swp_rdr_req_ntf_info.swp_rd_req_info.src);
+      break;
+    case MPOS_READER_MODE_STOP:
+      mSwpReaderTimer.kill();
+      e->CallVoidMethod(mNativeData->manager,
+                        gCachedMposManagerNotifyETSIReaderModeStopConfig,
+                        mDiscNtfTimeout);
+      break;
+    case MPOS_READER_MODE_TIMEOUT:
+      e->CallVoidMethod(mNativeData->manager,
+                        gCachedMposManagerNotifyETSIReaderModeSwpTimeout,
+                        mDiscNtfTimeout);
+      break;
+    case MPOS_READER_MODE_RESTART:
+      e->CallVoidMethod(mNativeData->manager,
+                        gCachedMposManagerNotifyETSIReaderRestart);
+      break;
+    default:
+
+      break;
+  }
+}
+
+void MposManager::hanldeEtsiReaderReqEvent(tNFA_EE_DISCOVER_REQ* aInfo) {
+  /* Handle Reader over SWP.
+   * 1. Check if the event is for Reader over SWP.
+   * 2. IF yes than send this info(READER_REQUESTED_EVENT) till FWK level.
+   * 3. Stop the discovery.
+   * 4. MAP the proprietary interface for Reader over SWP.NFC_DiscoveryMap,
+   *nfc_api.h
+   * 5. start the discovery with reader req, type and DH configuration.
+   *
+   * 6. IF yes than send this info(STOP_READER_EVENT) till FWK level.
+   * 7. MAP the DH interface for Reader over SWP. NFC_DiscoveryMap, nfc_api.h
+   * 8. start the discovery with DH configuration.
+   */
+  swp_rdr_req_ntf_info.mMutex.lock();
+  for (unsigned char xx = 0; xx < aInfo->num_ee; xx++) {
+    // for each technology (A, B, F, B'), print the bit field that shows
+    // what protocol(s) is support by that technology
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "EE[%u] Handle: 0x%04x  PA: 0x%02x  PB: 0x%02x", xx,
+        aInfo->ee_disc_info[xx].ee_handle, aInfo->ee_disc_info[xx].pa_protocol,
+        aInfo->ee_disc_info[xx].pb_protocol);
+
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "swp_rd_state is %s",
+        convertRdrStateToString(swp_rdr_req_ntf_info.swp_rd_state));
+    if ((aInfo->ee_disc_info[xx].ee_req_op == NFC_EE_DISC_OP_ADD) &&
+        (swp_rdr_req_ntf_info.swp_rd_state == STATE_SE_RDR_MODE_STOPPED ||
+         swp_rdr_req_ntf_info.swp_rd_state == STATE_SE_RDR_MODE_START_CONFIG ||
+         swp_rdr_req_ntf_info.swp_rd_state == STATE_SE_RDR_MODE_STOP_CONFIG) &&
+        (aInfo->ee_disc_info[xx].pa_protocol == NCI_PROTOCOL_ISO_DEP ||
+         aInfo->ee_disc_info[xx].pb_protocol == NCI_PROTOCOL_ISO_DEP)) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "NFA_RD_SWP_READER_REQUESTED  EE[%u] Handle: 0x%04x  PA: 0x%02x  PB: "
+          "0x%02x",
+          xx, aInfo->ee_disc_info[xx].ee_handle,
+          aInfo->ee_disc_info[xx].pa_protocol,
+          aInfo->ee_disc_info[xx].pb_protocol);
+
+      swp_rdr_req_ntf_info.swp_rd_req_info.src =
+          aInfo->ee_disc_info[xx].ee_handle;
+      swp_rdr_req_ntf_info.swp_rd_req_info.tech_mask = 0;
+      swp_rdr_req_ntf_info.swp_rd_req_info.reCfg = false;
+
+      if (!(swp_rdr_req_ntf_info.swp_rd_req_info.tech_mask &
+            NFA_TECHNOLOGY_MASK_A)) {
+        if (aInfo->ee_disc_info[xx].pa_protocol == NCI_PROTOCOL_ISO_DEP) {
+          swp_rdr_req_ntf_info.swp_rd_req_info.tech_mask |=
+              NFA_TECHNOLOGY_MASK_A;
+          swp_rdr_req_ntf_info.swp_rd_req_info.reCfg = true;
+        }
+      }
+
+      if (!(swp_rdr_req_ntf_info.swp_rd_req_info.tech_mask &
+            NFA_TECHNOLOGY_MASK_B)) {
+        if (aInfo->ee_disc_info[xx].pb_protocol == NCI_PROTOCOL_ISO_DEP) {
+          swp_rdr_req_ntf_info.swp_rd_req_info.tech_mask |=
+              NFA_TECHNOLOGY_MASK_B;
+          swp_rdr_req_ntf_info.swp_rd_req_info.reCfg = true;
+        }
+      }
+
+      if (swp_rdr_req_ntf_info.swp_rd_req_info.reCfg) {
+        mSwpRdrReqTimer.kill();
+        if (swp_rdr_req_ntf_info.swp_rd_state !=
+            STATE_SE_RDR_MODE_STOP_CONFIG) {
+          if (swp_rdr_req_ntf_info.swp_rd_req_info.tech_mask !=
+              (NFA_TECHNOLOGY_MASK_A | NFA_TECHNOLOGY_MASK_B)) {
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+                "swp_rd_state is %s  evt: NFA_RD_SWP_READER_REQUESTED "
+                "mSwpRdrReqTimer start",
+                convertRdrStateToString(swp_rdr_req_ntf_info.swp_rd_state));
+            mSwpRdrReqTimer.set(rdr_req_handling_timeout, readerReqEventNtf);
+            swp_rdr_req_ntf_info.swp_rd_state = STATE_SE_RDR_MODE_START_CONFIG;
+          }
+        }
+        /*RestartReadermode procedure special case should not de-activate*/
+        else if (swp_rdr_req_ntf_info.swp_rd_state ==
+                 STATE_SE_RDR_MODE_STOP_CONFIG) {
+          swp_rdr_req_ntf_info.swp_rd_state = STATE_SE_RDR_MODE_STARTED;
+          /*RFDEACTIVATE_DISCOVERY*/
+          NFA_Deactivate(false);
+        }
+        swp_rdr_req_ntf_info.swp_rd_req_info.reCfg = false;
+      }
+      break;
+    } else if ((aInfo->ee_disc_info[xx].ee_req_op == NFC_EE_DISC_OP_REMOVE) &&
+               ((swp_rdr_req_ntf_info.swp_rd_state ==
+                 STATE_SE_RDR_MODE_STARTED) ||
+                (swp_rdr_req_ntf_info.swp_rd_state ==
+                 STATE_SE_RDR_MODE_START_CONFIG) ||
+                (swp_rdr_req_ntf_info.swp_rd_state ==
+                 STATE_SE_RDR_MODE_STOP_CONFIG) ||
+                (swp_rdr_req_ntf_info.swp_rd_state ==
+                 STATE_SE_RDR_MODE_ACTIVATED)) &&
+               (aInfo->ee_disc_info[xx].pa_protocol == 0xFF ||
+                aInfo->ee_disc_info[xx].pb_protocol == 0xFF)) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "NFA_RD_SWP_READER_STOP  EE[%u] Handle: 0x%04x  PA: 0x%02x  PB: "
+          "0x%02x",
+          xx, aInfo->ee_disc_info[xx].ee_handle,
+          aInfo->ee_disc_info[xx].pa_protocol,
+          aInfo->ee_disc_info[xx].pb_protocol);
+
+      if (swp_rdr_req_ntf_info.swp_rd_req_info.src ==
+          aInfo->ee_disc_info[xx].ee_handle) {
+        if (aInfo->ee_disc_info[xx].pa_protocol == 0xFF) {
+          if (swp_rdr_req_ntf_info.swp_rd_req_info.tech_mask &
+              NFA_TECHNOLOGY_MASK_A) {
+            swp_rdr_req_ntf_info.swp_rd_req_info.tech_mask &=
+                ~NFA_TECHNOLOGY_MASK_A;
+            swp_rdr_req_ntf_info.swp_rd_req_info.reCfg = true;
+          }
+        }
+
+        if (aInfo->ee_disc_info[xx].pb_protocol == 0xFF) {
+          if (swp_rdr_req_ntf_info.swp_rd_req_info.tech_mask &
+              NFA_TECHNOLOGY_MASK_B) {
+            swp_rdr_req_ntf_info.swp_rd_req_info.tech_mask &=
+                ~NFA_TECHNOLOGY_MASK_B;
+            swp_rdr_req_ntf_info.swp_rd_req_info.reCfg = true;
+          }
+        }
+
+        if (swp_rdr_req_ntf_info.swp_rd_req_info.reCfg) {
+          swp_rdr_req_ntf_info.swp_rd_state = STATE_SE_RDR_MODE_STOP_CONFIG;
+          mSwpRdrReqTimer.kill();
+          if (swp_rdr_req_ntf_info.swp_rd_req_info.tech_mask) {
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+                "swp_rd_state is %s  evt: NFA_RD_SWP_READER_STOP "
+                "mSwpRdrReqTimer start",
+                convertRdrStateToString(swp_rdr_req_ntf_info.swp_rd_state));
+            mSwpRdrReqTimer.set(rdr_req_handling_timeout, readerReqEventNtf);
+          }
+          swp_rdr_req_ntf_info.swp_rd_req_info.reCfg = false;
+        }
+      }
+      break;
+    }
+  }
+  swp_rdr_req_ntf_info.mMutex.unlock();
+  if ((swp_rdr_req_ntf_info.swp_rd_req_info.tech_mask == 0) ||
+      (swp_rdr_req_ntf_info.swp_rd_req_info.tech_mask ==
+       (NFA_TECHNOLOGY_MASK_A | NFA_TECHNOLOGY_MASK_B))) {
+    if (swp_rdr_req_ntf_info.swp_rd_state == STATE_SE_RDR_MODE_STOP_CONFIG) {
+      notifyMPOSReaderEvent(MPOS_READER_MODE_STOP);
+    } else if (swp_rdr_req_ntf_info.swp_rd_state ==
+               STATE_SE_RDR_MODE_START_CONFIG) {
+      notifyMPOSReaderEvent(MPOS_READER_MODE_START);
+    }
+  }
+}
+
+void MposManager::discoveryMapCb(tNFC_DISCOVER_EVT event,
+                                 tNFC_DISCOVER* p_data) {
+  (void)event;
+  (void)p_data;
+  SyncEventGuard guard(mMposMgr.mDiscMapEvent);
+  mMposMgr.mDiscMapEvent.notifyOne();
+}
+
+/*******************************************************************************
+**
+** Function:        getSwpRrdReqInfo
+**
+** Description:     get swp_rdr_req_ntf_info
+**
+** Returns:         swp_rdr_req_ntf_info
+**
+*******************************************************************************/
+Rdr_req_ntf_info_t MposManager::getSwpRrdReqInfo() {
+  LOG(ERROR) << StringPrintf("%s Enter", __func__);
+  if (!nfcFL.nfcNxpEse || !nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s : nfcNxpEse or ETSI_READER not avaialble.Returning", __func__);
+  }
+  return swp_rdr_req_ntf_info;
+}
+
+/*******************************************************************************
+**
+** Function:        readerReqEventNtf
+**
+** Description:     This is used to send the reader start or stop request
+**                  event to service
+**
+** Returns:         None
+**
+*******************************************************************************/
+void MposManager::readerReqEventNtf(union sigval) {
+  if (!nfcFL.nfcNxpEse || !nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: nfcNxpEse or ETSI_READER not available. Returning", __func__);
+    return;
+  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s:  ", __func__);
+  JNIEnv* e = NULL;
+
+  ScopedAttach attach(mMposMgr.mNativeData->vm, &e);
+  if (e == NULL) {
+    LOG(ERROR) << StringPrintf("%s: jni env is null", __func__);
+    return;
+  }
+
+  Rdr_req_ntf_info_t mSwp_info = mMposMgr.getSwpRrdReqInfo();
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: swp_rdr_req_ntf_info.swp_rd_req_info.src = 0x%4x ",
+                      __func__, mSwp_info.swp_rd_req_info.src);
+
+  if (mMposMgr.getEtsiReaederState() == STATE_SE_RDR_MODE_START_CONFIG) {
+    e->CallVoidMethod(
+        mMposMgr.mNativeData->manager,
+        mMposMgr.gCachedMposManagerNotifyETSIReaderModeStartConfig,
+        (uint16_t)mSwp_info.swp_rd_req_info.src);
+  } else if (mMposMgr.getEtsiReaederState() == STATE_SE_RDR_MODE_STOP_CONFIG) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: mSwpReaderTimer.kill() ", __func__);
+    mMposMgr.mSwpReaderTimer.kill();
+    e->CallVoidMethod(mMposMgr.mNativeData->manager,
+                      mMposMgr.gCachedMposManagerNotifyETSIReaderModeStopConfig,
+                      mDiscNtfTimeout);
+  }
+}
+
+/*******************************************************************************
+**
+** Function:        startStopSwpReaderProc
+**
+** Description:     Notify the reader timeout
+**
+** Returns:         None
+**
+*******************************************************************************/
+void MposManager::startStopSwpReaderProc(union sigval) {
+  if (!nfcFL.nfcNxpEse || !nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: nfcNxpEse or ETSI_READER not enabled. Returning", __func__);
+    return;
+  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Timeout!!!", __func__);
+
+  mMposMgr.notifyMPOSReaderEvent(MPOS_READER_MODE_TIMEOUT);
+}
+
+/*******************************************************************************
+**
+** Function:        etsiReaderReStart
+**
+** Description:     Notify's the mPOS restart event
+**
+** Returns:         void.
+**
+*******************************************************************************/
+void MposManager::etsiReaderReStart() {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(" %s: Enter", __FUNCTION__);
+  pTransactionController->transactionEnd(TRANSACTION_REQUESTOR(etsiReader));
+  notifyMPOSReaderEvent(MPOS_READER_MODE_RESTART);
+}
+
+/*******************************************************************************
+**
+** Function:        validateHCITransactionEventParams
+**
+** Description:     Decodes the HCI_TRANSACTION_EVT to check for
+**                  reader restart and POWER_OFF evt
+**
+** Returns:         OK/FAILED.
+**
+*******************************************************************************/
+tNFA_STATUS MposManager::validateHCITransactionEventParams(uint8_t* aData,
+                                                           int32_t aDatalen) {
+  tNFA_STATUS status = NFA_STATUS_OK;
+  uint8_t Event, Version, Code;
+  if (aData != NULL && aDatalen >= 3) {
+    Event = *aData++;
+    Version = *aData++;
+    Code = *aData;
+    if (Event == EVENT_RF_ERROR && Version == EVENT_RF_VERSION) {
+      if (Code == EVENT_RDR_MODE_RESTART) {
+        status = NFA_STATUS_FAILED;
+        etsiReaderReStart();
+      } else {
+      }
+    }
+  } else if (aData != NULL && aDatalen == 0x01 &&
+             *aData == EVENT_EMV_POWER_OFF) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("Power off procedure to be triggered");
+
+    if (NfcConfig::hasKey(NAME_NFA_CONFIG_FORMAT)) {
+      unsigned long num = NfcConfig::getUnsigned(NAME_NFA_CONFIG_FORMAT);
+      if (num == 0x05) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("Power off procedure is triggered");
+        NFA_Deactivate(false);
+      } else {
+        // DO nothing
+      }
+    } else {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("NAME_NFA_CONFIG_FORMAT not found");
+    }
+  } else {
+  }
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function:        convertMposEventToString
+**
+** Description:     Converts the MPOS status events to String format
+**
+** Returns:         Name of the event
+**
+*******************************************************************************/
+const char* MposManager::convertMposEventToString(mpos_rd_state_t aEvent) {
+  switch (aEvent) {
+    case MPOS_READER_MODE_INVALID:
+      return "MPOS_READER_MODE_INVALID";
+    case MPOS_READER_MODE_START:
+      return "MPOS_READER_MODE_START";
+    case MPOS_READER_MODE_START_SUCCESS:
+      return "MPOS_READER_MODE_START_SUCCESS";
+    case MPOS_READER_MODE_RESTART:
+      return "MPOS_READER_MODE_RESTART";
+    case MPOS_READER_MODE_STOP:
+      return "MPOS_READER_MODE_STOP";
+    case MPOS_READER_MODE_STOP_SUCCESS:
+      return "MPOS_READER_MODE_STOP_SUCCESS";
+    case MPOS_READER_MODE_TIMEOUT:
+      return "MPOS_READER_MODE_TIMEOUT";
+    case MPOS_READER_MODE_REMOVE_CARD:
+      return "MPOS_READER_MODE_REMOVE_CARD";
+    case MPOS_READER_MODE_RECOVERY:
+      return "MPOS_READER_MODE_RECOVERY";
+    case MPOS_READER_MODE_FAIL:
+      return "MPOS_READER_MODE_FAIL";
+
+    default:
+      return "UNKNOWN";
+  }
+}
+
+/*******************************************************************************
+**
+** Function:        convertRdrStateToString
+**
+** Description:     Converts the MPOS state to String format
+**
+** Returns:         Name of the event
+**
+*******************************************************************************/
+const char* MposManager::convertRdrStateToString(se_rd_req_state_t aState) {
+  switch (aState) {
+    case STATE_SE_RDR_MODE_INVALID:
+      return "STATE_SE_RDR_MODE_INVALID";
+    case STATE_SE_RDR_MODE_START_CONFIG:
+      return "STATE_SE_RDR_MODE_START_CONFIG";
+    case STATE_SE_RDR_MODE_START_IN_PROGRESS:
+      return "STATE_SE_RDR_MODE_START_IN_PROGRESS";
+    case STATE_SE_RDR_MODE_STARTED:
+      return "STATE_SE_RDR_MODE_STARTED";
+    case STATE_SE_RDR_MODE_ACTIVATED:
+      return "STATE_SE_RDR_MODE_ACTIVATED";
+    case STATE_SE_RDR_MODE_STOP_CONFIG:
+      return "STATE_SE_RDR_MODE_STOP_CONFIG";
+    case STATE_SE_RDR_MODE_STOP_IN_PROGRESS:
+      return "STATE_SE_RDR_MODE_STOP_IN_PROGRESS";
+    case STATE_SE_RDR_MODE_STOPPED:
+      return "STATE_SE_RDR_MODE_STOPPED";
+
+    default:
+      return "UNKNOWN";
+  }
+}
diff --git a/nci/jni/MposManager.h b/nci/jni/MposManager.h
new file mode 100644
index 00000000..2de65332
--- /dev/null
+++ b/nci/jni/MposManager.h
@@ -0,0 +1,356 @@
+/******************************************************************************
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  Copyright 2018 NXP
+ *
+ ******************************************************************************/
+#pragma once
+#include "IntervalTimer.h"
+#include "Mutex.h"
+#include "NfcJniUtil.h"
+#include "SyncEvent.h"
+
+#include "nfa_api.h"
+#include "nfa_ee_api.h"
+#include "nfc_api.h"
+
+typedef struct {
+  tNFA_HANDLE src;
+  tNFA_TECHNOLOGY_MASK tech_mask;
+  bool reCfg;
+} rd_swp_req_t;
+
+typedef enum {
+  MPOS_READER_MODE_INVALID = 0x00,
+  MPOS_READER_MODE_START,
+  MPOS_READER_MODE_START_SUCCESS,
+  MPOS_READER_MODE_RESTART,
+  MPOS_READER_MODE_STOP,
+  MPOS_READER_MODE_STOP_SUCCESS,
+  MPOS_READER_MODE_TIMEOUT,
+  MPOS_READER_MODE_REMOVE_CARD,
+  MPOS_READER_MODE_RECOVERY,
+  MPOS_READER_MODE_RECOVERY_COMPLETE,
+  MPOS_READER_MODE_RECOVERY_TIMEOUT,
+  MPOS_READER_MODE_FAIL
+} mpos_rd_state_t;
+
+typedef enum {
+  STATE_SE_RDR_MODE_INVALID = 0x00,
+  STATE_SE_RDR_MODE_START_CONFIG,
+  STATE_SE_RDR_MODE_START_IN_PROGRESS,
+  STATE_SE_RDR_MODE_STARTED,
+  STATE_SE_RDR_MODE_ACTIVATED,
+  STATE_SE_RDR_MODE_STOP_CONFIG,
+  STATE_SE_RDR_MODE_STOP_IN_PROGRESS,
+  STATE_SE_RDR_MODE_STOPPED,
+} se_rd_req_state_t;
+
+typedef enum {
+  /* Reader over SWP Events*/
+  ETSI_READER_START_SUCCESS = 0x00,
+  ETSI_READER_START_FAIL,
+  ETSI_READER_ACTIVATED,
+  ETSI_READER_STOP,
+} etsi_rd_event_t;
+
+typedef struct {
+  rd_swp_req_t swp_rd_req_info;
+  rd_swp_req_t swp_rd_req_current_info;
+  se_rd_req_state_t swp_rd_state;
+  Mutex mMutex;
+} Rdr_req_ntf_info_t;
+
+#define NFC_NUM_INTERFACE_MAP 3
+#define NFC_SWP_RD_NUM_INTERFACE_MAP 1
+
+class MposManager {
+ public:
+  Rdr_req_ntf_info_t swp_rdr_req_ntf_info;
+  static jmethodID gCachedMposManagerNotifyETSIReaderRequested;
+  static jmethodID gCachedMposManagerNotifyETSIReaderRequestedFail;
+  static jmethodID gCachedMposManagerNotifyETSIReaderModeStartConfig;
+  static jmethodID gCachedMposManagerNotifyETSIReaderModeStopConfig;
+  static jmethodID gCachedMposManagerNotifyETSIReaderModeSwpTimeout;
+  static jmethodID gCachedMposManagerNotifyETSIReaderRestart;
+
+  /*******************************************************************************
+  **
+  ** Function:        initMposNativeStruct
+  **
+  ** Description:     Used to initialize the Native MPOS notification methods
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  static void initMposNativeStruct(JNIEnv* e, jobject o);
+
+  /*******************************************************************************
+  **
+  ** Function:        getInstance
+  **
+  ** Description:     Get the SecureElement singleton object.
+  **
+  ** Returns:         MposManager object.
+  **
+  *******************************************************************************/
+  static MposManager& getInstance();
+
+  /*******************************************************************************
+  **
+  ** Function:        initialize
+  **
+  ** Description:     Initialize all member variables.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool initialize(nfc_jni_native_data* native);
+
+  /*******************************************************************************
+  **
+  ** Function:        initializeReaderInfo
+  **
+  ** Description:     Initialize all MPOS member variables.
+  **
+  ** Returns:         none.
+  **
+  *******************************************************************************/
+  void initializeReaderInfo();
+
+  /*******************************************************************************
+  **
+  ** Function:        finalize
+  **
+  ** Description:     Release all resources.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void finalize();
+
+  /*******************************************************************************
+  **
+  ** Function:        setDedicatedReaderMode
+  **
+  ** Description:     Set/reset MPOS dedicated mode.
+  **
+  ** Returns:         SUCCESS/FAILED/BUSY
+  **
+  *******************************************************************************/
+  tNFA_STATUS setDedicatedReaderMode(bool on);
+
+  /*******************************************************************************
+  **
+  ** Function:        setEtsiReaederState
+  **
+  ** Description:     Set the current ETSI Reader state
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void setEtsiReaederState(se_rd_req_state_t newState);
+
+  /*******************************************************************************
+  **
+  ** Function:        getEtsiReaederState
+  **
+  ** Description:     Get the current ETSI Reader state
+  **
+  ** Returns:         Current ETSI state
+  **
+  *******************************************************************************/
+  se_rd_req_state_t getEtsiReaederState();
+
+  /*******************************************************************************
+  **
+  ** Function:        etsiInitConfig
+  **
+  ** Description:     Chnage the ETSI state before start configuration
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void etsiInitConfig();
+
+  /*******************************************************************************
+  **
+  ** Function:        etsiReaderConfig
+  **
+  ** Description:     Configuring to Emvco Profile
+  **
+  ** Returns:         Status - NFA_STATUS_FAILED
+  **                           NFA_STATUS_OK
+  **                           NFA_STATUS_INVALID_PARAM
+  **
+  *******************************************************************************/
+  tNFA_STATUS etsiReaderConfig(int32_t eeHandle);
+
+  /*******************************************************************************
+  **
+  ** Function:        etsiResetReaderConfig
+  **
+  ** Description:     Configuring from Emvco profile to Nfc forum profile
+  **
+  ** Returns:         Status - NFA_STATUS_FAILED
+  **                           NFA_STATUS_OK
+  **                           NFA_STATUS_INVALID_PARAM
+  **
+  *******************************************************************************/
+  tNFA_STATUS etsiResetReaderConfig();
+
+  /*******************************************************************************
+  **
+  ** Function:        notifyEEReaderEvent
+  **
+  ** Description:     Notify with the Reader event
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void notifyEEReaderEvent(etsi_rd_event_t evt);
+
+  /*******************************************************************************
+  **
+  ** Function:        notifyMPOSReaderEvent
+  **
+  ** Description:     Notify the Reader current status event to NFC service
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void notifyMPOSReaderEvent(mpos_rd_state_t aEvent);
+
+  /*******************************************************************************
+  **
+  ** Function:        hanldeEtsiReaderReqEvent
+  **
+  ** Description:     Handler for reader request add and remove notifications
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void hanldeEtsiReaderReqEvent(tNFA_EE_DISCOVER_REQ* aInfo);
+
+  /*******************************************************************************
+  **
+  ** Function:        getSwpRrdReqInfo
+  **
+  ** Description:     get swp_rdr_req_ntf_info
+  **
+  ** Returns:         swp_rdr_req_ntf_info
+  **
+  *******************************************************************************/
+  Rdr_req_ntf_info_t getSwpRrdReqInfo();
+
+  /*******************************************************************************
+  **
+  ** Function:        validateHCITransactionEventParams
+  **
+  ** Description:     Decodes the HCI_TRANSACTION_EVT to check for
+  **                  reader restart and POWER_OFF evt
+  **
+  ** Returns:         OK/FAILED.
+  **
+  *******************************************************************************/
+  tNFA_STATUS validateHCITransactionEventParams(uint8_t* aData,
+                                                int32_t aDatalen);
+
+  /*******************************************************************************
+  **
+  ** Function:        convertMposEventToString
+  **
+  ** Description:     Converts the MPOS status events to String format
+  **
+  ** Returns:         Name of the event
+  **
+  *******************************************************************************/
+  const char* convertMposEventToString(mpos_rd_state_t aEvent);
+
+  /*******************************************************************************
+  **
+  ** Function:        convertRdrStateToString
+  **
+  ** Description:     Converts the MPOS state to String format
+  **
+  ** Returns:         Name of the event
+  **
+  *******************************************************************************/
+  const char* convertRdrStateToString(se_rd_req_state_t aState);
+
+ private:
+  nfc_jni_native_data* mNativeData;
+  static MposManager mMposMgr;
+  static int32_t mDiscNtfTimeout;
+  static int32_t mRdrTagOpTimeout;
+  static const uint8_t EVENT_RF_ERROR =
+      0x80;  // HCI_TRANSACTION_EVENT parameter type
+  static const uint8_t EVENT_RF_VERSION =
+      0x00;  // HCI_TRANSACTION_EVENT parameter version
+  static const uint8_t EVENT_EMV_POWER_OFF =
+      0x72;  // HCI_TRANSACTION_EVENT parameter power off
+  static const uint8_t EVENT_RDR_MODE_RESTART =
+      0x04;  // EVENT to Restart Reader mode
+  static const unsigned short rdr_req_handling_timeout = 50;
+
+  IntervalTimer mSwpReaderTimer; /*timer swp reader timeout*/
+  IntervalTimer mSwpRdrReqTimer;
+
+  SyncEvent mDiscMapEvent;
+
+  /*******************************************************************************
+  **
+  ** Function:        discoveryMapCb
+  **
+  ** Description:     Callback for discovery map command
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  static void discoveryMapCb(tNFC_DISCOVER_EVT event, tNFC_DISCOVER* p_data);
+
+  /*******************************************************************************
+  **
+  ** Function:        readerReqEventNtf
+  **
+  ** Description:     This is used to send the reader start or stop request
+  **                  event to service
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  static void readerReqEventNtf(union sigval);
+
+  /*******************************************************************************
+  **
+  ** Function:        startStopSwpReaderProc
+  **
+  ** Description:     Notify the reader timeout
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  static void startStopSwpReaderProc(union sigval);
+
+  /*******************************************************************************
+  **
+  ** Function:        etsiReaderReStart
+  **
+  ** Description:     Notify's the mPOS restart event
+  **
+  ** Returns:         void.
+  **
+  *******************************************************************************/
+  void etsiReaderReStart();
+};
diff --git a/nci/jni/Mutex.cpp b/nci/jni/Mutex.cpp
index 495b26fa..842a4e81 100644
--- a/nci/jni/Mutex.cpp
+++ b/nci/jni/Mutex.cpp
@@ -21,9 +21,12 @@
 #include "Mutex.h"
 #include "NfcJniUtil.h"
 
-#include <log/log.h>
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
 #include <errno.h>
 
+using android::base::StringPrintf;
+
 /*******************************************************************************
 **
 ** Function:        Mutex
@@ -33,17 +36,14 @@
 ** Returns:         None.
 **
 *******************************************************************************/
-Mutex::Mutex ()
-{
-    memset (&mMutex, 0, sizeof(mMutex));
-    int res = pthread_mutex_init (&mMutex, NULL);
-    if (res != 0)
-    {
-        ALOGE("Mutex::Mutex: fail init; error=0x%X", res);
-    }
+Mutex::Mutex() {
+  memset(&mMutex, 0, sizeof(mMutex));
+  int res = pthread_mutex_init(&mMutex, NULL);
+  if (res != 0) {
+    LOG(ERROR) << StringPrintf("Mutex::Mutex: fail init; error=0x%X", res);
+  }
 }
 
-
 /*******************************************************************************
 **
 ** Function:        ~Mutex
@@ -53,16 +53,13 @@ Mutex::Mutex ()
 ** Returns:         None.
 **
 *******************************************************************************/
-Mutex::~Mutex ()
-{
-    int res = pthread_mutex_destroy (&mMutex);
-    if (res != 0)
-    {
-        ALOGE("Mutex::~Mutex: fail destroy; error=0x%X", res);
-    }
+Mutex::~Mutex() {
+  int res = pthread_mutex_destroy(&mMutex);
+  if (res != 0) {
+    LOG(ERROR) << StringPrintf("Mutex::~Mutex: fail destroy; error=0x%X", res);
+  }
 }
 
-
 /*******************************************************************************
 **
 ** Function:        lock
@@ -72,16 +69,13 @@ Mutex::~Mutex ()
 ** Returns:         None.
 **
 *******************************************************************************/
-void Mutex::lock ()
-{
-    int res = pthread_mutex_lock (&mMutex);
-    if (res != 0)
-    {
-        ALOGE("Mutex::lock: fail lock; error=0x%X", res);
-    }
+void Mutex::lock() {
+  int res = pthread_mutex_lock(&mMutex);
+  if (res != 0) {
+    LOG(ERROR) << StringPrintf("Mutex::lock: fail lock; error=0x%X", res);
+  }
 }
 
-
 /*******************************************************************************
 **
 ** Function:        unlock
@@ -91,16 +85,13 @@ void Mutex::lock ()
 ** Returns:         None.
 **
 *******************************************************************************/
-void Mutex::unlock ()
-{
-    int res = pthread_mutex_unlock (&mMutex);
-    if (res != 0)
-    {
-        ALOGE("Mutex::unlock: fail unlock; error=0x%X", res);
-    }
+void Mutex::unlock() {
+  int res = pthread_mutex_unlock(&mMutex);
+  if (res != 0) {
+    LOG(ERROR) << StringPrintf("Mutex::unlock: fail unlock; error=0x%X", res);
+  }
 }
 
-
 /*******************************************************************************
 **
 ** Function:        tryLock
@@ -110,17 +101,14 @@ void Mutex::unlock ()
 ** Returns:         True if the mutex is locked.
 **
 *******************************************************************************/
-bool Mutex::tryLock ()
-{
-    int res = pthread_mutex_trylock (&mMutex);
-    if ((res != 0) && (res != EBUSY))
-    {
-        ALOGE("Mutex::tryLock: error=0x%X", res);
-    }
-    return res == 0;
+bool Mutex::tryLock() {
+  int res = pthread_mutex_trylock(&mMutex);
+  if ((res != 0) && (res != EBUSY)) {
+    LOG(ERROR) << StringPrintf("Mutex::tryLock: error=0x%X", res);
+  }
+  return res == 0;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeHandle
@@ -130,7 +118,4 @@ bool Mutex::tryLock ()
 ** Returns:         Handle of the mutex.
 **
 *******************************************************************************/
-pthread_mutex_t* Mutex::nativeHandle ()
-{
-    return &mMutex;
-}
+pthread_mutex_t* Mutex::nativeHandle() { return &mMutex; }
diff --git a/nci/jni/Mutex.h b/nci/jni/Mutex.h
index 4efff8b6..2c622a94 100644
--- a/nci/jni/Mutex.h
+++ b/nci/jni/Mutex.h
@@ -22,92 +22,86 @@
 #include <pthread.h>
 #include <cstring>
 
-class Mutex
-{
-public:
-    /*******************************************************************************
-    **
-    ** Function:        Mutex
-    **
-    ** Description:     Initialize member variables.
-    **
-    ** Returns:         None.
-    **
-    *******************************************************************************/
-    Mutex ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        ~Mutex
-    **
-    ** Description:     Cleanup all resources.
-    **
-    ** Returns:         None.
-    **
-    *******************************************************************************/
-    ~Mutex ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        lock
-    **
-    ** Description:     Block the thread and try lock the mutex.
-    **
-    ** Returns:         None.
-    **
-    *******************************************************************************/
-    void lock ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        unlock
-    **
-    ** Description:     Unlock a mutex to unblock a thread.
-    **
-    ** Returns:         None.
-    **
-    *******************************************************************************/
-    void unlock ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        tryLock
-    **
-    ** Description:     Try to lock the mutex.
-    **
-    ** Returns:         True if the mutex is locked.
-    **
-    *******************************************************************************/
-    bool tryLock ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        nativeHandle
-    **
-    ** Description:     Get the handle of the mutex.
-    **
-    ** Returns:         Handle of the mutex.
-    **
-    *******************************************************************************/
-    pthread_mutex_t* nativeHandle ();
-
-    class Autolock {
-        public:
-            inline Autolock(Mutex& mutex) : mLock(mutex)  { mLock.lock(); }
-            inline Autolock(Mutex* mutex) : mLock(*mutex) { mLock.lock(); }
-            inline ~Autolock() { mLock.unlock(); }
-        private:
-            Mutex& mLock;
-    };
-
-
-private:
-    pthread_mutex_t mMutex;
+class Mutex {
+ public:
+  /*******************************************************************************
+  **
+  ** Function:        Mutex
+  **
+  ** Description:     Initialize member variables.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  Mutex();
+
+  /*******************************************************************************
+  **
+  ** Function:        ~Mutex
+  **
+  ** Description:     Cleanup all resources.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  ~Mutex();
+
+  /*******************************************************************************
+  **
+  ** Function:        lock
+  **
+  ** Description:     Block the thread and try lock the mutex.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  void lock();
+
+  /*******************************************************************************
+  **
+  ** Function:        unlock
+  **
+  ** Description:     Unlock a mutex to unblock a thread.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  void unlock();
+
+  /*******************************************************************************
+  **
+  ** Function:        tryLock
+  **
+  ** Description:     Try to lock the mutex.
+  **
+  ** Returns:         True if the mutex is locked.
+  **
+  *******************************************************************************/
+  bool tryLock();
+
+  /*******************************************************************************
+  **
+  ** Function:        nativeHandle
+  **
+  ** Description:     Get the handle of the mutex.
+  **
+  ** Returns:         Handle of the mutex.
+  **
+  *******************************************************************************/
+  pthread_mutex_t* nativeHandle();
+
+  class Autolock {
+   public:
+    inline Autolock(Mutex& mutex) : mLock(mutex) { mLock.lock(); }
+    inline Autolock(Mutex* mutex) : mLock(*mutex) { mLock.lock(); }
+    inline ~Autolock() { mLock.unlock(); }
+
+   private:
+    Mutex& mLock;
+  };
+
+ private:
+  pthread_mutex_t mMutex;
 };
 
 typedef Mutex::Autolock AutoMutex;
diff --git a/nci/jni/NativeLlcpConnectionlessSocket.cpp b/nci/jni/NativeLlcpConnectionlessSocket.cpp
index 16a2abdf..0d588e4f 100644
--- a/nci/jni/NativeLlcpConnectionlessSocket.cpp
+++ b/nci/jni/NativeLlcpConnectionlessSocket.cpp
@@ -16,38 +16,35 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+#include <errno.h>
 #include <malloc.h>
+#include <nativehelper/ScopedLocalRef.h>
+#include <nativehelper/ScopedPrimitiveArray.h>
 #include <semaphore.h>
 #include <string.h>
-#include <errno.h>
-#include "_OverrideLog.h"
-#include "NfcJniUtil.h"
 #include "JavaClassConstants.h"
-#include <nativehelper/ScopedLocalRef.h>
-#include <nativehelper/ScopedPrimitiveArray.h>
-extern "C"
-{
-    #include "nfa_api.h"
-    #include "nfa_p2p_api.h"
-}
+#include "NfcJniUtil.h"
+#include "nfa_api.h"
+#include "nfa_p2p_api.h"
 
+using android::base::StringPrintf;
 
-namespace android
-{
+extern bool nfc_debug_enabled;
 
+namespace android {
 
 /*****************************************************************************
 **
 ** private variables and functions
 **
 *****************************************************************************/
-static sem_t        sConnlessRecvSem;
-static jboolean     sConnlessRecvWaitingForData = JNI_FALSE;
-static uint8_t*     sConnlessRecvBuf = NULL;
-static uint32_t     sConnlessRecvLen = 0;
-static uint32_t     sConnlessRecvRemoteSap = 0;
-
+static sem_t sConnlessRecvSem;
+static jboolean sConnlessRecvWaitingForData = JNI_FALSE;
+static uint8_t* sConnlessRecvBuf = NULL;
+static uint32_t sConnlessRecvLen = 0;
+static uint32_t sConnlessRecvRemoteSap = 0;
 
 /*******************************************************************************
 **
@@ -62,35 +59,39 @@ static uint32_t     sConnlessRecvRemoteSap = 0;
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-static jboolean nativeLlcpConnectionlessSocket_doSendTo (JNIEnv *e, jobject o, jint nsap, jbyteArray data)
-{
-    ALOGV("%s: nsap = %d", __func__, nsap);
-
-    ScopedLocalRef<jclass> c(e, e->GetObjectClass(o));
-    jfieldID f = e->GetFieldID(c.get(), "mHandle", "I");
-    jint handle = e->GetIntField(o, f);
-
-    ScopedByteArrayRO bytes(e, data);
-    if (bytes.get() == NULL)
-    {
-        return JNI_FALSE;
-    }
-    size_t byte_count = bytes.size();
-
-    ALOGV("NFA_P2pSendUI: len = %zu", byte_count);
-    uint8_t* raw_ptr = const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0])); // TODO: API bug; NFA_P2pSendUI should take const*!
-    tNFA_STATUS status = NFA_P2pSendUI((tNFA_HANDLE) handle, nsap, byte_count, raw_ptr);
-
-    ALOGV("%s: NFA_P2pSendUI done, status = %d", __func__, status);
-    if (status != NFA_STATUS_OK)
-    {
-        ALOGE("%s: NFA_P2pSendUI failed, status = %d", __func__, status);
-        return JNI_FALSE;
-    }
-    return JNI_TRUE;
+static jboolean nativeLlcpConnectionlessSocket_doSendTo(JNIEnv* e, jobject o,
+                                                        jint nsap,
+                                                        jbyteArray data) {
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: nsap = %d", __func__, nsap);
+
+  ScopedLocalRef<jclass> c(e, e->GetObjectClass(o));
+  jfieldID f = e->GetFieldID(c.get(), "mHandle", "I");
+  jint handle = e->GetIntField(o, f);
+
+  ScopedByteArrayRO bytes(e, data);
+  if (bytes.get() == NULL) {
+    return JNI_FALSE;
+  }
+  size_t byte_count = bytes.size();
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("NFA_P2pSendUI: len = %zu", byte_count);
+  uint8_t* raw_ptr = const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(
+      &bytes[0]));  // TODO: API bug; NFA_P2pSendUI should take const*!
+  tNFA_STATUS status =
+      NFA_P2pSendUI((tNFA_HANDLE)handle, nsap, byte_count, raw_ptr);
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: NFA_P2pSendUI done, status = %d", __func__, status);
+  if (status != NFA_STATUS_OK) {
+    LOG(ERROR) << StringPrintf("%s: NFA_P2pSendUI failed, status = %d",
+                               __func__, status);
+    return JNI_FALSE;
+  }
+  return JNI_TRUE;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeLlcpConnectionlessSocket_receiveData
@@ -103,27 +104,26 @@ static jboolean nativeLlcpConnectionlessSocket_doSendTo (JNIEnv *e, jobject o, j
 ** Returns:         None
 **
 *******************************************************************************/
-void nativeLlcpConnectionlessSocket_receiveData (uint8_t* data, uint32_t len, uint32_t remoteSap)
-{
-    ALOGV("%s: waiting for data = %d, len = %d", __func__, sConnlessRecvWaitingForData, len);
-
-    // Sanity...
-    if (sConnlessRecvLen < len)
-    {
-        len = sConnlessRecvLen;
-    }
-
-    if (sConnlessRecvWaitingForData)
-    {
-        sConnlessRecvWaitingForData = JNI_FALSE;
-        sConnlessRecvLen = len;
-        memcpy (sConnlessRecvBuf, data, len);
-        sConnlessRecvRemoteSap = remoteSap;
-
-        sem_post (&sConnlessRecvSem);
-    }
-}
+void nativeLlcpConnectionlessSocket_receiveData(uint8_t* data, uint32_t len,
+                                                uint32_t remoteSap) {
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: waiting for data = %d, len = %d", __func__,
+                      sConnlessRecvWaitingForData, len);
+
+  // Sanity...
+  if (sConnlessRecvLen < len) {
+    len = sConnlessRecvLen;
+  }
+
+  if (sConnlessRecvWaitingForData) {
+    sConnlessRecvWaitingForData = JNI_FALSE;
+    sConnlessRecvLen = len;
+    memcpy(sConnlessRecvBuf, data, len);
+    sConnlessRecvRemoteSap = remoteSap;
 
+    sem_post(&sConnlessRecvSem);
+  }
+}
 
 /*******************************************************************************
 **
@@ -134,19 +134,16 @@ void nativeLlcpConnectionlessSocket_receiveData (uint8_t* data, uint32_t len, ui
 ** Returns:         None
 **
 *******************************************************************************/
-static jobject connectionlessCleanup ()
-{
-    sConnlessRecvWaitingForData = JNI_FALSE;
-    sConnlessRecvLen = 0;
-    if (sConnlessRecvBuf != NULL)
-    {
-        free (sConnlessRecvBuf);
-        sConnlessRecvBuf = NULL;
-    }
-    return NULL;
+static jobject connectionlessCleanup() {
+  sConnlessRecvWaitingForData = JNI_FALSE;
+  sConnlessRecvLen = 0;
+  if (sConnlessRecvBuf != NULL) {
+    free(sConnlessRecvBuf);
+    sConnlessRecvBuf = NULL;
+  }
+  return NULL;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeLlcpConnectionlessSocket_abortWait
@@ -156,11 +153,7 @@ static jobject connectionlessCleanup ()
 ** Returns:         None
 **
 *******************************************************************************/
-void nativeLlcpConnectionlessSocket_abortWait ()
-{
-    sem_post (&sConnlessRecvSem);
-}
-
+void nativeLlcpConnectionlessSocket_abortWait() { sem_post(&sConnlessRecvSem); }
 
 /*******************************************************************************
 **
@@ -174,82 +167,88 @@ void nativeLlcpConnectionlessSocket_abortWait ()
 ** Returns:         LlcpPacket Java object.
 **
 *******************************************************************************/
-static jobject nativeLlcpConnectionlessSocket_doReceiveFrom (JNIEnv* e, jobject, jint linkMiu)
-{
-    ALOGV("%s: linkMiu = %d", __func__, linkMiu);
-    jobject llcpPacket = NULL;
-    ScopedLocalRef<jclass> clsLlcpPacket(e, NULL);
-
-    if (sConnlessRecvWaitingForData != JNI_FALSE)
-    {
-        ALOGV("%s: Already waiting for incoming data", __func__);
-        return NULL;
-    }
-
-    sConnlessRecvBuf = (uint8_t*) malloc (linkMiu);
-    if (sConnlessRecvBuf == NULL)
-    {
-        ALOGV("%s: Failed to allocate %d bytes memory buffer", __func__, linkMiu);
-        return NULL;
-    }
-    sConnlessRecvLen = linkMiu;
-
-    // Create the write semaphore
-    if (sem_init (&sConnlessRecvSem, 0, 0) == -1)
-    {
-        ALOGE("%s: semaphore creation failed (errno=0x%08x)", __func__, errno);
-        return connectionlessCleanup ();
-    }
-
-    sConnlessRecvWaitingForData = JNI_TRUE;
-
-    // Wait for sConnlessRecvSem completion status
-    if (sem_wait (&sConnlessRecvSem))
-    {
-        ALOGE("%s: Failed to wait for write semaphore (errno=0x%08x)", __func__, errno);
-        goto TheEnd;
-    }
-
-    // Create new LlcpPacket object
-    if (nfc_jni_cache_object_local (e, "com/android/nfc/LlcpPacket", &(llcpPacket)) == -1)
-    {
-        ALOGE("%s: Find LlcpPacket class error", __func__);
-        return connectionlessCleanup ();
-    }
-
-    // Get NativeConnectionless class object
-    clsLlcpPacket.reset(e->GetObjectClass(llcpPacket));
-    if (e->ExceptionCheck())
-    {
-        e->ExceptionClear();
-        ALOGE("%s: Get Object class error", __func__);
-        return connectionlessCleanup ();
-    }
-
-    // Set Llcp Packet remote SAP
-    jfieldID f;
-    f = e->GetFieldID(clsLlcpPacket.get(), "mRemoteSap", "I");
-    e->SetIntField(llcpPacket, f, (jbyte) sConnlessRecvRemoteSap);
-
-    // Set Llcp Packet Buffer
-    ALOGV("%s: Received Llcp packet buffer size = %d\n", __func__, sConnlessRecvLen);
-    f = e->GetFieldID(clsLlcpPacket.get(), "mDataBuffer", "[B");
-
-    {
-        ScopedLocalRef<jbyteArray> receivedData(e, e->NewByteArray(sConnlessRecvLen));
-        e->SetByteArrayRegion(receivedData.get(), 0, sConnlessRecvLen, (jbyte*) sConnlessRecvBuf);
-        e->SetObjectField(llcpPacket, f, receivedData.get());
-    }
-
-TheEnd: // TODO: should all the "return connectionlessCleanup()"s in this function jump here instead?
-    connectionlessCleanup ();
-    if (sem_destroy (&sConnlessRecvSem))
-    {
-        ALOGE("%s: Failed to destroy sConnlessRecvSem semaphore (errno=0x%08x)", __func__, errno);
-    }
-    return llcpPacket;
-}
+static jobject nativeLlcpConnectionlessSocket_doReceiveFrom(JNIEnv* e, jobject,
+                                                            jint linkMiu) {
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: linkMiu = %d", __func__, linkMiu);
+  jobject llcpPacket = NULL;
+  ScopedLocalRef<jclass> clsLlcpPacket(e, NULL);
+
+  if (sConnlessRecvWaitingForData != JNI_FALSE) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Already waiting for incoming data", __func__);
+    return NULL;
+  }
 
+  sConnlessRecvBuf = (uint8_t*)malloc(linkMiu);
+  if (sConnlessRecvBuf == NULL) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: Failed to allocate %d bytes memory buffer", __func__, linkMiu);
+    return NULL;
+  }
+  sConnlessRecvLen = linkMiu;
+
+  // Create the write semaphore
+  if (sem_init(&sConnlessRecvSem, 0, 0) == -1) {
+    LOG(ERROR) << StringPrintf("%s: semaphore creation failed (errno=0x%08x)",
+                               __func__, errno);
+    return connectionlessCleanup();
+  }
+
+  sConnlessRecvWaitingForData = JNI_TRUE;
+
+  // Wait for sConnlessRecvSem completion status
+  if (sem_wait(&sConnlessRecvSem)) {
+    LOG(ERROR) << StringPrintf(
+        "%s: Failed to wait for write semaphore (errno=0x%08x)", __func__,
+        errno);
+    goto TheEnd;
+  }
+
+  // Create new LlcpPacket object
+  if (nfc_jni_cache_object_local(e, "com/android/nfc/LlcpPacket",
+                                 &(llcpPacket)) == -1) {
+    LOG(ERROR) << StringPrintf("%s: Find LlcpPacket class error", __func__);
+    return connectionlessCleanup();
+  }
+
+  // Get NativeConnectionless class object
+  clsLlcpPacket.reset(e->GetObjectClass(llcpPacket));
+  if (e->ExceptionCheck()) {
+    e->ExceptionClear();
+    LOG(ERROR) << StringPrintf("%s: Get Object class error", __func__);
+    return connectionlessCleanup();
+  }
+
+  // Set Llcp Packet remote SAP
+  jfieldID f;
+  f = e->GetFieldID(clsLlcpPacket.get(), "mRemoteSap", "I");
+  e->SetIntField(llcpPacket, f, (jbyte)sConnlessRecvRemoteSap);
+
+  // Set Llcp Packet Buffer
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Received Llcp packet buffer size = %d\n", __func__,
+                      sConnlessRecvLen);
+  f = e->GetFieldID(clsLlcpPacket.get(), "mDataBuffer", "[B");
+
+  {
+    ScopedLocalRef<jbyteArray> receivedData(e,
+                                            e->NewByteArray(sConnlessRecvLen));
+    e->SetByteArrayRegion(receivedData.get(), 0, sConnlessRecvLen,
+                          (jbyte*)sConnlessRecvBuf);
+    e->SetObjectField(llcpPacket, f, receivedData.get());
+  }
+
+TheEnd:  // TODO: should all the "return connectionlessCleanup()"s in this
+         // function jump here instead?
+  connectionlessCleanup();
+  if (sem_destroy(&sConnlessRecvSem)) {
+    LOG(ERROR) << StringPrintf(
+        "%s: Failed to destroy sConnlessRecvSem semaphore (errno=0x%08x)",
+        __func__, errno);
+  }
+  return llcpPacket;
+}
 
 /*******************************************************************************
 **
@@ -262,37 +261,34 @@ TheEnd: // TODO: should all the "return connectionlessCleanup()"s in this functi
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-static jboolean nativeLlcpConnectionlessSocket_doClose (JNIEnv *e, jobject o)
-{
-    ALOGV("%s", __func__);
-
-    ScopedLocalRef<jclass> c(e, e->GetObjectClass(o));
-    jfieldID f = e->GetFieldID(c.get(), "mHandle", "I");
-    jint handle = e->GetIntField(o, f);
-
-    tNFA_STATUS status = NFA_P2pDisconnect((tNFA_HANDLE) handle, false);
-    if (status != NFA_STATUS_OK)
-    {
-        ALOGE("%s: disconnect failed, status = %d", __func__, status);
-        return JNI_FALSE;
-    }
-    return JNI_TRUE;
+static jboolean nativeLlcpConnectionlessSocket_doClose(JNIEnv* e, jobject o) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
+
+  ScopedLocalRef<jclass> c(e, e->GetObjectClass(o));
+  jfieldID f = e->GetFieldID(c.get(), "mHandle", "I");
+  jint handle = e->GetIntField(o, f);
+
+  tNFA_STATUS status = NFA_P2pDisconnect((tNFA_HANDLE)handle, false);
+  if (status != NFA_STATUS_OK) {
+    LOG(ERROR) << StringPrintf("%s: disconnect failed, status = %d", __func__,
+                               status);
+    return JNI_FALSE;
+  }
+  return JNI_TRUE;
 }
 
-
 /*****************************************************************************
 **
 ** Description:     JNI functions
 **
 *****************************************************************************/
-static JNINativeMethod gMethods[] =
-{
-    {"doSendTo", "(I[B)Z", (void*) nativeLlcpConnectionlessSocket_doSendTo},
-    {"doReceiveFrom", "(I)Lcom/android/nfc/LlcpPacket;", (void*) nativeLlcpConnectionlessSocket_doReceiveFrom},
-    {"doClose", "()Z", (void*) nativeLlcpConnectionlessSocket_doClose},
+static JNINativeMethod gMethods[] = {
+    {"doSendTo", "(I[B)Z", (void*)nativeLlcpConnectionlessSocket_doSendTo},
+    {"doReceiveFrom", "(I)Lcom/android/nfc/LlcpPacket;",
+     (void*)nativeLlcpConnectionlessSocket_doReceiveFrom},
+    {"doClose", "()Z", (void*)nativeLlcpConnectionlessSocket_doClose},
 };
 
-
 /*******************************************************************************
 **
 ** Function:        register_com_android_nfc_NativeLlcpConnectionlessSocket
@@ -303,10 +299,9 @@ static JNINativeMethod gMethods[] =
 ** Returns:         Status of registration.
 **
 *******************************************************************************/
-int register_com_android_nfc_NativeLlcpConnectionlessSocket (JNIEnv *e)
-{
-    return jniRegisterNativeMethods (e, gNativeLlcpConnectionlessSocketClassName, gMethods, NELEM(gMethods));
+int register_com_android_nfc_NativeLlcpConnectionlessSocket(JNIEnv* e) {
+  return jniRegisterNativeMethods(e, gNativeLlcpConnectionlessSocketClassName,
+                                  gMethods, NELEM(gMethods));
 }
 
-
-} // android namespace
+}  // namespace android
diff --git a/nci/jni/NativeLlcpServiceSocket.cpp b/nci/jni/NativeLlcpServiceSocket.cpp
index 1711f537..edafbf89 100644
--- a/nci/jni/NativeLlcpServiceSocket.cpp
+++ b/nci/jni/NativeLlcpServiceSocket.cpp
@@ -13,25 +13,23 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+#include <nativehelper/JNIHelp.h>
 
-#include "_OverrideLog.h"
 #include "NfcJniUtil.h"
 //#include "NfcAdaptation.h"
-#include "PeerToPeer.h"
 #include "JavaClassConstants.h"
+#include "PeerToPeer.h"
 
-#include <nativehelper/JNIHelp.h>
-
-extern "C"
-{
-    #include "nfa_api.h"
-    #include "nfa_p2p_api.h"
-}
+#include "nfa_api.h"
+#include "nfa_p2p_api.h"
 
+using android::base::StringPrintf;
 
-namespace android
-{
+extern bool nfc_debug_enabled;
 
+namespace android {
 
 /*******************************************************************************
 **
@@ -47,61 +45,60 @@ namespace android
 ** Returns:         LlcpSocket Java object.
 **
 *******************************************************************************/
-static jobject nativeLlcpServiceSocket_doAccept(JNIEnv *e, jobject o, jint miu, jint rw, jint /*linearBufferLength*/)
-{
-    jobject     clientSocket = NULL;
-    jclass      clsNativeLlcpSocket = NULL;
-    jfieldID    f = 0;
-    PeerToPeer::tJNI_HANDLE serverHandle; //handle of the local server
-    bool        stat = false;
-    PeerToPeer::tJNI_HANDLE connHandle = PeerToPeer::getInstance().getNewJniHandle ();
-
-    ALOGV("%s: enter", __func__);
-
-    serverHandle = (PeerToPeer::tJNI_HANDLE) nfc_jni_get_nfc_socket_handle (e, o);
-
-    stat = PeerToPeer::getInstance().accept (serverHandle, connHandle, miu, rw);
-
-    if (! stat)
-    {
-        ALOGE("%s: fail accept", __func__);
-        goto TheEnd;
-    }
-
-    /* Create new LlcpSocket object */
-    if (nfc_jni_cache_object_local(e, gNativeLlcpSocketClassName, &(clientSocket)) == -1)
-    {
-        ALOGE("%s: fail create NativeLlcpSocket", __func__);
-        goto TheEnd;
-    }
-
-    /* Get NativeConnectionOriented class object */
-    clsNativeLlcpSocket = e->GetObjectClass (clientSocket);
-    if (e->ExceptionCheck())
-    {
-        e->ExceptionClear();
-        ALOGE("%s: get class object error", __func__);
-        goto TheEnd;
-    }
-
-    /* Set socket handle */
-    f = e->GetFieldID (clsNativeLlcpSocket, "mHandle", "I");
-    e->SetIntField (clientSocket, f, (jint) connHandle);
-
-    /* Set socket MIU */
-    f = e->GetFieldID (clsNativeLlcpSocket, "mLocalMiu", "I");
-    e->SetIntField (clientSocket, f, (jint)miu);
-
-    /* Set socket RW */
-    f = e->GetFieldID (clsNativeLlcpSocket, "mLocalRw", "I");
-    e->SetIntField (clientSocket, f, (jint)rw);
+static jobject nativeLlcpServiceSocket_doAccept(JNIEnv* e, jobject o, jint miu,
+                                                jint rw,
+                                                jint /*linearBufferLength*/) {
+  jobject clientSocket = NULL;
+  jclass clsNativeLlcpSocket = NULL;
+  jfieldID f = 0;
+  PeerToPeer::tJNI_HANDLE serverHandle;  // handle of the local server
+  bool stat = false;
+  PeerToPeer::tJNI_HANDLE connHandle =
+      PeerToPeer::getInstance().getNewJniHandle();
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+
+  serverHandle = (PeerToPeer::tJNI_HANDLE)nfc_jni_get_nfc_socket_handle(e, o);
+
+  stat = PeerToPeer::getInstance().accept(serverHandle, connHandle, miu, rw);
+
+  if (!stat) {
+    LOG(ERROR) << StringPrintf("%s: fail accept", __func__);
+    goto TheEnd;
+  }
+
+  /* Create new LlcpSocket object */
+  if (nfc_jni_cache_object_local(e, gNativeLlcpSocketClassName,
+                                 &(clientSocket)) == -1) {
+    LOG(ERROR) << StringPrintf("%s: fail create NativeLlcpSocket", __func__);
+    goto TheEnd;
+  }
+
+  /* Get NativeConnectionOriented class object */
+  clsNativeLlcpSocket = e->GetObjectClass(clientSocket);
+  if (e->ExceptionCheck()) {
+    e->ExceptionClear();
+    LOG(ERROR) << StringPrintf("%s: get class object error", __func__);
+    goto TheEnd;
+  }
+
+  /* Set socket handle */
+  f = e->GetFieldID(clsNativeLlcpSocket, "mHandle", "I");
+  e->SetIntField(clientSocket, f, (jint)connHandle);
+
+  /* Set socket MIU */
+  f = e->GetFieldID(clsNativeLlcpSocket, "mLocalMiu", "I");
+  e->SetIntField(clientSocket, f, (jint)miu);
+
+  /* Set socket RW */
+  f = e->GetFieldID(clsNativeLlcpSocket, "mLocalRw", "I");
+  e->SetIntField(clientSocket, f, (jint)rw);
 
 TheEnd:
-    ALOGV("%s: exit", __func__);
-    return clientSocket;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  return clientSocket;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeLlcpServiceSocket_doClose
@@ -113,33 +110,30 @@ TheEnd:
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-static jboolean nativeLlcpServiceSocket_doClose(JNIEnv *e, jobject o)
-{
-    ALOGV("%s: enter", __func__);
-    PeerToPeer::tJNI_HANDLE jniServerHandle = 0;
-    bool stat = false;
+static jboolean nativeLlcpServiceSocket_doClose(JNIEnv* e, jobject o) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+  PeerToPeer::tJNI_HANDLE jniServerHandle = 0;
+  bool stat = false;
 
-    jniServerHandle = nfc_jni_get_nfc_socket_handle (e, o);
+  jniServerHandle = nfc_jni_get_nfc_socket_handle(e, o);
 
-    stat = PeerToPeer::getInstance().deregisterServer (jniServerHandle);
+  stat = PeerToPeer::getInstance().deregisterServer(jniServerHandle);
 
-    ALOGV("%s: exit", __func__);
-    return JNI_TRUE;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  return JNI_TRUE;
 }
 
-
 /*****************************************************************************
 **
 ** Description:     JNI functions
 **
 *****************************************************************************/
-static JNINativeMethod gMethods[] =
-{
-    {"doAccept", "(III)Lcom/android/nfc/dhimpl/NativeLlcpSocket;", (void*) nativeLlcpServiceSocket_doAccept},
-    {"doClose", "()Z", (void*) nativeLlcpServiceSocket_doClose},
+static JNINativeMethod gMethods[] = {
+    {"doAccept", "(III)Lcom/android/nfc/dhimpl/NativeLlcpSocket;",
+     (void*)nativeLlcpServiceSocket_doAccept},
+    {"doClose", "()Z", (void*)nativeLlcpServiceSocket_doClose},
 };
 
-
 /*******************************************************************************
 **
 ** Function:        register_com_android_nfc_NativeLlcpServiceSocket
@@ -150,11 +144,9 @@ static JNINativeMethod gMethods[] =
 ** Returns:         Status of registration.
 **
 *******************************************************************************/
-int register_com_android_nfc_NativeLlcpServiceSocket (JNIEnv* e)
-{
-    return jniRegisterNativeMethods (e, gNativeLlcpServiceSocketClassName,
-            gMethods, NELEM(gMethods));
+int register_com_android_nfc_NativeLlcpServiceSocket(JNIEnv* e) {
+  return jniRegisterNativeMethods(e, gNativeLlcpServiceSocketClassName,
+                                  gMethods, NELEM(gMethods));
 }
 
-
-} //namespace android
+}  // namespace android
diff --git a/nci/jni/NativeLlcpSocket.cpp b/nci/jni/NativeLlcpSocket.cpp
index c6b57f60..eb4087ab 100644
--- a/nci/jni/NativeLlcpSocket.cpp
+++ b/nci/jni/NativeLlcpSocket.cpp
@@ -13,16 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-#include "_OverrideLog.h"
-#include "PeerToPeer.h"
-#include "JavaClassConstants.h"
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
 #include <nativehelper/ScopedPrimitiveArray.h>
 #include <nativehelper/ScopedUtfChars.h>
+#include "JavaClassConstants.h"
+#include "PeerToPeer.h"
 
+using android::base::StringPrintf;
 
-namespace android
-{
+extern bool nfc_debug_enabled;
 
+namespace android {
 
 /*******************************************************************************
 **
@@ -36,18 +38,18 @@ namespace android
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-static jboolean nativeLlcpSocket_doConnect (JNIEnv* e, jobject o, jint nSap)
-{
-    ALOGV("%s: enter; sap=%d", __func__, nSap);
+static jboolean nativeLlcpSocket_doConnect(JNIEnv* e, jobject o, jint nSap) {
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter; sap=%d", __func__, nSap);
 
-    PeerToPeer::tJNI_HANDLE jniHandle = (PeerToPeer::tJNI_HANDLE) nfc_jni_get_nfc_socket_handle(e, o);
-    bool stat = PeerToPeer::getInstance().connectConnOriented (jniHandle, nSap);
+  PeerToPeer::tJNI_HANDLE jniHandle =
+      (PeerToPeer::tJNI_HANDLE)nfc_jni_get_nfc_socket_handle(e, o);
+  bool stat = PeerToPeer::getInstance().connectConnOriented(jniHandle, nSap);
 
-    ALOGV("%s: exit", __func__);
-    return stat ? JNI_TRUE : JNI_FALSE;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  return stat ? JNI_TRUE : JNI_FALSE;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeLlcpSocket_doConnectBy
@@ -60,24 +62,23 @@ static jboolean nativeLlcpSocket_doConnect (JNIEnv* e, jobject o, jint nSap)
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-static jboolean nativeLlcpSocket_doConnectBy (JNIEnv* e, jobject o, jstring sn)
-{
-    ALOGV("%s: enter", __func__);
+static jboolean nativeLlcpSocket_doConnectBy(JNIEnv* e, jobject o, jstring sn) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
 
-    PeerToPeer::tJNI_HANDLE jniHandle = (PeerToPeer::tJNI_HANDLE) nfc_jni_get_nfc_socket_handle(e, o);
+  PeerToPeer::tJNI_HANDLE jniHandle =
+      (PeerToPeer::tJNI_HANDLE)nfc_jni_get_nfc_socket_handle(e, o);
 
-    ScopedUtfChars serviceName(e, sn);
-    if (serviceName.c_str() == NULL)
-    {
-        return JNI_FALSE;
-    }
-    bool stat = PeerToPeer::getInstance().connectConnOriented(jniHandle, serviceName.c_str());
+  ScopedUtfChars serviceName(e, sn);
+  if (serviceName.c_str() == NULL) {
+    return JNI_FALSE;
+  }
+  bool stat = PeerToPeer::getInstance().connectConnOriented(
+      jniHandle, serviceName.c_str());
 
-    ALOGV("%s: exit", __func__);
-    return stat ? JNI_TRUE : JNI_FALSE;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  return stat ? JNI_TRUE : JNI_FALSE;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeLlcpSocket_doClose
@@ -89,18 +90,17 @@ static jboolean nativeLlcpSocket_doConnectBy (JNIEnv* e, jobject o, jstring sn)
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-static jboolean nativeLlcpSocket_doClose(JNIEnv *e, jobject o)
-{
-    ALOGV("%s: enter", __func__);
+static jboolean nativeLlcpSocket_doClose(JNIEnv* e, jobject o) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
 
-    PeerToPeer::tJNI_HANDLE jniHandle = (PeerToPeer::tJNI_HANDLE) nfc_jni_get_nfc_socket_handle(e, o);
-    bool stat = PeerToPeer::getInstance().disconnectConnOriented (jniHandle);
+  PeerToPeer::tJNI_HANDLE jniHandle =
+      (PeerToPeer::tJNI_HANDLE)nfc_jni_get_nfc_socket_handle(e, o);
+  bool stat = PeerToPeer::getInstance().disconnectConnOriented(jniHandle);
 
-    ALOGV("%s: exit", __func__);
-    return stat ? JNI_TRUE : JNI_FALSE;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  return stat ? JNI_TRUE : JNI_FALSE;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeLlcpSocket_doSend
@@ -113,21 +113,21 @@ static jboolean nativeLlcpSocket_doClose(JNIEnv *e, jobject o)
 ** Returns:         True if sent ok.
 **
 *******************************************************************************/
-static jboolean nativeLlcpSocket_doSend (JNIEnv* e, jobject o, jbyteArray data)
-{
-    ALOGV_IF((appl_trace_level>=BT_TRACE_LEVEL_DEBUG), "%s: enter", __func__);
+static jboolean nativeLlcpSocket_doSend(JNIEnv* e, jobject o, jbyteArray data) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
 
-    ScopedByteArrayRO bytes(e, data);
+  ScopedByteArrayRO bytes(e, data);
 
-    PeerToPeer::tJNI_HANDLE jniHandle = (PeerToPeer::tJNI_HANDLE) nfc_jni_get_nfc_socket_handle(e, o);
-    uint8_t* raw_ptr = const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0]));
-    bool stat = PeerToPeer::getInstance().send(jniHandle, raw_ptr, bytes.size());
+  PeerToPeer::tJNI_HANDLE jniHandle =
+      (PeerToPeer::tJNI_HANDLE)nfc_jni_get_nfc_socket_handle(e, o);
+  uint8_t* raw_ptr =
+      const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0]));
+  bool stat = PeerToPeer::getInstance().send(jniHandle, raw_ptr, bytes.size());
 
-    ALOGV_IF((appl_trace_level>=BT_TRACE_LEVEL_DEBUG), "%s: exit", __func__);
-    return stat ? JNI_TRUE : JNI_FALSE;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  return stat ? JNI_TRUE : JNI_FALSE;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeLlcpSocket_doReceive
@@ -140,29 +140,30 @@ static jboolean nativeLlcpSocket_doSend (JNIEnv* e, jobject o, jbyteArray data)
 ** Returns:         Number of bytes received.
 **
 *******************************************************************************/
-static jint nativeLlcpSocket_doReceive(JNIEnv *e, jobject o, jbyteArray origBuffer)
-{
-    ALOGV_IF((appl_trace_level>=BT_TRACE_LEVEL_DEBUG), "%s: enter", __func__);
-
-    ScopedByteArrayRW bytes(e, origBuffer);
-
-    PeerToPeer::tJNI_HANDLE jniHandle = (PeerToPeer::tJNI_HANDLE) nfc_jni_get_nfc_socket_handle(e, o);
-    uint16_t actualLen = 0;
-    bool stat = PeerToPeer::getInstance().receive(jniHandle, reinterpret_cast<uint8_t*>(&bytes[0]), bytes.size(), actualLen);
-
-    jint retval = 0;
-    if (stat && (actualLen>0))
-    {
-        retval = actualLen;
-    }
-    else
-        retval = -1;
-
-    ALOGV_IF((appl_trace_level>=BT_TRACE_LEVEL_DEBUG), "%s: exit; actual len=%d", __func__, retval);
-    return retval;
+static jint nativeLlcpSocket_doReceive(JNIEnv* e, jobject o,
+                                       jbyteArray origBuffer) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+
+  ScopedByteArrayRW bytes(e, origBuffer);
+
+  PeerToPeer::tJNI_HANDLE jniHandle =
+      (PeerToPeer::tJNI_HANDLE)nfc_jni_get_nfc_socket_handle(e, o);
+  uint16_t actualLen = 0;
+  bool stat = PeerToPeer::getInstance().receive(
+      jniHandle, reinterpret_cast<uint8_t*>(&bytes[0]), bytes.size(),
+      actualLen);
+
+  jint retval = 0;
+  if (stat && (actualLen > 0)) {
+    retval = actualLen;
+  } else
+    retval = -1;
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit; actual len=%d", __func__, retval);
+  return retval;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeLlcpSocket_doGetRemoteSocketMIU
@@ -174,18 +175,17 @@ static jint nativeLlcpSocket_doReceive(JNIEnv *e, jobject o, jbyteArray origBuff
 ** Returns:         Peer's maximum information unit.
 **
 *******************************************************************************/
-static jint nativeLlcpSocket_doGetRemoteSocketMIU (JNIEnv* e, jobject o)
-{
-    ALOGV("%s: enter", __func__);
+static jint nativeLlcpSocket_doGetRemoteSocketMIU(JNIEnv* e, jobject o) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
 
-    PeerToPeer::tJNI_HANDLE jniHandle = (PeerToPeer::tJNI_HANDLE) nfc_jni_get_nfc_socket_handle(e, o);
-    jint miu = PeerToPeer::getInstance().getRemoteMaxInfoUnit(jniHandle);
+  PeerToPeer::tJNI_HANDLE jniHandle =
+      (PeerToPeer::tJNI_HANDLE)nfc_jni_get_nfc_socket_handle(e, o);
+  jint miu = PeerToPeer::getInstance().getRemoteMaxInfoUnit(jniHandle);
 
-    ALOGV("%s: exit", __func__);
-    return miu;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  return miu;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeLlcpSocket_doGetRemoteSocketRW
@@ -197,35 +197,34 @@ static jint nativeLlcpSocket_doGetRemoteSocketMIU (JNIEnv* e, jobject o)
 ** Returns:         Peer's receive window size.
 **
 *******************************************************************************/
-static jint nativeLlcpSocket_doGetRemoteSocketRW (JNIEnv* e, jobject o)
-{
-    ALOGV("%s: enter", __func__);
+static jint nativeLlcpSocket_doGetRemoteSocketRW(JNIEnv* e, jobject o) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
 
-    PeerToPeer::tJNI_HANDLE jniHandle = (PeerToPeer::tJNI_HANDLE) nfc_jni_get_nfc_socket_handle(e, o);
-    jint rw = PeerToPeer::getInstance().getRemoteRecvWindow (jniHandle);
+  PeerToPeer::tJNI_HANDLE jniHandle =
+      (PeerToPeer::tJNI_HANDLE)nfc_jni_get_nfc_socket_handle(e, o);
+  jint rw = PeerToPeer::getInstance().getRemoteRecvWindow(jniHandle);
 
-    ALOGV("%s: exit", __func__);
-    return rw;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  return rw;
 }
 
-
 /*****************************************************************************
 **
 ** Description:     JNI functions
 **
 *****************************************************************************/
-static JNINativeMethod gMethods[] =
-{
-    {"doConnect", "(I)Z", (void * ) nativeLlcpSocket_doConnect},
-    {"doConnectBy", "(Ljava/lang/String;)Z", (void*) nativeLlcpSocket_doConnectBy},
-    {"doClose", "()Z", (void *) nativeLlcpSocket_doClose},
-    {"doSend", "([B)Z", (void *) nativeLlcpSocket_doSend},
-    {"doReceive", "([B)I", (void *) nativeLlcpSocket_doReceive},
-    {"doGetRemoteSocketMiu", "()I", (void *) nativeLlcpSocket_doGetRemoteSocketMIU},
-    {"doGetRemoteSocketRw", "()I", (void *) nativeLlcpSocket_doGetRemoteSocketRW},
+static JNINativeMethod gMethods[] = {
+    {"doConnect", "(I)Z", (void*)nativeLlcpSocket_doConnect},
+    {"doConnectBy", "(Ljava/lang/String;)Z",
+     (void*)nativeLlcpSocket_doConnectBy},
+    {"doClose", "()Z", (void*)nativeLlcpSocket_doClose},
+    {"doSend", "([B)Z", (void*)nativeLlcpSocket_doSend},
+    {"doReceive", "([B)I", (void*)nativeLlcpSocket_doReceive},
+    {"doGetRemoteSocketMiu", "()I",
+     (void*)nativeLlcpSocket_doGetRemoteSocketMIU},
+    {"doGetRemoteSocketRw", "()I", (void*)nativeLlcpSocket_doGetRemoteSocketRW},
 };
 
-
 /*******************************************************************************
 **
 ** Function:        register_com_android_nfc_NativeLlcpSocket
@@ -236,10 +235,9 @@ static JNINativeMethod gMethods[] =
 ** Returns:         Status of registration.
 **
 *******************************************************************************/
-int register_com_android_nfc_NativeLlcpSocket (JNIEnv* e)
-{
-    return jniRegisterNativeMethods (e, gNativeLlcpSocketClassName, gMethods, NELEM(gMethods));
+int register_com_android_nfc_NativeLlcpSocket(JNIEnv* e) {
+  return jniRegisterNativeMethods(e, gNativeLlcpSocketClassName, gMethods,
+                                  NELEM(gMethods));
 }
 
-
-} //namespace android
+}  // namespace android
diff --git a/nci/jni/NativeMposManager.cpp b/nci/jni/NativeMposManager.cpp
new file mode 100644
index 00000000..99cf6259
--- /dev/null
+++ b/nci/jni/NativeMposManager.cpp
@@ -0,0 +1,353 @@
+/******************************************************************************
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  Copyright 2018 NXP
+ *
+ ******************************************************************************/
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+#include "JavaClassConstants.h"
+#include "MposManager.h"
+
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+
+namespace android {
+typedef enum {
+  LOW_POWER = 0x00,
+  ULTRA_LOW_POWER,
+} POWER_MODE;
+
+static const char* covertToString(POWER_MODE mode);
+extern void enableRfDiscovery();
+extern void startRfDiscovery(bool isStart);
+extern void disableRfDiscovery();
+/*******************************************************************************
+**
+** Function:        nfcManager_dosetEtsiReaederState
+**
+** Description:     Set ETSI reader state
+**                  e: JVM environment.
+**                  o: Java object.
+**                  newState : new state to be set
+**
+** Returns:         None.
+**
+*******************************************************************************/
+static void nativeNfcMposManager_doSetEtsiReaederState(
+    JNIEnv*, jobject, se_rd_req_state_t newState) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Enter ", __func__);
+  if (nfcFL.nfcNxpEse && nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
+    MposManager::getInstance().setEtsiReaederState(newState);
+  } else {
+    LOG(ERROR) << StringPrintf("%s: ETSI_READER not available. Returning",
+                               __func__);
+  }
+}
+
+/*******************************************************************************
+**
+** Function:        nfcManager_dogetEtsiReaederState
+**
+** Description:     Get current ETSI reader state
+**                  e: JVM environment.
+**                  o: Java object.
+**
+** Returns:         State.
+**
+*******************************************************************************/
+static int nativeNfcMposManager_doGetEtsiReaederState(JNIEnv*, jobject) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Enter ", __func__);
+  if (nfcFL.nfcNxpEse && nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
+    return MposManager::getInstance().getEtsiReaederState();
+  } else {
+    LOG(ERROR) << StringPrintf("%s: ETSI_READER not available. Returning",
+                               __func__);
+    return STATE_SE_RDR_MODE_STOPPED;
+  }
+}
+
+/*******************************************************************************
+**
+** Function:        nfcManager_doEtsiReaderConfig
+**
+** Description:     Configuring to Emvco profile
+**                  e: JVM environment.
+**                  o: Java object.
+**
+** Returns:         None.
+**
+*******************************************************************************/
+static void nativeNfcMposManager_doEtsiReaderConfig(JNIEnv*, jobject,
+                                                    int eeHandle) {
+  tNFC_STATUS status;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Enter ", __func__);
+  if (nfcFL.nfcNxpEse && nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
+    status = MposManager::getInstance().etsiReaderConfig(eeHandle);
+    if (status != NFA_STATUS_OK) {
+      LOG(ERROR) << StringPrintf("%s: etsiReaderConfig Failed ", __func__);
+    } else {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: etsiReaderConfig Success ", __func__);
+    }
+  } else {
+    LOG(ERROR) << StringPrintf("%s: ETSI_READER not available. Returning",
+                               __func__);
+  }
+}
+
+/*******************************************************************************
+**
+** Function:        nfcManager_doEtsiResetReaderConfig
+**
+** Description:     Configuring to Nfc forum profile
+**                  e: JVM environment.
+**                  o: Java object.
+**
+** Returns:         None.
+**
+*******************************************************************************/
+static void nativeNfcMposManager_doEtsiResetReaderConfig(JNIEnv*, jobject) {
+  tNFC_STATUS status;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Enter ", __func__);
+  if (nfcFL.nfcNxpEse && nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
+    status = MposManager::getInstance().etsiResetReaderConfig();
+    if (status != NFA_STATUS_OK) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: etsiReaderConfig Failed ", __func__);
+    } else {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: etsiReaderConfig Success ", __func__);
+    }
+  } else {
+    LOG(ERROR) << StringPrintf("%s: ETSI_READER not available. Returning",
+                               __func__);
+  }
+}
+
+/*******************************************************************************
+**
+** Function:        nfcManager_doNotifyEEReaderEvent
+**
+** Description:     Notify with the Reader event
+**                  e: JVM environment.
+**                  o: Java object.
+**
+** Returns:         None.
+**
+*******************************************************************************/
+static void nativeNfcMposManager_doNotifyEEReaderEvent(JNIEnv*, jobject,
+                                                       int evt) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Enter ", __func__);
+
+  if (nfcFL.nfcNxpEse && nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
+    MposManager::getInstance().notifyEEReaderEvent((etsi_rd_event_t)evt);
+  } else {
+    LOG(ERROR) << StringPrintf("%s: ETSI_READER not available. Returning",
+                               __func__);
+  }
+}
+
+/*******************************************************************************
+**
+** Function:        nfcManager_doEtsiInitConfig
+**
+** Description:     Chnage the ETSI state before start configuration
+**                  e: JVM environment.
+**                  o: Java object.
+**
+** Returns:         None.
+**
+*******************************************************************************/
+static void nativeNfcMposManager_doEtsiInitConfig(JNIEnv*, jobject, int evt) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Enter ", __func__);
+  if (nfcFL.nfcNxpEse && nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
+    MposManager::getInstance().etsiInitConfig();
+  } else {
+    LOG(ERROR) << StringPrintf("%s: ETSI_READER not available. Returning",
+                               __func__);
+  }
+}
+
+/*******************************************************************************
+**
+** Function:        nativeNfcMposManage_doMposSetReaderMode
+**
+** Description:     Set/Reset the MPOS reader mode
+**                  e: JVM environment.
+**                  o: Java object.
+**
+** Returns:         STATUS_OK/FAILED.
+**
+*******************************************************************************/
+static int nativeNfcMposManage_doMposSetReaderMode(JNIEnv*, jobject, bool on) {
+  tNFA_STATUS status = NFA_STATUS_REJECTED;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s:enter", __func__);
+  if (nfcFL.nfcNxpEse && nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
+    status = MposManager::getInstance().setDedicatedReaderMode(on);
+  } else {
+    LOG(ERROR) << StringPrintf("%s: ETSI_READER not available. Returning",
+                               __func__);
+  }
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function:        nativeNfcMposManage_doMposGetReaderMode
+**
+** Description:     Provides the state of the reader mode on/off
+**                  e: JVM environment.
+**                  o: Java object.
+**
+** Returns:         TRUE/FALSE.
+**
+*******************************************************************************/
+static bool nativeNfcMposManager_doMposGetReaderMode(JNIEnv*, jobject) {
+  bool isEnabled = false;
+  int state = MposManager::getInstance().getEtsiReaederState();
+
+  if ((state == STATE_SE_RDR_MODE_STOPPED) ||
+      (state == STATE_SE_RDR_MODE_INVALID)) {
+    isEnabled = false;
+  } else {
+    isEnabled = true;
+  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("isEnabled =%x", isEnabled);
+  return isEnabled;
+}
+
+/*******************************************************************************
+**
+** Function:        nativeNfcMposManage_doStopPoll
+**
+** Description:     Enables the specific power mode
+**                  e: JVM environment.
+**                  o: Java object.
+**                  mode: LOW/ULTRA LOW POWER
+**
+** Returns:         None.
+**
+*******************************************************************************/
+static void nativeNfcMposManage_doStopPoll(JNIEnv* e, jobject, int mode) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s:enter - %s mode", __func__, covertToString((POWER_MODE)mode));
+  if (nfcFL.nfcNxpEse && nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
+    switch (mode) {
+      case LOW_POWER:
+        disableRfDiscovery();
+        break;
+      case ULTRA_LOW_POWER:
+        startRfDiscovery(false);
+        break;
+      default:
+        break;
+    }
+  } else {
+    LOG(ERROR) << StringPrintf("%s: ETSI_READER not available. Returning",
+                               __func__);
+  }
+}
+
+/*******************************************************************************
+**
+** Function:        nativeNfcMposManage_doStartPoll
+**
+** Description:     Enables the NFC RF discovery
+**                  e: JVM environment.
+**                  o: Java object.
+**
+** Returns:         None.
+**
+*******************************************************************************/
+static void nativeNfcMposManage_doStartPoll(JNIEnv*, jobject) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s:enter", __func__);
+  if (nfcFL.nfcNxpEse && nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
+    enableRfDiscovery();
+  } else {
+    LOG(ERROR) << StringPrintf("%s: ETSI_READER not available. Returning",
+                               __func__);
+  }
+}
+
+/*******************************************************************************
+**
+** Function:        covertToString
+**
+** Description:     Converts power mode type int to string
+**
+** Returns:         String.
+**
+*******************************************************************************/
+static const char* covertToString(POWER_MODE mode) {
+  switch (mode) {
+    case LOW_POWER:
+      return "LOW_POWER";
+    case ULTRA_LOW_POWER:
+      return "ULTRA_LOW_POWER";
+    default:
+      return "INVALID";
+  }
+}
+
+/*****************************************************************************
+**
+** Description:     JNI functions
+**
+*****************************************************************************/
+static JNINativeMethod gMethods[] = {
+    {"doSetEtsiReaederState", "(I)V",
+     (void*)nativeNfcMposManager_doSetEtsiReaederState},
+
+    {"doGetEtsiReaederState", "()I",
+     (void*)nativeNfcMposManager_doGetEtsiReaederState},
+
+    {"doEtsiReaderConfig", "(I)V",
+     (void*)nativeNfcMposManager_doEtsiReaderConfig},
+
+    {"doEtsiResetReaderConfig", "()V",
+     (void*)nativeNfcMposManager_doEtsiResetReaderConfig},
+
+    {"doNotifyEEReaderEvent", "(I)V",
+     (void*)nativeNfcMposManager_doNotifyEEReaderEvent},
+
+    {"doEtsiInitConfig", "()V", (void*)nativeNfcMposManager_doEtsiInitConfig},
+
+    {"doMposSetReaderMode", "(Z)I",
+     (void*)nativeNfcMposManage_doMposSetReaderMode},
+
+    {"doMposGetReaderMode", "()Z",
+     (void*)nativeNfcMposManager_doMposGetReaderMode},
+
+    {"doStopPoll", "(I)V", (void*)nativeNfcMposManage_doStopPoll},
+
+    {"doStartPoll", "()V", (void*)nativeNfcMposManage_doStartPoll}};
+
+/*******************************************************************************
+**
+** Function:        register_com_android_nfc_NativeNfcSecureElement
+**
+** Description:     Regisgter JNI functions with Java Virtual Machine.
+**                  e: Environment of JVM.
+**
+** Returns:         Status of registration.
+**
+*******************************************************************************/
+int register_com_android_nfc_NativeNfcMposManager(JNIEnv* e) {
+  return jniRegisterNativeMethods(e, gNativeNfcMposManagerClassName, gMethods,
+                                  NELEM(gMethods));
+}
+
+}  // namespace android
diff --git a/nci/jni/NativeNfcAla.cpp b/nci/jni/NativeNfcAla.cpp
index 6b265da5..106a8be8 100644
--- a/nci/jni/NativeNfcAla.cpp
+++ b/nci/jni/NativeNfcAla.cpp
@@ -2,7 +2,7 @@
  * Copyright (c) 2016, The Linux Foundation. All rights reserved.
  * Not a Contribution.
  *
- * Copyright (C) 2015 NXP Semiconductors
+ * Copyright (C) 2015-2018 NXP Semiconductors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,43 +16,45 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+#include <ScopedPrimitiveArray.h>
+#include "DwpChannel.h"
+#include "JavaClassConstants.h"
+#include "JcopManager.h"
 #include "NfcJniUtil.h"
 #include "PowerSwitch.h"
-#include "JavaClassConstants.h"
-#include "_OverrideLog.h"
-#include <nativehelper/ScopedPrimitiveArray.h>
-#include "DwpChannel.h"
 #include "SecureElement.h"
 #include "TransactionController.h"
-extern "C"
-{
-    #include "AlaLib.h"
-    #include "IChannel.h"
-    #include "phNxpConfig.h"
-}
+#include "phNxpConfig.h"
+#include "nfc_config.h"
+
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
 #define LS_DEFAULT_VERSION 0x20
-namespace android
-{
-extern SyncEvent            sNfaVSCResponseEvent;
-extern void startRfDiscovery (bool isStart);
+namespace android {
+extern SyncEvent sNfaVSCResponseEvent;
+extern void startRfDiscovery(bool isStart);
 extern bool isDiscoveryStarted();
-extern void nfaVSCCallback(uint8_t event, uint16_t param_len, uint8_t *p_param);
-
-}
+extern void nfaVSCCallback(uint8_t event, uint16_t param_len, uint8_t* p_param);
+extern bool isLowRamDevice();
+}  // namespace android
 
-namespace android
-{
+namespace android {
 
 static bool sRfEnabled;
-jbyteArray nfcManager_lsExecuteScript(JNIEnv* e, jobject o, jstring src, jstring dest, jbyteArray);
+jbyteArray nfcManager_lsExecuteScript(JNIEnv* e, jobject o, jstring src,
+                                      jstring dest, jbyteArray);
 jbyteArray nfcManager_lsGetVersion(JNIEnv* e, jobject o);
-int nfcManager_doAppletLoadApplet(JNIEnv* e, jobject o, jstring choice, jbyteArray);
+int nfcManager_doAppletLoadApplet(JNIEnv* e, jobject o, jstring choice,
+                                  jbyteArray);
 int nfcManager_getLoaderServiceConfVersion(JNIEnv* e, jobject o);
 int nfcManager_GetAppletsList(JNIEnv* e, jobject o, jobjectArray list);
 jbyteArray nfcManager_GetCertificateKey(JNIEnv* e, jobject);
 jbyteArray nfcManager_lsGetStatus(JNIEnv* e, jobject);
 jbyteArray nfcManager_lsGetAppletStatus(JNIEnv* e, jobject);
-extern void DWPChannel_init(IChannel_t *DWP);
+extern void DWPChannel_init(IChannel_t* DWP);
 extern IChannel_t Dwp;
 
 /*******************************************************************************
@@ -66,55 +68,49 @@ extern IChannel_t Dwp;
 ** Returns:         None.
 **
 *******************************************************************************/
-int nfcManager_GetAppletsList(JNIEnv* e, jobject o, jobjectArray list)
-{
-    (void)e;
-    (void)o;
-    (void)list;
-    uint8_t xx=0;
+int nfcManager_GetAppletsList(JNIEnv* e, jobject o, jobjectArray list) {
+  (void)e;
+  (void)o;
+  (void)list;
+  uint8_t xx = 0;
 #if (NXP_LDR_SVC_VER_2 == FALSE)
-    if(nfcFL.nfcNxpEse) {
-        char *name[10];
-        uint8_t num =0;
-        uint8_t list_len = e->GetArrayLength(list);
-        ALOGV("%s: enter", __func__);
-
-        sRfEnabled = isDiscoveryStarted();
-        if (sRfEnabled) {
-            // Stop RF Discovery if we were polling
-            startRfDiscovery (false);
-        }
-        ALOGV("%s: list_len=0x%x", __func__, list_len);
-        ALA_GetlistofApplets(name, &num);
-
-        if((num != 0) &&
-                (list_len >= num))
-        {
-            while(num > 0)
-            {
-                jstring tmp = e->NewStringUTF(name[xx]);
-                e->SetObjectArrayElement(list, xx, tmp);
-                if(name[xx] != NULL)
-                {
-                    free(name[xx]);
-                }
-                xx++;
-                num--;
-            }
-        }
-        else
-        {
-            ALOGE("%s: No applets found",__func__);
-        }
-        startRfDiscovery (true);
+  if (nfcFL.nfcNxpEse) {
+    char* name[10];
+    uint8_t num = 0;
+    uint8_t list_len = e->GetArrayLength(list);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+
+    sRfEnabled = isDiscoveryStarted();
+    if (sRfEnabled) {
+      // Stop RF Discovery if we were polling
+      startRfDiscovery(false);
     }
-    else {
-        xx = -1;
-        ALOGV("%s: No p61", __func__);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: list_len=0x%x", __func__, list_len);
+    pJcopMgr->AlaGetlistofApplets(name, &num);
+
+    if ((num != 0) && (list_len >= num)) {
+      while (num > 0) {
+        jstring tmp = e->NewStringUTF(name[xx]);
+        e->SetObjectArrayElement(list, xx, tmp);
+        if (name[xx] != NULL) {
+          free(name[xx]);
+        }
+        xx++;
+        num--;
+      }
+    } else {
+      LOG(ERROR) << StringPrintf("%s: No applets found", __func__);
     }
+    startRfDiscovery(true);
+  } else {
+    xx = -1;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: No p61", __func__);
+  }
 #endif
-    ALOGV("%s: exit; num_applets =0x%X", __func__,xx);
-    return xx;
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit; num_applets =0x%X", __func__, xx);
+  return xx;
 }
 
 /*******************************************************************************
@@ -131,67 +127,62 @@ int nfcManager_GetAppletsList(JNIEnv* e, jobject o, jobjectArray list)
 **
 *******************************************************************************/
 
-int nfcManager_doAppletLoadApplet(JNIEnv* e, jobject o, jstring name, jbyteArray data)
-{
-    (void)e;
-    (void)o;
-    (void)name;
-    tNFA_STATUS wStatus, status;
+int nfcManager_doAppletLoadApplet(JNIEnv* e, jobject o, jstring name,
+                                  jbyteArray data) {
+  (void)e;
+  (void)o;
+  (void)name;
+  tNFA_STATUS wStatus = NFA_STATUS_FAILED;
 #if (NXP_LDR_SVC_VER_2 == FALSE)
-    if(nfcFL.nfcNxpEse) {
-        ALOGV("%s: enter", __func__);
-        IChannel_t Dwp;
-        bool stat = false;
-        const char *choice = NULL;
-
-        sRfEnabled = isDiscoveryStarted();
-        wStatus = status = NFA_STATUS_FAILED;
-
-        if(!pTransactionController->transactionAttempt(TRANSACTION_REQUESTOR(AppletLoadApplet),
-                                                    TRANSACTION_ATTEMPT_FOR_SECONDS(5)))
-        {
-            ALOGE("%s ERROR: attempt to start transaction has failed", __FUNCTION__);
-            return wStatus;
-        }
-        if (sRfEnabled) {
-            // Stop RF Discovery if we were polling
-            startRfDiscovery (false);
-        }
-        DWPChannel_init(&Dwp);
-        wStatus = ALA_Init(&Dwp);
-        if(wStatus != NFA_STATUS_OK)
-        {
-            ALOGE("%s: ALA initialization failed", __func__);
-        }
-        else
-        {
-            ALOGE("%s: start Applet load applet", __func__);
-            choice = e->GetStringUTFChars(name, 0);
-            ALOGE("choice= %s", choice);
-            ScopedByteArrayRO bytes(e, data);
-            uint8_t* buf = const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0]));
-            size_t bufLen = bytes.size();
-            wStatus = ALA_Start(choice, buf, bufLen);
-        }
-        stat = ALA_DeInit();
-        if(choice != NULL)
-            e->ReleaseStringUTFChars(name, choice);
-
-        if(dwpChannelForceClose == false)
-            startRfDiscovery (true);
+  if (nfcFL.nfcNxpEse) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+    IChannel_t Dwp;
+    bool stat = false;
+    const char* choice = NULL;
+
+    sRfEnabled = isDiscoveryStarted();
+
+    if (!pTransactionController->transactionAttempt(
+            TRANSACTION_REQUESTOR(AppletLoadApplet),
+            TRANSACTION_ATTEMPT_FOR_SECONDS(5))) {
+      LOG(ERROR) << StringPrintf(
+          "%s ERROR: attempt to start transaction has failed", __FUNCTION__);
+      return wStatus;
+    }
+    if (sRfEnabled) {
+      // Stop RF Discovery if we were polling
+      startRfDiscovery(false);
+    }
+    DWPChannel_init(&Dwp);
+    wStatus = pJcopMgr->AlaInitialize(&Dwp);
+    if (wStatus != NFA_STATUS_OK) {
+      LOG(ERROR) << StringPrintf("%s: ALA initialization failed", __func__);
+    } else {
+      LOG(ERROR) << StringPrintf("%s: start Applet load applet", __func__);
+      choice = e->GetStringUTFChars(name, 0);
+      LOG(ERROR) << StringPrintf("choice= %s", choice);
+      ScopedByteArrayRO bytes(e, data);
+      uint8_t* buf =
+          const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0]));
+      size_t bufLen = bytes.size();
+      wStatus = pJcopMgr->AlaStart(choice, buf, bufLen);
+    }
+    stat = pJcopMgr->AlaDeInitialize();
+    if (choice != NULL) e->ReleaseStringUTFChars(name, choice);
 
-        pTransactionController->transactionEnd(TRANSACTION_REQUESTOR(AppletLoadApplet));
+    if (dwpChannelForceClose == false) startRfDiscovery(true);
 
-        ALOGV("%s: exit; status =0x%X", __func__,wStatus);
-    }
-    else {
+    pTransactionController->transactionEnd(
+        TRANSACTION_REQUESTOR(AppletLoadApplet));
 
-        wStatus = 0x0F;
-        ALOGV("%s: No p61", __func__);
-    }
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: exit; wStatus =0x%X", __func__, wStatus);
+  } else {
+    wStatus = 0x0F;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: No p61", __func__);
+  }
 #endif
-    return wStatus;
-
+  return wStatus;
 }
 
 /*******************************************************************************
@@ -207,106 +198,119 @@ int nfcManager_doAppletLoadApplet(JNIEnv* e, jobject o, jstring name, jbyteArray
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-jbyteArray nfcManager_lsExecuteScript(JNIEnv* e, jobject o, jstring name, jstring dest, jbyteArray data)
-{
-    (void)e;
-    (void)o;
-    (void)name;
-    (void)dest;
-    const char *destpath = NULL;
-    const uint8_t lsExecuteResponseSize = 4;
-    uint8_t resSW [4]={0x4e,0x02,0x69,0x87};
-    jbyteArray result = e->NewByteArray(0);
-    #if (NXP_LDR_SVC_VER_2 == TRUE)
-    if(nfcFL.nfcNxpEse) {
-
-        ALOGV("%s: enter", __func__);
-        tNFA_STATUS wStatus, status;
-        IChannel_t Dwp;
-        bool stat = false;
-        const char *choice = NULL;
-
-        sRfEnabled = isDiscoveryStarted();
-        wStatus = status = NFA_STATUS_FAILED;
-
-        if(!pTransactionController->transactionAttempt(TRANSACTION_REQUESTOR(lsExecuteScript),
-                                                    TRANSACTION_ATTEMPT_FOR_SECONDS(5)))
-        {
-            ALOGE("%s ERROR: Attempt to start transaction failed", __FUNCTION__);
-            return result;
-        }
-        if (sRfEnabled) {
-            // Stop RF Discovery if we were polling
-            startRfDiscovery (false);
-        }
-        DWPChannel_init(&Dwp);
-        wStatus = ALA_Init(&Dwp);
-        if(wStatus != NFA_STATUS_OK)
-        {
-            ALOGE("%s: ALA initialization failed", __func__);
-        }
-        else
-        {
-            // Commented the Disabling standby
-            /* uint8_t param[] = {0x00}; //Disable standby
-        SyncEventGuard guard (sNfaVSCResponseEvent);
-        status = NFA_SendVsCommand (0x00,0x01,param,nfaVSCCallback);
-        if(NFA_STATUS_OK == status)
-        {
-            sNfaVSCResponseEvent.wait(); //wait for NFA VS command to finish
-            ALOGE("%s: start Applet load applet", __func__);
-            choice = e->GetStringUTFChars(name, 0);
-            ALOGE("choice= %s", choice);
-            wStatus = ALA_Start(choice);
-        }*/
-            destpath = e->GetStringUTFChars(dest, 0);
-            ALOGE("destpath= %s", destpath);
-            ALOGE("%s: start Applet load applet", __func__);
-            choice = e->GetStringUTFChars(name, 0);
-            ALOGE("choice= %s", choice);
-            ScopedByteArrayRO bytes(e, data);
-            uint8_t* buf = const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0]));
-            size_t bufLen = bytes.size();
-            wStatus = ALA_Start(choice,destpath, buf, bufLen,resSW);
-
-            //copy results back to java
-            result = e->NewByteArray(lsExecuteResponseSize);
-            if (result != NULL)
-            {
-                e->SetByteArrayRegion(result, 0, lsExecuteResponseSize, (jbyte *) resSW);
-            }
+jbyteArray nfcManager_lsExecuteScript(JNIEnv* e, jobject o, jstring name,
+                                      jstring dest, jbyteArray data) {
+  (void)e;
+  (void)o;
+  (void)name;
+  (void)dest;
+  const char* destpath = NULL;
+  const uint8_t lsExecuteResponseSize = 4;
+  uint8_t resSW[4] = {0x4e, 0x02, 0x69, 0x87};
+  jbyteArray result = e->NewByteArray(0);
+#if (NXP_LDR_SVC_VER_2 == TRUE)
+  if (nfcFL.nfcNxpEse) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+    tNFA_STATUS wStatus, status;
+    IChannel_t Dwp;
+    bool stat = false;
+    const char* choice = NULL;
+
+    if (isLowRamDevice()) {
+      SecureElement& se = SecureElement::getInstance();
+      if (se.isBusy() || (!pTransactionController->transactionAttempt(
+                             TRANSACTION_REQUESTOR(lsExecuteScript),
+                             TRANSACTION_ATTEMPT_FOR_SECONDS(5)))) {
+        LOG(ERROR) << StringPrintf(
+            " %s: Failed:SE Access Blocked by another process", __func__);
+        resSW[2] = 0x6F;
+        resSW[3] = 0x89;
+        // copy results back to java
+        result = e->NewByteArray(lsExecuteResponseSize);
+        if (result != NULL) {
+          e->SetByteArrayRegion(result, 0, lsExecuteResponseSize,
+                                (jbyte*)resSW);
         }
+        return result;
+      }
+    }
 
-        // Commented the Enabling standby
-        /* uint8_t param[] = {0x01}; //Enable standby
-    SyncEventGuard guard (sNfaVSCResponseEvent);
-    status = NFA_SendVsCommand (0x00,0x01,param,nfaVSCCallback);
-    if(NFA_STATUS_OK == status)
-    {
-        sNfaVSCResponseEvent.wait(); //wait for NFA VS command to finish
-    }*/
+    sRfEnabled = isDiscoveryStarted();
+    wStatus = status = NFA_STATUS_FAILED;
 
-        stat = ALA_DeInit();
-        if(choice != NULL)
-            e->ReleaseStringUTFChars(name, choice);
+    if (!isLowRamDevice() && !pTransactionController->transactionAttempt(
+                                 TRANSACTION_REQUESTOR(lsExecuteScript),
+                                 TRANSACTION_ATTEMPT_FOR_SECONDS(5))) {
+      LOG(ERROR) << StringPrintf(
+          "%s ERROR: Attempt to start transaction failed", __FUNCTION__);
+      return result;
+    }
+    if (sRfEnabled) {
+      // Stop RF Discovery if we were polling
+      startRfDiscovery(false);
+    }
+    DWPChannel_init(&Dwp);
+    wStatus = pJcopMgr->AlaInitialize(&Dwp);
+    if (wStatus != NFA_STATUS_OK) {
+      LOG(ERROR) << StringPrintf("%s: ALA initialization failed", __func__);
+    } else {
+      // Commented the Disabling standby
+      /* uint8_t param[] = {0x00}; //Disable standby
+  SyncEventGuard guard (sNfaVSCResponseEvent);
+  status = NFA_SendVsCommand (0x00,0x01,param,nfaVSCCallback);
+  if(NFA_STATUS_OK == status)
+  {
+      sNfaVSCResponseEvent.wait(); //wait for NFA VS command to finish
+      LOG(ERROR) << StringPrintf("%s: start Applet load applet", __func__);
+      choice = e->GetStringUTFChars(name, 0);
+      LOG(ERROR) << StringPrintf("choice= %s", choice);
+      wStatus = ALA_Start(choice);
+  }*/
+      destpath = e->GetStringUTFChars(dest, 0);
+      LOG(ERROR) << StringPrintf("destpath= %s", destpath);
+      LOG(ERROR) << StringPrintf("%s: start Applet load applet", __func__);
+      choice = e->GetStringUTFChars(name, 0);
+      LOG(ERROR) << StringPrintf("choice= %s", choice);
+      ScopedByteArrayRO bytes(e, data);
+      uint8_t* buf =
+          const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0]));
+      size_t bufLen = bytes.size();
+      wStatus = pJcopMgr->AlaStart(choice, destpath, buf, bufLen, resSW);
+
+      // copy results back to java
+      result = e->NewByteArray(lsExecuteResponseSize);
+      if (result != NULL) {
+        e->SetByteArrayRegion(result, 0, lsExecuteResponseSize, (jbyte*)resSW);
+      }
+    }
 
-        if(dwpChannelForceClose == false)
-            startRfDiscovery (true);
+    // Commented the Enabling standby
+    /* uint8_t param[] = {0x01}; //Enable standby
+SyncEventGuard guard (sNfaVSCResponseEvent);
+status = NFA_SendVsCommand (0x00,0x01,param,nfaVSCCallback);
+if(NFA_STATUS_OK == status)
+{
+    sNfaVSCResponseEvent.wait(); //wait for NFA VS command to finish
+}*/
 
-        pTransactionController->transactionEnd(TRANSACTION_REQUESTOR(lsExecuteScript));
+    stat = pJcopMgr->AlaDeInitialize();
+    if (choice != NULL) e->ReleaseStringUTFChars(name, choice);
 
-        ALOGV("%s: exit; status =0x%X", __func__,wStatus);
-    }
-    else {
-        if(destpath != NULL)
-            e->ReleaseStringUTFChars(dest, destpath);
+    if (dwpChannelForceClose == false) startRfDiscovery(true);
 
-        result = e->NewByteArray(0);
-        tNFA_STATUS wStatus = 0x0F;
-        ALOGV("%s: No p61", __func__);
-    }
+    pTransactionController->transactionEnd(
+        TRANSACTION_REQUESTOR(lsExecuteScript));
+
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: exit; status =0x%X", __func__, wStatus);
+  } else {
+    if (destpath != NULL) e->ReleaseStringUTFChars(dest, destpath);
+
+    result = e->NewByteArray(0);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: No p61", __func__);
+  }
 #endif
-    return result;
+  return result;
 }
 
 /*******************************************************************************
@@ -321,55 +325,53 @@ jbyteArray nfcManager_lsExecuteScript(JNIEnv* e, jobject o, jstring name, jstrin
 **
 *******************************************************************************/
 
-jbyteArray nfcManager_GetCertificateKey(JNIEnv* e, jobject)
-{
-    jbyteArray result = e->NewByteArray(0);
+jbyteArray nfcManager_GetCertificateKey(JNIEnv* e, jobject) {
+  jbyteArray result = e->NewByteArray(0);
 #if (NXP_LDR_SVC_VER_2 == FALSE)
-    if(nfcFL.nfcNxpEse) {
-        ALOGV("%s: enter", __func__);
-        tNFA_STATUS wStatus = NFA_STATUS_FAILED;
-        IChannel_t Dwp;
-        bool stat = false;
-        const int32_t recvBufferMaxSize = 256;
-        uint8_t recvBuffer [recvBufferMaxSize];
-        int32_t recvBufferActualSize = 0;
-
-        sRfEnabled = isDiscoveryStarted();
-
-        if (sRfEnabled) {
-            // Stop RF Discovery if we were polling
-            startRfDiscovery (false);
-        }
-        DWPChannel_init(&Dwp);
-        wStatus = ALA_Init(&Dwp);
-        if(wStatus != NFA_STATUS_OK)
-        {
-            ALOGE("%s: ALA initialization failed", __func__);
-        }
-        else
-        {
-            ALOGE("%s: start Get reference Certificate Key", __func__);
-            wStatus = ALA_GetCertificateKey(recvBuffer, &recvBufferActualSize);
-        }
+  if (nfcFL.nfcNxpEse) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+    tNFA_STATUS wStatus = NFA_STATUS_FAILED;
+    IChannel_t Dwp;
+    bool stat = false;
+    const int32_t recvBufferMaxSize = 256;
+    uint8_t recvBuffer[recvBufferMaxSize];
+    int32_t recvBufferActualSize = 0;
+
+    sRfEnabled = isDiscoveryStarted();
+
+    if (sRfEnabled) {
+      // Stop RF Discovery if we were polling
+      startRfDiscovery(false);
+    }
+    DWPChannel_init(&Dwp);
+    wStatus = pJcopMgr->AlaInitialize(&Dwp);
+    if (wStatus != NFA_STATUS_OK) {
+      LOG(ERROR) << StringPrintf("%s: ALA initialization failed", __func__);
+    } else {
+      LOG(ERROR) << StringPrintf("%s: start Get reference Certificate Key",
+                                 __func__);
+      wStatus =
+          pJcopMgr->AlaGetCertificateKey(recvBuffer, &recvBufferActualSize);
+    }
 
-        //copy results back to java
-        result = e->NewByteArray(recvBufferActualSize);
-        if (result != NULL)
-        {
-            e->SetByteArrayRegion(result, 0, recvBufferActualSize, (jbyte *) recvBuffer);
-        }
+    // copy results back to java
+    result = e->NewByteArray(recvBufferActualSize);
+    if (result != NULL) {
+      e->SetByteArrayRegion(result, 0, recvBufferActualSize,
+                            (jbyte*)recvBuffer);
+    }
 
-        stat = ALA_DeInit();
-        startRfDiscovery (true);
+    stat = pJcopMgr->AlaDeInitialize();
+    startRfDiscovery(true);
 
-        ALOGV("%s: exit: recv len=%ld", __func__, recvBufferActualSize);
-    }
-    else {
-        result = e->NewByteArray(0);
-        ALOGV("%s: No p61", __func__);
-    }
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: exit: recv len=%ld", __func__, recvBufferActualSize);
+  } else {
+    result = e->NewByteArray(0);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: No p61", __func__);
+  }
 #endif
-    return result;
+  return result;
 }
 
 /*******************************************************************************
@@ -383,64 +385,59 @@ jbyteArray nfcManager_GetCertificateKey(JNIEnv* e, jobject)
 ** Returns:         version of Loder service.
 **
 *******************************************************************************/
-jbyteArray nfcManager_lsGetVersion(JNIEnv* e, jobject)
-{
-    jbyteArray result;
+jbyteArray nfcManager_lsGetVersion(JNIEnv* e, jobject) {
+  jbyteArray result;
 #if (NXP_LDR_SVC_VER_2 == TRUE)
-    if(nfcFL.nfcNxpEse) {
-        ALOGV("%s: enter", __func__);
-        tNFA_STATUS wStatus = NFA_STATUS_FAILED;
-        IChannel_t Dwp;
-        bool stat = false;
-        const int32_t recvBufferMaxSize = 4;
-        uint8_t recvBuffer [recvBufferMaxSize];
-        result = e->NewByteArray(0);
-        sRfEnabled = isDiscoveryStarted();
-
-        if(!pTransactionController->transactionAttempt(TRANSACTION_REQUESTOR(lsGetVersion),TRANSACTION_ATTEMPT_FOR_SECONDS(5)))
-        {
-            ALOGE("%s ERRROR: Attempt to start transaction, failed",__FUNCTION__);
-            return result;
-        }
-        if (sRfEnabled) {
-            // Stop RF Discovery if we were polling
-            startRfDiscovery (false);
-        }
-        DWPChannel_init(&Dwp);
-        wStatus = ALA_Init(&Dwp);
-        if(wStatus != NFA_STATUS_OK)
-        {
-            ALOGE("%s: ALA initialization failed", __func__);
-        }
-        else
-        {
-            ALOGE("%s: start Get reference Certificate Key", __func__);
-            wStatus = ALA_lsGetVersion(recvBuffer);
-        }
+  if (nfcFL.nfcNxpEse) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+    tNFA_STATUS wStatus = NFA_STATUS_FAILED;
+    IChannel_t Dwp;
+    bool stat = false;
+    const int32_t recvBufferMaxSize = 4;
+    uint8_t recvBuffer[recvBufferMaxSize];
+    result = e->NewByteArray(0);
+    sRfEnabled = isDiscoveryStarted();
+
+    if (!pTransactionController->transactionAttempt(
+            TRANSACTION_REQUESTOR(lsGetVersion),
+            TRANSACTION_ATTEMPT_FOR_SECONDS(5))) {
+      LOG(ERROR) << StringPrintf(
+          "%s ERRROR: Attempt to start transaction, failed", __FUNCTION__);
+      return result;
+    }
+    if (sRfEnabled) {
+      // Stop RF Discovery if we were polling
+      startRfDiscovery(false);
+    }
+    DWPChannel_init(&Dwp);
+    wStatus = pJcopMgr->AlaInitialize(&Dwp);
+    if (wStatus != NFA_STATUS_OK) {
+      LOG(ERROR) << StringPrintf("%s: ALA initialization failed", __func__);
+    } else {
+      LOG(ERROR) << StringPrintf("%s: start Get reference Certificate Key",
+                                 __func__);
+      wStatus = pJcopMgr->AlaLsGetVersion(recvBuffer);
+    }
 
-        //copy results back to java
-        result = e->NewByteArray(recvBufferMaxSize);
-        if (result != NULL)
-        {
-            e->SetByteArrayRegion(result, 0, recvBufferMaxSize, (jbyte *) recvBuffer);
-        }
+    // copy results back to java
+    result = e->NewByteArray(recvBufferMaxSize);
+    if (result != NULL) {
+      e->SetByteArrayRegion(result, 0, recvBufferMaxSize, (jbyte*)recvBuffer);
+    }
 
-        stat = ALA_DeInit();
-        if(dwpChannelForceClose == false)
-            startRfDiscovery (true);
+    stat = pJcopMgr->AlaDeInitialize();
+    if (dwpChannelForceClose == false) startRfDiscovery(true);
 
-        pTransactionController->transactionEnd(TRANSACTION_REQUESTOR(lsGetVersion));
+    pTransactionController->transactionEnd(TRANSACTION_REQUESTOR(lsGetVersion));
 
-        ALOGV("%s: exit: recv len=%ld", __func__, recvBufferMaxSize);
-    }
-    else
-    {
-        result = e->NewByteArray(0);
-        ALOGV("%s: No p61", __func__);
-    }
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: exit: recv len=%d", __func__, recvBufferMaxSize);
+  } else {
+    result = e->NewByteArray(0);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: No p61", __func__);
+  }
 #endif
-    return result;
-
+  return result;
 }
 
 /*******************************************************************************
@@ -454,55 +451,52 @@ jbyteArray nfcManager_lsGetVersion(JNIEnv* e, jobject)
 ** Returns:         LS Previous execution Applet status .
 **
 *******************************************************************************/
-jbyteArray nfcManager_lsGetAppletStatus(JNIEnv* e, jobject)
-{
-    jbyteArray result = e->NewByteArray(0);
+jbyteArray nfcManager_lsGetAppletStatus(JNIEnv* e, jobject) {
+  jbyteArray result = e->NewByteArray(0);
 #if (NXP_LDR_SVC_VER_2 == TRUE)
-    if(nfcFL.nfcNxpEse) {
-        ALOGV("%s: enter", __func__);
-        tNFA_STATUS wStatus = NFA_STATUS_FAILED;
-        bool stat = false;
-        const int32_t recvBufferMaxSize = 2;
-        uint8_t recvBuffer [recvBufferMaxSize]={0x63,0x40};
-        IChannel_t Dwp;
-        sRfEnabled = isDiscoveryStarted();
-
-        if (sRfEnabled) {
-            // Stop RF Discovery if we were polling
-            startRfDiscovery (false);
-        }
-        DWPChannel_init(&Dwp);
-        wStatus = ALA_Init(&Dwp);
-        if(wStatus != NFA_STATUS_OK)
-        {
-            ALOGE("%s: ALA initialization failed", __func__);
-        }
-        else
-        {
-            ALOGE("%s: start Get reference Certificate Key", __func__);
-            wStatus = ALA_lsGetAppletStatus(recvBuffer);
-        }
+  if (nfcFL.nfcNxpEse) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+    tNFA_STATUS wStatus = NFA_STATUS_FAILED;
+    bool stat = false;
+    const int32_t recvBufferMaxSize = 2;
+    uint8_t recvBuffer[recvBufferMaxSize] = {0x63, 0x40};
+    IChannel_t Dwp;
+    sRfEnabled = isDiscoveryStarted();
+
+    if (sRfEnabled) {
+      // Stop RF Discovery if we were polling
+      startRfDiscovery(false);
+    }
+    DWPChannel_init(&Dwp);
+    wStatus = pJcopMgr->AlaInitialize(&Dwp);
+    if (wStatus != NFA_STATUS_OK) {
+      LOG(ERROR) << StringPrintf("%s: ALA initialization failed", __func__);
+    } else {
+      LOG(ERROR) << StringPrintf("%s: start Get reference Certificate Key",
+                                 __func__);
+      wStatus = pJcopMgr->AlaLsGetAppletStatus(recvBuffer);
+    }
 
-        ALOGV("%s: lsGetAppletStatus values %x %x", __func__, recvBuffer[0], recvBuffer[1]);
-        //copy results back to java
-        result = e->NewByteArray(recvBufferMaxSize);
-        if (result != NULL)
-        {
-            e->SetByteArrayRegion(result, 0, recvBufferMaxSize, (jbyte *) recvBuffer);
-        }
-        stat = ALA_DeInit();
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: lsGetAppletStatus values %x %x", __func__,
+                        recvBuffer[0], recvBuffer[1]);
+    // copy results back to java
+    result = e->NewByteArray(recvBufferMaxSize);
+    if (result != NULL) {
+      e->SetByteArrayRegion(result, 0, recvBufferMaxSize, (jbyte*)recvBuffer);
+    }
+    stat = pJcopMgr->AlaDeInitialize();
 
-        if(dwpChannelForceClose == false)
-            startRfDiscovery (true);
+    if (dwpChannelForceClose == false) startRfDiscovery(true);
 
-        ALOGV("%s: exit: recv len=%ld", __func__, recvBufferMaxSize);
-    }
-    else {
-        result = e->NewByteArray(0);
-        ALOGV("%s: No p61", __func__);
-    }
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: exit: recv len=%d", __func__, recvBufferMaxSize);
+  } else {
+    result = e->NewByteArray(0);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: No p61", __func__);
+  }
 #endif
-    return result;
+  return result;
 }
 
 /*******************************************************************************
@@ -516,33 +510,32 @@ jbyteArray nfcManager_lsGetAppletStatus(JNIEnv* e, jobject)
 ** Returns:         version of Loder service.
 **
 *******************************************************************************/
-jbyteArray nfcManager_lsGetStatus(JNIEnv* e, jobject)
-{
-    jbyteArray result = e->NewByteArray(0);
+jbyteArray nfcManager_lsGetStatus(JNIEnv* e, jobject) {
+  jbyteArray result = e->NewByteArray(0);
 #if (NXP_LDR_SVC_VER_2 == TRUE)
-    if(nfcFL.nfcNxpEse) {
-        ALOGV("%s: enter", __func__);
-        tNFA_STATUS wStatus = NFA_STATUS_FAILED;
-        const int32_t recvBufferMaxSize = 2;
-        uint8_t recvBuffer [recvBufferMaxSize] = {0x63,0x40};
-
-        wStatus = ALA_lsGetStatus(recvBuffer);
-
-        ALOGV("%s: lsGetStatus values %x %x", __func__, recvBuffer[0], recvBuffer[1]);
-        //copy results back to java
-        result = e->NewByteArray(recvBufferMaxSize);
-        if (result != NULL)
-        {
-            e->SetByteArrayRegion(result, 0, recvBufferMaxSize, (jbyte *) recvBuffer);
-        }
-        ALOGV("%s: exit: recv len=%ld", __func__, recvBufferMaxSize);
-    }
-    else {
-        result = e->NewByteArray(0);
-        ALOGV("%s: No p61", __func__);
+  if (nfcFL.nfcNxpEse) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+    tNFA_STATUS wStatus = NFA_STATUS_FAILED;
+    const int32_t recvBufferMaxSize = 2;
+    uint8_t recvBuffer[recvBufferMaxSize] = {0x63, 0x40};
+
+    wStatus = pJcopMgr->AlaLsGetStatus(recvBuffer);
+
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: lsGetStatus values %x %x", __func__, recvBuffer[0], recvBuffer[1]);
+    // copy results back to java
+    result = e->NewByteArray(recvBufferMaxSize);
+    if (result != NULL) {
+      e->SetByteArrayRegion(result, 0, recvBufferMaxSize, (jbyte*)recvBuffer);
     }
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: exit: recv len=%d", __func__, recvBufferMaxSize);
+  } else {
+    result = e->NewByteArray(0);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: No p61", __func__);
+  }
 #endif
-    return result;
+  return result;
 }
 
 /*******************************************************************************
@@ -560,26 +553,26 @@ int nfcManager_getLoaderServiceConfVersion(JNIEnv* /* e */, jobject /* o */)
 {
     unsigned long num = 0;
     uint8_t ls_version = LS_DEFAULT_VERSION;
-    ALOGV("%s: enter", __func__);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
 #if (NXP_LDR_SVC_VER_2 == TRUE)
-    if(nfcFL.nfcNxpEse) {
-        if(GetNxpNumValue (NAME_NXP_LOADER_SERICE_VERSION, (void*)&num, sizeof(num))==false)
-        {
-            ALOGV("LOADER_SERVICE_VERSION not found");
-            num = 0;
-        }
-        /*If LS version exists in config file*/
-        if(num != 0)
-        {
-            ls_version = num;
-        }
+  if (nfcFL.nfcNxpEse) {
+    if (NfcConfig::hasKey(NAME_NXP_LOADER_SERICE_VERSION)) {
+      num = NfcConfig::getUnsigned(NAME_NXP_LOADER_SERICE_VERSION);
+    } else {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("LOADER_SERVICE_VERSION not found");
+      num = 0;
     }
-    else {
-        ALOGV("%s: No P61", __func__);
+    /*If LS version exists in config file*/
+    if (num != 0) {
+      ls_version = num;
     }
+  } else {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: No P61", __func__);
+  }
 #endif
-    ALOGV("%s: exit", __func__);
-    return ls_version;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  return ls_version;
 }
 
 /*****************************************************************************
@@ -587,27 +580,22 @@ int nfcManager_getLoaderServiceConfVersion(JNIEnv* /* e */, jobject /* o */)
  ** Description:     JNI functions
  **
  *****************************************************************************/
-static JNINativeMethod gMethods[] =
-{
-    {"doLsExecuteScript","(Ljava/lang/String;Ljava/lang/String;[B)[B",
-                (void *)nfcManager_lsExecuteScript},
-    {"doLsGetVersion","()[B",
-                (void *)nfcManager_lsGetVersion},
-    {"doLsGetStatus","()[B",
-      (void *)nfcManager_lsGetStatus},
-    {"doLsGetAppletStatus","()[B",
-      (void *)nfcManager_lsGetAppletStatus},
+static JNINativeMethod gMethods[] = {
+    {"doLsExecuteScript", "(Ljava/lang/String;Ljava/lang/String;[B)[B",
+     (void*)nfcManager_lsExecuteScript},
+    {"doLsGetVersion", "()[B", (void*)nfcManager_lsGetVersion},
+    {"doLsGetStatus", "()[B", (void*)nfcManager_lsGetStatus},
+    {"doLsGetAppletStatus", "()[B", (void*)nfcManager_lsGetAppletStatus},
     {"doGetLSConfigVersion", "()I",
-       (void *)nfcManager_getLoaderServiceConfVersion},
+     (void*)nfcManager_getLoaderServiceConfVersion},
 
     {"GetAppletsList", "([Ljava/lang/String;)I",
-                (void *)nfcManager_GetAppletsList},
+     (void*)nfcManager_GetAppletsList},
 
     {"doAppletLoadApplet", "(Ljava/lang/String;[B)I",
-                (void *)nfcManager_doAppletLoadApplet},
+     (void*)nfcManager_doAppletLoadApplet},
 
-    {"GetCertificateKey", "()[B",
-                (void *)nfcManager_GetCertificateKey},
+    {"GetCertificateKey", "()[B", (void*)nfcManager_GetCertificateKey},
 };
 
 /*******************************************************************************
@@ -620,9 +608,8 @@ static JNINativeMethod gMethods[] =
  ** Returns:         Status of registration.
  **
  *******************************************************************************/
-int register_com_android_nfc_NativeNfcAla(JNIEnv *e)
-{
-    return jniRegisterNativeMethods(e, gNativeNfcAlaClassName,
-            gMethods, NELEM(gMethods));
+int register_com_android_nfc_NativeNfcAla(JNIEnv* e) {
+  return jniRegisterNativeMethods(e, gNativeNfcAlaClassName, gMethods,
+                                  NELEM(gMethods));
 }
 } /*namespace android*/
diff --git a/nci/jni/NativeNfcManager.cpp b/nci/jni/NativeNfcManager.cpp
index b5f89bd7..db297f52 100644
--- a/nci/jni/NativeNfcManager.cpp
+++ b/nci/jni/NativeNfcManager.cpp
@@ -4,7 +4,7 @@
  *  Copyright (c) 2016, The Linux Foundation. All rights reserved.
  *  Not a Contribution.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *  The original Work has been changed by NXP Semiconductors.
  *
  *  Copyright (C) 2012 The Android Open Source Project
@@ -22,404 +22,451 @@
  *  limitations under the License.
  *
  ******************************************************************************/
-#include <semaphore.h>
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+#include <cutils/properties.h>
 #include <errno.h>
-#include "_OverrideLog.h"
-#include "NfcJniUtil.h"
-#include "NfcAdaptation.h"
-#include "SyncEvent.h"
-#include "PeerToPeer.h"
-#include "SecureElement.h"
-#include "RoutingManager.h"
-#include "NfcTag.h"
-#include "config.h"
-#include "PowerSwitch.h"
-#include "JavaClassConstants.h"
-#include "Pn544Interop.h"
 #include <nativehelper/ScopedLocalRef.h>
-#include <nativehelper/ScopedUtfChars.h>
 #include <nativehelper/ScopedPrimitiveArray.h>
+#include <nativehelper/ScopedUtfChars.h>
+#include <pthread.h>
+#include <semaphore.h>
 #include <sys/time.h>
+#include "HciEventManager.h"
 #include "HciRFParams.h"
-#include <pthread.h>
-#if(NXP_EXTNS == TRUE)
+#include "JavaClassConstants.h"
+#include "NfcAdaptation.h"
+#include "NfcJniUtil.h"
+#include "NfcTag.h"
+#include "PeerToPeer.h"
+#include "Pn544Interop.h"
+#include "PowerSwitch.h"
+#include "RoutingManager.h"
+#include "SecureElement.h"
+#include "SyncEvent.h"
+#include "nfc_config.h"
+#if (NXP_EXTNS == TRUE)
+#include <cutils/properties.h>
 #include <signal.h>
 #include <sys/types.h>
+#include "MposManager.h"
 #endif
+#include <fcntl.h>
 #include "DwpChannel.h"
+#include "JcopManager.h"
 #include "TransactionController.h"
-#include <fcntl.h>
-extern "C"
-{
-    #include "nfc_api.h"
-    #include "nfa_api.h"
-    #include "nfa_p2p_api.h"
-    #include "rw_api.h"
-    #include "nfa_ee_api.h"
-    #include "nfc_brcm_defs.h"
-    #include "ce_api.h"
-    #include "phNxpExtns.h"
-    #include "phNxpConfig.h"
-
-#if(NXP_EXTNS == TRUE)
-    #include "JcDnld.h"
-    #include "IChannel.h"
-#endif
-}
-#define ALOGV ALOGD
+#include "ce_api.h"
+#include "nfa_api.h"
+#include "nfa_ee_api.h"
+#include "nfa_p2p_api.h"
+#include "nfc_api.h"
+#include "nfc_brcm_defs.h"
+#include "phNxpConfig.h"
+#include "phNxpExtns.h"
+#include "rw_api.h"
+
+using android::base::StringPrintf;
+
 #define SAK_VALUE_AT 17
-extern bool                   gReaderNotificationflag;
-extern const uint8_t          nfca_version_string [];
-extern const uint8_t          nfa_version_string [];
 extern tNFA_DM_DISC_FREQ_CFG* p_nfa_dm_rf_disc_freq_cfg;
-bool                          sHCEEnabled = true;
-
-#if(NXP_EXTNS == TRUE)
-#define RETRY_COUNT         0x10
-#define DEFAULT_COUNT       0x03
-#define ENABLE_DISCOVERY    0x01
-#define DISABLE_DISCOVERY   0x02
-#define ENABLE_P2P          0x04
-#define T3T_CONFIGURE       0x08
-#define RE_ROUTING          0x10
-#define CLEAR_ENABLE_DISABLE_PARAM   0xFC
+bool sHCEEnabled = true;
+#define RDR_PASS_THRU_MODE_DISABLE (0x0)
+#define RDR_PASS_THRU_MODE_ENABLE (0x1)
+#define RDR_PASS_THRU_MODE_XCV (0x2)
+#define RDR_PASS_THRU_ENABLE_TIMEOUT (1030)
+#define RDR_PASS_THRU_DISABLE_TIMEOUT (1030)
+#define RDR_PASS_THRU_XCV_TIMEOUT (1100)
+
+#define RDR_PASS_THRU_MOD_TYPE_A (0x0)
+#define RDR_PASS_THRU_MOD_TYPE_B (0x1)
+#define RDR_PASS_THRU_MOD_TYPE_V (0x2)
+#define RDR_PASS_THRU_MOD_TYPE_LIMIT (0x3)
+#define CMD_HDR_SIZE_XCV (0x3)
+#if (NXP_EXTNS == TRUE)
+#define RETRY_COUNT 0x10
+#define DEFAULT_COUNT 0x03
+#define ENABLE_DISCOVERY 0x01
+#define DISABLE_DISCOVERY 0x02
+#define ENABLE_P2P 0x04
+#define T3T_CONFIGURE 0x08
+#define RE_ROUTING 0x10
+#define CLEAR_ENABLE_DISABLE_PARAM 0xFC
 /* Delay to wait for SE intialization */
-#define SE_INIT_DELAY       50*1000
-#define NFCEE_DISC_TIMEOUT_SEC      2
-#define JCOP_INFO_PATH              "/data/nfc/jcop_info.txt"
-#define OSU_NOT_STARTED             00
-#define OSU_COMPLETE                03
-#define NFC_PIPE_STATUS_OFFSET       4
+#define SE_INIT_DELAY 50 * 1000
+#define NFCEE_DISC_TIMEOUT_SEC 2
+#define JCOP_INFO_PATH "/data/nfc/jcop_info.txt"
+#define OSU_NOT_STARTED 00
+#define OSU_COMPLETE 03
+#define NFC_PIPE_STATUS_OFFSET 4
 #define MAX_JCOP_TIMEOUT_VALUE 60000 /*Maximum Jcop OSU timeout value*/
-#define MAX_WAIT_TIME_FOR_RETRY 8 /*Maximum wait for retry in usec*/
-extern nfcee_disc_state     sNfcee_disc_state;
-extern bool                 recovery;
-extern uint8_t              swp_getconfig_status;
-extern int                  gUICCVirtualWiredProtectMask;
-extern int                  gEseVirtualWiredProtectMask;
-static int32_t              gNfcInitTimeout;
-int32_t                     gdisc_timeout;
-int32_t                     gSeDiscoverycount = 0;
-int32_t                     gActualSeCount = 0;
-uint16_t                    sCurrentSelectedUICCSlot = 1;
-SyncEvent                   gNfceeDiscCbEvent;
-uint8_t                     sSelectedUicc = 0;
-extern Rdr_req_ntf_info_t   swp_rdr_req_ntf_info;
-Mutex gDiscMutex;
+#define MAX_WAIT_TIME_FOR_RETRY 8    /*Maximum wait for retry in usec*/
+#define ESE_PWR_MGMT_PROP "ro.config.low_ram"
+#define IS_ESE_RF_CE_PARAM_FETCHED()             \
+  (pEvtData->get_config.param_tlvs[1] == 0xA0 && \
+   pEvtData->get_config.param_tlvs[2] == 0xF0)
+#define IS_ESE_CE_MODE_DISABLED()                \
+  (pEvtData->get_config.param_tlvs[5] == 0xFF || \
+   pEvtData->get_config.param_tlvs[43] == 0xFF)
+
+
+extern nfcee_disc_state sNfcee_disc_state;
+extern bool recovery;
+extern uint8_t swp_getconfig_status;
+extern int gUICCVirtualWiredProtectMask;
+extern int gEseVirtualWiredProtectMask;
+extern bool IsEseCeDisabled;
+static int32_t gNfcInitTimeout;
+int32_t gdisc_timeout;
+int32_t gSeDiscoverycount = 0;
+int32_t gActualSeCount = 0;
+uint16_t sCurrentSelectedUICCSlot = 1;
+SyncEvent gNfceeDiscCbEvent;
+uint8_t sSelectedUicc = 0;
+static bool sIsLowRamDevice = false;
+int32_t gSelfTestType = TEST_TYPE_NONE;
 bool nfcManager_getTransanctionRequest(int t3thandle, bool registerRequest);
 extern bool createSPIEvtHandlerThread();
 extern void releaseSPIEvtHandlerThread();
 #endif
-namespace android
-{
-    extern bool gIsTagDeactivating;
-    extern bool gIsSelectingRfInterface;
-    extern void nativeNfcTag_doTransceiveStatus (tNFA_STATUS status, uint8_t * buf, uint32_t buflen);
-    extern void nativeNfcTag_notifyRfTimeout ();
-    extern void nativeNfcTag_doConnectStatus (jboolean is_connect_ok);
-    extern void nativeNfcTag_doDeactivateStatus (int status);
-    extern void nativeNfcTag_doWriteStatus (jboolean is_write_ok);
-    extern void nativeNfcTag_doCheckNdefResult (tNFA_STATUS status, uint32_t max_size, uint32_t current_size, uint8_t flags);
-    extern void nativeNfcTag_doMakeReadonlyResult (tNFA_STATUS status);
-    extern void nativeNfcTag_doPresenceCheckResult (tNFA_STATUS status);
-    extern void nativeNfcTag_formatStatus (bool is_ok);
-    extern void nativeNfcTag_resetPresenceCheck ();
-    extern void nativeNfcTag_doReadCompleted (tNFA_STATUS status);
-    extern void nativeNfcTag_setRfInterface (tNFA_INTF_TYPE rfInterface);
-    extern void nativeNfcTag_abortWaits ();
-    extern void doDwpChannel_ForceExit();
-    extern void nativeLlcpConnectionlessSocket_abortWait ();
-    extern tNFA_STATUS EmvCo_dosetPoll(jboolean enable);
-    extern void nativeNfcTag_registerNdefTypeHandler ();
-    extern void nativeLlcpConnectionlessSocket_receiveData (uint8_t* data, uint32_t len, uint32_t remote_sap);
-    extern tNFA_STATUS SetScreenState(int state);
-    extern tNFA_STATUS SendAutonomousMode(int state , uint8_t num);
-    //Factory Test Code --start
-    extern tNFA_STATUS Nxp_SelfTest(uint8_t testcase, uint8_t* param);
-    extern void SetCbStatus(tNFA_STATUS status);
-    extern tNFA_STATUS GetCbStatus(void);
-    static void nfaNxpSelfTestNtfTimerCb (union sigval);
-    extern tNFA_STATUS ResetEseSession();
-    //Factory Test Code --end
-    extern bool getReconnectState(void);
-    extern tNFA_STATUS SetVenConfigValue(jint nfcMode);
-    extern tNFA_STATUS SetHfoConfigValue(void);
-    extern tNFA_STATUS SetUICC_SWPBitRate(bool);
-    extern tNFA_STATUS GetNumNFCEEConfigured(void);
-    extern void acquireRfInterfaceMutexLock();
-    extern void releaseRfInterfaceMutexLock();
-    extern tNFA_STATUS NxpNfc_Write_Cmd_Common(uint8_t retlen, uint8_t* buffer);
-#if(NXP_EXTNS == TRUE)
-    extern bool gIsWaiting4Deact2SleepNtf;
-    extern bool gGotDeact2IdleNtf;
-    bool nfcManager_isTransanctionOnGoing(bool isInstallRequest);
-    bool nfcManager_isRequestPending(void);
-    extern tNFA_STATUS enableSWPInterface();
-    extern tNFA_STATUS NxpNfc_Send_CoreResetInit_Cmd(void);
-    jmethodID gCachedNfcManagerNotifyFwDwnldRequested;
-    extern tNFA_STATUS SendAGCDebugCommand();
-    extern tNFA_STATUS Set_EERegisterValue(uint16_t RegAddr, uint8_t bitVal);
-    extern void nativeNfcTag_cacheNonNciCardDetection();
-    extern void nativeNfcTag_handleNonNciCardDetection(tNFA_CONN_EVT_DATA* eventData);
-    extern void nativeNfcTag_handleNonNciMultiCardDetection(uint8_t connEvent, tNFA_CONN_EVT_DATA* eventData);
-    extern uint8_t checkTagNtf;
-    extern uint8_t checkCmdSent;
+namespace android {
+extern bool gIsTagDeactivating;
+extern bool gIsSelectingRfInterface;
+extern void nativeNfcTag_doTransceiveStatus(tNFA_STATUS status, uint8_t* buf,
+                                            uint32_t buflen);
+extern void nativeNfcTag_notifyRfTimeout();
+extern void nativeNfcTag_doConnectStatus(jboolean is_connect_ok);
+extern void nativeNfcTag_doDeactivateStatus(int status);
+extern void nativeNfcTag_doWriteStatus(jboolean is_write_ok);
+extern jboolean nativeNfcTag_doDisconnect(JNIEnv*, jobject);
+extern void nativeNfcTag_doCheckNdefResult(tNFA_STATUS status,
+                                           uint32_t max_size,
+                                           uint32_t current_size,
+                                           uint8_t flags);
+extern void nativeNfcTag_doMakeReadonlyResult(tNFA_STATUS status);
+extern void nativeNfcTag_doPresenceCheckResult(tNFA_STATUS status);
+extern void nativeNfcTag_formatStatus(bool is_ok);
+extern void nativeNfcTag_resetPresenceCheck();
+extern void nativeNfcTag_doReadCompleted(tNFA_STATUS status);
+extern void nativeNfcTag_setRfInterface(tNFA_INTF_TYPE rfInterface);
+extern void nativeNfcTag_abortWaits();
+extern void doDwpChannel_ForceExit();
+extern void nativeLlcpConnectionlessSocket_abortWait();
+extern tNFA_STATUS EmvCo_dosetPoll(jboolean enable);
+extern void nativeNfcTag_registerNdefTypeHandler();
+extern void nativeLlcpConnectionlessSocket_receiveData(uint8_t* data,
+                                                       uint32_t len,
+                                                       uint32_t remote_sap);
+extern tNFA_STATUS SetScreenState(int state);
+extern tNFA_STATUS SendAutonomousMode(int state, uint8_t num);
+// Factory Test Code --start
+extern tNFA_STATUS Nxp_SelfTest(uint8_t testcase, uint8_t* param);
+extern void SetCbStatus(tNFA_STATUS status);
+extern tNFA_STATUS GetCbStatus(void);
+static void nfaNxpSelfTestNtfTimerCb(union sigval);
+extern tNFA_STATUS ResetEseSession();
+// Factory Test Code --end
+extern bool getReconnectState(void);
+extern tNFA_STATUS SetVenConfigValue(jint nfcMode);
+extern tNFA_STATUS SetHfoConfigValue(void);
+extern tNFA_STATUS SetUICC_SWPBitRate(bool);
+extern tNFA_STATUS GetNumNFCEEConfigured(void);
+extern void nativeNfcTag_acquireRfInterfaceMutexLock();
+extern void nativeNfcTag_releaseRfInterfaceMutexLock();
+extern tNFA_STATUS NxpNfc_Write_Cmd_Common(uint8_t retlen, uint8_t* buffer);
+#if (NXP_EXTNS == TRUE)
+extern bool gIsWaiting4Deact2SleepNtf;
+extern bool gGotDeact2IdleNtf;
+bool nfcManager_isTransanctionOnGoing(bool isInstallRequest);
+bool nfcManager_isRequestPending(void);
+extern tNFA_STATUS enableSWPInterface();
+extern tNFA_STATUS NxpNfc_Send_CoreResetInit_Cmd(void);
+jmethodID gCachedNfcManagerNotifyFwDwnldRequested;
+extern tNFA_STATUS SendAGCDebugCommand();
+extern tNFA_STATUS Set_EERegisterValue(uint16_t RegAddr, uint8_t bitVal);
+extern void nativeNfcTag_cacheNonNciCardDetection();
+extern void nativeNfcTag_handleNonNciCardDetection(
+    tNFA_CONN_EVT_DATA* eventData);
+extern void nativeNfcTag_handleNonNciMultiCardDetection(
+    uint8_t connEvent, tNFA_CONN_EVT_DATA* eventData);
+extern tNFA_STATUS NxpNfcUpdateEeprom(uint8_t* param, uint8_t len,
+                                      uint8_t* val);
+extern uint8_t checkTagNtf;
+extern uint8_t checkCmdSent;
 #endif
-}
-
+}  // namespace android
 
 /*****************************************************************************
 **
 ** public variables and functions
 **
 *****************************************************************************/
-bool                        gActivated = false;
-SyncEvent                   gDeactivatedEvent;
-
-namespace android
-{
-    int                     gGeneralPowershutDown = 0;
-    jmethodID               gCachedNfcManagerNotifyNdefMessageListeners;
-    jmethodID               gCachedNfcManagerNotifyTransactionListeners;
-    jmethodID               gCachedNfcManagerNotifyConnectivityListeners;
-    jmethodID               gCachedNfcManagerNotifyEmvcoMultiCardDetectedListeners;
-    jmethodID               gCachedNfcManagerNotifyLlcpLinkActivation;
-    jmethodID               gCachedNfcManagerNotifyLlcpLinkDeactivated;
-    jmethodID               gCachedNfcManagerNotifyLlcpFirstPacketReceived;
-    jmethodID               gCachedNfcManagerNotifySeFieldActivated;
-    jmethodID               gCachedNfcManagerNotifySeFieldDeactivated;
-    jmethodID               gCachedNfcManagerNotifySeListenActivated;
-    jmethodID               gCachedNfcManagerNotifySeListenDeactivated;
-    jmethodID               gCachedNfcManagerNotifyHostEmuActivated;
-    jmethodID               gCachedNfcManagerNotifyHostEmuData;
-    jmethodID               gCachedNfcManagerNotifyHostEmuDeactivated;
-    jmethodID               gCachedNfcManagerNotifyRfFieldActivated;
-    jmethodID               gCachedNfcManagerNotifyRfFieldDeactivated;
-    jmethodID               gCachedNfcManagerNotifySWPReaderRequested;
-    jmethodID               gCachedNfcManagerNotifySWPReaderRequestedFail;
-    jmethodID               gCachedNfcManagerNotifySWPReaderActivated;
-    jmethodID               gCachedNfcManagerNotifyAidRoutingTableFull;
-#if(NXP_EXTNS == TRUE)
-    int                     gMaxEERecoveryTimeout = MAX_EE_RECOVERY_TIMEOUT;
-    jmethodID               gCachedNfcManagerNotifyETSIReaderModeStartConfig;
-    jmethodID               gCachedNfcManagerNotifyETSIReaderModeStopConfig;
-    jmethodID               gCachedNfcManagerNotifyETSIReaderModeSwpTimeout;
-    jmethodID               gCachedNfcManagerNotifyUiccStatusEvent;
-    jmethodID               gCachedNfcManagerNotifyT3tConfigure;
-    jmethodID               gCachedNfcManagerNotifyJcosDownloadInProgress;
-    jmethodID               gCachedNfcManagerNotifyReRoutingEntry;
+bool gActivated = false;
+SyncEvent gDeactivatedEvent;
+
+namespace android {
+int gGeneralPowershutDown = 0;
+jmethodID gCachedNfcManagerNotifyNdefMessageListeners;
+jmethodID gCachedNfcManagerNotifyTransactionListeners;
+jmethodID gCachedNfcManagerNotifyConnectivityListeners;
+jmethodID gCachedNfcManagerNotifyEmvcoMultiCardDetectedListeners;
+jmethodID gCachedNfcManagerNotifyLlcpLinkActivation;
+jmethodID gCachedNfcManagerNotifyLlcpLinkDeactivated;
+jmethodID gCachedNfcManagerNotifyLlcpFirstPacketReceived;
+jmethodID gCachedNfcManagerNotifySeFieldActivated;
+jmethodID gCachedNfcManagerNotifySeFieldDeactivated;
+jmethodID gCachedNfcManagerNotifySeListenActivated;
+jmethodID gCachedNfcManagerNotifySeListenDeactivated;
+jmethodID gCachedNfcManagerNotifyHostEmuActivated;
+jmethodID gCachedNfcManagerNotifyHostEmuData;
+jmethodID gCachedNfcManagerNotifyHostEmuDeactivated;
+jmethodID gCachedNfcManagerNotifyRfFieldActivated;
+jmethodID gCachedNfcManagerNotifyRfFieldDeactivated;
+jmethodID gCachedNfcManagerNotifyAidRoutingTableFull;
+#if (NXP_EXTNS == TRUE)
+int gMaxEERecoveryTimeout = MAX_EE_RECOVERY_TIMEOUT;
+jmethodID gCachedNfcManagerNotifyUiccStatusEvent;
+jmethodID gCachedNfcManagerNotifyT3tConfigure;
+jmethodID gCachedNfcManagerNotifyJcosDownloadInProgress;
+jmethodID gCachedNfcManagerNotifyReRoutingEntry;
 #endif
-    const char*             gNativeP2pDeviceClassName                 = "com/android/nfc/dhimpl/NativeP2pDevice";
-    const char*             gNativeLlcpServiceSocketClassName         = "com/android/nfc/dhimpl/NativeLlcpServiceSocket";
-    const char*             gNativeLlcpConnectionlessSocketClassName  = "com/android/nfc/dhimpl/NativeLlcpConnectionlessSocket";
-    const char*             gNativeLlcpSocketClassName                = "com/android/nfc/dhimpl/NativeLlcpSocket";
-    const char*             gNativeNfcTagClassName                    = "com/android/nfc/dhimpl/NativeNfcTag";
-    const char*             gNativeNfcManagerClassName                = "com/android/nfc/dhimpl/NativeNfcManager";
-    const char*             gNativeNfcSecureElementClassName          = "com/android/nfc/dhimpl/NativeNfcSecureElement";
-    const char*             gNativeNfcAlaClassName                    = "com/android/nfc/dhimpl/NativeNfcAla";
-    void                    doStartupConfig ();
-    void                    startStopPolling (bool isStartPolling);
-    void                    startRfDiscovery (bool isStart);
-    void                    setUiccIdleTimeout (bool enable);
-    bool                    isDiscoveryStarted ();
-    void                    requestFwDownload();
-}
-
+const char* gNativeP2pDeviceClassName =
+    "com/android/nfc/dhimpl/NativeP2pDevice";
+const char* gNativeLlcpServiceSocketClassName =
+    "com/android/nfc/dhimpl/NativeLlcpServiceSocket";
+const char* gNativeLlcpConnectionlessSocketClassName =
+    "com/android/nfc/dhimpl/NativeLlcpConnectionlessSocket";
+const char* gNativeLlcpSocketClassName =
+    "com/android/nfc/dhimpl/NativeLlcpSocket";
+const char* gNativeNfcTagClassName = "com/android/nfc/dhimpl/NativeNfcTag";
+const char* gNativeNfcManagerClassName =
+    "com/android/nfc/dhimpl/NativeNfcManager";
+const char* gNativeNfcSecureElementClassName =
+    "com/android/nfc/dhimpl/NativeNfcSecureElement";
+const char* gNativeNfcAlaClassName = "com/android/nfc/dhimpl/NativeNfcAla";
+const char* gNativeNfcMposManagerClassName =
+    "com/android/nfc/dhimpl/NativeNfcMposManager";
+void doStartupConfig();
+void startStopPolling(bool isStartPolling);
+void startRfDiscovery(bool isStart);
+void setUiccIdleTimeout(bool enable);
+bool isDiscoveryStarted();
+void requestFwDownload();
+#if (NXP_EXTNS == TRUE)
+void enableRfDiscovery();
+void disableRfDiscovery();
+void storeLastDiscoveryParams(int technologies_mask, bool enable_lptd,
+                              bool reader_mode, bool enable_p2p, bool restart);
+static tNFA_STATUS configureListening(uint8_t aListenMask);
+static tNFA_STATUS configurePolling(uint8_t aPollMask);
+static tNFA_STATUS performRFTest(bool on);
+static tNFA_STATUS performTransacAB(uint8_t aType);
+static void activatedNtf_Cb();
+#endif
+}  // namespace android
 
 /*****************************************************************************
 **
 ** private variables and functions
 **
 *****************************************************************************/
-namespace android
-{
-static jint                 sLastError = ERROR_BUFFER_TOO_SMALL;
-static jmethodID            sCachedNfcManagerNotifySeApduReceived;
-static jmethodID            sCachedNfcManagerNotifySeMifareAccess;
-static jmethodID            sCachedNfcManagerNotifySeEmvCardRemoval;
-static jmethodID            sCachedNfcManagerNotifyTargetDeselected;
-static SyncEvent            sNfaEnableEvent;  //event for NFA_Enable()
-static SyncEvent            sNfaDisableEvent;  //event for NFA_Disable()
-SyncEvent                   sNfaEnableDisablePollingEvent;  //event for NFA_EnablePolling(), NFA_DisablePolling()
-SyncEvent                   sNfaSetConfigEvent;  // event for Set_Config....
-SyncEvent                   sNfaGetConfigEvent;  // event for Get_Config....
-
-static bool                 sIsNfaEnabled = false;
-static bool                 sDiscoveryEnabled = false;  //is polling or listening
-static bool                 sPollingEnabled = false;  //is polling for tag?
-static bool                 sIsDisabling = false;
-static bool                 sRfEnabled = false; // whether RF discovery is enabled
-static bool                 sSeRfActive = false;  // whether RF with SE is likely active
-static bool                 sReaderModeEnabled = false; // whether we're only reading tags, not allowing P2p/card emu
-static bool                 sP2pEnabled = false;
-static bool                 sP2pActive = false; // whether p2p was last active
-static bool                 sAbortConnlessWait = false;
-static jint                 sLfT3tMax = 0;
-
-static uint8_t              sIsSecElemSelected = 0;  //has NFC service selected a sec elem
-static uint8_t              sIsSecElemDetected = 0;  //has NFC service deselected a sec elem
-static bool                 sDiscCmdwhleNfcOff = false;
-static uint8_t              sAutonomousSet = 0;
-
-#define CONFIG_UPDATE_TECH_MASK     (1 << 1)
-#define TRANSACTION_TIMER_VALUE     50
-#define DEFAULT_TECH_MASK           (NFA_TECHNOLOGY_MASK_A \
-                                     | NFA_TECHNOLOGY_MASK_B \
-                                     | NFA_TECHNOLOGY_MASK_F \
-                                     | NFA_TECHNOLOGY_MASK_ISO15693 \
-                                     | NFA_TECHNOLOGY_MASK_B_PRIME \
-                                     | NFA_TECHNOLOGY_MASK_A_ACTIVE \
-                                     | NFA_TECHNOLOGY_MASK_F_ACTIVE \
-                                     | NFA_TECHNOLOGY_MASK_KOVIO)
-#define DEFAULT_DISCOVERY_DURATION       500
-#define READER_MODE_DISCOVERY_DURATION   200
-#if(NXP_EXTNS == TRUE)
-static bool                 gsNfaPartialEnabled = false;
-static uint16_t             sEnableStatus = false;
-SyncEvent                   sNfaGetRoutingEvent;  // event for Get_Routing....
-static bool                 sProvisionMode = false;
-SyncEvent                   sNfceeHciCbEnableEvent;
-SyncEvent                   sNfceeHciCbDisableEvent;
-#define DUAL_UICC_FEATURE_NOT_AVAILABLE   0xED;
-#define STATUS_UNKNOWN_ERROR              0xEF;
-
-enum
-{
-    UICC_CONFIGURED,
-    UICC_NOT_CONFIGURED
-};
-typedef enum dual_uicc_error_states{
-    DUAL_UICC_ERROR_NFCC_BUSY = 0x02,
-    DUAL_UICC_ERROR_SELECT_FAILED,
-    DUAL_UICC_ERROR_NFC_TURNING_OFF,
-    DUAL_UICC_ERROR_INVALID_SLOT,
-    DUAL_UICC_ERROR_STATUS_UNKNOWN
-}dual_uicc_error_state_t;
+namespace android {
+static jint sLastError = ERROR_BUFFER_TOO_SMALL;
+static jmethodID sCachedNfcManagerNotifySeApduReceived;
+static jmethodID sCachedNfcManagerNotifySeMifareAccess;
+static jmethodID sCachedNfcManagerNotifySeEmvCardRemoval;
+static jmethodID sCachedNfcManagerNotifyTargetDeselected;
+static SyncEvent sNfaEnableEvent;         // event for NFA_Enable()
+static SyncEvent sNfaDisableEvent;        // event for NFA_Disable()
+static SyncEvent sNfaTransitConfigEvent;  // event for NFA_SetTransitConfig()
+SyncEvent sNfaEnableDisablePollingEvent;  // event for NFA_EnablePolling(),
+                                          // NFA_DisablePolling()
+SyncEvent sNfaSetConfigEvent;             // event for Set_Config....
+SyncEvent sNfaGetConfigEvent;             // event for Get_Config....
+SyncEvent sExecPendingRegEvent;
+
+static bool sIsExecPendingReq = false;
+static bool sIsNfaEnabled = false;
+static bool sDiscoveryEnabled = false;  // is polling or listening
+static bool sPollingEnabled = false;    // is polling for tag?
+static bool sIsDisabling = false;
+static bool sRfEnabled = false;   // whether RF discovery is enabled
+static bool sSeRfActive = false;  // whether RF with SE is likely active
+static bool sReaderModeEnabled =
+    false;  // whether we're only reading tags, not allowing P2p/card emu
+static bool sP2pEnabled = false;
+static bool sP2pActive = false;  // whether p2p was last active
+static bool sAbortConnlessWait = false;
+static jint sLfT3tMax = 0;
+
+static uint8_t sIsSecElemSelected = 0;  // has NFC service selected a sec elem
+static uint8_t sIsSecElemDetected = 0;  // has NFC service deselected a sec elem
+static bool sDiscCmdwhleNfcOff = false;
+static uint8_t sAutonomousSet = 0;
+
+#define CONFIG_UPDATE_TECH_MASK (1 << 1)
+#define TRANSACTION_TIMER_VALUE 50
+#define DEFAULT_TECH_MASK                                                  \
+  (NFA_TECHNOLOGY_MASK_A | NFA_TECHNOLOGY_MASK_B | NFA_TECHNOLOGY_MASK_F | \
+   NFA_TECHNOLOGY_MASK_V | NFA_TECHNOLOGY_MASK_B_PRIME |                   \
+   NFA_TECHNOLOGY_MASK_A_ACTIVE | NFA_TECHNOLOGY_MASK_F_ACTIVE |           \
+   NFA_TECHNOLOGY_MASK_KOVIO)
+#define DEFAULT_DISCOVERY_DURATION 500
+#define READER_MODE_DISCOVERY_DURATION 200
+#if (NXP_EXTNS == TRUE)
+static bool gsNfaPartialEnabled = false;
+static uint16_t sEnableStatus = false;
+SyncEvent sNfaGetRoutingEvent;  // event for Get_Routing....
+static SyncEvent mSelfTestTransacAB;  // Event for Get activation
+static bool sProvisionMode = false;
+SyncEvent sNfceeHciCbEnableEvent;
+SyncEvent sNfceeHciCbDisableEvent;
+#define DUAL_UICC_FEATURE_NOT_AVAILABLE 0xED;
+#define STATUS_UNKNOWN_ERROR 0xEF;
+
+enum { UICC_CONFIGURED, UICC_NOT_CONFIGURED };
+typedef enum dual_uicc_error_states {
+  DUAL_UICC_ERROR_NFCC_BUSY = 0x02,
+  DUAL_UICC_ERROR_SELECT_FAILED,
+  DUAL_UICC_ERROR_NFC_TURNING_OFF,
+  DUAL_UICC_ERROR_INVALID_SLOT,
+  DUAL_UICC_ERROR_STATUS_UNKNOWN
+} dual_uicc_error_state_t;
 static tNFA_STATUS nfcManagerEnableNfc(NfcAdaptation& theInstance);
+static int nfcManager_setTransitConfig(JNIEnv* e, jobject o, jstring config);
 #endif
 
 static int screenstate = NFA_SCREEN_STATE_OFF_LOCKED;
 static bool pendingScreenState = false;
-static void nfcManager_doSetScreenState(JNIEnv* e, jobject o, jint screen_state_mask);
-static jint nfcManager_doGetNciVersion(JNIEnv* , jobject);
+static void nfcManager_doSetScreenState(JNIEnv* e, jobject o,
+                                        jint screen_state_mask);
+static jint nfcManager_doGetNciVersion(JNIEnv*, jobject);
 static int NFA_SCREEN_POLLING_TAG_MASK = 0x10;
-static void nfcManager_doSetScreenOrPowerState (JNIEnv* e, jobject o, jint state);
+static void nfcManager_doSetScreenOrPowerState(JNIEnv* e, jobject o,
+                                               jint state);
 static void StoreScreenState(int state);
 int getScreenState();
-static void nfaConnectionCallback (uint8_t event, tNFA_CONN_EVT_DATA *eventData);
-static void nfaDeviceManagementCallback (uint8_t event, tNFA_DM_CBACK_DATA *eventData);
-static bool isPeerToPeer (tNFA_ACTIVATED& activated);
+static void nfaConnectionCallback(uint8_t event, tNFA_CONN_EVT_DATA* eventData);
+static void nfaDeviceManagementCallback(uint8_t event,
+                                        tNFA_DM_CBACK_DATA* eventData);
+static bool isPeerToPeer(tNFA_ACTIVATED& activated);
 static bool isListenMode(tNFA_ACTIVATED& activated);
-static void enableDisableLptd (bool enable);
 static tNFA_STATUS stopPolling_rfDiscoveryDisabled();
-static tNFA_STATUS startPolling_rfDiscoveryDisabled(tNFA_TECHNOLOGY_MASK tech_mask);
+static tNFA_STATUS startPolling_rfDiscoveryDisabled(
+    tNFA_TECHNOLOGY_MASK tech_mask);
 
 static int nfcManager_getChipVer(JNIEnv* e, jobject o);
 static jbyteArray nfcManager_getFwFileName(JNIEnv* e, jobject o);
+static std::string ConvertJavaStrToStdString(JNIEnv* env, jstring s);
 static int nfcManager_getNfcInitTimeout(JNIEnv* e, jobject o);
 static int nfcManager_doJcosDownload(JNIEnv* e, jobject o);
 static void nfcManager_doCommitRouting(JNIEnv* e, jobject o);
-static void nfcManager_doSetVenConfigValue (JNIEnv *e, jobject o, jint venconfig);
 static jint nfcManager_getSecureElementTechList(JNIEnv* e, jobject o);
-static void nfcManager_setSecureElementListenTechMask(JNIEnv *e, jobject o, jint tech_mask);
+static void nfcManager_setSecureElementListenTechMask(JNIEnv* e, jobject o,
+                                                      jint tech_mask);
 static void notifyPollingEventwhileNfcOff();
 
 static uint8_t getJCOPOS_UpdaterState();
-void DWPChannel_init(IChannel_t *DWP);
+void DWPChannel_init(IChannel_t* DWP);
 IChannel_t Dwp;
 static uint16_t sCurrentConfigLen;
 static uint8_t sConfig[256];
 static int prevScreenState = NFA_SCREEN_STATE_OFF_LOCKED;
-#if(NXP_EXTNS == TRUE)
+#if (NXP_EXTNS == TRUE)
 static uint8_t sNfcState = NFC_OFF;
 bool isp2pActivated();
-static void nfcManager_doSetNfcMode (JNIEnv *e, jobject o, jint nfcMode);
-static bool nfcManager_doCheckJCOPOsDownLoad();
-typedef struct
-{
-    uint8_t  sUicc1Cntx[256];
-    uint16_t sUicc1CntxLen;
-    uint8_t  sUicc2Cntx[256];
-    uint16_t sUicc2CntxLen;
-    uint8_t  sUicc1TechCapblty[12];
-    uint8_t  sUicc2TechCapblty[12];
-    uint8_t  sUicc1SessionId[8];
-    uint8_t  sUicc2SessionId[8];
-    uint8_t  sUicc1SessionIdLen;
-    uint8_t  sUicc2SessionIdLen;
-    uint8_t  uiccActivStat = 0;
-    uint8_t  uiccConfigStat = 0;
-    unsigned long  dualUiccEnable = 0;
-}dual_uicc_info_t;
+static void nfcManager_doSetNfcMode(JNIEnv* e, jobject o, jint nfcMode);
+typedef struct {
+  uint8_t sUicc1Cntx[256];
+  uint16_t sUicc1CntxLen;
+  uint8_t sUicc2Cntx[256];
+  uint16_t sUicc2CntxLen;
+  uint8_t sUicc1TechCapblty[12];
+  uint8_t sUicc2TechCapblty[12];
+  uint8_t sUicc1SessionId[8];
+  uint8_t sUicc2SessionId[8];
+  uint8_t sUicc1SessionIdLen;
+  uint8_t sUicc2SessionIdLen;
+  uint8_t uiccActivStat = 0;
+  uint8_t uiccConfigStat = 0;
+  unsigned long dualUiccEnable = 0;
+} dual_uicc_info_t;
 dual_uicc_info_t dualUiccInfo;
-typedef enum
-{
-    UICC_CONNECTED_0,
-    UICC_CONNECTED_1,
-    UICC_CONNECTED_2
-}uicc_enumeration_t;
+typedef enum {
+  UICC_CONNECTED_0,
+  UICC_CONNECTED_1,
+  UICC_CONNECTED_2
+} uicc_enumeration_t;
 
 #endif
-static uint8_t sLongGuardTime[] = { 0x00, 0x20 };
-static uint8_t sDefaultGuardTime[] = { 0x00, 0x11 };
-#if(NXP_EXTNS == TRUE)
-Mutex                       gTransactionMutex;
-const char *                cur_transaction_handle = NULL;
+static uint8_t sLongGuardTime[] = {0x00, 0x20};
+static uint8_t sDefaultGuardTime[] = {0x00, 0x11};
+#if (NXP_EXTNS == TRUE)
+Mutex gTransactionMutex;
+const char* cur_transaction_handle = NULL;
 /*Proprietary cmd sent to HAL to send reader mode flag
-* Last byte of sProprietaryCmdBuf contains ReaderMode flag */
+ * Last byte of sProprietaryCmdBuf contains ReaderMode flag */
 #define PROPRIETARY_CMD_FELICA_READER_MODE 0xFE
-static uint8_t sProprietaryCmdBuf[]={0xFE,0xFE,0xFE,0x00};
+static uint8_t sProprietaryCmdBuf[] = {0xFE, 0xFE, 0xFE, 0x00};
 uint8_t felicaReader_Disc_id;
-static void    NxpResponsePropCmd_Cb(uint8_t event, uint16_t param_len, uint8_t *p_param);
-static int    sTechMask = 0; // Copy of Tech Mask used in doEnableReaderMode
+static void NxpResponsePropCmd_Cb(uint8_t event, uint16_t param_len,
+                                  uint8_t* p_param);
+static int sTechMask = 0;  // Copy of Tech Mask used in doEnableReaderMode
 static SyncEvent sRespCbEvent;
-bool  rfActivation = false;
-static void* pollT3TThread(void *arg);
+bool rfActivation = false;
+static void* pollT3TThread(void* arg);
 static bool switchP2PToT3TRead(uint8_t disc_id);
 static bool isActivatedTypeF(tNFA_ACTIVATED& activated);
-typedef enum felicaReaderMode_state
-{
-    STATE_IDLE = 0x00,
-    STATE_NFCDEP_ACTIVATED_NFCDEP_INTF,
-    STATE_DEACTIVATED_TO_SLEEP,
-    STATE_FRAMERF_INTF_SELECTED,
-}eFelicaReaderModeState_t;
-static eFelicaReaderModeState_t gFelicaReaderState=STATE_IDLE;
+typedef enum felicaReaderMode_state {
+  STATE_IDLE = 0x00,
+  STATE_NFCDEP_ACTIVATED_NFCDEP_INTF,
+  STATE_DEACTIVATED_TO_SLEEP,
+  STATE_FRAMERF_INTF_SELECTED,
+} eFelicaReaderModeState_t;
+static eFelicaReaderModeState_t gFelicaReaderState = STATE_IDLE;
 
 uint16_t sRoutingBuffLen;
 static uint8_t sRoutingBuff[MAX_GET_ROUTING_BUFFER_SIZE];
 static uint8_t sNfceeConfigured;
 static uint8_t sCheckNfceeFlag;
 void checkforNfceeBuffer();
+static uint32_t eSEPhyIntfInResponsive(tNFA_DM_CBACK_DATA* pEvtData);
+static void recoverEseConnectivity();
 void checkforNfceeConfig(uint8_t type);
-static void performHCIInitialization (JNIEnv* e, jobject o);
+static void performHCIInitialization(JNIEnv* e, jobject o);
 void performNfceeETSI12Config();
 tNFA_STATUS getUICC_RF_Param_SetSWPBitRate();
-//self test start
-static IntervalTimer nfaNxpSelfTestNtfTimer; // notification timer for swp self test
-static IntervalTimer uiccEventTimer; // notification timer for uicc select
-static void notifyUiccEvent (union sigval);
+// self test start
+static IntervalTimer
+    nfaNxpSelfTestNtfTimer;           // notification timer for swp self test
+static IntervalTimer uiccEventTimer;  // notification timer for uicc select
+static void notifyUiccEvent(union sigval);
 static SyncEvent sNfaNxpNtfEvent;
-static SyncEvent                   sNfaSetPowerSubState;  // event for power substate
-static void nfaNxpSelfTestNtfTimerCb (union sigval);
+static SyncEvent sNfaSetPowerSubState;  // event for power substate
+static void nfaNxpSelfTestNtfTimerCb(union sigval);
 static int nfcManager_setPreferredSimSlot(JNIEnv* e, jobject o, jint uiccSlot);
 static void nfcManager_doSetEEPROM(JNIEnv* e, jobject o, jbyteArray val);
 static jint nfcManager_getFwVersion(JNIEnv* e, jobject o);
 static jint nfcManager_SWPSelfTest(JNIEnv* e, jobject o, jint ch);
 static void nfcManager_doPrbsOff(JNIEnv* e, jobject o);
-static void nfcManager_doPrbsOn(JNIEnv* e, jobject o, jint prbs, jint hw_prbs, jint tech, jint rate);
+static void nfcManager_doPrbsOn(JNIEnv* e, jobject o, jint prbs, jint hw_prbs,
+                                jint tech, jint rate);
 static void nfcManager_Enablep2p(JNIEnv* e, jobject o, jboolean p2pFlag);
-//self test end
-static void nfcManager_setProvisionMode(JNIEnv* e, jobject o, jboolean provisionMode);
-static bool nfcManager_doPartialInitialize ();
+// self test end
+static void nfcManager_setProvisionMode(JNIEnv* e, jobject o,
+                                        jboolean provisionMode);
 static bool nfcManager_doPartialDeInitialize();
 static int nfcManager_doSelectUicc(JNIEnv* e, jobject o, jint uiccSlot);
+static void restartUiccListen(jint uiccSlot);
 static int nfcManager_doGetSelectedUicc(JNIEnv* e, jobject o);
 static void getUiccContext(int uiccSlot);
 static void update_uicc_context_info();
 static int getUiccSession();
-static void read_uicc_context(uint8_t *uiccContext, uint16_t uiccContextLen, uint8_t *uiccTechCap, uint16_t uiccTechCapLen, uint8_t block, uint8_t slotnum);
-static void write_uicc_context(uint8_t *uiccContext, uint16_t uiccContextLen, uint8_t *uiccTechCap, uint16_t uiccTechCapLen, uint8_t block, uint8_t slotnum);
+static void read_uicc_context(uint8_t* uiccContext, uint16_t uiccContextLen,
+                              uint8_t* uiccTechCap, uint16_t uiccTechCapLen,
+                              uint8_t block, uint8_t slotnum);
+static void write_uicc_context(uint8_t* uiccContext, uint16_t uiccContextLen,
+                               uint8_t* uiccTechCap, uint16_t uiccTechCapLen,
+                               uint8_t block, uint8_t slotnum);
 static uint16_t calc_crc16(uint8_t* pBuff, uint16_t wLen);
 
 static int nfcManager_staticDualUicc_Precondition(int uiccSlot);
@@ -434,108 +481,132 @@ tNFC_FW_VERSION get_fw_version();
 bool isNfcInitializationDone();
 static uint16_t discDuration = 0x00;
 uint16_t getrfDiscoveryDuration();
-typedef struct enableAGC_debug
-{
-    long enableAGC; // config param
-    bool AGCdebugstarted;// flag to indicate agc ongoing
-    bool AGCdebugrunning;//flag to indicate agc running or stopped.
-}enableAGC_debug_t;
+typedef struct enableAGC_debug {
+  long enableAGC;        // config param
+  bool AGCdebugstarted;  // flag to indicate agc ongoing
+  bool AGCdebugrunning;  // flag to indicate agc running or stopped.
+} enableAGC_debug_t;
 static enableAGC_debug_t menableAGC_debug_t;
-void *enableAGCThread(void *arg);
+void* enableAGCThread(void* arg);
 static void nfcManagerEnableAGCDebug(uint8_t connEvent);
 void set_AGC_process_state(bool state);
 bool get_AGC_process_state();
 
-void checkforTranscation(uint8_t connEvent ,void * eventData);
+void checkforTranscation(uint8_t connEvent, void* eventData);
 void sig_handler(int signo);
 void cleanup_timer();
+tNFA_STATUS updateEeprom(uint8_t* param, uint8_t len, uint8_t* val);
 /* Transaction Events in order */
 static IntervalTimer scleanupTimerProc_rffield;
-typedef enum transcation_events
-{
-    NFA_TRANS_DEFAULT = 0x00,
-    NFA_TRANS_ACTIVATED_EVT,
-    NFA_TRANS_EE_ACTION_EVT,
-    NFA_TRANS_DM_RF_FIELD_EVT,
-    NFA_TRANS_DM_RF_FIELD_EVT_ON,
-    NFA_TRANS_DM_RF_TRANS_START,
-    NFA_TRANS_DM_RF_FIELD_EVT_OFF,
-    NFA_TRANS_DM_RF_TRANS_PROGRESS,
-    NFA_TRANS_DM_RF_TRANS_END,
-    NFA_TRANS_MIFARE_ACT_EVT,
-    NFA_TRANS_CE_ACTIVATED = 0x18,
-    NFA_TRANS_CE_DEACTIVATED = 0x19,
-}eTranscation_events_t;
-
-
-typedef enum se_client
-{
-    DEFAULT = 0x00,
-    LDR_SRVCE,
-    JCOP_SRVCE,
-    LTSM_SRVCE
-}seClient_t;
+typedef enum transcation_events {
+  NFA_TRANS_DEFAULT = 0x00,
+  NFA_TRANS_ACTIVATED_EVT,
+  NFA_TRANS_EE_ACTION_EVT,
+  NFA_TRANS_DM_RF_FIELD_EVT,
+  NFA_TRANS_DM_RF_FIELD_EVT_ON,
+  NFA_TRANS_DM_RF_TRANS_START,
+  NFA_TRANS_DM_RF_FIELD_EVT_OFF,
+  NFA_TRANS_DM_RF_TRANS_PROGRESS,
+  NFA_TRANS_DM_RF_TRANS_END,
+  NFA_TRANS_MIFARE_ACT_EVT,
+  NFA_TRANS_CE_ACTIVATED = 0x18,
+  NFA_TRANS_CE_DEACTIVATED = 0x19,
+} eTranscation_events_t;
+
+typedef enum se_client {
+  DEFAULT = 0x00,
+  LDR_SRVCE,
+  JCOP_SRVCE,
+  LTSM_SRVCE
+} seClient_t;
 
 /*Structure to store  discovery parameters*/
-typedef struct discovery_Parameters
-{
-    int technologies_mask;
-    bool enable_lptd;
-    bool reader_mode;
-    bool enable_p2p;
-    bool restart;
-}discovery_Parameters_t;
-
+typedef struct discovery_Parameters {
+  int technologies_mask;
+  bool enable_lptd;
+  bool reader_mode;
+  bool enable_p2p;
+  bool restart;
+} discovery_Parameters_t;
+
+discovery_Parameters_t mDiscParams;
 /*Structure to store transcation result*/
-typedef struct Transcation_Check
-{
-    bool trans_in_progress;
-    char last_request;
-    struct nfc_jni_native_data *transaction_nat;
-    eScreenState_t last_screen_state_request;
-    eTranscation_events_t current_transcation_state;
-    discovery_Parameters_t discovery_params;
-    int t3thandle;
-    bool isInstallRequest;
+typedef struct Transcation_Check {
+  bool trans_in_progress;
+  char last_request;
+  struct nfc_jni_native_data* transaction_nat;
+  eScreenState_t last_screen_state_request;
+  eTranscation_events_t current_transcation_state;
+  discovery_Parameters_t discovery_params;
+  int t3thandle;
+  bool isInstallRequest;
 #endif
-} Transcation_Check_t;
-static struct nfc_jni_native_data *gNativeData = NULL;
-#if(NXP_EXTNS == TRUE)
-static struct nfc_jni_native_data* nat = NULL;
+}  // namespace android
+Transcation_Check_t;
+static struct nfc_jni_native_data* gNativeData = NULL;
+#if (NXP_EXTNS == TRUE)
 static bool sRfFieldOff = true;
 static bool gsRouteUpdated = false;
 /***P2P-Prio Logic for Multiprotocol***/
 static uint8_t multiprotocol_flag = 1;
 static uint8_t multiprotocol_detected = 0;
-void *p2p_prio_logic_multiprotocol(void *arg);
+void* p2p_prio_logic_multiprotocol(void* arg);
 static IntervalTimer multiprotocol_timer;
 pthread_t multiprotocol_thread;
 void reconfigure_poll_cb(union sigval);
 void clear_multiprotocol();
 void multiprotocol_clear_flag(union sigval);
-bool update_transaction_stat(const char * req_handle, transaction_state_t req_state);
+bool update_transaction_stat(const char* req_handle,
+                             transaction_state_t req_state);
+bool isLowRamDevice();
 #endif
-extern tNFA_INTF_TYPE   sCurrentRfInterface;
+extern tNFA_INTF_TYPE sCurrentRfInterface;
 static Transcation_Check_t transaction_data;
-static void nfcManager_enableDiscovery (JNIEnv* e, jobject o, jint technologies_mask,
-        jboolean enable_lptd, jboolean reader_mode, jboolean enable_p2p,
-        jboolean restart);
-void nfcManager_disableDiscovery (JNIEnv*, jobject);
+static void nfcManager_enableDiscovery(JNIEnv* e, jobject o,
+                                       jint technologies_mask,
+                                       jboolean enable_lptd,
+                                       jboolean reader_mode,
+                                       jboolean enable_p2p, jboolean restart);
+void nfcManager_disableDiscovery(JNIEnv*, jobject);
 static char get_last_request(void);
-static void set_last_request(char status, struct nfc_jni_native_data *nat);
+static void set_last_request(char status, struct nfc_jni_native_data* nat);
 static eScreenState_t get_lastScreenStateRequest(void);
 static void set_lastScreenStateRequest(eScreenState_t status);
-void *enableThread(void *arg);
+void* enableThread(void* arg);
 static IntervalTimer scleanupTimerProc_transaction;
-static bool gIsDtaEnabled=false;
+static bool gIsDtaEnabled = false;
 
-tNfc_featureList nfcFL;
 static void nfcManager_getFeatureList();
-static jbyteArray nfcManager_getAdditionalConfigOptions(JNIEnv *e, jobject o);
 static void register_signal_handler();
+static jbyteArray nfcManager_readerPassThruMode(JNIEnv *e, jobject o,
+                                                jbyte rqst,
+                                                jbyte modulationTyp);
+static jbyteArray nfcManager_transceiveAppData(JNIEnv *e, jobject o,
+                                               jbyteArray data);
 /////////////////////////////////////////////////////////////
 /////////////////////////////////////////////////////////////
 
+bool nfc_debug_enabled;
+
+namespace {
+void initializeGlobalDebugEnabledFlag() {
+  nfc_debug_enabled =
+      (NfcConfig::getUnsigned(NAME_NFC_DEBUG_ENABLED, 1) != 0) ? true : false;
+
+  char valueStr[PROPERTY_VALUE_MAX] = {0};
+  int len = property_get("nfc.debug_enabled", valueStr, "");
+  if (len > 0) {
+    unsigned debug_enabled = 1;
+    // let Android property override .conf variable
+    sscanf(valueStr, "%u", &debug_enabled);
+    nfc_debug_enabled = (debug_enabled == 0) ? false : true;
+  }
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: level=%u", __func__, nfc_debug_enabled);
+}
+}  // namespace
+
 /*******************************************************************************
 **
 ** Function:        getNative
@@ -545,17 +616,18 @@ static void register_signal_handler();
 ** Returns:         Native data structure.
 **
 *******************************************************************************/
-nfc_jni_native_data *getNative (JNIEnv* e, jobject o)
-{
-    static struct nfc_jni_native_data *sCachedNat = NULL;
-    if (e)
-    {
-        sCachedNat = nfc_jni_get_nat(e, o);
-    }
-    return sCachedNat;
+nfc_jni_native_data* getNative(JNIEnv* e, jobject o) {
+  static struct nfc_jni_native_data* sCachedNat = NULL;
+  if (e) {
+    sCachedNat = nfc_jni_get_nat(e, o);
+  }
+  return sCachedNat;
 }
 
-
+static void nfcManager_doShutdown(JNIEnv*, jobject) {
+  NfcAdaptation& theInstance = NfcAdaptation::GetInstance();
+  theInstance.DeviceShutdown();
+}
 /*******************************************************************************
 **
 ** Function:        handleRfDiscoveryEvent
@@ -566,159 +638,155 @@ nfc_jni_native_data *getNative (JNIEnv* e, jobject o)
 ** Returns:         None
 **
 *******************************************************************************/
-static void handleRfDiscoveryEvent (tNFC_RESULT_DEVT* discoveredDevice)
-{
-    int thread_ret;
+static void handleRfDiscoveryEvent(tNFC_RESULT_DEVT* discoveredDevice) {
+  int thread_ret;
 
-    if(discoveredDevice->more == NCI_DISCOVER_NTF_MORE)
-    {
-        //there is more discovery notification coming
-        NfcTag::getInstance ().mNumDiscNtf++;
-        return;
-    }
+  if (discoveredDevice->more == NCI_DISCOVER_NTF_MORE) {
+    // there is more discovery notification coming
+    NfcTag::getInstance().mNumDiscNtf++;
+    return;
+  }
 
-    NfcTag::getInstance ().mNumDiscNtf++;
-    ALOGD("%s: Total Notifications - %d ", __FUNCTION__, NfcTag::getInstance ().mNumDiscNtf);
+  NfcTag::getInstance().mNumDiscNtf++;
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Total Notifications - %d ", __FUNCTION__,
+                      NfcTag::getInstance().mNumDiscNtf);
 
-    if(NfcTag::getInstance ().mNumDiscNtf > 1)
-    {
-        NfcTag::getInstance().mIsMultiProtocolTag = true;
-    }
+  if (NfcTag::getInstance().mNumDiscNtf > 1) {
+    NfcTag::getInstance().mIsMultiProtocolTag = true;
+  }
 
-    bool isP2p = NfcTag::getInstance ().isP2pDiscovered ();
+  bool isP2p = NfcTag::getInstance().isP2pDiscovered();
 
-    if (!sReaderModeEnabled && isP2p)
-    {
-        ALOGD("%s: Select peer device", __FUNCTION__);
-#if(NXP_EXTNS == TRUE)
-        if(multiprotocol_detected == 1)
-        {
-            multiprotocol_timer.kill();
-        }
-#endif
-        NfcTag::getInstance ().selectP2p();
-    }
-#if(NXP_EXTNS == TRUE)
-    else if(!sReaderModeEnabled && multiprotocol_flag)
-    {
-        NfcTag::getInstance ().mNumDiscNtf = 0x00;
-        multiprotocol_flag = 0;
-        multiprotocol_detected = 1;
-        pthread_attr_t attr;
-        pthread_attr_init(&attr);
-        ALOGD("%s: starting p2p prio logic for multiprotocol tags", __FUNCTION__);
-        pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-        thread_ret = pthread_create(&multiprotocol_thread, &attr,
-                p2p_prio_logic_multiprotocol, NULL);
-        if(thread_ret != 0)
-            ALOGE("%s: unable to create the thread", __FUNCTION__);
-        pthread_attr_destroy(&attr);
-        ALOGD("%s: starting timer for reconfigure default polling callback", __FUNCTION__);
-        multiprotocol_timer.set (300, reconfigure_poll_cb);
+  if (!sReaderModeEnabled && isP2p) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Select peer device", __FUNCTION__);
+#if (NXP_EXTNS == TRUE)
+    if (multiprotocol_detected == 1) {
+      multiprotocol_timer.kill();
     }
 #endif
-    else
-    {
-        multiprotocol_flag = 1;
-#if(NXP_EXTNS == TRUE)
-        NfcTag::getInstance ().mNumDiscNtf--;
+    NfcTag::getInstance().selectP2p();
+  }
+#if (NXP_EXTNS == TRUE)
+  else if (!sReaderModeEnabled && multiprotocol_flag) {
+    NfcTag::getInstance().mNumDiscNtf = 0x00;
+    multiprotocol_flag = 0;
+    multiprotocol_detected = 1;
+    pthread_attr_t attr;
+    pthread_attr_init(&attr);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: starting p2p prio logic for multiprotocol tags", __FUNCTION__);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+    thread_ret = pthread_create(&multiprotocol_thread, &attr,
+                                p2p_prio_logic_multiprotocol, NULL);
+    if (thread_ret != 0)
+      LOG(ERROR) << StringPrintf("%s: unable to create the thread",
+                                 __FUNCTION__);
+    pthread_attr_destroy(&attr);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: starting timer for reconfigure default polling callback",
+        __FUNCTION__);
+    multiprotocol_timer.set(300, reconfigure_poll_cb);
+  }
 #endif
-        NfcTag::getInstance ().selectFirstTag();
-    }
+  else {
+    multiprotocol_flag = 1;
+#if (NXP_EXTNS == TRUE)
+    NfcTag::getInstance().mNumDiscNtf--;
+#endif
+    NfcTag::getInstance().selectFirstTag();
+  }
 }
 
-#if(NXP_EXTNS == TRUE)
-void *p2p_prio_logic_multiprotocol(void* /* arg */)
-{
-    tNFA_STATUS status             = NFA_STATUS_FAILED;
-    tNFA_TECHNOLOGY_MASK tech_mask = 0x00;
+#if (NXP_EXTNS == TRUE)
+void* p2p_prio_logic_multiprotocol(void* arg) {
+  tNFA_STATUS status = NFA_STATUS_FAILED;
+  tNFA_TECHNOLOGY_MASK tech_mask = 0x00;
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __FUNCTION__);
+  /* Do not need if it is already in screen off state */
+  if (!(getScreenState() &
+        (NFA_SCREEN_STATE_OFF_LOCKED | NFA_SCREEN_STATE_OFF_UNLOCKED))) {
+    /* Stop polling */
+    if (sRfEnabled) {
+      startRfDiscovery(false);
+    }
 
-    ALOGD ("%s: enter", __FUNCTION__);
-    /* Do not need if it is already in screen off state */
-    if ((getScreenState() != (NFA_SCREEN_STATE_OFF_LOCKED || NFA_SCREEN_STATE_OFF_UNLOCKED)))
     {
-        /* Stop polling */
-        if (sRfEnabled)
-        {
-            startRfDiscovery(false);
-        }
-
-        {
-            SyncEventGuard guard (sNfaEnableDisablePollingEvent);
-            status = NFA_DisablePolling ();
-            if (status == NFA_STATUS_OK)
-            {
-                sNfaEnableDisablePollingEvent.wait ();
-            }else
-            ALOGE ("%s: Failed to disable polling; error=0x%X", __FUNCTION__, status);
-        }
+      SyncEventGuard guard(sNfaEnableDisablePollingEvent);
+      status = NFA_DisablePolling();
+      if (status == NFA_STATUS_OK) {
+        sNfaEnableDisablePollingEvent.wait();
+      } else
+        LOG(ERROR) << StringPrintf("%s: Failed to disable polling; error=0x%X",
+                                   __FUNCTION__, status);
+    }
 
-        if(multiprotocol_detected)
-        {
-            ALOGD ("%s: configure polling to tech F only", __FUNCTION__);
-            tech_mask = NFA_TECHNOLOGY_MASK_F;
-        }
-        else
-        {
-            ALOGD ("%s: re-configure polling to default", __FUNCTION__);
-            unsigned long num = 0;
-            if (GetNumValue(NAME_POLLING_TECH_MASK, &num, sizeof(num)))
-                tech_mask = num;
-            else
-                tech_mask = DEFAULT_TECH_MASK;
-        }
+    if (multiprotocol_detected) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: configure polling to tech F only", __FUNCTION__);
+      tech_mask = NFA_TECHNOLOGY_MASK_F;
+    } else {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: re-configure polling to default", __FUNCTION__);
+      if (NfcConfig::hasKey(NAME_POLLING_TECH_MASK)) {
+        tech_mask = NfcConfig::getUnsigned(NAME_POLLING_TECH_MASK);
+      } else {
+        tech_mask = DEFAULT_TECH_MASK;
+      }
+    }
 
-        {
-            SyncEventGuard guard (sNfaEnableDisablePollingEvent);
-            status = NFA_EnablePolling (tech_mask);
-            if (status == NFA_STATUS_OK)
-            {
-                ALOGD ("%s: wait for enable event", __FUNCTION__);
-                sNfaEnableDisablePollingEvent.wait ();
-            }
-            else
-            {
-                ALOGE ("%s: fail enable polling; error=0x%X", __FUNCTION__, status);
-            }
-        }
+    {
+      SyncEventGuard guard(sNfaEnableDisablePollingEvent);
+      status = NFA_EnablePolling(tech_mask);
+      if (status == NFA_STATUS_OK) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: wait for enable event", __FUNCTION__);
+        sNfaEnableDisablePollingEvent.wait();
+      } else {
+        LOG(ERROR) << StringPrintf("%s: fail enable polling; error=0x%X",
+                                   __FUNCTION__, status);
+      }
+    }
 
-        /* start polling */
-        if (!sRfEnabled)
-        {
-            startRfDiscovery(true);
-        }
+    /* start polling */
+    if (!sRfEnabled) {
+      startRfDiscovery(true);
     }
-    ALOGD ("%s: exit", __FUNCTION__);
-    return NULL;
+  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __FUNCTION__);
+  return NULL;
 }
 
-void reconfigure_poll_cb(union sigval)
-{
-    ALOGV("Prio_Logic_multiprotocol timer expire");
-    ALOGV("CallBack Reconfiguring the POLL to Default");
-    clear_multiprotocol();
-    multiprotocol_timer.set (300, multiprotocol_clear_flag);
+void reconfigure_poll_cb(union sigval) {
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("Prio_Logic_multiprotocol timer expire");
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("CallBack Reconfiguring the POLL to Default");
+  clear_multiprotocol();
+  multiprotocol_timer.set(300, multiprotocol_clear_flag);
 }
 
-void clear_multiprotocol()
-{
-int thread_ret;
+void clear_multiprotocol() {
+  int thread_ret;
 
-    ALOGV("clear_multiprotocol");
-    multiprotocol_detected = 0;
-    pthread_attr_t attr;
-    pthread_attr_init(&attr);
-    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-    thread_ret = pthread_create(&multiprotocol_thread, &attr, p2p_prio_logic_multiprotocol, NULL);
-    if(thread_ret != 0)
-        ALOGV("unable to create the thread");
-    pthread_attr_destroy(&attr);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("clear_multiprotocol");
+  multiprotocol_detected = 0;
+  pthread_attr_t attr;
+  pthread_attr_init(&attr);
+  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+  thread_ret = pthread_create(&multiprotocol_thread, &attr,
+                              p2p_prio_logic_multiprotocol, NULL);
+  if (thread_ret != 0)
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("unable to create the thread");
+  pthread_attr_destroy(&attr);
 }
 
-void multiprotocol_clear_flag(union sigval)
-{
-    ALOGV("multiprotocol_clear_flag");
-    multiprotocol_flag = 1;
+void multiprotocol_clear_flag(union sigval) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("multiprotocol_clear_flag");
+  multiprotocol_flag = 1;
 }
 #endif
 
@@ -733,7487 +801,7523 @@ void multiprotocol_clear_flag(union sigval)
 ** Returns:         None
 **
 *******************************************************************************/
-static void nfaConnectionCallback (uint8_t connEvent, tNFA_CONN_EVT_DATA* eventData)
-{
-    tNFA_STATUS status          = NFA_STATUS_FAILED;
-    static uint8_t prev_more_val  = 0x00;
-    uint8_t cur_more_val          = 0x00;
-
-    ALOGV("%s: Connection Event = %u", __func__, connEvent);
-
-    switch (connEvent)
-    {
-        case NFA_POLL_ENABLED_EVT:
-        {
-            ALOGV("%s: NFA_POLL_ENABLED_EVT: status = 0x%0X", __func__, eventData->status);
-            SyncEventGuard guard (sNfaEnableDisablePollingEvent);
-            sNfaEnableDisablePollingEvent.notifyOne ();
+static void nfaConnectionCallback(uint8_t connEvent,
+                                  tNFA_CONN_EVT_DATA* eventData) {
+  tNFA_STATUS status = NFA_STATUS_FAILED;
+  static uint8_t prev_more_val = 0x00;
+  uint8_t cur_more_val = 0x00;
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Connection Event = %u", __func__, connEvent);
+
+  switch (connEvent) {
+    case NFA_POLL_ENABLED_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: NFA_POLL_ENABLED_EVT: status = 0x%0X", __func__,
+                          eventData->status);
+      SyncEventGuard guard(sNfaEnableDisablePollingEvent);
+      sNfaEnableDisablePollingEvent.notifyOne();
+    } break;
+
+    case NFA_POLL_DISABLED_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: NFA_POLL_DISABLED_EVT: status = 0x%0X", __func__,
+                          eventData->status);
+      SyncEventGuard guard(sNfaEnableDisablePollingEvent);
+      sNfaEnableDisablePollingEvent.notifyOne();
+    } break;
+
+    case NFA_RF_DISCOVERY_STARTED_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: NFA_RF_DISCOVERY_STARTED_EVT: status = 0x%0X",
+                          __func__, eventData->status);
+      SyncEventGuard guard(sNfaEnableDisablePollingEvent);
+      sNfaEnableDisablePollingEvent.notifyOne();
+    } break;
+
+    case NFA_RF_DISCOVERY_STOPPED_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: NFA_RF_DISCOVERY_STOPPED_EVT: status = 0x%0X",
+                          __func__, eventData->status);
+      notifyPollingEventwhileNfcOff();
+      if (getReconnectState() == true) {
+        eventData->deactivated.type = NFA_DEACTIVATE_TYPE_SLEEP;
+        NfcTag::getInstance().setDeactivationState(eventData->deactivated);
+        if (gIsTagDeactivating) {
+          NfcTag::getInstance().setActive(false);
+          nativeNfcTag_doDeactivateStatus(0);
+        }
+      }
+      /* sNfaEnableDisablePollingEvent shall be notified in all cases
+       * otherwise RF stop activity will block wait */
+      SyncEventGuard guard(sNfaEnableDisablePollingEvent);
+      sNfaEnableDisablePollingEvent.notifyOne();
+    } break;
+
+    case NFA_DISC_RESULT_EVT: {
+      status = eventData->disc_result.status;
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_DISC_RESULT_EVT: status = 0x%0X", __func__, status);
+      cur_more_val = eventData->disc_result.discovery_ntf.more;
+      if ((cur_more_val == 0x01) && (prev_more_val != 0x02)) {
+        LOG(ERROR) << StringPrintf("%s: NFA_DISC_RESULT_EVT: Failed", __func__);
+        status = NFA_STATUS_FAILED;
+      } else {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: NFA_DISC_RESULT_EVT: Success", __func__);
+        status = NFA_STATUS_OK;
+        prev_more_val = cur_more_val;
+      }
+#if (NXP_EXTNS == TRUE)
+#if (NFC_NXP_NON_STD_CARD == TRUE)
+      if (gIsSelectingRfInterface) {
+        LOG(ERROR) << StringPrintf(
+            "%s: NFA_DISC_RESULT_EVT: reSelect function didn't save the "
+            "modification",
+            __func__);
+        if (cur_more_val == 0x00) {
+          LOG(ERROR) << StringPrintf(
+              "%s: NFA_DISC_RESULT_EVT: error, select any one tag", __func__);
+          multiprotocol_flag = 0;
+        }
+      }
+#endif
+#endif
+      if (status != NFA_STATUS_OK) {
+        LOG(ERROR) << StringPrintf(
+            "%s: NFA_DISC_RESULT_EVT: error, status = 0x%0X", __func__, status);
+        NfcTag::getInstance().mNumDiscNtf = 0;
+      } else {
+        NfcTag::getInstance().connectionEventHandler(connEvent, eventData);
+        handleRfDiscoveryEvent(&eventData->disc_result.discovery_ntf);
+      }
+    } break;
+
+    case NFA_SELECT_RESULT_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_SELECT_RESULT_EVT: status = 0x%0X, gIsSelectingRfInterface "
+          "= %d, sIsDisabling = %d",
+          __func__, eventData->status, gIsSelectingRfInterface, sIsDisabling);
+
+      if (sIsDisabling) break;
+
+      if (eventData->status != NFA_STATUS_OK) {
+        if (gIsSelectingRfInterface) {
+#if (NXP_EXTNS == TRUE)
+#if (NFC_NXP_NON_STD_CARD == TRUE)
+          nativeNfcTag_cacheNonNciCardDetection();
+#endif
+#endif
+          nativeNfcTag_doConnectStatus(false);
         }
+#if (NXP_EXTNS == TRUE)
+        NfcTag::getInstance().selectCompleteStatus(false);
+        NfcTag::getInstance().mNumDiscNtf = 0x00;
+#endif
+        NfcTag::getInstance().mTechListIndex = 0;
+        LOG(ERROR) << StringPrintf(
+            "%s: NFA_SELECT_RESULT_EVT: error, status = 0x%0X", __func__,
+            eventData->status);
+        NFA_Deactivate(false);
+      }
+#if (NXP_EXTNS == TRUE)
+      else if (sReaderModeEnabled &&
+               (gFelicaReaderState == STATE_DEACTIVATED_TO_SLEEP)) {
+        SyncEventGuard g(sRespCbEvent);
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: Sending Sem Post for Select Event", __func__);
+        sRespCbEvent.notifyOne();
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: NFA_SELECT_RESULT_EVT: Frame RF Interface Selected", __func__);
+        gFelicaReaderState = STATE_FRAMERF_INTF_SELECTED;
+      }
+#endif
+    } break;
+
+    case NFA_DEACTIVATE_FAIL_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: NFA_DEACTIVATE_FAIL_EVT: status = 0x%0X",
+                          __func__, eventData->status);
+      {
+        SyncEventGuard guard(gDeactivatedEvent);
+        gActivated = false;
+        gDeactivatedEvent.notifyOne();
+      }
+      {
+        SyncEventGuard guard(sNfaEnableDisablePollingEvent);
+        sNfaEnableDisablePollingEvent.notifyOne();
+      }
+    } break;
+
+    case NFA_ACTIVATED_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_ACTIVATED_EVT: gIsSelectingRfInterface=%d, sIsDisabling=%d",
+          __func__, gIsSelectingRfInterface, sIsDisabling);
+#if (NXP_EXTNS == TRUE)
+      if (gSelfTestType != NFC_CMD_TYPE_TYPE_NONE) {
+        activatedNtf_Cb();
         break;
-
-        case NFA_POLL_DISABLED_EVT:
-        {
-            ALOGV("%s: NFA_POLL_DISABLED_EVT: status = 0x%0X", __func__, eventData->status);
-            SyncEventGuard guard (sNfaEnableDisablePollingEvent);
-            sNfaEnableDisablePollingEvent.notifyOne ();
-        }
+      }
+      rfActivation = true;
+
+      checkforTranscation(NFA_ACTIVATED_EVT, (void*)eventData);
+
+      NfcTag::getInstance().selectCompleteStatus(true);
+
+      /***P2P-Prio Logic for Multiprotocol***/
+      if ((eventData->activated.activate_ntf.protocol ==
+           NFA_PROTOCOL_NFC_DEP) &&
+          (multiprotocol_detected == 1)) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("Prio_Logic_multiprotocol stop timer");
+        multiprotocol_timer.kill();
+      }
+
+      if ((eventData->activated.activate_ntf.protocol == NFA_PROTOCOL_T3T) &&
+          (multiprotocol_detected == 1)) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("Prio_Logic_multiprotocol stop timer");
+        multiprotocol_timer.kill();
+        clear_multiprotocol();
+      }
+#endif
+      if (nfcFL.nfcNxpEse) {
+        if (nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
+          /*
+           * Handle Reader over SWP START_READER_EVENT
+           * */
+          if (eventData->activated.activate_ntf.intf_param.type ==
+                  NCI_INTERFACE_UICC_DIRECT_STAT ||
+              eventData->activated.activate_ntf.intf_param.type ==
+                  NCI_INTERFACE_ESE_DIRECT_STAT) {
+            MposManager::getInstance().setEtsiReaederState(
+                STATE_SE_RDR_MODE_ACTIVATED);
+            MposManager::getInstance().notifyEEReaderEvent(
+                ETSI_READER_ACTIVATED);
+            break;
+          }
+        }
+      }
+      if ((eventData->activated.activate_ntf.protocol !=
+           NFA_PROTOCOL_NFC_DEP) &&
+          (!isListenMode(eventData->activated))) {
+        nativeNfcTag_setRfInterface(
+            (tNFA_INTF_TYPE)eventData->activated.activate_ntf.intf_param.type);
+      }
+
+      if (EXTNS_GetConnectFlag() == true) {
+        NfcTag::getInstance().setActivationState();
+        nativeNfcTag_doConnectStatus(true);
         break;
+      }
 
-        case NFA_RF_DISCOVERY_STARTED_EVT:
-        {
-            ALOGV("%s: NFA_RF_DISCOVERY_STARTED_EVT: status = 0x%0X", __func__, eventData->status);
-            SyncEventGuard guard (sNfaEnableDisablePollingEvent);
-            sNfaEnableDisablePollingEvent.notifyOne ();
+      NfcTag::getInstance().setActive(true);
+
+      if (sIsDisabling || !sIsNfaEnabled) break;
+
+      gActivated = true;
+
+      NfcTag::getInstance().setActivationState();
+
+      if (gIsSelectingRfInterface) {
+        nativeNfcTag_doConnectStatus(true);
+        if (NfcTag::getInstance().isCashBeeActivated() == true ||
+            NfcTag::getInstance().isEzLinkTagActivated() == true) {
+          NfcTag::getInstance().connectionEventHandler(NFA_ACTIVATED_UPDATE_EVT,
+                                                       eventData);
         }
         break;
+      }
 
-        case NFA_RF_DISCOVERY_STOPPED_EVT:
-        {
-            ALOGV("%s: NFA_RF_DISCOVERY_STOPPED_EVT: status = 0x%0X", __func__, eventData->status);
-            notifyPollingEventwhileNfcOff();
-            if (getReconnectState() == true)
-            {
-                eventData->deactivated.type = NFA_DEACTIVATE_TYPE_SLEEP;
-                NfcTag::getInstance().setDeactivationState (eventData->deactivated);
-                if (gIsTagDeactivating)
-                {
-                    NfcTag::getInstance().setActive(false);
-                    nativeNfcTag_doDeactivateStatus(0);
-                }
+      nativeNfcTag_resetPresenceCheck();
+
+      if (isPeerToPeer(eventData->activated)) {
+        if (sReaderModeEnabled) {
+#if (NXP_EXTNS == TRUE)
+          /* If last transaction is complete or prev state is idle
+           * then proceed to next state*/
+          if (isActivatedTypeF(eventData->activated) &&
+              (sTechMask & NFA_TECHNOLOGY_MASK_F) &&
+              ((gFelicaReaderState == STATE_IDLE) ||
+               (gFelicaReaderState == STATE_FRAMERF_INTF_SELECTED))) {
+            DLOG_IF(INFO, nfc_debug_enabled)
+                << StringPrintf("%s: Activating Reader Mode in P2P ", __func__);
+            gFelicaReaderState = STATE_NFCDEP_ACTIVATED_NFCDEP_INTF;
+            switchP2PToT3TRead(eventData->activated.activate_ntf.rf_disc_id);
+          } else {
+            DLOG_IF(INFO, nfc_debug_enabled)
+                << StringPrintf("%s: Invalid FelicaReaderState : %d  ",
+                                __func__, gFelicaReaderState);
+            gFelicaReaderState = STATE_IDLE;
+#endif
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+                "%s: Ignoring P2P target in reader mode.", __func__);
+            NFA_Deactivate(false);
+#if (NXP_EXTNS == TRUE)
+          }
+#endif
+          break;
+        }
+        sP2pActive = true;
+#if (NXP_EXTNS == FALSE)
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: NFA_ACTIVATED_EVT; is p2p", __func__);
+        if (NFC_GetNCIVersion() == NCI_VERSION_1_0) {
+          // Disable RF field events in case of p2p
+          uint8_t nfa_disable_rf_events[] = {0x00};
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("%s: Disabling RF field events", __func__);
+          status = NFA_SetConfig(NCI_PARAM_ID_RF_FIELD_INFO,
+                                 sizeof(nfa_disable_rf_events),
+                                 &nfa_disable_rf_events[0]);
+          if (status == NFA_STATUS_OK) {
+            DLOG_IF(INFO, nfc_debug_enabled)
+                << StringPrintf("%s: Disabled RF field events", __func__);
+          } else {
+            LOG(ERROR) << StringPrintf("%s: Failed to disable RF field events",
+                                       __func__);
+          }
+
+#endif
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "%s: NFA_ACTIVATED_EVT: P2P is activated", __func__);
+          if ((nfcFL.nfcNxpEse &&
+               nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) &&
+              (SecureElement::getInstance().mIsWiredModeOpen &&
+               SecureElement::getInstance().mPassiveListenEnabled == true)) {
+            SecureElement::getInstance().mPassiveListenTimer.kill();
+          }
+
+          /* For Secure Element, consider the field to be on while P2P is active
+           */
+          SecureElement::getInstance().notifyRfFieldEvent(true);
+#if (NXP_EXTNS == TRUE)
+          if (nfcFL.nfcNxpEse && (nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME !=
+                                  nfcFL.eseFL._ESE_WIRED_MODE_RESUME)) {
+            SecureElement::getInstance().setDwpTranseiveState(
+                false, NFCC_ACTIVATED_NTF);
+          }
+#endif
+        } else if (pn544InteropIsBusy() == false) {
+#if (NXP_EXTNS == TRUE && NFC_NXP_NON_STD_CARD == TRUE)
+          nativeNfcTag_handleNonNciMultiCardDetection(connEvent, eventData);
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "%s: scoreGenericNtf = 0x%x", __func__, scoreGenericNtf);
+          if (scoreGenericNtf == true) {
+            if ((eventData->activated.activate_ntf.intf_param.type ==
+                 NFC_INTERFACE_ISO_DEP) &&
+                (eventData->activated.activate_ntf.protocol ==
+                 NFC_PROTOCOL_ISO_DEP)) {
+              nativeNfcTag_handleNonNciCardDetection(eventData);
+            }
+            scoreGenericNtf = false;
+          }
+#else
+        NfcTag::getInstance().connectionEventHandler(connEvent, eventData);
+
+        if (NfcTag::getInstance().mNumDiscNtf) {
+          NFA_Deactivate(true);
+        }
+#endif
+          /* We know it is not activating for P2P.  If it activated in
+           * listen mode then it is likely for an SE transaction.
+           * Send the RF Event */
+          if (isListenMode(eventData->activated)) {
+            sSeRfActive = true;
+            SecureElement::getInstance().notifyListenModeState(true);
+#if (NXP_EXTNS == TRUE)
+            if ((nfcFL.nfcNxpEse &&
+                 nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) &&
+                (SecureElement::getInstance().mIsWiredModeOpen &&
+                 SecureElement::getInstance().mPassiveListenEnabled == true)) {
+              SecureElement::getInstance().mPassiveListenTimer.kill();
             }
-            /* sNfaEnableDisablePollingEvent shall be notified in all cases
-             * otherwise RF stop activity will block wait */
-            SyncEventGuard guard (sNfaEnableDisablePollingEvent);
-            sNfaEnableDisablePollingEvent.notifyOne ();
+#endif
+          }
         }
-        break;
+      }
+      break;
 
-        case NFA_DISC_RESULT_EVT:
-        {
-            status = eventData->disc_result.status;
-            ALOGV("%s: NFA_DISC_RESULT_EVT: status = 0x%0X", __func__, status);
-            cur_more_val = eventData->disc_result.discovery_ntf.more;
-            if((cur_more_val == 0x01) && (prev_more_val != 0x02))
-            {
-                ALOGE("%s: NFA_DISC_RESULT_EVT: Failed", __func__);
-                status = NFA_STATUS_FAILED;
-            }
-            else
-            {
-                ALOGV("%s: NFA_DISC_RESULT_EVT: Success", __func__);
-                status = NFA_STATUS_OK;
-                prev_more_val = cur_more_val;
-            }
+      case NFA_DEACTIVATED_EVT: {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: NFA_DEACTIVATED_EVT: Type=%u, gIsTagDeactivating=%d", __func__,
+            eventData->deactivated.type, gIsTagDeactivating);
 #if (NXP_EXTNS == TRUE)
+        rfActivation = false;
+        if ((nfcFL.chipType == pn547C2) &&
+            (eventData->deactivated.type == NFA_DEACTIVATE_TYPE_IDLE)) {
+          checkforTranscation(NFA_DEACTIVATED_EVT, (void*)eventData);
+        }
 #if (NFC_NXP_NON_STD_CARD == TRUE)
-            if (gIsSelectingRfInterface)
-            {
-                ALOGE("%s: NFA_DISC_RESULT_EVT: reSelect function didn't save the modification", __func__);
-                if(cur_more_val == 0x00)
-                {
-                    ALOGE("%s: NFA_DISC_RESULT_EVT: error, select any one tag", __func__);
-                    multiprotocol_flag = 0;
-                }
-            }
+        if (checkCmdSent == 1 && eventData->deactivated.type == 0) {
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "%s: NFA_DEACTIVATED_EVT: Setting check flag  to one", __func__);
+          checkTagNtf = 1;
+        }
 #endif
 #endif
-            if (status != NFA_STATUS_OK)
-            {
-                ALOGE("%s: NFA_DISC_RESULT_EVT: error, status = 0x%0X", __func__, status);
-                NfcTag::getInstance ().mNumDiscNtf = 0;
-            }
-            else
-            {
-                NfcTag::getInstance().connectionEventHandler(connEvent, eventData);
-                handleRfDiscoveryEvent(&eventData->disc_result.discovery_ntf);
-            }
+
+        notifyPollingEventwhileNfcOff();
+
+        if (true == getReconnectState()) {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("Reconnect in progress : Do nothing");
+          break;
         }
-        break;
 
-        case NFA_SELECT_RESULT_EVT:
-        {
-            ALOGV("%s: NFA_SELECT_RESULT_EVT: status = 0x%0X, gIsSelectingRfInterface = %d, sIsDisabling = %d", __func__, eventData->status, gIsSelectingRfInterface, sIsDisabling);
+#if (NXP_EXTNS == TRUE)
+        /* P2P-priority logic for multiprotocol tags */
+        if ((multiprotocol_detected == 1) && (sP2pActive == 1)) {
+          NfcTag::getInstance().mNumDiscNtf = 0;
+          clear_multiprotocol();
+          multiprotocol_flag = 1;
+        }
+        if (gIsWaiting4Deact2SleepNtf) {
+          if (eventData->deactivated.type == NFA_DEACTIVATE_TYPE_IDLE) {
+            gGotDeact2IdleNtf = true;
+          } else if (eventData->deactivated.type == NFA_DEACTIVATE_TYPE_SLEEP) {
+            gIsWaiting4Deact2SleepNtf = false;
+          }
+        }
+#endif
+        NfcTag::getInstance().setDeactivationState(eventData->deactivated);
 
-            if (sIsDisabling)
-                break;
+        if (NfcTag::getInstance().mNumDiscNtf) {
+          NfcTag::getInstance().mNumDiscNtf--;
+          NfcTag::getInstance().selectNextTag();
+        }
 
-            if (eventData->status != NFA_STATUS_OK)
-            {
-                if (gIsSelectingRfInterface)
-                {
+        if (eventData->deactivated.type != NFA_DEACTIVATE_TYPE_SLEEP) {
+          {
+            SyncEventGuard guard(gDeactivatedEvent);
+            gActivated = false;
+            gDeactivatedEvent.notifyOne();
+          }
 #if (NXP_EXTNS == TRUE)
-#if (NFC_NXP_NON_STD_CARD == TRUE)
-                    nativeNfcTag_cacheNonNciCardDetection();
+          if ((nfcFL.nfcNxpEse &&
+               nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) &&
+              (SecureElement::getInstance().mIsWiredModeOpen &&
+               SecureElement::getInstance().mPassiveListenEnabled)) {
+            SecureElement::getInstance().startThread(0x00);
+          }
 #endif
+          NfcTag::getInstance().mNumDiscNtf = 0;
+          NfcTag::getInstance().mTechListIndex = 0;
+          nativeNfcTag_resetPresenceCheck();
+          NfcTag::getInstance().connectionEventHandler(connEvent, eventData);
+          nativeNfcTag_abortWaits();
+          NfcTag::getInstance().abort();
+          NfcTag::getInstance().mIsMultiProtocolTag = false;
+        } else if (gIsTagDeactivating) {
+          NfcTag::getInstance().setActive(false);
+          nativeNfcTag_doDeactivateStatus(0);
+        } else if (EXTNS_GetDeactivateFlag() == true) {
+          NfcTag::getInstance().setActive(false);
+          nativeNfcTag_doDeactivateStatus(0);
+        }
+
+        /* If RF is activated for what we think is a Secure Element transaction
+         * and it is deactivated to either IDLE or DISCOVERY mode, notify wait
+         * event */
+        if ((eventData->deactivated.type == NFA_DEACTIVATE_TYPE_IDLE) ||
+            (eventData->deactivated.type == NFA_DEACTIVATE_TYPE_DISCOVERY)) {
+#if (NXP_EXTNS == TRUE)
+          if (nfcFL.nfccFL._NFCEE_REMOVED_NTF_RECOVERY &&
+              RoutingManager::getInstance().is_ee_recovery_ongoing()) {
+            recovery = false;
+            SyncEventGuard guard(
+                SecureElement::getInstance().mEEdatapacketEvent);
+            SecureElement::getInstance().mEEdatapacketEvent.notifyOne();
+          }
 #endif
-                    nativeNfcTag_doConnectStatus(false);
+          if (sSeRfActive) {
+            sSeRfActive = false;
+            if (!sIsDisabling && sIsNfaEnabled)
+              SecureElement::getInstance().notifyListenModeState(false);
+          } else if (sP2pActive) {
+            sP2pActive = false;
+#if (NXP_EXTNS == FALSE)
+            DLOG_IF(INFO, nfc_debug_enabled)
+                << StringPrintf("%s: NFA_DEACTIVATED_EVT; is p2p", __func__);
+            if (NFC_GetNCIVersion() == NCI_VERSION_1_0) {
+              // Disable RF field events in case of p2p
+              uint8_t nfa_enable_rf_events[] = {0x01};
+
+              if (!sIsDisabling && sIsNfaEnabled) {
+                DLOG_IF(INFO, nfc_debug_enabled)
+                    << StringPrintf("%s: Enabling RF field events", __func__);
+                status = NFA_SetConfig(NCI_PARAM_ID_RF_FIELD_INFO,
+                                       sizeof(nfa_enable_rf_events),
+                                       &nfa_enable_rf_events[0]);
+                if (status == NFA_STATUS_OK) {
+                  DLOG_IF(INFO, nfc_debug_enabled)
+                      << StringPrintf("%s: Enabled RF field events", __func__);
+                } else {
+                  LOG(ERROR) << StringPrintf(
+                      "%s: Failed to enable RF field events", __func__);
                 }
-#if(NXP_EXTNS == TRUE)
-                NfcTag::getInstance().selectCompleteStatus(false);
-                NfcTag::getInstance ().mNumDiscNtf = 0x00;
-#endif
-                NfcTag::getInstance().mTechListIndex = 0;
-                ALOGE("%s: NFA_SELECT_RESULT_EVT: error, status = 0x%0X", __func__, eventData->status);
-                NFA_Deactivate (false);
-            }
-#if(NXP_EXTNS == TRUE)
-            else if (sReaderModeEnabled && (gFelicaReaderState == STATE_DEACTIVATED_TO_SLEEP))
-            {
-                SyncEventGuard g (sRespCbEvent);
-                ALOGV("%s: Sending Sem Post for Select Event", __func__);
-                sRespCbEvent.notifyOne ();
-                ALOGV("%s: NFA_SELECT_RESULT_EVT: Frame RF Interface Selected", __func__);
-                gFelicaReaderState = STATE_FRAMERF_INTF_SELECTED;
+              }
             }
 #endif
+            SecureElement::getInstance().notifyRfFieldEvent(false);
+            DLOG_IF(INFO, nfc_debug_enabled)
+                << StringPrintf("%s: NFA_DEACTIVATED_EVT: is p2p", __func__);
+          }
         }
-        break;
-
-        case NFA_DEACTIVATE_FAIL_EVT:
-        {
-            ALOGV("%s: NFA_DEACTIVATE_FAIL_EVT: status = 0x%0X", __func__, eventData->status);
-            {
-                SyncEventGuard guard (gDeactivatedEvent);
-                gActivated = false;
-                gDeactivatedEvent.notifyOne ();
-            }
-            {
-                SyncEventGuard guard (sNfaEnableDisablePollingEvent);
-                sNfaEnableDisablePollingEvent.notifyOne ();
-            }
+#if (NXP_EXTNS == TRUE)
+        if (sReaderModeEnabled &&
+            (eventData->deactivated.type == NFA_DEACTIVATE_TYPE_SLEEP)) {
+          if (gFelicaReaderState == STATE_NFCDEP_ACTIVATED_NFCDEP_INTF) {
+            SyncEventGuard g(sRespCbEvent);
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+                "%s: Sending Sem Post for Deactivated", __func__);
+            sRespCbEvent.notifyOne();
+            DLOG_IF(INFO, nfc_debug_enabled)
+                << StringPrintf("Switching to T3T\n");
+            gFelicaReaderState = STATE_DEACTIVATED_TO_SLEEP;
+          } else {
+            DLOG_IF(INFO, nfc_debug_enabled)
+                << StringPrintf("%s: FelicaReaderState Invalid", __func__);
+            gFelicaReaderState = STATE_IDLE;
+          }
         }
+#endif
+      } break;
+
+      case NFA_TLV_DETECT_EVT: {
+        status = eventData->tlv_detect.status;
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: NFA_TLV_DETECT_EVT status = 0x%0X, protocol = %d, num_tlvs = "
+            "%d, num_bytes = %d",
+            __func__, status, eventData->tlv_detect.protocol,
+            eventData->tlv_detect.num_tlvs, eventData->tlv_detect.num_bytes);
+        if (status != NFA_STATUS_OK) {
+          LOG(ERROR) << StringPrintf(
+              "%s: NFA_TLV_DETECT_EVT error: status = 0x%0X", __func__, status);
+        }
+      } break;
+
+      case NFA_NDEF_DETECT_EVT: {
+        /* NDEF Detection procedure is completed,
+         * if status is failure, it means the tag does not contain any or valid
+         * NDEF data
+         * pass the failure status to the NFC Service */
+        status = eventData->ndef_detect.status;
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: NFA_NDEF_DETECT_EVT status = 0x%0X, protocol = %u, "
+            "max_size = %u, cur_size = %u, flags = 0x%X",
+            __func__, status, eventData->ndef_detect.protocol,
+            eventData->ndef_detect.max_size, eventData->ndef_detect.cur_size,
+            eventData->ndef_detect.flags);
+        NfcTag::getInstance().connectionEventHandler(connEvent, eventData);
+        nativeNfcTag_doCheckNdefResult(status, eventData->ndef_detect.max_size,
+                                       eventData->ndef_detect.cur_size,
+                                       eventData->ndef_detect.flags);
+      } break;
+
+      case NFA_DATA_EVT: {
+        /* Data message received (for non-NDEF reads) */
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: NFA_DATA_EVT: status = 0x%X, len = %d",
+                            __func__, eventData->status, eventData->data.len);
+        nativeNfcTag_doTransceiveStatus(
+            eventData->status, eventData->data.p_data, eventData->data.len);
+      } break;
+
+      case NFA_RW_INTF_ERROR_EVT: {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: NFA_RW_INTF_ERROR_EVT", __func__);
+        nativeNfcTag_notifyRfTimeout();
+        nativeNfcTag_doReadCompleted(NFA_STATUS_TIMEOUT);
+      } break;
+
+      case NFA_SELECT_CPLT_EVT: {
+        status = eventData->status;
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: NFA_SELECT_CPLT_EVT: status = 0x%0X", __func__, status);
+        if (status != NFA_STATUS_OK) {
+          LOG(ERROR) << StringPrintf(
+              "%s: NFA_SELECT_CPLT_EVT error: status = 0x%0X", __func__,
+              status);
+        }
+      } break;
+
+      case NFA_READ_CPLT_EVT: {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: NFA_READ_CPLT_EVT: status = 0x%0X", __func__,
+                            eventData->status);
+        nativeNfcTag_doReadCompleted(eventData->status);
+        NfcTag::getInstance().connectionEventHandler(connEvent, eventData);
+      } break;
+
+      case NFA_WRITE_CPLT_EVT: {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: NFA_WRITE_CPLT_EVT: status = 0x%0X", __func__,
+                            eventData->status);
+        nativeNfcTag_doWriteStatus(eventData->status == NFA_STATUS_OK);
+      } break;
+
+      case NFA_SET_TAG_RO_EVT: {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: NFA_SET_TAG_RO_EVT: status = 0x%0X", __func__,
+                            eventData->status);
+        nativeNfcTag_doMakeReadonlyResult(eventData->status);
+      } break;
+
+      case NFA_CE_NDEF_WRITE_START_EVT: {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: NFA_CE_NDEF_WRITE_START_EVT: status: 0x%0X",
+                            __func__, eventData->status);
+        if (eventData->status != NFA_STATUS_OK)
+          LOG(ERROR) << StringPrintf(
+              "%s: NFA_CE_NDEF_WRITE_START_EVT error: status = 0x%0X", __func__,
+              eventData->status);
+      } break;
+
+      case NFA_CE_NDEF_WRITE_CPLT_EVT: {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: NFA_CE_NDEF_WRITE_CPLT_EVT: len = %u",
+                            __func__, eventData->ndef_write_cplt.len);
+      } break;
+
+      case NFA_LLCP_ACTIVATED_EVT: {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: NFA_LLCP_ACTIVATED_EVT: is_initiator: %d  remote_wks: %d, "
+            "remote_lsc: %d, remote_link_miu: %d, local_link_miu: %d",
+            __func__, eventData->llcp_activated.is_initiator,
+            eventData->llcp_activated.remote_wks,
+            eventData->llcp_activated.remote_lsc,
+            eventData->llcp_activated.remote_link_miu,
+            eventData->llcp_activated.local_link_miu);
+        PeerToPeer::getInstance().llcpActivatedHandler(
+            getNative(0, 0), eventData->llcp_activated);
+      } break;
+
+      case NFA_LLCP_DEACTIVATED_EVT: {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: NFA_LLCP_DEACTIVATED_EVT", __func__);
+        PeerToPeer::getInstance().llcpDeactivatedHandler(
+            getNative(0, 0), eventData->llcp_deactivated);
+      } break;
+
+      case NFA_LLCP_FIRST_PACKET_RECEIVED_EVT: {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: NFA_LLCP_FIRST_PACKET_RECEIVED_EVT", __func__);
+        PeerToPeer::getInstance().llcpFirstPacketHandler(getNative(0, 0));
+      } break;
+
+      case NFA_PRESENCE_CHECK_EVT: {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: NFA_PRESENCE_CHECK_EVT", __func__);
+        nativeNfcTag_doPresenceCheckResult(eventData->status);
+      } break;
+
+      case NFA_FORMAT_CPLT_EVT: {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: NFA_FORMAT_CPLT_EVT: status = 0x%0X", __func__,
+                            eventData->status);
+        nativeNfcTag_formatStatus(eventData->status == NFA_STATUS_OK);
+      } break;
+
+      case NFA_I93_CMD_CPLT_EVT: {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: NFA_I93_CMD_CPLT_EVT: status = 0x%0X",
+                            __func__, eventData->status);
+      } break;
+
+      case NFA_CE_UICC_LISTEN_CONFIGURED_EVT: {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: NFA_CE_UICC_LISTEN_CONFIGURED_EVT : status = 0x%0X", __func__,
+            eventData->status);
+        SecureElement::getInstance().connectionEventHandler(connEvent,
+                                                            eventData);
+      } break;
+
+      case NFA_CE_ESE_LISTEN_CONFIGURED_EVT: {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: NFA_CE_ESE_LISTEN_CONFIGURED_EVT : status = 0x%0X", __func__,
+            eventData->status);
+        SecureElement::getInstance().connectionEventHandler(connEvent,
+                                                            eventData);
+      } break;
+
+      case NFA_SET_P2P_LISTEN_TECH_EVT: {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: NFA_SET_P2P_LISTEN_TECH_EVT", __func__);
+        PeerToPeer::getInstance().connectionEventHandler(connEvent, eventData);
+      } break;
+
+      case NFA_CE_LOCAL_TAG_CONFIGURED_EVT: {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: NFA_CE_LOCAL_TAG_CONFIGURED_EVT", __func__);
+      } break;
+#if (NXP_EXTNS == TRUE)
+      case NFA_RECOVERY_EVT: {
+        if (nfcFL.nfcNxpEse && nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "%s: NFA_RECOVERY_EVT: Discovery Started in lower layer:Updating "
+              "status in JNI",
+              __func__);
+          if (MposManager::getInstance().getEtsiReaederState() ==
+              STATE_SE_RDR_MODE_STOP_IN_PROGRESS) {
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+                "%s: Reset the ETSI Reader State to STATE_SE_RDR_MODE_STOPPED",
+                __func__);
+            MposManager::getInstance().setEtsiReaederState(
+                STATE_SE_RDR_MODE_STOPPED);
+          }
+        }
+      } break;
+#endif
+#if (NXP_EXTNS == TRUE)
+      case NFA_PASSIVE_LISTEN_DISABLED_EVT: {
+        if (nfcFL.nfcNxpEse &&
+            nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("%s: NFA_PASSIVE_LISTEN_DISABLED_EVT", __func__);
+          SyncEventGuard g(SecureElement::getInstance().mPassiveListenEvt);
+          SecureElement::getInstance().mPassiveListenEvt.notifyOne();
+        }
+      } break;
+
+      case NFA_LISTEN_ENABLED_EVT: {
+        if (nfcFL.nfcNxpEse &&
+            nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("%s: NFA_LISTEN_ENABLED_EVT", __func__);
+          SyncEventGuard g(SecureElement::getInstance().mPassiveListenEvt);
+          SecureElement::getInstance().mPassiveListenEvt.notifyOne();
+        }
+      } break;
+#endif
+      default:
+        LOG(ERROR) << StringPrintf("%s: unknown event ????", __func__);
         break;
+    }
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_initNativeStruc
+  **
+  ** Description:     Initialize variables.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  static jboolean nfcManager_initNativeStruc(JNIEnv * e, jobject o) {
+    initializeGlobalDebugEnabledFlag();
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+#if (NXP_EXTNS == TRUE)
+    nfc_jni_native_data* nat =
+        (nfc_jni_native_data*)malloc(sizeof(struct nfc_jni_native_data));
+/*JCOP OS Download protection case to be handled*/
+#else
+  nfc_jni_native_data* nat =
+      (nfc_jni_native_data*)malloc(sizeof(struct nfc_jni_native_data));
+#endif
 
-        case NFA_ACTIVATED_EVT:
-        {
-            ALOGV("%s: NFA_ACTIVATED_EVT: gIsSelectingRfInterface=%d, sIsDisabling=%d", __func__, gIsSelectingRfInterface, sIsDisabling);
-#if(NXP_EXTNS == TRUE)
-            rfActivation = true;
+    if (nat == NULL) {
+      LOG(ERROR) << StringPrintf("%s: fail allocate native data", __func__);
+      return JNI_FALSE;
+    }
 
-            checkforTranscation(NFA_ACTIVATED_EVT, (void *)eventData);
+    memset(nat, 0, sizeof(*nat));
+    e->GetJavaVM(&(nat->vm));
+    nat->env_version = e->GetVersion();
+    nat->manager = e->NewGlobalRef(o);
 
-            NfcTag::getInstance().selectCompleteStatus(true);
+    ScopedLocalRef<jclass> cls(e, e->GetObjectClass(o));
+    jfieldID f = e->GetFieldID(cls.get(), "mNative", "J");
+    e->SetLongField(o, f, (jlong)nat);
 
-            /***P2P-Prio Logic for Multiprotocol***/
-            if( (eventData->activated.activate_ntf.protocol == NFA_PROTOCOL_NFC_DEP) && (multiprotocol_detected == 1) )
-            {
-                ALOGV("Prio_Logic_multiprotocol stop timer");
-                multiprotocol_timer.kill();
-            }
+    MposManager::initMposNativeStruct(e, o);
+    /* Initialize native cached references */
+    gCachedNfcManagerNotifyNdefMessageListeners =
+        e->GetMethodID(cls.get(), "notifyNdefMessageListeners",
+                       "(Lcom/android/nfc/dhimpl/NativeNfcTag;)V");
+    gCachedNfcManagerNotifyConnectivityListeners =
+        e->GetMethodID(cls.get(), "notifyConnectivityListeners", "(I)V");
+    gCachedNfcManagerNotifyEmvcoMultiCardDetectedListeners = e->GetMethodID(
+        cls.get(), "notifyEmvcoMultiCardDetectedListeners", "()V");
+    gCachedNfcManagerNotifyLlcpLinkActivation =
+        e->GetMethodID(cls.get(), "notifyLlcpLinkActivation",
+                       "(Lcom/android/nfc/dhimpl/NativeP2pDevice;)V");
+    gCachedNfcManagerNotifyLlcpLinkDeactivated =
+        e->GetMethodID(cls.get(), "notifyLlcpLinkDeactivated",
+                       "(Lcom/android/nfc/dhimpl/NativeP2pDevice;)V");
+    gCachedNfcManagerNotifyLlcpFirstPacketReceived =
+        e->GetMethodID(cls.get(), "notifyLlcpLinkFirstPacketReceived",
+                       "(Lcom/android/nfc/dhimpl/NativeP2pDevice;)V");
+    sCachedNfcManagerNotifyTargetDeselected =
+        e->GetMethodID(cls.get(), "notifyTargetDeselected", "()V");
+    gCachedNfcManagerNotifySeFieldActivated =
+        e->GetMethodID(cls.get(), "notifySeFieldActivated", "()V");
+    gCachedNfcManagerNotifySeFieldDeactivated =
+        e->GetMethodID(cls.get(), "notifySeFieldDeactivated", "()V");
+    gCachedNfcManagerNotifySeListenActivated =
+        e->GetMethodID(cls.get(), "notifySeListenActivated", "()V");
+    gCachedNfcManagerNotifySeListenDeactivated =
+        e->GetMethodID(cls.get(), "notifySeListenDeactivated", "()V");
+
+    gCachedNfcManagerNotifyHostEmuActivated =
+        e->GetMethodID(cls.get(), "notifyHostEmuActivated", "(I)V");
+
+    gCachedNfcManagerNotifyAidRoutingTableFull =
+        e->GetMethodID(cls.get(), "notifyAidRoutingTableFull", "()V");
+
+    gCachedNfcManagerNotifyHostEmuData =
+        e->GetMethodID(cls.get(), "notifyHostEmuData", "(I[B)V");
+
+    gCachedNfcManagerNotifyHostEmuDeactivated =
+        e->GetMethodID(cls.get(), "notifyHostEmuDeactivated", "(I)V");
+
+    gCachedNfcManagerNotifyRfFieldActivated =
+        e->GetMethodID(cls.get(), "notifyRfFieldActivated", "()V");
+    gCachedNfcManagerNotifyRfFieldDeactivated =
+        e->GetMethodID(cls.get(), "notifyRfFieldDeactivated", "()V");
+
+    sCachedNfcManagerNotifySeApduReceived =
+        e->GetMethodID(cls.get(), "notifySeApduReceived", "([B)V");
+
+    sCachedNfcManagerNotifySeMifareAccess =
+        e->GetMethodID(cls.get(), "notifySeMifareAccess", "([B)V");
+
+    sCachedNfcManagerNotifySeEmvCardRemoval =
+        e->GetMethodID(cls.get(), "notifySeEmvCardRemoval", "()V");
+
+    gCachedNfcManagerNotifyTransactionListeners = e->GetMethodID(
+        cls.get(), "notifyTransactionListeners", "([B[BLjava/lang/String;)V");
 
-            if( (eventData->activated.activate_ntf.protocol == NFA_PROTOCOL_T3T) && (multiprotocol_detected == 1) )
-            {
-                ALOGV("Prio_Logic_multiprotocol stop timer");
-                multiprotocol_timer.kill();
-                clear_multiprotocol();
-            }
-#endif
-            if(nfcFL.nfcNxpEse) {
-                if(nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
-                    /*
-                     * Handle Reader over SWP START_READER_EVENT
-                     * */
-                    if(eventData->activated.activate_ntf.intf_param.type == NCI_INTERFACE_UICC_DIRECT_STAT ||
-                          eventData->activated.activate_ntf.intf_param.type == NCI_INTERFACE_ESE_DIRECT_STAT)
-                    {
-                        SecureElement::getInstance().notifyEEReaderEvent(NFA_RD_SWP_READER_START, eventData->activated.activate_ntf.rf_tech_param.mode);
-                        gReaderNotificationflag = true;
-                        break;
-                    }
-                }
-            }
-            if((eventData->activated.activate_ntf.protocol != NFA_PROTOCOL_NFC_DEP) && (!isListenMode(eventData->activated)))
-            {
-                nativeNfcTag_setRfInterface ((tNFA_INTF_TYPE) eventData->activated.activate_ntf.intf_param.type);
-            }
-
-            if (EXTNS_GetConnectFlag() == true)
-            {
-                NfcTag::getInstance().setActivationState ();
-                nativeNfcTag_doConnectStatus(true);
-                break;
-            }
-
-            NfcTag::getInstance().setActive(true);
-
-            if (sIsDisabling || !sIsNfaEnabled)
-                break;
-
-            gActivated = true;
+#if (NXP_EXTNS == TRUE)
+    gCachedNfcManagerNotifyReRoutingEntry =
+        e->GetMethodID(cls.get(), "notifyReRoutingEntry", "()V");
 
-            NfcTag::getInstance().setActivationState ();
+    gCachedNfcManagerNotifyUiccStatusEvent =
+        e->GetMethodID(cls.get(), "notifyUiccStatusEvent", "(I)V");
 
-            if (gIsSelectingRfInterface)
-            {
-                nativeNfcTag_doConnectStatus(true);
-                if (NfcTag::getInstance ().isCashBeeActivated() == true || NfcTag::getInstance ().isEzLinkTagActivated() == true)
-                {
-                    NfcTag::getInstance().connectionEventHandler (NFA_ACTIVATED_UPDATE_EVT, eventData);
-                }
-                break;
-            }
+#if (NXP_NFCC_HCE_F == TRUE)
+    gCachedNfcManagerNotifyT3tConfigure =
+        e->GetMethodID(cls.get(), "notifyT3tConfigure", "()V");
+#endif
+    gCachedNfcManagerNotifyJcosDownloadInProgress =
+        e->GetMethodID(cls.get(), "notifyJcosDownloadInProgress", "(I)V");
 
-            nativeNfcTag_resetPresenceCheck();
+    gCachedNfcManagerNotifyFwDwnldRequested =
+        e->GetMethodID(cls.get(), "notifyFwDwnldRequested", "()V");
 
-            if (isPeerToPeer(eventData->activated))
-            {
-                if (sReaderModeEnabled)
-                {
-#if(NXP_EXTNS == TRUE)
-                    /* If last transaction is complete or prev state is idle
-                     * then proceed to next state*/
-                    if (isActivatedTypeF(eventData->activated) &&
-                            (sTechMask & NFA_TECHNOLOGY_MASK_F) &&
-                            ((gFelicaReaderState == STATE_IDLE) ||
-                                    (gFelicaReaderState == STATE_FRAMERF_INTF_SELECTED)))
-                    {
-                        ALOGV("%s: Activating Reader Mode in P2P ", __func__);
-                        gFelicaReaderState = STATE_NFCDEP_ACTIVATED_NFCDEP_INTF;
-                        switchP2PToT3TRead(eventData->activated.activate_ntf.rf_disc_id);
-                    }
-                    else
-                    {
-                        ALOGV("%s: Invalid FelicaReaderState : %d  ", __func__,gFelicaReaderState);
-                        gFelicaReaderState = STATE_IDLE;
-#endif
-                        ALOGV("%s: Ignoring P2P target in reader mode.", __func__);
-                        NFA_Deactivate (false);
-#if(NXP_EXTNS == TRUE)
-                    }
 #endif
-                    break;
-                }
-                sP2pActive = true;
-                ALOGV("%s: NFA_ACTIVATED_EVT: P2P is activated", __func__);
-                if ((nfcFL.nfcNxpEse && nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) &&
-                        (SecureElement::getInstance().mIsWiredModeOpen &&
-                                SecureElement::getInstance().mPassiveListenEnabled == true)) {
-                    SecureElement::getInstance().mPassiveListenTimer.kill();
-                }
+    if (nfc_jni_cache_object(e, gNativeNfcTagClassName,
+                             &(nat->cached_NfcTag)) == -1) {
+      LOG(ERROR) << StringPrintf("%s: fail cache NativeNfcTag", __func__);
+      free(nat);
+      return JNI_FALSE;
+    }
 
-                /* For Secure Element, consider the field to be on while P2P is active */
-                SecureElement::getInstance().notifyRfFieldEvent (true);
-#if(NXP_EXTNS == TRUE)
-                if(nfcFL.nfcNxpEse &&
-                        (nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME != nfcFL.eseFL._ESE_WIRED_MODE_RESUME)) {
-                    SecureElement::getInstance().setDwpTranseiveState(false, NFCC_ACTIVATED_NTF);
-                }
-#endif
-            }
-            else if (pn544InteropIsBusy() == false)
-            {
-#if(NXP_EXTNS == TRUE && NFC_NXP_NON_STD_CARD == TRUE)
-                nativeNfcTag_handleNonNciMultiCardDetection(connEvent, eventData);
-                ALOGV("%s: scoreGenericNtf = 0x%x", __func__ ,scoreGenericNtf);
-                if(scoreGenericNtf == true)
-                {
-                    if( (eventData->activated.activate_ntf.intf_param.type == NFC_INTERFACE_ISO_DEP) && (eventData->activated.activate_ntf.protocol == NFC_PROTOCOL_ISO_DEP) )
-                    {
-                        nativeNfcTag_handleNonNciCardDetection(eventData);
-                    }
-                    scoreGenericNtf = false;
-                }
-#else
-                NfcTag::getInstance().connectionEventHandler (connEvent, eventData);
+    if (nfc_jni_cache_object(e, gNativeP2pDeviceClassName,
+                             &(nat->cached_P2pDevice)) == -1) {
+      LOG(ERROR) << StringPrintf("%s: fail cache NativeP2pDevice", __func__);
+      free(nat);
+      return JNI_FALSE;
+    }
 
-                if(NfcTag::getInstance ().mNumDiscNtf)
-                {
-                    NFA_Deactivate (true);
-                }
-#endif
-                /* We know it is not activating for P2P.  If it activated in
-                 * listen mode then it is likely for an SE transaction.
-                 * Send the RF Event */
-                if (isListenMode(eventData->activated))
-                {
-                    sSeRfActive = true;
-                    SecureElement::getInstance().notifyListenModeState (true);
-#if(NXP_EXTNS == TRUE)
-                    if ((nfcFL.nfcNxpEse && nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) &&
-                            (SecureElement::getInstance().mIsWiredModeOpen &&
-                                    SecureElement::getInstance().mPassiveListenEnabled == true))
-                    {
-                        SecureElement::getInstance().mPassiveListenTimer.kill();
-                    }
+    gNativeData = getNative(e, o);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+    return JNI_TRUE;
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfaDeviceManagementCallback
+  **
+  ** Description:     Receive device management events from stack.
+  **                  dmEvent: Device-management event ID.
+  **                  eventData: Data associated with event ID.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void nfaDeviceManagementCallback(uint8_t dmEvent,
+                                   tNFA_DM_CBACK_DATA * eventData) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: enter; event=0x%X", __func__, dmEvent);
+
+    switch (dmEvent) {
+      case NFA_DM_ENABLE_EVT: /* Result of NFA_Enable */
+      {
+        SyncEventGuard guard(sNfaEnableEvent);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: NFA_DM_ENABLE_EVT; status=0x%X", __func__, eventData->status);
+        sIsNfaEnabled = eventData->status == NFA_STATUS_OK;
+#if (NXP_EXTNS == TRUE)
+        sEnableStatus = eventData->status;
 #endif
-                }
-            }
+        sIsDisabling = false;
+        sNfaEnableEvent.notifyOne();
+      } break;
+
+      case NFA_DM_DISABLE_EVT: /* Result of NFA_Disable */
+      {
+        SyncEventGuard guard(sNfaDisableEvent);
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: NFA_DM_DISABLE_EVT", __func__);
+        sIsNfaEnabled = false;
+        sIsDisabling = false;
+        sNfaDisableEvent.notifyOne();
+      } break;
+
+      case NFA_DM_SET_CONFIG_EVT:  // result of NFA_SetConfig
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: NFA_DM_SET_CONFIG_EVT", __func__);
+        {
+          SyncEventGuard guard(sNfaSetConfigEvent);
+          sNfaSetConfigEvent.notifyOne();
         }
         break;
 
-        case NFA_DEACTIVATED_EVT:
+      case NFA_DM_GET_CONFIG_EVT: /* Result of NFA_GetConfig */
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: NFA_DM_GET_CONFIG_EVT", __func__);
         {
-            ALOGV("%s: NFA_DEACTIVATED_EVT: Type=%u, gIsTagDeactivating=%d", __func__, eventData->deactivated.type, gIsTagDeactivating);
-#if (NXP_EXTNS == TRUE)
-            rfActivation = false;
-            if((nfcFL.chipType == pn547C2) &&
-                    (eventData->deactivated.type == NFA_DEACTIVATE_TYPE_IDLE)) {
-                checkforTranscation(NFA_DEACTIVATED_EVT, (void *)eventData);
-            }
-#if (NFC_NXP_NON_STD_CARD == TRUE)
-            if(checkCmdSent == 1 && eventData->deactivated.type == 0)
-            {
-                ALOGV("%s: NFA_DEACTIVATED_EVT: Setting check flag  to one", __func__);
-                checkTagNtf = 1;
-            }
-#endif
-#endif
-
-            notifyPollingEventwhileNfcOff();
-
-            if (true == getReconnectState())
-            {
-                ALOGV("Reconnect in progress : Do nothing");
-                break;
-            }
-
-            gReaderNotificationflag = false;
+          HciRFParams::getInstance().connectionEventHandler(dmEvent, eventData);
+          SyncEventGuard guard(sNfaGetConfigEvent);
+          if (eventData->status == NFA_STATUS_OK &&
+              eventData->get_config.tlv_size <= sizeof(sConfig)) {
+            sCurrentConfigLen = eventData->get_config.tlv_size;
+            memcpy(sConfig, eventData->get_config.param_tlvs,
+                   eventData->get_config.tlv_size);
 
-#if(NXP_EXTNS == TRUE)
-            /* P2P-priority logic for multiprotocol tags */
-            if( (multiprotocol_detected == 1) && (sP2pActive == 1) )
-            {
-                NfcTag::getInstance ().mNumDiscNtf = 0;
-                clear_multiprotocol();
-                multiprotocol_flag = 1;
-            }
-            if(gIsWaiting4Deact2SleepNtf)
-            {
-                if(eventData->deactivated.type == NFA_DEACTIVATE_TYPE_IDLE)
-                {
-                    gGotDeact2IdleNtf = true;
-                }
-                else if(eventData->deactivated.type == NFA_DEACTIVATE_TYPE_SLEEP)
-                {
-                    gIsWaiting4Deact2SleepNtf = false;
-                }
-            }
-#endif
-            NfcTag::getInstance().setDeactivationState (eventData->deactivated);
-
-            if(NfcTag::getInstance ().mNumDiscNtf)
-            {
-                NfcTag::getInstance ().mNumDiscNtf--;
-                NfcTag::getInstance().selectNextTag();
-            }
-
-            if (eventData->deactivated.type != NFA_DEACTIVATE_TYPE_SLEEP)
-            {
-                {
-                    SyncEventGuard guard (gDeactivatedEvent);
-                    gActivated = false;
-                    gDeactivatedEvent.notifyOne ();
-                }
-#if(NXP_EXTNS == TRUE)
-                if ((nfcFL.nfcNxpEse && nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) &&
-                        (SecureElement::getInstance().mIsWiredModeOpen &&
-                                SecureElement::getInstance().mPassiveListenEnabled))
-                {
-                    SecureElement::getInstance().startThread(0x00);
-                }
-#endif
-                NfcTag::getInstance ().mNumDiscNtf = 0;
-                NfcTag::getInstance ().mTechListIndex =0;
-                nativeNfcTag_resetPresenceCheck();
-                NfcTag::getInstance().connectionEventHandler (connEvent, eventData);
-                nativeNfcTag_abortWaits();
-                NfcTag::getInstance().abort ();
-                NfcTag::getInstance().mIsMultiProtocolTag = false;
-            }
-            else if (gIsTagDeactivating)
-            {
-                NfcTag::getInstance ().setActive (false);
-                nativeNfcTag_doDeactivateStatus (0);
-            }
-            else if (EXTNS_GetDeactivateFlag () == true)
-            {
-                NfcTag::getInstance ().setActive (false);
-                nativeNfcTag_doDeactivateStatus (0);
-            }
+#if (NXP_EXTNS == TRUE)
+            if (sCheckNfceeFlag) checkforNfceeBuffer();
 
-            /* If RF is activated for what we think is a Secure Element transaction
-             * and it is deactivated to either IDLE or DISCOVERY mode, notify wait event */
-            if ( (eventData->deactivated.type == NFA_DEACTIVATE_TYPE_IDLE) ||
-                 (eventData->deactivated.type == NFA_DEACTIVATE_TYPE_DISCOVERY) )
-            {
-#if(NXP_EXTNS == TRUE)
-                if(nfcFL.nfccFL._NFCEE_REMOVED_NTF_RECOVERY &&
-                        RoutingManager::getInstance().is_ee_recovery_ongoing())
-                {
-                    recovery=false;
-                    SyncEventGuard guard (SecureElement::getInstance().mEEdatapacketEvent);
-                    SecureElement::getInstance().mEEdatapacketEvent.notifyOne();
-                }
-#endif
-                if (sSeRfActive)
-                {
-                    sSeRfActive = false;
-                    if (!sIsDisabling && sIsNfaEnabled)
-                        SecureElement::getInstance().notifyListenModeState (false);
-                }
-                else if (sP2pActive)
-                {
-                    sP2pActive = false;
-                    SecureElement::getInstance().notifyRfFieldEvent (false);
-                    ALOGV("%s: NFA_DEACTIVATED_EVT: is p2p", __func__);
-                }
-            }
-#if(NXP_EXTNS == TRUE)
-            if (sReaderModeEnabled && (eventData->deactivated.type == NFA_DEACTIVATE_TYPE_SLEEP))
-            {
-                if(gFelicaReaderState == STATE_NFCDEP_ACTIVATED_NFCDEP_INTF)
-                {
-                    SyncEventGuard g (sRespCbEvent);
-                    ALOGV("%s: Sending Sem Post for Deactivated", __func__);
-                    sRespCbEvent.notifyOne ();
-                    ALOGV("Switching to T3T\n");
-                    gFelicaReaderState = STATE_DEACTIVATED_TO_SLEEP;
-                }
-                else
-                {
-                    ALOGV("%s: FelicaReaderState Invalid", __func__);
-                    gFelicaReaderState = STATE_IDLE;
-                }
-            }
+            if (eSEPhyIntfInResponsive(eventData)) recoverEseConnectivity();
 #endif
+          } else {
+            LOG(ERROR) << StringPrintf("%s: NFA_DM_GET_CONFIG failed",
+                                       __func__);
+            sCurrentConfigLen = 0;
+          }
+          sNfaGetConfigEvent.notifyOne();
         }
         break;
 
-        case NFA_TLV_DETECT_EVT:
-        {
-            status = eventData->tlv_detect.status;
-            ALOGV("%s: NFA_TLV_DETECT_EVT status = 0x%0X, protocol = %d, num_tlvs = %d, num_bytes = %d",
-                 __func__, status, eventData->tlv_detect.protocol,
-                 eventData->tlv_detect.num_tlvs, eventData->tlv_detect.num_bytes);
-            if (status != NFA_STATUS_OK)
-            {
-                ALOGE("%s: NFA_TLV_DETECT_EVT error: status = 0x%0X", __func__, status);
-            }
+      case NFA_DM_RF_FIELD_EVT:
+        checkforTranscation(NFA_TRANS_DM_RF_FIELD_EVT, (void*)eventData);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: NFA_DM_RF_FIELD_EVT; status=0x%X; field status=%u", __func__,
+            eventData->rf_field.status, eventData->rf_field.rf_field_status);
+        if (sIsDisabling || !sIsNfaEnabled) break;
+
+        if (!sP2pActive && eventData->rf_field.status == NFA_STATUS_OK) {
+          SecureElement::getInstance().notifyRfFieldEvent(
+              eventData->rf_field.rf_field_status == NFA_DM_RF_FIELD_ON);
+          struct nfc_jni_native_data* nat = getNative(NULL, NULL);
+          JNIEnv* e = NULL;
+          ScopedAttach attach(nat->vm, &e);
+          if (e == NULL) {
+            LOG(ERROR) << StringPrintf("jni env is null");
+            return;
+          }
+          if (eventData->rf_field.rf_field_status == NFA_DM_RF_FIELD_ON) {
+            if (!pTransactionController->transactionAttempt(
+                    TRANSACTION_REQUESTOR(RF_FIELD_EVT))) {
+              DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+                  "%s: RF field on evnt Not allowing to set", __FUNCTION__);
+            }
+            sRfFieldOff = false;
+            e->CallVoidMethod(nat->manager,
+                              android::gCachedNfcManagerNotifyRfFieldActivated);
+          } else {
+            /*In case of if Field On is not received before activation, consider
+             NFA_ACTIVATED_EVENT for
+             locking the transaction and use Field Off received while removing
+             the reader from proximity to end the lock*/
+            if (pTransactionController->getCurTransactionRequestor() ==
+                TRANSACTION_REQUESTOR(NFA_ACTIVATED_EVENT)) {
+              pTransactionController->transactionEnd(
+                  TRANSACTION_REQUESTOR(NFA_ACTIVATED_EVENT));
+            } else {
+              pTransactionController->transactionEnd(
+                  TRANSACTION_REQUESTOR(RF_FIELD_EVT));
+            }
+            sRfFieldOff = true;
+            e->CallVoidMethod(
+                nat->manager,
+                android::gCachedNfcManagerNotifyRfFieldDeactivated);
+          }
         }
         break;
 
-        case NFA_NDEF_DETECT_EVT:
-        {
-            /* NDEF Detection procedure is completed,
-             * if status is failure, it means the tag does not contain any or valid NDEF data
-             * pass the failure status to the NFC Service */
-            status = eventData->ndef_detect.status;
-            ALOGV("%s: NFA_NDEF_DETECT_EVT status = 0x%0X, protocol = %u, "
-                  "max_size = %u, cur_size = %u, flags = 0x%X", __func__,
-                 status,
-                 eventData->ndef_detect.protocol, eventData->ndef_detect.max_size,
-                 eventData->ndef_detect.cur_size, eventData->ndef_detect.flags);
-            NfcTag::getInstance().connectionEventHandler (connEvent, eventData);
-            nativeNfcTag_doCheckNdefResult(status,
-                eventData->ndef_detect.max_size, eventData->ndef_detect.cur_size,
-                eventData->ndef_detect.flags);
+      case NFA_DM_NFCC_TRANSPORT_ERR_EVT:
+      case NFA_DM_NFCC_TIMEOUT_EVT: {
+        if (dmEvent == NFA_DM_NFCC_TIMEOUT_EVT)
+          LOG(ERROR) << StringPrintf("%s: NFA_DM_NFCC_TIMEOUT_EVT; abort",
+                                     __func__);
+        else if (dmEvent == NFA_DM_NFCC_TRANSPORT_ERR_EVT)
+          LOG(ERROR) << StringPrintf("%s: NFA_DM_NFCC_TRANSPORT_ERR_EVT; abort",
+                                     __func__);
+        if (nfcFL.eseFL._JCOP_WA_ENABLE) {
+          NFA_HciW4eSETransaction_Complete(Wait);
         }
-        break;
-
-        case NFA_DATA_EVT:
+        nativeNfcTag_abortWaits();
+        NfcTag::getInstance().abort();
+        sAbortConnlessWait = true;
+        nativeLlcpConnectionlessSocket_abortWait();
         {
-            /* Data message received (for non-NDEF reads) */
-            ALOGV("%s: NFA_DATA_EVT: status = 0x%X, len = %d", __func__, eventData->status, eventData->data.len);
-            nativeNfcTag_doTransceiveStatus(eventData->status, eventData->data.p_data, eventData->data.len);
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "%s: aborting  sNfaEnableDisablePollingEvent", __func__);
+          SyncEventGuard guard(sNfaEnableDisablePollingEvent);
+          sNfaEnableDisablePollingEvent.notifyOne();
         }
-        break;
-
-        case NFA_RW_INTF_ERROR_EVT:
         {
-            ALOGV("%s: NFA_RW_INTF_ERROR_EVT", __func__);
-            nativeNfcTag_notifyRfTimeout();
-            nativeNfcTag_doReadCompleted (NFA_STATUS_TIMEOUT);
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("%s: aborting  sNfaEnableEvent", __func__);
+          SyncEventGuard guard(sNfaEnableEvent);
+          sNfaEnableEvent.notifyOne();
         }
-        break;
-
-        case NFA_SELECT_CPLT_EVT:
         {
-            status = eventData->status;
-            ALOGV("%s: NFA_SELECT_CPLT_EVT: status = 0x%0X", __func__, status);
-            if (status != NFA_STATUS_OK)
-            {
-                ALOGE("%s: NFA_SELECT_CPLT_EVT error: status = 0x%0X", __func__, status);
-            }
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("%s: aborting  sNfaDisableEvent", __func__);
+          SyncEventGuard guard(sNfaDisableEvent);
+          sNfaDisableEvent.notifyOne();
         }
-        break;
+        sDiscoveryEnabled = false;
+        sPollingEnabled = false;
+        PowerSwitch::getInstance().abort();
 
-        case NFA_READ_CPLT_EVT:
-        {
-            ALOGV("%s: NFA_READ_CPLT_EVT: status = 0x%0X", __func__, eventData->status);
-            nativeNfcTag_doReadCompleted (eventData->status);
-            NfcTag::getInstance().connectionEventHandler (connEvent, eventData);
+        if (!sIsDisabling && sIsNfaEnabled) {
+          EXTNS_Close();
+          NFA_Disable(false);
+          sIsDisabling = true;
+        } else {
+          sIsNfaEnabled = false;
+          sIsDisabling = false;
         }
-        break;
-
-        case NFA_WRITE_CPLT_EVT:
-        {
-            ALOGV("%s: NFA_WRITE_CPLT_EVT: status = 0x%0X", __func__, eventData->status);
-            nativeNfcTag_doWriteStatus (eventData->status == NFA_STATUS_OK);
+        PowerSwitch::getInstance().initialize(PowerSwitch::UNKNOWN_LEVEL);
+#if (NXP_EXTNS == TRUE)
+        if (eventData->status == NFA_STATUS_FAILED) {
+          LOG(ERROR) << StringPrintf("%s: Disabling NFC service", __func__);
+        } else {
+#endif
+          LOG(ERROR) << StringPrintf("%s: crash NFC service", __func__);
+          //////////////////////////////////////////////
+          // crash the NFC service process so it can restart automatically
+          abort();
+//////////////////////////////////////////////
+#if (NXP_EXTNS == TRUE)
         }
-        break;
+#endif
+      } break;
 
-        case NFA_SET_TAG_RO_EVT:
-        {
-            ALOGV("%s: NFA_SET_TAG_RO_EVT: status = 0x%0X", __func__, eventData->status);
-            nativeNfcTag_doMakeReadonlyResult(eventData->status);
-        }
+      case NFA_DM_PWR_MODE_CHANGE_EVT:
+        PowerSwitch::getInstance().deviceManagementCallback(dmEvent, eventData);
         break;
 
-        case NFA_CE_NDEF_WRITE_START_EVT:
-        {
-            ALOGV("%s: NFA_CE_NDEF_WRITE_START_EVT: status: 0x%0X", __func__, eventData->status);
-            if (eventData->status != NFA_STATUS_OK)
-                ALOGE("%s: NFA_CE_NDEF_WRITE_START_EVT error: status = 0x%0X", __func__, eventData->status);
+#if (NXP_EXTNS == TRUE)
+      case NFA_DM_SET_ROUTE_CONFIG_REVT:
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: NFA_DM_SET_ROUTE_CONFIG_REVT; status=0x%X",
+                            __func__, eventData->status);
+        if (eventData->status != NFA_STATUS_OK) {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("AID Routing table configuration Failed!!!");
+        } else {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("AID Routing Table configured.");
         }
+        RoutingManager::getInstance().mLmrtEvent.notifyOne();
         break;
 
-        case NFA_CE_NDEF_WRITE_CPLT_EVT:
-        {
-            ALOGV("%s: NFA_CE_NDEF_WRITE_CPLT_EVT: len = %u", __func__, eventData->ndef_write_cplt.len);
+      case NFA_DM_GET_ROUTE_CONFIG_REVT: {
+        RoutingManager::getInstance().processGetRoutingRsp(eventData,
+                                                           sRoutingBuff);
+        if (eventData->status == NFA_STATUS_OK) {
+          SyncEventGuard guard(sNfaGetRoutingEvent);
+          sNfaGetRoutingEvent.notifyOne();
         }
         break;
-
-        case NFA_LLCP_ACTIVATED_EVT:
-        {
-            ALOGV("%s: NFA_LLCP_ACTIVATED_EVT: is_initiator: %d  remote_wks: %d, remote_lsc: %d, remote_link_miu: %d, local_link_miu: %d",
-                 __func__,
-                 eventData->llcp_activated.is_initiator,
-                 eventData->llcp_activated.remote_wks,
-                 eventData->llcp_activated.remote_lsc,
-                 eventData->llcp_activated.remote_link_miu,
-                 eventData->llcp_activated.local_link_miu);
-            PeerToPeer::getInstance().llcpActivatedHandler (getNative(0, 0), eventData->llcp_activated);
+      }
+      case NFA_DM_EE_HCI_DISABLE: {
+        if (nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("NFA_DM_EE_HCI_DISABLE wait releasing");
+          SyncEventGuard guard(sNfceeHciCbDisableEvent);
+          sNfceeHciCbDisableEvent.notifyOne();
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("NFA_DM_EE_HCI_DISABLE wait released");
         }
         break;
-
-        case NFA_LLCP_DEACTIVATED_EVT:
-        {
-            ALOGV("%s: NFA_LLCP_DEACTIVATED_EVT", __func__);
-            PeerToPeer::getInstance().llcpDeactivatedHandler (getNative(0, 0), eventData->llcp_deactivated);
+      }
+      case NFA_DM_EE_HCI_ENABLE: {
+        if (nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("NFA_DM_EE_HCI_ENABLE wait releasing");
+          SyncEventGuard guard(sNfceeHciCbEnableEvent);
+          sNfceeHciCbEnableEvent.notifyOne();
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("NFA_DM_EE_HCI_ENABLE wait released");
         }
         break;
-
-        case NFA_LLCP_FIRST_PACKET_RECEIVED_EVT:
-        {
-            ALOGV("%s: NFA_LLCP_FIRST_PACKET_RECEIVED_EVT", __func__);
-            PeerToPeer::getInstance().llcpFirstPacketHandler (getNative(0, 0));
-        }
+      }
+      case NFA_DM_SET_TRANSIT_CONFIG_EVT: {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("NFA_DM_SET_TRANSIT_CONFIG EVT cback received");
+        SyncEventGuard guard(sNfaTransitConfigEvent);
+        sNfaTransitConfigEvent.notifyOne();
         break;
-
-        case NFA_PRESENCE_CHECK_EVT:
-        {
-            ALOGV("%s: NFA_PRESENCE_CHECK_EVT", __func__);
-            nativeNfcTag_doPresenceCheckResult (eventData->status);
-        }
+      }
+#endif
+      case NFA_DM_SET_POWER_SUB_STATE_EVT: {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: NFA_DM_SET_POWER_SUB_STATE_EVT; status=0x%X",
+                            __FUNCTION__, eventData->power_sub_state.status);
+        SyncEventGuard guard(sNfaSetPowerSubState);
+        sNfaSetPowerSubState.notifyOne();
+      } break;
+      case NFA_DM_EMVCO_PCD_COLLISION_EVT:
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "STATUS_EMVCO_PCD_COLLISION - Multiple card detected");
+        SecureElement::getInstance().notifyEmvcoMultiCardDetectedListeners();
         break;
 
-        case NFA_FORMAT_CPLT_EVT:
-        {
-            ALOGV("%s: NFA_FORMAT_CPLT_EVT: status = 0x%0X", __func__, eventData->status);
-            nativeNfcTag_formatStatus (eventData->status == NFA_STATUS_OK);
-        }
+      default:
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: unhandled event", __func__);
         break;
+    }
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_sendRawFrame
+  **
+  ** Description:     Send a raw frame.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  static jboolean nfcManager_sendRawFrame(JNIEnv * e, jobject,
+                                          jbyteArray data) {
+    size_t bufLen = 0x00;
+    uint8_t* buf = NULL;
+    tNFA_STATUS status;
+    if (data != NULL) {
+      ScopedByteArrayRO bytes(e, data);
+      buf = const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0]));
+      bufLen = bytes.size();
 
-        case NFA_I93_CMD_CPLT_EVT:
-        {
-            ALOGV("%s: NFA_I93_CMD_CPLT_EVT: status = 0x%0X", __func__, eventData->status);
+#if (NXP_EXTNS == TRUE)
+      if (nfcFL.nfccFL._NXP_NFCC_EMPTY_DATA_PACKET) {
+        RoutingManager::getInstance().mNfcFRspTimer.kill();
+        if (bufLen == 0) {
+          gIsEmptyRspSentByHceFApk = true;
         }
-        break;
+      }
+#endif
+      DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("nfcManager_sendRawFrame(): bufLen:%lu", bufLen);
+      status = NFA_SendRawFrame(buf, bufLen, 0);
+    } else {
+      DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("data is NULL ..Returning..");
+      status = NFA_STATUS_FAILED;
+    }
+    return (status == NFA_STATUS_OK);
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_routeAid
+  **
+  ** Description:     Route an AID to an EE
+  **                  e: JVM environment.
+  **                  aid: aid to be added to routing table.
+  **                  route: aid route location. i.e. DH/eSE/UICC
+  **                  power: power state
+  **                  aidInfo: prefix or suffix aid.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  static jboolean nfcManager_routeAid(JNIEnv * e, jobject, jbyteArray aid,
+                                      jint route, jint power, jint aidInfo) {
+    ScopedByteArrayRO bytes(e, aid);
+    uint8_t* buf =
+        const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0]));
+    size_t bufLen = bytes.size();
 
-        case NFA_CE_UICC_LISTEN_CONFIGURED_EVT :
-        {
-            ALOGV("%s: NFA_CE_UICC_LISTEN_CONFIGURED_EVT : status = 0x%0X", __func__, eventData->status);
-            SecureElement::getInstance().connectionEventHandler (connEvent, eventData);
-        }
-        break;
+#if (NXP_EXTNS == TRUE)
+    if ((nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) &&
+        (route == 2 || route == 4)) {  // UICC or UICC2 HANDLE
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "sCurrentSelectedUICCSlot:  %d", sCurrentSelectedUICCSlot);
+      route = (sCurrentSelectedUICCSlot != 0x02) ? 0x02 : 0x04;
+    }
+    /*In case of 66T/67T field on is observed as last field event once reader
+     is removed from proximity, which will hold the transaction lock
+     unnecessarily
+     In such cases end the lock as it is not required*/
+    if (((nfcFL.chipType == pn548C2) || (nfcFL.chipType == pn551)) &&
+        pTransactionController->getCurTransactionRequestor() ==
+            TRANSACTION_REQUESTOR(RF_FIELD_EVT)) {
+      pTransactionController->transactionEnd(
+          TRANSACTION_REQUESTOR(RF_FIELD_EVT));
+    }
+    bool result = RoutingManager::getInstance().addAidRouting(
+        buf, bufLen, route, power, aidInfo);
+#else
+  bool result =
+      RoutingManager::getInstance().addAidRouting(buf, bufLen, route, aidInfo);
 
-        case NFA_CE_ESE_LISTEN_CONFIGURED_EVT :
-        {
-            ALOGV("%s: NFA_CE_ESE_LISTEN_CONFIGURED_EVT : status = 0x%0X", __func__, eventData->status);
-            SecureElement::getInstance().connectionEventHandler (connEvent, eventData);
-        }
-        break;
+#endif
+    return result;
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_unrouteAid
+  **
+  ** Description:     Remove a AID routing
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  static jboolean nfcManager_unrouteAid(JNIEnv * e, jobject, jbyteArray aid) {
+    ScopedByteArrayRO bytes(e, aid);
+    uint8_t* buf =
+        const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0]));
+    size_t bufLen = bytes.size();
+    bool result = RoutingManager::getInstance().removeAidRouting(buf, bufLen);
+    return result;
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_routeApduPattern
+  **
+  ** Description:     Route an APDU and APDU mask to an EE
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  static jboolean nfcManager_routeApduPattern(
+      JNIEnv * e, jobject, jint route, jint powerState, jbyteArray apduData,
+      jbyteArray apduMask) {
+    ScopedByteArrayRO bytes(e, apduData);
+    uint8_t* apdu =
+        const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0]));
+    size_t apduLen = bytes.size();
+    ScopedByteArrayRO bytes2(e, apduMask);
+    uint8_t* mask =
+        const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes2[0]));
+    size_t maskLen = bytes2.size();
+#if (NXP_EXTNS == TRUE)
+    if (nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) {
+      if (route == 2 || route == 4) {  // UICC or UICC2 HANDLE
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "sCurrentSelectedUICCSlot:  %d", sCurrentSelectedUICCSlot);
+        route = (sCurrentSelectedUICCSlot != 0x02) ? 0x02 : 0x04;
+      }
+    }
+    if (nfcManager_isTransanctionOnGoing(true)) {
+      return false;
+    }
+#endif
+    return RoutingManager::getInstance().addApduRouting(route, powerState, apdu,
+                                                        apduLen, mask, maskLen);
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_unrouteApduPattern
+  **
+  ** Description:     Remove a APDU and APDU mask routing
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  static jboolean nfcManager_unrouteApduPattern(JNIEnv * e, jobject,
+                                                jbyteArray apduData) {
+#if (NXP_EXTNS == TRUE)
+    if (nfcManager_isTransanctionOnGoing(true)) {
+      return false;
+    }
+#endif
+    ScopedByteArrayRO bytes(e, apduData);
+    uint8_t* apdu =
+        const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0]));
+    size_t apduLen = bytes.size();
+    return RoutingManager::getInstance().removeApduRouting(apduLen, apdu);
+  }
 
-        case NFA_SET_P2P_LISTEN_TECH_EVT:
-        {
-            ALOGV("%s: NFA_SET_P2P_LISTEN_TECH_EVT", __func__);
-            PeerToPeer::getInstance().connectionEventHandler (connEvent, eventData);
-        }
-        break;
+#if (NXP_EXTNS == TRUE)
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_nfcSelfTest
+  **
+  ** Description:     Function to perform different types of analog tests
+  **                  i'e RF ON, RF OFF, Transc A, Transc B.
+  **
+  ** Returns:         success/failure
+  **
+  *******************************************************************************/
+
+  static jint nfcManager_nfcSelfTest(JNIEnv * e, jobject o, jint aType) {
+    tNFA_STATUS status = NFA_STATUS_FAILED;
 
-        case NFA_CE_LOCAL_TAG_CONFIGURED_EVT:
-        {
-            ALOGV("%s: NFA_CE_LOCAL_TAG_CONFIGURED_EVT", __func__);
-        }
+    if (!sIsNfaEnabled) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("NFC does not enabled!! returning...");
+      return status;
+    }
+    gSelfTestType = aType;
+    if (sDiscoveryEnabled) {
+      startRfDiscovery(false);
+    }
+
+    switch (aType) {
+      case TEST_TYPE_RF_ON:
+        status = performRFTest(true);
         break;
-#if(NXP_EXTNS == TRUE)
-        case NFA_RECOVERY_EVT:
-        {
-            if(nfcFL.nfcNxpEse && nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
-                ALOGV("%s: NFA_RECOVERY_EVT: Discovery Started in lower layer:Updating status in JNI", __func__);
-                if(RoutingManager::getInstance().getEtsiReaederState() == STATE_SE_RDR_MODE_STOP_IN_PROGRESS)
-                {
-                    ALOGV("%s: Reset the ETSI Reader State to STATE_SE_RDR_MODE_STOPPED", __func__);
-                    RoutingManager::getInstance().setEtsiReaederState(STATE_SE_RDR_MODE_STOPPED);
-                }
-            }
-        }
+      case TEST_TYPE_RF_OFF:
+        status = performRFTest(false);
         break;
-#endif
-#if(NXP_EXTNS == TRUE)
-        case NFA_PASSIVE_LISTEN_DISABLED_EVT:
-        {
-            if(nfcFL.nfcNxpEse && nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) {
-                ALOGV("%s: NFA_PASSIVE_LISTEN_DISABLED_EVT", __func__);
-                SyncEventGuard g (SecureElement::getInstance().mPassiveListenEvt);
-                SecureElement::getInstance().mPassiveListenEvt.notifyOne();
-            }
-        }
+      case TEST_TYPE_TRANSAC_A:
+        status = performTransacAB(NFC_CMD_TYPE_TRANSAC_A);
         break;
-
-        case NFA_LISTEN_ENABLED_EVT:
-        {
-            if(nfcFL.nfcNxpEse && nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) {
-                ALOGV("%s: NFA_LISTEN_ENABLED_EVT", __func__);
-                SyncEventGuard g (SecureElement::getInstance().mPassiveListenEvt);
-                SecureElement::getInstance().mPassiveListenEvt.notifyOne();
-            }
-        }
+      case TEST_TYPE_TRANSAC_B:
+        status = performTransacAB(NFC_CMD_TYPE_TRANSAC_B);
         break;
-#endif
-        default:
-            ALOGE("%s: unknown event ????", __func__);
+      default:
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("nfcManager_nfcSelfTest Invalid Parameter!!");
         break;
     }
-}
+    gSelfTestType = TEST_TYPE_NONE;
+    return status;
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_setRoutingEntry
+  **
+  ** Description:     Set the routing entry in routing table
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **                  type: technology or protocol routing
+  **                       0x01 - Technology
+  **                       0x02 - Protocol
+  **                  value: technology /protocol value
+  **                  route: routing destination
+  **                       0x00 : Device Host
+  **                       0x01 : ESE
+  **                       0x02 : UICC
+  **                  power: power state for the routing entry
+  *******************************************************************************/
+
+  static jboolean nfcManager_setRoutingEntry(
+      JNIEnv*, jobject, jint type, jint value, jint route, jint power) {
+    jboolean result = false;
 
+    result = RoutingManager::getInstance().setRoutingEntry(type, value, route,
+                                                           power);
+    return result;
+  }
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_clearRoutingEntry
+  **
+  ** Description:     Set the routing entry in routing table
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **                  type:technology/protocol/aid clear routing
+  **
+  *******************************************************************************/
+
+  static jboolean nfcManager_clearRoutingEntry(JNIEnv*, jobject, jint type) {
+    jboolean result = false;
 
-/*******************************************************************************
-**
-** Function:        nfcManager_initNativeStruc
-**
-** Description:     Initialize variables.
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         True if ok.
-**
-*******************************************************************************/
-static jboolean nfcManager_initNativeStruc (JNIEnv* e, jobject o)
-{
-    ALOGV("%s: enter", __func__);
-#if(NXP_EXTNS == TRUE)
-    nfc_jni_native_data* nat = (nfc_jni_native_data*)malloc(sizeof(struct nfc_jni_native_data));
-    /*JCOP OS Download protection case to be handled*/
-#else
-    nfc_jni_native_data* nat = (nfc_jni_native_data*)malloc(sizeof(struct nfc_jni_native_data));
+    result = RoutingManager::getInstance().clearRoutingEntry(type);
+    return result;
+  }
 #endif
 
-    if (nat == NULL)
-    {
-        ALOGE("%s: fail allocate native data", __func__);
-        return JNI_FALSE;
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_setDefaultRoute
+  **
+  ** Description:     Set the default route in routing table
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **
+  *******************************************************************************/
+
+  static jboolean nfcManager_setDefaultRoute(
+      JNIEnv*, jobject, jint defaultRouteEntry, jint defaultProtoRouteEntry,
+      jint defaultTechRouteEntry) {
+    jboolean result = false;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s : enter", __func__);
+#if (NXP_EXTNS == TRUE)
+    if (!pTransactionController->transactionAttempt(
+            TRANSACTION_REQUESTOR(setDefaultRoute))) {
+      LOG(ERROR) << StringPrintf(
+          "%s : Transaction in progress, Store the request", __FUNCTION__);
+      set_last_request(RE_ROUTING, NULL);
+      return result;
     }
-
-    memset (nat, 0, sizeof(*nat));
-    e->GetJavaVM(&(nat->vm));
-    nat->env_version = e->GetVersion();
-    nat->manager = e->NewGlobalRef(o);
-
-    ScopedLocalRef<jclass> cls(e, e->GetObjectClass(o));
-    jfieldID f = e->GetFieldID(cls.get(), "mNative", "J");
-    e->SetLongField(o, f, (jlong)nat);
-
-    /* Initialize native cached references */
-    gCachedNfcManagerNotifyNdefMessageListeners = e->GetMethodID(cls.get(),
-            "notifyNdefMessageListeners", "(Lcom/android/nfc/dhimpl/NativeNfcTag;)V");
-    gCachedNfcManagerNotifyTransactionListeners = e->GetMethodID(cls.get(),
-            "notifyTransactionListeners", "([B[BI)V");
-    gCachedNfcManagerNotifyConnectivityListeners = e->GetMethodID(cls.get(),
-                "notifyConnectivityListeners", "(I)V");
-    gCachedNfcManagerNotifyEmvcoMultiCardDetectedListeners = e->GetMethodID(cls.get(),
-                "notifyEmvcoMultiCardDetectedListeners", "()V");
-    gCachedNfcManagerNotifyLlcpLinkActivation = e->GetMethodID(cls.get(),
-            "notifyLlcpLinkActivation", "(Lcom/android/nfc/dhimpl/NativeP2pDevice;)V");
-    gCachedNfcManagerNotifyLlcpLinkDeactivated = e->GetMethodID(cls.get(),
-            "notifyLlcpLinkDeactivated", "(Lcom/android/nfc/dhimpl/NativeP2pDevice;)V");
-    gCachedNfcManagerNotifyLlcpFirstPacketReceived = e->GetMethodID(cls.get(),
-            "notifyLlcpLinkFirstPacketReceived", "(Lcom/android/nfc/dhimpl/NativeP2pDevice;)V");
-    sCachedNfcManagerNotifyTargetDeselected = e->GetMethodID(cls.get(),
-            "notifyTargetDeselected","()V");
-    gCachedNfcManagerNotifySeFieldActivated = e->GetMethodID(cls.get(),
-            "notifySeFieldActivated", "()V");
-    gCachedNfcManagerNotifySeFieldDeactivated = e->GetMethodID(cls.get(),
-            "notifySeFieldDeactivated", "()V");
-    gCachedNfcManagerNotifySeListenActivated = e->GetMethodID(cls.get(),
-            "notifySeListenActivated", "()V");
-    gCachedNfcManagerNotifySeListenDeactivated = e->GetMethodID(cls.get(),
-            "notifySeListenDeactivated", "()V");
-
-    gCachedNfcManagerNotifyHostEmuActivated = e->GetMethodID(cls.get(),
-            "notifyHostEmuActivated", "(I)V");
-
-    gCachedNfcManagerNotifyAidRoutingTableFull = e->GetMethodID(cls.get(),
-            "notifyAidRoutingTableFull", "()V");
-
-    gCachedNfcManagerNotifyHostEmuData = e->GetMethodID(cls.get(),
-            "notifyHostEmuData", "(I[B)V");
-
-    gCachedNfcManagerNotifyHostEmuDeactivated = e->GetMethodID(cls.get(),
-            "notifyHostEmuDeactivated", "(I)V");
-
-    gCachedNfcManagerNotifyRfFieldActivated = e->GetMethodID(cls.get(),
-            "notifyRfFieldActivated", "()V");
-    gCachedNfcManagerNotifyRfFieldDeactivated = e->GetMethodID(cls.get(),
-            "notifyRfFieldDeactivated", "()V");
-
-    sCachedNfcManagerNotifySeApduReceived = e->GetMethodID(cls.get(),
-            "notifySeApduReceived", "([B)V");
-
-    sCachedNfcManagerNotifySeMifareAccess = e->GetMethodID(cls.get(),
-            "notifySeMifareAccess", "([B)V");
-
-    sCachedNfcManagerNotifySeEmvCardRemoval =  e->GetMethodID(cls.get(),
-            "notifySeEmvCardRemoval", "()V");
-
-    gCachedNfcManagerNotifySWPReaderRequested = e->GetMethodID (cls.get(),
-            "notifySWPReaderRequested", "(ZZ)V");
-
-    gCachedNfcManagerNotifySWPReaderRequestedFail= e->GetMethodID (cls.get(),
-            "notifySWPReaderRequestedFail", "(I)V");
-
-    gCachedNfcManagerNotifySWPReaderActivated = e->GetMethodID (cls.get(),
-            "notifySWPReaderActivated", "()V");
-#if(NXP_EXTNS == TRUE)
-    gCachedNfcManagerNotifyReRoutingEntry = e->GetMethodID(cls.get(),
-            "notifyReRoutingEntry", "()V");
-        gCachedNfcManagerNotifyETSIReaderModeStartConfig = e->GetMethodID (cls.get(),
-                "notifyonETSIReaderModeStartConfig", "(I)V");
-
-    gCachedNfcManagerNotifyETSIReaderModeStopConfig = e->GetMethodID (cls.get(),
-            "notifyonETSIReaderModeStopConfig", "(I)V");
-
-    gCachedNfcManagerNotifyETSIReaderModeSwpTimeout = e->GetMethodID (cls.get(),
-            "notifyonETSIReaderModeSwpTimeout", "(I)V");
-
-    gCachedNfcManagerNotifyUiccStatusEvent= e->GetMethodID (cls.get(),
-            "notifyUiccStatusEvent", "(I)V");
-
-#if(NXP_NFCC_HCE_F == TRUE)
-    gCachedNfcManagerNotifyT3tConfigure = e->GetMethodID(cls.get(),
-            "notifyT3tConfigure", "()V");
 #endif
-    gCachedNfcManagerNotifyJcosDownloadInProgress = e->GetMethodID(cls.get(),
-            "notifyJcosDownloadInProgress", "(I)V");
-
-    gCachedNfcManagerNotifyFwDwnldRequested = e->GetMethodID(cls.get(),
-            "notifyFwDwnldRequested", "()V");
+    if (sRfEnabled) {
+      // Stop RF discovery to reconfigure
+      startRfDiscovery(false);
+    }
 
-#endif
-    if (nfc_jni_cache_object(e, gNativeNfcTagClassName, &(nat->cached_NfcTag)) == -1)
-    {
-        ALOGE("%s: fail cache NativeNfcTag", __func__);
-        return JNI_FALSE;
-    }
+#if (NXP_EXTNS == TRUE)
+    result = RoutingManager::getInstance().setDefaultRoute(
+        defaultRouteEntry, defaultProtoRouteEntry, defaultTechRouteEntry);
+    if (result)
+      result = RoutingManager::getInstance().commitRouting();
+    else
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s : Commit routing failed ", __func__);
+    gsRouteUpdated = true;
+#else
+  result = RoutingManager::getInstance().setDefaultRouting();
+#endif
 
-    if (nfc_jni_cache_object(e, gNativeP2pDeviceClassName, &(nat->cached_P2pDevice)) == -1)
-    {
-        ALOGE("%s: fail cache NativeP2pDevice", __func__);
-        return JNI_FALSE;
+    startRfDiscovery(true);
+#if (NXP_EXTNS == TRUE)
+    pTransactionController->transactionEnd(
+        TRANSACTION_REQUESTOR(setDefaultRoute));
+#endif
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s : exit", __func__);
+    return result;
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_getAidTableSize
+  ** Description:     Get the maximum supported size for AID routing table.
+  **
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **
+  *******************************************************************************/
+  static jint nfcManager_getAidTableSize(JNIEnv*, jobject) {
+    return NFA_GetAidTableSize();
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_getRemainingAidTableSize
+  ** Description:     Get the remaining size of AID routing table.
+  **
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **
+  *******************************************************************************/
+  static jint nfcManager_getRemainingAidTableSize(JNIEnv*, jobject) {
+    return NFA_GetRemainingAidTableSize();
+  }
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_clearAidTable
+  **
+  ** Description:     Clean all AIDs in routing table
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **
+  *******************************************************************************/
+  static bool nfcManager_clearAidTable(JNIEnv*, jobject) {
+#if (NXP_EXTNS == TRUE)
+    /*In case of 66T/67T field on is observed as last field event once reader
+     is removed from proximity, which will hold the transaction lock
+     unnecessarily
+     In such cases end the lock as it is not required*/
+    if (((nfcFL.chipType == pn548C2) || (nfcFL.chipType == pn551)) &&
+        pTransactionController->getCurTransactionRequestor() ==
+            TRANSACTION_REQUESTOR(RF_FIELD_EVT)) {
+      pTransactionController->transactionEnd(
+          TRANSACTION_REQUESTOR(RF_FIELD_EVT));
     }
+#endif
+    return RoutingManager::getInstance().clearAidTable();
+  }
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_doRegisterT3tIdentifier
+  **
+  ** Description:     Registers LF_T3T_IDENTIFIER for NFC-F.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **                  t3tIdentifier: LF_T3T_IDENTIFIER value (10 or 18 bytes)
+  **
+  ** Returns:         Handle retrieve from RoutingManager.
+  **
+  *******************************************************************************/
+  static jint nfcManager_doRegisterT3tIdentifier(JNIEnv * e, jobject,
+                                                 jbyteArray t3tIdentifier) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+    ScopedByteArrayRO bytes(e, t3tIdentifier);
+    uint8_t* buf =
+        const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0]));
+    size_t bufLen = bytes.size();
+    int handle =
+        RoutingManager::getInstance().registerT3tIdentifier(buf, bufLen);
+          DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: handle=%d", __func__, handle);
+    if (handle != NFA_HANDLE_INVALID)
+      RoutingManager::getInstance().commitRouting();
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+    return handle;
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_doDeregisterT3tIdentifier
+  **
+  ** Description:     Deregisters LF_T3T_IDENTIFIER for NFC-F.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **                  handle: Handle retrieve from libnfc-nci.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  static void nfcManager_doDeregisterT3tIdentifier(JNIEnv*, jobject,
+                                                   jint handle) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+    RoutingManager::getInstance().deregisterT3tIdentifier(handle);
+    RoutingManager::getInstance().commitRouting();
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_getLfT3tMax
+  **
+  ** Description:     Returns LF_T3T_MAX value.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **
+  ** Returns:         LF_T3T_MAX value.
+  **
+  *******************************************************************************/
+  static jint nfcManager_getLfT3tMax(JNIEnv*, jobject) { return sLfT3tMax; }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_doInitialize
+  **
+  ** Description:     Turn on NFC.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  static jboolean nfcManager_doInitialize(JNIEnv * e, jobject o) {
+    initializeGlobalDebugEnabledFlag();
+    tNFA_MW_VERSION mwVer;
+    gSeDiscoverycount = 0;
+    gActualSeCount = 0;
 
-    gNativeData = getNative(e,o);
-    ALOGV("%s: exit", __func__);
-    return JNI_TRUE;
-}
-
-
-/*******************************************************************************
-**
-** Function:        nfaDeviceManagementCallback
-**
-** Description:     Receive device management events from stack.
-**                  dmEvent: Device-management event ID.
-**                  eventData: Data associated with event ID.
-**
-** Returns:         None
-**
-*******************************************************************************/
-void nfaDeviceManagementCallback (uint8_t dmEvent, tNFA_DM_CBACK_DATA* eventData)
-{
-    ALOGV("%s: enter; event=0x%X", __func__, dmEvent);
+    uint8_t switchToUiccSlot = 0;
+#if (NXP_EXTNS == TRUE)
+    rfActivation = false;
+    tNFA_PMID ven_config_addr[] = {0xA0, 0x07};
+    tNFA_PMID pollProfileAddr[] = {0xA0, 0x44};
+    uint8_t pollProfileVal[] = {NFC_FORUM_POLL};
+    bool isSuccess = false;
+    sNfcee_disc_state = UICC_SESSION_NOT_INTIALIZED;
+    IsEseCeDisabled = false;
+    /* NFC initialization in progress */
+    if (NFC_OFF == sNfcState) sNfcState = NFC_INITIALIZING_IN_PROGRESS;
+
+    char propBuf[PROPERTY_VALUE_MAX] = {'\0'};
+    int len = property_get(ESE_PWR_MGMT_PROP, propBuf, "");
+    if (len != 0) {
+      sIsLowRamDevice = (propBuf[0] != '\0')
+                            ? ((strcmp(propBuf, "true") == 0) ? true : false)
+                            : true;
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "isLowRamDevice %s", sIsLowRamDevice ? "true" : "false");
+    }
+    NFA_SetLowRamDevice(sIsLowRamDevice);
+#endif
+    mwVer = NFA_GetMwVersion();
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s:  MW Version: NFC_NCIHALx_AR%X.%x.%x.%x", __func__,
+                        mwVer.validation, mwVer.android_version,
+                        mwVer.major_version, mwVer.minor_version);
 
-    switch (dmEvent)
-    {
-    case NFA_DM_ENABLE_EVT: /* Result of NFA_Enable */
-        {
-            SyncEventGuard guard (sNfaEnableEvent);
-            ALOGV("%s: NFA_DM_ENABLE_EVT; status=0x%X",
-                    __func__, eventData->status);
-            sIsNfaEnabled = eventData->status == NFA_STATUS_OK;
-#if(NXP_EXTNS == TRUE)
-            sEnableStatus = eventData->status;
+    tNFA_STATUS stat = NFA_STATUS_OK;
+    NfcTag::getInstance().mNfcDisableinProgress = false;
+    PowerSwitch& powerSwitch = PowerSwitch::getInstance();
+    if (sIsNfaEnabled) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: already enabled", __func__);
+      goto TheEnd;
+    }
+#if (NXP_EXTNS == TRUE)
+    if (gsNfaPartialEnabled) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: already  partial enable calling deinitialize", __func__);
+      nfcManager_doPartialDeInitialize();
+    }
 #endif
-            sIsDisabling = false;
-            sNfaEnableEvent.notifyOne ();
-        }
-        break;
+    powerSwitch.initialize(PowerSwitch::FULL_POWER);
+    register_signal_handler();
+    {
 
-    case NFA_DM_DISABLE_EVT: /* Result of NFA_Disable */
-        {
-            SyncEventGuard guard (sNfaDisableEvent);
-            ALOGV("%s: NFA_DM_DISABLE_EVT", __func__);
-            sIsNfaEnabled = false;
-            sIsDisabling = false;
-            sNfaDisableEvent.notifyOne ();
+      NfcAdaptation& theInstance = NfcAdaptation::GetInstance();
+      theInstance.Initialize();  // start GKI, NCI task, NFC task
+#if (NXP_EXTNS == TRUE)
+      int state = getJCOPOS_UpdaterState();
+      if ((state != OSU_COMPLETE) && (state != OSU_NOT_STARTED)) {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("JCOP is in OSU mode");
+        NFA_SetBootMode(NFA_OSU_BOOT_MODE);
+      } else {
+        NFA_SetBootMode(NFA_NORMAL_BOOT_MODE);
+      }
+#endif
+      stat = nfcManagerEnableNfc(theInstance);
+      nfcManager_getFeatureList();
+      if (nfcFL.nfcNxpEse) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("ESE Present Loading p61-jcop-lib");
+        pJcopMgr->JcopInitialize();
+      } else
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("ESE Not Present");
+      EXTNS_Init(nfaDeviceManagementCallback, nfaConnectionCallback);
+
+      if (stat == NFA_STATUS_OK) {
+        // sIsNfaEnabled indicates whether stack started successfully
+        if (sIsNfaEnabled) {
+          SecureElement::getInstance().initialize(getNative(e, o));
+          RoutingManager::getInstance().initialize(getNative(e, o));
+          HciRFParams::getInstance().initialize();
+          MposManager::getInstance().initialize(getNative(e, o));
+          sIsSecElemSelected =
+              (SecureElement::getInstance().getActualNumEe() - 1);
+          sIsSecElemDetected = sIsSecElemSelected;
+          nativeNfcTag_registerNdefTypeHandler();
+          NfcTag::getInstance().initialize(getNative(e, o));
+          PeerToPeer::getInstance().initialize();
+          PeerToPeer::getInstance().handleNfcOnOff(true);
+          HciEventManager::getInstance().initialize(getNative(e, o));
+#if (NXP_EXTNS == TRUE)
+          if (NfcConfig::hasKey(NAME_NXP_DEFAULT_NFCEE_DISC_TIMEOUT)) {
+            gdisc_timeout =
+                NfcConfig::getUnsigned(NAME_NXP_DEFAULT_NFCEE_DISC_TIMEOUT);
+          } else {
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+                "NAME_NXP_DEFAULT_NFCEE_DISC_TIMEOUT not found");
+            gdisc_timeout =
+                NFCEE_DISC_TIMEOUT_SEC; /*Default nfcee discover timeout*/
+          }
+          gdisc_timeout = gdisc_timeout * 1000;
+          if (NFA_STATUS_OK == GetNumNFCEEConfigured()) {
+            DLOG_IF(INFO, nfc_debug_enabled)
+                << StringPrintf(" gSeDiscoverycount = %d gActualSeCount=%d",
+                                gSeDiscoverycount, gActualSeCount);
+            if (gSeDiscoverycount < gActualSeCount) {
+              DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+                  "Wait for ESE to discover, gdisc_timeout = %d",
+                  gdisc_timeout);
+              SyncEventGuard g(gNfceeDiscCbEvent);
+              if (gNfceeDiscCbEvent.wait(gdisc_timeout) == false) {
+                LOG(ERROR) << StringPrintf(
+                    "%s: timeout waiting for nfcee dis event", __func__);
+              }
+              DLOG_IF(INFO, nfc_debug_enabled)
+                  << StringPrintf("gSeDiscoverycount  = %d gActualSeCount=%d",
+                                  gSeDiscoverycount, gActualSeCount);
+            } else {
+              DLOG_IF(INFO, nfc_debug_enabled)
+                  << StringPrintf("All ESE are discovered ");
+            }
+          }
+          // Create transaction controller
+          (void)transactionController::controller();
+          if (nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
+            checkforESERemoval();
+
+            if (NfcConfig::hasKey(NAME_NXP_DUAL_UICC_ENABLE)) {
+              dualUiccInfo.dualUiccEnable =
+                  NfcConfig::getUnsigned(NAME_NXP_DUAL_UICC_ENABLE);
+            }
+            if (dualUiccInfo.dualUiccEnable == 0x01) {
+              checkforNfceeConfig(UICC1 | UICC2 | ESE);
+              dualUiccInfo.uiccActivStat = 0x00;
+              if (SecureElement::getInstance().getEeStatus(
+                      SecureElement::getInstance().EE_HANDLE_0xF4) !=
+                  NFC_NFCEE_STATUS_REMOVED) {
+                dualUiccInfo.uiccActivStat = (sSelectedUicc & 0x0F);
+              }
+              switchToUiccSlot = ((sSelectedUicc & 0x0F) == 0x01) ? 0x02 : 0x01;
+              nfcManager_doSelectUicc(e, o, switchToUiccSlot);
+              if (SecureElement::getInstance().getEeStatus(
+                      SecureElement::getInstance().EE_HANDLE_0xF4) !=
+                  NFC_NFCEE_STATUS_REMOVED) {
+                dualUiccInfo.uiccActivStat |= (sSelectedUicc & 0x0F);
+              }
+              uiccEventTimer.set(1, notifyUiccEvent);
+            }
+          } else
+            SecureElement::getInstance().updateEEStatus();
+          if (nfcFL.eseFL._JCOP_WA_ENABLE) {
+            RoutingManager::getInstance().handleSERemovedNtf();
+          }
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("Discovered se count %d", gSeDiscoverycount);
+          /*Check for ETSI12 Configuration for SEs detected in the HCI Network*/
+          performNfceeETSI12Config();
+          if (nfcFL.eseFL._ESE_ETSI12_PROP_INIT &&
+              (swp_getconfig_status & SWP2_ESE)) {
+            performHCIInitialization(e, o);
+          }
+          SecureElement::getInstance().getSETechnology(
+              SecureElement::EE_HANDLE_0xF3);
+          checkforNfceeConfig(UICC1 | UICC2 | ESE);
+          /*Pending clear all pipe handling*/
+          if (sNfcee_disc_state == UICC_CLEAR_ALL_PIPE_NTF_RECEIVED) {
+            DLOG_IF(INFO, nfc_debug_enabled)
+                << StringPrintf("Perform pending UICC clear all pipe handling");
+            sNfcee_disc_state = UICC_SESSION_INTIALIZATION_DONE;
+            /*Handle UICC clear all pipe notification*/
+            checkforNfceeConfig(UICC1 | UICC2);
+          }
+          sNfcee_disc_state = UICC_SESSION_INTIALIZATION_DONE;
+#endif
+/////////////////////////////////////////////////////////////////////////////////
+// Add extra configuration here (work-arounds, etc.)
+#if (NXP_EXTNS == TRUE)
+          if (nfcFL.nfcNxpEse) {
+            if (nfcFL.eseFL._ESE_SVDD_SYNC ||
+                nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION ||
+                nfcFL.nfccFL._NFCC_SPI_FW_DOWNLOAD_SYNC ||
+                nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE) {
+              isSuccess = createSPIEvtHandlerThread();
+            }
+            if (nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE && isSuccess) {
+              SecureElement::getInstance().enableDwp();
+            } else if (!isSuccess) {
+              DLOG_IF(INFO, nfc_debug_enabled)
+                  << StringPrintf("Failed to start SPI Event Handler Thread");
+            }
+          }
+#endif
+          pendingScreenState = false;
+          {
+            SyncEventGuard guard(android::sNfaGetConfigEvent);
+            stat = NFA_GetConfig(0x01, ven_config_addr);
+            if (stat == NFA_STATUS_OK) {
+              android::sNfaGetConfigEvent.wait();
+            }
+            /*sCurrentConfigLen should be > 4 (num_tlv:1 + addr:2 + value:1) and
+             *pos 4 gives the current eeprom value*/
+            if ((sCurrentConfigLen > 4) && (sConfig[4] == 0x03)) {
+              DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+                  "%s: No need to update VEN_CONFIG. Already set to 0x%02x",
+                  __func__, sConfig[4]);
+            } else {
+              SetVenConfigValue(NFC_MODE_ON);
+              if (stat != NFA_STATUS_OK) {
+                LOG(ERROR) << StringPrintf(
+                    "%s: fail enable SetVenConfigValue; error=0x%X", __func__,
+                    stat);
+              }
+            }
+            gGeneralPowershutDown = 0;
+          }
+          updateEeprom(pollProfileAddr, sizeof(pollProfileVal), pollProfileVal);
+          if (gIsDtaEnabled == true) {
+            uint8_t configData = 0;
+            configData =
+                0x01; /**< Poll NFC-DEP : Highest Available Bit Rates */
+            NFA_SetConfig(NCI_PARAM_ID_BITR_NFC_DEP, sizeof(uint8_t),
+                          &configData);
+            configData = 0x0B; /**< Listen NFC-DEP : Waiting Time */
+            NFA_SetConfig(NFC_PMID_WT, sizeof(uint8_t), &configData);
+            configData =
+                0x0F; /**< Specific Parameters for NFC-DEP RF Interface */
+            NFA_SetConfig(NCI_PARAM_ID_NFC_DEP_OP, sizeof(uint8_t),
+                          &configData);
+          }
+
+        struct nfc_jni_native_data* nat = getNative(e, o);
+
+          if (nat) {
+          nat->tech_mask =
+              NfcConfig::getUnsigned(NAME_POLLING_TECH_MASK, DEFAULT_TECH_MASK);
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+                "%s: tag polling tech mask=0x%X", __func__, nat->tech_mask);
+          }
+
+          // if this value exists, set polling interval.
+        nat->discovery_duration = NfcConfig::getUnsigned(
+            NAME_NFA_DM_DISC_DURATION_POLL, DEFAULT_DISCOVERY_DURATION);
+#if (NXP_EXTNS == TRUE)
+          discDuration = nat->discovery_duration;
+#endif
+          NFA_SetRfDiscoveryDuration(nat->discovery_duration);
+
+          // get LF_T3T_MAX
+          {
+            SyncEventGuard guard(sNfaGetConfigEvent);
+            tNFA_PMID configParam[1] = {NCI_PARAM_ID_LF_T3T_MAX};
+            stat = NFA_GetConfig(1, configParam);
+            if (stat == NFA_STATUS_OK) {
+              sNfaGetConfigEvent.wait();
+              if (sCurrentConfigLen >= 4 ||
+                  sConfig[1] == NCI_PARAM_ID_LF_T3T_MAX) {
+                DLOG_IF(INFO, nfc_debug_enabled)
+                    << StringPrintf("%s: lfT3tMax=%d", __func__, sConfig[3]);
+                sLfT3tMax = sConfig[3];
+              }
+            }
+          }
+          unsigned long num = 0;
+          if (NfcConfig::hasKey(NAME_NXP_CE_ROUTE_STRICT_DISABLE)) {
+            num = NfcConfig::getUnsigned(NAME_NXP_CE_ROUTE_STRICT_DISABLE);
+          } else {
+            num = 0x01;
+          }
+          // TODO: Check this in L_OSP_EXT[PN547C2]
+          //                NFA_SetCEStrictDisable(num);
+          RoutingManager::getInstance().setCeRouteStrictDisable(num);
+          prevScreenState = NFA_SCREEN_STATE_OFF_LOCKED;
+#if (NXP_EXTNS != TRUE)
+          // Do custom NFCA startup configuration.
+          doStartupConfig();
+#else
+        if (HciRFParams::getInstance().isCeWithEseDisabled()) {
+          recoverEseConnectivity();
         }
-        break;
-
-    case NFA_DM_SET_CONFIG_EVT: //result of NFA_SetConfig
-        ALOGV("%s: NFA_DM_SET_CONFIG_EVT", __func__);
-        {
-            SyncEventGuard guard (sNfaSetConfigEvent);
-            sNfaSetConfigEvent.notifyOne();
+#endif
+          goto TheEnd;
         }
-        break;
+      }
 
-    case NFA_DM_GET_CONFIG_EVT: /* Result of NFA_GetConfig */
-        ALOGV("%s: NFA_DM_GET_CONFIG_EVT", __func__);
-        {
-            HciRFParams::getInstance().connectionEventHandler(dmEvent,eventData);
-            SyncEventGuard guard (sNfaGetConfigEvent);
-            if (eventData->status == NFA_STATUS_OK &&
-                    eventData->get_config.tlv_size <= sizeof(sConfig))
-            {
-                sCurrentConfigLen = eventData->get_config.tlv_size;
-                memcpy(sConfig, eventData->get_config.param_tlvs, eventData->get_config.tlv_size);
+      LOG(ERROR) << StringPrintf("%s: fail nfa enable; error=0x%X", __func__,
+                                 stat);
 
-#if(NXP_EXTNS == TRUE)
-                if(sCheckNfceeFlag)
-                    checkforNfceeBuffer();
-#endif
-            }
-            else
-            {
-                ALOGE("%s: NFA_DM_GET_CONFIG failed", __func__);
-                sCurrentConfigLen = 0;
-            }
-            sNfaGetConfigEvent.notifyOne();
-        }
-        break;
+      if (sIsNfaEnabled) {
+        EXTNS_Close();
+        stat = NFA_Disable(false /* ungraceful */);
+      }
 
-    case NFA_DM_RF_FIELD_EVT:
-        checkforTranscation(NFA_TRANS_DM_RF_FIELD_EVT, (void *)eventData);
-        ALOGV("%s: NFA_DM_RF_FIELD_EVT; status=0x%X; field status=%u", __func__,
-              eventData->rf_field.status, eventData->rf_field.rf_field_status);
-        if (sIsDisabling || !sIsNfaEnabled)
-            break;
+      theInstance.Finalize();
+    }
 
-        if (!sP2pActive && eventData->rf_field.status == NFA_STATUS_OK)
-        {
-            SecureElement::getInstance().notifyRfFieldEvent (
-                    eventData->rf_field.rf_field_status == NFA_DM_RF_FIELD_ON);
-            struct nfc_jni_native_data *nat = getNative(NULL, NULL);
-            JNIEnv* e = NULL;
-            ScopedAttach attach(nat->vm, &e);
-            if (e == NULL)
-            {
-                ALOGE("jni env is null");
-                return;
-            }
-            if (eventData->rf_field.rf_field_status == NFA_DM_RF_FIELD_ON)
-             {
-                if(!pTransactionController->transactionAttempt(TRANSACTION_REQUESTOR(RF_FIELD_EVT)))
-                {
-                    ALOGD ("%s: RF field on evnt Not allowing to set", __FUNCTION__);
-                }
-                sRfFieldOff = false;
-                e->CallVoidMethod (nat->manager, android::gCachedNfcManagerNotifyRfFieldActivated);
-             }
-            else
-            {
-                pTransactionController->transactionEnd(TRANSACTION_REQUESTOR(RF_FIELD_EVT));
-                sRfFieldOff = true;
-                e->CallVoidMethod (nat->manager, android::gCachedNfcManagerNotifyRfFieldDeactivated);
-            }
-        }
-        break;
+  TheEnd:
+    if (sIsNfaEnabled)
+      PowerSwitch::getInstance().setLevel(PowerSwitch::LOW_POWER);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+    return sIsNfaEnabled ? JNI_TRUE : JNI_FALSE;
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_doEnableDtaMode
+  **
+  ** Description:     Enable the DTA mode in NFC service.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  static void nfcManager_doEnableDtaMode(JNIEnv* /* e */, jobject /* o */) {
+    gIsDtaEnabled = true;
+  }
 
-    case NFA_DM_NFCC_TRANSPORT_ERR_EVT:
-    case NFA_DM_NFCC_TIMEOUT_EVT:
-        {
-            if (dmEvent == NFA_DM_NFCC_TIMEOUT_EVT)
-                ALOGE("%s: NFA_DM_NFCC_TIMEOUT_EVT; abort", __func__);
-            else if (dmEvent == NFA_DM_NFCC_TRANSPORT_ERR_EVT)
-                ALOGE("%s: NFA_DM_NFCC_TRANSPORT_ERR_EVT; abort", __func__);
-            if(nfcFL.eseFL._JCOP_WA_ENABLE) {
-                NFA_HciW4eSETransaction_Complete(Wait);
-            }
-            nativeNfcTag_abortWaits();
-            NfcTag::getInstance().abort ();
-            sAbortConnlessWait = true;
-            nativeLlcpConnectionlessSocket_abortWait();
-            {
-                ALOGV("%s: aborting  sNfaEnableDisablePollingEvent", __func__);
-                SyncEventGuard guard (sNfaEnableDisablePollingEvent);
-                sNfaEnableDisablePollingEvent.notifyOne();
-            }
-            {
-                ALOGV("%s: aborting  sNfaEnableEvent", __func__);
-                SyncEventGuard guard (sNfaEnableEvent);
-                sNfaEnableEvent.notifyOne();
-            }
-            {
-                ALOGV("%s: aborting  sNfaDisableEvent", __func__);
-                SyncEventGuard guard (sNfaDisableEvent);
-                sNfaDisableEvent.notifyOne();
-            }
-            sDiscoveryEnabled = false;
-            sPollingEnabled = false;
-            PowerSwitch::getInstance ().abort ();
+#if (NXP_EXTNS == TRUE)
+  /*******************************************************************************
+  **
+  ** Function:        nfcManagerEnableNfc
+  **
+  ** Description:     Enables Nfc submodules in libnfc
+  **
+  ** Returns:         Status
+  **
+  *******************************************************************************/
+  static tNFA_STATUS nfcManagerEnableNfc(NfcAdaptation & theInstance) {
+    uint8_t retryCount = 0;
+    tNFA_STATUS stat = NFA_STATUS_OK;
+    sEnableStatus = NFA_STATUS_FAILED;
+    do {
+      SyncEventGuard guard(sNfaEnableEvent);
+      tHAL_NFC_ENTRY* halFuncEntries = theInstance.GetHalEntryFuncs();
+      NFA_Init(halFuncEntries);
+      stat = NFA_Enable(nfaDeviceManagementCallback, nfaConnectionCallback);
+      if (stat == NFA_STATUS_OK) {
+        sNfaEnableEvent.wait();  // wait for NFA command to finish
+      }
+      retryCount++;
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: sEnableStatus =0x%X", __func__, sEnableStatus);
+    } while ((sEnableStatus == NFA_STATUS_NOT_INITIALIZED) && (retryCount < 3));
+
+    return sEnableStatus;
+  }
+  /*******************************************************************************
+   **
+   ** Function:        nfcManager_checkNfcStateBusy()
+   **
+   ** Description      This function returns whether NFC process is busy or not.
+   **
+   ** Returns          if Nfc state busy return true otherwise false.
+   **
+   *******************************************************************************/
+  bool nfcManager_checkNfcStateBusy() {
+    bool status = false;
 
-            if (!sIsDisabling && sIsNfaEnabled)
-            {
-                EXTNS_Close ();
-                NFA_Disable(false);
-                sIsDisabling = true;
-            }
-            else
-            {
-                sIsNfaEnabled = false;
-                sIsDisabling = false;
-            }
-            PowerSwitch::getInstance ().initialize (PowerSwitch::UNKNOWN_LEVEL);
-#if(NXP_EXTNS == TRUE)
-            if(eventData->status == NFA_STATUS_FAILED)
-            {
-                ALOGE("%s: Disabling NFC service", __func__);
-            }
-            else
-            {
-#endif
-                ALOGE("%s: crash NFC service", __func__);
-                //////////////////////////////////////////////
-                //crash the NFC service process so it can restart automatically
-                abort ();
-                //////////////////////////////////////////////
-#if(NXP_EXTNS == TRUE)
-            }
-#endif
-        }
-        break;
+    if (NFA_checkNfcStateBusy() == true) status = true;
 
-    case NFA_DM_PWR_MODE_CHANGE_EVT:
-        PowerSwitch::getInstance ().deviceManagementCallback (dmEvent, eventData);
-        break;
+    return status;
+  }
+  /*******************************************************************************
+   **
+   ** Function:        requestFwDownload
+   **
+   ** Description      This function is to complete the FW Dwnld to complete the
+   **                  the pending request due to SPI session ongoing .
+   **
+   ** Returns          void.
+   **
+   *******************************************************************************/
+  void requestFwDownload() {
+    JNIEnv* e = NULL;
+    uint8_t fwDnldRequest = false;
+    int status = NFA_STATUS_OK;
 
-#if(NXP_EXTNS == TRUE)
-    case NFA_DM_SET_ROUTE_CONFIG_REVT:
-        ALOGV("%s: NFA_DM_SET_ROUTE_CONFIG_REVT; status=0x%X",
-                __func__, eventData->status);
-        if(eventData->status != NFA_STATUS_OK)
-        {
-            ALOGV("AID Routing table configuration Failed!!!");
-        }
-        else
-        {
-            ALOGV("AID Routing Table configured.");
+    NfcAdaptation& theInstance = NfcAdaptation::GetInstance();
+    status = theInstance.HalGetFwDwnldFlag(&fwDnldRequest);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "Enter: %s fwDnldRequest = %d", __func__, fwDnldRequest);
+    if (status == NFA_STATUS_OK) {
+      if (fwDnldRequest == true) {
+        ScopedAttach attach(RoutingManager::getInstance().mNativeData->vm, &e);
+        if (e == NULL) {
+          LOG(ERROR) << StringPrintf("Exit:%s jni env is null", __func__);
+          return;
         }
-        RoutingManager::getInstance().mLmrtEvent.notifyOne();
-        break;
-
-    case NFA_DM_GET_ROUTE_CONFIG_REVT:
-    {
-        RoutingManager::getInstance().processGetRoutingRsp(eventData,sRoutingBuff);
-        if (eventData->status == NFA_STATUS_OK)
-        {
-            SyncEventGuard guard (sNfaGetRoutingEvent);
-            sNfaGetRoutingEvent.notifyOne();
+        if (nfcFL.nfccFL._NFCC_SPI_FW_DOWNLOAD_SYNC) {
+          e->CallVoidMethod(gNativeData->manager,
+                            android::gCachedNfcManagerNotifyFwDwnldRequested);
         }
-        break;
-    }
-    case NFA_DM_EE_HCI_DISABLE:
-    {
-        if(nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
-            ALOGV("NFA_DM_EE_HCI_DISABLE wait releasing");
-            SyncEventGuard guard (sNfceeHciCbDisableEvent);
-            sNfceeHciCbDisableEvent.notifyOne();
-            ALOGV("NFA_DM_EE_HCI_DISABLE wait released");
+        if (e->ExceptionCheck()) {
+          e->ExceptionClear();
+          LOG(ERROR) << StringPrintf("Exit:%s fail notify", __func__);
         }
-        break;
+
+      } else {
+        LOG(ERROR) << StringPrintf("Exit:%s Firmware download request:%d ",
+                                   __func__, fwDnldRequest);
+      }
+    } else {
+      LOG(ERROR) << StringPrintf("Exit:%s HalGetFwDwnldFlag status:%d ",
+                                 __func__, status);
+    }
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        updateEeprom
+  **
+  ** Description:     Used to send the EXTENDED SET CONFIG command to update
+  **                  the EEPROM values
+  **                  *param Address of the eeprom
+  **                  len of the eeprom address
+  **                  val to be updated
+  **
+  ** Returns:         NFA_STATUS_OK/NFA_STATUS_FAILED
+  **
+  *******************************************************************************/
+  tNFA_STATUS updateEeprom(uint8_t * param, uint8_t len, uint8_t * val) {
+    tNFA_STATUS status = NFA_STATUS_OK;
+    uint8_t valOffset = 4;
+    SyncEventGuard guard(sNfaGetConfigEvent);
+    status = NFA_GetConfig(0x01, param);
+    if (status == NFA_STATUS_OK) {
+      status = sNfaGetConfigEvent.wait(2 * ONE_SECOND_MS) ? NFA_STATUS_OK
+                                                          : NFA_STATUS_FAILED;
     }
-    case NFA_DM_EE_HCI_ENABLE:
-    {
-        if(nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
-            ALOGV("NFA_DM_EE_HCI_ENABLE wait releasing");
-            SyncEventGuard guard (sNfceeHciCbEnableEvent);
-            sNfceeHciCbEnableEvent.notifyOne();
-            ALOGV("NFA_DM_EE_HCI_ENABLE wait released");
+
+    if (status == NFA_STATUS_OK) {
+      /*sCurrentConfigLen should be > 4 (num_tlv:1 + addr:2 + value:1) and
+       *pos 4 gives the current eeprom value*/
+      if ((sCurrentConfigLen > PROPSETCONFIGMINLEN) &&
+          (sConfig[SETCONFIGLENPOS] == len)) {
+        if (memcmp(&sConfig[valOffset], val, len)) {
+          status = NxpNfcUpdateEeprom(param, len, val);
+        } else {
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Already same");
         }
-        break;
+      } else {
+        status = NFA_STATUS_FAILED;
+      }
     }
+    return status;
+  }
 #endif
-    case NFA_DM_SET_POWER_SUB_STATE_EVT:
-    {
-        ALOGD("%s: NFA_DM_SET_POWER_SUB_STATE_EVT; status=0x%X",__FUNCTION__, eventData->power_sub_state.status);
-        SyncEventGuard guard (sNfaSetPowerSubState);
-        sNfaSetPowerSubState.notifyOne();
-    }
-        break;
-    case NFA_DM_EMVCO_PCD_COLLISION_EVT:
-        ALOGV("STATUS_EMVCO_PCD_COLLISION - Multiple card detected");
-        SecureElement::getInstance().notifyEmvcoMultiCardDetectedListeners();
-        break;
 
-    default:
-        ALOGV("%s: unhandled event", __func__);
-        break;
-    }
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_doDisableDtaMode
+  **
+  ** Description:     Disable the DTA mode in NFC service.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  static void nfcManager_doDisableDtaMode(JNIEnv* /* e */, jobject /*o */) {
+    gIsDtaEnabled = false;
 }
 
-/*******************************************************************************
-**
-** Function:        nfcManager_sendRawFrame
-**
-** Description:     Send a raw frame.
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         True if ok.
-**
-*******************************************************************************/
-static jboolean nfcManager_sendRawFrame (JNIEnv* e, jobject, jbyteArray data)
-{
-    size_t bufLen = 0x00;
-    uint8_t* buf = NULL;
-    if(data != NULL)
-    {
-        ScopedByteArrayRO bytes(e, data);
-        buf = const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0]));
-        bufLen = bytes.size();
-    }
-#if(NXP_EXTNS == TRUE)
-    if(nfcFL.nfccFL._NXP_NFCC_EMPTY_DATA_PACKET) {
-        RoutingManager::getInstance().mNfcFRspTimer.kill();
-        if(bufLen == 0) {
-            gIsEmptyRspSentByHceFApk = true;
-        }
-    }
-#endif
-    ALOGV("nfcManager_sendRawFrame(): bufLen:%lu", bufLen);
-    tNFA_STATUS status = NFA_SendRawFrame (buf, bufLen, 0);
-    return (status == NFA_STATUS_OK);
+static void nfcManager_doFactoryReset(JNIEnv*, jobject) {
+  NfcAdaptation& theInstance = NfcAdaptation::GetInstance();
+  theInstance.FactoryReset();
 }
 
-/*******************************************************************************
-**
-** Function:        nfcManager_routeAid
-**
-** Description:     Route an AID to an EE
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         True if ok.
-**
-*******************************************************************************/
-static jboolean nfcManager_routeAid (JNIEnv* e, jobject, jbyteArray aid, jint route, jint power, jint aidInfo)
-{
-    ScopedByteArrayRO bytes(e, aid);
-    uint8_t* buf = const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0]));
-    size_t bufLen = bytes.size();
 #if (NXP_EXTNS == TRUE)
-    if((nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) &&
-            (route == 2 || route == 4)) { //UICC or UICC2 HANDLE
-        ALOGV("sCurrentSelectedUICCSlot:  %d", sCurrentSelectedUICCSlot);
-        route = (sCurrentSelectedUICCSlot != 0x02) ? 0x02 : 0x04;
+  /*******************************************************************************
+   **
+   ** Function:        nfcManager_Enablep2p
+   **
+   ** Description:     enable P2P
+   **                  e: JVM environment.
+   **                  o: Java object.
+   **
+   ** Returns:         None.
+   **
+   *******************************************************************************/
+  static void nfcManager_Enablep2p(JNIEnv* /* e */, jobject /* o */, jboolean p2pFlag) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("Enter :%s  p2pFlag = %d", __func__, p2pFlag);
+    /* if another transaction is already in progress, store this request */
+    if (!pTransactionController->transactionAttempt(
+            TRANSACTION_REQUESTOR(enablep2p))) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("Transaction in progress, Store the request");
+      set_last_request(ENABLE_P2P, NULL);
+      transaction_data.discovery_params.enable_p2p = p2pFlag;
+      return;
     }
-    if(nfcManager_isTransanctionOnGoing(true))
-    {
-       return false;
+    if (sRfEnabled && p2pFlag) {
+      /* Stop discovery if already ON */
+      startRfDiscovery(false);
     }
-    bool result = RoutingManager::getInstance().addAidRouting(buf, bufLen, route, power, aidInfo);
-#else
-    bool result = RoutingManager::getInstance().addAidRouting(buf, bufLen, route);
 
+    /* if already Polling, change to listen Mode */
+    if (sPollingEnabled) {
+      if (p2pFlag && !sP2pEnabled) {
+        /* enable P2P listening, if we were not already listening */
+        sP2pEnabled = true;
+        PeerToPeer::getInstance().enableP2pListening(true);
+      }
+    }
+    /* Beam ON - Discovery ON */
+    if (p2pFlag) {
+      NFA_ResumeP2p();
+      startRfDiscovery(p2pFlag);
+    }
+    pTransactionController->transactionEnd(TRANSACTION_REQUESTOR(enablep2p));
+  }
+
+  void enableRfDiscovery() {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __FUNCTION__);
+    nfcManager_enableDiscovery(NULL, NULL, mDiscParams.technologies_mask,
+                               mDiscParams.enable_lptd, mDiscParams.reader_mode,
+                               mDiscParams.enable_p2p, mDiscParams.restart);
+  }
+
+  void disableRfDiscovery() { nfcManager_disableDiscovery(NULL, NULL); }
+
+  void storeLastDiscoveryParams(int technologies_mask, bool enable_lptd,
+                                bool reader_mode, bool enable_p2p,
+                                bool restart) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __FUNCTION__);
+    mDiscParams.technologies_mask = technologies_mask;
+    mDiscParams.enable_lptd = enable_lptd;
+    mDiscParams.reader_mode = reader_mode;
+    mDiscParams.enable_p2p = enable_p2p;
+    mDiscParams.restart = restart;
+  }
 #endif
-    return result;
-}
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_enableDiscovery
+  **
+  ** Description:     Start polling and listening for devices.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **                  technologies_mask: the bitmask of technologies for which
+  *to enable discovery
+  **                  enable_lptd: whether to enable low power polling (default:
+  *false)
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  static void nfcManager_enableDiscovery(
+      JNIEnv * e, jobject o, jint technologies_mask, jboolean enable_lptd,
+      jboolean reader_mode, jboolean enable_p2p, jboolean restart) {
+    tNFA_STATUS status = NFA_STATUS_OK;
+    tNFA_STATUS stat = NFA_STATUS_OK;
+    tNFA_TECHNOLOGY_MASK tech_mask = DEFAULT_TECH_MASK;
+    unsigned long num = 0;
 
-/*******************************************************************************
-**
-** Function:        nfcManager_unrouteAid
-**
-** Description:     Remove a AID routing
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         True if ok.
-**
-*******************************************************************************/
-static jboolean nfcManager_unrouteAid (JNIEnv* e, jobject, jbyteArray aid)
-{
-    ScopedByteArrayRO bytes(e, aid);
-    uint8_t* buf = const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0]));
-    size_t bufLen = bytes.size();
-    bool result = RoutingManager::getInstance().removeAidRouting(buf, bufLen);
-    return result;
-}
+    tNFA_HANDLE handle = NFA_HANDLE_INVALID;
+    struct nfc_jni_native_data* nat = NULL;
 
-/*******************************************************************************
-**
-** Function:        nfcManager_routeApduPattern
-**
-** Description:     Route an APDU and APDU mask to an EE
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         True if ok.
-**
-*******************************************************************************/
-static jboolean nfcManager_routeApduPattern (JNIEnv* e, jobject, jint route, jint powerState,jbyteArray apduData, jbyteArray apduMask)
-{
-    ScopedByteArrayRO bytes(e, apduData);
-    uint8_t* apdu = const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0]));
-    size_t apduLen = bytes.size();
-    ScopedByteArrayRO bytes2(e, apduMask);
-    uint8_t* mask = const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes2[0]));
-    size_t maskLen = bytes2.size();
-#if(NXP_EXTNS == TRUE)
-    if(nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) {
-        if(route == 2 || route == 4) { //UICC or UICC2 HANDLE
-            ALOGV("sCurrentSelectedUICCSlot:  %d", sCurrentSelectedUICCSlot);
-            route = (sCurrentSelectedUICCSlot != 0x02) ? 0x02 : 0x04;
-        }
-    }
-    if(nfcManager_isTransanctionOnGoing(true))
-    {
-       return false;
-    }
+#if (NXP_EXTNS == TRUE)
+    tNFA_TECHNOLOGY_MASK etsi_tech_mask = 0;
+    p61_access_state_t p61_current_state = P61_STATE_INVALID;
+    long ret_val = -1;
 #endif
-    return RoutingManager::getInstance().addApduRouting(route, powerState, apdu, apduLen, mask , maskLen);
-}
+    if (e == NULL && o == NULL) {
+      nat = transaction_data.transaction_nat;
+    } else {
+      nat = getNative(e, o);
+    }
 
-/*******************************************************************************
-**
-** Function:        nfcManager_unrouteApduPattern
-**
-** Description:     Remove a APDU and APDU mask routing
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         True if ok.
-**
-*******************************************************************************/
-static jboolean nfcManager_unrouteApduPattern (JNIEnv* e, jobject, jbyteArray apduData)
-{
-#if(NXP_EXTNS == TRUE)
-    if(nfcManager_isTransanctionOnGoing(true))
-    {
-       return false;
+    storeLastDiscoveryParams(technologies_mask, enable_lptd, reader_mode,
+                             enable_p2p, restart);
+#if (NXP_EXTNS == TRUE)
+    if (!pTransactionController->transactionAttempt(
+            TRANSACTION_REQUESTOR(enableDiscovery))) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("Transaction is in progress store the request");
+      set_last_request(ENABLE_DISCOVERY, nat);
+      transaction_data.discovery_params.technologies_mask = technologies_mask;
+      transaction_data.discovery_params.enable_lptd = enable_lptd;
+      transaction_data.discovery_params.reader_mode = reader_mode;
+      transaction_data.discovery_params.enable_p2p = enable_p2p;
+      transaction_data.discovery_params.restart = restart;
+      goto TheEnd;
     }
 #endif
-    ScopedByteArrayRO bytes(e, apduData);
-    uint8_t* apdu = const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0]));
-    size_t apduLen = bytes.size();
-    return RoutingManager::getInstance().removeApduRouting(apduLen ,apdu);
-}
 
-#if(NXP_EXTNS == TRUE)
-/*******************************************************************************
-**
-** Function:        nfcManager_setRoutingEntry
-**
-** Description:     Set the routing entry in routing table
-**                  e: JVM environment.
-**                  o: Java object.
-**                  type: technology or protocol routing
-**                       0x01 - Technology
-**                       0x02 - Protocol
-**                  value: technology /protocol value
-**                  route: routing destination
-**                       0x00 : Device Host
-**                       0x01 : ESE
-**                       0x02 : UICC
-**                  power: power state for the routing entry
-*******************************************************************************/
-
-static jboolean nfcManager_setRoutingEntry (JNIEnv*, jobject, jint type, jint value, jint route, jint power)
-{
-    jboolean result = false;
+#if (NXP_EXTNS == TRUE)
+    if ((nfcFL.nfcNxpEse && nfcFL.eseFL._ESE_ETSI_READER_ENABLE) &&
+        (MposManager::getInstance().getEtsiReaederState() ==
+         STATE_SE_RDR_MODE_STARTED)) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: enter STATE_SE_RDR_MODE_START_CONFIG", __func__);
+      Rdr_req_ntf_info_t mSwp_info =
+          MposManager::getInstance().getSwpRrdReqInfo();
+      {
+        SyncEventGuard guard(android::sNfaEnableDisablePollingEvent);
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: disable polling", __func__);
+        status = NFA_DisablePolling();
+        if (status == NFA_STATUS_OK) {
+          android::sNfaEnableDisablePollingEvent
+              .wait();  // wait for NFA_POLL_DISABLED_EVT
+        } else {
+          LOG(ERROR) << StringPrintf("%s: fail disable polling; error=0x%X",
+                                     __func__, status);
+        }
+      }
 
-    result = RoutingManager::getInstance().setRoutingEntry(type, value, route, power);
-    return result;
-}
-/*******************************************************************************
-**
-** Function:        nfcManager_clearRoutingEntry
-**
-** Description:     Set the routing entry in routing table
-**                  e: JVM environment.
-**                  o: Java object.
-**                  type:technology/protocol/aid clear routing
-**
-*******************************************************************************/
+      if (mSwp_info.swp_rd_req_info.tech_mask & NFA_TECHNOLOGY_MASK_A)
+        etsi_tech_mask |= NFA_TECHNOLOGY_MASK_A;
+      if (mSwp_info.swp_rd_req_info.tech_mask & NFA_TECHNOLOGY_MASK_B)
+        etsi_tech_mask |= NFA_TECHNOLOGY_MASK_B;
 
-static jboolean nfcManager_clearRoutingEntry (JNIEnv*, jobject, jint type)
-{
-    jboolean result = false;
+      {
+        SyncEventGuard guard(android::sNfaEnableDisablePollingEvent);
+        status = NFA_EnablePolling(etsi_tech_mask);
+        if (status == NFA_STATUS_OK) {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("%s: wait for enable event", __func__);
+          android::sNfaEnableDisablePollingEvent
+              .wait();  // wait for NFA_POLL_ENABLED_EVT
+        } else {
+          LOG(ERROR) << StringPrintf("%s: fail enable polling; error=0x%X",
+                                     __func__, status);
+        }
+      }
+      startRfDiscovery(true);
+      pTransactionController->transactionEnd(
+          TRANSACTION_REQUESTOR(enableDiscovery));
 
-    result = RoutingManager::getInstance().clearRoutingEntry(type);
-    return result;
-}
+      if (!pTransactionController->transactionAttempt(
+              TRANSACTION_REQUESTOR(etsiReader))) {
+        LOG(ERROR) << StringPrintf("%s: transaction attempt failed",
+                                   __FUNCTION__);
+      }
+      goto TheEnd;
+    }
 #endif
 
-/*******************************************************************************
-**
-** Function:        nfcManager_setDefaultRoute
-**
-** Description:     Set the default route in routing table
-**                  e: JVM environment.
-**                  o: Java object.
-**
-*******************************************************************************/
+    if (technologies_mask == -1 && nat)
+      tech_mask = (tNFA_TECHNOLOGY_MASK)nat->tech_mask;
+    else if (technologies_mask != -1)
+      tech_mask = (tNFA_TECHNOLOGY_MASK)technologies_mask;
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: enter; tech_mask = %02x", __func__, tech_mask);
 
-static jboolean nfcManager_setDefaultRoute (JNIEnv*, jobject, jint defaultRouteEntry, jint defaultProtoRouteEntry, jint defaultTechRouteEntry)
-{
-    jboolean result = false;
-    ALOGV("%s : enter", __func__);
+    if (sDiscoveryEnabled && !restart) {
+      LOG(ERROR) << StringPrintf("%s: already discovering", __func__);
 #if (NXP_EXTNS == TRUE)
-    if(!pTransactionController->transactionAttempt(TRANSACTION_REQUESTOR(setDefaultRoute)))
-    {
-        ALOGE("%s : Transaction in progress, Store the request",__FUNCTION__);
-        set_last_request(RE_ROUTING, NULL);
-        return result;
-    }
+      goto TheEnd;
+#else
+    return;
 #endif
-    if (sRfEnabled)
-    {
-        // Stop RF discovery to reconfigure
-        startRfDiscovery(false);
     }
 
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: sIsSecElemSelected=%u", __func__, sIsSecElemSelected);
+    PowerSwitch::getInstance().setLevel(PowerSwitch::FULL_POWER);
+
+    if (sRfEnabled) {
+      // Stop RF discovery to reconfigure
+      startRfDiscovery(false);
+    }
+
+    if (NfcConfig::hasKey(NAME_UICC_LISTEN_TECH_MASK)) {
+      num = NfcConfig::getUnsigned(NAME_UICC_LISTEN_TECH_MASK);
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s:UICC_LISTEN_MASK=0x0%lu;", __func__, num);
+    }
+    // Check polling configuration
+    if (tech_mask != 0) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: Disable p2pListening", __func__);
+      PeerToPeer::getInstance().enableP2pListening(false);
+      stopPolling_rfDiscoveryDisabled();
+      startPolling_rfDiscoveryDisabled(tech_mask);
+
+      // Start P2P listening if tag polling was enabled
+      if (sPollingEnabled) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: Enable p2pListening", __func__);
+
+        if (enable_p2p && !sP2pEnabled) {
+          sP2pEnabled = true;
+          PeerToPeer::getInstance().enableP2pListening(true);
+          NFA_ResumeP2p();
+        } else if (!enable_p2p && sP2pEnabled) {
+          sP2pEnabled = false;
+          PeerToPeer::getInstance().enableP2pListening(false);
+          NFA_PauseP2p();
+        }
+
+        if (reader_mode && !sReaderModeEnabled) {
+          sReaderModeEnabled = true;
 #if (NXP_EXTNS == TRUE)
-    result = RoutingManager::getInstance().setDefaultRoute(defaultRouteEntry, defaultProtoRouteEntry, defaultTechRouteEntry);
-    if(result)
-        result = RoutingManager::getInstance().commitRouting();
-    else
-        ALOGV("%s : Commit routing failed ", __func__);
-    gsRouteUpdated = true;
-#else
-    result = RoutingManager::getInstance().setDefaultRouting();
+          NFA_SetReaderMode(true, 0);
+          /*Send the state of readmode flag to Hal using proprietary command*/
+          sProprietaryCmdBuf[3] = 0x01;
+          status |=
+              NFA_SendRawVsCommand(sizeof(sProprietaryCmdBuf),
+                                   sProprietaryCmdBuf, NxpResponsePropCmd_Cb);
+          if (status == NFA_STATUS_OK) {
+            SyncEventGuard guard(sNfaNxpNtfEvent);
+            sNfaNxpNtfEvent.wait(500);  // wait for callback
+          } else {
+            LOG(ERROR) << StringPrintf("%s: Failed NFA_SendRawVsCommand",
+                                       __func__);
+          }
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("%s: FRM Enable", __func__);
 #endif
+          NFA_DisableListening();
+#if (NXP_EXTNS == TRUE)
+          sTechMask = tech_mask;
 
-    startRfDiscovery(true);
+          discDuration = READER_MODE_DISCOVERY_DURATION;
+#endif
+          NFA_SetRfDiscoveryDuration(READER_MODE_DISCOVERY_DURATION);
+        } else if (!reader_mode && sReaderModeEnabled) {
+          struct nfc_jni_native_data* nat = getNative(e, o);
+          sReaderModeEnabled = false;
 #if (NXP_EXTNS == TRUE)
-    pTransactionController->transactionEnd(TRANSACTION_REQUESTOR(setDefaultRoute));
+          NFA_SetReaderMode(false, 0);
+          gFelicaReaderState = STATE_IDLE;
+          /*Send the state of readmode flag to Hal using proprietary command*/
+          sProprietaryCmdBuf[3] = 0x00;
+          status |=
+              NFA_SendRawVsCommand(sizeof(sProprietaryCmdBuf),
+                                   sProprietaryCmdBuf, NxpResponsePropCmd_Cb);
+          if (status == NFA_STATUS_OK) {
+            SyncEventGuard guard(sNfaNxpNtfEvent);
+            sNfaNxpNtfEvent.wait(500);  // wait for callback
+          } else {
+            LOG(ERROR) << StringPrintf("%s: Failed NFA_SendRawVsCommand",
+                                       __func__);
+          }
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("%s: FRM Disable", __func__);
 #endif
-    ALOGV("%s : exit", __func__);
-    return result;
-}
-
-/*******************************************************************************
-**
-** Function:        nfcManager_getAidTableSize
-** Description:     Get the maximum supported size for AID routing table.
-**
-**                  e: JVM environment.
-**                  o: Java object.
-**
-*******************************************************************************/
-static jint nfcManager_getAidTableSize (JNIEnv*, jobject )
-{
-    return NFA_GetAidTableSize();
-}
+          if ((nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME ==
+               nfcFL.eseFL._ESE_EXCLUSIVE_WIRED_MODE) ||
+              nfcFL.eseFL._ESE_UICC_EXCLUSIVE_WIRED_MODE) {
+            if (!SecureElement::getInstance().mlistenDisabled) {
+              NFA_EnableListening();
+            }
+          } else {
+            NFA_EnableListening();
+          }
 
-/*******************************************************************************
-**
-** Function:        nfcManager_getRemainingAidTableSize
-** Description:     Get the remaining size of AID routing table.
-**
-**                  e: JVM environment.
-**                  o: Java object.
-**
-*******************************************************************************/
-static jint nfcManager_getRemainingAidTableSize (JNIEnv* , jobject )
-{
-    return NFA_GetRemainingAidTableSize();
-}
-/*******************************************************************************
-**
-** Function:        nfcManager_clearAidTable
-**
-** Description:     Clean all AIDs in routing table
-**                  e: JVM environment.
-**                  o: Java object.
-**
-*******************************************************************************/
-static bool nfcManager_clearAidTable (JNIEnv*, jobject)
-{
-#if(NXP_EXTNS == TRUE)
-    if(nfcManager_isTransanctionOnGoing(true))
-    {
-       return false;
-    }
+#if (NXP_EXTNS == TRUE)
+          discDuration = nat->discovery_duration;
 #endif
-    return RoutingManager::getInstance().clearAidTable();
-}
-/*******************************************************************************
-**
-** Function:        nfcManager_doRegisterT3tIdentifier
-**
-** Description:     Registers LF_T3T_IDENTIFIER for NFC-F.
-**                  e: JVM environment.
-**                  o: Java object.
-**                  t3tIdentifier: LF_T3T_IDENTIFIER value (10 or 18 bytes)
-**
-** Returns:         Handle retrieve from RoutingManager.
-**
-*******************************************************************************/
-static jint nfcManager_doRegisterT3tIdentifier(JNIEnv* e, jobject, jbyteArray t3tIdentifier)
-{
-    ALOGV("%s: enter", __func__);
-    ScopedByteArrayRO bytes(e, t3tIdentifier);
-    uint8_t* buf = const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0]));
-    size_t bufLen = bytes.size();
-    int handle = RoutingManager::getInstance().registerT3tIdentifier(buf, bufLen);
-    ALOGV("%s: exit", __func__);
-    return handle;
-}
-
-/*******************************************************************************
-**
-** Function:        nfcManager_doDeregisterT3tIdentifier
-**
-** Description:     Deregisters LF_T3T_IDENTIFIER for NFC-F.
-**                  e: JVM environment.
-**                  o: Java object.
-**                  handle: Handle retrieve from libnfc-nci.
-**
-** Returns:         None
-**
-*******************************************************************************/
-static void nfcManager_doDeregisterT3tIdentifier(JNIEnv*, jobject, jint handle)
-{
-    ALOGV("%s: enter", __func__);
-    RoutingManager::getInstance().deregisterT3tIdentifier(handle);
-    ALOGV("%s: exit", __func__);
-}
-
-/*******************************************************************************
-**
-** Function:        nfcManager_getLfT3tMax
-**
-** Description:     Returns LF_T3T_MAX value.
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         LF_T3T_MAX value.
-**
-*******************************************************************************/
-static jint nfcManager_getLfT3tMax(JNIEnv*, jobject)
-{
-    return sLfT3tMax;
-}
-
-/*******************************************************************************
-**
-** Function:        nfcManager_doInitialize
-**
-** Description:     Turn on NFC.
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         True if ok.
-**
-*******************************************************************************/
-static jboolean nfcManager_doInitialize (JNIEnv* e, jobject o)
-{
-    tNFA_MW_VERSION mwVer;
-    gSeDiscoverycount = 0;
-    gActualSeCount = 0;
-    uint8_t configData = 0;
+          NFA_SetRfDiscoveryDuration(nat->discovery_duration);
+        } else {
+          {
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+                "%s: restart UICC listen mode (%02lX)", __func__, (num & 0xC7));
+            handle = (sCurrentSelectedUICCSlot!=0x02)?
+                SecureElement::getInstance().getEseHandleFromGenericId(SecureElement::UICC_ID):
+                SecureElement::getInstance().getEseHandleFromGenericId(SecureElement::UICC2_ID);
+            SyncEventGuard guard(SecureElement::getInstance().mUiccListenEvent);
+            stat = NFA_CeConfigureUiccListenTech(handle, 0x00);
+            if (stat == NFA_STATUS_OK) {
+              SecureElement::getInstance().mUiccListenEvent.wait();
+            } else
+              LOG(ERROR) << StringPrintf("fail to stop UICC listen");
+          }
+          {
+            SyncEventGuard guard(SecureElement::getInstance().mUiccListenEvent);
+            stat = NFA_CeConfigureUiccListenTech(handle, (num & 0xC7));
+            if (stat == NFA_STATUS_OK) {
+              SecureElement::getInstance().mUiccListenEvent.wait();
+            } else
+              LOG(ERROR) << StringPrintf("fail to start UICC listen");
+          }
+        }
+      }
+      NFC_SetNfcServicePid();
+    } else {
+      // No technologies configured, stop polling
+      stopPolling_rfDiscoveryDisabled();
+    }
 
-    uint8_t switchToUiccSlot = 0;
-#if(NXP_EXTNS == TRUE)
-    rfActivation = false;
-    tNFA_PMID ven_config_addr[]  = {0xA0, 0x07};
-    bool isSuccess = false;
-    sNfcee_disc_state = UICC_SESSION_NOT_INTIALIZED;
+    // Start P2P listening if tag polling was enabled or the mask was 0.
+    if (sDiscoveryEnabled || (tech_mask == 0)) {
+      handle = SecureElement::getInstance().getEseHandleFromGenericId(
+          SecureElement::UICC_ID);
 
-    /* NFC initialization in progress */
-    if(NFC_OFF == sNfcState)
-        sNfcState = NFC_INITIALIZING_IN_PROGRESS;
+#if (NXP_EXTNS == TRUE)
+      if ((getScreenState() == (NFA_SCREEN_STATE_ON_UNLOCKED)) ||
+          sProvisionMode) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: Enable p2pListening", __func__);
+        PeerToPeer::getInstance().enableP2pListening(true);
+      } else {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: Disable p2pListening", __func__);
+        PeerToPeer::getInstance().enableP2pListening(false);
+      }
 #endif
-    ALOGV("%s: enter; ver=%s nfa=%s NCI_VERSION=0x%02X",
-        __func__, nfca_version_string, nfa_version_string, NCI_VERSION);
-    mwVer=  NFA_GetMwVersion();
-    ALOGV("%s:  MW Version: NFC_NCIHALx_AR%X.%x.%x.%x",
-            __func__, mwVer.validation, mwVer.android_version,
-            mwVer.major_version,mwVer.minor_version);
 
-    tNFA_STATUS stat = NFA_STATUS_OK;
-    NfcTag::getInstance ().mNfcDisableinProgress = false;
-    PowerSwitch & powerSwitch = PowerSwitch::getInstance ();
-    if (sIsNfaEnabled)
-    {
-        ALOGV("%s: already enabled", __func__);
-        goto TheEnd;
+      {
+        SyncEventGuard guard(SecureElement::getInstance().mUiccListenEvent);
+        stat = NFA_CeConfigureUiccListenTech(handle, 0x00);
+        if (stat == NFA_STATUS_OK) {
+          SecureElement::getInstance().mUiccListenEvent.wait();
+        } else
+          LOG(ERROR) << StringPrintf("fail to start UICC listen");
+      }
+
+      {
+        SyncEventGuard guard(SecureElement::getInstance().mUiccListenEvent);
+        stat = NFA_CeConfigureUiccListenTech(handle, (num & 0xC7));
+        if (stat == NFA_STATUS_OK) {
+          SecureElement::getInstance().mUiccListenEvent.wait();
+        } else
+          LOG(ERROR) << StringPrintf("fail to start UICC listen");
+      }
     }
-#if(NXP_EXTNS == TRUE)
-    if(gsNfaPartialEnabled)
-    {
-        ALOGV("%s: already  partial enable calling deinitialize", __func__);
-        nfcManager_doPartialDeInitialize();
+    // Actually start discovery.
+    startRfDiscovery(true);
+    sDiscoveryEnabled = true;
+
+    PowerSwitch::getInstance().setModeOn(PowerSwitch::DISCOVERY);
+
+#if (NXP_EXTNS == TRUE)
+  TheEnd:
+    pTransactionController->transactionEnd(
+        TRANSACTION_REQUESTOR(enableDiscovery));
+    /* Set this state only during initialization and in all the other cases
+    NfcState should remain at NFC_ON  except during Nfc deinit */
+    if (NFC_INITIALIZING_IN_PROGRESS == sNfcState) {
+      sNfcState = NFC_ON;
+      ret_val = NFC_GetP61Status((void*)&p61_current_state);
+      if (ret_val < 0) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("NFC_GetP61Status failed");
+      }
+      if (!(p61_current_state & (P61_STATE_SPI) &&
+            !(p61_current_state & (P61_STATE_SPI_PRIO)))) {
+        SecureElement::getInstance().setNfccPwrConfig(
+            SecureElement::getInstance().NFCC_DECIDES);
+      }
+      NFC_SetNfcServicePid();
     }
+
 #endif
-    powerSwitch.initialize (PowerSwitch::FULL_POWER);
-    register_signal_handler();
-    {
-        unsigned long num = 0;
-
-        NfcAdaptation& theInstance = NfcAdaptation::GetInstance();
-        theInstance.Initialize(); //start GKI, NCI task, NFC task
-#if(NXP_EXTNS == TRUE)
-                int state = getJCOPOS_UpdaterState();
-                if((state != OSU_COMPLETE) &&
-                        (state != OSU_NOT_STARTED))
-                {
-                    ALOGV("JCOP is in OSU mode");
-                    NFA_SetBootMode(NFA_OSU_BOOT_MODE);
-                }
-                else {
-                    NFA_SetBootMode(NFA_NORMAL_BOOT_MODE);
-                }
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_disableDiscovery
+  **
+  ** Description:     Stop polling and listening for devices.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void nfcManager_disableDiscovery(JNIEnv * e, jobject o) {
+    (void)e;
+    (void)o;
+    tNFA_STATUS status = NFA_STATUS_OK;
+    unsigned long num = 0;
+    unsigned long p2p_listen_mask = 0;
+    tNFA_HANDLE handle = NFA_HANDLE_INVALID;
+#if (NXP_EXTNS == TRUE)
+    p61_access_state_t p61_current_state = P61_STATE_INVALID;
+    long ret_val = -1;
 #endif
-            stat = nfcManagerEnableNfc(theInstance);
-            nfcManager_getFeatureList();
-            EXTNS_Init (nfaDeviceManagementCallback, nfaConnectionCallback);
-
-        if (stat == NFA_STATUS_OK )
-        {
-            //sIsNfaEnabled indicates whether stack started successfully
-            if (sIsNfaEnabled)
-            {
-                SecureElement::getInstance().initialize (getNative(e, o));
-                //setListenMode();
-                RoutingManager::getInstance().initialize(getNative(e, o));
-                HciRFParams::getInstance().initialize ();
-                sIsSecElemSelected = (SecureElement::getInstance().getActualNumEe() - 1 );
-                sIsSecElemDetected = sIsSecElemSelected;
-                nativeNfcTag_registerNdefTypeHandler ();
-                NfcTag::getInstance().initialize (getNative(e, o));
-                PeerToPeer::getInstance().initialize ();
-                PeerToPeer::getInstance().handleNfcOnOff (true);
-#if(NXP_EXTNS == TRUE)
-                if(GetNxpNumValue(NAME_NXP_DEFAULT_NFCEE_DISC_TIMEOUT, (void *)&gdisc_timeout, sizeof(gdisc_timeout))==false)
-                {
-                    ALOGV("NAME_NXP_DEFAULT_NFCEE_DISC_TIMEOUT not found");
-                    gdisc_timeout = NFCEE_DISC_TIMEOUT_SEC; /*Default nfcee discover timeout*/
-                }
-                gdisc_timeout = gdisc_timeout * 1000;
-                if (NFA_STATUS_OK == GetNumNFCEEConfigured())
-                {
-                    ALOGV(" gSeDiscoverycount = %d gActualSeCount=%d", gSeDiscoverycount,gActualSeCount);
-                    if (gSeDiscoverycount < gActualSeCount)
-                    {
-                        ALOGV("Wait for ESE to discover, gdisc_timeout = %d", gdisc_timeout);
-                        SyncEventGuard g(gNfceeDiscCbEvent);
-                        if(gNfceeDiscCbEvent.wait(gdisc_timeout) == false)
-                        {
-                            ALOGE("%s: timeout waiting for nfcee dis event", __func__);
-                        }
-                        ALOGV("gSeDiscoverycount  = %d gActualSeCount=%d", gSeDiscoverycount,gActualSeCount);
-                    }
-                    else
-                    {
-                        ALOGV("All ESE are discovered ");
-                    }
-                }
-                if(nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
-                    checkforESERemoval();
-                    GetNxpNumValue (NAME_NXP_DUAL_UICC_ENABLE, (void*)&dualUiccInfo.dualUiccEnable, sizeof(dualUiccInfo.dualUiccEnable));
-                    if(dualUiccInfo.dualUiccEnable == 0x01)
-                    {
-                        checkforNfceeConfig(UICC1 | UICC2 | ESE);
-                        dualUiccInfo.uiccActivStat = 0x00;
-                        if(SecureElement::getInstance().getEeStatus(SecureElement::getInstance().EE_HANDLE_0xF4)!=NFC_NFCEE_STATUS_REMOVED)
-                        {
-                            dualUiccInfo.uiccActivStat = (sSelectedUicc & 0x0F);
-                        }
-                        switchToUiccSlot = ((sSelectedUicc & 0x0F) == 0x01) ? 0x02 : 0x01;
-                        nfcManager_doSelectUicc(e,o,switchToUiccSlot);
-                        if(SecureElement::getInstance().getEeStatus(SecureElement::getInstance().EE_HANDLE_0xF4)!=NFC_NFCEE_STATUS_REMOVED)
-                        {
-                            dualUiccInfo.uiccActivStat |= (sSelectedUicc & 0x0F);
-                        }
-                        uiccEventTimer.set (1, notifyUiccEvent);
-                    }
-                }
-                else
-                    SecureElement::getInstance().updateEEStatus();
-                if(nfcFL.eseFL._JCOP_WA_ENABLE) {
-                    RoutingManager::getInstance().handleSERemovedNtf();
-                }
-                ALOGV("Discovered se count %ld",gSeDiscoverycount);
-                /*Check for ETSI12 Configuration for SEs detected in the HCI Network*/
-                performNfceeETSI12Config();
-                if(nfcFL.eseFL._ESE_ETSI12_PROP_INIT && (swp_getconfig_status & SWP2_ESE)) {
-                    performHCIInitialization (e,o);
-                }
-               SecureElement::getInstance().getSETechnology(SecureElement::EE_HANDLE_0xF3);
-                checkforNfceeConfig(UICC1 | UICC2 | ESE);
-                /*Pending clear all pipe handling*/
-                if(sNfcee_disc_state == UICC_CLEAR_ALL_PIPE_NTF_RECEIVED)
-                {
-                    ALOGV("Perform pending UICC clear all pipe handling");
-                    sNfcee_disc_state = UICC_SESSION_INTIALIZATION_DONE;
-                    /*Handle UICC clear all pipe notification*/
-                    checkforNfceeConfig(UICC1 | UICC2);
-                }
-                    sNfcee_disc_state = UICC_SESSION_INTIALIZATION_DONE;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter;", __func__);
+#if (NXP_EXTNS == TRUE)
+    if (!pTransactionController->transactionAttempt(
+            TRANSACTION_REQUESTOR(disableDiscovery))) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("Transaction in progress, Store the request");
+      set_last_request(DISABLE_DISCOVERY, NULL);
+      return;
+    }
 #endif
-                    if(nfcFL.eseFL._GP_CONTINOUS_PROCESSING) {
-                        if(isNxpConfigModified())
-                        {
-                            ALOGV("Set JCOP CP Timeout");
-                            SecureElement::getInstance().setCPTimeout();
-                        }
-                        else
-                        {
-                            ALOGV("No Need to set JCOP CP Timeout");
-                        }
-                    }
-                /////////////////////////////////////////////////////////////////////////////////
-                // Add extra configuration here (work-arounds, etc.)
+    pn544InteropAbortNow();
 #if (NXP_EXTNS == TRUE)
-                    if(nfcFL.nfcNxpEse) {
-                        if(nfcFL.eseFL._ESE_SVDD_SYNC || nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION ||
-                                nfcFL.nfccFL._NFCC_SPI_FW_DOWNLOAD_SYNC ||
-                                nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE) {
-                            isSuccess = createSPIEvtHandlerThread();
-                        }
-                        if(nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE && isSuccess) {
-                            SecureElement::getInstance().enableDwp();
-                        }
-                        else if(!isSuccess) {
-                            ALOGV("Failed to start SPI Event Handler Thread");
-                        }
-                    }
+    if (nfcFL.nfcNxpEse && nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
+      if (MposManager::getInstance().getEtsiReaederState() ==
+          STATE_SE_RDR_MODE_START_IN_PROGRESS) {
+        Rdr_req_ntf_info_t mSwp_info =
+            MposManager::getInstance().getSwpRrdReqInfo();
+        //        if(android::isDiscoveryStarted() == true)
+        android::startRfDiscovery(false);
+        PeerToPeer::getInstance().enableP2pListening(false);
+        {
+          if (mSwp_info.swp_rd_req_info.src == 0x4C0) {
+            SyncEventGuard guard(SecureElement::getInstance().mEseListenEvent);
+            status = NFA_CeConfigureEseListenTech(handle, 0x00);
+            if (status == NFA_STATUS_OK)
+              SecureElement::getInstance().mEseListenEvent.wait();
+          } else {
+            SyncEventGuard guard(SecureElement::getInstance().mUiccListenEvent);
+            status = NFA_CeConfigureUiccListenTech(handle, 0x00);
+            if (status == NFA_STATUS_OK)
+              SecureElement::getInstance().mUiccListenEvent.wait();
+          }
+          if (status != NFA_STATUS_OK) {
+            LOG(ERROR) << StringPrintf("fail to reset UICC/eSE listen");
+          }
+        }
+        goto TheEnd;
+      } else if (MposManager::getInstance().getEtsiReaederState() ==
+                 STATE_SE_RDR_MODE_STOP_IN_PROGRESS) {
+        android::startRfDiscovery(false);
+        goto TheEnd;
+      }
+    }
 #endif
-                    //Create transaction controller
-                    (void)transactionController::controller();
-                    pendingScreenState = false;
-                    {
-                        SyncEventGuard guard (android::sNfaGetConfigEvent);
-                        stat = NFA_GetConfig(0x01,ven_config_addr);
-                        if(stat == NFA_STATUS_OK)
-                        {
-                            android::sNfaGetConfigEvent.wait();
-                        }
-                        /*sCurrentConfigLen should be > 4 (num_tlv:1 + addr:2 + value:1) and
-                         *pos 4 gives the current eeprom value*/
-                        if((sCurrentConfigLen > 4)&&(sConfig[4] == 0x03))
-                        {
-                            ALOGV("%s: No need to update VEN_CONFIG. Already set to 0x%02x", __func__,sConfig[4]);
-                        }
-                        else
-                        {
-                            SetVenConfigValue(NFC_MODE_ON);
-                            if (stat != NFA_STATUS_OK)
-                            {
-                                ALOGE("%s: fail enable SetVenConfigValue; error=0x%X", __func__, stat);
-                            }
-                        }
-                        gGeneralPowershutDown = 0;
-                    }
-                    if(gIsDtaEnabled == true){
-                        configData = 0x01;    /**< Poll NFC-DEP : Highest Available Bit Rates */
-                        NFA_SetConfig(NFC_PMID_BITR_NFC_DEP, sizeof(uint8_t), &configData);
-                        configData = 0x0B;    /**< Listen NFC-DEP : Waiting Time */
-                        NFA_SetConfig(NFC_PMID_WT, sizeof(uint8_t), &configData);
-                        configData = 0x0F;    /**< Specific Parameters for NFC-DEP RF Interface */
-                        NFA_SetConfig(NFC_PMID_NFC_DEP_OP, sizeof(uint8_t), &configData);
-                    }
 
-                struct nfc_jni_native_data *nat = getNative(e, o);
+    if (sDiscoveryEnabled == false) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: already disabled", __func__);
+      goto TheEnd;
+    }
+    // Stop RF Discovery.
+    startRfDiscovery(false);
+
+    if (sPollingEnabled) status = stopPolling_rfDiscoveryDisabled();
+    sDiscoveryEnabled = false;
 
-                if ( nat )
-                {
-                    if (GetNumValue(NAME_POLLING_TECH_MASK, &num, sizeof(num)))
-                        nat->tech_mask = num;
-                    else
-                        nat->tech_mask = DEFAULT_TECH_MASK;
-                    ALOGV("%s: tag polling tech mask=0x%X", __func__, nat->tech_mask);
-                }
+    if (NfcConfig::hasKey(NAME_UICC_LISTEN_TECH_MASK)) {
+      num = NfcConfig::getUnsigned(NAME_UICC_LISTEN_TECH_MASK);
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s:UICC_LISTEN_MASK=0x0%lu;", __func__, num);
+    }
 
-                // if this value exists, set polling interval.
-                if (GetNumValue(NAME_NFA_DM_DISC_DURATION_POLL, &num, sizeof(num)))
-                    nat->discovery_duration = num;
-                else
-                    nat->discovery_duration = DEFAULT_DISCOVERY_DURATION;
-#if(NXP_EXTNS == TRUE)
-                discDuration = nat->discovery_duration;
-#endif
-                NFA_SetRfDiscoveryDuration(nat->discovery_duration);
+    if (NfcConfig::hasKey(NAME_P2P_LISTEN_TECH_MASK)) {
+      p2p_listen_mask = NfcConfig::getUnsigned(NAME_P2P_LISTEN_TECH_MASK);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s:P2P_LISTEN_MASK=0x0%lu;", __func__, p2p_listen_mask);
+    }
+    PeerToPeer::getInstance().enableP2pListening(false);
+    NFA_PauseP2p();
 
-                // get LF_T3T_MAX
-                {
-                    SyncEventGuard guard (sNfaGetConfigEvent);
-                    tNFA_PMID configParam[1] = {NCI_PARAM_ID_LF_T3T_MAX};
-                    stat = NFA_GetConfig(1, configParam);
-                    if (stat == NFA_STATUS_OK)
-                    {
-                        sNfaGetConfigEvent.wait ();
-                        if (sCurrentConfigLen >= 4 || sConfig[1] == NCI_PARAM_ID_LF_T3T_MAX) {
-                            ALOGV("%s: lfT3tMax=%d", __func__, sConfig[3]);
-                            sLfT3tMax = sConfig[3];
-                        }
-                    }
-                }
-                if (GetNxpNumValue (NAME_NXP_CE_ROUTE_STRICT_DISABLE, (void*)&num, sizeof(num)) == false)
-                    num = 0x01; // default value
-
-//TODO: Check this in L_OSP_EXT[PN547C2]
-//                NFA_SetCEStrictDisable(num);
-                RoutingManager::getInstance().setCeRouteStrictDisable(num);
-                prevScreenState = NFA_SCREEN_STATE_OFF_LOCKED;
-#if(NXP_EXTNS != TRUE)
-                // Do custom NFCA startup configuration.
-                doStartupConfig();
-#endif
-                goto TheEnd;
-            }
+    if (sIsSecElemSelected) {
+      SecureElement& se = SecureElement::getInstance();
+      tNFA_HANDLE ee_handleList[nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED];
+      uint8_t count;
+      se.getEeHandleList(ee_handleList, &count);
+      for (int i = 0; i < count; i++) {
+        handle =
+            se.getEseHandleFromGenericId(se.getGenericEseId(ee_handleList[i]));
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s:Registering for active handle id=0x%x;", __func__, handle);
+
+        if (handle == 0x4C0) {
+          SyncEventGuard guard(SecureElement::getInstance().mEseListenEvent);
+          status = NFA_CeConfigureEseListenTech(handle, 0x00);
+          if (status == NFA_STATUS_OK)
+            SecureElement::getInstance().mEseListenEvent.wait();
+        } else {
+          SyncEventGuard guard(SecureElement::getInstance().mUiccListenEvent);
+          status = NFA_CeConfigureUiccListenTech(handle, 0x00);
+          if (status == NFA_STATUS_OK)
+            SecureElement::getInstance().mUiccListenEvent.wait();
+        }
+        if (status != NFA_STATUS_OK) {
+          LOG(ERROR) << StringPrintf("fail to reset UICC/eSE listen");
         }
 
-        ALOGE("%s: fail nfa enable; error=0x%X", __func__, stat);
-
-        if (sIsNfaEnabled)
-        {
-            EXTNS_Close ();
-            stat = NFA_Disable (false /* ungraceful */);
+        if (handle == 0x4C0) {
+          SyncEventGuard guard(SecureElement::getInstance().mEseListenEvent);
+          status = NFA_CeConfigureEseListenTech(handle, (num & 0x07));
+          if (status == NFA_STATUS_OK)
+            SecureElement::getInstance().mEseListenEvent.wait();
+        } else {
+          SyncEventGuard guard(SecureElement::getInstance().mUiccListenEvent);
+          status = NFA_CeConfigureUiccListenTech(handle, (num & 0x07));
+          if (status == NFA_STATUS_OK)
+            SecureElement::getInstance().mUiccListenEvent.wait();
+        }
+        if (status != NFA_STATUS_OK) {
+          LOG(ERROR) << StringPrintf("fail to start UICC/eSE listen");
         }
+      }
 
-        theInstance.Finalize();
+      PeerToPeer::getInstance().enableP2pListening(false);
+      startRfDiscovery(true);
     }
 
-TheEnd:
-    if (sIsNfaEnabled)
-        PowerSwitch::getInstance ().setLevel (PowerSwitch::LOW_POWER);
-    ALOGV("%s: exit", __func__);
+    sP2pEnabled = false;
+    // if nothing is active after this, then tell the controller to power down
+    // if (! PowerSwitch::getInstance ().setModeOff (PowerSwitch::DISCOVERY))
+    // PowerSwitch::getInstance ().setLevel (PowerSwitch::LOW_POWER);
+
+    // We may have had RF field notifications that did not cause
+    // any activate/deactive events. For example, caused by wireless
+    // charging orbs. Those may cause us to go to sleep while the last
+    // field event was indicating a field. To prevent sticking in that
+    // state, always reset the rf field status when we disable discovery.
+    SecureElement::getInstance().resetRfFieldStatus();
+  TheEnd:
 #if (NXP_EXTNS == TRUE)
-    if (isNxpConfigModified())
-    {
-        updateNxpConfigTimestamp();
+    pTransactionController->transactionEnd(
+        TRANSACTION_REQUESTOR(disableDiscovery));
+    /* Set this state only during initialization and in all the other cases
+        NfcState should remain at NFC_ON  except during Nfc deinit */
+    if (NFC_INITIALIZING_IN_PROGRESS == sNfcState) {
+      if (nfcFL.eseFL._WIRED_MODE_STANDBY) {
+        sNfcState = NFC_ON;
+        ret_val = NFC_GetP61Status((void*)&p61_current_state);
+        if (ret_val < 0) {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("NFC_GetP61Status failed");
+        }
+        if (!(p61_current_state & (P61_STATE_SPI) &&
+              !(p61_current_state & (P61_STATE_SPI_PRIO)))) {
+          SecureElement::getInstance().setNfccPwrConfig(
+              SecureElement::getInstance().NFCC_DECIDES);
+        }
+      }
+
+      NFC_SetNfcServicePid();
     }
 #endif
-    return sIsNfaEnabled ? JNI_TRUE : JNI_FALSE;
-}
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  }
 
-/*******************************************************************************
-**
-** Function:        nfcManager_doEnableDtaMode
-**
-** Description:     Enable the DTA mode in NFC service.
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         None
-**
-*******************************************************************************/
-static void nfcManager_doEnableDtaMode (JNIEnv* /* e */, jobject /* o */)
-{
-    gIsDtaEnabled = true;
-}
+  void enableDisableLongGuardTime(bool enable) {
+    // TODO
+    // This is basically a work-around for an issue
+    // in BCM20791B5: if a reader is configured as follows
+    // 1) Only polls for NFC-A
+    // 2) Cuts field between polls
+    // 3) Has a short guard time (~5ms)
+    // the BCM20791B5 doesn't wake up when such a reader
+    // is polling it. Unfortunately the default reader
+    // mode configuration on Android matches those
+    // criteria. To avoid the issue, increase the guard
+    // time when in reader mode.
+    //
+    // Proper fix is firmware patch for B5 controllers.
+    SyncEventGuard guard(sNfaSetConfigEvent);
+    tNFA_STATUS stat =
+        NFA_SetConfig(NCI_PARAM_ID_T1T_RDR_ONLY, 2,
+                      enable ? sLongGuardTime : sDefaultGuardTime);
+    if (stat == NFA_STATUS_OK)
+      sNfaSetConfigEvent.wait();
+    else
+      LOG(ERROR) << StringPrintf("%s: Could not configure longer guard time",
+                                 __func__);
+    return;
+  }
 
-#if (NXP_EXTNS == TRUE)
-/*******************************************************************************
-**
-** Function:        nfcManagerEnableNfc
-**
-** Description:     Enables Nfc submodules in libnfc
-**
-** Returns:         Status
-**
-*******************************************************************************/
-static tNFA_STATUS nfcManagerEnableNfc(NfcAdaptation& theInstance)
-{
-    uint8_t retryCount = 0;
-    unsigned long num = 0;
+  void setUiccIdleTimeout(bool enable) {
+    // This method is *NOT* thread-safe. Right now
+    // it is only called from the same thread so it's
+    // not an issue.
     tNFA_STATUS stat = NFA_STATUS_OK;
-    do {
-        SyncEventGuard guard (sNfaEnableEvent);
-        tHAL_NFC_ENTRY* halFuncEntries = theInstance.GetHalEntryFuncs ();
-        NFA_Init (halFuncEntries);
-        stat = NFA_Enable (nfaDeviceManagementCallback, nfaConnectionCallback);
-        if (stat == NFA_STATUS_OK)
-        {
-            num = initializeGlobalAppLogLevel ();
-            CE_SetTraceLevel (num);
-            LLCP_SetTraceLevel (num);
-            NFC_SetTraceLevel (num);
-            RW_SetTraceLevel (num);
-            NFA_SetTraceLevel (num);
-            NFA_P2pSetTraceLevel (num);
-            sNfaEnableEvent.wait(); //wait for NFA command to finish
-        }
-        retryCount++;
-        ALOGV("%s: sEnableStatus =0x%X", __func__, sEnableStatus);
-    }while((sEnableStatus == NFA_STATUS_NOT_INITIALIZED) && (retryCount < 3));
+    uint8_t swp_cfg_byte0 = 0x00;
+    {
+      SyncEventGuard guard(sNfaGetConfigEvent);
+      tNFA_PMID configParam[1] = {0xC2};
+      stat = NFA_GetConfig(1, configParam);
+      if (stat != NFA_STATUS_OK) {
+        LOG(ERROR) << StringPrintf("%s: NFA_GetConfig failed", __func__);
+        return;
+      }
+      sNfaGetConfigEvent.wait();
+      if (sCurrentConfigLen < 4 || sConfig[1] != 0xC2) {
+        LOG(ERROR) << StringPrintf(
+            "%s: Config TLV length %d returned is too short", __func__,
+            sCurrentConfigLen);
+        return;
+      }
+      swp_cfg_byte0 = sConfig[3];
+    }
+    SyncEventGuard guard(sNfaSetConfigEvent);
+    if (enable)
+      swp_cfg_byte0 |= 0x01;
+    else
+      swp_cfg_byte0 &= ~0x01;
 
-   return stat;
-}
-/*******************************************************************************
- **
- ** Function:        nfcManager_checkNfcStateBusy()
- **
- ** Description      This function returns whether NFC process is busy or not.
- **
- ** Returns          if Nfc state busy return true otherwise false.
- **
- *******************************************************************************/
-bool nfcManager_checkNfcStateBusy()
-{
-    bool status = false;
+    stat = NFA_SetConfig(0xC2, 1, &swp_cfg_byte0);
+    if (stat == NFA_STATUS_OK)
+      sNfaSetConfigEvent.wait();
+    else
+      LOG(ERROR) << StringPrintf(
+          "%s: Could not configure UICC idle timeout feature", __func__);
+    return;
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_doCreateLlcpServiceSocket
+  **
+  ** Description:     Create a new LLCP server socket.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **                  nSap: Service access point.
+  **                  sn: Service name
+  **                  miu: Maximum information unit.
+  **                  rw: Receive window size.
+  **                  linearBufferLength: Max buffer size.
+  **
+  ** Returns:         NativeLlcpServiceSocket Java object.
+  **
+  *******************************************************************************/
+  static jobject nfcManager_doCreateLlcpServiceSocket(
+      JNIEnv * e, jobject, jint nSap, jstring sn, jint miu, jint rw,
+      jint linearBufferLength) {
+    PeerToPeer::tJNI_HANDLE jniHandle =
+        PeerToPeer::getInstance().getNewJniHandle();
 
-    if(NFA_checkNfcStateBusy() == true)
-        status = true;
+    ScopedUtfChars serviceName(e, sn);
+    if (serviceName.c_str() == NULL) {
+      LOG(ERROR) << StringPrintf("%s: service name can not be null error",
+                                 __func__);
+      return NULL;
+    }
 
-    return status;
-}
-/*******************************************************************************
- **
- ** Function:        requestFwDownload
- **
- ** Description      This function is to complete the FW Dwnld to complete the
- **                  the pending request due to SPI session ongoing .
- **
- ** Returns          void.
- **
- *******************************************************************************/
-void requestFwDownload()
-{
-    JNIEnv* e = NULL;
-    uint8_t fwDnldRequest = false;
-    int status = NFA_STATUS_OK;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: enter: sap=%i; name=%s; miu=%i; rw=%i; buffLen=%i", __func__, nSap,
+        serviceName.c_str(), miu, rw, linearBufferLength);
 
-    NfcAdaptation& theInstance = NfcAdaptation::GetInstance();
-    status = theInstance.HalGetFwDwnldFlag(&fwDnldRequest);
-    ALOGV("Enter: %s fwDnldRequest = %d",__func__, fwDnldRequest);
-    if (status == NFA_STATUS_OK)
-    {
-        if(fwDnldRequest == true)
-        {
-            ScopedAttach attach(RoutingManager::getInstance().mNativeData->vm, &e);
-            if (e == NULL)
-            {
-                ALOGE("Exit:%s jni env is null",__func__);
-                return;
-            }
-            if(nfcFL.nfccFL._NFCC_SPI_FW_DOWNLOAD_SYNC) {
-                e->CallVoidMethod (gNativeData->manager,
-                        android::gCachedNfcManagerNotifyFwDwnldRequested);
-            }
-            if (e->ExceptionCheck())
-            {
-                e->ExceptionClear();
-                ALOGE("Exit:%s fail notify",__func__);
-            }
+    /* Create new NativeLlcpServiceSocket object */
+    jobject serviceSocket = NULL;
+    if (nfc_jni_cache_object_local(e, gNativeLlcpServiceSocketClassName,
+                                   &(serviceSocket)) == -1) {
+      LOG(ERROR) << StringPrintf("%s: Llcp socket object creation error",
+                                 __func__);
+      return NULL;
+    }
 
-        }
-        else
-        {
-            ALOGE("Exit:%s Firmware download request:%d ",__func__, fwDnldRequest);
-        }
+    /* Get NativeLlcpServiceSocket class object */
+    ScopedLocalRef<jclass> clsNativeLlcpServiceSocket(
+        e, e->GetObjectClass(serviceSocket));
+    if (e->ExceptionCheck()) {
+      e->ExceptionClear();
+      LOG(ERROR) << StringPrintf("%s: Llcp Socket get object class error",
+                                 __func__);
+      return NULL;
     }
-    else
-    {
-        ALOGE("Exit:%s HalGetFwDwnldFlag status:%d ",__func__, status);
+
+    if (!PeerToPeer::getInstance().registerServer(jniHandle,
+                                                  serviceName.c_str())) {
+      LOG(ERROR) << StringPrintf("%s: RegisterServer error", __func__);
+      return NULL;
     }
-}
-#endif
 
-/*******************************************************************************
-**
-** Function:        nfcManager_doDisableDtaMode
-**
-** Description:     Disable the DTA mode in NFC service.
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         None
-**
-*******************************************************************************/
-static void nfcManager_doDisableDtaMode(JNIEnv* /* e */, jobject /* o */)
-{
-    gIsDtaEnabled = false;
-}
+    jfieldID f;
 
-static void nfcManager_doFactoryReset(JNIEnv*, jobject) {
-  NfcAdaptation& theInstance = NfcAdaptation::GetInstance();
-  theInstance.FactoryReset();
-}
+    /* Set socket handle to be the same as the NfaHandle*/
+    f = e->GetFieldID(clsNativeLlcpServiceSocket.get(), "mHandle", "I");
+    e->SetIntField(serviceSocket, f, (jint)jniHandle);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: socket Handle = 0x%X", __func__, jniHandle);
 
-static void nfcManager_doShutdown(JNIEnv*, jobject) {
-  NfcAdaptation& theInstance = NfcAdaptation::GetInstance();
-  theInstance.DeviceShutdown();
-}
-#if(NXP_EXTNS == TRUE)
-/*******************************************************************************
- **
-** Function:        nfcManager_Enablep2p
-**
-** Description:     enable P2P
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         None.
-**
-*******************************************************************************/
-static void nfcManager_Enablep2p(JNIEnv* /* e */, jobject /* o */, jboolean p2pFlag)
-{
-    ALOGV("Enter :%s  p2pFlag = %d", __func__, p2pFlag);
-    /* if another transaction is already in progress, store this request */
-    if(!pTransactionController->transactionAttempt(TRANSACTION_REQUESTOR(enablep2p)))
-    {
-        ALOGD("Transaction in progress, Store the request");
-        set_last_request(ENABLE_P2P, NULL);
-        transaction_data.discovery_params.enable_p2p = p2pFlag;
-        return;
-    }
-    if(sRfEnabled && p2pFlag)
-    {
-        /* Stop discovery if already ON */
-        startRfDiscovery(false);
+    /* Set socket linear buffer length */
+    f = e->GetFieldID(clsNativeLlcpServiceSocket.get(),
+                      "mLocalLinearBufferLength", "I");
+    e->SetIntField(serviceSocket, f, (jint)linearBufferLength);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: buffer length = %d", __func__, linearBufferLength);
+
+    /* Set socket MIU */
+    f = e->GetFieldID(clsNativeLlcpServiceSocket.get(), "mLocalMiu", "I");
+    e->SetIntField(serviceSocket, f, (jint)miu);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: MIU = %d", __func__, miu);
+
+    /* Set socket RW */
+    f = e->GetFieldID(clsNativeLlcpServiceSocket.get(), "mLocalRw", "I");
+    e->SetIntField(serviceSocket, f, (jint)rw);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s:  RW = %d", __func__, rw);
+
+    sLastError = 0;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+    return serviceSocket;
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_doGetLastError
+  **
+  ** Description:     Get the last error code.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **
+  ** Returns:         Last error code.
+  **
+  *******************************************************************************/
+  static jint nfcManager_doGetLastError(JNIEnv*, jobject) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: last error=%i", __func__, sLastError);
+    return sLastError;
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_doDeinitialize
+  **
+  ** Description:     Turn off NFC.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  static jboolean nfcManager_doDeinitialize(JNIEnv * e, jobject obj) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+    {
+      SyncEventGuard guard (sExecPendingRegEvent);
+      sIsDisabling = true;
+      if(sIsExecPendingReq) {
+        //waiting for enableThread exit
+        sExecPendingRegEvent.wait();
+      }
     }
 
-    /* if already Polling, change to listen Mode */
-    if (sPollingEnabled)
-    {
-        if (p2pFlag && !sP2pEnabled)
-        {
-            /* enable P2P listening, if we were not already listening */
-            sP2pEnabled = true;
-            PeerToPeer::getInstance().enableP2pListening (true);
+#if (NXP_EXTNS == TRUE)
+    if (nfcFL.nfcNxpEse &&
+        (nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE || nfcFL.eseFL._ESE_SVDD_SYNC ||
+         nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION ||
+         nfcFL.nfccFL._NFCC_SPI_FW_DOWNLOAD_SYNC)) {
+      /* NFC state is put to NFC_OFF, no more request on NFC accepted(no signal
+       * events)*/
+      sNfcState = NFC_OFF;
+      NFC_ResetNfcServicePid();
+      releaseSPIEvtHandlerThread();
+    }
+
+    if (nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION &&
+        (SecureElement::getInstance().mDownloadMode == JCOP_DOWNLOAD)) {
+      if (e != NULL) {
+        unsigned long maxTimeout = 0;
+        unsigned long elapsedTimeout = 0;
+        if (NfcConfig::hasKey(NAME_OS_DOWNLOAD_TIMEOUT_VALUE)) {
+          maxTimeout = NfcConfig::getUnsigned(NAME_OS_DOWNLOAD_TIMEOUT_VALUE);
+        } else {
+          maxTimeout = MAX_JCOP_TIMEOUT_VALUE;
+          LOG(ERROR) << StringPrintf("%s: Failed to get timeout value = %ld",
+                                     __func__, maxTimeout);
+        }
+        while (SecureElement::getInstance().mDownloadMode == JCOP_DOWNLOAD) {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("%s: timeout waiting for Os Dowload", __func__);
+          usleep(MAX_WAIT_TIME_FOR_RETRY * 1000000);
+          e->CallVoidMethod(
+              gNativeData->manager,
+              android::gCachedNfcManagerNotifyJcosDownloadInProgress, true);
+          if (e->ExceptionCheck()) {
+            e->ExceptionClear();
+            DwpChannel::getInstance().forceClose();
+            LOG(ERROR) << StringPrintf("%s: fail notify", __func__);
+          }
+          elapsedTimeout += MAX_WAIT_TIME_FOR_RETRY;
+          if (elapsedTimeout * 1000 > maxTimeout) {
+            DwpChannel::getInstance().forceClose();
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+                "%s: Time elapsed force close DWP channel", __func__);
+          }
         }
+      } else {
+        DwpChannel::getInstance().forceClose();
+        LOG(ERROR) << StringPrintf(
+            "%s: Force close DWP channel as JNIEnv is null", __func__);
+      }
     }
-    /* Beam ON - Discovery ON */
-    if(p2pFlag)
-    {
-        NFA_ResumeP2p();
-        startRfDiscovery (p2pFlag);
+
+    if (isLowRamDevice()) {
+      SecureElement::getInstance().NfccStandByOperation(
+          STANDBY_ESE_PWR_RELEASE);
+    }
+
+    if (nfcFL.eseFL._JCOP_WA_ENABLE) {
+      rfActivation = false;
     }
-    pTransactionController->transactionEnd(TRANSACTION_REQUESTOR(enablep2p));
-}
 #endif
-/*******************************************************************************
-**
-** Function:        nfcManager_enableDiscovery
-**
-** Description:     Start polling and listening for devices.
-**                  e: JVM environment.
-**                  o: Java object.
-**                  technologies_mask: the bitmask of technologies for which to enable discovery
-**                  enable_lptd: whether to enable low power polling (default: false)
-**
-** Returns:         None
-**
-*******************************************************************************/
-static void nfcManager_enableDiscovery (JNIEnv* e, jobject o, jint technologies_mask,
-    jboolean enable_lptd, jboolean reader_mode, jboolean enable_p2p,
-    jboolean restart)
-{
-    tNFA_STATUS status = NFA_STATUS_OK;
-    tNFA_STATUS stat = NFA_STATUS_OK;
-    tNFA_TECHNOLOGY_MASK tech_mask = DEFAULT_TECH_MASK;
-    unsigned long num = 0;
+    doDwpChannel_ForceExit();
+    if (nfcFL.eseFL._JCOP_WA_ENABLE) {
+      NFA_HciW4eSETransaction_Complete(Wait);
+    }
+    if (nfcFL.nfcNxpEse) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("De-Initializing p61-jcop-lib library");
+      pJcopMgr->JcopDeInitialize();
+      pJcopMgr->deleteInstance();
+    }
+    pn544InteropAbortNow();
 
-    tNFA_HANDLE handle = NFA_HANDLE_INVALID;
-    struct nfc_jni_native_data *nat = NULL;
+    RoutingManager::getInstance().onNfccShutdown();
+    SecureElement::getInstance().finalize();
+    PowerSwitch::getInstance().initialize(PowerSwitch::UNKNOWN_LEVEL);
+    HciEventManager::getInstance().finalize();
+    // Stop the discovery before calling NFA_Disable.
+    if (sRfEnabled) startRfDiscovery(false);
+    tNFA_STATUS stat = NFA_STATUS_OK;
 
-#if(NXP_EXTNS == TRUE)
-    tNFA_TECHNOLOGY_MASK etsi_tech_mask = 0;
-    p61_access_state_t p61_current_state = P61_STATE_INVALID;
-    long ret_val = -1;
+    if (sIsNfaEnabled) {
+      /*
+       During device Power-Off while Nfc-On, Nfc mode will be NFC_MODE_ON
+       NFC_MODE_OFF indicates Nfc is turning off and only in this case reset the
+       venConfigValue
+       */
+      if (gGeneralPowershutDown == NFC_MODE_OFF) {
+        stat = SetVenConfigValue(NFC_MODE_OFF);
+
+        if (stat != NFA_STATUS_OK) {
+          LOG(ERROR) << StringPrintf(
+              "%s: fail enable SetVenConfigValue; error=0x%X", __func__, stat);
+        }
+      }
+      SyncEventGuard guard(sNfaDisableEvent);
+      EXTNS_Close();
+      stat = NFA_Disable(true /* graceful */);
+      if (stat == NFA_STATUS_OK) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: wait for completion", __func__);
+        sNfaDisableEvent.wait();  // wait for NFA command to finish
+        PeerToPeer::getInstance().handleNfcOnOff(false);
+      } else {
+        LOG(ERROR) << StringPrintf("%s: fail disable; error=0x%X", __func__,
+                                   stat);
+      }
+    }
+    NfcTag::getInstance().mNfcDisableinProgress = true;
+    nativeNfcTag_abortWaits();
+    NfcTag::getInstance().abort();
+    sAbortConnlessWait = true;
+    nativeLlcpConnectionlessSocket_abortWait();
+    sIsNfaEnabled = false;
+    sDiscoveryEnabled = false;
+    sIsDisabling = false;
+    sPollingEnabled = false;
+    //    sIsSecElemSelected = false;
+    sIsSecElemSelected = 0;
+    gActivated = false;
+    sP2pEnabled = false;
+#if (NXP_EXTNS == TRUE)
+    gsRouteUpdated = false;
 #endif
-    if(e == NULL && o == NULL)
+    sLfT3tMax = 0;
     {
-        nat = transaction_data.transaction_nat;
+      // unblock NFA_EnablePolling() and NFA_DisablePolling()
+      SyncEventGuard guard(sNfaEnableDisablePollingEvent);
+      sNfaEnableDisablePollingEvent.notifyOne();
     }
-    else
-    {
-        nat = getNative(e, o);
+    NfcAdaptation& theInstance = NfcAdaptation::GetInstance();
+    theInstance.Finalize();
+
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+    return JNI_TRUE;
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_doCreateLlcpSocket
+  **
+  ** Description:     Create a LLCP connection-oriented socket.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **                  nSap: Service access point.
+  **                  miu: Maximum information unit.
+  **                  rw: Receive window size.
+  **                  linearBufferLength: Max buffer size.
+  **
+  ** Returns:         NativeLlcpSocket Java object.
+  **
+  *******************************************************************************/
+  static jobject nfcManager_doCreateLlcpSocket(JNIEnv * e, jobject, jint nSap,
+                                               jint miu, jint rw,
+                                               jint linearBufferLength) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: enter; sap=%d; miu=%d; rw=%d; buffer len=%d",
+                        __func__, nSap, miu, rw, linearBufferLength);
+
+    PeerToPeer::tJNI_HANDLE jniHandle =
+        PeerToPeer::getInstance().getNewJniHandle();
+    PeerToPeer::getInstance().createClient(jniHandle, miu, rw);
+
+    /* Create new NativeLlcpSocket object */
+    jobject clientSocket = NULL;
+    if (nfc_jni_cache_object_local(e, gNativeLlcpSocketClassName,
+                                   &(clientSocket)) == -1) {
+      LOG(ERROR) << StringPrintf("%s: fail Llcp socket creation", __func__);
+      return clientSocket;
     }
-#if (NXP_EXTNS == TRUE)
-    if(!pTransactionController->transactionAttempt(TRANSACTION_REQUESTOR(enableDiscovery)))
-    {
-        ALOGV("Transaction is in progress store the request");
-        set_last_request(ENABLE_DISCOVERY, nat);
-        transaction_data.discovery_params.technologies_mask = technologies_mask;
-        transaction_data.discovery_params.enable_lptd = enable_lptd;
-        transaction_data.discovery_params.reader_mode = reader_mode;
-        transaction_data.discovery_params.enable_p2p = enable_p2p;
-        transaction_data.discovery_params.restart = restart;
-        goto TheEnd;
+
+    /* Get NativeConnectionless class object */
+    ScopedLocalRef<jclass> clsNativeLlcpSocket(e,
+                                               e->GetObjectClass(clientSocket));
+    if (e->ExceptionCheck()) {
+      e->ExceptionClear();
+      LOG(ERROR) << StringPrintf("%s: fail get class object", __func__);
+      return clientSocket;
     }
-#endif
 
-#if(NXP_EXTNS == TRUE)
-    if((nfcFL.nfcNxpEse && nfcFL.eseFL._ESE_ETSI_READER_ENABLE) &&
-            (RoutingManager::getInstance().getEtsiReaederState() == STATE_SE_RDR_MODE_STARTED)) {
-        ALOGV("%s: enter STATE_SE_RDR_MODE_START_CONFIG", __func__);
-        Rdr_req_ntf_info_t mSwp_info = RoutingManager::getInstance().getSwpRrdReqInfo();
-        {
-            SyncEventGuard guard (android::sNfaEnableDisablePollingEvent);
-            ALOGV("%s: disable polling", __func__);
-            status = NFA_DisablePolling ();
-            if (status == NFA_STATUS_OK)
-            {
-                android::sNfaEnableDisablePollingEvent.wait (); //wait for NFA_POLL_DISABLED_EVT
-            }
-            else
-            {
-                ALOGE("%s: fail disable polling; error=0x%X", __func__, status);
-            }
-        }
+    jfieldID f;
 
-        if(mSwp_info.swp_rd_req_info.tech_mask & NFA_TECHNOLOGY_MASK_A)
-            etsi_tech_mask |= NFA_TECHNOLOGY_MASK_A;
-        if(mSwp_info.swp_rd_req_info.tech_mask & NFA_TECHNOLOGY_MASK_B)
-            etsi_tech_mask |= NFA_TECHNOLOGY_MASK_B;
+    /* Set socket SAP */
+    f = e->GetFieldID(clsNativeLlcpSocket.get(), "mSap", "I");
+    e->SetIntField(clientSocket, f, (jint)nSap);
 
-        {
-            SyncEventGuard guard (android::sNfaEnableDisablePollingEvent);
-            status = NFA_EnablePolling (etsi_tech_mask);
-            if (status == NFA_STATUS_OK)
-            {
-                ALOGV("%s: wait for enable event", __func__);
-                android::sNfaEnableDisablePollingEvent.wait (); //wait for NFA_POLL_ENABLED_EVT
-            }
-            else
-            {
-                ALOGE("%s: fail enable polling; error=0x%X", __func__, status);
-            }
-        }
-        startRfDiscovery (true);
-        pTransactionController->transactionEnd(TRANSACTION_REQUESTOR(enableDiscovery));
+    /* Set socket handle */
+    f = e->GetFieldID(clsNativeLlcpSocket.get(), "mHandle", "I");
+    e->SetIntField(clientSocket, f, (jint)jniHandle);
 
-        if(!pTransactionController->transactionAttempt(TRANSACTION_REQUESTOR(etsiReader)))
-        {
-            ALOGE ("%s: transaction attempt failed", __FUNCTION__);
-        }
-        goto TheEnd;
-    }
-#endif
+    /* Set socket MIU */
+    f = e->GetFieldID(clsNativeLlcpSocket.get(), "mLocalMiu", "I");
+    e->SetIntField(clientSocket, f, (jint)miu);
 
-    if (technologies_mask == -1 && nat)
-        tech_mask = (tNFA_TECHNOLOGY_MASK)nat->tech_mask;
-    else if (technologies_mask != -1)
-        tech_mask = (tNFA_TECHNOLOGY_MASK) technologies_mask;
-    ALOGV("%s: enter; tech_mask = %02x", __func__, tech_mask);
+    /* Set socket RW */
+    f = e->GetFieldID(clsNativeLlcpSocket.get(), "mLocalRw", "I");
+    e->SetIntField(clientSocket, f, (jint)rw);
 
-    if( sDiscoveryEnabled && !restart)
-    {
-        ALOGE("%s: already discovering", __func__);
-#if(NXP_EXTNS == TRUE)
-        goto TheEnd;
-#else
-        return;
-#endif
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+    return clientSocket;
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_doCreateLlcpConnectionlessSocket
+  **
+  ** Description:     Create a connection-less socket.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **                  nSap: Service access point.
+  **                  sn: Service name.
+  **
+  ** Returns:         NativeLlcpConnectionlessSocket Java object.
+  **
+  *******************************************************************************/
+  static jobject nfcManager_doCreateLlcpConnectionlessSocket(
+      JNIEnv*, jobject, jint nSap, jstring /*sn*/) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: nSap=0x%X", __func__, nSap);
+    return NULL;
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_doGetSecureElementList
+  **
+  ** Description:     Get a list of secure element handles.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **
+  ** Returns:         List of secure element handles.
+  **
+  *******************************************************************************/
+  static jintArray nfcManager_doGetSecureElementList(JNIEnv * e, jobject) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
+    return SecureElement::getInstance().getListOfEeHandles(e);
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_doSelectSecureElement
+  **
+  ** Description:     NFC controller starts routing data in listen mode.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  static void nfcManager_doSelectSecureElement(JNIEnv * e, jobject o,
+                                               jint seId) {
+    (void)e;
+    (void)o;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+    bool stat = true;
+
+    if (sIsSecElemSelected >= sIsSecElemDetected) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: already selected", __func__);
+      goto TheEnd;
     }
 
-    ALOGV("%s: sIsSecElemSelected=%u", __func__, sIsSecElemSelected);
-    acquireRfInterfaceMutexLock();
-    PowerSwitch::getInstance ().setLevel (PowerSwitch::FULL_POWER);
+    PowerSwitch::getInstance().setLevel(PowerSwitch::FULL_POWER);
 
     if (sRfEnabled) {
-        // Stop RF discovery to reconfigure
-        startRfDiscovery(false);
+      // Stop RF Discovery if we were polling
+      startRfDiscovery(false);
     }
 
-    if ((GetNumValue(NAME_UICC_LISTEN_TECH_MASK, &num, sizeof(num))))
-    {
-        ALOGV("%s:UICC_LISTEN_MASK=0x0%lu;", __func__, num);
+    stat = SecureElement::getInstance().activate(seId);
+    if (stat) {
+      SecureElement::getInstance().routeToSecureElement();
+      sIsSecElemSelected++;
     }
 
+    startRfDiscovery(true);
+    PowerSwitch::getInstance().setModeOn(PowerSwitch::SE_ROUTING);
+  TheEnd:
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_activateSecureElement
+  **
+  ** Description:     This function shall activate the SE as per given
+  *identifier.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **                  seId: Secure element identifier
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  static void nfcManager_activateSecureElement(JNIEnv * e, jobject o,
+                                               jint seId) {
+    (void)e;
+    (void)o;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+    bool stat;
+    int maxRetryCount = 3;
 
-    // Check polling configuration
-    if (tech_mask != 0)
-    {
-        ALOGV("%s: Disable p2pListening", __func__);
-        PeerToPeer::getInstance().enableP2pListening (false);
-        stopPolling_rfDiscoveryDisabled();
-        //enableDisableLptd(enable_lptd);
-        startPolling_rfDiscoveryDisabled(tech_mask);
-
-        // Start P2P listening if tag polling was enabled
-        if (sPollingEnabled)
-        {
-            ALOGV("%s: Enable p2pListening", __func__);
-
-            if (enable_p2p && !sP2pEnabled) {
-                sP2pEnabled = true;
-                PeerToPeer::getInstance().enableP2pListening (true);
-                NFA_ResumeP2p();
-           } else if (!enable_p2p && sP2pEnabled) {
-                sP2pEnabled = false;
-                PeerToPeer::getInstance().enableP2pListening (false);
-                NFA_PauseP2p();
-            }
+    SecureElement::getInstance().deactivate(seId);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Deactivated", __func__);
+    do {
+      stat = SecureElement::getInstance().activate(seId);
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: Activate status %d", __func__, stat);
+    } while (!stat && maxRetryCount-- > 0);
+
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_doSetSEPowerOffState
+  **
+  ** Description:     NFC controller enable/disabe card emulation in power off
+  **                  state from EE.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  static void nfcManager_doSetSEPowerOffState(JNIEnv * e, jobject o, jint seId,
+                                              jboolean enable) {
+    (void)e;
+    (void)o;
+    tNFA_HANDLE ee_handle;
+    uint8_t power_state_mask = ~NFA_EE_PWR_STATE_SWITCH_OFF;
 
-            if (reader_mode && !sReaderModeEnabled)
-            {
-                sReaderModeEnabled = true;
-#if(NXP_EXTNS == TRUE)
-                NFA_SetReaderMode(true,0);
-                /*Send the state of readmode flag to Hal using proprietary command*/
-                sProprietaryCmdBuf[3]=0x01;
-                status |= NFA_SendNxpNciCommand(sizeof(sProprietaryCmdBuf),sProprietaryCmdBuf,NxpResponsePropCmd_Cb);
-                if (status == NFA_STATUS_OK)
-                {
-                    SyncEventGuard guard (sNfaNxpNtfEvent);
-                    sNfaNxpNtfEvent.wait(500); //wait for callback
-                }
-                else
-                {
-                    ALOGE("%s: Failed NFA_SendNxpNciCommand", __func__);
-                }
-                ALOGV("%s: FRM Enable", __func__);
-#endif
-                NFA_DisableListening();
-#if(NXP_EXTNS == TRUE)
-                sTechMask = tech_mask;
+    if (enable == true) {
+      power_state_mask = NFA_EE_PWR_STATE_SWITCH_OFF;
+    }
 
-                discDuration = READER_MODE_DISCOVERY_DURATION;
-#endif
-                NFA_SetRfDiscoveryDuration(READER_MODE_DISCOVERY_DURATION);
-            }
-            else if (!reader_mode && sReaderModeEnabled)
-            {
-                struct nfc_jni_native_data *nat = getNative(e, o);
-                sReaderModeEnabled = false;
-#if(NXP_EXTNS == TRUE)
-                NFA_SetReaderMode(false,0);
-                gFelicaReaderState = STATE_IDLE;
-                /*Send the state of readmode flag to Hal using proprietary command*/
-                sProprietaryCmdBuf[3]=0x00;
-                status |= NFA_SendNxpNciCommand(sizeof(sProprietaryCmdBuf),sProprietaryCmdBuf,NxpResponsePropCmd_Cb);
-                if (status == NFA_STATUS_OK)
-                {
-                    SyncEventGuard guard (sNfaNxpNtfEvent);
-                    sNfaNxpNtfEvent.wait(500); //wait for callback
-                }
-                else
-                {
-                    ALOGE("%s: Failed NFA_SendNxpNciCommand", __func__);
-                }
-                ALOGV("%s: FRM Disable", __func__);
-#endif
-                if((nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME == nfcFL.eseFL._ESE_EXCLUSIVE_WIRED_MODE) ||
-                        nfcFL.eseFL._ESE_UICC_EXCLUSIVE_WIRED_MODE) {
-                    if(!SecureElement::getInstance().mlistenDisabled){
-                        NFA_EnableListening();
-                    }
-                }
-                else {
-                    NFA_EnableListening();
-                }
-
-#if(NXP_EXTNS == TRUE)
-                discDuration = nat->discovery_duration;
-#endif
-                NFA_SetRfDiscoveryDuration(nat->discovery_duration);
-            }
-            else
-            {
-                {
-                    ALOGV("%s: restart UICC listen mode (%02lX)", __func__, (num & 0xC7));
-                    handle = SecureElement::getInstance().getEseHandleFromGenericId(SecureElement::UICC_ID);
-                    SyncEventGuard guard (SecureElement::getInstance().mUiccListenEvent);
-                    stat = NFA_CeConfigureUiccListenTech (handle, 0x00);
-                    if(stat == NFA_STATUS_OK)
-                    {
-                        SecureElement::getInstance().mUiccListenEvent.wait ();
-                    }
-                    else
-                        ALOGE("fail to stop UICC listen");
-                }
-                {
-                    SyncEventGuard guard (SecureElement::getInstance().mUiccListenEvent);
-                    stat = NFA_CeConfigureUiccListenTech (handle, (num & 0xC7));
-                    if(stat == NFA_STATUS_OK)
-                    {
-                        SecureElement::getInstance().mUiccListenEvent.wait ();
-                    }
-                    else
-                        ALOGE("fail to start UICC listen");
-                }
-            }
-        }
-        NFC_SetNfcServicePid();
-    }
-    else
-    {
-        // No technologies configured, stop polling
-        stopPolling_rfDiscoveryDisabled();
-    }
-
-    // Start P2P listening if tag polling was enabled or the mask was 0.
-    if (sDiscoveryEnabled || (tech_mask == 0))
-    {
-        handle = SecureElement::getInstance().getEseHandleFromGenericId(SecureElement::UICC_ID);
-
-#if(NXP_EXTNS == TRUE)
-        if((getScreenState() == (NFA_SCREEN_STATE_ON_LOCKED)) || sProvisionMode)
-        {
-            ALOGV("%s: Enable p2pListening", __func__);
-            PeerToPeer::getInstance().enableP2pListening (true);
-        }
-        else
-        {
-            ALOGV("%s: Disable p2pListening", __func__);
-            PeerToPeer::getInstance().enableP2pListening (false);
-        }
-#endif
-
-        {
-            SyncEventGuard guard (SecureElement::getInstance().mUiccListenEvent);
-            stat = NFA_CeConfigureUiccListenTech (handle, 0x00);
-            if(stat == NFA_STATUS_OK)
-            {
-                SecureElement::getInstance().mUiccListenEvent.wait ();
-            }
-            else
-                ALOGE("fail to start UICC listen");
-        }
+    ee_handle = SecureElement::getInstance().getEseHandleFromGenericId(seId);
 
-        {
-            SyncEventGuard guard (SecureElement::getInstance().mUiccListenEvent);
-            stat = NFA_CeConfigureUiccListenTech (handle, (num & 0xC7));
-            if(stat == NFA_STATUS_OK)
-            {
-                SecureElement::getInstance().mUiccListenEvent.wait ();
-            }
-            else
-                ALOGE("fail to start UICC listen");
-        }
+    if (sRfEnabled) {
+      // Stop RF Discovery if we were polling
+      startRfDiscovery(false);
     }
-    // Actually start discovery.
-    startRfDiscovery (true);
-    sDiscoveryEnabled = true;
 
-    PowerSwitch::getInstance ().setModeOn (PowerSwitch::DISCOVERY);
-    releaseRfInterfaceMutexLock();
+    tNFA_STATUS status = NFA_AddEePowerState(ee_handle, power_state_mask);
 
-#if (NXP_EXTNS == TRUE)
-TheEnd:
-    pTransactionController->transactionEnd(TRANSACTION_REQUESTOR(enableDiscovery));
-    /* Set this state only during initialization and in all the other cases
-    NfcState should remain at NFC_ON  except during Nfc deinit */
-    if(NFC_INITIALIZING_IN_PROGRESS == sNfcState)
-    {
-        sNfcState = NFC_ON;
-        ret_val = NFC_GetP61Status ((void *)&p61_current_state);
-        if (ret_val < 0)
-        {
-            ALOGV("NFC_GetP61Status failed");
-        }
-        if(!(p61_current_state & (P61_STATE_SPI)&&
-            !(p61_current_state & (P61_STATE_SPI_PRIO))))
-        {
-            SecureElement::getInstance().
-                setNfccPwrConfig(SecureElement::getInstance().
-                    NFCC_DECIDES);
-        }
-    }
+    // Commit the routing configuration
+    status |= NFA_EeUpdateNow();
 
-#endif
-    ALOGV("%s: exit", __func__);
-}
+    if (status != NFA_STATUS_OK)
+      LOG(ERROR) << StringPrintf("Failed to commit routing configuration");
 
+    startRfDiscovery(true);
 
-/*******************************************************************************
-**
-** Function:        nfcManager_disableDiscovery
-**
-** Description:     Stop polling and listening for devices.
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         None
-**
-*******************************************************************************/
-void nfcManager_disableDiscovery (JNIEnv* e, jobject o)
-{
+    //    TheEnd:                   /*commented to eliminate warning label
+    //    defined but not used*/
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_GetDefaultSE
+  **
+  ** Description:     Get default Secure Element.
+  **
+  **
+  ** Returns:         Returns 0.
+  **
+  *******************************************************************************/
+  static jint nfcManager_GetDefaultSE(JNIEnv * e, jobject o) {
     (void)e;
     (void)o;
-    tNFA_STATUS status = NFA_STATUS_OK;
     unsigned long num = 0;
-    unsigned long p2p_listen_mask =0;
-    tNFA_HANDLE handle = NFA_HANDLE_INVALID;
-    ALOGV("%s: enter;", __func__);
-#if (NXP_EXTNS == TRUE)
-    if(!pTransactionController->transactionAttempt(TRANSACTION_REQUESTOR(disableDiscovery)))
-    {
-        ALOGV("Transaction in progress, Store the request");
-        set_last_request(DISABLE_DISCOVERY, NULL);
-        return;
-    }
-#endif
-    pn544InteropAbortNow ();
-#if(NXP_EXTNS == TRUE)
-    if(nfcFL.nfcNxpEse && nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
-        if(RoutingManager::getInstance().getEtsiReaederState() == STATE_SE_RDR_MODE_START_IN_PROGRESS)
-        {
-            Rdr_req_ntf_info_t mSwp_info = RoutingManager::getInstance().getSwpRrdReqInfo();
-            //        if(android::isDiscoveryStarted() == true)
-            android::startRfDiscovery(false);
-            PeerToPeer::getInstance().enableP2pListening (false);
-            {
-                SyncEventGuard guard ( SecureElement::getInstance().mUiccListenEvent);
-                status = NFA_CeConfigureUiccListenTech (mSwp_info.swp_rd_req_info.src, 0x00);
-                if (status == NFA_STATUS_OK)
-                {
-                    SecureElement::getInstance().mUiccListenEvent.wait ();
-                }
-                else
-                {
-                    ALOGE("fail to stop listen");
-                }
-            }
-            goto TheEnd;
-        }
-        else if(RoutingManager::getInstance().getEtsiReaederState() == STATE_SE_RDR_MODE_STOP_IN_PROGRESS)
-        {
-            android::startRfDiscovery(false);
-            goto TheEnd;
-        }
+    if (NfcConfig::hasKey(NAME_NXP_DEFAULT_SE)) {
+      num = NfcConfig::getUnsigned(NAME_NXP_DEFAULT_SE);
     }
-#endif
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%lu: nfcManager_GetDefaultSE", num);
+    return num;
+  }
 
-    if (sDiscoveryEnabled == false)
-    {
-        ALOGV("%s: already disabled", __func__);
-        goto TheEnd;
-    }
-    acquireRfInterfaceMutexLock();
-    // Stop RF Discovery.
-    startRfDiscovery (false);
+  static jint nfcManager_getSecureElementTechList(JNIEnv * e, jobject o) {
+    (void)e;
+    (void)o;
+    uint8_t sak;
+    jint tech = 0x00;
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("nfcManager_getSecureElementTechList -Enter");
+    sak = HciRFParams::getInstance().getESeSak();
+    bool isTypeBPresent = HciRFParams::getInstance().isTypeBSupported();
 
-    if (sPollingEnabled)
-        status = stopPolling_rfDiscoveryDisabled();
-    sDiscoveryEnabled = false;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "nfcManager_getSecureElementTechList - sak is %0x", sak);
 
-    if ((GetNumValue(NAME_UICC_LISTEN_TECH_MASK, &num, sizeof(num))))
-    {
-        ALOGV("%s:UICC_LISTEN_MASK=0x0%lu;", __func__, num);
-    }
-    if ((GetNumValue("P2P_LISTEN_TECH_MASK", &p2p_listen_mask, sizeof(p2p_listen_mask))))
-    {
-        ALOGV("%s:P2P_LISTEN_MASK=0x0%lu;", __func__, p2p_listen_mask);
+    if (sak & 0x08) {
+      tech |= TARGET_TYPE_MIFARE_CLASSIC;
     }
 
-    PeerToPeer::getInstance().enableP2pListening (false);
-    NFA_PauseP2p();
-
-    if (sIsSecElemSelected)
-    {
-        handle = SecureElement::getInstance().getEseHandleFromGenericId(SecureElement::UICC_ID);
-        {
-            SyncEventGuard guard (SecureElement::getInstance().mUiccListenEvent);
-            status = NFA_CeConfigureUiccListenTech (handle, 0x00);
-            if (status == NFA_STATUS_OK)
-            {
-                SecureElement::getInstance().mUiccListenEvent.wait ();
-            }
-            else
-                ALOGE("fail to start UICC listen");
-        }
-
-        {
-            SyncEventGuard guard (SecureElement::getInstance().mUiccListenEvent);
-            status = NFA_CeConfigureUiccListenTech (handle, (num & 0x07));
-            if(status == NFA_STATUS_OK)
-            {
-                SecureElement::getInstance().mUiccListenEvent.wait ();
-            }
-            else
-                ALOGE("fail to start UICC listen");
-        }
-
-        PeerToPeer::getInstance().enableP2pListening (false);
-        startRfDiscovery (true);
+    if (sak & 0x20) {
+      tech |= NFA_TECHNOLOGY_MASK_A;
     }
 
-    sP2pEnabled = false;
-    //if nothing is active after this, then tell the controller to power down
-    //if (! PowerSwitch::getInstance ().setModeOff (PowerSwitch::DISCOVERY))
-        //PowerSwitch::getInstance ().setLevel (PowerSwitch::LOW_POWER);
-
-    // We may have had RF field notifications that did not cause
-    // any activate/deactive events. For example, caused by wireless
-    // charging orbs. Those may cause us to go to sleep while the last
-    // field event was indicating a field. To prevent sticking in that
-    // state, always reset the rf field status when we disable discovery.
-    SecureElement::getInstance().resetRfFieldStatus();
-    releaseRfInterfaceMutexLock();
-TheEnd:
-#if (NXP_EXTNS == TRUE)
-    pTransactionController->transactionEnd(TRANSACTION_REQUESTOR(disableDiscovery));
-#endif
-    ALOGV("%s: exit", __func__);
-}
-
-void enableDisableLongGuardTime (bool enable)
-{
-    // TODO
-    // This is basically a work-around for an issue
-    // in BCM20791B5: if a reader is configured as follows
-    // 1) Only polls for NFC-A
-    // 2) Cuts field between polls
-    // 3) Has a short guard time (~5ms)
-    // the BCM20791B5 doesn't wake up when such a reader
-    // is polling it. Unfortunately the default reader
-    // mode configuration on Android matches those
-    // criteria. To avoid the issue, increase the guard
-    // time when in reader mode.
-    //
-    // Proper fix is firmware patch for B5 controllers.
-    SyncEventGuard guard(sNfaSetConfigEvent);
-    tNFA_STATUS stat = NFA_SetConfig(NCI_PARAM_ID_T1T_RDR_ONLY, 2,
-            enable ? sLongGuardTime : sDefaultGuardTime);
-    if (stat == NFA_STATUS_OK)
-        sNfaSetConfigEvent.wait ();
-    else
-        ALOGE("%s: Could not configure longer guard time", __func__);
-    return;
-}
-
-void enableDisableLptd (bool enable)
-{
-    // This method is *NOT* thread-safe. Right now
-    // it is only called from the same thread so it's
-    // not an issue.
-    static bool sCheckedLptd = false;
-    static bool sHasLptd = false;
-
-    tNFA_STATUS stat = NFA_STATUS_OK;
-    if (!sCheckedLptd)
-    {
-        sCheckedLptd = true;
-        SyncEventGuard guard (sNfaGetConfigEvent);
-        tNFA_PMID configParam[1] = {NCI_PARAM_ID_TAGSNIFF_CFG};
-        stat = NFA_GetConfig(1, configParam);
-        if (stat != NFA_STATUS_OK)
-        {
-            ALOGE("%s: NFA_GetConfig failed", __func__);
-            return;
-        }
-        sNfaGetConfigEvent.wait ();
-        if (sCurrentConfigLen < 4 || sConfig[1] != NCI_PARAM_ID_TAGSNIFF_CFG) {
-            ALOGE("%s: Config TLV length %d returned is too short", __func__,
-                    sCurrentConfigLen);
-            return;
-        }
-        if (sConfig[3] == 0) {
-            ALOGE("%s: LPTD is disabled, not enabling in current config", __func__);
-            return;
-        }
-        sHasLptd = true;
+    if (isTypeBPresent == true) {
+      tech |= NFA_TECHNOLOGY_MASK_B;
     }
-    // Bail if we checked and didn't find any LPTD config before
-    if (!sHasLptd) return;
-    uint8_t enable_byte = enable ? 0x01 : 0x00;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "nfcManager_getSecureElementTechList - tech is %0x", tech);
+    return tech;
+  }
 
-    SyncEventGuard guard(sNfaSetConfigEvent);
+  static jintArray nfcManager_getActiveSecureElementList(JNIEnv * e,
+                                                         jobject o) {
+    (void)e;
+    (void)o;
+    return SecureElement::getInstance().getActiveSecureElementList(e);
+  }
 
-    stat = NFA_SetConfig(NCI_PARAM_ID_TAGSNIFF_CFG, 1, &enable_byte);
-    if (stat == NFA_STATUS_OK)
-        sNfaSetConfigEvent.wait ();
-    else
-        ALOGE("%s: Could not configure LPTD feature", __func__);
-    return;
-}
+  static void nfcManager_setSecureElementListenTechMask(JNIEnv * e, jobject o,
+                                                        jint tech_mask) {
+    (void)e;
+    (void)o;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: ENTER", __func__);
+    //    tNFA_STATUS status;                   /*commented to eliminate unused
+    //    variable warning*/
 
-void setUiccIdleTimeout (bool enable)
-{
-    // This method is *NOT* thread-safe. Right now
-    // it is only called from the same thread so it's
-    // not an issue.
-    tNFA_STATUS stat = NFA_STATUS_OK;
-    uint8_t swp_cfg_byte0 = 0x00;
-    {
-        SyncEventGuard guard (sNfaGetConfigEvent);
-        tNFA_PMID configParam[1] = {0xC2};
-        stat = NFA_GetConfig(1, configParam);
-        if (stat != NFA_STATUS_OK)
-        {
-            ALOGE("%s: NFA_GetConfig failed", __func__);
-            return;
-        }
-        sNfaGetConfigEvent.wait ();
-        if (sCurrentConfigLen < 4 || sConfig[1] != 0xC2) {
-            ALOGE("%s: Config TLV length %d returned is too short", __func__,
-                    sCurrentConfigLen);
-            return;
-        }
-        swp_cfg_byte0 = sConfig[3];
+    if (sRfEnabled) {
+      // Stop RF Discovery if we were polling
+      startRfDiscovery(false);
     }
-    SyncEventGuard guard(sNfaSetConfigEvent);
-    if (enable)
-        swp_cfg_byte0 |= 0x01;
-    else
-        swp_cfg_byte0 &= ~0x01;
+    SecureElement::getInstance().setEseListenTechMask(tech_mask);
 
-    stat = NFA_SetConfig(0xC2, 1, &swp_cfg_byte0);
-    if (stat == NFA_STATUS_OK)
-        sNfaSetConfigEvent.wait ();
-    else
-        ALOGE("%s: Could not configure UICC idle timeout feature", __func__);
-    return;
-}
+    startRfDiscovery(true);
 
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: EXIT", __func__);
+  }
 
-/*******************************************************************************
-**
-** Function:        nfcManager_doCreateLlcpServiceSocket
-**
-** Description:     Create a new LLCP server socket.
-**                  e: JVM environment.
-**                  o: Java object.
-**                  nSap: Service access point.
-**                  sn: Service name
-**                  miu: Maximum information unit.
-**                  rw: Receive window size.
-**                  linearBufferLength: Max buffer size.
-**
-** Returns:         NativeLlcpServiceSocket Java object.
-**
-*******************************************************************************/
-static jobject nfcManager_doCreateLlcpServiceSocket (JNIEnv* e, jobject, jint nSap, jstring sn, jint miu, jint rw, jint linearBufferLength)
-{
-    PeerToPeer::tJNI_HANDLE jniHandle = PeerToPeer::getInstance().getNewJniHandle ();
+  static jbyteArray nfcManager_getSecureElementUid(JNIEnv * e, jobject /* o */) {
+    jbyteArray jbuff = NULL;
+    uint8_t bufflen = 0;
+    uint8_t buf[16] = {
+        0,
+    };
 
-    ScopedUtfChars serviceName(e, sn);
-    if (serviceName.c_str() == NULL)
-    {
-        ALOGE("%s: service name can not be null error", __func__);
-        return NULL;
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("nfcManager_getSecureElementUid -Enter");
+    HciRFParams::getInstance().getESeUid(&buf[0], &bufflen);
+    if (bufflen > 0) {
+      jbuff = e->NewByteArray(bufflen);
+      e->SetByteArrayRegion(jbuff, 0, bufflen, (jbyte*)buf);
     }
+    return jbuff;
+  }
 
-    ALOGV("%s: enter: sap=%i; name=%s; miu=%i; rw=%i; buffLen=%i", __func__, nSap, serviceName.c_str(), miu, rw, linearBufferLength);
+  static tNFA_STATUS nfcManager_setEmvCoPollProfile(
+      JNIEnv * /* e */, jobject /* o */, jboolean enable, jint route) {
+    tNFA_STATUS status = NFA_STATUS_FAILED;
+    tNFA_TECHNOLOGY_MASK tech_mask = 0;
 
-    /* Create new NativeLlcpServiceSocket object */
-    jobject serviceSocket = NULL;
-    if (nfc_jni_cache_object_local(e, gNativeLlcpServiceSocketClassName, &(serviceSocket)) == -1)
-    {
-        ALOGE("%s: Llcp socket object creation error", __func__);
-        return NULL;
+    LOG(ERROR) << StringPrintf(
+        "In nfcManager_setEmvCoPollProfile enable = 0x%x route = 0x%x", enable,
+        route);
+    /* Stop polling */
+    if (isDiscoveryStarted()) {
+      // Stop RF discovery to reconfigure
+      startRfDiscovery(false);
     }
 
-    /* Get NativeLlcpServiceSocket class object */
-    ScopedLocalRef<jclass> clsNativeLlcpServiceSocket(e, e->GetObjectClass(serviceSocket));
-    if (e->ExceptionCheck())
-    {
-        e->ExceptionClear();
-        ALOGE("%s: Llcp Socket get object class error", __func__);
-        return NULL;
+    status = EmvCo_dosetPoll(enable);
+    if (status != NFA_STATUS_OK) {
+      LOG(ERROR) << StringPrintf("%s: fail enable polling; error=0x%X",
+                                 __func__, status);
+      goto TheEnd;
+    }
+
+    if (enable) {
+      if (route == 0x00) {
+        /* DH enable polling for A and B*/
+        tech_mask = NFA_TECHNOLOGY_MASK_A | NFA_TECHNOLOGY_MASK_B;
+      } else if (route == 0x01) {
+        /* UICC is end-point at present not supported by FW */
+        /* TBD : Get eeinfo (use handle appropirately, depending up
+         * on it enable the polling */
+      } else if (route == 0x02) {
+        /* ESE is end-point at present not supported by FW */
+        /* TBD : Get eeinfo (use handle appropirately, depending up
+         * on it enable the polling */
+      } else {
+      }
+    } else {
+      if (NfcConfig::hasKey(NAME_POLLING_TECH_MASK)) {
+        tech_mask = NfcConfig::getUnsigned(NAME_POLLING_TECH_MASK);
+      }
     }
 
-    if (!PeerToPeer::getInstance().registerServer (jniHandle, serviceName.c_str()))
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: enable polling", __func__);
     {
-        ALOGE("%s: RegisterServer error", __func__);
-        return NULL;
+      SyncEventGuard guard(sNfaEnableDisablePollingEvent);
+      status = NFA_EnablePolling(tech_mask);
+      if (status == NFA_STATUS_OK) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: wait for enable event", __func__);
+        sNfaEnableDisablePollingEvent.wait();  // wait for NFA_POLL_ENABLED_EVT
+      } else {
+        LOG(ERROR) << StringPrintf("%s: fail enable polling; error=0x%X",
+                                   __func__, status);
+      }
     }
 
-    jfieldID f;
-
-    /* Set socket handle to be the same as the NfaHandle*/
-    f = e->GetFieldID(clsNativeLlcpServiceSocket.get(), "mHandle", "I");
-    e->SetIntField(serviceSocket, f, (jint) jniHandle);
-    ALOGV("%s: socket Handle = 0x%X", __func__, jniHandle);
-
-    /* Set socket linear buffer length */
-    f = e->GetFieldID(clsNativeLlcpServiceSocket.get(), "mLocalLinearBufferLength", "I");
-    e->SetIntField(serviceSocket, f,(jint)linearBufferLength);
-    ALOGV("%s: buffer length = %d", __func__, linearBufferLength);
-
-    /* Set socket MIU */
-    f = e->GetFieldID(clsNativeLlcpServiceSocket.get(), "mLocalMiu", "I");
-    e->SetIntField(serviceSocket, f,(jint)miu);
-    ALOGV("%s: MIU = %d", __func__, miu);
+  TheEnd:
+    /* start polling */
+    if (!isDiscoveryStarted()) {
+      // Start RF discovery to reconfigure
+      startRfDiscovery(true);
+    }
+    return status;
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_doDeselectSecureElement
+  **
+  ** Description:     NFC controller stops routing data in listen mode.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  static void nfcManager_doDeselectSecureElement(JNIEnv * e, jobject o,
+                                                 jint seId) {
+    (void)e;
+    (void)o;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+    bool stat = false;
+    bool bRestartDiscovery = false;
 
-    /* Set socket RW */
-    f = e->GetFieldID(clsNativeLlcpServiceSocket.get(), "mLocalRw", "I");
-    e->SetIntField(serviceSocket, f,(jint)rw);
-    ALOGV("%s:  RW = %d", __func__, rw);
+    if (!sIsSecElemSelected) {
+      LOG(ERROR) << StringPrintf("%s: already deselected", __func__);
+      goto TheEnd2;
+    }
 
-    sLastError = 0;
-    ALOGV("%s: exit", __func__);
-    return serviceSocket;
-}
+    if (PowerSwitch::getInstance().getLevel() == PowerSwitch::LOW_POWER) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: do not deselect while power is OFF", __func__);
+      //        sIsSecElemSelected = false;
+      sIsSecElemSelected--;
+      goto TheEnd;
+    }
 
+    if (sRfEnabled) {
+      // Stop RF Discovery if we were polling
+      startRfDiscovery(false);
+      bRestartDiscovery = true;
+    }
+    // sIsSecElemSelected = false;
+    // sIsSecElemSelected--;
+
+    // if controller is not routing to sec elems AND there is no pipe connected,
+    // then turn off the sec elems
+    if (SecureElement::getInstance().isBusy() == false) {
+      // SecureElement::getInstance().deactivate (0xABCDEF);
+      stat = SecureElement::getInstance().deactivate(seId);
+      if (stat) {
+        sIsSecElemSelected--;
+        //            RoutingManager::getInstance().commitRouting();
+      }
+    }
 
-/*******************************************************************************
-**
-** Function:        nfcManager_doGetLastError
-**
-** Description:     Get the last error code.
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         Last error code.
-**
-*******************************************************************************/
-static jint nfcManager_doGetLastError(JNIEnv*, jobject)
-{
-    ALOGV("%s: last error=%i", __func__, sLastError);
-    return sLastError;
-}
-
-
-/*******************************************************************************
-**
-** Function:        nfcManager_doDeinitialize
-**
-** Description:     Turn off NFC.
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         True if ok.
-**
-*******************************************************************************/
-static jboolean nfcManager_doDeinitialize (JNIEnv* e, jobject obj)
-{
-    ALOGV("%s: enter", __func__);
-    sIsDisabling = true;
-
+  TheEnd:
+    /*
+     * conditional check is added to avoid multiple dicovery cmds
+     * at the time of NFC OFF in progress
+     */
+    if ((gGeneralPowershutDown != NFC_MODE_OFF) && bRestartDiscovery)
+      startRfDiscovery(true);
+
+    // if nothing is active after this, then tell the controller to power down
+    if (!PowerSwitch::getInstance().setModeOff(PowerSwitch::SE_ROUTING))
+      PowerSwitch::getInstance().setLevel(PowerSwitch::LOW_POWER);
+
+  TheEnd2:
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_getDefaultAidRoute
+  **
+  ** Description:     Get the default Aid Route Entry.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **                  mode: Not used.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  static jint nfcManager_getDefaultAidRoute(JNIEnv * /* e */, jobject /* o */) {
+    unsigned long num = 0;
 #if (NXP_EXTNS == TRUE)
-    if(nfcFL.nfcNxpEse && (nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE ||
-            nfcFL.eseFL._ESE_SVDD_SYNC || nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION ||
-            nfcFL.nfccFL._NFCC_SPI_FW_DOWNLOAD_SYNC)) {
-        /* NFC state is put to NFC_OFF, no more request on NFC accepted(no signal events)*/
-        sNfcState = NFC_OFF;
-        NFC_ResetNfcServicePid();
-        releaseSPIEvtHandlerThread();
-    }
-
-    if(nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION &&
-            (SecureElement::getInstance().mDownloadMode == JCOP_DOWNLOAD))
-    {
-        if (e != NULL)
-        {
-            unsigned long maxTimeout = 0;
-            unsigned long elapsedTimeout = 0;
-            if(!GetNxpNumValue(NAME_OS_DOWNLOAD_TIMEOUT_VALUE, &maxTimeout,
-                    sizeof(maxTimeout)))
-            {
-                maxTimeout = MAX_JCOP_TIMEOUT_VALUE;
-                ALOGE("%s: Failed to get timeout value = %ld",
-                        __func__, maxTimeout);
-            }
-            while(SecureElement::getInstance().mDownloadMode ==
-                    JCOP_DOWNLOAD) {
-                ALOGV("%s: timeout waiting for Os Dowload",
-                        __func__);
-                usleep(MAX_WAIT_TIME_FOR_RETRY*1000000);
-                e->CallVoidMethod (gNativeData->manager,
-                        android::gCachedNfcManagerNotifyJcosDownloadInProgress,
-                        true);
-                if (e->ExceptionCheck())
-                {
-                    e->ExceptionClear();
-                    DwpChannel::getInstance().forceClose();
-                    ALOGE("%s: fail notify", __func__);
-                }
-                elapsedTimeout += MAX_WAIT_TIME_FOR_RETRY;
-                if(elapsedTimeout*1000 > maxTimeout)
-                {
-                    DwpChannel::getInstance().forceClose();
-                    ALOGV("%s: Time elapsed force close DWP channel",
-                            __func__);
-                }
-            }
-        }
-        else
-        {
-            DwpChannel::getInstance().forceClose();
-            ALOGE("%s: Force close DWP channel as JNIEnv is null",
-                    __func__);
-        }
+    if (NfcConfig::hasKey(NAME_DEFAULT_AID_ROUTE)) {
+      num = NfcConfig::getUnsigned(NAME_DEFAULT_AID_ROUTE);
     }
-
-if(nfcFL.eseFL._JCOP_WA_ENABLE) {
-    rfActivation = false;
-}
 #endif
-    doDwpChannel_ForceExit();
-    if(nfcFL.eseFL._JCOP_WA_ENABLE) {
-        NFA_HciW4eSETransaction_Complete(Wait);
+    return num;
+  }
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_getDefaultDesfireRoute
+  **
+  ** Description:     Get the default Desfire Route Entry.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **                  mode: Not used.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  static jint nfcManager_getDefaultDesfireRoute(JNIEnv * /* e */, jobject /* o */) {
+    unsigned long num = 0;
+#if (NXP_EXTNS == TRUE)
+    if (NfcConfig::hasKey(NAME_DEFAULT_ROUTE))
+      num = NfcConfig::getUnsigned(NAME_DEFAULT_ROUTE);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: enter; NAME_DEFAULT_ROUTE = %02lx", __func__, num);
+#endif
+    return num;
+  }
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_getDefaultMifareCLTRoute
+  **
+  ** Description:     Get the default mifare CLT Route Entry.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **                  mode: Not used.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  static jint nfcManager_getDefaultMifareCLTRoute(JNIEnv * /* e */, jobject /* o */) {
+    unsigned long num = 0;
+#if (NXP_EXTNS == TRUE)
+    if (NfcConfig::hasKey(NAME_DEFAULT_OFFHOST_ROUTE))
+      num = NfcConfig::getUnsigned(NAME_DEFAULT_OFFHOST_ROUTE);
+#endif
+    return num;
+  }
+#if (NXP_EXTNS == TRUE)
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_getDefaultAidPowerState
+  **
+  ** Description:     Get the default Desfire Power States.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **
+  ** Returns:         Power State
+  **
+  *******************************************************************************/
+  static jint nfcManager_getDefaultAidPowerState(JNIEnv * /* e */, jobject /* o */) {
+    unsigned long num = 0;
+    if (NfcConfig::hasKey(NAME_DEFAULT_AID_PWR_STATE)) {
+      num = NfcConfig::getUnsigned(NAME_DEFAULT_AID_PWR_STATE);
+    }
+    return num;
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_getDefaultDesfirePowerState
+  **
+  ** Description:     Get the default Desfire Power States.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **
+  ** Returns:         Power State
+  **
+  *******************************************************************************/
+  static jint nfcManager_getDefaultDesfirePowerState(JNIEnv * /* e */, jobject /* o */) {
+    unsigned long num = 0;
+    if (NfcConfig::hasKey(NAME_DEFAULT_ROUTE_PWR_STATE)) {
+      num = NfcConfig::getUnsigned(NAME_DEFAULT_ROUTE_PWR_STATE);
     }
-    pn544InteropAbortNow ();
+    return num;
+  }
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_getDefaultMifareCLTPowerState
+  **
+  ** Description:     Get the default mifare CLT Power States.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **
+  ** Returns:         Power State
+  **
+  *******************************************************************************/
+  static jint nfcManager_getDefaultMifareCLTPowerState(JNIEnv * /* e */, jobject /* o */) {
+    unsigned long num = 0;
+    if (NfcConfig::hasKey(NAME_DEFAULT_OFFHOST_PWR_STATE)) {
+      num = NfcConfig::getUnsigned(NAME_DEFAULT_OFFHOST_PWR_STATE);
+    }
+    return num;
+  }
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_setDefaultTechRoute
+  **
+  ** Description:     Setting Default Technology Routing
+  **                  e:  JVM environment.
+  **                  o:  Java object.
+  **                  seId:  SecureElement Id
+  **                  tech_swithon:  technology switch_on
+  **                  tech_switchoff:  technology switch_off
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  static void nfcManager_setDefaultTechRoute(JNIEnv * e, jobject o, jint seId,
+                                             jint tech_switchon,
+                                             jint tech_switchoff) {
+    (void)e;
+    (void)o;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: ENTER", __func__);
+    //    tNFA_STATUS status;                   /*commented to eliminate unused
+    //    variable warning*/
 
-    RoutingManager::getInstance().onNfccShutdown();
-    SecureElement::getInstance().finalize ();
-    PowerSwitch::getInstance ().initialize (PowerSwitch::UNKNOWN_LEVEL);
-    //Stop the discovery before calling NFA_Disable.
-    if(sRfEnabled)
-        startRfDiscovery(false);
-    tNFA_STATUS stat = NFA_STATUS_OK;
+    if (sRfEnabled) {
+      // Stop RF Discovery if we were polling
+      startRfDiscovery(false);
+    }
+    RoutingManager::getInstance().setDefaultTechRouting(seId, tech_switchon,
+                                                        tech_switchoff);
+    // start discovery.
+    startRfDiscovery(true);
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_setDefaultProtoRoute
+  **
+  ** Description:     Setting Default Protocol Routing
+  **
+  **                  e:  JVM environment.
+  **                  o:  Java object.
+  **                  seId:  SecureElement Id
+  **                  proto_swithon:  Protocol switch_on
+  **                  proto_switchoff:  Protocol switch_off
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  static void nfcManager_setDefaultProtoRoute(JNIEnv * e, jobject o, jint seId,
+                                              jint proto_switchon,
+                                              jint proto_switchoff) {
+    (void)e;
+    (void)o;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: ENTER", __func__);
+    //    tNFA_STATUS status;                   /*commented to eliminate unused
+    //    variable warning*/
+    //    if (sRfEnabled) {
+    //        // Stop RF Discovery if we were polling
+    //        startRfDiscovery (false);
+    //    }
+    RoutingManager::getInstance().setDefaultProtoRouting(seId, proto_switchon,
+                                                         proto_switchoff);
+    // start discovery.
+    //    startRfDiscovery (true);
+  }
+
+  /*******************************************************************************
+   **
+   ** Function:        nfcManager_setPreferredSimSlot()
+   **
+   ** Description:     This api is used to select a particular UICC slot.
+   **
+   **
+   ** Returns:         success/failure
+   **
+   *******************************************************************************/
+  static int nfcManager_setPreferredSimSlot(JNIEnv * e, jobject o,
+                                            jint uiccSlot) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s : uiccslot : %d : enter", __func__, uiccSlot);
 
-    if (sIsNfaEnabled)
-    {
-        /*
-         During device Power-Off while Nfc-On, Nfc mode will be NFC_MODE_ON
-         NFC_MODE_OFF indicates Nfc is turning off and only in this case reset the venConfigValue
-         */
-        if(gGeneralPowershutDown == NFC_MODE_OFF)
-        {
-            stat = SetVenConfigValue(NFC_MODE_OFF);
+    tNFA_STATUS status = NFA_STATUS_OK;
+    if (nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) {
+      sCurrentSelectedUICCSlot = uiccSlot;
+      NFA_SetPreferredUiccId(
+          (uiccSlot == 2) ? (SecureElement::getInstance().EE_HANDLE_0xF8 &
+                             ~NFA_HANDLE_GROUP_EE)
+                          : (SecureElement::getInstance().EE_HANDLE_0xF4 &
+                             ~NFA_HANDLE_GROUP_EE));
+    }
+    return status;
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_isVzwFeatureEnabled
+  **
+  ** Description:     Check vzw feature is enabled or not
+  **
+  ** Returns:         True if the VZW_FEATURE_ENABLE is set.
+  **
+  *******************************************************************************/
+  static bool nfcManager_isVzwFeatureEnabled(JNIEnv * /* e */, jobject /* o */) {
+    unsigned int num = 0;
+    bool mStat = false;
 
-            if (stat != NFA_STATUS_OK)
-            {
-                ALOGE("%s: fail enable SetVenConfigValue; error=0x%X", __func__, stat);
-            }
-        }
-        SyncEventGuard guard (sNfaDisableEvent);
-        EXTNS_Close ();
-        stat = NFA_Disable (true /* graceful */);
-        if (stat == NFA_STATUS_OK)
-        {
-            ALOGV("%s: wait for completion", __func__);
-            sNfaDisableEvent.wait (); //wait for NFA command to finish
-            PeerToPeer::getInstance ().handleNfcOnOff (false);
-        }
-        else
-        {
-            ALOGE("%s: fail disable; error=0x%X", __func__, stat);
-        }
+    if (NfcConfig::hasKey("VZW_FEATURE_ENABLE")) {
+      mStat = NfcConfig::getUnsigned("VZW_FEATURE_ENABLE");
+      if (num == 0x01) {
+        mStat = true;
+      } else {
+        mStat = false;
+      }
+    } else {
+      mStat = false;
     }
-    NfcTag::getInstance ().mNfcDisableinProgress = true;
-    nativeNfcTag_abortWaits();
-    NfcTag::getInstance().abort ();
-    sAbortConnlessWait = true;
-    nativeLlcpConnectionlessSocket_abortWait();
-    sIsNfaEnabled = false;
-    sDiscoveryEnabled = false;
-    sIsDisabling = false;
-    sPollingEnabled = false;
-//    sIsSecElemSelected = false;
-    sIsSecElemSelected = 0;
-    gActivated = false;
-    sP2pEnabled = false;
-#if(NXP_EXTNS == TRUE)
-    gsRouteUpdated = false;
+    return mStat;
+  }
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_isNfccBusy
+  **
+  ** Description:     Check If NFCC is busy
+  **
+  ** Returns:         True if NFCC is busy.
+  **
+  *******************************************************************************/
+  static bool nfcManager_isNfccBusy(JNIEnv*, jobject) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: ENTER", __func__);
+    bool statBusy = false;
+    if (SecureElement::getInstance().isBusy()) {
+      LOG(ERROR) << StringPrintf("%s:FAIL  SE wired-mode : busy", __func__);
+      statBusy = true;
+    } else if (rfActivation) {
+      LOG(ERROR) << StringPrintf("%s:FAIL  RF session ongoing", __func__);
+      statBusy = true;
+    } else if (transaction_data.trans_in_progress) {
+      LOG(ERROR) << StringPrintf("%s: FAIL Transaction in progress", __func__);
+      statBusy = true;
+    }
+
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Exit statBusy : 0x%02x", __func__, statBusy);
+    return statBusy;
+  }
 #endif
-    sLfT3tMax = 0;
-    {
-        //unblock NFA_EnablePolling() and NFA_DisablePolling()
-        SyncEventGuard guard (sNfaEnableDisablePollingEvent);
-        sNfaEnableDisablePollingEvent.notifyOne ();
-    }
-    NfcAdaptation& theInstance = NfcAdaptation::GetInstance();
-    theInstance.Finalize();
+  /*******************************************************************************
+  **
+  ** Function:        isPeerToPeer
+  **
+  ** Description:     Whether the activation data indicates the peer supports
+  *NFC-DEP.
+  **                  activated: Activation data.
+  **
+  ** Returns:         True if the peer supports NFC-DEP.
+  **
+  *******************************************************************************/
+  static bool isPeerToPeer(tNFA_ACTIVATED & activated) {
+    return activated.activate_ntf.protocol == NFA_PROTOCOL_NFC_DEP;
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        isListenMode
+  **
+  ** Description:     Indicates whether the activation data indicates it is
+  **                  listen mode.
+  **
+  ** Returns:         True if this listen mode.
+  **
+  *******************************************************************************/
+  static bool isListenMode(tNFA_ACTIVATED & activated) {
+    return (
+        (NFC_DISCOVERY_TYPE_LISTEN_A ==
+         activated.activate_ntf.rf_tech_param.mode) ||
+        (NFC_DISCOVERY_TYPE_LISTEN_B ==
+         activated.activate_ntf.rf_tech_param.mode) ||
+        (NFC_DISCOVERY_TYPE_LISTEN_F ==
+         activated.activate_ntf.rf_tech_param.mode) ||
+        (NFC_DISCOVERY_TYPE_LISTEN_A_ACTIVE ==
+         activated.activate_ntf.rf_tech_param.mode) ||
+        (NFC_DISCOVERY_TYPE_LISTEN_F_ACTIVE ==
+         activated.activate_ntf.rf_tech_param.mode) ||
+        (NFC_DISCOVERY_TYPE_LISTEN_ISO15693 ==
+         activated.activate_ntf.rf_tech_param.mode) ||
+        (NFC_DISCOVERY_TYPE_LISTEN_B_PRIME ==
+         activated.activate_ntf.rf_tech_param.mode) ||
+        (NFC_INTERFACE_EE_DIRECT_RF == activated.activate_ntf.intf_param.type));
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_doCheckLlcp
+  **
+  ** Description:     Not used.
+  **
+  ** Returns:         True
+  **
+  *******************************************************************************/
+  static jboolean nfcManager_doCheckLlcp(JNIEnv*, jobject) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
+    return JNI_TRUE;
+  }
 
-    ALOGV("%s: exit", __func__);
+  static jboolean nfcManager_doCheckJcopDlAtBoot(JNIEnv * /* e */, jobject /* o */) {
+    unsigned int num = 0;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
+    if (NfcConfig::hasKey(NAME_NXP_JCOPDL_AT_BOOT_ENABLE)) {
+      num = NfcConfig::getUnsigned(NAME_NXP_JCOPDL_AT_BOOT_ENABLE);
+      if (num == 0x01) {
+        return JNI_TRUE;
+      } else {
+        return JNI_FALSE;
+      }
+    } else {
+      return JNI_FALSE;
+    }
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_doActivateLlcp
+  **
+  ** Description:     Not used.
+  **
+  ** Returns:         True
+  **
+  *******************************************************************************/
+  static jboolean nfcManager_doActivateLlcp(JNIEnv*, jobject) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
     return JNI_TRUE;
-}
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_doAbort
+  **
+  ** Description:     Not used.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  static void nfcManager_doAbort(JNIEnv * e, jobject, jstring msg) {
+    ScopedUtfChars message = {e, msg};
+    e->FatalError(message.c_str());
+    abort();  // <-- Unreachable
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_doDownload
+  **
+  ** Description:     Download firmware patch files.  Do not turn on NFC.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  static jboolean nfcManager_doDownload(JNIEnv*, jobject) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+    NfcAdaptation& theInstance = NfcAdaptation::GetInstance();
 
+    theInstance.Initialize();  // start GKI, NCI task, NFC task
+    theInstance.DownloadFirmware();
+    theInstance.Finalize();
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+    return JNI_TRUE;
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_doResetTimeouts
+  **
+  ** Description:     Not used.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  static void nfcManager_doResetTimeouts(JNIEnv*, jobject) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
+    NfcTag::getInstance().resetAllTransceiveTimeouts();
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_doSetTimeout
+  **
+  ** Description:     Set timeout value.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **                  tech: technology ID.
+  **                  timeout: Timeout value.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  static bool nfcManager_doSetTimeout(JNIEnv*, jobject, jint tech,
+                                      jint timeout) {
+    if (timeout <= 0) {
+      LOG(ERROR) << StringPrintf("%s: Timeout must be positive.", __func__);
+      return false;
+    }
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: tech=%d, timeout=%d", __func__, tech, timeout);
+
+    NfcTag::getInstance().setTransceiveTimeout(tech, timeout);
+    return true;
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_doGetTimeout
+  **
+  ** Description:     Get timeout value.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **                  tech: technology ID.
+  **
+  ** Returns:         Timeout value.
+  **
+  *******************************************************************************/
+  static jint nfcManager_doGetTimeout(JNIEnv*, jobject, jint tech) {
+    int timeout = NfcTag::getInstance().getTransceiveTimeout(tech);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: tech=%d, timeout=%d", __func__, tech, timeout);
+    return timeout;
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_doDump
+  **
+  ** Description:     Get libnfc-nci dump
+  **                  e: JVM environment.
+  **                  obj: Java object.
+  **                  fdobj: File descriptor to be used
+  **
+  ** Returns:         Void
+  **
+  *******************************************************************************/
+  static void nfcManager_doDump(JNIEnv * e, jobject obj, jobject fdobj) {
+    int fd = jniGetFDFromFileDescriptor(e, fdobj);
+    if (fd < 0) return;
 
-/*******************************************************************************
-**
-** Function:        nfcManager_doCreateLlcpSocket
-**
-** Description:     Create a LLCP connection-oriented socket.
-**                  e: JVM environment.
-**                  o: Java object.
-**                  nSap: Service access point.
-**                  miu: Maximum information unit.
-**                  rw: Receive window size.
-**                  linearBufferLength: Max buffer size.
-**
-** Returns:         NativeLlcpSocket Java object.
-**
-*******************************************************************************/
-static jobject nfcManager_doCreateLlcpSocket (JNIEnv* e, jobject, jint nSap, jint miu, jint rw, jint linearBufferLength)
-{
-    ALOGV("%s: enter; sap=%d; miu=%d; rw=%d; buffer len=%d", __func__, nSap, miu, rw, linearBufferLength);
+    NfcAdaptation& theInstance = NfcAdaptation::GetInstance();
+    theInstance.Dump(fd);
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_doSetP2pInitiatorModes
+  **
+  ** Description:     Set P2P initiator's activation modes.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **                  modes: Active and/or passive modes.  The values are
+  *specified
+  **                          in external/libnfc-nxp/inc/phNfcTypes.h.  See
+  **                          enum phNfc_eP2PMode_t.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  static void nfcManager_doSetP2pInitiatorModes(JNIEnv * e, jobject o,
+                                                jint modes) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: modes=0x%X", __func__, modes);
+    struct nfc_jni_native_data* nat = getNative(e, o);
 
-    PeerToPeer::tJNI_HANDLE jniHandle = PeerToPeer::getInstance().getNewJniHandle ();
-    PeerToPeer::getInstance().createClient (jniHandle, miu, rw);
+    tNFA_TECHNOLOGY_MASK mask = 0;
+    if (modes & 0x01) mask |= NFA_TECHNOLOGY_MASK_A;
+    if (modes & 0x02) mask |= NFA_TECHNOLOGY_MASK_F;
+    if (modes & 0x04) mask |= NFA_TECHNOLOGY_MASK_F;
+    if (modes & 0x08) mask |= NFA_TECHNOLOGY_MASK_A_ACTIVE;
+    if (modes & 0x10) mask |= NFA_TECHNOLOGY_MASK_F_ACTIVE;
+    if (modes & 0x20) mask |= NFA_TECHNOLOGY_MASK_F_ACTIVE;
+    nat->tech_mask = mask;
+  }
 
-    /* Create new NativeLlcpSocket object */
-    jobject clientSocket = NULL;
-    if (nfc_jni_cache_object_local(e, gNativeLlcpSocketClassName, &(clientSocket)) == -1)
-    {
-        ALOGE("%s: fail Llcp socket creation", __func__);
-        return clientSocket;
+#if (NXP_EXTNS == TRUE)
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_getRouting
+  **
+  ** Description:     Get Routing Table information.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **
+  ** Returns:         Current routing Settings.
+  **
+  *******************************************************************************/
+  static jbyteArray nfcManager_getRouting(JNIEnv * e, jobject /* o */) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s : Enter", __func__);
+    jbyteArray jbuff = NULL;
+    if (sRfEnabled) {
+      // Stop RF Discovery if we were polling
+      startRfDiscovery(false);
+    }
+    SyncEventGuard guard(sNfaGetRoutingEvent);
+    sRoutingBuffLen = 0;
+    RoutingManager::getInstance().getRouting();
+    sNfaGetRoutingEvent.wait();
+    if (sRoutingBuffLen > 0) {
+      jbuff = e->NewByteArray(sRoutingBuffLen);
+      e->SetByteArrayRegion(jbuff, 0, sRoutingBuffLen, (jbyte*)sRoutingBuff);
     }
 
-    /* Get NativeConnectionless class object */
-    ScopedLocalRef<jclass> clsNativeLlcpSocket(e, e->GetObjectClass(clientSocket));
-    if (e->ExceptionCheck())
-    {
-        e->ExceptionClear();
-        ALOGE("%s: fail get class object", __func__);
-        return clientSocket;
+    startRfDiscovery(true);
+    return jbuff;
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_getNfcInitTimeout
+  **
+  ** Description:     Gets the chip version.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **
+  ** Returns:         timeout in seconds
+  **
+  *******************************************************************************/
+  static int nfcManager_getNfcInitTimeout(JNIEnv * e, jobject o) {
+    (void)e;
+    (void)o;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+    unsigned long disc_timeout = 0;
+    unsigned long session_id_timeout = 0;
+    disc_timeout = 0;
+    gNfcInitTimeout = 0;
+    gdisc_timeout = 0;
+
+    if (NfcConfig::hasKey(NAME_NXP_DEFAULT_NFCEE_DISC_TIMEOUT)) {
+      disc_timeout =
+          NfcConfig::getUnsigned(NAME_NXP_DEFAULT_NFCEE_DISC_TIMEOUT);
+    } else {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("NAME_NXP_DEFAULT_NFCEE_DISC_TIMEOUT not found");
+      disc_timeout = 0;
     }
 
-    jfieldID f;
+    if (NfcConfig::hasKey(NAME_NXP_DEFAULT_NFCEE_TIMEOUT)) {
+      session_id_timeout =
+          NfcConfig::getUnsigned(NAME_NXP_DEFAULT_NFCEE_TIMEOUT);
+    } else {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("NAME_NXP_DEFAULT_NFCEE_TIMEOUT not found");
+      session_id_timeout = 0;
+    }
 
-    /* Set socket SAP */
-    f = e->GetFieldID (clsNativeLlcpSocket.get(), "mSap", "I");
-    e->SetIntField (clientSocket, f, (jint) nSap);
+    gNfcInitTimeout = (disc_timeout + session_id_timeout) * 1000;
+    gdisc_timeout = disc_timeout * 1000;
 
-    /* Set socket handle */
-    f = e->GetFieldID (clsNativeLlcpSocket.get(), "mHandle", "I");
-    e->SetIntField (clientSocket, f, (jint) jniHandle);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        " gNfcInitTimeout = %d: gdisc_timeout = %d "
+        "nfcManager_getNfcInitTimeout",
+        gNfcInitTimeout, gdisc_timeout);
+    return gNfcInitTimeout;
+  }
 
-    /* Set socket MIU */
-    f = e->GetFieldID (clsNativeLlcpSocket.get(), "mLocalMiu", "I");
-    e->SetIntField (clientSocket, f, (jint) miu);
+#endif
 
-    /* Set socket RW */
-    f = e->GetFieldID (clsNativeLlcpSocket.get(), "mLocalRw", "I");
-    e->SetIntField (clientSocket, f, (jint) rw);
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_doSetP2pTargetModes
+  **
+  ** Description:     Set P2P target's activation modes.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **                  modes: Active and/or passive modes.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  static void nfcManager_doSetP2pTargetModes(JNIEnv*, jobject, jint modes) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: modes=0x%X", __func__, modes);
+    // Map in the right modes
+    tNFA_TECHNOLOGY_MASK mask = 0;
+    if (modes & 0x01) mask |= NFA_TECHNOLOGY_MASK_A;
+    if (modes & 0x02) mask |= NFA_TECHNOLOGY_MASK_F;
+    if (modes & 0x04) mask |= NFA_TECHNOLOGY_MASK_F;
+    if (modes & 0x08)
+      mask |= NFA_TECHNOLOGY_MASK_A_ACTIVE | NFA_TECHNOLOGY_MASK_F_ACTIVE;
 
-    ALOGV("%s: exit", __func__);
-    return clientSocket;
-}
+    PeerToPeer::getInstance().setP2pListenMask(mask);
+  }
 
+  static void nfcManager_doEnableScreenOffSuspend(JNIEnv * /* e */, jobject /* o */) {
+    PowerSwitch::getInstance().setScreenOffPowerState(
+        PowerSwitch::POWER_STATE_FULL);
+  }
 
+  static void nfcManager_doDisableScreenOffSuspend(JNIEnv * /* e */, jobject /* o */) {
+    PowerSwitch::getInstance().setScreenOffPowerState(
+        PowerSwitch::POWER_STATE_OFF);
+  }
+#if (NXP_EXTNS == TRUE)
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_doUpdateScreenState
+  **
+  ** Description:     Update If any Pending screen state is present
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  static void nfcManager_doUpdateScreenState(JNIEnv * /* e */, jobject /* o */) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Enter ", __func__);
+    if (nfcFL.nfcNxpEse && nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
+      eScreenState_t last_screen_state_request;
+
+      if (pendingScreenState == true) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: pendingScreenState = true ", __func__);
+        pendingScreenState = false;
+        last_screen_state_request = get_lastScreenStateRequest();
+        nfcManager_doSetScreenState(NULL, NULL, last_screen_state_request);
+      } else {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: pendingScreenState = false ", __func__);
+      }
+    }
+  }
 /*******************************************************************************
-**
-** Function:        nfcManager_doCreateLlcpConnectionlessSocket
-**
-** Description:     Create a connection-less socket.
-**                  e: JVM environment.
-**                  o: Java object.
-**                  nSap: Service access point.
-**                  sn: Service name.
-**
-** Returns:         NativeLlcpConnectionlessSocket Java object.
-**
-*******************************************************************************/
-static jobject nfcManager_doCreateLlcpConnectionlessSocket (JNIEnv *, jobject, jint nSap, jstring /*sn*/)
-{
-    ALOGV("%s: nSap=0x%X", __func__, nSap);
-    return NULL;
-}
+ **
+ ** Function:        restartUiccListen()
+ **
+ ** Description:     ConfigureUICC Listen techmask according to uiccslot.
+ **
+ **
+ ** Returns:         null
+ **
+ *******************************************************************************/
+static void restartUiccListen(jint uiccSlot) {
+  tNFA_HANDLE handle = NFA_HANDLE_INVALID;
+  unsigned long int num = 0;
+  if (NfcConfig::hasKey(NAME_UICC_LISTEN_TECH_MASK)) {
+  num = NfcConfig::getUnsigned(NAME_UICC_LISTEN_TECH_MASK);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s:UICC_LISTEN_MASK=0x0%lu;", __func__, num);
+  }
+  {
+    SyncEventGuard guard(sNfaEnableDisablePollingEvent);
+    tNFA_STATUS status = NFA_StopRfDiscovery();
+    if (status == NFA_STATUS_OK) {
+      sNfaEnableDisablePollingEvent.wait();
+    } else
+      LOG(ERROR) << StringPrintf("%s: Failed to disable polling; error=0x%X",
+                                 __FUNCTION__, status);
+  }
+  {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: restart UICC listen mode (%02lX)", __func__, (num & 0xC7));
+    handle = (uiccSlot!=0x02)?
+        SecureElement::getInstance().getEseHandleFromGenericId(SecureElement::UICC_ID):
+        SecureElement::getInstance().getEseHandleFromGenericId(SecureElement::UICC2_ID);
+    SyncEventGuard guard(SecureElement::getInstance().mUiccListenEvent);
+    tNFA_STATUS stat = NFA_CeConfigureUiccListenTech(handle, 0x00);
+    if (stat == NFA_STATUS_OK) {
+      SecureElement::getInstance().mUiccListenEvent.wait();
+    } else
+      LOG(ERROR) << StringPrintf("fail to stop UICC listen");
+  }
+  {
+    SyncEventGuard guard(SecureElement::getInstance().mUiccListenEvent);
+    tNFA_STATUS stat = NFA_CeConfigureUiccListenTech(handle, (num & 0xC7));
+    if (stat == NFA_STATUS_OK) {
+      SecureElement::getInstance().mUiccListenEvent.wait();
+    } else
+      LOG(ERROR) << StringPrintf("fail to start UICC listen");
+  }
+}
+  /*******************************************************************************
+   **
+   ** Function:        nfcManager_doSelectUicc()
+   **
+   ** Description:     Issue any single TLV set config command as per input
+   ** register values and bit values
+   **
+   ** Returns:         success/failure
+   **
+   *******************************************************************************/
+  static int nfcManager_doSelectUicc(JNIEnv * e, jobject o, jint uiccSlot) {
+    (void)e;
+    (void)o;
+    uint8_t retStat = STATUS_UNKNOWN_ERROR;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+    if (nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
+      tNFA_STATUS status = NFC_STATUS_FAILED;
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: sUicc1CntxLen : 0x%02x  sUicc2CntxLen : 0x%02x", __func__,
+          dualUiccInfo.sUicc1CntxLen, dualUiccInfo.sUicc2CntxLen);
+      uint16_t RegAddr = 0xA0EC;
+      uint8_t bitVal;
+      eScreenState_t last_screen_state_request;
+      dualUiccInfo.uiccConfigStat = UICC_NOT_CONFIGURED;
+
+      RoutingManager& routingManager = RoutingManager::getInstance();
+      SecureElement& se = SecureElement::getInstance();
+
+      retStat = nfcManager_staticDualUicc_Precondition(uiccSlot);
+
+      if (retStat != UICC_NOT_CONFIGURED) {
+        goto endSwitch;
+      }
+
+      if (sRfEnabled) {
+        startRfDiscovery(false);
+      }
+      restartUiccListen(uiccSlot);
+
+      bitVal = ((0x10) | uiccSlot);
+
+      getUiccContext(uiccSlot);
+
+      if ((dualUiccInfo.sUicc1CntxLen != 0) ||
+          (dualUiccInfo.sUicc2CntxLen != 0)) {
+        if ((bitVal == 0x11) && (dualUiccInfo.sUicc1CntxLen != 0)) {
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "%s : update uicc1 context information ", __func__);
+          uint8_t cfg[256] = {0x20, 0x02};
+
+          memcpy(cfg + 3, dualUiccInfo.sUicc1Cntx, dualUiccInfo.sUicc1CntxLen);
+          cfg[2] = dualUiccInfo.sUicc1CntxLen - 1;
+          status = NxpNfc_Write_Cmd_Common(dualUiccInfo.sUicc1CntxLen + 2, cfg);
+
+          memcpy(cfg + 3, dualUiccInfo.sUicc1TechCapblty, 10);
+          cfg[2] = 9;
+          status = NxpNfc_Write_Cmd_Common(12, cfg);
+
+        } else if ((bitVal == 0x12) && (dualUiccInfo.sUicc2CntxLen != 0)) {
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "%s : update uicc2 context information", __func__);
+          uint8_t cfg[256] = {0x20, 0x02};
+          memcpy(cfg + 3, dualUiccInfo.sUicc2Cntx, dualUiccInfo.sUicc2CntxLen);
+          cfg[2] = dualUiccInfo.sUicc2CntxLen - 1;
+          status = NxpNfc_Write_Cmd_Common(dualUiccInfo.sUicc2CntxLen + 2, cfg);
+
+          memcpy(cfg + 3, dualUiccInfo.sUicc2TechCapblty, 10);
+          cfg[2] = 9;
+          status = NxpNfc_Write_Cmd_Common(12, cfg);
+        }
+      }
+
+      /*Update NFCC SWIO line accordingly*/
+      if ((Set_EERegisterValue(RegAddr, bitVal) != NFCSTATUS_OK)) {
+        retStat = DUAL_UICC_ERROR_SELECT_FAILED;
+        LOG(ERROR) << StringPrintf("%s : Set_EERegisterValue Failed", __func__);
+        goto endSwitch;
+      }
+
+      /*Mode Set Off for UICC*/
+      {
+        SyncEventGuard guard(routingManager.mEeSetModeEvent);
+        if ((NFA_EeModeSet(0x02, NFA_EE_MD_DEACTIVATE)) == NFA_STATUS_OK) {
+          routingManager.mEeSetModeEvent.wait();  // wait for
+                                                  // NFA_EE_MODE_SET_EVT
+        } else {
+          LOG(ERROR) << StringPrintf("%s : Failed to set EE inactive",
+                                     __func__);
+          goto endSwitch;
+        }
+      }
+      gSeDiscoverycount = 0;
+      /*Perform HAL re-initialisation
+       * NFA EE and HCI Subsystem de-init*/
+      {
+        SyncEventGuard guard(sNfceeHciCbDisableEvent);
+        NFA_EE_HCI_Control(false);
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("sNfceeHciCbDisableEvent waiting ......");
+        if (sNfceeHciCbDisableEvent.wait(500) == false) {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("sNfceeHciCbDisableEvent.wait Timeout happened");
+        } else {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("sNfceeHciCbDisableEvent.wait success");
+        }
+      }
+
+      /*Reset Nfcc*/
+      status = NFA_ResetNfcc();
+      /*Perform NFA EE and HCI Subsystem initialisation*/
+      {
+        SyncEventGuard guard(sNfceeHciCbEnableEvent);
+        NFA_EE_HCI_Control(true);
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("sNfceeHciCbEnableEvent waiting ......");
+        if (sNfceeHciCbEnableEvent.wait(500) == false) {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("sNfceeHciCbEnableEvent.wait Timeout happened");
+        } else {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("sNfceeHciCbEnableEvent.wait success");
+        }
+      }
 
+      {
+        se.updateEEStatus();
+        routingManager.initialize(getNative(e, o));
+        HciRFParams::getInstance().initialize();
+        sIsSecElemSelected = (se.getActualNumEe() - 1);
+        sIsSecElemDetected = sIsSecElemSelected;
+      }
+
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s : gSeDiscoverycount = %d", __func__, gSeDiscoverycount);
+      {
+        SyncEventGuard g(gNfceeDiscCbEvent);
+        /*Get the SWP1 and SWP2 lines status*/
+        if (NFA_STATUS_OK == GetNumNFCEEConfigured()) {
+          /*The SWP lines enabled and SE's discovered*/
+          if (gSeDiscoverycount < gActualSeCount) {
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+                "%s : Wait for ESE to discover, gdisc_timeout = %d", __func__,
+                gdisc_timeout);
+            if (gNfceeDiscCbEvent.wait(gdisc_timeout) == false) {
+              LOG(ERROR) << StringPrintf(
+                  "%s: timeout waiting for nfcee dis event", __func__);
+            }
+          } else {
+            DLOG_IF(INFO, nfc_debug_enabled)
+                << StringPrintf("%s : All ESE are discovered ", __func__);
+          }
+        }
+      }
+      /*Get the eSE and UICC parameters for RF*/
+      checkforNfceeConfig(UICC1 | UICC2 | ESE);
+
+      if (se.getEeStatus(se.EE_HANDLE_0xF4) == NFC_NFCEE_STATUS_REMOVED) {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s : UICC 0x%02x status : NFC_NFCEE_STATUS_REMOVED. Clearing "
+            "buffer",
+            __func__, sSelectedUicc);
+        if ((sSelectedUicc == 0x01) && (dualUiccInfo.sUicc1CntxLen != 0x00)) {
+          memset(dualUiccInfo.sUicc1Cntx, 0x00,
+                 sizeof(dualUiccInfo.sUicc1Cntx));
+          memset(dualUiccInfo.sUicc1TechCapblty, 0x00, 10);
+          dualUiccInfo.sUicc1CntxLen = 0x00;
+          write_uicc_context(
+              dualUiccInfo.sUicc1Cntx, dualUiccInfo.sUicc1CntxLen,
+              dualUiccInfo.sUicc1TechCapblty, 10, 1, sSelectedUicc);
+        } else if ((sSelectedUicc == 0x02) &&
+                   (dualUiccInfo.sUicc2CntxLen != 0x00)) {
+          memset(dualUiccInfo.sUicc2Cntx, 0x00,
+                 sizeof(dualUiccInfo.sUicc2Cntx));
+          memset(dualUiccInfo.sUicc2TechCapblty, 0x00, 10);
+          dualUiccInfo.sUicc2CntxLen = 0x00;
+          write_uicc_context(
+              dualUiccInfo.sUicc2Cntx, dualUiccInfo.sUicc2CntxLen,
+              dualUiccInfo.sUicc2TechCapblty, 10, 1, sSelectedUicc);
+        }
+      }
+
+      retStat = dualUiccInfo.uiccConfigStat;
+
+    endSwitch:
+      if ((retStat == UICC_CONFIGURED) || (retStat == UICC_NOT_CONFIGURED)) {
+        pTransactionController->transactionEnd(
+            TRANSACTION_REQUESTOR(staticDualUicc));
+        /*Apply screen state if pending*/
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: Apply screen state if pending", __func__);
+        if (pendingScreenState == true) {
+          pendingScreenState = false;
+          last_screen_state_request = get_lastScreenStateRequest();
+          nfcManager_doSetScreenState(NULL, NULL, last_screen_state_request);
+        } else {
+          LOG(ERROR) << StringPrintf("%s: Can not reset transaction state",
+                                     __func__);
+        }
+      }
+
+      /*If retStat is success then routing table will be reconfigured from
+       * NfcService
+       * As a part of commitRouting startRfDiscovery will be called.
+       * If retStat is failed then NfcService will not reconfigured routing
+       * table
+       * So do startRfDiscovery here*/
+      if ((retStat != UICC_CONFIGURED) && (retStat != UICC_NOT_CONFIGURED) &&
+          (!sRfEnabled)) {
+        startRfDiscovery(true);
+      }
+
+    } else if (nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) {
+      retStat = nfcManager_staticDualUicc_Precondition(uiccSlot);
+
+      if (retStat != UICC_NOT_CONFIGURED) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("staticDualUicc_Precondition failed.");
+        return retStat;
+      }
+
+      restartUiccListen(uiccSlot);
+      nfcManager_setPreferredSimSlot(NULL, NULL, uiccSlot);
+      retStat = UICC_CONFIGURED;
+      RoutingManager::getInstance().cleanRouting();
+      pTransactionController->transactionEnd(
+          TRANSACTION_REQUESTOR(staticDualUicc));
+    } else {
+      retStat = DUAL_UICC_FEATURE_NOT_AVAILABLE;
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: Dual uicc not supported retStat = %d", __func__, retStat);
+    }
+    DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: exit retStat = %d", __func__, retStat);
+    return retStat;
+  }
+
+  /*******************************************************************************
+   **
+   ** Function:        nfcManager_doGetSelectedUicc()
+   **
+   ** Description:     get the current selected active UICC
+   **
+   ** Returns:         UICC id
+   **
+   *******************************************************************************/
+  static int nfcManager_doGetSelectedUicc(JNIEnv * e, jobject o) {
+    uint8_t uicc_stat = STATUS_UNKNOWN_ERROR;
+    if (nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter ", __func__);
+      uicc_stat = SecureElement::getInstance().getUiccStatus(sSelectedUicc);
+    } else if (nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) {
+      uicc_stat =
+          SecureElement::getInstance().getUiccStatus(sCurrentSelectedUICCSlot);
+    } else {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: dual uicc not supported ", __func__);
+      uicc_stat = DUAL_UICC_FEATURE_NOT_AVAILABLE;
+    }
+    return uicc_stat;
+  }
+#endif
 
 /*******************************************************************************
 **
-** Function:        nfcManager_doGetSecureElementList
+** Function:        nfcManager_getIsoDepMaxTransceiveLength
 **
-** Description:     Get a list of secure element handles.
-**                  e: JVM environment.
-**                  o: Java object.
+** Description:     Get maximum ISO DEP Transceive Length supported by the NFC
+**                  chip. Returns default 261 bytes if the property is not set.
 **
-** Returns:         List of secure element handles.
+** Returns:         max value.
 **
 *******************************************************************************/
-static jintArray nfcManager_doGetSecureElementList(JNIEnv* e, jobject)
-{
-    ALOGV("%s", __func__);
-    return SecureElement::getInstance().getListOfEeHandles(e);
-}
+  static jint nfcManager_getIsoDepMaxTransceiveLength(JNIEnv*, jobject) {
+    /* Check if extended APDU is supported by the chip.
+     * If not, default value is returned.
+     * The maximum length of a default IsoDep frame consists of:
+     * CLA, INS, P1, P2, LC, LE + 255 payload bytes = 261 bytes
+     */
+  return NfcConfig::getUnsigned(NAME_ISO_DEP_MAX_TRANSCEIVE, 261);
+  }
 
-/*******************************************************************************
-**
-** Function:        setListenMode
-**
-** Description:     NFC controller starts routing data in listen mode.
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         None
-**
-*******************************************************************************/
-#if 0
-inline static void setListenMode()  /*defined as inline to eliminate warning defined but not used*/
-{
-    ALOGV("%s: enter", __func__);
-    tNFA_HANDLE ee_handleList[nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED];
-    uint8_t i, seId, count;
+  /*****************************************************************************
+  **
+  ** JNI functions for android-4.0.1_r1
+  **
+  *****************************************************************************/
+  static JNINativeMethod gMethods[] = {
+    {"doDownload", "()Z", (void*)nfcManager_doDownload},
 
-    PowerSwitch::getInstance ().setLevel (PowerSwitch::FULL_POWER);
+    {"initializeNativeStructure", "()Z", (void*)nfcManager_initNativeStruc},
 
-    if (sRfEnabled) {
-        // Stop RF Discovery if we were polling
-        startRfDiscovery (false);
-    }
-    SecureElement::getInstance().getEeHandleList(ee_handleList, &count);
-    if (count > nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED) {
-        count = nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED;
-        ALOGV("Count is more than NFA_EE_MAX_EE_SUPPORTED ,Forcing to NFA_EE_MAX_EE_SUPPORTED");
-    }
-    for ( i = 0; i < count; i++)
-    {
-        seId = SecureElement::getInstance().getGenericEseId(ee_handleList[i]);
-        SecureElement::getInstance().activate (seId);
-        sIsSecElemSelected++;
-    }
+    {"doInitialize", "()Z", (void*)nfcManager_doInitialize},
 
-    startRfDiscovery (true);
-    PowerSwitch::getInstance ().setModeOn (PowerSwitch::SE_ROUTING);
-//TheEnd:                           /*commented to eliminate warning label defined but not used*/
-    ALOGV("%s: exit", __func__);
-}
-#endif
+    {"doDeinitialize", "()Z", (void*)nfcManager_doDeinitialize},
 
+    {"sendRawFrame", "([B)Z", (void*)nfcManager_sendRawFrame},
 
-/*******************************************************************************
-**
-** Function:        nfcManager_doSelectSecureElement
-**
-** Description:     NFC controller starts routing data in listen mode.
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         None
-**
-*******************************************************************************/
-static void nfcManager_doSelectSecureElement(JNIEnv *e, jobject o, jint seId)
-{
-    (void)e;
-    (void)o;
-    ALOGV("%s: enter", __func__);
-    bool stat = true;
+    {"doRouteAid", "([BIII)Z", (void*)nfcManager_routeAid},
 
-    if (sIsSecElemSelected >= sIsSecElemDetected)
-    {
-        ALOGV("%s: already selected", __func__);
-        goto TheEnd;
-    }
+    {"doUnrouteAid", "([B)Z", (void*)nfcManager_unrouteAid},
 
-    PowerSwitch::getInstance ().setLevel (PowerSwitch::FULL_POWER);
+    {"doSetRoutingEntry", "(IIII)Z", (void*)nfcManager_setRoutingEntry},
 
-    if (sRfEnabled) {
-        // Stop RF Discovery if we were polling
-        startRfDiscovery (false);
-    }
+    {"doClearRoutingEntry", "(I)Z", (void*)nfcManager_clearRoutingEntry},
 
-    stat = SecureElement::getInstance().activate (seId);
-    if (stat)
-    {
-        SecureElement::getInstance().routeToSecureElement ();
-        sIsSecElemSelected++;
-//        if(sHCEEnabled == false)
-//        {
-//            RoutingManager::getInstance().setRouting(false);
-//        }
-    }
-//    sIsSecElemSelected = true;
-
-    startRfDiscovery (true);
-    PowerSwitch::getInstance ().setModeOn (PowerSwitch::SE_ROUTING);
-TheEnd:
-    ALOGV("%s: exit", __func__);
-}
+    {"clearAidTable", "()Z", (void*)nfcManager_clearAidTable},
 
-/*******************************************************************************
-**
-** Function:        nfcManager_doSetSEPowerOffState
-**
-** Description:     NFC controller enable/disabe card emulation in power off
-**                  state from EE.
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         None
-**
-*******************************************************************************/
-static void nfcManager_doSetSEPowerOffState(JNIEnv *e, jobject o, jint seId, jboolean enable)
-{
-    (void)e;
-    (void)o;
-    tNFA_HANDLE ee_handle;
-    uint8_t power_state_mask = ~NFA_EE_PWR_STATE_SWITCH_OFF;
+    {"setDefaultRoute", "(III)Z", (void*)nfcManager_setDefaultRoute},
 
-    if(enable == true)
-    {
-        power_state_mask = NFA_EE_PWR_STATE_SWITCH_OFF;
-    }
+    {"getAidTableSize", "()I", (void*)nfcManager_getAidTableSize},
 
-    ee_handle = SecureElement::getInstance().getEseHandleFromGenericId(seId);
+    {"getRemainingAidTableSize", "()I",
+     (void*)nfcManager_getRemainingAidTableSize},
 
-    if (sRfEnabled) {
-        // Stop RF Discovery if we were polling
-        startRfDiscovery (false);
-    }
+    {"getDefaultAidRoute", "()I", (void*)nfcManager_getDefaultAidRoute},
 
-    tNFA_STATUS status = NFA_AddEePowerState(ee_handle,power_state_mask);
+    {"getDefaultDesfireRoute", "()I", (void*)nfcManager_getDefaultDesfireRoute},
 
+    {"getDefaultMifareCLTRoute", "()I",
+     (void*)nfcManager_getDefaultMifareCLTRoute},
+    {"readerPassThruMode", "(BB)[B", (void*)nfcManager_readerPassThruMode},
+    {"transceiveAppData", "([B)[B", (void*)nfcManager_transceiveAppData},
+#if (NXP_EXTNS == TRUE)
+    {"getDefaultAidPowerState", "()I",
+     (void*)nfcManager_getDefaultAidPowerState},
 
-    // Commit the routing configuration
-    status |= NFA_EeUpdateNow();
+    {"getDefaultDesfirePowerState", "()I",
+     (void*)nfcManager_getDefaultDesfirePowerState},
 
-    if (status != NFA_STATUS_OK)
-        ALOGE("Failed to commit routing configuration");
+    {"getDefaultMifareCLTPowerState", "()I",
+     (void*)nfcManager_getDefaultMifareCLTPowerState},
+#endif
+    {"doRegisterT3tIdentifier", "([B)I",
+     (void*)nfcManager_doRegisterT3tIdentifier},
 
-    startRfDiscovery (true);
+    {"doDeregisterT3tIdentifier", "(I)V",
+     (void*)nfcManager_doDeregisterT3tIdentifier},
 
-//    TheEnd:                   /*commented to eliminate warning label defined but not used*/
-        ALOGV("%s: exit", __func__);
+    {"getLfT3tMax", "()I", (void*)nfcManager_getLfT3tMax},
 
-}
+    {"doEnableDiscovery", "(IZZZZ)V", (void*)nfcManager_enableDiscovery},
 
+    {"doGetSecureElementList", "()[I",
+     (void*)nfcManager_doGetSecureElementList},
 
-/*******************************************************************************
-**
-** Function:        nfcManager_GetDefaultSE
-**
-** Description:     Get default Secure Element.
-**
-**
-** Returns:         Returns 0.
-**
-*******************************************************************************/
-static jint nfcManager_GetDefaultSE(JNIEnv *e, jobject o)
-{
-    (void)e;
-    (void)o;
-    unsigned long num;
-    GetNxpNumValue (NAME_NXP_DEFAULT_SE, (void*)&num, sizeof(num));
-    ALOGV("%lu: nfcManager_GetDefaultSE", num);
-    return num;
+    {"doSelectSecureElement", "(I)V", (void*)nfcManager_doSelectSecureElement},
 
-}
+    {"doActivateSecureElement", "(I)V",
+     (void*)nfcManager_activateSecureElement},
 
+    {"doDeselectSecureElement", "(I)V",
+     (void*)nfcManager_doDeselectSecureElement},
 
-static jint nfcManager_getSecureElementTechList(JNIEnv *e, jobject o)
-{
-    (void)e;
-    (void)o;
-    uint8_t sak;
-    jint tech = 0x00;
-    ALOGV("nfcManager_getSecureElementTechList -Enter");
-    sak = HciRFParams::getInstance().getESeSak();
-    bool isTypeBPresent = HciRFParams::getInstance().isTypeBSupported();
+    {"doSetSEPowerOffState", "(IZ)V", (void*)nfcManager_doSetSEPowerOffState},
+    {"setDefaultTechRoute", "(III)V", (void*)nfcManager_setDefaultTechRoute},
 
-    ALOGV("nfcManager_getSecureElementTechList - sak is %0x", sak);
+    {"setDefaultProtoRoute", "(III)V", (void*)nfcManager_setDefaultProtoRoute},
 
-    if(sak & 0x08)
-    {
-        tech |= TARGET_TYPE_MIFARE_CLASSIC;
-    }
+    {"GetDefaultSE", "()I", (void*)nfcManager_GetDefaultSE},
 
-    if( sak & 0x20 )
-    {
-        tech |= NFA_TECHNOLOGY_MASK_A;
-    }
+    {"doCheckLlcp", "()Z", (void*)nfcManager_doCheckLlcp},
 
-    if( isTypeBPresent == true)
-    {
-        tech |= NFA_TECHNOLOGY_MASK_B;
-    }
-    ALOGV("nfcManager_getSecureElementTechList - tech is %0x", tech);
-    return tech;
+    {"doActivateLlcp", "()Z", (void*)nfcManager_doActivateLlcp},
 
-}
+    {"doCreateLlcpConnectionlessSocket",
+     "(ILjava/lang/String;)Lcom/android/nfc/dhimpl/"
+     "NativeLlcpConnectionlessSocket;",
+     (void*)nfcManager_doCreateLlcpConnectionlessSocket},
 
-static jintArray nfcManager_getActiveSecureElementList(JNIEnv *e, jobject o)
-{
-    (void)e;
-    (void)o;
-    return SecureElement::getInstance().getActiveSecureElementList(e);
-}
+    {"doCreateLlcpServiceSocket",
+     "(ILjava/lang/String;III)Lcom/android/nfc/dhimpl/NativeLlcpServiceSocket;",
+     (void*)nfcManager_doCreateLlcpServiceSocket},
 
-static void nfcManager_setSecureElementListenTechMask(JNIEnv *e, jobject o, jint tech_mask)
-{
-    (void)e;
-    (void)o;
-    ALOGV("%s: ENTER", __func__);
-//    tNFA_STATUS status;                   /*commented to eliminate unused variable warning*/
+    {"doCreateLlcpSocket", "(IIII)Lcom/android/nfc/dhimpl/NativeLlcpSocket;",
+     (void*)nfcManager_doCreateLlcpSocket},
 
-    if (sRfEnabled) {
-        // Stop RF Discovery if we were polling
-        startRfDiscovery (false);
-    }
-    SecureElement::getInstance().setEseListenTechMask(tech_mask);
+    {"doGetLastError", "()I", (void*)nfcManager_doGetLastError},
 
-    startRfDiscovery (true);
+    {"disableDiscovery", "()V", (void*)nfcManager_disableDiscovery},
 
-    ALOGV("%s: EXIT", __func__);
-}
+    {"doSetTimeout", "(II)Z", (void*)nfcManager_doSetTimeout},
 
+    {"doGetTimeout", "(I)I", (void*)nfcManager_doGetTimeout},
 
-static jbyteArray nfcManager_getSecureElementUid(JNIEnv* e, jobject /* o */)
-{
-    jbyteArray jbuff = NULL;
-    uint8_t bufflen = 0;
-    uint8_t buf[16] = {0,};
+    {"doResetTimeouts", "()V", (void*)nfcManager_doResetTimeouts},
 
-    ALOGV("nfcManager_getSecureElementUid -Enter");
-    HciRFParams::getInstance().getESeUid(&buf[0], &bufflen);
-    if(bufflen > 0)
-     {
-       jbuff = e->NewByteArray (bufflen);
-       e->SetByteArrayRegion (jbuff, 0, bufflen, (jbyte*) buf);
-     }
-    return jbuff;
-}
+    {"doAbort", "(Ljava/lang/String;)V", (void*)nfcManager_doAbort},
 
-static tNFA_STATUS nfcManager_setEmvCoPollProfile(JNIEnv* /* e */, jobject /* o */,
-        jboolean enable, jint route)
-{
-    tNFA_STATUS status = NFA_STATUS_FAILED;
-    tNFA_TECHNOLOGY_MASK tech_mask = 0;
+    {"doSetP2pInitiatorModes", "(I)V",
+     (void*)nfcManager_doSetP2pInitiatorModes},
 
-    ALOGE("In nfcManager_setEmvCoPollProfile enable = 0x%x route = 0x%x", enable, route);
-    /* Stop polling */
-    if ( isDiscoveryStarted())
-    {
-        // Stop RF discovery to reconfigure
-        startRfDiscovery(false);
-    }
+    {"doSetP2pTargetModes", "(I)V", (void*)nfcManager_doSetP2pTargetModes},
 
-    status = EmvCo_dosetPoll(enable);
-    if (status != NFA_STATUS_OK)
-    {
-        ALOGE("%s: fail enable polling; error=0x%X", __func__, status);
-        goto TheEnd;
-    }
+    {"doEnableScreenOffSuspend", "()V",
+     (void*)nfcManager_doEnableScreenOffSuspend},
 
-    if (enable)
-    {
-        if (route == 0x00)
-        {
-            /* DH enable polling for A and B*/
-            tech_mask = NFA_TECHNOLOGY_MASK_A | NFA_TECHNOLOGY_MASK_B;
-        }
-        else if(route == 0x01)
-        {
-            /* UICC is end-point at present not supported by FW */
-            /* TBD : Get eeinfo (use handle appropirately, depending up
-             * on it enable the polling */
-        }
-        else if(route == 0x02)
-        {
-            /* ESE is end-point at present not supported by FW */
-            /* TBD : Get eeinfo (use handle appropirately, depending up
-             * on it enable the polling */
-        }
-        else
-        {
+    {"doDisableScreenOffSuspend", "()V",
+     (void*)nfcManager_doDisableScreenOffSuspend},
 
-        }
+    {"doDump", "(Ljava/io/FileDescriptor;)V", (void*)nfcManager_doDump},
+
+    {"getChipVer", "()I", (void*)nfcManager_getChipVer},
+
+    {"JCOSDownload", "()I", (void*)nfcManager_doJcosDownload},
+    {"doCommitRouting", "()V", (void*)nfcManager_doCommitRouting},
+#if (NXP_EXTNS == TRUE)
+    {"doSetNfcMode", "(I)V", (void*)nfcManager_doSetNfcMode},
+
+    {"setTransitConfig", "(Ljava/lang/String;)I",
+     (void*)nfcManager_setTransitConfig},
+
+#endif
+    {"doGetSecureElementTechList", "()I",
+     (void*)nfcManager_getSecureElementTechList},
+
+    {"doGetActiveSecureElementList", "()[I",
+     (void*)nfcManager_getActiveSecureElementList},
+
+    {"doGetSecureElementUid", "()[B", (void*)nfcManager_getSecureElementUid},
+
+    {"setEmvCoPollProfile", "(ZI)I", (void*)nfcManager_setEmvCoPollProfile},
+
+    {"doSetSecureElementListenTechMask", "(I)V",
+     (void*)nfcManager_setSecureElementListenTechMask},
+    {"getNciVersion", "()I", (void*)nfcManager_doGetNciVersion},
+    {"doSetScreenState", "(I)V", (void*)nfcManager_doSetScreenState},
+    {"doSetScreenOrPowerState", "(I)V",
+     (void*)nfcManager_doSetScreenOrPowerState},
+    // Factory Test Code
+    {"doPrbsOn", "(IIII)V", (void*)nfcManager_doPrbsOn},
+    {"doPrbsOff", "()V", (void*)nfcManager_doPrbsOff},
+    // SWP self test
+    {"SWPSelfTest", "(I)I", (void*)nfcManager_SWPSelfTest},
+    // check firmware version
+    {"getFWVersion", "()I", (void*)nfcManager_getFwVersion},
+#if (NXP_EXTNS == TRUE)
+    {"updateScreenState", "()V", (void*)nfcManager_doUpdateScreenState},
+    {"doEnablep2p", "(Z)V", (void*)nfcManager_Enablep2p},
+    {"doSetProvisionMode", "(Z)V", (void*)nfcManager_setProvisionMode},
+    {"doGetRouting", "()[B", (void*)nfcManager_getRouting},
+    {"getNfcInitTimeout", "()I", (void*)nfcManager_getNfcInitTimeout},
+    {"isVzwFeatureEnabled", "()Z", (void*)nfcManager_isVzwFeatureEnabled},
+    {"isNfccBusy", "()Z", (void*)nfcManager_isNfccBusy},
+#endif
+    {"doSetEEPROM", "([B)V", (void*)nfcManager_doSetEEPROM},
+    {"doGetSeInterface", "(I)I", (void*)nfcManager_doGetSeInterface},
+    // Factory Test Code
+    {"doCheckJcopDlAtBoot", "()Z", (void*)nfcManager_doCheckJcopDlAtBoot},
+    {"doEnableDtaMode", "()V", (void*)nfcManager_doEnableDtaMode},
+    {"doDisableDtaMode", "()V", (void*)nfcManager_doDisableDtaMode},
+    {"doFactoryReset", "()V", (void*)nfcManager_doFactoryReset},
+    {"doShutdown", "()V", (void*)nfcManager_doShutdown},
+    {"getIsoDepMaxTransceiveLength", "()I",
+     (void*)nfcManager_getIsoDepMaxTransceiveLength}
+#if (NXP_EXTNS == TRUE)
+    ,
+    {"doselectUicc", "(I)I", (void*)nfcManager_doSelectUicc},
+    {"doGetSelectedUicc", "()I", (void*)nfcManager_doGetSelectedUicc},
+    {"setPreferredSimSlot", "(I)I", (void*)nfcManager_setPreferredSimSlot},
+    {"routeApduPattern", "(II[B[B)Z", (void*)nfcManager_routeApduPattern},
+    {"unrouteApduPattern", "([B)Z", (void*)nfcManager_unrouteApduPattern},
+    {"doNfcSelfTest", "(I)I", (void*)nfcManager_nfcSelfTest}
+#endif
+  };
+
+  /*******************************************************************************
+  **
+  ** Function:        register_com_android_nfc_NativeNfcManager
+  **
+  ** Description:     Regisgter JNI functions with Java Virtual Machine.
+  **                  e: Environment of JVM.
+  **
+  ** Returns:         Status of registration.
+  **
+  *******************************************************************************/
+  int register_com_android_nfc_NativeNfcManager(JNIEnv * e) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+    PowerSwitch::getInstance().initialize(PowerSwitch::UNKNOWN_LEVEL);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+    return jniRegisterNativeMethods(e, gNativeNfcManagerClassName, gMethods,
+                                    NELEM(gMethods));
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        startRfDiscovery
+  **
+  ** Description:     Ask stack to start polling and listening for devices.
+  **                  isStart: Whether to start.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void startRfDiscovery(bool isStart) {
+#if (NXP_EXTNS == TRUE)
+    tNFA_STATUS status = NFA_STATUS_FAILED;
+    if (sAutonomousSet == 1) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "Autonomous mode set don't start RF disc %d", isStart);
+      return;
+    }
+    if ((!gsRouteUpdated) && isStart) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: Routing table update pending.Can not start RF disc. Returning..",
+          __FUNCTION__);
+      return;
+    }
+    if (isStart == sRfEnabled) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s Already in RF state: %d", __FUNCTION__, isStart);
+      return;
     }
+#endif
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: is start=%d", __func__, isStart);
+    nativeNfcTag_acquireRfInterfaceMutexLock();
+    SyncEventGuard guard(sNfaEnableDisablePollingEvent);
+    status = isStart ? NFA_StartRfDiscovery() : NFA_StopRfDiscovery();
+    if (status == NFA_STATUS_OK) {
+      if (gGeneralPowershutDown == NFC_MODE_OFF) sDiscCmdwhleNfcOff = true;
+      se_rd_req_state_t state =
+          MposManager::getInstance().getEtsiReaederState();
+      if (state == STATE_SE_RDR_MODE_STOP_IN_PROGRESS ||
+          state == STATE_SE_RDR_MODE_ACTIVATED) {
+        sNfaEnableDisablePollingEvent
+            .wait();  // wait for NFA_RF_DISCOVERY_xxxx_EVT
+      } else {
+        sNfaEnableDisablePollingEvent.wait(
+            NFC_CMD_TIMEOUT);  // wait for NFA_RF_DISCOVERY_xxxx_EVT
+      }
+      sRfEnabled = isStart;
+      sDiscCmdwhleNfcOff = false;
+    } else {
+      LOG(ERROR) << StringPrintf(
+          "%s: Failed to start/stop RF discovery; error=0x%X", __func__,
+          status);
+    }
+    nativeNfcTag_releaseRfInterfaceMutexLock();
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: is exit=%d", __func__, isStart);
+  }
+
+  /*******************************************************************************
+   **
+   ** Function:        isDiscoveryStarted
+   **
+   ** Description:     Indicates whether the discovery is started.
+   **
+   ** Returns:         True if discovery is started
+   **
+   *******************************************************************************/
+  bool isDiscoveryStarted() { return sRfEnabled; }
+
+  /*******************************************************************************
+  **
+  ** Function:        notifyPollingEventwhileNfcOff
+  **
+  ** Description:     Notifies sNfaEnableDisablePollingEvent if tag operations
+  **                  is in progress at the time Nfc Off is in progress to avoid
+  **                  NFC off thread infinite block.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  static void notifyPollingEventwhileNfcOff() {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: sDiscCmdwhleNfcOff=%x", __func__, sDiscCmdwhleNfcOff);
+    if (sDiscCmdwhleNfcOff == true) {
+      SyncEventGuard guard(sNfaEnableDisablePollingEvent);
+      sNfaEnableDisablePollingEvent.notifyOne();
+    }
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        doStartupConfig
+  **
+  ** Description:     Configure the NFC controller.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void doStartupConfig() {
+    // configure RF polling frequency for each technology
+    static tNFA_DM_DISC_FREQ_CFG nfa_dm_disc_freq_cfg;
+    // values in the polling_frequency[] map to members of nfa_dm_disc_freq_cfg
+  std::vector<uint8_t> polling_frequency;
+  if (NfcConfig::hasKey(NAME_POLL_FREQUENCY))
+    polling_frequency = NfcConfig::getBytes(NAME_POLL_FREQUENCY);
+  if (polling_frequency.size() == 8) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: polling frequency", __func__);
+      memset(&nfa_dm_disc_freq_cfg, 0, sizeof(nfa_dm_disc_freq_cfg));
+      nfa_dm_disc_freq_cfg.pa = polling_frequency[0];
+      nfa_dm_disc_freq_cfg.pb = polling_frequency[1];
+      nfa_dm_disc_freq_cfg.pf = polling_frequency[2];
+      nfa_dm_disc_freq_cfg.pi93 = polling_frequency[3];
+      nfa_dm_disc_freq_cfg.pbp = polling_frequency[4];
+      nfa_dm_disc_freq_cfg.pk = polling_frequency[5];
+      nfa_dm_disc_freq_cfg.paa = polling_frequency[6];
+      nfa_dm_disc_freq_cfg.pfa = polling_frequency[7];
+      p_nfa_dm_rf_disc_freq_cfg = &nfa_dm_disc_freq_cfg;
+    }
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_isNfcActive
+  **
+  ** Description:     Used externaly to determine if NFC is active or not.
+  **
+  ** Returns:         'true' if the NFC stack is running, else 'false'.
+  **
+  *******************************************************************************/
+  bool nfcManager_isNfcActive() { return sIsNfaEnabled; }
+
+#if (NXP_EXTNS == TRUE)
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_isNfcDisabling
+  **
+  ** Description:     Used externaly to determine if NFC is deinit is ongoing or
+  *not.
+  **
+  ** Returns:         'true' if the NFC deinit is running, else 'false'.
+  **
+  *******************************************************************************/
+  bool nfcManager_isNfcDisabling() { return sIsDisabling; }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_getNfcState
+  **
+  ** Description:     Used internally and externally to check the current NFC
+  *state
+  **
+  ** Returns:         Returns the current state of NFC.
+  **
+  *******************************************************************************/
+  uint8_t nfcManager_getNfcState() {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: sNfcState = %d", __func__, sNfcState);
+    return sNfcState;
+  }
+
+#endif
+
+  /*******************************************************************************
+  **
+  ** Function:        startStopPolling
+  **
+  ** Description:     Start or stop polling.
+  **                  isStartPolling: true to start polling; false to stop
+  *polling.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  void startStopPolling(bool isStartPolling) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: enter; isStart=%u", __func__, isStartPolling);
+    startRfDiscovery(false);
+
+    if (isStartPolling)
+      startPolling_rfDiscoveryDisabled(0);
     else
-    {
-        unsigned long num = 0;
-        if (GetNumValue(NAME_POLLING_TECH_MASK, &num, sizeof(num)))
-            tech_mask = num;
-    }
+      stopPolling_rfDiscoveryDisabled();
 
-    ALOGV("%s: enable polling", __func__);
-    {
-        SyncEventGuard guard (sNfaEnableDisablePollingEvent);
-        status = NFA_EnablePolling (tech_mask);
-        if (status == NFA_STATUS_OK)
-        {
-            ALOGV("%s: wait for enable event", __func__);
-            sNfaEnableDisablePollingEvent.wait (); //wait for NFA_POLL_ENABLED_EVT
-        }
-        else
-        {
-            ALOGE("%s: fail enable polling; error=0x%X", __func__, status);
-        }
+    startRfDiscovery(true);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  }
+
+  static tNFA_STATUS startPolling_rfDiscoveryDisabled(
+      tNFA_TECHNOLOGY_MASK tech_mask) {
+    tNFA_STATUS stat = NFA_STATUS_FAILED;
+
+  if (tech_mask == 0)
+    tech_mask =
+        NfcConfig::getUnsigned(NAME_POLLING_TECH_MASK, DEFAULT_TECH_MASK);
+
+    nativeNfcTag_acquireRfInterfaceMutexLock();
+    SyncEventGuard guard(sNfaEnableDisablePollingEvent);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: enable polling", __func__);
+    stat = NFA_EnablePolling(tech_mask);
+    if (stat == NFA_STATUS_OK) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: wait for enable event", __func__);
+      sPollingEnabled = true;
+      sNfaEnableDisablePollingEvent.wait();  // wait for NFA_POLL_ENABLED_EVT
+    } else {
+      LOG(ERROR) << StringPrintf("%s: fail enable polling; error=0x%X",
+                                 __func__, stat);
     }
 
-TheEnd:
-    /* start polling */
-    if ( !isDiscoveryStarted())
-    {
-        // Start RF discovery to reconfigure
-        startRfDiscovery(true);
+    nativeNfcTag_releaseRfInterfaceMutexLock();
+
+    return stat;
+  }
+
+  static tNFA_STATUS stopPolling_rfDiscoveryDisabled() {
+    tNFA_STATUS stat = NFA_STATUS_FAILED;
+
+    nativeNfcTag_acquireRfInterfaceMutexLock();
+    SyncEventGuard guard(sNfaEnableDisablePollingEvent);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: disable polling", __func__);
+    stat = NFA_DisablePolling();
+    if (stat == NFA_STATUS_OK) {
+      sPollingEnabled = false;
+      sNfaEnableDisablePollingEvent.wait();  // wait for NFA_POLL_DISABLED_EVT
+    } else {
+      LOG(ERROR) << StringPrintf("%s: fail disable polling; error=0x%X",
+                                 __func__, stat);
     }
-    return status;
 
-}
+    nativeNfcTag_releaseRfInterfaceMutexLock();
 
-/*******************************************************************************
-**
-** Function:        nfcManager_doDeselectSecureElement
-**
-** Description:     NFC controller stops routing data in listen mode.
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         None
-**
-*******************************************************************************/
-static void nfcManager_doDeselectSecureElement(JNIEnv *e, jobject o,  jint seId)
-{
+    return stat;
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_getChipVer
+  **
+  ** Description:     Gets the chip version.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **
+  ** Returns:         None      0x00
+  **                  PN547C2   0x01
+  **                  PN65T     0x02 .
+  **
+  *******************************************************************************/
+  static int nfcManager_getChipVer(JNIEnv * e, jobject o) {
     (void)e;
     (void)o;
-    ALOGV("%s: enter", __func__);
-    bool stat = false;
-    bool bRestartDiscovery = false;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+    unsigned long num = 0;
 
-    if (! sIsSecElemSelected)
-    {
-        ALOGE("%s: already deselected", __func__);
-        goto TheEnd2;
+    if (NfcConfig::hasKey(NAME_NXP_NFC_CHIP)) {
+      num = NfcConfig::getUnsigned(NAME_NXP_NFC_CHIP);
     }
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%ld: nfcManager_getChipVer", num);
+    return num;
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_setTransitConfig
+  **
+  ** Description:     Set Transit Configuration
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **                  config: Jstring.
+  **
+  ** Returns:         Success      0x00
+  **                  Failed       0x01
+  **
+  *******************************************************************************/
+  static int nfcManager_setTransitConfig(JNIEnv * e, jobject o,
+                                         jstring config) {
+    (void)e;
+    (void)o;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+    std::string transitConfig = ConvertJavaStrToStdString(e, config);
+    SyncEventGuard guard(sNfaTransitConfigEvent);
+    int stat = NFA_SetTransitConfig(transitConfig);
+    sNfaTransitConfigEvent.wait(10 * ONE_SECOND_MS);
+    return stat;
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        ConvertJavaStrToStdString
+  **
+  ** Description:     Convert Jstring to string
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **                  s: Jstring.
+  **
+  ** Returns:         std::string
+  **
+  *******************************************************************************/
+  static std::string ConvertJavaStrToStdString(JNIEnv * env, jstring s) {
+    if (!s) return "";
+
+    const jclass strClass = env->GetObjectClass(s);
+    const jmethodID getBytes =
+        env->GetMethodID(strClass, "getBytes", "(Ljava/lang/String;)[B");
+    const jbyteArray strJbytes = (jbyteArray)env->CallObjectMethod(
+        s, getBytes, env->NewStringUTF("UTF-8"));
+
+    size_t length = (size_t)env->GetArrayLength(strJbytes);
+    jbyte* pBytes = env->GetByteArrayElements(strJbytes, NULL);
+
+    std::string ret = std::string((char*)pBytes, length);
+    env->ReleaseByteArrayElements(strJbytes, pBytes, JNI_ABORT);
+
+    env->DeleteLocalRef(strJbytes);
+    env->DeleteLocalRef(strClass);
+    return ret;
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        DWPChannel_init
+  **
+  ** Description:     Initializes the DWP channel functions.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  void DWPChannel_init(IChannel_t * DWP) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+    if (nfcFL.nfcNxpEse) {
+      DWP->open = open;
+      DWP->close = close;
+      DWP->transceive = transceive;
+      DWP->doeSE_Reset = doeSE_Reset;
+      DWP->doeSE_JcopDownLoadReset = doeSE_JcopDownLoadReset;
+    }
+  }
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_doJcosDownload
+  **
+  ** Description:     start jcos download.
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  static int nfcManager_doJcosDownload(JNIEnv * e, jobject o) {
+    (void)e;
+    (void)o;
+    tNFA_STATUS status = NFA_STATUS_FAILED;
+#if (NXP_EXTNS == TRUE)
+    if (nfcFL.nfcNxpEse) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+      bool stat = false;
+      int ret_val = -1;
+      NFCSTATUS ese_status = NFA_STATUS_FAILED;
+      p61_access_state_t p61_current_state = P61_STATE_INVALID;
+      eScreenState_t last_screen_state_request = get_lastScreenStateRequest();
+      SecureElement& se = SecureElement::getInstance();
 
-    if (PowerSwitch::getInstance ().getLevel() == PowerSwitch::LOW_POWER)
-    {
-        ALOGV("%s: do not deselect while power is OFF", __func__);
-//        sIsSecElemSelected = false;
-        sIsSecElemSelected--;
-        goto TheEnd;
-    }
+      if (nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION) {
+        if (sIsDisabling || !sIsNfaEnabled || nfcManager_checkNfcStateBusy()) {
+          return NFA_STATUS_FAILED;
+        }
 
-    if (sRfEnabled) {
-        // Stop RF Discovery if we were polling
-        startRfDiscovery (false);
-        bRestartDiscovery = true;
-    }
-    //sIsSecElemSelected = false;
-    //sIsSecElemSelected--;
+        ret_val = NFC_GetP61Status((void*)&p61_current_state);
+        if (ret_val < 0) {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("NFC_GetP61Status failed");
+          return NFA_STATUS_FAILED;
+        }
+        if (p61_current_state & P61_STATE_JCP_DWNLD ||
+            p61_current_state & P61_STATE_WIRED ||
+            p61_current_state & P61_STATE_SPI ||
+            p61_current_state & P61_STATE_SPI_PRIO) {
+          return NFA_STATUS_BUSY;
+        }
 
-    //if controller is not routing to sec elems AND there is no pipe connected,
-    //then turn off the sec elems
-    if (SecureElement::getInstance().isBusy() == false)
-    {
-        //SecureElement::getInstance().deactivate (0xABCDEF);
-        stat = SecureElement::getInstance().deactivate (seId);
-        if(stat)
-        {
-            sIsSecElemSelected--;
-//            RoutingManager::getInstance().commitRouting();
+        if (sIsDisabling || !sIsNfaEnabled || nfcManager_checkNfcStateBusy()) {
+          return NFA_STATUS_FAILED;
         }
-    }
 
-TheEnd:
-     /*
-     * conditional check is added to avoid multiple dicovery cmds
-     * at the time of NFC OFF in progress
-     */
-    if ((gGeneralPowershutDown != NFC_MODE_OFF) && bRestartDiscovery)
-        startRfDiscovery (true);
+        LOG(ERROR) << StringPrintf("%s: start JcopOs_Download 0x%X", __func__,
+                                   p61_current_state);
 
-    //if nothing is active after this, then tell the controller to power down
-    if (! PowerSwitch::getInstance ().setModeOff (PowerSwitch::SE_ROUTING))
-        PowerSwitch::getInstance ().setLevel (PowerSwitch::LOW_POWER);
+        ret_val = NFC_SetP61Status((void*)&ese_status, JCP_DWNLD_START);
+        if (ret_val < 0) {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("NFC_SetP61Status failed");
+        } else {
+          if (ese_status != NFCSTATUS_SUCCESS) {
+            DLOG_IF(INFO, nfc_debug_enabled)
+                << StringPrintf("Denying to set Jcop OS Download state");
+          } else {
+            if (!pTransactionController->transactionAttempt(
+                    TRANSACTION_REQUESTOR(jcosDownload))) {
+              LOG(ERROR) << StringPrintf(
+                  "%s: Transaction in progress. Returning", __func__);
+              return NFA_STATUS_FAILED;
+            }
+          }
+        }
+      }
+      if (sRfEnabled) {
+        // Stop RF Discovery if we were polling
+        startRfDiscovery(false);
+      }
+      DWPChannel_init(&Dwp);
+      status = pJcopMgr->JCDnldInit(&Dwp);
+      if (status != NFA_STATUS_OK) {
+        LOG(ERROR) << StringPrintf("%s: JCDND initialization failed", __func__);
+      } else {
+        LOG(ERROR) << StringPrintf("%s: start JcopOs_Download", __func__);
+        se.mDownloadMode = JCOP_DOWNLOAD;
+        status = pJcopMgr->JCDnldStartDownload();
+      }
+      if (nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION) {
+        ret_val = NFC_SetP61Status((void*)&ese_status, JCP_DWP_DWNLD_COMPLETE);
+        if (ret_val < 0) {
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "NFC_SetP61Status failed Deinit and starting discovery");
+        } else {
+          if (ese_status != NFCSTATUS_SUCCESS) {
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+                "Denying to set Jcop OS Download complete state");
+            status = ese_status;
+          }
+        }
+      }
+      stat = pJcopMgr->JCDnldDeInit();
+      if (nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION) {
+        pTransactionController->transactionEnd(
+            TRANSACTION_REQUESTOR(jcosDownload));
+        if (pendingScreenState == true) {
+          pendingScreenState = false;
+          last_screen_state_request = get_lastScreenStateRequest();
+          nfcManager_doSetScreenState(NULL, NULL, last_screen_state_request);
+        }
+      }
+      startRfDiscovery(true);
+      se.mDownloadMode = NONE;
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: exit; status =0x%X", __func__, status);
+    } else {
+      status = 0x0F;
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: No p61", __func__);
+    }
+#endif
+    return status;
+  }
 
-TheEnd2:
-    ALOGV("%s: exit", __func__);
-}
+#if (NXP_EXTNS == TRUE)
+  uint8_t getJCOPOS_UpdaterState() {
+    static const char fn[] = "getJCOPOS_UpdaterState";
+    if (!nfcFL.nfcNxpEse) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: nfcNxpEse not Enabled. Returning.", fn);
+      return OSU_NOT_STARTED;
+    }
+    FILE* fp;
+    unsigned int val = 0;
+    uint8_t state = 0;
+    int32_t result = 0;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
 
-/*******************************************************************************
-**
-** Function:        nfcManager_getDefaultAidRoute
-**
-** Description:     Get the default Aid Route Entry.
-**                  e: JVM environment.
-**                  o: Java object.
-**                  mode: Not used.
-**
-** Returns:         None
-**
-*******************************************************************************/
-static jint nfcManager_getDefaultAidRoute (JNIEnv* /* e */, jobject /* o */)
-{
-    unsigned long num = 0;
-#if(NXP_EXTNS == TRUE)
-    GetNxpNumValue(NAME_DEFAULT_AID_ROUTE, &num, sizeof(num));
+    fp = fopen(JCOP_INFO_PATH, "r");
+    if (fp != NULL) {
+      result = fscanf(fp, "%u", &val);
+      if (result != 0) {
+        state = (uint8_t)(val & 0x000000FF);
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("JcopOsState %d", state);
+      }
+      fclose(fp);
+    } else {
+      LOG(ERROR) << StringPrintf("file <%s> not exits for reading-: %s",
+                                 JCOP_INFO_PATH, strerror(errno));
+    }
+    return state;
+  }
 #endif
-    return num;
-}
-/*******************************************************************************
-**
-** Function:        nfcManager_getDefaultDesfireRoute
-**
-** Description:     Get the default Desfire Route Entry.
-**                  e: JVM environment.
-**                  o: Java object.
-**                  mode: Not used.
-**
-** Returns:         None
-**
-*******************************************************************************/
-static jint nfcManager_getDefaultDesfireRoute (JNIEnv* /* e */, jobject /* o */)
-{
-    unsigned long num = 0;
-#if(NXP_EXTNS == TRUE)
-    GetNxpNumValue(NAME_DEFAULT_DESFIRE_ROUTE, (void*)&num, sizeof(num));
-    ALOGV("%s: enter; NAME_DEFAULT_DESFIRE_ROUTE = %02lx", __func__, num);
+
+  static void nfcManager_doCommitRouting(JNIEnv * e, jobject o) {
+    (void)e;
+    (void)o;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+    PowerSwitch::getInstance().setLevel(PowerSwitch::FULL_POWER);
+    PowerSwitch::getInstance().setModeOn(PowerSwitch::HOST_ROUTING);
+#if (NXP_EXTNS == TRUE && NXP_NFCC_HCE_F == TRUE)
+    if (!pTransactionController->transactionAttempt(
+            TRANSACTION_REQUESTOR(commitRouting))) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: Not allowing to commit the routing", __func__);
+    } else {
 #endif
-    return num;
-}
-/*******************************************************************************
-**
-** Function:        nfcManager_getDefaultMifareCLTRoute
-**
-** Description:     Get the default mifare CLT Route Entry.
-**                  e: JVM environment.
-**                  o: Java object.
-**                  mode: Not used.
-**
-** Returns:         None
-**
-*******************************************************************************/
-static jint nfcManager_getDefaultMifareCLTRoute (JNIEnv* /* e */, jobject /* o */)
-{
-    unsigned long num = 0;
-#if(NXP_EXTNS == TRUE)
-    GetNxpNumValue(NAME_DEFAULT_MIFARE_CLT_ROUTE, &num, sizeof(num));
+      if (sRfEnabled) {
+        /*Stop RF discovery to reconfigure*/
+        startRfDiscovery(false);
+      }
+      RoutingManager::getInstance().commitRouting();
+      startRfDiscovery(true);
+#if (NXP_EXTNS == TRUE && NXP_NFCC_HCE_F == TRUE)
+      pTransactionController->transactionEnd(
+          TRANSACTION_REQUESTOR(commitRouting));
+    }
 #endif
-    return num;
-}
-#if(NXP_EXTNS == TRUE)
-/*******************************************************************************
-**
-** Function:        nfcManager_getDefaultAidPowerState
-**
-** Description:     Get the default Desfire Power States.
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         Power State
-**
-*******************************************************************************/
-static jint nfcManager_getDefaultAidPowerState (JNIEnv* /* e */, jobject /* o */)
-{
-    unsigned long num = 0;
-    GetNxpNumValue(NAME_DEFAULT_AID_PWR_STATE, &num, sizeof(num));
-    return num;
-}
-
-/*******************************************************************************
-**
-** Function:        nfcManager_getDefaultDesfirePowerState
-**
-** Description:     Get the default Desfire Power States.
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         Power State
-**
-*******************************************************************************/
-static jint nfcManager_getDefaultDesfirePowerState (JNIEnv* /* e */, jobject /* o */)
-{
-    unsigned long num = 0;
-    GetNxpNumValue(NAME_DEFAULT_DESFIRE_PWR_STATE, &num, sizeof(num));
-    return num;
-}
-/*******************************************************************************
-**
-** Function:        nfcManager_getDefaultMifareCLTPowerState
-**
-** Description:     Get the default mifare CLT Power States.
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         Power State
-**
-*******************************************************************************/
-static jint nfcManager_getDefaultMifareCLTPowerState (JNIEnv* /* e */, jobject /* o */)
-{
-    unsigned long num = 0;
-    GetNxpNumValue(NAME_DEFAULT_MIFARE_CLT_PWR_STATE, &num, sizeof(num));
-    return num;
-}
-/*******************************************************************************
-**
-** Function:        nfcManager_setDefaultTechRoute
-**
-** Description:     Setting Default Technology Routing
-**                  e:  JVM environment.
-**                  o:  Java object.
-**                  seId:  SecureElement Id
-**                  tech_swithon:  technology switch_on
-**                  tech_switchoff:  technology switch_off
-**
-** Returns:         None
-**
-*******************************************************************************/
-static void nfcManager_setDefaultTechRoute(JNIEnv* /* e */, jobject /* o */, jint seId,
-        jint tech_switchon, jint tech_switchoff)
-{
-    ALOGV("%s: ENTER", __func__);
-//    tNFA_STATUS status;                   /*commented to eliminate unused variable warning*/
-
-    if (sRfEnabled) {
-        // Stop RF Discovery if we were polling
-        startRfDiscovery (false);
-    }
-    RoutingManager::getInstance().setDefaultTechRouting (seId, tech_switchon, tech_switchoff);
-    // start discovery.
-    startRfDiscovery (true);
-}
-
-/*******************************************************************************
-**
-** Function:        nfcManager_setDefaultProtoRoute
-**
-** Description:     Setting Default Protocol Routing
-**
-**                  e:  JVM environment.
-**                  o:  Java object.
-**                  seId:  SecureElement Id
-**                  proto_swithon:  Protocol switch_on
-**                  proto_switchoff:  Protocol switch_off
-**
-** Returns:         None
-**
-*******************************************************************************/
-static void nfcManager_setDefaultProtoRoute(JNIEnv *e, jobject o, jint seId,
-        jint proto_switchon, jint proto_switchoff)
-{
-    (void)e;
-    (void)o;
-    ALOGV("%s: ENTER", __func__);
-//    tNFA_STATUS status;                   /*commented to eliminate unused variable warning*/
-//    if (sRfEnabled) {
-//        // Stop RF Discovery if we were polling
-//        startRfDiscovery (false);
-//    }
-    RoutingManager::getInstance().setDefaultProtoRouting (seId, proto_switchon, proto_switchoff);
-    // start discovery.
-//    startRfDiscovery (true);
-}
-
-/*******************************************************************************
- **
- ** Function:        nfcManager_setPreferredSimSlot()
- **
- ** Description:     This api is used to select a particular UICC slot.
- **
- **
- ** Returns:         success/failure
- **
- *******************************************************************************/
-static int nfcManager_setPreferredSimSlot(JNIEnv* e, jobject o, jint uiccSlot)
-{
-    ALOGV("%s : uiccslot : %d : enter", __func__, uiccSlot);
-
-    tNFA_STATUS status = NFA_STATUS_OK;
-    if(nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) {
-        sCurrentSelectedUICCSlot = uiccSlot;
-        NFA_SetPreferredUiccId((uiccSlot == 2)?(SecureElement::getInstance().EE_HANDLE_0xF8 & ~NFA_HANDLE_GROUP_EE) : (SecureElement::getInstance().EE_HANDLE_0xF4 & ~NFA_HANDLE_GROUP_EE));
-    }
-    return status;
-}
-
-/*******************************************************************************
-**
-** Function:        nfcManager_isVzwFeatureEnabled
-**
-** Description:     Check vzw feature is enabled or not
-**
-** Returns:         True if the VZW_FEATURE_ENABLE is set.
-**
-*******************************************************************************/
-static bool nfcManager_isVzwFeatureEnabled (JNIEnv* /* e */, jobject /* o */)
-{
-    unsigned int num = 0;
-    bool mStat = false;
-
-    if (GetNxpNumValue("VZW_FEATURE_ENABLE", &num, sizeof(num)))
-    {
-        if(num == 0x01)
-        {
-            mStat = true;
-        }
-        else
-        {
-            mStat = false;
-        }
-    }
-    else{
-        mStat = false;
-    }
-    return mStat;
-}
-/*******************************************************************************
-**
-** Function:        nfcManager_isNfccBusy
-**
-** Description:     Check If NFCC is busy
-**
-** Returns:         True if NFCC is busy.
-**
-*******************************************************************************/
-static bool nfcManager_isNfccBusy(JNIEnv*, jobject)
-{
-    ALOGV("%s: ENTER", __func__);
-    bool statBusy = false;
-    if(SecureElement::getInstance().isBusy())
-    {
-        ALOGE("%s:FAIL  SE wired-mode : busy", __func__);
-        statBusy = true;
-    }
-    else if(rfActivation)
-    {
-        ALOGE("%s:FAIL  RF session ongoing", __func__);
-        statBusy = true;
-    }
-    else if(transaction_data.trans_in_progress)
-    {
-        ALOGE("%s: FAIL Transaction in progress", __func__);
-        statBusy = true;
-    }
-
-    ALOGV("%s: Exit statBusy : 0x%02x", __func__,statBusy);
-    return statBusy;
-}
-#endif
-/*******************************************************************************
-**
-** Function:        isPeerToPeer
-**
-** Description:     Whether the activation data indicates the peer supports NFC-DEP.
-**                  activated: Activation data.
-**
-** Returns:         True if the peer supports NFC-DEP.
-**
-*******************************************************************************/
-static bool isPeerToPeer (tNFA_ACTIVATED& activated)
-{
-    return activated.activate_ntf.protocol == NFA_PROTOCOL_NFC_DEP;
-}
-
-/*******************************************************************************
-**
-** Function:        isListenMode
-**
-** Description:     Indicates whether the activation data indicates it is
-**                  listen mode.
-**
-** Returns:         True if this listen mode.
-**
-*******************************************************************************/
-static bool isListenMode(tNFA_ACTIVATED& activated)
-{
-    return ((NFC_DISCOVERY_TYPE_LISTEN_A == activated.activate_ntf.rf_tech_param.mode)
-            || (NFC_DISCOVERY_TYPE_LISTEN_B == activated.activate_ntf.rf_tech_param.mode)
-            || (NFC_DISCOVERY_TYPE_LISTEN_F == activated.activate_ntf.rf_tech_param.mode)
-            || (NFC_DISCOVERY_TYPE_LISTEN_A_ACTIVE == activated.activate_ntf.rf_tech_param.mode)
-            || (NFC_DISCOVERY_TYPE_LISTEN_F_ACTIVE == activated.activate_ntf.rf_tech_param.mode)
-            || (NFC_DISCOVERY_TYPE_LISTEN_ISO15693 == activated.activate_ntf.rf_tech_param.mode)
-            || (NFC_DISCOVERY_TYPE_LISTEN_B_PRIME == activated.activate_ntf.rf_tech_param.mode)
-            || (NFC_INTERFACE_EE_DIRECT_RF == activated.activate_ntf.intf_param.type));
-}
-
-/*******************************************************************************
-**
-** Function:        nfcManager_doCheckLlcp
-**
-** Description:     Not used.
-**
-** Returns:         True
-**
-*******************************************************************************/
-static jboolean nfcManager_doCheckLlcp(JNIEnv*, jobject)
-{
-    ALOGV("%s", __func__);
-    return JNI_TRUE;
-}
-
-
-static jboolean nfcManager_doCheckJcopDlAtBoot(JNIEnv* /* e */, jobject /* o */)
-{
-    unsigned int num = 0;
-    ALOGV("%s", __func__);
-    if(GetNxpNumValue(NAME_NXP_JCOPDL_AT_BOOT_ENABLE,(void*)&num,sizeof(num))) {
-        if(num == 0x01) {
-            return JNI_TRUE;
-        }
-        else {
-            return JNI_FALSE;
-        }
-    }
-    else {
-        return JNI_FALSE;
-    }
-}
-
-
-/*******************************************************************************
-**
-** Function:        nfcManager_doActivateLlcp
-**
-** Description:     Not used.
-**
-** Returns:         True
-**
-*******************************************************************************/
-static jboolean nfcManager_doActivateLlcp(JNIEnv*, jobject)
-{
-    ALOGV("%s", __func__);
-    return JNI_TRUE;
-}
-
-
-/*******************************************************************************
-**
-** Function:        nfcManager_doAbort
-**
-** Description:     Not used.
-**
-** Returns:         None
-**
-*******************************************************************************/
-static void nfcManager_doAbort(JNIEnv* e, jobject, jstring msg)
-{
-    ScopedUtfChars message = {e, msg};
-    e->FatalError(message.c_str());
-    abort(); // <-- Unreachable
-}
-
-
-/*******************************************************************************
-**
-** Function:        nfcManager_doDownload
-**
-** Description:     Download firmware patch files.  Do not turn on NFC.
-**
-** Returns:         True if ok.
-**
-*******************************************************************************/
-static jboolean nfcManager_doDownload(JNIEnv*, jobject)
-{
-    ALOGV("%s: enter", __func__);
-    NfcAdaptation& theInstance = NfcAdaptation::GetInstance();
-
-    theInstance.Initialize(); //start GKI, NCI task, NFC task
-    theInstance.DownloadFirmware ();
-    theInstance.Finalize();
-    ALOGV("%s: exit", __func__);
-    return JNI_TRUE;
-}
-
-
-/*******************************************************************************
-**
-** Function:        nfcManager_doResetTimeouts
-**
-** Description:     Not used.
-**
-** Returns:         None
-**
-*******************************************************************************/
-static void nfcManager_doResetTimeouts(JNIEnv*, jobject)
-{
-    ALOGV("%s", __func__);
-    NfcTag::getInstance().resetAllTransceiveTimeouts ();
-}
-
-
-/*******************************************************************************
-**
-** Function:        nfcManager_doSetTimeout
-**
-** Description:     Set timeout value.
-**                  e: JVM environment.
-**                  o: Java object.
-**                  tech: technology ID.
-**                  timeout: Timeout value.
-**
-** Returns:         True if ok.
-**
-*******************************************************************************/
-static bool nfcManager_doSetTimeout(JNIEnv*, jobject, jint tech, jint timeout)
-{
-    if (timeout <= 0)
-    {
-        ALOGE("%s: Timeout must be positive.",__func__);
-        return false;
-    }
-    ALOGV("%s: tech=%d, timeout=%d", __func__, tech, timeout);
-
-    NfcTag::getInstance().setTransceiveTimeout (tech, timeout);
-    return true;
-}
-
-
-/*******************************************************************************
-**
-** Function:        nfcManager_doGetTimeout
-**
-** Description:     Get timeout value.
-**                  e: JVM environment.
-**                  o: Java object.
-**                  tech: technology ID.
-**
-** Returns:         Timeout value.
-**
-*******************************************************************************/
-static jint nfcManager_doGetTimeout(JNIEnv*, jobject, jint tech)
-{
-    int timeout = NfcTag::getInstance().getTransceiveTimeout (tech);
-    ALOGV("%s: tech=%d, timeout=%d", __func__, tech, timeout);
-    return timeout;
-}
-
-
-/*******************************************************************************
-**
-** Function:        nfcManager_doDump
-**
-** Description:     Not used.
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         Text dump.
-**
-*******************************************************************************/
-static jstring nfcManager_doDump(JNIEnv* e, jobject)
-{
-    char buffer[100];
-    snprintf(buffer, sizeof(buffer), "libnfc llc error_count=%u", /*libnfc_llc_error_count*/ 0);
-    return e->NewStringUTF(buffer);
-}
-
-
-/*******************************************************************************
-**
-** Function:        nfcManager_doSetP2pInitiatorModes
-**
-** Description:     Set P2P initiator's activation modes.
-**                  e: JVM environment.
-**                  o: Java object.
-**                  modes: Active and/or passive modes.  The values are specified
-**                          in external/libnfc-nxp/inc/phNfcTypes.h.  See
-**                          enum phNfc_eP2PMode_t.
-**
-** Returns:         None.
-**
-*******************************************************************************/
-static void nfcManager_doSetP2pInitiatorModes (JNIEnv *e, jobject o, jint modes)
-{
-    ALOGV("%s: modes=0x%X", __func__, modes);
-    struct nfc_jni_native_data *nat = getNative(e, o);
-
-    tNFA_TECHNOLOGY_MASK mask = 0;
-    if (modes & 0x01) mask |= NFA_TECHNOLOGY_MASK_A;
-    if (modes & 0x02) mask |= NFA_TECHNOLOGY_MASK_F;
-    if (modes & 0x04) mask |= NFA_TECHNOLOGY_MASK_F;
-    if (modes & 0x08) mask |= NFA_TECHNOLOGY_MASK_A_ACTIVE;
-    if (modes & 0x10) mask |= NFA_TECHNOLOGY_MASK_F_ACTIVE;
-    if (modes & 0x20) mask |= NFA_TECHNOLOGY_MASK_F_ACTIVE;
-    nat->tech_mask = mask;
-}
-
-#if(NXP_EXTNS == TRUE)
-/*******************************************************************************
-**
-** Function:        nfcManager_getRouting
-**
-** Description:     Get Routing Table information.
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         Current routing Settings.
-**
-*******************************************************************************/
-static jbyteArray nfcManager_getRouting (JNIEnv *e, jobject /* o */)
-{
-    ALOGV("%s : Enter", __func__);
-    jbyteArray jbuff = NULL;
-    if (sRfEnabled) {
-        // Stop RF Discovery if we were polling
-        startRfDiscovery (false);
-    }
-    SyncEventGuard guard (sNfaGetRoutingEvent);
-    sRoutingBuffLen = 0;
-    RoutingManager::getInstance().getRouting();
-    sNfaGetRoutingEvent.wait ();
-    if(sRoutingBuffLen > 0)
-    {
-        jbuff = e->NewByteArray (sRoutingBuffLen);
-        e->SetByteArrayRegion (jbuff, 0, sRoutingBuffLen, (jbyte*) sRoutingBuff);
-    }
-
-    startRfDiscovery(true);
-    return jbuff;
-}
-
-/*******************************************************************************
-**
-** Function:        nfcManager_getNfcInitTimeout
-**
-** Description:     Gets the chip version.
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         timeout in seconds
-**
-*******************************************************************************/
-static int nfcManager_getNfcInitTimeout(JNIEnv* e, jobject o)
-{
-    (void)e;
-    (void)o;
-    ALOGV("%s: enter", __func__);
-    unsigned long disc_timeout =0;
-    unsigned long session_id_timeout =0;
-    disc_timeout = 0;
-    gNfcInitTimeout = 0;
-    gdisc_timeout = 0;
-
-    if(GetNxpNumValue(NAME_NXP_DEFAULT_NFCEE_DISC_TIMEOUT, (void *)&disc_timeout, sizeof(disc_timeout))==false)
-    {
-        ALOGV("NAME_NXP_DEFAULT_NFCEE_DISC_TIMEOUT not found");
-        disc_timeout = 0;
-    }
-    if(GetNxpNumValue(NAME_NXP_DEFAULT_NFCEE_TIMEOUT, (void *)&session_id_timeout,
-            sizeof(session_id_timeout))==false)
-    {
-        ALOGV("NAME_NXP_DEFAULT_NFCEE_TIMEOUT not found");
-        session_id_timeout = 0;
-    }
-
-    gNfcInitTimeout = (disc_timeout + session_id_timeout) *1000;
-    gdisc_timeout = disc_timeout *1000;
-
-    ALOGV(" gNfcInitTimeout = %ld: gdisc_timeout = %ld nfcManager_getNfcInitTimeout",
-            gNfcInitTimeout, gdisc_timeout);
-    return gNfcInitTimeout;
-}
-
-#endif
-
-/*******************************************************************************
-**
-** Function:        nfcManager_doSetP2pTargetModes
-**
-** Description:     Set P2P target's activation modes.
-**                  e: JVM environment.
-**                  o: Java object.
-**                  modes: Active and/or passive modes.
-**
-** Returns:         None.
-**
-*******************************************************************************/
-static void nfcManager_doSetP2pTargetModes (JNIEnv*, jobject, jint modes)
-{
-    ALOGV("%s: modes=0x%X", __func__, modes);
-    // Map in the right modes
-    tNFA_TECHNOLOGY_MASK mask = 0;
-    if (modes & 0x01) mask |= NFA_TECHNOLOGY_MASK_A;
-    if (modes & 0x02) mask |= NFA_TECHNOLOGY_MASK_F;
-    if (modes & 0x04) mask |= NFA_TECHNOLOGY_MASK_F;
-    if (modes & 0x08) mask |= NFA_TECHNOLOGY_MASK_A_ACTIVE | NFA_TECHNOLOGY_MASK_F_ACTIVE;
-
-    PeerToPeer::getInstance().setP2pListenMask(mask);
-}
-
-#if(NXP_EXTNS == TRUE)
-/*******************************************************************************
-**
-** Function:        nfcManager_dosetEtsiReaederState
-**
-** Description:     Set ETSI reader state
-**                  e: JVM environment.
-**                  o: Java object.
-**                  newState : new state to be set
-**
-** Returns:         None.
-**
-*******************************************************************************/
-static void nfcManager_dosetEtsiReaederState (JNIEnv*, jobject, se_rd_req_state_t newState)
-{
-    ALOGV("%s: Enter ", __func__);
-    if(nfcFL.nfcNxpEse && nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
-     RoutingManager::getInstance().setEtsiReaederState(newState);
-    }
-}
-
-/*******************************************************************************
-**
-** Function:        nfcManager_dogetEtsiReaederState
-**
-** Description:     Get current ETSI reader state
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         State.
-**
-*******************************************************************************/
-static int nfcManager_dogetEtsiReaederState (JNIEnv*, jobject)
-{
-    ALOGV("%s: Enter ", __func__);
-    if(nfcFL.nfcNxpEse && nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
-        return RoutingManager::getInstance().getEtsiReaederState();
-    }
-    else {
-        return STATE_SE_RDR_MODE_STOPPED;
-    }
-}
-
-/*******************************************************************************
-**
-** Function:        nfcManager_doEtsiReaderConfig
-**
-** Description:     Configuring to Emvco profile
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         None.
-**
-*******************************************************************************/
-static void nfcManager_doEtsiReaderConfig (JNIEnv*, jobject, int eeHandle)
-{
-    tNFC_STATUS status;
-    ALOGV("%s: Enter ", __func__);
-    if(nfcFL.nfcNxpEse && nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
-        status = SecureElement::getInstance().etsiReaderConfig(eeHandle);
-        if(status != NFA_STATUS_OK)
-        {
-            ALOGV("%s: etsiReaderConfig Failed ", __func__);
-        }
-        else
-        {
-            ALOGV("%s: etsiReaderConfig Success ", __func__);
-        }
-    }
-}
-
-/*******************************************************************************
-**
-** Function:        nfcManager_doEtsiResetReaderConfig
-**
-** Description:     Configuring to Nfc forum profile
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         None.
-**
-*******************************************************************************/
-static void nfcManager_doEtsiResetReaderConfig (JNIEnv*, jobject)
-{
-    tNFC_STATUS status;
-    ALOGV("%s: Enter ", __func__);
-    if(nfcFL.nfcNxpEse && nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
-        status = SecureElement::getInstance().etsiResetReaderConfig();
-        if(status != NFA_STATUS_OK)
-        {
-            ALOGV("%s: etsiReaderConfig Failed ", __func__);
-        }
-        else
-        {
-            ALOGV("%s: etsiReaderConfig Success ", __func__);
-        }
-    }
-}
-
-/*******************************************************************************
-**
-** Function:        nfcManager_doNotifyEEReaderEvent
-**
-** Description:     Notify with the Reader event
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         None.
-**
-*******************************************************************************/
-static void nfcManager_doNotifyEEReaderEvent (JNIEnv*, jobject, int evt)
-{
-    ALOGV("%s: Enter ", __func__);
-    if(nfcFL.nfcNxpEse && nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
-        SecureElement::getInstance().notifyEEReaderEvent(
-                evt,swp_rdr_req_ntf_info.swp_rd_req_info.tech_mask);
-    }
-}
-
-/*******************************************************************************
-**
-** Function:        nfcManager_doEtsiInitConfig
-**
-** Description:     Chnage the ETSI state before start configuration
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         None.
-**
-*******************************************************************************/
-static void nfcManager_doEtsiInitConfig (JNIEnv*, jobject, int /* evt */)
-{
-    ALOGV("%s: Enter ", __func__);
-    if(nfcFL.nfcNxpEse && nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
-        SecureElement::getInstance().etsiInitConfig();
-    }
-}
-#endif
-
-static void nfcManager_doEnableScreenOffSuspend(JNIEnv* /* e */, jobject /* o */)
-{
-    PowerSwitch::getInstance().setScreenOffPowerState(PowerSwitch::POWER_STATE_FULL);
-}
-
-static void nfcManager_doDisableScreenOffSuspend(JNIEnv* /* e */, jobject /* o */)
-{
-    PowerSwitch::getInstance().setScreenOffPowerState(PowerSwitch::POWER_STATE_OFF);
-}
-#if(NXP_EXTNS == TRUE)
-/*******************************************************************************
-**
-** Function:        nfcManager_doUpdateScreenState
-**
-** Description:     Update If any Pending screen state is present
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         None.
-**
-*******************************************************************************/
-static void nfcManager_doUpdateScreenState(JNIEnv* /* e */, jobject /* o */)
-{
-    ALOGV("%s: Enter ", __func__);
-    if(nfcFL.nfcNxpEse && nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
-        eScreenState_t last_screen_state_request;
-
-        if(pendingScreenState == true)
-        {
-            ALOGV("%s: pendingScreenState = true ", __func__);
-            pendingScreenState = false;
-            last_screen_state_request = get_lastScreenStateRequest();
-            nfcManager_doSetScreenState(NULL,NULL,last_screen_state_request);
-        }
-        else
-        {
-            ALOGV("%s: pendingScreenState = false ", __func__);
-        }
-    }
-}
-
-/*******************************************************************************
- **
- ** Function:        nfcManager_doSelectUicc()
- **
- ** Description:     Issue any single TLV set config command as per input
- ** register values and bit values
- **
- ** Returns:         success/failure
- **
- *******************************************************************************/
-static int nfcManager_doSelectUicc(JNIEnv* e, jobject o, jint uiccSlot)
-{
-    (void)e;
-    (void)o;
-    uint8_t retStat = STATUS_UNKNOWN_ERROR;
-    if(nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
-        tNFA_STATUS status = NFC_STATUS_FAILED;
-        ALOGV("%s: enter", __func__);
-        ALOGV("%s: sUicc1CntxLen : 0x%02x  sUicc2CntxLen : 0x%02x", __func__,dualUiccInfo.sUicc1CntxLen,dualUiccInfo.sUicc2CntxLen);
-        uint16_t RegAddr = 0xA0EC;
-        uint8_t bitVal;
-        eScreenState_t last_screen_state_request;
-        dualUiccInfo.uiccConfigStat = UICC_NOT_CONFIGURED;
-
-        RoutingManager& routingManager = RoutingManager::getInstance();
-        SecureElement &se = SecureElement::getInstance();
-
-        retStat = nfcManager_staticDualUicc_Precondition(uiccSlot);
-
-        if(retStat != UICC_NOT_CONFIGURED)
-        {
-            goto endSwitch;
-        }
-
-        if(sRfEnabled)
-        {
-            startRfDiscovery(false);
-        }
-
-        bitVal = ((0x10) | uiccSlot);
-
-        getUiccContext(uiccSlot);
-
-        if((dualUiccInfo.sUicc1CntxLen !=0)||(dualUiccInfo.sUicc2CntxLen !=0))
-        {
-
-            if((bitVal == 0x11)&&(dualUiccInfo.sUicc1CntxLen !=0))
-            {
-                ALOGV("%s : update uicc1 context information ", __func__);
-                uint8_t cfg[256] = {0x20,0x02};
-
-                memcpy(cfg+3, dualUiccInfo.sUicc1Cntx, dualUiccInfo.sUicc1CntxLen);
-                cfg[2] = dualUiccInfo.sUicc1CntxLen-1;
-                status = NxpNfc_Write_Cmd_Common(dualUiccInfo.sUicc1CntxLen+2, cfg);
-
-                memcpy(cfg+3, dualUiccInfo.sUicc1TechCapblty, 10);
-                cfg[2] = 9;
-                status = NxpNfc_Write_Cmd_Common(12, cfg);
-
-            }
-            else  if((bitVal == 0x12)&&(dualUiccInfo.sUicc2CntxLen !=0))
-            {
-                ALOGV("%s : update uicc2 context information", __func__);
-                uint8_t cfg[256] = {0x20,0x02};
-                memcpy(cfg+3, dualUiccInfo.sUicc2Cntx, dualUiccInfo.sUicc2CntxLen);
-                cfg[2] = dualUiccInfo.sUicc2CntxLen-1;
-                status = NxpNfc_Write_Cmd_Common(dualUiccInfo.sUicc2CntxLen+2, cfg);
-
-                memcpy(cfg+3, dualUiccInfo.sUicc2TechCapblty, 10);
-                cfg[2] = 9;
-                status = NxpNfc_Write_Cmd_Common(12, cfg);
-            }
-        }
-
-        /*Update NFCC SWIO line accordingly*/
-        if((Set_EERegisterValue(RegAddr, bitVal) != NFCSTATUS_OK))
-        {
-            retStat = DUAL_UICC_ERROR_SELECT_FAILED;
-            ALOGE("%s : Set_EERegisterValue Failed", __func__);
-            goto endSwitch;
-        }
-
-        /*Mode Set Off for UICC*/
-        {
-            SyncEventGuard guard (routingManager.mEeSetModeEvent);
-            if ((NFA_EeModeSet (0x02, NFA_EE_MD_DEACTIVATE)) == NFA_STATUS_OK)
-            {
-                routingManager.mEeSetModeEvent.wait (); //wait for NFA_EE_MODE_SET_EVT
-            }
-            else
-            {
-                ALOGE("%s : Failed to set EE inactive", __func__);
-                goto endSwitch;
-            }
-        }
-        gSeDiscoverycount  = 0;
-        /*Perform HAL re-initialisation
-         * NFA EE and HCI Subsystem de-init*/
-        {
-            SyncEventGuard guard (sNfceeHciCbDisableEvent);
-            NFA_EE_HCI_Control(false);
-            ALOGV("sNfceeHciCbDisableEvent waiting ......");
-            if(sNfceeHciCbDisableEvent.wait(500) == false)
-            {
-                ALOGV("sNfceeHciCbDisableEvent.wait Timeout happened");
-            }else{
-                ALOGV("sNfceeHciCbDisableEvent.wait success");
-            }
-
-        }
-
-        /*Reset Nfcc*/
-        status = NFA_ResetNfcc();
-        /*Perform NFA EE and HCI Subsystem initialisation*/
-        {
-            SyncEventGuard guard (sNfceeHciCbEnableEvent);
-            NFA_EE_HCI_Control(true);
-            ALOGV("sNfceeHciCbEnableEvent waiting ......");
-            if(sNfceeHciCbEnableEvent.wait(500) == false)
-            {
-                ALOGV("sNfceeHciCbEnableEvent.wait Timeout happened");
-            }else{
-                ALOGV("sNfceeHciCbEnableEvent.wait success");
-            }
-        }
-
-        {
-            se.updateEEStatus();
-            //setListenMode();
-            routingManager.initialize(getNative(e, o));
-            HciRFParams::getInstance().initialize ();
-            sIsSecElemSelected = (se.getActualNumEe() - 1 );
-            sIsSecElemDetected = sIsSecElemSelected;
-        }
-
-        ALOGV("%s : gSeDiscoverycount = %ld", __func__ , gSeDiscoverycount);
-        {
-            SyncEventGuard g(gNfceeDiscCbEvent);
-            /*Get the SWP1 and SWP2 lines status*/
-            if (NFA_STATUS_OK == GetNumNFCEEConfigured())
-            {
-                /*The SWP lines enabled and SE's discovered*/
-                if (gSeDiscoverycount < gActualSeCount)
-                {
-                    ALOGV("%s : Wait for ESE to discover, gdisc_timeout = %ld", __func__, gdisc_timeout);
-                    if(gNfceeDiscCbEvent.wait(gdisc_timeout) == false)
-                    {
-                        ALOGE("%s: timeout waiting for nfcee dis event", __func__);
-                    }
-                }
-                else
-                {
-                    ALOGV("%s : All ESE are discovered ", __func__);
-                }
-            }
-        }
-        /*Get the eSE and UICC parameters for RF*/
-        checkforNfceeConfig(UICC1 | UICC2 | ESE);
-
-        if(se.getEeStatus(se.EE_HANDLE_0xF4) == NFC_NFCEE_STATUS_REMOVED)
-        {
-            ALOGV("%s : UICC 0x%02x status : NFC_NFCEE_STATUS_REMOVED. Clearing buffer", __func__,sSelectedUicc);
-            if((sSelectedUicc == 0x01)&&(dualUiccInfo.sUicc1CntxLen != 0x00))
-            {
-                memset(dualUiccInfo.sUicc1Cntx,0x00,sizeof(dualUiccInfo.sUicc1Cntx));
-                memset(dualUiccInfo.sUicc1TechCapblty,0x00,10);
-                dualUiccInfo.sUicc1CntxLen = 0x00;
-                write_uicc_context(dualUiccInfo.sUicc1Cntx,  dualUiccInfo.sUicc1CntxLen, dualUiccInfo.sUicc1TechCapblty, 10, 1, sSelectedUicc);
-            }
-            else if((sSelectedUicc == 0x02)&&(dualUiccInfo.sUicc2CntxLen != 0x00))
-            {
-                memset(dualUiccInfo.sUicc2Cntx,0x00,sizeof(dualUiccInfo.sUicc2Cntx));
-                memset(dualUiccInfo.sUicc2TechCapblty,0x00,10);
-                dualUiccInfo.sUicc2CntxLen = 0x00;
-                write_uicc_context(dualUiccInfo.sUicc2Cntx,  dualUiccInfo.sUicc2CntxLen, dualUiccInfo.sUicc2TechCapblty, 10, 1, sSelectedUicc);
-            }
-        }
-
-        retStat = dualUiccInfo.uiccConfigStat;
-
-        endSwitch:
-        if((retStat == UICC_CONFIGURED) || (retStat == UICC_NOT_CONFIGURED))
-        {
-            pTransactionController->transactionEnd(TRANSACTION_REQUESTOR(staticDualUicc));
-            /*Apply screen state if pending*/
-            ALOGV("%s: Apply screen state if pending", __func__);
-            if(pendingScreenState == true)
-            {
-                pendingScreenState = false;
-                last_screen_state_request = get_lastScreenStateRequest();
-                nfcManager_doSetScreenState(NULL,NULL,last_screen_state_request);
-            }
-            else
-            {
-                ALOGE("%s: Can not reset transaction state", __func__);
-            }
-        }
-
-        /*If retStat is success then routing table will be reconfigured from NfcService
-         * As a part of commitRouting startRfDiscovery will be called.
-         * If retStat is failed then NfcService will not reconfigured routing table
-         * So do startRfDiscovery here*/
-        if((retStat != UICC_CONFIGURED) && (retStat != UICC_NOT_CONFIGURED) && (!sRfEnabled))
-        {
-            startRfDiscovery(true);
-        }
-
-        ALOGV("%s: exit retStat = %d", __func__, retStat);
-    }
-    else if(nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) {
-        retStat = nfcManager_staticDualUicc_Precondition(uiccSlot);
-
-        if(retStat != UICC_NOT_CONFIGURED)
-        {
-            ALOGV("staticDualUicc_Precondition failed.");
-            return retStat;
-        }
-
-        nfcManager_setPreferredSimSlot(NULL, NULL,uiccSlot);
-        retStat = UICC_CONFIGURED;
-        RoutingManager::getInstance().cleanRouting();
-       pTransactionController->transactionEnd(TRANSACTION_REQUESTOR(staticDualUicc));
-    }
-    else
-    {
-        retStat = DUAL_UICC_FEATURE_NOT_AVAILABLE;
-        ALOGV("%s: Dual uicc not supported retStat = %d", __func__, retStat);
-    }
-    return retStat;
-}
-
-/*******************************************************************************
- **
- ** Function:        nfcManager_doGetSelectedUicc()
- **
- ** Description:     get the current selected active UICC
- **
- ** Returns:         UICC id
- **
- *******************************************************************************/
-static int nfcManager_doGetSelectedUicc(JNIEnv* e, jobject o)
-{
-    uint8_t uicc_stat = STATUS_UNKNOWN_ERROR;
-    if(nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
-        ALOGV("%s: enter ",__func__);
-        uicc_stat = SecureElement::getInstance().getUiccStatus(sSelectedUicc);
-    }
-    else if(nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) {
-        uicc_stat = SecureElement::getInstance().getUiccStatus(sCurrentSelectedUICCSlot);
-    }
-    else {
-        ALOGV("%s: dual uicc not supported ",__func__);
-        uicc_stat = DUAL_UICC_FEATURE_NOT_AVAILABLE;
-    }
-    return uicc_stat;
-}
-#endif
-
-/*****************************************************************************
-**
-** JNI functions for android-4.0.1_r1
-**
-*****************************************************************************/
-static JNINativeMethod gMethods[] =
-{
-    {"doDownload", "()Z",
-            (void *)nfcManager_doDownload},
-
-    {"initializeNativeStructure", "()Z",
-            (void*) nfcManager_initNativeStruc},
-
-    {"doInitialize", "()Z",
-            (void*) nfcManager_doInitialize},
-
-    {"doDeinitialize", "()Z",
-            (void*) nfcManager_doDeinitialize},
-
-    {"sendRawFrame", "([B)Z",
-            (void*) nfcManager_sendRawFrame},
-
-    {"doRouteAid", "([BIII)Z",
-            (void*) nfcManager_routeAid},
-
-    {"doUnrouteAid", "([B)Z",
-            (void*) nfcManager_unrouteAid},
-
-    {"doSetRoutingEntry", "(IIII)Z",
-            (void*)nfcManager_setRoutingEntry},
-
-    {"doClearRoutingEntry", "(I)Z",
-            (void*)nfcManager_clearRoutingEntry},
-
-    {"clearAidTable", "()Z",
-            (void*) nfcManager_clearAidTable},
-
-    {"setDefaultRoute", "(III)Z",
-            (void*) nfcManager_setDefaultRoute},
-
-    {"getAidTableSize", "()I",
-            (void*) nfcManager_getAidTableSize},
-
-    {"getRemainingAidTableSize", "()I",
-            (void*) nfcManager_getRemainingAidTableSize},
-
-    {"getDefaultAidRoute", "()I",
-            (void*) nfcManager_getDefaultAidRoute},
-
-    {"getDefaultDesfireRoute", "()I",
-            (void*) nfcManager_getDefaultDesfireRoute},
-
-    {"getDefaultMifareCLTRoute", "()I",
-            (void*) nfcManager_getDefaultMifareCLTRoute},
-#if(NXP_EXTNS == TRUE)
-    {"getDefaultAidPowerState", "()I",
-            (void*) nfcManager_getDefaultAidPowerState},
-
-    {"getDefaultDesfirePowerState", "()I",
-            (void*) nfcManager_getDefaultDesfirePowerState},
-
-    {"getDefaultMifareCLTPowerState", "()I",
-            (void*) nfcManager_getDefaultMifareCLTPowerState},
-#endif
-    {"doRegisterT3tIdentifier", "([B)I",
-            (void*) nfcManager_doRegisterT3tIdentifier},
-
-    {"doDeregisterT3tIdentifier", "(I)V",
-            (void*) nfcManager_doDeregisterT3tIdentifier},
-
-    {"getLfT3tMax", "()I",
-            (void*) nfcManager_getLfT3tMax},
-
-    {"doEnableDiscovery", "(IZZZZ)V",
-            (void*) nfcManager_enableDiscovery},
-
-    {"doGetSecureElementList", "()[I",
-            (void *)nfcManager_doGetSecureElementList},
-
-    {"doSelectSecureElement", "(I)V",
-            (void *)nfcManager_doSelectSecureElement},
-
-    {"doDeselectSecureElement", "(I)V",
-            (void *)nfcManager_doDeselectSecureElement},
-
-    {"doSetSEPowerOffState", "(IZ)V",
-            (void *)nfcManager_doSetSEPowerOffState},
-    {"setDefaultTechRoute", "(III)V",
-            (void *)nfcManager_setDefaultTechRoute},
-
-    {"setDefaultProtoRoute", "(III)V",
-            (void *)nfcManager_setDefaultProtoRoute},
-
-    {"GetDefaultSE", "()I",
-            (void *)nfcManager_GetDefaultSE},
-
-    {"doCheckLlcp", "()Z",
-            (void *)nfcManager_doCheckLlcp},
-
-    {"doActivateLlcp", "()Z",
-            (void *)nfcManager_doActivateLlcp},
-
-    {"doCreateLlcpConnectionlessSocket", "(ILjava/lang/String;)Lcom/android/nfc/dhimpl/NativeLlcpConnectionlessSocket;",
-            (void *)nfcManager_doCreateLlcpConnectionlessSocket},
-
-    {"doCreateLlcpServiceSocket", "(ILjava/lang/String;III)Lcom/android/nfc/dhimpl/NativeLlcpServiceSocket;",
-            (void*) nfcManager_doCreateLlcpServiceSocket},
-
-    {"doCreateLlcpSocket", "(IIII)Lcom/android/nfc/dhimpl/NativeLlcpSocket;",
-            (void*) nfcManager_doCreateLlcpSocket},
-
-    {"doGetLastError", "()I",
-            (void*) nfcManager_doGetLastError},
-
-    {"disableDiscovery", "()V",
-            (void*) nfcManager_disableDiscovery},
-
-    {"doSetTimeout", "(II)Z",
-            (void *)nfcManager_doSetTimeout},
-
-    {"doGetTimeout", "(I)I",
-            (void *)nfcManager_doGetTimeout},
-
-    {"doResetTimeouts", "()V",
-            (void *)nfcManager_doResetTimeouts},
-
-    {"doAbort", "(Ljava/lang/String;)V",
-            (void *)nfcManager_doAbort},
-
-    {"doSetP2pInitiatorModes", "(I)V",
-            (void *)nfcManager_doSetP2pInitiatorModes},
-
-    {"doSetP2pTargetModes", "(I)V",
-            (void *)nfcManager_doSetP2pTargetModes},
-
-    {"doEnableScreenOffSuspend", "()V",
-            (void *)nfcManager_doEnableScreenOffSuspend},
-
-    {"doDisableScreenOffSuspend", "()V",
-            (void *)nfcManager_doDisableScreenOffSuspend},
-
-    {"doDump", "()Ljava/lang/String;",
-            (void *)nfcManager_doDump},
-
-    {"getChipVer", "()I",
-             (void *)nfcManager_getChipVer},
-
-    {"getFwFileName", "()[B",
-            (void *)nfcManager_getFwFileName},
-
-    {"JCOSDownload", "()I",
-            (void *)nfcManager_doJcosDownload},
-    {"doCommitRouting", "()V",
-            (void *)nfcManager_doCommitRouting},
-#if(NXP_EXTNS == TRUE)
-    {"doSetNfcMode", "(I)V",
-            (void *)nfcManager_doSetNfcMode},
-#endif
-    {"doGetSecureElementTechList", "()I",
-            (void *)nfcManager_getSecureElementTechList},
-
-    {"doGetActiveSecureElementList", "()[I",
-            (void *)nfcManager_getActiveSecureElementList},
-
-    {"doGetSecureElementUid", "()[B",
-            (void *)nfcManager_getSecureElementUid},
-
-    {"setEmvCoPollProfile", "(ZI)I",
-            (void *)nfcManager_setEmvCoPollProfile},
-
-    {"doSetSecureElementListenTechMask", "(I)V",
-            (void *)nfcManager_setSecureElementListenTechMask},
-    {"getNciVersion","()I",
-            (void *)nfcManager_doGetNciVersion},
-    {"doSetScreenState", "(I)V",
-            (void*)nfcManager_doSetScreenState},
-    {"doSetScreenOrPowerState", "(I)V",
-            (void*)nfcManager_doSetScreenOrPowerState},
-    //Factory Test Code
-    {"doPrbsOn", "(IIII)V",
-            (void *)nfcManager_doPrbsOn},
-    {"doPrbsOff", "()V",
-            (void *)nfcManager_doPrbsOff},
-    // SWP self test
-    {"SWPSelfTest", "(I)I",
-            (void *)nfcManager_SWPSelfTest},
-    // check firmware version
-    {"getFWVersion", "()I",
-            (void *)nfcManager_getFwVersion},
-#if(NXP_EXTNS == TRUE)
-    {"setEtsiReaederState", "(I)V",
-        (void *)nfcManager_dosetEtsiReaederState},
-
-    {"getEtsiReaederState", "()I",
-        (void *)nfcManager_dogetEtsiReaederState},
-
-    {"etsiReaderConfig", "(I)V",
-            (void *)nfcManager_doEtsiReaderConfig},
-
-    {"etsiResetReaderConfig", "()V",
-            (void *)nfcManager_doEtsiResetReaderConfig},
-
-    {"notifyEEReaderEvent", "(I)V",
-            (void *)nfcManager_doNotifyEEReaderEvent},
-
-    {"etsiInitConfig", "()V",
-            (void *)nfcManager_doEtsiInitConfig},
-
-    {"updateScreenState", "()V",
-            (void *)nfcManager_doUpdateScreenState},
-#endif
-#if(NXP_EXTNS == TRUE)
-    {"doEnablep2p", "(Z)V",
-            (void*)nfcManager_Enablep2p},
-    {"doSetProvisionMode", "(Z)V",
-            (void *)nfcManager_setProvisionMode},
-    {"doGetRouting", "()[B",
-            (void *)nfcManager_getRouting},
-    {"getNfcInitTimeout", "()I",
-             (void *)nfcManager_getNfcInitTimeout},
-    {"isVzwFeatureEnabled", "()Z",
-            (void *)nfcManager_isVzwFeatureEnabled},
-    {"isNfccBusy", "()Z",
-            (void *)nfcManager_isNfccBusy},
-#endif
-    {"doSetEEPROM", "([B)V",
-            (void*)nfcManager_doSetEEPROM},
-    {"doGetSeInterface","(I)I",
-            (void*)nfcManager_doGetSeInterface},
-    //Factory Test Code
-    {"doCheckJcopDlAtBoot", "()Z",
-            (void *)nfcManager_doCheckJcopDlAtBoot},
-    {"doEnableDtaMode", "()V",
-            (void*) nfcManager_doEnableDtaMode},
-    {"doDisableDtaMode", "()V",
-            (void*) nfcManager_doDisableDtaMode},
-    {"doFactoryReset", "()V", (void*)nfcManager_doFactoryReset},
-    {"doShutdown", "()V", (void*)nfcManager_doShutdown},
-    {"getAdditionalConfigOptions", "()[B",
-            (void *)nfcManager_getAdditionalConfigOptions}
-#if(NXP_EXTNS == TRUE)
-    ,{"doselectUicc", "(I)I",
-            (void*) nfcManager_doSelectUicc},
-     {"doGetSelectedUicc", "()I",
-            (void*) nfcManager_doGetSelectedUicc},
-     {"setPreferredSimSlot", "(I)I",
-            (void *)nfcManager_setPreferredSimSlot},
-     {"routeApduPattern", "(II[B[B)Z",
-                    (void*) nfcManager_routeApduPattern},
-     {"unrouteApduPattern", "([B)Z",
-                    (void*) nfcManager_unrouteApduPattern}
-#endif
-};
-
-
-/*******************************************************************************
-**
-** Function:        register_com_android_nfc_NativeNfcManager
-**
-** Description:     Regisgter JNI functions with Java Virtual Machine.
-**                  e: Environment of JVM.
-**
-** Returns:         Status of registration.
-**
-*******************************************************************************/
-int register_com_android_nfc_NativeNfcManager (JNIEnv *e)
-{
-    ALOGV("%s: enter", __func__);
-    PowerSwitch::getInstance ().initialize (PowerSwitch::UNKNOWN_LEVEL);
-    ALOGV("%s: exit", __func__);
-    return jniRegisterNativeMethods (e, gNativeNfcManagerClassName, gMethods, NELEM (gMethods));
-}
-
-
-/*******************************************************************************
-**
-** Function:        startRfDiscovery
-**
-** Description:     Ask stack to start polling and listening for devices.
-**                  isStart: Whether to start.
-**
-** Returns:         None
-**
-*******************************************************************************/
-void startRfDiscovery(bool isStart)
-{
-#if(NXP_EXTNS == TRUE)
-    tNFA_STATUS status = NFA_STATUS_FAILED;
-    if(sAutonomousSet == 1) {
-        ALOGV("Autonomous mode set don't start RF disc %d",isStart);
-        return;
-    }
-    if((!gsRouteUpdated) && isStart) {
-        ALOGV("%s: Routing table update pending.Can not start RF disc. Returning..",__FUNCTION__);
-        return;
-    }
-    if(isStart == sRfEnabled) {
-        ALOGD("%s Already in RF state: %d", __FUNCTION__, isStart);
-        return;
-    }
-    if(nfcFL.nfcNxpEse && nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) {
-        gDiscMutex.lock();
-    }
-#endif
-    ALOGV("%s: is start=%d", __func__, isStart);
-    SyncEventGuard guard (sNfaEnableDisablePollingEvent);
-    status  = isStart ? NFA_StartRfDiscovery () : NFA_StopRfDiscovery ();
-    if (status == NFA_STATUS_OK) {
-        if(gGeneralPowershutDown == NFC_MODE_OFF)
-            sDiscCmdwhleNfcOff = true;
-        sNfaEnableDisablePollingEvent.wait (NFC_CMD_TIMEOUT); //wait for NFA_RF_DISCOVERY_xxxx_EVT
-        sRfEnabled = isStart;
-        sDiscCmdwhleNfcOff = false;
-    }
-    else {
-        ALOGE("%s: Failed to start/stop RF discovery; error=0x%X", __func__, status);
-    }
-#if(NXP_EXTNS == TRUE)
-    if(nfcFL.nfcNxpEse && nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) {
-        gDiscMutex.unlock();
-    }
-#endif
-    ALOGV("%s: is exit=%d", __func__, isStart);
-}
-
-/*******************************************************************************
- **
-** Function:        isDiscoveryStarted
-**
-** Description:     Indicates whether the discovery is started.
-**
-** Returns:         True if discovery is started
-**
-*******************************************************************************/
-bool isDiscoveryStarted ()
-{
-    return sRfEnabled;
-}
-
-/*******************************************************************************
-**
-** Function:        notifyPollingEventwhileNfcOff
-**
-** Description:     Notifies sNfaEnableDisablePollingEvent if tag operations
-**                  is in progress at the time Nfc Off is in progress to avoid
-**                  NFC off thread infinite block.
-**
-** Returns:         None
-**
-*******************************************************************************/
-static void notifyPollingEventwhileNfcOff()
-{
-    ALOGV("%s: sDiscCmdwhleNfcOff=%x", __func__, sDiscCmdwhleNfcOff);
-    if(sDiscCmdwhleNfcOff == true)
-    {
-        SyncEventGuard guard (sNfaEnableDisablePollingEvent);
-        sNfaEnableDisablePollingEvent.notifyOne ();
-    }
-}
-
-/*******************************************************************************
-**
-** Function:        doStartupConfig
-**
-** Description:     Configure the NFC controller.
-**
-** Returns:         None
-**
-*******************************************************************************/
-void doStartupConfig()
-{
-    struct nfc_jni_native_data *nat = getNative(0, 0);
-    tNFA_STATUS stat = NFA_STATUS_FAILED;
-    int actualLen = 0;
-
-    // If polling for Active mode, set the ordering so that we choose Active over Passive mode first.
-    if (nat && (nat->tech_mask & (NFA_TECHNOLOGY_MASK_A_ACTIVE | NFA_TECHNOLOGY_MASK_F_ACTIVE)))
-    {
-        uint8_t  act_mode_order_param[] = { 0x01 };
-        SyncEventGuard guard (sNfaSetConfigEvent);
-        stat = NFA_SetConfig(NCI_PARAM_ID_ACT_ORDER, sizeof(act_mode_order_param), &act_mode_order_param[0]);
-        if (stat == NFA_STATUS_OK)
-            sNfaSetConfigEvent.wait ();
-    }
-
-    //configure RF polling frequency for each technology
-    static tNFA_DM_DISC_FREQ_CFG nfa_dm_disc_freq_cfg;
-    //values in the polling_frequency[] map to members of nfa_dm_disc_freq_cfg
-    uint8_t polling_frequency [8] = {1, 1, 1, 1, 1, 1, 1, 1};
-    actualLen = GetStrValue(NAME_POLL_FREQUENCY, (char*)polling_frequency, 8);
-    if (actualLen == 8)
-    {
-        ALOGV("%s: polling frequency", __func__);
-        memset (&nfa_dm_disc_freq_cfg, 0, sizeof(nfa_dm_disc_freq_cfg));
-        nfa_dm_disc_freq_cfg.pa = polling_frequency [0];
-        nfa_dm_disc_freq_cfg.pb = polling_frequency [1];
-        nfa_dm_disc_freq_cfg.pf = polling_frequency [2];
-        nfa_dm_disc_freq_cfg.pi93 = polling_frequency [3];
-        nfa_dm_disc_freq_cfg.pbp = polling_frequency [4];
-        nfa_dm_disc_freq_cfg.pk = polling_frequency [5];
-        nfa_dm_disc_freq_cfg.paa = polling_frequency [6];
-        nfa_dm_disc_freq_cfg.pfa = polling_frequency [7];
-        p_nfa_dm_rf_disc_freq_cfg = &nfa_dm_disc_freq_cfg;
-    }
-}
-
-
-/*******************************************************************************
-**
-** Function:        nfcManager_isNfcActive
-**
-** Description:     Used externaly to determine if NFC is active or not.
-**
-** Returns:         'true' if the NFC stack is running, else 'false'.
-**
-*******************************************************************************/
-bool nfcManager_isNfcActive()
-{
-    return sIsNfaEnabled;
-}
-
-#if(NXP_EXTNS == TRUE)
-/*******************************************************************************
-**
-** Function:        nfcManager_isNfcDisabling
-**
-** Description:     Used externaly to determine if NFC is deinit is ongoing or not.
-**
-** Returns:         'true' if the NFC deinit is running, else 'false'.
-**
-*******************************************************************************/
-bool nfcManager_isNfcDisabling()
-{
-    return sIsDisabling;
-}
-
-/*******************************************************************************
-**
-** Function:        nfcManager_getNfcState
-**
-** Description:     Used internally and externally to check the current NFC state
-**
-** Returns:         Returns the current state of NFC.
-**
-*******************************************************************************/
-uint8_t nfcManager_getNfcState()
-{
-    ALOGV("%s: sNfcState = %d", __func__, sNfcState);
-    return sNfcState;
-}
-#endif
-
-/*******************************************************************************
-**
-** Function:        startStopPolling
-**
-** Description:     Start or stop polling.
-**                  isStartPolling: true to start polling; false to stop polling.
-**
-** Returns:         None.
-**
-*******************************************************************************/
-void startStopPolling (bool isStartPolling)
-{
-    ALOGV("%s: enter; isStart=%u", __func__, isStartPolling);
-    startRfDiscovery (false);
-
-    if (isStartPolling) startPolling_rfDiscoveryDisabled(0);
-    else stopPolling_rfDiscoveryDisabled();
-
-    startRfDiscovery (true);
-    ALOGV("%s: exit", __func__);
-}
-
-static tNFA_STATUS startPolling_rfDiscoveryDisabled(tNFA_TECHNOLOGY_MASK tech_mask) {
-    tNFA_STATUS stat = NFA_STATUS_FAILED;
-
-    unsigned long num = 0;
-
-    if (tech_mask == 0 && GetNumValue(NAME_POLLING_TECH_MASK, &num, sizeof(num)))
-        tech_mask = num;
-    else if (tech_mask == 0) tech_mask = DEFAULT_TECH_MASK;
-
-    SyncEventGuard guard (sNfaEnableDisablePollingEvent);
-    ALOGV("%s: enable polling", __func__);
-    stat = NFA_EnablePolling (tech_mask);
-    if (stat == NFA_STATUS_OK)
-    {
-        ALOGV("%s: wait for enable event", __func__);
-        sPollingEnabled = true;
-        sNfaEnableDisablePollingEvent.wait (); //wait for NFA_POLL_ENABLED_EVT
-    }
-    else
-    {
-        ALOGE("%s: fail enable polling; error=0x%X", __func__, stat);
-    }
-
-    return stat;
-}
-
-static tNFA_STATUS stopPolling_rfDiscoveryDisabled() {
-    tNFA_STATUS stat = NFA_STATUS_FAILED;
-
-    SyncEventGuard guard (sNfaEnableDisablePollingEvent);
-    ALOGV("%s: disable polling", __func__);
-    stat = NFA_DisablePolling ();
-    if (stat == NFA_STATUS_OK) {
-        sPollingEnabled = false;
-        sNfaEnableDisablePollingEvent.wait (); //wait for NFA_POLL_DISABLED_EVT
-    } else {
-        ALOGE("%s: fail disable polling; error=0x%X", __func__, stat);
-    }
-
-    return stat;
-}
-
-
-/*******************************************************************************
-**
-** Function:        nfcManager_getChipVer
-**
-** Description:     Gets the chip version.
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         None      0x00
-**                  PN547C2   0x01
-**                  PN65T     0x02 .
-**
-*******************************************************************************/
-static int nfcManager_getChipVer(JNIEnv* /* e */, jobject /* o */)
-{
-    ALOGV("%s: enter", __func__);
-    unsigned long num =0;
-
-    GetNxpNumValue(NAME_NXP_NFC_CHIP, (void *)&num, sizeof(num));
-    ALOGV("%ld: nfcManager_getChipVer", num);
-    return num;
-}
-
-/*******************************************************************************
-**
-** Function:        nfcManager_getFwFileName
-**
-** Description:     Read Fw file name from config file.
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         jbyteArray: File name read from config file
-**                  NULL in case file name not found
-**
-*******************************************************************************/
-static jbyteArray nfcManager_getFwFileName(JNIEnv* e, jobject o)
-{
-    (void)o;
-    ALOGV("%s: enter", __func__);
-    char fwFileName[256];
-    int fileLen = 0;
-    jbyteArray jbuff = NULL;
-
-    if(GetNxpStrValue(NAME_NXP_FW_NAME, (char*)fwFileName, sizeof(fwFileName)) == true)
-    {
-        ALOGV("%s: FW_NAME read success = %s", __func__, fwFileName);
-        fileLen = strlen(fwFileName);
-        jbuff = e->NewByteArray (fileLen);
-        e->SetByteArrayRegion (jbuff, 0, fileLen, (jbyte*) fwFileName);
-    }
-    else
-    {
-        ALOGV("%s: FW_NAME not found", __func__);
-    }
-
-    return jbuff;
-}
-
-/*******************************************************************************
-**
-** Function:        DWPChannel_init
-**
-** Description:     Initializes the DWP channel functions.
-**
-** Returns:         True if ok.
-**
-*******************************************************************************/
-void DWPChannel_init(IChannel_t *DWP)
-{
-    ALOGV("%s: enter", __func__);
-    if(nfcFL.nfcNxpEse) {
-        DWP->open = open;
-        DWP->close = close;
-        DWP->transceive = transceive;
-        DWP->doeSE_Reset = doeSE_Reset;
-        DWP->doeSE_JcopDownLoadReset = doeSE_JcopDownLoadReset;
-    }
-}
-/*******************************************************************************
-**
-** Function:        nfcManager_doJcosDownload
-**
-** Description:     start jcos download.
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         True if ok.
-**
-*******************************************************************************/
-static int nfcManager_doJcosDownload(JNIEnv* /* e */, jobject /* o */)
-{
-    tNFA_STATUS status = NFA_STATUS_FAILED;
-#if (NXP_EXTNS == TRUE)
-    if(nfcFL.nfcNxpEse) {
-        ALOGV("%s: enter", __func__);
-        bool stat = false;
-        SecureElement &se = SecureElement::getInstance();
-
-
-        if(nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION) {
-            int ret_val = -1;
-            NFCSTATUS ese_status = NFA_STATUS_FAILED;
-            p61_access_state_t p61_current_state = P61_STATE_INVALID;
-            eScreenState_t last_screen_state_request = get_lastScreenStateRequest();
-
-            if (sIsDisabling || !sIsNfaEnabled || nfcManager_checkNfcStateBusy())
-            {
-                return NFA_STATUS_FAILED;
-            }
-
-            ret_val = NFC_GetP61Status ((void *)&p61_current_state);
-            if (ret_val < 0)
-            {
-                ALOGV("NFC_GetP61Status failed");
-                return NFA_STATUS_FAILED;
-            }
-            if(p61_current_state & P61_STATE_JCP_DWNLD || p61_current_state & P61_STATE_WIRED
-                    ||p61_current_state & P61_STATE_SPI || p61_current_state & P61_STATE_SPI_PRIO) {
-                return NFA_STATUS_BUSY;
-        }
-
-            if (sIsDisabling || !sIsNfaEnabled || nfcManager_checkNfcStateBusy())
-            {
-                return NFA_STATUS_FAILED;
-            }
-
-            ALOGE("%s: start JcopOs_Download 0x%X", __func__,p61_current_state);
-
-            ret_val = NFC_SetP61Status((void *)&ese_status, JCP_DWNLD_START);
-            if (ret_val < 0)
-            {
-                ALOGV("NFC_SetP61Status failed");
-            }
-            else
-            {
-                if (ese_status != NFCSTATUS_SUCCESS)
-                {
-                    ALOGV("Denying to set Jcop OS Download state");
-                    status = ese_status;
-                }
-                else
-                {
-                    if(!pTransactionController->transactionAttempt(TRANSACTION_REQUESTOR(jcosDownload)))
-                    {
-                        ALOGE("%s: Transaction in progress. Returning", __func__);
-                        return NFA_STATUS_FAILED;
-                    }
-                }
-                if (sRfEnabled) {
-                    // Stop RF Discovery if we were polling
-                    startRfDiscovery (false);
-                }
-                DWPChannel_init(&Dwp);
-                status = JCDNLD_Init(&Dwp);
-                if(status != NFA_STATUS_OK)
-                {
-                    ALOGE("%s: JCDND initialization failed", __func__);
-                }
-                else
-                {
-                    ALOGE("%s: start JcopOs_Download", __func__);
-                    se.mDownloadMode = JCOP_DOWNLOAD;
-                    status = JCDNLD_StartDownload();
-                }
-                if(nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION) {
-                    ret_val = NFC_SetP61Status ((void *)&ese_status, JCP_DWP_DWNLD_COMPLETE);
-                    if (ret_val < 0)
-                    {
-                        ALOGV("NFC_SetP61Status failed Deinit and starting discovery");
-                    }
-                    else
-                    {
-                        if (ese_status != NFCSTATUS_SUCCESS)
-                        {
-                            ALOGV("Denying to set Jcop OS Download complete state");
-                            status = ese_status;
-                        }
-                    }
-                }
-                stat = JCDNLD_DeInit();
-                if(nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION) {
-                    pTransactionController->transactionEnd(TRANSACTION_REQUESTOR(jcosDownload));
-                    if(pendingScreenState == true)
-                    {
-                        pendingScreenState = false;
-                        last_screen_state_request = get_lastScreenStateRequest();
-                        nfcManager_doSetScreenState(NULL,NULL,last_screen_state_request);
-                    }
-                }
-            }
-        }
-        startRfDiscovery (true);
-        se.mDownloadMode = NONE;
-        ALOGV("%s: exit; status =0x%X", __func__,status);
-    }
-    else
-    {
-        tNFA_STATUS status = 0x0F;
-        ALOGV("%s: No p61", __func__);
-    }
-#endif
-    return status;
-}
-
-#if(NXP_EXTNS == TRUE)
-uint8_t getJCOPOS_UpdaterState()
-{
-    static const char fn [] = "getJCOPOS_UpdaterState";
-    if(!nfcFL.nfcNxpEse) {
-        ALOGV("%s: nfcNxpEse not Enabled. Returning.", fn);
-        return OSU_NOT_STARTED;
-    }
-    FILE *fp;
-    unsigned int val = 0;
-    uint8_t state = 0;
-    int32_t result = 0;
-    ALOGV("%s: enter", fn);
-
-    fp = fopen(JCOP_INFO_PATH, "r");
-    if (fp != NULL) {
-        result = fscanf(fp, "%u", &val);
-        if (result != 0)
-        {
-            state = (uint8_t)(val & 0x000000FF);
-            ALOGV("JcopOsState %d", state);
-        }
-        fclose(fp);
-    }
-    else
-    {
-        ALOGE("file <%s> not exits for reading-: %s",
-                JCOP_INFO_PATH, strerror(errno));
-    }
-    return state;
-}
-#endif
-
-static void nfcManager_doCommitRouting(JNIEnv* e, jobject o)
-{
-    (void)e;
-    (void)o;
-    ALOGV("%s: enter", __func__);
-    PowerSwitch::getInstance ().setLevel (PowerSwitch::FULL_POWER);
-    PowerSwitch::getInstance ().setModeOn (PowerSwitch::HOST_ROUTING);
-#if(NXP_EXTNS == TRUE && NXP_NFCC_HCE_F == TRUE)
-    if(!pTransactionController->transactionAttempt(TRANSACTION_REQUESTOR(commitRouting)))
-    {
-        ALOGV("%s: Not allowing to commit the routing", __func__);
-    }
-    else
-    {
-#endif
-        if (sRfEnabled) {
-           /*Stop RF discovery to reconfigure*/
-           startRfDiscovery(false);
-        }
-        RoutingManager::getInstance().commitRouting();
-        startRfDiscovery(true);
-#if(NXP_EXTNS == TRUE && NXP_NFCC_HCE_F == TRUE)
-    }
-#endif
-
-    RoutingManager::getInstance().commitRouting();
-    startRfDiscovery(true);
-#if(NXP_EXTNS == TRUE && NXP_NFCC_HCE_F == TRUE)
-    pTransactionController->transactionEnd(TRANSACTION_REQUESTOR(commitRouting));
-#endif
-    ALOGV("%s: exit", __func__);
-}
-#if(NXP_EXTNS == TRUE)
-static void nfcManager_doSetNfcMode(JNIEnv* /* e */, jobject /* o */, jint nfcMode)
-{
-    /* Store the shutdown state */
-    gGeneralPowershutDown = nfcMode;
-}
-#endif
-bool isNfcInitializationDone()
-{
-    if(nfcFL.nfccFL._NFCEE_REMOVED_NTF_RECOVERY) {
-        return sIsNfaEnabled;
-    }
-    else {
-        ALOGV("%s: NFCEE_REMOVED_NTF_RECOVERY not enabled. Returning", __func__);
-        return false;
-    }
-}
-/*******************************************************************************
-**
-** Function:        StoreScreenState
-**
-** Description:     Sets  screen state
-**
-** Returns:         None
-**
-*******************************************************************************/
-static void StoreScreenState(int state)
-{
-    ALOGV("%s: enter", __func__);
-    screenstate = state;
-    nfc_ncif_storeScreenState(state);
-    ALOGV("%s: exit", __func__);
-}
-
-/*******************************************************************************
-**
-** Function:        getScreenState
-**
-** Description:     returns screen state
-**
-** Returns:         int
-**
-*******************************************************************************/
-int getScreenState()
-{
-    return screenstate;
-}
-
-/*******************************************************************************
-**
-** Function:        isp2pActivated
-**
-** Description:     returns p2pActive state
-**
-** Returns:         bool
-**
-*******************************************************************************/
-bool isp2pActivated()
-{
-    if(nfcFL.nfcNxpEse) {
-        return sP2pActive;
-    }
-    else {
-        ALOGV("%s: nfcNxpEse not set. Returning", __func__);
-        return false;
-    }
-}
-
-/*******************************************************************************
-**
-** Function:        nfcManager_doGetNciVersion
-**
-** Description:     get the nci version.
-**
-** Returns:         int
-**
-*******************************************************************************/
-static jint nfcManager_doGetNciVersion(JNIEnv* , jobject)
-{
-   return NFC_GetNCIVersion();
-}
-/*******************************************************************************
-**
-** Function:        nfcManager_doSetScreenState
-**
-** Description:     Set screen state
-**
-** Returns:         None
-**
-*******************************************************************************/
-static void nfcManager_doSetScreenState (JNIEnv* /* e */, jobject /* o */, jint screen_state_mask)
-{
-    tNFA_STATUS status = NFA_STATUS_OK;
-    unsigned long auto_num = 0;
-    uint8_t standby_num = 0x00;
-    uint8_t *buffer = NULL;
-    long bufflen = 260;
-    long retlen = 0;
-    int isfound;
-    uint8_t core_reset_cfg[8] = {0x20,0x00,0x01,0x00};
-    uint8_t core_init_cfg[8] = {0x20,0x01,0x00};
-    uint8_t  discovry_param = NFA_LISTEN_DH_NFCEE_ENABLE_MASK | NFA_POLLING_DH_ENABLE_MASK;
-    uint8_t state = (screen_state_mask & NFA_SCREEN_STATE_MASK);
-
-    ALOGV("%s: state = %d", __func__, state);
-
-    if (sIsDisabling || !sIsNfaEnabled)
-        return;
-
-#if (NXP_EXTNS == TRUE)
-    if(!pTransactionController->transactionAttempt(TRANSACTION_REQUESTOR(setScreenState)))
-    {
-        ALOGE("Payment is in progress!!!");
-        set_lastScreenStateRequest((eScreenState_t)state);
-        pendingScreenState = true;
-        return;
-    }
-#endif
-
-    int prevScreenState = getScreenState();
-    if(prevScreenState == state) {
-        ALOGV("Screen state is not changed. ");
-#if (NXP_EXTNS == TRUE)
-    pTransactionController->transactionEnd(TRANSACTION_REQUESTOR(setScreenState));
-#endif
-        return;
-    }
-    if(NFC_GetNCIVersion() == NCI_VERSION_2_0) {
-        if(prevScreenState == NFA_SCREEN_STATE_OFF_LOCKED || prevScreenState == NFA_SCREEN_STATE_OFF_UNLOCKED ||
-           prevScreenState == NFA_SCREEN_STATE_ON_LOCKED)
-        {
-            SyncEventGuard guard (sNfaSetPowerSubState);
-            status = NFA_SetPowerSubState(state);
-            if (status != NFA_STATUS_OK) {
-                ALOGE ("%s: fail enable SetScreenState; error=0x%X", __FUNCTION__, status);
-            }
-            else
-            {
-                sNfaSetPowerSubState.wait();
-            }
-        }
-
-        if( state == NFA_SCREEN_STATE_OFF_LOCKED || state == NFA_SCREEN_STATE_OFF_UNLOCKED) {
-            // disable both poll and listen on DH 0x02
-            discovry_param = NFA_POLLING_DH_DISABLE_MASK | NFA_LISTEN_DH_NFCEE_DISABLE_MASK;
-         }
-
-        if( state == NFA_SCREEN_STATE_ON_LOCKED) {
-            // disable poll and enable listen on DH 0x00
-            discovry_param = (screen_state_mask & NFA_SCREEN_POLLING_TAG_MASK) ? (NFA_LISTEN_DH_NFCEE_ENABLE_MASK | NFA_POLLING_DH_ENABLE_MASK):
-                (NFA_POLLING_DH_DISABLE_MASK | NFA_LISTEN_DH_NFCEE_ENABLE_MASK);
-         }
-
-        if( state == NFA_SCREEN_STATE_ON_UNLOCKED) {
-           // enable both poll and listen on DH 0x01
-           discovry_param = NFA_LISTEN_DH_NFCEE_ENABLE_MASK | NFA_POLLING_DH_ENABLE_MASK;
-        }
-
-        SyncEventGuard guard (sNfaSetConfigEvent);
-        status = NFA_SetConfig(NFC_PMID_CON_DISCOVERY_PARAM, NCI_PARAM_LEN_CON_DISCOVERY_PARAM, &discovry_param);
-        if (status == NFA_STATUS_OK) {
-            sNfaSetConfigEvent.wait ();
-            ALOGD ("%s: Disabled RF field events", __FUNCTION__);
-        } else {
-            ALOGE ("%s: Failed to disable RF field events", __FUNCTION__);
-        }
-
-        if(prevScreenState == NFA_SCREEN_STATE_ON_UNLOCKED)
-        {
-            SyncEventGuard guard (sNfaSetPowerSubState);
-            status = NFA_SetPowerSubState(state);
-            if (status != NFA_STATUS_OK) {
-            ALOGE ("%s: fail enable SetScreenState; error=0x%X", __FUNCTION__, status);
-            }
-            else
-            {
-                sNfaSetPowerSubState.wait();
-            }
-        }
-        StoreScreenState(state);
-#if (NXP_EXTNS == TRUE)
-        pTransactionController->transactionEnd(TRANSACTION_REQUESTOR(setScreenState));
-#endif
-        return;
-    }
-    acquireRfInterfaceMutexLock();
-    if (state) {
-        if (sRfEnabled) {
-            // Stop RF discovery to reconfigure
-            startRfDiscovery(false);
-        }
-
-        if(state == NFA_SCREEN_STATE_OFF_UNLOCKED || state == NFA_SCREEN_STATE_OFF_LOCKED || state == NFA_SCREEN_STATE_ON_LOCKED)
-        {
-            SyncEventGuard guard (sNfaEnableDisablePollingEvent);
-            status = NFA_DisablePolling ();
-            if (status == NFA_STATUS_OK)
-            {
-                sNfaEnableDisablePollingEvent.wait (); //wait for NFA_POLL_DISABLED_EVT
-            }else
-                ALOGE("%s: Failed to disable polling; error=0x%X", __func__, status);
-        }
-
-        if(GetNxpNumValue(NAME_NXP_CORE_SCRN_OFF_AUTONOMOUS_ENABLE,&auto_num ,sizeof(auto_num)))
-        {
-            ALOGV("%s: enter; NAME_NXP_CORE_SCRN_OFF_AUTONOMOUS_ENABLE = %02lx", __func__, auto_num);
-        }
-
-        status = SetScreenState(state);
-        if (status != NFA_STATUS_OK)
-        {
-            ALOGE("%s: fail enable SetScreenState; error=0x%X", __func__, status);
-        }
-        else
-        {
-            if (((prevScreenState == NFA_SCREEN_STATE_OFF_LOCKED|| prevScreenState == NFA_SCREEN_STATE_OFF_UNLOCKED) && state == NFA_SCREEN_STATE_ON_LOCKED)||
-#if(NXP_EXTNS == TRUE)
-                    (prevScreenState == NFA_SCREEN_STATE_ON_LOCKED && state == NFA_SCREEN_STATE_ON_UNLOCKED && sProvisionMode)||
-#endif
-                    (prevScreenState == NFA_SCREEN_STATE_ON_LOCKED && (state == NFA_SCREEN_STATE_OFF_LOCKED || state == NFA_SCREEN_STATE_OFF_UNLOCKED)&& sIsSecElemSelected) )
-            {
-                if(auto_num != 0x01)
-                {
-                    ALOGV("Start RF discovery");
-                    startRfDiscovery(true);
-                }
-            }
-            StoreScreenState(state);
-        }
-        if(sAutonomousSet == 1)
-        {
-            ALOGV("Send Core reset");
-            NxpNfc_Send_CoreResetInit_Cmd();
-        }
-        ALOGV("%s: auto_num : %d  sAutonomousSet : %d  sRfFieldOff : %d", __func__,auto_num,sAutonomousSet,sRfFieldOff);
-        if((auto_num == 0x01) && (sAutonomousSet != 1) &&
-                (sRfFieldOff == true) && (state == NFA_SCREEN_STATE_OFF_LOCKED || state == NFA_SCREEN_STATE_OFF_UNLOCKED))
-        {
-            buffer = (uint8_t*) malloc(bufflen*sizeof(uint8_t));
-            if(buffer == NULL)
-            {
-                ALOGV("%s: enter; NAME_NXP_CORE_STANDBY buffer is NULL", __func__);
-            }
-            else
-            {
-                isfound = GetNxpByteArrayValue(NAME_NXP_CORE_STANDBY, (char *) buffer,bufflen, &retlen);
-                if (retlen > 0)
-                {
-                    standby_num = buffer[3];
-                }
-                status = SendAutonomousMode(state,standby_num);
-                sAutonomousSet = 1;
-            }
-        }
-        else
-        {
-            sAutonomousSet = 0;
-            ALOGV("Not sending AUTONOMOUS command state is %d", state);
-            if (!sRfEnabled) {
-                // Start RF discovery if not
-                startRfDiscovery(true);
-            }
-
-        }
-        if(buffer)
-        {
-            free(buffer);
-        }
-
-    }
-    releaseRfInterfaceMutexLock();
-#if (NXP_EXTNS == TRUE)
-    pTransactionController->transactionEnd(TRANSACTION_REQUESTOR(setScreenState));
-#endif
-}
-#if(NXP_EXTNS == TRUE)
-/*******************************************************************************
-**
-** Function:        nfcManager_doSetScreenOrPowerState
-**                  This function combines both screen state and power state(ven power) values.
-**
-** Description:     Set screen or power state
-**                  e: JVM environment.
-**                  o: Java object.
-**                  state:represents power or screen state (0-3 screen state),6 (power on),7(power off)
-**
-** Returns:         None
-**
-*******************************************************************************/
-static void nfcManager_doSetScreenOrPowerState (JNIEnv* e, jobject o, jint state)
-{
-    ALOGE("%s: Enter", __func__);
-    if (state <= NFA_SCREEN_STATE_ON_UNLOCKED ) // SCREEN_STATE
-        nfcManager_doSetScreenState(e, o, state);
-    else if (state == VEN_POWER_STATE_ON) // POWER_ON NFC_OFF
-    {
-        nfcManager_doSetNfcMode(e , o, NFC_MODE_OFF);
-    }
-    else if (state == VEN_POWER_STATE_OFF) // POWER_OFF
-    {
-        if(sIsNfaEnabled)
-        {
-            if(nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION &&
-                    (SecureElement::getInstance().mDownloadMode == JCOP_DOWNLOAD)) {
-               DwpChannel::getInstance().forceClose();
-            }
-            nfcManager_doSetNfcMode(e , o, NFC_MODE_ON); //POWER_OFF NFC_ON
-        }
-        else
-        {
-            nfcManager_doSetNfcMode(e , o, NFC_MODE_OFF); //POWER_OFF NFC_OFF
-        }
-    }
-    else
-        ALOGE("%s: unknown screen or power state. state=%d", __func__, state);
-}
-/*******************************************************************************
- **
- ** Function:        nfcManager_isRequestPending()
- **
- ** Description:     Checks If any pending request
- **
- ** Returns:         true if any request pending else false
- **
-*******************************************************************************/
-bool nfcManager_isRequestPending(void)
-{
-    bool isPending = false;
-
-    if((transaction_data.current_transcation_state != NFA_TRANS_ACTIVATED_EVT) &&
-            ((pendingScreenState == true) || (get_last_request() != 0x00)))
-    {
-        isPending = true;
-    }
-    return isPending;
-}
-#endif
-/*******************************************************************************
- **
- ** Function:       get_last_request
- **
- ** Description:    returns the last enable/disable discovery event
- **
- ** Returns:        last request (char) .
- **
- *******************************************************************************/
-static char get_last_request()
-{
-    return(transaction_data.last_request);
-}
-/*******************************************************************************
- **
- ** Function:       set_last_request
- **
- ** Description:    stores the last enable/disable discovery event
- **
- ** Returns:        None .
- **
- *******************************************************************************/
-static void set_last_request(char status, struct nfc_jni_native_data *nat)
-{
-    if((status == ENABLE_DISCOVERY) || (status == DISABLE_DISCOVERY))
-    {
-        transaction_data.last_request &= CLEAR_ENABLE_DISABLE_PARAM;
-    }
-#if(NXP_EXTNS == TRUE && NXP_NFCC_HCE_F == TRUE)
-    transaction_data.last_request |= status;
-#else
-    transaction_data.last_request = status;
-#endif
-    if (nat != NULL)
-    {
-        transaction_data.transaction_nat = nat;
-    }
-}
-/*******************************************************************************
- **
- ** Function:       get_lastScreenStateRequest
- **
- ** Description:    returns the last screen state request
- **
- ** Returns:        last screen state request event (eScreenState_t) .
- **
- *******************************************************************************/
- static eScreenState_t get_lastScreenStateRequest()
-{
-    ALOGV("%s: %d", __func__, transaction_data.last_screen_state_request);
-    return(transaction_data.last_screen_state_request);
-}
-
-/*******************************************************************************
- **
- ** Function:       set_lastScreenStateRequest
- **
- ** Description:    stores the last screen state request
- **
- ** Returns:        None .
- **
- *******************************************************************************/
-static void set_lastScreenStateRequest(eScreenState_t status)
-{
-    ALOGV("%s: current=%d, new=%d", __func__, transaction_data.last_screen_state_request, status);
-    transaction_data.last_screen_state_request = status;
-}
-
-
-/*******************************************************************************
-**
-** Function:        switchBackTimerProc_transaction
-**
-** Description:     Callback function for interval timer.
-**
-** Returns:         None
-**
-*******************************************************************************/
-#if 0
-static void cleanupTimerProc_transaction(union sigval)
-{
-    ALOGV("Inside cleanupTimerProc");
-    cleanup_timer();
-}
-
-void cleanup_timer()
-{
-ALOGV("Inside cleanup");
-    pthread_t transaction_thread;
-    int irret = -1;
-    ALOGV("%s", __func__);
-
-    /* Transcation is done process the last request*/
-    pthread_attr_t attr;
-    pthread_attr_init(&attr);
-    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-    irret = pthread_create(&transaction_thread, &attr, enableThread, NULL);
-    if(irret != 0)
-    {
-        ALOGE("Unable to create the thread");
-    }
-    pthread_attr_destroy(&attr);
-    transaction_data.current_transcation_state = NFA_TRANS_DM_RF_TRANS_END;
-}
-#endif
-
-#if (NXP_EXTNS == TRUE)
-/*******************************************************************************
- **
- ** Function:       update_transaction_stat
- **
- ** Description:    updates the transaction status set/reset
- **                 req_handle : Requesting handle - Module name
- **                 req_state : SET_TRANSACTION_STATE / RESET_TRANSACTION_STATE
- **
- ** Returns:        update status
- **                 ret_stat : true/false
- **
- *******************************************************************************/
-#if 0
-bool update_transaction_stat(const char * req_handle, transaction_state_t req_state)
-{
-    bool ret_stat = false;
-
-    gTransactionMutex.lock();
-    /*Check if it is initialisation*/
-    if((req_handle == NULL)&&(req_state == RESET_TRANSACTION_STATE))
-    {
-        ALOGV("%s: Initialisation. Resetting transaction data", __func__);
-        transaction_data.trans_in_progress = false;
-        cur_transaction_handle = NULL;
-        ret_stat = true;
-    }
-    else
-    {
-        ALOGV("%s: Enter. Requested by : %s   Requested state : %s", __func__,req_handle,(req_state?"SET":"RESET"));
-    }
-
-    /*Check if no transaction is currently ongoing*/
-    if(!transaction_data.trans_in_progress)
-    {
-        if(req_state == SET_TRANSACTION_STATE)
-        {
-            transaction_data.trans_in_progress = req_state;
-            cur_transaction_handle = req_handle;
-            ret_stat = true;
-            /*Using a backup reset procedure as a timer to reset Transaction state,
-             *in case Transaction state is set but not reset because of some reason
-             *
-             *Also timer should not be started for below handles as these may take
-             *more time to reset depending on the transaction duration
-             **/
-            if(strcmp(req_handle,"NFA_ACTIVATED_EVT") &&
-                    strcmp(req_handle,"NFA_EE_ACTION_EVT") &&
-                    strcmp(req_handle,"NFA_TRANS_CE_ACTIVATED") &&
-                    strcmp(req_handle,"RF_FIELD_EVT") )
-            {
-                scleanupTimerProc_transaction.set (10000, cleanupTimerProc_transaction);
-            }
-
-        }
-        else
-        {
-            ALOGV("%s:Transaction state is already free. Returning", __func__);
-            cur_transaction_handle = NULL;
-            ret_stat = true;
-            scleanupTimerProc_transaction.kill ();
-        }
-    }
-    else
-    {
-        /*If transaction_stat is already set (transaction is ongoing) it can not be set again*/
-        if(req_state == SET_TRANSACTION_STATE)
-        {
-            ALOGV("%s:Transaction is in progress by : %s . Returning", __func__,cur_transaction_handle);
-            ret_stat = false;
-        }
-        else
-        {
-            /*If transaction_stat is already set only authorised module can reset it
-             *It should be either cur_transaction_handle (which has set transaction_stat) or
-             *exec_pending_req*/
-            if(cur_transaction_handle != NULL)
-            {
-                if(!strcmp(cur_transaction_handle,req_handle) || !strcmp(req_handle,"exec_pending_req"))
-                {
-                    transaction_data.trans_in_progress = req_state;
-                    cur_transaction_handle = NULL;
-                    ret_stat = true;
-                    scleanupTimerProc_transaction.kill ();
-                }
-                else
-                {
-                    ALOGV("%s:Handle Mismatch. Returning ..cur_transaction_handle : %s   Requested handle  : %s ", __func__,cur_transaction_handle,req_handle);
-                    ret_stat = false;
-                }
-            }
-            else
-            {
-                ALOGV("%s: No cur_transaction_handle. Allowing requested handle  : %s ", __func__,req_handle);
-                transaction_data.trans_in_progress = req_state;
-                cur_transaction_handle = req_handle;
-                ret_stat = true;
-                scleanupTimerProc_transaction.kill ();
-            }
-        }
-    }
-    ALOGV("%s: Exit.  Requested by : %s   Requested state : %s  status : %s", __func__,req_handle,(req_state?"SET":"RESET"), (ret_stat?"SUCCESS":"FAILED"));
-    gTransactionMutex.unlock();
-    return ret_stat;
-}
-#endif
-#endif
-/*******************************************************************************
- **
- ** Function:        checkforTranscation
- **
- ** Description:     Receive connection-related events from stack.
- **                  connEvent: Event code.
- **                  eventData: Event data.
- **
- ** Returns:         None
- **
- *******************************************************************************/
-void checkforTranscation(uint8_t connEvent, void* eventData)
-{
-    tNFA_CONN_EVT_DATA *eventAct_Data = (tNFA_CONN_EVT_DATA*) eventData;
-    tNFA_DM_CBACK_DATA* eventDM_Conn_data = (tNFA_DM_CBACK_DATA *) eventData;
-        tNFA_EE_CBACK_DATA* ee_action_data = (tNFA_EE_CBACK_DATA *) eventData;
-        tNFA_EE_ACTION& action = ee_action_data->action;
-
-    ALOGV("%s: enter; event=0x%X transaction_data.current_transcation_state = 0x%x", __func__, connEvent,
-            transaction_data.current_transcation_state);
-    switch(connEvent)
-    {
-    case NFA_ACTIVATED_EVT:
-        if((eventAct_Data->activated.activate_ntf.protocol != NFA_PROTOCOL_NFC_DEP) && (isListenMode(eventAct_Data->activated)))
-        {
-            ALOGV("ACTIVATED_EVT setting flag");
-            transaction_data.current_transcation_state = NFA_TRANS_ACTIVATED_EVT;
-#if (NXP_EXTNS == TRUE)
-            if(!pTransactionController->transactionAttempt(TRANSACTION_REQUESTOR(NFA_ACTIVATED_EVENT)))
-            {
-                ALOGE("%s: Transaction in progress. Can not set", __func__);
-            }
-#endif
-        }else{
-//            ALOGV("other event clearing flag ");
-//            memset(&transaction_data, 0x00, sizeof(Transcation_Check_t));
-        }
-        break;
-    case NFA_EE_ACTION_EVT:
-        if (transaction_data.current_transcation_state == NFA_TRANS_DEFAULT
-            || transaction_data.current_transcation_state == NFA_TRANS_ACTIVATED_EVT)
-        {
-            if(getScreenState() == NFA_SCREEN_STATE_OFF_LOCKED || getScreenState() == NFA_SCREEN_STATE_OFF_UNLOCKED)
-            {
-                if (!sP2pActive && eventDM_Conn_data->rf_field.status == NFA_STATUS_OK)
-                    SecureElement::getInstance().notifyRfFieldEvent (true);
-            }
-            if(nfcFL.chipType == pn547C2) {
-                if((action.param.technology == NFC_RF_TECHNOLOGY_A)&&(( getScreenState () == NFA_SCREEN_STATE_OFF_UNLOCKED ||  getScreenState () == NFA_SCREEN_STATE_ON_LOCKED || getScreenState () == NFA_SCREEN_STATE_OFF_LOCKED )))
-                {
-                    transaction_data.current_transcation_state = NFA_TRANS_MIFARE_ACT_EVT;
-#if (NXP_EXTNS == TRUE)
-                    if(!pTransactionController->transactionAttempt(TRANSACTION_REQUESTOR(NFA_EE_ACTION_EVENT)))
-                    {
-                        ALOGE("%s: Transaction in progress. Can not set", __func__);
-                    }
-#endif
-                }
-            }
-            else
-            {
-                transaction_data.current_transcation_state = NFA_TRANS_EE_ACTION_EVT;
-#if (NXP_EXTNS == TRUE)
-                if(!pTransactionController->transactionAttempt(TRANSACTION_REQUESTOR(NFA_EE_ACTION_EVENT)))
-                {
-                    ALOGE("%s: Transaction in progress. Can not set", __func__);
-                }
-#endif
-            }
-        }
-        break;
-    case NFA_TRANS_CE_ACTIVATED:
-        if (transaction_data.current_transcation_state == NFA_TRANS_DEFAULT || transaction_data.current_transcation_state == NFA_TRANS_ACTIVATED_EVT)
-            {
-            if(getScreenState() == NFA_SCREEN_STATE_OFF_LOCKED || getScreenState() == NFA_SCREEN_STATE_OFF_UNLOCKED)
-            {
-                if (!sP2pActive && eventDM_Conn_data->rf_field.status == NFA_STATUS_OK)
-                    SecureElement::getInstance().notifyRfFieldEvent (true);
-            }
-                transaction_data.current_transcation_state = NFA_TRANS_CE_ACTIVATED;
-#if (NXP_EXTNS == TRUE)
-                if(!pTransactionController->transactionAttempt(TRANSACTION_REQUESTOR(NFA_TRANS_CE_ACTIVATED_EVENT)))
-                {
-                    ALOGE("%s: Transaction in progress. Can not set", __func__);
-                }
-#endif
-            }
-        break;
-    case NFA_TRANS_CE_DEACTIVATED:
-        rfActivation = false;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  }
 #if (NXP_EXTNS == TRUE)
-        if (transaction_data.current_transcation_state == NFA_TRANS_CE_ACTIVATED)
-            {
-                transaction_data.current_transcation_state = NFA_TRANS_CE_DEACTIVATED;
-            }
+  static void nfcManager_doSetNfcMode(JNIEnv * e, jobject o, jint nfcMode) {
+    /* Store the shutdown state */
+    gGeneralPowershutDown = nfcMode;
+  }
 #endif
-        gActivated = false;
-        break;
-    case NFA_DEACTIVATED_EVT:
-        if(nfcFL.chipType == pn547C2) {
-            if(transaction_data.current_transcation_state == NFA_TRANS_MIFARE_ACT_EVT)
-            {
-                pTransactionController->lastRequestResume();
-            }
-        }
-        break;
-    case NFA_TRANS_DM_RF_FIELD_EVT:
-        if (eventDM_Conn_data->rf_field.status == NFA_STATUS_OK &&
-                (transaction_data.current_transcation_state == NFA_TRANS_EE_ACTION_EVT
-                        || transaction_data.current_transcation_state == NFA_TRANS_CE_DEACTIVATED
-                        || transaction_data.current_transcation_state == NFA_TRANS_CE_ACTIVATED)
-                && eventDM_Conn_data->rf_field.rf_field_status == 0)
-        {
-            ALOGV("start_timer");
-            if(nfcFL.chipType != pn547C2) {
-                set_AGC_process_state(false);
-            }
-            transaction_data.current_transcation_state = NFA_TRANS_DM_RF_FIELD_EVT_OFF;
-            pTransactionController->setAbortTimer(50/*msec*/);
-        }
-        else if (eventDM_Conn_data->rf_field.status == NFA_STATUS_OK &&
-                transaction_data.current_transcation_state == NFA_TRANS_DM_RF_FIELD_EVT_OFF &&
-                eventDM_Conn_data->rf_field.rf_field_status == 1)
-        {
-            if(nfcFL.chipType != pn547C2) {
-                nfcManagerEnableAGCDebug(connEvent);
-            }
-            transaction_data.current_transcation_state = NFA_TRANS_DM_RF_FIELD_EVT_ON;
-            ALOGV("Payment is in progress hold the screen on/off request ");
-            transaction_data.current_transcation_state = NFA_TRANS_DM_RF_TRANS_START;
-            pTransactionController->killAbortTimer();
+  bool isNfcInitializationDone() {
+    if (nfcFL.nfccFL._NFCEE_REMOVED_NTF_RECOVERY) {
+      return sIsNfaEnabled;
+    } else {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFCEE_REMOVED_NTF_RECOVERY not enabled. Returning", __func__);
+      return false;
+    }
+  }
+  /*******************************************************************************
+  **
+  ** Function:        StoreScreenState
+  **
+  ** Description:     Sets  screen state
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  static void StoreScreenState(int state) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+    screenstate = state;
+    nfc_ncif_storeScreenState(state);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        getScreenState
+  **
+  ** Description:     returns screen state
+  **
+  ** Returns:         int
+  **
+  *******************************************************************************/
+  int getScreenState() { return screenstate; }
+
+  /*******************************************************************************
+  **
+  ** Function:        isp2pActivated
+  **
+  ** Description:     returns p2pActive state
+  **
+  ** Returns:         bool
+  **
+  *******************************************************************************/
+  bool isp2pActivated() {
+    if (nfcFL.nfcNxpEse) {
+      return sP2pActive;
+    } else {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: nfcNxpEse not set. Returning", __func__);
+      return false;
+    }
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_doGetNciVersion
+  **
+  ** Description:     get the nci version.
+  **
+  ** Returns:         int
+  **
+  *******************************************************************************/
+  static jint nfcManager_doGetNciVersion(JNIEnv*, jobject) {
+    return NFC_GetNCIVersion();
+  }
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_doSetScreenState
+  **
+  ** Description:     Set screen state
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  static void nfcManager_doSetScreenState(JNIEnv * e, jobject o,
+                                          jint screen_state_mask) {
+    tNFA_STATUS status = NFA_STATUS_OK;
+    unsigned long auto_num = 0;
+    uint8_t discovry_param =
+        NCI_LISTEN_DH_NFCEE_ENABLE_MASK | NCI_POLLING_DH_ENABLE_MASK;
+    uint8_t state = (screen_state_mask & NFA_SCREEN_STATE_MASK);
 
-        }
-        else if (eventDM_Conn_data->rf_field.status == NFA_STATUS_OK &&
-                transaction_data.current_transcation_state == NFA_TRANS_DM_RF_TRANS_START &&
-                eventDM_Conn_data->rf_field.rf_field_status == 0)
-        {
-            ALOGV("Transcation is done");
-            if(nfcFL.chipType != pn547C2) {
-                set_AGC_process_state(false);
-            }
-            transaction_data.current_transcation_state = NFA_TRANS_DM_RF_TRANS_PROGRESS;
-            pTransactionController->lastRequestResume();
-        }else if(eventDM_Conn_data->rf_field.status == NFA_STATUS_OK &&
-                transaction_data.current_transcation_state == NFA_TRANS_ACTIVATED_EVT &&
-                eventDM_Conn_data->rf_field.rf_field_status == 0)
-        {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Enter state = %d", __func__, state);
 
-            ALOGD("No transaction done cleaning up the variables");
-            pTransactionController->lastRequestResume();
-        }
-        break;
-    default:
-        break;
+    if (sIsDisabling || !sIsNfaEnabled) {
+      return;
     }
 
-    ALOGV("%s: exit; event=0x%X transaction_data.current_transcation_state = 0x%x", __func__, connEvent,
-            transaction_data.current_transcation_state);
-}
-
-/*******************************************************************************
- **
- ** Function:       enableThread
- **
- ** Description:    thread to trigger enable/disable discovery related events
- **
- ** Returns:        None .
- **
- *******************************************************************************/
-void *enableThread(void *arg)
-{
-    (void)arg;
-    ALOGV("%s: enter", __func__);
-    char last_request = get_last_request();
-    eScreenState_t last_screen_state_request = get_lastScreenStateRequest();
-    if(nfcFL.chipType != pn547C2) {
-        set_AGC_process_state(false);
-    }
 #if (NXP_EXTNS == TRUE)
-    if(!pTransactionController->transactionTerminate(TRANSACTION_REQUESTOR(exec_pending_req)))
-    {
-        ALOGE("%s: Transaction in progress. Can not reset", __func__);
-    }
-#endif
-    bool screen_lock_flag = false;
-    bool disable_discovery = false;
-
-    if(sIsNfaEnabled != true || sIsDisabling == true)
-        goto TheEnd;
-
-    if (last_screen_state_request != NFA_SCREEN_STATE_UNKNOWN)
-    {
-        ALOGV("update last screen state request: %d", last_screen_state_request);
-        nfcManager_doSetScreenState(NULL, NULL, last_screen_state_request);
-        if( last_screen_state_request == NFA_SCREEN_STATE_ON_LOCKED)
-            screen_lock_flag = true;
-    }
-    else
-    {
-        ALOGV("No request pending");
-    }
-
-    if (last_request & ENABLE_DISCOVERY)
-    {
-        ALOGV("send the last request enable");
-        sDiscoveryEnabled = false;
-        sPollingEnabled = false;
-
-        nfcManager_enableDiscovery(NULL, NULL, transaction_data.discovery_params.technologies_mask, transaction_data.discovery_params.enable_lptd,
-                                         transaction_data.discovery_params.reader_mode, transaction_data.discovery_params.enable_p2p,
-                                         transaction_data.discovery_params.restart);
-    }
-
-    if (last_request & DISABLE_DISCOVERY)
-    {
-        ALOGV("send the last request disable");
-        nfcManager_disableDiscovery(NULL, NULL);
-        disable_discovery = true;
-    }
-#if(NXP_EXTNS == TRUE)
-    if (last_request & ENABLE_P2P)
-    {
-        ALOGV("send the last request to enable P2P ");
-        nfcManager_Enablep2p(NULL, NULL, transaction_data.discovery_params.enable_p2p);
-    }
-#if(NXP_NFCC_HCE_F == TRUE)
-    if(last_request & T3T_CONFIGURE)
-    {
-        ALOGV(" transaction_data.t3thandle %d ", transaction_data.t3thandle);
-        if(transaction_data.t3thandle != 0)
-        {
-           RoutingManager::getInstance().deregisterT3tIdentifier(transaction_data.t3thandle);
-        }
-        RoutingManager::getInstance().notifyT3tConfigure();
+    if (!pTransactionController->transactionAttempt(
+            TRANSACTION_REQUESTOR(setScreenState))) {
+      LOG(ERROR) << StringPrintf("Payment is in progress!!!");
+      if (state != getScreenState()) {
+        set_lastScreenStateRequest((eScreenState_t)state);
+        pendingScreenState = true;
+      }
+      return;
     }
 #endif
-    if(last_request & RE_ROUTING)
-    {
-        ALOGV(" transaction_data.isInstallRequest %d ", transaction_data.isInstallRequest);
-        if(!transaction_data.isInstallRequest)
-        {
-            RoutingManager::getInstance().clearAidTable();
-            //nfcManager_doCommitRouting(NULL,NULL);
-        }
-        RoutingManager::getInstance().notifyReRoutingEntry();
-    }
+    pendingScreenState = false;
+    int prevScreenState = getScreenState();
+    if (prevScreenState == state &&
+        get_lastScreenStateRequest() == NFA_SCREEN_STATE_UNKNOWN) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("Screen state is not changed. ");
+#if (NXP_EXTNS == TRUE)
+      pTransactionController->transactionEnd(
+          TRANSACTION_REQUESTOR(setScreenState));
 #endif
-    if(screen_lock_flag && disable_discovery)
-    {
-        startRfDiscovery(true);
-    }
-    screen_lock_flag = false;
-    disable_discovery = false;
-    memset(&transaction_data, 0x00, sizeof(Transcation_Check_t));
-    if(nfcFL.chipType != pn547C2) {
-        memset(&menableAGC_debug_t, 0x00, sizeof(enableAGC_debug_t));
-    }
-TheEnd:
-    ALOGV("%s: exit", __func__);
-    pthread_exit(NULL);
-    return NULL;
-}
-/*******************************************************************************
-**
-** Function         sig_handler
-**
-** Description      This function is used to handle the different types of
-**                  signal events.
-**
-** Returns          None
-**
-*******************************************************************************/
-void sig_handler(int signo)
-{
-    if(!nfcFL.eseFL._JCOP_WA_ENABLE) {
-        ALOGV("JCOP_WA_ENABLE not available..Returning");
+      return;
+    }
+    if (NFC_GetNCIVersion() == NCI_VERSION_2_0) {
+      if (prevScreenState == NFA_SCREEN_STATE_OFF_LOCKED ||
+          prevScreenState == NFA_SCREEN_STATE_OFF_UNLOCKED ||
+          prevScreenState == NFA_SCREEN_STATE_ON_LOCKED) {
+        SyncEventGuard guard(sNfaSetPowerSubState);
+        status = NFA_SetPowerSubStateForScreenState(state);
+        if (status != NFA_STATUS_OK) {
+          LOG(ERROR) << StringPrintf(
+              "%s: fail enable SetScreenState; error=0x%X", __FUNCTION__,
+              status);
+        } else {
+          sNfaSetPowerSubState.wait();
+        }
+      }
+
+      if (state == NFA_SCREEN_STATE_OFF_LOCKED ||
+          state == NFA_SCREEN_STATE_OFF_UNLOCKED) {
+        // disable both poll and listen on DH 0x02
+        discovry_param =
+            NCI_POLLING_DH_DISABLE_MASK | NCI_LISTEN_DH_NFCEE_DISABLE_MASK;
+      }
+
+      if (state == NFA_SCREEN_STATE_ON_LOCKED) {
+        // disable poll and enable listen on DH 0x00
+        discovry_param =
+            (screen_state_mask & NFA_SCREEN_POLLING_TAG_MASK)
+                ? (NCI_LISTEN_DH_NFCEE_ENABLE_MASK | NCI_POLLING_DH_ENABLE_MASK)
+                : (NCI_POLLING_DH_DISABLE_MASK |
+                   NCI_LISTEN_DH_NFCEE_ENABLE_MASK);
+      }
+
+      if (state == NFA_SCREEN_STATE_ON_UNLOCKED) {
+        // enable both poll and listen on DH 0x01
+        discovry_param =
+            NCI_LISTEN_DH_NFCEE_ENABLE_MASK | NCI_POLLING_DH_ENABLE_MASK;
+      }
+
+      SyncEventGuard guard(sNfaSetConfigEvent);
+      status =
+          NFA_SetConfig(NCI_PARAM_ID_CON_DISCOVERY_PARAM,
+                        NCI_PARAM_LEN_CON_DISCOVERY_PARAM, &discovry_param);
+      if (status == NFA_STATUS_OK) {
+        sNfaSetConfigEvent.wait();
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: Disabled RF field events", __FUNCTION__);
+      } else {
+        LOG(ERROR) << StringPrintf("%s: Failed to disable RF field events",
+                                   __FUNCTION__);
         return;
-}
-    switch (signo)
-    {
-        case SIGINT:
-            ALOGE("received SIGINT\n");
-            break;
-        case SIGABRT:
-            ALOGE("received SIGABRT\n");
-#if(NXP_EXTNS == TRUE)
-            if(nfcFL.nfccFL._NFCC_MW_RCVRY_BLK_FW_DNLD) {
-                NFA_MW_Fwdnlwd_Recovery(true);
-            }
-#endif
-            NFA_HciW4eSETransaction_Complete(Wait);
-            break;
-        case SIGSEGV:
-            ALOGE("received SIGSEGV\n");
-            break;
-        case SIGHUP:
-            ALOGE("received SIGHUP\n");
-            break;
-    }
-}
-
-/*******************************************************************************
-**
-** Function         nfcManager_doGetSeInterface
-**
-** Description      This function is used to get the eSE Client interfaces.
-**
-** Returns          integer - Physical medium
-**
-*******************************************************************************/
-static int nfcManager_doGetSeInterface(JNIEnv* /* e */, jobject /* o */, jint type)
-{
-    unsigned long num = 0;
-    switch(type)
-    {
-    case LDR_SRVCE:
-        if(GetNxpNumValue (NAME_NXP_P61_LS_DEFAULT_INTERFACE, (void*)&num, sizeof(num))==false)
-        {
-            ALOGV("NAME_NXP_P61_LS_DEFAULT_INTERFACE not found");
-            num = 1;
-        }
-        break;
-    case JCOP_SRVCE:
-        if(GetNxpNumValue (NAME_NXP_P61_JCOP_DEFAULT_INTERFACE, (void*)&num, sizeof(num))==false)
-        {
-            ALOGV("NAME_NXP_P61_JCOP_DEFAULT_INTERFACE not found");
-            num = 1;
+      }
+
+      if (prevScreenState == NFA_SCREEN_STATE_ON_UNLOCKED) {
+        SyncEventGuard guard(sNfaSetPowerSubState);
+        status = NFA_SetPowerSubStateForScreenState(state);
+        if (status != NFA_STATUS_OK) {
+          LOG(ERROR) << StringPrintf(
+              "%s: fail enable SetScreenState; error=0x%X", __FUNCTION__,
+              status);
+        } else {
+          sNfaSetPowerSubState.wait();
         }
-        break;
-    case LTSM_SRVCE:
-        if(GetNxpNumValue (NAME_NXP_P61_LTSM_DEFAULT_INTERFACE, (void*)&num, sizeof(num))==false)
-        {
-            ALOGV("NAME_NXP_P61_LTSM_DEFAULT_INTERFACE not found");
-            num = 1;
+      }
+      if ((state == NFA_SCREEN_STATE_OFF_LOCKED ||
+            state == NFA_SCREEN_STATE_OFF_UNLOCKED) &&
+            prevScreenState == NFA_SCREEN_STATE_ON_UNLOCKED) {
+            // screen turns off, disconnect tag if connected
+          nativeNfcTag_doDisconnect(NULL, NULL);
+      }
+
+      StoreScreenState(state);
+#if (NXP_EXTNS == TRUE)
+      pTransactionController->transactionEnd(
+          TRANSACTION_REQUESTOR(setScreenState));
+#endif
+      return;
+    }
+    if (state) {
+      if (sRfEnabled) {
+        // Stop RF discovery to reconfigure
+        startRfDiscovery(false);
+      }
+
+      if (state == NFA_SCREEN_STATE_OFF_UNLOCKED ||
+          state == NFA_SCREEN_STATE_OFF_LOCKED ||
+          state == NFA_SCREEN_STATE_ON_LOCKED) {
+        SyncEventGuard guard(sNfaEnableDisablePollingEvent);
+        status = NFA_DisablePolling();
+        if (status == NFA_STATUS_OK) {
+          sNfaEnableDisablePollingEvent
+              .wait();  // wait for NFA_POLL_DISABLED_EVT
+        } else
+          LOG(ERROR) << StringPrintf(
+              "%s: Failed to disable polling; error=0x%X", __func__, status);
+      }
+
+      if (NfcConfig::hasKey(NAME_NXP_CORE_SCRN_OFF_AUTONOMOUS_ENABLE)) {
+        auto_num =
+            NfcConfig::getUnsigned(NAME_NXP_CORE_SCRN_OFF_AUTONOMOUS_ENABLE);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: enter; NAME_NXP_CORE_SCRN_OFF_AUTONOMOUS_ENABLE = %02lx",
+            __func__, auto_num);
+      }
+
+      status = SetScreenState(state);
+      if (status != NFA_STATUS_OK) {
+        LOG(ERROR) << StringPrintf("%s: fail enable SetScreenState; error=0x%X",
+                                   __func__, status);
+      } else {
+        if (((prevScreenState == NFA_SCREEN_STATE_OFF_LOCKED ||
+              prevScreenState == NFA_SCREEN_STATE_OFF_UNLOCKED) &&
+             state == NFA_SCREEN_STATE_ON_LOCKED) ||
+#if (NXP_EXTNS == TRUE)
+            (prevScreenState == NFA_SCREEN_STATE_ON_LOCKED &&
+             state == NFA_SCREEN_STATE_ON_UNLOCKED && sProvisionMode) ||
+#endif
+            (prevScreenState == NFA_SCREEN_STATE_ON_LOCKED &&
+             (state == NFA_SCREEN_STATE_OFF_LOCKED ||
+              state == NFA_SCREEN_STATE_OFF_UNLOCKED) &&
+             sIsSecElemSelected)) {
+          if (auto_num != 0x01) {
+            DLOG_IF(INFO, nfc_debug_enabled)
+                << StringPrintf("Start RF discovery");
+            startRfDiscovery(true);
+          }
         }
-        break;
-    default:
-        break;
+        StoreScreenState(state);
+      }
+      if (sAutonomousSet == 1) {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Send Core reset");
+        NxpNfc_Send_CoreResetInit_Cmd();
+      }
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: auto_num : %lu  sAutonomousSet : %d  sRfFieldOff : %d", __func__,
+          auto_num, sAutonomousSet, sRfFieldOff);
+      if ((auto_num == 0x01) && (sAutonomousSet != 1) &&
+          (sRfFieldOff == true) && (state == NFA_SCREEN_STATE_OFF_LOCKED ||
+                                    state == NFA_SCREEN_STATE_OFF_UNLOCKED)) {
+
+        status = SendAutonomousMode(state, 0x01);
+        sAutonomousSet = 1;
+      } else {
+        sAutonomousSet = 0;
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "Not sending AUTONOMOUS command state is %d", state);
+        if (!sRfEnabled) {
+          // Start RF discovery if not
+          startRfDiscovery(true);
+        }
+      }
     }
-    ALOGV("%ld: nfcManager_doGetSeInterface", num);
-    return num;
-}
+#if (NXP_EXTNS == TRUE)
+    pTransactionController->transactionEnd(
+        TRANSACTION_REQUESTOR(setScreenState));
+#endif
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Exit", __func__);
+  }
+#if (NXP_EXTNS == TRUE)
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_doSetScreenOrPowerState
+  **                  This function combines both screen state and power
+  *state(ven power) values.
+  **
+  ** Description:     Set screen or power state
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **                  state:represents power or screen state (0-3 screen
+  *state),6 (power on),7(power off)
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  static void nfcManager_doSetScreenOrPowerState(JNIEnv * e, jobject o,
+                                                 jint state) {
+    LOG(ERROR) << StringPrintf("%s: Enter", __func__);
+    if ((state & NFA_SCREEN_STATE_MASK) <=
+        NFA_SCREEN_STATE_ON_UNLOCKED)  // SCREEN_STATE
+      nfcManager_doSetScreenState(e, o, state);
+    else if ((state & NFA_SCREEN_STATE_MASK) ==
+             VEN_POWER_STATE_ON)  // POWER_ON NFC_OFF
+    {
+      nfcManager_doSetNfcMode(e, o, NFC_MODE_OFF);
+    } else if ((state & NFA_SCREEN_STATE_MASK) ==
+               VEN_POWER_STATE_OFF)  // POWER_OFF
+    {
+      if (sIsNfaEnabled) {
+        if (nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION &&
+            (SecureElement::getInstance().mDownloadMode == JCOP_DOWNLOAD)) {
+          DwpChannel::getInstance().forceClose();
+        }
+        nfcManager_doSetNfcMode(e, o, NFC_MODE_ON);  // POWER_OFF NFC_ON
+      } else {
+        nfcManager_doSetNfcMode(e, o, NFC_MODE_OFF);  // POWER_OFF NFC_OFF
+      }
+    } else
+      LOG(ERROR) << StringPrintf("%s: unknown screen or power state. state=%d",
+                                 __func__, state);
+  }
+  /*******************************************************************************
+   **
+   ** Function:        nfcManager_isRequestPending()
+   **
+   ** Description:     Checks If any pending request
+   **
+   ** Returns:         true if any request pending else false
+   **
+   *******************************************************************************/
+  bool nfcManager_isRequestPending(void) {
+    bool isPending = false;
+    if ((transaction_data.current_transcation_state !=
+         NFA_TRANS_DM_RF_TRANS_END) &&
+        ((pendingScreenState == true) || (get_last_request() != 0x00))) {
+      isPending = true;
+    }
+    return isPending;
+  }
+#endif
+  /*******************************************************************************
+   **
+   ** Function:       get_last_request
+   **
+   ** Description:    returns the last enable/disable discovery event
+   **
+   ** Returns:        last request (char) .
+   **
+   *******************************************************************************/
+  static char get_last_request() { return (transaction_data.last_request); }
+  /*******************************************************************************
+   **
+   ** Function:       set_last_request
+   **
+   ** Description:    stores the last enable/disable discovery event
+   **
+   ** Returns:        None .
+   **
+   *******************************************************************************/
+  static void set_last_request(char status, struct nfc_jni_native_data* nat) {
+    if ((status == ENABLE_DISCOVERY) || (status == DISABLE_DISCOVERY)) {
+      transaction_data.last_request &= CLEAR_ENABLE_DISABLE_PARAM;
+    }
+#if (NXP_EXTNS == TRUE && NXP_NFCC_HCE_F == TRUE)
+    transaction_data.last_request |= status;
+#else
+  transaction_data.last_request = status;
+#endif
+    if (nat != NULL) {
+      transaction_data.transaction_nat = nat;
+    }
+  }
+  /*******************************************************************************
+   **
+   ** Function:       get_lastScreenStateRequest
+   **
+   ** Description:    returns the last screen state request
+   **
+   ** Returns:        last screen state request event (eScreenState_t) .
+   **
+   *******************************************************************************/
+  static eScreenState_t get_lastScreenStateRequest() {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: %d", __func__, transaction_data.last_screen_state_request);
+    return (transaction_data.last_screen_state_request);
+  }
+
+  /*******************************************************************************
+   **
+   ** Function:       set_lastScreenStateRequest
+   **
+   ** Description:    stores the last screen state request
+   **
+   ** Returns:        None .
+   **
+   *******************************************************************************/
+  static void set_lastScreenStateRequest(eScreenState_t status) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: current=%d, new=%d", __func__,
+                        transaction_data.last_screen_state_request, status);
+    transaction_data.last_screen_state_request = status;
+  }
 
-#if(NXP_EXTNS == TRUE)
-/**********************************************************************************
+/*******************************************************************************
 **
-** Function:       pollT3TThread
+** Function:        switchBackTimerProc_transaction
 **
-** Description:    This thread sends commands to switch from P2P to T3T
-**                 When ReaderMode is enabled, When P2P is detected,Switch to T3T
-**                 with Frame RF interface and Poll for T3T
+** Description:     Callback function for interval timer.
 **
-** Returns:         None.
+** Returns:         None
 **
-**********************************************************************************/
-static void* pollT3TThread(void *arg)
+*******************************************************************************/
+#if 0
+static void cleanupTimerProc_transaction(union sigval)
 {
-    ALOGV("%s: enter", __func__);
-    bool status=false;
-
-    if (sReaderModeEnabled && (sTechMask & NFA_TECHNOLOGY_MASK_F))
-    {
-     /*Deactivate RF to go to W4_HOST_SELECT state
-          *Send Select Command to Switch to FrameRF interface from NFCDEP interface
-          *After NFC-DEP activation with FrameRF Intf, invoke T3T Polling Cmd*/
-        {
-            SyncEventGuard g (sRespCbEvent);
-            if (NFA_STATUS_OK != (status = NFA_Deactivate (true))) //deactivate to sleep state
-            {
-                ALOGE("%s: deactivate failed, status = %d", __func__, status);
-            }
-            if (sRespCbEvent.wait (2000) == false) //if timeout occurred
-            {
-                ALOGE("%s: timeout waiting for deactivate", __func__);
-            }
-        }
-        {
-            SyncEventGuard g2 (sRespCbEvent);
-            ALOGV("Switching RF Interface from NFC-DEP to FrameRF for T3T\n");
-            if (NFA_STATUS_OK != (status = NFA_Select (*((uint8_t*)arg), NFA_PROTOCOL_T3T, NFA_INTERFACE_FRAME)))
-            {
-                ALOGE("%s: NFA_Select failed, status = %d", __func__, status);
-            }
-            if (sRespCbEvent.wait (2000) == false) //if timeout occured
-            {
-                ALOGE("%s: timeout waiting for select", __func__);
-            }
-        }
-    }
-    ALOGV("%s: exit", __func__);
-    pthread_exit(NULL);
-    return NULL;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Inside cleanupTimerProc");
+    cleanup_timer();
 }
 
-/**********************************************************************************
-**
-** Function:       switchP2PToT3TRead
-**
-** Description:    Create a thread to change the RF interface by Deactivating to Sleep
-**
-** Returns:         None.
-**
-**********************************************************************************/
-static bool switchP2PToT3TRead(uint8_t disc_id)
+void cleanup_timer()
 {
-    pthread_t pollT3TThreadId;
+DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Inside cleanup");
+    pthread_t transaction_thread;
     int irret = -1;
-    ALOGV("%s:entry", __func__);
-    felicaReader_Disc_id = disc_id;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
 
     /* Transcation is done process the last request*/
     pthread_attr_t attr;
     pthread_attr_init(&attr);
     pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-    irret = pthread_create(&pollT3TThreadId, &attr, pollT3TThread, (void*)&felicaReader_Disc_id);
+    irret = pthread_create(&transaction_thread, &attr, enableThread, NULL);
     if(irret != 0)
     {
-        ALOGE("Unable to create the thread");
+        LOG(ERROR) << StringPrintf("Unable to create the thread");
     }
     pthread_attr_destroy(&attr);
-    ALOGV("%s:exit", __func__);
-    return irret;
-}
-
-static void NxpResponsePropCmd_Cb(uint8_t /* event */, uint16_t param_len, uint8_t *p_param)
-{
-    ALOGV("NxpResponsePropCmd_Cb Received length data = 0x%x status = 0x%x", param_len, p_param[3]);
-    SyncEventGuard guard (sNfaNxpNtfEvent);
-    sNfaNxpNtfEvent.notifyOne ();
-}
-
-/*******************************************************************************
-**
-** Function:        nfcManager_setProvisionMode
-**
-** Description:     set/reset provision mode
-**                  e: JVM environment.
-**                  o: Java object.
-**
-** Returns:         None.
-**
-*******************************************************************************/
-static void nfcManager_setProvisionMode(JNIEnv* e, jobject o, jboolean provisionMode)
-{
-    ALOGV("Enter :%s  provisionMode = %d", __func__,provisionMode);
-    sProvisionMode = provisionMode;
-    NFA_setProvisionMode(provisionMode);
-    // When disabling provisioning mode, make sure configuration of routing table is also updated
-    // this is required to make sure p2p is blocked during locked screen
-    if ( !provisionMode )
-    {
-       RoutingManager::getInstance().commitRouting();
-    }
+    transaction_data.current_transcation_state = NFA_TRANS_DM_RF_TRANS_END;
 }
+#endif
 
+#if (NXP_EXTNS == TRUE)
 /*******************************************************************************
  **
- ** Function:        isActivatedTypeF
+ ** Function:       update_transaction_stat
  **
- ** Description:     Indicates whether the activation data indicates it is
- **                  TypeF technology.
+ ** Description:    updates the transaction status set/reset
+ **                 req_handle : Requesting handle - Module name
+ **                 req_state : SET_TRANSACTION_STATE / RESET_TRANSACTION_STATE
  **
- ** Returns:         True if activated technology is TypeF.
+ ** Returns:        update status
+ **                 ret_stat : true/false
  **
  *******************************************************************************/
-static bool isActivatedTypeF(tNFA_ACTIVATED& activated)
-{
-    return ((NFC_DISCOVERY_TYPE_POLL_F == activated.activate_ntf.rf_tech_param.mode)
-            || (NFC_DISCOVERY_TYPE_POLL_F_ACTIVE == activated.activate_ntf.rf_tech_param.mode)
-            || (NFC_DISCOVERY_TYPE_LISTEN_F == activated.activate_ntf.rf_tech_param.mode)
-            || (NFC_DISCOVERY_TYPE_LISTEN_F_ACTIVE == activated.activate_ntf.rf_tech_param.mode));
-}
-
-/**********************************************************************************
- **
- ** Function:        checkforNfceeBuffer
- **
- ** Description:    checking for the Nfcee Buffer (GetConfigs for SWP_INT_SESSION_ID (EA and EB))
- **
- ** Returns:         None .
- **
- **********************************************************************************/
-void checkforNfceeBuffer()
+#if 0
+bool update_transaction_stat(const char * req_handle, transaction_state_t req_state)
 {
-    int i, count = 0;
+    bool ret_stat = false;
 
-    for(i=4;i<12;i++)
+    gTransactionMutex.lock();
+    /*Check if it is initialisation*/
+    if((req_handle == NULL)&&(req_state == RESET_TRANSACTION_STATE))
     {
-        if(sConfig[i] == 0xff)
-            count++;
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Initialisation. Resetting transaction data", __func__);
+        transaction_data.trans_in_progress = false;
+        cur_transaction_handle = NULL;
+        ret_stat = true;
     }
-
-    if(count >= 8)
+    else
     {
-        /*If session ID received all 0xff for UICC and dual UICC feature is enabled then
-         * clear the corresponding buffer (invalid session ID)
-         * */
-        if(nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH &&
-                ((sConfig[1] == 0xA0) && (sConfig[2] == 0xEA) &&
-                        (dualUiccInfo.dualUiccEnable == 0x01)))
-        {
-            if(sSelectedUicc == 0x01)
-            {
-                memset(dualUiccInfo.sUicc1SessionId,0x00,sizeof(dualUiccInfo.sUicc1SessionId));
-                dualUiccInfo.sUicc1SessionIdLen = 0;
-            }
-            else
-            {
-                memset(dualUiccInfo.sUicc2SessionId,0x00,sizeof(dualUiccInfo.sUicc2SessionId));
-                dualUiccInfo.sUicc2SessionIdLen = 0;
-            }
-        }
-        sNfceeConfigured = 1;
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Enter. Requested by : %s   Requested state : %s", __func__,req_handle,(req_state?"SET":"RESET"));
     }
-    else
+
+    /*Check if no transaction is currently ongoing*/
+    if(!transaction_data.trans_in_progress)
     {
-        if(nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
-            if((sConfig[1] == 0xA0) && (sConfig[2] == 0xEA) &&
-                    (dualUiccInfo.dualUiccEnable == 0x01))
+        if(req_state == SET_TRANSACTION_STATE)
+        {
+            transaction_data.trans_in_progress = req_state;
+            cur_transaction_handle = req_handle;
+            ret_stat = true;
+            /*Using a backup reset procedure as a timer to reset Transaction state,
+             *in case Transaction state is set but not reset because of some reason
+             *
+             *Also timer should not be started for below handles as these may take
+             *more time to reset depending on the transaction duration
+             **/
+            if(strcmp(req_handle,"NFA_ACTIVATED_EVT") &&
+                    strcmp(req_handle,"NFA_EE_ACTION_EVT") &&
+                    strcmp(req_handle,"NFA_TRANS_CE_ACTIVATED") &&
+                    strcmp(req_handle,"RF_FIELD_EVT") )
             {
-                sNfceeConfigured = getUiccSession();
-            }
-            else {
-                sNfceeConfigured = 0;
+                scleanupTimerProc_transaction.set (10000, cleanupTimerProc_transaction);
             }
+
         }
-        else {
-            sNfceeConfigured = 0;
+        else
+        {
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s:Transaction state is already free. Returning", __func__);
+            cur_transaction_handle = NULL;
+            ret_stat = true;
+            scleanupTimerProc_transaction.kill ();
         }
     }
-
-    memset (sConfig, 0, sizeof (sConfig));
-
-}
-/**********************************************************************************
- **
- ** Function:        checkforNfceeConfig
- **
- ** Description:    checking for the Nfcee is configured or not (GetConfigs for SWP_INT_SESSION_ID (EA and EB))
- **
- ** Returns:         None .
- **
- **********************************************************************************/
-void checkforNfceeConfig(uint8_t type)
-{
-    uint8_t uicc_flag = 0,ese_flag = 0;
-    uint8_t uicc2_flag=0; /*For Dynamic Dual UICC*/
-    unsigned long timeout_buff_val=0,check_cnt=0,retry_cnt=0;
-
-    tNFA_STATUS status;
-    tNFA_PMID param_ids_UICC[]                  = {0xA0, 0xEA};
-    tNFA_PMID param_ids_eSE[]                   = {0xA0, 0xEB};
-    tNFA_PMID param_uicc1[] = {0xA0, 0x24};
-    tNFA_PMID param_ids_UICC2[]                 = {0xA0, 0x1E};
-    tNFA_PMID param_uicc2[] = {0xA0, 0xE9};
-
-    ALOGV("%s: enter, type=%x", __func__, type);
-    uint8_t pipeId = 0;
-    SecureElement::getInstance().updateEEStatus();
-    bool configureuicc1 = false;
-    bool configureuicc2 = false;
-
-    status = GetNxpNumValue(NAME_NXP_DEFAULT_NFCEE_TIMEOUT, (void*)&timeout_buff_val, sizeof(timeout_buff_val));
-
-    if(status == true)
-    {
-        check_cnt = timeout_buff_val*RETRY_COUNT;
-    }
     else
     {
-        check_cnt = DEFAULT_COUNT*RETRY_COUNT;
-    }
-
-    ALOGV("NAME_DEFAULT_NFCEE_TIMEOUT = %lu", check_cnt);
-
-    if(SecureElement::getInstance().getEeStatus(SecureElement::EE_HANDLE_0xF3) == NFC_NFCEE_STATUS_ACTIVE)
-    {
-        ese_flag = 0x01;
-        ALOGV("eSE_flag SET");
-    }
-    if(SecureElement::getInstance().getEeStatus(SecureElement::getInstance().EE_HANDLE_0xF4) == NFC_NFCEE_STATUS_ACTIVE)
-    {
-        uicc_flag = 0x01;
-        ALOGV("uicc_flag SET");
-    }
-    if(nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC) {
-        if(SecureElement::getInstance().getEeStatus(SecureElement::EE_HANDLE_0xF8) == NFC_NFCEE_STATUS_ACTIVE)
+        /*If transaction_stat is already set (transaction is ongoing) it can not be set again*/
+        if(req_state == SET_TRANSACTION_STATE)
         {
-            uicc2_flag = 0x01;
-            ALOGV("uicc2_flag SET");
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s:Transaction is in progress by : %s . Returning", __func__,cur_transaction_handle);
+            ret_stat = false;
         }
-    } else if(nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
-        if (dualUiccInfo.dualUiccEnable == 0x01)
+        else
         {
-            if(sSelectedUicc == 0x01)
+            /*If transaction_stat is already set only authorised module can reset it
+             *It should be either cur_transaction_handle (which has set transaction_stat) or
+             *exec_pending_req*/
+            if(cur_transaction_handle != NULL)
             {
-                memset(dualUiccInfo.sUicc1SessionId,0x00,sizeof(dualUiccInfo.sUicc1SessionId));
-                dualUiccInfo.sUicc1SessionIdLen = 0;
+                if(!strcmp(cur_transaction_handle,req_handle) || !strcmp(req_handle,"exec_pending_req"))
+                {
+                    transaction_data.trans_in_progress = req_state;
+                    cur_transaction_handle = NULL;
+                    ret_stat = true;
+                    scleanupTimerProc_transaction.kill ();
+                }
+                else
+                {
+                    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s:Handle Mismatch. Returning ..cur_transaction_handle : %s   Requested handle  : %s ", __func__,cur_transaction_handle,req_handle);
+                    ret_stat = false;
+                }
             }
             else
             {
-                memset(dualUiccInfo.sUicc2SessionId,0x00,sizeof(dualUiccInfo.sUicc2SessionId));
-                dualUiccInfo.sUicc2SessionIdLen = 0;
+                DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: No cur_transaction_handle. Allowing requested handle  : %s ", __func__,req_handle);
+                transaction_data.trans_in_progress = req_state;
+                cur_transaction_handle = req_handle;
+                ret_stat = true;
+                scleanupTimerProc_transaction.kill ();
             }
         }
     }
-    if((ese_flag == 0x01)||(uicc_flag == 0x01)||(uicc2_flag == 0x01))
-    {
-        if(nfcFL.nfcNxpEse && (ese_flag && ((type & ESE) == ESE)))
-        {
-            sCheckNfceeFlag = 1;
-            {
-                SyncEventGuard guard (android::sNfaGetConfigEvent);
-                while(check_cnt > retry_cnt)
-                {
-                    status = NFA_GetConfig(0x01,param_ids_eSE);
-                    if(status == NFA_STATUS_OK)
-                    {
-                        android::sNfaGetConfigEvent.wait();
-                    }
-                    if(sNfceeConfigured == 1)
-                    {
-                        SecureElement::getInstance().meSESessionIdOk = false;
-                        ALOGV("eSE Not Configured");
-                    }
-                    else
-                    {
-                        SecureElement::getInstance().meSESessionIdOk = true;
-                        ALOGV("eSE Configured");
-                        break;
-                    }
-
-                    usleep(100000);
-                    retry_cnt++;
-                }
-            }
-            if(check_cnt <= retry_cnt)
-                ALOGV("eSE Not Configured");
-            retry_cnt=0;
-        }
-
-        if(nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC &&
-                (uicc2_flag && ((type & UICC2) == UICC2)))
-        {
-            sCheckNfceeFlag = 1;
-            {
-                SyncEventGuard guard (android::sNfaGetConfigEvent);
-                while(check_cnt > retry_cnt)
-                {
-                    status = NFA_GetConfig(0x01,param_ids_UICC2);
-                    if(status == NFA_STATUS_OK)
-                    {
-                        android::sNfaGetConfigEvent.wait();
-                    }
-
-                    if(sNfceeConfigured == 1)
-                    {
-                        ALOGV("UICC2 Not Configured");
-                    }
-                    else
-                    {
-                        ALOGV("UICC2 Configured connectivity pipeId = %x",pipeId);
-                        configureuicc2 = true;
-                        if(nfcFL.nfccFL._UICC_CREATE_CONNECTIVITY_PIPE != true) {
-                            break;
-                        }
-                    }
-                    if(nfcFL.nfccFL._UICC_CREATE_CONNECTIVITY_PIPE) {
-                        if((configureuicc2 == true) || (check_cnt == retry_cnt))
-                        {
-                            configureuicc2 = false;
-                            pipeId =SecureElement::getInstance().getUiccGateAndPipeList(SecureElement::getInstance().EE_HANDLE_0xF8 & ~NFA_HANDLE_GROUP_EE);
-                            if(pipeId == 0)
-                            {
-                                ALOGV("Add pipe information");
-                                sCheckNfceeFlag = 0;
-                                status = NFA_GetConfig(0x01,param_uicc2);
-                                pipeId = 0x23;
-
-                                if(status == NFA_STATUS_OK)
-                                {
-                                    android::sNfaGetConfigEvent.wait();
-                                }
-                                sCheckNfceeFlag = 1;
-                                ALOGV("UICC2 connectivity gate present = %s", (sConfig[NFC_PIPE_STATUS_OFFSET]?"true":"false"));
-                                /*If pipe is present and opened update MW status*/
-                                if(sConfig[NFC_PIPE_STATUS_OFFSET] > PIPE_DELETED)
-                                {
-                                    SyncEventGuard guard(SecureElement::getInstance().mHciAddStaticPipe);
-                                    status = NFA_HciAddStaticPipe(SecureElement::getInstance().getHciHandleInfo(),
-                                            0x81, NFA_HCI_CONNECTIVITY_GATE, pipeId);
-                                    if(status == NFA_STATUS_OK)
-                                    {
-                                        SecureElement::getInstance().mHciAddStaticPipe.wait(500);
-                                    }
-                                }
-                            }
-                            break;
-                        }
-                    }
-                    usleep(100000);
-                    retry_cnt++;
-                }
-            }
-
-            if(check_cnt <= retry_cnt)
-                ALOGV("UICC2 Not Configured");
-            retry_cnt=0;
-            pipeId = 0;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Exit.  Requested by : %s   Requested state : %s  status : %s", __func__,req_handle,(req_state?"SET":"RESET"), (ret_stat?"SUCCESS":"FAILED"));
+    gTransactionMutex.unlock();
+    return ret_stat;
+}
+#endif
+#endif
+  /*******************************************************************************
+   **
+   ** Function:        checkforTranscation
+   **
+   ** Description:     Receive connection-related events from stack.
+   **                  connEvent: Event code.
+   **                  eventData: Event data.
+   **
+   ** Returns:         None
+   **
+   *******************************************************************************/
+  void checkforTranscation(uint8_t connEvent, void* eventData) {
+    tNFA_CONN_EVT_DATA* eventAct_Data = (tNFA_CONN_EVT_DATA*)eventData;
+    tNFA_DM_CBACK_DATA* eventDM_Conn_data = (tNFA_DM_CBACK_DATA*)eventData;
+    tNFA_EE_CBACK_DATA* ee_action_data = (tNFA_EE_CBACK_DATA*)eventData;
+    tNFA_EE_ACTION& action = ee_action_data->action;
+
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: enter; event=0x%X transaction_data.current_transcation_state = "
+        "0x%x",
+        __func__, connEvent, transaction_data.current_transcation_state);
+    switch (connEvent) {
+      case NFA_ACTIVATED_EVT:
+        if ((eventAct_Data->activated.activate_ntf.protocol !=
+             NFA_PROTOCOL_NFC_DEP) &&
+            (isListenMode(eventAct_Data->activated))) {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("ACTIVATED_EVT setting flag");
+          transaction_data.current_transcation_state = NFA_TRANS_ACTIVATED_EVT;
+#if (NXP_EXTNS == TRUE)
+          if (!pTransactionController->transactionAttempt(
+                  TRANSACTION_REQUESTOR(NFA_ACTIVATED_EVENT))) {
+            LOG(ERROR) << StringPrintf(
+                "%s: Transaction in progress. Can not set", __func__);
+          }
+#endif
+        } else {
+          //            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("other
+          //            event clearing flag ");
+          //            memset(&transaction_data, 0x00,
+          //            sizeof(Transcation_Check_t));
         }
-        if(uicc_flag && ((type & UICC1) == UICC1))
-        {
-            sCheckNfceeFlag = 1;
-            {
-                SyncEventGuard guard (android::sNfaGetConfigEvent);
-                while(check_cnt > retry_cnt)
-                {
-                    status = NFA_GetConfig(0x01,param_ids_UICC);
-                    if(status == NFA_STATUS_OK)
-                    {
-                        android::sNfaGetConfigEvent.wait();
-                    }
-
-                    if(sNfceeConfigured == 1)
-                    {
-                        ALOGV("UICC Not Configured");
-                    }
-                    else
-                    {
-                        if(nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH)
-                            dualUiccInfo.uiccConfigStat = UICC_CONFIGURED;
-                        ALOGV("UICC1 Configured connectivity pipeId = %x",pipeId);
-                        configureuicc1 = true;
-                        if(nfcFL.nfccFL._UICC_CREATE_CONNECTIVITY_PIPE == false) {
-                            break;
-                        }
-                    }
-                    if(nfcFL.nfccFL._UICC_CREATE_CONNECTIVITY_PIPE) {
-                        if((configureuicc1 == true) || (check_cnt == retry_cnt))
-                        {
-                            configureuicc1 = false;
-                            pipeId =SecureElement::getInstance().getUiccGateAndPipeList(SecureElement::getInstance().EE_HANDLE_0xF4 & ~NFA_HANDLE_GROUP_EE);
-                            if(pipeId == 0)
-                            {
-                                ALOGV("Add pipe information");
-                                sCheckNfceeFlag = 0;
-                                status = NFA_GetConfig(0x01,param_uicc1);
-                                pipeId = 0x0A;
-                                if(status == NFA_STATUS_OK)
-                                {
-                                    android::sNfaGetConfigEvent.wait();
-                                }
-                                sCheckNfceeFlag = 1;
-                                ALOGV("UICC1 connectivity gate present = %s", (sConfig[NFC_PIPE_STATUS_OFFSET]?"true":"false"));
-                                /*If pipe is present and opened update MW status*/
-                                if(sConfig[NFC_PIPE_STATUS_OFFSET] > PIPE_DELETED)
-                                {
-                                    SyncEventGuard guard(SecureElement::getInstance().mHciAddStaticPipe);
-                                    status = NFA_HciAddStaticPipe(SecureElement::getInstance().getHciHandleInfo(),
-                                            0x02, NFA_HCI_CONNECTIVITY_GATE, pipeId);
-                                    if(status == NFA_STATUS_OK)
-                                    {
-                                        SecureElement::getInstance().mHciAddStaticPipe.wait();
-                                    }
-                                }
-                            }
-                            break;
-                        }
-                    }
-                    usleep(100000);
-                    retry_cnt++;
-                }
+        break;
+      case NFA_EE_ACTION_EVT:
+        if (transaction_data.current_transcation_state == NFA_TRANS_DEFAULT ||
+            transaction_data.current_transcation_state ==
+                NFA_TRANS_ACTIVATED_EVT) {
+          if (getScreenState() == NFA_SCREEN_STATE_OFF_LOCKED ||
+              getScreenState() == NFA_SCREEN_STATE_OFF_UNLOCKED) {
+            if (!sP2pActive &&
+                eventDM_Conn_data->rf_field.status == NFA_STATUS_OK)
+              SecureElement::getInstance().notifyRfFieldEvent(true);
+          }
+          if (nfcFL.chipType == pn547C2) {
+            if ((action.param.technology == NFC_RF_TECHNOLOGY_A) &&
+                ((getScreenState() == NFA_SCREEN_STATE_OFF_UNLOCKED ||
+                  getScreenState() == NFA_SCREEN_STATE_ON_LOCKED ||
+                  getScreenState() == NFA_SCREEN_STATE_OFF_LOCKED))) {
+              transaction_data.current_transcation_state =
+                  NFA_TRANS_MIFARE_ACT_EVT;
+#if (NXP_EXTNS == TRUE)
+              if (!pTransactionController->transactionAttempt(
+                      TRANSACTION_REQUESTOR(NFA_EE_ACTION_EVENT))) {
+                LOG(ERROR) << StringPrintf(
+                    "%s: Transaction in progress. Can not set", __func__);
+              }
+#endif
             }
-
-            if(check_cnt <= retry_cnt)
-                ALOGE("UICC Not Configured");
-            retry_cnt=0;
-            if(nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
-                sCheckNfceeFlag = 0;
+          } else {
+            transaction_data.current_transcation_state =
+                NFA_TRANS_EE_ACTION_EVT;
+#if (NXP_EXTNS == TRUE)
+            if (!pTransactionController->transactionAttempt(
+                    TRANSACTION_REQUESTOR(NFA_EE_ACTION_EVENT))) {
+              LOG(ERROR) << StringPrintf(
+                  "%s: Transaction in progress. Can not set", __func__);
             }
+#endif
+          }
+        }
+        break;
+      case NFA_TRANS_CE_ACTIVATED:
+        if (transaction_data.current_transcation_state == NFA_TRANS_DEFAULT ||
+            transaction_data.current_transcation_state ==
+                NFA_TRANS_ACTIVATED_EVT) {
+          if (getScreenState() == NFA_SCREEN_STATE_OFF_LOCKED ||
+              getScreenState() == NFA_SCREEN_STATE_OFF_UNLOCKED) {
+            if (!sP2pActive &&
+                eventDM_Conn_data->rf_field.status == NFA_STATUS_OK)
+              SecureElement::getInstance().notifyRfFieldEvent(true);
+          }
+          transaction_data.current_transcation_state = NFA_TRANS_CE_ACTIVATED;
+#if (NXP_EXTNS == TRUE)
+          if (!pTransactionController->transactionAttempt(
+                  TRANSACTION_REQUESTOR(NFA_TRANS_CE_ACTIVATED_EVENT))) {
+            LOG(ERROR) << StringPrintf(
+                "%s: Transaction in progress. Can not set", __func__);
+          }
+#endif
+        }
+        break;
+      case NFA_TRANS_CE_DEACTIVATED:
+        rfActivation = false;
+#if (NXP_EXTNS == TRUE)
+        if (transaction_data.current_transcation_state ==
+            NFA_TRANS_CE_ACTIVATED) {
+          transaction_data.current_transcation_state = NFA_TRANS_CE_DEACTIVATED;
+        }
+#endif
+        gActivated = false;
+        break;
+      case NFA_DEACTIVATED_EVT:
+        if (nfcFL.chipType == pn547C2) {
+          if (transaction_data.current_transcation_state ==
+              NFA_TRANS_MIFARE_ACT_EVT) {
+            pTransactionController->lastRequestResume();
+          }
+        }
+        break;
+      case NFA_TRANS_DM_RF_FIELD_EVT:
+        if (eventDM_Conn_data->rf_field.status == NFA_STATUS_OK &&
+            (transaction_data.current_transcation_state ==
+                 NFA_TRANS_EE_ACTION_EVT ||
+             transaction_data.current_transcation_state ==
+                 NFA_TRANS_CE_DEACTIVATED ||
+             transaction_data.current_transcation_state ==
+                 NFA_TRANS_CE_ACTIVATED ||
+             transaction_data.current_transcation_state ==
+                 NFA_TRANS_ACTIVATED_EVT) &&
+            eventDM_Conn_data->rf_field.rf_field_status == 0) {
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("start_timer");
+          if (nfcFL.chipType != pn547C2) {
+            set_AGC_process_state(false);
+          }
+          transaction_data.current_transcation_state =
+              NFA_TRANS_DM_RF_FIELD_EVT_OFF;
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("Start guard RF ON timer");
+          pTransactionController->setAbortTimer(50 /*msec*/);
+        } else if (eventDM_Conn_data->rf_field.status == NFA_STATUS_OK &&
+                   transaction_data.current_transcation_state ==
+                       NFA_TRANS_DM_RF_FIELD_EVT_OFF &&
+                   eventDM_Conn_data->rf_field.rf_field_status == 1) {
+          if (nfcFL.chipType != pn547C2) {
+            nfcManagerEnableAGCDebug(connEvent);
+          }
+          transaction_data.current_transcation_state =
+              NFA_TRANS_DM_RF_FIELD_EVT_ON;
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "Payment is in progress hold the screen on/off request ");
+          transaction_data.current_transcation_state =
+              NFA_TRANS_DM_RF_TRANS_START;
+          pTransactionController->killAbortTimer();
+
+        } else if (eventDM_Conn_data->rf_field.status == NFA_STATUS_OK &&
+                   transaction_data.current_transcation_state ==
+                       NFA_TRANS_DM_RF_TRANS_START &&
+                   eventDM_Conn_data->rf_field.rf_field_status == 0) {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("Transcation is done");
+          pTransactionController->transactionEnd(
+              TRANSACTION_REQUESTOR(RF_FIELD_EVT));
+          if (nfcFL.chipType != pn547C2) {
+            set_AGC_process_state(false);
+          }
+          transaction_data.current_transcation_state =
+              NFA_TRANS_DM_RF_TRANS_PROGRESS;
+          pTransactionController->lastRequestResume();
+        } else if (eventDM_Conn_data->rf_field.status == NFA_STATUS_OK &&
+                   transaction_data.current_transcation_state ==
+                       NFA_TRANS_ACTIVATED_EVT &&
+                   eventDM_Conn_data->rf_field.rf_field_status == 0) {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("No transaction done cleaning up the variables");
+          pTransactionController->lastRequestResume();
         }
+        break;
+      default:
+        break;
     }
 
-    sCheckNfceeFlag = 0;
-
-    if(nfcFL.eseFL._JCOP_WA_ENABLE) {
-        RoutingManager::getInstance().handleSERemovedNtf();
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: exit; event=0x%X transaction_data.current_transcation_state = "
+        "0x%x",
+        __func__, connEvent, transaction_data.current_transcation_state);
+  }
+
+  /*******************************************************************************
+   **
+   ** Function:       enableThread
+   **
+   ** Description:    thread to trigger enable/disable discovery related events
+   **
+   ** Returns:        None .
+   **
+   *******************************************************************************/
+  void* enableThread(void* arg) {
+    (void)arg;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+    char last_request = get_last_request();
+    eScreenState_t last_screen_state_request = get_lastScreenStateRequest();
+    if (nfcFL.chipType != pn547C2) {
+      set_AGC_process_state(false);
     }
 
-}
-#endif
-
-#if(NXP_EXTNS == TRUE)
-static void nfaNxpSelfTestNtfTimerCb (union sigval)
-{
-    ALOGV("%s", __func__);
-    ALOGV("NXP SWP SelfTest : Can't get a notification about SWP Status!!");
-    SyncEventGuard guard (sNfaNxpNtfEvent);
-    sNfaNxpNtfEvent.notifyOne ();
-    SetCbStatus(NFA_STATUS_FAILED);
-}
-
-/**********************************************************************************
- **
- ** Function:        performNfceeETSI12Config
- **
- ** Description:    checking for Nfcee ETSI 12 Compliancy and configure if compliant
- **
- ** Returns:         None .
- **
- **********************************************************************************/
-void performNfceeETSI12Config()
-{
-    bool status;
-    tNFA_STATUS configstatus = NFA_STATUS_FAILED;
-    ALOGV("%s", __func__);
-
-    SecureElement::getInstance().setNfccPwrConfig
-        (SecureElement::getInstance().POWER_ALWAYS_ON|
-            SecureElement::getInstance().COMM_LINK_ACTIVE);
+    bool screen_lock_flag = false;
+    bool disable_discovery = false;
 
-    status = SecureElement::getInstance().configureNfceeETSI12();
-    if(status == true)
     {
-        {
-            SyncEventGuard guard (SecureElement::getInstance().mNfceeInitCbEvent);
-            if(SecureElement::getInstance().mNfceeInitCbEvent.wait(4000) == false)
-            {
-                ALOGE("%s:     timeout waiting for Nfcee Init event", __func__);
-            }
-        }
-        if(SecureElement::getInstance().mETSI12InitStatus != NFA_STATUS_OK)
-        {
-            //check for recovery
-            configstatus = ResetEseSession();
-            if(configstatus == NFA_STATUS_OK)
-            {
-                SecureElement::getInstance().meseETSI12Recovery = true;
-                SecureElement::getInstance().SecEle_Modeset(0x00);
-                usleep(50*1000);
-                SecureElement::getInstance().SecEle_Modeset(0x01);
-                SecureElement::getInstance().meseETSI12Recovery = false;
-            }
-        }
-    }
-
-}
+      SyncEventGuard guard (sExecPendingRegEvent);
+      if(sIsNfaEnabled != true || sIsDisabling == true) goto TheEnd;
 
-/**********************************************************************************
- **
- ** Function:       performHCIInitialization
- **
- ** Description:    Performs HCI and SWP interface Initialization
- **
- ** Returns:         None .
- **
- **********************************************************************************/
-static void performHCIInitialization (JNIEnv* e, jobject o)
-{
-    NFCSTATUS status = NFA_STATUS_FAILED;
-    ALOGV("%s", __func__);
-    GetNumNFCEEConfigured();
-    status = android::enableSWPInterface();
-    if(status == NFA_STATUS_OK)
-    {
-        RoutingManager::getInstance().nfaEEDisconnect();
-        usleep(1000 * 1000);
-        android::NxpNfc_Send_CoreResetInit_Cmd();
-        /*Update Actual SE count gActualSeCount*/
-        GetNumNFCEEConfigured();
-        RoutingManager::getInstance().nfaEEConnect();
-        SecureElement::getInstance().activateAllNfcee();
-        sIsSecElemSelected = (SecureElement::getInstance().getActualNumEe() - 1 );
-        sIsSecElemDetected = sIsSecElemSelected;
-    }
-    else
-    {
-        ALOGE("No UICC update required/failed to enable SWP interfaces");
+      sIsExecPendingReq = true;
     }
-}
-
-void checkforESERemoval()
-{
-    ALOGD("checkforESERemoval enter");
 
-    bool nfaEseRemovedNtf = true;
-    uint8_t numNfceePresent = SecureElement::getInstance().mNfceeData_t.mNfceePresent;
-    tNFA_HANDLE nfceeHandle[MAX_NFCEE];
-    tNFA_EE_STATUS nfceeStatus[MAX_NFCEE];
+    if (last_screen_state_request != NFA_SCREEN_STATE_UNKNOWN) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "update last screen state request: %d", last_screen_state_request);
+      nfcManager_doSetScreenState(NULL, NULL, last_screen_state_request);
+      set_lastScreenStateRequest(NFA_SCREEN_STATE_UNKNOWN);
+      if (last_screen_state_request == NFA_SCREEN_STATE_ON_LOCKED)
+        screen_lock_flag = true;
+    } else {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("No request pending");
+    }
 
-    uint8_t retry = 0;
-    uint8_t mActualNumEe = SecureElement::MAX_NUM_EE;
-    tNFA_EE_INFO mEeInfo[mActualNumEe];
-    uint8_t eseDetected = 0;
+    if (last_request & ENABLE_DISCOVERY) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("send the last request enable");
+      sDiscoveryEnabled = false;
+      sPollingEnabled = false;
 
-    for(int i = 1; i <= numNfceePresent; i++)
-    {
-        nfceeHandle[i] = SecureElement::getInstance().mNfceeData_t.mNfceeHandle[i];
-        nfceeStatus[i] = SecureElement::getInstance().mNfceeData_t.mNfceeHandle[i];
+      transaction_data.last_request &= ~(ENABLE_DISCOVERY);
+      nfcManager_enableDiscovery(
+          NULL, NULL, transaction_data.discovery_params.technologies_mask,
+          transaction_data.discovery_params.enable_lptd,
+          transaction_data.discovery_params.reader_mode,
+          transaction_data.discovery_params.enable_p2p,
+          transaction_data.discovery_params.restart);
+    }
 
-        if(nfceeHandle[i] == (SecureElement::EE_HANDLE_0xF3) && nfceeStatus[i] == 0x0)
-        {
-            nfaEseRemovedNtf = false;
-            break;
-        }
+    if (last_request & DISABLE_DISCOVERY) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("send the last request disable");
+      transaction_data.last_request &= ~(DISABLE_DISCOVERY);
+      nfcManager_disableDiscovery(NULL, NULL);
+      disable_discovery = true;
     }
-    if(nfaEseRemovedNtf)
-    {
-        ALOGD("nfaEseRemovedNtf true");
-        tNFA_STATUS configstatus = NFA_STATUS_FAILED;
-        do {
-            if ((configstatus = NFA_AllEeGetInfo (&mActualNumEe, mEeInfo)) != NFA_STATUS_OK)
-            {
-                ALOGE ("unable to get the EE status");
-            }
-            else
-            {
-                for(int xx = 0; xx <  mActualNumEe; xx++)
-                {
-                    ALOGE("xx=%d, ee_handle=0x0%x, status=0x0%x", xx, mEeInfo[xx].ee_handle,mEeInfo[xx].ee_status);
-                    if (mEeInfo[xx].ee_handle == 0x4C0)
-                    {
-                        if(mEeInfo[xx].ee_status == 0x02)
-                        {
-                            configstatus = ResetEseSession();
-                            RoutingManager::getInstance().nfaEEDisconnect();
-                            usleep(1000 *1000);
-                            android::NxpNfc_Send_CoreResetInit_Cmd();
-                            RoutingManager::getInstance().nfaEEConnect();
-                            usleep(1000 * 1000);
-                        }
-                        else
-                        {
-                            eseDetected = 0x01;
-                        }
-                        break;
-                    }
-                }
-            }
-        }while((eseDetected == 0x00) && (retry++ < 1));
+#if (NXP_EXTNS == TRUE)
+    if (last_request & ENABLE_P2P) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("send the last request to enable P2P ");
+      nfcManager_Enablep2p(NULL, NULL,
+                           transaction_data.discovery_params.enable_p2p);
+      transaction_data.last_request &= ~(ENABLE_P2P);
+    }
+#if (NXP_NFCC_HCE_F == TRUE)
+    if (last_request & T3T_CONFIGURE) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          " transaction_data.t3thandle %d ", transaction_data.t3thandle);
+      if (transaction_data.t3thandle != 0) {
+        RoutingManager::getInstance().deregisterT3tIdentifier(
+            transaction_data.t3thandle);
+      }
+      transaction_data.last_request &= ~(T3T_CONFIGURE);
+      RoutingManager::getInstance().notifyT3tConfigure();
     }
-    usleep(1000 * 1000);
-}
-
-/**********************************************************************************
- **
- ** Function:        getUiccContext
- **
- ** Description:     Read and store UICC context values
- **                  Respective context will be applied during next switching
- **
- ** Returns:         None
- **
- **********************************************************************************/
-static void getUiccContext(int uiccSlot)
-{
-    if(!nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
-        ALOGV("%s: STAT_DUAL_UICC_EXT_SWITCH not available. Returning", __func__);
-        return;
+#endif
+    if (last_request & RE_ROUTING) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf(" transaction_data.isInstallRequest %d ",
+                          transaction_data.isInstallRequest);
+      if (!transaction_data.isInstallRequest) {
+        RoutingManager::getInstance().clearAidTable();
+        // nfcManager_doCommitRouting(NULL,NULL);
+      }
+      transaction_data.last_request &= ~(RE_ROUTING);
+      RoutingManager::getInstance().notifyReRoutingEntry();
     }
-    uint8_t i;
-    tNFA_STATUS status;
-    tNFA_PMID param_ids_UICC_getContext[]       = {0xA0, 0xF4};
+#endif
+    if (screen_lock_flag && disable_discovery) {
+      startRfDiscovery(true);
+    }
+    screen_lock_flag = false;
+    disable_discovery = false;
+    last_screen_state_request = transaction_data.last_screen_state_request;
+    last_request = transaction_data.last_request;
+    memset(&transaction_data, 0x00, sizeof(Transcation_Check_t));
 
-    ALOGV("%s: Enter", __func__);
+    transaction_data.last_request = last_request;
+    set_lastScreenStateRequest(last_screen_state_request);
 
-    SyncEventGuard guard (android::sNfaGetConfigEvent);
-    status = NFA_GetConfig(0x01,param_ids_UICC_getContext);
-    if(status == NFA_STATUS_OK)
-    {
-        android::sNfaGetConfigEvent.wait();
+    if (nfcFL.chipType != pn547C2) {
+      memset(&menableAGC_debug_t, 0x00, sizeof(enableAGC_debug_t));
     }
 
-    ALOGV("%s: UICC context Info : Len = %x", __func__,sCurrentConfigLen);
-    /*If the session ID is changed or uicc changed*/
-
-    if((dualUiccInfo.sUicc1CntxLen != 0)&&(sSelectedUicc == 0x01))
     {
-        for(i= 0 ; i < dualUiccInfo.sUicc1CntxLen; i++)
-        {
-            if(sConfig[i] != dualUiccInfo.sUicc1Cntx[i])
-                break;
-        }
-        if(i != dualUiccInfo.sUicc1CntxLen)
-        {
-            ALOGV("%s: copying UICC1 info", __func__);
-            update_uicc_context_info();
-        }
+      SyncEventGuard guard (sExecPendingRegEvent);
+      sExecPendingRegEvent.notifyOne();
+      sIsExecPendingReq = false;
     }
-    /*If the session ID is changed or uicc changed*/
-    if((dualUiccInfo.sUicc2CntxLen != 0)&&(sSelectedUicc == 0x02))
-    {
-        for(i= 0 ; i < dualUiccInfo.sUicc2CntxLen; i++)
-        {
-            if(sConfig[i] != dualUiccInfo.sUicc2Cntx[i])
-                break;
-        }
-        if(i != dualUiccInfo.sUicc1CntxLen)
-        {
-            ALOGV("%s: copying UICC2 info", __func__);
-            update_uicc_context_info();
+  TheEnd:
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+    pthread_exit(NULL);
+    return NULL;
+  }
+  /*******************************************************************************
+  **
+  ** Function         sig_handler
+  **
+  ** Description      This function is used to handle the different types of
+  **                  signal events.
+  **
+  ** Returns          None
+  **
+  *******************************************************************************/
+  void sig_handler(int signo) {
+    if (!nfcFL.eseFL._JCOP_WA_ENABLE) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("JCOP_WA_ENABLE not available..Returning");
+      return;
+    }
+    switch (signo) {
+      case SIGINT:
+        LOG(ERROR) << StringPrintf("received SIGINT\n");
+        break;
+      case SIGABRT:
+        LOG(ERROR) << StringPrintf("received SIGABRT\n");
+#if (NXP_EXTNS == TRUE)
+        if (nfcFL.nfccFL._NFCC_MW_RCVRY_BLK_FW_DNLD) {
+          NFA_MW_Fwdnlwd_Recovery(true);
         }
+#endif
+        NFA_HciW4eSETransaction_Complete(Wait);
+        break;
+      case SIGSEGV:
+        LOG(ERROR) << StringPrintf("received SIGSEGV\n");
+        break;
+      case SIGHUP:
+        LOG(ERROR) << StringPrintf("received SIGHUP\n");
+        break;
     }
+  }
+
+  /*******************************************************************************
+  **
+  ** Function         nfcManager_doGetSeInterface
+  **
+  ** Description      This function is used to get the eSE Client interfaces.
+  **
+  ** Returns          integer - Physical medium
+  **
+  *******************************************************************************/
+  static int nfcManager_doGetSeInterface(JNIEnv * /* e */, jobject /* o */, jint type) {
+    unsigned long num = 0;
+    switch (type) {
+      case LDR_SRVCE:
 
-    /*For the first power cycle for uicc1*/
-    if((dualUiccInfo.sUicc1CntxLen == 0)&&(sSelectedUicc == 0x01))
-    {
-        ALOGV("%s:  power cycle storing UICC1 info",__func__);
-        dualUiccInfo.sUicc1CntxLen = sCurrentConfigLen;
-        for(i= 5 ; i < 13; i++)
-        {
-            if(sConfig[i] != (uint8_t)0xFF)
-                break;
+        if (NfcConfig::hasKey(NAME_NXP_P61_LS_DEFAULT_INTERFACE)) {
+          num = NfcConfig::getUnsigned(NAME_NXP_P61_LS_DEFAULT_INTERFACE);
+        } else {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("NAME_NXP_P61_LS_DEFAULT_INTERFACE not found");
+          num = 1;
         }
-        if(i == 13)
-        {
-            dualUiccInfo.sUicc1CntxLen = 0;
+        break;
+      case JCOP_SRVCE:
+        if (NfcConfig::hasKey(NAME_NXP_P61_JCOP_DEFAULT_INTERFACE)) {
+          num = NfcConfig::getUnsigned(NAME_NXP_P61_JCOP_DEFAULT_INTERFACE);
+        } else {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("NAME_NXP_P61_JCOP_DEFAULT_INTERFACE not found");
+          num = 1;
         }
-        else
-        {
-            ALOGV("%s: copying UICC1 info", __func__);
-            update_uicc_context_info();
+        break;
+      case LTSM_SRVCE:
+        if (NfcConfig::hasKey(NAME_NXP_P61_LTSM_DEFAULT_INTERFACE)) {
+          num = NfcConfig::getUnsigned(NAME_NXP_P61_LTSM_DEFAULT_INTERFACE);
+        } else {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("NAME_NXP_P61_LTSM_DEFAULT_INTERFACE not found");
+          num = 1;
         }
+        break;
+      default:
+        break;
     }
-    /*For the first power cycle for uicc2*/
-    else if((dualUiccInfo.sUicc2CntxLen == 0)&&(sSelectedUicc == 0x02))
-    {
-        ALOGV("%s:  power cycle storing UICC2 info",__func__);
-        dualUiccInfo.sUicc2CntxLen = sCurrentConfigLen;
-        for(i= 5 ; i < 13; i++)
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%ld: nfcManager_doGetSeInterface", num);
+    return num;
+  }
+
+#if (NXP_EXTNS == TRUE)
+  /**********************************************************************************
+  **
+  ** Function:       pollT3TThread
+  **
+  ** Description:    This thread sends commands to switch from P2P to T3T
+  **                 When ReaderMode is enabled, When P2P is detected,Switch to
+  *T3T
+  **                 with Frame RF interface and Poll for T3T
+  **
+  ** Returns:         None.
+  **
+  **********************************************************************************/
+  static void* pollT3TThread(void* arg) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+    bool status = false;
+
+    if (sReaderModeEnabled && (sTechMask & NFA_TECHNOLOGY_MASK_F)) {
+      /*Deactivate RF to go to W4_HOST_SELECT state
+       *Send Select Command to Switch to FrameRF interface from NFCDEP
+       *interface
+       *After NFC-DEP activation with FrameRF Intf, invoke T3T Polling Cmd*/
+      {
+        SyncEventGuard g(sRespCbEvent);
+        if (NFA_STATUS_OK !=
+            (status = NFA_Deactivate(true)))  // deactivate to sleep state
         {
-            if(sConfig[i] != (uint8_t)0xFF)
-                break;
+          LOG(ERROR) << StringPrintf("%s: deactivate failed, status = %d",
+                                     __func__, status);
         }
-        if(i == 13)
+        if (sRespCbEvent.wait(2000) == false)  // if timeout occurred
         {
-            dualUiccInfo.sUicc2CntxLen = 0;
+          LOG(ERROR) << StringPrintf("%s: timeout waiting for deactivate",
+                                     __func__);
         }
-        else
+      }
+      {
+        SyncEventGuard g2(sRespCbEvent);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "Switching RF Interface from NFC-DEP to FrameRF for T3T\n");
+        if (NFA_STATUS_OK !=
+            (status = NFA_Select(*((uint8_t*)arg), NFA_PROTOCOL_T3T,
+                                 NFA_INTERFACE_FRAME))) {
+          LOG(ERROR) << StringPrintf("%s: NFA_Select failed, status = %d",
+                                     __func__, status);
+        }
+        if (sRespCbEvent.wait(2000) == false)  // if timeout occured
         {
-            ALOGV("%s: copying UICC2 info", __func__);
-            update_uicc_context_info();
+          LOG(ERROR) << StringPrintf("%s: timeout waiting for select",
+                                     __func__);
         }
+      }
     }
-    else
-    {
-        ALOGV("%s: UICC info are already stored..",__func__);
-    }
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+    pthread_exit(NULL);
+    return NULL;
+  }
+
+  /**********************************************************************************
+  **
+  ** Function:       switchP2PToT3TRead
+  **
+  ** Description:    Create a thread to change the RF interface by Deactivating
+  *to Sleep
+  **
+  ** Returns:         None.
+  **
+  **********************************************************************************/
+  static bool switchP2PToT3TRead(uint8_t disc_id) {
+    pthread_t pollT3TThreadId;
+    int irret = -1;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s:entry", __func__);
+    felicaReader_Disc_id = disc_id;
 
-    if((uiccSlot == 0x01)&&(dualUiccInfo.sUicc1CntxLen == 0x00))
-    {
-        read_uicc_context(dualUiccInfo.sUicc1Cntx, dualUiccInfo.sUicc1CntxLen,
-                dualUiccInfo.sUicc1TechCapblty, sizeof(dualUiccInfo.sUicc1TechCapblty), 1, uiccSlot);
-    }
-    else if((uiccSlot == 0x02)&&(dualUiccInfo.sUicc2CntxLen == 0x00))
-    {
-        read_uicc_context(dualUiccInfo.sUicc2Cntx, dualUiccInfo.sUicc2CntxLen,
-                dualUiccInfo.sUicc2TechCapblty, sizeof(dualUiccInfo.sUicc2TechCapblty), 1, uiccSlot);
+    /* Transcation is done process the last request*/
+    pthread_attr_t attr;
+    pthread_attr_init(&attr);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+    irret = pthread_create(&pollT3TThreadId, &attr, pollT3TThread,
+                           (void*)&felicaReader_Disc_id);
+    if (irret != 0) {
+      LOG(ERROR) << StringPrintf("Unable to create the thread");
     }
+    pthread_attr_destroy(&attr);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s:exit", __func__);
+    return irret;
+  }
+
+  static void NxpResponsePropCmd_Cb(uint8_t /* event */, uint16_t param_len,
+                                    uint8_t * p_param) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "NxpResponsePropCmd_Cb Received length data = 0x%x status = 0x%x",
+        param_len, p_param[3]);
+    SyncEventGuard guard(sNfaNxpNtfEvent);
+    sNfaNxpNtfEvent.notifyOne();
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManager_setProvisionMode
+  **
+  ** Description:     set/reset provision mode
+  **                  e: JVM environment.
+  **                  o: Java object.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  static void nfcManager_setProvisionMode(JNIEnv * e, jobject o,
+                                          jboolean provisionMode) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "Enter :%s  provisionMode = %d", __func__, provisionMode);
+    sProvisionMode = provisionMode;
+    NFA_setProvisionMode(provisionMode);
+    // When disabling provisioning mode, make sure configuration of routing
+    // table is also updated
+    // this is required to make sure p2p is blocked during locked screen
+    if (!provisionMode) {
+      RoutingManager::getInstance().commitRouting();
+    }
+  }
+
+  /*******************************************************************************
+   **
+   ** Function:        isActivatedTypeF
+   **
+   ** Description:     Indicates whether the activation data indicates it is
+   **                  TypeF technology.
+   **
+   ** Returns:         True if activated technology is TypeF.
+   **
+   *******************************************************************************/
+  static bool isActivatedTypeF(tNFA_ACTIVATED & activated) {
+    return ((NFC_DISCOVERY_TYPE_POLL_F ==
+             activated.activate_ntf.rf_tech_param.mode) ||
+            (NFC_DISCOVERY_TYPE_POLL_F_ACTIVE ==
+             activated.activate_ntf.rf_tech_param.mode) ||
+            (NFC_DISCOVERY_TYPE_LISTEN_F ==
+             activated.activate_ntf.rf_tech_param.mode) ||
+            (NFC_DISCOVERY_TYPE_LISTEN_F_ACTIVE ==
+             activated.activate_ntf.rf_tech_param.mode));
+  }
+  /**********************************************************************************
+   **
+   ** Function:        eSEPhyIntfInResponsive
+   **
+   ** Description:    checking inactivity of eSE physical interface
+   **
+   ** Returns:         1(if true)/0 (if false) .
+   **
+   **********************************************************************************/
+  static uint32_t eSEPhyIntfInResponsive(tNFA_DM_CBACK_DATA * pEvtData) {
+    LOG(ERROR) << StringPrintf("%s: param_tlvs %x", __func__,
+                               pEvtData->get_config.param_tlvs[5]);
+    if (nfcFL.chipType != pn553)
+      return (IS_ESE_RF_CE_PARAM_FETCHED() && IS_ESE_CE_MODE_DISABLED() &&
+              SecureElement::getInstance().getEeStatus(ESE_HANDLE) ==
+                  NFA_EE_STATUS_ACTIVE);
+    else
+      return 0;
+  }
+  /**********************************************************************************
+  **
+  ** Function:        recoverEseConnectivity
+  **
+  ** Description:     reset eSE connection for recovering communication
+  **
+  ** Returns:         None
+  **
+  **********************************************************************************/
+  static void recoverEseConnectivity() {
+    tNFA_STATUS stat = ResetEseSession();
+    if (stat == NFA_STATUS_OK) {
+      SecureElement::getInstance().SecEle_Modeset(0x00);
+      usleep(50 * 1000);
+      SecureElement::getInstance().SecEle_Modeset(0x01);
+    }
+  }
+  /**********************************************************************************
+   **
+   ** Function:        checkforNfceeBuffer
+   **
+   ** Description:    checking for the Nfcee Buffer (GetConfigs for
+   *SWP_INT_SESSION_ID (EA and EB))
+   **
+   ** Returns:         None .
+   **
+   **********************************************************************************/
+  void checkforNfceeBuffer() {
+    int i, count = 0;
 
-    ALOGV("%s: Exit", __func__);
-}
-
-/**********************************************************************************
- **
- ** Function:        update_uicc_context_info
- **
- ** Description:     updates UICC context related info to buffere and file
- **
- ** Returns:         none
- **
- **********************************************************************************/
-static void update_uicc_context_info()
-{
-    if(!nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
-        ALOGV("%s: STAT_DUAL_UICC_EXT_SWITCH not available. Returning", __func__);
-        return;
-    }
-    ALOGV("%s: Enter", __func__);
-    tNFA_STATUS status = NFA_STATUS_FAILED;
-    tNFA_PMID param_ids_UICC_getOtherContext[]  = {0xA0, 0xF5};
-    if(sSelectedUicc == 0x01)
-    {
-        memcpy(dualUiccInfo.sUicc1Cntx, sConfig, sCurrentConfigLen);
-        status = NFA_GetConfig(0x01,param_ids_UICC_getOtherContext);
-        if(status == NFA_STATUS_OK)
-        {
-            android::sNfaGetConfigEvent.wait();
-        }
-        memcpy(dualUiccInfo.sUicc1TechCapblty, sConfig, sCurrentConfigLen);
-        write_uicc_context(dualUiccInfo.sUicc1Cntx,  dualUiccInfo.sUicc1CntxLen, dualUiccInfo.sUicc1TechCapblty, 10, 1, sSelectedUicc);
-    }
-    else if(sSelectedUicc == 0x02)
-    {
-        memcpy(dualUiccInfo.sUicc2Cntx, sConfig, sCurrentConfigLen);
-        status = NFA_GetConfig(0x01,param_ids_UICC_getOtherContext);
-        if(status == NFA_STATUS_OK)
-        {
-            android::sNfaGetConfigEvent.wait();
+    for (i = 4; i < 12; i++) {
+      if (sConfig[i] == 0xff) count++;
+    }
+
+    if (count >= 8) {
+      /*If session ID received all 0xff for UICC and dual UICC feature is
+       * enabled then
+       * clear the corresponding buffer (invalid session ID)
+       * */
+      if (nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH &&
+          ((sConfig[1] == 0xA0) && (sConfig[2] == 0xEA) &&
+           (dualUiccInfo.dualUiccEnable == 0x01))) {
+        if (sSelectedUicc == 0x01) {
+          memset(dualUiccInfo.sUicc1SessionId, 0x00,
+                 sizeof(dualUiccInfo.sUicc1SessionId));
+          dualUiccInfo.sUicc1SessionIdLen = 0;
+        } else {
+          memset(dualUiccInfo.sUicc2SessionId, 0x00,
+                 sizeof(dualUiccInfo.sUicc2SessionId));
+          dualUiccInfo.sUicc2SessionIdLen = 0;
         }
-        memcpy(dualUiccInfo.sUicc2TechCapblty, sConfig, sCurrentConfigLen);
-        write_uicc_context(dualUiccInfo.sUicc2Cntx,  dualUiccInfo.sUicc2CntxLen, dualUiccInfo.sUicc2TechCapblty, 10, 1, sSelectedUicc);
+      }
+      sNfceeConfigured = 1;
+    } else {
+      if (nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
+        if ((sConfig[1] == 0xA0) && (sConfig[2] == 0xEA) &&
+            (dualUiccInfo.dualUiccEnable == 0x01)) {
+          sNfceeConfigured = getUiccSession();
+        } else {
+          sNfceeConfigured = 0;
+        }
+      } else {
+        sNfceeConfigured = 0;
+      }
+    }
+
+    memset(sConfig, 0, sizeof(sConfig));
+  }
+  /**********************************************************************************
+   **
+   ** Function:        checkforNfceeConfig
+   **
+   ** Description:    checking for the Nfcee is configured or not (GetConfigs
+   *for SWP_INT_SESSION_ID (EA and EB))
+   **
+   ** Returns:         None .
+   **
+   **********************************************************************************/
+  void checkforNfceeConfig(uint8_t type) {
+    uint8_t uicc_flag = 0, ese_flag = 0;
+    uint8_t uicc2_flag = 0; /*For Dynamic Dual UICC*/
+    unsigned long timeout_buff_val = 0, check_cnt = 0, retry_cnt = 0;
 
-    }
-    ALOGV("%s: Exit", __func__);
-}
+    tNFA_STATUS status;
+    tNFA_PMID param_ids_UICC[] = {0xA0, 0xEA};
+    tNFA_PMID param_ids_eSE[] = {0xA0, 0xEB};
+    tNFA_PMID param_uicc1[] = {0xA0, 0x24};
+    tNFA_PMID param_ids_UICC2[] = {0xA0, 0x1E};
+    tNFA_PMID param_uicc2[] = {0xA0, 0xE9};
 
-/**********************************************************************************
- **
- ** Function:        write_uicc_context
- **
- ** Description:     write UICC context to file
- **
- ** Returns:         none
- **
- **********************************************************************************/
-void write_uicc_context(uint8_t *uiccContext, uint16_t uiccContextLen, uint8_t *uiccTechCap, uint16_t uiccTechCapLen, uint8_t block, uint8_t slotnum)
-{
-    if(!nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
-        ALOGV("%s: STAT_DUAL_UICC_EXT_SWITCH not available. Returning", __func__);
-        return;
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: enter, type=%x", __func__, type);
+    uint8_t pipeId = 0;
+    SecureElement::getInstance().updateEEStatus();
+    bool configureuicc1 = false;
+    bool configureuicc2 = false;
+
+    if (NfcConfig::hasKey(NAME_NXP_DEFAULT_NFCEE_TIMEOUT)) {
+      timeout_buff_val = NfcConfig::getUnsigned(NAME_NXP_DEFAULT_NFCEE_TIMEOUT);
+      check_cnt = timeout_buff_val * RETRY_COUNT;
+    } else {
+      check_cnt = DEFAULT_COUNT * RETRY_COUNT;
+    }
+
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("NAME_DEFAULT_NFCEE_TIMEOUT = %lu", check_cnt);
+
+    if (SecureElement::getInstance().getEeStatus(
+            SecureElement::EE_HANDLE_0xF3) == NFC_NFCEE_STATUS_ACTIVE) {
+      ese_flag = 0x01;
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("eSE_flag SET");
+    }
+    if (SecureElement::getInstance().getEeStatus(
+            SecureElement::getInstance().EE_HANDLE_0xF4) ==
+        NFC_NFCEE_STATUS_ACTIVE) {
+      uicc_flag = 0x01;
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("uicc_flag SET");
+    }
+    if (nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC) {
+      if (SecureElement::getInstance().getEeStatus(
+              SecureElement::EE_HANDLE_0xF8) == NFC_NFCEE_STATUS_ACTIVE) {
+        uicc2_flag = 0x01;
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("uicc2_flag SET");
+      }
+    } else if (nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
+      if (dualUiccInfo.dualUiccEnable == 0x01) {
+        if (sSelectedUicc == 0x01) {
+          memset(dualUiccInfo.sUicc1SessionId, 0x00,
+                 sizeof(dualUiccInfo.sUicc1SessionId));
+          dualUiccInfo.sUicc1SessionIdLen = 0;
+        } else {
+          memset(dualUiccInfo.sUicc2SessionId, 0x00,
+                 sizeof(dualUiccInfo.sUicc2SessionId));
+          dualUiccInfo.sUicc2SessionIdLen = 0;
+        }
+      }
+    }
+    if ((ese_flag == 0x01) || (uicc_flag == 0x01) || (uicc2_flag == 0x01)) {
+      if (nfcFL.nfcNxpEse && (ese_flag && ((type & ESE) == ESE))) {
+        sCheckNfceeFlag = 1;
+        {
+          SyncEventGuard guard(android::sNfaGetConfigEvent);
+          while (check_cnt > retry_cnt) {
+            status = NFA_GetConfig(0x01, param_ids_eSE);
+            if (status == NFA_STATUS_OK) {
+              android::sNfaGetConfigEvent.wait();
+            }
+            if (sNfceeConfigured == 1) {
+              SecureElement::getInstance().meSESessionIdOk = false;
+              DLOG_IF(INFO, nfc_debug_enabled)
+                  << StringPrintf("eSE Not Configured");
+            } else {
+              SecureElement::getInstance().meSESessionIdOk = true;
+              DLOG_IF(INFO, nfc_debug_enabled)
+                  << StringPrintf("eSE Configured");
+              break;
+            }
+
+            usleep(100000);
+            retry_cnt++;
+          }
+        }
+        if (check_cnt <= retry_cnt)
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("eSE Not Configured");
+        retry_cnt = 0;
+      }
+
+      if (nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC &&
+          (uicc2_flag && ((type & UICC2) == UICC2))) {
+        sCheckNfceeFlag = 1;
+        {
+          SyncEventGuard guard(android::sNfaGetConfigEvent);
+          while (check_cnt > retry_cnt) {
+            status = NFA_GetConfig(0x01, param_ids_UICC2);
+            if (status == NFA_STATUS_OK) {
+              android::sNfaGetConfigEvent.wait();
+            }
+
+            if (sNfceeConfigured == 1) {
+              DLOG_IF(INFO, nfc_debug_enabled)
+                  << StringPrintf("UICC2 Not Configured");
+            } else {
+              DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+                  "UICC2 Configured connectivity pipeId = %x", pipeId);
+              configureuicc2 = true;
+              if (nfcFL.nfccFL._UICC_CREATE_CONNECTIVITY_PIPE != true) {
+                break;
+              }
+            }
+            if (nfcFL.nfccFL._UICC_CREATE_CONNECTIVITY_PIPE) {
+              if ((configureuicc2 == true) || (check_cnt == retry_cnt)) {
+                configureuicc2 = false;
+                pipeId = SecureElement::getInstance().getUiccGateAndPipeList(
+                    SecureElement::getInstance().EE_HANDLE_0xF8 &
+                    ~NFA_HANDLE_GROUP_EE);
+                if (pipeId == 0) {
+                  DLOG_IF(INFO, nfc_debug_enabled)
+                      << StringPrintf("Add pipe information");
+                  sCheckNfceeFlag = 0;
+                  status = NFA_GetConfig(0x01, param_uicc2);
+                  pipeId = 0x23;
+
+                  if (status == NFA_STATUS_OK) {
+                    android::sNfaGetConfigEvent.wait();
+                  }
+                  sCheckNfceeFlag = 1;
+                  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+                      "UICC2 connectivity gate present = %s",
+                      (sConfig[NFC_PIPE_STATUS_OFFSET] ? "true" : "false"));
+                  /*If pipe is present and opened update MW status*/
+                  if (sConfig[NFC_PIPE_STATUS_OFFSET] > PIPE_DELETED) {
+                    SyncEventGuard guard(
+                        SecureElement::getInstance().mHciAddStaticPipe);
+                    status = NFA_HciAddStaticPipe(
+                        SecureElement::getInstance().getHciHandleInfo(), 0x81,
+                        NFA_HCI_CONNECTIVITY_GATE, pipeId);
+                    if (status == NFA_STATUS_OK) {
+                      SecureElement::getInstance().mHciAddStaticPipe.wait(500);
+                    }
+                  }
+                }
+                break;
+              }
+            }
+            usleep(100000);
+            retry_cnt++;
+          }
+        }
+
+        if (check_cnt <= retry_cnt)
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("UICC2 Not Configured");
+        retry_cnt = 0;
+        pipeId = 0;
+      }
+      if (uicc_flag && ((type & UICC1) == UICC1)) {
+        sCheckNfceeFlag = 1;
+        {
+          SyncEventGuard guard(android::sNfaGetConfigEvent);
+          while (check_cnt > retry_cnt) {
+            status = NFA_GetConfig(0x01, param_ids_UICC);
+            if (status == NFA_STATUS_OK) {
+              android::sNfaGetConfigEvent.wait();
+            }
+
+            if (sNfceeConfigured == 1) {
+              DLOG_IF(INFO, nfc_debug_enabled)
+                  << StringPrintf("UICC Not Configured");
+            } else {
+              if (nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH)
+                dualUiccInfo.uiccConfigStat = UICC_CONFIGURED;
+              DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+                  "UICC1 Configured connectivity pipeId = %x", pipeId);
+              configureuicc1 = true;
+              if (nfcFL.nfccFL._UICC_CREATE_CONNECTIVITY_PIPE == false) {
+                break;
+              }
+            }
+            if (nfcFL.nfccFL._UICC_CREATE_CONNECTIVITY_PIPE) {
+              if ((configureuicc1 == true) || (check_cnt == retry_cnt)) {
+                configureuicc1 = false;
+                pipeId = SecureElement::getInstance().getUiccGateAndPipeList(
+                    SecureElement::getInstance().EE_HANDLE_0xF4 &
+                    ~NFA_HANDLE_GROUP_EE);
+                if (pipeId == 0) {
+                  DLOG_IF(INFO, nfc_debug_enabled)
+                      << StringPrintf("Add pipe information");
+                  sCheckNfceeFlag = 0;
+                  status = NFA_GetConfig(0x01, param_uicc1);
+                  pipeId = 0x0A;
+                  if (status == NFA_STATUS_OK) {
+                    android::sNfaGetConfigEvent.wait();
+                  }
+                  sCheckNfceeFlag = 1;
+                  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+                      "UICC1 connectivity gate present = %s",
+                      (sConfig[NFC_PIPE_STATUS_OFFSET] ? "true" : "false"));
+                  /*If pipe is present and opened update MW status*/
+                  if (sConfig[NFC_PIPE_STATUS_OFFSET] > PIPE_DELETED) {
+                    SyncEventGuard guard(
+                        SecureElement::getInstance().mHciAddStaticPipe);
+                    status = NFA_HciAddStaticPipe(
+                        SecureElement::getInstance().getHciHandleInfo(), 0x02,
+                        NFA_HCI_CONNECTIVITY_GATE, pipeId);
+                    if (status == NFA_STATUS_OK) {
+                      SecureElement::getInstance().mHciAddStaticPipe.wait();
+                    }
+                  }
+                }
+                break;
+              }
+            }
+            usleep(100000);
+            retry_cnt++;
+          }
+        }
+
+        if (check_cnt <= retry_cnt)
+          LOG(ERROR) << StringPrintf("UICC Not Configured");
+        retry_cnt = 0;
+        if (nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
+          sCheckNfceeFlag = 0;
+        }
+      }
     }
-    char filename[256], filename2[256];
-    uint8_t cntx_len = 128;
-    uint8_t techCap = 10;
-    uint8_t*  frameByte;
-    uint16_t  crcVal = 0;
-    ALOGV("%s : enter", __func__);
 
-    memset (filename, 0, sizeof(filename));
-    memset (filename2, 0, sizeof(filename2));
-    strcpy(filename2, "/data/nfc");
-    strncat(filename2, "/nxpStorage.bin", sizeof(filename2)-strlen(filename2)-1);
+    sCheckNfceeFlag = 0;
 
-    if (strlen(filename2) > 200)
-    {
-        ALOGE("%s: filename too long", __func__);
-        return;
+    if (nfcFL.eseFL._JCOP_WA_ENABLE) {
+      RoutingManager::getInstance().handleSERemovedNtf();
     }
-    sprintf (filename, "%s%u", filename2, block);
-    ALOGV("%s: bytes=%u; file=%s slotnum=%d", __func__, uiccContextLen, filename, slotnum);
+  }
+#endif
 
-    int fileStream = 0;
+#if (NXP_EXTNS == TRUE)
+  static void nfaNxpSelfTestNtfTimerCb(union sigval) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "NXP SWP SelfTest : Can't get a notification about SWP Status!!");
+    SyncEventGuard guard(sNfaNxpNtfEvent);
+    sNfaNxpNtfEvent.notifyOne();
+    SetCbStatus(NFA_STATUS_FAILED);
+  }
+
+  /**********************************************************************************
+   **
+   ** Function:        performNfceeETSI12Config
+   **
+   ** Description:    checking for Nfcee ETSI 12 Compliancy and configure if
+   *compliant
+   **
+   ** Returns:         None .
+   **
+   **********************************************************************************/
+  void performNfceeETSI12Config() {
+    bool status;
+    tNFA_STATUS configstatus = NFA_STATUS_FAILED;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
 
-    fileStream = open (filename, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);
-    if (fileStream >= 0)
-    {
-        size_t actualWrittenCntx = 0;
-        size_t actualWrittenCrc = 0;
-        size_t actualWrittenTechCap = 0;
-        size_t actualWrittenCntxLen = 0;
+    SecureElement::getInstance().setNfccPwrConfig(
+        SecureElement::getInstance().POWER_ALWAYS_ON |
+        SecureElement::getInstance().COMM_LINK_ACTIVE);
 
-        if(slotnum == 1)
-        {
-            lseek(fileStream, 0, SEEK_SET);
-        }
-        else if(slotnum == 2)
-        {
-            lseek(fileStream, sizeof(dualUiccInfo.sUicc1Cntx)+sizeof(dualUiccInfo.sUicc1TechCapblty), SEEK_SET);
-        }
+    status = SecureElement::getInstance().configureNfceeETSI12();
+    if (status == true) {
+      {
+        SyncEventGuard guard(SecureElement::getInstance().mNfceeInitCbEvent);
+        if (SecureElement::getInstance().mNfceeInitCbEvent.wait(4000) ==
+            false) {
+          LOG(ERROR) << StringPrintf(
+              "%s:     timeout waiting for Nfcee Init event", __func__);
+        }
+      }
+      if (SecureElement::getInstance().mETSI12InitStatus != NFA_STATUS_OK) {
+        // check for recovery
+        configstatus = ResetEseSession();
+        if (configstatus == NFA_STATUS_OK) {
+          SecureElement::getInstance().meseETSI12Recovery = true;
+          SecureElement::getInstance().SecEle_Modeset(0x00);
+          usleep(50 * 1000);
+          SecureElement::getInstance().SecEle_Modeset(0x01);
+          SecureElement::getInstance().meseETSI12Recovery = false;
+        }
+        checkforNfceeConfig(ESE);
+      }
+    }
+  }
+
+  /**********************************************************************************
+   **
+   ** Function:       performHCIInitialization
+   **
+   ** Description:    Performs HCI and SWP interface Initialization
+   **
+   ** Returns:         None .
+   **
+   **********************************************************************************/
+  static void performHCIInitialization(JNIEnv * e, jobject o) {
+    NFCSTATUS status = NFA_STATUS_FAILED;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
+    GetNumNFCEEConfigured();
+    status = android::enableSWPInterface();
+    if (status == NFA_STATUS_OK) {
+      RoutingManager::getInstance().nfaEEDisconnect();
+      usleep(1000 * 1000);
+      android::NxpNfc_Send_CoreResetInit_Cmd();
+      /*Update Actual SE count gActualSeCount*/
+      GetNumNFCEEConfigured();
+      RoutingManager::getInstance().nfaEEConnect();
+      SecureElement::getInstance().activateAllNfcee();
+      sIsSecElemSelected = (SecureElement::getInstance().getActualNumEe() - 1);
+      sIsSecElemDetected = sIsSecElemSelected;
+    } else {
+      LOG(ERROR) << StringPrintf(
+          "No UICC update required/failed to enable SWP interfaces");
+    }
+  }
 
-        actualWrittenCntxLen = write(fileStream, &uiccContextLen, 1);
-        if(uiccContextLen > 0x00)
-        {
-            cntx_len = uiccContextLen;
-            techCap  = uiccTechCapLen;
-            crcVal   = calc_crc16(uiccContext,cntx_len);
-        }
+  void checkforESERemoval() {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("checkforESERemoval enter");
 
-        frameByte = (uint8_t *)&crcVal;
-        ALOGV("%s:CRC calculated %02x %02x", __func__, frameByte[0],frameByte[1]);
+    bool nfaEseRemovedNtf = true;
+    uint8_t numNfceePresent =
+        SecureElement::getInstance().mNfceeData_t.mNfceePresent;
+    tNFA_HANDLE nfceeHandle[MAX_NFCEE];
+    tNFA_EE_STATUS nfceeStatus[MAX_NFCEE];
 
-        actualWrittenCntx = write (fileStream, uiccContext, cntx_len);
-        actualWrittenCrc  = write (fileStream, frameByte, sizeof(crcVal));
-        actualWrittenTechCap = write (fileStream, uiccTechCap, techCap);
+    uint8_t retry = 0;
+    uint8_t mActualNumEe = SecureElement::MAX_NUM_EE;
+    tNFA_EE_INFO mEeInfo[mActualNumEe];
+    uint8_t eseDetected = 0;
 
-        ALOGV("%s: %zu bytes written", __func__, cntx_len);
-        if ((actualWrittenCntx == cntx_len) && (actualWrittenTechCap == techCap))
-        {
-            ALOGV("Write Success!");
-        }
-        else
-        {
-            ALOGE("%s: fail to write", __func__);
-        }
-        close (fileStream);
+    for (int i = 1; i <= numNfceePresent; i++) {
+      nfceeHandle[i] =
+          SecureElement::getInstance().mNfceeData_t.mNfceeHandle[i];
+      nfceeStatus[i] =
+          SecureElement::getInstance().mNfceeData_t.mNfceeHandle[i];
+
+      if (nfceeHandle[i] == (SecureElement::EE_HANDLE_0xF3) &&
+          nfceeStatus[i] == 0x0) {
+        nfaEseRemovedNtf = false;
+        break;
+      }
+    }
+    if (nfaEseRemovedNtf) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfaEseRemovedNtf true");
+      tNFA_STATUS configstatus = NFA_STATUS_FAILED;
+      do {
+        if ((configstatus = NFA_AllEeGetInfo(&mActualNumEe, mEeInfo)) !=
+            NFA_STATUS_OK) {
+          LOG(ERROR) << StringPrintf("unable to get the EE status");
+        } else {
+          for (int xx = 0; xx < mActualNumEe; xx++) {
+            LOG(ERROR) << StringPrintf("xx=%d, ee_handle=0x0%x, status=0x0%x",
+                                       xx, mEeInfo[xx].ee_handle,
+                                       mEeInfo[xx].ee_status);
+            if (mEeInfo[xx].ee_handle == 0x4C0) {
+              if (mEeInfo[xx].ee_status == 0x02) {
+                configstatus = ResetEseSession();
+                RoutingManager::getInstance().nfaEEDisconnect();
+                usleep(1000 * 1000);
+                android::NxpNfc_Send_CoreResetInit_Cmd();
+                RoutingManager::getInstance().nfaEEConnect();
+                usleep(1000 * 1000);
+              } else {
+                eseDetected = 0x01;
+              }
+              break;
+            }
+          }
+        }
+      } while ((eseDetected == 0x00) && (retry++ < 1));
     }
-    else
-    {
-        ALOGE("%s: fail to open, error = %d", __func__, errno);
+    usleep(1000 * 1000);
+  }
+
+  /**********************************************************************************
+   **
+   ** Function:        getUiccContext
+   **
+   ** Description:     Read and store UICC context values
+   **                  Respective context will be applied during next switching
+   **
+   ** Returns:         None
+   **
+   **********************************************************************************/
+  static void getUiccContext(int uiccSlot) {
+    if (!nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: STAT_DUAL_UICC_EXT_SWITCH not available. Returning", __func__);
+      return;
     }
-    ALOGV("%s : exit", __func__);
-}
+    uint8_t i;
+    tNFA_STATUS status;
+    tNFA_PMID param_ids_UICC_getContext[] = {0xA0, 0xF4};
 
-/**********************************************************************************
- **
- ** Function:        read_uicc_context
- **
- ** Description:     read UICC context from file
- **
- ** Returns:         none
- **
- **********************************************************************************/
-void read_uicc_context(uint8_t *uiccContext, uint16_t uiccContextLen, uint8_t *uiccTechCap, uint16_t uiccTechCapLen, uint8_t block, uint8_t slotnum)
-{
-    if(!nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
-        ALOGV("%s: STAT_DUAL_UICC_EXT_SWITCH not available. Returning", __func__);
-        return;
-    }
-    char filename[256], filename2[256];
-    uint8_t*  readCrc = NULL;
-    uint8_t*  frameByte = NULL;
-    uint16_t  crcVal;
-    uint8_t cmpStat;
-    ALOGV("%s : enter", __func__);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Enter", __func__);
 
-    memset (filename, 0, sizeof(filename));
-    memset (filename2, 0, sizeof(filename2));
-    strcpy(filename2, "/data/nfc");
-    strncat(filename2, "/nxpStorage.bin", sizeof(filename2)-strlen(filename2)-1);
-    if (strlen(filename2) > 200)
-    {
-        ALOGE("%s: filename too long", __func__);
-        return;
+    SyncEventGuard guard(android::sNfaGetConfigEvent);
+    status = NFA_GetConfig(0x01, param_ids_UICC_getContext);
+    if (status == NFA_STATUS_OK) {
+      android::sNfaGetConfigEvent.wait();
     }
-    sprintf (filename, "%s%u", filename2, block);
-
-    ALOGV("%s: buffer len=%u; file=%s, slotnum=%d", __func__, uiccContextLen, filename, slotnum);
-    int fileStream = open (filename, O_RDONLY);
-    if (fileStream >= 0)
-    {
-        size_t actualReadCntx = 0;
-        size_t actualReadCntxLen = 0;
-        size_t actualReadCrc = 0;
-        size_t actualReadTechCap = 0;
-        uint8_t readCntxLen = 0;
 
-        if(slotnum == 1)
-        {
-            lseek(fileStream, 0, SEEK_SET);
-        }
-        else if(slotnum == 2)
-        {
-            lseek(fileStream, sizeof(dualUiccInfo.sUicc1Cntx)+sizeof(dualUiccInfo.sUicc1TechCapblty), SEEK_SET);
-        }
-        actualReadCntxLen = read(fileStream, &readCntxLen, 1);
-        if(readCntxLen > 0x00)
-        {
-            actualReadCntx      = read (fileStream, uiccContext, readCntxLen);
-            readCrc = (uint8_t*) malloc(2*sizeof(uint8_t));
-            actualReadCrc       = read (fileStream, readCrc, sizeof(crcVal));
-            crcVal   = calc_crc16(uiccContext,readCntxLen);
-            frameByte = (uint8_t *)&crcVal;
-            actualReadTechCap   = read (fileStream, uiccTechCap, uiccTechCapLen);
-
-            ALOGV("%s:CRC calculated %02x %02x -- CRC read %02x %02x", __func__, frameByte[0],frameByte[1],readCrc[0],readCrc[1]);
-            cmpStat             = memcmp (readCrc, frameByte, sizeof(crcVal));
-            if(cmpStat == 0)
-            {
-                ALOGV("%s:CRC check result - success",__func__);
-            }
-            else
-            {
-                ALOGV("%s:CRC check result - failed. Resetting buffer",__func__);
-                memset(uiccContext,0x00,128);
-                memset(uiccTechCap,0x00,10);
-                write_uicc_context(uiccContext,  0, uiccTechCap, 10, 1, slotnum);
-            }
-            free(readCrc);
-        }
-        else
-        {
-            memset(uiccContext,0x00,128);
-            memset(uiccTechCap,0x00,10);
-        }
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: UICC context Info : Len = %x", __func__, sCurrentConfigLen);
+    /*If the session ID is changed or uicc changed*/
 
-        if(slotnum == 1)      dualUiccInfo.sUicc1CntxLen = readCntxLen;
-        else if(slotnum == 2) dualUiccInfo.sUicc2CntxLen = readCntxLen;
+    if ((dualUiccInfo.sUicc1CntxLen != 0) && (sSelectedUicc == 0x01)) {
+      for (i = 0; i < dualUiccInfo.sUicc1CntxLen; i++) {
+        if (sConfig[i] != dualUiccInfo.sUicc1Cntx[i]) break;
+      }
+      if (i != dualUiccInfo.sUicc1CntxLen) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: copying UICC1 info", __func__);
+        update_uicc_context_info();
+      }
+    }
+    /*If the session ID is changed or uicc changed*/
+    if ((dualUiccInfo.sUicc2CntxLen != 0) && (sSelectedUicc == 0x02)) {
+      for (i = 0; i < dualUiccInfo.sUicc2CntxLen; i++) {
+        if (sConfig[i] != dualUiccInfo.sUicc2Cntx[i]) break;
+      }
+      if (i != dualUiccInfo.sUicc1CntxLen) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: copying UICC2 info", __func__);
+        update_uicc_context_info();
+      }
+    }
 
-        close (fileStream);
-        if (actualReadCntx > 0)
-        {
-            ALOGV("%s: data size=%zu", __func__, actualReadCntx);
-        }
-        else
-        {
-            ALOGE("%s: fail to read", __func__);
-        }
+    /*For the first power cycle for uicc1*/
+    if ((dualUiccInfo.sUicc1CntxLen == 0) && (sSelectedUicc == 0x01)) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s:  power cycle storing UICC1 info", __func__);
+      dualUiccInfo.sUicc1CntxLen = sCurrentConfigLen;
+      for (i = 5; i < 13; i++) {
+        if (sConfig[i] != (uint8_t)0xFF) break;
+      }
+      if (i == 13) {
+        dualUiccInfo.sUicc1CntxLen = 0;
+      } else {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: copying UICC1 info", __func__);
+        update_uicc_context_info();
+      }
     }
-    else
-    {
-        ALOGV("%s: fail to open", __func__);
+    /*For the first power cycle for uicc2*/
+    else if ((dualUiccInfo.sUicc2CntxLen == 0) && (sSelectedUicc == 0x02)) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s:  power cycle storing UICC2 info", __func__);
+      dualUiccInfo.sUicc2CntxLen = sCurrentConfigLen;
+      for (i = 5; i < 13; i++) {
+        if (sConfig[i] != (uint8_t)0xFF) break;
+      }
+      if (i == 13) {
+        dualUiccInfo.sUicc2CntxLen = 0;
+      } else {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: copying UICC2 info", __func__);
+        update_uicc_context_info();
+      }
+    } else {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: UICC info are already stored..", __func__);
+    }
+
+    if ((uiccSlot == 0x01) && (dualUiccInfo.sUicc1CntxLen == 0x00)) {
+      read_uicc_context(dualUiccInfo.sUicc1Cntx, dualUiccInfo.sUicc1CntxLen,
+                        dualUiccInfo.sUicc1TechCapblty,
+                        sizeof(dualUiccInfo.sUicc1TechCapblty), 1, uiccSlot);
+    } else if ((uiccSlot == 0x02) && (dualUiccInfo.sUicc2CntxLen == 0x00)) {
+      read_uicc_context(dualUiccInfo.sUicc2Cntx, dualUiccInfo.sUicc2CntxLen,
+                        dualUiccInfo.sUicc2TechCapblty,
+                        sizeof(dualUiccInfo.sUicc2TechCapblty), 1, uiccSlot);
+    }
+
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Exit", __func__);
+  }
+
+  /**********************************************************************************
+   **
+   ** Function:        update_uicc_context_info
+   **
+   ** Description:     updates UICC context related info to buffere and file
+   **
+   ** Returns:         none
+   **
+   **********************************************************************************/
+  static void update_uicc_context_info() {
+    if (!nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: STAT_DUAL_UICC_EXT_SWITCH not available. Returning", __func__);
+      return;
+    }
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Enter", __func__);
+    tNFA_STATUS status = NFA_STATUS_FAILED;
+    tNFA_PMID param_ids_UICC_getOtherContext[] = {0xA0, 0xF5};
+    if (sSelectedUicc == 0x01) {
+      memcpy(dualUiccInfo.sUicc1Cntx, sConfig, sCurrentConfigLen);
+      status = NFA_GetConfig(0x01, param_ids_UICC_getOtherContext);
+      if (status == NFA_STATUS_OK) {
+        android::sNfaGetConfigEvent.wait();
+      }
+      memcpy(dualUiccInfo.sUicc1TechCapblty, sConfig, sCurrentConfigLen);
+      write_uicc_context(dualUiccInfo.sUicc1Cntx, dualUiccInfo.sUicc1CntxLen,
+                         dualUiccInfo.sUicc1TechCapblty, 10, 1, sSelectedUicc);
+    } else if (sSelectedUicc == 0x02) {
+      memcpy(dualUiccInfo.sUicc2Cntx, sConfig, sCurrentConfigLen);
+      status = NFA_GetConfig(0x01, param_ids_UICC_getOtherContext);
+      if (status == NFA_STATUS_OK) {
+        android::sNfaGetConfigEvent.wait();
+      }
+      memcpy(dualUiccInfo.sUicc2TechCapblty, sConfig, sCurrentConfigLen);
+      write_uicc_context(dualUiccInfo.sUicc2Cntx, dualUiccInfo.sUicc2CntxLen,
+                         dualUiccInfo.sUicc2TechCapblty, 10, 1, sSelectedUicc);
+    }
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Exit", __func__);
+  }
+
+  /**********************************************************************************
+   **
+   ** Function:        write_uicc_context
+   **
+   ** Description:     write UICC context to file
+   **
+   ** Returns:         none
+   **
+   **********************************************************************************/
+  void write_uicc_context(uint8_t * uiccContext, uint16_t uiccContextLen,
+                          uint8_t * uiccTechCap, uint16_t uiccTechCapLen,
+                          uint8_t block, uint8_t slotnum) {
+    if (!nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: STAT_DUAL_UICC_EXT_SWITCH not available. Returning", __func__);
+      return;
     }
-    ALOGV("%s : exit", __func__);
-}
+    char filename[256], filename2[256];
+    uint8_t cntx_len = 128;
+    uint8_t techCap = 10;
+    uint8_t* frameByte;
+    uint16_t crcVal = 0;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s : enter", __func__);
+
+    memset(filename, 0, sizeof(filename));
+    memset(filename2, 0, sizeof(filename2));
+    strlcpy(filename2, "/data/vendor/nfc", sizeof(filename2));
+    strlcat(filename2, "/nxpStorage.bin",
+            sizeof(filename2) - strlen(filename2) - 1);
+    if (strlen(filename2) > 200) {
+      LOG(ERROR) << StringPrintf("%s: filename too long", __func__);
+      return;
+    }
+    snprintf(filename, 256, "%s%u", filename2, block);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: bytes=%u; file=%s slotnum=%d", __func__,
+                        uiccContextLen, filename, slotnum);
 
-/*******************************************************************************
-**
-** Function         calc_crc16
-**
-** Description      Calculates CRC16 for the frame buffer
-**
-** Parameters       pBuff - CRC16 calculation input buffer
-**                  wLen  - input buffer length
-**
-** Returns          wCrc  - computed 2 byte CRC16 value
-**
-*******************************************************************************/
-uint16_t calc_crc16(uint8_t* pBuff, uint16_t wLen)
-{
-    if(!nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
-        ALOGV("%s: STAT_DUAL_UICC_EXT_SWITCH not available. Returning", __func__);
-        return 0xFF;
+    int fileStream = 0;
+
+    fileStream = open(filename, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);
+    if (fileStream >= 0) {
+      size_t actualWrittenCntx = 0;
+      size_t actualWrittenCrc = 0;
+      size_t actualWrittenTechCap = 0;
+      size_t actualWrittenCntxLen = 0;
+
+      if (slotnum == 1) {
+        lseek(fileStream, 0, SEEK_SET);
+      } else if (slotnum == 2) {
+        lseek(fileStream,
+              sizeof(dualUiccInfo.sUicc1Cntx) +
+                  sizeof(dualUiccInfo.sUicc1TechCapblty),
+              SEEK_SET);
+      }
+
+      actualWrittenCntxLen = write(fileStream, &uiccContextLen, 1);
+      if (uiccContextLen > 0x00) {
+        cntx_len = uiccContextLen;
+        techCap = uiccTechCapLen;
+        crcVal = calc_crc16(uiccContext, cntx_len);
+      }
+
+      frameByte = (uint8_t*)&crcVal;
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s:CRC calculated %02x %02x", __func__, frameByte[0], frameByte[1]);
+
+      actualWrittenCntx = write(fileStream, uiccContext, cntx_len);
+      actualWrittenCrc = write(fileStream, frameByte, sizeof(crcVal));
+      actualWrittenTechCap = write(fileStream, uiccTechCap, techCap);
+
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: %u bytes written", __func__, cntx_len);
+      if ((actualWrittenCntx == cntx_len) &&
+          (actualWrittenTechCap == techCap)) {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Write Success!");
+      } else {
+        LOG(ERROR) << StringPrintf("%s: fail to write", __func__);
+      }
+      close(fileStream);
+    } else {
+      LOG(ERROR) << StringPrintf("%s: fail to open, error = %d", __func__,
+                                 errno);
+    }
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s : exit", __func__);
+  }
+
+  /**********************************************************************************
+   **
+   ** Function:        read_uicc_context
+   **
+   ** Description:     read UICC context from file
+   **
+   ** Returns:         none
+   **
+   **********************************************************************************/
+  void read_uicc_context(uint8_t * uiccContext, uint16_t uiccContextLen,
+                         uint8_t * uiccTechCap, uint16_t uiccTechCapLen,
+                         uint8_t block, uint8_t slotnum) {
+    if (!nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: STAT_DUAL_UICC_EXT_SWITCH not available. Returning", __func__);
+      return;
+    }
+    char filename[256], filename2[256];
+    uint8_t* readCrc = NULL;
+    uint8_t* frameByte = NULL;
+    uint16_t crcVal;
+    uint8_t cmpStat;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s : enter", __func__);
+
+    memset(filename, 0, sizeof(filename));
+    memset(filename2, 0, sizeof(filename2));
+    strlcpy(filename2, "/data/vendor/nfc", sizeof(filename2));
+    strlcat(filename2, "/nxpStorage.bin",
+            sizeof(filename2) - strlen(filename2) - 1);
+    if (strlen(filename2) > 200) {
+      LOG(ERROR) << StringPrintf("%s: filename too long", __func__);
+      return;
+    }
+    snprintf(filename, 256, "%s%u", filename2, block);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: buffer len=%u; file=%s, slotnum=%d", __func__,
+                        uiccContextLen, filename, slotnum);
+    int fileStream = open(filename, O_RDONLY);
+    if (fileStream >= 0) {
+      size_t actualReadCntx = 0;
+      size_t actualReadCntxLen = 0;
+      size_t actualReadCrc = 0;
+      size_t actualReadTechCap = 0;
+      uint8_t readCntxLen = 0;
+
+      if (slotnum == 1) {
+        lseek(fileStream, 0, SEEK_SET);
+      } else if (slotnum == 2) {
+        lseek(fileStream,
+              sizeof(dualUiccInfo.sUicc1Cntx) +
+                  sizeof(dualUiccInfo.sUicc1TechCapblty),
+              SEEK_SET);
+      }
+      actualReadCntxLen = read(fileStream, &readCntxLen, 1);
+      if (readCntxLen > 0x00) {
+        actualReadCntx = read(fileStream, uiccContext, readCntxLen);
+        readCrc = (uint8_t*)malloc(2 * sizeof(uint8_t));
+        actualReadCrc = read(fileStream, readCrc, sizeof(crcVal));
+        crcVal = calc_crc16(uiccContext, readCntxLen);
+        frameByte = (uint8_t*)&crcVal;
+        actualReadTechCap = read(fileStream, uiccTechCap, uiccTechCapLen);
+
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s:CRC calculated %02x %02x -- CRC read %02x %02x", __func__,
+            frameByte[0], frameByte[1], readCrc[0], readCrc[1]);
+        cmpStat = memcmp(readCrc, frameByte, sizeof(crcVal));
+        if (cmpStat == 0) {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("%s:CRC check result - success", __func__);
+        } else {
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "%s:CRC check result - failed. Resetting buffer", __func__);
+          memset(uiccContext, 0x00, 128);
+          memset(uiccTechCap, 0x00, 10);
+          write_uicc_context(uiccContext, 0, uiccTechCap, 10, 1, slotnum);
+        }
+        free(readCrc);
+      } else {
+        memset(uiccContext, 0x00, 128);
+        memset(uiccTechCap, 0x00, 10);
+      }
+
+      if (slotnum == 1)
+        dualUiccInfo.sUicc1CntxLen = readCntxLen;
+      else if (slotnum == 2)
+        dualUiccInfo.sUicc2CntxLen = readCntxLen;
+
+      close(fileStream);
+      if (actualReadCntx > 0) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: data size=%zu", __func__, actualReadCntx);
+      } else {
+        LOG(ERROR) << StringPrintf("%s: fail to read", __func__);
+      }
+    } else {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: fail to open", __func__);
+    }
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s : exit", __func__);
+  }
+
+  /*******************************************************************************
+  **
+  ** Function         calc_crc16
+  **
+  ** Description      Calculates CRC16 for the frame buffer
+  **
+  ** Parameters       pBuff - CRC16 calculation input buffer
+  **                  wLen  - input buffer length
+  **
+  ** Returns          wCrc  - computed 2 byte CRC16 value
+  **
+  *******************************************************************************/
+  uint16_t calc_crc16(uint8_t * pBuff, uint16_t wLen) {
+    if (!nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: STAT_DUAL_UICC_EXT_SWITCH not available. Returning", __func__);
+      return 0xFF;
     }
     uint16_t wTmp;
     uint16_t wValue;
     uint16_t wCrc = 0xffff;
     uint32_t i;
     uint16_t aCrcTab[256] = {
-            0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7, 0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad,
-            0xe1ce, 0xf1ef, 0x1231, 0x0210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6, 0x9339, 0x8318, 0xb37b,
-            0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de, 0x2462, 0x3443, 0x0420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485,
-            0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d, 0x3653, 0x2672, 0x1611, 0x0630, 0x76d7,
-            0x66f6, 0x5695, 0x46b4, 0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d, 0xc7bc, 0x48c4, 0x58e5,
-            0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823, 0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a,
-            0xb92b, 0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12, 0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e,
-            0x9b79, 0x8b58, 0xbb3b, 0xab1a, 0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41, 0xedae,
-            0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b, 0x8d68, 0x9d49, 0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32,
-            0x1e51, 0x0e70, 0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78, 0x9188, 0x81a9, 0xb1ca,
-            0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f, 0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067,
-            0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e, 0x02b1, 0x1290, 0x22f3, 0x32d2, 0x4235,
-            0x5214, 0x6277, 0x7256, 0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d, 0x34e2, 0x24c3,
-            0x14a0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405, 0xa7db, 0xb7fa, 0x8799, 0x97b8, 0xe75f, 0xf77e, 0xc71d,
-            0xd73c, 0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634, 0xd94c, 0xc96d, 0xf90e, 0xe92f,
-            0x99c8, 0x89e9, 0xb98a, 0xa9ab, 0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882, 0x28a3, 0xcb7d,
-            0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a, 0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0,
-            0x2ab3, 0x3a92, 0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9, 0x7c26, 0x6c07, 0x5c64,
-            0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1, 0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8,
-            0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0 };
-
-    if((NULL == pBuff) || (0 == wLen))
-    {
-        ALOGV("%s: Invalid Params supplied", __func__);
-    }
-    else
-    {
-        /* Perform CRC calculation according to ccitt with a initial value of 0x1d0f */
-        for (i = 0; i < wLen; i++)
-        {
-            wValue = 0x00ffU & (uint16_t) pBuff[i];
-            wTmp = (wCrc >> 8U) ^ wValue;
-            wCrc = (wCrc << 8U) ^ aCrcTab[wTmp];
-        }
+        0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7, 0x8108,
+        0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef, 0x1231, 0x0210,
+        0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6, 0x9339, 0x8318, 0xb37b,
+        0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de, 0x2462, 0x3443, 0x0420, 0x1401,
+        0x64e6, 0x74c7, 0x44a4, 0x5485, 0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee,
+        0xf5cf, 0xc5ac, 0xd58d, 0x3653, 0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6,
+        0x5695, 0x46b4, 0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d,
+        0xc7bc, 0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823,
+        0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b, 0x5af5,
+        0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12, 0xdbfd, 0xcbdc,
+        0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a, 0x6ca6, 0x7c87, 0x4ce4,
+        0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41, 0xedae, 0xfd8f, 0xcdec, 0xddcd,
+        0xad2a, 0xbd0b, 0x8d68, 0x9d49, 0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13,
+        0x2e32, 0x1e51, 0x0e70, 0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a,
+        0x9f59, 0x8f78, 0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e,
+        0xe16f, 0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067,
+        0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e, 0x02b1,
+        0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256, 0xb5ea, 0xa5cb,
+        0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d, 0x34e2, 0x24c3, 0x14a0,
+        0x0481, 0x7466, 0x6447, 0x5424, 0x4405, 0xa7db, 0xb7fa, 0x8799, 0x97b8,
+        0xe75f, 0xf77e, 0xc71d, 0xd73c, 0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657,
+        0x7676, 0x4615, 0x5634, 0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9,
+        0xb98a, 0xa9ab, 0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882,
+        0x28a3, 0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a,
+        0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92, 0xfd2e,
+        0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9, 0x7c26, 0x6c07,
+        0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1, 0xef1f, 0xff3e, 0xcf5d,
+        0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8, 0x6e17, 0x7e36, 0x4e55, 0x5e74,
+        0x2e93, 0x3eb2, 0x0ed1, 0x1ef0};
+
+    if ((NULL == pBuff) || (0 == wLen)) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: Invalid Params supplied", __func__);
+    } else {
+      /* Perform CRC calculation according to ccitt with a initial value of
+       * 0x1d0f */
+      for (i = 0; i < wLen; i++) {
+        wValue = 0x00ffU & (uint16_t)pBuff[i];
+        wTmp = (wCrc >> 8U) ^ wValue;
+        wCrc = (wCrc << 8U) ^ aCrcTab[wTmp];
+      }
     }
 
     return wCrc;
-}
-
-/**********************************************************************************
- **
- ** Function:        getUiccSession
- **
- ** Description:     Read and store UICC session values
- **
- ** Returns:         UICC Configured status
- **                  1 : failed
- **                  0 : success
- **
- **********************************************************************************/
-static int getUiccSession()
-{
-    if(!nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
-        ALOGV("%s: STAT_DUAL_UICC_EXT_SWITCH not available. Returning", __func__);
-        return 0;
-    }
-    ALOGV("%s: Enter", __func__);
+  }
+
+  /**********************************************************************************
+   **
+   ** Function:        getUiccSession
+   **
+   ** Description:     Read and store UICC session values
+   **
+   ** Returns:         UICC Configured status
+   **                  1 : failed
+   **                  0 : success
+   **
+   **********************************************************************************/
+  static int getUiccSession() {
+    if (!nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: STAT_DUAL_UICC_EXT_SWITCH not available. Returning", __func__);
+      return 0;
+    }
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Enter", __func__);
 
     int cmpStat = 0, sUiccConfigured = 1;
     /*techInfo will be set if any DISCOVERY_REQ_NTF is received for current UICC
-     *It will be used to validate received session id belongs to current selected UICC or not
+     *It will be used to validate received session id belongs to current
+     *selected UICC or not
      * */
-    bool techInfo = SecureElement::getInstance().isTeckInfoReceived (SecureElement::getInstance().EE_HANDLE_0xF4);
-    ALOGV("%s: techInfo 0x%02x", __func__,techInfo);
+    bool techInfo = SecureElement::getInstance().isTeckInfoReceived(
+        SecureElement::getInstance().EE_HANDLE_0xF4);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: techInfo 0x%02x", __func__, techInfo);
 
     /* sConfig will have session ID received
-     * If received different from previous UICC save it in corresponding UICC buffer
+     * If received different from previous UICC save it in corresponding UICC
+     * buffer
      * If same, reset the UICC buffer
      * */
-    if(sSelectedUicc == 0x01)
-    {
-        if(dualUiccInfo.sUicc2SessionIdLen != 0)
-        {
-            cmpStat = memcmp (sConfig + 4, dualUiccInfo.sUicc2SessionId, dualUiccInfo.sUicc2SessionIdLen);
-            if((cmpStat == 0)||(!techInfo))
-            {
-                memset(dualUiccInfo.sUicc1SessionId,0x00,sizeof(dualUiccInfo.sUicc1SessionId));
-                dualUiccInfo.sUicc1SessionIdLen = 0;
-                sUiccConfigured = 1;
-            }
-            else
-            {
-                memcpy(dualUiccInfo.sUicc1SessionId, sConfig+4, 8);
-                dualUiccInfo.sUicc1SessionIdLen = 8;
-                sUiccConfigured = 0;
-            }
-        }
-        else if(techInfo)
-        {
-            memcpy(dualUiccInfo.sUicc1SessionId, sConfig+4, 8);
-            dualUiccInfo.sUicc1SessionIdLen = 8;
-            sUiccConfigured = 0;
-        }
-    }
-    else if(sSelectedUicc == 0x02)
-    {
-        if(dualUiccInfo.sUicc1SessionIdLen != 0)
-        {
-            cmpStat = memcmp (sConfig + 4, dualUiccInfo.sUicc1SessionId, dualUiccInfo.sUicc1SessionIdLen);
-            if((cmpStat == 0)||(!techInfo))
-            {
-                memset(dualUiccInfo.sUicc2SessionId,0x00,sizeof(dualUiccInfo.sUicc2SessionId));
-                dualUiccInfo.sUicc2SessionIdLen = 0;
-                sUiccConfigured = 1;
-            }
-            else
-            {
-                memcpy(dualUiccInfo.sUicc2SessionId, sConfig+4, 8);
-                dualUiccInfo.sUicc2SessionIdLen = 8;
-                sUiccConfigured = 0;
-            }
-        }
-        else if(techInfo)
-        {
-            memcpy(dualUiccInfo.sUicc2SessionId, sConfig+4, 8);
-            dualUiccInfo.sUicc2SessionIdLen = 8;
-            sUiccConfigured = 0;
+    if (sSelectedUicc == 0x01) {
+      if (dualUiccInfo.sUicc2SessionIdLen != 0) {
+        cmpStat = memcmp(sConfig + 4, dualUiccInfo.sUicc2SessionId,
+                         dualUiccInfo.sUicc2SessionIdLen);
+        if ((cmpStat == 0) || (!techInfo)) {
+          memset(dualUiccInfo.sUicc1SessionId, 0x00,
+                 sizeof(dualUiccInfo.sUicc1SessionId));
+          dualUiccInfo.sUicc1SessionIdLen = 0;
+          sUiccConfigured = 1;
+        } else {
+          memcpy(dualUiccInfo.sUicc1SessionId, sConfig + 4, 8);
+          dualUiccInfo.sUicc1SessionIdLen = 8;
+          sUiccConfigured = 0;
+        }
+      } else if (techInfo) {
+        memcpy(dualUiccInfo.sUicc1SessionId, sConfig + 4, 8);
+        dualUiccInfo.sUicc1SessionIdLen = 8;
+        sUiccConfigured = 0;
+      }
+    } else if (sSelectedUicc == 0x02) {
+      if (dualUiccInfo.sUicc1SessionIdLen != 0) {
+        cmpStat = memcmp(sConfig + 4, dualUiccInfo.sUicc1SessionId,
+                         dualUiccInfo.sUicc1SessionIdLen);
+        if ((cmpStat == 0) || (!techInfo)) {
+          memset(dualUiccInfo.sUicc2SessionId, 0x00,
+                 sizeof(dualUiccInfo.sUicc2SessionId));
+          dualUiccInfo.sUicc2SessionIdLen = 0;
+          sUiccConfigured = 1;
+        } else {
+          memcpy(dualUiccInfo.sUicc2SessionId, sConfig + 4, 8);
+          dualUiccInfo.sUicc2SessionIdLen = 8;
+          sUiccConfigured = 0;
         }
+      } else if (techInfo) {
+        memcpy(dualUiccInfo.sUicc2SessionId, sConfig + 4, 8);
+        dualUiccInfo.sUicc2SessionIdLen = 8;
+        sUiccConfigured = 0;
+      }
     }
     return sUiccConfigured;
-}
-/**********************************************************************************
- **
- ** Function:        notifyUiccEvent
- **
- ** Description:     Notifies UICC event sto Service
- **                  Possible values:
- **                  UICC_CONNECTED_0 - 0 UICC connected
- **                  UICC_CONNECTED_1 - 1 UICC connected
- **                  UICC_CONNECTED_2 - 2 UICCs connected
- **
- ** Returns:         None
- **
- **********************************************************************************/
-static void notifyUiccEvent (union sigval)
-{
-    if(!nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
-        ALOGV("%s: STAT_DUAL_UICC_EXT_SWITCH not available. Returning", __func__);
-        return;
-    }
-    ALOGV("%s", __func__);
-    struct nfc_jni_native_data *nat = getNative(NULL, NULL);
+  }
+  /**********************************************************************************
+   **
+   ** Function:        notifyUiccEvent
+   **
+   ** Description:     Notifies UICC event sto Service
+   **                  Possible values:
+   **                  UICC_CONNECTED_0 - 0 UICC connected
+   **                  UICC_CONNECTED_1 - 1 UICC connected
+   **                  UICC_CONNECTED_2 - 2 UICCs connected
+   **
+   ** Returns:         None
+   **
+   **********************************************************************************/
+  static void notifyUiccEvent(union sigval) {
+    if (!nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: STAT_DUAL_UICC_EXT_SWITCH not available. Returning", __func__);
+      return;
+    }
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
+    struct nfc_jni_native_data* nat = getNative(NULL, NULL);
     JNIEnv* e;
     ScopedAttach attach(nat->vm, &e);
-    if (e == NULL)
-    {
-        ALOGE("jni env is null");
-        return;
+    if (e == NULL) {
+      LOG(ERROR) << StringPrintf("jni env is null");
+      return;
     }
-    if(dualUiccInfo.uiccActivStat == 0x00) /*No UICC Detected*/
+    if (dualUiccInfo.uiccActivStat == 0x00) /*No UICC Detected*/
     {
-        e->CallVoidMethod (nat->manager, android::gCachedNfcManagerNotifyUiccStatusEvent, UICC_CONNECTED_0);
-    }
-    else if((dualUiccInfo.uiccActivStat == 0x01)||(dualUiccInfo.uiccActivStat == 0x02)) /*One UICC Detected*/
+      e->CallVoidMethod(nat->manager,
+                        android::gCachedNfcManagerNotifyUiccStatusEvent,
+                        UICC_CONNECTED_0);
+    } else if ((dualUiccInfo.uiccActivStat == 0x01) ||
+               (dualUiccInfo.uiccActivStat == 0x02)) /*One UICC Detected*/
     {
-        e->CallVoidMethod (nat->manager, android::gCachedNfcManagerNotifyUiccStatusEvent, UICC_CONNECTED_1);
-    }
-    else if(dualUiccInfo.uiccActivStat == 0x03) /*Two UICC Detected*/
+      e->CallVoidMethod(nat->manager,
+                        android::gCachedNfcManagerNotifyUiccStatusEvent,
+                        UICC_CONNECTED_1);
+    } else if (dualUiccInfo.uiccActivStat == 0x03) /*Two UICC Detected*/
     {
-        e->CallVoidMethod (nat->manager, android::gCachedNfcManagerNotifyUiccStatusEvent, UICC_CONNECTED_2);
+      e->CallVoidMethod(nat->manager,
+                        android::gCachedNfcManagerNotifyUiccStatusEvent,
+                        UICC_CONNECTED_2);
     }
+  }
 
-}
-
-static int nfcManager_staticDualUicc_Precondition(int uiccSlot)
-{
-if(!nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH && !nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) {
-    ALOGD("%s:Dual UICC feature not available . Returning", __func__);
-    return DUAL_UICC_FEATURE_NOT_AVAILABLE;
-}
+  static int nfcManager_staticDualUicc_Precondition(int uiccSlot) {
+    if (!nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH &&
+        !nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s:Dual UICC feature not available . Returning", __func__);
+      return DUAL_UICC_FEATURE_NOT_AVAILABLE;
+    }
     unsigned long uicc_active_state = 0;
 
     uint8_t retStat = UICC_NOT_CONFIGURED;
-    if(nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
-        if(GetNxpNumValue (NAME_NXP_DUAL_UICC_ENABLE, (void*)&uicc_active_state, sizeof(uicc_active_state)))
-        {
-            ALOGV("NXP_DUAL_UICC_ENABLE  : 0x%02lx",uicc_active_state);
-        }
-        else
-        {
-            ALOGE("NXP_DUAL_UICC_ENABLE Not found taking default value 0x00");
-            uicc_active_state = 0x00;
-        }
-
-        if(uicc_active_state != 0x01)
-        {
-            ALOGE("%s:FAIL Dual UICC feature not available", __func__);
-            retStat = DUAL_UICC_FEATURE_NOT_AVAILABLE;
-        }
-    }
-
-    if(sIsDisabling)
-    {
-        ALOGE("%s:FAIL Nfc is Disabling : Switch UICC not allowed", __func__);
-        retStat = DUAL_UICC_ERROR_NFC_TURNING_OFF;
-    }
-    else if(SecureElement::getInstance().isBusy())
-    {
-        ALOGE("%s:FAIL  SE wired-mode : busy", __func__);
-        retStat = DUAL_UICC_ERROR_NFCC_BUSY;
-    }
-    else if(rfActivation)
-    {
-        ALOGE("%s:FAIL  RF session ongoing", __func__);
-        retStat = DUAL_UICC_ERROR_NFCC_BUSY;
-    }
-    else if((uiccSlot != 0x01) && (uiccSlot != 0x02))
-    {
-        ALOGE("%s: Invalid slot id", __func__);
-        retStat = DUAL_UICC_ERROR_INVALID_SLOT;
-    }
-    else if(SecureElement::getInstance().isRfFieldOn())
-    {
-        ALOGE("%s:FAIL  RF field on", __func__);
+    if (nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
+      if (NfcConfig::hasKey(NAME_NXP_DUAL_UICC_ENABLE)) {
+        uicc_active_state = NfcConfig::getUnsigned(NAME_NXP_DUAL_UICC_ENABLE);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "NXP_DUAL_UICC_ENABLE  : 0x%02lx", uicc_active_state);
+      } else {
+        LOG(ERROR) << StringPrintf(
+            "NXP_DUAL_UICC_ENABLE Not found taking default value 0x00");
+        uicc_active_state = 0x00;
+      }
+
+      if (uicc_active_state != 0x01) {
+        LOG(ERROR) << StringPrintf("%s:FAIL Dual UICC feature not available",
+                                   __func__);
+        retStat = DUAL_UICC_FEATURE_NOT_AVAILABLE;
+      }
+    }
+
+    if (sIsDisabling) {
+      LOG(ERROR) << StringPrintf(
+          "%s:FAIL Nfc is Disabling : Switch UICC not allowed", __func__);
+      retStat = DUAL_UICC_ERROR_NFC_TURNING_OFF;
+    } else if (SecureElement::getInstance().isBusy()) {
+      LOG(ERROR) << StringPrintf("%s:FAIL  SE wired-mode : busy", __func__);
+      retStat = DUAL_UICC_ERROR_NFCC_BUSY;
+    } else if (rfActivation) {
+      LOG(ERROR) << StringPrintf("%s:FAIL  RF session ongoing", __func__);
+      retStat = DUAL_UICC_ERROR_NFCC_BUSY;
+    } else if ((uiccSlot != 0x01) && (uiccSlot != 0x02)) {
+      LOG(ERROR) << StringPrintf("%s: Invalid slot id", __func__);
+      retStat = DUAL_UICC_ERROR_INVALID_SLOT;
+    } else if (SecureElement::getInstance().isRfFieldOn()) {
+      LOG(ERROR) << StringPrintf("%s:FAIL  RF field on", __func__);
+      retStat = DUAL_UICC_ERROR_NFCC_BUSY;
+    } else if (sDiscoveryEnabled || sRfEnabled) {
+      if (!pTransactionController->transactionAttempt(
+              TRANSACTION_REQUESTOR(staticDualUicc))) {
+        LOG(ERROR) << StringPrintf("%s: Transaction in progress. Can not set",
+                                   __func__);
         retStat = DUAL_UICC_ERROR_NFCC_BUSY;
-    }
-    else if(sDiscoveryEnabled || sRfEnabled)
-    {
-        if(!pTransactionController->transactionAttempt(TRANSACTION_REQUESTOR(staticDualUicc)))
-        {
-            ALOGE("%s: Transaction in progress. Can not set", __func__);
-            retStat = DUAL_UICC_ERROR_NFCC_BUSY;
-        }
-        else
-        {
-            ALOGE("%s: Transaction state enabled", __func__);
-        }
-
+      } else {
+        LOG(ERROR) << StringPrintf("%s: Transaction state enabled", __func__);
+      }
     }
     return retStat;
-}
+  }
 
-static void nfaNxpSelfTestNtfCallback(uint8_t event, uint16_t param_len, uint8_t *p_param)
-{
+  static void nfaNxpSelfTestNtfCallback(uint8_t event, uint16_t param_len,
+                                        uint8_t * p_param) {
     (void)event;
-    ALOGV("%s", __func__);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
 
-    if(param_len == 0x05 && p_param[3] == 00) //p_param[4]  0x00:SWP Link OK 0x03:SWP link dead.
+    if (param_len == 0x05 &&
+        p_param[3] == 00)  // p_param[4]  0x00:SWP Link OK 0x03:SWP link dead.
     {
-        ALOGV("NXP SWP SelfTest : SWP Link OK ");
-        SetCbStatus(NFA_STATUS_OK);
-    }
-    else
-    {
-        if(p_param[3] == 0x03) ALOGV("NXP SWP SelfTest : SWP Link dead ");
-        SetCbStatus(NFA_STATUS_FAILED);
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("NXP SWP SelfTest : SWP Link OK ");
+      SetCbStatus(NFA_STATUS_OK);
+    } else {
+      if (p_param[3] == 0x03)
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("NXP SWP SelfTest : SWP Link dead ");
+      SetCbStatus(NFA_STATUS_FAILED);
     }
 
-    switch(p_param[4]){ //information of PMUVCC.
-        case 0x00 : ALOGV("NXP SWP SelfTest : No PMUVCC ");break;
-        case 0x01 : ALOGV("NXP SWP SelfTest : PMUVCC = 1.8V ");break;
-        case 0x02 : ALOGV("NXP SWP SelfTest : PMUVCC = 3.3V ");break;
-        case 0x03 : ALOGV("NXP SWP SelfTest : PMUVCC = undetermined ");break;
-        default   : ALOGV("NXP SWP SelfTest : unknown PMUVCC ");break;
+    switch (p_param[4]) {  // information of PMUVCC.
+      case 0x00:
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("NXP SWP SelfTest : No PMUVCC ");
+        break;
+      case 0x01:
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("NXP SWP SelfTest : PMUVCC = 1.8V ");
+        break;
+      case 0x02:
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("NXP SWP SelfTest : PMUVCC = 3.3V ");
+        break;
+      case 0x03:
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("NXP SWP SelfTest : PMUVCC = undetermined ");
+        break;
+      default:
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("NXP SWP SelfTest : unknown PMUVCC ");
+        break;
     }
 
-    SyncEventGuard guard (sNfaNxpNtfEvent);
-    sNfaNxpNtfEvent.notifyOne ();
-}
+    SyncEventGuard guard(sNfaNxpNtfEvent);
+    sNfaNxpNtfEvent.notifyOne();
+  }
 
-static void nfcManager_doPrbsOn(JNIEnv* e, jobject o, jint prbs, jint hw_prbs, jint tech, jint rate)
-{
+  static void nfcManager_doPrbsOn(JNIEnv * e, jobject o, jint prbs,
+                                  jint hw_prbs, jint tech, jint rate) {
     (void)e;
     (void)o;
-    ALOGV("%s: enter", __func__);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
     tNFA_STATUS status = NFA_STATUS_FAILED;
-//    bool stat = false;                    /*commented to eliminate unused variable warning*/
+    //    bool stat = false;                    /*commented to eliminate unused
+    //    variable warning*/
 
     if (!sIsNfaEnabled) {
-        ALOGV("NFC does not enabled!!");
-        return;
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("NFC does not enabled!!");
+      return;
     }
 
     if (sDiscoveryEnabled) {
-        ALOGV("Discovery must not be enabled for SelfTest");
-        return ;
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("Discovery must not be enabled for SelfTest");
+      return;
     }
 
-    if(tech < 0 || tech > 2)
-    {
-        ALOGV("Invalid tech! please choose A or B or F");
-        return;
+    if (tech < 0 || tech > 2) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("Invalid tech! please choose A or B or F");
+      return;
     }
 
-    if(rate < 0 || rate > 3){
-        ALOGV("Invalid bitrate! please choose 106 or 212 or 424 or 848");
-        return;
+    if (rate < 0 || rate > 3) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "Invalid bitrate! please choose 106 or 212 or 424 or 848");
+      return;
     }
 
-    //Technology to stream          0x00:TypeA 0x01:TypeB 0x02:TypeF
-    //Bitrate                       0x00:106kbps 0x01:212kbps 0x02:424kbps 0x03:848kbps
-    //prbs and hw_prbs              0x00 or 0x01 two extra parameters included in case of pn548AD
+    // Technology to stream          0x00:TypeA 0x01:TypeB 0x02:TypeF
+    // Bitrate                       0x00:106kbps 0x01:212kbps 0x02:424kbps
+    // 0x03:848kbps
+    // prbs and hw_prbs              0x00 or 0x01 two extra parameters included
+    // in case of pn548AD
     uint8_t param[4];
     memset(param, 0x00, sizeof(param));
-    if(nfcFL.chipType != pn547C2) {
-        param[0] = prbs;
-        param[1] = hw_prbs;
-        param[2] = tech;    //technology
-        param[3] = rate;    //bitrate
-        ALOGV("phNxpNciHal_getPrbsCmd: PRBS = %d  HW_PRBS = %d", prbs, hw_prbs);
-    }
-    else {
-        param[0] = tech;
-        param[1] = rate;
-    }
-    switch (tech)
-    {
-        case 0x00:
-             ALOGV("phNxpNciHal_getPrbsCmd - NFC_RF_TECHNOLOGY_A");
-             break;
-        case 0x01:
-             ALOGV("phNxpNciHal_getPrbsCmd - NFC_RF_TECHNOLOGY_B");
-             break;
-        case 0x02:
-             ALOGV("phNxpNciHal_getPrbsCmd - NFC_RF_TECHNOLOGY_F");
-             break;
-        default:
-             break;
-    }
-    switch (rate)
-    {
-        case 0x00:
-             ALOGV("phNxpNciHal_getPrbsCmd - NFC_BIT_RATE_106");
-             break;
-        case 0x01:
-             ALOGV("phNxpNciHal_getPrbsCmd - NFC_BIT_RATE_212");
-             break;
-        case 0x02:
-             ALOGV("phNxpNciHal_getPrbsCmd - NFC_BIT_RATE_424");
-             break;
-        case 0x03:
-             ALOGV("phNxpNciHal_getPrbsCmd - NFC_BIT_RATE_848");
-             break;
-        default:
-             break;
-    }
-    //step2. PRBS Test stop : CORE RESET_CMD
-    status = Nxp_SelfTest(3, param);   //CORE_RESET_CMD
-    if(NFA_STATUS_OK != status)
-    {
-        ALOGV("%s: CORE RESET_CMD Fail!", __func__);
-        status = NFA_STATUS_FAILED;
-        goto TheEnd;
+    if (nfcFL.chipType != pn547C2) {
+      param[0] = prbs;
+      param[1] = hw_prbs;
+      param[2] = tech;  // technology
+      param[3] = rate;  // bitrate
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "phNxpNciHal_getPrbsCmd: PRBS = %d  HW_PRBS = %d", prbs, hw_prbs);
+    } else {
+      param[0] = tech;
+      param[1] = rate;
     }
-    //step3. PRBS Test stop : CORE_INIT_CMD
-    status = Nxp_SelfTest(4, param);   //CORE_INIT_CMD
-    if(NFA_STATUS_OK != status)
-    {
-        ALOGV("%s: CORE_INIT_CMD Fail!", __func__);
-        status = NFA_STATUS_FAILED;
-        goto TheEnd;
+    switch (tech) {
+      case 0x00:
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("phNxpNciHal_getPrbsCmd - NFC_RF_TECHNOLOGY_A");
+        break;
+      case 0x01:
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("phNxpNciHal_getPrbsCmd - NFC_RF_TECHNOLOGY_B");
+        break;
+      case 0x02:
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("phNxpNciHal_getPrbsCmd - NFC_RF_TECHNOLOGY_F");
+        break;
+      default:
+        break;
     }
-    //step4. : NXP_ACT_PROP_EXTN
-    status = Nxp_SelfTest(5, param);   //NXP_ACT_PROP_EXTN
-    if(NFA_STATUS_OK != status)
-    {
-        ALOGV("%s: NXP_ACT_PROP_EXTN Fail!", __func__);
-        status = NFA_STATUS_FAILED;
-        goto TheEnd;
+    switch (rate) {
+      case 0x00:
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("phNxpNciHal_getPrbsCmd - NFC_BIT_RATE_106");
+        break;
+      case 0x01:
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("phNxpNciHal_getPrbsCmd - NFC_BIT_RATE_212");
+        break;
+      case 0x02:
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("phNxpNciHal_getPrbsCmd - NFC_BIT_RATE_424");
+        break;
+      case 0x03:
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("phNxpNciHal_getPrbsCmd - NFC_BIT_RATE_848");
+        break;
     }
-
-    status = Nxp_SelfTest(1, param);
-    ALOGV("%s: exit; status =0x%X", __func__,status);
-
-    TheEnd:
-        //Factory Test Code
-        ALOGV("%s: exit; status =0x%X", __func__,status);
+    // step2. PRBS Test stop : CORE RESET_CMD
+    status = Nxp_SelfTest(NFC_CMD_TYPE_CORE_RESET, param);  // CORE_RESET_CMD
+    if (NFA_STATUS_OK != status) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: CORE RESET_CMD Fail!", __func__);
+      status = NFA_STATUS_FAILED;
+      goto TheEnd;
+    }
+    // step3. PRBS Test stop : CORE_INIT_CMD
+    status = Nxp_SelfTest(NFC_CMD_TYPE_CORE_INIT, param);  // CORE_INIT_CMD
+    if (NFA_STATUS_OK != status) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: CORE_INIT_CMD Fail!", __func__);
+      status = NFA_STATUS_FAILED;
+      goto TheEnd;
+    }
+    // step4. : NXP_ACT_PROP_EXTN
+    status =
+        Nxp_SelfTest(NFC_CMD_TYPE_ACT_PROP_EXTN, param);  // NXP_ACT_PROP_EXTN
+    if (NFA_STATUS_OK != status) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: NXP_ACT_PROP_EXTN Fail!", __func__);
+      status = NFA_STATUS_FAILED;
+      goto TheEnd;
+    }
+
+    status = Nxp_SelfTest(NFC_CMD_TYPE_PRBS_START, param);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: exit; status =0x%X", __func__, status);
+
+  TheEnd:
+    // Factory Test Code
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: exit; status =0x%X", __func__, status);
     return;
-}
+  }
 
-static void nfcManager_doPrbsOff(JNIEnv* e, jobject o)
-{
+  static void nfcManager_doPrbsOff(JNIEnv * e, jobject o) {
     (void)e;
     (void)o;
-    ALOGV("%s: enter", __func__);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
     tNFA_STATUS status = NFA_STATUS_FAILED;
-//    bool stat = false;                    /*commented to eliminate unused variable warning*/
+    //    bool stat = false;                    /*commented to eliminate unused
+    //    variable warning*/
     uint8_t param;
 
     if (!sIsNfaEnabled) {
-        ALOGV("NFC does not enabled!!");
-        return;
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("NFC does not enabled!!");
+      return;
     }
 
     if (sDiscoveryEnabled) {
-        ALOGV("Discovery must not be enabled for SelfTest");
-        return;
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("Discovery must not be enabled for SelfTest");
+      return;
     }
 
-    //Factory Test Code
-    //step1. PRBS Test stop : VEN RESET
-    status = Nxp_SelfTest(2, &param);   //VEN RESET
-    if(NFA_STATUS_OK != status)
-    {
-        ALOGV("step1. PRBS Test stop : VEN RESET Fail!");
-        status = NFA_STATUS_FAILED;
-        goto TheEnd;
+    // Factory Test Code
+    // step1. PRBS Test stop : VEN RESET
+    status = Nxp_SelfTest(NFC_CMD_TYPE_PRBS_STOP, &param);  // VEN RESET
+    if (NFA_STATUS_OK != status) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("step1. PRBS Test stop : VEN RESET Fail!");
+      status = NFA_STATUS_FAILED;
+      goto TheEnd;
     }
 
-    TheEnd:
-    //Factory Test Code
-    ALOGV("%s: exit; status =0x%X", __func__,status);
+  TheEnd:
+    // Factory Test Code
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: exit; status =0x%X", __func__, status);
 
     return;
-}
+  }
 
-static jint nfcManager_SWPSelfTest(JNIEnv* e, jobject o, jint ch)
-{
+  static jint nfcManager_SWPSelfTest(JNIEnv * e, jobject o, jint ch) {
     (void)e;
     (void)o;
-    ALOGV("%s: enter", __func__);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
     tNFA_STATUS status = NFA_STATUS_FAILED;
     tNFA_STATUS regcb_stat = NFA_STATUS_FAILED;
     uint8_t param[1];
 
     if (!sIsNfaEnabled) {
-        ALOGV("NFC does not enabled!!");
-        return status;
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("NFC does not enabled!!");
+      return status;
     }
 
     if (sDiscoveryEnabled) {
-        ALOGV("Discovery must not be enabled for SelfTest");
-        return status;
-    }
-
-    if (ch < 0 || ch > 1){
-        ALOGV("Invalid channel!! please choose 0 or 1");
-        return status;
-    }
-
-
-    //step1.  : CORE RESET_CMD
-    status = Nxp_SelfTest(3, param);   //CORE_RESET_CMD
-    if(NFA_STATUS_OK != status)
-    {
-        ALOGV("step2. PRBS Test stop : CORE RESET_CMD Fail!");
-        status = NFA_STATUS_FAILED;
-        goto TheEnd;
-    }
-
-    //step2. : CORE_INIT_CMD
-    status = Nxp_SelfTest(4, param);   //CORE_INIT_CMD
-    if(NFA_STATUS_OK != status)
-    {
-        ALOGV("step3. PRBS Test stop : CORE_INIT_CMD Fail!");
-        status = NFA_STATUS_FAILED;
-        goto TheEnd;
-    }
-
-    //step3. : NXP_ACT_PROP_EXTN
-    status = Nxp_SelfTest(5, param);   //NXP_ACT_PROP_EXTN
-    if(NFA_STATUS_OK != status)
-    {
-        ALOGV("step: NXP_ACT_PROP_EXTN Fail!");
-        status = NFA_STATUS_FAILED;
-        goto TheEnd;
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("Discovery must not be enabled for SelfTest");
+      return status;
     }
 
-    regcb_stat = NFA_RegVSCback (true,nfaNxpSelfTestNtfCallback); //Register CallBack for NXP NTF
-    if(NFA_STATUS_OK != regcb_stat)
-    {
-        ALOGV("To Regist Ntf Callback is Fail!");
-        goto TheEnd;
-    }
-
-    param[0] = ch; // SWP channel 0x00 : SWP1(UICC) 0x01:SWP2(eSE)
-    status = Nxp_SelfTest(0, param);
-    if(NFA_STATUS_OK != status)
-    {
-        status = NFA_STATUS_FAILED;
-        goto TheEnd;
-    }
-
-    {
-        ALOGV("NFC NXP SelfTest wait for Notificaiton");
-        nfaNxpSelfTestNtfTimer.set(1000, nfaNxpSelfTestNtfTimerCb);
-        SyncEventGuard guard (sNfaNxpNtfEvent);
-        sNfaNxpNtfEvent.wait(); //wait for NXP Self NTF to come
-    }
-
-    status = GetCbStatus();
-    if(NFA_STATUS_OK != status)
-    {
-        status = NFA_STATUS_FAILED;
-    }
-
-    TheEnd:
-    if(NFA_STATUS_OK == regcb_stat) {
-        regcb_stat = NFA_RegVSCback (false,nfaNxpSelfTestNtfCallback); //DeRegister CallBack for NXP NTF
-    }
-    nfaNxpSelfTestNtfTimer.kill();
-    ALOGV("%s: exit; status =0x%X", __func__,status);
-    return status;
-}
-
-#if 0
-/*******************************************************************************
- **
- ** Function:       nfcManager_doPartialInitialize
- **
- ** Description:    Initializes the NFC partially if it is not initialized.
- **                 This will be required  for transceive  during NFC off.
- **
- **
- ** Returns:        true/false .
- **
- *******************************************************************************/
-static bool nfcManager_doPartialInitialize ()
-{
-
-    ALOGV("%s enter", __func__);
-    tNFA_STATUS stat = NFA_STATUS_OK;
-    if (sIsNfaEnabled || gsNfaPartialEnabled)
-    {
-        ALOGV("%s: NFC already enabled", __func__);
-        return true;
+    if (ch < 0 || ch > 1) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("Invalid channel!! please choose 0 or 1");
+      return status;
     }
-    NfcAdaptation& theInstance = NfcAdaptation::GetInstance();
-    theInstance.MinInitialize();
 
-    tHAL_NFC_ENTRY* halFuncEntries = theInstance.GetHalEntryFuncs ();
-    ALOGV("%s: calling nfa init", __func__);
-    if(NULL == halFuncEntries)
-    {
-        theInstance.Finalize();
-        gsNfaPartialEnabled = false;
-        return false;
+    // step1.  : CORE RESET_CMD
+    status = Nxp_SelfTest(NFC_CMD_TYPE_CORE_RESET, param);  // CORE_RESET_CMD
+    if (NFA_STATUS_OK != status) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("step2. PRBS Test stop : CORE RESET_CMD Fail!");
+      status = NFA_STATUS_FAILED;
+      goto TheEnd;
     }
 
-    NFA_SetBootMode(NFA_FAST_BOOT_MODE);
-    NFA_Init (halFuncEntries);
-    ALOGV("%s: calling enable", __func__);
-    stat = NFA_Enable (nfaDeviceManagementCallback, nfaConnectionCallback);
-    if (stat == NFA_STATUS_OK)
-    {
-        SyncEventGuard guard (sNfaEnableEvent);
-        sNfaEnableEvent.wait(); //wait for NFA command to finish
+    // step2. : CORE_INIT_CMD
+    status = Nxp_SelfTest(NFC_CMD_TYPE_CORE_INIT, param);  // CORE_INIT_CMD
+    if (NFA_STATUS_OK != status) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("step3. PRBS Test stop : CORE_INIT_CMD Fail!");
+      status = NFA_STATUS_FAILED;
+      goto TheEnd;
     }
 
-    if (sIsNfaEnabled)
-    {
-        gsNfaPartialEnabled = true;
-        sIsNfaEnabled = false;
+    // step3. : NXP_ACT_PROP_EXTN
+    status =
+        Nxp_SelfTest(NFC_CMD_TYPE_ACT_PROP_EXTN, param);  // NXP_ACT_PROP_EXTN
+    if (NFA_STATUS_OK != status) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("step: NXP_ACT_PROP_EXTN Fail!");
+      status = NFA_STATUS_FAILED;
+      goto TheEnd;
     }
-    else
-    {
-        NFA_Disable (false /* ungraceful */);
-        theInstance.Finalize();
-        gsNfaPartialEnabled = false;
+
+    regcb_stat = NFA_RegVSCback(
+        true, nfaNxpSelfTestNtfCallback);  // Register CallBack for NXP NTF
+    if (NFA_STATUS_OK != regcb_stat) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("To Regist Ntf Callback is Fail!");
+      goto TheEnd;
     }
 
-    ALOGV("%s exit status = 0x%x",  __func__ ,gsNfaPartialEnabled);
-    return gsNfaPartialEnabled;
-}
-#endif
-/*******************************************************************************
- **
- ** Function:       nfcManager_doPartialDeInitialize
- **
- ** Description:    DeInitializes the NFC partially if it is partially initialized.
- **
- ** Returns:        true/false .
- **
- *******************************************************************************/
-static bool nfcManager_doPartialDeInitialize()
-{
-    tNFA_STATUS stat = NFA_STATUS_OK;
-    if(!gsNfaPartialEnabled)
-    {
-        ALOGV("%s: cannot deinitialize NFC , not partially initilaized", __func__);
-        return true;
+    param[0] = ch;  // SWP channel 0x00 : SWP1(UICC) 0x01:SWP2(eSE)
+    status = Nxp_SelfTest(NFC_CMD_TYPE_SWP, param);
+    if (NFA_STATUS_OK != status) {
+      status = NFA_STATUS_FAILED;
+      goto TheEnd;
     }
-    ALOGV("%s:enter", __func__);
-    stat = NFA_Disable (true /* graceful */);
-    if (stat == NFA_STATUS_OK)
+
     {
-        ALOGV("%s: wait for completion", __func__);
-        SyncEventGuard guard (sNfaDisableEvent);
-        sNfaDisableEvent.wait (); //wait for NFA command to finish
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("NFC NXP SelfTest wait for Notificaiton");
+      nfaNxpSelfTestNtfTimer.set(1000, nfaNxpSelfTestNtfTimerCb);
+      SyncEventGuard guard(sNfaNxpNtfEvent);
+      sNfaNxpNtfEvent.wait();  // wait for NXP Self NTF to come
     }
-    else
-    {
-        ALOGE("%s: fail disable; error=0x%X", __func__, stat);
+
+    status = GetCbStatus();
+    if (NFA_STATUS_OK != status) {
+      status = NFA_STATUS_FAILED;
+    }
+
+  TheEnd:
+    if (NFA_STATUS_OK == regcb_stat) {
+      regcb_stat = NFA_RegVSCback(
+          false, nfaNxpSelfTestNtfCallback);  // DeRegister CallBack for NXP NTF
+    }
+    nfaNxpSelfTestNtfTimer.kill();
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: exit; status =0x%X", __func__, status);
+    return status;
+  }
+
+  /*******************************************************************************
+   **
+   ** Function:       nfcManager_doPartialDeInitialize
+   **
+   ** Description:    DeInitializes the NFC partially if it is partially
+   *initialized.
+   **
+   ** Returns:        true/false .
+   **
+   *******************************************************************************/
+  static bool nfcManager_doPartialDeInitialize() {
+    tNFA_STATUS stat = NFA_STATUS_OK;
+    if (!gsNfaPartialEnabled) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: cannot deinitialize NFC , not partially initilaized", __func__);
+      return true;
+    }
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s:enter", __func__);
+    stat = NFA_Disable(true /* graceful */);
+    if (stat == NFA_STATUS_OK) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: wait for completion", __func__);
+      SyncEventGuard guard(sNfaDisableEvent);
+      sNfaDisableEvent.wait();  // wait for NFA command to finish
+    } else {
+      LOG(ERROR) << StringPrintf("%s: fail disable; error=0x%X", __func__,
+                                 stat);
     }
     NfcAdaptation& theInstance = NfcAdaptation::GetInstance();
     theInstance.Finalize();
     NFA_SetBootMode(NFA_NORMAL_BOOT_MODE);
     gsNfaPartialEnabled = false;
     return true;
-}
-
-/**********************************************************************************
- **
- ** Function:        nfcManager_getFwVersion
- **
- ** Description:     To get the FW Version
- **
- ** Returns:         int fw version as below four byte format
- **                  [0x00  0xROM_CODE_V  0xFW_MAJOR_NO  0xFW_MINOR_NO]
- **
- **********************************************************************************/
-static jint nfcManager_getFwVersion(JNIEnv* e, jobject o)
-{
+  }
+
+  /**********************************************************************************
+   **
+   ** Function:        nfcManager_getFwVersion
+   **
+   ** Description:     To get the FW Version
+   **
+   ** Returns:         int fw version as below four byte format
+   **                  [0x00  0xROM_CODE_V  0xFW_MAJOR_NO  0xFW_MINOR_NO]
+   **
+   **********************************************************************************/
+  static jint nfcManager_getFwVersion(JNIEnv * e, jobject o) {
     (void)e;
     (void)o;
-    ALOGV("%s: enter", __func__);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
     tNFA_STATUS status = NFA_STATUS_FAILED;
-//    bool stat = false;                        /*commented to eliminate unused variable warning*/
+    //    bool stat = false;                        /*commented to eliminate
+    //    unused variable warning*/
     jint version = 0, temp = 0;
     tNFC_FW_VERSION nfc_native_fw_version;
 
     if (!sIsNfaEnabled) {
-        ALOGV("NFC does not enabled!!");
-        return status;
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("NFC does not enabled!!");
+      return status;
     }
     memset(&nfc_native_fw_version, 0, sizeof(nfc_native_fw_version));
 
     nfc_native_fw_version = nfc_ncif_getFWVersion();
-    ALOGV("FW Version: %x.%x.%x", nfc_native_fw_version.rom_code_version,
-               nfc_native_fw_version.major_version,nfc_native_fw_version.minor_version);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "FW Version: %x.%x.%x", nfc_native_fw_version.rom_code_version,
+        nfc_native_fw_version.major_version,
+        nfc_native_fw_version.minor_version);
 
     temp = nfc_native_fw_version.rom_code_version;
     version = temp << 16;
@@ -8221,384 +8325,939 @@ static jint nfcManager_getFwVersion(JNIEnv* e, jobject o)
     version |= temp << 8;
     version |= nfc_native_fw_version.minor_version;
 
-    ALOGV("%s: exit; version =0x%X", __func__,version);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: exit; version =0x%X", __func__, version);
     return version;
-}
+  }
 
-static void nfcManager_doSetEEPROM(JNIEnv* e, jobject o, jbyteArray val)
-{
+  static void nfcManager_doSetEEPROM(JNIEnv * e, jobject o, jbyteArray val) {
     (void)e;
     (void)o;
     (void)val;
-    ALOGV("%s: enter", __func__);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
     tNFA_STATUS status = NFA_STATUS_FAILED;
-//    bool stat = false;                        /*commented to eliminate unused variable warning*/
-//    uint8_t param;                              /*commented to eliminate unused variable warning*/
+    //    bool stat = false;                        /*commented to eliminate
+    //    unused variable warning*/
+    //    uint8_t param;                              /*commented to eliminate
+    //    unused variable warning*/
 
     if (!sIsNfaEnabled) {
-        ALOGV("NFC does not enabled!!");
-        return;
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("NFC does not enabled!!");
+      return;
     }
 
-    ALOGV("%s: exit; status =0x%X", __func__,status);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: exit; status =0x%X", __func__, status);
 
     return;
-}
-
-/*******************************************************************************
- **
- ** Function:        getUICC_RF_Param_SetSWPBitRate()
- **
- ** Description:     Get All UICC Parameters and set SWP bit rate
- **
- ** Returns:         success/failure
- **
- *******************************************************************************/
-tNFA_STATUS getUICC_RF_Param_SetSWPBitRate()
-{
+  }
+
+  /*******************************************************************************
+   **
+   ** Function:        getUICC_RF_Param_SetSWPBitRate()
+   **
+   ** Description:     Get All UICC Parameters and set SWP bit rate
+   **
+   ** Returns:         success/failure
+   **
+   *******************************************************************************/
+  tNFA_STATUS getUICC_RF_Param_SetSWPBitRate() {
     tNFA_STATUS status = NFA_STATUS_FAILED;
     tNFA_PMID rf_params_NFCEE_UICC[] = {0xA0, 0xEF};
     uint8_t sakValue = 0x00;
     bool isMifareSupported;
 
-    ALOGV("%s: enter", __func__);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
 
-    SyncEventGuard guard (android::sNfaGetConfigEvent);
+    SyncEventGuard guard(android::sNfaGetConfigEvent);
     status = NFA_GetConfig(0x01, rf_params_NFCEE_UICC);
-    if (status != NFA_STATUS_OK)
-    {
-        ALOGE("%s: NFA_GetConfig failed", __func__);
-        return status;
+    if (status != NFA_STATUS_OK) {
+      LOG(ERROR) << StringPrintf("%s: NFA_GetConfig failed", __func__);
+      return status;
     }
     android::sNfaGetConfigEvent.wait();
     sakValue = sConfig[SAK_VALUE_AT];
-    ALOGV("SAK Value =0x%X",sakValue);
-    if((sakValue & 0x08) == 0x00)
-    {
-        isMifareSupported = false;
-    }
-    else
-    {
-        isMifareSupported = true;
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("SAK Value =0x%X", sakValue);
+    if ((sakValue & 0x08) == 0x00) {
+      isMifareSupported = false;
+    } else {
+      isMifareSupported = true;
     }
     status = SetUICC_SWPBitRate(isMifareSupported);
 
     return status;
-}
-
-/*******************************************************************************
-**
-** Function:        nfcManagerEnableAGCDebug
-**
-** Description:     Enable/Disable Dynamic RSSI feature.
-**
-** Returns:         None
-**
-*******************************************************************************/
-static void nfcManagerEnableAGCDebug(uint8_t connEvent)
-{
-    if(nfcFL.chipType == pn547C2) {
-        ALOGV("%s ,chipType : pn547C2. Not allowed. Returning", __func__);
-        return;
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        nfcManagerEnableAGCDebug
+  **
+  ** Description:     Enable/Disable Dynamic RSSI feature.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  static void nfcManagerEnableAGCDebug(uint8_t connEvent) {
+    if (nfcFL.chipType == pn547C2) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s ,chipType : pn547C2. Not allowed. Returning", __func__);
+      return;
     }
     unsigned long enableAGCDebug = 0;
     int retvalue = 0xFF;
-    GetNxpNumValue (NAME_NXP_AGC_DEBUG_ENABLE, (void*)&enableAGCDebug, sizeof(enableAGCDebug));
-    menableAGC_debug_t.enableAGC = enableAGCDebug;
-    ALOGV("%s ,%lu:", __func__, enableAGCDebug);
-    if(sIsNfaEnabled != true || sIsDisabling == true)
-        return;
-    if(!menableAGC_debug_t.enableAGC)
-    {
-        ALOGV("%s AGCDebug not enabled", __func__);
-        return;
-    }
-    if(connEvent == NFA_TRANS_DM_RF_FIELD_EVT &&
-       menableAGC_debug_t.AGCdebugstarted == false)
-    {
-        pthread_t agcThread;
-        pthread_attr_t attr;
-        pthread_attr_init(&attr);
-        pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-        retvalue = pthread_create(&agcThread, &attr, enableAGCThread, NULL);
-        pthread_attr_destroy(&attr);
-        if(retvalue == 0)
-        {
-            menableAGC_debug_t.AGCdebugstarted = true;
-            set_AGC_process_state(true);
-        }
-    }
-}
 
-void *enableAGCThread(void* /* arg */)
-{
-    if(nfcFL.chipType == pn547C2) {
-        ALOGV("%s ,chipType : pn547C2. Not allowed. Returning", __func__);
-        return NULL;
+    if (NfcConfig::hasKey(NAME_NXP_AGC_DEBUG_ENABLE)) {
+      enableAGCDebug = NfcConfig::getUnsigned(NAME_NXP_AGC_DEBUG_ENABLE);
+    }
+    menableAGC_debug_t.enableAGC = enableAGCDebug;
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s ,%lu:", __func__, enableAGCDebug);
+    if (sIsNfaEnabled != true || sIsDisabling == true) return;
+    if (!menableAGC_debug_t.enableAGC) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s AGCDebug not enabled", __func__);
+      return;
+    }
+    if (connEvent == NFA_TRANS_DM_RF_FIELD_EVT &&
+        menableAGC_debug_t.AGCdebugstarted == false) {
+      pthread_t agcThread;
+      pthread_attr_t attr;
+      pthread_attr_init(&attr);
+      pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+      retvalue = pthread_create(&agcThread, &attr, enableAGCThread, NULL);
+      pthread_attr_destroy(&attr);
+      if (retvalue == 0) {
+        menableAGC_debug_t.AGCdebugstarted = true;
+        set_AGC_process_state(true);
+      }
+    }
+  }
+
+  void* enableAGCThread(void* /* arg */) {
+    if (nfcFL.chipType == pn547C2) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s ,chipType : pn547C2. Not allowed. Returning", __func__);
+      return NULL;
     }
     tNFA_STATUS status = NFA_STATUS_FAILED;
-    while( menableAGC_debug_t.AGCdebugstarted == true )
-    {
-        if(get_AGC_process_state() == false)
-        {
-            sleep(10000);
-            continue;
-        }
-
-        if(sIsNfaEnabled != true || sIsDisabling == true)
-        {
-            menableAGC_debug_t.AGCdebugstarted = false;
-            set_AGC_process_state(false);
-            break;
-        }
+    while (menableAGC_debug_t.AGCdebugstarted == true) {
+      if (get_AGC_process_state() == false) {
+        sleep(10000);
+        continue;
+      }
+
+      if (sIsNfaEnabled != true || sIsDisabling == true) {
+        menableAGC_debug_t.AGCdebugstarted = false;
+        set_AGC_process_state(false);
+        break;
+      }
 
-        status = SendAGCDebugCommand();
-        if(status == NFA_STATUS_OK)
-        {
-            ALOGV("%s:  enable success exit", __func__);
-        }
-        usleep(500000);
+      status = SendAGCDebugCommand();
+      if (status == NFA_STATUS_OK) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s:  enable success exit", __func__);
+      }
+      usleep(500000);
     }
-    ALOGV("%s: exit", __func__);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
     pthread_exit(NULL);
     return NULL;
-}
-/*******************************************************************************
- **
- ** Function:       set_AGC_process_state
- **
- ** Description:    sets the AGC process to stop
- **
- ** Returns:        None .
- **
- *******************************************************************************/
-void set_AGC_process_state(bool state)
-{
-    if(nfcFL.chipType == pn547C2) {
-        ALOGV("%s ,chipType : pn547C2. Not allowed. Returning", __func__);
-        return;
+  }
+  /*******************************************************************************
+   **
+   ** Function:       set_AGC_process_state
+   **
+   ** Description:    sets the AGC process to stop
+   **
+   ** Returns:        None .
+   **
+   *******************************************************************************/
+  void set_AGC_process_state(bool state) {
+    if (nfcFL.chipType == pn547C2) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s ,chipType : pn547C2. Not allowed. Returning", __func__);
+      return;
     }
     menableAGC_debug_t.AGCdebugrunning = state;
-}
-
-/*******************************************************************************
- **
- ** Function:       get_AGC_process_state
- **
- ** Description:    returns the AGC process state.
- **
- ** Returns:        true/false .
- **
- *******************************************************************************/
-bool get_AGC_process_state()
-{
-    if(nfcFL.chipType == pn547C2) {
-        ALOGV("%s ,chipType : pn547C2. Not allowed. Returning", __func__);
-        return false;
+  }
+
+  /*******************************************************************************
+   **
+   ** Function:       get_AGC_process_state
+   **
+   ** Description:    returns the AGC process state.
+   **
+   ** Returns:        true/false .
+   **
+   *******************************************************************************/
+  bool get_AGC_process_state() {
+    if (nfcFL.chipType == pn547C2) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s ,chipType : pn547C2. Not allowed. Returning", __func__);
+      return false;
     }
     return menableAGC_debug_t.AGCdebugrunning;
-}
-
-/*******************************************************************************
- **
- ** Function:        getrfDiscoveryDuration()
- **
- ** Description:     gets the current rf discovery duration.
- **
- ** Returns:         uint16_t
- **
- *******************************************************************************/
-uint16_t getrfDiscoveryDuration()
-{
-    return discDuration;
-}
-
-#if(NXP_NFCC_HCE_F == TRUE)
-/*******************************************************************************
- **
- ** Function:       nfcManager_getTransanctionRequest
- **
- ** Description:    returns the payment check for HCE-F
- **
- ** Returns:        true/false .
- **
- *******************************************************************************/
-bool nfcManager_getTransanctionRequest(int t3thandle, bool registerRequest)
-{
-    bool    stat = false;
+  }
+
+  /*******************************************************************************
+   **
+   ** Function:        getrfDiscoveryDuration()
+   **
+   ** Description:     gets the current rf discovery duration.
+   **
+   ** Returns:         uint16_t
+   **
+   *******************************************************************************/
+  uint16_t getrfDiscoveryDuration() { return discDuration; }
+
+#if (NXP_NFCC_HCE_F == TRUE)
+  /*******************************************************************************
+   **
+   ** Function:       nfcManager_getTransanctionRequest
+   **
+   ** Description:    returns the payment check for HCE-F
+   **
+   ** Returns:        true/false .
+   **
+   *******************************************************************************/
+  bool nfcManager_getTransanctionRequest(int t3thandle, bool registerRequest) {
+    bool stat = false;
 
-    if(!pTransactionController->transactionAttempt(TRANSACTION_REQUESTOR(getTransanctionRequest)))
-    {
-        ALOGV("Transcation is in progress store the requst %d %d", t3thandle ,registerRequest);
-        set_last_request(T3T_CONFIGURE, NULL);
-        if(!registerRequest)
-            transaction_data.t3thandle = t3thandle;
-        stat = true;
-    }
-    else
-    {
-        pTransactionController->transactionEnd(TRANSACTION_REQUESTOR(getTransanctionRequest));
+    if (!pTransactionController->transactionAttempt(
+            TRANSACTION_REQUESTOR(getTransanctionRequest))) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("Transcation is in progress store the requst %d %d",
+                          t3thandle, registerRequest);
+      set_last_request(T3T_CONFIGURE, NULL);
+      if (!registerRequest) transaction_data.t3thandle = t3thandle;
+      stat = true;
+    } else {
+      pTransactionController->transactionEnd(
+          TRANSACTION_REQUESTOR(getTransanctionRequest));
     }
     return stat;
-}
+  }
 #endif
 
-/*******************************************************************************
- **
- ** Function:        nfcManager_isTransanctionOnGoing(bool isInstallRequest)
- **
- ** Description:     Base on the input parameter.It update the parameter for
- **                  install/uninstall request.
- **
- ** Returns:         success/failure
- **
- *******************************************************************************/
-bool nfcManager_isTransanctionOnGoing(bool isInstallRequest)
-{
-    if(!pTransactionController->transactionAttempt(TRANSACTION_REQUESTOR(isTransanctionOnGoing)))
-    {
-        ALOGV(" Transcation is in progress store the requst");
-        set_last_request(RE_ROUTING, NULL);
-        if(!isInstallRequest)
-            transaction_data.isInstallRequest = isInstallRequest;
-        return true;
-    }
-    else
-    {
-        pTransactionController->transactionEnd(TRANSACTION_REQUESTOR(isTransanctionOnGoing));
+  /*******************************************************************************
+   **
+   ** Function:        nfcManager_isTransanctionOnGoing(bool isInstallRequest)
+   **
+   ** Description:     Base on the input parameter.It update the parameter for
+   **                  install/uninstall request.
+   **
+   ** Returns:         success/failure
+   **
+   *******************************************************************************/
+  bool nfcManager_isTransanctionOnGoing(bool isInstallRequest) {
+    if (!pTransactionController->transactionAttempt(
+            TRANSACTION_REQUESTOR(isTransanctionOnGoing))) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf(" Transcation is in progress store the requst");
+      set_last_request(RE_ROUTING, NULL);
+      if (!isInstallRequest)
+        transaction_data.isInstallRequest = isInstallRequest;
+      return true;
+    } else {
+      pTransactionController->transactionEnd(
+          TRANSACTION_REQUESTOR(isTransanctionOnGoing));
     }
     return false;
-}
-
-/*******************************************************************************
- **
- ** Function:        nfcManager_doCheckJCOPOsDownLoad()
- **
- ** Description:     This api checks whether JCOP OS download is ongoing.
- **
- ** Returns:         true/false
- **
-*******************************************************************************/
-static bool nfcManager_doCheckJCOPOsDownLoad()
-{
-    if(!nfcFL.nfcNxpEse && !nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION) {
-        ALOGV("%s : nfcNxpEse or ESE_JCOP_DWNLD_PROTECTION "
-                "not available. Returning",__func__);
-        return false;
-    }
-    jint ret_val = -1;
-    bool checkJcopDwnld = false;
-    p61_access_state_t p61_current_state = P61_STATE_INVALID;
-
-    ret_val = NFC_GetP61Status ((void *)&p61_current_state);
-    if (ret_val < 0)
-    {
-        ALOGV("NFC_GetP61Status failed");
-        return false;
-    }
-    if(p61_current_state & P61_STATE_JCP_DWNLD)
-        checkJcopDwnld = true;
-
-    return checkJcopDwnld;
-}
-/*******************************************************************************
- **
- ** Function:        nfcManager_sendEmptyDataMsg()
- **
- ** Description:     Sends Empty Data packet
- **
- ** Returns:         True/False
- **
-*******************************************************************************/
-bool nfcManager_sendEmptyDataMsg()
-{
-    if(!nfcFL.nfccFL._NXP_NFCC_EMPTY_DATA_PACKET) {
-        ALOGV("%s : NXP_NFCC_EMPTY_DATA_PACKET not available."
-                "Returning",__func__);
-        return false;
+  }
+
+  /*******************************************************************************
+   **
+   ** Function:        nfcManager_sendEmptyDataMsg()
+   **
+   ** Description:     Sends Empty Data packet
+   **
+   ** Returns:         True/False
+   **
+   *******************************************************************************/
+  bool nfcManager_sendEmptyDataMsg() {
+    if (!nfcFL.nfccFL._NXP_NFCC_EMPTY_DATA_PACKET) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s : NXP_NFCC_EMPTY_DATA_PACKET not available."
+          "Returning",
+          __func__);
+      return false;
     }
     tNFA_STATUS status = NFA_STATUS_FAILED;
     size_t bufLen = 0;
     uint8_t* buf = NULL;
-    ALOGV("nfcManager_sendEmptyRawFrame");
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("nfcManager_sendEmptyRawFrame");
 
-    status = NFA_SendRawFrame (buf, bufLen, 0);
+    status = NFA_SendRawFrame(buf, bufLen, 0);
 
     return (status == NFA_STATUS_OK);
-}
-/*******************************************************************************
- **
- ** Function:        nfcManager_transactionDetail()
- **
- ** Description:     Provides transaction detail data reference
- **
- ** Returns:         Pointer to transaction data
- **
-*******************************************************************************/
-Transcation_Check_t* nfcManager_transactionDetail(void)
-{
+  }
+  /*******************************************************************************
+   **
+   ** Function:        nfcManager_transactionDetail()
+   **
+   ** Description:     Provides transaction detail data reference
+   **
+   ** Returns:         Pointer to transaction data
+   **
+   *******************************************************************************/
+  Transcation_Check_t* nfcManager_transactionDetail(void) {
     return &android::transaction_data;
-}
-/*******************************************************************************
- **
- ** Function:        nfcManager_getFeatureList()
- **
- ** Description:     Get the Chipe type & Configure Chip type macros
- **
- ** Returns:         None
- **
-*******************************************************************************/
-void nfcManager_getFeatureList() {
-    tNFC_chipType chipType;// = pn553;
+  }
+  /*******************************************************************************
+   **
+   ** Function:        nfcManager_getFeatureList()
+   **
+   ** Description:     Get the Chipe type & Configure Chip type macros
+   **
+   ** Returns:         None
+   **
+   *******************************************************************************/
+  void nfcManager_getFeatureList() {
+    tNFC_chipType chipType;  // = pn553;
     chipType = NFC_GetChipType();
-    ALOGV("%s : chipType",__func__);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s : chipType", __func__);
     CONFIGURE_FEATURELIST(chipType);
-}
-
-/*******************************************************************************
- **
- ** Function:        register_signal_handler()
- **
- ** Description:     Register Signal handlers
- **
- ** Returns:         None .
- **
-*******************************************************************************/
-void register_signal_handler() {
+  }
+  /*******************************************************************************
+   **
+   ** Function:        register_signal_handler()
+   **
+   ** Description:     Register Signal handlers
+   **
+   ** Returns:         None .
+   **
+   *******************************************************************************/
+  void register_signal_handler() {
     struct sigaction sig;
 
     memset(&sig, 0, sizeof(struct sigaction));
     sig.sa_sigaction = spi_prio_signal_handler;
     sig.sa_flags = SA_SIGINFO;
-    if(sigaction(SIG_NFC, &sig, NULL) < 0) {
-        ALOGE("Failed to register spi prio session signal handler");
-    }
-    if ((signal(SIGABRT, sig_handler) == SIG_ERR) && (signal(SIGSEGV, sig_handler) == SIG_ERR)) {
-        ALOGE("Failed to register signal handler");
-     }
-}
+    if (sigaction(SIG_NFC, &sig, NULL) < 0) {
+      LOG(ERROR) << StringPrintf(
+          "Failed to register spi prio session signal handler");
+    }
+    if ((signal(SIGABRT, sig_handler) == SIG_ERR) &&
+        (signal(SIGSEGV, sig_handler) == SIG_ERR)) {
+      LOG(ERROR) << StringPrintf("Failed to register signal handler");
+    }
+  }
+
+  extern void NxpPropCmd_OnResponseCallback(uint8_t event, uint16_t param_len,
+                                            uint8_t * p_param);
+  extern tNFA_STATUS NxpPropCmd_send(
+      uint8_t * pData4Tx, uint8_t dataLen, uint8_t * rsp_len, uint8_t * rsp_buf,
+      uint32_t rspTimeout, tHAL_NFC_ENTRY * halMgr);
+  /*******************************************************************************
+   **
+   ** Class:       Command
+   **
+   ** Description: This class serves as base class for all propreitary
+   **              commands for special FW mode of operation.
+   **              It also holds reference to the HAL entry point functions.
+   **              This class provides template for methods which can operate on
+   **              command frames.It has default implementation for send() API
+   **              which can be shared by all subclasses.
+   **              This class shall not be instantiated.
+   **              It should be treated as an abstracted class.
+  *******************************************************************************/
+  class Command {
+  public:
+    /*Response wait time*/
+    uint32_t rspTimeout;
+    /*Retrial count limit to handle failure rsp*/
+    int32_t retryCount;
+    /*Name of the command*/
+    char *name;
+    /*Reference to NFC adapter instance*/
+    NfcAdaptation &nfcAdapter;
+    /*Reference to HAL manager*/
+    tHAL_NFC_ENTRY *halMgr;
+
+    /*Constructor*/
+    Command() : nfcAdapter(NfcAdaptation::GetInstance()) {
+      /*Retreive reference to HAL function manager*/
+      halMgr = nfcAdapter.GetHalEntryFuncs();
+    }
+    /*Overidable method list*/
+    virtual tNFA_STATUS preProcessor();
+    virtual tNFA_STATUS send(uint8_t *rsp_len, uint8_t *rsp_buf) {
+      return NFA_STATUS_OK;
+    }
+    virtual tNFA_STATUS send(uint8_t *pData4Tx, uint8_t dataLen, uint8_t *rsp_len,
+                             uint8_t *rsp_buf) {
+      return NxpPropCmd_send(pData4Tx, dataLen, rsp_len, rsp_buf, rspTimeout,
+                             halMgr);
+    }
+    virtual tNFA_STATUS postProcessor(uint8_t rsp_len, uint8_t *rsp_buf) {
+      return NFA_STATUS_OK;
+    }
+    virtual ~Command() {}
+  };
+  /*******************************************************************************
+   **
+   ** Class:        cmdEnablePassThru
+   **
+   ** Description: This child class provides command frame. It also provides the
+   **              API for validity check(preprocessor), sending command and
+   **              post processing the response.
+   **
+  *******************************************************************************/
+  class cmdEnablePassThru : public Command {
+  private:
+    uint8_t cmd_buf[5];
+
+  public:
+    /*Constructor*/
+    cmdEnablePassThru(uint8_t modulationTyp, uint32_t timeoutVal,
+                      uint32_t retryCnt) {
+      /*Set the command specific parameters*/
+      name = (char *)"RDR_PASS_THRU_MODE_ENABLE";
+      retryCount = retryCnt;
+      rspTimeout = timeoutVal;
+
+      /*Create the command frame*/
+      cmd_buf[0] = 0x2F;
+      cmd_buf[1] = 0x1C;
+      cmd_buf[2] = 0x02;
+      cmd_buf[3] = modulationTyp;
+      cmd_buf[4] = 0x00;
+    }
+    tNFA_STATUS send(uint8_t *rsp_len, uint8_t *rsp_buf) {
+      return Command::send(cmd_buf, sizeof(cmd_buf), rsp_len, rsp_buf);
+    }
+    tNFA_STATUS preProcessor() {
+      tNFA_STATUS status = NFA_STATUS_OK;
+      SecureElement &se = SecureElement::getInstance();
+
+      /*Reject request if secure element is listening*/
+      if (se.isActivatedInListenMode()) {
+        LOG(ERROR) << StringPrintf("%s: Denying access due to SE listen mode active", __func__);
+        status = NFA_STATUS_REJECTED;
+      }
+      /*Reject request if wired mode is ongoing*/
+      if (se.mIsWiredModeOpen == true) {
+        LOG(ERROR) << StringPrintf("%s: Denying access due to Wired session is ongoing", __func__);
+        status = NFA_STATUS_REJECTED;
+      }
+      if (android::sRfEnabled) {
+        /* Call the NFA_StopRfDiscovery to synchronize JNI, stack and FW*/
+        android::startRfDiscovery(false);
+        /*Stop RF discovery to reconfigure*/
+        /* [START]poll*/
+        {
+          uint8_t enable_discover[] = {0x21, 0x03, 0x03, 0x01, 0x00, 0x01};
+          uint8_t disable_discover[] = {0x21, 0x06, 0x01, 0x00};
+          status = android::NxpNfc_Write_Cmd_Common(sizeof(enable_discover),
+                                                    enable_discover);
+          if (status == NFA_STATUS_OK)
+            status = android::NxpNfc_Write_Cmd_Common(sizeof(disable_discover),
+                                                      disable_discover);
+        }
+        /*[END]poll*/
+      }
+      return status;
+    }
+  };
+  /*******************************************************************************
+   **
+   ** Class:       cmdDisablePassThru
+   **
+   ** Description: This child class provides command frame. It also provides the
+   **              API for validity check(preprocessor), sending command and
+   **              post processing the response.
+   **
+  *******************************************************************************/
+  class cmdDisablePassThru : public Command {
+  private:
+    uint8_t cmd_buf[3];
+
+  public:
+    /*Constructor*/
+    cmdDisablePassThru(uint32_t timeoutVal, uint32_t retryCnt) {
+      /*Set the command specific parameters*/
+      name = (char *)"RDR_PASS_THRU_MODE_DISABLE";
+      retryCount = retryCnt;
+      rspTimeout = timeoutVal;
+
+      /*Create the command frame*/
+      cmd_buf[0] = 0x2F;
+      cmd_buf[1] = 0x1A;
+      cmd_buf[2] = 0x00;
+    }
+
+    tNFA_STATUS send(uint8_t *rsp_len, uint8_t *rsp_buf) {
+      return Command::send(cmd_buf, sizeof(cmd_buf), rsp_len, rsp_buf);
+    }
+
+    tNFA_STATUS preProcessor() {
+      /*Reject request if NFA layer is not enabled*/
+      if (!android::sIsNfaEnabled
+          ) {
+        LOG(ERROR) << StringPrintf("%s: Denying request due to disabled NFA layer", __func__);
+        return NFA_STATUS_REJECTED;
+      }
+      /*Stop RF discovery in case RF is enabled*/
+      if (android::sRfEnabled && android::sIsNfaEnabled) {
+        // Stop RF discovery to reconfigure
+        android::startRfDiscovery(false);
+      }
+      return NFA_STATUS_OK;
+    }
+
+    tNFA_STATUS postProcessor(uint8_t rsp_len, uint8_t *rsp_buf) {
+
+      /*Start RF discovery in case RF is enabled*/
+      if (!android::sRfEnabled && android::sIsNfaEnabled)
+        android::startRfDiscovery(true);
+      return NFA_STATUS_OK;
+    }
+  };
+  /*******************************************************************************
+   **
+   ** Class:        cmdTransceive
+   **
+   ** Description:  Sends the iCode proprietary transcieve app command.
+   **               This child class provides command frame. It also provides the
+   **               API for validity check(preprocessor), sending command and
+   **               post processing the response.
+   **
+   **
+  *******************************************************************************/
+  class cmdTransceive : public Command {
+  private:
+    uint8_t cmd_buf[258];
+
+  public:
+    /*Constructor*/
+    cmdTransceive(uint32_t timeoutVal, uint32_t retryCnt) {
+      /*Set the command specific parameters*/
+      name = (char *)"RDR_PASS_THRU_MODE_XCV";
+      retryCount = retryCnt;
+      rspTimeout = timeoutVal;
+
+      /*Create the command frame*/
+      cmd_buf[0] = 0x2F;
+      cmd_buf[1] = 0x1B;
+    }
+
+    tNFA_STATUS send(uint8_t *pData4Tx, uint8_t dataLen, uint8_t *rsp_len,
+                     uint8_t *rsp_buf) {
+      cmd_buf[2] = dataLen;
+      memcpy(&cmd_buf[3], pData4Tx, dataLen);
+      return Command::send(cmd_buf, (dataLen + CMD_HDR_SIZE_XCV), rsp_len,
+                           rsp_buf);
+    }
+
+    tNFA_STATUS preProcessor() {
+      tNFA_STATUS status = NFA_STATUS_OK;
+      SecureElement &se = SecureElement::getInstance();
+
+      if (!android::sIsNfaEnabled
+          ) {
+        LOG(ERROR) << StringPrintf("%s: Denying access due to SE listen mode active", __func__);
+        return NFA_STATUS_REJECTED;
+      }
+      /*Reject request if wired mode is ongoing*/
+      if (se.mIsWiredModeOpen == true) {
+        LOG(ERROR) << StringPrintf("%s: Denying access due to Wired session is ongoing", __func__);
+        status = NFA_STATUS_REJECTED;
+      }
+      return status;
+    }
+  };
+  /*******************************************************************************
+   **
+   ** Class:        rdrPassThru
+   **
+   ** Description: This is a factory class which creates command instances
+   **              It creates transceive commands only when it is in busy mode.
+   **
+   ** Returns:         byte[]
+   **
+  *******************************************************************************/
+  class rdrPassThru {
+  private:
+    uint32_t state;
+    typedef enum { IDLE, BUSY } STATE_e;
+
+  public:
+    rdrPassThru() { state = IDLE; }
+
+    Command *createCommand(uint32_t rqst, uint32_t modulationType) {
+
+      switch (rqst) {
+      case RDR_PASS_THRU_MODE_ENABLE:
+        state = BUSY;
+        return new cmdEnablePassThru(modulationType, RDR_PASS_THRU_ENABLE_TIMEOUT, 3);
+      case RDR_PASS_THRU_MODE_DISABLE:
+        state = BUSY;
+        return new cmdDisablePassThru(RDR_PASS_THRU_DISABLE_TIMEOUT, 3);
+      case RDR_PASS_THRU_MODE_XCV:
+        state = BUSY;
+        return new cmdTransceive(RDR_PASS_THRU_DISABLE_TIMEOUT, 0);
+      default:
+        return NULL;
+      }
+      return NULL;
+    }
+
+    tNFA_STATUS condOfUseSatisfied(uint32_t rqst, uint32_t modulationTyp) {
+
+      if (rqst > RDR_PASS_THRU_MODE_XCV ||
+          modulationTyp > RDR_PASS_THRU_MOD_TYPE_LIMIT) {
+        LOG(ERROR) << StringPrintf("%s: Denying access due to Incorrect parameters", __func__);
+        return NFA_STATUS_REJECTED;
+      }
+      if (rqst == RDR_PASS_THRU_MODE_XCV && state == IDLE) {
+        LOG(ERROR) << StringPrintf("%s: Denying access due to Incorrect parameters", __func__);
+        return NFA_STATUS_REJECTED;
+      }
+      return NFA_STATUS_OK;
+    }
+    void destroy(Command *pCmdInstance) { delete pCmdInstance; }
+    void destroy(uint32_t rqst, Command *pCmdInstance) {
+
+      if (rqst == RDR_PASS_THRU_MODE_DISABLE)
+        state = IDLE;
+      delete pCmdInstance;
+    }
+  };
+  rdrPassThru rdrPassThruMgr;
+  /*******************************************************************************
+   **
+   ** Function:        nfcManager_readerPassThruMode()
+   **
+   ** Description:     Sends  proprietary command to NFC controller to manage
+   **                  special FW mode
+   **
+   ** Returns:         byte[]
+   **
+  *******************************************************************************/
+  static jbyteArray nfcManager_readerPassThruMode(
+    JNIEnv * e, jobject o, jbyte rqst, jbyte modulationTyp) {
+    tNFA_STATUS ret_stat = NFA_STATUS_OK;
+    uint8_t rsp_buf[255];
+    uint8_t rsp_len = 0;
+    jbyteArray buf = NULL;
+    static const char fn[] = "nfcManager_readerPassThruMode";
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s:enter", fn);
+
+    /*1. Check if the criteria for sending the command is satisfied*/
+    if ((ret_stat = rdrPassThruMgr.condOfUseSatisfied(rqst, modulationTyp)) ==
+        NFA_STATUS_OK) {
+
+      /*1.1.  Retreive the requested command instance from reader pass through
+       * manager (command factory)*/
+      Command *pCommand = rdrPassThruMgr.createCommand(rqst, modulationTyp);
+
+      /*1.2. Check valid command instance and command specific criteria for use */
+      if (pCommand != NULL && pCommand->preProcessor() == NFA_STATUS_OK) {
+        do {
+          /*1.2.1. Send the command to NFC controller*/
+          ret_stat = pCommand->send(&rsp_len, rsp_buf);
 
-#endif
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s:Invoked", pCommand->name);
 
-static jbyteArray nfcManager_getAdditionalConfigOptions(JNIEnv* e, jobject /* o */) {
-    char configoptions[256] = {0};
-    long retlen = 0;
-    jbyteArray result = NULL;
-    GetNxpByteArrayValue (NAME_NXP_ADDITIONAL_CONFIG_OPTIONS, configoptions, sizeof(configoptions), &retlen);
-    if(retlen > 0)
+          /*1.2.2. Incase of failure retry till the retrial limit is met*/
+        } while (ret_stat != NFA_STATUS_OK && pCommand->retryCount-- > 0);
+
+        /*1.2.3. Invoke command post processor*/
+        if (ret_stat == NFA_STATUS_OK)
+          ret_stat = pCommand->postProcessor(rsp_len, rsp_buf);
+
+        /*1.2.4. Delete the command instance*/
+        rdrPassThruMgr.destroy(rqst, pCommand);
+      }
+    } else {
+      /*2. If the criteria for sending the command is not satisfied; frame error
+       * rsp*/
+      rsp_len = sizeof(tNFA_STATUS);
+      rsp_buf[0] = NFA_STATUS_FAILED;
+    }
+    /*3. Set JNI variables for sending response to application*/
+    buf = e->NewByteArray(rsp_len);
+    e->SetByteArrayRegion(buf, 0, rsp_len, (jbyte *)rsp_buf);
+    return buf;
+  }
+
+  /*******************************************************************************
+   **
+   ** Function:        nfcManager_transceiveAppData()
+   **
+   ** Description:     Sends the proprietary transcieve app command
+   **
+   ** Returns:         byte[]
+   **
+  *******************************************************************************/
+  static jbyteArray nfcManager_transceiveAppData(JNIEnv * e, jobject o,
+                                                 jbyteArray data) {
+    tNFA_STATUS ret_stat = NFA_STATUS_OK;
+    uint8_t rsp_buf[255];
+    uint8_t rsp_len = 0;
+    uint8_t *dataBuf = NULL;
+    uint16_t dataLen = 0;
+    jbyteArray buf = NULL;
+    static const char fn[] = "nfcManager_transceiveAppData";
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s:enter", fn);
+
+    /*1. Check if the criteria for sending the command is satisfied*/
+    if ((ret_stat = rdrPassThruMgr.condOfUseSatisfied(RDR_PASS_THRU_MODE_XCV,
+                                                      0)) == NFA_STATUS_OK) {
+
+      /*1.1.  Retreive the requested command instance from reader pass through
+       * manager (command factory)*/
+      Command *pCommand = rdrPassThruMgr.createCommand(RDR_PASS_THRU_MODE_XCV, 0);
+
+      /*1.2. Check valid command instance and command specific criteria for use */
+      if (pCommand != NULL && pCommand->preProcessor() == NFA_STATUS_OK) {
+
+        /*1.2.1.  Determine application data length */
+        ScopedByteArrayRW bytes(e, data);
+        dataBuf = const_cast<uint8_t *>(reinterpret_cast<uint8_t *>(&bytes[0]));
+        dataLen = bytes.size();
+
+        do {
+          /*1.2.2. Send the command to NFC controller*/
+          ret_stat = pCommand->send(dataBuf, dataLen, &rsp_len, rsp_buf);
+
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s:Invoked", pCommand->name);
+
+          /*1.2.3. Incase of failure retry till the retrial limit is met*/
+        } while (ret_stat != NFA_STATUS_OK && pCommand->retryCount-- > 0);
+
+        /*1.2.4. Invoke command post processor*/
+        if (ret_stat == NFA_STATUS_OK)
+          ret_stat = pCommand->postProcessor(rsp_len, rsp_buf);
+
+        /*1.2.5. Delete the command instance*/
+        rdrPassThruMgr.destroy(pCommand);
+      }
+    } else {
+      /*2. If the criteria for sending the command is not satisfied; frame error
+       * rsp*/
+      rsp_len = sizeof(tNFA_STATUS);
+      rsp_buf[0] = NFA_STATUS_FAILED;
+    }
+    /*3. Set JNI variables for sending response to application*/
+
+    buf = e->NewByteArray(rsp_len);
+    e->SetByteArrayRegion(buf, 0, rsp_len, (jbyte *)rsp_buf);
+
+    return buf;
+  }
+
+  /*******************************************************************************
+   **
+   ** Function:        isLowRamDevice()
+   **
+   ** Description:     Provides whether device is low ram enabled or not
+   **
+   ** Returns:         None .
+   **
+   *******************************************************************************/
+  bool isLowRamDevice() { return sIsLowRamDevice; }
+
+  /*
+   * This API mainly used for Self-Test
+   * */
+  /*******************************************************************************
+   **
+   ** Function:        configureListening
+   **
+   ** Description:     Configure listen technologies
+   **
+   ** Returns:         success/failure
+   **
+   *******************************************************************************/
+  tNFA_STATUS configureListening(uint8_t aListenMask) {
+    tNFA_STATUS stat = NFA_STATUS_FAILED;
+    SecureElement& se = SecureElement::getInstance();
     {
-        result = e->NewByteArray(retlen);
-        if(result != NULL)
-        {
-            e->SetByteArrayRegion(result, 0, retlen, (jbyte *) configoptions);
-        }
+      SyncEventGuard guard(se.mUiccListenEvent);
+      stat = NFA_CeConfigureUiccListenTech(se.mActiveEeHandle, aListenMask);
+      if (stat == NFA_STATUS_OK) {
+        se.mUiccListenEvent.wait();
+        if (!aListenMask) stat = NFA_DisableListening();
+      } else {
+        LOG(ERROR) << StringPrintf("fail to start UICC listen");
+      }
     }
-    else
-    {
-        result = e->NewByteArray(0);
+    return stat;
+  }
+
+  /*******************************************************************************
+   **
+   ** Function:        configurePolling
+   **
+   ** Description:     Configure polling technologies
+   **
+   ** Returns:         success/failure
+   **
+   *******************************************************************************/
+  tNFA_STATUS configurePolling(uint8_t aPollMask) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: enter poll mask=0x%02X", __func__, aPollMask);
+    tNFA_STATUS stat = NFA_STATUS_FAILED;
+
+    if (aPollMask > 0) {
+      SyncEventGuard guard(sNfaEnableDisablePollingEvent);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("enable polling");
+      stat = NFA_EnablePolling(aPollMask);
+      if (stat == NFA_STATUS_OK) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("wait for enable event");
+        sPollingEnabled = true;
+        sNfaEnableDisablePollingEvent.wait();  // Wait for NFA_POLL_ENABLED_EVT.
+      } else {
+        LOG(ERROR) << StringPrintf("NFA_EnablePolling fail, error=0x%X", stat);
+      }
+    } else {
+      SyncEventGuard guard(sNfaEnableDisablePollingEvent);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("disable polling");
+      stat = NFA_DisablePolling();
+      if (stat == NFA_STATUS_OK) {
+        sPollingEnabled = false;
+        sNfaEnableDisablePollingEvent
+            .wait();  // Wait for NFA_POLL_DISABLED_EVT.
+      } else {
+        LOG(ERROR) << StringPrintf("NFA_DisablePolling fail, error=0x%X", stat);
+      }
+    }
+    if (aPollMask > 0) startRfDiscovery(true);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+    return stat;
+  }
+
+  /*******************************************************************************
+   **
+   ** Function:        performRFTest
+   **
+   ** Description:     SelfTest, Analog RF ON/OFF commands
+   **
+   ** Returns:         success/failure
+   **
+   *******************************************************************************/
+  tNFA_STATUS performRFTest(bool on) {
+    tNFA_STATUS status = NFA_STATUS_FAILED;
+    uint8_t aNumOfCmds = 0;
+    uint8_t count = 0;
+    uint8_t NFCInitCmdSeq[5] = {NFC_CMD_TYPE_CORE_RESET, NFC_CMD_TYPE_CORE_INIT,
+                                NFC_CMD_TYPE_ACT_PROP_EXTN};
+    aNumOfCmds = sizeof(NFCInitCmdSeq);
+    if (on) {
+      NFCInitCmdSeq[3] = NFC_CMD_TYPE_NFCC_STANDBY_OFF;
+      NFCInitCmdSeq[4] = NFC_CMD_TYPE_RF_ON;
+    } else {
+      NFCInitCmdSeq[3] = NFC_CMD_TYPE_RF_OFF;
+      NFCInitCmdSeq[4] = NFC_CMD_TYPE_NFCC_STANDBY_ON;
     }
-    return result;
 
+    do {
+      status = Nxp_SelfTest(NFCInitCmdSeq[count], 0x00);
+    } while ((status == NFA_STATUS_OK) && (++count < aNumOfCmds));
+
+    return status;
+  }
+
+  /*******************************************************************************
+   **
+   ** Function:        performTransacAB
+   **
+   ** Description:     SelfTest SWP, PRBS
+   **
+   ** Returns:         success/failure
+   **
+   *******************************************************************************/
+  tNFA_STATUS performTransacAB(uint8_t aType) {
+    tNFA_STATUS status = NFA_STATUS_FAILED;
+    uint8_t val[][1] = {{0x03}, {0x63}};
+    uint8_t len[] = {0x01, 0x01};
+    uint8_t tech_mask = 0;
+    uint8_t count = 0, addCnt = 0;
+    tNFA_PMID addBuf[][2] = {{0xA0, 0x3F}, {0xA0, 0x44}};
+    uint8_t aNumOfCmds = 0;
+    uint8_t NFCInitCmdSeq[3] = {NFC_CMD_TYPE_CORE_RESET, NFC_CMD_TYPE_CORE_INIT,
+                                NFC_CMD_TYPE_ACT_PROP_EXTN};
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+
+    configureListening(0x00);  // Disable listen phase
+    configurePolling(
+        0x00);  // This is remove previous poll config as part of Nfc-ON
+    if (aType == NFC_CMD_TYPE_TRANSAC_A) {
+      tech_mask = NFA_TECHNOLOGY_MASK_A;
+    } else {
+      *val[1] = 0x43;
+      tech_mask = NFA_TECHNOLOGY_MASK_A | NFA_TECHNOLOGY_MASK_B;
+    }
+
+    aNumOfCmds = sizeof(NFCInitCmdSeq);
+    do {
+      status = Nxp_SelfTest(NFCInitCmdSeq[count], 0x00);
+    } while ((status == NFA_STATUS_OK) && (++count < aNumOfCmds));
+    count = 0;
+    if (status == NFA_STATUS_OK) {
+      addCnt = sizeof(addBuf) / sizeof(addBuf[0]);
+      while ((status == NFA_STATUS_OK) && (count < addCnt)) {
+        status = NxpNfcUpdateEeprom(addBuf[count], len[count], val[count]);
+        count++;
+      }
+    } else {
+      LOG(ERROR) << StringPrintf("failed in to reset and init NFCC");
+    }
+    if (status == NFA_STATUS_OK) {
+      uint8_t val68[] = {0x00};
+      SyncEventGuard guard(sNfaSetConfigEvent);
+      status = NFA_SetConfig(NXP_NFC_NCI_PACM_BIT_RATE, 1, val68);
+      if (status == NFA_STATUS_OK) {
+        if (sNfaSetConfigEvent.wait(2 * ONE_SECOND_MS)) {
+          status = Nxp_SelfTest(NFC_CMD_TYPE_DISC_MAP, 0x00);
+        } else {
+          LOG(ERROR) << StringPrintf("Wait timeout");
+          status = NFA_STATUS_FAILED;
+        }
+      } else {
+        LOG(ERROR) << StringPrintf("failed to send set config command");
+      }
+    }
+    if (status == NFA_STATUS_OK) {
+      if ((status = configurePolling(tech_mask)) == NFA_STATUS_OK) {
+        SyncEventGuard gaurd(mSelfTestTransacAB);
+        if (mSelfTestTransacAB.wait(30 * ONE_SECOND_MS)) {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("Received activated ntf");
+          status = Nxp_SelfTest(NFC_CMD_TYPE_DEACTIVATE, 0x00);
+        }
+      } else {
+        // Do nothing
+      }
+    } else {
+      // Do nothing, enter in to normal polling mode
+    }
+    startRfDiscovery(true);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: exit status = 0X%02X", __func__, status);
+    return status;
+  }
+
+  /*******************************************************************************
+   **
+   ** Function:        activatedNtf_Cb
+   **
+   ** Description:     Receive activation notification from
+   *nfaConnectionCallback
+   **
+   ** Returns:         None
+   **
+   *******************************************************************************/
+  void activatedNtf_Cb() {
+    SyncEventGuard gaurd(mSelfTestTransacAB);
+    mSelfTestTransacAB.notifyOne();
+  }
+#endif
 }
-}
+
 /* namespace android */
diff --git a/nci/jni/NativeNfcTag.cpp b/nci/jni/NativeNfcTag.cpp
index f7b5b56a..7314f27a 100644
--- a/nci/jni/NativeNfcTag.cpp
+++ b/nci/jni/NativeNfcTag.cpp
@@ -3,7 +3,7 @@
  *  Copyright (c) 2016, The Linux Foundation. All rights reserved.
  *  Not a Contribution.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *  The original Work has been changed by NXP Semiconductors.
  *
  *  Copyright (C) 2012 The Android Open Source Project
@@ -21,163 +21,163 @@
  *  limitations under the License.
  *
  ******************************************************************************/
-
-#include <semaphore.h>
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
 #include <errno.h>
-#include <time.h>
+#include <nativehelper/ScopedLocalRef.h>
+#include <nativehelper/ScopedPrimitiveArray.h>
+#include <semaphore.h>
 #include <signal.h>
-#include "_OverrideLog.h"
-#include "NfcJniUtil.h"
-#include "NfcTag.h"
-#include "config.h"
-#include "Mutex.h"
+#include <time.h>
+#include <string>
 #include "IntervalTimer.h"
 #include "JavaClassConstants.h"
+#include "Mutex.h"
+#include "NfcJniUtil.h"
+#include "NfcTag.h"
 #include "Pn544Interop.h"
-#include <nativehelper/ScopedLocalRef.h>
-#include <nativehelper/ScopedPrimitiveArray.h>
-#include <string>
-
-extern "C"
-{
-    #include "nfa_api.h"
-    #include "nfa_rw_api.h"
-    #include "nfc_brcm_defs.h"
-    #include "ndef_utils.h"
-    #include "rw_api.h"
-    #include "phNxpExtns.h"
-}
-namespace android
-{
-    extern nfc_jni_native_data* getNative(JNIEnv *e, jobject o);
-    extern bool nfcManager_isNfcActive();
-    extern uint16_t getrfDiscoveryDuration();
-}
-
-extern bool         gActivated;
-extern SyncEvent    gDeactivatedEvent;
+#include "TransactionController.h"
+#include "ndef_utils.h"
+#include "nfa_api.h"
+#include "nfa_rw_api.h"
+#include "nfc_brcm_defs.h"
+#include "phNxpExtns.h"
+#include "rw_api.h"
+using android::base::StringPrintf;
+
+namespace android {
+extern nfc_jni_native_data* getNative(JNIEnv* e, jobject o);
+extern bool nfcManager_isNfcActive();
+extern uint16_t getrfDiscoveryDuration();
+}  // namespace android
+
+extern bool gActivated;
+extern SyncEvent gDeactivatedEvent;
+extern bool nfc_debug_enabled;
 
 /*****************************************************************************
 **
 ** public variables and functions
 **
 *****************************************************************************/
-namespace android
-{
-    bool    gIsTagDeactivating = false;    // flag for nfa callback indicating we are deactivating for RF interface switch
-    bool    gIsSelectingRfInterface = false; // flag for nfa callback indicating we are selecting for RF interface switch
-#if(NXP_EXTNS == TRUE)
-    bool    gIsWaiting4Deact2SleepNtf = false;
-    bool    gGotDeact2IdleNtf = false;
+namespace android {
+bool gIsTagDeactivating = false;  // flag for nfa callback indicating we are
+                                  // deactivating for RF interface switch
+bool gIsSelectingRfInterface = false;  // flag for nfa callback indicating we
+                                       // are selecting for RF interface switch
+#if (NXP_EXTNS == TRUE)
+bool gIsWaiting4Deact2SleepNtf = false;
+bool gGotDeact2IdleNtf = false;
 #endif
-    bool    fNeedToSwitchBack = false;
-    void    acquireRfInterfaceMutexLock();
-    void    releaseRfInterfaceMutexLock();
-}
-
+bool fNeedToSwitchBack = false;
+void nativeNfcTag_acquireRfInterfaceMutexLock();
+void nativeNfcTag_releaseRfInterfaceMutexLock();
+}  // namespace android
 
 /*****************************************************************************
 **
 ** private variables and functions
 **
 *****************************************************************************/
-namespace android
-{
-
+namespace android {
 
 // Pre-defined tag type values. These must match the values in
 // framework Ndef.java for Google public NFC API.
-#define NDEF_UNKNOWN_TYPE          (-1)
-#define NDEF_TYPE1_TAG             1
-#define NDEF_TYPE2_TAG             2
-#define NDEF_TYPE3_TAG             3
-#define NDEF_TYPE4_TAG             4
-#define NDEF_MIFARE_CLASSIC_TAG    101
+#define NDEF_UNKNOWN_TYPE (-1)
+#define NDEF_TYPE1_TAG 1
+#define NDEF_TYPE2_TAG 2
+#define NDEF_TYPE3_TAG 3
+#define NDEF_TYPE4_TAG 4
+#define NDEF_MIFARE_CLASSIC_TAG 101
 
 /*Below #defines are made to make libnfc-nci as AOSP*/
 #ifndef NCI_INTERFACE_MIFARE
-#define NCI_INTERFACE_MIFARE       0x80
+#define NCI_INTERFACE_MIFARE 0x80
 #endif
-#undef  NCI_PROTOCOL_MIFARE
-#define NCI_PROTOCOL_MIFARE        0x80
-
+#undef NCI_PROTOCOL_MIFARE
+#define NCI_PROTOCOL_MIFARE 0x80
 
-#define STATUS_CODE_TARGET_LOST    146  // this error code comes from the service
+#define STATUS_CODE_TARGET_LOST 146  // this error code comes from the service
 
-static uint32_t     sCheckNdefCurrentSize = 0;
-static tNFA_STATUS  sCheckNdefStatus = 0; //whether tag already contains a NDEF message
-static bool         sCheckNdefCapable = false; //whether tag has NDEF capability
-static tNFA_HANDLE  sNdefTypeHandlerHandle = NFA_HANDLE_INVALID;
-tNFA_INTF_TYPE   sCurrentRfInterface = NFA_INTERFACE_ISO_DEP;
+static uint32_t sCheckNdefCurrentSize = 0;
+static tNFA_STATUS sCheckNdefStatus =
+    0;  // whether tag already contains a NDEF message
+static bool sCheckNdefCapable = false;  // whether tag has NDEF capability
+static tNFA_HANDLE sNdefTypeHandlerHandle = NFA_HANDLE_INVALID;
+tNFA_INTF_TYPE sCurrentRfInterface = NFA_INTERFACE_ISO_DEP;
 static std::basic_string<uint8_t> sRxDataBuffer;
-static tNFA_STATUS  sRxDataStatus = NFA_STATUS_OK;
-static bool         sWaitingForTransceive = false;
-static bool         sTransceiveRfTimeout = false;
-static Mutex        sRfInterfaceMutex;
-static uint32_t     sReadDataLen = 0;
-static tNFA_STATUS  sReadStatus;
-static uint8_t*     sReadData = NULL;
-static bool         sIsReadingNdefMessage = false;
-static SyncEvent    sReadEvent;
-static sem_t        sWriteSem;
-static sem_t        sFormatSem;
-static SyncEvent    sTransceiveEvent;
-static SyncEvent    sReconnectEvent;
-static sem_t        sCheckNdefSem;
-static SyncEvent    sPresenceCheckEvent;
-static sem_t        sMakeReadonlySem;
-static IntervalTimer sSwitchBackTimer; // timer used to tell us to switch back to ISO_DEP frame interface
-static IntervalTimer sPresenceCheckTimer; // timer used for presence cmd notification timeout.
-static IntervalTimer sReconnectNtfTimer ;
-static jboolean     sWriteOk = JNI_FALSE;
-static jboolean     sWriteWaitingForComplete = JNI_FALSE;
-static bool         sFormatOk = false;
-#if(NXP_EXTNS == TRUE && NFC_NXP_NON_STD_CARD == TRUE)
-static bool         sNeedToSwitchRf = false;
+static tNFA_STATUS sRxDataStatus = NFA_STATUS_OK;
+static bool sWaitingForTransceive = false;
+static bool sTransceiveRfTimeout = false;
+static Mutex sRfInterfaceMutex;
+static uint32_t sReadDataLen = 0;
+static tNFA_STATUS sReadStatus;
+static uint8_t* sReadData = NULL;
+static bool sIsReadingNdefMessage = false;
+static SyncEvent sReadEvent;
+static sem_t sWriteSem;
+static sem_t sFormatSem;
+static SyncEvent sTransceiveEvent;
+static SyncEvent sReconnectEvent;
+static sem_t sCheckNdefSem;
+static SyncEvent sPresenceCheckEvent;
+static sem_t sMakeReadonlySem;
+static IntervalTimer sSwitchBackTimer;  // timer used to tell us to switch back
+                                        // to ISO_DEP frame interface
+static IntervalTimer
+    sPresenceCheckTimer;  // timer used for presence cmd notification timeout.
+static IntervalTimer sReconnectNtfTimer;
+static jboolean sWriteOk = JNI_FALSE;
+static jboolean sWriteWaitingForComplete = JNI_FALSE;
+static bool sFormatOk = false;
+#if (NXP_EXTNS == TRUE && NFC_NXP_NON_STD_CARD == TRUE)
+static bool sNeedToSwitchRf = false;
 #endif
-static jboolean     sConnectOk = JNI_FALSE;
-static jboolean     sConnectWaitingForComplete = JNI_FALSE;
-static bool         sGotDeactivate = false;
-static uint32_t     sCheckNdefMaxSize = 0;
-static bool         sCheckNdefCardReadOnly = false;
-static jboolean     sCheckNdefWaitingForComplete = JNI_FALSE;
-static bool         sIsTagPresent = true;
-static tNFA_STATUS  sMakeReadonlyStatus = NFA_STATUS_FAILED;
-static jboolean     sMakeReadonlyWaitingForComplete = JNI_FALSE;
-static int          sCurrentConnectedTargetType = TARGET_TYPE_UNKNOWN;
-static int          sCurrentConnectedTargetProtocol = NFC_PROTOCOL_UNKNOWN;
-static int          sCurrentConnectedHandle;
-static SyncEvent    sNfaVSCResponseEvent;
-static SyncEvent    sNfaVSCNotificationEvent;
-static bool         sIsTagInField;
-static bool         sVSCRsp;
-static bool         sReconnectFlag = false;
-static int reSelect (tNFA_INTF_TYPE rfInterface, bool fSwitchIfNeeded);
+static jboolean sConnectOk = JNI_FALSE;
+static jboolean sConnectWaitingForComplete = JNI_FALSE;
+static bool sGotDeactivate = false;
+static uint32_t sCheckNdefMaxSize = 0;
+static bool sCheckNdefCardReadOnly = false;
+static jboolean sCheckNdefWaitingForComplete = JNI_FALSE;
+static bool sIsTagPresent = true;
+static tNFA_STATUS sMakeReadonlyStatus = NFA_STATUS_FAILED;
+static jboolean sMakeReadonlyWaitingForComplete = JNI_FALSE;
+static int sCurrentConnectedTargetType = TARGET_TYPE_UNKNOWN;
+static int sCurrentConnectedTargetProtocol = NFC_PROTOCOL_UNKNOWN;
+static int sCurrentConnectedHandle;
+static SyncEvent sNfaVSCResponseEvent;
+static SyncEvent sNfaVSCNotificationEvent;
+static bool sIsTagInField;
+static bool sVSCRsp;
+static bool sReconnectFlag = false;
+static int reSelect(tNFA_INTF_TYPE rfInterface, bool fSwitchIfNeeded);
 static bool switchRfInterface(tNFA_INTF_TYPE rfInterface);
-static bool setNdefDetectionTimeoutIfTagAbsent (JNIEnv *e, jobject o, tNFC_PROTOCOL protocol);
-static void setNdefDetectionTimeout ();
-static jboolean nativeNfcTag_doPresenceCheck (JNIEnv*, jobject);
-#if(NXP_EXTNS == TRUE)
+static bool setNdefDetectionTimeoutIfTagAbsent(JNIEnv* e, jobject o,
+                                               tNFC_PROTOCOL protocol);
+static void setNdefDetectionTimeout();
+static jboolean nativeNfcTag_doPresenceCheck(JNIEnv*, jobject);
+#if (NXP_EXTNS == TRUE)
 uint8_t key1[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
 uint8_t key2[6] = {0xD3, 0xF7, 0xD3, 0xF7, 0xD3, 0xF7};
 bool isMifare = false;
-static uint8_t Presence_check_TypeB[] =  {0xB2};
-#if(NFC_NXP_NON_STD_CARD == TRUE)
-static uint16_t NON_NCI_CARD_TIMER_OFFSET =700;
+static uint8_t Presence_check_TypeB[] = {0xB2};
+#if (NFC_NXP_NON_STD_CARD == TRUE)
+static uint16_t NON_NCI_CARD_TIMER_OFFSET = 700;
 static IntervalTimer sNonNciCardDetectionTimer;
 static IntervalTimer sNonNciMultiCardDetectionTimer;
-struct sNonNciCard{
-    bool chinaTransp_Card;
-    bool Changan_Card;
-    uint8_t sProtocolType;
-    uint8_t srfInterfaceType;
-    uint32_t uidlen;
-    uint8_t uid[12];
+struct sNonNciCard {
+  bool chinaTransp_Card;
+  bool Changan_Card;
+  uint8_t sProtocolType;
+  uint8_t srfInterfaceType;
+  uint32_t uidlen;
+  uint8_t uid[12];
 } sNonNciCard_t;
 bool scoreGenericNtf = false;
 void nativeNfcTag_cacheNonNciCardDetection();
 void nativeNfcTag_handleNonNciCardDetection(tNFA_CONN_EVT_DATA* eventData);
-void nativeNfcTag_handleNonNciMultiCardDetection(uint8_t connEvent, tNFA_CONN_EVT_DATA* eventData);
+void nativeNfcTag_handleNonNciMultiCardDetection(uint8_t connEvent,
+                                                 tNFA_CONN_EVT_DATA* eventData);
 static void nonNciCardTimerProc(union sigval);
 static void nonNciMultiCardTimerProc(union sigval);
 uint8_t checkTagNtf = 0;
@@ -188,55 +188,55 @@ static bool sIsReconnecting = false;
 static int doReconnectFlag = 0x00;
 static bool sIsCheckingNDef = false;
 
-static void nfaVSCCallback(uint8_t event, uint16_t param_len, uint8_t *p_param);
-static void nfaVSCNtfCallback(uint8_t event, uint16_t param_len, uint8_t *p_param);
-static void presenceCheckTimerProc (union sigval);
+static void nfaVSCCallback(uint8_t event, uint16_t param_len, uint8_t* p_param);
+static void nfaVSCNtfCallback(uint8_t event, uint16_t param_len,
+                              uint8_t* p_param);
+static void presenceCheckTimerProc(union sigval);
 static void sReconnectTimerProc(union sigval);
 
-static void nfaVSCNtfCallback(uint8_t event, uint16_t param_len, uint8_t *p_param)
-{
-    (void)event;
-    ALOGV("%s", __func__);
-    if(param_len == 4 && p_param[3] == 0x01)
-    {
-        sIsTagInField = true;
-    }
-    else
-    {
-        sIsTagInField = false;
-    }
+static void nfaVSCNtfCallback(uint8_t event, uint16_t param_len,
+                              uint8_t* p_param) {
+  (void)event;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
+  if (param_len == 4 && p_param[3] == 0x01) {
+    sIsTagInField = true;
+  } else {
+    sIsTagInField = false;
+  }
 
-    ALOGV("%s is Tag in Field = %d", __func__, sIsTagInField);
-    usleep(100*1000);
-    SyncEventGuard guard (sNfaVSCNotificationEvent);
-    sNfaVSCNotificationEvent.notifyOne ();
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s is Tag in Field = %d", __func__, sIsTagInField);
+  usleep(100 * 1000);
+  SyncEventGuard guard(sNfaVSCNotificationEvent);
+  sNfaVSCNotificationEvent.notifyOne();
 }
 
-static void nfaVSCCallback(uint8_t event, uint16_t param_len, uint8_t *p_param)
-{
-    (void)event;
-    ALOGV("%s", __func__);
-    ALOGV("%s param_len = %d ", __func__, param_len);
-    ALOGV("%s p_param = %d ", __func__, *p_param);
-
-    if(param_len == 4 && p_param[3] == 0x00)
-    {
-        ALOGV("%s sVSCRsp = true", __func__);
+static void nfaVSCCallback(uint8_t event, uint16_t param_len,
+                           uint8_t* p_param) {
+  (void)event;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s param_len = %d ", __func__, param_len);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s p_param = %d ", __func__, *p_param);
 
-        sVSCRsp = true;
-    }
-    else
-    {
-        ALOGV("%s sVSCRsp = false", __func__);
+  if (param_len == 4 && p_param[3] == 0x00) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s sVSCRsp = true", __func__);
 
-        sVSCRsp = false;
-    }
+    sVSCRsp = true;
+  } else {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s sVSCRsp = false", __func__);
 
-    ALOGV("%s sVSCRsp = %d", __func__, sVSCRsp);
+    sVSCRsp = false;
+  }
 
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s sVSCRsp = %d", __func__, sVSCRsp);
 
-    SyncEventGuard guard (sNfaVSCResponseEvent);
-    sNfaVSCResponseEvent.notifyOne ();
+  SyncEventGuard guard(sNfaVSCResponseEvent);
+  sNfaVSCResponseEvent.notifyOne();
 }
 
 /*******************************************************************************
@@ -248,36 +248,34 @@ static void nfaVSCCallback(uint8_t event, uint16_t param_len, uint8_t *p_param)
 ** Returns:         None
 **
 *******************************************************************************/
-void nativeNfcTag_abortWaits ()
-{
-    ALOGV("%s", __func__);
-    {
-        SyncEventGuard g (sReadEvent);
-        sReadEvent.notifyOne ();
-    }
-    sem_post (&sWriteSem);
-    sem_post (&sFormatSem);
-    {
-        SyncEventGuard g (sTransceiveEvent);
-        sTransceiveEvent.notifyOne ();
-    }
-    {
-        SyncEventGuard g (sReconnectEvent);
-        sReconnectEvent.notifyOne ();
-    }
-
-    sem_post (&sCheckNdefSem);
-    {
-        SyncEventGuard guard (sPresenceCheckEvent);
-        sPresenceCheckEvent.notifyOne ();
-    }
-    sem_post (&sMakeReadonlySem);
-    sCurrentRfInterface = NFA_INTERFACE_ISO_DEP;
-    sCurrentConnectedTargetType = TARGET_TYPE_UNKNOWN;
-    sCurrentConnectedTargetProtocol = NFC_PROTOCOL_UNKNOWN;
+void nativeNfcTag_abortWaits() {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
+  {
+    SyncEventGuard g(sReadEvent);
+    sReadEvent.notifyOne();
+  }
+  sem_post(&sWriteSem);
+  sem_post(&sFormatSem);
+  {
+    SyncEventGuard g(sTransceiveEvent);
+    sTransceiveEvent.notifyOne();
+  }
+  {
+    SyncEventGuard g(sReconnectEvent);
+    sReconnectEvent.notifyOne();
+  }
+
+  sem_post(&sCheckNdefSem);
+  {
+    SyncEventGuard guard(sPresenceCheckEvent);
+    sPresenceCheckEvent.notifyOne();
+  }
+  sem_post(&sMakeReadonlySem);
+  sCurrentRfInterface = NFA_INTERFACE_ISO_DEP;
+  sCurrentConnectedTargetType = TARGET_TYPE_UNKNOWN;
+  sCurrentConnectedTargetProtocol = NFC_PROTOCOL_UNKNOWN;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeNfcTag_doReadCompleted
@@ -289,37 +287,35 @@ void nativeNfcTag_abortWaits ()
 ** Returns:         None
 **
 *******************************************************************************/
-void nativeNfcTag_doReadCompleted (tNFA_STATUS status)
-{
-    ALOGV("%s: status=0x%X; is reading=%u", __func__, status, sIsReadingNdefMessage);
+void nativeNfcTag_doReadCompleted(tNFA_STATUS status) {
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: status=0x%X; is reading=%u", __func__, status,
+                      sIsReadingNdefMessage);
 
-    if (sIsReadingNdefMessage == false)
-        return; //not reading NDEF message right now, so just return
+  if (sIsReadingNdefMessage == false)
+    return;  // not reading NDEF message right now, so just return
 
-    sReadStatus = status;
-    if (status != NFA_STATUS_OK)
-    {
-        sReadDataLen = 0;
-        if (sReadData)
-            free (sReadData);
-        sReadData = NULL;
-    }
-    SyncEventGuard g (sReadEvent);
-    sReadEvent.notifyOne ();
+  sReadStatus = status;
+  if (status != NFA_STATUS_OK) {
+    sReadDataLen = 0;
+    if (sReadData) free(sReadData);
+    sReadData = NULL;
+  }
+  SyncEventGuard g(sReadEvent);
+  sReadEvent.notifyOne();
 }
 
 /*******************************************************************************
  **
-** Function:        nativeNfcTag_setRfInterface
-**
-** Description:     Set rf interface.
-**
-** Returns:         void
-**
-*******************************************************************************/
-void nativeNfcTag_setRfInterface (tNFA_INTF_TYPE rfInterface)
-{
-    sCurrentRfInterface = rfInterface;
+ ** Function:        nativeNfcTag_setRfInterface
+ **
+ ** Description:     Set rf interface.
+ **
+ ** Returns:         void
+ **
+ *******************************************************************************/
+void nativeNfcTag_setRfInterface(tNFA_INTF_TYPE rfInterface) {
+  sCurrentRfInterface = rfInterface;
 }
 
 /*******************************************************************************
@@ -333,37 +329,37 @@ void nativeNfcTag_setRfInterface (tNFA_INTF_TYPE rfInterface)
 ** Returns:         None
 **
 *******************************************************************************/
-static void ndefHandlerCallback (tNFA_NDEF_EVT event, tNFA_NDEF_EVT_DATA *eventData)
-{
-    ALOGV("%s: event=%u, eventData=%p", __func__, event, eventData);
-
-    switch (event)
-    {
-    case NFA_NDEF_REGISTER_EVT:
-        {
-            tNFA_NDEF_REGISTER& ndef_reg = eventData->ndef_reg;
-            ALOGV("%s: NFA_NDEF_REGISTER_EVT; status=0x%X; h=0x%X", __func__, ndef_reg.status, ndef_reg.ndef_type_handle);
-            sNdefTypeHandlerHandle = ndef_reg.ndef_type_handle;
-        }
-        break;
-
-    case NFA_NDEF_DATA_EVT:
-        {
-            ALOGV("%s: NFA_NDEF_DATA_EVT; data_len = %u", __func__, eventData->ndef_data.len);
-            sReadDataLen = eventData->ndef_data.len;
-            sReadData = (uint8_t*) malloc (sReadDataLen);
-            if(sReadData != NULL)
-                memcpy (sReadData, eventData->ndef_data.p_data, eventData->ndef_data.len);
-        }
-        break;
+static void ndefHandlerCallback(tNFA_NDEF_EVT event,
+                                tNFA_NDEF_EVT_DATA* eventData) {
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: event=%u, eventData=%p", __func__, event, eventData);
+
+  switch (event) {
+    case NFA_NDEF_REGISTER_EVT: {
+      tNFA_NDEF_REGISTER& ndef_reg = eventData->ndef_reg;
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: NFA_NDEF_REGISTER_EVT; status=0x%X; h=0x%X",
+                          __func__, ndef_reg.status, ndef_reg.ndef_type_handle);
+      sNdefTypeHandlerHandle = ndef_reg.ndef_type_handle;
+    } break;
+
+    case NFA_NDEF_DATA_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: NFA_NDEF_DATA_EVT; data_len = %u", __func__,
+                          eventData->ndef_data.len);
+      sReadDataLen = eventData->ndef_data.len;
+      sReadData = (uint8_t*)malloc(sReadDataLen);
+      if (sReadData != NULL)
+        memcpy(sReadData, eventData->ndef_data.p_data,
+               eventData->ndef_data.len);
+    } break;
 
     default:
-        ALOGE("%s: Unknown event %u ????", __func__, event);
-        break;
-    }
+      LOG(ERROR) << StringPrintf("%s: Unknown event %u ????", __func__, event);
+      break;
+  }
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeNfcTag_doRead
@@ -375,69 +371,61 @@ static void ndefHandlerCallback (tNFA_NDEF_EVT event, tNFA_NDEF_EVT_DATA *eventD
 ** Returns:         NDEF message.
 **
 *******************************************************************************/
-static jbyteArray nativeNfcTag_doRead (JNIEnv* e, jobject o)
-{
-    ALOGV("%s: enter", __func__);
-    tNFA_STATUS status = NFA_STATUS_FAILED;
-    jbyteArray buf = NULL;
-
-    sReadStatus = NFA_STATUS_OK;
-    sReadDataLen = 0;
-    if (sReadData != NULL)
-    {
-        free (sReadData);
-        sReadData = NULL;
-    }
-
-    if (sCheckNdefCurrentSize > 0)
-    {
-        {
-            SyncEventGuard g (sReadEvent);
-            sIsReadingNdefMessage = true;
-            if (sCurrentConnectedTargetProtocol == NFA_PROTOCOL_MIFARE)
-            {
-                status = EXTNS_MfcReadNDef ();
-            }
-            else
-            {
-                status = NFA_RwReadNDef ();
-            }
-            sReadEvent.wait (); //wait for NFA_READ_CPLT_EVT
-        }
-        sIsReadingNdefMessage = false;
-
-        if (sReadDataLen > 0) //if stack actually read data from the tag
-        {
-            ALOGV("%s: read %u bytes", __func__, sReadDataLen);
-            buf = e->NewByteArray (sReadDataLen);
-            e->SetByteArrayRegion (buf, 0, sReadDataLen, (jbyte*) sReadData);
-        }
-        if (sReadStatus == NFA_STATUS_TIMEOUT)
-            setNdefDetectionTimeout();
-        else if (sReadStatus == NFA_STATUS_FAILED)
-            (void)setNdefDetectionTimeoutIfTagAbsent(e, o, NFA_PROTOCOL_ISO15693);
-    }
-    else
-    {
-        ALOGV("%s: create empty buffer", __func__);
-        sReadDataLen = 0;
-        sReadData = (uint8_t*) malloc (1);
-        buf = e->NewByteArray (sReadDataLen);
-        e->SetByteArrayRegion (buf, 0, sReadDataLen, (jbyte*) sReadData);
-    }
-
-    if (sReadData)
-    {
-        free (sReadData);
-        sReadData = NULL;
-    }
+static jbyteArray nativeNfcTag_doRead(JNIEnv* e, jobject o) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+  tNFA_STATUS status = NFA_STATUS_FAILED;
+  jbyteArray buf = NULL;
+
+  sReadStatus = NFA_STATUS_OK;
+  sReadDataLen = 0;
+  if (sReadData != NULL) {
+    free(sReadData);
+    sReadData = NULL;
+  }
+
+  if (sCheckNdefCurrentSize > 0) {
+    {
+      SyncEventGuard g(sReadEvent);
+      sIsReadingNdefMessage = true;
+      if (sCurrentConnectedTargetProtocol == NFC_PROTOCOL_MIFARE) {
+        status = EXTNS_MfcReadNDef();
+      } else {
+        status = NFA_RwReadNDef();
+      }
+      sReadEvent.wait();  // wait for NFA_READ_CPLT_EVT
+    }
+    sIsReadingNdefMessage = false;
+
+    if (sReadDataLen > 0)  // if stack actually read data from the tag
+    {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: read %u bytes", __func__, sReadDataLen);
+      buf = e->NewByteArray(sReadDataLen);
+      e->SetByteArrayRegion(buf, 0, sReadDataLen, (jbyte*)sReadData);
+    }
+    if (sReadStatus == NFA_STATUS_TIMEOUT)
+      setNdefDetectionTimeout();
+    else if (sReadStatus == NFA_STATUS_FAILED)
+      (void)setNdefDetectionTimeoutIfTagAbsent(e, o, NFA_PROTOCOL_T5T);
+  } else {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: create empty buffer", __func__);
     sReadDataLen = 0;
-
-    ALOGV("%s: exit", __func__);
-    return buf;
+    sReadData = (uint8_t*)malloc(1);
+    buf = e->NewByteArray(sReadDataLen);
+    e->SetByteArrayRegion(buf, 0, sReadDataLen, (jbyte*)sReadData);
+  }
+
+  if (sReadData) {
+    free(sReadData);
+    sReadData = NULL;
+  }
+  sReadDataLen = 0;
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  return buf;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeNfcTag_doWriteStatus
@@ -449,16 +437,14 @@ static jbyteArray nativeNfcTag_doRead (JNIEnv* e, jobject o)
 ** Returns:         None
 **
 *******************************************************************************/
-void nativeNfcTag_doWriteStatus (jboolean isWriteOk)
-{
-    if (sWriteWaitingForComplete != JNI_FALSE)
-    {
-        sWriteWaitingForComplete = JNI_FALSE;
-        sWriteOk = isWriteOk;
-        sem_post (&sWriteSem);
-    }
+void nativeNfcTag_doWriteStatus(jboolean isWriteOk) {
+  if (sWriteWaitingForComplete != JNI_FALSE) {
+    sWriteWaitingForComplete = JNI_FALSE;
+    sWriteOk = isWriteOk;
+    sem_post(&sWriteSem);
+  }
 }
-#if(NXP_EXTNS == TRUE && NFC_NXP_NON_STD_CARD == TRUE)
+#if (NXP_EXTNS == TRUE && NFC_NXP_NON_STD_CARD == TRUE)
 /*******************************************************************************
 **
 ** Function:        nonNciCardTimerProc
@@ -470,11 +456,10 @@ void nativeNfcTag_doWriteStatus (jboolean isWriteOk)
 ** Returns:         None
 **
 *******************************************************************************/
-void nonNciCardTimerProc(union sigval)
-{
-    ALOGV("%s: enter ", __func__);
-    memset(&sNonNciCard_t,0,sizeof(sNonNciCard));
-    scoreGenericNtf = false;
+void nonNciCardTimerProc(union sigval) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter ", __func__);
+  memset(&sNonNciCard_t, 0, sizeof(sNonNciCard));
+  scoreGenericNtf = false;
 }
 
 /*******************************************************************************
@@ -488,11 +473,10 @@ void nonNciCardTimerProc(union sigval)
 ** Returns:         None
 **
 *******************************************************************************/
-void nonNciMultiCardTimerProc(union sigval)
-{
-    ALOGV("%s: enter ", __func__);
-    checkTagNtf = 0;
-    checkCmdSent = 0;
+void nonNciMultiCardTimerProc(union sigval) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter ", __func__);
+  checkTagNtf = 0;
+  checkCmdSent = 0;
 }
 
 /*******************************************************************************
@@ -504,20 +488,25 @@ void nonNciMultiCardTimerProc(union sigval)
 ** Returns:         None
 **
 *******************************************************************************/
-void nativeNfcTag_cacheNonNciCardDetection()
-{
-    NfcTag& natTag = NfcTag::getInstance ();
-    static uint32_t cardDetectTimeout = 0;
-    static uint8_t *uid;
-    scoreGenericNtf = true;
-    NfcTag::getInstance().getTypeATagUID(&uid ,&sNonNciCard_t.uidlen);
-    memcpy(sNonNciCard_t.uid ,uid ,sNonNciCard_t.uidlen);
-    sNonNciCard_t.sProtocolType = natTag.mTechLibNfcTypes[sCurrentConnectedHandle];
-    sNonNciCard_t.srfInterfaceType = sCurrentRfInterface;
-    cardDetectTimeout =  NON_NCI_CARD_TIMER_OFFSET + android::getrfDiscoveryDuration();
-    ALOGV("%s: cardDetectTimeout = %d", __func__,cardDetectTimeout);
-    sNonNciCardDetectionTimer.set(cardDetectTimeout, nonNciCardTimerProc);
-    ALOGV("%s: sNonNciCard_t.sProtocolType=0x%x sNonNciCard_t.srfInterfaceType =0x%x ", __func__,sNonNciCard_t.sProtocolType, sNonNciCard_t.srfInterfaceType);
+void nativeNfcTag_cacheNonNciCardDetection() {
+  NfcTag& natTag = NfcTag::getInstance();
+  static uint32_t cardDetectTimeout = 0;
+  static uint8_t* uid;
+  scoreGenericNtf = true;
+  NfcTag::getInstance().getTypeATagUID(&uid, &sNonNciCard_t.uidlen);
+  memcpy(sNonNciCard_t.uid, uid, sNonNciCard_t.uidlen);
+  sNonNciCard_t.sProtocolType =
+      natTag.mTechLibNfcTypes[sCurrentConnectedHandle];
+  sNonNciCard_t.srfInterfaceType = sCurrentRfInterface;
+  cardDetectTimeout =
+      NON_NCI_CARD_TIMER_OFFSET + android::getrfDiscoveryDuration();
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: cardDetectTimeout = %d",
+                                                   __func__, cardDetectTimeout);
+  sNonNciCardDetectionTimer.set(cardDetectTimeout, nonNciCardTimerProc);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: sNonNciCard_t.sProtocolType=0x%x sNonNciCard_t.srfInterfaceType "
+      "=0x%x ",
+      __func__, sNonNciCard_t.sProtocolType, sNonNciCard_t.srfInterfaceType);
 }
 /*******************************************************************************
 **
@@ -528,30 +517,37 @@ void nativeNfcTag_cacheNonNciCardDetection()
 ** Returns:         None
 **
 *******************************************************************************/
-void nativeNfcTag_handleNonNciCardDetection(tNFA_CONN_EVT_DATA* eventData)
-{
-    ALOGV("%s: enter ", __func__);
-    sNonNciCardDetectionTimer.kill();
-    static uint32_t tempUidLen = 0x00;
-    static uint8_t  *tempUid;
-    NfcTag::getInstance().getTypeATagUID(&tempUid, &tempUidLen);
-    if((eventData->activated.activate_ntf.intf_param.type == sNonNciCard_t.srfInterfaceType)  && ( eventData->activated.activate_ntf.protocol == sNonNciCard_t.sProtocolType))
-    {
-        if((tempUidLen == sNonNciCard_t.uidlen) && (memcmp(tempUid, sNonNciCard_t.uid, tempUidLen) == 0x00) )
-        {
-            sNonNciCard_t.chinaTransp_Card = true;
-            ALOGV("%s:  sNonNciCard_t.chinaTransp_Card = true", __func__);
-        }
-    }
-    else if((sNonNciCard_t.srfInterfaceType == NFC_INTERFACE_FRAME) && ( eventData->activated.activate_ntf.protocol == sNonNciCard_t.sProtocolType))
-    {
-        if((tempUidLen == sNonNciCard_t.uidlen) && (memcmp(tempUid, sNonNciCard_t.uid, tempUidLen) == 0x00) )
-        {
-            sNonNciCard_t.Changan_Card = true;
-            ALOGV("%s:   sNonNciCard_t.Changan_Card = true", __func__);
-        }
-    }
-    ALOGV("%s: eventData->activated.activate_ntf.protocol =0x%x eventData->activated.activate_ntf.intf_param.type =0x%x", __func__,eventData->activated.activate_ntf.protocol, eventData->activated.activate_ntf.intf_param.type);
+void nativeNfcTag_handleNonNciCardDetection(tNFA_CONN_EVT_DATA* eventData) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter ", __func__);
+  sNonNciCardDetectionTimer.kill();
+  static uint32_t tempUidLen = 0x00;
+  static uint8_t* tempUid;
+  NfcTag::getInstance().getTypeATagUID(&tempUid, &tempUidLen);
+  if ((eventData->activated.activate_ntf.intf_param.type ==
+       sNonNciCard_t.srfInterfaceType) &&
+      (eventData->activated.activate_ntf.protocol ==
+       sNonNciCard_t.sProtocolType)) {
+    if ((tempUidLen == sNonNciCard_t.uidlen) &&
+        (memcmp(tempUid, sNonNciCard_t.uid, tempUidLen) == 0x00)) {
+      sNonNciCard_t.chinaTransp_Card = true;
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s:  sNonNciCard_t.chinaTransp_Card = true", __func__);
+    }
+  } else if ((sNonNciCard_t.srfInterfaceType == NFC_INTERFACE_FRAME) &&
+             (eventData->activated.activate_ntf.protocol ==
+              sNonNciCard_t.sProtocolType)) {
+    if ((tempUidLen == sNonNciCard_t.uidlen) &&
+        (memcmp(tempUid, sNonNciCard_t.uid, tempUidLen) == 0x00)) {
+      sNonNciCard_t.Changan_Card = true;
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s:   sNonNciCard_t.Changan_Card = true", __func__);
+    }
+  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: eventData->activated.activate_ntf.protocol =0x%x "
+      "eventData->activated.activate_ntf.intf_param.type =0x%x",
+      __func__, eventData->activated.activate_ntf.protocol,
+      eventData->activated.activate_ntf.intf_param.type);
 }
 
 /*******************************************************************************
@@ -563,31 +559,28 @@ void nativeNfcTag_handleNonNciCardDetection(tNFA_CONN_EVT_DATA* eventData)
 ** Returns:         None
 **
 *******************************************************************************/
-void nativeNfcTag_handleNonNciMultiCardDetection(uint8_t connEvent, tNFA_CONN_EVT_DATA* eventData)
-{
-    ALOGV("%s: enter ", __func__);
-    if(NfcTag::getInstance ().mNumDiscNtf)
-    {
-        ALOGV("%s: check_tag_ntf = %d, check_cmd_sent = %d", __func__ ,checkTagNtf,checkCmdSent);
-        if(checkTagNtf == 0)
-        {
-            NfcTag::getInstance().connectionEventHandler (connEvent, eventData);
-            NFA_Deactivate (true);
-            checkCmdSent = 1;
-            sNonNciMultiCardDetectionTimer.set(NON_NCI_CARD_TIMER_OFFSET, nonNciCardTimerProc);
-        }
-        else if(checkTagNtf == 1)
-        {
-            NfcTag::getInstance ().mNumDiscNtf = 0;
-            checkTagNtf = 0;
-            checkCmdSent = 0;
-            NfcTag::getInstance().connectionEventHandler (connEvent, eventData);
-        }
-    }
-    else
-    {
-        NfcTag::getInstance().connectionEventHandler (connEvent, eventData);
-    }
+void nativeNfcTag_handleNonNciMultiCardDetection(
+    uint8_t connEvent, tNFA_CONN_EVT_DATA* eventData) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter ", __func__);
+  if (NfcTag::getInstance().mNumDiscNtf) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: check_tag_ntf = %d, check_cmd_sent = %d", __func__,
+                        checkTagNtf, checkCmdSent);
+    if (checkTagNtf == 0) {
+      NfcTag::getInstance().connectionEventHandler(connEvent, eventData);
+      NFA_Deactivate(true);
+      checkCmdSent = 1;
+      sNonNciMultiCardDetectionTimer.set(NON_NCI_CARD_TIMER_OFFSET,
+                                         nonNciCardTimerProc);
+    } else if (checkTagNtf == 1) {
+      NfcTag::getInstance().mNumDiscNtf = 0;
+      checkTagNtf = 0;
+      checkCmdSent = 0;
+      NfcTag::getInstance().connectionEventHandler(connEvent, eventData);
+    }
+  } else {
+    NfcTag::getInstance().connectionEventHandler(connEvent, eventData);
+  }
 }
 /*******************************************************************************
 **
@@ -598,10 +591,9 @@ void nativeNfcTag_handleNonNciMultiCardDetection(uint8_t connEvent, tNFA_CONN_EV
 ** Returns:         None
 **
 *******************************************************************************/
-static void switchBackTimerProc (union sigval)
-{
-    ALOGV("%s", __func__);
-    switchRfInterface(NFA_INTERFACE_ISO_DEP);
+static void switchBackTimerProc(union sigval) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
+  switchRfInterface(NFA_INTERFACE_ISO_DEP);
 }
 #endif
 
@@ -616,13 +608,11 @@ static void switchBackTimerProc (union sigval)
 ** Returns:         None
 **
 *******************************************************************************/
-void nativeNfcTag_formatStatus (bool isOk)
-{
-    sFormatOk = isOk;
-    sem_post (&sFormatSem);
+void nativeNfcTag_formatStatus(bool isOk) {
+  sFormatOk = isOk;
+  sem_post(&sFormatSem);
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeNfcTag_doWrite
@@ -635,168 +625,162 @@ void nativeNfcTag_formatStatus (bool isOk)
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-static jboolean nativeNfcTag_doWrite (JNIEnv* e, jobject, jbyteArray buf)
-{
-    jboolean result = JNI_FALSE;
-    tNFA_STATUS status = 0;
-    const int maxBufferSize = 1024;
-    uint8_t buffer[maxBufferSize] = { 0 };
-    uint32_t curDataSize = 0;
-
-    ScopedByteArrayRO bytes(e, buf);
-    uint8_t* p_data = const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0])); // TODO: const-ness API bug in NFA_RwWriteNDef!
-
-    ALOGV("%s: enter; len = %zu", __func__, bytes.size());
-
-    /* Create the write semaphore */
-    if (sem_init (&sWriteSem, 0, 0) == -1)
-    {
-        ALOGE("%s: semaphore creation failed (errno=0x%08x)", __func__, errno);
-        return JNI_FALSE;
-    }
-
-    sWriteWaitingForComplete = JNI_TRUE;
-    if (sCheckNdefStatus == NFA_STATUS_FAILED)
-    {
-        //if tag does not contain a NDEF message
-        //and tag is capable of storing NDEF message
-        if (sCheckNdefCapable)
-        {
-#if(NXP_EXTNS == TRUE)
-            isMifare = false;
-#endif
-            ALOGV("%s: try format", __func__);
-            sem_init (&sFormatSem, 0, 0);
-            sFormatOk = false;
-            if (sCurrentConnectedTargetProtocol == NFA_PROTOCOL_MIFARE)
-            {
-#if(NXP_EXTNS == TRUE)
-                isMifare = true;
-                status = EXTNS_MfcFormatTag(key1,sizeof(key1));
+static jboolean nativeNfcTag_doWrite(JNIEnv* e, jobject, jbyteArray buf) {
+  jboolean result = JNI_FALSE;
+  tNFA_STATUS status = 0;
+  const int maxBufferSize = 1024;
+  uint8_t buffer[maxBufferSize] = {0};
+  uint32_t curDataSize = 0;
+
+  ScopedByteArrayRO bytes(e, buf);
+  uint8_t* p_data = const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(
+      &bytes[0]));  // TODO: const-ness API bug in NFA_RwWriteNDef!
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter; len = %zu", __func__, bytes.size());
+
+  /* Create the write semaphore */
+  if (sem_init(&sWriteSem, 0, 0) == -1) {
+    LOG(ERROR) << StringPrintf("%s: semaphore creation failed (errno=0x%08x)",
+                               __func__, errno);
+    return JNI_FALSE;
+  }
+
+  sWriteWaitingForComplete = JNI_TRUE;
+  if (sCheckNdefStatus == NFA_STATUS_FAILED) {
+    // if tag does not contain a NDEF message
+    // and tag is capable of storing NDEF message
+    if (sCheckNdefCapable) {
+#if (NXP_EXTNS == TRUE)
+      isMifare = false;
 #endif
-            }
-            else
-            {
-                status = NFA_RwFormatTag ();
-            }
-            sem_wait (&sFormatSem);
-            sem_destroy (&sFormatSem);
-
-#if(NXP_EXTNS == TRUE)
-            if(isMifare == true && sFormatOk != true)
-            {
-            sem_init (&sFormatSem, 0, 0);
-
-            status = EXTNS_MfcFormatTag(key2,sizeof(key2));
-                sem_wait (&sFormatSem);
-                sem_destroy (&sFormatSem);
-            }
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: try format", __func__);
+      sem_init(&sFormatSem, 0, 0);
+      sFormatOk = false;
+      if (sCurrentConnectedTargetProtocol == NFC_PROTOCOL_MIFARE) {
+#if (NXP_EXTNS == TRUE)
+        isMifare = true;
+        status = EXTNS_MfcFormatTag(key1, sizeof(key1));
 #endif
+      } else {
+        status = NFA_RwFormatTag();
+      }
+      sem_wait(&sFormatSem);
+      sem_destroy(&sFormatSem);
 
-            if (sFormatOk == false) //if format operation failed
-                goto TheEnd;
-        }
-        ALOGV("%s: try write", __func__);
-        status = NFA_RwWriteNDef (p_data, bytes.size());
-    }
-    else if (bytes.size() == 0)
-    {
-        //if (NXP TagWriter wants to erase tag) then create and write an empty ndef message
-        NDEF_MsgInit (buffer, maxBufferSize, &curDataSize);
-        status = NDEF_MsgAddRec (buffer, maxBufferSize, &curDataSize, NDEF_TNF_EMPTY, NULL, 0, NULL, 0, NULL, 0);
-        ALOGV("%s: create empty ndef msg; status=%u; size=%u", __func__, status, curDataSize);
-        if (sCurrentConnectedTargetProtocol == NFA_PROTOCOL_MIFARE)
-        {
-            status = EXTNS_MfcWriteNDef (buffer, curDataSize);
-        }
-        else
-        {
-            status = NFA_RwWriteNDef (buffer, curDataSize);
-        }
-    }
-    else
-    {
-        ALOGV("%s: NFA_RwWriteNDef", __func__);
-        if (sCurrentConnectedTargetProtocol == NFA_PROTOCOL_MIFARE)
-        {
-            status = EXTNS_MfcWriteNDef (p_data, bytes.size());
-        }
-        else
-        {
-            status = NFA_RwWriteNDef (p_data, bytes.size());
-        }
-    }
+#if (NXP_EXTNS == TRUE)
+      if (isMifare == true && sFormatOk != true) {
+        sem_init(&sFormatSem, 0, 0);
 
-    if (status != NFA_STATUS_OK)
-    {
-        ALOGE("%s: write/format error=%d", __func__, status);
-        goto TheEnd;
-    }
+        status = EXTNS_MfcFormatTag(key2, sizeof(key2));
+        sem_wait(&sFormatSem);
+        sem_destroy(&sFormatSem);
+      }
+#endif
 
-    /* Wait for write completion status */
-    sWriteOk = false;
-    if (sem_wait (&sWriteSem))
-    {
-        ALOGE("%s: wait semaphore (errno=0x%08x)", __func__, errno);
+      if (sFormatOk == false)  // if format operation failed
         goto TheEnd;
     }
-
-    result = sWriteOk;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: try write", __func__);
+    status = NFA_RwWriteNDef(p_data, bytes.size());
+  } else if (bytes.size() == 0) {
+    // if (NXP TagWriter wants to erase tag) then create and write an empty ndef
+    // message
+    NDEF_MsgInit(buffer, maxBufferSize, &curDataSize);
+    status = NDEF_MsgAddRec(buffer, maxBufferSize, &curDataSize, NDEF_TNF_EMPTY,
+                            NULL, 0, NULL, 0, NULL, 0);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: create empty ndef msg; status=%u; size=%u",
+                        __func__, status, curDataSize);
+    if (sCurrentConnectedTargetProtocol == NFC_PROTOCOL_MIFARE) {
+      status = EXTNS_MfcWriteNDef(buffer, curDataSize);
+    } else {
+      status = NFA_RwWriteNDef(buffer, curDataSize);
+    }
+  } else {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: NFA_RwWriteNDef", __func__);
+    if (sCurrentConnectedTargetProtocol == NFC_PROTOCOL_MIFARE) {
+      status = EXTNS_MfcWriteNDef(p_data, bytes.size());
+    } else {
+      status = NFA_RwWriteNDef(p_data, bytes.size());
+    }
+  }
+
+  if (status != NFA_STATUS_OK) {
+    LOG(ERROR) << StringPrintf("%s: write/format error=%d", __func__, status);
+    goto TheEnd;
+  }
+
+  /* Wait for write completion status */
+  sWriteOk = false;
+  if (sem_wait(&sWriteSem)) {
+    LOG(ERROR) << StringPrintf("%s: wait semaphore (errno=0x%08x)", __func__,
+                               errno);
+    goto TheEnd;
+  }
+
+  result = sWriteOk;
 
 TheEnd:
-    /* Destroy semaphore */
-    if (sem_destroy (&sWriteSem))
-    {
-        ALOGE("%s: failed destroy semaphore (errno=0x%08x)", __func__, errno);
-    }
-    sWriteWaitingForComplete = JNI_FALSE;
-    ALOGV("%s: exit; result=%d", __func__, result);
-    return result;
+  /* Destroy semaphore */
+  if (sem_destroy(&sWriteSem)) {
+    LOG(ERROR) << StringPrintf("%s: failed destroy semaphore (errno=0x%08x)",
+                               __func__, errno);
+  }
+  sWriteWaitingForComplete = JNI_FALSE;
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit; result=%d", __func__, result);
+  return result;
 }
 
 /*******************************************************************************
 **
 ** Function:        setNdefDetectionTimeoutIfTagAbsent
 **
-** Description:     Check protocol / presence of a tag which cannot detect tag lost during
-**                  NDEF check. If it is absent, set NDEF detection timed out state.
+** Description:     Check protocol / presence of a tag which cannot detect tag
+*lost during
+**                  NDEF check. If it is absent, set NDEF detection timed out
+*state.
 **
-** Returns:         True if a tag is absent and a current protocol matches the given protocols.
+** Returns:         True if a tag is absent and a current protocol matches the
+*given protocols.
 **
 *******************************************************************************/
-static bool setNdefDetectionTimeoutIfTagAbsent (JNIEnv *e, jobject o, tNFC_PROTOCOL protocol)
-{
-    if (!(NfcTag::getInstance().getProtocol() & protocol))
-        return false;
+static bool setNdefDetectionTimeoutIfTagAbsent(JNIEnv* e, jobject o,
+                                               tNFC_PROTOCOL protocol) {
+  if (!(NfcTag::getInstance().getProtocol() & protocol)) return false;
 
-    if (nativeNfcTag_doPresenceCheck(e, o))
-        return false;
+  if (nativeNfcTag_doPresenceCheck(e, o)) return false;
 
-    ALOGV("%s: tag is not present. set NDEF detection timed out", __func__);
-    setNdefDetectionTimeout();
-    return true;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: tag is not present. set NDEF detection timed out", __func__);
+  setNdefDetectionTimeout();
+  return true;
 }
 
 /*******************************************************************************
 **
 ** Function:        setNdefDetectionTimeout
 **
-** Description:     Set the flag which indicates whether NDEF detection algorithm
+** Description:     Set the flag which indicates whether NDEF detection
+*algorithm
 **                  timed out so that the tag is regarded as lost.
 **
 ** Returns:         None
 **
 *******************************************************************************/
-static void setNdefDetectionTimeout ()
-{
-    tNFA_CONN_EVT_DATA conn_evt_data;
+static void setNdefDetectionTimeout() {
+  tNFA_CONN_EVT_DATA conn_evt_data;
 
-    conn_evt_data.status               = NFA_STATUS_TIMEOUT;
-    conn_evt_data.ndef_detect.cur_size = 0;
-    conn_evt_data.ndef_detect.max_size = 0;
-    conn_evt_data.ndef_detect.flags    = RW_NDEF_FL_UNKNOWN;
+  conn_evt_data.status = NFA_STATUS_TIMEOUT;
+  conn_evt_data.ndef_detect.cur_size = 0;
+  conn_evt_data.ndef_detect.max_size = 0;
+  conn_evt_data.ndef_detect.flags = RW_NDEF_FL_UNKNOWN;
 
-    NfcTag::getInstance().connectionEventHandler(NFA_NDEF_DETECT_EVT, &conn_evt_data);
+  NfcTag::getInstance().connectionEventHandler(NFA_NDEF_DETECT_EVT,
+                                               &conn_evt_data);
 }
 
 /*******************************************************************************
@@ -809,25 +793,21 @@ static void setNdefDetectionTimeout ()
 ** Returns:         None
 **
 *******************************************************************************/
-void nativeNfcTag_doConnectStatus (jboolean isConnectOk)
-{
-    if (EXTNS_GetConnectFlag() == true)
-    {
-        EXTNS_MfcActivated ();
-        EXTNS_SetConnectFlag (false);
-        return;
-    }
-
-    if (sConnectWaitingForComplete != JNI_FALSE)
-    {
-        sConnectWaitingForComplete = JNI_FALSE;
-        sConnectOk = isConnectOk;
-        SyncEventGuard g (sReconnectEvent);
-        sReconnectEvent.notifyOne ();
-    }
+void nativeNfcTag_doConnectStatus(jboolean isConnectOk) {
+  if (EXTNS_GetConnectFlag() == true) {
+    EXTNS_MfcActivated();
+    EXTNS_SetConnectFlag(false);
+    return;
+  }
+
+  if (sConnectWaitingForComplete != JNI_FALSE) {
+    sConnectWaitingForComplete = JNI_FALSE;
+    sConnectOk = isConnectOk;
+    SyncEventGuard g(sReconnectEvent);
+    sReconnectEvent.notifyOne();
+  }
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeNfcTag_doDeactivateStatus
@@ -837,22 +817,19 @@ void nativeNfcTag_doConnectStatus (jboolean isConnectOk)
 ** Returns:         None
 **
 *******************************************************************************/
-void nativeNfcTag_doDeactivateStatus (int status)
-{
-    if(EXTNS_GetDeactivateFlag() == true)
-    {
-        EXTNS_MfcDisconnect ();
-        EXTNS_SetDeactivateFlag (false);
-        return;
-    }
+void nativeNfcTag_doDeactivateStatus(int status) {
+  if (EXTNS_GetDeactivateFlag() == true) {
+    EXTNS_MfcDisconnect();
+    EXTNS_SetDeactivateFlag(false);
+    return;
+  }
 
-    sGotDeactivate = (status == 0);
+  sGotDeactivate = (status == 0);
 
-    SyncEventGuard g (sReconnectEvent);
-    sReconnectEvent.notifyOne ();
+  SyncEventGuard g(sReconnectEvent);
+  sReconnectEvent.notifyOne();
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeNfcTag_doConnect
@@ -865,73 +842,73 @@ void nativeNfcTag_doDeactivateStatus (int status)
 ** Returns:         Must return NXP status code, which NFC service expects.
 **
 *******************************************************************************/
-static jint nativeNfcTag_doConnect (JNIEnv*, jobject, jint targetHandle)
-{
-    ALOGV("%s: targetHandle = %d", __func__, targetHandle);
-    int i = targetHandle;
-    NfcTag& natTag = NfcTag::getInstance ();
-    int retCode = NFCSTATUS_SUCCESS;
-    sCurrentConnectedTargetType = natTag.mTechList[i];
-    sCurrentConnectedTargetProtocol = natTag.mTechLibNfcTypes[i];
-
-    if (i >= NfcTag::MAX_NUM_TECHNOLOGY)
-    {
-        ALOGE("%s: Handle not found", __func__);
-        retCode = NFCSTATUS_FAILED;
-        goto TheEnd;
-    }
-#if(NXP_EXTNS == TRUE && NFC_NXP_NON_STD_CARD == TRUE)
-    sNeedToSwitchRf = false;
+static jint nativeNfcTag_doConnect(JNIEnv*, jobject, jint targetHandle) {
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: targetHandle = %d", __func__, targetHandle);
+  int i = targetHandle;
+  NfcTag& natTag = NfcTag::getInstance();
+  int retCode = NFCSTATUS_SUCCESS;
+  if (i >= NfcTag::MAX_NUM_TECHNOLOGY) {
+    LOG(ERROR) << StringPrintf("%s: Handle not found", __func__);
+    retCode = NFCSTATUS_FAILED;
+    goto TheEnd;
+  }
+  sCurrentConnectedTargetType = natTag.mTechList[i];
+  sCurrentConnectedTargetProtocol = natTag.mTechLibNfcTypes[i];
+#if (NXP_EXTNS == TRUE && NFC_NXP_NON_STD_CARD == TRUE)
+  sNeedToSwitchRf = false;
 #endif
-    if (natTag.getActivationState() != NfcTag::Active)
-    {
-        ALOGE("%s: tag already deactivated", __func__);
-        retCode = NFCSTATUS_FAILED;
-        goto TheEnd;
-    }
-#if(NXP_EXTNS == TRUE)
-    sCurrentConnectedHandle = targetHandle;
-    if(sCurrentConnectedTargetProtocol == NFC_PROTOCOL_T3BT)
-    {
-        goto TheEnd;
-    }
+  if (natTag.getActivationState() != NfcTag::Active) {
+    LOG(ERROR) << StringPrintf("%s: tag already deactivated", __func__);
+    retCode = NFCSTATUS_FAILED;
+    goto TheEnd;
+  }
+#if (NXP_EXTNS == TRUE)
+  sCurrentConnectedHandle = targetHandle;
+  if (sCurrentConnectedTargetProtocol == NFC_PROTOCOL_T3BT) {
+    goto TheEnd;
+  }
 #endif
 
-    if (sCurrentConnectedTargetProtocol != NFC_PROTOCOL_ISO_DEP)
-    {
-        ALOGV("%s() Nfc type = %d, do nothing for non ISO_DEP", __func__, sCurrentConnectedTargetProtocol);
-        retCode = NFCSTATUS_SUCCESS;
-        goto TheEnd;
-    }
-    /* Switching is required for CTS protocol paramter test case.*/
-    if (sCurrentConnectedTargetType == TARGET_TYPE_ISO14443_3A || sCurrentConnectedTargetType == TARGET_TYPE_ISO14443_3B)
-    {
-        ALOGV("%s: switching to tech: %d need to switch rf intf to frame", __func__, sCurrentConnectedTargetType);
-#if(NXP_EXTNS == TRUE && NFC_NXP_NON_STD_CARD == TRUE)
-        if(sNonNciCard_t.Changan_Card == true)
-            sNeedToSwitchRf = true;
-        else
-#endif
-            retCode = switchRfInterface(NFA_INTERFACE_FRAME) ? NFA_STATUS_OK : NFA_STATUS_FAILED;
-    }
+  if (sCurrentConnectedTargetProtocol != NFC_PROTOCOL_ISO_DEP) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s() Nfc type = %d, do nothing for non ISO_DEP",
+                        __func__, sCurrentConnectedTargetProtocol);
+    retCode = NFCSTATUS_SUCCESS;
+    goto TheEnd;
+  }
+  /* Switching is required for CTS protocol paramter test case.*/
+  if (sCurrentConnectedTargetType == TARGET_TYPE_ISO14443_3A ||
+      sCurrentConnectedTargetType == TARGET_TYPE_ISO14443_3B) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: switching to tech: %d need to switch rf intf to frame", __func__,
+        sCurrentConnectedTargetType);
+#if (NXP_EXTNS == TRUE && NFC_NXP_NON_STD_CARD == TRUE)
+    if (sNonNciCard_t.Changan_Card == true)
+      sNeedToSwitchRf = true;
     else
-    {
-        retCode = switchRfInterface(NFA_INTERFACE_ISO_DEP) ? NFA_STATUS_OK : NFA_STATUS_FAILED;
-    }
+#endif
+      retCode = switchRfInterface(NFA_INTERFACE_FRAME) ? NFA_STATUS_OK
+                                                       : NFA_STATUS_FAILED;
+  } else {
+    retCode = switchRfInterface(NFA_INTERFACE_ISO_DEP) ? NFA_STATUS_OK
+                                                       : NFA_STATUS_FAILED;
+  }
 
 TheEnd:
-    ALOGV("%s: exit 0x%X", __func__, retCode);
-    return retCode;
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit 0x%X", __func__, retCode);
+  return retCode;
 }
-void setReconnectState(bool flag)
-{
-    sReconnectFlag = flag;
-    ALOGV("setReconnectState = 0x%x",sReconnectFlag );
+void setReconnectState(bool flag) {
+  sReconnectFlag = flag;
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("setReconnectState = 0x%x", sReconnectFlag);
 }
-bool getReconnectState(void)
-{
-    ALOGV("getReconnectState = 0x%x",sReconnectFlag );
-    return sReconnectFlag;
+bool getReconnectState(void) {
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("getReconnectState = 0x%x", sReconnectFlag);
+  return sReconnectFlag;
 }
 /*******************************************************************************
 **
@@ -944,286 +921,278 @@ bool getReconnectState(void)
 **                  146 (defined in service) on tag lost
 **
 *******************************************************************************/
-static int reSelect (tNFA_INTF_TYPE rfInterface, bool fSwitchIfNeeded)
-{
-    int handle          = sCurrentConnectedHandle;
-    int rVal            = 1;
-    tNFA_STATUS status  = NFA_STATUS_FAILED;
+static int reSelect(tNFA_INTF_TYPE rfInterface, bool fSwitchIfNeeded) {
+  int handle = sCurrentConnectedHandle;
+  int rVal = 1;
+  tNFA_STATUS status = NFA_STATUS_FAILED;
 
-    ALOGV("%s: enter; Requested RF Intf = 0x%0X, Current RF Intf = 0x%0X", __func__, rfInterface, sCurrentRfInterface);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: enter; Requested RF Intf = 0x%0X, Current RF Intf = 0x%0X", __func__,
+      rfInterface, sCurrentRfInterface);
 
-    sRfInterfaceMutex.lock ();
+  sRfInterfaceMutex.lock();
 
-    if (fSwitchIfNeeded && (rfInterface == sCurrentRfInterface))
-    {
-        sRfInterfaceMutex.unlock ();
-        return 0;
-    }
+  if (fSwitchIfNeeded && (rfInterface == sCurrentRfInterface)) {
+    sRfInterfaceMutex.unlock();
+    return 0;
+  }
 
-    NfcTag& natTag = NfcTag::getInstance ();
+  NfcTag& natTag = NfcTag::getInstance();
 
-#if(NFC_NXP_NON_STD_CARD == TRUE)
-    uint8_t retry_cnt = 1;
+#if (NFC_NXP_NON_STD_CARD == TRUE)
+  uint8_t retry_cnt = 1;
 #endif
 
-    do
-    {
-        /* if tag has shutdown, abort this method */
-        if (natTag.isNdefDetectionTimedOut())
-        {
-            ALOGV("%s: NDEF detection timeout; break", __func__);
-            rVal = STATUS_CODE_TARGET_LOST;
-            break;
-        }
+  do {
+    /* if tag has shutdown, abort this method */
+    if (natTag.isNdefDetectionTimedOut()) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: NDEF detection timeout; break", __func__);
+      rVal = STATUS_CODE_TARGET_LOST;
+      break;
+    }
 
 #if (NFC_NXP_NON_STD_CARD == TRUE)
-        if(!retry_cnt && (natTag.mTechLibNfcTypes[handle] != NFA_PROTOCOL_MIFARE))
-        {
-            ALOGV("%s: Cashbee detected", __func__);
-            natTag.mCashbeeDetected = true;
-        }
+    if (!retry_cnt &&
+        (natTag.mTechLibNfcTypes[handle] != NFC_PROTOCOL_MIFARE)) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: Cashbee detected", __func__);
+      natTag.mCashbeeDetected = true;
+    }
 #endif
 
-        {
-            SyncEventGuard guard1 (sReconnectEvent);
-            gIsTagDeactivating  = true;
-            sGotDeactivate      = false;
-            setReconnectState(false);
-            NFA_SetReconnectState(true);
+    {
+      SyncEventGuard guard1(sReconnectEvent);
+      gIsTagDeactivating = true;
+      sGotDeactivate = false;
+      setReconnectState(false);
+      NFA_SetReconnectState(true);
 
-            if ( natTag.isCashBeeActivated() == true || natTag.isEzLinkTagActivated() == true
+      if (natTag.isCashBeeActivated() == true ||
+          natTag.isEzLinkTagActivated() == true
 #if (NXP_EXTNS == TRUE && NFC_NXP_NON_STD_CARD == TRUE)
-                 || sNonNciCard_t.chinaTransp_Card == true
+          || sNonNciCard_t.chinaTransp_Card == true
 #endif
-            )
-            {
-                setReconnectState(true);
-                ALOGV("%s: Deactivate to IDLE", __func__);
-                if (NFA_STATUS_OK != (status = NFA_StopRfDiscovery ()))
-                {
-                    ALOGE("%s: Deactivate failed, status = 0x%0X", __func__, status);
-                    break;
-                }
-            }
-            else
-            {
-                ALOGV("%s: Deactivate to SLEEP", __func__);
-                if (NFA_STATUS_OK != (status = NFA_Deactivate (true)))
-                {
-                    ALOGE("%s: Deactivate failed, status = 0x%0X", __func__, status);
-                    break;
-                }
-#if(NXP_EXTNS == TRUE)
-                else if(natTag.mIsMultiProtocolTag)
-                {
-                    gIsWaiting4Deact2SleepNtf = true;
-                }
+      ) {
+        setReconnectState(true);
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: Deactivate to IDLE", __func__);
+        if (NFA_STATUS_OK != (status = NFA_StopRfDiscovery())) {
+          LOG(ERROR) << StringPrintf("%s: Deactivate failed, status = 0x%0X",
+                                     __func__, status);
+          break;
+        }
+      } else {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: Deactivate to SLEEP", __func__);
+        if (NFA_STATUS_OK != (status = NFA_Deactivate(true))) {
+          LOG(ERROR) << StringPrintf("%s: Deactivate failed, status = 0x%0X",
+                                     __func__, status);
+          break;
+        }
+#if (NXP_EXTNS == TRUE)
+        else if (natTag.mIsMultiProtocolTag) {
+          gIsWaiting4Deact2SleepNtf = true;
+        }
 #endif
-            }
+      }
 
-            if (sReconnectEvent.wait (1000) == false)
-            {
-                ALOGE("%s: Timeout waiting for deactivate", __func__);
-            }
-        }
+      if (sReconnectEvent.wait(1000) == false) {
+        LOG(ERROR) << StringPrintf("%s: Timeout waiting for deactivate",
+                                   __func__);
+      }
+    }
 
-#if(NXP_EXTNS == TRUE)
-        if(gIsWaiting4Deact2SleepNtf)
-        {
-            if (gGotDeact2IdleNtf)
-            {
-                ALOGE("%s: wrong deactivate ntf; break", __func__);
-                gIsWaiting4Deact2SleepNtf = false;
-                gGotDeact2IdleNtf = false;
-                rVal = STATUS_CODE_TARGET_LOST;
-                break;
-            }
-        }
+#if (NXP_EXTNS == TRUE)
+    if (gIsWaiting4Deact2SleepNtf) {
+      if (gGotDeact2IdleNtf) {
+        LOG(ERROR) << StringPrintf("%s: wrong deactivate ntf; break", __func__);
+        gIsWaiting4Deact2SleepNtf = false;
+        gGotDeact2IdleNtf = false;
+        rVal = STATUS_CODE_TARGET_LOST;
+        break;
+      }
+    }
 #endif
 
-        if(natTag.getActivationState() == NfcTag::Idle)
-        {
-            ALOGV("%s: Tag is in IDLE state", __func__);
-
-            if(natTag.mActivationParams_t.mTechLibNfcTypes == NFC_PROTOCOL_ISO_DEP)
-            {
-                if(natTag.mActivationParams_t.mTechParams == NFC_DISCOVERY_TYPE_POLL_A)
-                {
-                    natTag.mCashbeeDetected = true;
-                }
-                else if(natTag.mActivationParams_t.mTechParams == NFC_DISCOVERY_TYPE_POLL_B)
-                {
-                    natTag.mEzLinkTypeTag = true;
-                }
-            }
+    if (natTag.getActivationState() == NfcTag::Idle) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: Tag is in IDLE state", __func__);
+
+      if (natTag.mActivationParams_t.mTechLibNfcTypes == NFC_PROTOCOL_ISO_DEP) {
+        if (natTag.mActivationParams_t.mTechParams ==
+            NFC_DISCOVERY_TYPE_POLL_A) {
+          natTag.mCashbeeDetected = true;
+        } else if (natTag.mActivationParams_t.mTechParams ==
+                   NFC_DISCOVERY_TYPE_POLL_B) {
+          natTag.mEzLinkTypeTag = true;
         }
+      }
+    }
 
-        if ( !(natTag.isCashBeeActivated() == true || natTag.isEzLinkTagActivated() == true
-#if(NXP_EXTNS == TRUE && NFC_NXP_NON_STD_CARD == TRUE)
-           || sNonNciCard_t.chinaTransp_Card == true
-#endif
-        ) )
-        {
-            if (natTag.getActivationState () != NfcTag::Sleep)
-            {
-                ALOGV("%s: Tag is not in SLEEP", __func__);
-                rVal = STATUS_CODE_TARGET_LOST;
-#if(NFC_NXP_NON_STD_CARD == TRUE)
-                if(!retry_cnt)
+    if (!(natTag.isCashBeeActivated() == true ||
+          natTag.isEzLinkTagActivated() == true
+#if (NXP_EXTNS == TRUE && NFC_NXP_NON_STD_CARD == TRUE)
+          || sNonNciCard_t.chinaTransp_Card == true
 #endif
-                    break;
-#if(NFC_NXP_NON_STD_CARD == TRUE)
-                else
-                    continue;
+          )) {
+      if (natTag.getActivationState() != NfcTag::Sleep) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: Tag is not in SLEEP", __func__);
+        rVal = STATUS_CODE_TARGET_LOST;
+#if (NFC_NXP_NON_STD_CARD == TRUE)
+        if (!retry_cnt)
 #endif
-            }
-        }
+          break;
+#if (NFC_NXP_NON_STD_CARD == TRUE)
         else
-        {
-            setReconnectState(false);
-        }
+          continue;
+#endif
+      }
+    } else {
+      setReconnectState(false);
+    }
 
-        gIsTagDeactivating = false;
+    gIsTagDeactivating = false;
 
-        {
-            SyncEventGuard guard2 (sReconnectEvent);
-            gIsSelectingRfInterface     = true;
-            sConnectWaitingForComplete  = JNI_TRUE;
+    {
+      SyncEventGuard guard2(sReconnectEvent);
+      gIsSelectingRfInterface = true;
+      sConnectWaitingForComplete = JNI_TRUE;
 
-            if (natTag.isCashBeeActivated() == true || natTag.isEzLinkTagActivated() == true
-#if(NXP_EXTNS == TRUE && NFC_NXP_NON_STD_CARD == TRUE)
-               || sNonNciCard_t.chinaTransp_Card == true
-#endif
-            )
-            {
-                setReconnectState(true);
-                ALOGV("%s: Start RF discovery", __func__);
-                if (NFA_STATUS_OK != (status = NFA_StartRfDiscovery ()))
-                {
-                    ALOGE("%s: deactivate failed, status = 0x%0X", __func__, status);
-                    break;
-                }
-            }
-            else
-            {
-                ALOGV("%s: Select RF interface = 0x%0X", __func__, rfInterface);
-                if (NFA_STATUS_OK != (status = NFA_Select (natTag.mTechHandles[handle], natTag.mTechLibNfcTypes[handle], rfInterface)))
-                {
-                    ALOGE("%s: NFA_Select failed, status = 0x%0X", __func__, status);
-                    break;
-                }
-            }
-
-            sConnectOk = false;
-
-            if (sReconnectEvent.wait (1000) == false)
-            {
-                ALOGE("%s: timeout waiting for select", __func__);
-#if(NXP_EXTNS == TRUE)
-                if (!(natTag.isCashBeeActivated() == true || natTag.isEzLinkTagActivated() == true
-        #if(NFC_NXP_NON_STD_CARD == TRUE)
-                   || sNonNciCard_t.chinaTransp_Card == true
-        #endif
-                ))
-                {
-                    status = NFA_Deactivate (false);
-                    if (status != NFA_STATUS_OK)
-                        ALOGE("%s: deactivate failed; error status = 0x%X", __func__, status);
-                }
-                break;
+      if (natTag.isCashBeeActivated() == true ||
+          natTag.isEzLinkTagActivated() == true
+#if (NXP_EXTNS == TRUE && NFC_NXP_NON_STD_CARD == TRUE)
+          || sNonNciCard_t.chinaTransp_Card == true
 #endif
-            }
+      ) {
+        setReconnectState(true);
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: Start RF discovery", __func__);
+        if (NFA_STATUS_OK != (status = NFA_StartRfDiscovery())) {
+          LOG(ERROR) << StringPrintf("%s: deactivate failed, status = 0x%0X",
+                                     __func__, status);
+          break;
         }
+      } else {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: Select RF interface = 0x%0X", __func__, rfInterface);
+        if (NFA_STATUS_OK !=
+            (status =
+                 NFA_Select(natTag.mTechHandles[handle],
+                            natTag.mTechLibNfcTypes[handle], rfInterface))) {
+          LOG(ERROR) << StringPrintf("%s: NFA_Select failed, status = 0x%0X",
+                                     __func__, status);
+          break;
+        }
+      }
 
-        ALOGV("%s: Select completed; sConnectOk = 0x%0X", __func__, sConnectOk);
+      sConnectOk = false;
 
-        if (natTag.getActivationState () != NfcTag::Active)
-        {
-            ALOGV("%s: Tag is not Active", __func__);
-            rVal = STATUS_CODE_TARGET_LOST;
-#if(NFC_NXP_NON_STD_CARD == TRUE)
-            if(!retry_cnt)
+      if (sReconnectEvent.wait(1000) == false) {
+        LOG(ERROR) << StringPrintf("%s: timeout waiting for select", __func__);
+#if (NXP_EXTNS == TRUE)
+        if (!(natTag.isCashBeeActivated() == true ||
+              natTag.isEzLinkTagActivated() == true
+#if (NFC_NXP_NON_STD_CARD == TRUE)
+              || sNonNciCard_t.chinaTransp_Card == true
 #endif
-            break;
-        }
-        if(natTag.isEzLinkTagActivated() == true)
-        {
-            natTag.mEzLinkTypeTag = false;
-        }
-#if(NFC_NXP_NON_STD_CARD == TRUE)
-        if(natTag.isCashBeeActivated() == true)
-        {
-            natTag.mCashbeeDetected = false;
+              )) {
+          status = NFA_Deactivate(false);
+          if (status != NFA_STATUS_OK)
+            LOG(ERROR) << StringPrintf(
+                "%s: deactivate failed; error status = 0x%X", __func__, status);
         }
+        break;
 #endif
-        if (sConnectOk)
-        {
-            rVal = 0;
-            sCurrentRfInterface = rfInterface;
-#if(NFC_NXP_NON_STD_CARD == TRUE)
-            break;
+      }
+    }
+
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: Select completed; sConnectOk = 0x%0X", __func__, sConnectOk);
+
+    if (natTag.getActivationState() != NfcTag::Active) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: Tag is not Active", __func__);
+      rVal = STATUS_CODE_TARGET_LOST;
+#if (NFC_NXP_NON_STD_CARD == TRUE)
+      if (!retry_cnt)
 #endif
-        }
-        else
-        {
-            rVal = 1;
-        }
+        break;
+    }
+    if (natTag.isEzLinkTagActivated() == true) {
+      natTag.mEzLinkTypeTag = false;
+    }
+#if (NFC_NXP_NON_STD_CARD == TRUE)
+    if (natTag.isCashBeeActivated() == true) {
+      natTag.mCashbeeDetected = false;
     }
-#if(NFC_NXP_NON_STD_CARD == TRUE)
-    while (retry_cnt--);
-#else
-    while(0);
 #endif
-    setReconnectState(false);
-    NFA_SetReconnectState(false);
-    sConnectWaitingForComplete  = JNI_FALSE;
-    gIsTagDeactivating          = false;
-    gIsSelectingRfInterface     = false;
-    sRfInterfaceMutex.unlock ();
-    ALOGV("%s: exit rVal = 0x%0X", __func__, rVal);
-    return rVal;
-}
-
-/*******************************************************************************
+    if (sConnectOk) {
+      rVal = 0;
+      sCurrentRfInterface = rfInterface;
+#if (NFC_NXP_NON_STD_CARD == TRUE)
+      break;
+#endif
+    } else {
+      rVal = 1;
+    }
+  }
+#if (NFC_NXP_NON_STD_CARD == TRUE)
+  while (retry_cnt--);
+#else
+  while (0);
+#endif
+  setReconnectState(false);
+  NFA_SetReconnectState(false);
+  sConnectWaitingForComplete = JNI_FALSE;
+  gIsTagDeactivating = false;
+  gIsSelectingRfInterface = false;
+  sRfInterfaceMutex.unlock();
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit rVal = 0x%0X", __func__, rVal);
+  return rVal;
+}
+
+/*******************************************************************************
 **
 ** Function:        switchRfInterface
 **
-** Description:     Switch controller's RF interface to frame, ISO-DEP, or NFC-DEP.
+** Description:     Switch controller's RF interface to frame, ISO-DEP, or
+*NFC-DEP.
 **                  rfInterface: Type of RF interface.
 **
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-static bool switchRfInterface (tNFA_INTF_TYPE rfInterface)
-{
-    ALOGV("%s: rf intf = %d", __func__, rfInterface);
-
-    if (sCurrentConnectedTargetProtocol != NFC_PROTOCOL_ISO_DEP)
-    {
-        ALOGV("%s: protocol: %d not ISO_DEP, do nothing", __func__, sCurrentConnectedTargetProtocol);
-        return true;
-    }
+static bool switchRfInterface(tNFA_INTF_TYPE rfInterface) {
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: rf intf = %d", __func__, rfInterface);
+
+  if (sCurrentConnectedTargetProtocol != NFC_PROTOCOL_ISO_DEP) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: protocol: %d not ISO_DEP, do nothing", __func__,
+                        sCurrentConnectedTargetProtocol);
+    return true;
+  }
 
-    ALOGV("%s: new rf intf = %d, cur rf intf = %d", __func__, rfInterface, sCurrentRfInterface);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: new rf intf = %d, cur rf intf = %d", __func__,
+                      rfInterface, sCurrentRfInterface);
 
-    bool rVal = true;
-    if (rfInterface != sCurrentRfInterface)
-    {
-        if (0 == reSelect(rfInterface, true))
-        {
-            sCurrentRfInterface = rfInterface;
-            rVal = true;
-        }
-        else
-        {
-            rVal = false;
-        }
+  bool rVal = true;
+  if (rfInterface != sCurrentRfInterface) {
+    if (0 == reSelect(rfInterface, true)) {
+      sCurrentRfInterface = rfInterface;
+      rVal = true;
+    } else {
+      rVal = false;
     }
+  }
 
-    return rVal;
+  return rVal;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeNfcTag_doReconnect
@@ -1235,149 +1204,148 @@ static bool switchRfInterface (tNFA_INTF_TYPE rfInterface)
 ** Returns:         Status code.
 **
 *******************************************************************************/
-static jint nativeNfcTag_doReconnect (JNIEnv*, jobject)
-{
-    ALOGV("%s: enter", __func__);
-    int retCode = NFCSTATUS_SUCCESS;
-    NfcTag& natTag = NfcTag::getInstance ();
-    int handle = sCurrentConnectedHandle;
-
-    uint8_t* uid;
-    uint32_t uid_len;
-    tNFC_STATUS stat;
-    ALOGV("%s: enter; handle=%x", __func__, handle);
-    natTag.getTypeATagUID(&uid,&uid_len);
-
-    if(natTag.mNfcDisableinProgress)
-    {
-        ALOGE("%s: NFC disabling in progress", __func__);
-        retCode = NFCSTATUS_FAILED;
-        goto TheEnd;
-    }
-
-    if (natTag.getActivationState() != NfcTag::Active)
-    {
-        ALOGE("%s: tag already deactivated", __func__);
-        retCode = NFCSTATUS_FAILED;
+static jint nativeNfcTag_doReconnect(JNIEnv*, jobject) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+  int retCode = NFCSTATUS_SUCCESS;
+  NfcTag& natTag = NfcTag::getInstance();
+  int handle = sCurrentConnectedHandle;
+
+  uint8_t* uid;
+  uint32_t uid_len;
+  tNFC_STATUS stat;
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter; handle=%x", __func__, handle);
+  natTag.getTypeATagUID(&uid, &uid_len);
+
+  if (natTag.mNfcDisableinProgress) {
+    LOG(ERROR) << StringPrintf("%s: NFC disabling in progress", __func__);
+    retCode = NFCSTATUS_FAILED;
+    goto TheEnd;
+  }
+
+  if (natTag.getActivationState() != NfcTag::Active) {
+    LOG(ERROR) << StringPrintf("%s: tag already deactivated", __func__);
+    retCode = NFCSTATUS_FAILED;
+    goto TheEnd;
+  }
+
+  // special case for Kovio
+  if (sCurrentConnectedTargetType == TARGET_TYPE_KOVIO_BARCODE) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: fake out reconnect for Kovio", __func__);
+    goto TheEnd;
+  }
+
+  if (natTag.isNdefDetectionTimedOut()) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: ndef detection timeout", __func__);
+    retCode = STATUS_CODE_TARGET_LOST;
+    goto TheEnd;
+  }
+
+  // special case for TypeB and TypeA random UID
+  if ((sCurrentRfInterface != NCI_INTERFACE_FRAME) &&
+      ((natTag.mTechLibNfcTypes[handle] == NFA_PROTOCOL_ISO_DEP &&
+        true == natTag.isTypeBTag()) ||
+       (NfcTag::getInstance().mTechLibNfcTypes[handle] ==
+            NFA_PROTOCOL_ISO_DEP &&
+        uid_len > 0 && uid[0] == 0x08))) {
+    if (NFA_GetNCIVersion() != NCI_VERSION_2_0) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: reconnect for TypeB / TypeA random uid", __func__);
+      sReconnectNtfTimer.set(500, sReconnectTimerProc);
+
+      tNFC_STATUS stat = NFA_RegVSCback(
+          true, nfaVSCNtfCallback);  // Register CallBack for VS NTF
+      if (NFA_STATUS_OK != stat) {
+        retCode = 0x01;
         goto TheEnd;
-    }
+      }
+
+      {
+        SyncEventGuard guard(sNfaVSCResponseEvent);
+        stat = NFA_SendVsCommand(0x11, 0x00, NULL, nfaVSCCallback);
+        if (NFA_STATUS_OK == stat) {
+          sIsReconnecting = true;
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "%s: reconnect for TypeB - wait for NFA VS command to finish",
+              __func__);
+          sNfaVSCResponseEvent.wait();  // wait for NFA VS command to finish
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("%s: reconnect for TypeB - Got RSP", __func__);
+        }
+      }
 
-    // special case for Kovio
-    if (sCurrentConnectedTargetType == TARGET_TYPE_KOVIO_BARCODE)
-    {
-        ALOGV("%s: fake out reconnect for Kovio", __func__);
-        goto TheEnd;
-    }
+      if (false == sVSCRsp) {
+        retCode = 0x01;
+        sIsReconnecting = false;
+      } else {
+        {
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "%s: reconnect for TypeB - wait for NFA VS NTF to come",
+              __func__);
+          SyncEventGuard guard(sNfaVSCNotificationEvent);
+          sNfaVSCNotificationEvent.wait();  // wait for NFA VS NTF to come
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "%s: reconnect for TypeB - GOT NFA VS NTF", __func__);
+          sReconnectNtfTimer.kill();
+          sIsReconnecting = false;
+        }
 
-    if (natTag.isNdefDetectionTimedOut())
-    {
-        ALOGV("%s: ndef detection timeout", __func__);
-        retCode = STATUS_CODE_TARGET_LOST;
-        goto TheEnd;
-    }
+        if (false == sIsTagInField) {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("%s: NxpNci: TAG OUT OF FIELD", __func__);
+          retCode = STATUS_CODE_TARGET_LOST;
+
+          SyncEventGuard g(gDeactivatedEvent);
+
+          // Tag not present, deactivate the TAG.
+          stat = NFA_Deactivate(false);
+          if (stat == NFA_STATUS_OK) {
+            gDeactivatedEvent.wait();
+          } else {
+            LOG(ERROR) << StringPrintf("%s: deactivate failed; error=0x%X",
+                                       __func__, stat);
+          }
+        }
 
-    //special case for TypeB and TypeA random UID
-    if ( (sCurrentRfInterface != NCI_INTERFACE_FRAME) &&
-            ((natTag.mTechLibNfcTypes[handle] == NFA_PROTOCOL_ISO_DEP &&
-            true == natTag.isTypeBTag() ) ||
-            ( NfcTag::getInstance ().mTechLibNfcTypes[handle] == NFA_PROTOCOL_ISO_DEP &&
-                    uid_len > 0 && uid[0] == 0x08))
-         )
-    {
-        if(NFA_GetNCIVersion() != NCI_VERSION_2_0)
-		{
-            ALOGV("%s: reconnect for TypeB / TypeA random uid", __func__);
-            sReconnectNtfTimer.set(500, sReconnectTimerProc);
-
-            tNFC_STATUS stat = NFA_RegVSCback (true,nfaVSCNtfCallback); //Register CallBack for VS NTF
-            if(NFA_STATUS_OK != stat)
-            {
-                retCode = 0x01;
-                goto TheEnd;
-            }
-
-            SyncEventGuard guard (sNfaVSCResponseEvent);
-            stat = NFA_SendVsCommand (0x11,0x00,NULL,nfaVSCCallback);
-            if(NFA_STATUS_OK == stat)
-            {
-                sIsReconnecting = true;
-                ALOGV("%s: reconnect for TypeB - wait for NFA VS command to finish", __func__);
-                sNfaVSCResponseEvent.wait(); //wait for NFA VS command to finish
-                ALOGV("%s: reconnect for TypeB - Got RSP", __func__);
-            }
-
-            if(false == sVSCRsp)
-            {
-                retCode = 0x01;
-                sIsReconnecting = false;
-            }
-            else
-            {
-                {
-                    ALOGV("%s: reconnect for TypeB - wait for NFA VS NTF to come", __func__);
-                    SyncEventGuard guard (sNfaVSCNotificationEvent);
-                    sNfaVSCNotificationEvent.wait(); //wait for NFA VS NTF to come
-                    ALOGV("%s: reconnect for TypeB - GOT NFA VS NTF", __func__);
-                    sReconnectNtfTimer.kill();
-                    sIsReconnecting = false;
-                }
-
-                if(false == sIsTagInField)
-                {
-                    ALOGV("%s: NxpNci: TAG OUT OF FIELD", __func__);
-                    retCode = STATUS_CODE_TARGET_LOST;
-
-                    SyncEventGuard g (gDeactivatedEvent);
-
-                    //Tag not present, deactivate the TAG.
-                    stat = NFA_Deactivate (false);
-                    if (stat == NFA_STATUS_OK)
-                    {
-                        gDeactivatedEvent.wait ();
-                    }
-                    else
-                    {
-                        ALOGE("%s: deactivate failed; error=0x%X", __func__, stat);
-                    }
-                }
-
-                else
-                {
-                    retCode = 0x00;
-                }
-            }
-
-            stat = NFA_RegVSCback (false,nfaVSCNtfCallback); //DeRegister CallBack for VS NTF
-            if(NFA_STATUS_OK != stat)
-            {
-                retCode = 0x01;
-            }
-            ALOGV("%s: reconnect for TypeB - return", __func__);
-        }else{
-                SyncEventGuard guard (sPresenceCheckEvent);
-                stat = NFA_RwPresenceCheck (NfcTag::getInstance().getPresenceCheckAlgorithm());
-                if (stat == NFA_STATUS_OK)
-                {
-                    sPresenceCheckEvent.wait ();
-                    retCode = sIsTagPresent ? NCI_STATUS_OK : NCI_STATUS_FAILED;
-                }
+        else {
+          retCode = 0x00;
         }
-        goto TheEnd;
-    }
-     // this is only supported for type 2 or 4 (ISO_DEP) tags
-    if (sCurrentConnectedTargetProtocol == NFA_PROTOCOL_ISO_DEP)
-        retCode = reSelect(NFA_INTERFACE_ISO_DEP, false);
-    else if (sCurrentConnectedTargetProtocol == NFA_PROTOCOL_T2T)
-        retCode = reSelect(NFA_INTERFACE_FRAME, false);
-    else if (sCurrentConnectedTargetProtocol == NFA_PROTOCOL_MIFARE)
-        retCode = reSelect(NFA_INTERFACE_MIFARE, false);
+      }
+
+      stat = NFA_RegVSCback(
+          false, nfaVSCNtfCallback);  // DeRegister CallBack for VS NTF
+      if (NFA_STATUS_OK != stat) {
+        retCode = 0x01;
+      }
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: reconnect for TypeB - return", __func__);
+    } else {
+      SyncEventGuard guard(sPresenceCheckEvent);
+      stat = NFA_RwPresenceCheck(
+          NfcTag::getInstance().getPresenceCheckAlgorithm());
+      if (stat == NFA_STATUS_OK) {
+        sPresenceCheckEvent.wait();
+        retCode = sIsTagPresent ? NCI_STATUS_OK : NCI_STATUS_FAILED;
+      }
+    }
+    goto TheEnd;
+  }
+  // this is only supported for type 2 or 4 (ISO_DEP) tags
+  if (sCurrentConnectedTargetProtocol == NFA_PROTOCOL_ISO_DEP)
+    retCode = reSelect(NFA_INTERFACE_ISO_DEP, false);
+  else if (sCurrentConnectedTargetProtocol == NFA_PROTOCOL_T2T)
+    retCode = reSelect(NFA_INTERFACE_FRAME, false);
+  else if (sCurrentConnectedTargetProtocol == NFC_PROTOCOL_MIFARE)
+    retCode = reSelect(NFA_INTERFACE_MIFARE, false);
 
 TheEnd:
-    ALOGV("%s: exit 0x%X", __func__, retCode);
-    return retCode;
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit 0x%X", __func__, retCode);
+  return retCode;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeNfcTag_doHandleReconnect
@@ -1390,15 +1358,15 @@ TheEnd:
 ** Returns:         Status code.
 **
 *******************************************************************************/
-static jint nativeNfcTag_doHandleReconnect (JNIEnv *e, jobject o, jint targetHandle)
-{
-    ALOGV("%s: targetHandle = %d", __func__, targetHandle);
-    if(NfcTag::getInstance ().mNfcDisableinProgress)
-        return STATUS_CODE_TARGET_LOST;
-    return nativeNfcTag_doConnect (e, o, targetHandle);
+static jint nativeNfcTag_doHandleReconnect(JNIEnv* e, jobject o,
+                                           jint targetHandle) {
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: targetHandle = %d", __func__, targetHandle);
+  if (NfcTag::getInstance().mNfcDisableinProgress)
+    return STATUS_CODE_TARGET_LOST;
+  return nativeNfcTag_doConnect(e, o, targetHandle);
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeNfcTag_doDisconnect
@@ -1410,35 +1378,33 @@ static jint nativeNfcTag_doHandleReconnect (JNIEnv *e, jobject o, jint targetHan
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-static jboolean nativeNfcTag_doDisconnect (JNIEnv*, jobject)
-{
-    ALOGV("%s: enter", __func__);
-    tNFA_STATUS nfaStat = NFA_STATUS_OK;
-
-    NfcTag::getInstance().resetAllTransceiveTimeouts ();
-#if(NXP_EXTNS == TRUE && NFC_NXP_NON_STD_CARD == TRUE)
-    if(sNonNciCard_t.Changan_Card == true || sNonNciCard_t.chinaTransp_Card == true)
-    {
-        memset(&sNonNciCard_t,0,sizeof(sNonNciCard));
-        scoreGenericNtf = false;
-    }
+jboolean nativeNfcTag_doDisconnect(JNIEnv*, jobject) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+  tNFA_STATUS nfaStat = NFA_STATUS_OK;
+
+  NfcTag::getInstance().resetAllTransceiveTimeouts();
+#if (NXP_EXTNS == TRUE && NFC_NXP_NON_STD_CARD == TRUE)
+  if (sNonNciCard_t.Changan_Card == true ||
+      sNonNciCard_t.chinaTransp_Card == true) {
+    memset(&sNonNciCard_t, 0, sizeof(sNonNciCard));
+    scoreGenericNtf = false;
+  }
 #endif
-    if (NfcTag::getInstance ().getActivationState () != NfcTag::Active)
-    {
-        ALOGE("%s: tag already deactivated", __func__);
-        goto TheEnd;
-    }
+  if (NfcTag::getInstance().getActivationState() != NfcTag::Active) {
+    LOG(ERROR) << StringPrintf("%s: tag already deactivated", __func__);
+    goto TheEnd;
+  }
 
-    nfaStat = NFA_Deactivate (false);
-    if (nfaStat != NFA_STATUS_OK)
-        ALOGE("%s: deactivate failed; error=0x%X", __func__, nfaStat);
+  nfaStat = NFA_Deactivate(false);
+  if (nfaStat != NFA_STATUS_OK)
+    LOG(ERROR) << StringPrintf("%s: deactivate failed; error=0x%X", __func__,
+                               nfaStat);
 
 TheEnd:
-    ALOGV("%s: exit", __func__);
-    return (nfaStat == NFA_STATUS_OK) ? JNI_TRUE : JNI_FALSE;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  return (nfaStat == NFA_STATUS_OK) ? JNI_TRUE : JNI_FALSE;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeNfcTag_doTransceiveStatus
@@ -1451,47 +1417,42 @@ TheEnd:
 ** Returns:         None
 **
 *******************************************************************************/
-void nativeNfcTag_doTransceiveStatus (tNFA_STATUS status, uint8_t* buf, uint32_t bufLen)
-{
-    SyncEventGuard g (sTransceiveEvent);
-    ALOGV("%s: data len=%d, cur connection handle =%d", __func__, bufLen, sCurrentConnectedHandle);
-
-    if (sCurrentConnectedTargetProtocol == NFA_PROTOCOL_MIFARE)
-    {
-       if (EXTNS_GetCallBackFlag () == false)
-       {
-           EXTNS_MfcCallBack (buf, bufLen);
-           return;
-       }
-    }
-
-    if (!sWaitingForTransceive)
-    {
-        ALOGE("%s: drop data", __func__);
-        return;
-    }
-    sRxDataStatus = status;
-    if (sRxDataStatus == NFA_STATUS_OK || sRxDataStatus == NFA_STATUS_CONTINUE)
-        sRxDataBuffer.append (buf, bufLen);
-
-    if (sRxDataStatus == NFA_STATUS_OK)
-        sTransceiveEvent.notifyOne ();
+void nativeNfcTag_doTransceiveStatus(tNFA_STATUS status, uint8_t* buf,
+                                     uint32_t bufLen) {
+  SyncEventGuard g(sTransceiveEvent);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: data len=%d, cur connection handle =%d", __func__,
+                      bufLen, sCurrentConnectedHandle);
+
+  if (sCurrentConnectedTargetProtocol == NFC_PROTOCOL_MIFARE) {
+    if (EXTNS_GetCallBackFlag() == false) {
+      EXTNS_MfcCallBack(buf, bufLen);
+      return;
+    }
+  }
+
+  if (!sWaitingForTransceive) {
+    LOG(ERROR) << StringPrintf("%s: drop data", __func__);
+    return;
+  }
+  sRxDataStatus = status;
+  if (sRxDataStatus == NFA_STATUS_OK || sRxDataStatus == NFC_STATUS_CONTINUE)
+    sRxDataBuffer.append(buf, bufLen);
+
+  if (sRxDataStatus == NFA_STATUS_OK) sTransceiveEvent.notifyOne();
 }
 
+void nativeNfcTag_notifyRfTimeout() {
+  SyncEventGuard g(sTransceiveEvent);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: waiting for transceive: %d", __func__, sWaitingForTransceive);
+  if (!sWaitingForTransceive) return;
 
-void nativeNfcTag_notifyRfTimeout ()
-{
-    SyncEventGuard g (sTransceiveEvent);
-    ALOGV("%s: waiting for transceive: %d", __func__, sWaitingForTransceive);
-    if (!sWaitingForTransceive)
-        return;
-
-    sTransceiveRfTimeout = true;
+  sTransceiveRfTimeout = true;
 
-    sTransceiveEvent.notifyOne ();
+  sTransceiveEvent.notifyOne();
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeNfcTag_doTransceive
@@ -1505,180 +1466,161 @@ void nativeNfcTag_notifyRfTimeout ()
 ** Returns:         Response from tag.
 **
 *******************************************************************************/
-static jbyteArray nativeNfcTag_doTransceive (JNIEnv* e, jobject o, jbyteArray data, jboolean raw, jintArray statusTargetLost)
-{
-    int timeout = NfcTag::getInstance ().getTransceiveTimeout (sCurrentConnectedTargetType);
-    ALOGV("%s: enter; raw=%u; timeout = %d", __func__, raw, timeout);
-
-    bool waitOk = false;
-    bool isNack = false;
-    jint *targetLost = NULL;
-    tNFA_STATUS status;
-#if(NXP_EXTNS == TRUE && NFC_NXP_NON_STD_CARD == TRUE)
-    bool fNeedToSwitchBack = false;
+static jbyteArray nativeNfcTag_doTransceive(JNIEnv* e, jobject o,
+                                            jbyteArray data, jboolean raw,
+                                            jintArray statusTargetLost) {
+  int timeout =
+      NfcTag::getInstance().getTransceiveTimeout(sCurrentConnectedTargetType);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: enter; raw=%u; timeout = %d", __func__, raw, timeout);
+
+  bool waitOk = false;
+  bool isNack = false;
+  jint* targetLost = NULL;
+  tNFA_STATUS status;
+#if (NXP_EXTNS == TRUE && NFC_NXP_NON_STD_CARD == TRUE)
+  bool fNeedToSwitchBack = false;
 #endif
-    if (sCurrentConnectedTargetProtocol == NFA_PROTOCOL_MIFARE)
-    {
-        if( doReconnectFlag == 0)
-        {
-            int retCode = NFCSTATUS_SUCCESS;
-            retCode = nativeNfcTag_doReconnect (e, o);
-            doReconnectFlag = 0x01;
-        }
+  if (sCurrentConnectedTargetProtocol == NFC_PROTOCOL_MIFARE) {
+    if (doReconnectFlag == 0) {
+      int retCode = NFCSTATUS_SUCCESS;
+      retCode = nativeNfcTag_doReconnect(e, o);
+      doReconnectFlag = 0x01;
+    }
+  }
+
+  if (NfcTag::getInstance().getActivationState() != NfcTag::Active) {
+    if (statusTargetLost) {
+      targetLost = e->GetIntArrayElements(statusTargetLost, 0);
+      if (targetLost)
+        *targetLost = 1;  // causes NFC service to throw TagLostException
+      e->ReleaseIntArrayElements(statusTargetLost, targetLost, 0);
+    }
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: tag not active", __func__);
+    return NULL;
+  }
+
+  NfcTag& natTag = NfcTag::getInstance();
+
+  // get input buffer and length from java call
+  ScopedByteArrayRO bytes(e, data);
+  uint8_t* buf = const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(
+      &bytes[0]));  // TODO: API bug; NFA_SendRawFrame should take const*!
+  size_t bufLen = bytes.size();
+
+  if (statusTargetLost) {
+    targetLost = e->GetIntArrayElements(statusTargetLost, 0);
+    if (targetLost) *targetLost = 0;  // success, tag is still present
+  }
+
+  sSwitchBackTimer.kill();
+  ScopedLocalRef<jbyteArray> result(e, NULL);
+  do {
+#if (NXP_EXTNS == TRUE && NFC_NXP_NON_STD_CARD == TRUE)
+    if (sNeedToSwitchRf) {
+      if (!switchRfInterface(NFA_INTERFACE_FRAME))  // NFA_INTERFACE_ISO_DEP
+      {
+        break;
+      }
+      fNeedToSwitchBack = true;
     }
-
-    if (NfcTag::getInstance ().getActivationState () != NfcTag::Active)
+#endif
     {
-        if (statusTargetLost)
-        {
-            targetLost = e->GetIntArrayElements (statusTargetLost, 0);
-            if (targetLost)
-                *targetLost = 1; //causes NFC service to throw TagLostException
-            e->ReleaseIntArrayElements (statusTargetLost, targetLost, 0);
-        }
-        ALOGV("%s: tag not active", __func__);
-        return NULL;
+      SyncEventGuard g(sTransceiveEvent);
+      sTransceiveRfTimeout = false;
+      sWaitingForTransceive = true;
+      sRxDataStatus = NFA_STATUS_OK;
+      sRxDataBuffer.clear();
+      if (sCurrentConnectedTargetProtocol == NFC_PROTOCOL_MIFARE) {
+        status = EXTNS_MfcTransceive(buf, bufLen);
+      } else {
+        status = NFA_SendRawFrame(buf, bufLen,
+                                  NFA_DM_DEFAULT_PRESENCE_CHECK_START_DELAY);
+      }
+
+      if (status != NFA_STATUS_OK) {
+        LOG(ERROR) << StringPrintf("%s: fail send; error=%d", __func__, status);
+        break;
+      }
+      waitOk = sTransceiveEvent.wait(timeout);
     }
 
-    NfcTag& natTag = NfcTag::getInstance ();
-
-    // get input buffer and length from java call
-    ScopedByteArrayRO bytes(e, data);
-    uint8_t* buf = const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0])); // TODO: API bug; NFA_SendRawFrame should take const*!
-    size_t bufLen = bytes.size();
-
-    if (statusTargetLost)
+    if (waitOk == false || sTransceiveRfTimeout)  // if timeout occurred
     {
-        targetLost = e->GetIntArrayElements (statusTargetLost, 0);
-        if (targetLost)
-            *targetLost = 0; //success, tag is still present
+      LOG(ERROR) << StringPrintf("%s: wait response timeout", __func__);
+      if (targetLost)
+        *targetLost = 1;  // causes NFC service to throw TagLostException
+      break;
     }
 
-    sSwitchBackTimer.kill ();
-    ScopedLocalRef<jbyteArray> result(e, NULL);
-    do
-    {
-#if(NXP_EXTNS == TRUE && NFC_NXP_NON_STD_CARD == TRUE)
-        if (sNeedToSwitchRf)
-        {
-            if (!switchRfInterface (NFA_INTERFACE_FRAME)) //NFA_INTERFACE_ISO_DEP
-            {
-                break;
-            }
-            fNeedToSwitchBack = true;
-        }
-#endif
-        {
-            SyncEventGuard g (sTransceiveEvent);
-            sTransceiveRfTimeout = false;
-            sWaitingForTransceive = true;
-            sRxDataStatus = NFA_STATUS_OK;
-            sRxDataBuffer.clear ();
-            if (sCurrentConnectedTargetProtocol == NFA_PROTOCOL_MIFARE)
-            {
-                status = EXTNS_MfcTransceive (buf, bufLen);
-            }
-            else
-            {
-                status = NFA_SendRawFrame (buf, bufLen,
-                        NFA_DM_DEFAULT_PRESENCE_CHECK_START_DELAY);
-            }
-
-            if (status != NFA_STATUS_OK)
-            {
-                ALOGE("%s: fail send; error=%d", __func__, status);
-                break;
-            }
-            waitOk = sTransceiveEvent.wait (timeout);
-        }
+    if (NfcTag::getInstance().getActivationState() != NfcTag::Active) {
+      LOG(ERROR) << StringPrintf("%s: already deactivated", __func__);
+      if (targetLost)
+        *targetLost = 1;  // causes NFC service to throw TagLostException
+      break;
+    }
 
-        if (waitOk == false || sTransceiveRfTimeout) //if timeout occurred
-        {
-            ALOGE("%s: wait response timeout", __func__);
-            if (targetLost)
-                *targetLost = 1; //causes NFC service to throw TagLostException
-            break;
-        }
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: response %zu bytes", __func__, sRxDataBuffer.size());
 
-        if (NfcTag::getInstance ().getActivationState () != NfcTag::Active)
-        {
-            ALOGE("%s: already deactivated", __func__);
-            if (targetLost)
-                *targetLost = 1; //causes NFC service to throw TagLostException
-            break;
-        }
-
-        ALOGV("%s: response %zu bytes", __func__, sRxDataBuffer.size());
+    if ((natTag.getProtocol() == NFA_PROTOCOL_T2T) &&
+        natTag.isT2tNackResponse(sRxDataBuffer.data(), sRxDataBuffer.size())) {
+      isNack = true;
+    }
 
-        if ((natTag.getProtocol () == NFA_PROTOCOL_T2T) &&
-            natTag.isT2tNackResponse (sRxDataBuffer.data(), sRxDataBuffer.size()))
-        {
-            isNack = true;
+    if (sRxDataBuffer.size() > 0) {
+      if (isNack) {
+        // Some Mifare Ultralight C tags enter the HALT state after it
+        // responds with a NACK.  Need to perform a "reconnect" operation
+        // to wake it.
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: try reconnect", __func__);
+        nativeNfcTag_doReconnect(NULL, NULL);
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: reconnect finish", __func__);
+      } else if (sCurrentConnectedTargetProtocol == NFC_PROTOCOL_MIFARE) {
+        uint32_t transDataLen = sRxDataBuffer.size();
+        uint8_t* transData = (uint8_t*)sRxDataBuffer.data();
+        if (EXTNS_CheckMfcResponse(&transData, &transDataLen) ==
+            NFCSTATUS_FAILED) {
+          nativeNfcTag_doReconnect(e, o);
         }
-
-        if (sRxDataBuffer.size() > 0)
-        {
-            if (isNack)
-            {
-                //Some Mifare Ultralight C tags enter the HALT state after it
-                //responds with a NACK.  Need to perform a "reconnect" operation
-                //to wake it.
-                ALOGV("%s: try reconnect", __func__);
-                nativeNfcTag_doReconnect (NULL, NULL);
-                ALOGV("%s: reconnect finish", __func__);
-            }
-            else if (sCurrentConnectedTargetProtocol == NFA_PROTOCOL_MIFARE)
-            {
-                uint32_t transDataLen = sRxDataBuffer.size ();
-                uint8_t *transData = (uint8_t *)sRxDataBuffer.data ();
-                if (EXTNS_CheckMfcResponse (&transData, &transDataLen) == NFCSTATUS_FAILED)
-                {
-                    nativeNfcTag_doReconnect (e, o);
-                }
-                else
-                {
-                    if (transDataLen != 0)
-                    {
-                        result.reset (e->NewByteArray(transDataLen));
-                    }
-                    if (result.get () != NULL)
-                    {
-                        e->SetByteArrayRegion (result.get (), 0, transDataLen, (const jbyte *) transData);
-                    }
-                    else
-                        ALOGE("%s: Failed to allocate java byte array", __func__);
-                }
-            }
-            else
-            {
-                // marshall data to java for return
-                result.reset(e->NewByteArray(sRxDataBuffer.size()));
-                if (result.get() != NULL)
-                {
-                    e->SetByteArrayRegion(result.get(), 0, sRxDataBuffer.size(), (const jbyte *) sRxDataBuffer.data());
-                }
-                else
-                    ALOGE("%s: Failed to allocate java byte array", __func__);
-            } // else a nack is treated as a transceive failure to the upper layers
-
-            sRxDataBuffer.clear();
+        if (transDataLen != 0) {
+          result.reset(e->NewByteArray(transDataLen));
+          if (result.get() != NULL) {
+            e->SetByteArrayRegion(result.get(), 0, transDataLen,
+                                  (const jbyte*)transData);
+          } else
+            LOG(ERROR) << StringPrintf("%s: Failed to allocate java byte array",
+                                       __func__);
         }
-    } while (0);
-
-    sWaitingForTransceive = false;
-    if (targetLost)
-        e->ReleaseIntArrayElements (statusTargetLost, targetLost, 0);
-#if(NXP_EXTNS == TRUE && NFC_NXP_NON_STD_CARD == TRUE)
-    if (fNeedToSwitchBack)
-    {
-        sSwitchBackTimer.set (1500, switchBackTimerProc);
-    }
+      } else {
+        // marshall data to java for return
+        result.reset(e->NewByteArray(sRxDataBuffer.size()));
+        if (result.get() != NULL) {
+          e->SetByteArrayRegion(result.get(), 0, sRxDataBuffer.size(),
+                                (const jbyte*)sRxDataBuffer.data());
+        } else
+          LOG(ERROR) << StringPrintf("%s: Failed to allocate java byte array",
+                                     __func__);
+      }  // else a nack is treated as a transceive failure to the upper layers
+
+      sRxDataBuffer.clear();
+    }
+  } while (0);
+
+  sWaitingForTransceive = false;
+  if (targetLost) e->ReleaseIntArrayElements(statusTargetLost, targetLost, 0);
+#if (NXP_EXTNS == TRUE && NFC_NXP_NON_STD_CARD == TRUE)
+  if (fNeedToSwitchBack) {
+    sSwitchBackTimer.set(1500, switchBackTimerProc);
+  }
 #endif
-    ALOGV("%s: exit", __func__);
-    return result.release();
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  return result.release();
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeNfcTag_doGetNdefType
@@ -1692,49 +1634,41 @@ static jbyteArray nativeNfcTag_doTransceive (JNIEnv* e, jobject o, jbyteArray da
 ** Returns:         Type of tag represented by NFC Service.
 **
 *******************************************************************************/
-static jint nativeNfcTag_doGetNdefType (JNIEnv*, jobject, jint libnfcType, jint javaType)
-{
-    ALOGV("%s: enter; libnfc type=%d; java type=%d", __func__, libnfcType, javaType);
-    jint ndefType = NDEF_UNKNOWN_TYPE;
-
-    // For NFA, libnfcType is mapped to the protocol value received
-    // in the NFA_ACTIVATED_EVT and NFA_DISC_RESULT_EVT event.
-    if(NFA_PROTOCOL_T1T == libnfcType)
-    {
-        ndefType = NDEF_TYPE1_TAG;
-    }
-    else if(NFA_PROTOCOL_T2T == libnfcType)
-    {
-        ndefType = NDEF_TYPE2_TAG;
-    }
-    else if(NFA_PROTOCOL_T3T == libnfcType)
-    {
-        ndefType = NDEF_TYPE3_TAG;
-    }
-    else if(NFA_PROTOCOL_ISO_DEP == libnfcType)
-    {
-        ndefType = NDEF_TYPE4_TAG;
-    }
-    else if(NFA_PROTOCOL_MIFARE == libnfcType)
-    {
-        ndefType = NDEF_MIFARE_CLASSIC_TAG;
-    }
-    else
-    {
-        /* NFA_PROTOCOL_ISO15693 and others */
-        ndefType = NDEF_UNKNOWN_TYPE;
-    }
-
-    ALOGV("%s: exit; ndef type=%d", __func__, ndefType);
-    return ndefType;
+static jint nativeNfcTag_doGetNdefType(JNIEnv*, jobject, jint libnfcType,
+                                       jint javaType) {
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter; libnfc type=%d; java type=%d", __func__,
+                      libnfcType, javaType);
+  jint ndefType = NDEF_UNKNOWN_TYPE;
+
+  // For NFA, libnfcType is mapped to the protocol value received
+  // in the NFA_ACTIVATED_EVT and NFA_DISC_RESULT_EVT event.
+  if (NFA_PROTOCOL_T1T == libnfcType) {
+    ndefType = NDEF_TYPE1_TAG;
+  } else if (NFA_PROTOCOL_T2T == libnfcType) {
+    ndefType = NDEF_TYPE2_TAG;
+  } else if (NFA_PROTOCOL_T3T == libnfcType) {
+    ndefType = NDEF_TYPE3_TAG;
+  } else if (NFA_PROTOCOL_ISO_DEP == libnfcType) {
+    ndefType = NDEF_TYPE4_TAG;
+  } else if (NFC_PROTOCOL_MIFARE == libnfcType) {
+    ndefType = NDEF_MIFARE_CLASSIC_TAG;
+  } else {
+    /* NFA_PROTOCOL_T5T and others */
+    ndefType = NDEF_UNKNOWN_TYPE;
+  }
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit; ndef type=%d", __func__, ndefType);
+  return ndefType;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeNfcTag_doCheckNdefResult
 **
-** Description:     Receive the result of checking whether the tag contains a NDEF
+** Description:     Receive the result of checking whether the tag contains a
+*NDEF
 **                  message.  Called by the NFA_NDEF_DETECT_EVT.
 **                  status: Status of the operation.
 **                  maxSize: Maximum size of NDEF message.
@@ -1744,77 +1678,75 @@ static jint nativeNfcTag_doGetNdefType (JNIEnv*, jobject, jint libnfcType, jint
 ** Returns:         None
 **
 *******************************************************************************/
-void nativeNfcTag_doCheckNdefResult (tNFA_STATUS status, uint32_t maxSize, uint32_t currentSize, uint8_t flags)
-{
-    //this function's flags parameter is defined using the following macros
-    //in nfc/include/rw_api.h;
-    //#define RW_NDEF_FL_READ_ONLY  0x01    /* Tag is read only              */
-    //#define RW_NDEF_FL_FORMATED   0x02    /* Tag formated for NDEF         */
-    //#define RW_NDEF_FL_SUPPORTED  0x04    /* NDEF supported by the tag     */
-    //#define RW_NDEF_FL_UNKNOWN    0x08    /* Unable to find if tag is ndef capable/formated/read only */
-    //#define RW_NDEF_FL_FORMATABLE 0x10    /* Tag supports format operation */
-
-    if (!sCheckNdefWaitingForComplete)
-    {
-        ALOGE("%s: not waiting", __func__);
-        return;
-    }
-
-    if (flags & RW_NDEF_FL_READ_ONLY)
-        ALOGV("%s: flag read-only", __func__);
-    if (flags & RW_NDEF_FL_FORMATED)
-        ALOGV("%s: flag formatted for ndef", __func__);
-    if (flags & RW_NDEF_FL_SUPPORTED)
-        ALOGV("%s: flag ndef supported", __func__);
-    if (flags & RW_NDEF_FL_UNKNOWN)
-        ALOGV("%s: flag all unknown", __func__);
-    if (flags & RW_NDEF_FL_FORMATABLE)
-        ALOGV("%s: flag formattable", __func__);
-
-    sCheckNdefWaitingForComplete = JNI_FALSE;
-    sCheckNdefStatus = status;
-    if (sCheckNdefStatus != NFA_STATUS_OK && sCheckNdefStatus != NFA_STATUS_TIMEOUT)
-        sCheckNdefStatus = NFA_STATUS_FAILED;
-    sCheckNdefCapable = false; //assume tag is NOT ndef capable
-    if (sCheckNdefStatus == NFA_STATUS_OK)
-    {
-        //NDEF content is on the tag
-        sCheckNdefMaxSize = maxSize;
-        sCheckNdefCurrentSize = currentSize;
-        sCheckNdefCardReadOnly = flags & RW_NDEF_FL_READ_ONLY;
+void nativeNfcTag_doCheckNdefResult(tNFA_STATUS status, uint32_t maxSize,
+                                    uint32_t currentSize, uint8_t flags) {
+  // this function's flags parameter is defined using the following macros
+  // in nfc/include/rw_api.h;
+  //#define RW_NDEF_FL_READ_ONLY  0x01    /* Tag is read only              */
+  //#define RW_NDEF_FL_FORMATED   0x02    /* Tag formated for NDEF         */
+  //#define RW_NDEF_FL_SUPPORTED  0x04    /* NDEF supported by the tag     */
+  //#define RW_NDEF_FL_UNKNOWN    0x08    /* Unable to find if tag is ndef
+  // capable/formated/read only */
+  //#define RW_NDEF_FL_FORMATABLE 0x10    /* Tag supports format operation */
+
+  if (!sCheckNdefWaitingForComplete) {
+    LOG(ERROR) << StringPrintf("%s: not waiting", __func__);
+    return;
+  }
+
+  if (flags & RW_NDEF_FL_READ_ONLY)
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: flag read-only", __func__);
+  if (flags & RW_NDEF_FL_FORMATED)
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: flag formatted for ndef", __func__);
+  if (flags & RW_NDEF_FL_SUPPORTED)
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: flag ndef supported", __func__);
+  if (flags & RW_NDEF_FL_UNKNOWN)
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: flag all unknown", __func__);
+  if (flags & RW_NDEF_FL_FORMATABLE)
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: flag formattable", __func__);
+
+  sCheckNdefWaitingForComplete = JNI_FALSE;
+  sCheckNdefStatus = status;
+  if (sCheckNdefStatus != NFA_STATUS_OK &&
+      sCheckNdefStatus != NFA_STATUS_TIMEOUT)
+    sCheckNdefStatus = NFA_STATUS_FAILED;
+  sCheckNdefCapable = false;  // assume tag is NOT ndef capable
+  if (sCheckNdefStatus == NFA_STATUS_OK) {
+    // NDEF content is on the tag
+    sCheckNdefMaxSize = maxSize;
+    sCheckNdefCurrentSize = currentSize;
+    sCheckNdefCardReadOnly = flags & RW_NDEF_FL_READ_ONLY;
+    sCheckNdefCapable = true;
+  } else if (sCheckNdefStatus == NFA_STATUS_FAILED) {
+    // no NDEF content on the tag
+    sCheckNdefMaxSize = 0;
+    sCheckNdefCurrentSize = 0;
+    sCheckNdefCardReadOnly = flags & RW_NDEF_FL_READ_ONLY;
+    if ((flags & RW_NDEF_FL_UNKNOWN) == 0)  // if stack understands the tag
+    {
+      if (flags & RW_NDEF_FL_SUPPORTED)  // if tag is ndef capable
         sCheckNdefCapable = true;
     }
-    else if (sCheckNdefStatus == NFA_STATUS_FAILED)
-    {
-        //no NDEF content on the tag
-        sCheckNdefMaxSize = 0;
-        sCheckNdefCurrentSize = 0;
-        sCheckNdefCardReadOnly = flags & RW_NDEF_FL_READ_ONLY;
-        if ((flags & RW_NDEF_FL_UNKNOWN) == 0) //if stack understands the tag
-        {
-            if (flags & RW_NDEF_FL_SUPPORTED) //if tag is ndef capable
-                sCheckNdefCapable = true;
-        }
-    }
-    else if (sCheckNdefStatus == NFA_STATUS_TIMEOUT)
-    {
-        ALOGE("%s: timeout", __func__);
-
-        sCheckNdefMaxSize = 0;
-        sCheckNdefCurrentSize = 0;
-        sCheckNdefCardReadOnly = false;
-    }
-    else
-    {
-        ALOGE("%s: unknown status=0x%X", __func__, status);
-        sCheckNdefMaxSize = 0;
-        sCheckNdefCurrentSize = 0;
-        sCheckNdefCardReadOnly = false;
-    }
-    sem_post (&sCheckNdefSem);
+  } else if (sCheckNdefStatus == NFA_STATUS_TIMEOUT) {
+    LOG(ERROR) << StringPrintf("%s: timeout", __func__);
+
+    sCheckNdefMaxSize = 0;
+    sCheckNdefCurrentSize = 0;
+    sCheckNdefCardReadOnly = false;
+  } else {
+    LOG(ERROR) << StringPrintf("%s: unknown status=0x%X", __func__, status);
+    sCheckNdefMaxSize = 0;
+    sCheckNdefCurrentSize = 0;
+    sCheckNdefCardReadOnly = false;
+  }
+  sem_post(&sCheckNdefSem);
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeNfcTag_doCheckNdef
@@ -1827,148 +1759,143 @@ void nativeNfcTag_doCheckNdefResult (tNFA_STATUS status, uint32_t maxSize, uint3
 ** Returns:         Status code; 0 is success.
 **
 *******************************************************************************/
-static jint nativeNfcTag_doCheckNdef (JNIEnv* e, jobject o, jintArray ndefInfo)
-{
-    tNFA_STATUS status = NFA_STATUS_FAILED;
-    jint* ndef = NULL;
-    int handle = sCurrentConnectedHandle;
-    ALOGV("%s: enter; handle=%x", __func__, handle);
-
-    ALOGV("%s: enter", __func__);
-    sIsCheckingNDef = true;
+static jint nativeNfcTag_doCheckNdef(JNIEnv* e, jobject o, jintArray ndefInfo) {
+  tNFA_STATUS status = NFA_STATUS_FAILED;
+  jint* ndef = NULL;
+  int handle = sCurrentConnectedHandle;
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter; handle=%x", __func__, handle);
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+  sIsCheckingNDef = true;
 #if (NXP_EXTNS == TRUE)
-    if (sCurrentConnectedTargetProtocol == NFA_PROTOCOL_T3BT)
-    {
-        ndef = e->GetIntArrayElements (ndefInfo, 0);
-        ndef[0] = 0;
-        ndef[1] = NDEF_MODE_READ_ONLY;
-        e->ReleaseIntArrayElements (ndefInfo, ndef, 0);
-        sIsCheckingNDef = false;
-        return NFA_STATUS_FAILED;
-    }
+  if (sCurrentConnectedTargetProtocol == NFA_PROTOCOL_T3BT) {
+    ndef = e->GetIntArrayElements(ndefInfo, 0);
+    ndef[0] = 0;
+    ndef[1] = NDEF_MODE_READ_ONLY;
+    e->ReleaseIntArrayElements(ndefInfo, ndef, 0);
+    sIsCheckingNDef = false;
+    return NFA_STATUS_FAILED;
+  }
 #endif
 
-    // special case for Kovio
-    if (sCurrentConnectedTargetProtocol == TARGET_TYPE_KOVIO_BARCODE)
-    {
-        ALOGV("%s: Kovio tag, no NDEF", __func__);
-        ndef = e->GetIntArrayElements (ndefInfo, 0);
-        ndef[0] = 0;
-        ndef[1] = NDEF_MODE_READ_ONLY;
-        e->ReleaseIntArrayElements (ndefInfo, ndef, 0);
-        sIsCheckingNDef = false;
-        return NFA_STATUS_FAILED;
-    }
-    if (sCurrentConnectedTargetProtocol == NFA_PROTOCOL_MIFARE)
-    {
-        nativeNfcTag_doReconnect (e, o);
-    }
-
-    doReconnectFlag = 0;
-
-    /* Create the write semaphore */
-    if (sem_init (&sCheckNdefSem, 0, 0) == -1)
-    {
-        ALOGE("%s: Check NDEF semaphore creation failed (errno=0x%08x)", __func__, errno);
-        sIsCheckingNDef = false;
-        return JNI_FALSE;
-    }
-
-    if (NfcTag::getInstance ().getActivationState () != NfcTag::Active)
-    {
-        ALOGE("%s: tag already deactivated", __func__);
-        goto TheEnd;
-    }
-
-    ALOGV("%s: try NFA_RwDetectNDef", __func__);
-    sCheckNdefWaitingForComplete = JNI_TRUE;
-
-    ALOGV("%s: NfcTag::getInstance ().mTechLibNfcTypes[%d]=%d", __func__, handle, NfcTag::getInstance ().mTechLibNfcTypes[handle]);
-
-    if (sCurrentConnectedTargetProtocol == NFA_PROTOCOL_MIFARE)
-    {
-        status = EXTNS_MfcCheckNDef ();
-    }
+  // special case for Kovio
+  if (sCurrentConnectedTargetProtocol == TARGET_TYPE_KOVIO_BARCODE) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Kovio tag, no NDEF", __func__);
+    ndef = e->GetIntArrayElements(ndefInfo, 0);
+    ndef[0] = 0;
+    ndef[1] = NDEF_MODE_READ_ONLY;
+    e->ReleaseIntArrayElements(ndefInfo, ndef, 0);
+    sIsCheckingNDef = false;
+    return NFA_STATUS_FAILED;
+  }
+  if (sCurrentConnectedTargetProtocol == NFC_PROTOCOL_MIFARE) {
+    nativeNfcTag_doReconnect(e, o);
+  }
+
+  doReconnectFlag = 0;
+
+  /* Create the write semaphore */
+  if (sem_init(&sCheckNdefSem, 0, 0) == -1) {
+    LOG(ERROR) << StringPrintf(
+        "%s: Check NDEF semaphore creation failed (errno=0x%08x)", __func__,
+        errno);
+    sIsCheckingNDef = false;
+    return JNI_FALSE;
+  }
+
+  if (NfcTag::getInstance().getActivationState() != NfcTag::Active) {
+    LOG(ERROR) << StringPrintf("%s: tag already deactivated", __func__);
+    goto TheEnd;
+  }
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: try NFA_RwDetectNDef", __func__);
+  sCheckNdefWaitingForComplete = JNI_TRUE;
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: NfcTag::getInstance ().mTechLibNfcTypes[%d]=%d", __func__, handle,
+      NfcTag::getInstance().mTechLibNfcTypes[handle]);
+
+  if (sCurrentConnectedTargetProtocol == NFC_PROTOCOL_MIFARE) {
+    status = EXTNS_MfcCheckNDef();
+  } else {
+    status = NFA_RwDetectNDef();
+  }
+
+  if (status != NFA_STATUS_OK) {
+    LOG(ERROR) << StringPrintf("%s: NFA_RwDetectNDef failed, status = 0x%X",
+                               __func__, status);
+    goto TheEnd;
+  }
+
+  /* Wait for check NDEF completion status */
+  if (sem_wait(&sCheckNdefSem)) {
+    LOG(ERROR) << StringPrintf(
+        "%s: Failed to wait for check NDEF semaphore (errno=0x%08x)", __func__,
+        errno);
+    goto TheEnd;
+  }
+
+  if (sCheckNdefStatus == NFA_STATUS_OK) {
+    // stack found a NDEF message on the tag
+    ndef = e->GetIntArrayElements(ndefInfo, 0);
+    if (NfcTag::getInstance().getProtocol() == NFA_PROTOCOL_T1T)
+      ndef[0] = NfcTag::getInstance().getT1tMaxMessageSize();
     else
-    {
-        status = NFA_RwDetectNDef ();
-    }
-
-    if (status != NFA_STATUS_OK)
-    {
-        ALOGE("%s: NFA_RwDetectNDef failed, status = 0x%X", __func__, status);
-        goto TheEnd;
-    }
-
-    /* Wait for check NDEF completion status */
-    if (sem_wait (&sCheckNdefSem))
-    {
-        ALOGE("%s: Failed to wait for check NDEF semaphore (errno=0x%08x)", __func__, errno);
-        goto TheEnd;
-    }
-
-    if (sCheckNdefStatus == NFA_STATUS_OK)
-    {
-        //stack found a NDEF message on the tag
-        ndef = e->GetIntArrayElements (ndefInfo, 0);
-        if (NfcTag::getInstance ().getProtocol () == NFA_PROTOCOL_T1T)
-            ndef[0] = NfcTag::getInstance ().getT1tMaxMessageSize ();
-        else
-            ndef[0] = sCheckNdefMaxSize;
-        if (sCheckNdefCardReadOnly)
-            ndef[1] = NDEF_MODE_READ_ONLY;
-        else
-            ndef[1] = NDEF_MODE_READ_WRITE;
-        e->ReleaseIntArrayElements (ndefInfo, ndef, 0);
-        status = NFA_STATUS_OK;
-    }
-    else if (sCheckNdefStatus == NFA_STATUS_FAILED)
-    {
-        //stack did not find a NDEF message on the tag;
-        ndef = e->GetIntArrayElements (ndefInfo, 0);
-        if (NfcTag::getInstance ().getProtocol () == NFA_PROTOCOL_T1T)
-            ndef[0] = NfcTag::getInstance ().getT1tMaxMessageSize ();
-        else
-            ndef[0] = sCheckNdefMaxSize;
-        if (sCheckNdefCardReadOnly)
-            ndef[1] = NDEF_MODE_READ_ONLY;
-        else
-            ndef[1] = NDEF_MODE_READ_WRITE;
-        e->ReleaseIntArrayElements (ndefInfo, ndef, 0);
-        status = NFA_STATUS_FAILED;
-        if (setNdefDetectionTimeoutIfTagAbsent(e, o, NFA_PROTOCOL_T3T | NFA_PROTOCOL_ISO15693))
-            status = STATUS_CODE_TARGET_LOST;
-    }
-    else if ((sCheckNdefStatus == NFA_STATUS_TIMEOUT) && (NfcTag::getInstance ().getProtocol() == NFC_PROTOCOL_ISO_DEP))
-    {
-        pn544InteropStopPolling ();
-        status = STATUS_CODE_TARGET_LOST;
-    }
+      ndef[0] = sCheckNdefMaxSize;
+    if (sCheckNdefCardReadOnly)
+      ndef[1] = NDEF_MODE_READ_ONLY;
     else
-    {
-        ALOGV("%s: unknown status 0x%X", __func__, sCheckNdefStatus);
-        status = sCheckNdefStatus;
-    }
-
-    /* Reconnect Mifare Classic Tag for furture use */
-    if (sCurrentConnectedTargetProtocol == NFA_PROTOCOL_MIFARE)
-    {
-        nativeNfcTag_doReconnect (e, o);
-    }
+      ndef[1] = NDEF_MODE_READ_WRITE;
+    e->ReleaseIntArrayElements(ndefInfo, ndef, 0);
+    status = NFA_STATUS_OK;
+  } else if (sCheckNdefStatus == NFA_STATUS_FAILED) {
+    // stack did not find a NDEF message on the tag;
+    ndef = e->GetIntArrayElements(ndefInfo, 0);
+    if (NfcTag::getInstance().getProtocol() == NFA_PROTOCOL_T1T)
+      ndef[0] = NfcTag::getInstance().getT1tMaxMessageSize();
+    else
+      ndef[0] = sCheckNdefMaxSize;
+    if (sCheckNdefCardReadOnly)
+      ndef[1] = NDEF_MODE_READ_ONLY;
+    else
+      ndef[1] = NDEF_MODE_READ_WRITE;
+    e->ReleaseIntArrayElements(ndefInfo, ndef, 0);
+    status = NFA_STATUS_FAILED;
+    if (setNdefDetectionTimeoutIfTagAbsent(e, o,
+                                           NFA_PROTOCOL_T3T | NFA_PROTOCOL_T5T))
+      status = STATUS_CODE_TARGET_LOST;
+  } else if ((sCheckNdefStatus == NFA_STATUS_TIMEOUT) &&
+             (NfcTag::getInstance().getProtocol() == NFC_PROTOCOL_ISO_DEP)) {
+    pn544InteropStopPolling();
+    status = STATUS_CODE_TARGET_LOST;
+  } else {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: unknown status 0x%X", __func__, sCheckNdefStatus);
+    status = sCheckNdefStatus;
+  }
+
+  /* Reconnect Mifare Classic Tag for furture use */
+  if (sCurrentConnectedTargetProtocol == NFC_PROTOCOL_MIFARE) {
+    nativeNfcTag_doReconnect(e, o);
+  }
 
 TheEnd:
-    /* Destroy semaphore */
-    if (sem_destroy (&sCheckNdefSem))
-    {
-        ALOGE("%s: Failed to destroy check NDEF semaphore (errno=0x%08x)", __func__, errno);
-    }
-    sCheckNdefWaitingForComplete = JNI_FALSE;
-    sIsCheckingNDef = false;
-    ALOGV("%s: exit; status=0x%X", __func__, status);
-    return status;
+  /* Destroy semaphore */
+  if (sem_destroy(&sCheckNdefSem)) {
+    LOG(ERROR) << StringPrintf(
+        "%s: Failed to destroy check NDEF semaphore (errno=0x%08x)", __func__,
+        errno);
+  }
+  sCheckNdefWaitingForComplete = JNI_FALSE;
+  sIsCheckingNDef = false;
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit; status=0x%X", __func__, status);
+  return status;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeNfcTag_resetPresenceCheck
@@ -1978,15 +1905,13 @@ TheEnd:
 ** Returns:         None
 **
 *******************************************************************************/
-void nativeNfcTag_resetPresenceCheck ()
-{
-    sIsTagPresent = true;
-    NfcTag::getInstance ().mCashbeeDetected = false;
-    NfcTag::getInstance ().mEzLinkTypeTag = false;
-    MfcResetPresenceCheckStatus();
+void nativeNfcTag_resetPresenceCheck() {
+  sIsTagPresent = true;
+  NfcTag::getInstance().mCashbeeDetected = false;
+  NfcTag::getInstance().mEzLinkTypeTag = false;
+  MfcResetPresenceCheckStatus();
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeNfcTag_doPresenceCheckResult
@@ -1997,14 +1922,12 @@ void nativeNfcTag_resetPresenceCheck ()
 ** Returns:         None
 **
 *******************************************************************************/
-void nativeNfcTag_doPresenceCheckResult (tNFA_STATUS status)
-{
-    SyncEventGuard guard (sPresenceCheckEvent);
-    sIsTagPresent = status == NFA_STATUS_OK;
-    sPresenceCheckEvent.notifyOne ();
+void nativeNfcTag_doPresenceCheckResult(tNFA_STATUS status) {
+  SyncEventGuard guard(sPresenceCheckEvent);
+  sIsTagPresent = status == NFA_STATUS_OK;
+  sPresenceCheckEvent.notifyOne();
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeNfcTag_doPresenceCheck
@@ -2016,67 +1939,67 @@ void nativeNfcTag_doPresenceCheckResult (tNFA_STATUS status)
 ** Returns:         True if tag is in RF field.
 **
 *******************************************************************************/
-static jboolean nativeNfcTag_doPresenceCheck (JNIEnv*, jobject)
-{
-    ALOGV("%s", __func__);
-    tNFA_STATUS status = NFA_STATUS_OK;
-    jboolean isPresent = JNI_FALSE;
-    uint8_t* uid;
-    uint32_t uid_len;
-    NfcTag::getInstance ().getTypeATagUID(&uid,&uid_len);
-    int handle = sCurrentConnectedHandle;
-
-    if(NfcTag::getInstance().mNfcDisableinProgress)
-    {
-        ALOGV("%s, Nfc disable in progress",__func__);
-        return JNI_FALSE;
-    }
-
-    if (sIsCheckingNDef == true)
-    {
-        ALOGV("%s: Ndef is being checked", __func__);
-        return JNI_TRUE;
+static jboolean nativeNfcTag_doPresenceCheck(JNIEnv*, jobject) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
+  tNFA_STATUS status = NFA_STATUS_OK;
+  jboolean isPresent = JNI_FALSE;
+  uint8_t* uid;
+  uint32_t uid_len;
+  bool result;
+  NfcTag::getInstance().getTypeATagUID(&uid, &uid_len);
+  int handle = sCurrentConnectedHandle;
+
+  if (NfcTag::getInstance().mNfcDisableinProgress) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s, Nfc disable in progress", __func__);
+    return JNI_FALSE;
+  }
+
+  if (sIsCheckingNDef == true) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Ndef is being checked", __func__);
+    return JNI_TRUE;
+  }
+  if (fNeedToSwitchBack) {
+    sSwitchBackTimer.kill();
+  }
+  if (nfcManager_isNfcActive() == false) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: NFC is no longer active.", __func__);
+    return JNI_FALSE;
+  }
+
+  if (!sRfInterfaceMutex.tryLock()) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: tag is being reSelected assume it is present", __func__);
+    return JNI_TRUE;
+  }
+
+  sRfInterfaceMutex.unlock();
+
+  if (NfcTag::getInstance().isActivated() == false) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: tag already deactivated", __func__);
+    return JNI_FALSE;
+  }
+
+  /*Presence check for Kovio - RF Deactive command with type Discovery*/
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: handle=%d", __func__, handle);
+  if (sCurrentConnectedTargetProtocol == TARGET_TYPE_KOVIO_BARCODE) {
+    SyncEventGuard guard(sPresenceCheckEvent);
+    status =
+        NFA_RwPresenceCheck(NfcTag::getInstance().getPresenceCheckAlgorithm());
+    if (status == NFA_STATUS_OK) {
+      sPresenceCheckEvent.wait();
+      isPresent = sIsTagPresent ? JNI_TRUE : JNI_FALSE;
     }
-    if (fNeedToSwitchBack)
-    {
-        sSwitchBackTimer.kill ();
-    }
-    if (nfcManager_isNfcActive() == false)
-    {
-        ALOGV("%s: NFC is no longer active.", __func__);
-        return JNI_FALSE;
-    }
-
-    if (!sRfInterfaceMutex.tryLock())
-    {
-        ALOGV("%s: tag is being reSelected assume it is present", __func__);
-        return JNI_TRUE;
-    }
-
-    sRfInterfaceMutex.unlock();
-
-    if (NfcTag::getInstance ().isActivated () == false)
-    {
-        ALOGV("%s: tag already deactivated", __func__);
-        return JNI_FALSE;
-    }
-
-    /*Presence check for Kovio - RF Deactive command with type Discovery*/
-    ALOGV("%s: handle=%d", __func__, handle);
-    if (sCurrentConnectedTargetProtocol == TARGET_TYPE_KOVIO_BARCODE)
-    {
-        SyncEventGuard guard (sPresenceCheckEvent);
-        status = NFA_RwPresenceCheck (NfcTag::getInstance().getPresenceCheckAlgorithm());
-        if (status == NFA_STATUS_OK)
-        {
-            sPresenceCheckEvent.wait ();
-            isPresent = sIsTagPresent ? JNI_TRUE : JNI_FALSE;
-        }
-        if (isPresent == JNI_FALSE)
-            ALOGV("%s: tag absent", __func__);
-        return isPresent;
+    if (isPresent == JNI_FALSE)
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: tag absent", __func__);
+    return isPresent;
 #if 0
-        ALOGV("%s: Kovio, force deactivate handling", __func__);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Kovio, force deactivate handling", __func__);
         tNFA_DEACTIVATED deactivated = {NFA_DEACTIVATE_TYPE_IDLE};
         {
             SyncEventGuard g (gDeactivatedEvent);
@@ -2092,124 +2015,156 @@ static jboolean nativeNfcTag_doPresenceCheck (JNIEnv*, jobject)
 
         return JNI_FALSE;
 #endif
-    }
-
-    /*
-     * This fix is made because NFA_RwPresenceCheck cmd is not woking for ISO-DEP in CEFH mode
-     * Hence used the Properitary presence check cmd
-     * */
-
-    if (NfcTag::getInstance ().mTechLibNfcTypes[handle] == NFA_PROTOCOL_ISO_DEP && NFA_GetNCIVersion() != NCI_VERSION_2_0)
-    {
-        if (sIsReconnecting == true)
-        {
-            ALOGV("%s: Reconnecting Tag", __func__);
-            return JNI_TRUE;
+  }
+
+  /*
+   * This fix is made because NFA_RwPresenceCheck cmd is not woking for ISO-DEP
+   * in CEFH mode
+   * Hence used the Properitary presence check cmd
+   * */
+
+  if (NfcTag::getInstance().mTechLibNfcTypes[handle] == NFA_PROTOCOL_ISO_DEP &&
+      NFA_GetNCIVersion() != NCI_VERSION_2_0) {
+    if (sIsReconnecting == true) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: Reconnecting Tag", __func__);
+      return JNI_TRUE;
+    }
+    if (!pTransactionController->transactionAttempt(
+            TRANSACTION_REQUESTOR(TAG_PRESENCE_CHECK),
+            TRANSACTION_ATTEMPT_FOR_SECONDS(5))) {
+      LOG(ERROR) << StringPrintf(
+          "%s: Transaction in progress. Can not perform presence check",
+          __func__);
+      return JNI_FALSE;
+    }
+
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: presence check for TypeB / TypeA random uid", __func__);
+    sPresenceCheckTimer.set(500, presenceCheckTimerProc);
+
+    tNFC_STATUS stat = NFA_RegVSCback(
+        true, nfaVSCNtfCallback);  // Register CallBack for VS NTF
+    if (NFA_STATUS_OK != stat) {
+      LOG(ERROR) << StringPrintf("%s: Kill presence check timer", __func__);
+      sPresenceCheckTimer.kill();
+      goto TheEnd;
+    }
+    {
+      SyncEventGuard guard(sNfaVSCResponseEvent);
+      stat = NFA_SendVsCommand(0x11, 0x00, NULL, nfaVSCCallback);
+      if (NFA_STATUS_OK == stat) {
+        /*Considering the FWI=14 for slowest tag, wait time is kept 5000*/
+        result = sNfaVSCResponseEvent.wait(
+            5000);  // wait for NFA VS command to finish
+        if (result == FALSE) {
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "%s: Timedout while waiting for presence check rsp", __func__);
+          pTransactionController->transactionEnd(
+              TRANSACTION_REQUESTOR(TAG_PRESENCE_CHECK));
+          return JNI_FALSE;
         }
-        ALOGV("%s: presence check for TypeB / TypeA random uid", __func__);
-        sPresenceCheckTimer.set(500, presenceCheckTimerProc);
-
-        tNFC_STATUS stat = NFA_RegVSCback (true,nfaVSCNtfCallback); //Register CallBack for VS NTF
-        if(NFA_STATUS_OK != stat)
-        {
-            goto TheEnd;
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: presence check for TypeB - GOT NFA VS RSP", __func__);
+      } else {
+        LOG(ERROR) << StringPrintf(
+            "%s: Kill presence check timer, command failed", __func__);
+        sPresenceCheckTimer.kill();
+      }
+    }
+    pTransactionController->transactionEnd(
+        TRANSACTION_REQUESTOR(TAG_PRESENCE_CHECK));
+
+    if (true == sVSCRsp) {
+      {
+        SyncEventGuard guard(sNfaVSCNotificationEvent);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: presence check for TypeB - wait for NFA VS NTF to come",
+            __func__);
+        result =
+            sNfaVSCNotificationEvent.wait(5000);  // wait for NFA VS NTF to come
+        sPresenceCheckTimer.kill();
+        if (result == FALSE) {
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "%s: Timedout while waiting for presence check Ntf", __func__);
+          return JNI_FALSE;
         }
-
-        SyncEventGuard guard (sNfaVSCResponseEvent);
-        stat = NFA_SendVsCommand (0x11,0x00,NULL,nfaVSCCallback);
-        if(NFA_STATUS_OK == stat)
-        {
-            ALOGV("%s: presence check for TypeB - wait for NFA VS RSP to come", __func__);
-            sNfaVSCResponseEvent.wait(); //wait for NFA VS command to finish
-            ALOGV("%s: presence check for TypeB - GOT NFA VS RSP", __func__);
-        }
-
-        if(true == sVSCRsp)
-        {
-            {
-                SyncEventGuard guard (sNfaVSCNotificationEvent);
-                ALOGV("%s: presence check for TypeB - wait for NFA VS NTF to come", __func__);
-                sNfaVSCNotificationEvent.wait(); //wait for NFA VS NTF to come
-                ALOGV("%s: presence check for TypeB - GOT NFA VS NTF", __func__);
-                sPresenceCheckTimer.kill();
-            }
-
-            if(false == sIsTagInField)
-            {
-                isPresent = JNI_FALSE;
-            }
-            else
-            {
-                isPresent =  JNI_TRUE;
-            }
-        }
-        NFA_RegVSCback (false,nfaVSCNtfCallback); //DeRegister CallBack for VS NTF
-        ALOGV("%s: presence check for TypeB - return", __func__);
-        goto TheEnd;
-    }
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: presence check for TypeB - GOT NFA VS NTF", __func__);
+      }
+
+      if (false == sIsTagInField) {
+        isPresent = JNI_FALSE;
+      } else {
+        isPresent = JNI_TRUE;
+      }
+    }
+    NFA_RegVSCback(false, nfaVSCNtfCallback);  // DeRegister CallBack for VS NTF
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: presence check for TypeB - return", __func__);
+    goto TheEnd;
+  }
 
 #if (NXP_EXTNS == TRUE)
-    if(NfcTag::getInstance ().mTechLibNfcTypes[handle] == NFA_PROTOCOL_T3BT)
-    {
-        uint8_t *pbuf = NULL;
-        uint8_t bufLen = 0x00;
-        bool waitOk = false;
-        int timeout = NfcTag::getInstance ().getTransceiveTimeout (sCurrentConnectedTargetType);
-        ALOGV("%s: enter; timeout = %d", __func__, timeout);
-
-        SyncEventGuard g (sTransceiveEvent);
-        sTransceiveRfTimeout = false;
-        sWaitingForTransceive = true;
-        //sTransceiveDataLen = 0;
-        bufLen = (uint8_t) sizeof(Presence_check_TypeB);
-        pbuf = Presence_check_TypeB;
-        //memcpy(pbuf, Attrib_cmd_TypeB, bufLen);
-        status = NFA_SendRawFrame (pbuf, bufLen,NFA_DM_DEFAULT_PRESENCE_CHECK_START_DELAY);
-        if (status != NFA_STATUS_OK)
-        {
-            ALOGE("%s: fail send; error=%d", __func__, status);
-        }
-        else
-            waitOk = sTransceiveEvent.wait (timeout);
-
-        if (waitOk == false || sTransceiveRfTimeout) //if timeout occurred
-        {
-            return JNI_FALSE;;
-        }
-        else
-        {
-            return JNI_TRUE;
-        }
-    }
+  if (NfcTag::getInstance().mTechLibNfcTypes[handle] == NFA_PROTOCOL_T3BT) {
+    uint8_t* pbuf = NULL;
+    uint8_t bufLen = 0x00;
+    bool waitOk = false;
+    int timeout =
+        NfcTag::getInstance().getTransceiveTimeout(sCurrentConnectedTargetType);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: enter; timeout = %d", __func__, timeout);
+
+    SyncEventGuard g(sTransceiveEvent);
+    sTransceiveRfTimeout = false;
+    sWaitingForTransceive = true;
+    // sTransceiveDataLen = 0;
+    bufLen = (uint8_t)sizeof(Presence_check_TypeB);
+    pbuf = Presence_check_TypeB;
+    // memcpy(pbuf, Attrib_cmd_TypeB, bufLen);
+    status = NFA_SendRawFrame(pbuf, bufLen,
+                              NFA_DM_DEFAULT_PRESENCE_CHECK_START_DELAY);
+    if (status != NFA_STATUS_OK) {
+      LOG(ERROR) << StringPrintf("%s: fail send; error=%d", __func__, status);
+    } else
+      waitOk = sTransceiveEvent.wait(timeout);
+
+    if (waitOk == false || sTransceiveRfTimeout)  // if timeout occurred
+    {
+      return JNI_FALSE;
+      ;
+    } else {
+      return JNI_TRUE;
+    }
+  }
 #endif
 
-    if (sCurrentConnectedTargetProtocol == NFA_PROTOCOL_MIFARE)
-    {
-         status = EXTNS_MfcPresenceCheck ();
-         if (status == NFCSTATUS_SUCCESS)
-         {
-             return (NFCSTATUS_SUCCESS == EXTNS_GetPresenceCheckStatus ()) ? JNI_TRUE : JNI_FALSE;
-         }
+  if (sCurrentConnectedTargetProtocol == NFC_PROTOCOL_MIFARE) {
+    status = EXTNS_MfcPresenceCheck();
+    if (status == NFCSTATUS_SUCCESS) {
+      return (NFCSTATUS_SUCCESS == EXTNS_GetPresenceCheckStatus()) ? JNI_TRUE
+                                                                   : JNI_FALSE;
     }
+  }
 
-    {
-        SyncEventGuard guard (sPresenceCheckEvent);
-        status = NFA_RwPresenceCheck (NfcTag::getInstance().getPresenceCheckAlgorithm());
-        if (status == NFA_STATUS_OK)
-        {
-            sPresenceCheckEvent.wait ();
-            isPresent = sIsTagPresent ? JNI_TRUE : JNI_FALSE;
-        }
+  {
+    SyncEventGuard guard(sPresenceCheckEvent);
+    status =
+        NFA_RwPresenceCheck(NfcTag::getInstance().getPresenceCheckAlgorithm());
+    if (status == NFA_STATUS_OK) {
+      sPresenceCheckEvent.wait();
+      isPresent = sIsTagPresent ? JNI_TRUE : JNI_FALSE;
     }
+  }
 
-    TheEnd:
+TheEnd:
 
-    if (isPresent == JNI_FALSE)
-        ALOGV("%s: tag absent", __func__);
-    return isPresent;
+  if (isPresent == JNI_FALSE)
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: tag absent", __func__);
+  return isPresent;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeNfcTag_doIsNdefFormatable
@@ -2225,71 +2180,62 @@ static jboolean nativeNfcTag_doPresenceCheck (JNIEnv*, jobject)
 ** Returns:         True if formattable.
 **
 *******************************************************************************/
-static jboolean nativeNfcTag_doIsNdefFormatable (JNIEnv* e,
-        jobject o, jint /*libNfcType*/, jbyteArray, jbyteArray,
-        jbyteArray)
-{
-    jboolean isFormattable = JNI_FALSE;
-
-    tNFC_PROTOCOL protocol = NfcTag::getInstance().getProtocol();
-    if (NFA_PROTOCOL_T1T == protocol || NFA_PROTOCOL_ISO15693 == protocol
-            || NFA_PROTOCOL_MIFARE == protocol)
-    {
-        isFormattable = JNI_TRUE;
-    }
-    else if(NFA_PROTOCOL_T3T == protocol)
-    {
-        isFormattable = NfcTag::getInstance().isFelicaLite() ? JNI_TRUE : JNI_FALSE;
-    }
-    else if(NFA_PROTOCOL_T2T == protocol)
-    {
-        isFormattable = ( NfcTag::getInstance().isMifareUltralight() |
-                          NfcTag::getInstance().isInfineonMyDMove() |
-                          NfcTag::getInstance().isKovioType2Tag() )
-                        ? JNI_TRUE : JNI_FALSE;
-    }
-    else if(NFA_PROTOCOL_ISO_DEP == protocol)
-    {
-        /**
-         * Determines whether this is a formatable IsoDep tag - currectly only NXP DESFire
-         * is supported.
-         */
-        uint8_t  cmd[] = {0x90, 0x60, 0x00, 0x00, 0x00};
-
-        if(NfcTag::getInstance().isMifareDESFire())
-        {
-            /* Identifies as DESfire, use get version cmd to be sure */
-            jbyteArray versionCmd = e->NewByteArray(5);
-            e->SetByteArrayRegion(versionCmd, 0, 5, (jbyte*)cmd);
-            jbyteArray respBytes = nativeNfcTag_doTransceive(e, o,
-                        versionCmd, JNI_TRUE, NULL);
-            if (respBytes != NULL)
-            {
-                // Check whether the response matches a typical DESfire
-                // response.
-                // libNFC even does more advanced checking than we do
-                // here, and will only format DESfire's with a certain
-                // major/minor sw version and NXP as a manufacturer.
-                // We don't want to do such checking here, to avoid
-                // having to change code in multiple places.
-                // A succesful (wrapped) DESFire getVersion command returns
-                // 9 bytes, with byte 7 0x91 and byte 8 having status
-                // code 0xAF (these values are fixed and well-known).
-                int respLength = e->GetArrayLength(respBytes);
-                uint8_t* resp = (uint8_t*)e->GetByteArrayElements(respBytes, NULL);
-                if (respLength == 9 && resp[7] == 0x91 && resp[8] == 0xAF)
-                {
-                    isFormattable = JNI_TRUE;
-                }
-                e->ReleaseByteArrayElements(respBytes, (jbyte *)resp, JNI_ABORT);
-            }
+static jboolean nativeNfcTag_doIsNdefFormatable(JNIEnv* e, jobject o,
+                                                jint /*libNfcType*/, jbyteArray,
+                                                jbyteArray, jbyteArray) {
+  jboolean isFormattable = JNI_FALSE;
+
+  tNFC_PROTOCOL protocol = NfcTag::getInstance().getProtocol();
+  if (NFA_PROTOCOL_T1T == protocol || NFA_PROTOCOL_T5T == protocol ||
+      NFC_PROTOCOL_MIFARE == protocol) {
+    isFormattable = JNI_TRUE;
+  } else if (NFA_PROTOCOL_T3T == protocol) {
+    isFormattable = NfcTag::getInstance().isFelicaLite() ? JNI_TRUE : JNI_FALSE;
+  } else if (NFA_PROTOCOL_T2T == protocol) {
+    isFormattable = (NfcTag::getInstance().isMifareUltralight() |
+                     NfcTag::getInstance().isInfineonMyDMove() |
+                     NfcTag::getInstance().isKovioType2Tag())
+                        ? JNI_TRUE
+                        : JNI_FALSE;
+  } else if (NFA_PROTOCOL_ISO_DEP == protocol) {
+    /**
+     * Determines whether this is a formatable IsoDep tag - currectly only NXP
+     * DESFire
+     * is supported.
+     */
+    uint8_t cmd[] = {0x90, 0x60, 0x00, 0x00, 0x00};
+
+    if (NfcTag::getInstance().isMifareDESFire()) {
+      /* Identifies as DESfire, use get version cmd to be sure */
+      jbyteArray versionCmd = e->NewByteArray(5);
+      e->SetByteArrayRegion(versionCmd, 0, 5, (jbyte*)cmd);
+      jbyteArray respBytes =
+          nativeNfcTag_doTransceive(e, o, versionCmd, JNI_TRUE, NULL);
+      if (respBytes != NULL) {
+        // Check whether the response matches a typical DESfire
+        // response.
+        // libNFC even does more advanced checking than we do
+        // here, and will only format DESfire's with a certain
+        // major/minor sw version and NXP as a manufacturer.
+        // We don't want to do such checking here, to avoid
+        // having to change code in multiple places.
+        // A succesful (wrapped) DESFire getVersion command returns
+        // 9 bytes, with byte 7 0x91 and byte 8 having status
+        // code 0xAF (these values are fixed and well-known).
+        int respLength = e->GetArrayLength(respBytes);
+        uint8_t* resp = (uint8_t*)e->GetByteArrayElements(respBytes, NULL);
+        if (respLength == 9 && resp[7] == 0x91 && resp[8] == 0xAF) {
+          isFormattable = JNI_TRUE;
         }
+        e->ReleaseByteArrayElements(respBytes, (jbyte*)resp, JNI_ABORT);
+      }
     }
-    ALOGV("%s: is formattable=%u", __func__, isFormattable);
-    return isFormattable;
+  }
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: is formattable=%u", __func__, isFormattable);
+  return isFormattable;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeNfcTag_doIsIsoDepNdefFormatable
@@ -2303,59 +2249,60 @@ static jboolean nativeNfcTag_doIsNdefFormatable (JNIEnv* e,
 ** Returns:         True if formattable.
 **
 *******************************************************************************/
-static jboolean nativeNfcTag_doIsIsoDepNdefFormatable (JNIEnv *e, jobject o, jbyteArray pollBytes, jbyteArray actBytes)
-{
-    uint8_t uidFake[] = { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 };
-    ALOGV("%s", __func__);
-    jbyteArray uidArray = e->NewByteArray (8);
-    e->SetByteArrayRegion (uidArray, 0, 8, (jbyte*) uidFake);
-    return nativeNfcTag_doIsNdefFormatable (e, o, 0, uidArray, pollBytes, actBytes);
+static jboolean nativeNfcTag_doIsIsoDepNdefFormatable(JNIEnv* e, jobject o,
+                                                      jbyteArray pollBytes,
+                                                      jbyteArray actBytes) {
+  uint8_t uidFake[] = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
+  jbyteArray uidArray = e->NewByteArray(8);
+  e->SetByteArrayRegion(uidArray, 0, 8, (jbyte*)uidFake);
+  return nativeNfcTag_doIsNdefFormatable(e, o, 0, uidArray, pollBytes,
+                                         actBytes);
 }
 
 /*******************************************************************************
  **
  ** Function:        nativeNfcTag_makeMifareNdefFormat
-**
-** Description:     Format a mifare classic tag so it can store NDEF message.
-**                  e: JVM environment.
-**                  o: Java object.
-**                  key: Key to acces tag.
-**                  keySize: size of Key.
-**
-** Returns:         True if ok.
-**
-*******************************************************************************/
-static jboolean nativeNfcTag_makeMifareNdefFormat (JNIEnv *e, jobject o, uint8_t *key, uint32_t keySize)
-{
-    ALOGV("%s: enter", __func__);
-    tNFA_STATUS status = NFA_STATUS_OK;
-
-    status = nativeNfcTag_doReconnect (e, o);
-    if (status != NFA_STATUS_OK)
-    {
-        ALOGV("%s: reconnect error, status=%u", __func__, status);
-        return JNI_FALSE;
-    }
-
-    sem_init (&sFormatSem, 0, 0);
-    sFormatOk = false;
-
-    status = EXTNS_MfcFormatTag (key, keySize);
-
-    if (status == NFA_STATUS_OK)
-    {
-        ALOGV("%s: wait for completion", __func__);
-        sem_wait (&sFormatSem);
-        status = sFormatOk ? NFA_STATUS_OK : NFA_STATUS_FAILED;
-    }
-    else
-    {
-        ALOGE("%s: error status=%u", __func__, status);
-    }
-
-    sem_destroy (&sFormatSem);
-    ALOGV("%s: exit", __func__);
-    return (status == NFA_STATUS_OK) ? JNI_TRUE : JNI_FALSE;
+ **
+ ** Description:     Format a mifare classic tag so it can store NDEF message.
+ **                  e: JVM environment.
+ **                  o: Java object.
+ **                  key: Key to acces tag.
+ **                  keySize: size of Key.
+ **
+ ** Returns:         True if ok.
+ **
+ *******************************************************************************/
+static jboolean nativeNfcTag_makeMifareNdefFormat(JNIEnv* e, jobject o,
+                                                  uint8_t* key,
+                                                  uint32_t keySize) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+  tNFA_STATUS status = NFA_STATUS_OK;
+
+  status = nativeNfcTag_doReconnect(e, o);
+  if (status != NFA_STATUS_OK) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: reconnect error, status=%u", __func__, status);
+    return JNI_FALSE;
+  }
+
+  sem_init(&sFormatSem, 0, 0);
+  sFormatOk = false;
+
+  status = EXTNS_MfcFormatTag(key, keySize);
+
+  if (status == NFA_STATUS_OK) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: wait for completion", __func__);
+    sem_wait(&sFormatSem);
+    status = sFormatOk ? NFA_STATUS_OK : NFA_STATUS_FAILED;
+  } else {
+    LOG(ERROR) << StringPrintf("%s: error status=%u", __func__, status);
+  }
+
+  sem_destroy(&sFormatSem);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  return (status == NFA_STATUS_OK) ? JNI_TRUE : JNI_FALSE;
 }
 
 /*******************************************************************************
@@ -2370,62 +2317,57 @@ static jboolean nativeNfcTag_makeMifareNdefFormat (JNIEnv *e, jobject o, uint8_t
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-static jboolean nativeNfcTag_doNdefFormat (JNIEnv *e, jobject o, jbyteArray)
-{
-    ALOGV("%s: enter", __func__);
-    tNFA_STATUS status = NFA_STATUS_OK;
-
-    // Do not try to format if tag is already deactivated.
-    if (NfcTag::getInstance ().isActivated () == false)
-    {
-        ALOGV("%s: tag already deactivated(no need to format)", __func__);
-        return JNI_FALSE;
-    }
-
-    if (sCurrentConnectedTargetProtocol == NFA_PROTOCOL_MIFARE)
-    {
-         static uint8_t mfc_key1[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
-         static uint8_t mfc_key2[6] = {0xD3, 0xF7, 0xD3, 0xF7, 0xD3, 0xF7};
-         jboolean result;
-
-         result = nativeNfcTag_makeMifareNdefFormat (e, o, mfc_key1, sizeof(mfc_key1));
-         if (result == JNI_FALSE)
-         {
-             result = nativeNfcTag_makeMifareNdefFormat (e, o, mfc_key2, sizeof(mfc_key2));
-         }
-         if(result == JNI_FALSE)
-         {
-             ALOGE("%s: error status=%u", __func__, NFA_STATUS_FAILED);
-             EXTNS_SetConnectFlag (false);
-         }
-         return result;
-    }
-
-    sem_init (&sFormatSem, 0, 0);
-    sFormatOk = false;
-    status = NFA_RwFormatTag ();
-    if (status == NFA_STATUS_OK)
-    {
-        ALOGV("%s: wait for completion", __func__);
-        sem_wait (&sFormatSem);
-        status = sFormatOk ? NFA_STATUS_OK : NFA_STATUS_FAILED;
+static jboolean nativeNfcTag_doNdefFormat(JNIEnv* e, jobject o, jbyteArray) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+  tNFA_STATUS status = NFA_STATUS_OK;
+
+  // Do not try to format if tag is already deactivated.
+  if (NfcTag::getInstance().isActivated() == false) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: tag already deactivated(no need to format)", __func__);
+    return JNI_FALSE;
+  }
+
+  if (sCurrentConnectedTargetProtocol == NFC_PROTOCOL_MIFARE) {
+    static uint8_t mfc_key1[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
+    static uint8_t mfc_key2[6] = {0xD3, 0xF7, 0xD3, 0xF7, 0xD3, 0xF7};
+    jboolean result;
+
+    result =
+        nativeNfcTag_makeMifareNdefFormat(e, o, mfc_key1, sizeof(mfc_key1));
+    if (result == JNI_FALSE) {
+      result =
+          nativeNfcTag_makeMifareNdefFormat(e, o, mfc_key2, sizeof(mfc_key2));
+    }
+    if (result == JNI_FALSE) {
+      LOG(ERROR) << StringPrintf("%s: error status=%u", __func__,
+                                 NFA_STATUS_FAILED);
+      EXTNS_SetConnectFlag(false);
     }
-    else
-    {
-        ALOGE("%s: error status=%u", __func__, status);
-    }
-    sem_destroy (&sFormatSem);
-
-    if (sCurrentConnectedTargetProtocol == NFA_PROTOCOL_ISO_DEP)
-    {
-        int retCode = NFCSTATUS_SUCCESS;
-        retCode = nativeNfcTag_doReconnect (e, o);
-    }
-    ALOGV("%s: exit", __func__);
-    return (status == NFA_STATUS_OK) ? JNI_TRUE : JNI_FALSE;
+    return result;
+  }
+
+  sem_init(&sFormatSem, 0, 0);
+  sFormatOk = false;
+  status = NFA_RwFormatTag();
+  if (status == NFA_STATUS_OK) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: wait for completion", __func__);
+    sem_wait(&sFormatSem);
+    status = sFormatOk ? NFA_STATUS_OK : NFA_STATUS_FAILED;
+  } else {
+    LOG(ERROR) << StringPrintf("%s: error status=%u", __func__, status);
+  }
+  sem_destroy(&sFormatSem);
+
+  if (sCurrentConnectedTargetProtocol == NFA_PROTOCOL_ISO_DEP) {
+    int retCode = NFCSTATUS_SUCCESS;
+    retCode = nativeNfcTag_doReconnect(e, o);
+  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  return (status == NFA_STATUS_OK) ? JNI_TRUE : JNI_FALSE;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeNfcTag_doMakeReadonlyResult
@@ -2437,74 +2379,71 @@ static jboolean nativeNfcTag_doNdefFormat (JNIEnv *e, jobject o, jbyteArray)
 ** Returns:         None
 **
 *******************************************************************************/
-void nativeNfcTag_doMakeReadonlyResult (tNFA_STATUS status)
-{
-    if (sMakeReadonlyWaitingForComplete != JNI_FALSE)
-    {
-        sMakeReadonlyWaitingForComplete = JNI_FALSE;
-        sMakeReadonlyStatus = status;
+void nativeNfcTag_doMakeReadonlyResult(tNFA_STATUS status) {
+  if (sMakeReadonlyWaitingForComplete != JNI_FALSE) {
+    sMakeReadonlyWaitingForComplete = JNI_FALSE;
+    sMakeReadonlyStatus = status;
 
-        sem_post (&sMakeReadonlySem);
-    }
+    sem_post(&sMakeReadonlySem);
+  }
 }
 
 /*******************************************************************************
  **
-** Function:        nativeNfcTag_makeMifareReadonly
-**
-** Description:     Make the mifare classic tag read-only.
-**                  e: JVM environment.
-**                  o: Java object.
-**                  key: Key to access the tag.
-**                  keySize: size of Key.
-**
-** Returns:         True if ok.
-**
-*******************************************************************************/
-static jboolean nativeNfcTag_makeMifareReadonly (JNIEnv *e, jobject o, uint8_t *key, int32_t keySize)
-{
-    jboolean result = JNI_FALSE;
-    tNFA_STATUS status = NFA_STATUS_OK;
+ ** Function:        nativeNfcTag_makeMifareReadonly
+ **
+ ** Description:     Make the mifare classic tag read-only.
+ **                  e: JVM environment.
+ **                  o: Java object.
+ **                  key: Key to access the tag.
+ **                  keySize: size of Key.
+ **
+ ** Returns:         True if ok.
+ **
+ *******************************************************************************/
+static jboolean nativeNfcTag_makeMifareReadonly(JNIEnv* e, jobject o,
+                                                uint8_t* key, int32_t keySize) {
+  jboolean result = JNI_FALSE;
+  tNFA_STATUS status = NFA_STATUS_OK;
 
-    sMakeReadonlyStatus = NFA_STATUS_FAILED;
+  sMakeReadonlyStatus = NFA_STATUS_FAILED;
 
-    ALOGV("%s", __func__);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
 
-    /* Create the make_readonly semaphore */
-    if (sem_init (&sMakeReadonlySem, 0, 0) == -1)
-    {
-        ALOGE("%s: Make readonly semaphore creation failed (errno=0x%08x)", __func__, errno);
-        return JNI_FALSE;
-    }
+  /* Create the make_readonly semaphore */
+  if (sem_init(&sMakeReadonlySem, 0, 0) == -1) {
+    LOG(ERROR) << StringPrintf(
+        "%s: Make readonly semaphore creation failed (errno=0x%08x)", __func__,
+        errno);
+    return JNI_FALSE;
+  }
 
-    sMakeReadonlyWaitingForComplete = JNI_TRUE;
+  sMakeReadonlyWaitingForComplete = JNI_TRUE;
 
-    status = nativeNfcTag_doReconnect (e, o);
-    if (status != NFA_STATUS_OK)
-    {
-        goto TheEnd;
-    }
+  status = nativeNfcTag_doReconnect(e, o);
+  if (status != NFA_STATUS_OK) {
+    goto TheEnd;
+  }
 
-    status = EXTNS_MfcSetReadOnly (key, keySize);
-    if (status != NFA_STATUS_OK)
-    {
-        goto TheEnd;
-    }
-    sem_wait (&sMakeReadonlySem);
+  status = EXTNS_MfcSetReadOnly(key, keySize);
+  if (status != NFA_STATUS_OK) {
+    goto TheEnd;
+  }
+  sem_wait(&sMakeReadonlySem);
 
-    if (sMakeReadonlyStatus == NFA_STATUS_OK)
-    {
-        result = JNI_TRUE;
-    }
+  if (sMakeReadonlyStatus == NFA_STATUS_OK) {
+    result = JNI_TRUE;
+  }
 
 TheEnd:
-    /* Destroy semaphore */
-    if (sem_destroy (&sMakeReadonlySem))
-    {
-        ALOGE("%s: Failed to destroy read_only semaphore (errno=0x%08x)", __func__, errno);
-    }
-    sMakeReadonlyWaitingForComplete = JNI_FALSE;
-    return result;
+  /* Destroy semaphore */
+  if (sem_destroy(&sMakeReadonlySem)) {
+    LOG(ERROR) << StringPrintf(
+        "%s: Failed to destroy read_only semaphore (errno=0x%08x)", __func__,
+        errno);
+  }
+  sMakeReadonlyWaitingForComplete = JNI_FALSE;
+  return result;
 }
 
 /*******************************************************************************
@@ -2519,74 +2458,71 @@ TheEnd:
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-static jboolean nativeNfcTag_doMakeReadonly (JNIEnv *e, jobject o, jbyteArray)
-{
-    jboolean result = JNI_FALSE;
-    tNFA_STATUS status = NFA_STATUS_OK;
-
-    ALOGV("%s", __func__);
-
-    if (sCurrentConnectedTargetProtocol == NFA_PROTOCOL_MIFARE)
-    {
-        static uint8_t mfc_key1[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
-        static uint8_t mfc_key2[6] = {0xD3, 0xF7, 0xD3, 0xF7, 0xD3, 0xF7};
-        result = nativeNfcTag_makeMifareReadonly (e, o, mfc_key1, sizeof(mfc_key1));
-        if (result == JNI_FALSE)
-        {
-            result = nativeNfcTag_makeMifareReadonly (e, o, mfc_key2, sizeof(mfc_key2));
-        }
-        return result;
-    }
+static jboolean nativeNfcTag_doMakeReadonly(JNIEnv* e, jobject o, jbyteArray) {
+  jboolean result = JNI_FALSE;
+  tNFA_STATUS status = NFA_STATUS_OK;
 
-    /* Create the make_readonly semaphore */
-    if (sem_init (&sMakeReadonlySem, 0, 0) == -1)
-    {
-        ALOGE("%s: Make readonly semaphore creation failed (errno=0x%08x)", __func__, errno);
-        return JNI_FALSE;
-    }
-
-    sMakeReadonlyWaitingForComplete = JNI_TRUE;
-
-    // Hard-lock the tag (cannot be reverted)
-    status = NFA_RwSetTagReadOnly(true);
-    if (status == NFA_STATUS_REJECTED)
-    {
-        status = NFA_RwSetTagReadOnly (false); //try soft lock
-        if (status != NFA_STATUS_OK)
-        {
-            ALOGE("%s: fail soft lock, status=%d", __func__, status);
-            goto TheEnd;
-        }
-    }
-    else if(status != NFA_STATUS_OK)
-    {
-        ALOGE("%s: fail hard lock, status=%d", __func__, status);
-        goto TheEnd;
-    }
-
-    /*Wait for check NDEF completion status*/
-    if (sem_wait (&sMakeReadonlySem))
-    {
-        ALOGE("%s: Failed to wait for make_readonly semaphore (errno=0x%08x)", __func__, errno);
-        goto TheEnd;
-    }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
 
-    if(sMakeReadonlyStatus == NFA_STATUS_OK)
-    {
-        result = JNI_TRUE;
+  if (sCurrentConnectedTargetProtocol == NFC_PROTOCOL_MIFARE) {
+    static uint8_t mfc_key1[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
+    static uint8_t mfc_key2[6] = {0xD3, 0xF7, 0xD3, 0xF7, 0xD3, 0xF7};
+    result = nativeNfcTag_makeMifareReadonly(e, o, mfc_key1, sizeof(mfc_key1));
+    if (result == JNI_FALSE) {
+      result =
+          nativeNfcTag_makeMifareReadonly(e, o, mfc_key2, sizeof(mfc_key2));
     }
+    return result;
+  }
+
+  /* Create the make_readonly semaphore */
+  if (sem_init(&sMakeReadonlySem, 0, 0) == -1) {
+    LOG(ERROR) << StringPrintf(
+        "%s: Make readonly semaphore creation failed (errno=0x%08x)", __func__,
+        errno);
+    return JNI_FALSE;
+  }
+
+  sMakeReadonlyWaitingForComplete = JNI_TRUE;
+
+  // Hard-lock the tag (cannot be reverted)
+  status = NFA_RwSetTagReadOnly(true);
+  if (status == NFA_STATUS_REJECTED) {
+    status = NFA_RwSetTagReadOnly(false);  // try soft lock
+    if (status != NFA_STATUS_OK) {
+      LOG(ERROR) << StringPrintf("%s: fail soft lock, status=%d", __func__,
+                                 status);
+      goto TheEnd;
+    }
+  } else if (status != NFA_STATUS_OK) {
+    LOG(ERROR) << StringPrintf("%s: fail hard lock, status=%d", __func__,
+                               status);
+    goto TheEnd;
+  }
+
+  /*Wait for check NDEF completion status*/
+  if (sem_wait(&sMakeReadonlySem)) {
+    LOG(ERROR) << StringPrintf(
+        "%s: Failed to wait for make_readonly semaphore (errno=0x%08x)",
+        __func__, errno);
+    goto TheEnd;
+  }
+
+  if (sMakeReadonlyStatus == NFA_STATUS_OK) {
+    result = JNI_TRUE;
+  }
 
 TheEnd:
-    /* Destroy semaphore */
-    if (sem_destroy (&sMakeReadonlySem))
-    {
-        ALOGE("%s: Failed to destroy read_only semaphore (errno=0x%08x)", __func__, errno);
-    }
-    sMakeReadonlyWaitingForComplete = JNI_FALSE;
-    return result;
+  /* Destroy semaphore */
+  if (sem_destroy(&sMakeReadonlySem)) {
+    LOG(ERROR) << StringPrintf(
+        "%s: Failed to destroy read_only semaphore (errno=0x%08x)", __func__,
+        errno);
+  }
+  sMakeReadonlyWaitingForComplete = JNI_FALSE;
+  return result;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeNfcTag_registerNdefTypeHandler
@@ -2597,17 +2533,16 @@ TheEnd:
 ** Returns:         None
 **
 *******************************************************************************/
-//register a callback to receive NDEF message from the tag
-//from the NFA_NDEF_DATA_EVT;
-void nativeNfcTag_registerNdefTypeHandler ()
-{
-    ALOGV("%s", __func__);
-    sNdefTypeHandlerHandle = NFA_HANDLE_INVALID;
-    NFA_RegisterNDefTypeHandler (true, NFA_TNF_DEFAULT, (uint8_t *) "", 0, ndefHandlerCallback);
-    EXTNS_MfcRegisterNDefTypeHandler (ndefHandlerCallback);
+// register a callback to receive NDEF message from the tag
+// from the NFA_NDEF_DATA_EVT;
+void nativeNfcTag_registerNdefTypeHandler() {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
+  sNdefTypeHandlerHandle = NFA_HANDLE_INVALID;
+  NFA_RegisterNDefTypeHandler(true, NFA_TNF_DEFAULT, (uint8_t*)"", 0,
+                              ndefHandlerCallback);
+  EXTNS_MfcRegisterNDefTypeHandler(ndefHandlerCallback);
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeNfcTag_deregisterNdefTypeHandler
@@ -2617,14 +2552,12 @@ void nativeNfcTag_registerNdefTypeHandler ()
 ** Returns:         None
 **
 *******************************************************************************/
-void nativeNfcTag_deregisterNdefTypeHandler ()
-{
-    ALOGV("%s", __func__);
-    NFA_DeregisterNDefTypeHandler (sNdefTypeHandlerHandle);
-    sNdefTypeHandlerHandle = NFA_HANDLE_INVALID;
+void nativeNfcTag_deregisterNdefTypeHandler() {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
+  NFA_DeregisterNDefTypeHandler(sNdefTypeHandlerHandle);
+  sNdefTypeHandlerHandle = NFA_HANDLE_INVALID;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        presenceCheckTimerProc
@@ -2634,19 +2567,18 @@ void nativeNfcTag_deregisterNdefTypeHandler ()
 ** Returns:         None
 **
 *******************************************************************************/
-static void presenceCheckTimerProc (union sigval)
-{
-    ALOGV("%s", __func__);
-    sIsTagInField = false;
-    sIsReconnecting = false;
-    {
-        SyncEventGuard guard (sNfaVSCResponseEvent);
-        sNfaVSCResponseEvent.notifyOne ();
-    }
-    {
-        SyncEventGuard guard (sNfaVSCNotificationEvent);
-        sNfaVSCNotificationEvent.notifyOne ();
-    }
+static void presenceCheckTimerProc(union sigval) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
+  sIsTagInField = false;
+  sIsReconnecting = false;
+  {
+    SyncEventGuard guard(sNfaVSCResponseEvent);
+    sNfaVSCResponseEvent.notifyOne();
+  }
+  {
+    SyncEventGuard guard(sNfaVSCNotificationEvent);
+    sNfaVSCNotificationEvent.notifyOne();
+  }
 }
 
 /*******************************************************************************
@@ -2658,48 +2590,48 @@ static void presenceCheckTimerProc (union sigval)
 ** Returns:         None
 **
 *******************************************************************************/
-static void sReconnectTimerProc (union sigval)
-{
-    ALOGV("%s", __func__);
-    {
-        SyncEventGuard guard (sNfaVSCResponseEvent);
-        sNfaVSCResponseEvent.notifyOne ();
-    }
-    {
-        SyncEventGuard guard (sNfaVSCNotificationEvent);
-        sNfaVSCNotificationEvent.notifyOne ();
-    }
+static void sReconnectTimerProc(union sigval) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
+  {
+    SyncEventGuard guard(sNfaVSCResponseEvent);
+    sNfaVSCResponseEvent.notifyOne();
+  }
+  {
+    SyncEventGuard guard(sNfaVSCNotificationEvent);
+    sNfaVSCNotificationEvent.notifyOne();
+  }
 }
 
 /*******************************************************************************
 **
-** Function:        acquireRfInterfaceMutexLock
+** Function:        nativeNfcTag_acquireRfInterfaceMutexLock
 **
 ** Description:     acquire lock
 **
 ** Returns:         None
 **
 *******************************************************************************/
-void acquireRfInterfaceMutexLock()
-{
-    ALOGV("%s: try to acquire lock", __func__);
-    sRfInterfaceMutex.lock();
-    ALOGV("%s: sRfInterfaceMutex lock", __func__);
+void nativeNfcTag_acquireRfInterfaceMutexLock() {
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: try to acquire lock", __func__);
+  sRfInterfaceMutex.lock();
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: sRfInterfaceMutex lock", __func__);
 }
 
 /*******************************************************************************
 **
-** Function:       releaseRfInterfaceMutexLock
+** Function:       nativeNfcTag_releaseRfInterfaceMutexLock
 **
 ** Description:    release the lock
 **
 ** Returns:        None
 **
 *******************************************************************************/
-void releaseRfInterfaceMutexLock()
-{
-    sRfInterfaceMutex.unlock();
-    ALOGV("%s: sRfInterfaceMutex unlock", __func__);
+void nativeNfcTag_releaseRfInterfaceMutexLock() {
+  sRfInterfaceMutex.unlock();
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: sRfInterfaceMutex unlock", __func__);
 }
 
 /*****************************************************************************
@@ -2707,24 +2639,23 @@ void releaseRfInterfaceMutexLock()
 ** JNI functions for Android 4.0.3
 **
 *****************************************************************************/
-static JNINativeMethod gMethods[] =
-{
-   {"doConnect", "(I)I", (void *)nativeNfcTag_doConnect},
-   {"doDisconnect", "()Z", (void *)nativeNfcTag_doDisconnect},
-   {"doReconnect", "()I", (void *)nativeNfcTag_doReconnect},
-   {"doHandleReconnect", "(I)I", (void *)nativeNfcTag_doHandleReconnect},
-   {"doTransceive", "([BZ[I)[B", (void *)nativeNfcTag_doTransceive},
-   {"doGetNdefType", "(II)I", (void *)nativeNfcTag_doGetNdefType},
-   {"doCheckNdef", "([I)I", (void *)nativeNfcTag_doCheckNdef},
-   {"doRead", "()[B", (void *)nativeNfcTag_doRead},
-   {"doWrite", "([B)Z", (void *)nativeNfcTag_doWrite},
-   {"doPresenceCheck", "()Z", (void *)nativeNfcTag_doPresenceCheck},
-   {"doIsIsoDepNdefFormatable", "([B[B)Z", (void *)nativeNfcTag_doIsIsoDepNdefFormatable},
-   {"doNdefFormat", "([B)Z", (void *)nativeNfcTag_doNdefFormat},
-   {"doMakeReadonly", "([B)Z", (void *)nativeNfcTag_doMakeReadonly},
+static JNINativeMethod gMethods[] = {
+    {"doConnect", "(I)I", (void*)nativeNfcTag_doConnect},
+    {"doDisconnect", "()Z", (void*)nativeNfcTag_doDisconnect},
+    {"doReconnect", "()I", (void*)nativeNfcTag_doReconnect},
+    {"doHandleReconnect", "(I)I", (void*)nativeNfcTag_doHandleReconnect},
+    {"doTransceive", "([BZ[I)[B", (void*)nativeNfcTag_doTransceive},
+    {"doGetNdefType", "(II)I", (void*)nativeNfcTag_doGetNdefType},
+    {"doCheckNdef", "([I)I", (void*)nativeNfcTag_doCheckNdef},
+    {"doRead", "()[B", (void*)nativeNfcTag_doRead},
+    {"doWrite", "([B)Z", (void*)nativeNfcTag_doWrite},
+    {"doPresenceCheck", "()Z", (void*)nativeNfcTag_doPresenceCheck},
+    {"doIsIsoDepNdefFormatable", "([B[B)Z",
+     (void*)nativeNfcTag_doIsIsoDepNdefFormatable},
+    {"doNdefFormat", "([B)Z", (void*)nativeNfcTag_doNdefFormat},
+    {"doMakeReadonly", "([B)Z", (void*)nativeNfcTag_doMakeReadonly},
 };
 
-
 /*******************************************************************************
 **
 ** Function:        register_com_android_nfc_NativeNfcTag
@@ -2735,11 +2666,10 @@ static JNINativeMethod gMethods[] =
 ** Returns:         Status of registration.
 **
 *******************************************************************************/
-int register_com_android_nfc_NativeNfcTag (JNIEnv *e)
-{
-    ALOGV("%s", __func__);
-    return jniRegisterNativeMethods (e, gNativeNfcTagClassName, gMethods, NELEM (gMethods));
+int register_com_android_nfc_NativeNfcTag(JNIEnv* e) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
+  return jniRegisterNativeMethods(e, gNativeNfcTagClassName, gMethods,
+                                  NELEM(gMethods));
 }
 
-
 } /* namespace android */
diff --git a/nci/jni/NativeNxpFeature.cpp b/nci/jni/NativeNxpFeature.cpp
index 170575c8..9028d347 100644
--- a/nci/jni/NativeNxpFeature.cpp
+++ b/nci/jni/NativeNxpFeature.cpp
@@ -2,7 +2,7 @@
  * Copyright (c) 2016, The Linux Foundation. All rights reserved.
  * Not a Contribution.
  *
- * Copyright (C) 2015 NXP Semiconductors
+ * Copyright (C) 2015-2018 NXP Semiconductors
  * The original Work has been changed by NXP Semiconductors.
  *
  * Copyright (C) 2012 The Android Open Source Project
@@ -19,134 +19,195 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-#include <semaphore.h>
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
 #include <errno.h>
-#include "_OverrideLog.h"
-#include "NfcJniUtil.h"
-#include "SyncEvent.h"
+#include <semaphore.h>
 #include "JavaClassConstants.h"
-#include "config.h"
 #include "NfcAdaptation.h"
+#include "NfcJniUtil.h"
 #include "RoutingManager.h"
+#include "SyncEvent.h"
+#include "config.h"
 
-extern "C"
-{
 #include "nfa_api.h"
 #include "nfa_rw_api.h"
-}
 
-typedef struct nxp_feature_data
-{
-    SyncEvent    NxpFeatureConfigEvt;
-    tNFA_STATUS  wstatus;
-    uint8_t      rsp_data[255];
-    uint8_t      rsp_len;
-}Nxp_Feature_Data_t;
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+
+typedef struct nxp_feature_data {
+  SyncEvent NxpFeatureConfigEvt;
+  Mutex mMutex;
+  tNFA_STATUS wstatus;
+  uint8_t rsp_data[255];
+  uint8_t rsp_len;
+} Nxp_Feature_Data_t;
 
 extern int32_t gActualSeCount;
 uint8_t swp_getconfig_status;
-#if(NXP_EXTNS == TRUE)
+#if (NXP_EXTNS == TRUE)
 extern uint8_t sSelectedUicc;
 #endif
-namespace android
-{
+namespace android {
 static Nxp_Feature_Data_t gnxpfeature_conf;
 void SetCbStatus(tNFA_STATUS status);
 tNFA_STATUS GetCbStatus(void);
-static void NxpResponse_Cb(uint8_t event, uint16_t param_len, uint8_t *p_param);
-static void NxpResponse_SetDhlf_Cb(uint8_t event, uint16_t param_len, uint8_t *p_param);
-static void NxpResponse_SetVenConfig_Cb(uint8_t event, uint16_t param_len, uint8_t *p_param);
-#if(NXP_EXTNS == TRUE)
+static void NxpResponse_Cb(uint8_t event, uint16_t param_len, uint8_t* p_param);
+static void NxpResponse_SetDhlf_Cb(uint8_t event, uint16_t param_len,
+                                   uint8_t* p_param);
+static void NxpResponse_SetVenConfig_Cb(uint8_t event, uint16_t param_len,
+                                        uint8_t* p_param);
+#if (NXP_EXTNS == TRUE)
 tNFA_STATUS NxpNfc_Send_CoreResetInit_Cmd(void);
-typedef void (tNXP_RSP_CBACK)(uint8_t event, uint16_t param_len, uint8_t *p_param);
-tNFA_STATUS NxpNfc_Write_Cmd(uint8_t retlen, uint8_t* buffer, tNXP_RSP_CBACK* p_cback);
+typedef void(tNXP_RSP_CBACK)(uint8_t event, uint16_t param_len,
+                             uint8_t* p_param);
+tNFA_STATUS NxpNfc_Write_Cmd(uint8_t retlen, uint8_t* buffer,
+                             tNXP_RSP_CBACK* p_cback);
+tNFA_STATUS NxpNfcUpdateEeprom(uint8_t* param, uint8_t len, uint8_t* val);
 #endif
+}  // namespace android
+
+namespace android {
+void SetCbStatus(tNFA_STATUS status) { gnxpfeature_conf.wstatus = status; }
+
+tNFA_STATUS GetCbStatus(void) { return gnxpfeature_conf.wstatus; }
+
+void NxpPropCmd_OnResponseCallback(uint8_t event, uint16_t param_len,
+                                   uint8_t *p_param) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+    "NxpPropCmd_OnResponseCallback: Received length data = 0x%x status = "
+        "0x%x", param_len, p_param[3]);
+  uint8_t oid = p_param[1];
+  uint8_t status = NFA_STATUS_FAILED;
+
+  switch (oid) {
+  case (0x1A):
+  /*FALL_THRU*/
+  case (0x1C):
+    status = p_param[3];
+    break;
+  case (0x1B):
+    status = p_param[param_len - 1];
+    break;
+  default:
+    LOG(ERROR) << StringPrintf("Propreitary Rsp: OID is not supported");
+    break;
+  }
+
+  android::SetCbStatus(status);
+
+  android::gnxpfeature_conf.rsp_len = (uint8_t)param_len;
+  memcpy(android::gnxpfeature_conf.rsp_data, p_param, param_len);
+  SyncEventGuard guard(android::gnxpfeature_conf.NxpFeatureConfigEvt);
+  android::gnxpfeature_conf.NxpFeatureConfigEvt.notifyOne();
 }
-
-namespace android
-{
-void SetCbStatus(tNFA_STATUS status)
-{
-    gnxpfeature_conf.wstatus = status;
-}
-
-tNFA_STATUS GetCbStatus(void)
-{
-    return gnxpfeature_conf.wstatus;
+tNFA_STATUS NxpPropCmd_send(uint8_t *pData4Tx, uint8_t dataLen,
+                            uint8_t *rsp_len, uint8_t *rsp_buf,
+                            uint32_t rspTimeout, tHAL_NFC_ENTRY *halMgr) {
+  tNFA_STATUS status = NFA_STATUS_FAILED;
+  bool retVal = false;
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: prop cmd being txed", __func__);
+
+  gnxpfeature_conf.mMutex.lock();
+
+  android::SetCbStatus(NFA_STATUS_FAILED);
+  SyncEventGuard guard(android::gnxpfeature_conf.NxpFeatureConfigEvt);
+
+  status =
+      NFA_SendRawVsCommand(dataLen, pData4Tx, NxpPropCmd_OnResponseCallback);
+  if (status == NFA_STATUS_OK) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Success NFA_SendNxpNciCommand", __func__);
+
+    retVal = android::gnxpfeature_conf.NxpFeatureConfigEvt.wait(
+        rspTimeout); /* wait for callback */
+    if (retVal == false) {
+      android::SetCbStatus(NFA_STATUS_TIMEOUT);
+      android::gnxpfeature_conf.rsp_len = 0;
+      memset(android::gnxpfeature_conf.rsp_data, 0,
+             sizeof(android::gnxpfeature_conf.rsp_data));
+    }
+  } else {
+    LOG(ERROR) << StringPrintf("%s: Failed NFA_SendNxpNciCommand", __func__);
+  }
+  status = android::GetCbStatus();
+  if ((android::gnxpfeature_conf.rsp_len > 3) && (rsp_buf != NULL)) {
+    *rsp_len = android::gnxpfeature_conf.rsp_len - 3;
+    memcpy(rsp_buf, android::gnxpfeature_conf.rsp_data + 3,
+           android::gnxpfeature_conf.rsp_len - 3);
+  }
+  android::gnxpfeature_conf.mMutex.unlock();
+  return status;
 }
 
-static void NxpResponse_Cb(uint8_t event, uint16_t param_len, uint8_t *p_param)
-{
-    (void)event;
-    ALOGV("NxpResponse_Cb Received length data = 0x%x status = 0x%x", param_len, p_param[3]);
-
-    if(p_param[3] == 0x00)
-    {
-        SetCbStatus(NFA_STATUS_OK);
-    }
-    else
-    {
-        SetCbStatus(NFA_STATUS_FAILED);
-    }
-    gnxpfeature_conf.rsp_len = (uint8_t)param_len;
-    if(param_len > 0 && p_param != NULL)
-    {
-        memcpy(gnxpfeature_conf.rsp_data, p_param, param_len);
-    }
-    SyncEventGuard guard(gnxpfeature_conf.NxpFeatureConfigEvt);
-    gnxpfeature_conf.NxpFeatureConfigEvt.notifyOne ();
+static void NxpResponse_Cb(uint8_t event, uint16_t param_len,
+                           uint8_t* p_param) {
+  (void)event;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "NxpResponse_Cb Received length data = 0x%x status = 0x%x", param_len,
+      p_param[3]);
 
+  if (p_param[3] == 0x00) {
+    SetCbStatus(NFA_STATUS_OK);
+  } else {
+    SetCbStatus(NFA_STATUS_FAILED);
+  }
+  gnxpfeature_conf.rsp_len = (uint8_t)param_len;
+  if (param_len > 0 && p_param != NULL) {
+    memcpy(gnxpfeature_conf.rsp_data, p_param, param_len);
+  }
+  SyncEventGuard guard(gnxpfeature_conf.NxpFeatureConfigEvt);
+  gnxpfeature_conf.NxpFeatureConfigEvt.notifyOne();
 }
-static void NxpResponse_SetDhlf_Cb(uint8_t event, uint16_t param_len, uint8_t *p_param)
-{
-    (void)event;
-    ALOGV("NxpResponse_SetDhlf_Cb Received length data = 0x%x status = 0x%x", param_len, p_param[3]);
-
-    if(p_param[3] == 0x00)
-    {
-        SetCbStatus(NFA_STATUS_OK);
-    }
-    else
-    {
-        SetCbStatus(NFA_STATUS_FAILED);
-    }
-
-    SyncEventGuard guard(gnxpfeature_conf.NxpFeatureConfigEvt);
-    gnxpfeature_conf.NxpFeatureConfigEvt.notifyOne ();
+static void NxpResponse_SetDhlf_Cb(uint8_t event, uint16_t param_len,
+                                   uint8_t* p_param) {
+  (void)event;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "NxpResponse_SetDhlf_Cb Received length data = 0x%x status = 0x%x",
+      param_len, p_param[3]);
+
+  if (p_param[3] == 0x00) {
+    SetCbStatus(NFA_STATUS_OK);
+  } else {
+    SetCbStatus(NFA_STATUS_FAILED);
+  }
 
+  SyncEventGuard guard(gnxpfeature_conf.NxpFeatureConfigEvt);
+  gnxpfeature_conf.NxpFeatureConfigEvt.notifyOne();
 }
 
-static void NxpResponse_SetVenConfig_Cb(uint8_t /* event */, uint16_t param_len, uint8_t *p_param)
-{
-    ALOGV("NxpResponse_SetVenConfig_Cb Received length data = 0x%x status = 0x%x", param_len, p_param[3]);
-    if(p_param[3] == 0x00)
-    {
-        SetCbStatus(NFA_STATUS_OK);
-    }
-    else
-    {
-        SetCbStatus(NFA_STATUS_FAILED);
-    }
-    SyncEventGuard guard(gnxpfeature_conf.NxpFeatureConfigEvt);
-    gnxpfeature_conf.NxpFeatureConfigEvt.notifyOne ();
+static void NxpResponse_SetVenConfig_Cb(uint8_t event, uint16_t param_len,
+                                        uint8_t* p_param) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "NxpResponse_SetVenConfig_Cb Received length data = 0x%x status = 0x%x",
+      param_len, p_param[3]);
+  if (p_param[3] == 0x00) {
+    SetCbStatus(NFA_STATUS_OK);
+  } else {
+    SetCbStatus(NFA_STATUS_FAILED);
+  }
+  SyncEventGuard guard(gnxpfeature_conf.NxpFeatureConfigEvt);
+  gnxpfeature_conf.NxpFeatureConfigEvt.notifyOne();
 }
 
-static void NxpResponse_SetSWPBitRate_Cb(uint8_t /* event */, uint16_t param_len, uint8_t *p_param)
-{
-    ALOGV("NxpResponse_SetSWPBitRate_CbReceived length data = 0x%x status = 0x%x", param_len, p_param[3]);
-    if(p_param[3] == 0x00)
-    {
-        SetCbStatus(NFA_STATUS_OK);
-    }
-    else
-    {
-        SetCbStatus(NFA_STATUS_FAILED);
-    }
-    SyncEventGuard guard(gnxpfeature_conf.NxpFeatureConfigEvt);
-    gnxpfeature_conf.NxpFeatureConfigEvt.notifyOne ();
+static void NxpResponse_SetSWPBitRate_Cb(uint8_t event, uint16_t param_len,
+                                         uint8_t* p_param) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "NxpResponse_SetSWPBitRate_CbReceived length data = 0x%x status = 0x%x",
+      param_len, p_param[3]);
+  if (p_param[3] == 0x00) {
+    SetCbStatus(NFA_STATUS_OK);
+  } else {
+    SetCbStatus(NFA_STATUS_FAILED);
+  }
+  SyncEventGuard guard(gnxpfeature_conf.NxpFeatureConfigEvt);
+  gnxpfeature_conf.NxpFeatureConfigEvt.notifyOne();
 }
 
-#if(NXP_EXTNS == TRUE)
+#if (NXP_EXTNS == TRUE)
 /*******************************************************************************
  **
  ** Function:        NxpResponse_SwitchUICC_Cb
@@ -157,23 +218,23 @@ static void NxpResponse_SetSWPBitRate_Cb(uint8_t /* event */, uint16_t param_len
  ** Returns:         None
  **
  *******************************************************************************/
-static void NxpResponse_SwitchUICC_Cb(uint8_t event, uint16_t param_len, uint8_t *p_param)
-{
-    if(!nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
-        ALOGV("%s STAT_DUAL_UICC_EXT_SWITCH not available. Returning",__func__);
-        return ;
-    }
-    ALOGV("NxpResponse_SwitchUICC_Cb length data = 0x%x status = 0x%x", param_len, p_param[3]);
-    if(p_param[3] == 0x00)
-    {
-        SetCbStatus(NFA_STATUS_OK);
-    }
-    else
-    {
-        SetCbStatus(NFA_STATUS_FAILED);
-    }
-    SyncEventGuard guard(gnxpfeature_conf.NxpFeatureConfigEvt);
-    gnxpfeature_conf.NxpFeatureConfigEvt.notifyOne ();
+static void NxpResponse_SwitchUICC_Cb(uint8_t event, uint16_t param_len,
+                                      uint8_t* p_param) {
+  if (!nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s STAT_DUAL_UICC_EXT_SWITCH not available. Returning", __func__);
+    return;
+  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "NxpResponse_SwitchUICC_Cb length data = 0x%x status = 0x%x", param_len,
+      p_param[3]);
+  if (p_param[3] == 0x00) {
+    SetCbStatus(NFA_STATUS_OK);
+  } else {
+    SetCbStatus(NFA_STATUS_FAILED);
+  }
+  SyncEventGuard guard(gnxpfeature_conf.NxpFeatureConfigEvt);
+  gnxpfeature_conf.NxpFeatureConfigEvt.notifyOne();
 }
 /*******************************************************************************
  **
@@ -184,23 +245,24 @@ static void NxpResponse_SwitchUICC_Cb(uint8_t event, uint16_t param_len, uint8_t
  ** Returns:         success/failure
  **
  *******************************************************************************/
-static void NxpResponse_EnableAGCDebug_Cb(uint8_t /* event */, uint16_t param_len, uint8_t *p_param)
-{
-    if(nfcFL.chipType == pn547C2) {
-        ALOGV("%s chipType : pn547C2. Not allowed. Returning", __func__);
-        return;
-    }
-
-    ALOGV("NxpResponse_EnableAGCDebug_Cb Received length data = 0x%x", param_len);
-    SetCbStatus(NFA_STATUS_FAILED);
-    if(param_len > 0)
-    {
-        gnxpfeature_conf.rsp_len = param_len;
-        memcpy(gnxpfeature_conf.rsp_data, p_param, gnxpfeature_conf.rsp_len);
-        SetCbStatus(NFA_STATUS_OK);
-    }
-    SyncEventGuard guard(gnxpfeature_conf.NxpFeatureConfigEvt);
-    gnxpfeature_conf.NxpFeatureConfigEvt.notifyOne ();
+static void NxpResponse_EnableAGCDebug_Cb(uint8_t event, uint16_t param_len,
+                                          uint8_t* p_param) {
+  if (nfcFL.chipType == pn547C2) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s chipType : pn547C2. Not allowed. Returning", __func__);
+    return;
+  }
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "NxpResponse_EnableAGCDebug_Cb Received length data = 0x%x", param_len);
+  SetCbStatus(NFA_STATUS_FAILED);
+  if (param_len > 0) {
+    gnxpfeature_conf.rsp_len = param_len;
+    memcpy(gnxpfeature_conf.rsp_data, p_param, gnxpfeature_conf.rsp_len);
+    SetCbStatus(NFA_STATUS_OK);
+  }
+  SyncEventGuard guard(gnxpfeature_conf.NxpFeatureConfigEvt);
+  gnxpfeature_conf.NxpFeatureConfigEvt.notifyOne();
 }
 /*******************************************************************************
  **
@@ -211,66 +273,66 @@ static void NxpResponse_EnableAGCDebug_Cb(uint8_t /* event */, uint16_t param_le
  ** Returns:         success/failure
  **
  *******************************************************************************/
-static void printDataByte(uint16_t param_len, uint8_t *p_param)
-{
-    if(nfcFL.chipType == pn547C2) {
-            ALOGV("%s chipType : pn547C2. Not allowed. Returning", __func__);
-            return;
-        }
-    char print_buffer[param_len * 3 + 1];
-    memset (print_buffer, 0, sizeof(print_buffer));
-    for (int i = 0; i < param_len; i++)
-    {
-        snprintf(&print_buffer[i * 2], 3 ,"%02X", p_param[i]);
-    }
-    ALOGV("AGC Dynamic RSSI values  = %s", print_buffer);
+static void printDataByte(uint16_t param_len, uint8_t* p_param) {
+  if (nfcFL.chipType == pn547C2) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s chipType : pn547C2. Not allowed. Returning", __func__);
+    return;
+  }
+  char print_buffer[param_len * 3 + 1];
+  memset(print_buffer, 0, sizeof(print_buffer));
+  for (int i = 0; i < param_len; i++) {
+    snprintf(&print_buffer[i * 2], 3, "%02X", p_param[i]);
+  }
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("AGC Dynamic RSSI values  = %s", print_buffer);
 }
 /*******************************************************************************
  **
  ** Function:        SendAGCDebugCommand()
  **
  ** Description:     Sends the AGC Debug command.This enables dynamic RSSI
- **                  look up table filling for different "TX RF settings" and enables
+ **                  look up table filling for different "TX RF settings" and
+ *enables
  **                  MWdebug prints.
  **
  ** Returns:         success/failure
  **
  *******************************************************************************/
-tNFA_STATUS SendAGCDebugCommand()
-{
-    tNFA_STATUS status = NFA_STATUS_FAILED;
-    if(nfcFL.chipType == pn547C2) {
-        ALOGV("%s chipType : pn547C2. Not allowed. Returning", __func__);
-        return NFA_STATUS_FAILED;
-    }
-
-        uint8_t cmd_buf[] = {0x2F, 0x33, 0x04, 0x40, 0x00, 0x40, 0xD8};
-
-        uint8_t cmd_buf2[] = {0x2F, 0x32, 0x01, 0x01};
-    ALOGV("%s: enter", __func__);
-    SetCbStatus(NFA_STATUS_FAILED);
-    gnxpfeature_conf.rsp_len = 0;
-    memset(gnxpfeature_conf.rsp_data, 0, 50);
-    SyncEventGuard guard (gnxpfeature_conf.NxpFeatureConfigEvt);
-    if(nfcFL.chipType == pn547C2 || nfcFL.chipType == pn551)
-        status = NFA_SendNxpNciCommand(sizeof(cmd_buf), cmd_buf, NxpResponse_EnableAGCDebug_Cb);
-    else if(nfcFL.chipType == pn553 || nfcFL.chipType == pn557)
-        status = NFA_SendNxpNciCommand(sizeof(cmd_buf2), cmd_buf2, NxpResponse_EnableAGCDebug_Cb);
-    if (status == NFA_STATUS_OK)
-    {
-        ALOGV("%s: Success NFA_SendNxpNciCommand", __func__);
-        gnxpfeature_conf.NxpFeatureConfigEvt.wait(1000); /* wait for callback */
-    }
-    else
-    {
-        ALOGE("%s: Failed NFA_SendNxpNciCommand", __func__);
-    }
-    status = GetCbStatus();
-    if(status == NFA_STATUS_OK && gnxpfeature_conf.rsp_len > 0)
-    {
-        printDataByte(gnxpfeature_conf.rsp_len, gnxpfeature_conf.rsp_data);
-    }
-    return status;
+tNFA_STATUS SendAGCDebugCommand() {
+  tNFA_STATUS status = NFA_STATUS_FAILED;
+  if (nfcFL.chipType == pn547C2) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s chipType : pn547C2. Not allowed. Returning", __func__);
+    return NFA_STATUS_FAILED;
+  }
+
+  uint8_t cmd_buf[] = {0x2F, 0x33, 0x04, 0x40, 0x00, 0x40, 0xD8};
+
+  uint8_t cmd_buf2[] = {0x2F, 0x32, 0x01, 0x01};
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+  SetCbStatus(NFA_STATUS_FAILED);
+  gnxpfeature_conf.rsp_len = 0;
+  memset(gnxpfeature_conf.rsp_data, 0, 50);
+  SyncEventGuard guard(gnxpfeature_conf.NxpFeatureConfigEvt);
+  if (nfcFL.chipType == pn547C2 || nfcFL.chipType == pn551)
+    status = NFA_SendRawVsCommand(sizeof(cmd_buf), cmd_buf,
+                                  NxpResponse_EnableAGCDebug_Cb);
+  else if (nfcFL.chipType == pn553 || nfcFL.chipType == pn557)
+    status = NFA_SendRawVsCommand(sizeof(cmd_buf2), cmd_buf2,
+                                  NxpResponse_EnableAGCDebug_Cb);
+  if (status == NFA_STATUS_OK) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Success NFA_SendRawVsCommand", __func__);
+    gnxpfeature_conf.NxpFeatureConfigEvt.wait(1000); /* wait for callback */
+  } else {
+    LOG(ERROR) << StringPrintf("%s: Failed NFA_SendRawVsCommand", __func__);
+  }
+  status = GetCbStatus();
+  if (status == NFA_STATUS_OK && gnxpfeature_conf.rsp_len > 0) {
+    printDataByte(gnxpfeature_conf.rsp_len, gnxpfeature_conf.rsp_data);
+  }
+  return status;
 }
 /*******************************************************************************
  **
@@ -281,36 +343,34 @@ tNFA_STATUS SendAGCDebugCommand()
  ** Returns:         success/failure
  **
  *******************************************************************************/
-tNFA_STATUS EmvCo_dosetPoll(jboolean enable)
-{
-    tNFA_STATUS status = NFA_STATUS_FAILED;
-    uint8_t cmd_buf[] ={0x20, 0x02, 0x05, 0x01, 0xA0, 0x44, 0x01, 0x00};
-
-    ALOGV("%s: enter", __func__);
-
-    SetCbStatus(NFA_STATUS_FAILED);
-    SyncEventGuard guard (gnxpfeature_conf.NxpFeatureConfigEvt);
-    if(enable)
-    {
-        NFA_SetEmvCoState(true);
-        ALOGV("EMV-CO polling profile");
-        cmd_buf[7] = 0x01; /*EMV-CO Poll*/
-    }
-    else
-    {
-        NFA_SetEmvCoState(false);
-        ALOGV("NFC forum polling profile");
-    }
-    status = NFA_SendNxpNciCommand(sizeof(cmd_buf), cmd_buf, NxpResponse_Cb);
-    if (status == NFA_STATUS_OK) {
-        ALOGV("%s: Success NFA_SendNxpNciCommand", __func__);
-        gnxpfeature_conf.NxpFeatureConfigEvt.wait(); /* wait for callback */
-    } else {
-        ALOGE("%s: Failed NFA_SendNxpNciCommand", __func__);
-    }
-
-    status = GetCbStatus();
-    return status;
+tNFA_STATUS EmvCo_dosetPoll(jboolean enable) {
+  tNFA_STATUS status = NFA_STATUS_FAILED;
+  uint8_t cmd_buf[] = {0x20, 0x02, 0x05, 0x01, 0xA0, 0x44, 0x01, 0x00};
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+
+  SetCbStatus(NFA_STATUS_FAILED);
+  SyncEventGuard guard(gnxpfeature_conf.NxpFeatureConfigEvt);
+  if (enable) {
+    NFA_SetEmvCoState(true);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("EMV-CO polling profile");
+    cmd_buf[7] = 0x01; /*EMV-CO Poll*/
+  } else {
+    NFA_SetEmvCoState(false);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("NFC forum polling profile");
+  }
+  status = NFA_SendRawVsCommand(sizeof(cmd_buf), cmd_buf, NxpResponse_Cb);
+  if (status == NFA_STATUS_OK) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Success NFA_SendRawVsCommand", __func__);
+    gnxpfeature_conf.NxpFeatureConfigEvt.wait(); /* wait for callback */
+  } else {
+    LOG(ERROR) << StringPrintf("%s: Failed NFA_SendRawVsCommand", __func__);
+  }
+
+  status = GetCbStatus();
+  return status;
 }
 
 /*******************************************************************************
@@ -322,44 +382,40 @@ tNFA_STATUS EmvCo_dosetPoll(jboolean enable)
  ** Returns:         success/failure
  **
  *******************************************************************************/
-tNFA_STATUS SetScreenState(jint state)
-{
-    tNFA_STATUS status = NFA_STATUS_FAILED;
-    uint8_t screen_off_state_cmd_buff[] = {0x2F, 0x15, 0x01, 0x01};
-
-    ALOGV("%s: enter", __func__);
-
-    SetCbStatus(NFA_STATUS_FAILED);
-    SyncEventGuard guard (gnxpfeature_conf.NxpFeatureConfigEvt);
-    if(state == NFA_SCREEN_STATE_OFF_UNLOCKED || state == NFA_SCREEN_STATE_OFF_LOCKED)
-    {
-        ALOGV("Set Screen OFF");
-        screen_off_state_cmd_buff[3] = 0x01;
-    }
-    else if(state == NFA_SCREEN_STATE_ON_LOCKED)
-    {
-        ALOGV("Screen ON-locked");
-        screen_off_state_cmd_buff[3] = 0x02;
-    }
-    else if(state == NFA_SCREEN_STATE_ON_UNLOCKED)
-    {
-        ALOGV("Screen ON-Unlocked");
-        screen_off_state_cmd_buff[3] = 0x00;
-    }
-    else
-    {
-        ALOGV("Invalid screen state");
-    }
-    status = NFA_SendNxpNciCommand(sizeof(screen_off_state_cmd_buff), screen_off_state_cmd_buff, NxpResponse_SetDhlf_Cb);
-    if (status == NFA_STATUS_OK) {
-        ALOGV("%s: Success NFA_SendNxpNciCommand", __func__);
-        gnxpfeature_conf.NxpFeatureConfigEvt.wait(); /* wait for callback */
-    } else {
-        ALOGE("%s: Failed NFA_SendNxpNciCommand", __func__);
-    }
-
-    status = GetCbStatus();
-    return status;
+tNFA_STATUS SetScreenState(jint state) {
+  tNFA_STATUS status = NFA_STATUS_FAILED;
+  uint8_t screen_off_state_cmd_buff[] = {0x2F, 0x15, 0x01, 0x01};
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+
+  SetCbStatus(NFA_STATUS_FAILED);
+  SyncEventGuard guard(gnxpfeature_conf.NxpFeatureConfigEvt);
+  if (state == NFA_SCREEN_STATE_OFF_UNLOCKED ||
+      state == NFA_SCREEN_STATE_OFF_LOCKED) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Set Screen OFF");
+    screen_off_state_cmd_buff[3] = 0x01;
+  } else if (state == NFA_SCREEN_STATE_ON_LOCKED) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Screen ON-locked");
+    screen_off_state_cmd_buff[3] = 0x02;
+  } else if (state == NFA_SCREEN_STATE_ON_UNLOCKED) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Screen ON-Unlocked");
+    screen_off_state_cmd_buff[3] = 0x00;
+  } else {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Invalid screen state");
+  }
+  status =
+      NFA_SendRawVsCommand(sizeof(screen_off_state_cmd_buff),
+                           screen_off_state_cmd_buff, NxpResponse_SetDhlf_Cb);
+  if (status == NFA_STATUS_OK) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Success NFA_SendRawVsCommand", __func__);
+    gnxpfeature_conf.NxpFeatureConfigEvt.wait(); /* wait for callback */
+  } else {
+    LOG(ERROR) << StringPrintf("%s: Failed NFA_SendRawVsCommand", __func__);
+  }
+
+  status = GetCbStatus();
+  return status;
 }
 
 /*******************************************************************************
@@ -371,51 +427,46 @@ tNFA_STATUS SetScreenState(jint state)
  ** Returns:         success/failure
  **
  *******************************************************************************/
-tNFA_STATUS SendAutonomousMode(jint state ,uint8_t num)
-{
-    tNFA_STATUS status = NFA_STATUS_FAILED;
-    uint8_t autonomos_cmd_buff[] = {0x2F, 0x00, 0x01, 0x00};
-    uint8_t core_standby = 0x0;
-
-
-    ALOGV("%s: enter", __func__);
-    SetCbStatus(NFA_STATUS_FAILED);
-    SyncEventGuard guard (gnxpfeature_conf.NxpFeatureConfigEvt);
-    if(state == NFA_SCREEN_STATE_OFF_UNLOCKED || state == NFA_SCREEN_STATE_OFF_LOCKED)
-    {
-        ALOGV("Set Screen OFF");
-        /*Standby mode is automatically set with Autonomous mode
-         * Value of core_standby will not be considering when state is in SCREEN_OFF Mode*/
-        autonomos_cmd_buff[3] = 0x02;
-    }
-    else if(state == NFA_SCREEN_STATE_ON_UNLOCKED)
-    {
-        ALOGV("Screen ON-Unlocked");
-        core_standby = num;
-        autonomos_cmd_buff[3] = 0x00 | core_standby;
-    }
-    else if(state == NFA_SCREEN_STATE_ON_LOCKED)
-    {
-        core_standby = num;
-        autonomos_cmd_buff[3] = 0x00 | core_standby;
-    }
-    else
-    {
-        ALOGV("Invalid screen state");
-        return  NFA_STATUS_FAILED;
-    }
-    status = NFA_SendNxpNciCommand(sizeof(autonomos_cmd_buff), autonomos_cmd_buff, NxpResponse_SetDhlf_Cb);
-    if (status == NFA_STATUS_OK) {
-        ALOGV("%s: Success NFA_SendNxpNciCommand", __func__);
-        gnxpfeature_conf.NxpFeatureConfigEvt.wait(); /* wait for callback */
-    } else {
-        ALOGE("%s: Failed NFA_SendNxpNciCommand", __func__);
-    }
-
-    status = GetCbStatus();
-    return status;
+tNFA_STATUS SendAutonomousMode(jint state, uint8_t num) {
+  tNFA_STATUS status = NFA_STATUS_FAILED;
+  uint8_t autonomos_cmd_buff[] = {0x2F, 0x00, 0x01, 0x00};
+  uint8_t core_standby = 0x0;
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+  SetCbStatus(NFA_STATUS_FAILED);
+  SyncEventGuard guard(gnxpfeature_conf.NxpFeatureConfigEvt);
+  if (state == NFA_SCREEN_STATE_OFF_UNLOCKED ||
+      state == NFA_SCREEN_STATE_OFF_LOCKED) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Set Screen OFF");
+    /*Standby mode is automatically set with Autonomous mode
+     * Value of core_standby will not be considering when state is in SCREEN_OFF
+     * Mode*/
+    autonomos_cmd_buff[3] = 0x02;
+  } else if (state == NFA_SCREEN_STATE_ON_UNLOCKED) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Screen ON-Unlocked");
+    core_standby = num;
+    autonomos_cmd_buff[3] = 0x00 | core_standby;
+  } else if (state == NFA_SCREEN_STATE_ON_LOCKED) {
+    core_standby = num;
+    autonomos_cmd_buff[3] = 0x00 | core_standby;
+  } else {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Invalid screen state");
+    return NFA_STATUS_FAILED;
+  }
+  status = NFA_SendRawVsCommand(sizeof(autonomos_cmd_buff), autonomos_cmd_buff,
+                                NxpResponse_SetDhlf_Cb);
+  if (status == NFA_STATUS_OK) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Success NFA_SendRawVsCommand", __func__);
+    gnxpfeature_conf.NxpFeatureConfigEvt.wait(); /* wait for callback */
+  } else {
+    LOG(ERROR) << StringPrintf("%s: Failed NFA_SendRawVsCommand", __func__);
+  }
+
+  status = GetCbStatus();
+  return status;
 }
-//Factory Test Code --start
+// Factory Test Code --start
 /*******************************************************************************
  **
  ** Function:        Nxp_SelfTest
@@ -425,126 +476,166 @@ tNFA_STATUS SendAutonomousMode(jint state ,uint8_t num)
  ** Returns:         success/failure
  **
  *******************************************************************************/
-tNFA_STATUS Nxp_SelfTest(uint8_t testcase, uint8_t* param)
-{
-    tNFA_STATUS status = NFA_STATUS_FAILED;
-    uint8_t swp_test[] ={0x2F, 0x3E, 0x01, 0x00};   //SWP SelfTest
-    uint8_t prbs_test[] ={0x2F, 0x30, 0x06, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF};    //PRBS SelfTest
-    uint8_t cmd_buf[9] = {0,};
-    uint8_t prbs_test_stat[] ={0x2F, 0x30, 0x04, 0x00, 0x00, 0x01, 0xFF};    //PRBS SelfTest
-    uint8_t cmd_buf_stat[7] = {0,};
-    //Factory Test Code for PRBS STOP --/
-//    uint8_t prbs_stop[] ={0x2F, 0x30, 0x04, 0x53, 0x54, 0x4F, 0x50};  //STOP!!    /*commented to eliminate unused variable warning*/
-    uint8_t rst_cmd[] ={0x20, 0x00, 0x01, 0x00};    //CORE_RESET_CMD
-    uint8_t init_cmd[] ={0x20, 0x01, 0x00};         //CORE_INIT_CMD
-    uint8_t prop_ext_act_cmd[] ={0x2F, 0x02, 0x00};         //CORE_INIT_CMD
-
-    //Factory Test Code for PRBS STOP --/
-    uint8_t cmd_len = 0;
-
-    ALOGV("%s: enter", __func__);
-
-    NfcAdaptation& theInstance = NfcAdaptation::GetInstance();
-    tHAL_NFC_ENTRY* halFuncEntries = theInstance.GetHalEntryFuncs ();
-
-    SetCbStatus(NFA_STATUS_FAILED);
-    SyncEventGuard guard (gnxpfeature_conf.NxpFeatureConfigEvt);
-    if(nfcFL.chipType != pn547C2) {
+tNFA_STATUS Nxp_SelfTest(uint8_t testcase, uint8_t* param) {
+  tNFA_STATUS status = NFA_STATUS_FAILED;
+  uint8_t swp_test[] = {0x2F, 0x3E, 0x01, 0x00};  // SWP SelfTest
+  uint8_t prbs_test[] = {0x2F, 0x30, 0x06, 0x00, 0x00,
+                         0x00, 0x00, 0x01, 0xFF};  // PRBS SelfTest
+  uint8_t cmd_buf[9] = {
+      0,
+  };
+  uint8_t prbs_test_stat[] = {0x2F, 0x30, 0x04, 0x00,
+                              0x00, 0x01, 0xFF};  // PRBS SelfTest
+  uint8_t cmd_buf_stat[7] = {
+      0,
+  };
+  // Factory Test Code for PRBS STOP --/
+  //    uint8_t prbs_stop[] ={0x2F, 0x30, 0x04, 0x53, 0x54, 0x4F, 0x50};
+  //    //STOP!!    /*commented to eliminate unused variable warning*/
+  uint8_t rst_cmd[] = {0x20, 0x00, 0x01, 0x00};     // CORE_RESET_CMD
+  uint8_t init_cmd[] = {0x20, 0x01, 0x00};          // CORE_INIT_CMD
+  uint8_t prop_ext_act_cmd[] = {0x2F, 0x02, 0x00};  // CORE_INIT_CMD
+  uint8_t cmd_nfcc_standby_off[] = {0x2F, 0x00, 0x01, 0x00};
+  uint8_t cmd_rf_on[] = {0x2F, 0x3D, 0x02, 0x20, 0x01};
+  uint8_t cmd_rf_off[] = {0x2F, 0x3D, 0x02, 0x20, 0x00};
+  uint8_t cmd_nfcc_standby_on[] = {0x2F, 0x00, 0x01, 0x01};
+  uint8_t cmd_nfcc_disc_map[] = {0x21, 0x00, 0x04, 0x01, 0x04, 0x01, 0x02};
+  uint8_t cmd_nfcc_deactivate[] = {0x21, 0x06, 0x01, 0x00};
+  // Factory Test Code for PRBS STOP --/
+  uint8_t cmd_len = 0;
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+
+  NfcAdaptation& theInstance = NfcAdaptation::GetInstance();
+  tHAL_NFC_ENTRY* halFuncEntries = theInstance.GetHalEntryFuncs();
+
+  SetCbStatus(NFA_STATUS_FAILED);
+  SyncEventGuard guard(gnxpfeature_conf.NxpFeatureConfigEvt);
+  if (nfcFL.chipType != pn547C2) {
     memset(cmd_buf, 0x00, sizeof(cmd_buf));
-    }
-    else {
-        memset(cmd_buf_stat, 0x00, sizeof(cmd_buf_stat));
-    }
-    switch(testcase){
-    case 0 ://SWP Self-Test
-        cmd_len = sizeof(swp_test);
-        swp_test[3] = param[0];  //select channel 0x00:UICC(SWP1) 0x01:eSE(SWP2)
-        if(nfcFL.chipType != pn547C2) {
-            memcpy(cmd_buf, swp_test, 4);
-        }
-        else {
-            memcpy(cmd_buf_stat, swp_test, 4);
-        }
-        break;
-
-    case 1 ://PRBS Test start
-        if(nfcFL.chipType != pn547C2) {
-            cmd_len = sizeof(prbs_test);
-            //Technology to stream 0x00:TypeA 0x01:TypeB 0x02:TypeF
-            //Bitrate                       0x00:106kbps 0x01:212kbps 0x02:424kbps 0x03:848kbps
-            memcpy(&prbs_test[3], param, (cmd_len-5));
-            memcpy(cmd_buf, prbs_test, cmd_len);
-        }
-        else {
-            cmd_len = sizeof(prbs_test_stat);
-            //Technology to stream 0x00:TypeA 0x01:TypeB 0x02:TypeF
-            //Bitrate                       0x00:106kbps 0x01:212kbps 0x02:424kbps 0x03:848kbps
-            memcpy(&prbs_test_stat[3], param, (cmd_len-5));
-            memcpy(cmd_buf_stat, prbs_test_stat, cmd_len);
-        }
-
-        break;
-
-        //Factory Test Code
-    case 2 ://step1. PRBS Test stop : VEN RESET
-        halFuncEntries->power_cycle();
-        return NFCSTATUS_SUCCESS;
-        break;
-
-    case 3 ://step2. PRBS Test stop : CORE RESET
-        cmd_len = sizeof(rst_cmd);
-        if(nfcFL.chipType != pn547C2) {
+  } else {
+    memset(cmd_buf_stat, 0x00, sizeof(cmd_buf_stat));
+  }
+  switch (testcase) {
+    case NFC_CMD_TYPE_SWP:  // SWP Self-Test
+      cmd_len = sizeof(swp_test);
+      swp_test[3] = param[0];  // select channel 0x00:UICC(SWP1) 0x01:eSE(SWP2)
+      if (nfcFL.chipType != pn547C2) {
+        memcpy(cmd_buf, swp_test, 4);
+      } else {
+        memcpy(cmd_buf_stat, swp_test, 4);
+      }
+      break;
+
+    case NFC_CMD_TYPE_PRBS_START:  // PRBS Test start
+      if (nfcFL.chipType != pn547C2) {
+        cmd_len = sizeof(prbs_test);
+        // Technology to stream 0x00:TypeA 0x01:TypeB 0x02:TypeF
+        // Bitrate                       0x00:106kbps 0x01:212kbps 0x02:424kbps
+        // 0x03:848kbps
+        memcpy(&prbs_test[3], param, (cmd_len - 5));
+        memcpy(cmd_buf, prbs_test, cmd_len);
+      } else {
+        cmd_len = sizeof(prbs_test_stat);
+        // Technology to stream 0x00:TypeA 0x01:TypeB 0x02:TypeF
+        // Bitrate                       0x00:106kbps 0x01:212kbps 0x02:424kbps
+        // 0x03:848kbps
+        memcpy(&prbs_test_stat[3], param, (cmd_len - 5));
+        memcpy(cmd_buf_stat, prbs_test_stat, cmd_len);
+      }
+
+      break;
+
+    // Factory Test Code
+    case NFC_CMD_TYPE_PRBS_STOP:  // step1. PRBS Test stop : VEN RESET
+      halFuncEntries->power_cycle();
+      return NFCSTATUS_SUCCESS;
+      break;
+
+    case NFC_CMD_TYPE_CORE_RESET:  // step2. PRBS Test stop : CORE RESET
+      cmd_len = sizeof(rst_cmd);
+      if (nfcFL.chipType != pn547C2) {
         memcpy(cmd_buf, rst_cmd, 4);
-        }
-        else {
-            memcpy(cmd_buf_stat, rst_cmd, 4);
-        }
-        break;
-
-    case 4 ://step3. PRBS Test stop : CORE_INIT
-        cmd_len = sizeof(init_cmd);
-        if(nfcFL.chipType != pn547C2) {
-            memcpy(cmd_buf, init_cmd, cmd_len);
-        }
-        else {
-            memcpy(cmd_buf_stat, init_cmd, cmd_len);
-        }
-        break;
-        //Factory Test Code
-
-    case 5 ://step5. : NXP_ACT_PROP_EXTN
-        cmd_len = sizeof(prop_ext_act_cmd);
-        if(nfcFL.chipType != pn547C2) {
-            memcpy(cmd_buf, prop_ext_act_cmd, 3);
-        }
-        else {
-            memcpy(cmd_buf_stat, prop_ext_act_cmd, 3);
-        }
-        break;
-
-    default :
-        ALOGV("NXP_SelfTest Invalid Parameter!!");
-        return status;
-    }
-
-    if(nfcFL.chipType != pn547C2) {
-        status = NFA_SendNxpNciCommand(cmd_len, cmd_buf, NxpResponse_SetDhlf_Cb);
-    }
-    else {
-        status = NFA_SendNxpNciCommand(cmd_len, cmd_buf_stat, NxpResponse_SetDhlf_Cb);
-    }
-
-    if (status == NFA_STATUS_OK) {
-        ALOGV("%s: Success NFA_SendNxpNciCommand", __func__);
-        gnxpfeature_conf.NxpFeatureConfigEvt.wait(); /* wait for callback */
-    } else {
-        ALOGE("%s: Failed NFA_SendNxpNciCommand", __func__);
-    }
-
-    status = GetCbStatus();
-    return status;
+      } else {
+        memcpy(cmd_buf_stat, rst_cmd, 4);
+      }
+      break;
+
+    case NFC_CMD_TYPE_CORE_INIT:  // step3. PRBS Test stop : CORE_INIT
+      cmd_len = sizeof(init_cmd);
+      if (nfcFL.chipType != pn547C2) {
+        memcpy(cmd_buf, init_cmd, cmd_len);
+      } else {
+        memcpy(cmd_buf_stat, init_cmd, cmd_len);
+      }
+      break;
+    // Factory Test Code
+
+    case NFC_CMD_TYPE_ACT_PROP_EXTN:  // step5. : NXP_ACT_PROP_EXTN
+      cmd_len = sizeof(prop_ext_act_cmd);
+      if (nfcFL.chipType != pn547C2) {
+        memcpy(cmd_buf, prop_ext_act_cmd, 3);
+      } else {
+        memcpy(cmd_buf_stat, prop_ext_act_cmd, 3);
+      }
+      break;
+    case NFC_CMD_TYPE_RF_ON:
+      cmd_len = sizeof(cmd_rf_on);
+      memcpy(cmd_buf, cmd_rf_on, cmd_len);
+      break;
+
+    case NFC_CMD_TYPE_RF_OFF:
+      cmd_len = sizeof(cmd_rf_off);
+      memcpy(cmd_buf, cmd_rf_off, cmd_len);
+      break;
+
+    case NFC_CMD_TYPE_DISC_MAP:
+      cmd_len = sizeof(cmd_nfcc_disc_map);
+      memcpy(cmd_buf, cmd_nfcc_disc_map, cmd_len);
+      break;
+
+    case NFC_CMD_TYPE_DEACTIVATE:
+      cmd_len = sizeof(cmd_nfcc_deactivate);
+      memcpy(cmd_buf, cmd_nfcc_deactivate, cmd_len);
+      break;
+
+    case NFC_CMD_TYPE_NFCC_STANDBY_ON:
+      cmd_len = sizeof(cmd_nfcc_standby_on);
+      memcpy(cmd_buf, cmd_nfcc_standby_on, cmd_len);
+      break;
+
+    case NFC_CMD_TYPE_NFCC_STANDBY_OFF:
+      cmd_len = sizeof(cmd_nfcc_standby_off);
+      memcpy(cmd_buf, cmd_nfcc_standby_off, cmd_len);
+      break;
+
+    default:
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("NXP_SelfTest Invalid Parameter!!");
+      return status;
+  }
+
+  if (nfcFL.chipType != pn547C2) {
+    status = NFA_SendRawVsCommand(cmd_len, cmd_buf, NxpResponse_SetDhlf_Cb);
+  } else {
+    status =
+        NFA_SendRawVsCommand(cmd_len, cmd_buf_stat, NxpResponse_SetDhlf_Cb);
+  }
+
+  if (status == NFA_STATUS_OK) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Success NFA_SendRawVsCommand", __func__);
+    gnxpfeature_conf.NxpFeatureConfigEvt.wait(); /* wait for callback */
+  } else {
+    LOG(ERROR) << StringPrintf("%s: Failed NFA_SendRawVsCommand", __func__);
+  }
+
+  status = GetCbStatus();
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit status = 0x%02X", __func__, status);
+  return status;
 }
-//Factory Test Code --end
+// Factory Test Code --end
 
 /*******************************************************************************
  **
@@ -555,96 +646,89 @@ tNFA_STATUS Nxp_SelfTest(uint8_t testcase, uint8_t* param)
  ** Returns:         success/failure
  **
  *******************************************************************************/
-tNFA_STATUS SetVenConfigValue(jint nfcMode)
-{
-    tNFA_STATUS status = NFA_STATUS_FAILED;
-    uint8_t cmd_buf[] = {0x20, 0x02, 0x05, 0x01, 0xA0, 0x07, 0x01, 0x03};
-    ALOGV("%s: enter", __func__);
-    if(nfcMode == NFC_MODE_OFF)
-    {
-        ALOGV("Setting the VEN_CFG to 2, Disable ESE events");
-        cmd_buf[7] = 0x02;
-    }
-    else if(nfcMode == NFC_MODE_ON)
-    {
-        ALOGV("Setting the VEN_CFG to 3, Make ");
-        cmd_buf[7] = 0x03;
-    }
-    else
-    {
-        ALOGE("Wrong VEN_CFG Value");
-        return status;
-    }
-    SetCbStatus(NFA_STATUS_FAILED);
-    SyncEventGuard guard (gnxpfeature_conf.NxpFeatureConfigEvt);
-    status = NFA_SendNxpNciCommand(sizeof(cmd_buf), cmd_buf, NxpResponse_SetVenConfig_Cb);
-    if (status == NFA_STATUS_OK)
-    {
-        ALOGV("%s: Success NFA_SendNxpNciCommand", __func__);
-        gnxpfeature_conf.NxpFeatureConfigEvt.wait(); /* wait for callback */
-    }
-    else
-    {
-        ALOGE("%s: Failed NFA_SendNxpNciCommand", __func__);
-    }
-    status = GetCbStatus();
+tNFA_STATUS SetVenConfigValue(jint nfcMode) {
+  tNFA_STATUS status = NFA_STATUS_FAILED;
+  uint8_t cmd_buf[] = {0x20, 0x02, 0x05, 0x01, 0xA0, 0x07, 0x01, 0x03};
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+  if (nfcMode == NFC_MODE_OFF) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("Setting the VEN_CFG to 2, Disable ESE events");
+    cmd_buf[7] = 0x02;
+  } else if (nfcMode == NFC_MODE_ON) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("Setting the VEN_CFG to 3, Make ");
+    cmd_buf[7] = 0x03;
+  } else {
+    LOG(ERROR) << StringPrintf("Wrong VEN_CFG Value");
     return status;
+  }
+  SetCbStatus(NFA_STATUS_FAILED);
+  SyncEventGuard guard(gnxpfeature_conf.NxpFeatureConfigEvt);
+  status = NFA_SendRawVsCommand(sizeof(cmd_buf), cmd_buf,
+                                NxpResponse_SetVenConfig_Cb);
+  if (status == NFA_STATUS_OK) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Success NFA_SendRawVsCommand", __func__);
+    gnxpfeature_conf.NxpFeatureConfigEvt.wait(); /* wait for callback */
+  } else {
+    LOG(ERROR) << StringPrintf("%s: Failed NFA_SendRawVsCommand", __func__);
+  }
+  status = GetCbStatus();
+  return status;
 }
 
-static void NxpResponse_GetNumNFCEEValueCb(uint8_t /* event */, uint16_t param_len, uint8_t *p_param)
-{
-    uint8_t cfg_param_offset = 0x05;
-    swp_getconfig_status = SWP_DEFAULT;
-    ALOGV("NxpResponse_GetNumNFCEEValueCb length data = 0x%x status = 0x%x", param_len, p_param[3]);
-
-    if(p_param != NULL && param_len > 0x00 && p_param[3] == NFA_STATUS_OK && p_param[2] > 0x00)
-    {
-        while(cfg_param_offset < param_len)
-        {
-            if(nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH &&
-                    (p_param[5] == 0xA0 && p_param[6] == 0xEC)) {
-                sSelectedUicc = (p_param[8] & 0x0F);
-                ALOGV("Selected Uicc:%d",sSelectedUicc);
-            }
-
-            if(p_param[cfg_param_offset] == NXP_NFC_SET_CONFIG_PARAM_EXT && p_param[cfg_param_offset+1] == NXP_NFC_PARAM_ID_SWP1)
-            {
-                if(p_param[cfg_param_offset+3] != NXP_FEATURE_DISABLED)
-                {
-                     ALOGV("SWP1 Interface is enabled");
-                     swp_getconfig_status |= SWP1_UICC1;
-                     gActualSeCount++;
-                }
-            }
-            else if(p_param[cfg_param_offset] == NXP_NFC_SET_CONFIG_PARAM_EXT && p_param[cfg_param_offset+1] == NXP_NFC_PARAM_ID_SWP2)
-            {
-                if (p_param[cfg_param_offset+3] != NXP_FEATURE_DISABLED)
-                {
-                    ALOGV("SWP2 Interface is enabled");
-                    swp_getconfig_status |= SWP2_ESE;
-                    gActualSeCount++;
-                }
-            }
-            else if(p_param[cfg_param_offset] == NXP_NFC_SET_CONFIG_PARAM_EXT && p_param[cfg_param_offset+1] == NXP_NFC_PARAM_ID_SWP1A)
-            {
-                if (p_param[cfg_param_offset+3] != NXP_FEATURE_DISABLED)
-                {
-                    ALOGV("SWP1A Interface is enabled");
-                    swp_getconfig_status |= SWP1A_UICC2;
-                    gActualSeCount++;
-                }
-            }
-            cfg_param_offset += 0x04;
+static void NxpResponse_GetNumNFCEEValueCb(uint8_t event, uint16_t param_len,
+                                           uint8_t* p_param) {
+  uint8_t cfg_param_offset = 0x05;
+  swp_getconfig_status = SWP_DEFAULT;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "NxpResponse_GetNumNFCEEValueCb length data = 0x%x status = 0x%x",
+      param_len, p_param[3]);
+
+  if (p_param != NULL && param_len > 0x00 && p_param[3] == NFA_STATUS_OK &&
+      p_param[2] > 0x00) {
+    while (cfg_param_offset < param_len) {
+      if (nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH &&
+          (p_param[5] == 0xA0 && p_param[6] == 0xEC)) {
+        sSelectedUicc = (p_param[8] & 0x0F);
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("Selected Uicc:%d", sSelectedUicc);
+      }
+
+      if (p_param[cfg_param_offset] == NXP_NFC_SET_CONFIG_PARAM_EXT &&
+          p_param[cfg_param_offset + 1] == NXP_NFC_PARAM_ID_SWP1) {
+        if (p_param[cfg_param_offset + 3] != NXP_FEATURE_DISABLED) {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("SWP1 Interface is enabled");
+          swp_getconfig_status |= SWP1_UICC1;
+          gActualSeCount++;
         }
-    }
-    else
-    {
-        /* for fail case assign max no of smx */
-        gActualSeCount = 3;
-    }
-    SetCbStatus(NFA_STATUS_OK);
-    SyncEventGuard guard(gnxpfeature_conf.NxpFeatureConfigEvt);
-    gnxpfeature_conf.NxpFeatureConfigEvt.notifyOne ();
+      } else if (p_param[cfg_param_offset] == NXP_NFC_SET_CONFIG_PARAM_EXT &&
+                 p_param[cfg_param_offset + 1] == NXP_NFC_PARAM_ID_SWP2) {
+        if (p_param[cfg_param_offset + 3] != NXP_FEATURE_DISABLED) {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("SWP2 Interface is enabled");
+          swp_getconfig_status |= SWP2_ESE;
+          gActualSeCount++;
+        }
+      } else if (p_param[cfg_param_offset] == NXP_NFC_SET_CONFIG_PARAM_EXT &&
+                 p_param[cfg_param_offset + 1] == NXP_NFC_PARAM_ID_SWP1A) {
+        if (p_param[cfg_param_offset + 3] != NXP_FEATURE_DISABLED) {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("SWP1A Interface is enabled");
+          swp_getconfig_status |= SWP1A_UICC2;
+          gActualSeCount++;
+        }
+      }
+      cfg_param_offset += 0x04;
+    }
+  } else {
+    /* for fail case assign max no of smx */
+    gActualSeCount = 3;
+  }
+  SetCbStatus(NFA_STATUS_OK);
+  SyncEventGuard guard(gnxpfeature_conf.NxpFeatureConfigEvt);
+  gnxpfeature_conf.NxpFeatureConfigEvt.notifyOne();
 }
 
 /*******************************************************************************
@@ -656,46 +740,53 @@ static void NxpResponse_GetNumNFCEEValueCb(uint8_t /* event */, uint16_t param_l
  ** Returns:         success/failure
  **
  *******************************************************************************/
-tNFA_STATUS GetNumNFCEEConfigured(void)
-{
-    tNFA_STATUS status = NFA_STATUS_FAILED;
-    gActualSeCount = 1; /* default HCI present */
-    uint8_t cmd_buf[255] = {0x20, 0x03, 0x05, 0x02, NXP_NFC_SET_CONFIG_PARAM_EXT, NXP_NFC_PARAM_ID_SWP1, NXP_NFC_SET_CONFIG_PARAM_EXT, NXP_NFC_PARAM_ID_SWP2};
-    uint8_t cmd_buf_len = 0x08;
-    uint8_t num_config_params = 0x02;
-    uint8_t config_param_len = 0x05;
-    uint8_t buf_offset = 0x08;
+tNFA_STATUS GetNumNFCEEConfigured(void) {
+  tNFA_STATUS status = NFA_STATUS_FAILED;
+  gActualSeCount = 1; /* default HCI present */
+  uint8_t cmd_buf[255] = {0x20,
+                          0x03,
+                          0x05,
+                          0x02,
+                          NXP_NFC_SET_CONFIG_PARAM_EXT,
+                          NXP_NFC_PARAM_ID_SWP1,
+                          NXP_NFC_SET_CONFIG_PARAM_EXT,
+                          NXP_NFC_PARAM_ID_SWP2};
+  uint8_t cmd_buf_len = 0x08;
+  uint8_t num_config_params = 0x02;
+  uint8_t config_param_len = 0x05;
+  uint8_t buf_offset = 0x08;
+  if (nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC) {
     cmd_buf[buf_offset++] = NXP_NFC_SET_CONFIG_PARAM_EXT;
     cmd_buf[buf_offset++] = NXP_NFC_PARAM_ID_SWP1A;
     cmd_buf_len += 0x02;
     num_config_params++;
     config_param_len += 0x02;
-    cmd_buf[2] = config_param_len;
-    cmd_buf[3] = num_config_params;
-
-    ALOGV("%s: enter", __func__);
-
-    if(NFA_GetNCIVersion() == NCI_VERSION_2_0)
-       gActualSeCount = 0;
-
-    SetCbStatus(NFA_STATUS_FAILED);
-    SyncEventGuard guard (gnxpfeature_conf.NxpFeatureConfigEvt);
-    status = NFA_SendNxpNciCommand(cmd_buf_len, cmd_buf, NxpResponse_GetNumNFCEEValueCb);
-    if (status == NFA_STATUS_OK)
-    {
-        ALOGV("%s: Success NFA_SendNxpNciCommand", __func__);
-        gnxpfeature_conf.NxpFeatureConfigEvt.wait(); /* wait for callback */
-    }
-    else
-    {
-        ALOGE("%s: Failed NFA_SendNxpNciCommand", __func__);
-    }
-    status = GetCbStatus();
-    ALOGV("%s : gActualSeCount = %ld",__func__, gActualSeCount);
-    return status;
+  }
+  cmd_buf[2] = config_param_len;
+  cmd_buf[3] = num_config_params;
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+
+  if (NFA_GetNCIVersion() == NCI_VERSION_2_0) gActualSeCount = 0;
+
+  SetCbStatus(NFA_STATUS_FAILED);
+  SyncEventGuard guard(gnxpfeature_conf.NxpFeatureConfigEvt);
+  status = NFA_SendRawVsCommand(cmd_buf_len, cmd_buf,
+                                NxpResponse_GetNumNFCEEValueCb);
+  if (status == NFA_STATUS_OK) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Success NFA_SendRawVsCommand", __func__);
+    gnxpfeature_conf.NxpFeatureConfigEvt.wait(); /* wait for callback */
+  } else {
+    LOG(ERROR) << StringPrintf("%s: Failed NFA_SendRawVsCommand", __func__);
+  }
+  status = GetCbStatus();
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s : gActualSeCount = %d", __func__, gActualSeCount);
+  return status;
 }
 
-#if(NFC_NXP_HFO_SETTINGS == true)
+#if (NFC_NXP_HFO_SETTINGS == true)
 /*******************************************************************************
  **
  ** Function:        SetHfoConfigValue
@@ -706,56 +797,56 @@ tNFA_STATUS GetNumNFCEEConfigured(void)
  ** Returns:         success/failure
  **
  *******************************************************************************/
-tNFA_STATUS SetHfoConfigValue(void)
-{
-/* set 4 RF registers for phone off
- *
-# A0, 0D, 06, 06, 83, 10, 10, 40, 00 RF_CLIF_CFG_TARGET CLIF_DPLL_GEAR_REG
-# A0, 0D, 06, 06, 82, 13, 14, 17, 00 RF_CLIF_CFG_TARGET CLIF_DPLL_INIT_REG
-# A0, 0D, 06, 06, 84, AA, 85, 00, 00 RF_CLIF_CFG_TARGET CLIF_DPLL_INIT_FREQ_REG
-# A0, 0D, 06, 06, 81, 63, 02, 00, 00 RF_CLIF_CFG_TARGET CLIF_DPLL_CONTROL_REG
-*/
-/* default value of four registers in nxp-ALMSL.conf need to set in full power on
-# A0, 0D, 06, 06, 83, 55, 2A, 04, 00 RF_CLIF_CFG_TARGET CLIF_DPLL_GEAR_REG
-# A0, 0D, 06, 06, 82, 33, 14, 17, 00 RF_CLIF_CFG_TARGET CLIF_DPLL_INIT_REG
-# A0, 0D, 06, 06, 84, AA, 85, 00, 80 RF_CLIF_CFG_TARGET CLIF_DPLL_INIT_FREQ_REG
-# A0, 0D, 06, 06, 81, 63, 00, 00, 00 RF_CLIF_CFG_TARGET CLIF_DPLL_CONTROL_REG
-
-*/
-    tNFA_STATUS status = NFA_STATUS_FAILED;
-    uint8_t cmd_buf[] = {0x20, 0x02, 0x29, 0x05, 0xA0, 0x03, 0x01, 0x06,
-                                                 0xA0, 0x0D, 0x06, 0x06, 0x83, 0x10, 0x10, 0x40, 0x00,
-                                                 0xA0, 0x0D, 0x06, 0x06, 0x82, 0x13, 0x14, 0x17, 0x00,
-                                                 0xA0, 0x0D, 0x06, 0x06, 0x84, 0xAA, 0x85, 0x00, 0x00,
-                                                 0xA0, 0x0D, 0x06, 0x06, 0x81, 0x63, 0x02, 0x00, 0x00 };
-    ALOGV("%s: enter", __func__);
-
-    SetCbStatus(NFA_STATUS_FAILED);
-    SyncEventGuard guard (gnxpfeature_conf.NxpFeatureConfigEvt);
-    status = NFA_SendNxpNciCommand(sizeof(cmd_buf), cmd_buf, NxpResponse_SetVenConfig_Cb);
-    if (status == NFA_STATUS_OK)
-    {
-        ALOGV("%s: Success NFA_SendNxpNciCommand", __func__);
-        gnxpfeature_conf.NxpFeatureConfigEvt.wait(); /* wait for callback */
-    }
-    else
-    {
-        ALOGE("%s: Failed NFA_SendNxpNciCommand", __func__);
-    }
-    status = GetCbStatus();
-    if (NFA_STATUS_OK == status)
-    {
-        ALOGV("%s: HFO Settinng Success", __func__);
-         // TBD write value in temp file in /data/vendor/nfc
-        // At next boot hal will read this file and re-apply the
-        // Default Clock setting
-    }
-    ALOGV("%s: exit", __func__);
-    return status;
+tNFA_STATUS SetHfoConfigValue(void) {
+  /* set 4 RF registers for phone off
+   *
+  # A0, 0D, 06, 06, 83, 10, 10, 40, 00 RF_CLIF_CFG_TARGET CLIF_DPLL_GEAR_REG
+  # A0, 0D, 06, 06, 82, 13, 14, 17, 00 RF_CLIF_CFG_TARGET CLIF_DPLL_INIT_REG
+  # A0, 0D, 06, 06, 84, AA, 85, 00, 00 RF_CLIF_CFG_TARGET
+  CLIF_DPLL_INIT_FREQ_REG
+  # A0, 0D, 06, 06, 81, 63, 02, 00, 00 RF_CLIF_CFG_TARGET CLIF_DPLL_CONTROL_REG
+  */
+  /* default value of four registers in nxp-ALMSL.conf need to set in full power
+  on
+  # A0, 0D, 06, 06, 83, 55, 2A, 04, 00 RF_CLIF_CFG_TARGET CLIF_DPLL_GEAR_REG
+  # A0, 0D, 06, 06, 82, 33, 14, 17, 00 RF_CLIF_CFG_TARGET CLIF_DPLL_INIT_REG
+  # A0, 0D, 06, 06, 84, AA, 85, 00, 80 RF_CLIF_CFG_TARGET
+  CLIF_DPLL_INIT_FREQ_REG
+  # A0, 0D, 06, 06, 81, 63, 00, 00, 00 RF_CLIF_CFG_TARGET CLIF_DPLL_CONTROL_REG
+
+  */
+  tNFA_STATUS status = NFA_STATUS_FAILED;
+  uint8_t cmd_buf[] = {0x20, 0x02, 0x29, 0x05, 0xA0, 0x03, 0x01, 0x06, 0xA0,
+                       0x0D, 0x06, 0x06, 0x83, 0x10, 0x10, 0x40, 0x00, 0xA0,
+                       0x0D, 0x06, 0x06, 0x82, 0x13, 0x14, 0x17, 0x00, 0xA0,
+                       0x0D, 0x06, 0x06, 0x84, 0xAA, 0x85, 0x00, 0x00, 0xA0,
+                       0x0D, 0x06, 0x06, 0x81, 0x63, 0x02, 0x00, 0x00};
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+
+  SetCbStatus(NFA_STATUS_FAILED);
+  SyncEventGuard guard(gnxpfeature_conf.NxpFeatureConfigEvt);
+  status = NFA_SendRawVsCommand(sizeof(cmd_buf), cmd_buf,
+                                NxpResponse_SetVenConfig_Cb);
+  if (status == NFA_STATUS_OK) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Success NFA_SendRawVsCommand", __func__);
+    gnxpfeature_conf.NxpFeatureConfigEvt.wait(); /* wait for callback */
+  } else {
+    LOG(ERROR) << StringPrintf("%s: Failed NFA_SendRawVsCommand", __func__);
+  }
+  status = GetCbStatus();
+  if (NFA_STATUS_OK == status) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: HFO Settinng Success", __func__);
+    // TBD write value in temp file in /data/nfc
+    // At next boot hal will read this file and re-apply the
+    // Default Clock setting
+  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  return status;
 }
 #endif
 
-
 /*******************************************************************************
  **
  ** Function:        ResetEseSession
@@ -765,34 +856,30 @@ tNFA_STATUS SetHfoConfigValue(void)
  ** Returns:         success/failure
  **
  *******************************************************************************/
-tNFA_STATUS ResetEseSession()
-{
-    tNFA_STATUS status = NFA_STATUS_FAILED;
-    static uint8_t cmd_buf[] = { 0x20, 0x02, 0x0C, 0x01,
-                                 0xA0, 0xEB, 0x08, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
-    ALOGV("%s: enter", __func__);
-
-    SetCbStatus(NFA_STATUS_FAILED);
-    {
-        SyncEventGuard guard (gnxpfeature_conf.NxpFeatureConfigEvt);
-        status = NFA_SendNxpNciCommand(sizeof(cmd_buf), cmd_buf, NxpResponse_Cb);
-        if (status == NFA_STATUS_OK)
-        {
-            ALOGV("%s: Success NFA_SendNxpNciCommand", __func__);
-            gnxpfeature_conf.NxpFeatureConfigEvt.wait(); /* wait for callback */
-        }
-        else
-        {
-            ALOGE("%s: Failed NFA_SendNxpNciCommand", __func__);
-        }
+tNFA_STATUS ResetEseSession() {
+  tNFA_STATUS status = NFA_STATUS_FAILED;
+  static uint8_t cmd_buf[] = {0x20, 0x02, 0x0C, 0x01, 0xA0, 0xEB, 0x08, 0xFF,
+                              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+
+  SetCbStatus(NFA_STATUS_FAILED);
+  {
+    SyncEventGuard guard(gnxpfeature_conf.NxpFeatureConfigEvt);
+    status = NFA_SendRawVsCommand(sizeof(cmd_buf), cmd_buf, NxpResponse_Cb);
+    if (status == NFA_STATUS_OK) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: Success NFA_SendRawVsCommand", __func__);
+      gnxpfeature_conf.NxpFeatureConfigEvt.wait(); /* wait for callback */
+    } else {
+      LOG(ERROR) << StringPrintf("%s: Failed NFA_SendRawVsCommand", __func__);
     }
-    status = GetCbStatus();
+  }
+  status = GetCbStatus();
 
-    ALOGV("%s: exit", __func__);
-    return status;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  return status;
 }
 
-
 /*******************************************************************************
  **
  ** Function:        enableSWPInterface
@@ -802,74 +889,71 @@ tNFA_STATUS ResetEseSession()
  ** Returns:         success/failure
  **
  *******************************************************************************/
-tNFA_STATUS enableSWPInterface()
-{
-    tNFA_STATUS status = NFA_STATUS_FAILED;
-    static uint8_t get_eeprom_data[6] = {0x20, 0x03,  0x03 , 0x01 ,0xA0, 0x14};
-    uint8_t dual_uicc_cmd_buf[] = { 0x20, 0x02, 0x09, 0x02,
-            0xA0, 0xEC, 0x01, 0x00,
-            0xA0, 0xD4, 0x01, 0x00 };
-    uint8_t cmd_buf[] = { 0x20, 0x02, 0x05, 0x01,
-            0xA0, 0xEC, 0x01, 0x00 };
-    ALOGV("%s: enter", __func__);
-
-    status = NxpNfc_Write_Cmd(sizeof(get_eeprom_data), get_eeprom_data, NxpResponse_Cb);
-    if((status == NFA_STATUS_OK) && (gnxpfeature_conf.rsp_len > 8))
+tNFA_STATUS enableSWPInterface() {
+  tNFA_STATUS status = NFA_STATUS_FAILED;
+  static uint8_t get_eeprom_data[6] = {0x20, 0x03, 0x03, 0x01, 0xA0, 0x14};
+  uint8_t dual_uicc_cmd_buf[] = {0x20, 0x02, 0x09, 0x02, 0xA0, 0xEC,
+                                 0x01, 0x00, 0xA0, 0xD4, 0x01, 0x00};
+  uint8_t cmd_buf[] = {0x20, 0x02, 0x05, 0x01, 0xA0, 0xEC, 0x01, 0x00};
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+
+  status = NxpNfc_Write_Cmd(sizeof(get_eeprom_data), get_eeprom_data,
+                            NxpResponse_Cb);
+  if ((status == NFA_STATUS_OK) && (gnxpfeature_conf.rsp_len > 8)) {
+    if (gnxpfeature_conf.rsp_data[8] == 0x01 &&
+        !(swp_getconfig_status & SWP1_UICC1))  // SWP status read
     {
-        if(gnxpfeature_conf.rsp_data[8] == 0x01 && !(swp_getconfig_status & SWP1_UICC1) ) //SWP status read
-        {
-            if(nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) {
-                dual_uicc_cmd_buf[7] = 0x01;
-            }
-            else {
-                cmd_buf[7] = 0x01;
-            }
-        }
-        if(nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) {
-            if(gnxpfeature_conf.rsp_data[9] == 0x01 && !(swp_getconfig_status & SWP1A_UICC2) ) //SWP1A status read
-            {
-                dual_uicc_cmd_buf[11] = 0x01;
-            }
-        }
-        if(((!nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) && (cmd_buf[7] == 0x00)) ||
-                ((nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) &&
-                (dual_uicc_cmd_buf[7] == 0x00 && dual_uicc_cmd_buf[11] == 0x00))) {
-            ALOGV("%s: No mismatch in UICC SWP and configuration set", __func__);
-            status = NFA_STATUS_FAILED;
+      if (nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) {
+        dual_uicc_cmd_buf[7] = 0x01;
+      } else {
+        cmd_buf[7] = 0x01;
+      }
+    }
+    if (nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) {
+      if (gnxpfeature_conf.rsp_data[9] == 0x01 &&
+          !(swp_getconfig_status & SWP1A_UICC2))  // SWP1A status read
+      {
+        dual_uicc_cmd_buf[11] = 0x01;
+      }
+    }
+    if (((!nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) &&
+         (cmd_buf[7] == 0x00)) ||
+        ((nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) &&
+         (dual_uicc_cmd_buf[7] == 0x00 && dual_uicc_cmd_buf[11] == 0x00))) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: No mismatch in UICC SWP and configuration set", __func__);
+      status = NFA_STATUS_FAILED;
+    } else {
+      SetCbStatus(NFA_STATUS_FAILED);
+      {
+        SyncEventGuard guard(gnxpfeature_conf.NxpFeatureConfigEvt);
+        if (nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) {
+          status = NFA_SendRawVsCommand(sizeof(dual_uicc_cmd_buf),
+                                        dual_uicc_cmd_buf, NxpResponse_Cb);
+        } else {
+          status =
+              NFA_SendRawVsCommand(sizeof(cmd_buf), cmd_buf, NxpResponse_Cb);
         }
-        else
-        {
-            SetCbStatus(NFA_STATUS_FAILED);
-            {
-                SyncEventGuard guard (gnxpfeature_conf.NxpFeatureConfigEvt);
-                if(nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) {
-                    status = NFA_SendNxpNciCommand(sizeof(dual_uicc_cmd_buf),
-                            dual_uicc_cmd_buf, NxpResponse_Cb);
-                }
-                else {
-                    status = NFA_SendNxpNciCommand(sizeof(cmd_buf), cmd_buf, NxpResponse_Cb);
-                }
-
-                if (status == NFA_STATUS_OK)
-                {
-                    ALOGV("%s: Success NFA_SendNxpNciCommand", __func__);
-                    gnxpfeature_conf.NxpFeatureConfigEvt.wait(); /* wait for callback */
-                }
-                else
-                {
-                    ALOGE("%s: Failed NFA_SendNxpNciCommand", __func__);
-                }
-            }
-            status = GetCbStatus();
-            if (NFA_STATUS_OK == status)
-            {
-                ALOGV("%s: GetCbStatus():%d", __func__, status);
-            }
+
+        if (status == NFA_STATUS_OK) {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("%s: Success NFA_SendRawVsCommand", __func__);
+          gnxpfeature_conf.NxpFeatureConfigEvt.wait(); /* wait for callback */
+        } else {
+          LOG(ERROR) << StringPrintf("%s: Failed NFA_SendRawVsCommand",
+                                     __func__);
         }
+      }
+      status = GetCbStatus();
+      if (NFA_STATUS_OK == status) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: GetCbStatus():%d", __func__, status);
+      }
     }
+  }
 
-    ALOGV("%s: exit", __func__);
-    return status;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  return status;
 }
 
 /*******************************************************************************
@@ -881,36 +965,33 @@ tNFA_STATUS enableSWPInterface()
  ** Returns:         success/failure
  **
  *******************************************************************************/
-tNFA_STATUS SetUICC_SWPBitRate(bool isMifareSupported)
-{
-    tNFA_STATUS status = NFA_STATUS_FAILED;
-    uint8_t cmd_buf[] ={0x20, 0x02, 0x05, 0x01, 0xA0, 0xC0, 0x01, 0x03};
-
-    if(isMifareSupported)
-    {
-        ALOGV("Setting the SWP_BITRATE_INT1 to 0x06 (1250 kb/s)");
-        cmd_buf[7] = 0x06;
-    }
-    else
-    {
-        ALOGV("Setting the SWP_BITRATE_INT1 to 0x04 (910 kb/s)");
-        cmd_buf[7] = 0x04;
-    }
-
-    SetCbStatus(NFA_STATUS_FAILED);
-    SyncEventGuard guard (gnxpfeature_conf.NxpFeatureConfigEvt);
-    status = NFA_SendNxpNciCommand(sizeof(cmd_buf), cmd_buf, NxpResponse_SetSWPBitRate_Cb);
-    if (status == NFA_STATUS_OK)
-    {
-        ALOGV("%s: Success NFA_SendNxpNciCommand", __func__);
-        gnxpfeature_conf.NxpFeatureConfigEvt.wait(); /* wait for callback */
-    }
-    else
-    {
-         ALOGE("%s: Failed NFA_SendNxpNciCommand", __func__);
-    }
-    status = GetCbStatus();
-    return status;
+tNFA_STATUS SetUICC_SWPBitRate(bool isMifareSupported) {
+  tNFA_STATUS status = NFA_STATUS_FAILED;
+  uint8_t cmd_buf[] = {0x20, 0x02, 0x05, 0x01, 0xA0, 0xC0, 0x01, 0x03};
+
+  if (isMifareSupported) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("Setting the SWP_BITRATE_INT1 to 0x06 (1250 kb/s)");
+    cmd_buf[7] = 0x06;
+  } else {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("Setting the SWP_BITRATE_INT1 to 0x04 (910 kb/s)");
+    cmd_buf[7] = 0x04;
+  }
+
+  SetCbStatus(NFA_STATUS_FAILED);
+  SyncEventGuard guard(gnxpfeature_conf.NxpFeatureConfigEvt);
+  status = NFA_SendRawVsCommand(sizeof(cmd_buf), cmd_buf,
+                                NxpResponse_SetSWPBitRate_Cb);
+  if (status == NFA_STATUS_OK) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Success NFA_SendRawVsCommand", __func__);
+    gnxpfeature_conf.NxpFeatureConfigEvt.wait(); /* wait for callback */
+  } else {
+    LOG(ERROR) << StringPrintf("%s: Failed NFA_SendRawVsCommand", __func__);
+  }
+  status = GetCbStatus();
+  return status;
 }
 /*******************************************************************************
  **
@@ -921,34 +1002,31 @@ tNFA_STATUS SetUICC_SWPBitRate(bool isMifareSupported)
  ** Returns:         success/failure
  **
  *******************************************************************************/
-tNFA_STATUS NxpNfc_Write_Cmd(uint8_t retlen, uint8_t* buffer, tNXP_RSP_CBACK* p_cback)
-{
-    tNFA_STATUS status = NFA_STATUS_FAILED;
-    SetCbStatus(NFA_STATUS_FAILED);
-    SyncEventGuard guard (gnxpfeature_conf.NxpFeatureConfigEvt);
-    status = NFA_SendNxpNciCommand(retlen, buffer, p_cback);
-    if (status == NFA_STATUS_OK)
-    {
-        ALOGV("%s: Success NFA_SendNxpNciCommand", __func__);
-        gnxpfeature_conf.NxpFeatureConfigEvt.wait(); /* wait for callback */
-    }
-    else
-    {
-         ALOGE("%s: Failed NFA_SendNxpNciCommand", __func__);
-    }
-    status = GetCbStatus();
-    return status;
+tNFA_STATUS NxpNfc_Write_Cmd(uint8_t retlen, uint8_t* buffer,
+                             tNXP_RSP_CBACK* p_cback) {
+  tNFA_STATUS status = NFA_STATUS_FAILED;
+  SetCbStatus(NFA_STATUS_FAILED);
+  SyncEventGuard guard(gnxpfeature_conf.NxpFeatureConfigEvt);
+  status = NFA_SendRawVsCommand(retlen, buffer, p_cback);
+  if (status == NFA_STATUS_OK) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Success NFA_SendRawVsCommand", __func__);
+    gnxpfeature_conf.NxpFeatureConfigEvt.wait(); /* wait for callback */
+  } else {
+    LOG(ERROR) << StringPrintf("%s: Failed NFA_SendRawVsCommand", __func__);
+  }
+  status = GetCbStatus();
+  return status;
 }
-void start_timer_msec(struct timeval  *start_tv)
-{
-    gettimeofday(start_tv, NULL);
+void start_timer_msec(struct timeval* start_tv) {
+  gettimeofday(start_tv, NULL);
 }
 
-long stop_timer_getdifference_msec(struct timeval  *start_tv, struct timeval  *stop_tv)
-{
-    gettimeofday(stop_tv, NULL);
-    return ((long) (stop_tv->tv_sec - start_tv->tv_sec)*1000L +
-            (long) (stop_tv->tv_usec - start_tv->tv_usec)/1000L);
+long stop_timer_getdifference_msec(struct timeval* start_tv,
+                                   struct timeval* stop_tv) {
+  gettimeofday(stop_tv, NULL);
+  return ((long)(stop_tv->tv_sec - start_tv->tv_sec) * 1000L +
+          (long)(stop_tv->tv_usec - start_tv->tv_usec) / 1000L);
 }
 
 #endif
@@ -962,69 +1040,65 @@ long stop_timer_getdifference_msec(struct timeval  *start_tv, struct timeval  *s
  ** Returns:         success/failure
  **
  *******************************************************************************/
-tNFA_STATUS Set_EERegisterValue(uint16_t RegAddr, uint8_t bitVal)
-{
-    if(!nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
-        ALOGV("%s STAT_DUAL_UICC_EXT_SWITCH not available. Returning",__func__);
-        return NFC_STATUS_FAILED;
-    }
-    tNFA_STATUS status = NFC_STATUS_FAILED;
-    uint8_t swp1conf[] = {0x20,0x02,0x05,0x01,0x00,0x00,0x01,0x00};
-    ALOGV("Enter: Prepare SWP1 configurations");
-    swp1conf[4] = (uint8_t)((RegAddr & 0xFF00)>>8);
-    swp1conf[5] = (uint8_t)(RegAddr & 0x00FF);
-    swp1conf[7] = (uint8_t)(0xFF & bitVal);
-    //swp1conf[7] = 0x01;
-    ALOGV("Exit: Prepare SWP1 configurations");
-
-    SetCbStatus(NFA_STATUS_FAILED);
-    SyncEventGuard guard (gnxpfeature_conf.NxpFeatureConfigEvt);
-
-    status = NFA_SendNxpNciCommand(sizeof(swp1conf), swp1conf, NxpResponse_SwitchUICC_Cb);
-    if (status == NFA_STATUS_OK)
-    {
-        ALOGV("%s: Success NFA_SendNxpNciCommand", __func__);
-        gnxpfeature_conf.NxpFeatureConfigEvt.wait(); /* wait for callback */
-        status = NFA_STATUS_FAILED;
-    }
-    else
-    {
-         ALOGE("%s: Failed NFA_SendNxpNciCommand", __func__);
-    }
-    status = GetCbStatus();
-    return status;
+tNFA_STATUS Set_EERegisterValue(uint16_t RegAddr, uint8_t bitVal) {
+  if (!nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s STAT_DUAL_UICC_EXT_SWITCH not available. Returning", __func__);
+    return NFC_STATUS_FAILED;
+  }
+  tNFA_STATUS status = NFC_STATUS_FAILED;
+  uint8_t swp1conf[] = {0x20, 0x02, 0x05, 0x01, 0x00, 0x00, 0x01, 0x00};
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("Enter: Prepare SWP1 configurations");
+  swp1conf[4] = (uint8_t)((RegAddr & 0xFF00) >> 8);
+  swp1conf[5] = (uint8_t)(RegAddr & 0x00FF);
+  swp1conf[7] = (uint8_t)(0xFF & bitVal);
+  // swp1conf[7] = 0x01;
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("Exit: Prepare SWP1 configurations");
+
+  SetCbStatus(NFA_STATUS_FAILED);
+  SyncEventGuard guard(gnxpfeature_conf.NxpFeatureConfigEvt);
+
+  status = NFA_SendRawVsCommand(sizeof(swp1conf), swp1conf,
+                                NxpResponse_SwitchUICC_Cb);
+  if (status == NFA_STATUS_OK) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Success NFA_SendRawVsCommand", __func__);
+    gnxpfeature_conf.NxpFeatureConfigEvt.wait(); /* wait for callback */
+  } else {
+    LOG(ERROR) << StringPrintf("%s: Failed NFA_SendRawVsCommand", __func__);
+  }
+  status = GetCbStatus();
+  return status;
 }
 
-#if(NXP_EXTNS == TRUE)
+#if (NXP_EXTNS == TRUE)
 /*******************************************************************************
-+ **
-+ ** Function:        NxpNfc_Write_Cmd()
-+ **
-+ ** Description:     Writes the command to NFCC
-+ **
-+ ** Returns:         success/failure
-+ **
-+ *******************************************************************************/
-tNFA_STATUS NxpNfc_Write_Cmd_Common(uint8_t retlen, uint8_t* buffer)
-{
-    tNFA_STATUS status = NFA_STATUS_FAILED;
-    SetCbStatus(NFA_STATUS_FAILED);
-    SyncEventGuard guard (gnxpfeature_conf.NxpFeatureConfigEvt);
-    status = NFA_SendNxpNciCommand(retlen, buffer, NxpResponse_Cb);
-    if (status == NFA_STATUS_OK)
-    {
-        ALOGV("%s: Success NFA_SendNxpNciCommand", __func__);
-        gnxpfeature_conf.NxpFeatureConfigEvt.wait(); /* wait for callback */
-    }
-    else
-    {
-         ALOGE("%s: Failed NFA_SendNxpNciCommand", __func__);
-    }
-    status = GetCbStatus();
-    return status;
+ **
+ ** Function:        NxpNfc_Write_Cmd()
+ **
+ ** Description:     Writes the command to NFCC
+ **
+ ** Returns:         success/failure
+ **
+ *******************************************************************************/
+tNFA_STATUS NxpNfc_Write_Cmd_Common(uint8_t retlen, uint8_t* buffer) {
+  tNFA_STATUS status = NFA_STATUS_FAILED;
+  SetCbStatus(NFA_STATUS_FAILED);
+  SyncEventGuard guard(gnxpfeature_conf.NxpFeatureConfigEvt);
+  status = NFA_SendRawVsCommand(retlen, buffer, NxpResponse_Cb);
+  if (status == NFA_STATUS_OK) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Success NFA_SendRawVsCommand", __func__);
+    gnxpfeature_conf.NxpFeatureConfigEvt.wait(); /* wait for callback */
+  } else {
+    LOG(ERROR) << StringPrintf("%s: Failed NFA_SendRawVsCommand", __func__);
+  }
+  status = GetCbStatus();
+  return status;
 }
-#endif
-#if(NXP_EXTNS == TRUE)
+
 /*******************************************************************************
  **
  ** Function:        NxpNfc_Send_CoreResetInit_Cmd()
@@ -1034,17 +1108,72 @@ tNFA_STATUS NxpNfc_Write_Cmd_Common(uint8_t retlen, uint8_t* buffer)
  ** Returns:         success/failure
  **
  *******************************************************************************/
-tNFA_STATUS NxpNfc_Send_CoreResetInit_Cmd(void)
-{
-    tNFA_STATUS status = NFA_STATUS_FAILED;
-    uint8_t *p;
+tNFA_STATUS NxpNfc_Send_CoreResetInit_Cmd(void) {
+  tNFA_STATUS status = NFA_STATUS_FAILED;
+  uint8_t* p;
 
-    status = (tNFA_STATUS)NFA_Send_Core_Reset();
+  status = (tNFA_STATUS)NFA_Send_Core_Reset();
 
-    if(status == NFA_STATUS_OK) {
-        NFA_Send_Core_Init(&p);
-    }
+  if (status == NFA_STATUS_OK) {
+    NFA_Send_Core_Init(&p);
+  }
+  return status;
+}
+
+/*******************************************************************************
+ **
+ ** Function:        NxpNfcUpdateEeprom()
+ **
+ ** Description:     Sends extended nxp set config parameter
+ **
+ ** Returns:         NFA_STATUS_FAILED/NFA_STATUS_OK
+ **
+ *******************************************************************************/
+tNFA_STATUS NxpNfcUpdateEeprom(uint8_t* param, uint8_t len, uint8_t* val) {
+  tNFA_STATUS status = NFA_STATUS_FAILED;
+  uint8_t* cmdBuf = NULL;
+  uint8_t setCfgCmdLen = 0;  // Memory field len 1bytes
+  uint8_t setCfgCmdHdr[7] = {
+      0x20,     0x02,  // set_cfg header
+      0x00,            // len of following value
+      0x01,            // Num Param
+      param[0],        // First byte of Address
+      param[1],        // Second byte of Address
+      len              // Data len
+  };
+  setCfgCmdLen = sizeof(setCfgCmdHdr) + len;
+  setCfgCmdHdr[2] = setCfgCmdLen - SETCONFIGLENPOS;
+  cmdBuf = (uint8_t*)malloc(setCfgCmdLen);
+  if (cmdBuf == NULL) {
+    LOG(ERROR) << StringPrintf("memory allocation failed");
     return status;
+  }
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("setCfgCmdLen=%u", setCfgCmdLen);
+  memset(cmdBuf, 0, setCfgCmdLen);
+  memcpy(cmdBuf, setCfgCmdHdr, sizeof(setCfgCmdHdr));
+  memcpy(cmdBuf + sizeof(setCfgCmdHdr), val, len);
+
+  SetCbStatus(NFA_STATUS_FAILED);
+  SyncEventGuard guard(gnxpfeature_conf.NxpFeatureConfigEvt);
+  status = NFA_SendRawVsCommand(setCfgCmdLen, cmdBuf, NxpResponse_Cb);
+  if (status == NFA_STATUS_OK) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("Success NFA_SendRawVsCommand");
+    gnxpfeature_conf.NxpFeatureConfigEvt.wait(
+        2 * ONE_SECOND_MS); /* wait for callback */
+  } else {
+    LOG(ERROR) << StringPrintf("Failed NFA_SendRawVsCommand");
+  }
+
+  if (cmdBuf) {
+    free(cmdBuf);
+    cmdBuf = NULL;
+  }
+
+  status = GetCbStatus();
+  return status;
 }
+
 #endif
 } /*namespace android*/
diff --git a/nci/jni/NativeP2pDevice.cpp b/nci/jni/NativeP2pDevice.cpp
index d8a1c7f2..352c81e1 100644
--- a/nci/jni/NativeP2pDevice.cpp
+++ b/nci/jni/NativeP2pDevice.cpp
@@ -14,67 +14,57 @@
  * limitations under the License.
  */
 
-#include "_OverrideLog.h"
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
 #include <log/log.h>
-#include "NfcJniUtil.h"
 #include "JavaClassConstants.h"
-
+#include "NfcJniUtil.h"
 #include <nativehelper/JNIHelp.h>
 
-namespace android
-{
+using android::base::StringPrintf;
 
+extern bool nfc_debug_enabled;
 
-static jboolean nativeP2pDeviceDoConnect (JNIEnv*, jobject)
-{
-    ALOGV("%s", __func__);
-    return JNI_TRUE;
-}
-
+namespace android {
 
-static jboolean nativeP2pDeviceDoDisconnect (JNIEnv*, jobject)
-{
-    ALOGV("%s", __func__);
-    return JNI_TRUE;
+static jboolean nativeP2pDeviceDoConnect(JNIEnv*, jobject) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
+  return JNI_TRUE;
 }
 
-
-static jbyteArray nativeP2pDeviceDoTransceive (JNIEnv*, jobject, jbyteArray)
-{
-    ALOGV("%s", __func__);
-    return NULL;
+static jboolean nativeP2pDeviceDoDisconnect(JNIEnv*, jobject) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
+  return JNI_TRUE;
 }
 
-
-static jbyteArray nativeP2pDeviceDoReceive (JNIEnv*, jobject)
-{
-    ALOGV("%s", __func__);
-    return NULL;
+static jbyteArray nativeP2pDeviceDoTransceive(JNIEnv*, jobject, jbyteArray) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
+  return NULL;
 }
 
-
-static jboolean nativeP2pDeviceDoSend (JNIEnv*, jobject, jbyteArray)
-{
-    ALOGV("%s", __func__);
-    return JNI_TRUE;
+static jbyteArray nativeP2pDeviceDoReceive(JNIEnv*, jobject) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
+  return NULL;
 }
 
+static jboolean nativeP2pDeviceDoSend(JNIEnv*, jobject, jbyteArray) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
+  return JNI_TRUE;
+}
 
 /*****************************************************************************
 **
 ** Description:     JNI functions
 **
 *****************************************************************************/
-static JNINativeMethod gMethods[] =
-{
-    {"doConnect", "()Z", (void *) nativeP2pDeviceDoConnect},
-    {"doDisconnect", "()Z", (void *) nativeP2pDeviceDoDisconnect},
-    {"doTransceive", "([B)[B", (void *) nativeP2pDeviceDoTransceive},
-    {"doReceive", "()[B", (void *) nativeP2pDeviceDoReceive},
-    {"doSend", "([B)Z", (void *) nativeP2pDeviceDoSend},
+static JNINativeMethod gMethods[] = {
+    {"doConnect", "()Z", (void*)nativeP2pDeviceDoConnect},
+    {"doDisconnect", "()Z", (void*)nativeP2pDeviceDoDisconnect},
+    {"doTransceive", "([B)[B", (void*)nativeP2pDeviceDoTransceive},
+    {"doReceive", "()[B", (void*)nativeP2pDeviceDoReceive},
+    {"doSend", "([B)Z", (void*)nativeP2pDeviceDoSend},
 };
 
-
 /*******************************************************************************
 **
 ** Function:        register_com_android_nfc_NativeP2pDevice
@@ -85,11 +75,9 @@ static JNINativeMethod gMethods[] =
 ** Returns:         Status of registration.
 **
 *******************************************************************************/
-int register_com_android_nfc_NativeP2pDevice (JNIEnv* e)
-{
-    return jniRegisterNativeMethods (e, gNativeP2pDeviceClassName,
-            gMethods, NELEM(gMethods));
+int register_com_android_nfc_NativeP2pDevice(JNIEnv* e) {
+  return jniRegisterNativeMethods(e, gNativeP2pDeviceClassName, gMethods,
+                                  NELEM(gMethods));
 }
 
-
-} // namepspace android
+}  // namespace android
diff --git a/nci/jni/NativeSecureElement.cpp b/nci/jni/NativeSecureElement.cpp
old mode 100644
new mode 100755
index 0bdb5cf2..f4aafba8
--- a/nci/jni/NativeSecureElement.cpp
+++ b/nci/jni/NativeSecureElement.cpp
@@ -2,7 +2,7 @@
  * Copyright (c) 2016, The Linux Foundation. All rights reserved.
  * Not a Contribution.
  *
- * Copyright (C) 2015 NXP Semiconductors
+ * Copyright (C) 2015-2018 NXP Semiconductors
  * The original Work has been changed by NXP Semiconductors.
  *
  * Copyright (C) 2012 The Android Open Source Project
@@ -19,49 +19,44 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-#include "_OverrideLog.h"
-#include "SecureElement.h"
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+#include <ScopedPrimitiveArray.h>
 #include "JavaClassConstants.h"
-#include "PowerSwitch.h"
 #include "NfcTag.h"
+#include "PowerSwitch.h"
 #include "RoutingManager.h"
-#include <nativehelper/ScopedPrimitiveArray.h>
+#include "SecureElement.h"
 #include "phNxpConfig.h"
+#include "nfc_config.h"
 
-#define ALOGV ALOGD
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
 extern bool hold_the_transceive;
 extern int dual_mode_current_state;
 extern bool ceTransactionPending;
-namespace android
-{
+namespace android {
 
-extern void startRfDiscovery (bool isStart);
+extern void startRfDiscovery(bool isStart);
 extern bool isDiscoveryStarted();
 extern bool isp2pActivated();
-extern void com_android_nfc_NfcManager_disableDiscovery (JNIEnv* e, jobject o);
-extern void com_android_nfc_NfcManager_enableDiscovery (JNIEnv* e, jobject o, jint mode);
+extern void com_android_nfc_NfcManager_disableDiscovery(JNIEnv* e, jobject o);
+extern void com_android_nfc_NfcManager_enableDiscovery(JNIEnv* e, jobject o,
+                                                       jint mode);
 #if (NXP_EXTNS == TRUE)
+extern bool isLowRamDevice();
 extern int gMaxEERecoveryTimeout;
 #endif
-static SyncEvent            sNfaVSCResponseEvent;
-//static bool sRfEnabled;           /*commented to eliminate warning defined but not used*/
-
-static void nfaVSCCallback(uint8_t event, uint16_t param_len, uint8_t *p_param);
-
-inline static void nfaVSCCallback(uint8_t event, uint16_t param_len, uint8_t *p_param)    /*defined as inline to eliminate warning defined but not used*/
-{
-    (void)event;
-    (void)param_len;
-    (void)p_param;
-    SyncEventGuard guard (sNfaVSCResponseEvent);
-    sNfaVSCResponseEvent.notifyOne ();
-}
+Mutex mSPIDwpSyncMutex;
+static SyncEvent sNfaVSCResponseEvent;
+// static bool sRfEnabled;           /*commented to eliminate warning defined
+// but not used*/
 
 // These must match the EE_ERROR_ types in NfcService.java
 static const int EE_ERROR_IO = -1;
 static const int EE_ERROR_INIT = -3;
-static const int EE_ERROR_LISTEN_MODE = -4;
-static const int EE_ERROR_EXT_FIELD = -5;
 
 /*******************************************************************************
 **
@@ -75,301 +70,187 @@ static const int EE_ERROR_EXT_FIELD = -5;
 **
 *******************************************************************************/
 #if (NXP_EXTNS == TRUE)
-static jint nativeNfcSecureElement_doOpenSecureElementConnection (JNIEnv*, jobject,jint seId)
+static jint nativeNfcSecureElement_doOpenSecureElementConnection(
+    JNIEnv*, jobject, __attribute__((unused)) jint seId)
 #else
-static jint nativeNfcSecureElement_doOpenSecureElementConnection (JNIEnv*, jobject)
+static jint nativeNfcSecureElement_doOpenSecureElementConnection(JNIEnv*,
+                                                                 jobject)
 #endif
 {
-    ALOGV("%s: enter", __func__);
-    bool stat = false;
-    jint secElemHandle = EE_ERROR_INIT;
-    long ret_val = -1;
-    NFCSTATUS status = NFCSTATUS_FAILED;
-    p61_access_state_t p61_current_state = P61_STATE_INVALID;
-    se_apdu_gate_info gateInfo = NO_APDU_GATE;
-    SecureElement &se = SecureElement::getInstance();
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+  bool stat = false;
+  jint secElemHandle = EE_ERROR_INIT;
+  long ret_val = -1;
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  p61_access_state_t p61_current_state = P61_STATE_INVALID;
+  se_apdu_gate_info gateInfo = NO_APDU_GATE;
+  SecureElement& se = SecureElement::getInstance();
+  android::mSPIDwpSyncMutex.lock();
 #if (NXP_EXTNS == TRUE)
-    if(nfcFL.nfcNxpEse) {
-        if(!nfcFL.eseFL._ESE_WIRED_MODE_PRIO && se.isBusy()) {
-            goto TheEnd;
-        }
-        se.mIsExclusiveWiredMode = false; // to ctlr exclusive wired mode
-        if(seId == 0xF4)
-        {
-            if(se.mIsWiredModeOpen)
-            {
-                goto TheEnd;
-            }
-            if(nfcFL.eseFL._ESE_UICC_EXCLUSIVE_WIRED_MODE) {
-                se.mIsExclusiveWiredMode = true;
-            }
-            stat = se.checkForWiredModeAccess();
-            if(stat == false)
-            {
-                ALOGV("Denying SE open due to SE listen mode active");
-                secElemHandle = EE_ERROR_LISTEN_MODE;
-                goto TheEnd;
-            }
-
-            ALOGV("%s: Activating UICC Wired Mode=0x%X", __func__, seId);
-            stat = se.activate(seId);
-            ALOGV("%s: Check UICC activation status stat=%X", __func__, stat);
-            if (stat)
-            {
-                //establish a pipe to UICC
-                ALOGV("%s: Creatting a pipe to UICC!", __func__);
-                stat = se.connectEE();
-                if (stat)
-                {
-                    secElemHandle = se.mActiveEeHandle;
-                }
-                else
-                {
-                    se.deactivate (0);
-                }
-            }
-            if ((!stat) && (! PowerSwitch::getInstance ().setModeOff (PowerSwitch::SE_CONNECTED)))
-            {
-                PowerSwitch::getInstance ().setLevel (PowerSwitch::LOW_POWER);
-            }
-            se.mIsWiredModeOpen = true;
-            if(nfcFL.eseFL._ESE_UICC_EXCLUSIVE_WIRED_MODE) {
-                if (isDiscoveryStarted())
-                {
-                    // Stop RF Discovery if we were polling
-                    startRfDiscovery (false);
-                    status = NFA_DisableListening();
-                    if(status == NFCSTATUS_OK)
-                    {
-                        startRfDiscovery (true);
-                    }
-                }
-                else
-                {
-                    status = NFA_DisableListening();
-                }
-                se.mlistenDisabled = true;
-            }
-            goto TheEnd;
-            if(nfcFL.eseFL._ESE_WIRED_MODE_PRIO) {
-                if(se.mIsWiredModeOpen&&(se.mActiveEeHandle == (se.EE_HANDLE_0xF4 || SecureElement::EE_HANDLE_0xF8)))
-                {
-                    stat = SecureElement::getInstance().disconnectEE (se.mActiveEeHandle);
-                    se.mActiveEeHandle = NFA_HANDLE_INVALID;
-                    se.mIsWiredModeOpen = false;
-                }
-            }
-
-            if(nfcFL.chipType != pn547C2) {
-                if(nfcFL.nfccFL._NFCEE_REMOVED_NTF_RECOVERY && (RoutingManager::getInstance().is_ee_recovery_ongoing()))
-                {
-                    SyncEventGuard guard (se.mEEdatapacketEvent);
-                    if(se.mEEdatapacketEvent.wait(android::gMaxEERecoveryTimeout) == false)
-                    {
-                        goto TheEnd;
-                    }
-                }
-                if(nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME ==
-                        nfcFL.eseFL._ESE_UICC_EXCLUSIVE_WIRED_MODE) {
-
-                    se.mIsExclusiveWiredMode = true;
-                }
-                stat = se.checkForWiredModeAccess();
-                if(stat == false)
-                {
-                    ALOGV("Denying SE open due to SE listen mode active");
-                    secElemHandle = EE_ERROR_LISTEN_MODE;
-                    goto TheEnd;
-                }
-            }
-            else
-            {
-                if (se.isActivatedInListenMode()) {
-                    ALOGV("Denying SE open due to SE listen mode active");
-                    secElemHandle = EE_ERROR_LISTEN_MODE;
-                    goto TheEnd;
-                }
-
-                if (se.isRfFieldOn()) {
-                    ALOGV("Denying SE open due to SE in active RF field");
-                    secElemHandle = EE_ERROR_EXT_FIELD;
-                    goto TheEnd;
-                }
-            }
-
-            ret_val = NFC_GetP61Status ((void *)&p61_current_state);
-            if (ret_val < 0)
-            {
-                ALOGV("NFC_GetP61Status failed");
-                goto TheEnd;
-            }
-            ALOGV("P61 Status is: %x", p61_current_state);
-
-            if(nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION &&
-                    (p61_current_state & P61_STATE_JCP_DWNLD))
-                ALOGV("Denying SE open due to JCOP OS Download is in progress");
-            secElemHandle = EE_ERROR_IO;
-            goto TheEnd;
-        }
+  if ((!nfcFL.nfcNxpEse) ||
+      (!nfcFL.eseFL._ESE_WIRED_MODE_PRIO && se.isBusy())) {
+    goto TheEnd;
+  }
+
+  ret_val = NFC_GetP61Status((void*)&p61_current_state);
+  if (ret_val < 0) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_GetP61Status failed");
+    goto TheEnd;
+  }
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s P61 Status is: %x", __func__, p61_current_state);
+
+  if (((nfcFL.eseFL._NXP_ESE_VER == JCOP_VER_3_1) &&
+          (!(p61_current_state & P61_STATE_SPI) &&
+           !(p61_current_state & P61_STATE_SPI_PRIO))) ||
+      (nfcFL.eseFL._NXP_ESE_VER != JCOP_VER_3_1)) {
+    if (p61_current_state & (P61_STATE_SPI) ||
+        (p61_current_state & (P61_STATE_SPI_PRIO))) {
+      dual_mode_current_state |= SPI_ON;
+    }
+    if (p61_current_state & (P61_STATE_SPI_PRIO)) {
+      hold_the_transceive = true;
     }
 
-
-    if (((nfcFL.eseFL._NXP_ESE_VER == JCOP_VER_3_1)) &&(!(p61_current_state & P61_STATE_SPI) && !(p61_current_state & P61_STATE_SPI_PRIO))||(nfcFL.eseFL._NXP_ESE_VER != JCOP_VER_3_1))
-    {
-        if(p61_current_state & (P61_STATE_SPI)||(p61_current_state & (P61_STATE_SPI_PRIO)))
-        {
-            dual_mode_current_state |= SPI_ON;
-        }
-        if(p61_current_state & (P61_STATE_SPI_PRIO))
-        {
-            hold_the_transceive = true;
-        }
-
-        secElemHandle = NFC_ReqWiredAccess ((void *)&status);
-        if (secElemHandle < 0)
-        {
-            ALOGV("Denying SE open due to NFC_ReqWiredAccess failed");
-            goto TheEnd;
-        }
-        else
-        {
-            if (status != NFCSTATUS_SUCCESS)
-            {
-                ALOGV("Denying SE open due to SE is being used by SPI");
-                secElemHandle = EE_ERROR_IO;
-                goto TheEnd;
-            }
-            else
-            {
-                if(nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME == nfcFL.eseFL._ESE_UICC_EXCLUSIVE_WIRED_MODE) {
-                    if (isDiscoveryStarted())
-                    {
-                        // Stop RF Discovery if we were polling
-                        startRfDiscovery (false);
-                        status = NFA_DisableListening();
-                        if(status == NFCSTATUS_OK)
-                        {
-                            startRfDiscovery (true);
-                        }
-                    }
-                    else
-                    {
-                        status = NFA_DisableListening();
-                    }
-                    se.mlistenDisabled = true;
-                }
+    secElemHandle = NFC_ReqWiredAccess((void*)&status);
+    if (secElemHandle < 0) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("Denying SE open due to NFC_ReqWiredAccess failed");
+      goto TheEnd;
+    } else {
+      if (status != NFCSTATUS_SUCCESS) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("Denying SE open due to SE is being used by SPI");
+        secElemHandle = EE_ERROR_IO;
+        goto TheEnd;
+      } else {
+        if (nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME ==
+            nfcFL.eseFL._ESE_UICC_EXCLUSIVE_WIRED_MODE) {
+          if (isDiscoveryStarted()) {
+            // Stop RF Discovery if we were polling
+            startRfDiscovery(false);
+            status = NFA_DisableListening();
+            if (status == NFCSTATUS_OK) {
+              startRfDiscovery(true);
             }
+          } else {
+            status = NFA_DisableListening();
+          }
+          se.mlistenDisabled = true;
         }
+      }
     }
-    else
-    {
-        ALOGV("Denying SE open because SPI is already open");
-        goto TheEnd;
-
-    }
+  } else {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("Denying SE open because SPI is already open");
+    goto TheEnd;
+  }
 #endif
-/* Tell the controller to power up to get ready for sec elem operations */
-PowerSwitch::getInstance ().setLevel (PowerSwitch::FULL_POWER);
-PowerSwitch::getInstance ().setModeOn (PowerSwitch::SE_CONNECTED);
+  /* Tell the controller to power up to get ready for sec elem operations */
+  PowerSwitch::getInstance().setLevel(PowerSwitch::FULL_POWER);
+  PowerSwitch::getInstance().setModeOn(PowerSwitch::SE_CONNECTED);
 /* If controller is not routing AND there is no pipe connected,
        then turn on the sec elem */
-#if(NXP_EXTNS == TRUE)
-if(nfcFL.nfcNxpEse) {
-    if(nfcFL.eseFL._ESE_FORCE_ENABLE && (!(p61_current_state & (P61_STATE_SPI | P61_STATE_SPI_PRIO))) && (!(dual_mode_current_state & CL_ACTIVE)))
-        stat = se.SecEle_Modeset(0x01); //Workaround
+#if (NXP_EXTNS == TRUE)
+  if (nfcFL.nfcNxpEse) {
+    if (nfcFL.eseFL._ESE_FORCE_ENABLE &&
+        (!(p61_current_state & (P61_STATE_SPI | P61_STATE_SPI_PRIO))) &&
+        (!(dual_mode_current_state & CL_ACTIVE)))
+      stat = se.SecEle_Modeset(0x01);  // Workaround
     usleep(150000); /*provide enough delay if NFCC enter in recovery*/
-}
+  }
 #endif
-stat = se.activate(SecureElement::ESE_ID); // It is to get the current activated handle.
+  stat = se.activate(
+      SecureElement::ESE_ID);  // It is to get the current activated handle.
 
-if (stat)
-{
-    //establish a pipe to sec elem
+  if (stat) {
+    // establish a pipe to sec elem
     stat = se.connectEE();
-    if (stat)
-    {
-        secElemHandle = se.mActiveEeHandle;
-    }
-    else
-    {
-        se.deactivate (0);
+    if (stat) {
+      secElemHandle = se.mActiveEeHandle;
+    } else {
+      se.deactivate(0);
     }
-}
-#if(NXP_EXTNS == TRUE)
-if(nfcFL.nfcNxpEse && stat)
-{
+  }
+#if (NXP_EXTNS == TRUE)
+  if (nfcFL.nfcNxpEse && stat) {
     status = NFA_STATUS_OK;
-    if(nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) {
-        if(!(se.isActivatedInListenMode() || isp2pActivated() || NfcTag::getInstance ().isActivated ()))
-        {
-            se.enablePassiveListen(0x00);
-        }
-        se.meseUiccConcurrentAccess = true;
+    if (nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) {
+      if (!(se.isActivatedInListenMode() || isp2pActivated() ||
+            NfcTag::getInstance().isActivated())) {
+        se.enablePassiveListen(0x00);
+      }
+      se.meseUiccConcurrentAccess = true;
     }
-
-    if(nfcFL.eseFL._WIRED_MODE_STANDBY &&
-            (se.mNfccPowerMode == 1))
-    {
-        status = se.setNfccPwrConfig(se.POWER_ALWAYS_ON|se.COMM_LINK_ACTIVE);
-        if(status != NFA_STATUS_OK)
-        {
-            ALOGV("%s: power link command failed", __func__);
-        }
-        else
-        {
-            se.SecEle_Modeset(0x01);
-        }
+    /*Do not send PowerLink and ModeSet If SPI is already open*/
+    if ((nfcFL.eseFL._WIRED_MODE_STANDBY && (se.mNfccPowerMode == 1)) &&
+        !(p61_current_state & (P61_STATE_SPI | P61_STATE_SPI_PRIO))) {
+      status = se.setNfccPwrConfig(se.POWER_ALWAYS_ON | se.COMM_LINK_ACTIVE);
+      if (status != NFA_STATUS_OK) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: power link command failed", __func__);
+      } else {
+        se.SecEle_Modeset(0x01);
+      }
     }
 #endif
 
-    if((status == NFA_STATUS_OK) && (se.mIsIntfRstEnabled))
-    {
-        gateInfo = se.getApduGateInfo();
-        ALOGV("%s: GateInfo %d", __func__, gateInfo);
-        if(gateInfo == ETSI_12_APDU_GATE)
-        {
-            se.NfccStandByOperation(STANDBY_TIMER_STOP);
-            status = se.SecElem_sendEvt_Abort();
-            if(status != NFA_STATUS_OK)
-            {
-                ALOGV("%s: EVT_ABORT failed", __func__);
-                se.sendEvent(SecureElement::EVT_END_OF_APDU_TRANSFER);
-            }
+    if ((status == NFA_STATUS_OK) && (se.mIsIntfRstEnabled)) {
+      gateInfo = se.getApduGateInfo();
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: GateInfo %d", __func__, gateInfo);
+      if (gateInfo == ETSI_12_APDU_GATE) {
+        se.NfccStandByOperation(STANDBY_TIMER_STOP);
+        status = se.SecElem_sendEvt_Abort();
+        if (status != NFA_STATUS_OK) {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("%s: EVT_ABORT failed", __func__);
+          se.sendEvent(SecureElement::EVT_END_OF_APDU_TRANSFER);
         }
+      }
     }
-
-    if(status != NFA_STATUS_OK)
-    {
-        if(nfcFL.eseFL._WIRED_MODE_STANDBY && (se.mNfccPowerMode == 1) &&
-        !(p61_current_state & (P61_STATE_SPI | P61_STATE_SPI_PRIO))) {
-            se.setNfccPwrConfig(se.NFCC_DECIDES);
-        }
-        se.disconnectEE (secElemHandle);
-        secElemHandle = EE_ERROR_INIT;
-
-        ret_val = NFC_RelWiredAccess((void*)&status);
-        if(ret_val < 0)
-            ALOGV("Denying SE release due to NFC_RelWiredAccess failure");
-        else if(status != NFCSTATUS_SUCCESS)
-            ALOGV("Denying SE close, since SE is not released by PN54xx driver");
+    if (status == NFA_STATUS_OK) {
+      bool ret = false;
+      ret = se.checkPipeStatusAndRecreate();
+      if (!ret) status = NFCSTATUS_FAILED;
     }
-    else
-    {
-        se.mIsWiredModeOpen = true;
+    if (status != NFA_STATUS_OK) {
+      if (nfcFL.eseFL._WIRED_MODE_STANDBY && (se.mNfccPowerMode == 1) &&
+          !(p61_current_state & (P61_STATE_SPI | P61_STATE_SPI_PRIO))) {
+        se.setNfccPwrConfig(se.NFCC_DECIDES);
+      }
+      se.disconnectEE(secElemHandle);
+      secElemHandle = EE_ERROR_INIT;
+
+      ret_val = NFC_RelWiredAccess((void*)&status);
+      if (ret_val < 0)
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "Denying SE release due to NFC_RelWiredAccess failure");
+      else if (status != NFCSTATUS_SUCCESS)
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "Denying SE close, since SE is not released by PN54xx driver");
+    } else {
+      se.mIsWiredModeOpen = true;
     }
-}
-//if code fails to connect to the secure element, and nothing is active, then
-//tell the controller to power down
-if ((!stat) && (! PowerSwitch::getInstance ().setModeOff (PowerSwitch::SE_CONNECTED)))
-{
-    PowerSwitch::getInstance ().setLevel (PowerSwitch::LOW_POWER);
-}
+  }
+  // if code fails to connect to the secure element, and nothing is active, then
+  // tell the controller to power down
+  if ((!stat) &&
+      (!PowerSwitch::getInstance().setModeOff(PowerSwitch::SE_CONNECTED))) {
+    PowerSwitch::getInstance().setLevel(PowerSwitch::LOW_POWER);
+  }
+#if (NXP_EXTNS == TRUE)
+  if (isLowRamDevice()) {
+    se.NfccStandByOperation(STANDBY_ESE_PWR_ACQUIRE);
+  }
+#endif
 
 TheEnd:
-ALOGV("%s: exit; return handle=0x%X", __func__, secElemHandle);
-return secElemHandle;
-}
-
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit; return handle=0x%X", __func__, secElemHandle);
+  android::mSPIDwpSyncMutex.unlock();
+  return secElemHandle;
+}  // namespace android
 
 /*******************************************************************************
 **
@@ -383,137 +264,143 @@ return secElemHandle;
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-static jboolean nativeNfcSecureElement_doDisconnectSecureElementConnection (JNIEnv*, jobject, jint handle)
-{
-    ALOGV("%s: enter; handle=0x%04x", __func__, handle);
-    bool stat = false;
-#if(NXP_EXTNS == TRUE)
-    long ret_val = -1;
-    NFCSTATUS status = NFCSTATUS_FAILED;
-
-    SecureElement &se = SecureElement::getInstance();
-    se.NfccStandByOperation(STANDBY_TIMER_STOP);
-#endif
+static jboolean nativeNfcSecureElement_doDisconnectSecureElementConnection(
+    JNIEnv*, jobject, jint handle) {
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter; handle=0x%04x", __func__, handle);
+  bool stat = false;
+  long ret_val = -1;
+  p61_access_state_t p61_current_state = P61_STATE_INVALID;
+  android::mSPIDwpSyncMutex.lock();
+  ret_val = NFC_GetP61Status((void*)&p61_current_state);
+  if (ret_val < 0) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_GetP61Status failed");
+  }
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s P61 Status is: %x", __func__, p61_current_state);
+  if (p61_current_state & (P61_STATE_SPI) ||
+      (p61_current_state & (P61_STATE_SPI_PRIO))) {
+    dual_mode_current_state |= SPI_ON;
+  }
+  if ((p61_current_state & (P61_STATE_WIRED)) &&
+      (p61_current_state & (P61_STATE_SPI | P61_STATE_SPI_PRIO))) {
+    dual_mode_current_state |= SPI_DWPCL_BOTH_ACTIVE;
+  }
 
-#if(NXP_EXTNS == TRUE)
-    if(nfcFL.nfcNxpEse) {
-        if(handle == (SecureElement::EE_HANDLE_0xF8||se.EE_HANDLE_0xF4))
-        {
-            stat = SecureElement::getInstance().disconnectEE (handle);
-            if(nfcFL.nfcNxpEse) {
-                se.mIsWiredModeOpen = false;
-                if(nfcFL.eseFL._ESE_EXCLUSIVE_WIRED_MODE) {
-                    se.mIsExclusiveWiredMode = false;
-                    if(se.mlistenDisabled)
-                    {
-                        if (isDiscoveryStarted())
-                        {
-                            // Stop RF Discovery if we were polling
-                            startRfDiscovery (false);
-                            status = NFA_EnableListening();
-                            startRfDiscovery (true);
-                        }
-                        else
-                        {
-                            status = NFA_EnableListening();
-                        }
-                        se.mlistenDisabled = false;
-                    }
-                }
-            }
-            goto TheEnd;
-        }
+#if (NXP_EXTNS == TRUE)
+  NFCSTATUS status = NFCSTATUS_FAILED;
+
+  SecureElement& se = SecureElement::getInstance();
+  se.NfccStandByOperation(STANDBY_TIMER_STOP);
+  if (isLowRamDevice()) {
+    se.NfccStandByOperation(STANDBY_ESE_PWR_RELEASE);
+  }
+#endif
 
-        if(nfcFL.nfcNxpEse) {
-            //Send the EVT_END_OF_APDU_TRANSFER event at the end of wired mode session.
-            se.NfccStandByOperation(STANDBY_MODE_ON);
+#if (NXP_EXTNS == TRUE)
+  if (nfcFL.nfcNxpEse) {
+    if (handle == (SecureElement::EE_HANDLE_0xF8 || se.EE_HANDLE_0xF4)) {
+      stat = SecureElement::getInstance().disconnectEE(handle);
+      se.mIsWiredModeOpen = false;
+      if (nfcFL.eseFL._ESE_EXCLUSIVE_WIRED_MODE) {
+        se.mIsExclusiveWiredMode = false;
+        if (se.mlistenDisabled) {
+          if (isDiscoveryStarted()) {
+          // Stop RF Discovery if we were polling
+            startRfDiscovery(false);
+            status = NFA_EnableListening();
+            startRfDiscovery(true);
+          } else {
+             status = NFA_EnableListening();
+          }
+          se.mlistenDisabled = false;
         }
+      }
+      goto TheEnd;
     }
+
+    // Send the EVT_END_OF_APDU_TRANSFER event at the end of wired mode
+    // session.
+    se.NfccStandByOperation(STANDBY_MODE_ON);
+  }
 #endif
 
-    stat = SecureElement::getInstance().disconnectEE (handle);
-
-    /* if nothing is active after this, then tell the controller to power down */
-    if (! PowerSwitch::getInstance ().setModeOff (PowerSwitch::SE_CONNECTED))
-        PowerSwitch::getInstance ().setLevel (PowerSwitch::LOW_POWER);
-#if(NXP_EXTNS == TRUE)
-    if(nfcFL.nfcNxpEse) {
-        ret_val = NFC_RelWiredAccess ((void *)&status);
-        if (ret_val < 0)
-        {
-            ALOGV("Denying SE Release due to NFC_RelWiredAccess failed");
-            goto TheEnd;
-        }
-        else
-        {
-            if (status != NFCSTATUS_SUCCESS)
-            {
-                ALOGV("Denying SE close due to SE is not being released by Pn54x driver");
-                stat = false;
-            }
-            if(nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) {
-                se.enablePassiveListen(0x01);
-                SecureElement::getInstance().mPassiveListenTimer.kill();
-                se.meseUiccConcurrentAccess = false;
-            }
-            se.mIsWiredModeOpen = false;
-            if((nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME ==
-                    nfcFL.eseFL._ESE_UICC_EXCLUSIVE_WIRED_MODE) && se.mlistenDisabled) {
-                if (isDiscoveryStarted())
-                {
-                    // Stop RF Discovery if we were polling
-                    startRfDiscovery (false);
-                    status = NFA_EnableListening();
-                    startRfDiscovery (true);
-                }
-                else
-                {
-                    status = NFA_EnableListening();
-                }
-                se.mlistenDisabled = false;
-            }
+  stat = SecureElement::getInstance().disconnectEE(handle);
+
+  /* if nothing is active after this, then tell the controller to power down */
+  if (!PowerSwitch::getInstance().setModeOff(PowerSwitch::SE_CONNECTED))
+    PowerSwitch::getInstance().setLevel(PowerSwitch::LOW_POWER);
+#if (NXP_EXTNS == TRUE)
+  if (nfcFL.nfcNxpEse) {
+    ret_val = NFC_RelWiredAccess((void*)&status);
+    if (ret_val < 0) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "Denying SE Release due to NFC_RelWiredAccess failed");
+      goto TheEnd;
+    } else {
+      if (status != NFCSTATUS_SUCCESS) {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "Denying SE close due to SE is not being released by Pn54x driver");
+        stat = false;
+      }
+      if (nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) {
+        se.enablePassiveListen(0x01);
+        SecureElement::getInstance().mPassiveListenTimer.kill();
+        se.meseUiccConcurrentAccess = false;
+      }
+      se.mIsWiredModeOpen = false;
+      if ((nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME ==
+           nfcFL.eseFL._ESE_UICC_EXCLUSIVE_WIRED_MODE) &&
+          se.mlistenDisabled) {
+        if (isDiscoveryStarted()) {
+          // Stop RF Discovery if we were polling
+          startRfDiscovery(false);
+          status = NFA_EnableListening();
+          startRfDiscovery(true);
+        } else {
+          status = NFA_EnableListening();
         }
+        se.mlistenDisabled = false;
+      }
     }
+  }
 #endif
 TheEnd:
-#if(NXP_EXTNS == TRUE)
-if(nfcFL.nfcNxpEse) {
-    ALOGV("%s: exit stat = %d", __func__, stat);
-}
-else {
-    ALOGV("%s: exit", __func__);
-}
+#if (NXP_EXTNS == TRUE)
+  if (nfcFL.nfcNxpEse) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: exit stat = %d", __func__, stat);
+  } else {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  }
 #else
-    ALOGV("%s: exit", __func__);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
 #endif
-
-    return stat ? JNI_TRUE : JNI_FALSE;
+  android::mSPIDwpSyncMutex.unlock();
+  return stat ? JNI_TRUE : JNI_FALSE;
 }
-#if(NXP_EXTNS == TRUE)
-static int checkP61Status(void)
-{
-    if(!nfcFL.nfcNxpEse) {
-        ALOGV("%s : nfcNxpEse not available. Returning", __func__);
-        return -1;
-    }
-    jint ret_val = -1;
-    p61_access_state_t p61_current_state = P61_STATE_INVALID;
-    ret_val = NFC_GetP61Status ((void *)&p61_current_state);
-    if (ret_val < 0)
-    {
-        ALOGV("NFC_GetP61Status failed");
-        return -1;
-    }
-    if(p61_current_state & (P61_STATE_SPI)||(p61_current_state & (P61_STATE_SPI_PRIO)))
-    {
-        ALOGV("No gpio change");
-        ret_val = 0;
-    }
-    else
-    {
-        ret_val = -1;
-    }
-    return ret_val;
+#if (NXP_EXTNS == TRUE)
+static int checkP61Status(void) {
+  if (!nfcFL.nfcNxpEse) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s : nfcNxpEse not available. Returning", __func__);
+    return -1;
+  }
+  jint ret_val = -1;
+  p61_access_state_t p61_current_state = P61_STATE_INVALID;
+  ret_val = NFC_GetP61Status((void*)&p61_current_state);
+  if (ret_val < 0) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_GetP61Status failed");
+    return -1;
+  }
+  if (p61_current_state & (P61_STATE_SPI) ||
+      (p61_current_state & (P61_STATE_SPI_PRIO))) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("No gpio change");
+    ret_val = 0;
+  } else {
+    ret_val = -1;
+  }
+  return ret_val;
 }
 #endif
 /*******************************************************************************
@@ -528,91 +415,95 @@ static int checkP61Status(void)
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-static jboolean nativeNfcSecureElement_doResetSecureElement (JNIEnv*, jobject, jint handle)
-{
-    bool stat = false;
-    if(nfcFL.nfcNxpEse) {
-        tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
-        SecureElement &se = SecureElement::getInstance();
-
-        ALOGV("%s: enter; handle=0x%04x", __func__, handle);
-        if(!se.mIsWiredModeOpen)
-        {
-            ALOGV("wired mode is not open");
-            return stat;
-        }
-        if(nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE && nfcFL.eseFL._WIRED_MODE_STANDBY && !checkP61Status()) {
-            ALOGV("Reset is not allowed while SPI ON");
-            return stat;
-        }
-        if(nfcFL.eseFL._WIRED_MODE_STANDBY && (se.mNfccPowerMode == 1))
-        {
-            nfaStat = se.setNfccPwrConfig(se.NFCC_DECIDES);
-            ALOGV("%s Power Mode is Legacy", __func__);
-        }
-        {
-            stat = se.SecEle_Modeset(0x00);
-            if (handle == SecureElement::EE_HANDLE_0xF3)
-            {
-                if(checkP61Status())
-                    se.NfccStandByOperation(STANDBY_GPIO_LOW);
-            }
-            usleep(100 * 1000);
-            if (handle == SecureElement::EE_HANDLE_0xF3)
-            {
-                if(checkP61Status() && (se.mIsWiredModeOpen == true))
-                    se.NfccStandByOperation(STANDBY_GPIO_HIGH);
-            }
-
-            if(nfcFL.eseFL._WIRED_MODE_STANDBY && (se.mNfccPowerMode == 1))
-                stat = se.setNfccPwrConfig(se.POWER_ALWAYS_ON |se.COMM_LINK_ACTIVE);
-            ALOGV("%s Power Mode is Legacy", __func__);
+static jboolean nativeNfcSecureElement_doResetSecureElement(JNIEnv*, jobject,
+                                                            jint handle) {
+  bool stat = false;
+  if (nfcFL.nfcNxpEse) {
+    tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+    SecureElement& se = SecureElement::getInstance();
+
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: enter; handle=0x%04x", __func__, handle);
+    if (!se.mIsWiredModeOpen) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("wired mode is not open");
+      return stat;
+    }
+    if (nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE &&
+        nfcFL.eseFL._WIRED_MODE_STANDBY && !checkP61Status()) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("Reset is not allowed while SPI ON");
+      return stat;
+    }
+    if (nfcFL.eseFL._WIRED_MODE_STANDBY && (se.mNfccPowerMode == 1)) {
+      nfaStat = se.setNfccPwrConfig(se.NFCC_DECIDES);
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s Power Mode is Legacy", __func__);
+    }
+    {
+      stat = se.SecEle_Modeset(0x00);
+      if (handle == SecureElement::EE_HANDLE_0xF3) {
+        if (checkP61Status()) se.NfccStandByOperation(STANDBY_GPIO_LOW);
+      }
+      usleep(100 * 1000);
+      if (handle == SecureElement::EE_HANDLE_0xF3) {
+        if (checkP61Status() && (se.mIsWiredModeOpen == true))
+          se.NfccStandByOperation(STANDBY_GPIO_HIGH);
+      }
+
+      if (nfcFL.eseFL._WIRED_MODE_STANDBY && (se.mNfccPowerMode == 1)) {
+        uint8_t status = se.setNfccPwrConfig(se.POWER_ALWAYS_ON | se.COMM_LINK_ACTIVE);
+        if (status != NFA_STATUS_OK) {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("%s: power link command failed", __func__);
         }
-        usleep(2000 * 1000);
-        stat = se.SecEle_Modeset(0x01);
+      }
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s Power Mode is Legacy", __func__);
     }
-ALOGV("%s: exit", __func__);
-return stat ? JNI_TRUE : JNI_FALSE;
+    usleep(2000 * 1000);
+    stat = se.SecEle_Modeset(0x01);
+  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  return stat ? JNI_TRUE : JNI_FALSE;
 }
 
 /*******************************************************************************
  **
-** Function:        nativeNfcSecureElement_doeSEChipResetSecureElement
-**
-** Description:     Reset the secure element.
-**                  e: JVM environment.
-**                  o: Java object.
-**                  handle: Handle of secure element.
-**
-** Returns:         True if ok.
-**
-*******************************************************************************/
-static jboolean nativeNfcSecureElement_doeSEChipResetSecureElement (JNIEnv*, jobject)
-{
-    bool stat = false;
-    NFCSTATUS status = NFCSTATUS_FAILED;
-    unsigned long num = 0x01;
+ ** Function:        nativeNfcSecureElement_doeSEChipResetSecureElement
+ **
+ ** Description:     Reset the secure element.
+ **                  e: JVM environment.
+ **                  o: Java object.
+ **                  handle: Handle of secure element.
+ **
+ ** Returns:         True if ok.
+ **
+ *******************************************************************************/
+static jboolean nativeNfcSecureElement_doeSEChipResetSecureElement(JNIEnv*,
+                                                                   jobject) {
+  bool stat = false;
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  unsigned long num = 0x01;
 #if (NXP_EXTNS == TRUE)
-    SecureElement &se = SecureElement::getInstance();
-    if(nfcFL.nfcNxpEse) {
-        if (GetNxpNumValue("NXP_ESE_POWER_DH_CONTROL", &num, sizeof(num)))
-        {
-            ALOGV("Power schemes enabled in config file is %ld", num);
-        }
-        if(num == 0x02)
-        {
-            status = se.eSE_Chip_Reset();
-            if(status == NFCSTATUS_SUCCESS)
-            {
-                stat = true;
-            }
-        }
+  SecureElement& se = SecureElement::getInstance();
+  if (nfcFL.nfcNxpEse) {
+    if (NfcConfig::hasKey("NXP_ESE_POWER_DH_CONTROL")) {
+      num = NfcConfig::getUnsigned("NXP_ESE_POWER_DH_CONTROL");
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("Power schemes enabled in config file is %ld", num);
     }
+    if (num == 0x02) {
+      status = se.eSE_Chip_Reset();
+      if (status == NFCSTATUS_SUCCESS) {
+        stat = true;
+      }
+    }
+  }
 #endif
-    return stat ? JNI_TRUE : JNI_FALSE;
+  return stat ? JNI_TRUE : JNI_FALSE;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nativeNfcSecureElement_doGetAtr
@@ -625,27 +516,30 @@ static jboolean nativeNfcSecureElement_doeSEChipResetSecureElement (JNIEnv*, job
 ** Returns:         Buffer of received data.
 **
 *******************************************************************************/
-static jbyteArray nativeNfcSecureElement_doGetAtr (JNIEnv* e, jobject, jint handle)
-{
-    bool stat = false;
-    const int32_t recvBufferMaxSize = 1024;
-    uint8_t recvBuffer [recvBufferMaxSize];
-    int32_t recvBufferActualSize = 0;
-    if(nfcFL.nfcNxpEse) {
-        ALOGV("%s: enter; handle=0x%04x", __func__, handle);
-
-        stat = SecureElement::getInstance().getAtr(handle, recvBuffer, &recvBufferActualSize);
-
-        //copy results back to java
-    }
-    jbyteArray result = e->NewByteArray(recvBufferActualSize);
-    if (result != NULL) {
-        e->SetByteArrayRegion(result, 0, recvBufferActualSize, (jbyte *) recvBuffer);
-    }
-
-    ALOGV("%s: exit: recv len=%ld", __func__, recvBufferActualSize);
-
-    return result;
+static jbyteArray nativeNfcSecureElement_doGetAtr(JNIEnv* e, jobject,
+                                                  jint handle) {
+  bool stat = false;
+  const int32_t recvBufferMaxSize = 1024;
+  uint8_t recvBuffer[recvBufferMaxSize];
+  int32_t recvBufferActualSize = 0;
+  if (nfcFL.nfcNxpEse) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: enter; handle=0x%04x", __func__, handle);
+
+    stat = SecureElement::getInstance().getAtr(handle, recvBuffer,
+                                               &recvBufferActualSize);
+
+    // copy results back to java
+  }
+  jbyteArray result = e->NewByteArray(recvBufferActualSize);
+  if (result != NULL) {
+    e->SetByteArrayRegion(result, 0, recvBufferActualSize, (jbyte*)recvBuffer);
+  }
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit: recv len=%d", __func__, recvBufferActualSize);
+
+  return result;
 }
 
 /*******************************************************************************
@@ -661,42 +555,46 @@ static jbyteArray nativeNfcSecureElement_doGetAtr (JNIEnv* e, jobject, jint hand
 ** Returns:         Buffer of received data.
 **
 *******************************************************************************/
-static jbyteArray nativeNfcSecureElement_doTransceive (JNIEnv* e, jobject, jint handle, jbyteArray data)
-{
-    const int32_t recvBufferMaxSize = 0x8800;//1024; 34k
-    uint8_t recvBuffer [recvBufferMaxSize];
-    int32_t recvBufferActualSize = 0;
-    eTransceiveStatus tranStatus = TRANSCEIVE_STATUS_FAILED;
-
-    ScopedByteArrayRW bytes(e, data);
-#if(NXP_EXTNS == TRUE)
-    ALOGV("%s: enter; handle=0x%X; buf len=%zu", __func__, handle, bytes.size());
-    tranStatus = SecureElement::getInstance().transceive(reinterpret_cast<uint8_t*>(&bytes[0]), bytes.size(), recvBuffer, recvBufferMaxSize, recvBufferActualSize, WIRED_MODE_TRANSCEIVE_TIMEOUT);
-    if(tranStatus == TRANSCEIVE_STATUS_MAX_WTX_REACHED)
-    {
-        ALOGE ("%s: Wired Mode Max WTX count reached", __FUNCTION__);
-        jbyteArray result = e->NewByteArray(0);
-        nativeNfcSecureElement_doResetSecureElement(e,NULL,handle);
-        return result;
-    }
-
-    //copy results back to java
-    jbyteArray result = e->NewByteArray(recvBufferActualSize);
-    if (result != NULL)
-    {
-        e->SetByteArrayRegion(result, 0, recvBufferActualSize, (jbyte *) recvBuffer);
-    }
-    if (nfcFL.nfcNxpEse && nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION &&
-            (SecureElement::getInstance().mIsWiredModeBlocked == true))
-    {
-        ALOGV("APDU Transceive CE wait");
-        SecureElement::getInstance().startThread(0x01);
-    }
-    ALOGV("%s: exit: recv len=%ld", __func__, recvBufferActualSize);
-    return result;
-#else
+static jbyteArray nativeNfcSecureElement_doTransceive(JNIEnv* e, jobject,
+                                                      jint handle,
+                                                      jbyteArray data) {
+  const int32_t recvBufferMaxSize = 0x8800;  // 1024; 34k
+  uint8_t recvBuffer[recvBufferMaxSize];
+  int32_t recvBufferActualSize = 0;
+  eTransceiveStatus tranStatus = TRANSCEIVE_STATUS_FAILED;
+
+  ScopedByteArrayRW bytes(e, data);
+#if (NXP_EXTNS == TRUE)
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: enter; handle=0x%X; buf len=%zu", __func__, handle, bytes.size());
+  tranStatus = SecureElement::getInstance().transceive(
+      reinterpret_cast<uint8_t*>(&bytes[0]), bytes.size(), recvBuffer,
+      recvBufferMaxSize, recvBufferActualSize, WIRED_MODE_TRANSCEIVE_TIMEOUT);
+  if (tranStatus == TRANSCEIVE_STATUS_MAX_WTX_REACHED) {
+    LOG(ERROR) << StringPrintf("%s: Wired Mode Max WTX count reached",
+                               __FUNCTION__);
     jbyteArray result = e->NewByteArray(0);
+    nativeNfcSecureElement_doResetSecureElement(e, NULL, handle);
     return result;
+  }
+
+  // copy results back to java
+  jbyteArray result = e->NewByteArray(recvBufferActualSize);
+  if (result != NULL) {
+    e->SetByteArrayRegion(result, 0, recvBufferActualSize, (jbyte*)recvBuffer);
+  }
+  if (nfcFL.nfcNxpEse &&
+      nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION &&
+      (SecureElement::getInstance().mIsWiredModeBlocked == true)) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("APDU Transceive CE wait");
+    SecureElement::getInstance().startThread(0x01);
+  }
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit: recv len=%d", __func__, recvBufferActualSize);
+  return result;
+#else
+  jbyteArray result = e->NewByteArray(0);
+  return result;
 #endif
 }
 
@@ -705,21 +603,24 @@ static jbyteArray nativeNfcSecureElement_doTransceive (JNIEnv* e, jobject, jint
 ** Description:     JNI functions
 **
 *****************************************************************************/
-static JNINativeMethod gMethods[] =
-{
-#if(NXP_EXTNS == TRUE)
-   {"doNativeOpenSecureElementConnection", "(I)I", (void *) nativeNfcSecureElement_doOpenSecureElementConnection},
+static JNINativeMethod gMethods[] = {
+#if (NXP_EXTNS == TRUE)
+    {"doNativeOpenSecureElementConnection", "(I)I",
+     (void*)nativeNfcSecureElement_doOpenSecureElementConnection},
 #else
-    {"doNativeOpenSecureElementConnection", "()I", (void *) nativeNfcSecureElement_doOpenSecureElementConnection},
+    {"doNativeOpenSecureElementConnection", "()I",
+     (void*)nativeNfcSecureElement_doOpenSecureElementConnection},
 #endif
-   {"doNativeDisconnectSecureElementConnection", "(I)Z", (void *) nativeNfcSecureElement_doDisconnectSecureElementConnection},
-   {"doNativeResetSecureElement", "(I)Z", (void *) nativeNfcSecureElement_doResetSecureElement},
-   {"doNativeeSEChipResetSecureElement", "()Z", (void *) nativeNfcSecureElement_doeSEChipResetSecureElement},
-   {"doTransceive", "(I[B)[B", (void *) nativeNfcSecureElement_doTransceive},
-   {"doNativeGetAtr", "(I)[B", (void *) nativeNfcSecureElement_doGetAtr},
+    {"doNativeDisconnectSecureElementConnection", "(I)Z",
+     (void*)nativeNfcSecureElement_doDisconnectSecureElementConnection},
+    {"doNativeResetSecureElement", "(I)Z",
+     (void*)nativeNfcSecureElement_doResetSecureElement},
+    {"doNativeeSEChipResetSecureElement", "()Z",
+     (void*)nativeNfcSecureElement_doeSEChipResetSecureElement},
+    {"doTransceive", "(I[B)[B", (void*)nativeNfcSecureElement_doTransceive},
+    {"doNativeGetAtr", "(I)[B", (void*)nativeNfcSecureElement_doGetAtr},
 };
 
-
 /*******************************************************************************
 **
 ** Function:        register_com_android_nfc_NativeNfcSecureElement
@@ -730,11 +631,9 @@ static JNINativeMethod gMethods[] =
 ** Returns:         Status of registration.
 **
 *******************************************************************************/
-int register_com_android_nfc_NativeNfcSecureElement(JNIEnv *e)
-{
-    return jniRegisterNativeMethods(e, gNativeNfcSecureElementClassName,
-            gMethods, NELEM(gMethods));
+int register_com_android_nfc_NativeNfcSecureElement(JNIEnv* e) {
+  return jniRegisterNativeMethods(e, gNativeNfcSecureElementClassName, gMethods,
+                                  NELEM(gMethods));
 }
 
-
-} // namespace android
+}  // namespace android
diff --git a/nci/jni/NfcJniUtil.cpp b/nci/jni/NfcJniUtil.cpp
index b01f9acb..03952931 100644
--- a/nci/jni/NfcJniUtil.cpp
+++ b/nci/jni/NfcJniUtil.cpp
@@ -18,7 +18,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -36,12 +36,17 @@
 
 #include "NfcJniUtil.h"
 
-#include <log/log.h>
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
 #include <errno.h>
+#include <log/log.h>
 #include <nativehelper/JNIHelp.h>
 #include <nativehelper/ScopedLocalRef.h>
 #include "RoutingManager.h"
 
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
 
 /*******************************************************************************
 **
@@ -54,44 +59,41 @@
 ** Returns:         JNI version.
 **
 *******************************************************************************/
-jint JNI_OnLoad (JavaVM* jvm, void*)
-{
-    ALOGV("%s: enter", __func__);
-    JNIEnv *e = NULL;
-
-    ALOGI("NFC Service: loading nci JNI");
-
-    // Check JNI version
-    if (jvm->GetEnv ((void **) &e, JNI_VERSION_1_6))
-        return JNI_ERR;
-
-    if (android::register_com_android_nfc_NativeNfcManager (e) == -1)
-        return JNI_ERR;
-    if (android::register_com_android_nfc_NativeLlcpServiceSocket (e) == -1)
-        return JNI_ERR;
-    if (android::register_com_android_nfc_NativeLlcpSocket (e) == -1)
-        return JNI_ERR;
-    if (android::register_com_android_nfc_NativeNfcTag (e) == -1)
-        return JNI_ERR;
-    if (android::register_com_android_nfc_NativeLlcpConnectionlessSocket (e) == -1)
-        return JNI_ERR;
-    if (android::register_com_android_nfc_NativeP2pDevice (e) == -1)
-        return JNI_ERR;
-    if (RoutingManager::getInstance().registerJniFunctions (e) == -1)
-        return JNI_ERR;
-    if (android::register_com_android_nfc_NativeNfcSecureElement (e) == -1)
-        return JNI_ERR;
-    if (android::register_com_android_nfc_NativeNfcAla (e) == -1)
-           return JNI_ERR;
-
-    ALOGV("%s: exit", __func__);
-    return JNI_VERSION_1_6;
+jint JNI_OnLoad(JavaVM* jvm, void*) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+  JNIEnv* e = NULL;
+
+  LOG(INFO) << StringPrintf("NFC Service: loading nci JNI");
+
+  // Check JNI version
+  if (jvm->GetEnv((void**)&e, JNI_VERSION_1_6)) return JNI_ERR;
+
+  if (android::register_com_android_nfc_NativeNfcManager(e) == -1)
+    return JNI_ERR;
+  if (android::register_com_android_nfc_NativeLlcpServiceSocket(e) == -1)
+    return JNI_ERR;
+  if (android::register_com_android_nfc_NativeLlcpSocket(e) == -1)
+    return JNI_ERR;
+  if (android::register_com_android_nfc_NativeNfcTag(e) == -1) return JNI_ERR;
+  if (android::register_com_android_nfc_NativeLlcpConnectionlessSocket(e) == -1)
+    return JNI_ERR;
+  if (android::register_com_android_nfc_NativeP2pDevice(e) == -1)
+    return JNI_ERR;
+  if (RoutingManager::getInstance().registerJniFunctions(e) == -1)
+    return JNI_ERR;
+  if (android::register_com_android_nfc_NativeNfcSecureElement(e) == -1)
+    return JNI_ERR;
+  if (android::register_com_android_nfc_NativeNfcAla(e) == -1) return JNI_ERR;
+#if (NXP_EXTNS == TRUE)
+  if (android::register_com_android_nfc_NativeNfcMposManager(e) == -1)
+    return JNI_ERR;
+#endif
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  return JNI_VERSION_1_6;
 }
 
-
-namespace android
-{
-
+namespace android {
 
 /*******************************************************************************
 **
@@ -102,33 +104,28 @@ namespace android
 ** Returns:         Status code.
 **
 *******************************************************************************/
-int nfc_jni_cache_object (JNIEnv *e, const char *className, jobject *cachedObj)
-{
-    ScopedLocalRef<jclass> cls(e, e->FindClass(className));
-    if (cls.get() == NULL)
-    {
-        ALOGE("%s: find class error", __func__);
-        return -1;
-    }
-
-    jmethodID ctor = e->GetMethodID(cls.get(), "<init>", "()V");
-    ScopedLocalRef<jobject> obj(e, e->NewObject(cls.get(), ctor));
-    if (obj.get() == NULL)
-    {
-       ALOGE("%s: create object error", __func__);
-       return -1;
-    }
-
-    *cachedObj = e->NewGlobalRef(obj.get());
-    if (*cachedObj == NULL)
-    {
-        ALOGE("%s: global ref error", __func__);
-        return -1;
-    }
-    return 0;
+int nfc_jni_cache_object(JNIEnv* e, const char* className, jobject* cachedObj) {
+  ScopedLocalRef<jclass> cls(e, e->FindClass(className));
+  if (cls.get() == NULL) {
+    LOG(ERROR) << StringPrintf("%s: find class error", __func__);
+    return -1;
+  }
+
+  jmethodID ctor = e->GetMethodID(cls.get(), "<init>", "()V");
+  ScopedLocalRef<jobject> obj(e, e->NewObject(cls.get(), ctor));
+  if (obj.get() == NULL) {
+    LOG(ERROR) << StringPrintf("%s: create object error", __func__);
+    return -1;
+  }
+
+  *cachedObj = e->NewGlobalRef(obj.get());
+  if (*cachedObj == NULL) {
+    LOG(ERROR) << StringPrintf("%s: global ref error", __func__);
+    return -1;
+  }
+  return 0;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nfc_jni_get_nfc_socket_handle
@@ -140,14 +137,12 @@ int nfc_jni_cache_object (JNIEnv *e, const char *className, jobject *cachedObj)
 ** Returns:         Value of mHandle.
 **
 *******************************************************************************/
-int nfc_jni_get_nfc_socket_handle (JNIEnv *e, jobject o)
-{
-    ScopedLocalRef<jclass> c(e, e->GetObjectClass(o));
-    jfieldID f = e->GetFieldID(c.get(), "mHandle", "I");
-    return e->GetIntField(o, f);
+int nfc_jni_get_nfc_socket_handle(JNIEnv* e, jobject o) {
+  ScopedLocalRef<jclass> c(e, e->GetObjectClass(o));
+  jfieldID f = e->GetFieldID(c.get(), "mHandle", "I");
+  return e->GetIntField(o, f);
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nfc_jni_get_nat
@@ -159,15 +154,13 @@ int nfc_jni_get_nfc_socket_handle (JNIEnv *e, jobject o)
 ** Returns:         Pointer to the value of mNative.
 **
 *******************************************************************************/
-struct nfc_jni_native_data* nfc_jni_get_nat(JNIEnv *e, jobject o)
-{
-   ScopedLocalRef<jclass> c(e, e->GetObjectClass(o));
-   jfieldID f = e->GetFieldID(c.get(), "mNative", "J");
-   /* Retrieve native structure address */
-   return (struct nfc_jni_native_data*) e->GetLongField(o, f);
+struct nfc_jni_native_data* nfc_jni_get_nat(JNIEnv* e, jobject o) {
+  ScopedLocalRef<jclass> c(e, e->GetObjectClass(o));
+  jfieldID f = e->GetFieldID(c.get(), "mNative", "J");
+  /* Retrieve native structure address */
+  return (struct nfc_jni_native_data*)e->GetLongField(o, f);
 }
 
-
 /*******************************************************************************
 **
 ** Function         nfc_jni_cache_object_local
@@ -177,31 +170,27 @@ struct nfc_jni_native_data* nfc_jni_get_nat(JNIEnv *e, jobject o)
 ** Returns          -1 on failure, 0 on success
 **
 *******************************************************************************/
-int nfc_jni_cache_object_local (JNIEnv *e, const char *className, jobject *cachedObj)
-{
-    ScopedLocalRef<jclass> cls(e, e->FindClass(className));
-    if(cls.get() == NULL)
-    {
-        ALOGE("%s: find class error", __func__);
-        return -1;
-    }
-
-    jmethodID ctor = e->GetMethodID(cls.get(), "<init>", "()V");
-    jobject obj = e->NewObject(cls.get(), ctor);
-    if (obj == NULL)
-    {
-       ALOGE("%s: create object error", __func__);
-       return -1;
-    }
-
-    *cachedObj = obj;
-    if (*cachedObj == NULL)
-    {
-        ALOGE("%s: global ref error", __func__);
-        return -1;
-    }
-    return 0;
+int nfc_jni_cache_object_local(JNIEnv* e, const char* className,
+                               jobject* cachedObj) {
+  ScopedLocalRef<jclass> cls(e, e->FindClass(className));
+  if (cls.get() == NULL) {
+    LOG(ERROR) << StringPrintf("%s: find class error", __func__);
+    return -1;
+  }
+
+  jmethodID ctor = e->GetMethodID(cls.get(), "<init>", "()V");
+  jobject obj = e->NewObject(cls.get(), ctor);
+  if (obj == NULL) {
+    LOG(ERROR) << StringPrintf("%s: create object error", __func__);
+    return -1;
+  }
+
+  *cachedObj = obj;
+  if (*cachedObj == NULL) {
+    LOG(ERROR) << StringPrintf("%s: global ref error", __func__);
+    return -1;
+  }
+  return 0;
 }
 
-
-} // namespace android
+}  // namespace android
diff --git a/nci/jni/NfcJniUtil.h b/nci/jni/NfcJniUtil.h
index c033aadf..b224ee80 100644
--- a/nci/jni/NfcJniUtil.h
+++ b/nci/jni/NfcJniUtil.h
@@ -17,7 +17,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -33,181 +33,174 @@
  *
  ******************************************************************************/
 #pragma once
-#undef LOG_TAG
-#define LOG_TAG "BrcmNfcJni"
-#include <nativehelper/JNIHelp.h>
+#include <JNIHelp.h>
 #include <jni.h>
 #include <pthread.h>
-#include <sys/queue.h>
 #include <semaphore.h>
+#include <sys/queue.h>
 #include "Nxp_Features.h"
 
-#define ALOGV ALOGD
 /* Discovery modes -- keep in sync with NFCManager.DISCOVERY_MODE_* */
-#define DISCOVERY_MODE_TAG_READER         0
-#define DISCOVERY_MODE_NFCIP1             1
-#define DISCOVERY_MODE_CARD_EMULATION     2
-#define DISCOVERY_MODE_TABLE_SIZE         3
-
-#define DISCOVERY_MODE_DISABLED           0
-#define DISCOVERY_MODE_ENABLED            1
+#define DISCOVERY_MODE_TAG_READER 0
+#define DISCOVERY_MODE_NFCIP1 1
+#define DISCOVERY_MODE_CARD_EMULATION 2
+#define DISCOVERY_MODE_TABLE_SIZE 3
 
-#define MODE_P2P_TARGET                   0
-#define MODE_P2P_INITIATOR                1
+#define DISCOVERY_MODE_DISABLED 0
+#define DISCOVERY_MODE_ENABLED 1
 
+#define MODE_P2P_TARGET 0
+#define MODE_P2P_INITIATOR 1
 
 /* Properties values */
-#define PROPERTY_LLCP_LTO                 0
-#define PROPERTY_LLCP_MIU                 1
-#define PROPERTY_LLCP_WKS                 2
-#define PROPERTY_LLCP_OPT                 3
-#define PROPERTY_NFC_DISCOVERY_A          4
-#define PROPERTY_NFC_DISCOVERY_B          5
-#define PROPERTY_NFC_DISCOVERY_F          6
-#define PROPERTY_NFC_DISCOVERY_15693      7
-#define PROPERTY_NFC_DISCOVERY_NCFIP      8
-
+#define PROPERTY_LLCP_LTO 0
+#define PROPERTY_LLCP_MIU 1
+#define PROPERTY_LLCP_WKS 2
+#define PROPERTY_LLCP_OPT 3
+#define PROPERTY_NFC_DISCOVERY_A 4
+#define PROPERTY_NFC_DISCOVERY_B 5
+#define PROPERTY_NFC_DISCOVERY_F 6
+#define PROPERTY_NFC_DISCOVERY_15693 7
+#define PROPERTY_NFC_DISCOVERY_NCFIP 8
 
 /* Error codes */
-#define ERROR_BUFFER_TOO_SMALL            (-12)
-#define ERROR_INSUFFICIENT_RESOURCES      (-9)
-
+#define ERROR_BUFFER_TOO_SMALL (-12)
+#define ERROR_INSUFFICIENT_RESOURCES (-9)
 
 /* Pre-defined tag type values. These must match the values in
  * Ndef.java in the framework.
  */
-#define NDEF_UNKNOWN_TYPE                (-1)
-#define NDEF_TYPE1_TAG                   1
-#define NDEF_TYPE2_TAG                   2
-#define NDEF_TYPE3_TAG                   3
-#define NDEF_TYPE4_TAG                   4
-#define NDEF_MIFARE_CLASSIC_TAG          101
-
+#define NDEF_UNKNOWN_TYPE (-1)
+#define NDEF_TYPE1_TAG 1
+#define NDEF_TYPE2_TAG 2
+#define NDEF_TYPE3_TAG 3
+#define NDEF_TYPE4_TAG 4
+#define NDEF_MIFARE_CLASSIC_TAG 101
 
 /* Pre-defined card read/write state values. These must match the values in
  * Ndef.java in the framework.
  */
-#define NDEF_MODE_READ_ONLY              1
-#define NDEF_MODE_READ_WRITE             2
-#define NDEF_MODE_UNKNOWN                3
-
-#if(NXP_EXTNS == TRUE)
-#define VEN_POWER_STATE_ON                   9
-#define VEN_POWER_STATE_OFF                  10
+#define NDEF_MODE_READ_ONLY 1
+#define NDEF_MODE_READ_WRITE 2
+#define NDEF_MODE_UNKNOWN 3
+
+#if (NXP_EXTNS == TRUE)
+#define VEN_POWER_STATE_ON 9
+#define VEN_POWER_STATE_OFF 10
+#define NFC_FORUM_POLL 0
+#define EMVCO_POLL_MODE 1
+#define SETCONFIGLENPOS 3
+#define PROPSETCONFIGMINLEN 4
 // ESE Suppored Technologies
-#define TARGET_TYPE_ISO14443_3A_3B        11
+#define TARGET_TYPE_ISO14443_3A_3B 11
 #endif
-/* Name strings for target types. These *must* match the values in TagTechnology.java */
-#define TARGET_TYPE_UNKNOWN               (-1)
-#define TARGET_TYPE_ISO14443_3A           1
-#define TARGET_TYPE_ISO14443_3B           2
-#define TARGET_TYPE_ISO14443_4            3
-#define TARGET_TYPE_FELICA                4
-#define TARGET_TYPE_ISO15693              5
-#define TARGET_TYPE_NDEF                  6
-#define TARGET_TYPE_NDEF_FORMATABLE       7
-#define TARGET_TYPE_MIFARE_CLASSIC        8
-#define TARGET_TYPE_MIFARE_UL             9
-#define TARGET_TYPE_KOVIO_BARCODE         10
-#define TARGET_TYPE_ISO14443_4A           11
-#define TARGET_TYPE_ISO14443_4B           12
+/* Name strings for target types. These *must* match the values in
+ * TagTechnology.java */
+#define TARGET_TYPE_UNKNOWN (-1)
+#define TARGET_TYPE_ISO14443_3A 1
+#define TARGET_TYPE_ISO14443_3B 2
+#define TARGET_TYPE_ISO14443_4 3
+#define TARGET_TYPE_FELICA 4
+#define TARGET_TYPE_V 5
+#define TARGET_TYPE_NDEF 6
+#define TARGET_TYPE_NDEF_FORMATABLE 7
+#define TARGET_TYPE_MIFARE_CLASSIC 8
+#define TARGET_TYPE_MIFARE_UL 9
+#define TARGET_TYPE_KOVIO_BARCODE 10
+#define TARGET_TYPE_ISO14443_4A 11
+#define TARGET_TYPE_ISO14443_4B 12
 
 /* Setting VEN_CFG  */
-#define NFC_MODE_ON           3
-#define NFC_MODE_OFF          2
+#define NFC_MODE_ON 3
+#define NFC_MODE_OFF 2
 
-//define a few NXP error codes that NFC service expects;
-//see external/libnfc-nxp/src/phLibNfcStatus.h;
-//see external/libnfc-nxp/inc/phNfcStatus.h
+// define a few NXP error codes that NFC service expects;
+// see external/libnfc-nxp/src/phLibNfcStatus.h;
+// see external/libnfc-nxp/inc/phNfcStatus.h
 #define NFCSTATUS_SUCCESS (0x0000)
 #define NFCSTATUS_FAILED (0x00FF)
-#if(NXP_EXTNS == TRUE)
+#if (NXP_EXTNS == TRUE)
 /*NFCEE recovery maximum timeout value*/
-#define MAX_EE_RECOVERY_TIMEOUT    10000
-/* NFC states: Primarily used to decide SPI signal handling (whether to discard or accept)*/
-typedef enum eNfcState
-{
-    NFC_OFF = 0x00, /* Default state */
-    NFC_INITIALIZING_IN_PROGRESS = 0x01, /* Initializing not complete (RF discovery not enabled yet) */
-    NFC_ON = 0x02 /* NFC is fully ON*/
-};
-#define NFC_CMD_TIMEOUT 100 /* 100ms timeout to wait on the semaphore for the command sent */
+#define MAX_EE_RECOVERY_TIMEOUT 10000
+/* NFC states: Primarily used to decide SPI signal handling (whether to discard
+ * or accept)*/
+typedef enum {
+  NFC_OFF = 0x00, /* Default state */
+  NFC_INITIALIZING_IN_PROGRESS =
+      0x01,     /* Initializing not complete (RF discovery not enabled yet) */
+  NFC_ON = 0x02 /* NFC is fully ON*/
+} eNfcState;
+#define NFC_CMD_TIMEOUT \
+  2000 /* 2 sec timeout to wait on the semaphore for the command sent */
+#define ONE_SECOND_MS 1000
+#define DWP_LINK_ACTV_TIMEOUT 4000
 #endif
 
-struct nfc_jni_native_data
-{
-   /* Thread handle */
-   pthread_t thread;
-   int running;
+struct nfc_jni_native_data {
+  /* Thread handle */
+  pthread_t thread;
+  int running;
 
-   /* Our VM */
-   JavaVM *vm;
-   int env_version;
+  /* Our VM */
+  JavaVM* vm;
+  int env_version;
 
-   /* Reference to the NFCManager instance */
-   jobject manager;
+  /* Reference to the NFCManager instance */
+  jobject manager;
 
-   /* Cached objects */
-   jobject cached_NfcTag;
-   jobject cached_P2pDevice;
+  /* Cached objects */
+  jobject cached_NfcTag;
+  jobject cached_P2pDevice;
 
-   /* Secure Element selected */
-   int seId;
+  /* Secure Element selected */
+  int seId;
 
-   /* LLCP params */
-   int lto;
-   int miu;
-   int wks;
-   int opt;
+  /* LLCP params */
+  int lto;
+  int miu;
+  int wks;
+  int opt;
 
-   int tech_mask;
-   int discovery_duration;
+  int tech_mask;
+  int discovery_duration;
 
-   /* Tag detected */
-   jobject tag;
+  /* Tag detected */
+  jobject tag;
 
-   int tHandle;
-   int tProtocols[16];
-   int handles[16];
+  int tHandle;
+  int tProtocols[16];
+  int handles[16];
 };
 
+class ScopedAttach {
+ public:
+  ScopedAttach(JavaVM* vm, JNIEnv** env) : vm_(vm) {
+    vm_->AttachCurrentThread(env, NULL);
+  }
 
-class ScopedAttach
-{
-public:
-    ScopedAttach(JavaVM* vm, JNIEnv** env) : vm_(vm)
-    {
-        vm_->AttachCurrentThread(env, NULL);
-    }
-
-    ~ScopedAttach()
-    {
-        vm_->DetachCurrentThread();
-    }
+  ~ScopedAttach() { vm_->DetachCurrentThread(); }
 
-private:
-        JavaVM* vm_;
+ private:
+  JavaVM* vm_;
 };
 
-
-extern "C"
-{
-    jint JNI_OnLoad(JavaVM *jvm, void *reserved);
-}
-
-
-namespace android
-{
-    int nfc_jni_cache_object (JNIEnv *e, const char *clsname, jobject *cached_obj);
-    int nfc_jni_cache_object_local (JNIEnv *e, const char *className, jobject *cachedObj);
-    int nfc_jni_get_nfc_socket_handle (JNIEnv *e, jobject o);
-    struct nfc_jni_native_data* nfc_jni_get_nat (JNIEnv *e, jobject o);
-    int register_com_android_nfc_NativeNfcManager (JNIEnv *e);
-    int register_com_android_nfc_NativeNfcTag (JNIEnv *e);
-    int register_com_android_nfc_NativeP2pDevice (JNIEnv *e);
-    int register_com_android_nfc_NativeLlcpConnectionlessSocket (JNIEnv *e);
-    int register_com_android_nfc_NativeLlcpServiceSocket (JNIEnv *e);
-    int register_com_android_nfc_NativeLlcpSocket (JNIEnv *e);
-    int register_com_android_nfc_NativeNfcSecureElement (JNIEnv *e);
-    int register_com_android_nfc_NativeNfcAla(JNIEnv *e);
-} // namespace android
+jint JNI_OnLoad(JavaVM* jvm, void* reserved);
+
+namespace android {
+int nfc_jni_cache_object(JNIEnv* e, const char* clsname, jobject* cached_obj);
+int nfc_jni_cache_object_local(JNIEnv* e, const char* className,
+                               jobject* cachedObj);
+int nfc_jni_get_nfc_socket_handle(JNIEnv* e, jobject o);
+struct nfc_jni_native_data* nfc_jni_get_nat(JNIEnv* e, jobject o);
+int register_com_android_nfc_NativeNfcManager(JNIEnv* e);
+int register_com_android_nfc_NativeNfcTag(JNIEnv* e);
+int register_com_android_nfc_NativeP2pDevice(JNIEnv* e);
+int register_com_android_nfc_NativeLlcpConnectionlessSocket(JNIEnv* e);
+int register_com_android_nfc_NativeLlcpServiceSocket(JNIEnv* e);
+int register_com_android_nfc_NativeLlcpSocket(JNIEnv* e);
+int register_com_android_nfc_NativeNfcSecureElement(JNIEnv* e);
+int register_com_android_nfc_NativeNfcAla(JNIEnv* e);
+#if (NXP_EXTNS == TRUE)
+int register_com_android_nfc_NativeNfcMposManager(JNIEnv* e);
+#endif
+}  // namespace android
diff --git a/nci/jni/NfcTag.cpp b/nci/jni/NfcTag.cpp
index c6e54aa8..178a03fe 100644
--- a/nci/jni/NfcTag.cpp
+++ b/nci/jni/NfcTag.cpp
@@ -2,7 +2,7 @@
  * Copyright (c) 2016, The Linux Foundation. All rights reserved.
  * Not a Contribution.
  *
- * Copyright (C) 2015 NXP Semiconductors
+ * Copyright (C) 2015-2018 NXP Semiconductors
  * The original Work has been changed by NXP Semiconductors.
  *
  * Copyright (C) 2012 The Android Open Source Project
@@ -22,20 +22,23 @@
 /*
  *  Tag-reading, tag-writing operations.
  */
-#include "_OverrideLog.h"
 #include "NfcTag.h"
-#include "JavaClassConstants.h"
-#include "config.h"
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
 #include <nativehelper/ScopedLocalRef.h>
 #include <nativehelper/ScopedPrimitiveArray.h>
 #include "IntervalTimer.h"
-extern "C"
-{
-    #include "rw_int.h"
-    #include "nfc_brcm_defs.h"
-    #include "phNxpExtns.h"
-}
-#if(NXP_EXTNS == TRUE)
+#include "JavaClassConstants.h"
+#include "nfc_config.h"
+#include "nfc_brcm_defs.h"
+#include "phNxpExtns.h"
+#include "rw_int.h"
+
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+
+#if (NXP_EXTNS == TRUE)
 static void deleteglobaldata(JNIEnv* e);
 static void selectCompleteCallBack(union sigval);
 static jobjectArray techActBytes1;
@@ -52,40 +55,38 @@ IntervalTimer gSelectCompleteTimer;
 ** Returns:         None
 **
 *******************************************************************************/
-NfcTag::NfcTag ()
-:   mNumTechList (0),
-    mNumDiscNtf (0),
-    mNumDiscTechList (0),
-    mTechListIndex (0),
-    mCashbeeDetected(false),
-    mEzLinkTypeTag(false),
-#if(NXP_EXTNS == TRUE)
-    mWaitingForSelect(false),
-    mIsMultiProtocolTag(false),
+NfcTag::NfcTag()
+    : mNumTechList(0),
+      mNumDiscNtf(0),
+      mNumDiscTechList(0),
+      mTechListIndex(0),
+      mCashbeeDetected(false),
+      mEzLinkTypeTag(false),
+#if (NXP_EXTNS == TRUE)
+      mWaitingForSelect(false),
+      mIsMultiProtocolTag(false),
 #endif
-    mTechnologyTimeoutsTable (MAX_NUM_TECHNOLOGY),
-    mNativeData (NULL),
-    mIsActivated (false),
-    mActivationState (Idle),
-    mProtocol(NFC_PROTOCOL_UNKNOWN),
-    mtT1tMaxMessageSize (0),
-    mReadCompletedStatus (NFA_STATUS_OK),
-    mLastKovioUidLen (0),
-    mNdefDetectionTimedOut (false),
-    mIsDynamicTagId (false),
-    mIsFelicaLite(false),
-    mPresenceCheckAlgorithm (NFA_RW_PRES_CHK_DEFAULT)
-{
-    memset (mTechList, 0, sizeof(mTechList));
-    memset (mTechHandles, 0, sizeof(mTechHandles));
-    memset (mTechLibNfcTypes, 0, sizeof(mTechLibNfcTypes));
-    memset (mTechParams, 0, sizeof(mTechParams));
-    memset(mLastKovioUid, 0, NFC_KOVIO_MAX_LEN);
-    memset(&mLastKovioTime, 0, sizeof(mLastKovioTime));
-    memset(&mActivationParams_t, 0, sizeof(activationParams_t));
+      mTechnologyTimeoutsTable(MAX_NUM_TECHNOLOGY),
+      mNativeData(NULL),
+      mIsActivated(false),
+      mActivationState(Idle),
+      mProtocol(NFC_PROTOCOL_UNKNOWN),
+      mtT1tMaxMessageSize(0),
+      mReadCompletedStatus(NFA_STATUS_OK),
+      mLastKovioUidLen(0),
+      mNdefDetectionTimedOut(false),
+      mIsDynamicTagId(false),
+      mIsFelicaLite(false),
+      mPresenceCheckAlgorithm(NFA_RW_PRES_CHK_DEFAULT) {
+  memset(mTechList, 0, sizeof(mTechList));
+  memset(mTechHandles, 0, sizeof(mTechHandles));
+  memset(mTechLibNfcTypes, 0, sizeof(mTechLibNfcTypes));
+  memset(mTechParams, 0, sizeof(mTechParams));
+  memset(mLastKovioUid, 0, NFC_KOVIO_MAX_LEN);
+  memset(&mLastKovioTime, 0, sizeof(mLastKovioTime));
+  memset(&mActivationParams_t, 0, sizeof(activationParams_t));
 }
 
-
 /*******************************************************************************
 **
 ** Function:        getInstance
@@ -95,13 +96,11 @@ NfcTag::NfcTag ()
 ** Returns:         Reference to NfcTag object.
 **
 *******************************************************************************/
-NfcTag& NfcTag::getInstance ()
-{
-    static NfcTag tag;
-    return tag;
+NfcTag& NfcTag::getInstance() {
+  static NfcTag tag;
+  return tag;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        initialize
@@ -112,27 +111,25 @@ NfcTag& NfcTag::getInstance ()
 ** Returns:         None
 **
 *******************************************************************************/
-void NfcTag::initialize (nfc_jni_native_data* native)
-{
-    long num = 0;
-
-    mNativeData = native;
-    mIsActivated = false;
-    mActivationState = Idle;
-    mProtocol = NFC_PROTOCOL_UNKNOWN;
-    mNumTechList = 0;
-    mNumDiscNtf = 0;
-    mNumDiscTechList = 0;
-    mTechListIndex = 0;
-    mtT1tMaxMessageSize = 0;
-    mReadCompletedStatus = NFA_STATUS_OK;
-    mNfcDisableinProgress = false;
-    resetTechnologies ();
-    if (GetNumValue(NAME_PRESENCE_CHECK_ALGORITHM, &num, sizeof(num)))
-        mPresenceCheckAlgorithm = num;
+void NfcTag::initialize(nfc_jni_native_data* native) {
+
+  mNativeData = native;
+  mIsActivated = false;
+  mActivationState = Idle;
+  mProtocol = NFC_PROTOCOL_UNKNOWN;
+  mNumTechList = 0;
+  mNumDiscNtf = 0;
+  mNumDiscTechList = 0;
+  mTechListIndex = 0;
+  mtT1tMaxMessageSize = 0;
+  mReadCompletedStatus = NFA_STATUS_OK;
+  mNfcDisableinProgress = false;
+  resetTechnologies();
+  if (NfcConfig::hasKey(NAME_PRESENCE_CHECK_ALGORITHM))
+    mPresenceCheckAlgorithm =
+        NfcConfig::getUnsigned(NAME_PRESENCE_CHECK_ALGORITHM);
 }
 
-
 /*******************************************************************************
 **
 ** Function:        abort
@@ -142,13 +139,11 @@ void NfcTag::initialize (nfc_jni_native_data* native)
 ** Returns:         None
 **
 *******************************************************************************/
-void NfcTag::abort ()
-{
-    SyncEventGuard g (mReadCompleteEvent);
-    mReadCompleteEvent.notifyOne ();
+void NfcTag::abort() {
+  SyncEventGuard g(mReadCompleteEvent);
+  mReadCompleteEvent.notifyOne();
 }
 
-
 /*******************************************************************************
 **
 ** Function:        getActivationState
@@ -158,12 +153,10 @@ void NfcTag::abort ()
 ** Returns:         Idle, Sleep, or Activated.
 **
 *******************************************************************************/
-NfcTag::ActivationState NfcTag::getActivationState ()
-{
-    return mActivationState;
+NfcTag::ActivationState NfcTag::getActivationState() {
+  return mActivationState;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        setDeactivationState
@@ -174,17 +167,15 @@ NfcTag::ActivationState NfcTag::getActivationState ()
 ** Returns:         None.
 **
 *******************************************************************************/
-void NfcTag::setDeactivationState (tNFA_DEACTIVATED& deactivated)
-{
-    static const char fn [] = "NfcTag::setDeactivationState";
-    mActivationState = Idle;
-    mNdefDetectionTimedOut = false;
-    if (deactivated.type == NFA_DEACTIVATE_TYPE_SLEEP)
-        mActivationState = Sleep;
-    ALOGV("%s: state=%u", fn, mActivationState);
+void NfcTag::setDeactivationState(tNFA_DEACTIVATED& deactivated) {
+  static const char fn[] = "NfcTag::setDeactivationState";
+  mActivationState = Idle;
+  mNdefDetectionTimedOut = false;
+  if (deactivated.type == NFA_DEACTIVATE_TYPE_SLEEP) mActivationState = Sleep;
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: state=%u", fn, mActivationState);
 }
 
-
 /*******************************************************************************
 **
 ** Function:        setActivationState
@@ -194,12 +185,12 @@ void NfcTag::setDeactivationState (tNFA_DEACTIVATED& deactivated)
 ** Returns:         None.
 **
 *******************************************************************************/
-void NfcTag::setActivationState ()
-{
-    static const char fn [] = "NfcTag::setActivationState";
-    mNdefDetectionTimedOut = false;
-    mActivationState = Active;
-    ALOGV("%s: state=%u", fn, mActivationState);
+void NfcTag::setActivationState() {
+  static const char fn[] = "NfcTag::setActivationState";
+  mNdefDetectionTimedOut = false;
+  mActivationState = Active;
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: state=%u", fn, mActivationState);
 }
 
 /*******************************************************************************
@@ -211,11 +202,7 @@ void NfcTag::setActivationState ()
 ** Returns:         True if tag is activated.
 **
 *******************************************************************************/
-bool NfcTag::isActivated ()
-{
-    return mIsActivated;
-}
-
+bool NfcTag::isActivated() { return mIsActivated; }
 
 /*******************************************************************************
 **
@@ -226,10 +213,7 @@ bool NfcTag::isActivated ()
 ** Returns:         Protocol number.
 **
 *******************************************************************************/
-tNFC_PROTOCOL NfcTag::getProtocol()
-{
-    return mProtocol;
-}
+tNFC_PROTOCOL NfcTag::getProtocol() { return mProtocol; }
 
 /*******************************************************************************
 **
@@ -240,28 +224,25 @@ tNFC_PROTOCOL NfcTag::getProtocol()
 ** Returns          Time difference in milliseconds
 **
 *******************************************************************************/
-uint32_t TimeDiff(timespec start, timespec end)
-{
-    timespec temp;
-    if ((end.tv_nsec-start.tv_nsec)<0)
-    {
-        temp.tv_sec = end.tv_sec-start.tv_sec-1;
-        temp.tv_nsec = 1000000000+end.tv_nsec-start.tv_nsec;
-    }
-    else
-    {
-        temp.tv_sec = end.tv_sec-start.tv_sec;
-        temp.tv_nsec = end.tv_nsec-start.tv_nsec;
-    }
-
-    return (temp.tv_sec * 1000) + (temp.tv_nsec / 1000000);
+uint32_t TimeDiff(timespec start, timespec end) {
+  timespec temp;
+  if ((end.tv_nsec - start.tv_nsec) < 0) {
+    temp.tv_sec = end.tv_sec - start.tv_sec - 1;
+    temp.tv_nsec = 1000000000 + end.tv_nsec - start.tv_nsec;
+  } else {
+    temp.tv_sec = end.tv_sec - start.tv_sec;
+    temp.tv_nsec = end.tv_nsec - start.tv_nsec;
+  }
+
+  return (temp.tv_sec * 1000) + (temp.tv_nsec / 1000000);
 }
 
 /*******************************************************************************
 **
 ** Function:        IsSameKovio
 **
-** Description:     Checks if tag activate is the same (UID) Kovio tag previously
+** Description:     Checks if tag activate is the same (UID) Kovio tag
+*previously
 **                  activated.  This is needed due to a problem with some Kovio
 **                  tags re-activating multiple times.
 **                  activationData: data from activation.
@@ -270,386 +251,405 @@ uint32_t TimeDiff(timespec start, timespec end)
 **                  activated, false otherwise
 **
 *******************************************************************************/
-bool NfcTag::IsSameKovio(tNFA_ACTIVATED& activationData)
-{
-    static const char fn [] = "NfcTag::IsSameKovio";
-    ALOGV("%s: enter", fn);
-    tNFC_ACTIVATE_DEVT& rfDetail = activationData.activate_ntf;
-
-    if (rfDetail.protocol != NFC_PROTOCOL_KOVIO)
-        return false;
-
-    memcpy (&(mTechParams[0]), &(rfDetail.rf_tech_param), sizeof(rfDetail.rf_tech_param));
-    if (mTechParams [0].mode != NFC_DISCOVERY_TYPE_POLL_KOVIO)
-        return false;
-
-    struct timespec now;
-    clock_gettime(CLOCK_REALTIME, &now);
-
-    bool rVal = false;
-    if (mTechParams[0].param.pk.uid_len == mLastKovioUidLen)
-    {
-        if (memcmp(mLastKovioUid, &mTechParams [0].param.pk.uid, mTechParams[0].param.pk.uid_len) == 0)
-        {
-            //same tag
-            if (TimeDiff(mLastKovioTime, now) < 500)
-            {
-                // same tag within 500 ms, ignore activation
-                rVal = true;
-            }
-        }
-    }
-
-    // save Kovio tag info
-    if (!rVal)
-    {
-        if ((mLastKovioUidLen = mTechParams[0].param.pk.uid_len) > NFC_KOVIO_MAX_LEN)
-            mLastKovioUidLen = NFC_KOVIO_MAX_LEN;
-        memcpy(mLastKovioUid, mTechParams[0].param.pk.uid, mLastKovioUidLen);
-    }
-    mLastKovioTime = now;
-    ALOGV("%s: exit, is same Kovio=%d", fn, rVal);
-    return rVal;
+bool NfcTag::IsSameKovio(tNFA_ACTIVATED& activationData) {
+  static const char fn[] = "NfcTag::IsSameKovio";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+  tNFC_ACTIVATE_DEVT& rfDetail = activationData.activate_ntf;
+
+  if (rfDetail.protocol != NFC_PROTOCOL_KOVIO) return false;
+
+  memcpy(&(mTechParams[0]), &(rfDetail.rf_tech_param),
+         sizeof(rfDetail.rf_tech_param));
+  if (mTechParams[0].mode != NFC_DISCOVERY_TYPE_POLL_KOVIO) return false;
+
+  struct timespec now;
+  clock_gettime(CLOCK_REALTIME, &now);
+
+  bool rVal = false;
+  if (mTechParams[0].param.pk.uid_len == mLastKovioUidLen) {
+    if (memcmp(mLastKovioUid, &mTechParams[0].param.pk.uid,
+               mTechParams[0].param.pk.uid_len) == 0) {
+      // same tag
+      if (TimeDiff(mLastKovioTime, now) < 500) {
+        // same tag within 500 ms, ignore activation
+        rVal = true;
+      }
+    }
+  }
+
+  // save Kovio tag info
+  if (!rVal) {
+    if ((mLastKovioUidLen = mTechParams[0].param.pk.uid_len) >
+        NFC_KOVIO_MAX_LEN)
+      mLastKovioUidLen = NFC_KOVIO_MAX_LEN;
+    memcpy(mLastKovioUid, mTechParams[0].param.pk.uid, mLastKovioUidLen);
+  }
+  mLastKovioTime = now;
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit, is same Kovio=%d", fn, rVal);
+  return rVal;
 }
 
 /*******************************************************************************
 **
 ** Function:        discoverTechnologies
 **
-** Description:     Discover the technologies that NFC service needs by interpreting
+** Description:     Discover the technologies that NFC service needs by
+*interpreting
 **                  the data structures from the stack.
 **                  activationData: data from activation.
 **
 ** Returns:         None
 **
 *******************************************************************************/
-void NfcTag::discoverTechnologies (tNFA_ACTIVATED& activationData)
-{
-    static const char fn [] = "NfcTag::discoverTechnologies (activation)";
-    ALOGV("%s: enter", fn);
-    tNFC_ACTIVATE_DEVT& rfDetail = activationData.activate_ntf;
-
-    mNumTechList = mTechListIndex;
-    ALOGV("mNumTechList =%d, mTechListIndex=%d", mNumTechList, mTechListIndex);
-#if(NXP_EXTNS == TRUE)
-    if (mNumTechList >= MAX_NUM_TECHNOLOGY)
-    {
-        ALOGE("%s: exceed max=%d", fn, MAX_NUM_TECHNOLOGY);
-        goto TheEnd;
-    }
+void NfcTag::discoverTechnologies(tNFA_ACTIVATED& activationData) {
+  static const char fn[] = "NfcTag::discoverTechnologies (activation)";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+  tNFC_ACTIVATE_DEVT& rfDetail = activationData.activate_ntf;
+
+  mNumTechList = mTechListIndex;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "mNumTechList =%d, mTechListIndex=%d", mNumTechList, mTechListIndex);
+#if (NXP_EXTNS == TRUE)
+  if (mNumTechList >= MAX_NUM_TECHNOLOGY) {
+    LOG(ERROR) << StringPrintf("%s: exceed max=%d", fn, MAX_NUM_TECHNOLOGY);
+    goto TheEnd;
+  }
 #endif
-    mTechHandles [mNumTechList] = rfDetail.rf_disc_id;
-    mTechLibNfcTypes [mNumTechList] = rfDetail.protocol;
-
-    //save the stack's data structure for interpretation later
-    memcpy (&(mTechParams[mNumTechList]), &(rfDetail.rf_tech_param), sizeof(rfDetail.rf_tech_param));
-
-    if(NFC_PROTOCOL_T1T == rfDetail.protocol)
-    {
-        mTechList [mNumTechList] = TARGET_TYPE_ISO14443_3A; //is TagTechnology.NFC_A by Java API
-    }
-    else if(NFC_PROTOCOL_T2T == rfDetail.protocol)
-    {
-        mTechList [mNumTechList] = TARGET_TYPE_ISO14443_3A;  //is TagTechnology.NFC_A by Java API
-        // could be MifFare UL or Classic or Kovio
-        {
-            // need to look at first byte of uid to find Manufacture Byte
-            tNFC_RF_TECH_PARAMS tech_params;
-            memcpy (&tech_params, &(rfDetail.rf_tech_param), sizeof(rfDetail.rf_tech_param));
-
-            if ((tech_params.param.pa.nfcid1[0] == 0x04 && rfDetail.rf_tech_param.param.pa.sel_rsp == 0) ||
-                rfDetail.rf_tech_param.param.pa.sel_rsp == 0x18 ||
-                rfDetail.rf_tech_param.param.pa.sel_rsp == 0x08 ||
-                rfDetail.rf_tech_param.param.pa.sel_rsp == 0x01)
-            {
-#if(NXP_EXTNS == TRUE)
-                if ((rfDetail.rf_tech_param.param.pa.sel_rsp == 0) &&
-                     (mNumTechList < (MAX_NUM_TECHNOLOGY-1)))
+  mTechHandles[mNumTechList] = rfDetail.rf_disc_id;
+  mTechLibNfcTypes[mNumTechList] = rfDetail.protocol;
+
+  // save the stack's data structure for interpretation later
+  memcpy(&(mTechParams[mNumTechList]), &(rfDetail.rf_tech_param),
+         sizeof(rfDetail.rf_tech_param));
+
+  if (NFC_PROTOCOL_T1T == rfDetail.protocol) {
+    mTechList[mNumTechList] =
+        TARGET_TYPE_ISO14443_3A;  // is TagTechnology.NFC_A by Java API
+  } else if (NFC_PROTOCOL_T2T == rfDetail.protocol) {
+    mTechList[mNumTechList] =
+        TARGET_TYPE_ISO14443_3A;  // is TagTechnology.NFC_A by Java API
+    // could be MifFare UL or Classic or Kovio
+    {
+      // need to look at first byte of uid to find Manufacture Byte
+      tNFC_RF_TECH_PARAMS tech_params;
+      memcpy(&tech_params, &(rfDetail.rf_tech_param),
+             sizeof(rfDetail.rf_tech_param));
+
+      if ((tech_params.param.pa.nfcid1[0] == 0x04 &&
+           rfDetail.rf_tech_param.param.pa.sel_rsp == 0) ||
+          rfDetail.rf_tech_param.param.pa.sel_rsp == 0x18 ||
+          rfDetail.rf_tech_param.param.pa.sel_rsp == 0x08 ||
+          rfDetail.rf_tech_param.param.pa.sel_rsp == 0x01) {
+#if (NXP_EXTNS == TRUE)
+        if ((rfDetail.rf_tech_param.param.pa.sel_rsp == 0) &&
+            (mNumTechList < (MAX_NUM_TECHNOLOGY - 1)))
 #else
-                if (rfDetail.rf_tech_param.param.pa.sel_rsp == 0)
+        if (rfDetail.rf_tech_param.param.pa.sel_rsp == 0)
 #endif
-                {
-                    mNumTechList++;
-                    mTechHandles [mNumTechList] = rfDetail.rf_disc_id;
-                    mTechLibNfcTypes [mNumTechList] = rfDetail.protocol;
-                    //save the stack's data structure for interpretation later
-                    memcpy (&(mTechParams[mNumTechList]), &(rfDetail.rf_tech_param), sizeof(rfDetail.rf_tech_param));
-                    mTechList [mNumTechList] = TARGET_TYPE_MIFARE_UL; //is TagTechnology.MIFARE_ULTRALIGHT by Java API
-                }
-#if(NXP_EXTNS == TRUE)
-                              //To support skylander tag.
-                else if (rfDetail.rf_tech_param.param.pa.sel_rsp == 0x01)
-                {
-                    mTechLibNfcTypes [mNumTechList] = NFC_PROTOCOL_MIFARE;
-                    rfDetail.rf_tech_param.param.pa.sel_rsp = 0x08;
-                    memcpy (&tech_params, &(rfDetail.rf_tech_param), sizeof(rfDetail.rf_tech_param));
-                    if(mNumTechList < (MAX_NUM_TECHNOLOGY-1))
-                    {
-                        mNumTechList++;
-                        mTechHandles [mNumTechList] = rfDetail.rf_disc_id;
-                        mTechLibNfcTypes [mNumTechList] = NFC_PROTOCOL_MIFARE;
-                        //save the stack's data structure for interpretation later
-                        memcpy (&(mTechParams[mNumTechList]), &(rfDetail.rf_tech_param), sizeof(rfDetail.rf_tech_param));
-                        mTechList [mNumTechList] = TARGET_TYPE_MIFARE_CLASSIC; //is TagTechnology.MIFARE_CLASSIC by Java API
-                    }
-                    EXTNS_MfcInit(activationData);
-                }
-#endif
-            }
-        }
-    }
-    else if(NFC_PROTOCOL_T3BT == rfDetail.protocol)
-    {
-        mTechHandles [mNumTechList] = rfDetail.rf_disc_id;
-        mTechLibNfcTypes [mNumTechList] = rfDetail.protocol;
-        mTechList [mNumTechList] = TARGET_TYPE_ISO14443_3B; //is TagTechnology.NFC_B by Java API
-        //save the stack's data structure for interpretation later
-        memcpy (&(mTechParams[mNumTechList]), &(rfDetail.rf_tech_param), sizeof(rfDetail.rf_tech_param));
-    }
-    else if(NFC_PROTOCOL_T3T == rfDetail.protocol)
-    {
-        uint8_t xx = 0;
-
-        mTechList [mNumTechList] = TARGET_TYPE_FELICA;
-
-        //see if it is Felica Lite.
-        while (xx < activationData.params.t3t.num_system_codes)
         {
-            if (activationData.params.t3t.p_system_codes[xx++] == T3T_SYSTEM_CODE_FELICA_LITE)
-            {
-                mIsFelicaLite = true;
-                break;
-            }
+          mNumTechList++;
+          mTechHandles[mNumTechList] = rfDetail.rf_disc_id;
+          mTechLibNfcTypes[mNumTechList] = rfDetail.protocol;
+          // save the stack's data structure for interpretation later
+          memcpy(&(mTechParams[mNumTechList]), &(rfDetail.rf_tech_param),
+                 sizeof(rfDetail.rf_tech_param));
+          mTechList[mNumTechList] =
+              TARGET_TYPE_MIFARE_UL;  // is TagTechnology.MIFARE_ULTRALIGHT by
+                                      // Java API
         }
-    }
-    else if(NFC_PROTOCOL_ISO_DEP == rfDetail.protocol)
-    {
-        //type-4 tag uses technology ISO-DEP and technology A or B
-        mTechList [mNumTechList] = TARGET_TYPE_ISO14443_4; //is TagTechnology.ISO_DEP by Java API
-#if(NXP_EXTNS == TRUE)
-        if ( ( (rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_POLL_A) ||
-            (rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_POLL_A_ACTIVE) ||
-            (rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_LISTEN_A) ||
-            (rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_LISTEN_A_ACTIVE) ) && mNumTechList < (MAX_NUM_TECHNOLOGY-1))
-#else
-        if ( (rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_POLL_A) ||
-                (rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_POLL_A_ACTIVE) ||
-                (rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_LISTEN_A) ||
-                (rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_LISTEN_A_ACTIVE))
-#endif
-        {
+#if (NXP_EXTNS == TRUE)
+        // To support skylander tag.
+        else if (rfDetail.rf_tech_param.param.pa.sel_rsp == 0x01) {
+          mTechLibNfcTypes[mNumTechList] = NFC_PROTOCOL_MIFARE;
+          rfDetail.rf_tech_param.param.pa.sel_rsp = 0x08;
+          memcpy(&tech_params, &(rfDetail.rf_tech_param),
+                 sizeof(rfDetail.rf_tech_param));
+          if (mNumTechList < (MAX_NUM_TECHNOLOGY - 1)) {
             mNumTechList++;
-            mTechHandles [mNumTechList] = rfDetail.rf_disc_id;
-            mTechLibNfcTypes [mNumTechList] = rfDetail.protocol;
-            mTechList [mNumTechList] = TARGET_TYPE_ISO14443_3A; //is TagTechnology.NFC_A by Java API
-            //save the stack's data structure for interpretation later
-            memcpy (&(mTechParams[mNumTechList]), &(rfDetail.rf_tech_param), sizeof(rfDetail.rf_tech_param));
+            mTechHandles[mNumTechList] = rfDetail.rf_disc_id;
+            mTechLibNfcTypes[mNumTechList] = NFC_PROTOCOL_MIFARE;
+            // save the stack's data structure for interpretation later
+            memcpy(&(mTechParams[mNumTechList]), &(rfDetail.rf_tech_param),
+                   sizeof(rfDetail.rf_tech_param));
+            mTechList[mNumTechList] =
+                TARGET_TYPE_MIFARE_CLASSIC;  // is TagTechnology.MIFARE_CLASSIC
+                                             // by Java API
+          }
+          EXTNS_MfcInit(activationData);
         }
-#if(NXP_EXTNS == TRUE)
-        else if ( ((rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_POLL_B) ||
-                (rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_POLL_B_PRIME) ||
-                (rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_LISTEN_B) ||
-                (rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_LISTEN_B_PRIME) ) && mNumTechList < (MAX_NUM_TECHNOLOGY-1))
+#endif
+      }
+    }
+  } else if (NFC_PROTOCOL_T3BT == rfDetail.protocol) {
+    mTechHandles[mNumTechList] = rfDetail.rf_disc_id;
+    mTechLibNfcTypes[mNumTechList] = rfDetail.protocol;
+    mTechList[mNumTechList] =
+        TARGET_TYPE_ISO14443_3B;  // is TagTechnology.NFC_B by Java API
+    // save the stack's data structure for interpretation later
+    memcpy(&(mTechParams[mNumTechList]), &(rfDetail.rf_tech_param),
+           sizeof(rfDetail.rf_tech_param));
+  } else if (NFC_PROTOCOL_T3T == rfDetail.protocol) {
+    uint8_t xx = 0;
+
+    mTechList[mNumTechList] = TARGET_TYPE_FELICA;
+
+    // see if it is Felica Lite.
+    while (xx < activationData.params.t3t.num_system_codes) {
+      if (activationData.params.t3t.p_system_codes[xx++] ==
+          T3T_SYSTEM_CODE_FELICA_LITE) {
+        mIsFelicaLite = true;
+        break;
+      }
+    }
+  } else if (NFC_PROTOCOL_ISO_DEP == rfDetail.protocol) {
+    if ((rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_POLL_A) ||
+        (rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_POLL_A_ACTIVE)) {
+      double fc = 13560000;
+      uint8_t fwi = rfDetail.intf_param.intf_param.pa_iso.fwi;
+      if (fwi >= MIN_FWI && fwi <= MAX_FWI) {
+        double fwt = (((1 << fwi) * 256 * 16) / fc) * 1000;
+        if (fwt < MIN_TRANSCEIVE_TIMEOUT_IN_MILLISEC)
+          fwt = MIN_TRANSCEIVE_TIMEOUT_IN_MILLISEC;
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "Setting the Xceive timeout = %f, fwi = %0#x", fwt, fwi);
+        setTransceiveTimeout(mTechList[mNumTechList], 3*fwt);
+      }
+    }
+    // type-4 tag uses technology ISO-DEP and technology A or B
+    mTechList[mNumTechList] =
+        TARGET_TYPE_ISO14443_4;  // is TagTechnology.ISO_DEP by Java API
+#if (NXP_EXTNS == TRUE)
+    if (((rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_POLL_A) ||
+         (rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_POLL_A_ACTIVE) ||
+         (rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_LISTEN_A) ||
+         (rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_LISTEN_A_ACTIVE)) &&
+        mNumTechList < (MAX_NUM_TECHNOLOGY - 1))
 #else
-        else if ((rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_POLL_B) ||
-                (rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_POLL_B_PRIME) ||
-                (rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_LISTEN_B) ||
-                (rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_LISTEN_B_PRIME))
+    if ((rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_POLL_A) ||
+        (rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_POLL_A_ACTIVE) ||
+        (rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_LISTEN_A) ||
+        (rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_LISTEN_A_ACTIVE))
 #endif
-        {
-            mNumTechList++;
-            mTechHandles [mNumTechList] = rfDetail.rf_disc_id;
-            mTechLibNfcTypes [mNumTechList] = rfDetail.protocol;
-            mTechList [mNumTechList] = TARGET_TYPE_ISO14443_3B; //is TagTechnology.NFC_B by Java API
-            //save the stack's data structure for interpretation later
-            memcpy (&(mTechParams[mNumTechList]), &(rfDetail.rf_tech_param), sizeof(rfDetail.rf_tech_param));
-        }
-    }
-    else if(NFC_PROTOCOL_15693 == rfDetail.protocol)
-    {
-        //is TagTechnology.NFC_V by Java API
-         mTechList [mNumTechList] = TARGET_TYPE_ISO15693;
-    }
-    else if(NFC_PROTOCOL_KOVIO == rfDetail.protocol)
-    {
-        ALOGV("%s: Kovio", fn);
-        mTechList [mNumTechList] = TARGET_TYPE_KOVIO_BARCODE;
-    }
-    else if(NFC_PROTOCOL_MIFARE == rfDetail.protocol)
-    {
-        ALOGV("Mifare Classic detected");
-        EXTNS_MfcInit(activationData);
-        mTechList [mNumTechList] = TARGET_TYPE_ISO14443_3A;  //is TagTechnology.NFC_A by Java API
-        // could be MifFare UL or Classic or Kovio
-        {
-            // need to look at first byte of uid to find manuf.
-            tNFC_RF_TECH_PARAMS tech_params;
-            memcpy (&tech_params, &(rfDetail.rf_tech_param), sizeof(rfDetail.rf_tech_param));
-            if (mNumTechList < (MAX_NUM_TECHNOLOGY-1))
-                {
-                    mNumTechList++;
-                    mTechHandles [mNumTechList] = rfDetail.rf_disc_id;
-                    mTechLibNfcTypes [mNumTechList] = rfDetail.protocol;
-                    //save the stack's data structure for interpretation later
-                    memcpy (&(mTechParams[mNumTechList]), &(rfDetail.rf_tech_param), sizeof(rfDetail.rf_tech_param));
-                    mTechList [mNumTechList] = TARGET_TYPE_MIFARE_CLASSIC; //is TagTechnology.MIFARE_ULTRALIGHT by Java API
-                }
-        }
-    }
-    else
     {
-        ALOGE("%s: unknown protocol ????", fn);
-        mTechList [mNumTechList] = TARGET_TYPE_UNKNOWN;
+      mNumTechList++;
+      mTechHandles[mNumTechList] = rfDetail.rf_disc_id;
+      mTechLibNfcTypes[mNumTechList] = rfDetail.protocol;
+      mTechList[mNumTechList] =
+          TARGET_TYPE_ISO14443_3A;  // is TagTechnology.NFC_A by Java API
+      // save the stack's data structure for interpretation later
+      memcpy(&(mTechParams[mNumTechList]), &(rfDetail.rf_tech_param),
+             sizeof(rfDetail.rf_tech_param));
     }
-
-    mNumTechList++;
 #if (NXP_EXTNS == TRUE)
-        for (int i=0; (i < mNumTechList) && (mNumTechList < MAX_NUM_TECHNOLOGY); i++)
+    else if (((rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_POLL_B) ||
+              (rfDetail.rf_tech_param.mode ==
+               NFC_DISCOVERY_TYPE_POLL_B_PRIME) ||
+              (rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_LISTEN_B) ||
+              (rfDetail.rf_tech_param.mode ==
+               NFC_DISCOVERY_TYPE_LISTEN_B_PRIME)) &&
+             mNumTechList < (MAX_NUM_TECHNOLOGY - 1))
 #else
-    for (int i=0; i < mNumTechList; i++)
+    else if ((rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_POLL_B) ||
+             (rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_POLL_B_PRIME) ||
+             (rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_LISTEN_B) ||
+             (rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_LISTEN_B_PRIME))
 #endif
     {
-        ALOGV("%s: index=%d; tech=%d; handle=%d; nfc type=%d", fn,
-                i, mTechList[i], mTechHandles[i], mTechLibNfcTypes[i]);
-    }
+      mNumTechList++;
+      mTechHandles[mNumTechList] = rfDetail.rf_disc_id;
+      mTechLibNfcTypes[mNumTechList] = rfDetail.protocol;
+      mTechList[mNumTechList] =
+          TARGET_TYPE_ISO14443_3B;  // is TagTechnology.NFC_B by Java API
+      // save the stack's data structure for interpretation later
+      memcpy(&(mTechParams[mNumTechList]), &(rfDetail.rf_tech_param),
+             sizeof(rfDetail.rf_tech_param));
+    }
+  } else if (NFC_PROTOCOL_T5T == rfDetail.protocol) {
+    // is TagTechnology.NFC_V by Java API
+    mTechList[mNumTechList] = TARGET_TYPE_V;
+  } else if (NFC_PROTOCOL_KOVIO == rfDetail.protocol) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Kovio", fn);
+    mTechList[mNumTechList] = TARGET_TYPE_KOVIO_BARCODE;
+  } else if (NFC_PROTOCOL_MIFARE == rfDetail.protocol) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Mifare Classic detected");
+    EXTNS_MfcInit(activationData);
+    mTechList[mNumTechList] =
+        TARGET_TYPE_ISO14443_3A;  // is TagTechnology.NFC_A by Java API
+    // could be MifFare UL or Classic or Kovio
+    {
+      // need to look at first byte of uid to find manuf.
+      tNFC_RF_TECH_PARAMS tech_params;
+      memcpy(&tech_params, &(rfDetail.rf_tech_param),
+             sizeof(rfDetail.rf_tech_param));
+      if (mNumTechList < (MAX_NUM_TECHNOLOGY - 1)) {
+        mNumTechList++;
+        mTechHandles[mNumTechList] = rfDetail.rf_disc_id;
+        mTechLibNfcTypes[mNumTechList] = rfDetail.protocol;
+        // save the stack's data structure for interpretation later
+        memcpy(&(mTechParams[mNumTechList]), &(rfDetail.rf_tech_param),
+               sizeof(rfDetail.rf_tech_param));
+        mTechList[mNumTechList] =
+            TARGET_TYPE_MIFARE_CLASSIC;  // is TagTechnology.MIFARE_ULTRALIGHT
+                                         // by Java API
+      }
+    }
+  } else {
+    LOG(ERROR) << StringPrintf("%s: unknown protocol ????", fn);
+    mTechList[mNumTechList] = TARGET_TYPE_UNKNOWN;
+  }
+
+  mNumTechList++;
+#if (NXP_EXTNS == TRUE)
+  for (int i = 0; (i < mNumTechList) && (mNumTechList < MAX_NUM_TECHNOLOGY);
+       i++)
+#else
+  for (int i = 0; i < mNumTechList; i++)
+#endif
+  {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: index=%d; tech=%d; handle=%d; nfc type=%d", fn, i,
+                        mTechList[i], mTechHandles[i], mTechLibNfcTypes[i]);
+  }
 #if (NXP_EXTNS == TRUE)
 TheEnd:
 #endif
-    ALOGV("%s: exit", fn);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
 }
 
-
 /*******************************************************************************
 **
 ** Function:        discoverTechnologies
 **
-** Description:     Discover the technologies that NFC service needs by interpreting
+** Description:     Discover the technologies that NFC service needs by
+*interpreting
 **                  the data structures from the stack.
 **                  discoveryData: data from discovery events(s).
 **
 ** Returns:         None
 **
 *******************************************************************************/
-void NfcTag::discoverTechnologies (tNFA_DISC_RESULT& discoveryData)
-{
-    static const char fn [] = "NfcTag::discoverTechnologies (discovery)";
-    tNFC_RESULT_DEVT& discovery_ntf = discoveryData.discovery_ntf;
-
-    ALOGV("%s: enter: rf disc. id=%u; protocol=%u, mNumTechList=%u", fn, discovery_ntf.rf_disc_id, discovery_ntf.protocol, mNumTechList);
-    if (mNumTechList >= MAX_NUM_TECHNOLOGY)
-    {
-        ALOGE("%s: exceed max=%d", fn, MAX_NUM_TECHNOLOGY);
-        goto TheEnd;
-    }
-    mTechHandles [mNumTechList] = discovery_ntf.rf_disc_id;
-    mTechLibNfcTypes [mNumTechList] = discovery_ntf.protocol;
-
-    //save the stack's data structure for interpretation later
-    memcpy (&(mTechParams[mNumTechList]), &(discovery_ntf.rf_tech_param), sizeof(discovery_ntf.rf_tech_param));
-
-    if(NFC_PROTOCOL_T1T == discovery_ntf.protocol)
-    {
-        mTechList [mNumTechList] = TARGET_TYPE_ISO14443_3A; //is TagTechnology.NFC_A by Java API
-    }
-    else if(NFC_PROTOCOL_T2T == discovery_ntf.protocol)
-    {
-        mTechList [mNumTechList] = TARGET_TYPE_ISO14443_3A;  //is TagTechnology.NFC_A by Java API
-        //type-2 tags are identical to Mifare Ultralight, so Ultralight is also discovered
-        if ((discovery_ntf.rf_tech_param.param.pa.sel_rsp == 0) &&
-                (mNumTechList < (MAX_NUM_TECHNOLOGY-1)))
-        {
-            // Mifare Ultralight
-            mNumTechList++;
-            mTechHandles [mNumTechList] = discovery_ntf.rf_disc_id;
-            mTechLibNfcTypes [mNumTechList] = discovery_ntf.protocol;
-            mTechList [mNumTechList] = TARGET_TYPE_MIFARE_UL; //is TagTechnology.MIFARE_ULTRALIGHT by Java API
-        }
-
-        //save the stack's data structure for interpretation later
-        memcpy (&(mTechParams[mNumTechList]), &(discovery_ntf.rf_tech_param), sizeof(discovery_ntf.rf_tech_param));
-    }
-    else if(NFC_PROTOCOL_T3T == discovery_ntf.protocol)
-    {
-        mTechList [mNumTechList] = TARGET_TYPE_FELICA;
-    }
-    else if(NFC_PROTOCOL_ISO_DEP == discovery_ntf.protocol)
-    {
-        //type-4 tag uses technology ISO-DEP and technology A or B
-        mTechList [mNumTechList] = TARGET_TYPE_ISO14443_4; //is TagTechnology.ISO_DEP by Java API
-        if ( (discovery_ntf.rf_tech_param.mode == NFC_DISCOVERY_TYPE_POLL_A) ||
-                (discovery_ntf.rf_tech_param.mode == NFC_DISCOVERY_TYPE_POLL_A_ACTIVE) ||
-                (discovery_ntf.rf_tech_param.mode == NFC_DISCOVERY_TYPE_LISTEN_A) ||
-                (discovery_ntf.rf_tech_param.mode == NFC_DISCOVERY_TYPE_LISTEN_A_ACTIVE) )
-        {
-            if (mNumTechList < (MAX_NUM_TECHNOLOGY-1))
-            {
-                mNumTechList++;
-                mTechHandles [mNumTechList] = discovery_ntf.rf_disc_id;
-                mTechLibNfcTypes [mNumTechList] = discovery_ntf.protocol;
-                mTechList [mNumTechList] = TARGET_TYPE_ISO14443_3A; //is TagTechnology.NFC_A by Java API
-                //save the stack's data structure for interpretation later
-                memcpy (&(mTechParams[mNumTechList]), &(discovery_ntf.rf_tech_param), sizeof(discovery_ntf.rf_tech_param));
-            }
-        }
-        else if ( (discovery_ntf.rf_tech_param.mode == NFC_DISCOVERY_TYPE_POLL_B) ||
-                (discovery_ntf.rf_tech_param.mode == NFC_DISCOVERY_TYPE_POLL_B_PRIME) ||
-                (discovery_ntf.rf_tech_param.mode == NFC_DISCOVERY_TYPE_LISTEN_B) ||
-                (discovery_ntf.rf_tech_param.mode == NFC_DISCOVERY_TYPE_LISTEN_B_PRIME) )
-        {
-            if (mNumTechList < (MAX_NUM_TECHNOLOGY-1))
-            {
-                mNumTechList++;
-                mTechHandles [mNumTechList] = discovery_ntf.rf_disc_id;
-                mTechLibNfcTypes [mNumTechList] = discovery_ntf.protocol;
-                mTechList [mNumTechList] = TARGET_TYPE_ISO14443_3B; //is TagTechnology.NFC_B by Java API
-                //save the stack's data structure for interpretation later
-                memcpy (&(mTechParams[mNumTechList]), &(discovery_ntf.rf_tech_param), sizeof(discovery_ntf.rf_tech_param));
-            }
-        }
-    }
-    else if(NFC_PROTOCOL_15693 == discovery_ntf.protocol)
-    {
-        //is TagTechnology.NFC_V by Java API
-        mTechList [mNumTechList] = TARGET_TYPE_ISO15693;
-    }
-    else if (NFC_PROTOCOL_MIFARE == discovery_ntf.protocol)
-    {
-        mTechList [mNumTechList] = TARGET_TYPE_MIFARE_CLASSIC;
-        if (mNumTechList < (MAX_NUM_TECHNOLOGY-1))
-        {
-            mNumTechList++;
-            mTechHandles [mNumTechList] = discovery_ntf.rf_disc_id;
-            mTechLibNfcTypes [mNumTechList] = discovery_ntf.protocol;
-            mTechList [mNumTechList] = TARGET_TYPE_ISO14443_3A;
-            //save the stack's data structure for interpretation later
-            memcpy (&(mTechParams[mNumTechList]), &(discovery_ntf.rf_tech_param), sizeof(discovery_ntf.rf_tech_param));
-        }
-    }
-    else
-    {
-        ALOGE("%s: unknown protocol ????", fn);
-        mTechList [mNumTechList] = TARGET_TYPE_UNKNOWN;
-    }
-
-    mNumTechList++;
-
-    if(discovery_ntf.more != NCI_DISCOVER_NTF_MORE)
-    {
+void NfcTag::discoverTechnologies(tNFA_DISC_RESULT& discoveryData) {
+  static const char fn[] = "NfcTag::discoverTechnologies (discovery)";
+  tNFC_RESULT_DEVT& discovery_ntf = discoveryData.discovery_ntf;
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: enter: rf disc. id=%u; protocol=%u, mNumTechList=%u", fn,
+      discovery_ntf.rf_disc_id, discovery_ntf.protocol, mNumTechList);
+  if (mNumTechList >= MAX_NUM_TECHNOLOGY) {
+    LOG(ERROR) << StringPrintf("%s: exceed max=%d", fn, MAX_NUM_TECHNOLOGY);
+    goto TheEnd;
+  }
+  mTechHandles[mNumTechList] = discovery_ntf.rf_disc_id;
+  mTechLibNfcTypes[mNumTechList] = discovery_ntf.protocol;
+
+  // save the stack's data structure for interpretation later
+  memcpy(&(mTechParams[mNumTechList]), &(discovery_ntf.rf_tech_param),
+         sizeof(discovery_ntf.rf_tech_param));
+
+  if (NFC_PROTOCOL_T1T == discovery_ntf.protocol) {
+    mTechList[mNumTechList] =
+        TARGET_TYPE_ISO14443_3A;  // is TagTechnology.NFC_A by Java API
+  } else if (NFC_PROTOCOL_T2T == discovery_ntf.protocol) {
+    mTechList[mNumTechList] =
+        TARGET_TYPE_ISO14443_3A;  // is TagTechnology.NFC_A by Java API
+    // type-2 tags are identical to Mifare Ultralight, so Ultralight is also
+    // discovered
+    if ((discovery_ntf.rf_tech_param.param.pa.sel_rsp == 0) &&
+        (mNumTechList < (MAX_NUM_TECHNOLOGY - 1))) {
+      // Mifare Ultralight
+      mNumTechList++;
+      mTechHandles[mNumTechList] = discovery_ntf.rf_disc_id;
+      mTechLibNfcTypes[mNumTechList] = discovery_ntf.protocol;
+      mTechList[mNumTechList] =
+          TARGET_TYPE_MIFARE_UL;  // is TagTechnology.MIFARE_ULTRALIGHT by Java
+                                  // API
+    }
+
+    // save the stack's data structure for interpretation later
+    memcpy(&(mTechParams[mNumTechList]), &(discovery_ntf.rf_tech_param),
+           sizeof(discovery_ntf.rf_tech_param));
+  } else if (NFC_PROTOCOL_T3T == discovery_ntf.protocol) {
+    mTechList[mNumTechList] = TARGET_TYPE_FELICA;
+  } else if (NFC_PROTOCOL_ISO_DEP == discovery_ntf.protocol) {
+    // type-4 tag uses technology ISO-DEP and technology A or B
+    mTechList[mNumTechList] =
+        TARGET_TYPE_ISO14443_4;  // is TagTechnology.ISO_DEP by Java API
+    if ((discovery_ntf.rf_tech_param.mode == NFC_DISCOVERY_TYPE_POLL_A) ||
+        (discovery_ntf.rf_tech_param.mode ==
+         NFC_DISCOVERY_TYPE_POLL_A_ACTIVE) ||
+        (discovery_ntf.rf_tech_param.mode == NFC_DISCOVERY_TYPE_LISTEN_A) ||
+        (discovery_ntf.rf_tech_param.mode ==
+         NFC_DISCOVERY_TYPE_LISTEN_A_ACTIVE)) {
+      if (mNumTechList < (MAX_NUM_TECHNOLOGY - 1)) {
+        mNumTechList++;
+        mTechHandles[mNumTechList] = discovery_ntf.rf_disc_id;
+        mTechLibNfcTypes[mNumTechList] = discovery_ntf.protocol;
+        mTechList[mNumTechList] =
+            TARGET_TYPE_ISO14443_3A;  // is TagTechnology.NFC_A by Java API
+        // save the stack's data structure for interpretation later
+        memcpy(&(mTechParams[mNumTechList]), &(discovery_ntf.rf_tech_param),
+               sizeof(discovery_ntf.rf_tech_param));
+      }
+    } else if ((discovery_ntf.rf_tech_param.mode ==
+                NFC_DISCOVERY_TYPE_POLL_B) ||
+               (discovery_ntf.rf_tech_param.mode ==
+                NFC_DISCOVERY_TYPE_POLL_B_PRIME) ||
+               (discovery_ntf.rf_tech_param.mode ==
+                NFC_DISCOVERY_TYPE_LISTEN_B) ||
+               (discovery_ntf.rf_tech_param.mode ==
+                NFC_DISCOVERY_TYPE_LISTEN_B_PRIME)) {
+      if (mNumTechList < (MAX_NUM_TECHNOLOGY - 1)) {
+        mNumTechList++;
+        mTechHandles[mNumTechList] = discovery_ntf.rf_disc_id;
+        mTechLibNfcTypes[mNumTechList] = discovery_ntf.protocol;
+        mTechList[mNumTechList] =
+            TARGET_TYPE_ISO14443_3B;  // is TagTechnology.NFC_B by Java API
+        // save the stack's data structure for interpretation later
+        memcpy(&(mTechParams[mNumTechList]), &(discovery_ntf.rf_tech_param),
+               sizeof(discovery_ntf.rf_tech_param));
+      }
+    }
+  } else if (NFC_PROTOCOL_T5T == discovery_ntf.protocol) {
+    // is TagTechnology.NFC_V by Java API
+    mTechList[mNumTechList] = TARGET_TYPE_V;
+  } else if (NFC_PROTOCOL_MIFARE == discovery_ntf.protocol) {
+    mTechList[mNumTechList] = TARGET_TYPE_MIFARE_CLASSIC;
+    if (mNumTechList < (MAX_NUM_TECHNOLOGY - 1)) {
+      mNumTechList++;
+      mTechHandles[mNumTechList] = discovery_ntf.rf_disc_id;
+      mTechLibNfcTypes[mNumTechList] = discovery_ntf.protocol;
+      mTechList[mNumTechList] = TARGET_TYPE_ISO14443_3A;
+      // save the stack's data structure for interpretation later
+      memcpy(&(mTechParams[mNumTechList]), &(discovery_ntf.rf_tech_param),
+             sizeof(discovery_ntf.rf_tech_param));
+    }
+  } else {
+    LOG(ERROR) << StringPrintf("%s: unknown protocol ????", fn);
+    mTechList[mNumTechList] = TARGET_TYPE_UNKNOWN;
+  }
+
+  mNumTechList++;
+
+  if (discovery_ntf.more != NCI_DISCOVER_NTF_MORE) {
 #if (NXP_EXTNS == TRUE)
-        for (int i=0; (i < mNumTechList) && (mNumTechList < MAX_NUM_TECHNOLOGY); i++)
+    for (int i = 0; (i < mNumTechList) && (mNumTechList < MAX_NUM_TECHNOLOGY);
+         i++)
 #else
-        for (int i=0; i < mNumTechList; i++)
+    for (int i = 0; i < mNumTechList; i++)
 #endif
-        {
-            ALOGV("%s: index=%d; tech=%d; handle=%d; nfc type=%d", fn,
-                    i, mTechList[i], mTechHandles[i], mTechLibNfcTypes[i]);
-        }
+    {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: index=%d; tech=%d; handle=%d; nfc type=%d", fn, i, mTechList[i],
+          mTechHandles[i], mTechLibNfcTypes[i]);
     }
-    mNumDiscTechList = mNumTechList;
-    ALOGV("%s; mNumDiscTechList=%x", fn, mNumDiscTechList);
+  }
+  mNumDiscTechList = mNumTechList;
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s; mNumDiscTechList=%x", fn, mNumDiscTechList);
 
 TheEnd:
-    ALOGV("%s: exit", fn);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
 }
 
 /*******************************************************************************
@@ -664,73 +664,71 @@ TheEnd:
 ** Returns:         None
 **
 *******************************************************************************/
-void NfcTag::createNativeNfcTag (tNFA_ACTIVATED& activationData)
-{
-    static const char fn [] = "NfcTag::createNativeNfcTag";
-    ALOGV("%s: enter", fn);
-
-    JNIEnv* e = NULL;
-    ScopedAttach attach(mNativeData->vm, &e);
-    if (e == NULL)
-    {
-        ALOGE("%s: jni env is null", fn);
-        return;
-    }
-
-    ScopedLocalRef<jclass> tag_cls(e, e->GetObjectClass(mNativeData->cached_NfcTag));
-    if (e->ExceptionCheck())
-    {
-        e->ExceptionClear();
-        ALOGE("%s: failed to get class", fn);
-        return;
-    }
-
-    //create a new Java NativeNfcTag object
-    jmethodID ctor = e->GetMethodID(tag_cls.get(), "<init>", "()V");
-    ScopedLocalRef<jobject> tag(e, e->NewObject(tag_cls.get(), ctor));
-
-    //fill NativeNfcTag's mProtocols, mTechList, mTechHandles, mTechLibNfcTypes
-    fillNativeNfcTagMembers1(e, tag_cls.get(), tag.get());
-
-    //fill NativeNfcTag's members: mHandle, mConnectedTechnology
-    fillNativeNfcTagMembers2(e, tag_cls.get(), tag.get(), activationData);
-
-    //fill NativeNfcTag's members: mTechPollBytes
-    fillNativeNfcTagMembers3(e, tag_cls.get(), tag.get(), activationData);
-
-    //fill NativeNfcTag's members: mTechActBytes
-    fillNativeNfcTagMembers4(e, tag_cls.get(), tag.get(), activationData);
-
-    //fill NativeNfcTag's members: mUid
-    fillNativeNfcTagMembers5(e, tag_cls.get(), tag.get(), activationData);
-
-    if (mNativeData->tag != NULL)
-    {
-        e->DeleteGlobalRef(mNativeData->tag);
-    }
-    mNativeData->tag = e->NewGlobalRef(tag.get());
-
-    ALOGV("%s; mNumDiscNtf=%x", fn,mNumDiscNtf);
-    if(!mNumDiscNtf || NfcTag::getInstance().checkNextValidProtocol() == -1)
-    {
-        //notify NFC service about this new tag
-        mNumDiscNtf = 0;
-        ALOGV("%s: try notify nfc service", fn);
-        storeActivationParams();
-        e->CallVoidMethod(mNativeData->manager, android::gCachedNfcManagerNotifyNdefMessageListeners, tag.get());
-        if (e->ExceptionCheck())
-        {
-            e->ExceptionClear();
-            ALOGE("%s: fail notify nfc service", fn);
-        }
-        deleteglobaldata(e);
-    }
-    else
-    {
-        ALOGV("%s: Selecting next tag", fn);
-    }
-
-    ALOGV("%s: exit", fn);
+void NfcTag::createNativeNfcTag(tNFA_ACTIVATED& activationData) {
+  static const char fn[] = "NfcTag::createNativeNfcTag";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+
+  JNIEnv* e = NULL;
+  ScopedAttach attach(mNativeData->vm, &e);
+  if (e == NULL) {
+    LOG(ERROR) << StringPrintf("%s: jni env is null", fn);
+    return;
+  }
+
+  ScopedLocalRef<jclass> tag_cls(e,
+                                 e->GetObjectClass(mNativeData->cached_NfcTag));
+  if (e->ExceptionCheck()) {
+    e->ExceptionClear();
+    LOG(ERROR) << StringPrintf("%s: failed to get class", fn);
+    return;
+  }
+
+  // create a new Java NativeNfcTag object
+  jmethodID ctor = e->GetMethodID(tag_cls.get(), "<init>", "()V");
+  ScopedLocalRef<jobject> tag(e, e->NewObject(tag_cls.get(), ctor));
+
+  // fill NativeNfcTag's mProtocols, mTechList, mTechHandles, mTechLibNfcTypes
+  fillNativeNfcTagMembers1(e, tag_cls.get(), tag.get());
+
+  // fill NativeNfcTag's members: mHandle, mConnectedTechnology
+  fillNativeNfcTagMembers2(e, tag_cls.get(), tag.get(), activationData);
+
+  // fill NativeNfcTag's members: mTechPollBytes
+  fillNativeNfcTagMembers3(e, tag_cls.get(), tag.get(), activationData);
+
+  // fill NativeNfcTag's members: mTechActBytes
+  fillNativeNfcTagMembers4(e, tag_cls.get(), tag.get(), activationData);
+
+  // fill NativeNfcTag's members: mUid
+  fillNativeNfcTagMembers5(e, tag_cls.get(), tag.get(), activationData);
+
+  if (mNativeData->tag != NULL) {
+    e->DeleteGlobalRef(mNativeData->tag);
+  }
+  mNativeData->tag = e->NewGlobalRef(tag.get());
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s; mNumDiscNtf=%x", fn, mNumDiscNtf);
+  if (!mNumDiscNtf || NfcTag::getInstance().checkNextValidProtocol() == -1) {
+    // notify NFC service about this new tag
+    mNumDiscNtf = 0;
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: try notify nfc service", fn);
+    storeActivationParams();
+    e->CallVoidMethod(mNativeData->manager,
+                      android::gCachedNfcManagerNotifyNdefMessageListeners,
+                      tag.get());
+    if (e->ExceptionCheck()) {
+      e->ExceptionClear();
+      LOG(ERROR) << StringPrintf("%s: fail notify nfc service", fn);
+    }
+    deleteglobaldata(e);
+  } else {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Selecting next tag", fn);
+  }
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
 }
 
 /*******************************************************************************
@@ -743,27 +741,24 @@ void NfcTag::createNativeNfcTag (tNFA_ACTIVATED& activationData)
 ** Returns:         None
 **
 *******************************************************************************/
-static void deleteglobaldata(JNIEnv* e)
-{
-    static const char fn [] = "deleteglobaldata";
-    ALOGV("%s: enter", fn);
-    if( techActBytes1 != NULL)
-    {
-        e->DeleteGlobalRef(techActBytes1);
-    }
-    if(techPollBytes2 != NULL)
-    {
-        e->DeleteGlobalRef(techPollBytes2);
-    }
-    ALOGV("%s: exit", fn);
+static void deleteglobaldata(JNIEnv* e) {
+  static const char fn[] = "deleteglobaldata";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+  if (techActBytes1 != NULL) {
+    e->DeleteGlobalRef(techActBytes1);
+  }
+  if (techPollBytes2 != NULL) {
+    e->DeleteGlobalRef(techPollBytes2);
+  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
 }
 
-
 /*******************************************************************************
 **
 ** Function:        fillNativeNfcTagMembers1
 **
-** Description:     Fill NativeNfcTag's members: mProtocols, mTechList, mTechHandles, mTechLibNfcTypes.
+** Description:     Fill NativeNfcTag's members: mProtocols, mTechList,
+*mTechHandles, mTechLibNfcTypes.
 **                  e: JVM environment.
 **                  tag_cls: Java NativeNfcTag class.
 **                  tag: Java NativeNfcTag object.
@@ -771,48 +766,48 @@ static void deleteglobaldata(JNIEnv* e)
 ** Returns:         None
 **
 *******************************************************************************/
-void NfcTag::fillNativeNfcTagMembers1 (JNIEnv* e, jclass tag_cls, jobject tag)
-{
-    static const char fn [] = "NfcTag::fillNativeNfcTagMembers1";
-    ALOGV("%s", fn);
-
-    //create objects that represent NativeNfcTag's member variables
-    ScopedLocalRef<jintArray> techList(e, e->NewIntArray(mNumTechList));
-    ScopedLocalRef<jintArray> handleList(e, e->NewIntArray(mNumTechList));
-    ScopedLocalRef<jintArray> typeList(e, e->NewIntArray(mNumTechList));
-
-    {
-        ScopedIntArrayRW technologies(e, techList.get());
-        ScopedIntArrayRW handles(e, handleList.get());
-        ScopedIntArrayRW types(e, typeList.get());
-        for (int i = 0; i < mNumTechList; i++) {
-            mNativeData->tProtocols [i] = mTechLibNfcTypes [i];
-            mNativeData->handles [i] = mTechHandles [i];
-            technologies [i] = mTechList [i];
-            handles [i]      = mTechHandles [i];
-            types [i]        = mTechLibNfcTypes [i];
-        }
-    }
-
-    jfieldID f = NULL;
-
-    f = e->GetFieldID(tag_cls, "mTechList", "[I");
-    e->SetObjectField(tag, f, techList.get());
-
-    f = e->GetFieldID(tag_cls, "mTechHandles", "[I");
-    e->SetObjectField(tag, f, handleList.get());
-
-    f = e->GetFieldID(tag_cls, "mTechLibNfcTypes", "[I");
-    e->SetObjectField(tag, f, typeList.get());
+void NfcTag::fillNativeNfcTagMembers1(JNIEnv* e, jclass tag_cls, jobject tag) {
+  static const char fn[] = "NfcTag::fillNativeNfcTagMembers1";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", fn);
+
+  // create objects that represent NativeNfcTag's member variables
+  ScopedLocalRef<jintArray> techList(e, e->NewIntArray(mNumTechList));
+  ScopedLocalRef<jintArray> handleList(e, e->NewIntArray(mNumTechList));
+  ScopedLocalRef<jintArray> typeList(e, e->NewIntArray(mNumTechList));
+
+  {
+    ScopedIntArrayRW technologies(e, techList.get());
+    ScopedIntArrayRW handles(e, handleList.get());
+    ScopedIntArrayRW types(e, typeList.get());
+    for (int i = 0; i < mNumTechList; i++) {
+      mNativeData->tProtocols[i] = mTechLibNfcTypes[i];
+      mNativeData->handles[i] = mTechHandles[i];
+      technologies[i] = mTechList[i];
+      handles[i] = mTechHandles[i];
+      types[i] = mTechLibNfcTypes[i];
+    }
+  }
+
+  jfieldID f = NULL;
+
+  f = e->GetFieldID(tag_cls, "mTechList", "[I");
+  e->SetObjectField(tag, f, techList.get());
+
+  f = e->GetFieldID(tag_cls, "mTechHandles", "[I");
+  e->SetObjectField(tag, f, handleList.get());
+
+  f = e->GetFieldID(tag_cls, "mTechLibNfcTypes", "[I");
+  e->SetObjectField(tag, f, typeList.get());
 }
 
-
 /*******************************************************************************
 **
 ** Function:        fillNativeNfcTagMembers2
 **
-** Description:     Fill NativeNfcTag's members: mConnectedTechIndex or mConnectedTechnology.
-**                  The original Google's implementation is in set_target_pollBytes(
+** Description:     Fill NativeNfcTag's members: mConnectedTechIndex or
+*mConnectedTechnology.
+**                  The original Google's implementation is in
+*set_target_pollBytes(
 **                  in com_android_nfc_NativeNfcTag.cpp;
 **                  e: JVM environment.
 **                  tag_cls: Java NativeNfcTag class.
@@ -822,22 +817,22 @@ void NfcTag::fillNativeNfcTagMembers1 (JNIEnv* e, jclass tag_cls, jobject tag)
 ** Returns:         None
 **
 *******************************************************************************/
-//fill NativeNfcTag's members: mHandle, mConnectedTechnology
-void NfcTag::fillNativeNfcTagMembers2 (JNIEnv* e, jclass tag_cls, jobject tag, tNFA_ACTIVATED& /*activationData*/)
-{
-    static const char fn [] = "NfcTag::fillNativeNfcTagMembers2";
-    ALOGV("%s", fn);
-    jfieldID f = e->GetFieldID(tag_cls, "mConnectedTechIndex", "I");
-    e->SetIntField(tag, f, (jint) 0);
+// fill NativeNfcTag's members: mHandle, mConnectedTechnology
+void NfcTag::fillNativeNfcTagMembers2(JNIEnv* e, jclass tag_cls, jobject tag,
+                                      tNFA_ACTIVATED& /*activationData*/) {
+  static const char fn[] = "NfcTag::fillNativeNfcTagMembers2";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", fn);
+  jfieldID f = e->GetFieldID(tag_cls, "mConnectedTechIndex", "I");
+  e->SetIntField(tag, f, (jint)0);
 }
 
-
 /*******************************************************************************
 **
 ** Function:        fillNativeNfcTagMembers3
 **
 ** Description:     Fill NativeNfcTag's members: mTechPollBytes.
-**                  The original Google's implementation is in set_target_pollBytes(
+**                  The original Google's implementation is in
+*set_target_pollBytes(
 **                  in com_android_nfc_NativeNfcTag.cpp;
 **                  e: JVM environment.
 **                  tag_cls: Java NativeNfcTag class.
@@ -847,137 +842,135 @@ void NfcTag::fillNativeNfcTagMembers2 (JNIEnv* e, jclass tag_cls, jobject tag, t
 ** Returns:         None
 **
 *******************************************************************************/
-void NfcTag::fillNativeNfcTagMembers3 (JNIEnv* e, jclass tag_cls, jobject tag, tNFA_ACTIVATED& activationData)
-{
-    static const char fn [] = "NfcTag::fillNativeNfcTagMembers3";
-    ScopedLocalRef<jbyteArray> pollBytes(e, e->NewByteArray(0));
-    ScopedLocalRef<jclass> byteArrayClass(e, e->GetObjectClass(pollBytes.get()));
-    ScopedLocalRef<jobjectArray> techPollBytes(e, e->NewObjectArray(mNumTechList, byteArrayClass.get(), 0));
-    int len = 0;
-    if(mTechListIndex == 0)
-    {
-        techPollBytes2= reinterpret_cast<jobjectArray>(e->NewGlobalRef(techPollBytes.get()));
-    }
-    else
-    {
-        for(int j=0;j<mTechListIndex;j++)
-        {
-            ScopedLocalRef<jobject> obj1(e, e->GetObjectArrayElement(techPollBytes2, j));
-            e->SetObjectArrayElement(techPollBytes.get(), j, obj1.get());
-        }
-    }
-
-    for (int i = mTechListIndex; i < mNumTechList; i++)
-
-    {
-        ALOGV("%s: index=%d; rf tech params mode=%u", fn, i, mTechParams [i].mode);
-        if (NFC_DISCOVERY_TYPE_POLL_A == mTechParams [i].mode
-              || NFC_DISCOVERY_TYPE_POLL_A_ACTIVE == mTechParams [i].mode
-              || NFC_DISCOVERY_TYPE_LISTEN_A == mTechParams [i].mode
-              || NFC_DISCOVERY_TYPE_LISTEN_A_ACTIVE == mTechParams [i].mode)
-        {
-            ALOGV("%s: tech A", fn);
-            pollBytes.reset(e->NewByteArray(2));
-            e->SetByteArrayRegion(pollBytes.get(), 0, 2, (jbyte*) mTechParams [i].param.pa.sens_res);
-        }
-        else if (NFC_DISCOVERY_TYPE_POLL_B == mTechParams [i].mode
-              || NFC_DISCOVERY_TYPE_POLL_B_PRIME == mTechParams [i].mode
-              || NFC_DISCOVERY_TYPE_LISTEN_B == mTechParams [i].mode
-              || NFC_DISCOVERY_TYPE_LISTEN_B_PRIME == mTechParams [i].mode)
-        {
-            if (mTechList [i] == TARGET_TYPE_ISO14443_3B) //is TagTechnology.NFC_B by Java API
-            {
-                /*****************
-                see NFC Forum Digital Protocol specification; section 5.6.2;
-                in SENSB_RES response, byte 6 through 9 is Application Data, byte 10-12 or 13 is Protocol Info;
-                used by public API: NfcB.getApplicationData(), NfcB.getProtocolInfo();
-                *****************/
-                ALOGV("%s: tech B; TARGET_TYPE_ISO14443_3B", fn);
-                len = mTechParams [i].param.pb.sensb_res_len;
-                len = len - 4; //subtract 4 bytes for NFCID0 at byte 2 through 5
-                if(len > 0)
-                {
-                    pollBytes.reset(e->NewByteArray(len));
-                    e->SetByteArrayRegion(pollBytes.get(), 0, len, (jbyte*) (mTechParams [i].param.pb.sensb_res+4));
-                }
-                else
-                {
-                    ALOGV("%s: tech B; Activation param missing", fn);
-                }
-            }
-            else
-            {
-                pollBytes.reset(e->NewByteArray(0));
-            }
-        }
-        else if (NFC_DISCOVERY_TYPE_POLL_F == mTechParams [i].mode
-              || NFC_DISCOVERY_TYPE_POLL_F_ACTIVE == mTechParams [i].mode
-              || NFC_DISCOVERY_TYPE_LISTEN_F == mTechParams [i].mode
-              || NFC_DISCOVERY_TYPE_LISTEN_F_ACTIVE == mTechParams [i].mode)
-        {
-            /****************
-            see NFC Forum Type 3 Tag Operation Specification; sections 2.3.2, 2.3.1.2;
-            see NFC Forum Digital Protocol Specification; sections 6.6.2;
-            PMm: manufacture parameter; 8 bytes;
-            System Code: 2 bytes;
-            ****************/
-            ALOGV("%s: tech F", fn);
-            uint8_t result [10]; //return result to NFC service
-            memset (result, 0, sizeof(result));
-            len =  10;
-
-            /****
-            for (int ii = 0; ii < mTechParams [i].param.pf.sensf_res_len; ii++)
-            {
-                ALOGV("%s: tech F, sendf_res[%d]=%d (0x%x)",
-                      fn, ii, mTechParams [i].param.pf.sensf_res[ii],mTechParams [i].param.pf.sensf_res[ii]);
-            }
-            ***/
-            memcpy (result, mTechParams [i].param.pf.sensf_res + 8, 8); //copy PMm
-            if (activationData.params.t3t.num_system_codes > 0) //copy the first System Code
-            {
-                uint16_t systemCode = *(activationData.params.t3t.p_system_codes);
-                result [8] = (uint8_t) (systemCode >> 8);
-                result [9] = (uint8_t) systemCode;
-                ALOGV("%s: tech F; sys code=0x%X 0x%X", fn, result [8], result [9]);
-            }
-            pollBytes.reset(e->NewByteArray(len));
-            e->SetByteArrayRegion(pollBytes.get(), 0, len, (jbyte*) result);
-        }
-        else if (NFC_DISCOVERY_TYPE_POLL_ISO15693 == mTechParams [i].mode
-              || NFC_DISCOVERY_TYPE_LISTEN_ISO15693 == mTechParams [i].mode)
-        {
-            ALOGV("%s: tech iso 15693", fn);
-            //iso 15693 response flags: 1 octet
-            //iso 15693 Data Structure Format Identifier (DSF ID): 1 octet
-            //used by public API: NfcV.getDsfId(), NfcV.getResponseFlags();
-            uint8_t data [2]= {activationData.params.i93.afi, activationData.params.i93.dsfid};
-            pollBytes.reset(e->NewByteArray(2));
-            e->SetByteArrayRegion(pollBytes.get(), 0, 2, (jbyte *) data);
-        }
-
-        else if (NFC_DISCOVERY_TYPE_POLL_KOVIO == mTechParams [i].mode)
-        {
-            ALOGV("%s: tech Kovio", fn);
-            pollBytes.reset(e->NewByteArray(0));
+void NfcTag::fillNativeNfcTagMembers3(JNIEnv* e, jclass tag_cls, jobject tag,
+                                      tNFA_ACTIVATED& activationData) {
+  static const char fn[] = "NfcTag::fillNativeNfcTagMembers3";
+  ScopedLocalRef<jbyteArray> pollBytes(e, e->NewByteArray(0));
+  ScopedLocalRef<jclass> byteArrayClass(e, e->GetObjectClass(pollBytes.get()));
+  ScopedLocalRef<jobjectArray> techPollBytes(
+      e, e->NewObjectArray(mNumTechList, byteArrayClass.get(), 0));
+  int len = 0;
+  if (mTechListIndex == 0) {
+    techPollBytes2 =
+        reinterpret_cast<jobjectArray>(e->NewGlobalRef(techPollBytes.get()));
+  } else {
+    for (int j = 0; j < mTechListIndex; j++) {
+      ScopedLocalRef<jobject> obj1(e,
+                                   e->GetObjectArrayElement(techPollBytes2, j));
+      e->SetObjectArrayElement(techPollBytes.get(), j, obj1.get());
+    }
+  }
+
+  for (int i = mTechListIndex; i < mNumTechList; i++)
+
+  {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: index=%d; rf tech params mode=%u", fn, i, mTechParams[i].mode);
+    if (NFC_DISCOVERY_TYPE_POLL_A == mTechParams[i].mode ||
+        NFC_DISCOVERY_TYPE_POLL_A_ACTIVE == mTechParams[i].mode ||
+        NFC_DISCOVERY_TYPE_LISTEN_A == mTechParams[i].mode ||
+        NFC_DISCOVERY_TYPE_LISTEN_A_ACTIVE == mTechParams[i].mode) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: tech A", fn);
+      pollBytes.reset(e->NewByteArray(2));
+      e->SetByteArrayRegion(pollBytes.get(), 0, 2,
+                            (jbyte*)mTechParams[i].param.pa.sens_res);
+    } else if (NFC_DISCOVERY_TYPE_POLL_B == mTechParams[i].mode ||
+               NFC_DISCOVERY_TYPE_POLL_B_PRIME == mTechParams[i].mode ||
+               NFC_DISCOVERY_TYPE_LISTEN_B == mTechParams[i].mode ||
+               NFC_DISCOVERY_TYPE_LISTEN_B_PRIME == mTechParams[i].mode) {
+      if (mTechList[i] ==
+          TARGET_TYPE_ISO14443_3B)  // is TagTechnology.NFC_B by Java API
+      {
+        /*****************
+        see NFC Forum Digital Protocol specification; section 5.6.2;
+        in SENSB_RES response, byte 6 through 9 is Application Data, byte 10-12
+        or 13 is Protocol Info;
+        used by public API: NfcB.getApplicationData(), NfcB.getProtocolInfo();
+        *****************/
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: tech B; TARGET_TYPE_ISO14443_3B", fn);
+        len = mTechParams[i].param.pb.sensb_res_len;
+        len = len - 4;  // subtract 4 bytes for NFCID0 at byte 2 through 5
+        if (len > 0) {
+          pollBytes.reset(e->NewByteArray(len));
+          e->SetByteArrayRegion(
+              pollBytes.get(), 0, len,
+              (jbyte*)(mTechParams[i].param.pb.sensb_res + 4));
+        } else {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("%s: tech B; Activation param missing", fn);
         }
-        else
-        {
-            ALOGE("%s: tech unknown ????", fn);
-            pollBytes.reset(e->NewByteArray(0));
-
-        } //switch: every type of technology
-        e->SetObjectArrayElement(techPollBytes.get(), i, pollBytes.get());
-    }
-    if (techPollBytes2 != NULL && mTechListIndex != 0 )
-    {
-        e->DeleteGlobalRef(techPollBytes2);
-
-        techPollBytes2= reinterpret_cast<jobjectArray>(e->NewGlobalRef(techPollBytes.get()));
-    }
-    //for: every technology in the array
-    jfieldID f = e->GetFieldID(tag_cls, "mTechPollBytes", "[[B");
-    e->SetObjectField(tag, f, techPollBytes.get());
+      } else {
+        pollBytes.reset(e->NewByteArray(0));
+      }
+    } else if (NFC_DISCOVERY_TYPE_POLL_F == mTechParams[i].mode ||
+               NFC_DISCOVERY_TYPE_POLL_F_ACTIVE == mTechParams[i].mode ||
+               NFC_DISCOVERY_TYPE_LISTEN_F == mTechParams[i].mode ||
+               NFC_DISCOVERY_TYPE_LISTEN_F_ACTIVE == mTechParams[i].mode) {
+      /****************
+      see NFC Forum Type 3 Tag Operation Specification; sections 2.3.2, 2.3.1.2;
+      see NFC Forum Digital Protocol Specification; sections 6.6.2;
+      PMm: manufacture parameter; 8 bytes;
+      System Code: 2 bytes;
+      ****************/
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: tech F", fn);
+      uint8_t result[10];  // return result to NFC service
+      memset(result, 0, sizeof(result));
+      len = 10;
+
+      /****
+      for (int ii = 0; ii < mTechParams [i].param.pf.sensf_res_len; ii++)
+      {
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: tech F,
+      sendf_res[%d]=%d (0x%x)",
+                fn, ii, mTechParams [i].param.pf.sensf_res[ii],mTechParams
+      [i].param.pf.sensf_res[ii]);
+      }
+      ***/
+      memcpy(result, mTechParams[i].param.pf.sensf_res + 8, 8);  // copy PMm
+      if (activationData.params.t3t.num_system_codes >
+          0)  // copy the first System Code
+      {
+        uint16_t systemCode = *(activationData.params.t3t.p_system_codes);
+        result[8] = (uint8_t)(systemCode >> 8);
+        result[9] = (uint8_t)systemCode;
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: tech F; sys code=0x%X 0x%X", fn, result[8], result[9]);
+      }
+      pollBytes.reset(e->NewByteArray(len));
+      e->SetByteArrayRegion(pollBytes.get(), 0, len, (jbyte*)result);
+    } else if (NFC_DISCOVERY_TYPE_POLL_V == mTechParams[i].mode ||
+               NFC_DISCOVERY_TYPE_LISTEN_ISO15693 == mTechParams[i].mode) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: tech iso 15693", fn);
+      // iso 15693 response flags: 1 octet
+      // iso 15693 Data Structure Format Identifier (DSF ID): 1 octet
+      // used by public API: NfcV.getDsfId(), NfcV.getResponseFlags();
+      uint8_t data[2] = {activationData.params.i93.afi,
+                         activationData.params.i93.dsfid};
+      pollBytes.reset(e->NewByteArray(2));
+      e->SetByteArrayRegion(pollBytes.get(), 0, 2, (jbyte*)data);
+    }
+
+    else if (NFC_DISCOVERY_TYPE_POLL_KOVIO == mTechParams[i].mode) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: tech Kovio", fn);
+      pollBytes.reset(e->NewByteArray(0));
+    } else {
+      LOG(ERROR) << StringPrintf("%s: tech unknown ????", fn);
+      pollBytes.reset(e->NewByteArray(0));
+
+    }  // switch: every type of technology
+    e->SetObjectArrayElement(techPollBytes.get(), i, pollBytes.get());
+  }
+  if (techPollBytes2 != NULL && mTechListIndex != 0) {
+    e->DeleteGlobalRef(techPollBytes2);
+
+    techPollBytes2 =
+        reinterpret_cast<jobjectArray>(e->NewGlobalRef(techPollBytes.get()));
+  }
+  // for: every technology in the array
+  jfieldID f = e->GetFieldID(tag_cls, "mTechPollBytes", "[[B");
+  e->SetObjectField(tag, f, techPollBytes.get());
 }
 
 /*******************************************************************************
@@ -985,7 +978,8 @@ void NfcTag::fillNativeNfcTagMembers3 (JNIEnv* e, jclass tag_cls, jobject tag, t
 ** Function:        fillNativeNfcTagMembers4
 **
 ** Description:     Fill NativeNfcTag's members: mTechActBytes.
-**                  The original Google's implementation is in set_target_activationBytes()
+**                  The original Google's implementation is in
+*set_target_activationBytes()
 **                  in com_android_nfc_NativeNfcTag.cpp;
 **                  e: JVM environment.
 **                  tag_cls: Java NativeNfcTag class.
@@ -995,147 +989,147 @@ void NfcTag::fillNativeNfcTagMembers3 (JNIEnv* e, jclass tag_cls, jobject tag, t
 ** Returns:         None
 **
 *******************************************************************************/
-void NfcTag::fillNativeNfcTagMembers4 (JNIEnv* e, jclass tag_cls, jobject tag, tNFA_ACTIVATED& activationData)
-{
-    static const char fn [] = "NfcTag::fillNativeNfcTagMembers4";
-    ScopedLocalRef<jbyteArray> actBytes(e, e->NewByteArray(0));
-    ScopedLocalRef<jclass> byteArrayClass(e, e->GetObjectClass(actBytes.get()));
-    ScopedLocalRef<jobjectArray> techActBytes(e, e->NewObjectArray(mNumTechList, byteArrayClass.get(), 0));
-    if(mTechListIndex == 0)
-    {
-        techActBytes1 = reinterpret_cast<jobjectArray>(e->NewGlobalRef(techActBytes.get()));
-    }
-    else
-    {
-        for(int j=0;j < mTechListIndex;j++)
-        {
-            ScopedLocalRef<jobject> obj1(e, e->GetObjectArrayElement(techActBytes1, j));
-            e->SetObjectArrayElement(techActBytes.get(), j, obj1.get());
-        }
-    }
-
-    for (int i = mTechListIndex; i < mNumTechList; i++)
-
-    {
-        ALOGV("%s: index=%d", fn, i);
-        if (NFC_PROTOCOL_T1T == mTechLibNfcTypes[i] || NFC_PROTOCOL_T2T == mTechLibNfcTypes[i])
-        {
-            if (mTechLibNfcTypes[i] == NFC_PROTOCOL_T1T)
-                ALOGV("%s: T1T; tech A", fn);
-            else if (mTechLibNfcTypes[i] == NFC_PROTOCOL_T2T)
-                ALOGV("%s: T2T; tech A", fn);
-            actBytes.reset(e->NewByteArray(1));
-            e->SetByteArrayRegion(actBytes.get(), 0, 1, (jbyte*) &mTechParams [i].param.pa.sel_rsp);
-        }
-        else if (NFC_PROTOCOL_T3T == mTechLibNfcTypes[i])
-        {
-            //felica
-            ALOGV("%s: T3T; felica; tech F", fn);
-            //really, there is no data
+void NfcTag::fillNativeNfcTagMembers4(JNIEnv* e, jclass tag_cls, jobject tag,
+                                      tNFA_ACTIVATED& activationData) {
+  static const char fn[] = "NfcTag::fillNativeNfcTagMembers4";
+  ScopedLocalRef<jbyteArray> actBytes(e, e->NewByteArray(0));
+  ScopedLocalRef<jclass> byteArrayClass(e, e->GetObjectClass(actBytes.get()));
+  ScopedLocalRef<jobjectArray> techActBytes(
+      e, e->NewObjectArray(mNumTechList, byteArrayClass.get(), 0));
+  if (mTechListIndex == 0) {
+    techActBytes1 =
+        reinterpret_cast<jobjectArray>(e->NewGlobalRef(techActBytes.get()));
+  } else {
+    for (int j = 0; j < mTechListIndex; j++) {
+      ScopedLocalRef<jobject> obj1(e,
+                                   e->GetObjectArrayElement(techActBytes1, j));
+      e->SetObjectArrayElement(techActBytes.get(), j, obj1.get());
+    }
+  }
+
+  for (int i = mTechListIndex; i < mNumTechList; i++)
+
+  {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: index=%d", fn, i);
+    if (NFC_PROTOCOL_T1T == mTechLibNfcTypes[i] ||
+        NFC_PROTOCOL_T2T == mTechLibNfcTypes[i]) {
+      if (mTechLibNfcTypes[i] == NFC_PROTOCOL_T1T)
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: T1T; tech A", fn);
+      else if (mTechLibNfcTypes[i] == NFC_PROTOCOL_T2T)
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: T2T; tech A", fn);
+      actBytes.reset(e->NewByteArray(1));
+      e->SetByteArrayRegion(actBytes.get(), 0, 1,
+                            (jbyte*)&mTechParams[i].param.pa.sel_rsp);
+    } else if (NFC_PROTOCOL_T3T == mTechLibNfcTypes[i]) {
+      // felica
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: T3T; felica; tech F", fn);
+      // really, there is no data
+      actBytes.reset(e->NewByteArray(0));
+    } else if (NFC_PROTOCOL_MIFARE == mTechLibNfcTypes[i]) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: Mifare Classic; tech A", fn);
+      actBytes.reset(e->NewByteArray(1));
+      e->SetByteArrayRegion(actBytes.get(), 0, 1,
+                            (jbyte*)&mTechParams[i].param.pa.sel_rsp);
+    } else if (NFC_PROTOCOL_T3BT == mTechLibNfcTypes[i]) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: tech T3BT; chinaId card", fn);
+      actBytes.reset(e->NewByteArray(0));
+    } else if (NFC_PROTOCOL_ISO_DEP == mTechLibNfcTypes[i]) {
+      if (mTechList[i] ==
+          TARGET_TYPE_ISO14443_4)  // is TagTechnology.ISO_DEP by Java API
+      {
+        if ((mTechParams[i].mode == NFC_DISCOVERY_TYPE_POLL_A) ||
+            (mTechParams[i].mode == NFC_DISCOVERY_TYPE_POLL_A_ACTIVE) ||
+            (mTechParams[i].mode == NFC_DISCOVERY_TYPE_LISTEN_A) ||
+            (mTechParams[i].mode == NFC_DISCOVERY_TYPE_LISTEN_A_ACTIVE)) {
+          // see NFC Forum Digital Protocol specification, section 11.6.2, "RATS
+          // Response"; search for "historical bytes";
+          // copy historical bytes into Java object;
+          // the public API, IsoDep.getHistoricalBytes(), returns this data;
+          if (activationData.activate_ntf.intf_param.type ==
+              NFC_INTERFACE_ISO_DEP) {
+            tNFC_INTF_PA_ISO_DEP& pa_iso =
+                activationData.activate_ntf.intf_param.intf_param.pa_iso;
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+                "%s: T4T; ISO_DEP for tech A; copy historical bytes; len=%u",
+                fn, pa_iso.his_byte_len);
+            actBytes.reset(e->NewByteArray(pa_iso.his_byte_len));
+            if (pa_iso.his_byte_len > 0)
+              e->SetByteArrayRegion(actBytes.get(), 0, pa_iso.his_byte_len,
+                                    (jbyte*)(pa_iso.his_byte));
+          } else {
+            LOG(ERROR) << StringPrintf(
+                "%s: T4T; ISO_DEP for tech A; wrong interface=%u", fn,
+                activationData.activate_ntf.intf_param.type);
             actBytes.reset(e->NewByteArray(0));
-        }
-        else if (NFC_PROTOCOL_MIFARE == mTechLibNfcTypes[i])
-        {
-            ALOGV("%s: Mifare Classic; tech A", fn);
-            actBytes.reset (e->NewByteArray(1));
-            e->SetByteArrayRegion (actBytes.get(), 0, 1,
-                    (jbyte*) &mTechParams [i].param.pa.sel_rsp);
-        }
-        else if (NFC_PROTOCOL_T3BT == mTechLibNfcTypes[i])
-        {
-            ALOGV("%s: tech T3BT; chinaId card", fn);
+          }
+        } else if ((mTechParams[i].mode == NFC_DISCOVERY_TYPE_POLL_B) ||
+                   (mTechParams[i].mode == NFC_DISCOVERY_TYPE_POLL_B_PRIME) ||
+                   (mTechParams[i].mode == NFC_DISCOVERY_TYPE_LISTEN_B) ||
+                   (mTechParams[i].mode == NFC_DISCOVERY_TYPE_LISTEN_B_PRIME)) {
+          // see NFC Forum Digital Protocol specification, section 12.6.2,
+          // "ATTRIB Response";
+          // copy higher-layer response bytes into Java object;
+          // the public API, IsoDep.getHiLayerResponse(), returns this data;
+          if (activationData.activate_ntf.intf_param.type ==
+              NFC_INTERFACE_ISO_DEP) {
+            tNFC_INTF_PB_ISO_DEP& pb_iso =
+                activationData.activate_ntf.intf_param.intf_param.pb_iso;
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+                "%s: T4T; ISO_DEP for tech B; copy response bytes; len=%u", fn,
+                pb_iso.hi_info_len);
+            actBytes.reset(e->NewByteArray(pb_iso.hi_info_len));
+            if (pb_iso.hi_info_len > 0)
+              e->SetByteArrayRegion(actBytes.get(), 0, pb_iso.hi_info_len,
+                                    (jbyte*)(pb_iso.hi_info));
+          } else {
+            LOG(ERROR) << StringPrintf(
+                "%s: T4T; ISO_DEP for tech B; wrong interface=%u", fn,
+                activationData.activate_ntf.intf_param.type);
             actBytes.reset(e->NewByteArray(0));
+          }
         }
-        else if (NFC_PROTOCOL_ISO_DEP == mTechLibNfcTypes[i])
-        {
-                if (mTechList [i] == TARGET_TYPE_ISO14443_4) //is TagTechnology.ISO_DEP by Java API
-                {
-                    if ( (mTechParams[i].mode == NFC_DISCOVERY_TYPE_POLL_A) ||
-                            (mTechParams[i].mode == NFC_DISCOVERY_TYPE_POLL_A_ACTIVE) ||
-                            (mTechParams[i].mode == NFC_DISCOVERY_TYPE_LISTEN_A) ||
-                            (mTechParams[i].mode == NFC_DISCOVERY_TYPE_LISTEN_A_ACTIVE) )
-                    {
-                        //see NFC Forum Digital Protocol specification, section 11.6.2, "RATS Response"; search for "historical bytes";
-                        //copy historical bytes into Java object;
-                        //the public API, IsoDep.getHistoricalBytes(), returns this data;
-                        if (activationData.activate_ntf.intf_param.type == NFC_INTERFACE_ISO_DEP)
-                        {
-                            tNFC_INTF_PA_ISO_DEP& pa_iso = activationData.activate_ntf.intf_param.intf_param.pa_iso;
-                            ALOGV("%s: T4T; ISO_DEP for tech A; copy historical bytes; len=%u", fn, pa_iso.his_byte_len);
-                            actBytes.reset(e->NewByteArray(pa_iso.his_byte_len));
-                            if (pa_iso.his_byte_len > 0)
-                                e->SetByteArrayRegion(actBytes.get(), 0, pa_iso.his_byte_len, (jbyte*) (pa_iso.his_byte));
-                        }
-                        else
-                        {
-                            ALOGE("%s: T4T; ISO_DEP for tech A; wrong interface=%u", fn, activationData.activate_ntf.intf_param.type);
-                            actBytes.reset(e->NewByteArray(0));
-                        }
-                    }
-                    else if ( (mTechParams[i].mode == NFC_DISCOVERY_TYPE_POLL_B) ||
-                            (mTechParams[i].mode == NFC_DISCOVERY_TYPE_POLL_B_PRIME) ||
-                            (mTechParams[i].mode == NFC_DISCOVERY_TYPE_LISTEN_B) ||
-                            (mTechParams[i].mode == NFC_DISCOVERY_TYPE_LISTEN_B_PRIME) )
-                    {
-                        //see NFC Forum Digital Protocol specification, section 12.6.2, "ATTRIB Response";
-                        //copy higher-layer response bytes into Java object;
-                        //the public API, IsoDep.getHiLayerResponse(), returns this data;
-                        if (activationData.activate_ntf.intf_param.type == NFC_INTERFACE_ISO_DEP)
-                        {
-                            tNFC_INTF_PB_ISO_DEP& pb_iso = activationData.activate_ntf.intf_param.intf_param.pb_iso;
-                            ALOGV("%s: T4T; ISO_DEP for tech B; copy response bytes; len=%u", fn, pb_iso.hi_info_len);
-                            actBytes.reset(e->NewByteArray(pb_iso.hi_info_len));
-                            if (pb_iso.hi_info_len > 0)
-                                e->SetByteArrayRegion(actBytes.get(), 0, pb_iso.hi_info_len, (jbyte*) (pb_iso.hi_info));
-                        }
-                        else
-                        {
-                            ALOGE("%s: T4T; ISO_DEP for tech B; wrong interface=%u", fn, activationData.activate_ntf.intf_param.type);
-                            actBytes.reset(e->NewByteArray(0));
-                        }
-                    }
-                }
-                else if (mTechList [i] == TARGET_TYPE_ISO14443_3A) //is TagTechnology.NFC_A by Java API
-                {
-                    ALOGV("%s: T4T; tech A", fn);
-                    actBytes.reset(e->NewByteArray(1));
-                    e->SetByteArrayRegion(actBytes.get(), 0, 1, (jbyte*) &mTechParams [i].param.pa.sel_rsp);
-                }
-                else
-                {
-                    actBytes.reset(e->NewByteArray(0));
-                }
-        } //case NFC_PROTOCOL_ISO_DEP: //t4t
-        else if (NFC_PROTOCOL_15693 == mTechLibNfcTypes[i])
-        {
-            ALOGV("%s: tech iso 15693", fn);
-            //iso 15693 response flags: 1 octet
-            //iso 15693 Data Structure Format Identifier (DSF ID): 1 octet
-            //used by public API: NfcV.getDsfId(), NfcV.getResponseFlags();
-            uint8_t data [2]= {activationData.params.i93.afi, activationData.params.i93.dsfid};
-            actBytes.reset(e->NewByteArray(2));
-            e->SetByteArrayRegion(actBytes.get(), 0, 2, (jbyte *) data);
-        }
-        else if (NFC_PROTOCOL_KOVIO == mTechLibNfcTypes[i])
-        {
-            ALOGV("%s: tech Kovio", fn);
-            actBytes.reset(e->NewByteArray(0));
-        }
-        else
-        {
-            ALOGV("%s: tech unknown ????", fn);
-            actBytes.reset(e->NewByteArray(0));
-        }//switch
-        e->SetObjectArrayElement(techActBytes.get(), i, actBytes.get());
-        }
-    if (techActBytes1 != NULL && mTechListIndex !=0 )
-    {
-        e->DeleteGlobalRef(techActBytes1);
-        techActBytes1 = reinterpret_cast<jobjectArray>(e->NewGlobalRef(techActBytes.get()));
-    }
-    //for: every technology in the array
-    jfieldID f = e->GetFieldID (tag_cls, "mTechActBytes", "[[B");
-    e->SetObjectField(tag, f, techActBytes.get());
+      } else if (mTechList[i] ==
+                 TARGET_TYPE_ISO14443_3A)  // is TagTechnology.NFC_A by Java API
+      {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: T4T; tech A", fn);
+        actBytes.reset(e->NewByteArray(1));
+        e->SetByteArrayRegion(actBytes.get(), 0, 1,
+                              (jbyte*)&mTechParams[i].param.pa.sel_rsp);
+      } else {
+        actBytes.reset(e->NewByteArray(0));
+      }
+    }  // case NFC_PROTOCOL_ISO_DEP: //t4t
+    else if (NFC_PROTOCOL_T5T == mTechLibNfcTypes[i]) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: tech iso 15693", fn);
+      // iso 15693 response flags: 1 octet
+      // iso 15693 Data Structure Format Identifier (DSF ID): 1 octet
+      // used by public API: NfcV.getDsfId(), NfcV.getResponseFlags();
+      uint8_t data[2] = {activationData.params.i93.afi,
+                         activationData.params.i93.dsfid};
+      actBytes.reset(e->NewByteArray(2));
+      e->SetByteArrayRegion(actBytes.get(), 0, 2, (jbyte*)data);
+    } else if (NFC_PROTOCOL_KOVIO == mTechLibNfcTypes[i]) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: tech Kovio", fn);
+      actBytes.reset(e->NewByteArray(0));
+    } else {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: tech unknown ????", fn);
+      actBytes.reset(e->NewByteArray(0));
+    }  // switch
+    e->SetObjectArrayElement(techActBytes.get(), i, actBytes.get());
+  }
+  if (techActBytes1 != NULL && mTechListIndex != 0) {
+    e->DeleteGlobalRef(techActBytes1);
+    techActBytes1 =
+        reinterpret_cast<jobjectArray>(e->NewGlobalRef(techActBytes.get()));
+  }
+  // for: every technology in the array
+  jfieldID f = e->GetFieldID(tag_cls, "mTechActBytes", "[[B");
+  e->SetObjectField(tag, f, techActBytes.get());
 }
 
 /*******************************************************************************
@@ -1143,7 +1137,8 @@ void NfcTag::fillNativeNfcTagMembers4 (JNIEnv* e, jclass tag_cls, jobject tag, t
 ** Function:        fillNativeNfcTagMembers5
 **
 ** Description:     Fill NativeNfcTag's members: mUid.
-**                  The original Google's implementation is in nfc_jni_Discovery_notification_callback()
+**                  The original Google's implementation is in
+*nfc_jni_Discovery_notification_callback()
 **                  in com_android_nfc_NativeNfcManager.cpp;
 **                  e: JVM environment.
 **                  tag_cls: Java NativeNfcTag class.
@@ -1153,93 +1148,82 @@ void NfcTag::fillNativeNfcTagMembers4 (JNIEnv* e, jclass tag_cls, jobject tag, t
 ** Returns:         None
 **
 *******************************************************************************/
-void NfcTag::fillNativeNfcTagMembers5 (JNIEnv* e, jclass tag_cls, jobject tag, tNFA_ACTIVATED& activationData)
-{
-    static const char fn [] = "NfcTag::fillNativeNfcTagMembers5";
-    int len = 0;
-    ScopedLocalRef<jbyteArray> uid(e, NULL);
-
-    if (NFC_DISCOVERY_TYPE_POLL_KOVIO == mTechParams [0].mode)
-    {
-        ALOGV("%s: Kovio", fn);
-        len = mTechParams [0].param.pk.uid_len;
-        uid.reset(e->NewByteArray(len));
-        e->SetByteArrayRegion(uid.get(), 0, len,
-                (jbyte*) &mTechParams [0].param.pk.uid);
-    }
-    else if (NFC_DISCOVERY_TYPE_POLL_A == mTechParams [0].mode
-          || NFC_DISCOVERY_TYPE_POLL_A_ACTIVE == mTechParams [0].mode
-          || NFC_DISCOVERY_TYPE_LISTEN_A == mTechParams [0].mode
-          || NFC_DISCOVERY_TYPE_LISTEN_A_ACTIVE == mTechParams [0].mode)
-    {
-        ALOGV("%s: tech A", fn);
-        len = mTechParams [0].param.pa.nfcid1_len;
-        uid.reset(e->NewByteArray(len));
-        e->SetByteArrayRegion(uid.get(), 0, len,
-                (jbyte*) &mTechParams [0].param.pa.nfcid1);
-        //a tag's NFCID1 can change dynamically at each activation;
-        //only the first byte (0x08) is constant; a dynamic NFCID1's length
-        //must be 4 bytes (see NFC Digitial Protocol,
-        //section 4.7.2 SDD_RES Response, Requirements 20).
-        mIsDynamicTagId = (mTechParams [0].param.pa.nfcid1_len == 4) &&
-                (mTechParams [0].param.pa.nfcid1 [0] == 0x08);
-    }
-    else if (NFC_DISCOVERY_TYPE_POLL_B == mTechParams [0].mode
-          || NFC_DISCOVERY_TYPE_POLL_B_PRIME == mTechParams [0].mode
-          || NFC_DISCOVERY_TYPE_LISTEN_B == mTechParams [0].mode
-          || NFC_DISCOVERY_TYPE_LISTEN_B_PRIME == mTechParams [0].mode)
-    {
-#if (NXP_EXTNS == TRUE)
-        if(activationData.activate_ntf.protocol != NFA_PROTOCOL_T3BT)
-#endif
-        {
-            ALOGV("%s: tech B", fn);
-            uid.reset(e->NewByteArray(NFC_NFCID0_MAX_LEN));
-            e->SetByteArrayRegion(uid.get(), 0, NFC_NFCID0_MAX_LEN,
-                    (jbyte*) &mTechParams [0].param.pb.nfcid0);
-        }
+void NfcTag::fillNativeNfcTagMembers5(JNIEnv* e, jclass tag_cls, jobject tag,
+                                      tNFA_ACTIVATED& activationData) {
+  static const char fn[] = "NfcTag::fillNativeNfcTagMembers5";
+  int len = 0;
+  ScopedLocalRef<jbyteArray> uid(e, NULL);
+
+  if (NFC_DISCOVERY_TYPE_POLL_KOVIO == mTechParams[0].mode) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Kovio", fn);
+    len = mTechParams[0].param.pk.uid_len;
+    uid.reset(e->NewByteArray(len));
+    e->SetByteArrayRegion(uid.get(), 0, len,
+                          (jbyte*)&mTechParams[0].param.pk.uid);
+  } else if (NFC_DISCOVERY_TYPE_POLL_A == mTechParams[0].mode ||
+             NFC_DISCOVERY_TYPE_POLL_A_ACTIVE == mTechParams[0].mode ||
+             NFC_DISCOVERY_TYPE_LISTEN_A == mTechParams[0].mode ||
+             NFC_DISCOVERY_TYPE_LISTEN_A_ACTIVE == mTechParams[0].mode) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: tech A", fn);
+    len = mTechParams[0].param.pa.nfcid1_len;
+    uid.reset(e->NewByteArray(len));
+    e->SetByteArrayRegion(uid.get(), 0, len,
+                          (jbyte*)&mTechParams[0].param.pa.nfcid1);
+    // a tag's NFCID1 can change dynamically at each activation;
+    // only the first byte (0x08) is constant; a dynamic NFCID1's length
+    // must be 4 bytes (see NFC Digitial Protocol,
+    // section 4.7.2 SDD_RES Response, Requirements 20).
+    mIsDynamicTagId = (mTechParams[0].param.pa.nfcid1_len == 4) &&
+                      (mTechParams[0].param.pa.nfcid1[0] == 0x08);
+  } else if (NFC_DISCOVERY_TYPE_POLL_B == mTechParams[0].mode ||
+             NFC_DISCOVERY_TYPE_POLL_B_PRIME == mTechParams[0].mode ||
+             NFC_DISCOVERY_TYPE_LISTEN_B == mTechParams[0].mode ||
+             NFC_DISCOVERY_TYPE_LISTEN_B_PRIME == mTechParams[0].mode) {
 #if (NXP_EXTNS == TRUE)
-        else
-        {
-            ALOGV("%s: chinaId card", fn);
-            ALOGV("%s: pipi_id[0]=%x", fn, mTechParams [0].param.pb.pupiid[0]);
-            uid.reset(e->NewByteArray(NFC_PUPIID_MAX_LEN));
-            e->SetByteArrayRegion(uid.get(), 0, NFC_PUPIID_MAX_LEN,
-                    (jbyte*) &mTechParams [0].param.pb.pupiid);
-        }
+    if (activationData.activate_ntf.protocol != NFA_PROTOCOL_T3BT)
 #endif
-    }
-    else if (NFC_DISCOVERY_TYPE_POLL_F == mTechParams [0].mode
-          || NFC_DISCOVERY_TYPE_POLL_F_ACTIVE == mTechParams [0].mode
-          || NFC_DISCOVERY_TYPE_LISTEN_F == mTechParams [0].mode
-          || NFC_DISCOVERY_TYPE_LISTEN_F_ACTIVE == mTechParams [0].mode)
-    {
-        uid.reset(e->NewByteArray(NFC_NFCID2_LEN));
-        e->SetByteArrayRegion(uid.get(), 0, NFC_NFCID2_LEN,
-                (jbyte*) &mTechParams [0].param.pf.nfcid2);
-        ALOGV("%s: tech F", fn);
-    }
-    else if (NFC_DISCOVERY_TYPE_POLL_ISO15693 == mTechParams [0].mode
-          || NFC_DISCOVERY_TYPE_LISTEN_ISO15693 == mTechParams [0].mode)
     {
-            ALOGV("%s: tech iso 15693", fn);
-            jbyte data [I93_UID_BYTE_LEN];  //8 bytes
-            for (int i=0; i<I93_UID_BYTE_LEN; ++i) //reverse the ID
-                data[i] = activationData.params.i93.uid [I93_UID_BYTE_LEN - i - 1];
-            uid.reset(e->NewByteArray(I93_UID_BYTE_LEN));
-            e->SetByteArrayRegion(uid.get(), 0, I93_UID_BYTE_LEN, data);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: tech B", fn);
+      uid.reset(e->NewByteArray(NFC_NFCID0_MAX_LEN));
+      e->SetByteArrayRegion(uid.get(), 0, NFC_NFCID0_MAX_LEN,
+                            (jbyte*)&mTechParams[0].param.pb.nfcid0);
     }
-    else
-    {
-        ALOGE("%s: tech unknown ????", fn);
-        uid.reset(e->NewByteArray(0));
+#if (NXP_EXTNS == TRUE)
+    else {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: chinaId card", fn);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: pipi_id[0]=%x", fn, mTechParams[0].param.pb.pupiid[0]);
+      uid.reset(e->NewByteArray(NFC_PUPIID_MAX_LEN));
+      e->SetByteArrayRegion(uid.get(), 0, NFC_PUPIID_MAX_LEN,
+                            (jbyte*)&mTechParams[0].param.pb.pupiid);
     }
-    jfieldID f = e->GetFieldID(tag_cls, "mUid", "[B");
-    e->SetObjectField(tag, f, uid.get());
-    mTechListIndex = mNumTechList;
-    if(!mNumDiscNtf)
-        mTechListIndex = 0;
-    ALOGV("%s;mTechListIndex=%x",fn,mTechListIndex);
+#endif
+  } else if (NFC_DISCOVERY_TYPE_POLL_F == mTechParams[0].mode ||
+             NFC_DISCOVERY_TYPE_POLL_F_ACTIVE == mTechParams[0].mode ||
+             NFC_DISCOVERY_TYPE_LISTEN_F == mTechParams[0].mode ||
+             NFC_DISCOVERY_TYPE_LISTEN_F_ACTIVE == mTechParams[0].mode) {
+    uid.reset(e->NewByteArray(NFC_NFCID2_LEN));
+    e->SetByteArrayRegion(uid.get(), 0, NFC_NFCID2_LEN,
+                          (jbyte*)&mTechParams[0].param.pf.nfcid2);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: tech F", fn);
+  } else if (NFC_DISCOVERY_TYPE_POLL_V == mTechParams[0].mode ||
+             NFC_DISCOVERY_TYPE_LISTEN_ISO15693 == mTechParams[0].mode) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: tech iso 15693", fn);
+    jbyte data[I93_UID_BYTE_LEN];               // 8 bytes
+    for (int i = 0; i < I93_UID_BYTE_LEN; ++i)  // reverse the ID
+      data[i] = activationData.params.i93.uid[I93_UID_BYTE_LEN - i - 1];
+    uid.reset(e->NewByteArray(I93_UID_BYTE_LEN));
+    e->SetByteArrayRegion(uid.get(), 0, I93_UID_BYTE_LEN, data);
+  } else {
+    LOG(ERROR) << StringPrintf("%s: tech unknown ????", fn);
+    uid.reset(e->NewByteArray(0));
+  }
+  jfieldID f = e->GetFieldID(tag_cls, "mUid", "[B");
+  e->SetObjectField(tag, f, uid.get());
+  mTechListIndex = mNumTechList;
+  if (!mNumDiscNtf) mTechListIndex = 0;
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s;mTechListIndex=%x", fn, mTechListIndex);
 }
 
 /*******************************************************************************
@@ -1251,23 +1235,21 @@ void NfcTag::fillNativeNfcTagMembers5 (JNIEnv* e, jclass tag_cls, jobject tag, t
 ** Returns:         True if the peer supports P2P.
 **
 *******************************************************************************/
-bool NfcTag::isP2pDiscovered ()
-{
-    static const char fn [] = "NfcTag::isP2pDiscovered";
-    bool retval = false;
-
-    for (int i = 0; i < mNumTechList; i++)
-    {
-        if (mTechLibNfcTypes[i] == NFA_PROTOCOL_NFC_DEP)
-        {
-            //if remote device supports P2P
-            ALOGV("%s: discovered P2P", fn);
-            retval = true;
-            break;
-        }
-    }
-    ALOGV("%s: return=%u", fn, retval);
-    return retval;
+bool NfcTag::isP2pDiscovered() {
+  static const char fn[] = "NfcTag::isP2pDiscovered";
+  bool retval = false;
+
+  for (int i = 0; i < mNumTechList; i++) {
+    if (mTechLibNfcTypes[i] == NFA_PROTOCOL_NFC_DEP) {
+      // if remote device supports P2P
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: discovered P2P", fn);
+      retval = true;
+      break;
+    }
+  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: return=%u", fn, retval);
+  return retval;
 }
 
 /*******************************************************************************
@@ -1279,11 +1261,9 @@ bool NfcTag::isP2pDiscovered ()
 ** Returns:         None
 **
 *******************************************************************************/
-void NfcTag::storeActivationParams()
-{
-
-    mActivationParams_t.mTechParams = mTechParams[0].mode;
-    mActivationParams_t.mTechLibNfcTypes = mTechLibNfcTypes [0];
+void NfcTag::storeActivationParams() {
+  mActivationParams_t.mTechParams = mTechParams[0].mode;
+  mActivationParams_t.mTechLibNfcTypes = mTechLibNfcTypes[0];
 }
 /*******************************************************************************
 **
@@ -1294,137 +1274,120 @@ void NfcTag::storeActivationParams()
 ** Returns:         None
 **
 *******************************************************************************/
-void NfcTag::selectP2p()
-{
-    static const char fn [] = "NfcTag::selectP2p";
-    uint8_t rfDiscoveryId = 0;
-
-    for (int i = 0; i < mNumTechList; i++)
-    {
-        //if remote device does not support P2P, just skip it
-        if (mTechLibNfcTypes[i] != NFA_PROTOCOL_NFC_DEP)
-            continue;
-
-        //if remote device supports tech F;
-        //tech F is preferred because it is faster than tech A
-        if ( (mTechParams[i].mode == NFC_DISCOVERY_TYPE_POLL_F) ||
-             (mTechParams[i].mode == NFC_DISCOVERY_TYPE_POLL_F_ACTIVE) )
-        {
-            rfDiscoveryId = mTechHandles[i];
-            break; //no need to search further
-        }
-        else if ( (mTechParams[i].mode == NFC_DISCOVERY_TYPE_POLL_A) ||
-                (mTechParams[i].mode == NFC_DISCOVERY_TYPE_POLL_A_ACTIVE) )
-        {
-            //only choose tech A if tech F is unavailable
-            if (rfDiscoveryId == 0)
-                rfDiscoveryId = mTechHandles[i];
-        }
+void NfcTag::selectP2p() {
+  static const char fn[] = "NfcTag::selectP2p";
+  uint8_t rfDiscoveryId = 0;
+
+  for (int i = 0; i < mNumTechList; i++) {
+    // if remote device does not support P2P, just skip it
+    if (mTechLibNfcTypes[i] != NFA_PROTOCOL_NFC_DEP) continue;
+
+    // if remote device supports tech F;
+    // tech F is preferred because it is faster than tech A
+    if ((mTechParams[i].mode == NFC_DISCOVERY_TYPE_POLL_F) ||
+        (mTechParams[i].mode == NFC_DISCOVERY_TYPE_POLL_F_ACTIVE)) {
+      rfDiscoveryId = mTechHandles[i];
+      break;  // no need to search further
+    } else if ((mTechParams[i].mode == NFC_DISCOVERY_TYPE_POLL_A) ||
+               (mTechParams[i].mode == NFC_DISCOVERY_TYPE_POLL_A_ACTIVE)) {
+      // only choose tech A if tech F is unavailable
+      if (rfDiscoveryId == 0) rfDiscoveryId = mTechHandles[i];
+    }
+  }
+
+  if (rfDiscoveryId > 0) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: select P2P; target rf discov id=0x%X", fn, rfDiscoveryId);
+    tNFA_STATUS stat =
+        NFA_Select(rfDiscoveryId, NFA_PROTOCOL_NFC_DEP, NFA_INTERFACE_NFC_DEP);
+    if (stat != NFA_STATUS_OK)
+      LOG(ERROR) << StringPrintf("%s: fail select P2P; error=0x%X", fn, stat);
+#if (NXP_EXTNS == TRUE)
+    else {
+      mWaitingForSelect = true;
+      LOG(ERROR) << StringPrintf("%s: starting timer", fn);
+      gSelectCompleteTimer.set(1000, selectCompleteCallBack);
     }
-
-    if (rfDiscoveryId > 0)
-    {
-        ALOGV("%s: select P2P; target rf discov id=0x%X", fn, rfDiscoveryId);
-        tNFA_STATUS stat = NFA_Select (rfDiscoveryId, NFA_PROTOCOL_NFC_DEP, NFA_INTERFACE_NFC_DEP);
-        if (stat != NFA_STATUS_OK)
-            ALOGE("%s: fail select P2P; error=0x%X", fn, stat);
-#if(NXP_EXTNS == TRUE)
-        else
-        {
-            mWaitingForSelect = true;
-            ALOGE("%s: starting timer", fn);
-            gSelectCompleteTimer.set(1000, selectCompleteCallBack);
-        }
 #endif
-    }
-    else
-        ALOGE("%s: cannot find P2P", fn);
-    resetTechnologies ();
+  } else
+    LOG(ERROR) << StringPrintf("%s: cannot find P2P", fn);
+  resetTechnologies();
 }
 
-
 /*******************************************************************************
 **
 ** Function:        resetTechnologies
 **
-** Description:     Clear all data related to the technology, protocol of the tag.
+** Description:     Clear all data related to the technology, protocol of the
+*tag.
 **
 ** Returns:         None
 **
 *******************************************************************************/
-void NfcTag::resetTechnologies ()
-{
-    static const char fn [] = "NfcTag::resetTechnologies";
-    ALOGV("%s", fn);
-    mNumTechList = 0;
-    mTechListIndex = 0;
-    memset (mTechList, 0, sizeof(mTechList));
-    memset (mTechHandles, 0, sizeof(mTechHandles));
-    memset (mTechLibNfcTypes, 0, sizeof(mTechLibNfcTypes));
-    memset (mTechParams, 0, sizeof(mTechParams));
-    mIsDynamicTagId = false;
-    mIsFelicaLite = false;
-    resetAllTransceiveTimeouts ();
-#if(NXP_EXTNS == TRUE)
-    mNumDiscNtf = 0;
+void NfcTag::resetTechnologies() {
+  static const char fn[] = "NfcTag::resetTechnologies";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", fn);
+  mNumTechList = 0;
+  mTechListIndex = 0;
+  memset(mTechList, 0, sizeof(mTechList));
+  memset(mTechHandles, 0, sizeof(mTechHandles));
+  memset(mTechLibNfcTypes, 0, sizeof(mTechLibNfcTypes));
+  memset(mTechParams, 0, sizeof(mTechParams));
+  mIsDynamicTagId = false;
+  mIsFelicaLite = false;
+  resetAllTransceiveTimeouts();
+#if (NXP_EXTNS == TRUE)
+  mNumDiscNtf = 0;
 #endif
 }
 
-
 /*******************************************************************************
 **
 ** Function:        selectFirstTag
 **
-** Description:     When multiple tags are discovered, just select the first one to activate.
+** Description:     When multiple tags are discovered, just select the first one
+*to activate.
 **
 ** Returns:         None
 **
 *******************************************************************************/
-void NfcTag::selectFirstTag ()
-{
-    static const char fn [] = "NfcTag::selectFirstTag";
-    int foundIdx = -1;
-    tNFA_INTF_TYPE rf_intf = NFA_INTERFACE_FRAME;
-
-    for (int i = 0; i < mNumTechList; i++)
-    {
-        ALOGV("%s: nfa target idx=%d h=0x%X; protocol=0x%X",
-                fn, i, mTechHandles [i], mTechLibNfcTypes [i]);
-        if (mTechLibNfcTypes[i] != NFA_PROTOCOL_NFC_DEP)
-        {
-            foundIdx = i;
-            selectedId = i;
-            break;
-        }
+void NfcTag::selectFirstTag() {
+  static const char fn[] = "NfcTag::selectFirstTag";
+  int foundIdx = -1;
+  tNFA_INTF_TYPE rf_intf = NFA_INTERFACE_FRAME;
+
+  for (int i = 0; i < mNumTechList; i++) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: nfa target idx=%d h=0x%X; protocol=0x%X", fn, i,
+                        mTechHandles[i], mTechLibNfcTypes[i]);
+    if (mTechLibNfcTypes[i] != NFA_PROTOCOL_NFC_DEP) {
+      foundIdx = i;
+      selectedId = i;
+      break;
+    }
+  }
+
+  if (foundIdx != -1) {
+    if (mTechLibNfcTypes[foundIdx] == NFA_PROTOCOL_ISO_DEP) {
+      rf_intf = NFA_INTERFACE_ISO_DEP;
+    } else if (mTechLibNfcTypes[foundIdx] == NFC_PROTOCOL_MIFARE) {
+      rf_intf = NFA_INTERFACE_MIFARE;
+    } else
+      rf_intf = NFA_INTERFACE_FRAME;
+
+    tNFA_STATUS stat =
+        NFA_Select(mTechHandles[foundIdx], mTechLibNfcTypes[foundIdx], rf_intf);
+    if (stat != NFA_STATUS_OK)
+      LOG(ERROR) << StringPrintf("%s: fail select; error=0x%X", fn, stat);
+#if (NXP_EXTNS == TRUE)
+    else {
+      mWaitingForSelect = true;
+      gSelectCompleteTimer.set(1000, selectCompleteCallBack);
+      LOG(ERROR) << StringPrintf("%s:starting timer", fn);
     }
-
-    if (foundIdx != -1)
-    {
-        if (mTechLibNfcTypes [foundIdx] == NFA_PROTOCOL_ISO_DEP)
-        {
-            rf_intf = NFA_INTERFACE_ISO_DEP;
-        }
-        else if(mTechLibNfcTypes [foundIdx] == NFA_PROTOCOL_MIFARE)
-        {
-            rf_intf = NFA_INTERFACE_MIFARE;
-        }
-        else
-            rf_intf = NFA_INTERFACE_FRAME;
-
-        tNFA_STATUS stat = NFA_Select (mTechHandles [foundIdx], mTechLibNfcTypes [foundIdx], rf_intf);
-        if (stat != NFA_STATUS_OK)
-            ALOGE("%s: fail select; error=0x%X", fn, stat);
-#if(NXP_EXTNS == TRUE)
-        else
-        {
-            mWaitingForSelect = true;
-            gSelectCompleteTimer.set(1000, selectCompleteCallBack);
-            ALOGE("%s:starting timer", fn);
-        }
 #endif
-    }
-    else
-        ALOGE("%s: only found NFC-DEP technology.", fn);
+  } else
+    LOG(ERROR) << StringPrintf("%s: only found NFC-DEP technology.", fn);
 }
 
 /*******************************************************************************
@@ -1436,89 +1399,82 @@ void NfcTag::selectFirstTag ()
 ** Returns:         id
 **
 *******************************************************************************/
-int NfcTag::checkNextValidProtocol(void)
-{
-    static const char fn [] = "NfcTag::checkNextValidProtocol";
-    ALOGV("%s: enter, mNumDiscTechList=%x", fn, mNumDiscTechList);
-    int foundIdx = -1;
-    ALOGV("%s: enter,selectedId=%x", fn, selectedId);
-    for (int i = 0; i < mNumDiscTechList; i++)
-    {
-        ALOGV("%s: nfa target idx=%d h=0x%X; protocol=0x%X",
-                fn, i, mTechHandles [i], mTechLibNfcTypes [i]);
-        if ((mTechHandles[selectedId] != mTechHandles [i]) &&
-            (mTechLibNfcTypes[i] != NFA_PROTOCOL_NFC_DEP))
-        {
-            foundIdx = i;
-            break;
-        }
-    }
-    return foundIdx;
+int NfcTag::checkNextValidProtocol(void) {
+  static const char fn[] = "NfcTag::checkNextValidProtocol";
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter, mNumDiscTechList=%x", fn, mNumDiscTechList);
+  int foundIdx = -1;
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter,selectedId=%x", fn, selectedId);
+  for (int i = 0; i < mNumDiscTechList; i++) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: nfa target idx=%d h=0x%X; protocol=0x%X", fn, i,
+                        mTechHandles[i], mTechLibNfcTypes[i]);
+    if ((mTechHandles[selectedId] != mTechHandles[i]) &&
+        (mTechLibNfcTypes[i] != NFA_PROTOCOL_NFC_DEP)) {
+      foundIdx = i;
+      break;
+    }
+  }
+  return foundIdx;
 }
 
- /*******************************************************************************
+/*******************************************************************************
 **
 ** Function:        selectNextTag
 **
-** Description:     When multiple tags are discovered, selects the Nex one to activate.
+** Description:     When multiple tags are discovered, selects the Nex one to
+*activate.
 **
 ** Returns:         None
 **
 *******************************************************************************/
-void NfcTag::selectNextTag ()
-{
-    static const char fn [] = "NfcTag::selectNextTag";
-    int foundIdx = -1;
-    tNFA_INTF_TYPE rf_intf = NFA_INTERFACE_FRAME;
-    tNFA_STATUS stat = NFA_STATUS_FAILED;
-
-    ALOGV("%s: enter, mNumDiscTechList=%x", fn, mNumDiscTechList);
-    for (int i = 0; i < mNumDiscTechList; i++)
-    {
-        ALOGV("%s: nfa target idx=%d h=0x%X; protocol=0x%X",
-                fn, i, mTechHandles [i], mTechLibNfcTypes [i]);
-        if ((mTechHandles[selectedId] != mTechHandles [i]) &&
-            (mTechLibNfcTypes[i] != NFA_PROTOCOL_NFC_DEP))
-        {
-            selectedId = i;
-            foundIdx = i;
-            break;
-        }
-    }
-
-    if (foundIdx != -1)
-    {
-        if (mTechLibNfcTypes [foundIdx] == NFA_PROTOCOL_ISO_DEP)
-        {
-            rf_intf = NFA_INTERFACE_ISO_DEP;
-        }
-        else if(mTechLibNfcTypes [foundIdx] == NFA_PROTOCOL_MIFARE)
-        {
-            rf_intf = NFA_INTERFACE_MIFARE;
-        }
-        else
-            rf_intf = NFA_INTERFACE_FRAME;
-
-        stat = NFA_Select (mTechHandles [foundIdx], mTechLibNfcTypes [foundIdx], rf_intf);
-        if (stat == NFA_STATUS_OK)
-        {
-            ALOGE("%s: stat=%x; wait for activated ntf", fn, stat);
-#if(NXP_EXTNS == TRUE)
-            {
-                mWaitingForSelect = true;
-                ALOGE("%s:starting timer", fn);
-                gSelectCompleteTimer.set(1000, selectCompleteCallBack);
-            }
+void NfcTag::selectNextTag() {
+  static const char fn[] = "NfcTag::selectNextTag";
+  int foundIdx = -1;
+  tNFA_INTF_TYPE rf_intf = NFA_INTERFACE_FRAME;
+  tNFA_STATUS stat = NFA_STATUS_FAILED;
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter, mNumDiscTechList=%x", fn, mNumDiscTechList);
+  for (int i = 0; i < mNumDiscTechList; i++) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: nfa target idx=%d h=0x%X; protocol=0x%X", fn, i,
+                        mTechHandles[i], mTechLibNfcTypes[i]);
+    if ((mTechHandles[selectedId] != mTechHandles[i]) &&
+        (mTechLibNfcTypes[i] != NFA_PROTOCOL_NFC_DEP)) {
+      selectedId = i;
+      foundIdx = i;
+      break;
+    }
+  }
+
+  if (foundIdx != -1) {
+    if (mTechLibNfcTypes[foundIdx] == NFA_PROTOCOL_ISO_DEP) {
+      rf_intf = NFA_INTERFACE_ISO_DEP;
+    } else if (mTechLibNfcTypes[foundIdx] == NFC_PROTOCOL_MIFARE) {
+      rf_intf = NFA_INTERFACE_MIFARE;
+    } else
+      rf_intf = NFA_INTERFACE_FRAME;
+
+    stat =
+        NFA_Select(mTechHandles[foundIdx], mTechLibNfcTypes[foundIdx], rf_intf);
+    if (stat == NFA_STATUS_OK) {
+      LOG(ERROR) << StringPrintf("%s: stat=%x; wait for activated ntf", fn,
+                                 stat);
+#if (NXP_EXTNS == TRUE)
+      {
+        mWaitingForSelect = true;
+        LOG(ERROR) << StringPrintf("%s:starting timer", fn);
+        gSelectCompleteTimer.set(1000, selectCompleteCallBack);
+      }
 #endif
-        }
-        else
-            ALOGE("%s: fail select; error=0x%X", fn, stat);
-    }
-    else
-        ALOGE("%s: only found NFC-DEP technology.", fn);
+    } else
+      LOG(ERROR) << StringPrintf("%s: fail select; error=0x%X", fn, stat);
+  } else
+    LOG(ERROR) << StringPrintf("%s: only found NFC-DEP technology.", fn);
 }
 
-
 /*******************************************************************************
 **
 ** Function:        getT1tMaxMessageSize
@@ -1528,57 +1484,52 @@ void NfcTag::selectNextTag ()
 ** Returns:         Maximum size in octets.
 **
 *******************************************************************************/
-int NfcTag::getT1tMaxMessageSize ()
-{
-    static const char fn [] = "NfcTag::getT1tMaxMessageSize";
-
-    if (mProtocol != NFC_PROTOCOL_T1T)
-    {
-        ALOGE("%s: wrong protocol %u", fn, mProtocol);
-        return 0;
-    }
-    return mtT1tMaxMessageSize;
+int NfcTag::getT1tMaxMessageSize() {
+  static const char fn[] = "NfcTag::getT1tMaxMessageSize";
+
+  if (mProtocol != NFC_PROTOCOL_T1T) {
+    LOG(ERROR) << StringPrintf("%s: wrong protocol %u", fn, mProtocol);
+    return 0;
+  }
+  return mtT1tMaxMessageSize;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        calculateT1tMaxMessageSize
 **
-** Description:     Calculate type-1 tag's max message size based on header ROM bytes.
+** Description:     Calculate type-1 tag's max message size based on header ROM
+*bytes.
 **                  activate: reference to activation data.
 **
 ** Returns:         None
 **
 *******************************************************************************/
-void NfcTag::calculateT1tMaxMessageSize (tNFA_ACTIVATED& activate)
-{
-    static const char fn [] = "NfcTag::calculateT1tMaxMessageSize";
+void NfcTag::calculateT1tMaxMessageSize(tNFA_ACTIVATED& activate) {
+  static const char fn[] = "NfcTag::calculateT1tMaxMessageSize";
 
-    //make sure the tag is type-1
-    if (activate.activate_ntf.protocol != NFC_PROTOCOL_T1T)
-    {
-        mtT1tMaxMessageSize = 0;
-        return;
-    }
+  // make sure the tag is type-1
+  if (activate.activate_ntf.protocol != NFC_PROTOCOL_T1T) {
+    mtT1tMaxMessageSize = 0;
+    return;
+  }
 
-    //examine the first byte of header ROM bytes
-    switch (activate.params.t1t.hr[0])
-    {
+  // examine the first byte of header ROM bytes
+  switch (activate.params.t1t.hr[0]) {
     case RW_T1T_IS_TOPAZ96:
-        mtT1tMaxMessageSize = 90;
-        break;
+      mtT1tMaxMessageSize = 90;
+      break;
     case RW_T1T_IS_TOPAZ512:
-        mtT1tMaxMessageSize = 462;
-        break;
+      mtT1tMaxMessageSize = 462;
+      break;
     default:
-        ALOGE("%s: unknown T1T HR0=%u", fn, activate.params.t1t.hr[0]);
-        mtT1tMaxMessageSize = 0;
-        break;
-    }
+      LOG(ERROR) << StringPrintf("%s: unknown T1T HR0=%u", fn,
+                                 activate.params.t1t.hr[0]);
+      mtT1tMaxMessageSize = 0;
+      break;
+  }
 }
 
-
 /*******************************************************************************
 **
 ** Function:        isMifareUltralight
@@ -1588,33 +1539,31 @@ void NfcTag::calculateT1tMaxMessageSize (tNFA_ACTIVATED& activate)
 ** Returns:         True if tag is Mifare Ultralight.
 **
 *******************************************************************************/
-bool NfcTag::isMifareUltralight ()
-{
-    static const char fn [] = "NfcTag::isMifareUltralight";
-    bool retval = false;
-
-    for (int i =0; i < mNumTechList; i++)
-    {
-        if (mTechParams[i].mode == NFC_DISCOVERY_TYPE_POLL_A)
-        {
-            //see NFC Digital Protocol, section 4.6.3 (SENS_RES); section 4.8.2 (SEL_RES).
-            //see "MF0ICU1 Functional specification MIFARE Ultralight", Rev. 3.4 - 4 February 2008,
-            //section 6.7.
-            if ( (mTechParams[i].param.pa.sens_res[0] == 0x44) &&
-                 (mTechParams[i].param.pa.sens_res[1] == 0) &&
-                 ( (mTechParams[i].param.pa.sel_rsp == 0) || (mTechParams[i].param.pa.sel_rsp == 0x04) ) &&
-                 (mTechParams[i].param.pa.nfcid1[0] == 0x04) )
-            {
-                retval = true;
-            }
-            break;
-        }
-    }
-    ALOGV("%s: return=%u", fn, retval);
-    return retval;
+bool NfcTag::isMifareUltralight() {
+  static const char fn[] = "NfcTag::isMifareUltralight";
+  bool retval = false;
+
+  for (int i = 0; i < mNumTechList; i++) {
+    if (mTechParams[i].mode == NFC_DISCOVERY_TYPE_POLL_A) {
+      // see NFC Digital Protocol, section 4.6.3 (SENS_RES); section 4.8.2
+      // (SEL_RES).
+      // see "MF0ICU1 Functional specification MIFARE Ultralight", Rev. 3.4 - 4
+      // February 2008,
+      // section 6.7.
+      if ((mTechParams[i].param.pa.sens_res[0] == 0x44) &&
+          (mTechParams[i].param.pa.sens_res[1] == 0) &&
+          ((mTechParams[i].param.pa.sel_rsp == 0) ||
+           (mTechParams[i].param.pa.sel_rsp == 0x04)) &&
+          (mTechParams[i].param.pa.nfcid1[0] == 0x04)) {
+        retval = true;
+      }
+      break;
+    }
+  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: return=%u", fn, retval);
+  return retval;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        isMifareDESFire
@@ -1624,32 +1573,27 @@ bool NfcTag::isMifareUltralight ()
 ** Returns:         True if tag is Mifare DESFire.
 **
 *******************************************************************************/
-bool NfcTag::isMifareDESFire ()
-{
-    static const char fn [] = "NfcTag::isMifareDESFire";
-    bool retval = false;
-
-    for (int i =0; i < mNumTechList; i++)
-    {
-        if ( (mTechParams[i].mode == NFC_DISCOVERY_TYPE_POLL_A) ||
-             (mTechParams[i].mode == NFC_DISCOVERY_TYPE_LISTEN_A) ||
-             (mTechParams[i].mode == NFC_DISCOVERY_TYPE_LISTEN_A_ACTIVE) )
-        {
-            /* DESfire has one sak byte and 2 ATQA bytes */
-            if ( (mTechParams[i].param.pa.sens_res[0] == 0x44) &&
-                 (mTechParams[i].param.pa.sens_res[1] == 3) &&
-                 (mTechParams[i].param.pa.sel_rsp == 0x20))
-            {
-                retval = true;
-            }
-            break;
-        }
-    }
-    ALOGV("%s: return=%u", fn, retval);
-    return retval;
+bool NfcTag::isMifareDESFire() {
+  static const char fn[] = "NfcTag::isMifareDESFire";
+  bool retval = false;
+
+  for (int i = 0; i < mNumTechList; i++) {
+    if ((mTechParams[i].mode == NFC_DISCOVERY_TYPE_POLL_A) ||
+        (mTechParams[i].mode == NFC_DISCOVERY_TYPE_LISTEN_A) ||
+        (mTechParams[i].mode == NFC_DISCOVERY_TYPE_LISTEN_A_ACTIVE)) {
+      /* DESfire has one sak byte and 2 ATQA bytes */
+      if ((mTechParams[i].param.pa.sens_res[0] == 0x44) &&
+          (mTechParams[i].param.pa.sens_res[1] == 3) &&
+          (mTechParams[i].param.pa.sel_rsp == 0x20)) {
+        retval = true;
+      }
+      break;
+    }
+  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: return=%u", fn, retval);
+  return retval;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        isFelicaLite
@@ -1660,18 +1604,15 @@ bool NfcTag::isMifareDESFire ()
 **
 *******************************************************************************/
 
-bool NfcTag::isFelicaLite ()
-{
-    return mIsFelicaLite;
-}
-
+bool NfcTag::isFelicaLite() { return mIsFelicaLite; }
 
 /*******************************************************************************
 **
 ** Function:        isT2tNackResponse
 **
 ** Description:     Whether the response is a T2T NACK response.
-**                  See NFC Digital Protocol Technical Specification (2010-11-17).
+**                  See NFC Digital Protocol Technical Specification
+*(2010-11-17).
 **                  Chapter 9 (Type 2 Tag Platform), section 9.6 (READ).
 **                  response: buffer contains T2T response.
 **                  responseLen: length of the response.
@@ -1679,23 +1620,20 @@ bool NfcTag::isFelicaLite ()
 ** Returns:         True if the response is NACK
 **
 *******************************************************************************/
-bool NfcTag::isT2tNackResponse (const uint8_t* response, uint32_t responseLen)
-{
-    static const char fn [] = "NfcTag::isT2tNackResponse";
-    bool isNack = false;
+bool NfcTag::isT2tNackResponse(const uint8_t* response, uint32_t responseLen) {
+  static const char fn[] = "NfcTag::isT2tNackResponse";
+  bool isNack = false;
 
-    if (responseLen == 1)
-    {
-        if (response[0] == 0xA)
-            isNack = false; //an ACK response, so definitely not a NACK
-        else
-            isNack = true; //assume every value is a NACK
-    }
-    ALOGV("%s: return %u", fn, isNack);
-    return isNack;
+  if (responseLen == 1) {
+    if (response[0] == 0xA)
+      isNack = false;  // an ACK response, so definitely not a NACK
+    else
+      isNack = true;  // assume every value is a NACK
+  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: return %u", fn, isNack);
+  return isNack;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        isNdefDetectionTimedOut
@@ -1705,11 +1643,7 @@ bool NfcTag::isT2tNackResponse (const uint8_t* response, uint32_t responseLen)
 ** Returns:         True if NDEF-detection algorithm timed out.
 **
 *******************************************************************************/
-bool NfcTag::isNdefDetectionTimedOut ()
-{
-    return mNdefDetectionTimedOut;
-}
-
+bool NfcTag::isNdefDetectionTimedOut() { return mNdefDetectionTimedOut; }
 
 /*******************************************************************************
 **
@@ -1722,77 +1656,63 @@ bool NfcTag::isNdefDetectionTimedOut ()
 ** Returns:         None
 **
 *******************************************************************************/
-void NfcTag::connectionEventHandler (uint8_t event, tNFA_CONN_EVT_DATA* data)
-{
-    static const char fn [] = "NfcTag::connectionEventHandler";
+void NfcTag::connectionEventHandler(uint8_t event, tNFA_CONN_EVT_DATA* data) {
+  static const char fn[] = "NfcTag::connectionEventHandler";
 
-    switch (event)
-    {
-    case NFA_DISC_RESULT_EVT:
-        {
-            tNFA_DISC_RESULT& disc_result = data->disc_result;
-            if (disc_result.status == NFA_STATUS_OK)
-            {
-                discoverTechnologies (disc_result);
-            }
-        }
-        break;
+  switch (event) {
+    case NFA_DISC_RESULT_EVT: {
+      tNFA_DISC_RESULT& disc_result = data->disc_result;
+      if (disc_result.status == NFA_STATUS_OK) {
+        discoverTechnologies(disc_result);
+      }
+    } break;
 
     case NFA_ACTIVATED_EVT:
-        // Only do tag detection if we are polling and it is not 'EE Direct RF' activation
-        // (which may happen when we are activated as a tag).
-        if (data->activated.activate_ntf.rf_tech_param.mode < NCI_DISCOVERY_TYPE_LISTEN_A
-            && data->activated.activate_ntf.intf_param.type != NFC_INTERFACE_EE_DIRECT_RF)
-        {
-            tNFA_ACTIVATED& activated = data->activated;
-            if (IsSameKovio(activated))
-                break;
-            mIsActivated = true;
-            mProtocol = activated.activate_ntf.protocol;
-            calculateT1tMaxMessageSize (activated);
-            discoverTechnologies (activated);
-            createNativeNfcTag (activated);
-        }
-        break;
+      // Only do tag detection if we are polling and it is not 'EE Direct RF'
+      // activation
+      // (which may happen when we are activated as a tag).
+      if (data->activated.activate_ntf.rf_tech_param.mode <
+              NCI_DISCOVERY_TYPE_LISTEN_A &&
+          data->activated.activate_ntf.intf_param.type !=
+              NFC_INTERFACE_EE_DIRECT_RF) {
+        tNFA_ACTIVATED& activated = data->activated;
+        if (IsSameKovio(activated)) break;
+        mIsActivated = true;
+        mProtocol = activated.activate_ntf.protocol;
+        calculateT1tMaxMessageSize(activated);
+        discoverTechnologies(activated);
+        createNativeNfcTag(activated);
+      }
+      break;
 
     case NFA_DEACTIVATED_EVT:
-        mIsActivated = false;
-        mProtocol = NFC_PROTOCOL_UNKNOWN;
-        resetTechnologies ();
-        break;
-
-    case NFA_READ_CPLT_EVT:
-        {
-            SyncEventGuard g (mReadCompleteEvent);
-            mReadCompletedStatus = data->status;
-            mNdefDetectionTimedOut = data->status != NFA_STATUS_OK;
-            if (mNdefDetectionTimedOut)
-                ALOGE("%s: NDEF detection timed out", fn);
-            mReadCompleteEvent.notifyOne ();
-        }
-        break;
-
-    case NFA_NDEF_DETECT_EVT:
-        {
-            tNFA_NDEF_DETECT& ndef_detect = data->ndef_detect;
-            mNdefDetectionTimedOut = ndef_detect.status == NFA_STATUS_TIMEOUT;
-            if (mNdefDetectionTimedOut)
-                ALOGE("%s: NDEF detection timed out", fn);
-        }
-        break;
-
-    case NFA_ACTIVATED_UPDATE_EVT:
-        {
-            tNFA_ACTIVATED& activated = data->activated;
-            mIsActivated = true;
-            mProtocol = activated.activate_ntf.protocol;
-            discoverTechnologies (activated);
-        }
-        break;
-    }
+      mIsActivated = false;
+      mProtocol = NFC_PROTOCOL_UNKNOWN;
+      resetTechnologies();
+      break;
+
+    case NFA_READ_CPLT_EVT: {
+      SyncEventGuard g(mReadCompleteEvent);
+      mReadCompletedStatus = data->status;
+      mReadCompleteEvent.notifyOne();
+    } break;
+
+    case NFA_NDEF_DETECT_EVT: {
+      tNFA_NDEF_DETECT& ndef_detect = data->ndef_detect;
+      mNdefDetectionTimedOut = ndef_detect.status == NFA_STATUS_TIMEOUT;
+      if (mNdefDetectionTimedOut)
+        LOG(ERROR) << StringPrintf("%s: NDEF detection timed out", fn);
+    } break;
+
+    case NFA_ACTIVATED_UPDATE_EVT: {
+      tNFA_ACTIVATED& activated = data->activated;
+      mIsActivated = true;
+      mProtocol = activated.activate_ntf.protocol;
+      discoverTechnologies(activated);
+    } break;
+  }
 }
 
-
 /*******************************************************************************
 **
 ** Function         setActive
@@ -1802,11 +1722,7 @@ void NfcTag::connectionEventHandler (uint8_t event, tNFA_CONN_EVT_DATA* data)
 ** Returns          None.
 **
 *******************************************************************************/
-void NfcTag::setActive(bool active)
-{
-    mIsActivated = active;
-}
-
+void NfcTag::setActive(bool active) { mIsActivated = active; }
 
 /*******************************************************************************
 **
@@ -1817,14 +1733,12 @@ void NfcTag::setActive(bool active)
 ** Returns:         True if ID is dynamic.
 **
 *******************************************************************************/
-bool NfcTag::isDynamicTagId ()
-{
-    return mIsDynamicTagId &&
-            (mTechList [0] == TARGET_TYPE_ISO14443_4) &&  //type-4 tag
-            (mTechList [1] == TARGET_TYPE_ISO14443_3A);  //tech A
+bool NfcTag::isDynamicTagId() {
+  return mIsDynamicTagId &&
+         (mTechList[0] == TARGET_TYPE_ISO14443_4) &&  // type-4 tag
+         (mTechList[1] == TARGET_TYPE_ISO14443_3A);   // tech A
 }
 
-
 /*******************************************************************************
 **
 ** Function:        resetAllTransceiveTimeouts
@@ -1834,18 +1748,17 @@ bool NfcTag::isDynamicTagId ()
 ** Returns:         none
 **
 *******************************************************************************/
-void NfcTag::resetAllTransceiveTimeouts ()
-{
-    mTechnologyTimeoutsTable [TARGET_TYPE_ISO14443_3A] = 618; //NfcA
-    mTechnologyTimeoutsTable [TARGET_TYPE_ISO14443_3B] = 1000; //NfcB
-    mTechnologyTimeoutsTable [TARGET_TYPE_ISO14443_4] = 618; //ISO-DEP
-    mTechnologyTimeoutsTable [TARGET_TYPE_FELICA] = 255; //Felica
-    mTechnologyTimeoutsTable [TARGET_TYPE_ISO15693] = 1000;//NfcV
-    mTechnologyTimeoutsTable [TARGET_TYPE_NDEF] = 1000;
-    mTechnologyTimeoutsTable [TARGET_TYPE_NDEF_FORMATABLE] = 1000;
-    mTechnologyTimeoutsTable [TARGET_TYPE_MIFARE_CLASSIC] = 618; //MifareClassic
-    mTechnologyTimeoutsTable [TARGET_TYPE_MIFARE_UL] = 618; //MifareUltralight
-    mTechnologyTimeoutsTable [TARGET_TYPE_KOVIO_BARCODE] = 1000; //NfcBarcode
+void NfcTag::resetAllTransceiveTimeouts() {
+  mTechnologyTimeoutsTable[TARGET_TYPE_ISO14443_3A] = 618;   // NfcA
+  mTechnologyTimeoutsTable[TARGET_TYPE_ISO14443_3B] = 1000;  // NfcB
+  mTechnologyTimeoutsTable[TARGET_TYPE_ISO14443_4] = 618;    // ISO-DEP
+  mTechnologyTimeoutsTable[TARGET_TYPE_FELICA] = 255;        // Felica
+  mTechnologyTimeoutsTable[TARGET_TYPE_V] = 1000;            // NfcV
+  mTechnologyTimeoutsTable[TARGET_TYPE_NDEF] = 1000;
+  mTechnologyTimeoutsTable[TARGET_TYPE_NDEF_FORMATABLE] = 1000;
+  mTechnologyTimeoutsTable[TARGET_TYPE_MIFARE_CLASSIC] = 618;  // MifareClassic
+  mTechnologyTimeoutsTable[TARGET_TYPE_MIFARE_UL] = 618;  // MifareUltralight
+  mTechnologyTimeoutsTable[TARGET_TYPE_KOVIO_BARCODE] = 1000;  // NfcBarcode
 }
 
 /*******************************************************************************
@@ -1853,41 +1766,40 @@ void NfcTag::resetAllTransceiveTimeouts ()
 ** Function:        getTransceiveTimeout
 **
 ** Description:     Get the timeout value for one technology.
-**                  techId: one of the values in TARGET_TYPE_* defined in NfcJniUtil.h
+**                  techId: one of the values in TARGET_TYPE_* defined in
+*NfcJniUtil.h
 **
 ** Returns:         Timeout value in millisecond.
 **
 *******************************************************************************/
-int NfcTag::getTransceiveTimeout (int techId)
-{
-    static const char fn [] = "NfcTag::getTransceiveTimeout";
-    int retval = 1000;
-    if ((techId > 0) && (techId < (int) mTechnologyTimeoutsTable.size()))
-        retval = mTechnologyTimeoutsTable [techId];
-    else
-        ALOGE("%s: invalid tech=%d", fn, techId);
-    return retval;
+int NfcTag::getTransceiveTimeout(int techId) {
+  static const char fn[] = "NfcTag::getTransceiveTimeout";
+  int retval = 1000;
+  if ((techId > 0) && (techId < (int)mTechnologyTimeoutsTable.size()))
+    retval = mTechnologyTimeoutsTable[techId];
+  else
+    LOG(ERROR) << StringPrintf("%s: invalid tech=%d", fn, techId);
+  return retval;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        setTransceiveTimeout
 **
 ** Description:     Set the timeout value for one technology.
-**                  techId: one of the values in TARGET_TYPE_* defined in NfcJniUtil.h
+**                  techId: one of the values in TARGET_TYPE_* defined in
+*NfcJniUtil.h
 **                  timeout: timeout value in millisecond.
 **
 ** Returns:         Timeout value.
 **
 *******************************************************************************/
-void NfcTag::setTransceiveTimeout (int techId, int timeout)
-{
-    static const char fn [] = "NfcTag::setTransceiveTimeout";
-    if ((techId >= 0) && (techId < (int) mTechnologyTimeoutsTable.size()))
-        mTechnologyTimeoutsTable [techId] = timeout;
-    else
-        ALOGE("%s: invalid tech=%d", fn, techId);
+void NfcTag::setTransceiveTimeout(int techId, int timeout) {
+  static const char fn[] = "NfcTag::setTransceiveTimeout";
+  if ((techId >= 0) && (techId < (int)mTechnologyTimeoutsTable.size()))
+    mTechnologyTimeoutsTable[techId] = timeout;
+  else
+    LOG(ERROR) << StringPrintf("%s: invalid tech=%d", fn, techId);
 }
 
 /*******************************************************************************
@@ -1899,10 +1811,7 @@ void NfcTag::setTransceiveTimeout (int techId, int timeout)
 ** Returns:         True if tag is activated.
 **
 *******************************************************************************/
-bool NfcTag::isEzLinkTagActivated ()
-{
-    return mEzLinkTypeTag;
-}
+bool NfcTag::isEzLinkTagActivated() { return mEzLinkTypeTag; }
 
 /*******************************************************************************
 **
@@ -1913,10 +1822,7 @@ bool NfcTag::isEzLinkTagActivated ()
 ** Returns:         True if tag is activated.
 **
 *******************************************************************************/
-bool NfcTag::isCashBeeActivated ()
-{
-    return mCashbeeDetected;
-}
+bool NfcTag::isCashBeeActivated() { return mCashbeeDetected; }
 
 /*******************************************************************************
 **
@@ -1927,25 +1833,21 @@ bool NfcTag::isCashBeeActivated ()
 ** Returns:         True if tag is Type B.
 **
 *******************************************************************************/
-bool NfcTag::isTypeBTag ()
-{
-    static const char fn [] = "NfcTag::isTypeBTag";
-    bool retval = false;
-
-    for (int i =0; i < mNumTechList; i++)
-    {
-        if ( (mTechParams[i].mode == NFC_DISCOVERY_TYPE_POLL_B) ||
-             (mTechParams[i].mode == NFC_DISCOVERY_TYPE_LISTEN_B) )
-        {
-            retval = true;
-            break;
-        }
-    }
-    ALOGV("%s: return=%u", fn, retval);
-    return retval;
+bool NfcTag::isTypeBTag() {
+  static const char fn[] = "NfcTag::isTypeBTag";
+  bool retval = false;
+
+  for (int i = 0; i < mNumTechList; i++) {
+    if ((mTechParams[i].mode == NFC_DISCOVERY_TYPE_POLL_B) ||
+        (mTechParams[i].mode == NFC_DISCOVERY_TYPE_LISTEN_B)) {
+      retval = true;
+      break;
+    }
+  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: return=%u", fn, retval);
+  return retval;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        getPresenceCheckAlgorithm
@@ -1955,12 +1857,10 @@ bool NfcTag::isTypeBTag ()
 ** Returns:         Presence-check algorithm.
 **
 *******************************************************************************/
-tNFA_RW_PRES_CHK_OPTION NfcTag::getPresenceCheckAlgorithm ()
-{
-    return mPresenceCheckAlgorithm;
+tNFA_RW_PRES_CHK_OPTION NfcTag::getPresenceCheckAlgorithm() {
+  return mPresenceCheckAlgorithm;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        isInfineonMyDMove
@@ -1970,31 +1870,25 @@ tNFA_RW_PRES_CHK_OPTION NfcTag::getPresenceCheckAlgorithm ()
 ** Returns:         True if tag is Infineon My-D Move.
 **
 *******************************************************************************/
-bool NfcTag::isInfineonMyDMove ()
-{
-    static const char fn [] = "NfcTag::isInfineonMyDMove";
-    bool retval = false;
-
-    for (int i =0; i < mNumTechList; i++)
-    {
-        if (mTechParams[i].mode == NFC_DISCOVERY_TYPE_POLL_A)
-        {
-            //see Infineon my-d move, my-d move NFC, SLE 66R01P, SLE 66R01PN,
-            //Short Product Information, 2011-11-24, section 3.5
-            if (mTechParams[i].param.pa.nfcid1[0] == 0x05)
-            {
-                uint8_t highNibble = mTechParams[i].param.pa.nfcid1[1] & 0xF0;
-                if (highNibble == 0x30)
-                    retval = true;
-            }
-            break;
-        }
-    }
-    ALOGV("%s: return=%u", fn, retval);
-    return retval;
+bool NfcTag::isInfineonMyDMove() {
+  static const char fn[] = "NfcTag::isInfineonMyDMove";
+  bool retval = false;
+
+  for (int i = 0; i < mNumTechList; i++) {
+    if (mTechParams[i].mode == NFC_DISCOVERY_TYPE_POLL_A) {
+      // see Infineon my-d move, my-d move NFC, SLE 66R01P, SLE 66R01PN,
+      // Short Product Information, 2011-11-24, section 3.5
+      if (mTechParams[i].param.pa.nfcid1[0] == 0x05) {
+        uint8_t highNibble = mTechParams[i].param.pa.nfcid1[1] & 0xF0;
+        if (highNibble == 0x30) retval = true;
+      }
+      break;
+    }
+  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: return=%u", fn, retval);
+  return retval;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        isKovioType2Tag
@@ -2004,44 +1898,36 @@ bool NfcTag::isInfineonMyDMove ()
 ** Returns:         True if tag is Kovio Type-2 tag.
 **
 *******************************************************************************/
-bool NfcTag::isKovioType2Tag ()
-{
-    static const char fn [] = "NfcTag::isKovioType2Tag";
-    bool retval = false;
-
-    for (int i =0; i < mNumTechList; i++)
-    {
-        if (mTechParams[i].mode == NFC_DISCOVERY_TYPE_POLL_A)
-        {
-            //Kovio 2Kb RFID Tag, Functional Specification,
-            //March 2, 2012, v2.0, section 8.3.
-            if (mTechParams[i].param.pa.nfcid1[0] == 0x37)
-                retval = true;
-            break;
-        }
-    }
-    ALOGV("%s: return=%u", fn, retval);
-    return retval;
+bool NfcTag::isKovioType2Tag() {
+  static const char fn[] = "NfcTag::isKovioType2Tag";
+  bool retval = false;
+
+  for (int i = 0; i < mNumTechList; i++) {
+    if (mTechParams[i].mode == NFC_DISCOVERY_TYPE_POLL_A) {
+      // Kovio 2Kb RFID Tag, Functional Specification,
+      // March 2, 2012, v2.0, section 8.3.
+      if (mTechParams[i].param.pa.nfcid1[0] == 0x37) retval = true;
+      break;
+    }
+  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: return=%u", fn, retval);
+  return retval;
 }
 
-
-void NfcTag::getTypeATagUID(uint8_t **uid, uint32_t *len)
-{
-    for (int i =0; i < mNumTechList; i++)
-    {
-        if ( (mTechParams[i].mode == NFC_DISCOVERY_TYPE_POLL_A) ||
-             (mTechParams[i].mode == NFC_DISCOVERY_TYPE_LISTEN_A) )
-        {
-            *len = mTechParams [i].param.pa.nfcid1_len;
-            *uid = mTechParams [0].param.pa.nfcid1;
-            return;
-        }
+void NfcTag::getTypeATagUID(uint8_t** uid, uint32_t* len) {
+  for (int i = 0; i < mNumTechList; i++) {
+    if ((mTechParams[i].mode == NFC_DISCOVERY_TYPE_POLL_A) ||
+        (mTechParams[i].mode == NFC_DISCOVERY_TYPE_LISTEN_A)) {
+      *len = mTechParams[i].param.pa.nfcid1_len;
+      *uid = mTechParams[0].param.pa.nfcid1;
+      return;
     }
+  }
 
-    *len = 0;
-    *uid = NULL;
+  *len = 0;
+  *uid = NULL;
 }
-#if(NXP_EXTNS == TRUE)
+#if (NXP_EXTNS == TRUE)
 /*******************************************************************************
 **
 ** Function:        selectCompleteStatus
@@ -2051,15 +1937,13 @@ void NfcTag::getTypeATagUID(uint8_t **uid, uint32_t *len)
 ** Returns:         None
 **
 *******************************************************************************/
-void NfcTag::selectCompleteStatus(bool status)
-{
-
-    if(mWaitingForSelect == true)
-    {
-        ALOGV("selectCompleteStatus=%u", status);
-        gSelectCompleteTimer.kill();
-        mWaitingForSelect = false;
-    }
+void NfcTag::selectCompleteStatus(bool status) {
+  if (mWaitingForSelect == true) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("selectCompleteStatus=%u", status);
+    gSelectCompleteTimer.kill();
+    mWaitingForSelect = false;
+  }
 }
 
 /*******************************************************************************
@@ -2071,14 +1955,11 @@ void NfcTag::selectCompleteStatus(bool status)
 ** Returns:         None
 **
 *******************************************************************************/
-void selectCompleteCallBack(union sigval)
-{
-
-    if(NfcTag::getInstance().mWaitingForSelect == true)
-    {
-        ALOGV("selectCompleteCallBack");
-        NfcTag::getInstance().mWaitingForSelect = false;
-        NFA_Deactivate (false);
-    }
+void selectCompleteCallBack(union sigval) {
+  if (NfcTag::getInstance().mWaitingForSelect == true) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("selectCompleteCallBack");
+    NfcTag::getInstance().mWaitingForSelect = false;
+    NFA_Deactivate(false);
+  }
 }
 #endif
diff --git a/nci/jni/NfcTag.h b/nci/jni/NfcTag.h
index 8ed03427..1a221db5 100644
--- a/nci/jni/NfcTag.h
+++ b/nci/jni/NfcTag.h
@@ -24,657 +24,651 @@
  */
 
 #pragma once
-#include "SyncEvent.h"
-#include "NfcJniUtil.h"
 #include <vector>
-extern "C"
-{
-    #include "nfa_rw_api.h"
-}
-
-typedef struct activationParams{
-    int mTechParams;
-    int mTechLibNfcTypes;
+#include "NfcJniUtil.h"
+#include "SyncEvent.h"
+#include "nfa_rw_api.h"
+
+#define MIN_FWI (1)
+#define MAX_FWI (14)
+#define MIN_TRANSCEIVE_TIMEOUT_IN_MILLISEC (500.0)
+
+typedef struct activationParams {
+  int mTechParams;
+  int mTechLibNfcTypes;
 } activationParams_t;
 
-class NfcTag
-{
-public:
-    enum ActivationState {Idle, Sleep, Active};
-    static const int MAX_NUM_TECHNOLOGY = 11; //max number of technologies supported by one or more tags
-    int mTechList [MAX_NUM_TECHNOLOGY]; //array of NFC technologies according to NFC service
-    int mTechHandles [MAX_NUM_TECHNOLOGY]; //array of tag handles according to NFC service
-    int mTechLibNfcTypes [MAX_NUM_TECHNOLOGY]; //array of detailed tag types according to NFC service
-    int mNumTechList; //current number of NFC technologies in the list
-    int mNumDiscNtf;
-    int mNumDiscTechList;
-    int mTechListIndex;
-    bool mNfcDisableinProgress;
-    bool mCashbeeDetected;
-    bool mEzLinkTypeTag;
-    activationParams_t mActivationParams_t;
-#if(NXP_EXTNS == TRUE)
-    bool mWaitingForSelect;
-    bool mIsMultiProtocolTag;
+class NfcTag {
+ public:
+  enum ActivationState { Idle, Sleep, Active };
+  static const int MAX_NUM_TECHNOLOGY =
+      11;  // max number of technologies supported by one or more tags
+  int mTechList[MAX_NUM_TECHNOLOGY];  // array of NFC technologies according to
+                                      // NFC service
+  int mTechHandles[MAX_NUM_TECHNOLOGY];  // array of tag handles according to
+                                         // NFC service
+  int mTechLibNfcTypes[MAX_NUM_TECHNOLOGY];  // array of detailed tag types
+                                             // according to NFC service
+  int mNumTechList;  // current number of NFC technologies in the list
+  int mNumDiscNtf;
+  int mNumDiscTechList;
+  int mTechListIndex;
+  bool mNfcDisableinProgress;
+  bool mCashbeeDetected;
+  bool mEzLinkTypeTag;
+  activationParams_t mActivationParams_t;
+#if (NXP_EXTNS == TRUE)
+  bool mWaitingForSelect;
+  bool mIsMultiProtocolTag;
 #endif
-   /*******************************************************************************
-    **
-    ** Function:        NfcTag
-    **
-    ** Description:     Initialize member variables.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    NfcTag ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        getInstance
-    **
-    ** Description:     Get a reference to the singleton NfcTag object.
-    **
-    ** Returns:         Reference to NfcTag object.
-    **
-    *******************************************************************************/
-    static NfcTag& getInstance ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        initialize
-    **
-    ** Description:     Reset member variables.
-    **                  native: Native data.
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void initialize (nfc_jni_native_data* native);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        abort
-    **
-    ** Description:     Unblock all operations.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void abort ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        connectionEventHandler
-    **
-    ** Description:     Handle connection-related events.
-    **                  event: event code.
-    **                  data: pointer to event data.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void connectionEventHandler (uint8_t event, tNFA_CONN_EVT_DATA* data);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        isActivated
-    **
-    ** Description:     Is tag activated?
-    **
-    ** Returns:         True if tag is activated.
-    **
-    *******************************************************************************/
-    bool isActivated ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        getActivationState
-    **
-    ** Description:     What is the current state: Idle, Sleep, or Activated.
-    **
-    ** Returns:         Idle, Sleep, or Activated.
-    **
-    *******************************************************************************/
-    ActivationState getActivationState ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        setDeactivationState
-    **
-    ** Description:     Set the current state: Idle or Sleep.
-    **                  deactivated: state of deactivation.
-    **
-    ** Returns:         None.
-    **
-    *******************************************************************************/
-    void setDeactivationState (tNFA_DEACTIVATED& deactivated);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        setActivationState
-    **
-    ** Description:     Set the current state to Active.
-    **
-    ** Returns:         None.
-    **
-    *******************************************************************************/
-    void setActivationState ();
-
-    /*******************************************************************************
-    **
-    ** Function:        getProtocol
-    **
-    ** Description:     Get the protocol of the current tag.
-    **
-    ** Returns:         Protocol number.
-    **
-    *******************************************************************************/
-    tNFC_PROTOCOL getProtocol ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        isP2pDiscovered
-    **
-    ** Description:     Does the peer support P2P?
-    **
-    ** Returns:         True if the peer supports P2P.
-    **
-    *******************************************************************************/
-    bool isP2pDiscovered ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        selectP2p
-    **
-    ** Description:     Select the preferred P2P technology if there is a choice.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void selectP2p ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        selectFirstTag
-    **
-    ** Description:     When multiple tags are discovered, just select the first one to activate.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void selectFirstTag ();
-
-    /*******************************************************************************
-    **
-    ** Function:        selectNextTag
-    **
-    ** Description:     When multiple tags are discovered, selects the Nex one to activate.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void selectNextTag ();
-
-    /*******************************************************************************
-    **
-    ** Function:        getT1tMaxMessageSize
-    **
-    ** Description:     Get the maximum size (octet) that a T1T can store.
-    **
-    ** Returns:         Maximum size in octets.
-    **
-    *******************************************************************************/
-    int getT1tMaxMessageSize ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        isMifareUltralight
-    **
-    ** Description:     Whether the currently activated tag is Mifare Ultralight.
-    **
-    ** Returns:         True if tag is Mifare Ultralight.
-    **
-    *******************************************************************************/
-    bool isMifareUltralight ();
-
-    /*******************************************************************************
-    **
-    ** Function:        isMifareDESFire
-    **
-    ** Description:     Whether the currently activated tag is Mifare Ultralight.
-    **
-    ** Returns:         True if tag is Mifare Ultralight.
-    **
-    *******************************************************************************/
-    bool isMifareDESFire ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        isFelicaLite
-    **
-    ** Description:     Whether the currently activated tag is Felica Lite.
-    **
-    ** Returns:         True if tag is Felica Lite.
-    **
-    *******************************************************************************/
-    bool isFelicaLite ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        isT2tNackResponse
-    **
-    ** Description:     Whether the response is a T2T NACK response.
-    **                  See NFC Digital Protocol Technical Specification (2010-11-17).
-    **                  Chapter 9 (Type 2 Tag Platform), section 9.6 (READ).
-    **                  response: buffer contains T2T response.
-    **                  responseLen: length of the response.
-    **
-    ** Returns:         True if the response is NACK
-    **
-    *******************************************************************************/
-    bool isT2tNackResponse (const uint8_t* response, uint32_t responseLen);
-
-    /*******************************************************************************
-    **
-    ** Function:        isNdefDetectionTimedOut
-    **
-    ** Description:     Whether NDEF-detection algorithm has timed out.
-    **
-    ** Returns:         True if NDEF-detection algorithm timed out.
-    **
-    *******************************************************************************/
-    bool isNdefDetectionTimedOut ();
-
-
-    /*******************************************************************************
-    **
-    ** Function         setActive
-    **
-    ** Description      Sets the active state for the object
-    **
-    ** Returns          None.
-    **
-    *******************************************************************************/
-    void setActive(bool active);
-
-    /*******************************************************************************
-    **
-    ** Function:        isDynamicTagId
-    **
-    ** Description:     Whether a tag has a dynamic tag ID.
-    **
-    ** Returns:         True if ID is dynamic.
-    **
-    *******************************************************************************/
-    bool isDynamicTagId ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        resetAllTransceiveTimeouts
-    **
-    ** Description:     Reset all timeouts for all technologies to default values.
-    **
-    ** Returns:         none
-    **
-    *******************************************************************************/
-    void resetAllTransceiveTimeouts ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        isDefaultTransceiveTimeout
-    **
-    ** Description:     Is the timeout value for a technology the default value?
-    **                  techId: one of the values in TARGET_TYPE_* defined in NfcJniUtil.h.
-    **                  timeout: Check this value against the default value.
-    **
-    ** Returns:         True if timeout is equal to the default value.
-    **
-    *******************************************************************************/
-    bool isDefaultTransceiveTimeout (int techId, int timeout);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        getTransceiveTimeout
-    **
-    ** Description:     Get the timeout value for one technology.
-    **                  techId: one of the values in TARGET_TYPE_* defined in NfcJniUtil.h
-    **
-    ** Returns:         Timeout value in millisecond.
-    **
-    *******************************************************************************/
-    int getTransceiveTimeout (int techId);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        setTransceiveTimeout
-    **
-    ** Description:     Set the timeout value for one technology.
-    **                  techId: one of the values in TARGET_TYPE_* defined in NfcJniUtil.h
-    **                  timeout: timeout value in millisecond.
-    **
-    ** Returns:         Timeout value.
-    **
-    *******************************************************************************/
-    void setTransceiveTimeout (int techId, int timeout);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        getPresenceCheckAlgorithm
-    **
-    ** Description:     Get presence-check algorithm from .conf file.
-    **
-    ** Returns:         Presence-check algorithm.
-    **
-    *******************************************************************************/
-    tNFA_RW_PRES_CHK_OPTION getPresenceCheckAlgorithm ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        isInfineonMyDMove
-    **
-    ** Description:     Whether the currently activated tag is Infineon My-D Move.
-    **
-    ** Returns:         True if tag is Infineon My-D Move.
-    **
-    *******************************************************************************/
-    bool isInfineonMyDMove ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        isKovioType2Tag
-    **
-    ** Description:     Whether the currently activated tag is Kovio 2Kb RFID tag.
-    **                  It is a NFC Forum type-2 tag.
-    **
-    ** Returns:         True if tag is Kovio 2Kb RFID tag.
-    **
-    *******************************************************************************/
-    bool isKovioType2Tag ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        isTypeBTag
-    **
-    ** Description:     Whether the currently activated tag is Type B.
-    **
-    ** Returns:         True if tag is Type B.
-    **
-    *******************************************************************************/
-    bool isTypeBTag ();
-
-    /*******************************************************************************
-    **
-    ** Function:        getTypeATagUID
-    **
-    ** Description:     Get the UID of TypeA Tag.
-    **
-    ** Returns:         UID in case of TypeA Tag otherwise NULL..
-    **
-    *******************************************************************************/
-    void getTypeATagUID(uint8_t **uid, uint32_t *len);
-
-    /*******************************************************************************
-    **
-    ** Function:        checkNextValidProtocol
-    **
-    ** Description:     When multiple tags are discovered, check next valid protocol
-    **
-    ** Returns:         id
-    **
-    *******************************************************************************/
-    int checkNextValidProtocol(void );
-
-    /*******************************************************************************
-    **
-    ** Function:        isEzLinkTagActivated
-    **
-    ** Description:     checks if EzLinkTag tag is detected
-    **
-    ** Returns:         True if tag is activated.
-    **
-    *******************************************************************************/
-    bool isEzLinkTagActivated ();
-
-    /*******************************************************************************
-    **
-    ** Function:        isCashBeeActivated
-    **
-    ** Description:     checks if cashbee tag is detected
-    **
-    ** Returns:         True if tag is activated.
-    **
-    *******************************************************************************/
-    bool isCashBeeActivated ();
-    /*******************************************************************************
-    **
-    ** Function:        storeActivationParams
-    **
-    ** Description:     stores tag activation parameters for backup
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void storeActivationParams();
-#if(NXP_EXTNS == TRUE)
-    /*******************************************************************************
-    **
-    ** Function:        selectCompleteStatus
-    **
-    ** Description:     Notify whether tag select is success/failure
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void selectCompleteStatus(bool status);
+  /*******************************************************************************
+   **
+   ** Function:        NfcTag
+   **
+   ** Description:     Initialize member variables.
+   **
+   ** Returns:         None
+   **
+   *******************************************************************************/
+  NfcTag();
+
+  /*******************************************************************************
+  **
+  ** Function:        getInstance
+  **
+  ** Description:     Get a reference to the singleton NfcTag object.
+  **
+  ** Returns:         Reference to NfcTag object.
+  **
+  *******************************************************************************/
+  static NfcTag& getInstance();
+
+  /*******************************************************************************
+  **
+  ** Function:        initialize
+  **
+  ** Description:     Reset member variables.
+  **                  native: Native data.
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void initialize(nfc_jni_native_data* native);
+
+  /*******************************************************************************
+  **
+  ** Function:        abort
+  **
+  ** Description:     Unblock all operations.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void abort();
+
+  /*******************************************************************************
+  **
+  ** Function:        connectionEventHandler
+  **
+  ** Description:     Handle connection-related events.
+  **                  event: event code.
+  **                  data: pointer to event data.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void connectionEventHandler(uint8_t event, tNFA_CONN_EVT_DATA* data);
+
+  /*******************************************************************************
+  **
+  ** Function:        isActivated
+  **
+  ** Description:     Is tag activated?
+  **
+  ** Returns:         True if tag is activated.
+  **
+  *******************************************************************************/
+  bool isActivated();
+
+  /*******************************************************************************
+  **
+  ** Function:        getActivationState
+  **
+  ** Description:     What is the current state: Idle, Sleep, or Activated.
+  **
+  ** Returns:         Idle, Sleep, or Activated.
+  **
+  *******************************************************************************/
+  ActivationState getActivationState();
+
+  /*******************************************************************************
+  **
+  ** Function:        setDeactivationState
+  **
+  ** Description:     Set the current state: Idle or Sleep.
+  **                  deactivated: state of deactivation.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  void setDeactivationState(tNFA_DEACTIVATED& deactivated);
+
+  /*******************************************************************************
+  **
+  ** Function:        setActivationState
+  **
+  ** Description:     Set the current state to Active.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  void setActivationState();
+
+  /*******************************************************************************
+  **
+  ** Function:        getProtocol
+  **
+  ** Description:     Get the protocol of the current tag.
+  **
+  ** Returns:         Protocol number.
+  **
+  *******************************************************************************/
+  tNFC_PROTOCOL getProtocol();
+
+  /*******************************************************************************
+  **
+  ** Function:        isP2pDiscovered
+  **
+  ** Description:     Does the peer support P2P?
+  **
+  ** Returns:         True if the peer supports P2P.
+  **
+  *******************************************************************************/
+  bool isP2pDiscovered();
+
+  /*******************************************************************************
+  **
+  ** Function:        selectP2p
+  **
+  ** Description:     Select the preferred P2P technology if there is a choice.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void selectP2p();
+
+  /*******************************************************************************
+  **
+  ** Function:        selectFirstTag
+  **
+  ** Description:     When multiple tags are discovered, just select the first
+  *one to activate.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void selectFirstTag();
+
+  /*******************************************************************************
+  **
+  ** Function:        selectNextTag
+  **
+  ** Description:     When multiple tags are discovered, selects the Nex one to
+  *activate.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void selectNextTag();
+
+  /*******************************************************************************
+  **
+  ** Function:        getT1tMaxMessageSize
+  **
+  ** Description:     Get the maximum size (octet) that a T1T can store.
+  **
+  ** Returns:         Maximum size in octets.
+  **
+  *******************************************************************************/
+  int getT1tMaxMessageSize();
+
+  /*******************************************************************************
+  **
+  ** Function:        isMifareUltralight
+  **
+  ** Description:     Whether the currently activated tag is Mifare Ultralight.
+  **
+  ** Returns:         True if tag is Mifare Ultralight.
+  **
+  *******************************************************************************/
+  bool isMifareUltralight();
+
+  /*******************************************************************************
+  **
+  ** Function:        isMifareDESFire
+  **
+  ** Description:     Whether the currently activated tag is Mifare Ultralight.
+  **
+  ** Returns:         True if tag is Mifare Ultralight.
+  **
+  *******************************************************************************/
+  bool isMifareDESFire();
+
+  /*******************************************************************************
+  **
+  ** Function:        isFelicaLite
+  **
+  ** Description:     Whether the currently activated tag is Felica Lite.
+  **
+  ** Returns:         True if tag is Felica Lite.
+  **
+  *******************************************************************************/
+  bool isFelicaLite();
+
+  /*******************************************************************************
+  **
+  ** Function:        isT2tNackResponse
+  **
+  ** Description:     Whether the response is a T2T NACK response.
+  **                  See NFC Digital Protocol Technical Specification
+  *(2010-11-17).
+  **                  Chapter 9 (Type 2 Tag Platform), section 9.6 (READ).
+  **                  response: buffer contains T2T response.
+  **                  responseLen: length of the response.
+  **
+  ** Returns:         True if the response is NACK
+  **
+  *******************************************************************************/
+  bool isT2tNackResponse(const uint8_t* response, uint32_t responseLen);
+
+  /*******************************************************************************
+  **
+  ** Function:        isNdefDetectionTimedOut
+  **
+  ** Description:     Whether NDEF-detection algorithm has timed out.
+  **
+  ** Returns:         True if NDEF-detection algorithm timed out.
+  **
+  *******************************************************************************/
+  bool isNdefDetectionTimedOut();
+
+  /*******************************************************************************
+  **
+  ** Function         setActive
+  **
+  ** Description      Sets the active state for the object
+  **
+  ** Returns          None.
+  **
+  *******************************************************************************/
+  void setActive(bool active);
+
+  /*******************************************************************************
+  **
+  ** Function:        isDynamicTagId
+  **
+  ** Description:     Whether a tag has a dynamic tag ID.
+  **
+  ** Returns:         True if ID is dynamic.
+  **
+  *******************************************************************************/
+  bool isDynamicTagId();
+
+  /*******************************************************************************
+  **
+  ** Function:        resetAllTransceiveTimeouts
+  **
+  ** Description:     Reset all timeouts for all technologies to default values.
+  **
+  ** Returns:         none
+  **
+  *******************************************************************************/
+  void resetAllTransceiveTimeouts();
+
+  /*******************************************************************************
+  **
+  ** Function:        isDefaultTransceiveTimeout
+  **
+  ** Description:     Is the timeout value for a technology the default value?
+  **                  techId: one of the values in TARGET_TYPE_* defined in
+  *NfcJniUtil.h.
+  **                  timeout: Check this value against the default value.
+  **
+  ** Returns:         True if timeout is equal to the default value.
+  **
+  *******************************************************************************/
+  bool isDefaultTransceiveTimeout(int techId, int timeout);
+
+  /*******************************************************************************
+  **
+  ** Function:        getTransceiveTimeout
+  **
+  ** Description:     Get the timeout value for one technology.
+  **                  techId: one of the values in TARGET_TYPE_* defined in
+  *NfcJniUtil.h
+  **
+  ** Returns:         Timeout value in millisecond.
+  **
+  *******************************************************************************/
+  int getTransceiveTimeout(int techId);
+
+  /*******************************************************************************
+  **
+  ** Function:        setTransceiveTimeout
+  **
+  ** Description:     Set the timeout value for one technology.
+  **                  techId: one of the values in TARGET_TYPE_* defined in
+  *NfcJniUtil.h
+  **                  timeout: timeout value in millisecond.
+  **
+  ** Returns:         Timeout value.
+  **
+  *******************************************************************************/
+  void setTransceiveTimeout(int techId, int timeout);
+
+  /*******************************************************************************
+  **
+  ** Function:        getPresenceCheckAlgorithm
+  **
+  ** Description:     Get presence-check algorithm from .conf file.
+  **
+  ** Returns:         Presence-check algorithm.
+  **
+  *******************************************************************************/
+  tNFA_RW_PRES_CHK_OPTION getPresenceCheckAlgorithm();
+
+  /*******************************************************************************
+  **
+  ** Function:        isInfineonMyDMove
+  **
+  ** Description:     Whether the currently activated tag is Infineon My-D Move.
+  **
+  ** Returns:         True if tag is Infineon My-D Move.
+  **
+  *******************************************************************************/
+  bool isInfineonMyDMove();
+
+  /*******************************************************************************
+  **
+  ** Function:        isKovioType2Tag
+  **
+  ** Description:     Whether the currently activated tag is Kovio 2Kb RFID tag.
+  **                  It is a NFC Forum type-2 tag.
+  **
+  ** Returns:         True if tag is Kovio 2Kb RFID tag.
+  **
+  *******************************************************************************/
+  bool isKovioType2Tag();
+
+  /*******************************************************************************
+  **
+  ** Function:        isTypeBTag
+  **
+  ** Description:     Whether the currently activated tag is Type B.
+  **
+  ** Returns:         True if tag is Type B.
+  **
+  *******************************************************************************/
+  bool isTypeBTag();
+
+  /*******************************************************************************
+  **
+  ** Function:        getTypeATagUID
+  **
+  ** Description:     Get the UID of TypeA Tag.
+  **
+  ** Returns:         UID in case of TypeA Tag otherwise NULL..
+  **
+  *******************************************************************************/
+  void getTypeATagUID(uint8_t** uid, uint32_t* len);
+
+  /*******************************************************************************
+  **
+  ** Function:        checkNextValidProtocol
+  **
+  ** Description:     When multiple tags are discovered, check next valid
+  *protocol
+  **
+  ** Returns:         id
+  **
+  *******************************************************************************/
+  int checkNextValidProtocol(void);
+
+  /*******************************************************************************
+  **
+  ** Function:        isEzLinkTagActivated
+  **
+  ** Description:     checks if EzLinkTag tag is detected
+  **
+  ** Returns:         True if tag is activated.
+  **
+  *******************************************************************************/
+  bool isEzLinkTagActivated();
+
+  /*******************************************************************************
+  **
+  ** Function:        isCashBeeActivated
+  **
+  ** Description:     checks if cashbee tag is detected
+  **
+  ** Returns:         True if tag is activated.
+  **
+  *******************************************************************************/
+  bool isCashBeeActivated();
+  /*******************************************************************************
+  **
+  ** Function:        storeActivationParams
+  **
+  ** Description:     stores tag activation parameters for backup
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void storeActivationParams();
+#if (NXP_EXTNS == TRUE)
+  /*******************************************************************************
+  **
+  ** Function:        selectCompleteStatus
+  **
+  ** Description:     Notify whether tag select is success/failure
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void selectCompleteStatus(bool status);
 #endif
-private:
-    std::vector<int> mTechnologyTimeoutsTable;
-    std::vector<int> mTechnologyDefaultTimeoutsTable;
-    nfc_jni_native_data* mNativeData;
-    bool mIsActivated;
-    ActivationState mActivationState;
-    tNFC_PROTOCOL mProtocol;
-    int mtT1tMaxMessageSize; //T1T max NDEF message size
-    tNFA_STATUS mReadCompletedStatus;
-    int mLastKovioUidLen;   // len of uid of last Kovio tag activated
-    bool mNdefDetectionTimedOut; // whether NDEF detection algorithm timed out
-    tNFC_RF_TECH_PARAMS mTechParams [MAX_NUM_TECHNOLOGY]; //array of technology parameters
-    SyncEvent mReadCompleteEvent;
-    struct timespec mLastKovioTime; // time of last Kovio tag activation
-    uint8_t mLastKovioUid[NFC_KOVIO_MAX_LEN]; // uid of last Kovio tag activated
-    bool mIsDynamicTagId; // whether the tag has dynamic tag ID
-    bool mIsFelicaLite;
-    tNFA_RW_PRES_CHK_OPTION mPresenceCheckAlgorithm;
-
-
-    /*******************************************************************************
-    **
-    ** Function:        IsSameKovio
-    **
-    ** Description:     Checks if tag activate is the same (UID) Kovio tag previously
-    **                  activated.  This is needed due to a problem with some Kovio
-    **                  tags re-activating multiple times.
-    **                  activationData: data from activation.
-    **
-    ** Returns:         true if the activation is from the same tag previously
-    **                  activated, false otherwise
-    **
-    *******************************************************************************/
-    bool IsSameKovio(tNFA_ACTIVATED& activationData);
-
-    /*******************************************************************************
-    **
-    ** Function:        discoverTechnologies
-    **
-    ** Description:     Discover the technologies that NFC service needs by interpreting
-    **                  the data strucutures from the stack.
-    **                  activationData: data from activation.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void discoverTechnologies (tNFA_ACTIVATED& activationData);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        discoverTechnologies
-    **
-    ** Description:     Discover the technologies that NFC service needs by interpreting
-    **                  the data strucutures from the stack.
-    **                  discoveryData: data from discovery events(s).
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void discoverTechnologies (tNFA_DISC_RESULT& discoveryData);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        createNativeNfcTag
-    **
-    ** Description:     Create a brand new Java NativeNfcTag object;
-    **                  fill the objects's member variables with data;
-    **                  notify NFC service;
-    **                  activationData: data from activation.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void createNativeNfcTag (tNFA_ACTIVATED& activationData);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        fillNativeNfcTagMembers1
-    **
-    ** Description:     Fill NativeNfcTag's members: mProtocols, mTechList, mTechHandles, mTechLibNfcTypes.
-    **                  e: JVM environment.
-    **                  tag_cls: Java NativeNfcTag class.
-    **                  tag: Java NativeNfcTag object.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void fillNativeNfcTagMembers1 (JNIEnv* e, jclass tag_cls, jobject tag);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        fillNativeNfcTagMembers2
-    **
-    ** Description:     Fill NativeNfcTag's members: mConnectedTechIndex or mConnectedTechnology.
-    **                  The original Google's implementation is in set_target_pollBytes(
-    **                  in com_android_nfc_NativeNfcTag.cpp;
-    **                  e: JVM environment.
-    **                  tag_cls: Java NativeNfcTag class.
-    **                  tag: Java NativeNfcTag object.
-    **                  activationData: data from activation.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void fillNativeNfcTagMembers2 (JNIEnv* e, jclass tag_cls, jobject tag, tNFA_ACTIVATED& activationData);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        fillNativeNfcTagMembers3
-    **
-    ** Description:     Fill NativeNfcTag's members: mTechPollBytes.
-    **                  The original Google's implementation is in set_target_pollBytes(
-    **                  in com_android_nfc_NativeNfcTag.cpp;
-    **                  e: JVM environment.
-    **                  tag_cls: Java NativeNfcTag class.
-    **                  tag: Java NativeNfcTag object.
-    **                  activationData: data from activation.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void fillNativeNfcTagMembers3 (JNIEnv* e, jclass tag_cls, jobject tag, tNFA_ACTIVATED& activationData);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        fillNativeNfcTagMembers4
-    **
-    ** Description:     Fill NativeNfcTag's members: mTechActBytes.
-    **                  The original Google's implementation is in set_target_activationBytes()
-    **                  in com_android_nfc_NativeNfcTag.cpp;
-    **                  e: JVM environment.
-    **                  tag_cls: Java NativeNfcTag class.
-    **                  tag: Java NativeNfcTag object.
-    **                  activationData: data from activation.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void fillNativeNfcTagMembers4 (JNIEnv* e, jclass tag_cls, jobject tag, tNFA_ACTIVATED& activationData);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        fillNativeNfcTagMembers5
-    **
-    ** Description:     Fill NativeNfcTag's members: mUid.
-    **                  The original Google's implementation is in nfc_jni_Discovery_notification_callback()
-    **                  in com_android_nfc_NativeNfcManager.cpp;
-    **                  e: JVM environment.
-    **                  tag_cls: Java NativeNfcTag class.
-    **                  tag: Java NativeNfcTag object.
-    **                  activationData: data from activation.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void fillNativeNfcTagMembers5 (JNIEnv* e, jclass tag_cls, jobject tag, tNFA_ACTIVATED& activationData);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        resetTechnologies
-    **
-    ** Description:     Clear all data related to the technology, protocol of the tag.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void resetTechnologies ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        calculateT1tMaxMessageSize
-    **
-    ** Description:     Calculate type-1 tag's max message size based on header ROM bytes.
-    **                  activate: reference to activation data.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void calculateT1tMaxMessageSize (tNFA_ACTIVATED& activate);
-
+ private:
+  std::vector<int> mTechnologyTimeoutsTable;
+  std::vector<int> mTechnologyDefaultTimeoutsTable;
+  nfc_jni_native_data* mNativeData;
+  bool mIsActivated;
+  ActivationState mActivationState;
+  tNFC_PROTOCOL mProtocol;
+  int mtT1tMaxMessageSize;  // T1T max NDEF message size
+  tNFA_STATUS mReadCompletedStatus;
+  int mLastKovioUidLen;         // len of uid of last Kovio tag activated
+  bool mNdefDetectionTimedOut;  // whether NDEF detection algorithm timed out
+  tNFC_RF_TECH_PARAMS
+      mTechParams[MAX_NUM_TECHNOLOGY];  // array of technology parameters
+  SyncEvent mReadCompleteEvent;
+  struct timespec mLastKovioTime;  // time of last Kovio tag activation
+  uint8_t mLastKovioUid[NFC_KOVIO_MAX_LEN];  // uid of last Kovio tag activated
+  bool mIsDynamicTagId;  // whether the tag has dynamic tag ID
+  bool mIsFelicaLite;
+  tNFA_RW_PRES_CHK_OPTION mPresenceCheckAlgorithm;
+
+  /*******************************************************************************
+  **
+  ** Function:        IsSameKovio
+  **
+  ** Description:     Checks if tag activate is the same (UID) Kovio tag
+  *previously
+  **                  activated.  This is needed due to a problem with some
+  *Kovio
+  **                  tags re-activating multiple times.
+  **                  activationData: data from activation.
+  **
+  ** Returns:         true if the activation is from the same tag previously
+  **                  activated, false otherwise
+  **
+  *******************************************************************************/
+  bool IsSameKovio(tNFA_ACTIVATED& activationData);
+
+  /*******************************************************************************
+  **
+  ** Function:        discoverTechnologies
+  **
+  ** Description:     Discover the technologies that NFC service needs by
+  *interpreting
+  **                  the data strucutures from the stack.
+  **                  activationData: data from activation.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void discoverTechnologies(tNFA_ACTIVATED& activationData);
+
+  /*******************************************************************************
+  **
+  ** Function:        discoverTechnologies
+  **
+  ** Description:     Discover the technologies that NFC service needs by
+  *interpreting
+  **                  the data strucutures from the stack.
+  **                  discoveryData: data from discovery events(s).
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void discoverTechnologies(tNFA_DISC_RESULT& discoveryData);
+
+  /*******************************************************************************
+  **
+  ** Function:        createNativeNfcTag
+  **
+  ** Description:     Create a brand new Java NativeNfcTag object;
+  **                  fill the objects's member variables with data;
+  **                  notify NFC service;
+  **                  activationData: data from activation.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void createNativeNfcTag(tNFA_ACTIVATED& activationData);
+
+  /*******************************************************************************
+  **
+  ** Function:        fillNativeNfcTagMembers1
+  **
+  ** Description:     Fill NativeNfcTag's members: mProtocols, mTechList,
+  *mTechHandles, mTechLibNfcTypes.
+  **                  e: JVM environment.
+  **                  tag_cls: Java NativeNfcTag class.
+  **                  tag: Java NativeNfcTag object.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void fillNativeNfcTagMembers1(JNIEnv* e, jclass tag_cls, jobject tag);
+
+  /*******************************************************************************
+  **
+  ** Function:        fillNativeNfcTagMembers2
+  **
+  ** Description:     Fill NativeNfcTag's members: mConnectedTechIndex or
+  *mConnectedTechnology.
+  **                  The original Google's implementation is in
+  *set_target_pollBytes(
+  **                  in com_android_nfc_NativeNfcTag.cpp;
+  **                  e: JVM environment.
+  **                  tag_cls: Java NativeNfcTag class.
+  **                  tag: Java NativeNfcTag object.
+  **                  activationData: data from activation.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void fillNativeNfcTagMembers2(JNIEnv* e, jclass tag_cls, jobject tag,
+                                tNFA_ACTIVATED& activationData);
+
+  /*******************************************************************************
+  **
+  ** Function:        fillNativeNfcTagMembers3
+  **
+  ** Description:     Fill NativeNfcTag's members: mTechPollBytes.
+  **                  The original Google's implementation is in
+  *set_target_pollBytes(
+  **                  in com_android_nfc_NativeNfcTag.cpp;
+  **                  e: JVM environment.
+  **                  tag_cls: Java NativeNfcTag class.
+  **                  tag: Java NativeNfcTag object.
+  **                  activationData: data from activation.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void fillNativeNfcTagMembers3(JNIEnv* e, jclass tag_cls, jobject tag,
+                                tNFA_ACTIVATED& activationData);
+
+  /*******************************************************************************
+  **
+  ** Function:        fillNativeNfcTagMembers4
+  **
+  ** Description:     Fill NativeNfcTag's members: mTechActBytes.
+  **                  The original Google's implementation is in
+  *set_target_activationBytes()
+  **                  in com_android_nfc_NativeNfcTag.cpp;
+  **                  e: JVM environment.
+  **                  tag_cls: Java NativeNfcTag class.
+  **                  tag: Java NativeNfcTag object.
+  **                  activationData: data from activation.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void fillNativeNfcTagMembers4(JNIEnv* e, jclass tag_cls, jobject tag,
+                                tNFA_ACTIVATED& activationData);
+
+  /*******************************************************************************
+  **
+  ** Function:        fillNativeNfcTagMembers5
+  **
+  ** Description:     Fill NativeNfcTag's members: mUid.
+  **                  The original Google's implementation is in
+  *nfc_jni_Discovery_notification_callback()
+  **                  in com_android_nfc_NativeNfcManager.cpp;
+  **                  e: JVM environment.
+  **                  tag_cls: Java NativeNfcTag class.
+  **                  tag: Java NativeNfcTag object.
+  **                  activationData: data from activation.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void fillNativeNfcTagMembers5(JNIEnv* e, jclass tag_cls, jobject tag,
+                                tNFA_ACTIVATED& activationData);
+
+  /*******************************************************************************
+  **
+  ** Function:        resetTechnologies
+  **
+  ** Description:     Clear all data related to the technology, protocol of the
+  *tag.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void resetTechnologies();
+
+  /*******************************************************************************
+  **
+  ** Function:        calculateT1tMaxMessageSize
+  **
+  ** Description:     Calculate type-1 tag's max message size based on header
+  *ROM bytes.
+  **                  activate: reference to activation data.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void calculateT1tMaxMessageSize(tNFA_ACTIVATED& activate);
 };
diff --git a/nci/jni/PeerToPeer.cpp b/nci/jni/PeerToPeer.cpp
index a93a8466..21dd90bf 100644
--- a/nci/jni/PeerToPeer.cpp
+++ b/nci/jni/PeerToPeer.cpp
@@ -22,13 +22,17 @@
 /*
  *  Communicate with a peer using NFC-DEP, LLCP, SNEP.
  */
-#include "_OverrideLog.h"
 #include "PeerToPeer.h"
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+#include <nativehelper/ScopedLocalRef.h>
+#include "JavaClassConstants.h"
 #include "NfcJniUtil.h"
+#include "nfc_config.h"
 #include "llcp_defs.h"
-#include "config.h"
-#include "JavaClassConstants.h"
-#include <nativehelper/ScopedLocalRef.h>
+
+using android::base::StringPrintf;
 
 /* Some older PN544-based solutions would only send the first SYMM back
  * (as an initiator) after the full LTO (750ms). But our connect timer
@@ -37,24 +41,23 @@
  * socket, causing concurrency issues in that stack. Increase the default
  * timeout to 2000 ms, giving us enough time to complete the first connect.
  */
-#define LLCP_DATA_LINK_TIMEOUT    2000
+#define LLCP_DATA_LINK_TIMEOUT 2000
 
 using namespace android;
 
-namespace android
-{
-    extern void nativeNfcTag_registerNdefTypeHandler ();
-    extern void nativeNfcTag_deregisterNdefTypeHandler ();
-    extern int getScreenState();
-    extern void startRfDiscovery(bool isStart);
-    extern bool isDiscoveryStarted();
-    extern int gGeneralPowershutDown;
-}
-
+namespace android {
+extern void nativeNfcTag_registerNdefTypeHandler();
+extern void nativeNfcTag_deregisterNdefTypeHandler();
+extern int getScreenState();
+extern void startRfDiscovery(bool isStart);
+extern bool isDiscoveryStarted();
+extern int gGeneralPowershutDown;
+}  // namespace android
 
 PeerToPeer PeerToPeer::sP2p;
-const std::string P2pServer::sSnepServiceName ("urn:nfc:sn:snep");
+const std::string P2pServer::sSnepServiceName("urn:nfc:sn:snep");
 
+extern bool nfc_debug_enabled;
 
 /*******************************************************************************
 **
@@ -65,20 +68,17 @@ const std::string P2pServer::sSnepServiceName ("urn:nfc:sn:snep");
 ** Returns:         None
 **
 *******************************************************************************/
-PeerToPeer::PeerToPeer ()
-:   mRemoteWKS (0),
-    mIsP2pListening (false),
-    mP2pListenTechMask (NFA_TECHNOLOGY_MASK_A
-                        | NFA_TECHNOLOGY_MASK_F
-                        | NFA_TECHNOLOGY_MASK_A_ACTIVE
-                        | NFA_TECHNOLOGY_MASK_F_ACTIVE),
-    mNextJniHandle (1)
-{
-    memset (mServers, 0, sizeof(mServers));
-    memset (mClients, 0, sizeof(mClients));
+PeerToPeer::PeerToPeer()
+    : mRemoteWKS(0),
+      mIsP2pListening(false),
+      mP2pListenTechMask(NFA_TECHNOLOGY_MASK_A | NFA_TECHNOLOGY_MASK_F |
+                         NFA_TECHNOLOGY_MASK_A_ACTIVE |
+                         NFA_TECHNOLOGY_MASK_F_ACTIVE),
+      mNextJniHandle(1) {
+  memset(mServers, 0, sizeof(mServers));
+  memset(mClients, 0, sizeof(mClients));
 }
 
-
 /*******************************************************************************
 **
 ** Function:        ~PeerToPeer
@@ -88,10 +88,7 @@ PeerToPeer::PeerToPeer ()
 ** Returns:         None
 **
 *******************************************************************************/
-PeerToPeer::~PeerToPeer ()
-{
-}
-
+PeerToPeer::~PeerToPeer() {}
 
 /*******************************************************************************
 **
@@ -102,11 +99,7 @@ PeerToPeer::~PeerToPeer ()
 ** Returns:         Singleton PeerToPeer object.
 **
 *******************************************************************************/
-PeerToPeer& PeerToPeer::getInstance ()
-{
-    return sP2p;
-}
-
+PeerToPeer& PeerToPeer::getInstance() { return sP2p; }
 
 /*******************************************************************************
 **
@@ -117,17 +110,14 @@ PeerToPeer& PeerToPeer::getInstance ()
 ** Returns:         None
 **
 *******************************************************************************/
-void PeerToPeer::initialize ()
-{
-    static const char fn [] = "PeerToPeer::initialize";
-    unsigned long num = 0;
-
-    ALOGV("%s: enter", fn);
-    if (GetNumValue ("P2P_LISTEN_TECH_MASK", &num, sizeof (num)))
-        mP2pListenTechMask = num;
-    ALOGV("%s: exit", fn);
-}
+void PeerToPeer::initialize() {
+  static const char fn[] = "PeerToPeer::initialize";
 
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+  if (NfcConfig::hasKey(NAME_P2P_LISTEN_TECH_MASK))
+    mP2pListenTechMask = NfcConfig::getUnsigned(NAME_P2P_LISTEN_TECH_MASK);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
+}
 
 /*******************************************************************************
 **
@@ -140,22 +130,18 @@ void PeerToPeer::initialize ()
 ** Returns:         PeerToPeer object.
 **
 *******************************************************************************/
-sp<P2pServer> PeerToPeer::findServerLocked (tNFA_HANDLE nfaP2pServerHandle)
-{
-    for (int i = 0; i < sMax; i++)
-    {
-        if ( (mServers[i] != NULL)
-          && (mServers[i]->mNfaP2pServerHandle == nfaP2pServerHandle) )
-        {
-            return (mServers [i]);
-        }
+sp<P2pServer> PeerToPeer::findServerLocked(tNFA_HANDLE nfaP2pServerHandle) {
+  for (int i = 0; i < sMax; i++) {
+    if ((mServers[i] != NULL) &&
+        (mServers[i]->mNfaP2pServerHandle == nfaP2pServerHandle)) {
+      return (mServers[i]);
     }
+  }
 
-    // If here, not found
-    return NULL;
+  // If here, not found
+  return NULL;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        findServerLocked
@@ -167,22 +153,17 @@ sp<P2pServer> PeerToPeer::findServerLocked (tNFA_HANDLE nfaP2pServerHandle)
 ** Returns:         PeerToPeer object.
 **
 *******************************************************************************/
-sp<P2pServer> PeerToPeer::findServerLocked (tJNI_HANDLE jniHandle)
-{
-    for (int i = 0; i < sMax; i++)
-    {
-        if ( (mServers[i] != NULL)
-          && (mServers[i]->mJniHandle == jniHandle) )
-        {
-            return (mServers [i]);
-        }
+sp<P2pServer> PeerToPeer::findServerLocked(tJNI_HANDLE jniHandle) {
+  for (int i = 0; i < sMax; i++) {
+    if ((mServers[i] != NULL) && (mServers[i]->mJniHandle == jniHandle)) {
+      return (mServers[i]);
     }
+  }
 
-    // If here, not found
-    return NULL;
+  // If here, not found
+  return NULL;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        findServerLocked
@@ -194,19 +175,17 @@ sp<P2pServer> PeerToPeer::findServerLocked (tJNI_HANDLE jniHandle)
 ** Returns:         PeerToPeer object.
 **
 *******************************************************************************/
-sp<P2pServer> PeerToPeer::findServerLocked (const char *serviceName)
-{
-    for (int i = 0; i < sMax; i++)
-    {
-        if ( (mServers[i] != NULL) && (mServers[i]->mServiceName.compare(serviceName) == 0) )
-            return (mServers [i]);
-    }
-
-    // If here, not found
-    return NULL;
+sp<P2pServer> PeerToPeer::findServerLocked(const char* serviceName) {
+  for (int i = 0; i < sMax; i++) {
+    if ((mServers[i] != NULL) &&
+        (mServers[i]->mServiceName.compare(serviceName) == 0))
+      return (mServers[i]);
+  }
+
+  // If here, not found
+  return NULL;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        registerServer
@@ -218,53 +197,56 @@ sp<P2pServer> PeerToPeer::findServerLocked (const char *serviceName)
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-bool PeerToPeer::registerServer (tJNI_HANDLE jniHandle, const char *serviceName)
-{
-    static const char fn [] = "PeerToPeer::registerServer";
-    ALOGV("%s: enter; service name: %s  JNI handle: %u", fn, serviceName, jniHandle);
-    sp<P2pServer>   pSrv = NULL;
-
-    mMutex.lock();
-    // Check if already registered
-    if ((pSrv = findServerLocked(serviceName)) != NULL)
-    {
-        ALOGV("%s: service name=%s  already registered, handle: 0x%04x", fn, serviceName, pSrv->mNfaP2pServerHandle);
-
-        // Update JNI handle
-        pSrv->mJniHandle = jniHandle;
-        mMutex.unlock();
-        return (true);
-    }
+bool PeerToPeer::registerServer(tJNI_HANDLE jniHandle,
+                                const char* serviceName) {
+  static const char fn[] = "PeerToPeer::registerServer";
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter; service name: %s  JNI handle: %u", fn,
+                      serviceName, jniHandle);
+  sp<P2pServer> pSrv = NULL;
+
+  mMutex.lock();
+  // Check if already registered
+  if ((pSrv = findServerLocked(serviceName)) != NULL) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: service name=%s  already registered, handle: 0x%04x", fn,
+        serviceName, pSrv->mNfaP2pServerHandle);
+
+    // Update JNI handle
+    pSrv->mJniHandle = jniHandle;
+    mMutex.unlock();
+    return (true);
+  }
 
-    for (int ii = 0; ii < sMax; ii++)
-    {
-        if (mServers[ii] == NULL)
-        {
-            pSrv = mServers[ii] = new P2pServer(jniHandle, serviceName);
+  for (int ii = 0; ii < sMax; ii++) {
+    if (mServers[ii] == NULL) {
+      pSrv = mServers[ii] = new P2pServer(jniHandle, serviceName);
 
-            ALOGV("%s: added new p2p server  index: %d  handle: %u  name: %s", fn, ii, jniHandle, serviceName);
-            break;
-        }
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: added new p2p server  index: %d  handle: %u  name: %s", fn, ii,
+          jniHandle, serviceName);
+      break;
     }
-    mMutex.unlock();
+  }
+  mMutex.unlock();
 
-    if (pSrv == NULL)
-    {
-        ALOGE("%s: service name=%s  no free entry", fn, serviceName);
-        return (false);
-    }
+  if (pSrv == NULL) {
+    LOG(ERROR) << StringPrintf("%s: service name=%s  no free entry", fn,
+                               serviceName);
+    return (false);
+  }
 
-    if (pSrv->registerWithStack()) {
-        ALOGV("%s: got new p2p server h=0x%X", fn, pSrv->mNfaP2pServerHandle);
-        return (true);
-    } else {
-        ALOGE("%s: invalid server handle", fn);
-        removeServer (jniHandle);
-        return (false);
-    }
+  if (pSrv->registerWithStack()) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: got new p2p server h=0x%X", fn, pSrv->mNfaP2pServerHandle);
+    return (true);
+  } else {
+    LOG(ERROR) << StringPrintf("%s: invalid server handle", fn);
+    removeServer(jniHandle);
+    return (false);
+  }
 }
 
-
 /*******************************************************************************
 **
 ** Function:        removeServer
@@ -275,27 +257,26 @@ bool PeerToPeer::registerServer (tJNI_HANDLE jniHandle, const char *serviceName)
 ** Returns:         None
 **
 *******************************************************************************/
-void PeerToPeer::removeServer (tJNI_HANDLE jniHandle)
-{
-    static const char fn [] = "PeerToPeer::removeServer";
+void PeerToPeer::removeServer(tJNI_HANDLE jniHandle) {
+  static const char fn[] = "PeerToPeer::removeServer";
 
-    AutoMutex mutex(mMutex);
+  AutoMutex mutex(mMutex);
 
-    for (int i = 0; i < sMax; i++)
-    {
-        if ( (mServers[i] != NULL) && (mServers[i]->mJniHandle == jniHandle) )
-        {
-            ALOGV("%s: server jni_handle: %u;  nfa_handle: 0x%04x; name: %s; index=%d",
-                    fn, jniHandle, mServers[i]->mNfaP2pServerHandle, mServers[i]->mServiceName.c_str(), i);
+  for (int i = 0; i < sMax; i++) {
+    if ((mServers[i] != NULL) && (mServers[i]->mJniHandle == jniHandle)) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: server jni_handle: %u;  nfa_handle: 0x%04x; name: %s; index=%d",
+          fn, jniHandle, mServers[i]->mNfaP2pServerHandle,
+          mServers[i]->mServiceName.c_str(), i);
 
-            mServers [i] = NULL;
-            return;
-        }
+      mServers[i] = NULL;
+      return;
     }
-    ALOGE("%s: unknown server jni handle: %u", fn, jniHandle);
+  }
+  LOG(ERROR) << StringPrintf("%s: unknown server jni handle: %u", fn,
+                             jniHandle);
 }
 
-
 /*******************************************************************************
 **
 ** Function:        llcpActivatedHandler
@@ -307,73 +288,75 @@ void PeerToPeer::removeServer (tJNI_HANDLE jniHandle)
 ** Returns:         None
 **
 *******************************************************************************/
-void PeerToPeer::llcpActivatedHandler (nfc_jni_native_data* nat, tNFA_LLCP_ACTIVATED& activated)
-{
-    static const char fn [] = "PeerToPeer::llcpActivatedHandler";
-    ALOGV("%s: enter", fn);
-
-    //no longer need to receive NDEF message from a tag
-    android::nativeNfcTag_deregisterNdefTypeHandler ();
-
-    mRemoteWKS = activated.remote_wks;
-
-    JNIEnv* e = NULL;
-    ScopedAttach attach(nat->vm, &e);
-    if (e == NULL)
-    {
-        ALOGE("%s: jni env is null", fn);
-        return;
-    }
-
-    ALOGV("%s: get object class", fn);
-    ScopedLocalRef<jclass> tag_cls(e, e->GetObjectClass(nat->cached_P2pDevice));
-    if (e->ExceptionCheck()) {
-        e->ExceptionClear();
-        ALOGE("%s: fail get p2p device", fn);
-        return;
-    }
-
-    ALOGV("%s: instantiate", fn);
-    /* New target instance */
-    jmethodID ctor = e->GetMethodID(tag_cls.get(), "<init>", "()V");
-    ScopedLocalRef<jobject> tag(e, e->NewObject(tag_cls.get(), ctor));
-
-    /* Set P2P Target mode */
-    jfieldID f = e->GetFieldID(tag_cls.get(), "mMode", "I");
-
-    if (activated.is_initiator == true) {
-        ALOGV("%s: p2p initiator", fn);
-        e->SetIntField(tag.get(), f, (jint) MODE_P2P_INITIATOR);
-    } else {
-        ALOGV("%s: p2p target", fn);
-        e->SetIntField(tag.get(), f, (jint) MODE_P2P_TARGET);
-    }
-    /* Set LLCP version */
-    f = e->GetFieldID(tag_cls.get(), "mLlcpVersion", "B");
-    e->SetByteField(tag.get(), f, (jbyte) activated.remote_version);
-
-    /* Set tag handle */
-    f = e->GetFieldID(tag_cls.get(), "mHandle", "I");
-    e->SetIntField(tag.get(), f, (jint) 0x1234); // ?? This handle is not used for anything
-
-    if (nat->tag != NULL) {
-        e->DeleteGlobalRef(nat->tag);
-    }
-    nat->tag = e->NewGlobalRef(tag.get());
-
-    ALOGV("%s: notify nfc service", fn);
-
-    /* Notify manager that new a P2P device was found */
-    e->CallVoidMethod(nat->manager, android::gCachedNfcManagerNotifyLlcpLinkActivation, tag.get());
-    if (e->ExceptionCheck()) {
-        e->ExceptionClear();
-        ALOGE("%s: fail notify", fn);
-    }
-
-    ALOGV("%s: exit", fn);
+void PeerToPeer::llcpActivatedHandler(nfc_jni_native_data* nat,
+                                      tNFA_LLCP_ACTIVATED& activated) {
+  static const char fn[] = "PeerToPeer::llcpActivatedHandler";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+
+  // no longer need to receive NDEF message from a tag
+  android::nativeNfcTag_deregisterNdefTypeHandler();
+
+  mRemoteWKS = activated.remote_wks;
+
+  JNIEnv* e = NULL;
+  ScopedAttach attach(nat->vm, &e);
+  if (e == NULL) {
+    LOG(ERROR) << StringPrintf("%s: jni env is null", fn);
+    return;
+  }
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: get object class", fn);
+  ScopedLocalRef<jclass> tag_cls(e, e->GetObjectClass(nat->cached_P2pDevice));
+  if (e->ExceptionCheck()) {
+    e->ExceptionClear();
+    LOG(ERROR) << StringPrintf("%s: fail get p2p device", fn);
+    return;
+  }
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: instantiate", fn);
+  /* New target instance */
+  jmethodID ctor = e->GetMethodID(tag_cls.get(), "<init>", "()V");
+  ScopedLocalRef<jobject> tag(e, e->NewObject(tag_cls.get(), ctor));
+
+  /* Set P2P Target mode */
+  jfieldID f = e->GetFieldID(tag_cls.get(), "mMode", "I");
+
+  if (activated.is_initiator == true) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: p2p initiator", fn);
+    e->SetIntField(tag.get(), f, (jint)MODE_P2P_INITIATOR);
+  } else {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: p2p target", fn);
+    e->SetIntField(tag.get(), f, (jint)MODE_P2P_TARGET);
+  }
+  /* Set LLCP version */
+  f = e->GetFieldID(tag_cls.get(), "mLlcpVersion", "B");
+  e->SetByteField(tag.get(), f, (jbyte)activated.remote_version);
+
+  /* Set tag handle */
+  f = e->GetFieldID(tag_cls.get(), "mHandle", "I");
+  e->SetIntField(tag.get(), f,
+                 (jint)0x1234);  // ?? This handle is not used for anything
+
+  if (nat->tag != NULL) {
+    e->DeleteGlobalRef(nat->tag);
+  }
+  nat->tag = e->NewGlobalRef(tag.get());
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: notify nfc service", fn);
+
+  /* Notify manager that new a P2P device was found */
+  e->CallVoidMethod(nat->manager,
+                    android::gCachedNfcManagerNotifyLlcpLinkActivation,
+                    tag.get());
+  if (e->ExceptionCheck()) {
+    e->ExceptionClear();
+    LOG(ERROR) << StringPrintf("%s: fail notify", fn);
+  }
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
 }
 
-
 /*******************************************************************************
 **
 ** Function:        llcpDeactivatedHandler
@@ -385,57 +368,57 @@ void PeerToPeer::llcpActivatedHandler (nfc_jni_native_data* nat, tNFA_LLCP_ACTIV
 ** Returns:         None
 **
 *******************************************************************************/
-void PeerToPeer::llcpDeactivatedHandler (nfc_jni_native_data* nat, tNFA_LLCP_DEACTIVATED& /*deactivated*/)
-{
-    static const char fn [] = "PeerToPeer::llcpDeactivatedHandler";
-    ALOGV("%s: enter", fn);
-
-    JNIEnv* e = NULL;
-    ScopedAttach attach(nat->vm, &e);
-    if (e == NULL)
-    {
-        ALOGE("%s: jni env is null", fn);
-        return;
-    }
-
-    ALOGV("%s: notify nfc service", fn);
-    /* Notify manager that the LLCP is lost or deactivated */
-    e->CallVoidMethod (nat->manager, android::gCachedNfcManagerNotifyLlcpLinkDeactivated, nat->tag);
-    if (e->ExceptionCheck())
-    {
-        e->ExceptionClear();
-        ALOGE("%s: fail notify", fn);
-    }
-
-    //let the tag-reading code handle NDEF data event
-    android::nativeNfcTag_registerNdefTypeHandler ();
-    ALOGV("%s: exit", fn);
+void PeerToPeer::llcpDeactivatedHandler(
+    nfc_jni_native_data* nat, tNFA_LLCP_DEACTIVATED& /*deactivated*/) {
+  static const char fn[] = "PeerToPeer::llcpDeactivatedHandler";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+
+  JNIEnv* e = NULL;
+  ScopedAttach attach(nat->vm, &e);
+  if (e == NULL) {
+    LOG(ERROR) << StringPrintf("%s: jni env is null", fn);
+    return;
+  }
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: notify nfc service", fn);
+  /* Notify manager that the LLCP is lost or deactivated */
+  e->CallVoidMethod(nat->manager,
+                    android::gCachedNfcManagerNotifyLlcpLinkDeactivated,
+                    nat->tag);
+  if (e->ExceptionCheck()) {
+    e->ExceptionClear();
+    LOG(ERROR) << StringPrintf("%s: fail notify", fn);
+  }
+
+  // let the tag-reading code handle NDEF data event
+  android::nativeNfcTag_registerNdefTypeHandler();
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
 }
 
-void PeerToPeer::llcpFirstPacketHandler (nfc_jni_native_data* nat)
-{
-    static const char fn [] = "PeerToPeer::llcpFirstPacketHandler";
-    ALOGV("%s: enter", fn);
-
-    JNIEnv* e = NULL;
-    ScopedAttach attach(nat->vm, &e);
-    if (e == NULL)
-    {
-        ALOGE("%s: jni env is null", fn);
-        return;
-    }
-
-    ALOGV("%s: notify nfc service", fn);
-    /* Notify manager that the LLCP is lost or deactivated */
-    e->CallVoidMethod (nat->manager, android::gCachedNfcManagerNotifyLlcpFirstPacketReceived, nat->tag);
-    if (e->ExceptionCheck())
-    {
-        e->ExceptionClear();
-        ALOGE("%s: fail notify", fn);
-    }
-
-    ALOGV("%s: exit", fn);
-
+void PeerToPeer::llcpFirstPacketHandler(nfc_jni_native_data* nat) {
+  static const char fn[] = "PeerToPeer::llcpFirstPacketHandler";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+
+  JNIEnv* e = NULL;
+  ScopedAttach attach(nat->vm, &e);
+  if (e == NULL) {
+    LOG(ERROR) << StringPrintf("%s: jni env is null", fn);
+    return;
+  }
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: notify nfc service", fn);
+  /* Notify manager that the LLCP is lost or deactivated */
+  e->CallVoidMethod(nat->manager,
+                    android::gCachedNfcManagerNotifyLlcpFirstPacketReceived,
+                    nat->tag);
+  if (e->ExceptionCheck()) {
+    e->ExceptionClear();
+    LOG(ERROR) << StringPrintf("%s: fail notify", fn);
+  }
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
 }
 /*******************************************************************************
 **
@@ -450,27 +433,28 @@ void PeerToPeer::llcpFirstPacketHandler (nfc_jni_native_data* nat)
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-bool PeerToPeer::accept (tJNI_HANDLE serverJniHandle, tJNI_HANDLE connJniHandle, int maxInfoUnit, int recvWindow)
-{
-    static const char fn [] = "PeerToPeer::accept";
-    sp<P2pServer> pSrv = NULL;
-
-    ALOGV("%s: enter; server jni handle: %u; conn jni handle: %u; maxInfoUnit: %d; recvWindow: %d", fn,
-            serverJniHandle, connJniHandle, maxInfoUnit, recvWindow);
-
-    mMutex.lock();
-    if ((pSrv = findServerLocked (serverJniHandle)) == NULL)
-    {
-        ALOGE("%s: unknown server jni handle: %u", fn, serverJniHandle);
-        mMutex.unlock();
-        return (false);
-    }
+bool PeerToPeer::accept(tJNI_HANDLE serverJniHandle, tJNI_HANDLE connJniHandle,
+                        int maxInfoUnit, int recvWindow) {
+  static const char fn[] = "PeerToPeer::accept";
+  sp<P2pServer> pSrv = NULL;
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: enter; server jni handle: %u; conn jni handle: %u; maxInfoUnit: %d; "
+      "recvWindow: %d",
+      fn, serverJniHandle, connJniHandle, maxInfoUnit, recvWindow);
+
+  mMutex.lock();
+  if ((pSrv = findServerLocked(serverJniHandle)) == NULL) {
+    LOG(ERROR) << StringPrintf("%s: unknown server jni handle: %u", fn,
+                               serverJniHandle);
     mMutex.unlock();
+    return (false);
+  }
+  mMutex.unlock();
 
-    return pSrv->accept(serverJniHandle, connJniHandle, maxInfoUnit, recvWindow);
+  return pSrv->accept(serverJniHandle, connJniHandle, maxInfoUnit, recvWindow);
 }
 
-
 /*******************************************************************************
 **
 ** Function:        deregisterServer
@@ -480,56 +464,51 @@ bool PeerToPeer::accept (tJNI_HANDLE serverJniHandle, tJNI_HANDLE connJniHandle,
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-bool PeerToPeer::deregisterServer (tJNI_HANDLE jniHandle)
-{
-    static const char fn [] = "PeerToPeer::deregisterServer";
-    ALOGV("%s: enter; JNI handle: %u", fn, jniHandle);
-    tNFA_STATUS     nfaStat = NFA_STATUS_FAILED;
-    sp<P2pServer>   pSrv = NULL;
-    bool            isPollingTempStopped = false;
-
-    mMutex.lock();
-    if ((pSrv = findServerLocked (jniHandle)) == NULL)
-    {
-        ALOGE("%s: unknown service handle: %u", fn, jniHandle);
-        mMutex.unlock();
-        return (false);
-    }
+bool PeerToPeer::deregisterServer(tJNI_HANDLE jniHandle) {
+  static const char fn[] = "PeerToPeer::deregisterServer";
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter; JNI handle: %u", fn, jniHandle);
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+  sp<P2pServer> pSrv = NULL;
+  bool isPollingTempStopped = false;
+
+  mMutex.lock();
+  if ((pSrv = findServerLocked(jniHandle)) == NULL) {
+    LOG(ERROR) << StringPrintf("%s: unknown service handle: %u", fn, jniHandle);
     mMutex.unlock();
-    if(isDiscoveryStarted())
-    {
-        isPollingTempStopped = true;
-        startRfDiscovery(false);
-    }
-
-    {
-        // Server does not call NFA_P2pDisconnect(), so unblock the accept()
-        SyncEventGuard guard (pSrv->mConnRequestEvent);
-        pSrv->mConnRequestEvent.notifyOne();
-    }
-
-    nfaStat = NFA_P2pDeregister (pSrv->mNfaP2pServerHandle);
-    if (nfaStat != NFA_STATUS_OK)
-    {
-        ALOGE("%s: deregister error=0x%X", fn, nfaStat);
-    }
-
-    removeServer (jniHandle);
-
-    /*
-     * conditional check is added to avoid multiple dicovery cmds
-     * at the time of NFC OFF in progress
-     */
-    if((gGeneralPowershutDown != NFC_MODE_OFF) && isPollingTempStopped == true)
-    {
-        startRfDiscovery(true);
-    }
-
-    ALOGV("%s: exit", fn);
-    return true;
+    return (false);
+  }
+  mMutex.unlock();
+  if (isDiscoveryStarted()) {
+    isPollingTempStopped = true;
+    startRfDiscovery(false);
+  }
+
+  {
+    // Server does not call NFA_P2pDisconnect(), so unblock the accept()
+    SyncEventGuard guard(pSrv->mConnRequestEvent);
+    pSrv->mConnRequestEvent.notifyOne();
+  }
+
+  nfaStat = NFA_P2pDeregister(pSrv->mNfaP2pServerHandle);
+  if (nfaStat != NFA_STATUS_OK) {
+    LOG(ERROR) << StringPrintf("%s: deregister error=0x%X", fn, nfaStat);
+  }
+
+  removeServer(jniHandle);
+
+  /*
+   * conditional check is added to avoid multiple dicovery cmds
+   * at the time of NFC OFF in progress
+   */
+  if ((gGeneralPowershutDown != NFC_MODE_OFF) && isPollingTempStopped == true) {
+    startRfDiscovery(true);
+  }
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
+  return true;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        createClient
@@ -542,56 +521,55 @@ bool PeerToPeer::deregisterServer (tJNI_HANDLE jniHandle)
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-bool PeerToPeer::createClient (tJNI_HANDLE jniHandle, uint16_t miu, uint8_t rw)
-{
-    static const char fn [] = "PeerToPeer::createClient";
-    int i = 0;
-    ALOGV("%s: enter: jni h: %u  miu: %u  rw: %u", fn, jniHandle, miu, rw);
-
-    mMutex.lock();
-    sp<P2pClient> client = NULL;
-    for (i = 0; i < sMax; i++)
-    {
-        if (mClients[i] == NULL)
-        {
-            mClients [i] = client = new P2pClient();
-
-            mClients [i]->mClientConn->mJniHandle   = jniHandle;
-            mClients [i]->mClientConn->mMaxInfoUnit = miu;
-            mClients [i]->mClientConn->mRecvWindow  = rw;
-            break;
-        }
-    }
-    mMutex.unlock();
-
-    if (client == NULL || i >=sMax)
-    {
-        ALOGE("%s: fail", fn);
-        return (false);
-    }
-
-    ALOGV("%s: pClient: 0x%p  assigned for client jniHandle: %u", fn, client.get(), jniHandle);
-
-    {
-        SyncEventGuard guard (mClients[i]->mRegisteringEvent);
-        NFA_P2pRegisterClient (NFA_P2P_DLINK_TYPE, nfaClientCallback);
-        mClients[i]->mRegisteringEvent.wait(); //wait for NFA_P2P_REG_CLIENT_EVT
-    }
-
-    if (mClients[i]->mNfaP2pClientHandle != NFA_HANDLE_INVALID)
-    {
-        ALOGV("%s: exit; new client jniHandle: %u   NFA Handle: 0x%04x", fn, jniHandle, client->mClientConn->mNfaConnHandle);
-        return (true);
-    }
-    else
-    {
-        ALOGE("%s: FAILED; new client jniHandle: %u   NFA Handle: 0x%04x", fn, jniHandle, client->mClientConn->mNfaConnHandle);
-        removeConn (jniHandle);
-        return (false);
-    }
+bool PeerToPeer::createClient(tJNI_HANDLE jniHandle, uint16_t miu, uint8_t rw) {
+  static const char fn[] = "PeerToPeer::createClient";
+  int i = 0;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: enter: jni h: %u  miu: %u  rw: %u", fn, jniHandle, miu, rw);
+
+  mMutex.lock();
+  sp<P2pClient> client = NULL;
+  for (i = 0; i < sMax; i++) {
+    if (mClients[i] == NULL) {
+      mClients[i] = client = new P2pClient();
+
+      mClients[i]->mClientConn->mJniHandle = jniHandle;
+      mClients[i]->mClientConn->mMaxInfoUnit = miu;
+      mClients[i]->mClientConn->mRecvWindow = rw;
+      break;
+    }
+  }
+  mMutex.unlock();
+
+  if (client == NULL || i >= sMax) {
+    LOG(ERROR) << StringPrintf("%s: fail", fn);
+    return (false);
+  }
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: pClient: 0x%p  assigned for client jniHandle: %u",
+                      fn, client.get(), jniHandle);
+
+  {
+    SyncEventGuard guard(mClients[i]->mRegisteringEvent);
+    NFA_P2pRegisterClient(NFA_P2P_DLINK_TYPE, nfaClientCallback);
+    mClients[i]->mRegisteringEvent.wait();  // wait for NFA_P2P_REG_CLIENT_EVT
+  }
+
+  if (mClients[i]->mNfaP2pClientHandle != NFA_HANDLE_INVALID) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: exit; new client jniHandle: %u   NFA Handle: 0x%04x", fn,
+        jniHandle, client->mClientConn->mNfaConnHandle);
+    return (true);
+  } else {
+    LOG(ERROR) << StringPrintf(
+        "%s: FAILED; new client jniHandle: %u   NFA Handle: 0x%04x", fn,
+        jniHandle, client->mClientConn->mNfaConnHandle);
+    removeConn(jniHandle);
+    return (false);
+  }
 }
 
-
 /*******************************************************************************
 **
 ** Function:        removeConn
@@ -602,40 +580,36 @@ bool PeerToPeer::createClient (tJNI_HANDLE jniHandle, uint16_t miu, uint8_t rw)
 ** Returns:         None
 **
 *******************************************************************************/
-void PeerToPeer::removeConn(tJNI_HANDLE jniHandle)
-{
-    static const char fn[] = "PeerToPeer::removeConn";
-
-    AutoMutex mutex(mMutex);
-    // If the connection is a for a client, delete the client itself
-    for (int ii = 0; ii < sMax; ii++)
-    {
-        if ((mClients[ii] != NULL) && (mClients[ii]->mClientConn->mJniHandle == jniHandle))
-        {
-            if (mClients[ii]->mNfaP2pClientHandle != NFA_HANDLE_INVALID)
-                NFA_P2pDeregister (mClients[ii]->mNfaP2pClientHandle);
-
-            mClients[ii] = NULL;
-            ALOGV("%s: deleted client handle: %u  index: %u", fn, jniHandle, ii);
-            return;
-        }
-    }
-
-    // If the connection is for a server, just delete the connection
-    for (int ii = 0; ii < sMax; ii++)
-    {
-        if (mServers[ii] != NULL)
-        {
-            if (mServers[ii]->removeServerConnection(jniHandle)) {
-                return;
-            }
-        }
+void PeerToPeer::removeConn(tJNI_HANDLE jniHandle) {
+  static const char fn[] = "PeerToPeer::removeConn";
+
+  AutoMutex mutex(mMutex);
+  // If the connection is a for a client, delete the client itself
+  for (int ii = 0; ii < sMax; ii++) {
+    if ((mClients[ii] != NULL) &&
+        (mClients[ii]->mClientConn->mJniHandle == jniHandle)) {
+      if (mClients[ii]->mNfaP2pClientHandle != NFA_HANDLE_INVALID)
+        NFA_P2pDeregister(mClients[ii]->mNfaP2pClientHandle);
+
+      mClients[ii] = NULL;
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: deleted client handle: %u  index: %u", fn, jniHandle, ii);
+      return;
+    }
+  }
+
+  // If the connection is for a server, just delete the connection
+  for (int ii = 0; ii < sMax; ii++) {
+    if (mServers[ii] != NULL) {
+      if (mServers[ii]->removeServerConnection(jniHandle)) {
+        return;
+      }
     }
+  }
 
-    ALOGE("%s: could not find handle: %u", fn, jniHandle);
+  LOG(ERROR) << StringPrintf("%s: could not find handle: %u", fn, jniHandle);
 }
 
-
 /*******************************************************************************
 **
 ** Function:        connectConnOriented
@@ -647,16 +621,17 @@ void PeerToPeer::removeConn(tJNI_HANDLE jniHandle)
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-bool PeerToPeer::connectConnOriented (tJNI_HANDLE jniHandle, const char* serviceName)
-{
-    static const char fn [] = "PeerToPeer::connectConnOriented";
-    ALOGV("%s: enter; h: %u  service name=%s", fn, jniHandle, serviceName);
-    bool stat = createDataLinkConn (jniHandle, serviceName, 0);
-    ALOGV("%s: exit; h: %u  stat: %u", fn, jniHandle, stat);
-    return stat;
+bool PeerToPeer::connectConnOriented(tJNI_HANDLE jniHandle,
+                                     const char* serviceName) {
+  static const char fn[] = "PeerToPeer::connectConnOriented";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: enter; h: %u  service name=%s", fn, jniHandle, serviceName);
+  bool stat = createDataLinkConn(jniHandle, serviceName, 0);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit; h: %u  stat: %u", fn, jniHandle, stat);
+  return stat;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        connectConnOriented
@@ -668,16 +643,17 @@ bool PeerToPeer::connectConnOriented (tJNI_HANDLE jniHandle, const char* service
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-bool PeerToPeer::connectConnOriented (tJNI_HANDLE jniHandle, uint8_t destinationSap)
-{
-    static const char fn [] = "PeerToPeer::connectConnOriented";
-    ALOGV("%s: enter; h: %u  dest sap: 0x%X", fn, jniHandle, destinationSap);
-    bool stat = createDataLinkConn (jniHandle, NULL, destinationSap);
-    ALOGV("%s: exit; h: %u  stat: %u", fn, jniHandle, stat);
-    return stat;
+bool PeerToPeer::connectConnOriented(tJNI_HANDLE jniHandle,
+                                     uint8_t destinationSap) {
+  static const char fn[] = "PeerToPeer::connectConnOriented";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: enter; h: %u  dest sap: 0x%X", fn, jniHandle, destinationSap);
+  bool stat = createDataLinkConn(jniHandle, NULL, destinationSap);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit; h: %u  stat: %u", fn, jniHandle, stat);
+  return stat;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        createDataLinkConn
@@ -690,58 +666,57 @@ bool PeerToPeer::connectConnOriented (tJNI_HANDLE jniHandle, uint8_t destination
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-bool PeerToPeer::createDataLinkConn (tJNI_HANDLE jniHandle, const char* serviceName, uint8_t destinationSap)
-{
-    static const char fn [] = "PeerToPeer::createDataLinkConn";
-    ALOGV("%s: enter", fn);
-    tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
-    sp<P2pClient>   pClient = NULL;
-
-    if ((pClient = findClient (jniHandle)) == NULL)
-    {
-        ALOGE("%s: can't find client, JNI handle: %u", fn, jniHandle);
-        return (false);
-    }
-
-    {
-        SyncEventGuard guard (pClient->mConnectingEvent);
-        pClient->mIsConnecting = true;
-
-        if (serviceName)
-            nfaStat = NFA_P2pConnectByName (pClient->mNfaP2pClientHandle,
-                    const_cast<char*>(serviceName), pClient->mClientConn->mMaxInfoUnit,
-                    pClient->mClientConn->mRecvWindow);
-        else if (destinationSap)
-            nfaStat = NFA_P2pConnectBySap (pClient->mNfaP2pClientHandle, destinationSap,
-                    pClient->mClientConn->mMaxInfoUnit, pClient->mClientConn->mRecvWindow);
-        if (nfaStat == NFA_STATUS_OK)
-        {
-            ALOGV("%s: wait for connected event  mConnectingEvent: 0x%p", fn, pClient.get());
-            pClient->mConnectingEvent.wait();
-        }
-    }
-
-    if (nfaStat == NFA_STATUS_OK)
-    {
-        if (pClient->mClientConn->mNfaConnHandle == NFA_HANDLE_INVALID)
-        {
-            removeConn (jniHandle);
-            nfaStat = NFA_STATUS_FAILED;
-        }
-        else
-            pClient->mIsConnecting = false;
-    }
-    else
-    {
-        removeConn (jniHandle);
-        ALOGE("%s: fail; error=0x%X", fn, nfaStat);
-    }
-
-    ALOGV("%s: exit", fn);
-    return nfaStat == NFA_STATUS_OK;
+bool PeerToPeer::createDataLinkConn(tJNI_HANDLE jniHandle,
+                                    const char* serviceName,
+                                    uint8_t destinationSap) {
+  static const char fn[] = "PeerToPeer::createDataLinkConn";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+  sp<P2pClient> pClient = NULL;
+
+  if ((pClient = findClient(jniHandle)) == NULL) {
+    LOG(ERROR) << StringPrintf("%s: can't find client, JNI handle: %u", fn,
+                               jniHandle);
+    return (false);
+  }
+
+  {
+    SyncEventGuard guard(pClient->mConnectingEvent);
+    pClient->mIsConnecting = true;
+
+    if (serviceName)
+      nfaStat = NFA_P2pConnectByName(pClient->mNfaP2pClientHandle,
+                                     const_cast<char*>(serviceName),
+                                     pClient->mClientConn->mMaxInfoUnit,
+                                     pClient->mClientConn->mRecvWindow);
+    else if (destinationSap)
+      nfaStat =
+          NFA_P2pConnectBySap(pClient->mNfaP2pClientHandle, destinationSap,
+                              pClient->mClientConn->mMaxInfoUnit,
+                              pClient->mClientConn->mRecvWindow);
+    if (nfaStat == NFA_STATUS_OK) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: wait for connected event  mConnectingEvent: 0x%p", fn,
+          pClient.get());
+      pClient->mConnectingEvent.wait();
+    }
+  }
+
+  if (nfaStat == NFA_STATUS_OK) {
+    if (pClient->mClientConn->mNfaConnHandle == NFA_HANDLE_INVALID) {
+      removeConn(jniHandle);
+      nfaStat = NFA_STATUS_FAILED;
+    } else
+      pClient->mIsConnecting = false;
+  } else {
+    removeConn(jniHandle);
+    LOG(ERROR) << StringPrintf("%s: fail; error=0x%X", fn, nfaStat);
+  }
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
+  return nfaStat == NFA_STATUS_OK;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        findClient
@@ -752,18 +727,16 @@ bool PeerToPeer::createDataLinkConn (tJNI_HANDLE jniHandle, const char* serviceN
 ** Returns:         PeerToPeer object.
 **
 *******************************************************************************/
-sp<P2pClient> PeerToPeer::findClient (tNFA_HANDLE nfaConnHandle)
-{
-    AutoMutex mutex(mMutex);
-    for (int i = 0; i < sMax; i++)
-    {
-        if ((mClients[i] != NULL) && (mClients[i]->mNfaP2pClientHandle == nfaConnHandle))
-            return (mClients[i]);
-    }
-    return (NULL);
+sp<P2pClient> PeerToPeer::findClient(tNFA_HANDLE nfaConnHandle) {
+  AutoMutex mutex(mMutex);
+  for (int i = 0; i < sMax; i++) {
+    if ((mClients[i] != NULL) &&
+        (mClients[i]->mNfaP2pClientHandle == nfaConnHandle))
+      return (mClients[i]);
+  }
+  return (NULL);
 }
 
-
 /*******************************************************************************
 **
 ** Function:        findClient
@@ -774,18 +747,16 @@ sp<P2pClient> PeerToPeer::findClient (tNFA_HANDLE nfaConnHandle)
 ** Returns:         PeerToPeer object.
 **
 *******************************************************************************/
-sp<P2pClient> PeerToPeer::findClient (tJNI_HANDLE jniHandle)
-{
-    AutoMutex mutex(mMutex);
-    for (int i = 0; i < sMax; i++)
-    {
-        if ((mClients[i] != NULL) && (mClients[i]->mClientConn->mJniHandle == jniHandle))
-            return (mClients[i]);
-    }
-    return (NULL);
+sp<P2pClient> PeerToPeer::findClient(tJNI_HANDLE jniHandle) {
+  AutoMutex mutex(mMutex);
+  for (int i = 0; i < sMax; i++) {
+    if ((mClients[i] != NULL) &&
+        (mClients[i]->mClientConn->mJniHandle == jniHandle))
+      return (mClients[i]);
+  }
+  return (NULL);
 }
 
-
 /*******************************************************************************
 **
 ** Function:        findClientCon
@@ -796,18 +767,16 @@ sp<P2pClient> PeerToPeer::findClient (tJNI_HANDLE jniHandle)
 ** Returns:         PeerToPeer object.
 **
 *******************************************************************************/
-sp<P2pClient> PeerToPeer::findClientCon (tNFA_HANDLE nfaConnHandle)
-{
-    AutoMutex mutex(mMutex);
-    for (int i = 0; i < sMax; i++)
-    {
-        if ((mClients[i] != NULL) && (mClients[i]->mClientConn->mNfaConnHandle == nfaConnHandle))
-            return (mClients[i]);
-    }
-    return (NULL);
+sp<P2pClient> PeerToPeer::findClientCon(tNFA_HANDLE nfaConnHandle) {
+  AutoMutex mutex(mMutex);
+  for (int i = 0; i < sMax; i++) {
+    if ((mClients[i] != NULL) &&
+        (mClients[i]->mClientConn->mNfaConnHandle == nfaConnHandle))
+      return (mClients[i]);
+  }
+  return (NULL);
 }
 
-
 /*******************************************************************************
 **
 ** Function:        findConnection
@@ -818,35 +787,30 @@ sp<P2pClient> PeerToPeer::findClientCon (tNFA_HANDLE nfaConnHandle)
 ** Returns:         PeerToPeer object.
 **
 *******************************************************************************/
-sp<NfaConn> PeerToPeer::findConnection (tNFA_HANDLE nfaConnHandle)
-{
-    AutoMutex mutex(mMutex);
-    // First, look through all the client control blocks
-    for (int ii = 0; ii < sMax; ii++)
-    {
-        if ( (mClients[ii] != NULL)
-           && (mClients[ii]->mClientConn->mNfaConnHandle == nfaConnHandle) ) {
-            return mClients[ii]->mClientConn;
-        }
-    }
-
-    // Not found yet. Look through all the server control blocks
-    for (int ii = 0; ii < sMax; ii++)
-    {
-        if (mServers[ii] != NULL)
-        {
-            sp<NfaConn> conn = mServers[ii]->findServerConnection(nfaConnHandle);
-            if (conn != NULL) {
-                return conn;
-            }
-        }
-    }
-
-    // Not found...
-    return NULL;
+sp<NfaConn> PeerToPeer::findConnection(tNFA_HANDLE nfaConnHandle) {
+  AutoMutex mutex(mMutex);
+  // First, look through all the client control blocks
+  for (int ii = 0; ii < sMax; ii++) {
+    if ((mClients[ii] != NULL) &&
+        (mClients[ii]->mClientConn->mNfaConnHandle == nfaConnHandle)) {
+      return mClients[ii]->mClientConn;
+    }
+  }
+
+  // Not found yet. Look through all the server control blocks
+  for (int ii = 0; ii < sMax; ii++) {
+    if (mServers[ii] != NULL) {
+      sp<NfaConn> conn = mServers[ii]->findServerConnection(nfaConnHandle);
+      if (conn != NULL) {
+        return conn;
+      }
+    }
+  }
+
+  // Not found...
+  return NULL;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        findConnection
@@ -857,35 +821,30 @@ sp<NfaConn> PeerToPeer::findConnection (tNFA_HANDLE nfaConnHandle)
 ** Returns:         PeerToPeer object.
 **
 *******************************************************************************/
-sp<NfaConn> PeerToPeer::findConnection (tJNI_HANDLE jniHandle)
-{
-    AutoMutex mutex(mMutex);
-    // First, look through all the client control blocks
-    for (int ii = 0; ii < sMax; ii++)
-    {
-        if ( (mClients[ii] != NULL)
-          && (mClients[ii]->mClientConn->mJniHandle == jniHandle) ) {
-            return mClients[ii]->mClientConn;
-        }
-    }
-
-    // Not found yet. Look through all the server control blocks
-    for (int ii = 0; ii < sMax; ii++)
-    {
-        if (mServers[ii] != NULL)
-        {
-            sp<NfaConn> conn = mServers[ii]->findServerConnection(jniHandle);
-            if (conn != NULL) {
-                return conn;
-            }
-        }
-    }
-
-    // Not found...
-    return NULL;
+sp<NfaConn> PeerToPeer::findConnection(tJNI_HANDLE jniHandle) {
+  AutoMutex mutex(mMutex);
+  // First, look through all the client control blocks
+  for (int ii = 0; ii < sMax; ii++) {
+    if ((mClients[ii] != NULL) &&
+        (mClients[ii]->mClientConn->mJniHandle == jniHandle)) {
+      return mClients[ii]->mClientConn;
+    }
+  }
+
+  // Not found yet. Look through all the server control blocks
+  for (int ii = 0; ii < sMax; ii++) {
+    if (mServers[ii] != NULL) {
+      sp<NfaConn> conn = mServers[ii]->findServerConnection(jniHandle);
+      if (conn != NULL) {
+        return conn;
+      }
+    }
+  }
+
+  // Not found...
+  return NULL;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        send
@@ -898,47 +857,51 @@ sp<NfaConn> PeerToPeer::findConnection (tJNI_HANDLE jniHandle)
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-bool PeerToPeer::send (tJNI_HANDLE jniHandle, uint8_t *buffer, uint16_t bufferLen)
-{
-    static const char fn [] = "PeerToPeer::send";
-    tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
-    sp<NfaConn>     pConn =  NULL;
-
-    if ((pConn = findConnection (jniHandle)) == NULL)
-    {
-        ALOGE("%s: can't find connection handle: %u", fn, jniHandle);
-        return (false);
-    }
-
-    ALOGV_IF((appl_trace_level>=BT_TRACE_LEVEL_DEBUG), "%s: send data; jniHandle: %u  nfaHandle: 0x%04X",
-            fn, pConn->mJniHandle, pConn->mNfaConnHandle);
-
-    while (true)
-    {
-        SyncEventGuard guard (pConn->mCongEvent);
-        nfaStat = NFA_P2pSendData (pConn->mNfaConnHandle, bufferLen, buffer);
-        if (nfaStat == NFA_STATUS_CONGESTED)
-            pConn->mCongEvent.wait (); //wait for NFA_P2P_CONGEST_EVT
-        else
-            break;
-
-        if (pConn->mNfaConnHandle == NFA_HANDLE_INVALID) //peer already disconnected
-        {
-            ALOGV_IF((appl_trace_level>=BT_TRACE_LEVEL_DEBUG), "%s: peer disconnected", fn);
-            return (false);
-        }
-    }
-
-    if (nfaStat == NFA_STATUS_OK)
-        ALOGV_IF((appl_trace_level>=BT_TRACE_LEVEL_DEBUG), "%s: exit OK; JNI handle: %u  NFA Handle: 0x%04x", fn, jniHandle, pConn->mNfaConnHandle);
+bool PeerToPeer::send(tJNI_HANDLE jniHandle, uint8_t* buffer,
+                      uint16_t bufferLen) {
+  static const char fn[] = "PeerToPeer::send";
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+  sp<NfaConn> pConn = NULL;
+
+  if ((pConn = findConnection(jniHandle)) == NULL) {
+    LOG(ERROR) << StringPrintf("%s: can't find connection handle: %u", fn,
+                               jniHandle);
+    return (false);
+  }
+
+  DLOG_IF(INFO, nfc_debug_enabled)  << StringPrintf(
+           "%s: send data; jniHandle: %u  nfaHandle: 0x%04X", fn,
+           pConn->mJniHandle, pConn->mNfaConnHandle);
+
+  while (true) {
+    SyncEventGuard guard(pConn->mCongEvent);
+    nfaStat = NFA_P2pSendData(pConn->mNfaConnHandle, bufferLen, buffer);
+    if (nfaStat == NFA_STATUS_CONGESTED)
+      pConn->mCongEvent.wait();  // wait for NFA_P2P_CONGEST_EVT
     else
-        ALOGE("%s: Data not sent; JNI handle: %u  NFA Handle: 0x%04x  error: 0x%04x",
-              fn, jniHandle, pConn->mNfaConnHandle, nfaStat);
+      break;
 
-    return nfaStat == NFA_STATUS_OK;
+    if (pConn->mNfaConnHandle ==
+        NFA_HANDLE_INVALID)  // peer already disconnected
+    {
+      DLOG_IF(INFO, nfc_debug_enabled)  << StringPrintf(
+               "%s: peer disconnected", fn);
+      return (false);
+    }
+  }
+
+  if (nfaStat == NFA_STATUS_OK)
+    DLOG_IF(INFO, nfc_debug_enabled)  << StringPrintf(
+             "%s: exit OK; JNI handle: %u  NFA Handle: 0x%04x", fn, jniHandle,
+             pConn->mNfaConnHandle);
+  else
+    LOG(ERROR) << StringPrintf(
+        "%s: Data not sent; JNI handle: %u  NFA Handle: 0x%04x  error: 0x%04x",
+        fn, jniHandle, pConn->mNfaConnHandle, nfaStat);
+
+  return nfaStat == NFA_STATUS_OK;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        receive
@@ -952,46 +915,51 @@ bool PeerToPeer::send (tJNI_HANDLE jniHandle, uint8_t *buffer, uint16_t bufferLe
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-bool PeerToPeer::receive (tJNI_HANDLE jniHandle, uint8_t* buffer, uint16_t bufferLen, uint16_t& actualLen)
-{
-    static const char fn [] = "PeerToPeer::receive";
-    ALOGV_IF((appl_trace_level>=BT_TRACE_LEVEL_DEBUG), "%s: enter; jniHandle: %u  bufferLen: %u", fn, jniHandle, bufferLen);
-    sp<NfaConn> pConn = NULL;
-    tNFA_STATUS stat = NFA_STATUS_FAILED;
-    uint32_t actualDataLen2 = 0;
-    bool    isMoreData = true;
-    bool retVal = false;
-
-    if ((pConn = findConnection (jniHandle)) == NULL)
+bool PeerToPeer::receive(tJNI_HANDLE jniHandle, uint8_t* buffer,
+                         uint16_t bufferLen, uint16_t& actualLen) {
+  static const char fn[] = "PeerToPeer::receive";
+  DLOG_IF(INFO, nfc_debug_enabled)  << StringPrintf(
+           "%s: enter; jniHandle: %u  bufferLen: %u", fn, jniHandle, bufferLen);
+  sp<NfaConn> pConn = NULL;
+  tNFA_STATUS stat = NFA_STATUS_FAILED;
+  uint32_t actualDataLen2 = 0;
+  bool isMoreData = true;
+  bool retVal = false;
+
+  if ((pConn = findConnection(jniHandle)) == NULL) {
+    LOG(ERROR) << StringPrintf("%s: can't find connection handle: %u", fn,
+                               jniHandle);
+    return (false);
+  }
+
+  DLOG_IF(INFO, nfc_debug_enabled)  << StringPrintf(
+           "%s: jniHandle: %u  nfaHandle: 0x%04X  buf len=%u", fn,
+           pConn->mJniHandle, pConn->mNfaConnHandle, bufferLen);
+
+  while (pConn->mNfaConnHandle != NFA_HANDLE_INVALID) {
+    // NFA_P2pReadData() is synchronous
+    stat = NFA_P2pReadData(pConn->mNfaConnHandle, bufferLen, &actualDataLen2,
+                           buffer, &isMoreData);
+    if ((stat == NFA_STATUS_OK) && (actualDataLen2 > 0))  // received some data
     {
-        ALOGE("%s: can't find connection handle: %u", fn, jniHandle);
-        return (false);
+      actualLen = (uint16_t)actualDataLen2;
+      retVal = true;
+      break;
     }
-
-    ALOGV_IF((appl_trace_level>=BT_TRACE_LEVEL_DEBUG), "%s: jniHandle: %u  nfaHandle: 0x%04X  buf len=%u", fn, pConn->mJniHandle, pConn->mNfaConnHandle, bufferLen);
-
-    while (pConn->mNfaConnHandle != NFA_HANDLE_INVALID)
+    DLOG_IF(INFO, nfc_debug_enabled)  << StringPrintf(
+             "%s: waiting for data...", fn);
     {
-        //NFA_P2pReadData() is synchronous
-        stat = NFA_P2pReadData (pConn->mNfaConnHandle, bufferLen, &actualDataLen2, buffer, &isMoreData);
-        if ((stat == NFA_STATUS_OK) && (actualDataLen2 > 0)) //received some data
-        {
-            actualLen = (uint16_t) actualDataLen2;
-            retVal = true;
-            break;
-        }
-        ALOGV_IF((appl_trace_level>=BT_TRACE_LEVEL_DEBUG), "%s: waiting for data...", fn);
-        {
-            SyncEventGuard guard (pConn->mReadEvent);
-            pConn->mReadEvent.wait();
-        }
-    } //while
+      SyncEventGuard guard(pConn->mReadEvent);
+      pConn->mReadEvent.wait();
+    }
+  }  // while
 
-    ALOGV_IF((appl_trace_level>=BT_TRACE_LEVEL_DEBUG), "%s: exit; nfa h: 0x%X  ok: %u  actual len: %u", fn, pConn->mNfaConnHandle, retVal, actualLen);
-    return retVal;
+  DLOG_IF(INFO, nfc_debug_enabled)  << StringPrintf(
+           "%s: exit; nfa h: 0x%X  ok: %u  actual len: %u", fn,
+           pConn->mNfaConnHandle, retVal, actualLen);
+  return retVal;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        disconnectConnOriented
@@ -1002,59 +970,59 @@ bool PeerToPeer::receive (tJNI_HANDLE jniHandle, uint8_t* buffer, uint16_t buffe
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-bool PeerToPeer::disconnectConnOriented (tJNI_HANDLE jniHandle)
-{
-    static const char fn [] = "PeerToPeer::disconnectConnOriented";
-    tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
-    sp<P2pClient>   pClient = NULL;
-    sp<NfaConn>     pConn = NULL;
-
-    ALOGV("%s: enter; jni handle: %u", fn, jniHandle);
-
-    if ((pConn = findConnection(jniHandle)) == NULL)
-    {
-        ALOGE("%s: can't find connection handle: %u", fn, jniHandle);
-        return (false);
-    }
-
-    // If this is a client, he may not be connected yet, so unblock him just in case
-    if ( ((pClient = findClient(jniHandle)) != NULL) && (pClient->mIsConnecting) )
-    {
-        SyncEventGuard guard (pClient->mConnectingEvent);
-        pClient->mConnectingEvent.notifyOne();
-        return (true);
-    }
-
-    {
-        SyncEventGuard guard1 (pConn->mCongEvent);
-        pConn->mCongEvent.notifyOne (); //unblock send() if congested
-    }
-    {
-        SyncEventGuard guard2 (pConn->mReadEvent);
-        pConn->mReadEvent.notifyOne (); //unblock receive()
-    }
+bool PeerToPeer::disconnectConnOriented(tJNI_HANDLE jniHandle) {
+  static const char fn[] = "PeerToPeer::disconnectConnOriented";
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+  sp<P2pClient> pClient = NULL;
+  sp<NfaConn> pConn = NULL;
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter; jni handle: %u", fn, jniHandle);
+
+  if ((pConn = findConnection(jniHandle)) == NULL) {
+    LOG(ERROR) << StringPrintf("%s: can't find connection handle: %u", fn,
+                               jniHandle);
+    return (false);
+  }
+
+  // If this is a client, he may not be connected yet, so unblock him just in
+  // case
+  if (((pClient = findClient(jniHandle)) != NULL) && (pClient->mIsConnecting)) {
+    SyncEventGuard guard(pClient->mConnectingEvent);
+    pClient->mConnectingEvent.notifyOne();
+    return (true);
+  }
+
+  {
+    SyncEventGuard guard1(pConn->mCongEvent);
+    pConn->mCongEvent.notifyOne();  // unblock send() if congested
+  }
+  {
+    SyncEventGuard guard2(pConn->mReadEvent);
+    pConn->mReadEvent.notifyOne();  // unblock receive()
+  }
+
+  if (pConn->mNfaConnHandle != NFA_HANDLE_INVALID) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: try disconn nfa h=0x%04X", fn, pConn->mNfaConnHandle);
+    SyncEventGuard guard(pConn->mDisconnectingEvent);
+    nfaStat = NFA_P2pDisconnect(pConn->mNfaConnHandle, false);
 
-    if (pConn->mNfaConnHandle != NFA_HANDLE_INVALID)
-    {
-        ALOGV("%s: try disconn nfa h=0x%04X", fn, pConn->mNfaConnHandle);
-        SyncEventGuard guard (pConn->mDisconnectingEvent);
-        nfaStat = NFA_P2pDisconnect (pConn->mNfaConnHandle, false);
-
-        if (nfaStat != NFA_STATUS_OK)
-            ALOGE("%s: fail p2p disconnect", fn);
-        else
-            pConn->mDisconnectingEvent.wait();
-    }
+    if (nfaStat != NFA_STATUS_OK)
+      LOG(ERROR) << StringPrintf("%s: fail p2p disconnect", fn);
+    else
+      pConn->mDisconnectingEvent.wait();
+  }
 
-    mDisconnectMutex.lock ();
-    removeConn (jniHandle);
-    mDisconnectMutex.unlock ();
+  mDisconnectMutex.lock();
+  removeConn(jniHandle);
+  mDisconnectMutex.unlock();
 
-    ALOGV("%s: exit; jni handle: %u", fn, jniHandle);
-    return nfaStat == NFA_STATUS_OK;
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit; jni handle: %u", fn, jniHandle);
+  return nfaStat == NFA_STATUS_OK;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        getRemoteMaxInfoUnit
@@ -1065,21 +1033,20 @@ bool PeerToPeer::disconnectConnOriented (tJNI_HANDLE jniHandle)
 ** Returns:         Peer's max information unit.
 **
 *******************************************************************************/
-uint16_t PeerToPeer::getRemoteMaxInfoUnit (tJNI_HANDLE jniHandle)
-{
-    static const char fn [] = "PeerToPeer::getRemoteMaxInfoUnit";
-    sp<NfaConn> pConn = NULL;
-
-    if ((pConn = findConnection(jniHandle)) == NULL)
-    {
-        ALOGE("%s: can't find client  jniHandle: %u", fn, jniHandle);
-        return 0;
-    }
-    ALOGV("%s: jniHandle: %u   MIU: %u", fn, jniHandle, pConn->mRemoteMaxInfoUnit);
-    return (pConn->mRemoteMaxInfoUnit);
+uint16_t PeerToPeer::getRemoteMaxInfoUnit(tJNI_HANDLE jniHandle) {
+  static const char fn[] = "PeerToPeer::getRemoteMaxInfoUnit";
+  sp<NfaConn> pConn = NULL;
+
+  if ((pConn = findConnection(jniHandle)) == NULL) {
+    LOG(ERROR) << StringPrintf("%s: can't find client  jniHandle: %u", fn,
+                               jniHandle);
+    return 0;
+  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: jniHandle: %u   MIU: %u", fn, jniHandle, pConn->mRemoteMaxInfoUnit);
+  return (pConn->mRemoteMaxInfoUnit);
 }
 
-
 /*******************************************************************************
 **
 ** Function:        getRemoteRecvWindow
@@ -1090,18 +1057,17 @@ uint16_t PeerToPeer::getRemoteMaxInfoUnit (tJNI_HANDLE jniHandle)
 ** Returns:         Peer's receive window size.
 **
 *******************************************************************************/
-uint8_t PeerToPeer::getRemoteRecvWindow (tJNI_HANDLE jniHandle)
-{
-    static const char fn [] = "PeerToPeer::getRemoteRecvWindow";
-    ALOGV("%s: client jni handle: %u", fn, jniHandle);
-    sp<NfaConn> pConn = NULL;
-
-    if ((pConn = findConnection(jniHandle)) == NULL)
-    {
-        ALOGE("%s: can't find client", fn);
-        return 0;
-    }
-    return pConn->mRemoteRecvWindow;
+uint8_t PeerToPeer::getRemoteRecvWindow(tJNI_HANDLE jniHandle) {
+  static const char fn[] = "PeerToPeer::getRemoteRecvWindow";
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: client jni handle: %u", fn, jniHandle);
+  sp<NfaConn> pConn = NULL;
+
+  if ((pConn = findConnection(jniHandle)) == NULL) {
+    LOG(ERROR) << StringPrintf("%s: can't find client", fn);
+    return 0;
+  }
+  return pConn->mRemoteRecvWindow;
 }
 
 /*******************************************************************************
@@ -1114,11 +1080,10 @@ uint8_t PeerToPeer::getRemoteRecvWindow (tJNI_HANDLE jniHandle)
 ** Returns:         None
 **
 *******************************************************************************/
-void PeerToPeer::setP2pListenMask (tNFA_TECHNOLOGY_MASK p2pListenMask) {
-    mP2pListenTechMask = p2pListenMask;
+void PeerToPeer::setP2pListenMask(tNFA_TECHNOLOGY_MASK p2pListenMask) {
+  mP2pListenTechMask = p2pListenMask;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        getP2pListenMask
@@ -1128,12 +1093,10 @@ void PeerToPeer::setP2pListenMask (tNFA_TECHNOLOGY_MASK p2pListenMask) {
 ** Returns:         Set of technologies.
 **
 *******************************************************************************/
-tNFA_TECHNOLOGY_MASK PeerToPeer::getP2pListenMask ()
-{
-    return mP2pListenTechMask;
+tNFA_TECHNOLOGY_MASK PeerToPeer::getP2pListenMask() {
+  return mP2pListenTechMask;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        resetP2pListenMask
@@ -1143,18 +1106,14 @@ tNFA_TECHNOLOGY_MASK PeerToPeer::getP2pListenMask ()
 ** Returns:         None.
 **
 *******************************************************************************/
-void PeerToPeer::resetP2pListenMask ()
-{
-    unsigned long num = 0;
-    mP2pListenTechMask = NFA_TECHNOLOGY_MASK_A
-                        | NFA_TECHNOLOGY_MASK_F
-                        | NFA_TECHNOLOGY_MASK_A_ACTIVE
-                        | NFA_TECHNOLOGY_MASK_F_ACTIVE;
-    if (GetNumValue ("P2P_LISTEN_TECH_MASK", &num, sizeof (num)))
-        mP2pListenTechMask = num;
+void PeerToPeer::resetP2pListenMask() {
+  mP2pListenTechMask = NFA_TECHNOLOGY_MASK_A | NFA_TECHNOLOGY_MASK_F |
+                       NFA_TECHNOLOGY_MASK_A_ACTIVE |
+                       NFA_TECHNOLOGY_MASK_F_ACTIVE;
+  if (NfcConfig::hasKey(NAME_P2P_LISTEN_TECH_MASK))
+    mP2pListenTechMask = NfcConfig::getUnsigned(NAME_P2P_LISTEN_TECH_MASK);
 }
 
-
 /*******************************************************************************
 **
 ** Function:        enableP2pListening
@@ -1165,38 +1124,36 @@ void PeerToPeer::resetP2pListenMask ()
 ** Returns:         None
 **
 *******************************************************************************/
-void PeerToPeer::enableP2pListening (bool isEnable)
-{
-    static const char    fn []   = "PeerToPeer::enableP2pListening";
-    tNFA_STATUS          nfaStat = NFA_STATUS_FAILED;
-
-    ALOGV("%s: enter isEnable: %u  mIsP2pListening: %u", fn, isEnable, mIsP2pListening);
-
-    // If request to enable P2P listening, and we were not already listening
-    if ( (isEnable == true) && (mIsP2pListening == false) && (mP2pListenTechMask != 0) )
-    {
-        SyncEventGuard guard (mSetTechEvent);
-        if ((nfaStat = NFA_SetP2pListenTech (mP2pListenTechMask)) == NFA_STATUS_OK)
-        {
-            mSetTechEvent.wait ();
-            mIsP2pListening = true;
-        }
-        else
-            ALOGE("%s: fail enable listen; error=0x%X", fn, nfaStat);
-    }
-    else if ( (isEnable == false) && (mIsP2pListening == true) )
-    {
-        SyncEventGuard guard (mSetTechEvent);
-        // Request to disable P2P listening, check if it was enabled
-        if ((nfaStat = NFA_SetP2pListenTech(0)) == NFA_STATUS_OK)
-        {
-            mSetTechEvent.wait ();
-            mIsP2pListening = false;
-        }
-        else
-            ALOGE("%s: fail disable listen; error=0x%X", fn, nfaStat);
-    }
-    ALOGV("%s: exit; mIsP2pListening: %u", fn, mIsP2pListening);
+void PeerToPeer::enableP2pListening(bool isEnable) {
+  static const char fn[] = "PeerToPeer::enableP2pListening";
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter isEnable: %u  mIsP2pListening: %u", fn,
+                      isEnable, mIsP2pListening);
+
+  // If request to enable P2P listening, and we were not already listening
+  if ((isEnable == true) && (mIsP2pListening == false) &&
+      (mP2pListenTechMask != 0)) {
+    SyncEventGuard guard(mSetTechEvent);
+    if ((nfaStat = NFA_SetP2pListenTech(mP2pListenTechMask)) == NFA_STATUS_OK) {
+      mSetTechEvent.wait();
+      mIsP2pListening = true;
+    } else
+      LOG(ERROR) << StringPrintf("%s: fail enable listen; error=0x%X", fn,
+                                 nfaStat);
+  } else if ((isEnable == false) && (mIsP2pListening == true)) {
+    SyncEventGuard guard(mSetTechEvent);
+    // Request to disable P2P listening, check if it was enabled
+    if ((nfaStat = NFA_SetP2pListenTech(0)) == NFA_STATUS_OK) {
+      mSetTechEvent.wait();
+      mIsP2pListening = false;
+    } else
+      LOG(ERROR) << StringPrintf("%s: fail disable listen; error=0x%X", fn,
+                                 nfaStat);
+  }
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit; mIsP2pListening: %u", fn, mIsP2pListening);
 }
 
 /*******************************************************************************
@@ -1209,61 +1166,51 @@ void PeerToPeer::enableP2pListening (bool isEnable)
 ** Returns:         None
 **
 *******************************************************************************/
-void PeerToPeer::handleNfcOnOff (bool isOn)
-{
-    static const char fn [] = "PeerToPeer::handleNfcOnOff";
-    ALOGV("%s: enter; is on=%u", fn, isOn);
-
-    mIsP2pListening = false;            // In both cases, P2P will not be listening
-
-    AutoMutex mutex(mMutex);
-    if (isOn)
-    {
-        // Start with no clients or servers
-        memset (mServers, 0, sizeof(mServers));
-        memset (mClients, 0, sizeof(mClients));
-    }
-    else
-    {
-        // Disconnect through all the clients
-        for (int ii = 0; ii < sMax; ii++)
-        {
-            if (mClients[ii] != NULL)
-            {
-                if (mClients[ii]->mClientConn->mNfaConnHandle == NFA_HANDLE_INVALID)
-                {
-                    SyncEventGuard guard (mClients[ii]->mConnectingEvent);
-                    mClients[ii]->mConnectingEvent.notifyOne();
-                }
-                else
-                {
-                    mClients[ii]->mClientConn->mNfaConnHandle = NFA_HANDLE_INVALID;
-                    {
-                        SyncEventGuard guard1 (mClients[ii]->mClientConn->mCongEvent);
-                        mClients[ii]->mClientConn->mCongEvent.notifyOne (); //unblock send()
-                    }
-                    {
-                        SyncEventGuard guard2 (mClients[ii]->mClientConn->mReadEvent);
-                        mClients[ii]->mClientConn->mReadEvent.notifyOne (); //unblock receive()
-                    }
-                }
-            }
-        } //loop
-
-        // Now look through all the server control blocks
-        for (int ii = 0; ii < sMax; ii++)
-        {
-            if (mServers[ii] != NULL)
-            {
-                mServers[ii]->unblockAll();
-            }
-        } //loop
-
-    }
-    ALOGV("%s: exit", fn);
+void PeerToPeer::handleNfcOnOff(bool isOn) {
+  static const char fn[] = "PeerToPeer::handleNfcOnOff";
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter; is on=%u", fn, isOn);
+
+  mIsP2pListening = false;  // In both cases, P2P will not be listening
+
+  AutoMutex mutex(mMutex);
+  if (isOn) {
+    // Start with no clients or servers
+    memset(mServers, 0, sizeof(mServers));
+    memset(mClients, 0, sizeof(mClients));
+  } else {
+    // Disconnect through all the clients
+    for (int ii = 0; ii < sMax; ii++) {
+      if (mClients[ii] != NULL) {
+        if (mClients[ii]->mClientConn->mNfaConnHandle == NFA_HANDLE_INVALID) {
+          SyncEventGuard guard(mClients[ii]->mConnectingEvent);
+          mClients[ii]->mConnectingEvent.notifyOne();
+        } else {
+          mClients[ii]->mClientConn->mNfaConnHandle = NFA_HANDLE_INVALID;
+          {
+            SyncEventGuard guard1(mClients[ii]->mClientConn->mCongEvent);
+            mClients[ii]->mClientConn->mCongEvent.notifyOne();  // unblock
+                                                                // send()
+          }
+          {
+            SyncEventGuard guard2(mClients[ii]->mClientConn->mReadEvent);
+            mClients[ii]
+                ->mClientConn->mReadEvent.notifyOne();  // unblock receive()
+          }
+        }
+      }
+    }  // loop
+
+    // Now look through all the server control blocks
+    for (int ii = 0; ii < sMax; ii++) {
+      if (mServers[ii] != NULL) {
+        mServers[ii]->unblockAll();
+      }
+    }  // loop
+  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nfaServerCallback
@@ -1275,152 +1222,171 @@ void PeerToPeer::handleNfcOnOff (bool isOn)
 ** Returns:         None
 **
 *******************************************************************************/
-void PeerToPeer::nfaServerCallback (tNFA_P2P_EVT p2pEvent, tNFA_P2P_EVT_DATA* eventData)
-{
-    static const char fn [] = "PeerToPeer::nfaServerCallback";
-    sp<P2pServer>   pSrv = NULL;
-    sp<NfaConn>     pConn = NULL;
-
-    ALOGV_IF((appl_trace_level>=BT_TRACE_LEVEL_DEBUG), "%s: enter; event=0x%X", fn, p2pEvent);
-
-    switch (p2pEvent)
-    {
-    case NFA_P2P_REG_SERVER_EVT:  // NFA_P2pRegisterServer() has started to listen
-        ALOGV("%s: NFA_P2P_REG_SERVER_EVT; handle: 0x%04x; service sap=0x%02x  name: %s", fn,
-              eventData->reg_server.server_handle, eventData->reg_server.server_sap, eventData->reg_server.service_name);
-
-        sP2p.mMutex.lock();
-        pSrv = sP2p.findServerLocked(eventData->reg_server.service_name);
-        sP2p.mMutex.unlock();
-        if (pSrv == NULL)
-        {
-            ALOGE("%s: NFA_P2P_REG_SERVER_EVT for unknown service: %s", fn, eventData->reg_server.service_name);
-        }
-        else
-        {
-            SyncEventGuard guard (pSrv->mRegServerEvent);
-            pSrv->mNfaP2pServerHandle = eventData->reg_server.server_handle;
-            pSrv->mRegServerEvent.notifyOne(); //unblock registerServer()
-        }
-        break;
-
-    case NFA_P2P_ACTIVATED_EVT: //remote device has activated
-        ALOGV("%s: NFA_P2P_ACTIVATED_EVT; handle: 0x%04x", fn, eventData->activated.handle);
-        break;
+void PeerToPeer::nfaServerCallback(tNFA_P2P_EVT p2pEvent,
+                                   tNFA_P2P_EVT_DATA* eventData) {
+  static const char fn[] = "PeerToPeer::nfaServerCallback";
+  sp<P2pServer> pSrv = NULL;
+  sp<NfaConn> pConn = NULL;
+
+  DLOG_IF(INFO, nfc_debug_enabled)  << StringPrintf( "%s: enter; event=0x%X",
+           fn, p2pEvent);
+
+  switch (p2pEvent) {
+    case NFA_P2P_REG_SERVER_EVT:  // NFA_P2pRegisterServer() has started to
+                                  // listen
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_P2P_REG_SERVER_EVT; handle: 0x%04x; service sap=0x%02x  "
+          "name: %s",
+          fn, eventData->reg_server.server_handle,
+          eventData->reg_server.server_sap, eventData->reg_server.service_name);
+
+      sP2p.mMutex.lock();
+      pSrv = sP2p.findServerLocked(eventData->reg_server.service_name);
+      sP2p.mMutex.unlock();
+      if (pSrv == NULL) {
+        LOG(ERROR) << StringPrintf(
+            "%s: NFA_P2P_REG_SERVER_EVT for unknown service: %s", fn,
+            eventData->reg_server.service_name);
+      } else {
+        SyncEventGuard guard(pSrv->mRegServerEvent);
+        pSrv->mNfaP2pServerHandle = eventData->reg_server.server_handle;
+        pSrv->mRegServerEvent.notifyOne();  // unblock registerServer()
+      }
+      break;
+
+    case NFA_P2P_ACTIVATED_EVT:  // remote device has activated
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: NFA_P2P_ACTIVATED_EVT; handle: 0x%04x", fn,
+                          eventData->activated.handle);
+      break;
 
     case NFA_P2P_DEACTIVATED_EVT:
-        ALOGV("%s: NFA_P2P_DEACTIVATED_EVT; handle: 0x%04x", fn, eventData->activated.handle);
-        break;
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: NFA_P2P_DEACTIVATED_EVT; handle: 0x%04x", fn,
+                          eventData->activated.handle);
+      break;
 
     case NFA_P2P_CONN_REQ_EVT:
-        ALOGV("%s: NFA_P2P_CONN_REQ_EVT; nfa server h=0x%04x; nfa conn h=0x%04x; remote sap=0x%02x", fn,
-                eventData->conn_req.server_handle, eventData->conn_req.conn_handle, eventData->conn_req.remote_sap);
-
-        sP2p.mMutex.lock();
-        pSrv = sP2p.findServerLocked(eventData->conn_req.server_handle);
-        sP2p.mMutex.unlock();
-        if (pSrv == NULL)
-        {
-            ALOGE("%s: NFA_P2P_CONN_REQ_EVT; unknown server h", fn);
-            return;
-        }
-        ALOGV("%s: NFA_P2P_CONN_REQ_EVT; server jni h=%u", fn, pSrv->mJniHandle);
-
-        // Look for a connection block that is waiting (handle invalid)
-        if ((pConn = pSrv->findServerConnection((tNFA_HANDLE) NFA_HANDLE_INVALID)) == NULL)
-        {
-            ALOGE("%s: NFA_P2P_CONN_REQ_EVT; server not listening", fn);
-        }
-        else
-        {
-            SyncEventGuard guard (pSrv->mConnRequestEvent);
-            pConn->mNfaConnHandle = eventData->conn_req.conn_handle;
-            pConn->mRemoteMaxInfoUnit = eventData->conn_req.remote_miu;
-            pConn->mRemoteRecvWindow = eventData->conn_req.remote_rw;
-            ALOGV("%s: NFA_P2P_CONN_REQ_EVT; server jni h=%u; conn jni h=%u; notify conn req", fn, pSrv->mJniHandle, pConn->mJniHandle);
-            pSrv->mConnRequestEvent.notifyOne(); //unblock accept()
-        }
-        break;
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_P2P_CONN_REQ_EVT; nfa server h=0x%04x; nfa conn h=0x%04x; "
+          "remote sap=0x%02x",
+          fn, eventData->conn_req.server_handle,
+          eventData->conn_req.conn_handle, eventData->conn_req.remote_sap);
+
+      sP2p.mMutex.lock();
+      pSrv = sP2p.findServerLocked(eventData->conn_req.server_handle);
+      sP2p.mMutex.unlock();
+      if (pSrv == NULL) {
+        LOG(ERROR) << StringPrintf("%s: NFA_P2P_CONN_REQ_EVT; unknown server h",
+                                   fn);
+        return;
+      }
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_P2P_CONN_REQ_EVT; server jni h=%u", fn, pSrv->mJniHandle);
+
+      // Look for a connection block that is waiting (handle invalid)
+      if ((pConn = pSrv->findServerConnection(
+               (tNFA_HANDLE)NFA_HANDLE_INVALID)) == NULL) {
+        LOG(ERROR) << StringPrintf(
+            "%s: NFA_P2P_CONN_REQ_EVT; server not listening", fn);
+      } else {
+        SyncEventGuard guard(pSrv->mConnRequestEvent);
+        pConn->mNfaConnHandle = eventData->conn_req.conn_handle;
+        pConn->mRemoteMaxInfoUnit = eventData->conn_req.remote_miu;
+        pConn->mRemoteRecvWindow = eventData->conn_req.remote_rw;
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: NFA_P2P_CONN_REQ_EVT; server jni h=%u; conn jni h=%u; notify "
+            "conn req",
+            fn, pSrv->mJniHandle, pConn->mJniHandle);
+        pSrv->mConnRequestEvent.notifyOne();  // unblock accept()
+      }
+      break;
 
     case NFA_P2P_CONNECTED_EVT:
-        ALOGV("%s: NFA_P2P_CONNECTED_EVT; h=0x%x  remote sap=0x%X", fn,
-                eventData->connected.client_handle, eventData->connected.remote_sap);
-        break;
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_P2P_CONNECTED_EVT; h=0x%x  remote sap=0x%X", fn,
+          eventData->connected.client_handle, eventData->connected.remote_sap);
+      break;
 
     case NFA_P2P_DISC_EVT:
-        ALOGV("%s: NFA_P2P_DISC_EVT; h=0x%04x; reason=0x%X", fn, eventData->disc.handle, eventData->disc.reason);
-        // Look for the connection block
-        if ((pConn = sP2p.findConnection(eventData->disc.handle)) == NULL)
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: NFA_P2P_DISC_EVT; h=0x%04x; reason=0x%X", fn,
+                          eventData->disc.handle, eventData->disc.reason);
+      // Look for the connection block
+      if ((pConn = sP2p.findConnection(eventData->disc.handle)) == NULL) {
+        LOG(ERROR) << StringPrintf(
+            "%s: NFA_P2P_DISC_EVT: can't find conn for NFA handle: 0x%04x", fn,
+            eventData->disc.handle);
+      } else {
+        sP2p.mDisconnectMutex.lock();
+        pConn->mNfaConnHandle = NFA_HANDLE_INVALID;
         {
-            ALOGE("%s: NFA_P2P_DISC_EVT: can't find conn for NFA handle: 0x%04x", fn, eventData->disc.handle);
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "%s: NFA_P2P_DISC_EVT; try guard disconn event", fn);
+          SyncEventGuard guard3(pConn->mDisconnectingEvent);
+          pConn->mDisconnectingEvent.notifyOne();
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "%s: NFA_P2P_DISC_EVT; notified disconn event", fn);
         }
-        else
-        {
-            sP2p.mDisconnectMutex.lock ();
-            pConn->mNfaConnHandle = NFA_HANDLE_INVALID;
-            {
-                ALOGV("%s: NFA_P2P_DISC_EVT; try guard disconn event", fn);
-                SyncEventGuard guard3 (pConn->mDisconnectingEvent);
-                pConn->mDisconnectingEvent.notifyOne ();
-                ALOGV("%s: NFA_P2P_DISC_EVT; notified disconn event", fn);
-            }
-            {
-                ALOGV("%s: NFA_P2P_DISC_EVT; try guard congest event", fn);
-                SyncEventGuard guard1 (pConn->mCongEvent);
-                pConn->mCongEvent.notifyOne (); //unblock write (if congested)
-                ALOGV("%s: NFA_P2P_DISC_EVT; notified congest event", fn);
-            }
-            {
-                ALOGV("%s: NFA_P2P_DISC_EVT; try guard read event", fn);
-                SyncEventGuard guard2 (pConn->mReadEvent);
-                pConn->mReadEvent.notifyOne (); //unblock receive()
-                ALOGV("%s: NFA_P2P_DISC_EVT; notified read event", fn);
-            }
-            sP2p.mDisconnectMutex.unlock ();
-        }
-        break;
-
-    case NFA_P2P_DATA_EVT:
-        // Look for the connection block
-        if ((pConn = sP2p.findConnection(eventData->data.handle)) == NULL)
         {
-            ALOGE("%s: NFA_P2P_DATA_EVT: can't find conn for NFA handle: 0x%04x", fn, eventData->data.handle);
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "%s: NFA_P2P_DISC_EVT; try guard congest event", fn);
+          SyncEventGuard guard1(pConn->mCongEvent);
+          pConn->mCongEvent.notifyOne();  // unblock write (if congested)
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "%s: NFA_P2P_DISC_EVT; notified congest event", fn);
         }
-        else
         {
-            ALOGV_IF((appl_trace_level>=BT_TRACE_LEVEL_DEBUG), "%s: NFA_P2P_DATA_EVT; h=0x%X; remote sap=0x%X", fn,
-                    eventData->data.handle, eventData->data.remote_sap);
-            SyncEventGuard guard (pConn->mReadEvent);
-            pConn->mReadEvent.notifyOne();
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("%s: NFA_P2P_DISC_EVT; try guard read event", fn);
+          SyncEventGuard guard2(pConn->mReadEvent);
+          pConn->mReadEvent.notifyOne();  // unblock receive()
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("%s: NFA_P2P_DISC_EVT; notified read event", fn);
         }
-        break;
+        sP2p.mDisconnectMutex.unlock();
+      }
+      break;
+
+    case NFA_P2P_DATA_EVT:
+      // Look for the connection block
+      if ((pConn = sP2p.findConnection(eventData->data.handle)) == NULL) {
+        LOG(ERROR) << StringPrintf(
+            "%s: NFA_P2P_DATA_EVT: can't find conn for NFA handle: 0x%04x", fn,
+            eventData->data.handle);
+      } else {
+        DLOG_IF(INFO, nfc_debug_enabled)  << StringPrintf(
+                 "%s: NFA_P2P_DATA_EVT; h=0x%X; remote sap=0x%X", fn,
+                 eventData->data.handle, eventData->data.remote_sap);
+        SyncEventGuard guard(pConn->mReadEvent);
+        pConn->mReadEvent.notifyOne();
+      }
+      break;
 
     case NFA_P2P_CONGEST_EVT:
-        // Look for the connection block
-        if ((pConn = sP2p.findConnection(eventData->congest.handle)) == NULL)
-        {
-            ALOGE("%s: NFA_P2P_CONGEST_EVT: can't find conn for NFA handle: 0x%04x", fn, eventData->congest.handle);
-        }
-        else
-        {
-            ALOGV("%s: NFA_P2P_CONGEST_EVT; nfa handle: 0x%04x  congested: %u", fn,
-                    eventData->congest.handle, eventData->congest.is_congested);
-            if (eventData->congest.is_congested == false)
-            {
-                SyncEventGuard guard (pConn->mCongEvent);
-                pConn->mCongEvent.notifyOne();
-            }
+      // Look for the connection block
+      if ((pConn = sP2p.findConnection(eventData->congest.handle)) == NULL) {
+        LOG(ERROR) << StringPrintf(
+            "%s: NFA_P2P_CONGEST_EVT: can't find conn for NFA handle: 0x%04x",
+            fn, eventData->congest.handle);
+      } else {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: NFA_P2P_CONGEST_EVT; nfa handle: 0x%04x  congested: %u", fn,
+            eventData->congest.handle, eventData->congest.is_congested);
+        if (eventData->congest.is_congested == false) {
+          SyncEventGuard guard(pConn->mCongEvent);
+          pConn->mCongEvent.notifyOne();
         }
-        break;
+      }
+      break;
 
     default:
-        ALOGE("%s: unknown event 0x%X ????", fn, p2pEvent);
-        break;
-    }
-    ALOGV_IF((appl_trace_level>=BT_TRACE_LEVEL_DEBUG), "%s: exit", fn);
+      LOG(ERROR) << StringPrintf("%s: unknown event 0x%X ????", fn, p2pEvent);
+      break;
+  }
+  DLOG_IF(INFO, nfc_debug_enabled)  << StringPrintf( "%s: exit", fn);
 }
 
-
 /*******************************************************************************
 **
 ** Function:        nfaClientCallback
@@ -1432,146 +1398,161 @@ void PeerToPeer::nfaServerCallback (tNFA_P2P_EVT p2pEvent, tNFA_P2P_EVT_DATA* ev
 ** Returns:         None
 **
 *******************************************************************************/
-void PeerToPeer::nfaClientCallback (tNFA_P2P_EVT p2pEvent, tNFA_P2P_EVT_DATA* eventData)
-{
-    static const char fn [] = "PeerToPeer::nfaClientCallback";
-    sp<NfaConn>     pConn = NULL;
-    sp<P2pClient>   pClient = NULL;
+void PeerToPeer::nfaClientCallback(tNFA_P2P_EVT p2pEvent,
+                                   tNFA_P2P_EVT_DATA* eventData) {
+  static const char fn[] = "PeerToPeer::nfaClientCallback";
+  sp<NfaConn> pConn = NULL;
+  sp<P2pClient> pClient = NULL;
 
-    ALOGV_IF((appl_trace_level>=BT_TRACE_LEVEL_DEBUG), "%s: enter; event=%u", fn, p2pEvent);
+  DLOG_IF(INFO, nfc_debug_enabled)  << StringPrintf( "%s: enter; event=%u",
+           fn, p2pEvent);
 
-    switch (p2pEvent)
-    {
+  switch (p2pEvent) {
     case NFA_P2P_REG_CLIENT_EVT:
-        // Look for a client that is trying to register
-        if ((pClient = sP2p.findClient ((tNFA_HANDLE)NFA_HANDLE_INVALID)) == NULL)
-        {
-            ALOGE("%s: NFA_P2P_REG_CLIENT_EVT: can't find waiting client", fn);
-        }
-        else
-        {
-            ALOGV("%s: NFA_P2P_REG_CLIENT_EVT; Conn Handle: 0x%04x, pClient: 0x%p", fn, eventData->reg_client.client_handle, pClient.get());
-
-            SyncEventGuard guard (pClient->mRegisteringEvent);
-            pClient->mNfaP2pClientHandle = eventData->reg_client.client_handle;
-            pClient->mRegisteringEvent.notifyOne();
-        }
-        break;
+      // Look for a client that is trying to register
+      if ((pClient = sP2p.findClient((tNFA_HANDLE)NFA_HANDLE_INVALID)) ==
+          NULL) {
+        LOG(ERROR) << StringPrintf(
+            "%s: NFA_P2P_REG_CLIENT_EVT: can't find waiting client", fn);
+      } else {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: NFA_P2P_REG_CLIENT_EVT; Conn Handle: 0x%04x, pClient: 0x%p",
+            fn, eventData->reg_client.client_handle, pClient.get());
+
+        SyncEventGuard guard(pClient->mRegisteringEvent);
+        pClient->mNfaP2pClientHandle = eventData->reg_client.client_handle;
+        pClient->mRegisteringEvent.notifyOne();
+      }
+      break;
 
     case NFA_P2P_ACTIVATED_EVT:
-        // Look for a client that is trying to register
-        if ((pClient = sP2p.findClient (eventData->activated.handle)) == NULL)
-        {
-            ALOGE("%s: NFA_P2P_ACTIVATED_EVT: can't find client", fn);
-        }
-        else
-        {
-            ALOGV("%s: NFA_P2P_ACTIVATED_EVT; Conn Handle: 0x%04x, pClient: 0x%p", fn, eventData->activated.handle, pClient.get());
-        }
-        break;
+      // Look for a client that is trying to register
+      if ((pClient = sP2p.findClient(eventData->activated.handle)) == NULL) {
+        LOG(ERROR) << StringPrintf(
+            "%s: NFA_P2P_ACTIVATED_EVT: can't find client", fn);
+      } else {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: NFA_P2P_ACTIVATED_EVT; Conn Handle: 0x%04x, pClient: 0x%p", fn,
+            eventData->activated.handle, pClient.get());
+      }
+      break;
 
     case NFA_P2P_DEACTIVATED_EVT:
-        ALOGV("%s: NFA_P2P_DEACTIVATED_EVT: conn handle: 0x%X", fn, eventData->deactivated.handle);
-        break;
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: NFA_P2P_DEACTIVATED_EVT: conn handle: 0x%X", fn,
+                          eventData->deactivated.handle);
+      break;
 
     case NFA_P2P_CONNECTED_EVT:
-        // Look for the client that is trying to connect
-        if ((pClient = sP2p.findClient (eventData->connected.client_handle)) == NULL)
-        {
-            ALOGE("%s: NFA_P2P_CONNECTED_EVT: can't find client: 0x%04x", fn, eventData->connected.client_handle);
-        }
-        else
-        {
-            ALOGV("%s: NFA_P2P_CONNECTED_EVT; client_handle=0x%04x  conn_handle: 0x%04x  remote sap=0x%X  pClient: 0x%p", fn,
-                    eventData->connected.client_handle, eventData->connected.conn_handle, eventData->connected.remote_sap, pClient.get());
-
-            SyncEventGuard guard (pClient->mConnectingEvent);
-            pClient->mClientConn->mNfaConnHandle     = eventData->connected.conn_handle;
-            pClient->mClientConn->mRemoteMaxInfoUnit = eventData->connected.remote_miu;
-            pClient->mClientConn->mRemoteRecvWindow  = eventData->connected.remote_rw;
-            pClient->mConnectingEvent.notifyOne(); //unblock createDataLinkConn()
-        }
-        break;
+      // Look for the client that is trying to connect
+      if ((pClient = sP2p.findClient(eventData->connected.client_handle)) ==
+          NULL) {
+        LOG(ERROR) << StringPrintf(
+            "%s: NFA_P2P_CONNECTED_EVT: can't find client: 0x%04x", fn,
+            eventData->connected.client_handle);
+      } else {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: NFA_P2P_CONNECTED_EVT; client_handle=0x%04x  conn_handle: "
+            "0x%04x  remote sap=0x%X  pClient: 0x%p",
+            fn, eventData->connected.client_handle,
+            eventData->connected.conn_handle, eventData->connected.remote_sap,
+            pClient.get());
+
+        SyncEventGuard guard(pClient->mConnectingEvent);
+        pClient->mClientConn->mNfaConnHandle = eventData->connected.conn_handle;
+        pClient->mClientConn->mRemoteMaxInfoUnit =
+            eventData->connected.remote_miu;
+        pClient->mClientConn->mRemoteRecvWindow =
+            eventData->connected.remote_rw;
+        pClient->mConnectingEvent.notifyOne();  // unblock createDataLinkConn()
+      }
+      break;
 
     case NFA_P2P_DISC_EVT:
-        ALOGV("%s: NFA_P2P_DISC_EVT; h=0x%04x; reason=0x%X", fn, eventData->disc.handle, eventData->disc.reason);
-        // Look for the connection block
-        if ((pConn = sP2p.findConnection(eventData->disc.handle)) == NULL)
-        {
-            // If no connection, may be a client that is trying to connect
-            if ((pClient = sP2p.findClient (eventData->disc.handle)) == NULL)
-            {
-                ALOGE("%s: NFA_P2P_DISC_EVT: can't find client for NFA handle: 0x%04x", fn, eventData->disc.handle);
-                return;
-            }
-            // Unblock createDataLinkConn()
-            SyncEventGuard guard (pClient->mConnectingEvent);
-            pClient->mConnectingEvent.notifyOne();
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: NFA_P2P_DISC_EVT; h=0x%04x; reason=0x%X", fn,
+                          eventData->disc.handle, eventData->disc.reason);
+      // Look for the connection block
+      if ((pConn = sP2p.findConnection(eventData->disc.handle)) == NULL) {
+        // If no connection, may be a client that is trying to connect
+        if ((pClient = sP2p.findClient(eventData->disc.handle)) == NULL) {
+          LOG(ERROR) << StringPrintf(
+              "%s: NFA_P2P_DISC_EVT: can't find client for NFA handle: 0x%04x",
+              fn, eventData->disc.handle);
+          return;
         }
-        else
+        // Unblock createDataLinkConn()
+        SyncEventGuard guard(pClient->mConnectingEvent);
+        pClient->mConnectingEvent.notifyOne();
+      } else {
+        sP2p.mDisconnectMutex.lock();
+        pConn->mNfaConnHandle = NFA_HANDLE_INVALID;
         {
-            sP2p.mDisconnectMutex.lock ();
-            pConn->mNfaConnHandle = NFA_HANDLE_INVALID;
-            {
-                ALOGV("%s: NFA_P2P_DISC_EVT; try guard disconn event", fn);
-                SyncEventGuard guard3 (pConn->mDisconnectingEvent);
-                pConn->mDisconnectingEvent.notifyOne ();
-                ALOGV("%s: NFA_P2P_DISC_EVT; notified disconn event", fn);
-            }
-            {
-                ALOGV("%s: NFA_P2P_DISC_EVT; try guard congest event", fn);
-                SyncEventGuard guard1 (pConn->mCongEvent);
-                pConn->mCongEvent.notifyOne(); //unblock write (if congested)
-                ALOGV("%s: NFA_P2P_DISC_EVT; notified congest event", fn);
-            }
-            {
-                ALOGV("%s: NFA_P2P_DISC_EVT; try guard read event", fn);
-                SyncEventGuard guard2 (pConn->mReadEvent);
-                pConn->mReadEvent.notifyOne(); //unblock receive()
-                ALOGV("%s: NFA_P2P_DISC_EVT; notified read event", fn);
-            }
-            sP2p.mDisconnectMutex.unlock ();
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "%s: NFA_P2P_DISC_EVT; try guard disconn event", fn);
+          SyncEventGuard guard3(pConn->mDisconnectingEvent);
+          pConn->mDisconnectingEvent.notifyOne();
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "%s: NFA_P2P_DISC_EVT; notified disconn event", fn);
         }
-        break;
-
-    case NFA_P2P_DATA_EVT:
-        // Look for the connection block
-        if ((pConn = sP2p.findConnection(eventData->data.handle)) == NULL)
         {
-            ALOGE("%s: NFA_P2P_DATA_EVT: can't find conn for NFA handle: 0x%04x", fn, eventData->data.handle);
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "%s: NFA_P2P_DISC_EVT; try guard congest event", fn);
+          SyncEventGuard guard1(pConn->mCongEvent);
+          pConn->mCongEvent.notifyOne();  // unblock write (if congested)
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "%s: NFA_P2P_DISC_EVT; notified congest event", fn);
         }
-        else
         {
-            ALOGV_IF((appl_trace_level>=BT_TRACE_LEVEL_DEBUG), "%s: NFA_P2P_DATA_EVT; h=0x%X; remote sap=0x%X", fn,
-                    eventData->data.handle, eventData->data.remote_sap);
-            SyncEventGuard guard (pConn->mReadEvent);
-            pConn->mReadEvent.notifyOne();
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("%s: NFA_P2P_DISC_EVT; try guard read event", fn);
+          SyncEventGuard guard2(pConn->mReadEvent);
+          pConn->mReadEvent.notifyOne();  // unblock receive()
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("%s: NFA_P2P_DISC_EVT; notified read event", fn);
         }
-        break;
+        sP2p.mDisconnectMutex.unlock();
+      }
+      break;
 
-    case NFA_P2P_CONGEST_EVT:
-        // Look for the connection block
-        if ((pConn = sP2p.findConnection(eventData->congest.handle)) == NULL)
-        {
-            ALOGE("%s: NFA_P2P_CONGEST_EVT: can't find conn for NFA handle: 0x%04x", fn, eventData->congest.handle);
-        }
-        else
-        {
-            ALOGV_IF((appl_trace_level>=BT_TRACE_LEVEL_DEBUG), "%s: NFA_P2P_CONGEST_EVT; nfa handle: 0x%04x  congested: %u", fn,
-                    eventData->congest.handle, eventData->congest.is_congested);
+    case NFA_P2P_DATA_EVT:
+      // Look for the connection block
+      if ((pConn = sP2p.findConnection(eventData->data.handle)) == NULL) {
+        LOG(ERROR) << StringPrintf(
+            "%s: NFA_P2P_DATA_EVT: can't find conn for NFA handle: 0x%04x", fn,
+            eventData->data.handle);
+      } else {
+        DLOG_IF(INFO, nfc_debug_enabled)  << StringPrintf(
+                 "%s: NFA_P2P_DATA_EVT; h=0x%X; remote sap=0x%X", fn,
+                 eventData->data.handle, eventData->data.remote_sap);
+        SyncEventGuard guard(pConn->mReadEvent);
+        pConn->mReadEvent.notifyOne();
+      }
+      break;
 
-            SyncEventGuard guard (pConn->mCongEvent);
-            pConn->mCongEvent.notifyOne();
-        }
-        break;
+    case NFA_P2P_CONGEST_EVT:
+      // Look for the connection block
+      if ((pConn = sP2p.findConnection(eventData->congest.handle)) == NULL) {
+        LOG(ERROR) << StringPrintf(
+            "%s: NFA_P2P_CONGEST_EVT: can't find conn for NFA handle: 0x%04x",
+            fn, eventData->congest.handle);
+      } else {
+        DLOG_IF(INFO, nfc_debug_enabled)  << StringPrintf(
+                 "%s: NFA_P2P_CONGEST_EVT; nfa handle: 0x%04x  congested: %u",
+                 fn, eventData->congest.handle,
+                 eventData->congest.is_congested);
+
+        SyncEventGuard guard(pConn->mCongEvent);
+        pConn->mCongEvent.notifyOne();
+      }
+      break;
 
     default:
-        ALOGE("%s: unknown event 0x%X ????", fn, p2pEvent);
-        break;
-    }
+      LOG(ERROR) << StringPrintf("%s: unknown event 0x%X ????", fn, p2pEvent);
+      break;
+  }
 }
 
-
 /*******************************************************************************
 **
 ** Function:        connectionEventHandler
@@ -1583,20 +1564,17 @@ void PeerToPeer::nfaClientCallback (tNFA_P2P_EVT p2pEvent, tNFA_P2P_EVT_DATA* ev
 ** Returns:         None
 **
 *******************************************************************************/
-void PeerToPeer::connectionEventHandler (uint8_t event, tNFA_CONN_EVT_DATA* /*eventData*/)
-{
-    switch (event)
-    {
-    case NFA_SET_P2P_LISTEN_TECH_EVT:
-        {
-            SyncEventGuard guard (mSetTechEvent);
-            mSetTechEvent.notifyOne(); //unblock NFA_SetP2pListenTech()
-            break;
-        }
-    }
+void PeerToPeer::connectionEventHandler(uint8_t event,
+                                        tNFA_CONN_EVT_DATA* /*eventData*/) {
+  switch (event) {
+    case NFA_SET_P2P_LISTEN_TECH_EVT: {
+      SyncEventGuard guard(mSetTechEvent);
+      mSetTechEvent.notifyOne();  // unblock NFA_SetP2pListenTech()
+      break;
+    }
+  }
 }
 
-
 /*******************************************************************************
 **
 ** Function:        getNextJniHandle
@@ -1606,21 +1584,18 @@ void PeerToPeer::connectionEventHandler (uint8_t event, tNFA_CONN_EVT_DATA* /*ev
 ** Returns:         A new JNI handle.
 **
 *******************************************************************************/
-PeerToPeer::tJNI_HANDLE PeerToPeer::getNewJniHandle ()
-{
-    tJNI_HANDLE newHandle = 0;
-
-    mNewJniHandleMutex.lock ();
-    newHandle = mNextJniHandle++;
-    mNewJniHandleMutex.unlock ();
-    return newHandle;
-}
+PeerToPeer::tJNI_HANDLE PeerToPeer::getNewJniHandle() {
+  tJNI_HANDLE newHandle = 0;
 
+  mNewJniHandleMutex.lock();
+  newHandle = mNextJniHandle++;
+  mNewJniHandleMutex.unlock();
+  return newHandle;
+}
 
 /////////////////////////////////////////////////////////////////////////
 /////////////////////////////////////////////////////////////////////////
 
-
 /*******************************************************************************
 **
 ** Function:        P2pServer
@@ -1631,153 +1606,160 @@ PeerToPeer::tJNI_HANDLE PeerToPeer::getNewJniHandle ()
 **
 *******************************************************************************/
 P2pServer::P2pServer(PeerToPeer::tJNI_HANDLE jniHandle, const char* serviceName)
-:   mNfaP2pServerHandle (NFA_HANDLE_INVALID),
-    mJniHandle (jniHandle)
-{
-    mServiceName.assign (serviceName);
+    : mNfaP2pServerHandle(NFA_HANDLE_INVALID), mJniHandle(jniHandle) {
+  mServiceName.assign(serviceName);
 
-    memset (mServerConn, 0, sizeof(mServerConn));
+  memset(mServerConn, 0, sizeof(mServerConn));
 }
 
-bool P2pServer::registerWithStack()
-{
-    static const char fn [] = "P2pServer::registerWithStack";
-    ALOGV("%s: enter; service name: %s  JNI handle: %u", fn, mServiceName.c_str(), mJniHandle);
-    tNFA_STATUS     stat  = NFA_STATUS_OK;
-    uint8_t         serverSap = NFA_P2P_ANY_SAP;
-
-    /**********************
-   default values for all LLCP parameters:
-   - Local Link MIU (LLCP_MIU)
-   - Option parameter (LLCP_OPT_VALUE)
-   - Response Waiting Time Index (LLCP_WAITING_TIME)
-   - Local Link Timeout (LLCP_LTO_VALUE)
-   - Inactivity Timeout as initiator role (LLCP_INIT_INACTIVITY_TIMEOUT)
-   - Inactivity Timeout as target role (LLCP_TARGET_INACTIVITY_TIMEOUT)
-   - Delay SYMM response (LLCP_DELAY_RESP_TIME)
-   - Data link connection timeout (LLCP_DATA_LINK_CONNECTION_TOUT)
-   - Delay timeout to send first PDU as initiator (LLCP_DELAY_TIME_TO_SEND_FIRST_PDU)
-   ************************/
-   stat = NFA_P2pSetLLCPConfig (LLCP_MAX_MIU,
-           LLCP_OPT_VALUE,
-           LLCP_WAITING_TIME,
-           LLCP_LTO_VALUE,
-           0, //use 0 for infinite timeout for symmetry procedure when acting as initiator
-           0, //use 0 for infinite timeout for symmetry procedure when acting as target
-           LLCP_DELAY_RESP_TIME,
-           LLCP_DATA_LINK_TIMEOUT,
-           LLCP_DELAY_TIME_TO_SEND_FIRST_PDU);
-   if (stat != NFA_STATUS_OK)
-       ALOGE("%s: fail set LLCP config; error=0x%X", fn, stat);
-
-   if (sSnepServiceName.compare(mServiceName) == 0)
-       serverSap = LLCP_SAP_SNEP; //LLCP_SAP_SNEP == 4
-
-   {
-       SyncEventGuard guard (mRegServerEvent);
-       stat = NFA_P2pRegisterServer (serverSap, NFA_P2P_DLINK_TYPE, const_cast<char*>(mServiceName.c_str()),
-               PeerToPeer::nfaServerCallback);
-       if (stat != NFA_STATUS_OK)
-       {
-           ALOGE("%s: fail register p2p server; error=0x%X", fn, stat);
-           return (false);
-       }
-       ALOGV("%s: wait for listen-completion event", fn);
-       // Wait for NFA_P2P_REG_SERVER_EVT
-       mRegServerEvent.wait ();
-   }
-
-   return (mNfaP2pServerHandle != NFA_HANDLE_INVALID);
+bool P2pServer::registerWithStack() {
+  static const char fn[] = "P2pServer::registerWithStack";
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter; service name: %s  JNI handle: %u", fn,
+                      mServiceName.c_str(), mJniHandle);
+  tNFA_STATUS stat = NFA_STATUS_OK;
+  uint8_t serverSap = NFA_P2P_ANY_SAP;
+
+  /**********************
+ default values for all LLCP parameters:
+ - Local Link MIU (LLCP_MIU)
+ - Option parameter (LLCP_OPT_VALUE)
+ - Response Waiting Time Index (LLCP_WAITING_TIME)
+ - Local Link Timeout (LLCP_LTO_VALUE)
+ - Inactivity Timeout as initiator role (LLCP_INIT_INACTIVITY_TIMEOUT)
+ - Inactivity Timeout as target role (LLCP_TARGET_INACTIVITY_TIMEOUT)
+ - Delay SYMM response (LLCP_DELAY_RESP_TIME)
+ - Data link connection timeout (LLCP_DATA_LINK_CONNECTION_TOUT)
+ - Delay timeout to send first PDU as initiator
+ (LLCP_DELAY_TIME_TO_SEND_FIRST_PDU)
+ ************************/
+  stat = NFA_P2pSetLLCPConfig(LLCP_MAX_MIU, LLCP_OPT_VALUE, LLCP_WAITING_TIME,
+                              LLCP_LTO_VALUE,
+                              0,  // use 0 for infinite timeout for symmetry
+                                  // procedure when acting as initiator
+                              0,  // use 0 for infinite timeout for symmetry
+                                  // procedure when acting as target
+                              LLCP_DELAY_RESP_TIME, LLCP_DATA_LINK_TIMEOUT,
+                              LLCP_DELAY_TIME_TO_SEND_FIRST_PDU);
+  if (stat != NFA_STATUS_OK)
+    LOG(ERROR) << StringPrintf("%s: fail set LLCP config; error=0x%X", fn,
+                               stat);
+
+  if (sSnepServiceName.compare(mServiceName) == 0)
+    serverSap = 4;  // LLCP_SAP_SNEP == 4
+
+  {
+    SyncEventGuard guard(mRegServerEvent);
+    stat = NFA_P2pRegisterServer(serverSap, NFA_P2P_DLINK_TYPE,
+                                 const_cast<char*>(mServiceName.c_str()),
+                                 PeerToPeer::nfaServerCallback);
+    if (stat != NFA_STATUS_OK) {
+      LOG(ERROR) << StringPrintf("%s: fail register p2p server; error=0x%X", fn,
+                                 stat);
+      return (false);
+    }
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: wait for listen-completion event", fn);
+    // Wait for NFA_P2P_REG_SERVER_EVT
+    mRegServerEvent.wait();
+  }
+
+  return (mNfaP2pServerHandle != NFA_HANDLE_INVALID);
 }
 
-bool P2pServer::accept(PeerToPeer::tJNI_HANDLE serverJniHandle, PeerToPeer::tJNI_HANDLE connJniHandle,
-        int maxInfoUnit, int recvWindow)
-{
-    static const char fn [] = "P2pServer::accept";
-    tNFA_STATUS     nfaStat  = NFA_STATUS_OK;
-
-    sp<NfaConn> connection = allocateConnection(connJniHandle);
-    if (connection == NULL) {
-        ALOGE("%s: failed to allocate new server connection", fn);
-        return false;
-    }
-
-    {
-        // Wait for NFA_P2P_CONN_REQ_EVT or NFA_NDEF_DATA_EVT when remote device requests connection
-        SyncEventGuard guard (mConnRequestEvent);
-        ALOGV("%s: serverJniHandle: %u; connJniHandle: %u; wait for incoming connection", fn,
-                serverJniHandle, connJniHandle);
-        mConnRequestEvent.wait();
-        ALOGV("%s: serverJniHandle: %u; connJniHandle: %u; nfa conn h: 0x%X; got incoming connection", fn,
-                serverJniHandle, connJniHandle, connection->mNfaConnHandle);
-    }
-
-    if (connection->mNfaConnHandle == NFA_HANDLE_INVALID)
-    {
-        removeServerConnection(connJniHandle);
-        ALOGV("%s: no handle assigned", fn);
-        return (false);
-    }
+bool P2pServer::accept(PeerToPeer::tJNI_HANDLE serverJniHandle,
+                       PeerToPeer::tJNI_HANDLE connJniHandle, int maxInfoUnit,
+                       int recvWindow) {
+  static const char fn[] = "P2pServer::accept";
+  tNFA_STATUS nfaStat = NFA_STATUS_OK;
 
-    if (maxInfoUnit > (int)LLCP_MIU)
-    {
-        ALOGV("%s: overriding the miu passed by the app(%d) with stack miu(%zu)", fn, maxInfoUnit, LLCP_MIU);
-        maxInfoUnit = LLCP_MIU;
-    }
-
-    ALOGV("%s: serverJniHandle: %u; connJniHandle: %u; nfa conn h: 0x%X; try accept", fn,
-            serverJniHandle, connJniHandle, connection->mNfaConnHandle);
-    nfaStat = NFA_P2pAcceptConn (connection->mNfaConnHandle, maxInfoUnit, recvWindow);
-
-    if (nfaStat != NFA_STATUS_OK)
-    {
-        ALOGE("%s: fail to accept remote; error=0x%X", fn, nfaStat);
-        return (false);
-    }
-
-    ALOGV("%s: exit; serverJniHandle: %u; connJniHandle: %u; nfa conn h: 0x%X", fn,
-            serverJniHandle, connJniHandle, connection->mNfaConnHandle);
-    return (true);
+  sp<NfaConn> connection = allocateConnection(connJniHandle);
+  if (connection == NULL) {
+    LOG(ERROR) << StringPrintf("%s: failed to allocate new server connection",
+                               fn);
+    return false;
+  }
+
+  {
+    // Wait for NFA_P2P_CONN_REQ_EVT or NFA_NDEF_DATA_EVT when remote device
+    // requests connection
+    SyncEventGuard guard(mConnRequestEvent);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: serverJniHandle: %u; connJniHandle: %u; wait for incoming "
+        "connection",
+        fn, serverJniHandle, connJniHandle);
+    mConnRequestEvent.wait();
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: serverJniHandle: %u; connJniHandle: %u; nfa conn h: 0x%X; got "
+        "incoming connection",
+        fn, serverJniHandle, connJniHandle, connection->mNfaConnHandle);
+  }
+
+  if (connection->mNfaConnHandle == NFA_HANDLE_INVALID) {
+    removeServerConnection(connJniHandle);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: no handle assigned", fn);
+    return (false);
+  }
+
+  if (maxInfoUnit > (int)LLCP_MIU) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: overriding the miu passed by the app(%d) with stack miu(%zu)", fn,
+        maxInfoUnit, LLCP_MIU);
+    maxInfoUnit = LLCP_MIU;
+  }
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: serverJniHandle: %u; connJniHandle: %u; nfa conn h: 0x%X; try "
+      "accept",
+      fn, serverJniHandle, connJniHandle, connection->mNfaConnHandle);
+  nfaStat =
+      NFA_P2pAcceptConn(connection->mNfaConnHandle, maxInfoUnit, recvWindow);
+
+  if (nfaStat != NFA_STATUS_OK) {
+    LOG(ERROR) << StringPrintf("%s: fail to accept remote; error=0x%X", fn,
+                               nfaStat);
+    return (false);
+  }
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: exit; serverJniHandle: %u; connJniHandle: %u; nfa conn h: 0x%X", fn,
+      serverJniHandle, connJniHandle, connection->mNfaConnHandle);
+  return (true);
 }
 
-void P2pServer::unblockAll()
-{
-    AutoMutex mutex(mMutex);
-    for (int jj = 0; jj < MAX_NFA_CONNS_PER_SERVER; jj++)
-    {
-        if (mServerConn[jj] != NULL)
-        {
-            mServerConn[jj]->mNfaConnHandle = NFA_HANDLE_INVALID;
-            {
-                SyncEventGuard guard1 (mServerConn[jj]->mCongEvent);
-                mServerConn[jj]->mCongEvent.notifyOne (); //unblock write (if congested)
-            }
-            {
-                SyncEventGuard guard2 (mServerConn[jj]->mReadEvent);
-                mServerConn[jj]->mReadEvent.notifyOne (); //unblock receive()
-            }
-        }
-    }
+void P2pServer::unblockAll() {
+  AutoMutex mutex(mMutex);
+  for (int jj = 0; jj < MAX_NFA_CONNS_PER_SERVER; jj++) {
+    if (mServerConn[jj] != NULL) {
+      mServerConn[jj]->mNfaConnHandle = NFA_HANDLE_INVALID;
+      {
+        SyncEventGuard guard1(mServerConn[jj]->mCongEvent);
+        mServerConn[jj]->mCongEvent.notifyOne();  // unblock write (if
+                                                  // congested)
+      }
+      {
+        SyncEventGuard guard2(mServerConn[jj]->mReadEvent);
+        mServerConn[jj]->mReadEvent.notifyOne();  // unblock receive()
+      }
+    }
+  }
 }
 
-sp<NfaConn> P2pServer::allocateConnection (PeerToPeer::tJNI_HANDLE jniHandle)
-{
-    AutoMutex mutex(mMutex);
-    // First, find a free connection block to handle the connection
-    for (int ii = 0; ii < MAX_NFA_CONNS_PER_SERVER; ii++)
-    {
-        if (mServerConn[ii] == NULL)
-        {
-            mServerConn[ii] = new NfaConn;
-            mServerConn[ii]->mJniHandle = jniHandle;
-            return mServerConn[ii];
-        }
+sp<NfaConn> P2pServer::allocateConnection(PeerToPeer::tJNI_HANDLE jniHandle) {
+  AutoMutex mutex(mMutex);
+  // First, find a free connection block to handle the connection
+  for (int ii = 0; ii < MAX_NFA_CONNS_PER_SERVER; ii++) {
+    if (mServerConn[ii] == NULL) {
+      mServerConn[ii] = new NfaConn;
+      mServerConn[ii]->mJniHandle = jniHandle;
+      return mServerConn[ii];
     }
+  }
 
-    return NULL;
+  return NULL;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        findServerConnection
@@ -1788,19 +1770,18 @@ sp<NfaConn> P2pServer::allocateConnection (PeerToPeer::tJNI_HANDLE jniHandle)
 ** Returns:         P2pServer object.
 **
 *******************************************************************************/
-sp<NfaConn> P2pServer::findServerConnection (tNFA_HANDLE nfaConnHandle)
-{
-    int jj = 0;
-
-    AutoMutex mutex(mMutex);
-    for (jj = 0; jj < MAX_NFA_CONNS_PER_SERVER; jj++)
-    {
-        if ( (mServerConn[jj] != NULL) && (mServerConn[jj]->mNfaConnHandle == nfaConnHandle) )
-            return (mServerConn[jj]);
-    }
-
-    // If here, not found
-    return (NULL);
+sp<NfaConn> P2pServer::findServerConnection(tNFA_HANDLE nfaConnHandle) {
+  int jj = 0;
+
+  AutoMutex mutex(mMutex);
+  for (jj = 0; jj < MAX_NFA_CONNS_PER_SERVER; jj++) {
+    if ((mServerConn[jj] != NULL) &&
+        (mServerConn[jj]->mNfaConnHandle == nfaConnHandle))
+      return (mServerConn[jj]);
+  }
+
+  // If here, not found
+  return (NULL);
 }
 
 /*******************************************************************************
@@ -1813,19 +1794,17 @@ sp<NfaConn> P2pServer::findServerConnection (tNFA_HANDLE nfaConnHandle)
 ** Returns:         P2pServer object.
 **
 *******************************************************************************/
-sp<NfaConn> P2pServer::findServerConnection (PeerToPeer::tJNI_HANDLE jniHandle)
-{
-    int jj = 0;
+sp<NfaConn> P2pServer::findServerConnection(PeerToPeer::tJNI_HANDLE jniHandle) {
+  int jj = 0;
 
-    AutoMutex mutex(mMutex);
-    for (jj = 0; jj < MAX_NFA_CONNS_PER_SERVER; jj++)
-    {
-        if ( (mServerConn[jj] != NULL) && (mServerConn[jj]->mJniHandle == jniHandle) )
-            return (mServerConn[jj]);
-    }
+  AutoMutex mutex(mMutex);
+  for (jj = 0; jj < MAX_NFA_CONNS_PER_SERVER; jj++) {
+    if ((mServerConn[jj] != NULL) && (mServerConn[jj]->mJniHandle == jniHandle))
+      return (mServerConn[jj]);
+  }
 
-    // If here, not found
-    return (NULL);
+  // If here, not found
+  return (NULL);
 }
 
 /*******************************************************************************
@@ -1838,26 +1817,24 @@ sp<NfaConn> P2pServer::findServerConnection (PeerToPeer::tJNI_HANDLE jniHandle)
 ** Returns:         P2pServer object.
 **
 *******************************************************************************/
-bool P2pServer::removeServerConnection (PeerToPeer::tJNI_HANDLE jniHandle)
-{
-    int jj = 0;
+bool P2pServer::removeServerConnection(PeerToPeer::tJNI_HANDLE jniHandle) {
+  int jj = 0;
 
-    AutoMutex mutex(mMutex);
-    for (jj = 0; jj < MAX_NFA_CONNS_PER_SERVER; jj++)
-    {
-        if ( (mServerConn[jj] != NULL) && (mServerConn[jj]->mJniHandle == jniHandle) ) {
-            mServerConn[jj] = NULL;
-            return true;
-        }
+  AutoMutex mutex(mMutex);
+  for (jj = 0; jj < MAX_NFA_CONNS_PER_SERVER; jj++) {
+    if ((mServerConn[jj] != NULL) &&
+        (mServerConn[jj]->mJniHandle == jniHandle)) {
+      mServerConn[jj] = NULL;
+      return true;
     }
+  }
 
-    // If here, not found
-    return false;
+  // If here, not found
+  return false;
 }
 /////////////////////////////////////////////////////////////////////////
 /////////////////////////////////////////////////////////////////////////
 
-
 /*******************************************************************************
 **
 ** Function:        P2pClient
@@ -1867,14 +1844,11 @@ bool P2pServer::removeServerConnection (PeerToPeer::tJNI_HANDLE jniHandle)
 ** Returns:         None
 **
 *******************************************************************************/
-P2pClient::P2pClient ()
-:   mNfaP2pClientHandle (NFA_HANDLE_INVALID),
-    mIsConnecting (false)
-{
-    mClientConn = new NfaConn();
+P2pClient::P2pClient()
+    : mNfaP2pClientHandle(NFA_HANDLE_INVALID), mIsConnecting(false) {
+  mClientConn = new NfaConn();
 }
 
-
 /*******************************************************************************
 **
 ** Function:        ~P2pClient
@@ -1884,15 +1858,11 @@ P2pClient::P2pClient ()
 ** Returns:         None
 **
 *******************************************************************************/
-P2pClient::~P2pClient ()
-{
-}
-
+P2pClient::~P2pClient() {}
 
 /////////////////////////////////////////////////////////////////////////
 /////////////////////////////////////////////////////////////////////////
 
-
 /*******************************************************************************
 **
 ** Function:        NfaConn
@@ -1903,11 +1873,9 @@ P2pClient::~P2pClient ()
 **
 *******************************************************************************/
 NfaConn::NfaConn()
-:   mNfaConnHandle (NFA_HANDLE_INVALID),
-    mJniHandle (0),
-    mMaxInfoUnit (0),
-    mRecvWindow (0),
-    mRemoteMaxInfoUnit (0),
-    mRemoteRecvWindow (0)
-{
-}
+    : mNfaConnHandle(NFA_HANDLE_INVALID),
+      mJniHandle(0),
+      mMaxInfoUnit(0),
+      mRecvWindow(0),
+      mRemoteMaxInfoUnit(0),
+      mRemoteRecvWindow(0) {}
diff --git a/nci/jni/PeerToPeer.h b/nci/jni/PeerToPeer.h
index 76dde7cd..b9f0fc11 100644
--- a/nci/jni/PeerToPeer.h
+++ b/nci/jni/PeerToPeer.h
@@ -20,18 +20,15 @@
 #pragma once
 #include <utils/RefBase.h>
 #include <utils/StrongPointer.h>
-#include "SyncEvent.h"
-#include "NfcJniUtil.h"
 #include <string>
-extern "C"
-{
-    #include "nfa_p2p_api.h"
-}
+#include "NfcJniUtil.h"
+#include "SyncEvent.h"
+#include "nfa_p2p_api.h"
 
 class P2pServer;
 class P2pClient;
 class NfaConn;
-#define MAX_NFA_CONNS_PER_SERVER    5
+#define MAX_NFA_CONNS_PER_SERVER 5
 
 /*****************************************************************************
 **
@@ -40,544 +37,520 @@ class NfaConn;
 **  Description:    Communicate with a peer using NFC-DEP, LLCP, SNEP.
 **
 *****************************************************************************/
-class PeerToPeer
-{
-public:
-    typedef unsigned int tJNI_HANDLE;
-
-    /*******************************************************************************
-    **
-    ** Function:        PeerToPeer
-    **
-    ** Description:     Initialize member variables.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    PeerToPeer ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        ~PeerToPeer
-    **
-    ** Description:     Free all resources.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    ~PeerToPeer ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        getInstance
-    **
-    ** Description:     Get the singleton PeerToPeer object.
-    **
-    ** Returns:         Singleton PeerToPeer object.
-    **
-    *******************************************************************************/
-    static PeerToPeer& getInstance();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        initialize
-    **
-    ** Description:     Initialize member variables.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void initialize ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        llcpActivatedHandler
-    **
-    ** Description:     Receive LLLCP-activated event from stack.
-    **                  nat: JVM-related data.
-    **                  activated: Event data.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void llcpActivatedHandler (nfc_jni_native_data* nativeData, tNFA_LLCP_ACTIVATED& activated);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        llcpDeactivatedHandler
-    **
-    ** Description:     Receive LLLCP-deactivated event from stack.
-    **                  nat: JVM-related data.
-    **                  deactivated: Event data.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void llcpDeactivatedHandler (nfc_jni_native_data* nativeData, tNFA_LLCP_DEACTIVATED& deactivated);
-
-    void llcpFirstPacketHandler(nfc_jni_native_data* nativeData);
-
-    /*******************************************************************************
-    **
-    ** Function:        connectionEventHandler
-    **
-    ** Description:     Receive events from the stack.
-    **                  event: Event code.
-    **                  eventData: Event data.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void connectionEventHandler (uint8_t event, tNFA_CONN_EVT_DATA* eventData);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        registerServer
-    **
-    ** Description:     Let a server start listening for peer's connection request.
-    **                  jniHandle: Connection handle.
-    **                  serviceName: Server's service name.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    bool registerServer (tJNI_HANDLE jniHandle, const char* serviceName);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        deregisterServer
-    **
-    ** Description:     Stop a P2pServer from listening for peer.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    bool deregisterServer (tJNI_HANDLE jniHandle);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        accept
-    **
-    ** Description:     Accept a peer's request to connect.
-    **                  serverJniHandle: Server's handle.
-    **                  connJniHandle: Connection handle.
-    **                  maxInfoUnit: Maximum information unit.
-    **                  recvWindow: Receive window size.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    bool accept (tJNI_HANDLE serverJniHandle, tJNI_HANDLE connJniHandle, int maxInfoUnit, int recvWindow);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        createClient
-    **
-    ** Description:     Create a P2pClient object for a new out-bound connection.
-    **                  jniHandle: Connection handle.
-    **                  miu: Maximum information unit.
-    **                  rw: Receive window size.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    bool createClient (tJNI_HANDLE jniHandle, uint16_t miu, uint8_t rw);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        connectConnOriented
-    **
-    ** Description:     Establish a connection-oriented connection to a peer.
-    **                  jniHandle: Connection handle.
-    **                  serviceName: Peer's service name.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    bool connectConnOriented (tJNI_HANDLE jniHandle, const char* serviceName);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        connectConnOriented
-    **
-    ** Description:     Establish a connection-oriented connection to a peer.
-    **                  jniHandle: Connection handle.
-    **                  destinationSap: Peer's service access point.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    bool connectConnOriented (tJNI_HANDLE jniHandle, uint8_t destinationSap);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        send
-    **
-    ** Description:     Send data to peer.
-    **                  jniHandle: Handle of connection.
-    **                  buffer: Buffer of data.
-    **                  bufferLen: Length of data.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    bool send (tJNI_HANDLE jniHandle, uint8_t* buffer, uint16_t bufferLen);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        receive
-    **
-    ** Description:     Receive data from peer.
-    **                  jniHandle: Handle of connection.
-    **                  buffer: Buffer to store data.
-    **                  bufferLen: Max length of buffer.
-    **                  actualLen: Actual length received.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    bool receive (tJNI_HANDLE jniHandle, uint8_t* buffer, uint16_t bufferLen, uint16_t& actualLen);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        disconnectConnOriented
-    **
-    ** Description:     Disconnect a connection-oriented connection with peer.
-    **                  jniHandle: Handle of connection.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    bool disconnectConnOriented (tJNI_HANDLE jniHandle);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        getRemoteMaxInfoUnit
-    **
-    ** Description:     Get peer's max information unit.
-    **                  jniHandle: Handle of the connection.
-    **
-    ** Returns:         Peer's max information unit.
-    **
-    *******************************************************************************/
-    uint16_t getRemoteMaxInfoUnit (tJNI_HANDLE jniHandle);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        getRemoteRecvWindow
-    **
-    ** Description:     Get peer's receive window size.
-    **                  jniHandle: Handle of the connection.
-    **
-    ** Returns:         Peer's receive window size.
-    **
-    *******************************************************************************/
-    uint8_t getRemoteRecvWindow (tJNI_HANDLE jniHandle);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        setP2pListenMask
-    **
-    ** Description:     Sets the p2p listen technology mask.
-    **                  p2pListenMask: the p2p listen mask to be set?
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void setP2pListenMask (tNFA_TECHNOLOGY_MASK p2pListenMask);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        getP2pListenMask
-    **
-    ** Description:     Get the set of technologies that P2P is listening.
-    **
-    ** Returns:         Set of technologies.
-    **
-    *******************************************************************************/
-    tNFA_TECHNOLOGY_MASK getP2pListenMask ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        resetP2pListenMask
-    **
-    ** Description:     Reset the p2p listen technology mask to initial value.
-    **
-    ** Returns:         None.
-    **
-    *******************************************************************************/
-    void resetP2pListenMask ();
-
-    /*******************************************************************************
-    **
-    ** Function:        enableP2pListening
-    **
-    ** Description:     Start/stop polling/listening to peer that supports P2P.
-    **                  isEnable: Is enable polling/listening?
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void enableP2pListening (bool isEnable);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        handleNfcOnOff
-    **
-    ** Description:     Handle events related to turning NFC on/off by the user.
-    **                  isOn: Is NFC turning on?
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void handleNfcOnOff (bool isOn);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        getNextJniHandle
-    **
-    ** Description:     Get a new JNI handle.
-    **
-    ** Returns:         A new JNI handle.
-    **
-    *******************************************************************************/
-    tJNI_HANDLE getNewJniHandle ();
-
-    /*******************************************************************************
-    **
-    ** Function:        nfaServerCallback
-    **
-    ** Description:     Receive LLCP-related events from the stack.
-    **                  p2pEvent: Event code.
-    **                  eventData: Event data.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    static void nfaServerCallback  (tNFA_P2P_EVT p2pEvent, tNFA_P2P_EVT_DATA *eventData);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        nfaClientCallback
-    **
-    ** Description:     Receive LLCP-related events from the stack.
-    **                  p2pEvent: Event code.
-    **                  eventData: Event data.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    static void nfaClientCallback  (tNFA_P2P_EVT p2pEvent, tNFA_P2P_EVT_DATA *eventData);
-
-private:
-    static const int sMax = 10;
-    static PeerToPeer sP2p;
-
-    // Variables below only accessed from a single thread
-    uint16_t        mRemoteWKS;                 // Peer's well known services
-    bool            mIsP2pListening;            // If P2P listening is enabled or not
-    tNFA_TECHNOLOGY_MASK    mP2pListenTechMask; // P2P Listen mask
-
-    // Variable below is protected by mNewJniHandleMutex
-    tJNI_HANDLE     mNextJniHandle;
-
-    // Variables below protected by mMutex
-    // A note on locking order: mMutex in PeerToPeer is *ALWAYS*
-    // locked before any locks / guards in P2pServer / P2pClient
-    Mutex                    mMutex;
-    android::sp<P2pServer>   mServers [sMax];
-    android::sp<P2pClient>   mClients [sMax];
-
-    // Synchronization variables
-    SyncEvent       mSetTechEvent;              // completion event for NFA_SetP2pListenTech()
-    SyncEvent       mSnepDefaultServerStartStopEvent; // completion event for NFA_SnepStartDefaultServer(), NFA_SnepStopDefaultServer()
-    SyncEvent       mSnepRegisterEvent;         // completion event for NFA_SnepRegisterClient()
-    Mutex           mDisconnectMutex;           // synchronize the disconnect operation
-    Mutex           mNewJniHandleMutex;         // synchronize the creation of a new JNI handle
-
-
-    /*******************************************************************************
-    **
-    ** Function:        ndefTypeCallback
-    **
-    ** Description:     Receive NDEF-related events from the stack.
-    **                  ndefEvent: Event code.
-    **                  eventData: Event data.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    static void ndefTypeCallback   (tNFA_NDEF_EVT event, tNFA_NDEF_EVT_DATA *evetnData);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        findServer
-    **
-    ** Description:     Find a PeerToPeer object by connection handle.
-    **                  nfaP2pServerHandle: Connectin handle.
-    **
-    ** Returns:         PeerToPeer object.
-    **
-    *******************************************************************************/
-    android::sp<P2pServer>   findServerLocked (tNFA_HANDLE nfaP2pServerHandle);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        findServer
-    **
-    ** Description:     Find a PeerToPeer object by connection handle.
-    **                  serviceName: service name.
-    **
-    ** Returns:         PeerToPeer object.
-    **
-    *******************************************************************************/
-    android::sp<P2pServer>   findServerLocked (tJNI_HANDLE jniHandle);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        findServer
-    **
-    ** Description:     Find a PeerToPeer object by service name
-    **                  serviceName: service name.
-    **
-    ** Returns:         PeerToPeer object.
-    **
-    *******************************************************************************/
-    android::sp<P2pServer>   findServerLocked (const char *serviceName);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        removeServer
-    **
-    ** Description:     Free resources related to a server.
-    **                  jniHandle: Connection handle.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void        removeServer (tJNI_HANDLE jniHandle);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        removeConn
-    **
-    ** Description:     Free resources related to a connection.
-    **                  jniHandle: Connection handle.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void        removeConn (tJNI_HANDLE jniHandle);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        createDataLinkConn
-    **
-    ** Description:     Establish a connection-oriented connection to a peer.
-    **                  jniHandle: Connection handle.
-    **                  serviceName: Peer's service name.
-    **                  destinationSap: Peer's service access point.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    bool        createDataLinkConn (tJNI_HANDLE jniHandle, const char* serviceName, uint8_t destinationSap);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        findClient
-    **
-    ** Description:     Find a PeerToPeer object with a client connection handle.
-    **                  nfaConnHandle: Connection handle.
-    **
-    ** Returns:         PeerToPeer object.
-    **
-    *******************************************************************************/
-    android::sp<P2pClient>   findClient (tNFA_HANDLE nfaConnHandle);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        findClient
-    **
-    ** Description:     Find a PeerToPeer object with a client connection handle.
-    **                  jniHandle: Connection handle.
-    **
-    ** Returns:         PeerToPeer object.
-    **
-    *******************************************************************************/
-    android::sp<P2pClient>   findClient (tJNI_HANDLE jniHandle);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        findClientCon
-    **
-    ** Description:     Find a PeerToPeer object with a client connection handle.
-    **                  nfaConnHandle: Connection handle.
-    **
-    ** Returns:         PeerToPeer object.
-    **
-    *******************************************************************************/
-    android::sp<P2pClient>   findClientCon (tNFA_HANDLE nfaConnHandle);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        findConnection
-    **
-    ** Description:     Find a PeerToPeer object with a connection handle.
-    **                  nfaConnHandle: Connection handle.
-    **
-    ** Returns:         PeerToPeer object.
-    **
-    *******************************************************************************/
-    android::sp<NfaConn>     findConnection (tNFA_HANDLE nfaConnHandle);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        findConnection
-    **
-    ** Description:     Find a PeerToPeer object with a connection handle.
-    **                  jniHandle: Connection handle.
-    **
-    ** Returns:         PeerToPeer object.
-    **
-    *******************************************************************************/
-    android::sp<NfaConn>     findConnection (tJNI_HANDLE jniHandle);
+class PeerToPeer {
+ public:
+  typedef unsigned int tJNI_HANDLE;
+
+  /*******************************************************************************
+  **
+  ** Function:        PeerToPeer
+  **
+  ** Description:     Initialize member variables.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  PeerToPeer();
+
+  /*******************************************************************************
+  **
+  ** Function:        ~PeerToPeer
+  **
+  ** Description:     Free all resources.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  ~PeerToPeer();
+
+  /*******************************************************************************
+  **
+  ** Function:        getInstance
+  **
+  ** Description:     Get the singleton PeerToPeer object.
+  **
+  ** Returns:         Singleton PeerToPeer object.
+  **
+  *******************************************************************************/
+  static PeerToPeer& getInstance();
+
+  /*******************************************************************************
+  **
+  ** Function:        initialize
+  **
+  ** Description:     Initialize member variables.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void initialize();
+
+  /*******************************************************************************
+  **
+  ** Function:        llcpActivatedHandler
+  **
+  ** Description:     Receive LLLCP-activated event from stack.
+  **                  nat: JVM-related data.
+  **                  activated: Event data.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void llcpActivatedHandler(nfc_jni_native_data* nativeData,
+                            tNFA_LLCP_ACTIVATED& activated);
+
+  /*******************************************************************************
+  **
+  ** Function:        llcpDeactivatedHandler
+  **
+  ** Description:     Receive LLLCP-deactivated event from stack.
+  **                  nat: JVM-related data.
+  **                  deactivated: Event data.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void llcpDeactivatedHandler(nfc_jni_native_data* nativeData,
+                              tNFA_LLCP_DEACTIVATED& deactivated);
+
+  void llcpFirstPacketHandler(nfc_jni_native_data* nativeData);
+
+  /*******************************************************************************
+  **
+  ** Function:        connectionEventHandler
+  **
+  ** Description:     Receive events from the stack.
+  **                  event: Event code.
+  **                  eventData: Event data.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void connectionEventHandler(uint8_t event, tNFA_CONN_EVT_DATA* eventData);
+
+  /*******************************************************************************
+  **
+  ** Function:        registerServer
+  **
+  ** Description:     Let a server start listening for peer's connection
+  *request.
+  **                  jniHandle: Connection handle.
+  **                  serviceName: Server's service name.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool registerServer(tJNI_HANDLE jniHandle, const char* serviceName);
+
+  /*******************************************************************************
+  **
+  ** Function:        deregisterServer
+  **
+  ** Description:     Stop a P2pServer from listening for peer.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool deregisterServer(tJNI_HANDLE jniHandle);
+
+  /*******************************************************************************
+  **
+  ** Function:        accept
+  **
+  ** Description:     Accept a peer's request to connect.
+  **                  serverJniHandle: Server's handle.
+  **                  connJniHandle: Connection handle.
+  **                  maxInfoUnit: Maximum information unit.
+  **                  recvWindow: Receive window size.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool accept(tJNI_HANDLE serverJniHandle, tJNI_HANDLE connJniHandle,
+              int maxInfoUnit, int recvWindow);
+
+  /*******************************************************************************
+  **
+  ** Function:        createClient
+  **
+  ** Description:     Create a P2pClient object for a new out-bound connection.
+  **                  jniHandle: Connection handle.
+  **                  miu: Maximum information unit.
+  **                  rw: Receive window size.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool createClient(tJNI_HANDLE jniHandle, uint16_t miu, uint8_t rw);
+
+  /*******************************************************************************
+  **
+  ** Function:        connectConnOriented
+  **
+  ** Description:     Establish a connection-oriented connection to a peer.
+  **                  jniHandle: Connection handle.
+  **                  serviceName: Peer's service name.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool connectConnOriented(tJNI_HANDLE jniHandle, const char* serviceName);
+
+  /*******************************************************************************
+  **
+  ** Function:        connectConnOriented
+  **
+  ** Description:     Establish a connection-oriented connection to a peer.
+  **                  jniHandle: Connection handle.
+  **                  destinationSap: Peer's service access point.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool connectConnOriented(tJNI_HANDLE jniHandle, uint8_t destinationSap);
+
+  /*******************************************************************************
+  **
+  ** Function:        send
+  **
+  ** Description:     Send data to peer.
+  **                  jniHandle: Handle of connection.
+  **                  buffer: Buffer of data.
+  **                  bufferLen: Length of data.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool send(tJNI_HANDLE jniHandle, uint8_t* buffer, uint16_t bufferLen);
+
+  /*******************************************************************************
+  **
+  ** Function:        receive
+  **
+  ** Description:     Receive data from peer.
+  **                  jniHandle: Handle of connection.
+  **                  buffer: Buffer to store data.
+  **                  bufferLen: Max length of buffer.
+  **                  actualLen: Actual length received.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool receive(tJNI_HANDLE jniHandle, uint8_t* buffer, uint16_t bufferLen,
+               uint16_t& actualLen);
+
+  /*******************************************************************************
+  **
+  ** Function:        disconnectConnOriented
+  **
+  ** Description:     Disconnect a connection-oriented connection with peer.
+  **                  jniHandle: Handle of connection.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool disconnectConnOriented(tJNI_HANDLE jniHandle);
+
+  /*******************************************************************************
+  **
+  ** Function:        getRemoteMaxInfoUnit
+  **
+  ** Description:     Get peer's max information unit.
+  **                  jniHandle: Handle of the connection.
+  **
+  ** Returns:         Peer's max information unit.
+  **
+  *******************************************************************************/
+  uint16_t getRemoteMaxInfoUnit(tJNI_HANDLE jniHandle);
+
+  /*******************************************************************************
+  **
+  ** Function:        getRemoteRecvWindow
+  **
+  ** Description:     Get peer's receive window size.
+  **                  jniHandle: Handle of the connection.
+  **
+  ** Returns:         Peer's receive window size.
+  **
+  *******************************************************************************/
+  uint8_t getRemoteRecvWindow(tJNI_HANDLE jniHandle);
+
+  /*******************************************************************************
+  **
+  ** Function:        setP2pListenMask
+  **
+  ** Description:     Sets the p2p listen technology mask.
+  **                  p2pListenMask: the p2p listen mask to be set?
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void setP2pListenMask(tNFA_TECHNOLOGY_MASK p2pListenMask);
+
+  /*******************************************************************************
+  **
+  ** Function:        getP2pListenMask
+  **
+  ** Description:     Get the set of technologies that P2P is listening.
+  **
+  ** Returns:         Set of technologies.
+  **
+  *******************************************************************************/
+  tNFA_TECHNOLOGY_MASK getP2pListenMask();
+
+  /*******************************************************************************
+  **
+  ** Function:        resetP2pListenMask
+  **
+  ** Description:     Reset the p2p listen technology mask to initial value.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  void resetP2pListenMask();
+
+  /*******************************************************************************
+  **
+  ** Function:        enableP2pListening
+  **
+  ** Description:     Start/stop polling/listening to peer that supports P2P.
+  **                  isEnable: Is enable polling/listening?
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void enableP2pListening(bool isEnable);
+
+  /*******************************************************************************
+  **
+  ** Function:        handleNfcOnOff
+  **
+  ** Description:     Handle events related to turning NFC on/off by the user.
+  **                  isOn: Is NFC turning on?
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void handleNfcOnOff(bool isOn);
+
+  /*******************************************************************************
+  **
+  ** Function:        getNextJniHandle
+  **
+  ** Description:     Get a new JNI handle.
+  **
+  ** Returns:         A new JNI handle.
+  **
+  *******************************************************************************/
+  tJNI_HANDLE getNewJniHandle();
+
+  /*******************************************************************************
+  **
+  ** Function:        nfaServerCallback
+  **
+  ** Description:     Receive LLCP-related events from the stack.
+  **                  p2pEvent: Event code.
+  **                  eventData: Event data.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  static void nfaServerCallback(tNFA_P2P_EVT p2pEvent,
+                                tNFA_P2P_EVT_DATA* eventData);
+
+  /*******************************************************************************
+  **
+  ** Function:        nfaClientCallback
+  **
+  ** Description:     Receive LLCP-related events from the stack.
+  **                  p2pEvent: Event code.
+  **                  eventData: Event data.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  static void nfaClientCallback(tNFA_P2P_EVT p2pEvent,
+                                tNFA_P2P_EVT_DATA* eventData);
+
+ private:
+  static const int sMax = 10;
+  static PeerToPeer sP2p;
+
+  // Variables below only accessed from a single thread
+  uint16_t mRemoteWKS;   // Peer's well known services
+  bool mIsP2pListening;  // If P2P listening is enabled or not
+  tNFA_TECHNOLOGY_MASK mP2pListenTechMask;  // P2P Listen mask
+
+  // Variable below is protected by mNewJniHandleMutex
+  tJNI_HANDLE mNextJniHandle;
+
+  // Variables below protected by mMutex
+  // A note on locking order: mMutex in PeerToPeer is *ALWAYS*
+  // locked before any locks / guards in P2pServer / P2pClient
+  Mutex mMutex;
+  android::sp<P2pServer> mServers[sMax];
+  android::sp<P2pClient> mClients[sMax];
+
+  // Synchronization variables
+  SyncEvent mSetTechEvent;  // completion event for NFA_SetP2pListenTech()
+  SyncEvent mSnepDefaultServerStartStopEvent;  // completion event for
+                                               // NFA_SnepStartDefaultServer(),
+                                               // NFA_SnepStopDefaultServer()
+  SyncEvent
+      mSnepRegisterEvent;    // completion event for NFA_SnepRegisterClient()
+  Mutex mDisconnectMutex;    // synchronize the disconnect operation
+  Mutex mNewJniHandleMutex;  // synchronize the creation of a new JNI handle
+
+  /*******************************************************************************
+  **
+  ** Function:        ndefTypeCallback
+  **
+  ** Description:     Receive NDEF-related events from the stack.
+  **                  ndefEvent: Event code.
+  **                  eventData: Event data.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  static void ndefTypeCallback(tNFA_NDEF_EVT event,
+                               tNFA_NDEF_EVT_DATA* evetnData);
+
+  /*******************************************************************************
+  **
+  ** Function:        findServer
+  **
+  ** Description:     Find a PeerToPeer object by connection handle.
+  **                  nfaP2pServerHandle: Connectin handle.
+  **
+  ** Returns:         PeerToPeer object.
+  **
+  *******************************************************************************/
+  android::sp<P2pServer> findServerLocked(tNFA_HANDLE nfaP2pServerHandle);
+
+  /*******************************************************************************
+  **
+  ** Function:        findServer
+  **
+  ** Description:     Find a PeerToPeer object by connection handle.
+  **                  serviceName: service name.
+  **
+  ** Returns:         PeerToPeer object.
+  **
+  *******************************************************************************/
+  android::sp<P2pServer> findServerLocked(tJNI_HANDLE jniHandle);
+
+  /*******************************************************************************
+  **
+  ** Function:        findServer
+  **
+  ** Description:     Find a PeerToPeer object by service name
+  **                  serviceName: service name.
+  **
+  ** Returns:         PeerToPeer object.
+  **
+  *******************************************************************************/
+  android::sp<P2pServer> findServerLocked(const char* serviceName);
+
+  /*******************************************************************************
+  **
+  ** Function:        removeServer
+  **
+  ** Description:     Free resources related to a server.
+  **                  jniHandle: Connection handle.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void removeServer(tJNI_HANDLE jniHandle);
+
+  /*******************************************************************************
+  **
+  ** Function:        removeConn
+  **
+  ** Description:     Free resources related to a connection.
+  **                  jniHandle: Connection handle.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void removeConn(tJNI_HANDLE jniHandle);
+
+  /*******************************************************************************
+  **
+  ** Function:        createDataLinkConn
+  **
+  ** Description:     Establish a connection-oriented connection to a peer.
+  **                  jniHandle: Connection handle.
+  **                  serviceName: Peer's service name.
+  **                  destinationSap: Peer's service access point.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool createDataLinkConn(tJNI_HANDLE jniHandle, const char* serviceName,
+                          uint8_t destinationSap);
+
+  /*******************************************************************************
+  **
+  ** Function:        findClient
+  **
+  ** Description:     Find a PeerToPeer object with a client connection handle.
+  **                  nfaConnHandle: Connection handle.
+  **
+  ** Returns:         PeerToPeer object.
+  **
+  *******************************************************************************/
+  android::sp<P2pClient> findClient(tNFA_HANDLE nfaConnHandle);
+
+  /*******************************************************************************
+  **
+  ** Function:        findClient
+  **
+  ** Description:     Find a PeerToPeer object with a client connection handle.
+  **                  jniHandle: Connection handle.
+  **
+  ** Returns:         PeerToPeer object.
+  **
+  *******************************************************************************/
+  android::sp<P2pClient> findClient(tJNI_HANDLE jniHandle);
+
+  /*******************************************************************************
+  **
+  ** Function:        findClientCon
+  **
+  ** Description:     Find a PeerToPeer object with a client connection handle.
+  **                  nfaConnHandle: Connection handle.
+  **
+  ** Returns:         PeerToPeer object.
+  **
+  *******************************************************************************/
+  android::sp<P2pClient> findClientCon(tNFA_HANDLE nfaConnHandle);
+
+  /*******************************************************************************
+  **
+  ** Function:        findConnection
+  **
+  ** Description:     Find a PeerToPeer object with a connection handle.
+  **                  nfaConnHandle: Connection handle.
+  **
+  ** Returns:         PeerToPeer object.
+  **
+  *******************************************************************************/
+  android::sp<NfaConn> findConnection(tNFA_HANDLE nfaConnHandle);
+
+  /*******************************************************************************
+  **
+  ** Function:        findConnection
+  **
+  ** Description:     Find a PeerToPeer object with a connection handle.
+  **                  jniHandle: Connection handle.
+  **
+  ** Returns:         PeerToPeer object.
+  **
+  *******************************************************************************/
+  android::sp<NfaConn> findConnection(tJNI_HANDLE jniHandle);
 };
 
-
 /*****************************************************************************
 **
 **  Name:           NfaConn
@@ -585,33 +558,30 @@ private:
 **  Description:    Store information about a connection related to a peer.
 **
 *****************************************************************************/
-class NfaConn : public android::RefBase
-{
-public:
-    tNFA_HANDLE         mNfaConnHandle;         // NFA handle of the P2P connection
-    PeerToPeer::tJNI_HANDLE         mJniHandle;             // JNI handle of the P2P connection
-    uint16_t            mMaxInfoUnit;
-    uint8_t             mRecvWindow;
-    uint16_t            mRemoteMaxInfoUnit;
-    uint8_t             mRemoteRecvWindow;
-    SyncEvent           mReadEvent;             // event for reading
-    SyncEvent           mCongEvent;             // event for congestion
-    SyncEvent           mDisconnectingEvent;     // event for disconnecting
-
-
-    /*******************************************************************************
-    **
-    ** Function:        NfaConn
-    **
-    ** Description:     Initialize member variables.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    NfaConn();
+class NfaConn : public android::RefBase {
+ public:
+  tNFA_HANDLE mNfaConnHandle;          // NFA handle of the P2P connection
+  PeerToPeer::tJNI_HANDLE mJniHandle;  // JNI handle of the P2P connection
+  uint16_t mMaxInfoUnit;
+  uint8_t mRecvWindow;
+  uint16_t mRemoteMaxInfoUnit;
+  uint8_t mRemoteRecvWindow;
+  SyncEvent mReadEvent;           // event for reading
+  SyncEvent mCongEvent;           // event for congestion
+  SyncEvent mDisconnectingEvent;  // event for disconnecting
+
+  /*******************************************************************************
+  **
+  ** Function:        NfaConn
+  **
+  ** Description:     Initialize member variables.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  NfaConn();
 };
 
-
 /*****************************************************************************
 **
 **  Name:           P2pServer
@@ -619,122 +589,121 @@ public:
 **  Description:    Store information about an in-bound connection from a peer.
 **
 *****************************************************************************/
-class P2pServer : public android::RefBase
-{
-public:
-    static const std::string sSnepServiceName;
-
-    tNFA_HANDLE     mNfaP2pServerHandle;    // NFA p2p handle of local server
-    PeerToPeer::tJNI_HANDLE     mJniHandle;     // JNI Handle
-    SyncEvent       mRegServerEvent;        // for NFA_P2pRegisterServer()
-    SyncEvent       mConnRequestEvent;      // for accept()
-    std::string     mServiceName;
-
-    /*******************************************************************************
-    **
-    ** Function:        P2pServer
-    **
-    ** Description:     Initialize member variables.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    P2pServer (PeerToPeer::tJNI_HANDLE jniHandle, const char* serviceName);
-
-    /*******************************************************************************
-    **
-    ** Function:        registerWithStack
-    **
-    ** Description:     Register this server with the stack.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    bool registerWithStack();
-
-    /*******************************************************************************
-    **
-    ** Function:        accept
-    **
-    ** Description:     Accept a peer's request to connect.
-    **                  serverJniHandle: Server's handle.
-    **                  connJniHandle: Connection handle.
-    **                  maxInfoUnit: Maximum information unit.
-    **                  recvWindow: Receive window size.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    bool accept (PeerToPeer::tJNI_HANDLE serverJniHandle, PeerToPeer::tJNI_HANDLE connJniHandle,
-            int maxInfoUnit, int recvWindow);
-
-    /*******************************************************************************
-    **
-    ** Function:        unblockAll
-    **
-    ** Description:     Unblocks all server connections
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    void unblockAll();
-
-    /*******************************************************************************
-    **
-    ** Function:        findServerConnection
-    **
-    ** Description:     Find a P2pServer that has the handle.
-    **                  nfaConnHandle: NFA connection handle.
-    **
-    ** Returns:         P2pServer object.
-    **
-    *******************************************************************************/
-    android::sp<NfaConn> findServerConnection (tNFA_HANDLE nfaConnHandle);
-
-    /*******************************************************************************
-    **
-    ** Function:        findServerConnection
-    **
-    ** Description:     Find a P2pServer that has the handle.
-    **                  jniHandle: JNI connection handle.
-    **
-    ** Returns:         P2pServer object.
-    **
-    *******************************************************************************/
-    android::sp<NfaConn> findServerConnection (PeerToPeer::tJNI_HANDLE jniHandle);
-
-    /*******************************************************************************
-    **
-    ** Function:        removeServerConnection
-    **
-    ** Description:     Remove a server connection with the provided handle.
-    **                  jniHandle: JNI connection handle.
-    **
-    ** Returns:         True if connection found and removed.
-    **
-    *******************************************************************************/
-    bool removeServerConnection(PeerToPeer::tJNI_HANDLE jniHandle);
-
-private:
-    Mutex           mMutex;
-    // mServerConn is protected by mMutex
-    android::sp<NfaConn>     mServerConn[MAX_NFA_CONNS_PER_SERVER];
-
-    /*******************************************************************************
-    **
-    ** Function:        allocateConnection
-    **
-    ** Description:     Allocate a new connection to accept on
-    **                  jniHandle: JNI connection handle.
-    **
-    ** Returns:         Allocated connection object
-    **                  NULL if the maximum number of connections was reached
-    **
-    *******************************************************************************/
-    android::sp<NfaConn> allocateConnection (PeerToPeer::tJNI_HANDLE jniHandle);
+class P2pServer : public android::RefBase {
+ public:
+  static const std::string sSnepServiceName;
+
+  tNFA_HANDLE mNfaP2pServerHandle;     // NFA p2p handle of local server
+  PeerToPeer::tJNI_HANDLE mJniHandle;  // JNI Handle
+  SyncEvent mRegServerEvent;           // for NFA_P2pRegisterServer()
+  SyncEvent mConnRequestEvent;         // for accept()
+  std::string mServiceName;
+
+  /*******************************************************************************
+  **
+  ** Function:        P2pServer
+  **
+  ** Description:     Initialize member variables.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  P2pServer(PeerToPeer::tJNI_HANDLE jniHandle, const char* serviceName);
+
+  /*******************************************************************************
+  **
+  ** Function:        registerWithStack
+  **
+  ** Description:     Register this server with the stack.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool registerWithStack();
+
+  /*******************************************************************************
+  **
+  ** Function:        accept
+  **
+  ** Description:     Accept a peer's request to connect.
+  **                  serverJniHandle: Server's handle.
+  **                  connJniHandle: Connection handle.
+  **                  maxInfoUnit: Maximum information unit.
+  **                  recvWindow: Receive window size.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool accept(PeerToPeer::tJNI_HANDLE serverJniHandle,
+              PeerToPeer::tJNI_HANDLE connJniHandle, int maxInfoUnit,
+              int recvWindow);
+
+  /*******************************************************************************
+  **
+  ** Function:        unblockAll
+  **
+  ** Description:     Unblocks all server connections
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  void unblockAll();
+
+  /*******************************************************************************
+  **
+  ** Function:        findServerConnection
+  **
+  ** Description:     Find a P2pServer that has the handle.
+  **                  nfaConnHandle: NFA connection handle.
+  **
+  ** Returns:         P2pServer object.
+  **
+  *******************************************************************************/
+  android::sp<NfaConn> findServerConnection(tNFA_HANDLE nfaConnHandle);
+
+  /*******************************************************************************
+  **
+  ** Function:        findServerConnection
+  **
+  ** Description:     Find a P2pServer that has the handle.
+  **                  jniHandle: JNI connection handle.
+  **
+  ** Returns:         P2pServer object.
+  **
+  *******************************************************************************/
+  android::sp<NfaConn> findServerConnection(PeerToPeer::tJNI_HANDLE jniHandle);
+
+  /*******************************************************************************
+  **
+  ** Function:        removeServerConnection
+  **
+  ** Description:     Remove a server connection with the provided handle.
+  **                  jniHandle: JNI connection handle.
+  **
+  ** Returns:         True if connection found and removed.
+  **
+  *******************************************************************************/
+  bool removeServerConnection(PeerToPeer::tJNI_HANDLE jniHandle);
+
+ private:
+  Mutex mMutex;
+  // mServerConn is protected by mMutex
+  android::sp<NfaConn> mServerConn[MAX_NFA_CONNS_PER_SERVER];
+
+  /*******************************************************************************
+  **
+  ** Function:        allocateConnection
+  **
+  ** Description:     Allocate a new connection to accept on
+  **                  jniHandle: JNI connection handle.
+  **
+  ** Returns:         Allocated connection object
+  **                  NULL if the maximum number of connections was reached
+  **
+  *******************************************************************************/
+  android::sp<NfaConn> allocateConnection(PeerToPeer::tJNI_HANDLE jniHandle);
 };
 
-
 /*****************************************************************************
 **
 **  Name:           P2pClient
@@ -742,48 +711,45 @@ private:
 **  Description:    Store information about an out-bound connection to a peer.
 **
 *****************************************************************************/
-class P2pClient : public android::RefBase
-{
-public:
-    tNFA_HANDLE           mNfaP2pClientHandle;    // NFA p2p handle of client
-    bool                  mIsConnecting;          // Set true while connecting
-    android::sp<NfaConn>  mClientConn;
-    SyncEvent             mRegisteringEvent;      // For client registration
-    SyncEvent             mConnectingEvent;       // for NFA_P2pConnectByName or Sap()
-    SyncEvent             mSnepEvent;             // To wait for SNEP completion
-
-    /*******************************************************************************
-    **
-    ** Function:        P2pClient
-    **
-    ** Description:     Initialize member variables.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    P2pClient ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        ~P2pClient
-    **
-    ** Description:     Free all resources.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    ~P2pClient ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        unblock
-    **
-    ** Description:     Unblocks any threads that are locked on this connection
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void unblock();
+class P2pClient : public android::RefBase {
+ public:
+  tNFA_HANDLE mNfaP2pClientHandle;  // NFA p2p handle of client
+  bool mIsConnecting;               // Set true while connecting
+  android::sp<NfaConn> mClientConn;
+  SyncEvent mRegisteringEvent;  // For client registration
+  SyncEvent mConnectingEvent;   // for NFA_P2pConnectByName or Sap()
+  SyncEvent mSnepEvent;         // To wait for SNEP completion
+
+  /*******************************************************************************
+  **
+  ** Function:        P2pClient
+  **
+  ** Description:     Initialize member variables.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  P2pClient();
+
+  /*******************************************************************************
+  **
+  ** Function:        ~P2pClient
+  **
+  ** Description:     Free all resources.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  ~P2pClient();
+
+  /*******************************************************************************
+  **
+  ** Function:        unblock
+  **
+  ** Description:     Unblocks any threads that are locked on this connection
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void unblock();
 };
diff --git a/nci/jni/Pn544Interop.cpp b/nci/jni/Pn544Interop.cpp
index 3cc82182..c5a1c3fc 100644
--- a/nci/jni/Pn544Interop.cpp
+++ b/nci/jni/Pn544Interop.cpp
@@ -21,18 +21,23 @@
 **                  operations with PN544 controller.
 **
 *****************************************************************************/
-#include "_OverrideLog.h"
 #include "Pn544Interop.h"
 #include "IntervalTimer.h"
 #include "Mutex.h"
 #include "NfcTag.h"
-namespace android
-{
-    extern void startStopPolling (bool isStartPolling);
-    extern void releaseRfInterfaceMutexLock();
-    extern void acquireRfInterfaceMutexLock();
-}
 
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+
+namespace android {
+extern void startStopPolling(bool isStartPolling);
+extern void nativeNfcTag_releaseRfInterfaceMutexLock();
+extern void nativeNfcTag_acquireRfInterfaceMutexLock();
+}  // namespace android
 
 /*****************************************************************************
 **
@@ -40,14 +45,14 @@ namespace android
 **
 *****************************************************************************/
 
-
-static const int gIntervalTime = 1000; //millisecond between the check to restore polling
+static const int gIntervalTime =
+    1000;  // millisecond between the check to restore polling
 static IntervalTimer gTimer;
 static Mutex gMutex;
-static void pn544InteropStartPolling (union sigval); //callback function for interval timer
-static bool gIsBusy = false; //is timer busy?
-static bool gAbortNow = false; //stop timer during next callback
-
+static void pn544InteropStartPolling(
+    union sigval);              // callback function for interval timer
+static bool gIsBusy = false;    // is timer busy?
+static bool gAbortNow = false;  // stop timer during next callback
 
 /*******************************************************************************
 **
@@ -59,20 +64,19 @@ static bool gAbortNow = false; //stop timer during next callback
 ** Returns:         None
 **
 *******************************************************************************/
-void pn544InteropStopPolling ()
-{
-    ALOGV("%s: enter", __func__);
-    gMutex.lock ();
-    gTimer.kill ();
-    android::startStopPolling (false);
-    gIsBusy = true;
-    gAbortNow = false;
-    gTimer.set (gIntervalTime, pn544InteropStartPolling); //after some time, start polling again
-    gMutex.unlock ();
-    ALOGV("%s: exit", __func__);
+void pn544InteropStopPolling() {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+  gMutex.lock();
+  gTimer.kill();
+  android::startStopPolling(false);
+  gIsBusy = true;
+  gAbortNow = false;
+  gTimer.set(gIntervalTime,
+             pn544InteropStartPolling);  // after some time, start polling again
+  gMutex.unlock();
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
 }
 
-
 /*******************************************************************************
 **
 ** Function:        pn544InteropStartPolling
@@ -83,39 +87,35 @@ void pn544InteropStopPolling ()
 ** Returns:         None
 **
 *******************************************************************************/
-void pn544InteropStartPolling (union sigval)
-{
-    ALOGV("%s: enter", __func__);
-    android::acquireRfInterfaceMutexLock();
-    gMutex.lock ();
-    NfcTag::ActivationState state = NfcTag::getInstance ().getActivationState ();
-
-    if (gAbortNow)
-    {
-        ALOGV("%s: abort now", __func__);
-        gIsBusy = false;
-        goto TheEnd;
-    }
-
-    if (state == NfcTag::Idle)
-    {
-        ALOGV("%s: start polling", __func__);
-        android::startStopPolling (true);
-        gIsBusy = false;
-    }
-    else
-    {
-        ALOGV("%s: try again later", __func__);
-        gTimer.set (gIntervalTime, pn544InteropStartPolling); //after some time, start polling again
-    }
+void pn544InteropStartPolling(union sigval) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+  gMutex.lock();
+  NfcTag::ActivationState state = NfcTag::getInstance().getActivationState();
+
+  if (gAbortNow) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: abort now", __func__);
+    gIsBusy = false;
+    goto TheEnd;
+  }
+
+  if (state == NfcTag::Idle) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: start polling", __func__);
+    android::startStopPolling(true);
+    gIsBusy = false;
+  } else {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: try again later", __func__);
+    gTimer.set(
+        gIntervalTime,
+        pn544InteropStartPolling);  // after some time, start polling again
+  }
 
 TheEnd:
-    gMutex.unlock ();
-    android::releaseRfInterfaceMutexLock();
-    ALOGV("%s: exit", __func__);
+  gMutex.unlock();
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
 }
 
-
 /*******************************************************************************
 **
 ** Function:        pn544InteropIsBusy
@@ -125,17 +125,15 @@ TheEnd:
 ** Returns:         True if the code is busy.
 **
 *******************************************************************************/
-bool pn544InteropIsBusy ()
-{
-    bool isBusy = false;
-    gMutex.lock ();
-    isBusy = gIsBusy;
-    gMutex.unlock ();
-    ALOGV("%s: %u", __func__, isBusy);
-    return isBusy;
+bool pn544InteropIsBusy() {
+  bool isBusy = false;
+  gMutex.lock();
+  isBusy = gIsBusy;
+  gMutex.unlock();
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: %u", __func__, isBusy);
+  return isBusy;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        pn544InteropAbortNow
@@ -145,10 +143,9 @@ bool pn544InteropIsBusy ()
 ** Returns:         None.
 **
 *******************************************************************************/
-void pn544InteropAbortNow ()
-{
-    ALOGV("%s", __func__);
-    gMutex.lock ();
-    gAbortNow = true;
-    gMutex.unlock ();
+void pn544InteropAbortNow() {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
+  gMutex.lock();
+  gAbortNow = true;
+  gMutex.unlock();
 }
diff --git a/nci/jni/Pn544Interop.h b/nci/jni/Pn544Interop.h
index 2926195c..3d1bc20c 100644
--- a/nci/jni/Pn544Interop.h
+++ b/nci/jni/Pn544Interop.h
@@ -24,7 +24,6 @@
 #pragma once
 #include "NfcJniUtil.h"
 
-
 /*******************************************************************************
 **
 ** Function:        pn544InteropStopPolling
@@ -35,8 +34,7 @@
 ** Returns:         None
 **
 *******************************************************************************/
-void pn544InteropStopPolling ();
-
+void pn544InteropStopPolling();
 
 /*******************************************************************************
 **
@@ -47,8 +45,7 @@ void pn544InteropStopPolling ();
 ** Returns:         True if the code is busy.
 **
 *******************************************************************************/
-bool pn544InteropIsBusy ();
-
+bool pn544InteropIsBusy();
 
 /*******************************************************************************
 **
@@ -59,4 +56,4 @@ bool pn544InteropIsBusy ();
 ** Returns:         None.
 **
 *******************************************************************************/
-void pn544InteropAbortNow ();
+void pn544InteropAbortNow();
diff --git a/nci/jni/PowerSwitch.cpp b/nci/jni/PowerSwitch.cpp
index 13274e76..ab358147 100644
--- a/nci/jni/PowerSwitch.cpp
+++ b/nci/jni/PowerSwitch.cpp
@@ -35,26 +35,29 @@
 /*
  *  Adjust the controller's power states.
  */
-#include "_OverrideLog.h"
 #include "PowerSwitch.h"
 #include "NfcJniUtil.h"
-#include "config.h"
 #include "SecureElement.h"
+#include "nfc_config.h"
 
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
 
-namespace android
-{
-    void doStartupConfig ();
+using android::base::StringPrintf;
+
+namespace android {
+void doStartupConfig();
 }
 
-extern bool         gActivated;
-extern SyncEvent    gDeactivatedEvent;
+extern bool gActivated;
+extern bool nfc_debug_enabled;
+extern SyncEvent gDeactivatedEvent;
 
 PowerSwitch PowerSwitch::sPowerSwitch;
-const PowerSwitch::PowerActivity PowerSwitch::DISCOVERY=0x01;
-const PowerSwitch::PowerActivity PowerSwitch::SE_ROUTING=0x02;
-const PowerSwitch::PowerActivity PowerSwitch::SE_CONNECTED=0x04;
-const PowerSwitch::PowerActivity PowerSwitch::HOST_ROUTING=0x08;
+const PowerSwitch::PowerActivity PowerSwitch::DISCOVERY = 0x01;
+const PowerSwitch::PowerActivity PowerSwitch::SE_ROUTING = 0x02;
+const PowerSwitch::PowerActivity PowerSwitch::SE_CONNECTED = 0x04;
+const PowerSwitch::PowerActivity PowerSwitch::HOST_ROUTING = 0x08;
 
 /*******************************************************************************
 **
@@ -65,15 +68,12 @@ const PowerSwitch::PowerActivity PowerSwitch::HOST_ROUTING=0x08;
 ** Returns:         None
 **
 *******************************************************************************/
-PowerSwitch::PowerSwitch ()
-:   mCurrLevel (UNKNOWN_LEVEL),
-    mCurrDeviceMgtPowerState (NFA_DM_PWR_STATE_UNKNOWN),
-    mExpectedDeviceMgtPowerState (NFA_DM_PWR_STATE_UNKNOWN),
-    mDesiredScreenOffPowerState (0),
-    mCurrActivity(0)
-{
-}
-
+PowerSwitch::PowerSwitch()
+    : mCurrLevel(UNKNOWN_LEVEL),
+      mCurrDeviceMgtPowerState(NFA_DM_PWR_STATE_UNKNOWN),
+      mExpectedDeviceMgtPowerState(NFA_DM_PWR_STATE_UNKNOWN),
+      mDesiredScreenOffPowerState(0),
+      mCurrActivity(0) {}
 
 /*******************************************************************************
 **
@@ -84,10 +84,7 @@ PowerSwitch::PowerSwitch ()
 ** Returns:         None
 **
 *******************************************************************************/
-PowerSwitch::~PowerSwitch ()
-{
-}
-
+PowerSwitch::~PowerSwitch() {}
 
 /*******************************************************************************
 **
@@ -98,11 +95,7 @@ PowerSwitch::~PowerSwitch ()
 ** Returns:         Reference to this object.
 **
 *******************************************************************************/
-PowerSwitch& PowerSwitch::getInstance ()
-{
-    return sPowerSwitch;
-}
-
+PowerSwitch& PowerSwitch::getInstance() { return sPowerSwitch; }
 
 /*******************************************************************************
 **
@@ -113,38 +106,37 @@ PowerSwitch& PowerSwitch::getInstance ()
 ** Returns:         None
 **
 *******************************************************************************/
-void PowerSwitch::initialize (PowerLevel level)
-{
-    static const char fn [] = "PowerSwitch::initialize";
-    unsigned long num = 0;
+void PowerSwitch::initialize(PowerLevel level) {
+  static const char fn[] = "PowerSwitch::initialize";
 
-    mMutex.lock ();
+  mMutex.lock();
 
-    ALOGV("%s: level=%s (%u)", fn, powerLevelToString(level), level);
-    if (GetNumValue (NAME_SCREEN_OFF_POWER_STATE, &num, sizeof(num)))
-        mDesiredScreenOffPowerState = (int) num;
-    ALOGV("%s: desired screen-off state=%d", fn, mDesiredScreenOffPowerState);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: level=%s (%u)", fn, powerLevelToString(level), level);
+  if (NfcConfig::hasKey(NAME_SCREEN_OFF_POWER_STATE))
+    mDesiredScreenOffPowerState =
+        (int)NfcConfig::getUnsigned(NAME_SCREEN_OFF_POWER_STATE);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: desired screen-off state=%d", fn, mDesiredScreenOffPowerState);
 
-    switch (level)
-    {
+  switch (level) {
     case FULL_POWER:
-        mCurrDeviceMgtPowerState = NFA_DM_PWR_MODE_FULL;
-        mCurrLevel = level;
-        break;
+      mCurrDeviceMgtPowerState = NFA_DM_PWR_MODE_FULL;
+      mCurrLevel = level;
+      break;
 
     case UNKNOWN_LEVEL:
-        mCurrDeviceMgtPowerState = NFA_DM_PWR_STATE_UNKNOWN;
-        mCurrLevel = level;
-        break;
+      mCurrDeviceMgtPowerState = NFA_DM_PWR_STATE_UNKNOWN;
+      mCurrLevel = level;
+      break;
 
     default:
-        ALOGE("%s: not handled", fn);
-        break;
-    }
-    mMutex.unlock ();
+      LOG(ERROR) << StringPrintf("%s: not handled", fn);
+      break;
+  }
+  mMutex.unlock();
 }
 
-
 /*******************************************************************************
 **
 ** Function:        getLevel
@@ -154,16 +146,14 @@ void PowerSwitch::initialize (PowerLevel level)
 ** Returns:         Power level.
 **
 *******************************************************************************/
-PowerSwitch::PowerLevel PowerSwitch::getLevel ()
-{
-    PowerLevel level = UNKNOWN_LEVEL;
-    mMutex.lock ();
-    level = mCurrLevel;
-    mMutex.unlock ();
-    return level;
+PowerSwitch::PowerLevel PowerSwitch::getLevel() {
+  PowerLevel level = UNKNOWN_LEVEL;
+  mMutex.lock();
+  level = mCurrLevel;
+  mMutex.unlock();
+  return level;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        setLevel
@@ -174,83 +164,79 @@ PowerSwitch::PowerLevel PowerSwitch::getLevel ()
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-bool PowerSwitch::setLevel (PowerLevel newLevel)
-{
-    static const char fn [] = "PowerSwitch::setLevel";
-    bool retval = false;
+bool PowerSwitch::setLevel(PowerLevel newLevel) {
+  static const char fn[] = "PowerSwitch::setLevel";
+  bool retval = false;
 
-    mMutex.lock ();
+  mMutex.lock();
 
-    ALOGV("%s: level=%s (%u)", fn, powerLevelToString(newLevel), newLevel);
-    if (mCurrLevel == newLevel)
-    {
-        retval = true;
-        goto TheEnd;
-    }
-
-    if (mCurrLevel == UNKNOWN_LEVEL)
-    {
-        ALOGE("%s: unknown power level", fn);
-        goto TheEnd;
-    }
-
-    if ( (mCurrLevel == LOW_POWER && newLevel == FULL_POWER) ||
-         (mCurrLevel == FULL_POWER && newLevel == LOW_POWER) )
-    {
-        mMutex.unlock ();
-        SyncEventGuard g (gDeactivatedEvent);
-        if (gActivated)
-        {
-            ALOGV("%s: wait for deactivation", fn);
-            gDeactivatedEvent.wait ();
-        }
-        mMutex.lock ();
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: level=%s (%u)", fn, powerLevelToString(newLevel), newLevel);
+  if (mCurrLevel == newLevel) {
+    retval = true;
+    goto TheEnd;
+  }
+
+  if (mCurrLevel == UNKNOWN_LEVEL) {
+    LOG(ERROR) << StringPrintf("%s: unknown power level", fn);
+    goto TheEnd;
+  }
+
+  if ((mCurrLevel == LOW_POWER && newLevel == FULL_POWER) ||
+      (mCurrLevel == FULL_POWER && newLevel == LOW_POWER)) {
+    mMutex.unlock();
+    SyncEventGuard g(gDeactivatedEvent);
+    if (gActivated) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: wait for deactivation", fn);
+      gDeactivatedEvent.wait();
     }
+    mMutex.lock();
+  }
 
-    switch (newLevel)
-    {
+  switch (newLevel) {
     case FULL_POWER:
-        if (mCurrDeviceMgtPowerState == NFA_DM_PWR_MODE_OFF_SLEEP)
-            retval = setPowerOffSleepState (false);
-        break;
+      if (mCurrDeviceMgtPowerState == NFA_DM_PWR_MODE_OFF_SLEEP)
+        retval = setPowerOffSleepState(false);
+      break;
 
     case LOW_POWER:
     case POWER_OFF:
-        if (isPowerOffSleepFeatureEnabled())
-            retval = setPowerOffSleepState (true);
-        else if (mDesiredScreenOffPowerState == 1) //.conf file desires full-power
-        {
-            mCurrLevel = FULL_POWER;
-            retval = true;
-        }
-        break;
+      if (isPowerOffSleepFeatureEnabled())
+        retval = setPowerOffSleepState(true);
+      else if (mDesiredScreenOffPowerState ==
+               1)  //.conf file desires full-power
+      {
+        mCurrLevel = FULL_POWER;
+        retval = true;
+      }
+      break;
 
     default:
-        ALOGE("%s: not handled", fn);
-        break;
-    }
+      LOG(ERROR) << StringPrintf("%s: not handled", fn);
+      break;
+  }
 
-    ALOGV("%s: actual power level=%s", fn, powerLevelToString(mCurrLevel));
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: actual power level=%s", fn, powerLevelToString(mCurrLevel));
 
 TheEnd:
-    mMutex.unlock ();
-    return retval;
+  mMutex.unlock();
+  return retval;
 }
 
+bool PowerSwitch::setScreenOffPowerState(ScreenOffPowerState newState) {
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("PowerSwitch::setScreenOffPowerState: level=%s (%u)",
+                      screenOffPowerStateToString(newState), newState);
 
-bool PowerSwitch::setScreenOffPowerState (ScreenOffPowerState newState)
-{
-    ALOGV("PowerSwitch::setScreenOffPowerState: level=%s (%u)",
-        screenOffPowerStateToString(newState), newState);
-
-    mMutex.lock ();
-    mDesiredScreenOffPowerState = (int) newState;
-    mMutex.unlock ();
+  mMutex.lock();
+  mDesiredScreenOffPowerState = (int)newState;
+  mMutex.unlock();
 
-    return true;
+  return true;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        setModeOff
@@ -260,19 +246,19 @@ bool PowerSwitch::setScreenOffPowerState (ScreenOffPowerState newState)
 ** Returns:         True if any mode is still active.
 **
 *******************************************************************************/
-bool PowerSwitch::setModeOff (PowerActivity deactivated)
-{
-    bool retVal = false;
-
-    mMutex.lock ();
-    mCurrActivity &= ~deactivated;
-    retVal = mCurrActivity != 0;
-    ALOGV("PowerSwitch::setModeOff(deactivated=0x%x) : mCurrActivity=0x%x", deactivated, mCurrActivity);
-    mMutex.unlock ();
-    return retVal;
+bool PowerSwitch::setModeOff(PowerActivity deactivated) {
+  bool retVal = false;
+
+  mMutex.lock();
+  mCurrActivity &= ~deactivated;
+  retVal = mCurrActivity != 0;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "PowerSwitch::setModeOff(deactivated=0x%x) : mCurrActivity=0x%x",
+      deactivated, mCurrActivity);
+  mMutex.unlock();
+  return retVal;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        setModeOn
@@ -282,19 +268,19 @@ bool PowerSwitch::setModeOff (PowerActivity deactivated)
 ** Returns:         True if any mode is active.
 **
 *******************************************************************************/
-bool PowerSwitch::setModeOn (PowerActivity activated)
-{
-    bool retVal = false;
-
-    mMutex.lock ();
-    mCurrActivity |= activated;
-    retVal = mCurrActivity != 0;
-    ALOGV("PowerSwitch::setModeOn(activated=0x%x) : mCurrActivity=0x%x", activated, mCurrActivity);
-    mMutex.unlock ();
-    return retVal;
+bool PowerSwitch::setModeOn(PowerActivity activated) {
+  bool retVal = false;
+
+  mMutex.lock();
+  mCurrActivity |= activated;
+  retVal = mCurrActivity != 0;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "PowerSwitch::setModeOn(activated=0x%x) : mCurrActivity=0x%x", activated,
+      mCurrActivity);
+  mMutex.unlock();
+  return retVal;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        setPowerOffSleepState
@@ -305,83 +291,80 @@ bool PowerSwitch::setModeOn (PowerActivity activated)
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-bool PowerSwitch::setPowerOffSleepState (bool sleep)
-{
-    static const char fn [] = "PowerSwitch::setPowerOffSleepState";
-    ALOGV("%s: enter; sleep=%u", fn, sleep);
-    tNFA_STATUS stat = NFA_STATUS_FAILED;
-    bool retval = false;
-
-    if (sleep) //enter power-off-sleep state
-    {
-        //make sure the current power state is ON
-        if (mCurrDeviceMgtPowerState != NFA_DM_PWR_MODE_OFF_SLEEP)
-        {
-            SyncEventGuard guard (mPowerStateEvent);
-            mExpectedDeviceMgtPowerState = NFA_DM_PWR_MODE_OFF_SLEEP; //if power adjustment is ok, then this is the expected state
-            ALOGV("%s: try power off", fn);
-            stat = NFA_PowerOffSleepMode (true);
-            if (stat == NFA_STATUS_OK)
-            {
-                mPowerStateEvent.wait ();
-                mCurrLevel = LOW_POWER;
-            }
-            else
-            {
-                ALOGE("%s: API fail; stat=0x%X", fn, stat);
-                goto TheEnd;
-            }
-        }
-        else
-        {
-            ALOGE("%s: power is not ON; curr device mgt power state=%s (%u)", fn,
-                    deviceMgtPowerStateToString (mCurrDeviceMgtPowerState), mCurrDeviceMgtPowerState);
-            goto TheEnd;
-        }
+bool PowerSwitch::setPowerOffSleepState(bool sleep) {
+  static const char fn[] = "PowerSwitch::setPowerOffSleepState";
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter; sleep=%u", fn, sleep);
+  tNFA_STATUS stat = NFA_STATUS_FAILED;
+  bool retval = false;
+
+  if (sleep)  // enter power-off-sleep state
+  {
+    // make sure the current power state is ON
+    if (mCurrDeviceMgtPowerState != NFA_DM_PWR_MODE_OFF_SLEEP) {
+      SyncEventGuard guard(mPowerStateEvent);
+      mExpectedDeviceMgtPowerState =
+          NFA_DM_PWR_MODE_OFF_SLEEP;  // if power adjustment is ok, then this is
+                                      // the expected state
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: try power off", fn);
+      stat = NFA_PowerOffSleepMode(true);
+      if (stat == NFA_STATUS_OK) {
+        mPowerStateEvent.wait();
+        mCurrLevel = LOW_POWER;
+      } else {
+        LOG(ERROR) << StringPrintf("%s: API fail; stat=0x%X", fn, stat);
+        goto TheEnd;
+      }
+    } else {
+      LOG(ERROR) << StringPrintf(
+          "%s: power is not ON; curr device mgt power state=%s (%u)", fn,
+          deviceMgtPowerStateToString(mCurrDeviceMgtPowerState),
+          mCurrDeviceMgtPowerState);
+      goto TheEnd;
     }
-    else //exit power-off-sleep state
-    {
-        //make sure the current power state is OFF
-        if (mCurrDeviceMgtPowerState != NFA_DM_PWR_MODE_FULL)
-        {
-            SyncEventGuard guard (mPowerStateEvent);
-            mCurrDeviceMgtPowerState = NFA_DM_PWR_STATE_UNKNOWN;
-            mExpectedDeviceMgtPowerState = NFA_DM_PWR_MODE_FULL;  //if power adjustment is ok, then this is the expected state
-            ALOGV("%s: try full power", fn);
-            stat = NFA_PowerOffSleepMode (false);
-            if (stat == NFA_STATUS_OK)
-            {
-                mPowerStateEvent.wait ();
-                if (mCurrDeviceMgtPowerState != NFA_DM_PWR_MODE_FULL)
-                {
-                    ALOGE("%s: unable to full power; curr device mgt power stat=%s (%u)", fn,
-                            deviceMgtPowerStateToString (mCurrDeviceMgtPowerState), mCurrDeviceMgtPowerState);
-                    goto TheEnd;
-                }
-                android::doStartupConfig ();
-                mCurrLevel = FULL_POWER;
-            }
-            else
-            {
-                ALOGE("%s: API fail; stat=0x%X", fn, stat);
-                goto TheEnd;
-            }
-        }
-        else
-        {
-            ALOGE("%s: not in power-off state; curr device mgt power state=%s (%u)", fn,
-                    deviceMgtPowerStateToString (mCurrDeviceMgtPowerState), mCurrDeviceMgtPowerState);
-            goto TheEnd;
+  } else  // exit power-off-sleep state
+  {
+    // make sure the current power state is OFF
+    if (mCurrDeviceMgtPowerState != NFA_DM_PWR_MODE_FULL) {
+      SyncEventGuard guard(mPowerStateEvent);
+      mCurrDeviceMgtPowerState = NFA_DM_PWR_STATE_UNKNOWN;
+      mExpectedDeviceMgtPowerState =
+          NFA_DM_PWR_MODE_FULL;  // if power adjustment is ok, then this is the
+                                 // expected state
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: try full power", fn);
+      stat = NFA_PowerOffSleepMode(false);
+      if (stat == NFA_STATUS_OK) {
+        mPowerStateEvent.wait();
+        if (mCurrDeviceMgtPowerState != NFA_DM_PWR_MODE_FULL) {
+          LOG(ERROR) << StringPrintf(
+              "%s: unable to full power; curr device mgt power stat=%s (%u)",
+              fn, deviceMgtPowerStateToString(mCurrDeviceMgtPowerState),
+              mCurrDeviceMgtPowerState);
+          goto TheEnd;
         }
+        android::doStartupConfig();
+        mCurrLevel = FULL_POWER;
+      } else {
+        LOG(ERROR) << StringPrintf("%s: API fail; stat=0x%X", fn, stat);
+        goto TheEnd;
+      }
+    } else {
+      LOG(ERROR) << StringPrintf(
+          "%s: not in power-off state; curr device mgt power state=%s (%u)", fn,
+          deviceMgtPowerStateToString(mCurrDeviceMgtPowerState),
+          mCurrDeviceMgtPowerState);
+      goto TheEnd;
     }
+  }
 
-    retval = true;
+  retval = true;
 TheEnd:
-    ALOGV("%s: exit; return %u", fn, retval);
-    return retval;
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit; return %u", fn, retval);
+  return retval;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        deviceMgtPowerStateToString
@@ -392,20 +375,18 @@ TheEnd:
 ** Returns:         Text representation of power level.
 **
 *******************************************************************************/
-const char* PowerSwitch::deviceMgtPowerStateToString (uint8_t deviceMgtPowerState)
-{
-    switch (deviceMgtPowerState)
-    {
+const char* PowerSwitch::deviceMgtPowerStateToString(
+    uint8_t deviceMgtPowerState) {
+  switch (deviceMgtPowerState) {
     case NFA_DM_PWR_MODE_FULL:
-        return "DM-FULL";
+      return "DM-FULL";
     case NFA_DM_PWR_MODE_OFF_SLEEP:
-        return "DM-OFF";
+      return "DM-OFF";
     default:
-        return "DM-unknown????";
-    }
+      return "DM-unknown????";
+  }
 }
 
-
 /*******************************************************************************
 **
 ** Function:        powerLevelToString
@@ -416,21 +397,19 @@ const char* PowerSwitch::deviceMgtPowerStateToString (uint8_t deviceMgtPowerStat
 ** Returns:         Text representation of power level.
 **
 *******************************************************************************/
-const char* PowerSwitch::powerLevelToString (PowerLevel level)
-{
-    switch (level)
-    {
+const char* PowerSwitch::powerLevelToString(PowerLevel level) {
+  switch (level) {
     case UNKNOWN_LEVEL:
-        return "PS-UNKNOWN";
+      return "PS-UNKNOWN";
     case FULL_POWER:
-        return "PS-FULL";
+      return "PS-FULL";
     case LOW_POWER:
-        return "PS-LOW-POWER";
+      return "PS-LOW-POWER";
     case POWER_OFF:
-        return "PS-POWER-OFF";
+      return "PS-POWER-OFF";
     default:
-        return "PS-unknown????";
-    }
+      return "PS-unknown????";
+  }
 }
 
 /*******************************************************************************
@@ -443,19 +422,18 @@ const char* PowerSwitch::powerLevelToString (PowerLevel level)
 ** Returns:         Text representation of power level.
 **
 *******************************************************************************/
-const char* PowerSwitch::screenOffPowerStateToString (ScreenOffPowerState state)
-{
-    switch (state)
-    {
+const char* PowerSwitch::screenOffPowerStateToString(
+    ScreenOffPowerState state) {
+  switch (state) {
     case POWER_STATE_OFF:
-        return "SOPS-POWER_OFF";
+      return "SOPS-POWER_OFF";
     case POWER_STATE_FULL:
-        return "SOPS-FULL";
+      return "SOPS-FULL";
     case POWER_STATE_CARD_EMULATION:
-        return "SOPS-CARD_EMULATION";
+      return "SOPS-CARD_EMULATION";
     default:
-        return "SOPS-unknown????";
-    }
+      return "SOPS-unknown????";
+  }
 }
 
 /*******************************************************************************
@@ -467,15 +445,13 @@ const char* PowerSwitch::screenOffPowerStateToString (ScreenOffPowerState state)
 ** Returns:         None
 **
 *******************************************************************************/
-void PowerSwitch::abort ()
-{
-    static const char fn [] = "PowerSwitch::abort";
-    ALOGV("%s", fn);
-    SyncEventGuard guard (mPowerStateEvent);
-    mPowerStateEvent.notifyOne ();
+void PowerSwitch::abort() {
+  static const char fn[] = "PowerSwitch::abort";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", fn);
+  SyncEventGuard guard(mPowerStateEvent);
+  mPowerStateEvent.notifyOne();
 }
 
-
 /*******************************************************************************
 **
 ** Function:        deviceManagementCallback
@@ -487,32 +463,31 @@ void PowerSwitch::abort ()
 ** Returns:         None
 **
 *******************************************************************************/
-void PowerSwitch::deviceManagementCallback (uint8_t event, tNFA_DM_CBACK_DATA* eventData)
-{
-    static const char fn [] = "PowerSwitch::deviceManagementCallback";
-
-    switch (event)
-    {
-    case NFA_DM_PWR_MODE_CHANGE_EVT:
-        {
-            tNFA_DM_PWR_MODE_CHANGE& power_mode = eventData->power_mode;
-            ALOGV("%s: NFA_DM_PWR_MODE_CHANGE_EVT; status=0x%X; device mgt power state=%s (0x%X)", fn,
-                    power_mode.status, sPowerSwitch.deviceMgtPowerStateToString (power_mode.power_mode),
-                    power_mode.power_mode);
-            SyncEventGuard guard (sPowerSwitch.mPowerStateEvent);
-            if (power_mode.status == NFA_STATUS_OK)
-            {
-                //the event data does not contain the newly configured power mode,
-                //so this code assigns the expected value
-                sPowerSwitch.mCurrDeviceMgtPowerState = sPowerSwitch.mExpectedDeviceMgtPowerState;
-            }
-            sPowerSwitch.mPowerStateEvent.notifyOne ();
-        }
-        break;
-    }
+void PowerSwitch::deviceManagementCallback(uint8_t event,
+                                           tNFA_DM_CBACK_DATA* eventData) {
+  static const char fn[] = "PowerSwitch::deviceManagementCallback";
+
+  switch (event) {
+    case NFA_DM_PWR_MODE_CHANGE_EVT: {
+      tNFA_DM_PWR_MODE_CHANGE& power_mode = eventData->power_mode;
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_DM_PWR_MODE_CHANGE_EVT; status=0x%X; device mgt power "
+          "state=%s (0x%X)",
+          fn, power_mode.status,
+          sPowerSwitch.deviceMgtPowerStateToString(power_mode.power_mode),
+          power_mode.power_mode);
+      SyncEventGuard guard(sPowerSwitch.mPowerStateEvent);
+      if (power_mode.status == NFA_STATUS_OK) {
+        // the event data does not contain the newly configured power mode,
+        // so this code assigns the expected value
+        sPowerSwitch.mCurrDeviceMgtPowerState =
+            sPowerSwitch.mExpectedDeviceMgtPowerState;
+      }
+      sPowerSwitch.mPowerStateEvent.notifyOne();
+    } break;
+  }
 }
 
-
 /*******************************************************************************
 **
 ** Function:        isPowerOffSleepFeatureEnabled
@@ -522,7 +497,6 @@ void PowerSwitch::deviceManagementCallback (uint8_t event, tNFA_DM_CBACK_DATA* e
 ** Returns:         True if feature is enabled.
 **
 *******************************************************************************/
-bool PowerSwitch::isPowerOffSleepFeatureEnabled ()
-{
-    return mDesiredScreenOffPowerState == 0;
+bool PowerSwitch::isPowerOffSleepFeatureEnabled() {
+  return mDesiredScreenOffPowerState == 0;
 }
diff --git a/nci/jni/PowerSwitch.h b/nci/jni/PowerSwitch.h
index ae9986f2..b596cffd 100644
--- a/nci/jni/PowerSwitch.h
+++ b/nci/jni/PowerSwitch.h
@@ -18,9 +18,8 @@
  *  Adjust the controller's power states.
  */
 #pragma once
-#include "nfa_api.h"
 #include "SyncEvent.h"
-
+#include "nfa_api.h"
 
 /*****************************************************************************
 **
@@ -29,272 +28,268 @@
 **  Description:    Adjust the controller's power states.
 **
 *****************************************************************************/
-class PowerSwitch
-{
-public:
-
-
-    /*******************************************************************************
-    **
-    ** Description:     UNKNOWN_LEVEL: power level is unknown because the stack is off.
-    **                  FULL_POWER: controller is in full-power state.
-    **                  LOW_POWER: controller is in lower-power state.
-    **
-    *******************************************************************************/
-    enum PowerLevel {UNKNOWN_LEVEL, FULL_POWER, LOW_POWER, POWER_OFF};
-
-    /*******************************************************************************
-    **
-    ** Description:     POWER_STATE_OFF: power level is OFF when screen is off.
-    **                  POWER_STATE_FULL: controller is in full-power state when screen is off.
-    **                                    after a period of inactivity, controller goes into snooze
-    **                                    mode.
-    **                  POWER_STATE_CARD_EMULATION: screen-off card-emulation
-    **                                              (CE4/CE3/CE1 modes are used),
-    **
-    *******************************************************************************/
-    enum ScreenOffPowerState {
-        POWER_STATE_OFF = 0,
-        POWER_STATE_FULL = 1,
-        POWER_STATE_CARD_EMULATION = 2
-    };
-
-    /*******************************************************************************
-    **
-    ** Description:     DISCOVERY: Discovery is enabled
-    **                  SE_ROUTING: Routing to SE is enabled.
-    **                  SE_CONNECTED: SE is connected.
-    **
-    *******************************************************************************/
-    typedef int PowerActivity;
-    static const PowerActivity DISCOVERY;
-    static const PowerActivity SE_ROUTING;
-    static const PowerActivity SE_CONNECTED;
-    static const PowerActivity HOST_ROUTING;
-
-    /*******************************************************************************
-    **
-    ** Description:     Platform Power Level, copied from NativeNfcBrcmPowerMode.java.
-    **                  UNKNOWN_LEVEL: power level is unknown.
-    **                  POWER_OFF: The phone is turned OFF
-    **                  SCREEN_OFF: The phone is turned ON but screen is OFF
-    **                  SCREEN_ON_LOCKED: The phone is turned ON, screen is ON but user locked
-    **                  SCREEN_ON_UNLOCKED: The phone is turned ON, screen is ON, and user unlocked
-    **
-    *******************************************************************************/
-    static const int PLATFORM_UNKNOWN_LEVEL = 0;
-    static const int PLATFORM_POWER_OFF = 1;
-    static const int PLATFORM_SCREEN_OFF = 2;
-    static const int PLATFORM_SCREEN_ON_LOCKED = 3;
-    static const int PLATFORM_SCREEN_ON_UNLOCKED = 4;
-
-    static const int VBAT_MONITOR_ENABLED = 1;
-    static const int VBAT_MONITOR_PRIMARY_THRESHOLD = 5;
-    static const int VBAT_MONITOR_SECONDARY_THRESHOLD = 8;
-    /*******************************************************************************
-    **
-    ** Function:        PowerSwitch
-    **
-    ** Description:     Initialize member variables.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    PowerSwitch ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        ~PowerSwitch
-    **
-    ** Description:     Release all resources.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    ~PowerSwitch ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        getInstance
-    **
-    ** Description:     Get the singleton of this object.
-    **
-    ** Returns:         Reference to this object.
-    **
-    *******************************************************************************/
-    static PowerSwitch& getInstance ();
-
-    /*******************************************************************************
-    **
-    ** Function:        initialize
-    **
-    ** Description:     Initialize member variables.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void initialize (PowerLevel level);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        getLevel
-    **
-    ** Description:     Get the current power level of the controller.
-    **
-    ** Returns:         Power level.
-    **
-    *******************************************************************************/
-    PowerLevel getLevel ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        setLevel
-    **
-    ** Description:     Set the controller's power level.
-    **                  level: power level.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    bool setLevel (PowerLevel level);
-
-    /*******************************************************************************
-    **
-    ** Function:        setScreenOffPowerState
-    **
-    ** Description:     Set the controller's screen off power state.
-    **                  state: the desired screen off power state.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    bool setScreenOffPowerState (ScreenOffPowerState state);
-
-    /*******************************************************************************
-    **
-    ** Function:        setModeOff
-    **
-    ** Description:     Set a mode to be deactive.
-    **
-    ** Returns:         True if any mode is still active.
-    **
-    *******************************************************************************/
-    bool setModeOff (PowerActivity deactivated);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        setModeOn
-    **
-    ** Description:     Set a mode to be active.
-    **
-    ** Returns:         True if any mode is active.
-    **
-    *******************************************************************************/
-    bool setModeOn (PowerActivity activated);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        abort
-    **
-    ** Description:     Abort and unblock currrent operation.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void abort ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        deviceManagementCallback
-    **
-    ** Description:     Callback function for the stack.
-    **                  event: event ID.
-    **                  eventData: event's data.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    static void deviceManagementCallback (uint8_t event, tNFA_DM_CBACK_DATA* eventData);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        isPowerOffSleepFeatureEnabled
-    **
-    ** Description:     Whether power-off-sleep feature is enabled in .conf file.
-    **
-    ** Returns:         True if feature is enabled.
-    **
-    *******************************************************************************/
-    bool isPowerOffSleepFeatureEnabled ();
-
-private:
-    PowerLevel mCurrLevel;
-    uint8_t mCurrDeviceMgtPowerState; //device management power state; such as NFA_BRCM_PWR_MODE_???
-    uint8_t mExpectedDeviceMgtPowerState; //device management power state; such as NFA_BRCM_PWR_MODE_???
-    int mDesiredScreenOffPowerState; //read from .conf file; 0=power-off-sleep; 1=full power; 2=CE4 power
-    static PowerSwitch sPowerSwitch; //singleton object
-    static const uint8_t NFA_DM_PWR_STATE_UNKNOWN = -1; //device management power state power state is unknown
-    SyncEvent mPowerStateEvent;
-    PowerActivity mCurrActivity;
-    Mutex mMutex;
-
-
-    /*******************************************************************************
-    **
-    ** Function:        setPowerOffSleepState
-    **
-    ** Description:     Adjust controller's power-off-sleep state.
-    **                  sleep: whether to enter sleep state.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    bool setPowerOffSleepState (bool sleep);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        deviceMgtPowerStateToString
-    **
-    ** Description:     Decode power level to a string.
-    **                  deviceMgtPowerState: power level.
-    **
-    ** Returns:         Text representation of power level.
-    **
-    *******************************************************************************/
-    const char* deviceMgtPowerStateToString (uint8_t deviceMgtPowerState);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        powerLevelToString
-    **
-    ** Description:     Decode power level to a string.
-    **                  level: power level.
-    **
-    ** Returns:         Text representation of power level.
-    **
-    *******************************************************************************/
-    const char* powerLevelToString (PowerLevel level);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        screenOffPowerStateToString
-    **
-    ** Description:     Decode screen-off power state to a string.
-    **                  state: power state
-    **
-    ** Returns:         Text representation of screen-off power state.
-    **
-    *******************************************************************************/
-    const char* screenOffPowerStateToString (ScreenOffPowerState state);
+class PowerSwitch {
+ public:
+  /*******************************************************************************
+  **
+  ** Description:     UNKNOWN_LEVEL: power level is unknown because the stack is
+  *off.
+  **                  FULL_POWER: controller is in full-power state.
+  **                  LOW_POWER: controller is in lower-power state.
+  **
+  *******************************************************************************/
+  enum PowerLevel { UNKNOWN_LEVEL, FULL_POWER, LOW_POWER, POWER_OFF };
+
+  /*******************************************************************************
+  **
+  ** Description:     POWER_STATE_OFF: power level is OFF when screen is off.
+  **                  POWER_STATE_FULL: controller is in full-power state when
+  *screen is off.
+  **                                    after a period of inactivity, controller
+  *goes into snooze
+  **                                    mode.
+  **                  POWER_STATE_CARD_EMULATION: screen-off card-emulation
+  **                                              (CE4/CE3/CE1 modes are used),
+  **
+  *******************************************************************************/
+  enum ScreenOffPowerState {
+    POWER_STATE_OFF = 0,
+    POWER_STATE_FULL = 1,
+    POWER_STATE_CARD_EMULATION = 2
+  };
+
+  /*******************************************************************************
+  **
+  ** Description:     DISCOVERY: Discovery is enabled
+  **                  SE_ROUTING: Routing to SE is enabled.
+  **                  SE_CONNECTED: SE is connected.
+  **
+  *******************************************************************************/
+  typedef int PowerActivity;
+  static const PowerActivity DISCOVERY;
+  static const PowerActivity SE_ROUTING;
+  static const PowerActivity SE_CONNECTED;
+  static const PowerActivity HOST_ROUTING;
+
+  /*******************************************************************************
+  **
+  ** Description:     Platform Power Level, copied from
+  *NativeNfcBrcmPowerMode.java.
+  **                  UNKNOWN_LEVEL: power level is unknown.
+  **                  POWER_OFF: The phone is turned OFF
+  **                  SCREEN_OFF: The phone is turned ON but screen is OFF
+  **                  SCREEN_ON_LOCKED: The phone is turned ON, screen is ON but
+  *user locked
+  **                  SCREEN_ON_UNLOCKED: The phone is turned ON, screen is ON,
+  *and user unlocked
+  **
+  *******************************************************************************/
+  static const int PLATFORM_UNKNOWN_LEVEL = 0;
+  static const int PLATFORM_POWER_OFF = 1;
+  static const int PLATFORM_SCREEN_OFF = 2;
+  static const int PLATFORM_SCREEN_ON_LOCKED = 3;
+  static const int PLATFORM_SCREEN_ON_UNLOCKED = 4;
+
+  static const int VBAT_MONITOR_ENABLED = 1;
+  static const int VBAT_MONITOR_PRIMARY_THRESHOLD = 5;
+  static const int VBAT_MONITOR_SECONDARY_THRESHOLD = 8;
+  /*******************************************************************************
+  **
+  ** Function:        PowerSwitch
+  **
+  ** Description:     Initialize member variables.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  PowerSwitch();
+
+  /*******************************************************************************
+  **
+  ** Function:        ~PowerSwitch
+  **
+  ** Description:     Release all resources.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  ~PowerSwitch();
+
+  /*******************************************************************************
+  **
+  ** Function:        getInstance
+  **
+  ** Description:     Get the singleton of this object.
+  **
+  ** Returns:         Reference to this object.
+  **
+  *******************************************************************************/
+  static PowerSwitch& getInstance();
+
+  /*******************************************************************************
+  **
+  ** Function:        initialize
+  **
+  ** Description:     Initialize member variables.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void initialize(PowerLevel level);
+
+  /*******************************************************************************
+  **
+  ** Function:        getLevel
+  **
+  ** Description:     Get the current power level of the controller.
+  **
+  ** Returns:         Power level.
+  **
+  *******************************************************************************/
+  PowerLevel getLevel();
+
+  /*******************************************************************************
+  **
+  ** Function:        setLevel
+  **
+  ** Description:     Set the controller's power level.
+  **                  level: power level.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool setLevel(PowerLevel level);
+
+  /*******************************************************************************
+  **
+  ** Function:        setScreenOffPowerState
+  **
+  ** Description:     Set the controller's screen off power state.
+  **                  state: the desired screen off power state.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool setScreenOffPowerState(ScreenOffPowerState state);
+
+  /*******************************************************************************
+  **
+  ** Function:        setModeOff
+  **
+  ** Description:     Set a mode to be deactive.
+  **
+  ** Returns:         True if any mode is still active.
+  **
+  *******************************************************************************/
+  bool setModeOff(PowerActivity deactivated);
+
+  /*******************************************************************************
+  **
+  ** Function:        setModeOn
+  **
+  ** Description:     Set a mode to be active.
+  **
+  ** Returns:         True if any mode is active.
+  **
+  *******************************************************************************/
+  bool setModeOn(PowerActivity activated);
+
+  /*******************************************************************************
+  **
+  ** Function:        abort
+  **
+  ** Description:     Abort and unblock currrent operation.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void abort();
+
+  /*******************************************************************************
+  **
+  ** Function:        deviceManagementCallback
+  **
+  ** Description:     Callback function for the stack.
+  **                  event: event ID.
+  **                  eventData: event's data.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  static void deviceManagementCallback(uint8_t event,
+                                       tNFA_DM_CBACK_DATA* eventData);
+
+  /*******************************************************************************
+  **
+  ** Function:        isPowerOffSleepFeatureEnabled
+  **
+  ** Description:     Whether power-off-sleep feature is enabled in .conf file.
+  **
+  ** Returns:         True if feature is enabled.
+  **
+  *******************************************************************************/
+  bool isPowerOffSleepFeatureEnabled();
+
+ private:
+  PowerLevel mCurrLevel;
+  uint8_t mCurrDeviceMgtPowerState;  // device management power state; such as
+                                     // NFA_BRCM_PWR_MODE_???
+  uint8_t mExpectedDeviceMgtPowerState;  // device management power state; such
+                                         // as NFA_BRCM_PWR_MODE_???
+  int mDesiredScreenOffPowerState;  // read from .conf file; 0=power-off-sleep;
+                                    // 1=full power; 2=CE4 power
+  static PowerSwitch sPowerSwitch;  // singleton object
+  static const uint8_t NFA_DM_PWR_STATE_UNKNOWN =
+      -1;  // device management power state power state is unknown
+  SyncEvent mPowerStateEvent;
+  PowerActivity mCurrActivity;
+  Mutex mMutex;
+
+  /*******************************************************************************
+  **
+  ** Function:        setPowerOffSleepState
+  **
+  ** Description:     Adjust controller's power-off-sleep state.
+  **                  sleep: whether to enter sleep state.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool setPowerOffSleepState(bool sleep);
+
+  /*******************************************************************************
+  **
+  ** Function:        deviceMgtPowerStateToString
+  **
+  ** Description:     Decode power level to a string.
+  **                  deviceMgtPowerState: power level.
+  **
+  ** Returns:         Text representation of power level.
+  **
+  *******************************************************************************/
+  const char* deviceMgtPowerStateToString(uint8_t deviceMgtPowerState);
+
+  /*******************************************************************************
+  **
+  ** Function:        powerLevelToString
+  **
+  ** Description:     Decode power level to a string.
+  **                  level: power level.
+  **
+  ** Returns:         Text representation of power level.
+  **
+  *******************************************************************************/
+  const char* powerLevelToString(PowerLevel level);
+
+  /*******************************************************************************
+  **
+  ** Function:        screenOffPowerStateToString
+  **
+  ** Description:     Decode screen-off power state to a string.
+  **                  state: power state
+  **
+  ** Returns:         Text representation of screen-off power state.
+  **
+  *******************************************************************************/
+  const char* screenOffPowerStateToString(ScreenOffPowerState state);
 };
diff --git a/nci/jni/RouteDataSet.cpp b/nci/jni/RouteDataSet.cpp
index d04587ca..14bc33a1 100644
--- a/nci/jni/RouteDataSet.cpp
+++ b/nci/jni/RouteDataSet.cpp
@@ -23,14 +23,21 @@
 /*
  *  Import and export general routing data using a XML file.
  */
-#include "_OverrideLog.h"
-#include "RouteDataSet.h"
-//#include "libxml/xmlmemory.h"
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
 #include <errno.h>
 #include <sys/stat.h>
+/* NOTE:
+ * This has to be included AFTER the android-base includes since
+ * android-base/macros.h defines ATTRIBUTE_UNUSED, also used in the
+ * tiny XML library.
+ */
+#include "RouteDataSet.h"
 
-extern char bcm_nfc_location[];
+using android::base::StringPrintf;
 
+extern std::string nfc_storage_path;
+extern bool nfc_debug_enabled;
 
 /*******************************************************************************
 **
@@ -43,39 +50,31 @@ extern char bcm_nfc_location[];
 ** Returns:         None.
 **
 *******************************************************************************/
-AidBuffer::AidBuffer (std::string& aid)
-:   mBuffer (NULL),
-    mBufferLen (0)
-{
-    unsigned int num = 0;
-    const char delimiter = ':';
-    std::string::size_type pos1 = 0;
-    std::string::size_type pos2 = aid.find_first_of (delimiter);
-
-    //parse the AID string; each hex number is separated by a colon;
-    mBuffer = new uint8_t [aid.length()];
-    while (true)
-    {
-        num = 0;
-        if (pos2 == std::string::npos)
-        {
-            sscanf (aid.substr(pos1).c_str(), "%x", &num);
-            mBuffer [mBufferLen] = (uint8_t) num;
-            mBufferLen++;
-            break;
-        }
-        else
-        {
-            sscanf (aid.substr(pos1, pos2-pos1+1).c_str(), "%x", &num);
-            mBuffer [mBufferLen] = (uint8_t) num;
-            mBufferLen++;
-            pos1 = pos2 + 1;
-            pos2 = aid.find_first_of (delimiter, pos1);
-        }
+AidBuffer::AidBuffer(std::string& aid) : mBuffer(NULL), mBufferLen(0) {
+  unsigned int num = 0;
+  const char delimiter = ':';
+  std::string::size_type pos1 = 0;
+  std::string::size_type pos2 = aid.find_first_of(delimiter);
+
+  // parse the AID string; each hex number is separated by a colon;
+  mBuffer = new uint8_t[aid.length()];
+  while (true) {
+    num = 0;
+    if (pos2 == std::string::npos) {
+      sscanf(aid.substr(pos1).c_str(), "%x", &num);
+      mBuffer[mBufferLen] = (uint8_t)num;
+      mBufferLen++;
+      break;
+    } else {
+      sscanf(aid.substr(pos1, pos2 - pos1 + 1).c_str(), "%x", &num);
+      mBuffer[mBufferLen] = (uint8_t)num;
+      mBufferLen++;
+      pos1 = pos2 + 1;
+      pos2 = aid.find_first_of(delimiter, pos1);
     }
+  }
 }
 
-
 /*******************************************************************************
 **
 ** Function:        ~AidBuffer
@@ -85,19 +84,13 @@ AidBuffer::AidBuffer (std::string& aid)
 ** Returns:         None.
 **
 *******************************************************************************/
-AidBuffer::~AidBuffer ()
-{
-    delete [] mBuffer;
-}
-
+AidBuffer::~AidBuffer() { delete[] mBuffer; }
 
 /*******************************************************************************/
 /*******************************************************************************/
 
-
 const char* RouteDataSet::sConfigFile = "/param/route.xml";
 
-
 /*******************************************************************************
 **
 ** Function:        ~RouteDataSet
@@ -107,11 +100,7 @@ const char* RouteDataSet::sConfigFile = "/param/route.xml";
 ** Returns:         None.
 **
 *******************************************************************************/
-RouteDataSet::~RouteDataSet ()
-{
-    deleteDatabase ();
-}
-
+RouteDataSet::~RouteDataSet() { deleteDatabase(); }
 
 /*******************************************************************************
 **
@@ -122,17 +111,17 @@ RouteDataSet::~RouteDataSet ()
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-bool RouteDataSet::initialize()
-{
-    ALOGV("%s: enter", "RouteDataSet::initialize");
-    //check that the libxml2 version in use is compatible
-    //with the version the software has been compiled with
-    //LIBXML_TEST_VERSION
-    ALOGV("%s: exit; return=true", "RouteDataSet::initialize");
-    return true;
+bool RouteDataSet::initialize() {
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter", "RouteDataSet::initialize");
+  // check that the libxml2 version in use is compatible
+  // with the version the software has been compiled with
+  // LIBXML_TEST_VERSION
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit; return=true", "RouteDataSet::initialize");
+  return true;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        deleteDatabase
@@ -142,22 +131,24 @@ bool RouteDataSet::initialize()
 ** Returns:         None.
 **
 *******************************************************************************/
-void RouteDataSet::deleteDatabase()
-{
-    ALOGV("%s: default db size=%zu; sec elem db size=%zu", "RouteDataSet::deleteDatabase",
-            mDefaultRouteDatabase.size(), mSecElemRouteDatabase.size());
-    Database::iterator it;
-
-    for (it = mDefaultRouteDatabase.begin(); it != mDefaultRouteDatabase.end(); it++)
-        delete (*it);
-    mDefaultRouteDatabase.clear ();
-
-    for (it = mSecElemRouteDatabase.begin(); it != mSecElemRouteDatabase.end(); it++)
-        delete (*it);
-    mSecElemRouteDatabase.clear ();
+void RouteDataSet::deleteDatabase() {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: default db size=%zu; sec elem db size=%zu",
+      "RouteDataSet::deleteDatabase", mDefaultRouteDatabase.size(),
+      mSecElemRouteDatabase.size());
+  Database::iterator it;
+
+  for (it = mDefaultRouteDatabase.begin(); it != mDefaultRouteDatabase.end();
+       it++)
+    delete (*it);
+  mDefaultRouteDatabase.clear();
+
+  for (it = mSecElemRouteDatabase.begin(); it != mSecElemRouteDatabase.end();
+       it++)
+    delete (*it);
+  mSecElemRouteDatabase.clear();
 }
 
-
 /*******************************************************************************
 **
 ** Function:        import
@@ -167,15 +158,14 @@ void RouteDataSet::deleteDatabase()
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-bool RouteDataSet::import ()
-{
-    static const char fn [] = "RouteDataSet::import";
-    ALOGV("%s: enter", fn);
-    bool retval = false;
+bool RouteDataSet::import() {
+  static const char fn[] = "RouteDataSet::import";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+  bool retval = false;
 #if 0
     xmlDocPtr doc;
     xmlNodePtr node1;
-    std::string strFilename(bcm_nfc_location);
+    std::string strFilename(nfc_storage_path);
     strFilename += sConfigFile;
 
     deleteDatabase ();
@@ -183,17 +173,17 @@ bool RouteDataSet::import ()
     doc = xmlParseFile (strFilename.c_str());
     if (doc == NULL)
     {
-        ALOGV("%s: fail parse", fn);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: fail parse", fn);
         goto TheEnd;
     }
 
     node1 = xmlDocGetRootElement (doc);
     if (node1 == NULL)
     {
-        ALOGE("%s: fail root element", fn);
+        LOG(ERROR) << StringPrintf("%s: fail root element", fn);
         goto TheEnd;
     }
-    ALOGV("%s: root=%s", fn, node1->name);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: root=%s", fn, node1->name);
 
     node1 = node1->xmlChildrenNode;
     while (node1) //loop through all elements in <Routes ...
@@ -203,7 +193,7 @@ bool RouteDataSet::import ()
             xmlChar* value = xmlGetProp (node1, (const xmlChar*) "Type");
             if (value && (xmlStrcmp (value, (const xmlChar*) "SecElemSelectedRoutes") == 0))
             {
-                ALOGV("%s: found SecElemSelectedRoutes", fn);
+                DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: found SecElemSelectedRoutes", fn);
                 xmlNodePtr node2 = node1->xmlChildrenNode;
                 while (node2) //loop all elements in <Route Type="SecElemSelectedRoutes" ...
                 {
@@ -216,7 +206,7 @@ bool RouteDataSet::import ()
             }
             else if (value && (xmlStrcmp (value, (const xmlChar*) "DefaultRoutes") == 0))
             {
-                ALOGV("%s: found DefaultRoutes", fn);
+                DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: found DefaultRoutes", fn);
                 xmlNodePtr node2 = node1->xmlChildrenNode;
                 while (node2) //loop all elements in <Route Type="DefaultRoutes" ...
                 {
@@ -237,12 +227,11 @@ bool RouteDataSet::import ()
 TheEnd:
     xmlFreeDoc (doc);
     xmlCleanupParser ();
-    ALOGV("%s: exit; return=%u", fn, retval);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit; return=%u", fn, retval);
 #endif
-    return retval;
+  return retval;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        saveToFile
@@ -253,39 +242,35 @@ TheEnd:
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-bool RouteDataSet::saveToFile (const char* routesXml)
-{
-    static const char fn [] = "RouteDataSet::saveToFile";
-    FILE* fh = NULL;
-    size_t actualWritten = 0;
-    bool retval = false;
-    std::string filename (bcm_nfc_location);
-    int stat = 0;
-
-    filename.append (sConfigFile);
-    fh = fopen (filename.c_str (), "w");
-    if (fh == NULL)
-    {
-        ALOGE("%s: fail to open file", fn);
-        return false;
-    }
-
-    actualWritten = fwrite (routesXml, sizeof(char), strlen(routesXml), fh);
-    retval = actualWritten == strlen(routesXml);
-    fclose (fh);
-    ALOGV("%s: wrote %zu bytes", fn, actualWritten);
-    if (retval == false)
-        ALOGE("%s: error during write", fn);
-
-    //set file permission to
-    //owner read, write; group read; other read
-    stat = chmod (filename.c_str (), S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
-    if (stat == -1)
-        ALOGE("%s: error during chmod", fn);
-    return retval;
+bool RouteDataSet::saveToFile(const char* routesXml) {
+  static const char fn[] = "RouteDataSet::saveToFile";
+  FILE* fh = NULL;
+  size_t actualWritten = 0;
+  bool retval = false;
+  std::string filename(nfc_storage_path);
+  int stat = 0;
+
+  filename.append(sConfigFile);
+  fh = fopen(filename.c_str(), "w");
+  if (fh == NULL) {
+    LOG(ERROR) << StringPrintf("%s: fail to open file", fn);
+    return false;
+  }
+
+  actualWritten = fwrite(routesXml, sizeof(char), strlen(routesXml), fh);
+  retval = actualWritten == strlen(routesXml);
+  fclose(fh);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: wrote %zu bytes", fn, actualWritten);
+  if (retval == false) LOG(ERROR) << StringPrintf("%s: error during write", fn);
+
+  // set file permission to
+  // owner read, write; group read; other read
+  stat = chmod(filename.c_str(), S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
+  if (stat == -1) LOG(ERROR) << StringPrintf("%s: error during chmod", fn);
+  return retval;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        loadFromFile
@@ -296,34 +281,31 @@ bool RouteDataSet::saveToFile (const char* routesXml)
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-bool RouteDataSet::loadFromFile (std::string& routesXml)
-{
-    FILE* fh = NULL;
-    size_t actual = 0;
-    char buffer [1024];
-    std::string filename (bcm_nfc_location);
-
-    filename.append (sConfigFile);
-    fh = fopen (filename.c_str (), "r");
-    if (fh == NULL)
-    {
-        ALOGV("%s: fail to open file", "RouteDataSet::loadFromFile");
-        return false;
-    }
-
-    while (true)
-    {
-        actual = fread (buffer, sizeof(char), sizeof(buffer), fh);
-        if (actual == 0)
-            break;
-        routesXml.append (buffer, actual);
-    }
-    fclose (fh);
-    ALOGV("%s: read %zu bytes", "RouteDataSet::loadFromFile", routesXml.length());
-    return true;
+bool RouteDataSet::loadFromFile(std::string& routesXml) {
+  FILE* fh = NULL;
+  size_t actual = 0;
+  char buffer[1024];
+  std::string filename(nfc_storage_path);
+
+  filename.append(sConfigFile);
+  fh = fopen(filename.c_str(), "r");
+  if (fh == NULL) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: fail to open file", "RouteDataSet::loadFromFile");
+    return false;
+  }
+
+  while (true) {
+    actual = fread(buffer, sizeof(char), sizeof(buffer), fh);
+    if (actual == 0) break;
+    routesXml.append(buffer, actual);
+  }
+  fclose(fh);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: read %zu bytes", "RouteDataSet::loadFromFile", routesXml.length());
+  return true;
 }
 
-
 #if 0
 
 
@@ -349,7 +331,7 @@ void RouteDataSet::importProtocolRoute (xmlNodePtr& element, Database& database)
     RouteDataForProtocol* data = new RouteDataForProtocol;
     xmlChar* value = NULL;
 
-    ALOGV_IF(sDebug, "%s: element=%s", "RouteDataSet::importProtocolRoute", element->name);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: element=%s", "RouteDataSet::importProtocolRoute", element->name);
     value = xmlGetProp (element, id);
     if (value)
     {
@@ -362,7 +344,7 @@ void RouteDataSet::importProtocolRoute (xmlNodePtr& element, Database& database)
         else if (xmlStrcmp (value, (const xmlChar*) "IsoDep") == 0)
             data->mProtocol = NFA_PROTOCOL_MASK_ISO_DEP;
         xmlFree (value);
-        ALOGV_IF(sDebug, "%s: %s=0x%X", "RouteDataSet::importProtocolRoute", id, data->mProtocol);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: %s=0x%X", "RouteDataSet::importProtocolRoute", id, data->mProtocol);
     }
 
     value = xmlGetProp (element, secElem);
@@ -371,7 +353,7 @@ void RouteDataSet::importProtocolRoute (xmlNodePtr& element, Database& database)
         data->mNfaEeHandle = strtol ((char*) value, NULL, 16);
         xmlFree (value);
         data->mNfaEeHandle = data->mNfaEeHandle | NFA_HANDLE_GROUP_EE;
-        ALOGV_IF(sDebug, "%s: %s=0x%X", "RouteDataSet::importProtocolRoute", secElem, data->mNfaEeHandle);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: %s=0x%X", "RouteDataSet::importProtocolRoute", secElem, data->mNfaEeHandle);
     }
 
     value = xmlGetProp (element, switchOn);
@@ -420,7 +402,7 @@ void RouteDataSet::importTechnologyRoute (xmlNodePtr& element, Database& databas
     RouteDataForTechnology* data = new RouteDataForTechnology;
     xmlChar* value = NULL;
 
-    ALOGV_IF(sDebug, "%s: element=%s", "RouteDataSet::importTechnologyRoute", element->name);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: element=%s", "RouteDataSet::importTechnologyRoute", element->name);
     value = xmlGetProp (element, id);
     if (value)
     {
@@ -431,7 +413,7 @@ void RouteDataSet::importTechnologyRoute (xmlNodePtr& element, Database& databas
         else if (xmlStrcmp (value, (const xmlChar*) "NfcF") == 0)
             data->mTechnology = NFA_TECHNOLOGY_MASK_F;
         xmlFree (value);
-        ALOGV_IF(sDebug, "%s: %s=0x%X", "RouteDataSet::importTechnologyRoute", id, data->mTechnology);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: %s=0x%X", "RouteDataSet::importTechnologyRoute", id, data->mTechnology);
     }
 
     value = xmlGetProp (element, secElem);
@@ -440,7 +422,7 @@ void RouteDataSet::importTechnologyRoute (xmlNodePtr& element, Database& databas
         data->mNfaEeHandle = strtol ((char*) value, NULL, 16);
         xmlFree (value);
         data->mNfaEeHandle = data->mNfaEeHandle | NFA_HANDLE_GROUP_EE;
-        ALOGV_IF(sDebug, "%s: %s=0x%X", "RouteDataSet::importTechnologyRoute", secElem, data->mNfaEeHandle);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: %s=0x%X", "RouteDataSet::importTechnologyRoute", secElem, data->mNfaEeHandle);
     }
 
     value = xmlGetProp (element, switchOn);
@@ -476,17 +458,16 @@ void RouteDataSet::importTechnologyRoute (xmlNodePtr& element, Database& databas
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-bool RouteDataSet::deleteFile ()
-{
-    static const char fn [] = "RouteDataSet::deleteFile";
-    std::string filename (bcm_nfc_location);
-    filename.append (sConfigFile);
-    int stat = remove (filename.c_str());
-    ALOGV("%s: exit %u", fn, stat==0);
-    return stat == 0;
+bool RouteDataSet::deleteFile() {
+  static const char fn[] = "RouteDataSet::deleteFile";
+  std::string filename(nfc_storage_path);
+  filename.append(sConfigFile);
+  int stat = remove(filename.c_str());
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit %u", fn, stat == 0);
+  return stat == 0;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        getDatabase
@@ -497,19 +478,16 @@ bool RouteDataSet::deleteFile ()
 ** Returns:         Pointer to database.
 **
 *******************************************************************************/
-RouteDataSet::Database* RouteDataSet::getDatabase (DatabaseSelection selection)
-{
-    switch (selection)
-    {
+RouteDataSet::Database* RouteDataSet::getDatabase(DatabaseSelection selection) {
+  switch (selection) {
     case DefaultRouteDatabase:
-        return &mDefaultRouteDatabase;
+      return &mDefaultRouteDatabase;
     case SecElemRouteDatabase:
-        return &mSecElemRouteDatabase;
-    }
-    return NULL;
+      return &mSecElemRouteDatabase;
+  }
+  return NULL;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        printDiagnostic
@@ -519,51 +497,48 @@ RouteDataSet::Database* RouteDataSet::getDatabase (DatabaseSelection selection)
 ** Returns:         None.
 **
 *******************************************************************************/
-void RouteDataSet::printDiagnostic ()
-{
-    static const char fn [] = "RouteDataSet::printDiagnostic";
-    Database* db = getDatabase (DefaultRouteDatabase);
-
-    ALOGV("%s: default route database", fn);
-    for (Database::iterator iter = db->begin(); iter != db->end(); iter++)
-    {
-        RouteData* routeData = *iter;
-        switch (routeData->mRouteType)
-        {
-        case RouteData::ProtocolRoute:
-            {
-                RouteDataForProtocol* proto = (RouteDataForProtocol*) routeData;
-                ALOGV("%s: ee h=0x%X; protocol=0x%X", fn, proto->mNfaEeHandle, proto->mProtocol);
-            }
-            break;
-        case RouteData::TechnologyRoute:
-            {
-                RouteDataForTechnology* tech = (RouteDataForTechnology*) routeData;
-                ALOGV("%s: ee h=0x%X; technology=0x%X", fn, tech->mNfaEeHandle, tech->mTechnology);
-            }
-            break;
-        }
+void RouteDataSet::printDiagnostic() {
+  static const char fn[] = "RouteDataSet::printDiagnostic";
+  Database* db = getDatabase(DefaultRouteDatabase);
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: default route database", fn);
+  for (Database::iterator iter = db->begin(); iter != db->end(); iter++) {
+    RouteData* routeData = *iter;
+    switch (routeData->mRouteType) {
+      case RouteData::ProtocolRoute: {
+        RouteDataForProtocol* proto = (RouteDataForProtocol*)routeData;
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: ee h=0x%X; protocol=0x%X", fn,
+                            proto->mNfaEeHandle, proto->mProtocol);
+      } break;
+      case RouteData::TechnologyRoute: {
+        RouteDataForTechnology* tech = (RouteDataForTechnology*)routeData;
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: ee h=0x%X; technology=0x%X", fn,
+                            tech->mNfaEeHandle, tech->mTechnology);
+      } break;
     }
-
-    ALOGV("%s: sec elem route database", fn);
-    db = getDatabase (SecElemRouteDatabase);
-    for (Database::iterator iter2 = db->begin(); iter2 != db->end(); iter2++)
-    {
-        RouteData* routeData = *iter2;
-        switch (routeData->mRouteType)
-        {
-        case RouteData::ProtocolRoute:
-            {
-                RouteDataForProtocol* proto = (RouteDataForProtocol*) routeData;
-                ALOGV("%s: ee h=0x%X; protocol=0x%X", fn, proto->mNfaEeHandle, proto->mProtocol);
-            }
-            break;
-        case RouteData::TechnologyRoute:
-            {
-                RouteDataForTechnology* tech = (RouteDataForTechnology*) routeData;
-                ALOGV("%s: ee h=0x%X; technology=0x%X", fn, tech->mNfaEeHandle, tech->mTechnology);
-            }
-            break;
-        }
+  }
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: sec elem route database", fn);
+  db = getDatabase(SecElemRouteDatabase);
+  for (Database::iterator iter2 = db->begin(); iter2 != db->end(); iter2++) {
+    RouteData* routeData = *iter2;
+    switch (routeData->mRouteType) {
+      case RouteData::ProtocolRoute: {
+        RouteDataForProtocol* proto = (RouteDataForProtocol*)routeData;
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: ee h=0x%X; protocol=0x%X", fn,
+                            proto->mNfaEeHandle, proto->mProtocol);
+      } break;
+      case RouteData::TechnologyRoute: {
+        RouteDataForTechnology* tech = (RouteDataForTechnology*)routeData;
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: ee h=0x%X; technology=0x%X", fn,
+                            tech->mNfaEeHandle, tech->mTechnology);
+      } break;
     }
+  }
 }
diff --git a/nci/jni/RouteDataSet.h b/nci/jni/RouteDataSet.h
index ba45dfd7..2a0e075d 100644
--- a/nci/jni/RouteDataSet.h
+++ b/nci/jni/RouteDataSet.h
@@ -40,9 +40,8 @@
 #include "NfcJniUtil.h"
 #include "nfa_api.h"
 //#include <libxml/parser.h>
-#include <vector>
 #include <string>
-
+#include <vector>
 
 /*****************************************************************************
 **
@@ -51,20 +50,15 @@
 **  Description:    Base class for every kind of route data.
 **
 *****************************************************************************/
-class RouteData
-{
-public:
-    enum RouteType {ProtocolRoute, TechnologyRoute};
-    RouteType mRouteType;
+class RouteData {
+ public:
+  enum RouteType { ProtocolRoute, TechnologyRoute };
+  RouteType mRouteType;
 
-protected:
-    RouteData (RouteType routeType) : mRouteType (routeType)
-    {}
+ protected:
+  RouteData(RouteType routeType) : mRouteType(routeType) {}
 };
 
-
-
-
 /*****************************************************************************
 **
 **  Name:           RouteDataForProtocol
@@ -72,22 +66,23 @@ protected:
 **  Description:    Data for protocol routes.
 **
 *****************************************************************************/
-class RouteDataForProtocol : public RouteData
-{
-public:
-    int mNfaEeHandle; //for example 0x4f3, 0x4f4
-    bool mSwitchOn;
-    bool mSwitchOff;
-    bool mBatteryOff;
-    tNFA_PROTOCOL_MASK mProtocol;
-
-    RouteDataForProtocol () : RouteData (ProtocolRoute), mNfaEeHandle (NFA_HANDLE_INVALID),
-            mSwitchOn (false), mSwitchOff (false), mBatteryOff (false),
-            mProtocol (0)
-    {}
+class RouteDataForProtocol : public RouteData {
+ public:
+  int mNfaEeHandle;  // for example 0x4f3, 0x4f4
+  bool mSwitchOn;
+  bool mSwitchOff;
+  bool mBatteryOff;
+  tNFA_PROTOCOL_MASK mProtocol;
+
+  RouteDataForProtocol()
+      : RouteData(ProtocolRoute),
+        mNfaEeHandle(NFA_HANDLE_INVALID),
+        mSwitchOn(false),
+        mSwitchOff(false),
+        mBatteryOff(false),
+        mProtocol(0) {}
 };
 
-
 /*****************************************************************************
 **
 **  Name:           RouteDataForTechnology
@@ -95,26 +90,26 @@ public:
 **  Description:    Data for technology routes.
 **
 *****************************************************************************/
-class RouteDataForTechnology : public RouteData
-{
-public:
-    int mNfaEeHandle; //for example 0x4f3, 0x4f4
-    bool mSwitchOn;
-    bool mSwitchOff;
-    bool mBatteryOff;
-    tNFA_TECHNOLOGY_MASK mTechnology;
-
-    RouteDataForTechnology () : RouteData (TechnologyRoute), mNfaEeHandle (NFA_HANDLE_INVALID),
-            mSwitchOn (false), mSwitchOff (false), mBatteryOff (false),
-            mTechnology (0)
-    {}
+class RouteDataForTechnology : public RouteData {
+ public:
+  int mNfaEeHandle;  // for example 0x4f3, 0x4f4
+  bool mSwitchOn;
+  bool mSwitchOff;
+  bool mBatteryOff;
+  tNFA_TECHNOLOGY_MASK mTechnology;
+
+  RouteDataForTechnology()
+      : RouteData(TechnologyRoute),
+        mNfaEeHandle(NFA_HANDLE_INVALID),
+        mSwitchOn(false),
+        mSwitchOff(false),
+        mBatteryOff(false),
+        mTechnology(0) {}
 };
 
-
 /*****************************************************************************/
 /*****************************************************************************/
 
-
 /*****************************************************************************
 **
 **  Name:           AidBuffer
@@ -123,49 +118,44 @@ public:
 **                  values to bytes.
 **
 *****************************************************************************/
-class AidBuffer
-{
-public:
-
-    /*******************************************************************************
-    **
-    ** Function:        AidBuffer
-    **
-    ** Description:     Parse a string of hex numbers.  Store result in an array of
-    **                  bytes.
-    **                  aid: string of hex numbers.
-    **
-    ** Returns:         None.
-    **
-    *******************************************************************************/
-    AidBuffer (std::string& aid);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        ~AidBuffer
-    **
-    ** Description:     Release all resources.
-    **
-    ** Returns:         None.
-    **
-    *******************************************************************************/
-    ~AidBuffer ();
-
-
-    uint8_t* buffer () {return mBuffer;};
-    int length () {return mBufferLen;};
-
-private:
-    uint8_t* mBuffer;
-    uint32_t mBufferLen;
+class AidBuffer {
+ public:
+  /*******************************************************************************
+  **
+  ** Function:        AidBuffer
+  **
+  ** Description:     Parse a string of hex numbers.  Store result in an array
+  *of
+  **                  bytes.
+  **                  aid: string of hex numbers.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  AidBuffer(std::string& aid);
+
+  /*******************************************************************************
+  **
+  ** Function:        ~AidBuffer
+  **
+  ** Description:     Release all resources.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  ~AidBuffer();
+
+  uint8_t* buffer() { return mBuffer; };
+  int length() { return mBufferLen; };
+
+ private:
+  uint8_t* mBuffer;
+  uint32_t mBufferLen;
 };
 
-
 /*****************************************************************************/
 /*****************************************************************************/
 
-
 /*****************************************************************************
 **
 **  Name:           RouteDataSet
@@ -174,153 +164,142 @@ private:
 **                  See /data/bcm/param/route.xml
 **
 *****************************************************************************/
-class RouteDataSet
-{
-public:
-    typedef std::vector<RouteData*> Database;
-    enum DatabaseSelection {DefaultRouteDatabase, SecElemRouteDatabase};
-
-
-    /*******************************************************************************
-    **
-    ** Function:        ~RouteDataSet
-    **
-    ** Description:     Release all resources.
-    **
-    ** Returns:         None.
-    **
-    *******************************************************************************/
-    ~RouteDataSet ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        initialize
-    **
-    ** Description:     Initialize resources.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    bool initialize ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        import
-    **
-    ** Description:     Import data from an XML file.  Fill the database.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    bool import ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        getDatabase
-    **
-    ** Description:     Obtain a database of routing data.
-    **                  selection: which database.
-    **
-    ** Returns:         Pointer to database.
-    **
-    *******************************************************************************/
-    Database* getDatabase (DatabaseSelection selection);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        saveToFile
-    **
-    ** Description:     Save XML data from a string into a file.
-    **                  routesXml: XML that represents routes.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    static bool saveToFile (const char* routesXml);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        loadFromFile
-    **
-    ** Description:     Load XML data from file into a string.
-    **                  routesXml: string to receive XML data.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    static bool loadFromFile (std::string& routesXml);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        deleteFile
-    **
-    ** Description:     Delete route data XML file.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    static bool deleteFile ();
-
-    /*******************************************************************************
-    **
-    ** Function:        printDiagnostic
-    **
-    ** Description:     Print some diagnostic output.
-    **
-    ** Returns:         None.
-    **
-    *******************************************************************************/
-    void printDiagnostic ();
-
-private:
-    Database mSecElemRouteDatabase; //routes when NFC service selects sec elem
-    Database mDefaultRouteDatabase; //routes when NFC service deselects sec elem
-    static const char* sConfigFile;
-    static const bool sDebug = false;
-
-
-    /*******************************************************************************
-    **
-    ** Function:        deleteDatabase
-    **
-    ** Description:     Delete all routes stored in all databases.
-    **
-    ** Returns:         None.
-    **
-    *******************************************************************************/
-    void deleteDatabase ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        importProtocolRoute
-    **
-    ** Description:     Parse data for protocol routes.
-    **                  element: XML node for one protocol route.
-    **                  database: store data in this database.
-    **
-    ** Returns:         None.
-    **
-    *******************************************************************************/
-    //void importProtocolRoute (xmlNodePtr& element, Database& database);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        importTechnologyRoute
-    **
-    ** Description:     Parse data for technology routes.
-    **                  element: XML node for one technology route.
-    **                  database: store data in this database.
-    **
-    ** Returns:         None.
-    **
-    *******************************************************************************/
+class RouteDataSet {
+ public:
+  typedef std::vector<RouteData*> Database;
+  enum DatabaseSelection { DefaultRouteDatabase, SecElemRouteDatabase };
+
+  /*******************************************************************************
+  **
+  ** Function:        ~RouteDataSet
+  **
+  ** Description:     Release all resources.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  ~RouteDataSet();
+
+  /*******************************************************************************
+  **
+  ** Function:        initialize
+  **
+  ** Description:     Initialize resources.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool initialize();
+
+  /*******************************************************************************
+  **
+  ** Function:        import
+  **
+  ** Description:     Import data from an XML file.  Fill the database.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool import();
+
+  /*******************************************************************************
+  **
+  ** Function:        getDatabase
+  **
+  ** Description:     Obtain a database of routing data.
+  **                  selection: which database.
+  **
+  ** Returns:         Pointer to database.
+  **
+  *******************************************************************************/
+  Database* getDatabase(DatabaseSelection selection);
+
+  /*******************************************************************************
+  **
+  ** Function:        saveToFile
+  **
+  ** Description:     Save XML data from a string into a file.
+  **                  routesXml: XML that represents routes.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  static bool saveToFile(const char* routesXml);
+
+  /*******************************************************************************
+  **
+  ** Function:        loadFromFile
+  **
+  ** Description:     Load XML data from file into a string.
+  **                  routesXml: string to receive XML data.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  static bool loadFromFile(std::string& routesXml);
+
+  /*******************************************************************************
+  **
+  ** Function:        deleteFile
+  **
+  ** Description:     Delete route data XML file.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  static bool deleteFile();
+
+  /*******************************************************************************
+  **
+  ** Function:        printDiagnostic
+  **
+  ** Description:     Print some diagnostic output.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  void printDiagnostic();
+
+ private:
+  Database mSecElemRouteDatabase;  // routes when NFC service selects sec elem
+  Database mDefaultRouteDatabase;  // routes when NFC service deselects sec elem
+  static const char* sConfigFile;
+  static const bool sDebug = false;
+
+  /*******************************************************************************
+  **
+  ** Function:        deleteDatabase
+  **
+  ** Description:     Delete all routes stored in all databases.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  void deleteDatabase();
+
+  /*******************************************************************************
+  **
+  ** Function:        importProtocolRoute
+  **
+  ** Description:     Parse data for protocol routes.
+  **                  element: XML node for one protocol route.
+  **                  database: store data in this database.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  // void importProtocolRoute (xmlNodePtr& element, Database& database);
+
+  /*******************************************************************************
+  **
+  ** Function:        importTechnologyRoute
+  **
+  ** Description:     Parse data for technology routes.
+  **                  element: XML node for one technology route.
+  **                  database: store data in this database.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
   //  void importTechnologyRoute (xmlNodePtr& element, Database& database);
 };
diff --git a/nci/jni/RoutingManager.cpp b/nci/jni/RoutingManager.cpp
old mode 100644
new mode 100755
index d3dee5cf..2a979c86
--- a/nci/jni/RoutingManager.cpp
+++ b/nci/jni/RoutingManager.cpp
@@ -2,7 +2,7 @@
  * Copyright (c) 2016, The Linux Foundation. All rights reserved.
  * Not a Contribution.
  *
- * Copyright (C) 2015 NXP Semiconductors
+ * Copyright (C) 2015-2018 NXP Semiconductors
  * The original Work has been changed by NXP Semiconductors.
  *
  * Copyright (C) 2013 The Android Open Source Project
@@ -23,22 +23,27 @@
  *  Manage the listen-mode routing table.
  */
 
-#include <log/log.h>
-#include <nativehelper/ScopedLocalRef.h>
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
 #include <nativehelper/JNIHelp.h>
-#include "config.h"
+#include <nativehelper/ScopedLocalRef.h>
 #include "JavaClassConstants.h"
-#include "RoutingManager.h"
 #include "SecureElement.h"
-#if(NXP_EXTNS == TRUE)
-extern "C"{
-#include "phNxpConfig.h"
-#include "nfc_api.h"
+#include "RoutingManager.h"
+#include "nfc_config.h"
+#include "nfa_ee_api.h"
+#if (NXP_EXTNS == TRUE)
+#include "MposManager.h"
 #include "nfa_api.h"
-}
-#define ALOGV ALOGD
+#include "nfc_api.h"
+#include "phNxpConfig.h"
+#include "nfc_config.h"
+
+using android::base::StringPrintf;
+
 extern int32_t gSeDiscoverycount;
 extern SyncEvent gNfceeDiscCbEvent;
+extern bool nfc_debug_enabled;
 
 uint8_t nfcee_swp_discovery_status;
 extern int32_t gActualSeCount;
@@ -52,113 +57,88 @@ int gWiredModeRfFieldEnable = 0;
 #endif
 extern bool sHCEEnabled;
 
-const JNINativeMethod RoutingManager::sMethods [] =
-{
-    {"doGetDefaultRouteDestination", "()I", (void*) RoutingManager::com_android_nfc_cardemulation_doGetDefaultRouteDestination},
-    {"doGetDefaultOffHostRouteDestination", "()I", (void*) RoutingManager::com_android_nfc_cardemulation_doGetDefaultOffHostRouteDestination},
-    {"doGetAidMatchingMode", "()I", (void*) RoutingManager::com_android_nfc_cardemulation_doGetAidMatchingMode},
-    {"doGetAidMatchingPlatform", "()I", (void*) RoutingManager::com_android_nfc_cardemulation_doGetAidMatchingPlatform}
-};
-
-static uint16_t rdr_req_handling_timeout = 50;
-
-
-#if(NXP_EXTNS == TRUE)
-Rdr_req_ntf_info_t swp_rdr_req_ntf_info;
-static IntervalTimer swp_rd_req_timer;
-#endif
+const JNINativeMethod RoutingManager::sMethods[] = {
+    {"doGetDefaultRouteDestination", "()I",
+     (void*)RoutingManager::
+         com_android_nfc_cardemulation_doGetDefaultRouteDestination},
+    {"doGetDefaultOffHostRouteDestination", "()I",
+     (void*)RoutingManager::
+         com_android_nfc_cardemulation_doGetDefaultOffHostRouteDestination},
+    {"doGetAidMatchingMode", "()I",
+     (void*)RoutingManager::com_android_nfc_cardemulation_doGetAidMatchingMode},
+    {"doGetAidMatchingPlatform", "()I",
+     (void*)RoutingManager::
+         com_android_nfc_cardemulation_doGetAidMatchingPlatform}};
 
 uint16_t lastcehandle = 0;
+// SCBR from host works only when App is in foreground
+static const uint8_t SYS_CODE_PWR_STATE_HOST = 0x01;
+static const uint16_t DEFAULT_SYS_CODE = 0xFEFE;
 
-namespace android
-{
-    extern void checkforTranscation(uint8_t connEvent, void* eventData );
+namespace android {
+extern void checkforTranscation(uint8_t connEvent, void* eventData);
 #if (NXP_EXTNS == TRUE)
-    extern bool nfcManager_sendEmptyDataMsg();
-    extern bool gIsEmptyRspSentByHceFApk;
-    extern uint16_t sRoutingBuffLen;
-    extern bool  rfActivation;
-    extern bool isNfcInitializationDone();
-    extern void startRfDiscovery (bool isStart);
-    extern bool isDiscoveryStarted();
-    extern int getScreenState();
-#if(NXP_NFCC_HCE_F == TRUE)
-    extern bool nfcManager_getTransanctionRequest(int t3thandle, bool registerRequest);
+extern bool nfcManager_sendEmptyDataMsg();
+extern bool gIsEmptyRspSentByHceFApk;
+extern uint16_t sRoutingBuffLen;
+extern bool rfActivation;
+extern bool isNfcInitializationDone();
+extern void startRfDiscovery(bool isStart);
+extern bool isDiscoveryStarted();
+extern int getScreenState();
+#if (NXP_NFCC_HCE_F == TRUE)
+extern bool nfcManager_getTransanctionRequest(int t3thandle,
+                                              bool registerRequest);
 #endif
 #endif
-}
+}  // namespace android
 
 #if (NXP_EXTNS == TRUE)
 static RouteInfo_t gRouteInfo;
 #endif
 
-RoutingManager::RoutingManager ()
-: mNativeData(NULL),
-  mDefaultEe (NFA_HANDLE_INVALID),
-  mHostListnTechMask (0),
-  mUiccListnTechMask (0),
-  mFwdFuntnEnable (true),
-  mAddAid(0),
-  mDefaultHCEFRspTimeout (5000)
-{
-    static const char fn [] = "RoutingManager::RoutingManager()";
-    unsigned long num = 0;
-    ALOGV("%s:enter", fn);
-    // Get the active SE
-    if (GetNumValue("ACTIVE_SE", &num, sizeof(num)))
-        mActiveSe = num;
-    else
-        mActiveSe = 0x00;
-    // Get the active SE for Nfc-F
-    if (GetNumValue("ACTIVE_SE_NFCF", &num, sizeof(num)))
-        mActiveSeNfcF = num;
-    else
-        mActiveSeNfcF = 0x00;
-    // Get the "default" route
-    if (GetNumValue("DEFAULT_ISODEP_ROUTE", &num, sizeof(num)))
-    {
-        if(nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) {
-            if((num == 0xF4 || num == 0xF8) && sCurrentSelectedUICCSlot)
-            {
-                mDefaultEe = (sCurrentSelectedUICCSlot != 0x02) ? 0xF4 : 0xF8;
-            }
-            else
-            {
-                mDefaultEe = num;
-            }
-            ALOGV("%s: DEFAULT_ISODEP_ROUTE mDefaultEe : %d", fn, mDefaultEe);
-        }
-        else {
-            mDefaultEe = num;
-        }
+RoutingManager::RoutingManager()
+    : mNativeData(NULL),
+      mDefaultEe(NFA_HANDLE_INVALID),
+      mHostListnTechMask(0),
+      mUiccListnTechMask(0),
+      mFwdFuntnEnable(true),
+      mAddAid(0),
+      mDefaultHCEFRspTimeout(5000) {
+  static const char fn[] = "RoutingManager::RoutingManager()";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s:enter", fn);
+  mDefaultOffHostRoute =
+      NfcConfig::getUnsigned(NAME_DEFAULT_OFFHOST_ROUTE, 0x00);
+
+  mAidMatchingMode =
+      NfcConfig::getUnsigned(NAME_AID_MATCHING_MODE, AID_MATCHING_EXACT_ONLY);
+
+  mAidMatchingPlatform =
+      NfcConfig::getUnsigned("AID_MATCHING_PLATFORM", AID_MATCHING_L);
+
+  mDefaultSysCodeRoute =
+      NfcConfig::getUnsigned(NAME_DEFAULT_SYS_CODE_ROUTE, 0xC0);
+
+  mDefaultSysCodePowerstate =
+      NfcConfig::getUnsigned(NAME_DEFAULT_SYS_CODE_PWR_STATE, 0x19);
+
+  mOffHostAidRoutingPowerState =
+      NfcConfig::getUnsigned(NAME_OFFHOST_AID_ROUTE_PWR_STATE, 0x01);
+
+  mDefaultSysCode = DEFAULT_SYS_CODE;
+  if (NfcConfig::hasKey(NAME_DEFAULT_SYS_CODE)) {
+    std::vector<uint8_t> pSysCode = NfcConfig::getBytes(NAME_DEFAULT_SYS_CODE);
+    if (pSysCode.size() == 0x02) {
+      mDefaultSysCode = ((pSysCode[0] << 8) | ((int)pSysCode[1] << 0));
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: DEFAULT_SYS_CODE: 0x%02X", __func__, mDefaultSysCode);
     }
-    else
-    {
-        mDefaultEe = 0x00;
-    }
-    // Get the "default" route for Nfc-F
-    if (GetNumValue("DEFAULT_NFCF_ROUTE", &num, sizeof(num)))
-      mDefaultEeNfcF = num;
-    else
-      mDefaultEeNfcF = 0x00;
-    // Get the default "off-host" route.  This is hard-coded at the Java layer
-    // but we can override it here to avoid forcing Java changes.
-    if (GetNumValue("DEFAULT_OFFHOST_ROUTE", &num, sizeof(num)))
-        mOffHostEe = num;
-    else
-        mOffHostEe = 0x02;
-    if (GetNumValue("AID_MATCHING_MODE", &num, sizeof(num)))
-        mAidMatchingMode = num;
-    else
-        mAidMatchingMode = AID_MATCHING_EXACT_ONLY;
-    if (GetNxpNumValue("AID_MATCHING_PLATFORM", &num, sizeof(num)))
-        mAidMatchingPlatform = num;
-    else
-        mAidMatchingPlatform = AID_MATCHING_L;
-
-    mSeTechMask = 0x00; //unused
-    mNfcFOnDhHandle = NFA_HANDLE_INVALID;
-    ALOGV("%s:exit", fn);
+  }
+
+  mSeTechMask = 0x00;  // unused
+  mNfcFOnDhHandle = NFA_HANDLE_INVALID;
+  mIsScbrSupported = false;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s:exit", fn);
 }
 
 int RoutingManager::mChipId = 0;
@@ -166,3068 +146,3044 @@ int RoutingManager::mChipId = 0;
 bool recovery;
 #endif
 
-#if(NXP_EXTNS == TRUE)
-void reader_req_event_ntf (union sigval);
-#endif
-RoutingManager::~RoutingManager ()
-{
-    NFA_EeDeregister (nfaEeCallback);
-}
+RoutingManager::~RoutingManager() { NFA_EeDeregister(nfaEeCallback); }
 
-bool RoutingManager::initialize (nfc_jni_native_data* native)
-{
-    static const char fn [] = "RoutingManager::initialize()";
-    unsigned long num = 0, tech = 0;
-    mNativeData = native;
-    uint8_t ActualNumEe = nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED;
-    tNFA_EE_INFO mEeInfo [ActualNumEe];
+bool RoutingManager::initialize(nfc_jni_native_data* native) {
+  static const char fn[] = "RoutingManager::initialize()";
+  unsigned long num = 0;
+  mNativeData = native;
+  uint8_t ActualNumEe = nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED;
+  tNFA_EE_INFO mEeInfo[ActualNumEe];
 
-    ALOGV("%s: enter", fn);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
 #if (NXP_EXTNS == TRUE)
-    memset(&gRouteInfo, 0x00, sizeof(RouteInfo_t));
-    nfcee_swp_discovery_status = SWP_DEFAULT;
-    if ((GetNumValue(NAME_HOST_LISTEN_TECH_MASK, &tech, sizeof(tech))))
-        mHostListnTechMask = tech;
-    else
-        mHostListnTechMask = 0x07;
-
-    if ((GetNumValue(NAME_UICC_LISTEN_TECH_MASK, &tech, sizeof(tech))))
-        mUiccListnTechMask = tech;
-    else
-        mUiccListnTechMask = 0x07;
-
-    if ((GetNumValue(NAME_NXP_FWD_FUNCTIONALITY_ENABLE, &tech, sizeof(tech))))
-        mFwdFuntnEnable = tech;
-    else
-        mFwdFuntnEnable = 0x01;
-
-    if (GetNxpNumValue (NAME_NXP_DEFAULT_SE, (void*)&num, sizeof(num)))
-        mDefaultEe = num;
-    else
-        mDefaultEe = 0x02;
-
-    if (GetNxpNumValue (NAME_NXP_ENABLE_ADD_AID, (void*)&num, sizeof(num)))
-        mAddAid = num;
-    else
-        mAddAid = 0x01;
-
-    if(nfcFL.nfcNxpEse && (nfcFL.chipType != pn547C2)) {
-        if (GetNxpNumValue (NAME_NXP_ESE_WIRED_PRT_MASK, (void*)&num, sizeof(num)))
-            gEseVirtualWiredProtectMask = num;
-        else
-            gEseVirtualWiredProtectMask = 0x00;
-
-        if (GetNxpNumValue (NAME_NXP_UICC_WIRED_PRT_MASK, (void*)&num, sizeof(num)))
-            gUICCVirtualWiredProtectMask = num;
-        else
-            gUICCVirtualWiredProtectMask = 0x00;
-
-        if (GetNxpNumValue (NAME_NXP_WIRED_MODE_RF_FIELD_ENABLE, (void*)&num, sizeof(num)))
-            gWiredModeRfFieldEnable = num;
-        else
-            gWiredModeRfFieldEnable = 0x00;
-    }
-    if(nfcFL.eseFL._ESE_FELICA_CLT) {
-        if (GetNxpNumValue (NAME_DEFAULT_FELICA_CLT_ROUTE, (void*)&num, sizeof(num)))
-        {
-            if(nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC && nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) {
-                if((num == 0x02 || num == 0x03) && sCurrentSelectedUICCSlot)
-                {
-                    mDefaultTechFSeID = getUiccRoute(sCurrentSelectedUICCSlot);
-                }
-                else
-                {
-                    mDefaultTechFSeID = ( (num == 0x01) ? ROUTE_LOC_ESE_ID : ((num == 0x02) ? SecureElement::getInstance().EE_HANDLE_0xF4 : ROUTE_LOC_UICC2_ID) );
-                }
-            }
-            else
-            {
-                mDefaultTechFSeID = ( (num == 0x01) ? ROUTE_LOC_ESE_ID : ((num == 0x02) ? SecureElement::getInstance().EE_HANDLE_0xF4 : ROUTE_LOC_UICC2_ID) );
-            }
-        }
-        else
-        {
-            mDefaultTechFSeID = getUiccRoute(sCurrentSelectedUICCSlot);
-        }
+  memset(&gRouteInfo, 0x00, sizeof(RouteInfo_t));
+  nfcee_swp_discovery_status = SWP_DEFAULT;
+
+  if (NfcConfig::hasKey(NAME_HOST_LISTEN_TECH_MASK)) {
+    mHostListnTechMask = NfcConfig::getUnsigned(NAME_HOST_LISTEN_TECH_MASK);
+  } else {
+    mHostListnTechMask = 0x07;
+  }
+
+  if (NfcConfig::hasKey(NAME_UICC_LISTEN_TECH_MASK)) {
+    mUiccListnTechMask = NfcConfig::getUnsigned(NAME_UICC_LISTEN_TECH_MASK);
+  } else {
+    mUiccListnTechMask = 0x07;
+  }
+
+  if (NfcConfig::hasKey(NAME_NXP_FWD_FUNCTIONALITY_ENABLE)) {
+    mFwdFuntnEnable = NfcConfig::getUnsigned(NAME_NXP_FWD_FUNCTIONALITY_ENABLE);
+  } else {
+    mFwdFuntnEnable = 0x07;
+  }
+
+  if (NfcConfig::hasKey(NAME_NXP_DEFAULT_SE)) {
+    mDefaultEe = NfcConfig::getUnsigned(NAME_NXP_DEFAULT_SE);
+  } else {
+    mDefaultEe = 0x02;
+  }
+
+
+  if (NfcConfig::hasKey(NAME_NXP_ENABLE_ADD_AID)) {
+    mAddAid = NfcConfig::getUnsigned(NAME_NXP_ENABLE_ADD_AID);
+  } else {
+    mAddAid = 0x01;
+  }
+
+  if (nfcFL.nfcNxpEse && (nfcFL.chipType != pn547C2)) {
+    if (NfcConfig::hasKey(NAME_NXP_ESE_WIRED_PRT_MASK)) {
+      gEseVirtualWiredProtectMask =
+          NfcConfig::getUnsigned(NAME_NXP_ESE_WIRED_PRT_MASK);
+    } else {
+      gEseVirtualWiredProtectMask = 0x00;
+    }
 
-        if (GetNxpNumValue (NAME_DEFAULT_FELICA_CLT_PWR_STATE, (void*)&num, sizeof(num)))
-            mDefaultTechFPowerstate = num;
-        else
-            mDefaultTechFPowerstate = 0x3F;
-    }else {
-        mDefaultTechFSeID = SecureElement::getInstance().EE_HANDLE_0xF4;
-        mDefaultTechFPowerstate = 0x3F;
+    if (NfcConfig::hasKey(NAME_NXP_UICC_WIRED_PRT_MASK)) {
+      gUICCVirtualWiredProtectMask =
+          NfcConfig::getUnsigned(NAME_NXP_UICC_WIRED_PRT_MASK);
+    } else {
+      gUICCVirtualWiredProtectMask = 0x00;
     }
-    if (GetNxpNumValue (NAME_NXP_HCEF_CMD_RSP_TIMEOUT_VALUE, (void*)&num, sizeof(num)))
-    {
-        if(num > 0)
-        {
-            mDefaultHCEFRspTimeout = num;
-        }
+
+    if (NfcConfig::hasKey(NAME_NXP_WIRED_MODE_RF_FIELD_ENABLE)) {
+      gWiredModeRfFieldEnable =
+          NfcConfig::getUnsigned(NAME_NXP_WIRED_MODE_RF_FIELD_ENABLE);
+    } else {
+      gWiredModeRfFieldEnable = 0x00;
+    }
+  }
+  if (nfcFL.eseFL._ESE_FELICA_CLT) {
+    if (NfcConfig::hasKey(NAME_DEFAULT_NFCF_ROUTE)) {
+      num = NfcConfig::getUnsigned(NAME_DEFAULT_NFCF_ROUTE);
+      if (nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC &&
+          nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) {
+        if ((num == 0x02 || num == 0x03) && sCurrentSelectedUICCSlot) {
+          mDefaultTechFSeID = getUiccRoute(sCurrentSelectedUICCSlot);
+        } else {
+          mDefaultTechFSeID =
+              ((num == 0x01)
+                   ? ROUTE_LOC_ESE_ID
+                   : ((num == 0x02)
+                          ? SecureElement::getInstance().EE_HANDLE_0xF4
+                          : ROUTE_LOC_UICC2_ID));
+        }
+      } else {
+        mDefaultTechFSeID =
+            ((num == 0x01)
+                 ? ROUTE_LOC_ESE_ID
+                 : ((num == 0x02) ? SecureElement::getInstance().EE_HANDLE_0xF4
+                                  : ROUTE_LOC_UICC2_ID));
+      }
+    } else {
+      mDefaultTechFSeID = getUiccRoute(sCurrentSelectedUICCSlot);
     }
-#endif
-    if ((GetNxpNumValue(NAME_NXP_NFC_CHIP, &num, sizeof(num))))
-    {
-        mChipId = num;
+
+    if (NfcConfig::hasKey(NAME_DEFAULT_FELICA_CLT_PWR_STATE)) {
+      num = NfcConfig::getUnsigned(NAME_DEFAULT_FELICA_CLT_PWR_STATE);
+      mDefaultTechFPowerstate = num;
+    } else {
+      mDefaultTechFPowerstate = 0x3F;
     }
+  } else {
+    mDefaultTechFSeID = SecureElement::getInstance().EE_HANDLE_0xF4;
+    mDefaultTechFPowerstate = 0x3F;
+  }
 
-    tNFA_STATUS nfaStat;
-    {
-        SyncEventGuard guard (mEeRegisterEvent);
-        ALOGV("%s: try ee register", fn);
-        nfaStat = NFA_EeRegister (nfaEeCallback);
-        if (nfaStat != NFA_STATUS_OK)
-        {
-            ALOGE("%s: fail ee register; error=0x%X", fn, nfaStat);
-            return false;
-        }
-        mEeRegisterEvent.wait ();
+  if (NfcConfig::hasKey(NAME_NXP_HCEF_CMD_RSP_TIMEOUT_VALUE)) {
+    num = NfcConfig::getUnsigned(NAME_NXP_HCEF_CMD_RSP_TIMEOUT_VALUE);
+    if (num > 0) {
+      mDefaultHCEFRspTimeout = num;
     }
+  }
+#endif
+  if (NfcConfig::hasKey(NAME_NXP_NFC_CHIP)) {
+    num = NfcConfig::getUnsigned(NAME_NXP_NFC_CHIP);
+    mChipId = num;
+  }
+
+  tNFA_STATUS nfaStat;
+  {
+    SyncEventGuard guard(mEeRegisterEvent);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: try ee register", fn);
+    nfaStat = NFA_EeRegister(nfaEeCallback);
+    if (nfaStat != NFA_STATUS_OK) {
+      LOG(ERROR) << StringPrintf("%s: fail ee register; error=0x%X", fn,
+                                 nfaStat);
+      return false;
+    }
+    mEeRegisterEvent.wait();
+  }
 
-#if(NXP_EXTNS == TRUE)
-    if (mHostListnTechMask)
-    {
-        // Tell the host-routing to only listen on Nfc-A/Nfc-B
-        nfaStat = NFA_CeSetIsoDepListenTech(mHostListnTechMask & 0xB);
-        if (nfaStat != NFA_STATUS_OK)
-            ALOGE("Failed to configure CE IsoDep technologies");
+#if (NXP_EXTNS == TRUE)
+  if (mHostListnTechMask) {
+    // Tell the host-routing to only listen on Nfc-A/Nfc-B
+    nfaStat = NFA_CeSetIsoDepListenTech(mHostListnTechMask & 0xB);
+    if (nfaStat != NFA_STATUS_OK)
+      LOG(ERROR) << StringPrintf("Failed to configure CE IsoDep technologies");
 
-        // Tell the host-routing to only listen on Nfc-A/Nfc-B
-        nfaStat = NFA_CeRegisterAidOnDH (NULL, 0, stackCallback);
-        if (nfaStat != NFA_STATUS_OK)
-            ALOGE("Failed to register wildcard AID for DH");
-    }
-    mRxDataBuffer.clear ();
+    // Tell the host-routing to only listen on Nfc-A/Nfc-B
+    nfaStat = NFA_CeRegisterAidOnDH(NULL, 0, stackCallback);
+    if (nfaStat != NFA_STATUS_OK)
+      LOG(ERROR) << StringPrintf("Failed to register wildcard AID for DH");
+  }
+  mRxDataBuffer.clear();
 #else
 //    setDefaultRouting();
 #endif
 
-    if ((nfaStat = NFA_AllEeGetInfo (&ActualNumEe, mEeInfo)) != NFA_STATUS_OK)
-    {
-        ALOGE("%s: fail get info; error=0x%X", fn, nfaStat);
-        ActualNumEe = 0;
-    }
-    else
-    {
-        //gSeDiscoverycount = ActualNumEe;
-        SecureElement::getInstance().updateNfceeDiscoverInfo();
-        ALOGV("%s:gSeDiscoverycount=0x%lX;", __func__, gSeDiscoverycount);
-#if 0
-        if(mChipId == 0x02 || mChipId == 0x04)
-        {
-            for(int xx = 0; xx <  ActualNumEe; xx++)
-            {
-                ALOGE("xx=%d, ee_handle=0x0%x, status=0x0%x", xx, mEeInfo[xx].ee_handle,mEeInfo[xx].ee_status);
-                if ((mEeInfo[xx].ee_handle == SecureElement::EE_HANDLE_0xF3) &&
-                        (mEeInfo[xx].ee_status == 0x02))
-                {
-                    ee_removed_disc_ntf_handler(mEeInfo[xx].ee_handle, mEeInfo[xx].ee_status);
-                    break;
-                }
-            }
-        }
-#endif
-    }
-
-#if(NXP_EXTNS == TRUE)
-    if(nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
-        swp_rdr_req_ntf_info.mMutex.lock();
-        memset(&(swp_rdr_req_ntf_info.swp_rd_req_info),0x00,sizeof(rd_swp_req_t));
-        memset(&(swp_rdr_req_ntf_info.swp_rd_req_current_info),0x00,sizeof(rd_swp_req_t));
-        swp_rdr_req_ntf_info.swp_rd_req_current_info.src = NFA_HANDLE_INVALID;
-        swp_rdr_req_ntf_info.swp_rd_req_info.src = NFA_HANDLE_INVALID;
-        swp_rdr_req_ntf_info.swp_rd_state = STATE_SE_RDR_MODE_STOPPED;
-        swp_rdr_req_ntf_info.mMutex.unlock();
+  if ((nfaStat = NFA_AllEeGetInfo(&ActualNumEe, mEeInfo)) != NFA_STATUS_OK) {
+    LOG(ERROR) << StringPrintf("%s: fail get info; error=0x%X", fn, nfaStat);
+    ActualNumEe = 0;
+  } else {
+    // gSeDiscoverycount = ActualNumEe;
+    SecureElement::getInstance().updateNfceeDiscoverInfo();
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s:gSeDiscoverycount=0x%d;", __func__, gSeDiscoverycount);
+
+    tNFA_TECHNOLOGY_MASK seTechMask = 0;
+    for (uint8_t i = 0; i < ActualNumEe; i++) {
+      if (mEeInfo[i].ee_handle != SecureElement::EE_HANDLE_0xF3) continue;
+      if (mEeInfo[i].la_protocol != 0)
+        seTechMask |= NFA_TECHNOLOGY_MASK_A;
+      if (mEeInfo[i].lb_protocol != 0)
+        seTechMask |= NFA_TECHNOLOGY_MASK_B;
+      if (mEeInfo[i].lf_protocol != 0)
+        seTechMask |= NFA_TECHNOLOGY_MASK_F;
+      break;
+    }
+
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s:seTechMask=0x%x;", __func__, seTechMask);
+    if (seTechMask) {
+      SyncEventGuard guard(SecureElement::getInstance().mEseListenEvent);
+      nfaStat = NFA_CeConfigureEseListenTech(SecureElement::EE_HANDLE_0xF3,
+                                             seTechMask);
+      if (nfaStat == NFA_STATUS_OK) {
+        SecureElement::getInstance().mEseListenEvent.wait(500);
+      } else
+        LOG(ERROR) << StringPrintf("fail to start ESE listen");
+    }
+  }
+  printMemberData();
+
+  if (NFC_GetNCIVersion() == NCI_VERSION_2_0) {
+    SyncEventGuard guard(mRoutingEvent);
+    // Register System Code for routing
+    nfaStat = NFA_EeAddSystemCodeRouting(mDefaultSysCode, mDefaultSysCodeRoute,
+                                         mDefaultSysCodePowerstate);
+    if (nfaStat == NFA_STATUS_NOT_SUPPORTED) {
+      mIsScbrSupported = false;
+      LOG(ERROR) << StringPrintf("%s: SCBR not supported", fn);
+    } else if (nfaStat == NFA_STATUS_OK) {
+      mIsScbrSupported = true;
+      mRoutingEvent.wait();
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: Succeed to register system code", fn);
+    } else {
+      LOG(ERROR) << StringPrintf("%s: Fail to register system code", fn);
     }
-#endif
+  }
 
-    printMemberData();
-
-    ALOGV("%s: exit", fn);
-    return true;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
+  return true;
 }
-#if(NXP_EXTNS == TRUE)
-void RoutingManager::registerProtoRouteEntry(tNFA_HANDLE     ee_handle,
-                                         tNFA_PROTOCOL_MASK  protocols_switch_on,
-                                         tNFA_PROTOCOL_MASK  protocols_switch_off,
-                                         tNFA_PROTOCOL_MASK  protocols_battery_off,
-                                         tNFA_PROTOCOL_MASK  protocols_screen_lock,
-                                         tNFA_PROTOCOL_MASK  protocols_screen_off,
-                                         tNFA_PROTOCOL_MASK  protocols_screen_off_lock
-                                         )
-{
-    static const char fn [] = "RoutingManager::registerProtoRouteEntry";
-    bool new_entry = true;
-    uint8_t i = 0;
-    tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
-
-    if(gRouteInfo.num_entries == 0)
-    {
-        ALOGV("%s: enter, first entry :%x", fn, ee_handle);
-        gRouteInfo.protoInfo[0].ee_handle = ee_handle;
-        gRouteInfo.protoInfo[0].protocols_switch_on = protocols_switch_on;
-        gRouteInfo.protoInfo[0].protocols_switch_off = protocols_switch_off;
-        gRouteInfo.protoInfo[0].protocols_battery_off = protocols_battery_off;
-        gRouteInfo.protoInfo[0].protocols_screen_lock = protocols_screen_lock;
-        gRouteInfo.protoInfo[0].protocols_screen_off = protocols_screen_off;
-        gRouteInfo.protoInfo[0].protocols_screen_off_lock = protocols_screen_off_lock;
-        gRouteInfo.num_entries = 1;
-    }
-    else
-    {
-        for (i = 0;i < gRouteInfo.num_entries; i++)
-        {
-            if(gRouteInfo.protoInfo[i].ee_handle == ee_handle)
-            {
-                ALOGV("%s: enter, proto handle match found :%x", fn, ee_handle);
-                gRouteInfo.protoInfo[i].protocols_switch_on |= protocols_switch_on;
-                gRouteInfo.protoInfo[i].protocols_switch_off |= protocols_switch_off;
-                gRouteInfo.protoInfo[i].protocols_battery_off |= protocols_battery_off;
-                gRouteInfo.protoInfo[i].protocols_screen_lock |= protocols_screen_lock;
-                gRouteInfo.protoInfo[i].protocols_screen_off |= protocols_screen_off;
-                gRouteInfo.protoInfo[i].protocols_screen_off_lock |= protocols_screen_off_lock;
-                new_entry = false;
-                break;
-            }
-        }
-        if(new_entry)
-        {
-            ALOGV("%s: enter,new proto handle entry :%x", fn, ee_handle);
-            i = gRouteInfo.num_entries;
-            gRouteInfo.protoInfo[i].ee_handle = ee_handle;
-            gRouteInfo.protoInfo[i].protocols_switch_on = protocols_switch_on;
-            gRouteInfo.protoInfo[i].protocols_switch_off = protocols_switch_off;
-            gRouteInfo.protoInfo[i].protocols_battery_off = protocols_battery_off;
-            gRouteInfo.protoInfo[i].protocols_screen_lock = protocols_screen_lock;
-            gRouteInfo.protoInfo[i].protocols_screen_off = protocols_screen_off;
-            gRouteInfo.protoInfo[i].protocols_screen_off_lock = protocols_screen_off_lock;
-            gRouteInfo.num_entries++;
-        }
-    }
-    for (i = 0;i < gRouteInfo.num_entries; i++)
-    {
-        nfaStat = NFA_EeSetDefaultProtoRouting (gRouteInfo.protoInfo[i].ee_handle,
-                                                gRouteInfo.protoInfo[i].protocols_switch_on,
-                                                gRouteInfo.protoInfo[i].protocols_switch_off,
-                                                gRouteInfo.protoInfo[i].protocols_battery_off,
-                                                gRouteInfo.protoInfo[i].protocols_screen_lock,
-                                                gRouteInfo.protoInfo[i].protocols_screen_off,
-                                                gRouteInfo.protoInfo[i].protocols_screen_off_lock);
-        if(nfaStat == NFA_STATUS_OK){
-            mRoutingEvent.wait ();
-            ALOGV("tech routing SUCCESS");
-        }
-        else{
-            ALOGE("Fail to set default tech routing");
-        }
+#if (NXP_EXTNS == TRUE)
+void RoutingManager::registerProtoRouteEntry(
+    tNFA_HANDLE ee_handle, tNFA_PROTOCOL_MASK protocols_switch_on,
+    tNFA_PROTOCOL_MASK protocols_switch_off,
+    tNFA_PROTOCOL_MASK protocols_battery_off,
+    tNFA_PROTOCOL_MASK protocols_screen_lock,
+    tNFA_PROTOCOL_MASK protocols_screen_off,
+    tNFA_PROTOCOL_MASK protocols_screen_off_lock) {
+  static const char fn[] = "RoutingManager::registerProtoRouteEntry";
+  bool new_entry = true;
+  uint8_t i = 0;
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+
+  if (gRouteInfo.num_entries == 0) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: enter, first entry :%x", fn, ee_handle);
+    gRouteInfo.protoInfo[0].ee_handle = ee_handle;
+    gRouteInfo.protoInfo[0].protocols_switch_on = protocols_switch_on;
+    gRouteInfo.protoInfo[0].protocols_switch_off = protocols_switch_off;
+    gRouteInfo.protoInfo[0].protocols_battery_off = protocols_battery_off;
+    gRouteInfo.protoInfo[0].protocols_screen_lock = protocols_screen_lock;
+    gRouteInfo.protoInfo[0].protocols_screen_off = protocols_screen_off;
+    gRouteInfo.protoInfo[0].protocols_screen_off_lock =
+        protocols_screen_off_lock;
+    gRouteInfo.num_entries = 1;
+  } else {
+    for (i = 0; i < gRouteInfo.num_entries; i++) {
+      if (gRouteInfo.protoInfo[i].ee_handle == ee_handle) {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: enter, proto handle match found :%x", fn, ee_handle);
+        gRouteInfo.protoInfo[i].protocols_switch_on |= protocols_switch_on;
+        gRouteInfo.protoInfo[i].protocols_switch_off |= protocols_switch_off;
+        gRouteInfo.protoInfo[i].protocols_battery_off |= protocols_battery_off;
+        gRouteInfo.protoInfo[i].protocols_screen_lock |= protocols_screen_lock;
+        gRouteInfo.protoInfo[i].protocols_screen_off |= protocols_screen_off;
+        gRouteInfo.protoInfo[i].protocols_screen_off_lock |=
+            protocols_screen_off_lock;
+        new_entry = false;
+        break;
+      }
+    }
+    if (new_entry) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: enter,new proto handle entry :%x", fn, ee_handle);
+      i = gRouteInfo.num_entries;
+      gRouteInfo.protoInfo[i].ee_handle = ee_handle;
+      gRouteInfo.protoInfo[i].protocols_switch_on = protocols_switch_on;
+      gRouteInfo.protoInfo[i].protocols_switch_off = protocols_switch_off;
+      gRouteInfo.protoInfo[i].protocols_battery_off = protocols_battery_off;
+      gRouteInfo.protoInfo[i].protocols_screen_lock = protocols_screen_lock;
+      gRouteInfo.protoInfo[i].protocols_screen_off = protocols_screen_off;
+      gRouteInfo.protoInfo[i].protocols_screen_off_lock =
+          protocols_screen_off_lock;
+      gRouteInfo.num_entries++;
+    }
+  }
+  for (i = 0; i < gRouteInfo.num_entries; i++) {
+    nfaStat = NFA_EeSetDefaultProtoRouting(
+        gRouteInfo.protoInfo[i].ee_handle,
+        gRouteInfo.protoInfo[i].protocols_switch_on,
+        gRouteInfo.protoInfo[i].protocols_switch_off,
+        gRouteInfo.protoInfo[i].protocols_battery_off,
+        gRouteInfo.protoInfo[i].protocols_screen_lock,
+        gRouteInfo.protoInfo[i].protocols_screen_off,
+        gRouteInfo.protoInfo[i].protocols_screen_off_lock);
+    if (nfaStat == NFA_STATUS_OK) {
+      mRoutingEvent.wait();
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("tech routing SUCCESS");
+    } else {
+      LOG(ERROR) << StringPrintf("Fail to set default tech routing");
     }
+  }
 }
 #endif
 
-RoutingManager& RoutingManager::getInstance ()
-{
-    static RoutingManager manager;
-    return manager;
-}
-
-void RoutingManager::cleanRouting()
-{
-    tNFA_STATUS nfaStat;
-    //tNFA_HANDLE seHandle = NFA_HANDLE_INVALID;        /*commented to eliminate unused variable warning*/
-    tNFA_HANDLE ee_handleList[nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED];
-    uint8_t i, count;
-   // static const char fn [] = "SecureElement::cleanRouting";   /*commented to eliminate unused variable warning*/
-    SyncEventGuard guard (mRoutingEvent);
-    SecureElement::getInstance().getEeHandleList(ee_handleList, &count);
-    if (count > nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED) {
-        count = nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED;
-        ALOGV("Count is more than SecureElement::MAX_NUM_EE,Forcing to SecureElement::MAX_NUM_EE");
-    }
-    for ( i = 0; i < count; i++)
-    {
-#if(NXP_EXTNS == TRUE)
-        nfaStat =  NFA_EeSetDefaultTechRouting(ee_handleList[i],0,0,0,0,0,0);
+RoutingManager& RoutingManager::getInstance() {
+  static RoutingManager manager;
+  return manager;
+}
+
+void RoutingManager::cleanRouting() {
+  tNFA_STATUS nfaStat;
+  // tNFA_HANDLE seHandle = NFA_HANDLE_INVALID;        /*commented to eliminate
+  // unused variable warning*/
+  tNFA_HANDLE ee_handleList[nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED];
+  uint8_t i, count;
+  // static const char fn [] = "SecureElement::cleanRouting";   /*commented to
+  // eliminate unused variable warning*/
+  SyncEventGuard guard(mRoutingEvent);
+  SecureElement::getInstance().getEeHandleList(ee_handleList, &count);
+  if (count > nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED) {
+    count = nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "Count is more than SecureElement::MAX_NUM_EE,Forcing to "
+        "SecureElement::MAX_NUM_EE");
+  }
+  for (i = 0; i < count; i++) {
+#if (NXP_EXTNS == TRUE)
+    nfaStat = NFA_EeSetDefaultTechRouting(ee_handleList[i], 0, 0, 0, 0, 0, 0);
 #else
-        nfaStat =  NFA_EeSetDefaultTechRouting(ee_handleList[i],0,0,0);
+    nfaStat = NFA_EeSetDefaultTechRouting(ee_handleList[i], 0, 0, 0);
 #endif
-        if(nfaStat == NFA_STATUS_OK)
-        {
-            mRoutingEvent.wait ();
-        }
-#if(NXP_EXTNS == TRUE)
-        nfaStat =  NFA_EeSetDefaultProtoRouting(ee_handleList[i],0,0,0,0,0,0);
+    if (nfaStat == NFA_STATUS_OK) {
+      mRoutingEvent.wait();
+    }
+#if (NXP_EXTNS == TRUE)
+    nfaStat = NFA_EeSetDefaultProtoRouting(ee_handleList[i], 0, 0, 0, 0, 0, 0);
 #else
-        nfaStat =  NFA_EeSetDefaultProtoRouting(ee_handleList[i],0,0,0);
+    nfaStat = NFA_EeSetDefaultProtoRouting(ee_handleList[i], 0, 0, 0);
 #endif
-        if(nfaStat == NFA_STATUS_OK)
-        {
-            mRoutingEvent.wait ();
-        }
+    if (nfaStat == NFA_STATUS_OK) {
+      mRoutingEvent.wait();
     }
-    //clean HOST
-#if(NXP_EXTNS == TRUE)
-    nfaStat =  NFA_EeSetDefaultTechRouting(NFA_EE_HANDLE_DH,0,0,0,0,0,0);
+  }
+// clean HOST
+#if (NXP_EXTNS == TRUE)
+  nfaStat = NFA_EeSetDefaultTechRouting(NFA_EE_HANDLE_DH, 0, 0, 0, 0, 0, 0);
 #else
-    nfaStat =  NFA_EeSetDefaultTechRouting(NFA_EE_HANDLE_DH,0,0,0);
+  nfaStat = NFA_EeSetDefaultTechRouting(NFA_EE_HANDLE_DH, 0, 0, 0);
 #endif
-    if(nfaStat == NFA_STATUS_OK)
-    {
-        mRoutingEvent.wait ();
-    }
-#if(NXP_EXTNS == TRUE)
-    nfaStat =  NFA_EeSetDefaultProtoRouting(NFA_EE_HANDLE_DH,0,0,0,0,0,0);
+  if (nfaStat == NFA_STATUS_OK) {
+    mRoutingEvent.wait();
+  }
+#if (NXP_EXTNS == TRUE)
+  nfaStat = NFA_EeSetDefaultProtoRouting(NFA_EE_HANDLE_DH, 0, 0, 0, 0, 0, 0);
 #else
-    nfaStat =  NFA_EeSetDefaultProtoRouting(NFA_EE_HANDLE_DH,0,0,0);
+  nfaStat = NFA_EeSetDefaultProtoRouting(NFA_EE_HANDLE_DH, 0, 0, 0);
 #endif
-    if(nfaStat == NFA_STATUS_OK)
-    {
-        mRoutingEvent.wait ();
-    }
+  if (nfaStat == NFA_STATUS_OK) {
+    mRoutingEvent.wait();
+  }
 #if 0
     /*commented to avoid send LMRT command twice*/
     nfaStat = NFA_EeUpdateNow();
     if (nfaStat != NFA_STATUS_OK)
-        ALOGE("Failed to commit routing configuration");
+        LOG(ERROR) << StringPrintf("Failed to commit routing configuration");
 #endif
 }
 
-#if(NXP_EXTNS == TRUE)
-void RoutingManager::setRouting(bool isHCEEnabled)
-{
-    tNFA_STATUS nfaStat;
-    tNFA_HANDLE defaultHandle = NFA_HANDLE_INVALID;
-    tNFA_HANDLE ee_handleList[nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED];
-    uint8_t i = 0, count;
-    static const char fn [] = "SecureElement::setRouting";
-    unsigned long num = 0;
-
-    if ((GetNumValue(NAME_UICC_LISTEN_TECH_MASK, &num, sizeof(num))))
-    {
-        ALOGE("%s:UICC_LISTEN_MASK=0x0%lu;", __func__, num);
-    }
-    SecureElement &se = SecureElement::getInstance();
-    if (isHCEEnabled)
-    {
-        defaultHandle = NFA_EE_HANDLE_DH;
-    }
-    else
-    {
-        SecureElement::getInstance().getEeHandleList(ee_handleList, &count);
-        for ( ; i < count; i++)
-        {
-            if (defaultHandle == NFA_HANDLE_INVALID)
-            {
-                defaultHandle = ee_handleList[i];
-                break;
-            }
-        }
+#if (NXP_EXTNS == TRUE)
+void RoutingManager::setRouting(bool isHCEEnabled) {
+  tNFA_STATUS nfaStat;
+  tNFA_HANDLE defaultHandle = NFA_HANDLE_INVALID;
+  tNFA_HANDLE ee_handleList[nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED];
+  uint8_t i = 0, count;
+  static const char fn[] = "SecureElement::setRouting";
+  unsigned long num = 0;
+
+  if (NfcConfig::hasKey(NAME_UICC_LISTEN_TECH_MASK)) {
+    num = NfcConfig::getUnsigned(NAME_UICC_LISTEN_TECH_MASK);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s:UICC_LISTEN_MASK=0x0%lu;", __func__, num);
+  }
+
+  SecureElement& se = SecureElement::getInstance();
+  if (isHCEEnabled) {
+    defaultHandle = NFA_EE_HANDLE_DH;
+  } else {
+    SecureElement::getInstance().getEeHandleList(ee_handleList, &count);
+    for (; i < count; i++) {
+      if (defaultHandle == NFA_HANDLE_INVALID) {
+        defaultHandle = ee_handleList[i];
+        break;
+      }
     }
-    ALOGV("%s: defaultHandle %u = 0x%X", fn, i, defaultHandle);
+  }
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: defaultHandle %u = 0x%X", fn, i, defaultHandle);
 
-    if (defaultHandle != NFA_HANDLE_INVALID)
+  if (defaultHandle != NFA_HANDLE_INVALID) {
     {
-        {
-            SyncEventGuard guard (mRoutingEvent);
-
-            tNFA_STATUS status =  NFA_EeSetDefaultTechRouting(se.EE_HANDLE_0xF4,0,0,0,0,0,0); //UICC clear
-
-            if(status == NFA_STATUS_OK)
-            {
-                mRoutingEvent.wait ();
-            }
-        }
-
-        {
-            SyncEventGuard guard (mRoutingEvent);
+      SyncEventGuard guard(mRoutingEvent);
 
-            tNFA_STATUS status =  NFA_EeSetDefaultProtoRouting(se.EE_HANDLE_0xF4,0,0,0,0,0,0); //UICC clear
+      tNFA_STATUS status = NFA_EeSetDefaultTechRouting(
+          se.EE_HANDLE_0xF4, 0, 0, 0, 0, 0, 0);  // UICC clear
 
-            if(status == NFA_STATUS_OK)
-            {
-                mRoutingEvent.wait ();
-            }
-        }
-
-        {
-            SyncEventGuard guard (mRoutingEvent);
+      if (status == NFA_STATUS_OK) {
+        mRoutingEvent.wait();
+      }
+    }
 
-            tNFA_STATUS status =  NFA_EeSetDefaultTechRouting(SecureElement::EE_HANDLE_0xF3,0,0,0,0,0,0); //SMX clear
+    {
+      SyncEventGuard guard(mRoutingEvent);
 
-            if(status == NFA_STATUS_OK)
-            {
-                mRoutingEvent.wait ();
-            }
-        }
+      tNFA_STATUS status = NFA_EeSetDefaultProtoRouting(
+          se.EE_HANDLE_0xF4, 0, 0, 0, 0, 0, 0);  // UICC clear
 
-        {
-            SyncEventGuard guard (mRoutingEvent);
+      if (status == NFA_STATUS_OK) {
+        mRoutingEvent.wait();
+      }
+    }
 
-            tNFA_STATUS status =  NFA_EeSetDefaultProtoRouting(SecureElement::EE_HANDLE_0xF3,0,0,0,0,0,0); //SMX clear
+    {
+      SyncEventGuard guard(mRoutingEvent);
 
-            if(status == NFA_STATUS_OK)
-            {
-                mRoutingEvent.wait ();
-            }
-        }
+      tNFA_STATUS status = NFA_EeSetDefaultTechRouting(
+          SecureElement::EE_HANDLE_0xF3, 0, 0, 0, 0, 0, 0);  // SMX clear
 
-        {
-            SyncEventGuard guard (mRoutingEvent);
+      if (status == NFA_STATUS_OK) {
+        mRoutingEvent.wait();
+      }
+    }
 
-            tNFA_STATUS status =  NFA_EeSetDefaultTechRouting(0x400,0,0,0,0,0,0); //HOST clear
+    {
+      SyncEventGuard guard(mRoutingEvent);
 
-            if(status == NFA_STATUS_OK)
-            {
-                mRoutingEvent.wait ();
-            }
-        }
+      tNFA_STATUS status = NFA_EeSetDefaultProtoRouting(
+          SecureElement::EE_HANDLE_0xF3, 0, 0, 0, 0, 0, 0);  // SMX clear
 
-        {
-            SyncEventGuard guard (mRoutingEvent);
+      if (status == NFA_STATUS_OK) {
+        mRoutingEvent.wait();
+      }
+    }
 
-            tNFA_STATUS status =  NFA_EeSetDefaultProtoRouting(0x400,0,0,0,0,0,0); //HOST clear
+    {
+      SyncEventGuard guard(mRoutingEvent);
 
-            if(status == NFA_STATUS_OK)
-            {
-                mRoutingEvent.wait ();
-            }
-        }
-        if(defaultHandle == NFA_EE_HANDLE_DH)
-        {
-            SyncEventGuard guard (mRoutingEvent);
-            // Default routing for NFC-A technology
-            if(mCeRouteStrictDisable == 0x01)
-            {
-                nfaStat = NFA_EeSetDefaultTechRouting (defaultHandle, 0x01, 0, 0, 0x01, 0,0);
-            }else
-            {
-                nfaStat = NFA_EeSetDefaultTechRouting (defaultHandle, 0x01, 0, 0, 0, 0,0);
-            }
+      tNFA_STATUS status =
+          NFA_EeSetDefaultTechRouting(0x400, 0, 0, 0, 0, 0, 0);  // HOST clear
 
-            if (nfaStat == NFA_STATUS_OK)
-                mRoutingEvent.wait ();
-            else
-                ALOGE("Fail to set default tech routing");
-        }
-        else
-        {
-            SyncEventGuard guard (mRoutingEvent);
-            // Default routing for NFC-A technology
-            if(mCeRouteStrictDisable == 0x01)
-            {
-                nfaStat = NFA_EeSetDefaultTechRouting (defaultHandle, num, num, num, num, num,num);
-            }else{
-                nfaStat = NFA_EeSetDefaultTechRouting (defaultHandle, num, num, num, 0, 0,0);
-            }
-            if (nfaStat == NFA_STATUS_OK)
-                mRoutingEvent.wait ();
-            else
-                ALOGE("Fail to set default tech routing");
-        }
+      if (status == NFA_STATUS_OK) {
+        mRoutingEvent.wait();
+      }
+    }
 
-        if(defaultHandle == NFA_EE_HANDLE_DH)
-        {
-            SyncEventGuard guard (mRoutingEvent);
-            // Default routing for IsoDep protocol
-            if(mCeRouteStrictDisable == 0x01)
-            {
-                nfaStat = NFA_EeSetDefaultProtoRouting(defaultHandle, NFA_PROTOCOL_MASK_ISO_DEP, 0, 0, NFA_PROTOCOL_MASK_ISO_DEP, 0,0);
-            }
-            else
-            {
-                nfaStat = NFA_EeSetDefaultProtoRouting(defaultHandle, NFA_PROTOCOL_MASK_ISO_DEP, 0, 0, 0 ,0,0);
-            }
-            if (nfaStat == NFA_STATUS_OK)
-                mRoutingEvent.wait ();
-            else
-                ALOGE("Fail to set default proto routing");
-        }
-        else
-        {
-            SyncEventGuard guard (mRoutingEvent);
-            // Default routing for IsoDep protocol
-            if(mCeRouteStrictDisable == 0x01)
-            {
-                nfaStat = NFA_EeSetDefaultProtoRouting(defaultHandle,
-                                                       NFA_PROTOCOL_MASK_ISO_DEP,
-                                                       NFA_PROTOCOL_MASK_ISO_DEP,
-                                                       NFA_PROTOCOL_MASK_ISO_DEP,
-                                                       NFA_PROTOCOL_MASK_ISO_DEP,
-                                                       NFA_PROTOCOL_MASK_ISO_DEP,
-                                                       NFA_PROTOCOL_MASK_ISO_DEP);
-            }
-            else
-            {
-                nfaStat = NFA_EeSetDefaultProtoRouting(defaultHandle,
-                                                       NFA_PROTOCOL_MASK_ISO_DEP,
-                                                       NFA_PROTOCOL_MASK_ISO_DEP,
-                                                       NFA_PROTOCOL_MASK_ISO_DEP,
-                                                       0,
-                                                       0,
-                                                       0);
-            }
-            if (nfaStat == NFA_STATUS_OK)
-                mRoutingEvent.wait ();
-            else
-                ALOGE("Fail to set default proto routing");
-        }
+    {
+      SyncEventGuard guard(mRoutingEvent);
 
-        if(defaultHandle != NFA_EE_HANDLE_DH)
-        {
-            {
-                SyncEventGuard guard (SecureElement::getInstance().mUiccListenEvent);
-                nfaStat = NFA_CeConfigureUiccListenTech (defaultHandle, 0x00);
-                if (nfaStat == NFA_STATUS_OK)
-                {
-                    SecureElement::getInstance().mUiccListenEvent.wait ();
-                }
-                else
-                    ALOGE("fail to start UICC listen");
-            }
+      tNFA_STATUS status =
+          NFA_EeSetDefaultProtoRouting(0x400, 0, 0, 0, 0, 0, 0);  // HOST clear
 
-            {
-                SyncEventGuard guard (SecureElement::getInstance().mUiccListenEvent);
-                nfaStat = NFA_CeConfigureUiccListenTech (defaultHandle, (num & 0x07));
-                if(nfaStat == NFA_STATUS_OK)
-                {
-                    SecureElement::getInstance().mUiccListenEvent.wait ();
-                }
-                else
-                    ALOGE("fail to start UICC listen");
-            }
-        }
+      if (status == NFA_STATUS_OK) {
+        mRoutingEvent.wait();
+      }
     }
+    if (defaultHandle == NFA_EE_HANDLE_DH) {
+      SyncEventGuard guard(mRoutingEvent);
+      // Default routing for NFC-A technology
+      if (mCeRouteStrictDisable == 0x01) {
+        nfaStat =
+            NFA_EeSetDefaultTechRouting(defaultHandle, 0x01, 0, 0, 0x01, 0, 0);
+      } else {
+        nfaStat =
+            NFA_EeSetDefaultTechRouting(defaultHandle, 0x01, 0, 0, 0, 0, 0);
+      }
 
-    // Commit the routing configuration
-    nfaStat = NFA_EeUpdateNow();
-    if (nfaStat != NFA_STATUS_OK)
-        ALOGE("Failed to commit routing configuration");
-}
-/*This function takes the default AID route, protocol(ISO-DEP) route and Tech(A&B) route as arguments in following format
-* -----------------------------------------------------------------------------------------------------------
-* | RFU(TechA/B) | RouteLocBit1 | RouteLocBit0 | ScreenOff | ScreenLock | BatteryOff | SwitchOff | SwitchOn |
-* -----------------------------------------------------------------------------------------------------------
-* Route location is set as below
-* ----------------------------------------------
-* | RouteLocBit1 | RouteLocBit0 | RouteLocation|
-* ----------------------------------------------
-* |       0      |      0       |    Host      |
-* ----------------------------------------------
-* |       0      |      1       |    eSE       |
-* ----------------------------------------------
-* |       1      |      0       |    Uicc1     |
-* ----------------------------------------------
-* |       1      |      1       |    Uicc2     | => Valid if DYNAMIC_DUAL_UICC is enabled
-* ----------------------------------------------
-* Based on these parameters, this function creates the protocol route entries/ technology route entries
-* which are required to be pushed to listen mode routing table using NFA_EeSetDefaultProtoRouting/TechRouting
-*/
-bool RoutingManager::setDefaultRoute(const int defaultRoute, const int protoRoute, const int techRoute)
-{
-    static const char fn []   = "RoutingManager::setDefaultRoute";
-    tNFA_STATUS       nfaStat = NFA_STATUS_FAILED;
+      if (nfaStat == NFA_STATUS_OK)
+        mRoutingEvent.wait();
+      else
+        LOG(ERROR) << StringPrintf("Fail to set default tech routing");
+    } else {
+      SyncEventGuard guard(mRoutingEvent);
+      // Default routing for NFC-A technology
+      if (mCeRouteStrictDisable == 0x01) {
+        nfaStat = NFA_EeSetDefaultTechRouting(defaultHandle, num, num, num, num,
+                                              num, num);
+      } else {
+        nfaStat =
+            NFA_EeSetDefaultTechRouting(defaultHandle, num, num, num, 0, 0, 0);
+      }
+      if (nfaStat == NFA_STATUS_OK)
+        mRoutingEvent.wait();
+      else
+        LOG(ERROR) << StringPrintf("Fail to set default tech routing");
+    }
+
+    if (defaultHandle == NFA_EE_HANDLE_DH) {
+      SyncEventGuard guard(mRoutingEvent);
+      // Default routing for IsoDep protocol
+      if (mCeRouteStrictDisable == 0x01) {
+        nfaStat = NFA_EeSetDefaultProtoRouting(defaultHandle,
+                                               NFA_PROTOCOL_MASK_ISO_DEP, 0, 0,
+                                               NFA_PROTOCOL_MASK_ISO_DEP, 0, 0);
+      } else {
+        nfaStat = NFA_EeSetDefaultProtoRouting(
+            defaultHandle, NFA_PROTOCOL_MASK_ISO_DEP, 0, 0, 0, 0, 0);
+      }
+      if (nfaStat == NFA_STATUS_OK)
+        mRoutingEvent.wait();
+      else
+        LOG(ERROR) << StringPrintf("Fail to set default proto routing");
+    } else {
+      SyncEventGuard guard(mRoutingEvent);
+      // Default routing for IsoDep protocol
+      if (mCeRouteStrictDisable == 0x01) {
+        nfaStat = NFA_EeSetDefaultProtoRouting(
+            defaultHandle, NFA_PROTOCOL_MASK_ISO_DEP, NFA_PROTOCOL_MASK_ISO_DEP,
+            NFA_PROTOCOL_MASK_ISO_DEP, NFA_PROTOCOL_MASK_ISO_DEP,
+            NFA_PROTOCOL_MASK_ISO_DEP, NFA_PROTOCOL_MASK_ISO_DEP);
+      } else {
+        nfaStat = NFA_EeSetDefaultProtoRouting(
+            defaultHandle, NFA_PROTOCOL_MASK_ISO_DEP, NFA_PROTOCOL_MASK_ISO_DEP,
+            NFA_PROTOCOL_MASK_ISO_DEP, 0, 0, 0);
+      }
+      if (nfaStat == NFA_STATUS_OK)
+        mRoutingEvent.wait();
+      else
+        LOG(ERROR) << StringPrintf("Fail to set default proto routing");
+    }
+
+    if (defaultHandle != NFA_EE_HANDLE_DH) {
+      {
+        SyncEventGuard guard(SecureElement::getInstance().mUiccListenEvent);
+        nfaStat = NFA_CeConfigureUiccListenTech(defaultHandle, 0x00);
+        if (nfaStat == NFA_STATUS_OK) {
+          SecureElement::getInstance().mUiccListenEvent.wait();
+        } else
+          LOG(ERROR) << StringPrintf("fail to start UICC listen");
+      }
+
+      {
+        SyncEventGuard guard(SecureElement::getInstance().mUiccListenEvent);
+        nfaStat = NFA_CeConfigureUiccListenTech(defaultHandle, (num & 0x07));
+        if (nfaStat == NFA_STATUS_OK) {
+          SecureElement::getInstance().mUiccListenEvent.wait();
+        } else
+          LOG(ERROR) << StringPrintf("fail to start UICC listen");
+      }
+    }
+  }
+
+  // Commit the routing configuration
+  nfaStat = NFA_EeUpdateNow();
+  if (nfaStat != NFA_STATUS_OK)
+    LOG(ERROR) << StringPrintf("Failed to commit routing configuration");
+}
+/*This function takes the default AID route, protocol(ISO-DEP) route and
+ * Tech(A&B) route as arguments in following format
+ * -----------------------------------------------------------------------------------------------------------
+ * | RFU(TechA/B) | RouteLocBit1 | RouteLocBit0 | ScreenOff | ScreenLock |
+ * BatteryOff | SwitchOff | SwitchOn |
+ * -----------------------------------------------------------------------------------------------------------
+ * Route location is set as below
+ * ----------------------------------------------
+ * | RouteLocBit1 | RouteLocBit0 | RouteLocation|
+ * ----------------------------------------------
+ * |       0      |      0       |    Host      |
+ * ----------------------------------------------
+ * |       0      |      1       |    eSE       |
+ * ----------------------------------------------
+ * |       1      |      0       |    Uicc1     |
+ * ----------------------------------------------
+ * |       1      |      1       |    Uicc2     | => Valid if DYNAMIC_DUAL_UICC
+ * is enabled
+ * ----------------------------------------------
+ * Based on these parameters, this function creates the protocol route entries/
+ * technology route entries
+ * which are required to be pushed to listen mode routing table using
+ * NFA_EeSetDefaultProtoRouting/TechRouting
+ */
+bool RoutingManager::setDefaultRoute(const int defaultRoute,
+                                     const int protoRoute,
+                                     const int techRoute) {
+  static const char fn[] = "RoutingManager::setDefaultRoute";
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
 
-    ALOGV("%s: enter; defaultRoute:0x%2X protoRoute:0x%2X TechRoute:0x%2X HostListenMask:0x%X", fn, defaultRoute, protoRoute, techRoute, mHostListnTechMask);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: enter; defaultRoute:0x%2X protoRoute:0x%2X TechRoute:0x%2X "
+      "HostListenMask:0x%X",
+      fn, defaultRoute, protoRoute, techRoute, mHostListnTechMask);
 
-    extractRouteLocationAndPowerStates(defaultRoute,protoRoute,techRoute);
+  extractRouteLocationAndPowerStates(defaultRoute, protoRoute, techRoute);
 
-#if(NXP_EXTNS == TRUE)
-    if(NFA_GetNCIVersion() == NCI_VERSION_2_0) {
-        setEmptyAidEntry();
-    }
+#if (NXP_EXTNS == TRUE)
+  if (NFA_GetNCIVersion() == NCI_VERSION_2_0) {
+    setEmptyAidEntry();
+  }
 #endif
 
-    if (mHostListnTechMask)
-    {
-       nfaStat = NFA_CeSetIsoDepListenTech(mHostListnTechMask & 0xB);
-       if (nfaStat != NFA_STATUS_OK)
-           ALOGE("Failed to configure CE IsoDep technologies");
-       nfaStat = NFA_CeRegisterAidOnDH (NULL, 0, stackCallback);
-       if (nfaStat != NFA_STATUS_OK)
-           ALOGE("Failed to register wildcard AID for DH");
-    }
+  if (mHostListnTechMask) {
+    nfaStat = NFA_CeSetIsoDepListenTech(mHostListnTechMask & 0xB);
+    if (nfaStat != NFA_STATUS_OK)
+      LOG(ERROR) << StringPrintf("Failed to configure CE IsoDep technologies");
+    nfaStat = NFA_CeRegisterAidOnDH(NULL, 0, stackCallback);
+    if (nfaStat != NFA_STATUS_OK)
+      LOG(ERROR) << StringPrintf("Failed to register wildcard AID for DH");
+  }
 
-    checkProtoSeID();
+  checkProtoSeID();
 
-    initialiseTableEntries ();
+  initialiseTableEntries();
 
-    compileProtoEntries ();
+  compileProtoEntries();
 
-    consolidateProtoEntries ();
+  consolidateProtoEntries();
 
-    setProtoRouting ();
+  setProtoRouting();
 
-    compileTechEntries ();
+  compileTechEntries();
 
-    consolidateTechEntries ();
+  consolidateTechEntries();
 
-    setTechRouting ();
+  setTechRouting();
 
-    configureOffHostNfceeTechMask();
+  configureOffHostNfceeTechMask();
 
-    ALOGV("%s: exit", fn);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
 
-    return true;
+  return true;
 }
 
-void RoutingManager::setCeRouteStrictDisable(uint32_t state)
-{
-    ALOGV("%s: mCeRouteScreenLock = 0x%lX", __func__, state);
-    mCeRouteStrictDisable = state;
+void RoutingManager::setCeRouteStrictDisable(uint32_t state) {
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: mCeRouteScreenLock = 0x%u", __func__, state);
+  mCeRouteStrictDisable = state;
 }
 
 /******************************************************************************
  ** Function:    nfaEEConnect
  **
  ** Description: This function is invoked in case of eSE session reset.
- **              in this case we already discovered eSE earlierhence eSE the eSE count is
- **              decremented from gSeDiscoveryCount so that only pending NFCEE(UICC1 & UICC2)
+ **              in this case we already discovered eSE earlierhence eSE the eSE
+ *count is
+ **              decremented from gSeDiscoveryCount so that only pending
+ *NFCEE(UICC1 & UICC2)
  **              would be rediscovered.
  **
  ** Returns:     None
  ********************************************************************************/
-void RoutingManager::nfaEEConnect()
-{
-    tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
-    if(NFA_GetNCIVersion() != NCI_VERSION_2_0)
-    {
-      nfaStat = NFA_EeConnect(EE_HCI_DEFAULT_HANDLE, NFC_NFCEE_INTERFACE_HCI_ACCESS, nfaEeCallback);
-    }
-    else
-    {
-      nfaStat = NFA_EeDiscover(nfaEeCallback);
-    }
-    if(nfaStat == NFA_STATUS_OK)
-    {
-        SyncEventGuard g(gNfceeDiscCbEvent);
-        ALOGV("%s, Sem wait for gNfceeDiscCbEvent %d", __FUNCTION__, gdisc_timeout);
-        gNfceeDiscCbEvent.wait(gdisc_timeout);
-    }
-
+void RoutingManager::nfaEEConnect() {
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+  if (NFA_GetNCIVersion() != NCI_VERSION_2_0) {
+    nfaStat = NFA_EeConnect(EE_HCI_DEFAULT_HANDLE,
+                            NFC_NFCEE_INTERFACE_HCI_ACCESS, nfaEeCallback);
+  } else {
+    nfaStat = NFA_EeDiscover(nfaEeCallback);
+  }
+  if (nfaStat == NFA_STATUS_OK) {
+    SyncEventGuard g(gNfceeDiscCbEvent);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s, Sem wait for gNfceeDiscCbEvent %d", __FUNCTION__, gdisc_timeout);
+    gNfceeDiscCbEvent.wait(gdisc_timeout);
+  }
 }
 
 /******************************************************************************
  ** Function: nfaEEDisconnect
  **
- ** Description: This function can be called to delete the core logical connection
+ ** Description: This function can be called to delete the core logical
+ *connection
  ** already created , to create connection again.
  **
  ** Returns: None
  ********************************************************************************/
-void RoutingManager::nfaEEDisconnect()
-{
-    if(NFA_STATUS_OK == NFA_EeDisconnect(EE_HCI_DEFAULT_HANDLE))
-    {
-        SyncEventGuard guard(mEEDisconnectEvt);
-        ALOGV("%s, Sem wait for mEEDisconnectEvt", __FUNCTION__);
-        mEEDisconnectEvt.wait(1000);
-    }
-}
-
-void RoutingManager::printMemberData()
-{
-    ALOGV("%s: ACTIVE_SE = 0x%0X", __func__, mActiveSe);
-    ALOGV("%s: ACTIVE_SE_NFCF = 0x%0X", __func__, mActiveSeNfcF);
-    ALOGV("%s: AID_MATCHING_MODE = 0x%0X", __func__, mAidMatchingMode);
-    ALOGV("%s: DEFAULT_NFCF_ROUTE = 0x%0X", __func__, mDefaultEeNfcF);
-    ALOGV("%s: DEFAULT_ISODEP_ROUTE = 0x%0X", __func__, mDefaultEe);
-    ALOGV("%s: DEFAULT_OFFHOST_ROUTE = 0x%0X", __func__, mOffHostEe);
-    ALOGV("%s: AID_MATCHING_PLATFORM = 0x%0X", __func__, mAidMatchingPlatform);
-    ALOGV("%s: HOST_LISTEN_TECH_MASK = 0x%0X;", __func__, mHostListnTechMask);
-    ALOGV("%s: UICC_LISTEN_TECH_MASK = 0x%0X;", __func__, mUiccListnTechMask);
-    ALOGV("%s: DEFAULT_FELICA_CLT_ROUTE = 0x%0lX;", __func__, mDefaultTechFSeID);
-    ALOGV("%s: DEFAULT_FELICA_CLT_PWR_STATE = 0x%0lX;", __func__, mDefaultTechFPowerstate);
-
-    ALOGV("%s: NXP_NFC_CHIP = 0x%0X;", __func__, mChipId);
-    ALOGV("%s: NXP_DEFAULT_SE = 0x%0X;", __func__, mDefaultEe);
-    ALOGV("%s: NXP_ENABLE_ADD_AID = 0x%0lX;", __func__, mAddAid);
-    ALOGV("%s: NXP_ESE_WIRED_PRT_MASK = 0x%0X;", __func__, gEseVirtualWiredProtectMask);
-    ALOGV("%s: NXP_UICC_WIRED_PRT_MASK = 0x%0X;", __func__, gUICCVirtualWiredProtectMask);
-    ALOGV("%s: NXP_FWD_FUNCTIONALITY_ENABLE = 0x%0X;", __func__, mFwdFuntnEnable);
-    ALOGV("%s: NXP_WIRED_MODE_RF_FIELD_ENABLE = 0x%0X;", __func__, gWiredModeRfFieldEnable);
-
-}
-/* extract route location and power states in defaultRoute,protoRoute & techRoute in the following format
+void RoutingManager::nfaEEDisconnect() {
+  if (NFA_STATUS_OK == NFA_EeDisconnect(EE_HCI_DEFAULT_HANDLE)) {
+    SyncEventGuard guard(mEEDisconnectEvt);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s, Sem wait for mEEDisconnectEvt", __FUNCTION__);
+    mEEDisconnectEvt.wait(1000);
+  }
+}
+
+void RoutingManager::printMemberData() {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: AID_MATCHING_MODE = 0x%0X", __func__, mAidMatchingMode);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: DEFAULT_ISODEP_ROUTE = 0x%0X", __func__, mDefaultEe);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: AID_MATCHING_PLATFORM = 0x%0X", __func__, mAidMatchingPlatform);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: HOST_LISTEN_TECH_MASK = 0x%0X;", __func__, mHostListnTechMask);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: UICC_LISTEN_TECH_MASK = 0x%0X;", __func__, mUiccListnTechMask);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: DEFAULT_FELICA_CLT_ROUTE = 0x%0u;", __func__, mDefaultTechFSeID);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: DEFAULT_FELICA_CLT_PWR_STATE = 0x%0u;", __func__,
+                      mDefaultTechFPowerstate);
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: NXP_NFC_CHIP = 0x%0X;", __func__, mChipId);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: NXP_DEFAULT_SE = 0x%0X;", __func__, mDefaultEe);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: NXP_ENABLE_ADD_AID = 0x%0u;", __func__, mAddAid);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: NXP_ESE_WIRED_PRT_MASK = 0x%0X;", __func__,
+                      gEseVirtualWiredProtectMask);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: NXP_UICC_WIRED_PRT_MASK = 0x%0X;", __func__,
+                      gUICCVirtualWiredProtectMask);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: NXP_FWD_FUNCTIONALITY_ENABLE = 0x%0X;", __func__, mFwdFuntnEnable);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: NXP_WIRED_MODE_RF_FIELD_ENABLE = 0x%0X;", __func__,
+                      gWiredModeRfFieldEnable);
+}
+/* extract route location and power states in defaultRoute,protoRoute &
+ * techRoute in the following format
  * -----------------------------------------------------------------------------------------------------------
- * |  |  | ScreenOffLock | ScreenOff | ScreenLock | BatteryOff | SwitchOff | SwitchOn |
+ * |  |  | ScreenOffLock | ScreenOff | ScreenLock | BatteryOff | SwitchOff |
+ * SwitchOn |
+ * -----------------------------------------------------------------------------------------------------------
+ *  *
  * -----------------------------------------------------------------------------------------------------------
- *  * -----------------------------------------------------------------------------------------------------------
  * |  |  |  | |  | RFU(TechA/B) | RouteLocBit1 | RouteLocBit0
  * -----------------------------------------------------------------------------------------------------------
  * to mDefaultIso7816SeID & mDefaultIso7816Powerstate
  *    mDefaultIsoDepSeID  & mDefaultIsoDepPowerstate
  *    mDefaultTechASeID   & mDefaultTechAPowerstate
  */
-void RoutingManager::extractRouteLocationAndPowerStates(const int defaultRoute, const int protoRoute, const int techRoute)
-{
-    static const char fn []   = "RoutingManager::extractRouteLocationAndPowerStates";
-    ALOGV("%s:mDefaultIso7816SeID:0x%2lX mDefaultIsoDepSeID:0x%lX mDefaultTechASeID 0x%X", fn, defaultRoute & 0x0300, protoRoute & 0x0300,techRoute & 0x0300);
-    mDefaultIso7816SeID = ((((defaultRoute & 0x0300) >> 8) == 0x00) ? ROUTE_LOC_HOST_ID : ((((defaultRoute & 0x0300)>>8 )== 0x01 ) ? ROUTE_LOC_ESE_ID : getUiccRouteLocId(defaultRoute)));
-    mDefaultIso7816Powerstate = defaultRoute & 0x3F;
-    ALOGV("%s:mDefaultIso7816SeID:0x%2lX mDefaultIso7816Powerstate:0x%lX", fn, mDefaultIso7816SeID, mDefaultIso7816Powerstate);
-    mDefaultIsoDepSeID = ((((protoRoute & 0x0300) >> 8) == 0x00) ? ROUTE_LOC_HOST_ID : ((((protoRoute & 0x0300)>>8 )== 0x01 ) ? ROUTE_LOC_ESE_ID : getUiccRouteLocId(protoRoute)));
-    mDefaultIsoDepPowerstate = protoRoute & 0x3F;
-    ALOGV("%s:mDefaultIsoDepSeID:0x%2lX mDefaultIsoDepPowerstate:0x%2lX", fn, mDefaultIsoDepSeID,mDefaultIsoDepPowerstate);
-    mDefaultTechASeID = ((((techRoute & 0x0300) >> 8) == 0x00) ? ROUTE_LOC_HOST_ID : ((((techRoute & 0x0300)>>8 )== 0x01 ) ? ROUTE_LOC_ESE_ID : getUiccRouteLocId(techRoute)));
-    mDefaultTechAPowerstate = techRoute & 0x3F;
-    ALOGV("%s:mDefaultTechASeID:0x%2lX mDefaultTechAPowerstate:0x%2lX", fn, mDefaultTechASeID,mDefaultTechAPowerstate);
+void RoutingManager::extractRouteLocationAndPowerStates(const int defaultRoute,
+                                                        const int protoRoute,
+                                                        const int techRoute) {
+  static const char fn[] = "RoutingManager::extractRouteLocationAndPowerStates";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s:mDefaultIso7816SeID:0x%2X mDefaultIsoDepSeID:0x%X mDefaultTechASeID "
+      "0x%X",
+      fn, defaultRoute & 0x0300, protoRoute & 0x0300, techRoute & 0x0300);
+  mDefaultIso7816SeID = ((((defaultRoute & 0x0300) >> 8) == 0x00)
+                             ? ROUTE_LOC_HOST_ID
+                             : ((((defaultRoute & 0x0300) >> 8) == 0x01)
+                                    ? ROUTE_LOC_ESE_ID
+                                    : getUiccRouteLocId(defaultRoute)));
+  mDefaultIso7816Powerstate = defaultRoute & 0x3F;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s:mDefaultIso7816SeID:0x%2u mDefaultIso7816Powerstate:0x%u", fn,
+      mDefaultIso7816SeID, mDefaultIso7816Powerstate);
+  mDefaultIsoDepSeID = ((((protoRoute & 0x0300) >> 8) == 0x00)
+                            ? ROUTE_LOC_HOST_ID
+                            : ((((protoRoute & 0x0300) >> 8) == 0x01)
+                                   ? ROUTE_LOC_ESE_ID
+                                   : getUiccRouteLocId(protoRoute)));
+  mDefaultIsoDepPowerstate = protoRoute & 0x3F;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s:mDefaultIsoDepSeID:0x%2u mDefaultIsoDepPowerstate:0x%2u", fn,
+      mDefaultIsoDepSeID, mDefaultIsoDepPowerstate);
+  mDefaultTechASeID = ((((techRoute & 0x0300) >> 8) == 0x00)
+                           ? ROUTE_LOC_HOST_ID
+                           : ((((techRoute & 0x0300) >> 8) == 0x01)
+                                  ? ROUTE_LOC_ESE_ID
+                                  : getUiccRouteLocId(techRoute)));
+  mDefaultTechAPowerstate = techRoute & 0x3F;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s:mDefaultTechASeID:0x%2u mDefaultTechAPowerstate:0x%2u", fn,
+      mDefaultTechASeID, mDefaultTechAPowerstate);
+}
+/* Based on the features enabled :- NXP_NFCC_DYNAMIC_DUAL_UICC,
+ * NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH & NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH,
+ * Calculate the UICC route location ID.
+ * For DynamicDualUicc,Route location is based on the user configuration(6th &
+ * 7th bit) of route
+ * For StaticDualUicc without External Switch(with DynamicDualUicc enabled),
+ * Route location is based on user selection from selectUicc() API
+ * For StaticDualUicc(With External Switch), Route location is always
+ * ROUTE_LOC_UICC1_ID
+ */
+uint16_t RoutingManager::getUiccRouteLocId(const int route) {
+  if (nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC &&
+      nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH)
+    return getUiccRoute(sCurrentSelectedUICCSlot);
+  else if (nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC)
+    return ((((route & 0x0300) >> 8) == 0x02)
+                ? SecureElement::getInstance().EE_HANDLE_0xF4
+                : ROUTE_LOC_UICC2_ID);
+  else /*#if (NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH == true)*/
+    return SecureElement::getInstance().EE_HANDLE_0xF4;
+}
+
+/* To check whether the route location for ISO-DEP protocol defined by user in
+ * config file is actually connected or not
+ * If not connected then set it to HOST by default*/
+void RoutingManager::checkProtoSeID(void) {
+  static const char fn[] = "RoutingManager::checkProtoSeID";
+  uint8_t isDefaultIsoDepSeIDPresent = 0;
+  uint8_t isDefaultAidRoutePresent = 0;
+  tNFA_HANDLE ActDevHandle = NFA_HANDLE_INVALID;
+  unsigned long check_default_proto_se_id_req = 0;
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+
+  if (NfcConfig::hasKey(NAME_CHECK_DEFAULT_PROTO_SE_ID)) {
+    check_default_proto_se_id_req =
+        NfcConfig::getUnsigned(NAME_CHECK_DEFAULT_PROTO_SE_ID);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: CHECK_DEFAULT_PROTO_SE_ID - 0x%2lX ", fn,
+                        check_default_proto_se_id_req);
+  } else {
+    LOG(ERROR) << StringPrintf(
+        "%s: CHECK_DEFAULT_PROTO_SE_ID not defined. Taking default value - "
+        "0x%2lX",
+        fn, check_default_proto_se_id_req);
+  }
+
+  if (check_default_proto_se_id_req == 0x01) {
+    uint8_t count, seId = 0;
+    tNFA_HANDLE ee_handleList[nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED];
+    SecureElement::getInstance().getEeHandleList(ee_handleList, &count);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: count : %d", fn, count);
+    for (int i = 0; ((count != 0) && (i < count)); i++) {
+      seId = SecureElement::getInstance().getGenericEseId(ee_handleList[i]);
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: seId : %d", fn, seId);
+      ActDevHandle =
+          SecureElement::getInstance().getEseHandleFromGenericId(seId);
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: ActDevHandle : 0x%X", fn, ActDevHandle);
+      if (mDefaultIsoDepSeID == ActDevHandle) {
+        isDefaultIsoDepSeIDPresent = 1;
+      }
+      if (mDefaultIso7816SeID == ActDevHandle) {
+        isDefaultAidRoutePresent = 1;
+      }
+      if (isDefaultIsoDepSeIDPresent && isDefaultAidRoutePresent) {
+        break;
+      }
+    }
+
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s:isDefaultIsoDepSeIDPresent:0x%X", fn, isDefaultIsoDepSeIDPresent);
+    if (!isDefaultIsoDepSeIDPresent) {
+      mDefaultIsoDepSeID = ROUTE_LOC_HOST_ID;
+      mDefaultIsoDepPowerstate =
+          PWR_SWTCH_ON_SCRN_UNLCK_MASK | PWR_SWTCH_ON_SCRN_LOCK_MASK;
+    }
+    if (!isDefaultAidRoutePresent) {
+      mDefaultIso7816SeID = ROUTE_LOC_HOST_ID;
+      mDefaultIso7816Powerstate =
+          PWR_SWTCH_ON_SCRN_UNLCK_MASK | PWR_SWTCH_ON_SCRN_LOCK_MASK;
+    }
+  }
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
+}
+
+void RoutingManager::configureOffHostNfceeTechMask(void) {
+  static const char fn[] = "RoutingManager::configureOffHostNfceeTechMask";
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+  uint8_t seId = 0x00;
+  uint8_t count = 0x00;
+  tNFA_HANDLE preferredHandle = SecureElement::getInstance().EE_HANDLE_0xF4;
+  tNFA_HANDLE defaultHandle = NFA_HANDLE_INVALID;
+  tNFA_HANDLE ee_handleList[nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED];
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+
+  if (mDefaultEe & SecureElement::ESE_ID)  // eSE
+  {
+    preferredHandle = ROUTE_LOC_ESE_ID;
+  } else if ((mDefaultEe & SecureElement::UICC_ID) || (mDefaultEe & SecureElement::UICC2_ID)) //UICC
+  {
+    preferredHandle = ((sCurrentSelectedUICCSlot == 2) ? ROUTE_LOC_UICC2_ID : SecureElement::getInstance().EE_HANDLE_0xF4);
+  }
+
+  SecureElement::getInstance().getEeHandleList(ee_handleList, &count);
+
+  for (uint8_t i = 0; ((count != 0) && (i < count)); i++) {
+    seId = SecureElement::getInstance().getGenericEseId(ee_handleList[i]);
+    defaultHandle =
+        SecureElement::getInstance().getEseHandleFromGenericId(seId);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: ee_handleList[%d] : 0x%X", fn, i, ee_handleList[i]);
+    if (preferredHandle == defaultHandle) {
+      break;
+    }
+    defaultHandle = NFA_HANDLE_INVALID;
+  }
+
+  if ((defaultHandle != NFA_HANDLE_INVALID) && (0 != mUiccListnTechMask)) {
+    if(defaultHandle == SecureElement::EE_HANDLE_0xF3) {
+      {
+        SyncEventGuard guard(SecureElement::getInstance().mEseListenEvent);
+        nfaStat = NFA_CeConfigureEseListenTech(defaultHandle, 0x00);
+        if (nfaStat == NFA_STATUS_OK) {
+          SecureElement::getInstance().mEseListenEvent.wait();
+        } else
+          LOG(ERROR) << StringPrintf("fail to start eSE listen");
+      }
+      {
+        SyncEventGuard guard(SecureElement::getInstance().mEseListenEvent);
+        nfaStat = NFA_CeConfigureEseListenTech(defaultHandle,
+                                                (mUiccListnTechMask & 0x07));
+        if (nfaStat == NFA_STATUS_OK) {
+          SecureElement::getInstance().mEseListenEvent.wait();
+        } else
+          LOG(ERROR) << StringPrintf("fail to start eSE listen");
+      }
+    } else {
+      {
+        SyncEventGuard guard(SecureElement::getInstance().mUiccListenEvent);
+        nfaStat = NFA_CeConfigureUiccListenTech(defaultHandle, 0x00);
+        if (nfaStat == NFA_STATUS_OK) {
+          SecureElement::getInstance().mUiccListenEvent.wait();
+        } else
+          LOG(ERROR) << StringPrintf("fail to start UICC listen");
+      }
+      {
+        SyncEventGuard guard(SecureElement::getInstance().mUiccListenEvent);
+        nfaStat = NFA_CeConfigureUiccListenTech(defaultHandle,
+                                                (mUiccListnTechMask & 0x07));
+        if (nfaStat == NFA_STATUS_OK) {
+          SecureElement::getInstance().mUiccListenEvent.wait();
+        } else
+          LOG(ERROR) << StringPrintf("fail to start UICC listen");
+      }
+    }
+  }
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
+}
+
+void RoutingManager::initialiseTableEntries(void) {
+  static const char fn[] = "RoutingManager::initialiseTableEntries";
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+
+  /* Defined Protocol Masks
+   * T1T      0x01
+   * T2T      0x02
+   * T3T      0x04
+   * ISO-DEP  0x08
+   * NFC-DEP  0x10
+   * ISO-7816 0x20
+   */
+
+  mProtoTableEntries[PROTO_T3T_IDX].protocol = NFA_PROTOCOL_MASK_T3T;
+  mProtoTableEntries[PROTO_ISODEP_IDX].protocol = NFA_PROTOCOL_MASK_ISO_DEP;
+  if (NFA_GetNCIVersion() == NCI_VERSION_1_0) {
+    mProtoTableEntries[PROTO_ISO7816_IDX].protocol = NFC_PROTOCOL_MASK_ISO7816;
+  }
+
+  mTechTableEntries[TECH_A_IDX].technology = NFA_TECHNOLOGY_MASK_A;
+  mTechTableEntries[TECH_B_IDX].technology = NFA_TECHNOLOGY_MASK_B;
+  mTechTableEntries[TECH_F_IDX].technology = NFA_TECHNOLOGY_MASK_F;
+
+  for (int xx = 0; xx < AVAILABLE_PROTO_ENTRIES(); xx++) {
+    mProtoTableEntries[xx].routeLoc = mTechTableEntries[xx].routeLoc = 0x00;
+    mProtoTableEntries[xx].power = mTechTableEntries[xx].power = 0x00;
+    mProtoTableEntries[xx].enable = mTechTableEntries[xx].enable = false;
+  }
+
+  mLmrtEntries[ROUTE_LOC_HOST_ID_IDX].nfceeID = ROUTE_LOC_HOST_ID;
+  mLmrtEntries[ROUTE_LOC_ESE_ID_IDX].nfceeID = ROUTE_LOC_ESE_ID;
+  mLmrtEntries[ROUTE_LOC_UICC1_ID_IDX].nfceeID =
+      SecureElement::getInstance().EE_HANDLE_0xF4;
+  mLmrtEntries[ROUTE_LOC_UICC2_ID_IDX].nfceeID = ROUTE_LOC_UICC2_ID;
+
+  /*Initialize the table for all route location nfceeID*/
+  for (int xx = 0; xx < MAX_ROUTE_LOC_ENTRIES; xx++) {
+    mLmrtEntries[xx].proto_switch_on = mLmrtEntries[xx].tech_switch_on = 0x00;
+    mLmrtEntries[xx].proto_switch_off = mLmrtEntries[xx].tech_switch_off = 0x00;
+    mLmrtEntries[xx].proto_battery_off = mLmrtEntries[xx].tech_battery_off =
+        0x00;
+    mLmrtEntries[xx].proto_screen_lock = mLmrtEntries[xx].tech_screen_lock =
+        0x00;
+    mLmrtEntries[xx].proto_screen_off = mLmrtEntries[xx].tech_screen_off = 0x00;
+    mLmrtEntries[xx].proto_screen_off_lock =
+        mLmrtEntries[xx].tech_screen_off_lock = 0x00;
+  }
+  /*Get all the technologies supported by all the execution environments*/
+  mTechSupportedByEse =
+      SecureElement::getInstance().getSETechnology(ROUTE_LOC_ESE_ID);
+  mTechSupportedByUicc1 = SecureElement::getInstance().getSETechnology(
+      SecureElement::getInstance().EE_HANDLE_0xF4);
+  mTechSupportedByUicc2 =
+      SecureElement::getInstance().getSETechnology(ROUTE_LOC_UICC2_ID);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: exit; mTechSupportedByEse:0x%0u mTechSupportedByUicc1:0x%0u "
+      "mTechSupportedByUicc2:0x%0u",
+      fn, mTechSupportedByEse, mTechSupportedByUicc1, mTechSupportedByUicc2);
+}
+
+/* Compilation of Proto Table entries strictly based on config file parameters
+ * Each entry in proto table consistes of route location, protocol and power
+ * state
+ * */
+void RoutingManager::compileProtoEntries(void) {
+  static const char fn[] = "RoutingManager::compileProtoEntries";
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+
+  /*Populate the entries on  protocol table*/
+  mProtoTableEntries[PROTO_T3T_IDX].routeLoc =
+      ROUTE_LOC_HOST_ID;  // T3T Proto always to HOST. For other EE used Tech F
+                          // routing
+  mProtoTableEntries[PROTO_T3T_IDX].power =
+      PWR_SWTCH_ON_SCRN_UNLCK_MASK;  // Only Screen ON UNLOCK allowed
+  mProtoTableEntries[PROTO_T3T_IDX].enable =
+      ((mHostListnTechMask & 0x04) != 0x00) ? true : false;
+
+  mProtoTableEntries[PROTO_ISODEP_IDX].routeLoc = mDefaultIsoDepSeID;
+  mProtoTableEntries[PROTO_ISODEP_IDX].power =
+      mCeRouteStrictDisable ? mDefaultIsoDepPowerstate
+                            : (mDefaultIsoDepPowerstate & POWER_STATE_MASK);
+  mProtoTableEntries[PROTO_ISODEP_IDX].enable =
+      ((mHostListnTechMask & 0x03) != 0x00) ? true : false;
+
+  if (NFA_GetNCIVersion() == NCI_VERSION_1_0) {
+    mProtoTableEntries[PROTO_ISO7816_IDX].routeLoc = mDefaultIso7816SeID;
+    mProtoTableEntries[PROTO_ISO7816_IDX].power =
+        mCeRouteStrictDisable ? mDefaultIso7816Powerstate
+                              : (mDefaultIso7816Powerstate & POWER_STATE_MASK);
+    mProtoTableEntries[PROTO_ISO7816_IDX].enable =
+        (mDefaultIso7816SeID == ROUTE_LOC_HOST_ID)
+            ? (((mHostListnTechMask & 0x03) != 0x00) ? true : false)
+            : (true);
+  }
+  dumpTables(1);
 
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
 }
-/* Based on the features enabled :- NXP_NFCC_DYNAMIC_DUAL_UICC, NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH & NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH,
- * Calculate the UICC route location ID.
- * For DynamicDualUicc,Route location is based on the user configuration(6th & 7th bit) of route
- * For StaticDualUicc without External Switch(with DynamicDualUicc enabled), Route location is based on user selection from selectUicc() API
- * For StaticDualUicc(With External Switch), Route location is always ROUTE_LOC_UICC1_ID
+
+/* libnfc-nci takes protocols for each power-state for single route location
+ * The previous protocols set will be overwritten by new protocols set by
+ * NFA_EeSetDefaultProtoRouting
+ * So consolidate all the protocols/power state for a given NFCEE ID's
+ * For example:
+ * When PROTOCOL(ISO-DEP) and  AID default route(ISO7816) set to same EE then
+ * set (ISO-DEP | ISO-7816) to that EE.
  */
-uint16_t RoutingManager::getUiccRouteLocId(const int route)
-{
-    if(nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC && nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH)
-        return getUiccRoute(sCurrentSelectedUICCSlot);
-    else if(nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC)
-        return ((((route & 0x0300)>>8 )== 0x02 ) ? SecureElement::getInstance().EE_HANDLE_0xF4 : ROUTE_LOC_UICC2_ID);
-    else /*#if (NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH == true)*/
-        return SecureElement::getInstance().EE_HANDLE_0xF4;
+void RoutingManager::consolidateProtoEntries(void) {
+  static const char fn[] = "RoutingManager::consolidateProtoEntries";
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+
+  int index = -1;
+
+  for (int xx = 0; xx < AVAILABLE_PROTO_ENTRIES(); xx++) {
+    if (mProtoTableEntries[xx].enable) {
+      switch (mProtoTableEntries[xx].routeLoc) {
+        case ROUTE_LOC_HOST_ID:
+          index = ROUTE_LOC_HOST_ID_IDX;
+          break;
+        case ROUTE_LOC_ESE_ID:
+          index = ROUTE_LOC_ESE_ID_IDX;
+          break;
+        case ROUTE_LOC_UICC1_ID:
+        case ROUTE_LOC_UICC1_ID_NCI2_0:
+          index = ROUTE_LOC_UICC1_ID_IDX;
+          break;
+        case ROUTE_LOC_UICC2_ID:
+          index = ROUTE_LOC_UICC2_ID_IDX;
+          break;
+      }
+      if (index != -1) {
+        mLmrtEntries[index].proto_switch_on =
+            (mLmrtEntries[index].proto_switch_on) |
+            ((mProtoTableEntries[xx].power & PWR_SWTCH_ON_SCRN_UNLCK_MASK)
+                 ? mProtoTableEntries[xx].protocol
+                 : 0);
+        mLmrtEntries[index].proto_switch_off =
+            (mLmrtEntries[index].proto_switch_off) |
+            ((mProtoTableEntries[xx].power & PWR_SWTCH_OFF_MASK)
+                 ? mProtoTableEntries[xx].protocol
+                 : 0);
+        mLmrtEntries[index].proto_battery_off =
+            (mLmrtEntries[index].proto_battery_off) |
+            ((mProtoTableEntries[xx].power & PWR_BATT_OFF_MASK)
+                 ? mProtoTableEntries[xx].protocol
+                 : 0);
+        mLmrtEntries[index].proto_screen_lock =
+            (mLmrtEntries[index].proto_screen_lock) |
+            ((mProtoTableEntries[xx].power & PWR_SWTCH_ON_SCRN_LOCK_MASK)
+                 ? mProtoTableEntries[xx].protocol
+                 : 0);
+        mLmrtEntries[index].proto_screen_off =
+            (mLmrtEntries[index].proto_screen_off) |
+            ((mProtoTableEntries[xx].power & PWR_SWTCH_ON_SCRN_OFF_MASK)
+                 ? mProtoTableEntries[xx].protocol
+                 : 0);
+        mLmrtEntries[index].proto_screen_off_lock =
+            (mLmrtEntries[index].proto_screen_off_lock) |
+            ((mProtoTableEntries[xx].power & PWR_SWTCH_ON_SCRN_OFF_LOCK_MASK)
+                 ? mProtoTableEntries[xx].protocol
+                 : 0);
+      }
+    }
+  }
+
+  dumpTables(2);
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
+}
+
+void RoutingManager::setProtoRouting() {
+  static const char fn[] = "RoutingManager::setProtoRouting";
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+  SyncEventGuard guard(mRoutingEvent);
+  for (int xx = 0; xx < MAX_ROUTE_LOC_ENTRIES; xx++) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: nfceeID:0x%X", fn, mLmrtEntries[xx].nfceeID);
+    if (mLmrtEntries[xx].nfceeID && (mLmrtEntries[xx].proto_switch_on ||
+                                     mLmrtEntries[xx].proto_switch_off ||
+                                     mLmrtEntries[xx].proto_battery_off ||
+                                     mLmrtEntries[xx].proto_screen_lock ||
+                                     mLmrtEntries[xx].proto_screen_off ||
+                                     mLmrtEntries[xx].proto_screen_off_lock)) {
+      /*Clear protocols for NFCEE ID control block */
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: Clear Proto Routing Entries for nfceeID:0x%X",
+                          fn, mLmrtEntries[xx].nfceeID);
+      nfaStat = NFA_EeSetDefaultProtoRouting(mLmrtEntries[xx].nfceeID, 0, 0, 0,
+                                             0, 0, 0);
+      if (nfaStat == NFA_STATUS_OK) {
+        mRoutingEvent.wait();
+      } else {
+        LOG(ERROR) << StringPrintf("Fail to clear proto routing to 0x%X",
+                                   mLmrtEntries[xx].nfceeID);
+      }
+      /*Set Required protocols for NFCEE ID control block in libnfc-nci*/
+      nfaStat = NFA_EeSetDefaultProtoRouting(
+          mLmrtEntries[xx].nfceeID, mLmrtEntries[xx].proto_switch_on,
+          mLmrtEntries[xx].proto_switch_off, mLmrtEntries[xx].proto_battery_off,
+          mLmrtEntries[xx].proto_screen_lock, mLmrtEntries[xx].proto_screen_off,
+          mLmrtEntries[xx].proto_screen_off_lock);
+      if (nfaStat == NFA_STATUS_OK) {
+        mRoutingEvent.wait();
+      } else {
+        LOG(ERROR) << StringPrintf("Fail to set proto routing to 0x%X",
+                                   mLmrtEntries[xx].nfceeID);
+      }
+    }
+  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
 }
+#if (NXP_EXTNS == TRUE)
+/*
+ * In NCI2.0 Protocol 7816 routing is replaced with empty AID
+ * Routing entry Format :
+ *  Type   = [0x12]
+ *  Length = 2 [0x02]
+ *  Value  = [Route_loc, Power_state]
+ * */
+void RoutingManager::setEmptyAidEntry() {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter, ", __func__);
 
-/* To check whether the route location for ISO-DEP protocol defined by user in config file is actually connected or not
- * If not connected then set it to HOST by default*/
-void RoutingManager::checkProtoSeID(void)
-{
-    static const char fn []                         = "RoutingManager::checkProtoSeID";
-    uint8_t           isDefaultIsoDepSeIDPresent    = 0;
-    uint8_t           isDefaultAidRoutePresent      = 0;
-    tNFA_HANDLE       ActDevHandle                  = NFA_HANDLE_INVALID;
-    unsigned long     check_default_proto_se_id_req = 0;
+  uint16_t routeLoc;
+  uint8_t power;
 
-    ALOGV("%s: enter", fn);
+  routeLoc = mDefaultIso7816SeID;
+  power = mCeRouteStrictDisable
+              ? mDefaultIso7816Powerstate
+              : (mDefaultIso7816Powerstate & POWER_STATE_MASK);
 
-    if (GetNxpNumValue(NAME_CHECK_DEFAULT_PROTO_SE_ID, &check_default_proto_se_id_req, sizeof(check_default_proto_se_id_req)))
-    {
-        ALOGV("%s: CHECK_DEFAULT_PROTO_SE_ID - 0x%2lX ",fn,check_default_proto_se_id_req);
-    }
-    else
-    {
-        ALOGE("%s: CHECK_DEFAULT_PROTO_SE_ID not defined. Taking default value - 0x%2lX",fn,check_default_proto_se_id_req);
-    }
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: routeLoc 0x%x", __func__, routeLoc);
+  if (routeLoc == NFA_HANDLE_INVALID) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Invalid routeLoc. Return.", __func__);
+    return;
+  }
 
-    if(check_default_proto_se_id_req == 0x01)
-    {
-        uint8_t count,seId=0;
-        tNFA_HANDLE ee_handleList[nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED];
-        SecureElement::getInstance().getEeHandleList(ee_handleList, &count);
-        ALOGV("%s: count : %d", fn, count);
-        for (int  i = 0; ((count != 0 ) && (i < count)); i++)
-        {
-            seId = SecureElement::getInstance().getGenericEseId(ee_handleList[i]);
-            ALOGV("%s: seId : %d", fn, seId);
-            ActDevHandle = SecureElement::getInstance().getEseHandleFromGenericId(seId);
-            ALOGV("%s: ActDevHandle : 0x%X", fn, ActDevHandle);
-            if (mDefaultIsoDepSeID == ActDevHandle)
-            {
-                isDefaultIsoDepSeIDPresent = 1;
-            }
-            if (mDefaultIso7816SeID == ActDevHandle)
-            {
-                isDefaultAidRoutePresent = 1;
-            }
-            if(isDefaultIsoDepSeIDPresent && isDefaultAidRoutePresent)
-            {
-                break;
-            }
-        }
-
-        ALOGV("%s:isDefaultIsoDepSeIDPresent:0x%X", fn, isDefaultIsoDepSeIDPresent);
-        if(!isDefaultIsoDepSeIDPresent)
-        {
-            mDefaultIsoDepSeID = ROUTE_LOC_HOST_ID;
-            mDefaultIsoDepPowerstate = PWR_SWTCH_ON_SCRN_UNLCK_MASK | PWR_SWTCH_ON_SCRN_LOCK_MASK;
-        }
-        if(!isDefaultAidRoutePresent)
-        {
-            mDefaultIso7816SeID = ROUTE_LOC_HOST_ID;
-            mDefaultIso7816Powerstate = PWR_SWTCH_ON_SCRN_UNLCK_MASK | PWR_SWTCH_ON_SCRN_LOCK_MASK;
-        }
-    }
-
-    ALOGV("%s: exit", fn);
-}
-
-void RoutingManager::configureOffHostNfceeTechMask(void)
-{
-    static const char fn []           = "RoutingManager::configureOffHostNfceeTechMask";
-    tNFA_STATUS       nfaStat         = NFA_STATUS_FAILED;
-    uint8_t           seId            = 0x00;
-    uint8_t           count           = 0x00;
-    tNFA_HANDLE       preferredHandle = SecureElement::getInstance().EE_HANDLE_0xF4;
-    tNFA_HANDLE       defaultHandle   = NFA_HANDLE_INVALID;
-    tNFA_HANDLE       ee_handleList[nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED];
-
-    ALOGV("%s: enter", fn);
-
-    if (mDefaultEe & SecureElement::ESE_ID) //eSE
-    {
-        preferredHandle = ROUTE_LOC_ESE_ID;
-    }
-    else if (mDefaultEe & SecureElement::UICC_ID) //UICC
-    {
-        preferredHandle = SecureElement::getInstance().EE_HANDLE_0xF4;
-    }
-    else if (nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC &&
-            nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH &&
-            (mDefaultEe & SecureElement::UICC2_ID)) //UICC
-    {
-        preferredHandle = ROUTE_LOC_UICC2_ID;
-    }
-
-    SecureElement::getInstance().getEeHandleList(ee_handleList, &count);
-
-    for (uint8_t i = 0; ((count != 0 ) && (i < count)); i++)
-    {
-        seId = SecureElement::getInstance().getGenericEseId(ee_handleList[i]);
-        defaultHandle = SecureElement::getInstance().getEseHandleFromGenericId(seId);
-        ALOGV("%s: ee_handleList[%d] : 0x%X", fn, i,ee_handleList[i]);
-        if (preferredHandle == defaultHandle)
-        {
-            break;
-        }
-        defaultHandle   = NFA_HANDLE_INVALID;
-    }
-
-    if((defaultHandle != NFA_HANDLE_INVALID)  &&  (0 != mUiccListnTechMask))
-    {
-        {
-            SyncEventGuard guard (SecureElement::getInstance().mUiccListenEvent);
-            nfaStat = NFA_CeConfigureUiccListenTech (defaultHandle, 0x00);
-            if (nfaStat == NFA_STATUS_OK)
-            {
-                 SecureElement::getInstance().mUiccListenEvent.wait ();
-            }
-            else
-                 ALOGE("fail to start UICC listen");
-        }
-        {
-            SyncEventGuard guard (SecureElement::getInstance().mUiccListenEvent);
-            nfaStat = NFA_CeConfigureUiccListenTech (defaultHandle, (mUiccListnTechMask & 0x07));
-            if(nfaStat == NFA_STATUS_OK)
-            {
-                 SecureElement::getInstance().mUiccListenEvent.wait ();
-            }
-            else
-                 ALOGE("fail to start UICC listen");
-        }
-    }
-
-    ALOGV("%s: exit", fn);
-}
-
-void RoutingManager::initialiseTableEntries(void)
-{
-    static const char fn [] = "RoutingManager::initialiseTableEntries";
-
-    ALOGV("%s: enter", fn);
-
-    /* Defined Protocol Masks
-    * T1T      0x01
-    * T2T      0x02
-    * T3T      0x04
-    * ISO-DEP  0x08
-    * NFC-DEP  0x10
-    * ISO-7816 0x20
-    */
-
-    mProtoTableEntries[PROTO_T3T_IDX].protocol     = NFA_PROTOCOL_MASK_T3T;
-    mProtoTableEntries[PROTO_ISODEP_IDX].protocol  = NFA_PROTOCOL_MASK_ISO_DEP;
-    if(NFA_GetNCIVersion() == NCI_VERSION_1_0) {
-        mProtoTableEntries[PROTO_ISO7816_IDX].protocol = NFC_PROTOCOL_MASK_ISO7816;
-    }
-
-    mTechTableEntries[TECH_A_IDX].technology       = NFA_TECHNOLOGY_MASK_A;
-    mTechTableEntries[TECH_B_IDX].technology       = NFA_TECHNOLOGY_MASK_B;
-    mTechTableEntries[TECH_F_IDX].technology       = NFA_TECHNOLOGY_MASK_F;
-
-
-    for(int xx = 0; xx < AVAILABLE_PROTO_ENTRIES(); xx++)
-    {
-        mProtoTableEntries[xx].routeLoc = mTechTableEntries[xx].routeLoc = 0x00;
-        mProtoTableEntries[xx].power    = mTechTableEntries[xx].power    = 0x00;
-        mProtoTableEntries[xx].enable   = mTechTableEntries[xx].enable   = false;
-    }
-
-    mLmrtEntries[ROUTE_LOC_HOST_ID_IDX].nfceeID    = ROUTE_LOC_HOST_ID;
-    mLmrtEntries[ROUTE_LOC_ESE_ID_IDX].nfceeID     = ROUTE_LOC_ESE_ID;
-    mLmrtEntries[ROUTE_LOC_UICC1_ID_IDX].nfceeID   = SecureElement::getInstance().EE_HANDLE_0xF4;
-    mLmrtEntries[ROUTE_LOC_UICC2_ID_IDX].nfceeID   = ROUTE_LOC_UICC2_ID;
-
-    /*Initialize the table for all route location nfceeID*/
-    for(int xx=0;xx<MAX_ROUTE_LOC_ENTRIES;xx++)
-    {
-        mLmrtEntries[xx].proto_switch_on   = mLmrtEntries[xx].tech_switch_on   = 0x00;
-        mLmrtEntries[xx].proto_switch_off  = mLmrtEntries[xx].tech_switch_off  = 0x00;
-        mLmrtEntries[xx].proto_battery_off = mLmrtEntries[xx].tech_battery_off = 0x00;
-        mLmrtEntries[xx].proto_screen_lock = mLmrtEntries[xx].tech_screen_lock = 0x00;
-        mLmrtEntries[xx].proto_screen_off  = mLmrtEntries[xx].tech_screen_off  = 0x00;
-        mLmrtEntries[xx].proto_screen_off_lock  = mLmrtEntries[xx].tech_screen_off_lock  = 0x00;
-    }
-    /*Get all the technologies supported by all the execution environments*/
-     mTechSupportedByEse   = SecureElement::getInstance().getSETechnology(ROUTE_LOC_ESE_ID);
-     mTechSupportedByUicc1 = SecureElement::getInstance().getSETechnology(SecureElement::getInstance().EE_HANDLE_0xF4);
-     mTechSupportedByUicc2 = SecureElement::getInstance().getSETechnology(ROUTE_LOC_UICC2_ID);
-     ALOGV("%s: exit; mTechSupportedByEse:0x%0lX mTechSupportedByUicc1:0x%0lX mTechSupportedByUicc2:0x%0lX", fn, mTechSupportedByEse, mTechSupportedByUicc1, mTechSupportedByUicc2);
-}
-
-/* Compilation of Proto Table entries strictly based on config file parameters
- * Each entry in proto table consistes of route location, protocol and power state
- * */
-void RoutingManager::compileProtoEntries(void)
-{
-    static const char fn [] = "RoutingManager::compileProtoEntries";
-
-    ALOGV("%s: enter", fn);
-
-    /*Populate the entries on  protocol table*/
-    mProtoTableEntries[PROTO_T3T_IDX].routeLoc = ROUTE_LOC_HOST_ID;//T3T Proto always to HOST. For other EE used Tech F routing
-    mProtoTableEntries[PROTO_T3T_IDX].power    = PWR_SWTCH_ON_SCRN_UNLCK_MASK; //Only Screen ON UNLOCK allowed
-    mProtoTableEntries[PROTO_T3T_IDX].enable   = ((mHostListnTechMask & 0x04) != 0x00) ? true : false;
-
-    mProtoTableEntries[PROTO_ISODEP_IDX].routeLoc = mDefaultIsoDepSeID;
-    mProtoTableEntries[PROTO_ISODEP_IDX].power    = mCeRouteStrictDisable ? mDefaultIsoDepPowerstate : (mDefaultIsoDepPowerstate & POWER_STATE_MASK);
-    mProtoTableEntries[PROTO_ISODEP_IDX].enable   = ((mHostListnTechMask & 0x03) != 0x00) ? true : false;
-
-    if(NFA_GetNCIVersion() == NCI_VERSION_1_0) {
-    mProtoTableEntries[PROTO_ISO7816_IDX].routeLoc = mDefaultIso7816SeID;
-    mProtoTableEntries[PROTO_ISO7816_IDX].power    = mCeRouteStrictDisable ? mDefaultIso7816Powerstate : (mDefaultIso7816Powerstate & POWER_STATE_MASK);
-    mProtoTableEntries[PROTO_ISO7816_IDX].enable   = (mDefaultIso7816SeID == ROUTE_LOC_HOST_ID) ? (((mHostListnTechMask & 0x03) != 0x00) ? true : false):(true);
-    }
-    dumpTables(1);
-
-    ALOGV("%s: exit", fn);
-}
-
-/* libnfc-nci takes protocols for each power-state for single route location
- * The previous protocols set will be overwritten by new protocols set by NFA_EeSetDefaultProtoRouting
- * So consolidate all the protocols/power state for a given NFCEE ID's
- * For example:
- * When PROTOCOL(ISO-DEP) and  AID default route(ISO7816) set to same EE then set (ISO-DEP | ISO-7816) to that EE.
- */
-void RoutingManager::consolidateProtoEntries(void)
-{
-    static const char fn [] = "RoutingManager::consolidateProtoEntries";
-
-    ALOGV("%s: enter", fn);
-
-    int index = -1;
-
-    for(int xx=0;xx<AVAILABLE_PROTO_ENTRIES();xx++)
-    {
-        if(mProtoTableEntries[xx].enable)
-        {
-            switch(mProtoTableEntries[xx].routeLoc)
-            {
-                case ROUTE_LOC_HOST_ID:
-                        index = ROUTE_LOC_HOST_ID_IDX;
-                    break;
-                case ROUTE_LOC_ESE_ID:
-                        index = ROUTE_LOC_ESE_ID_IDX;
-                    break;
-                case ROUTE_LOC_UICC1_ID:
-                case ROUTE_LOC_UICC1_ID_NCI2_0:
-                        index = ROUTE_LOC_UICC1_ID_IDX;
-                    break;
-                case ROUTE_LOC_UICC2_ID:
-                        index = ROUTE_LOC_UICC2_ID_IDX;
-                    break;
-            }
-            if(index != -1)
-            {
-                mLmrtEntries[index].proto_switch_on    = (mLmrtEntries[index].proto_switch_on)   |
-                                                         ((mProtoTableEntries[xx].power & PWR_SWTCH_ON_SCRN_UNLCK_MASK) ? mProtoTableEntries[xx].protocol:0);
-                mLmrtEntries[index].proto_switch_off   = (mLmrtEntries[index].proto_switch_off)  |
-                                                         ((mProtoTableEntries[xx].power & PWR_SWTCH_OFF_MASK) ? mProtoTableEntries[xx].protocol:0);
-                mLmrtEntries[index].proto_battery_off  = (mLmrtEntries[index].proto_battery_off) |
-                                                         ((mProtoTableEntries[xx].power & PWR_BATT_OFF_MASK) ? mProtoTableEntries[xx].protocol:0);
-                mLmrtEntries[index].proto_screen_lock  = (mLmrtEntries[index].proto_screen_lock) |
-                                                         ((mProtoTableEntries[xx].power & PWR_SWTCH_ON_SCRN_LOCK_MASK) ? mProtoTableEntries[xx].protocol:0);
-                mLmrtEntries[index].proto_screen_off   = (mLmrtEntries[index].proto_screen_off)  |
-                                                         ((mProtoTableEntries[xx].power & PWR_SWTCH_ON_SCRN_OFF_MASK) ? mProtoTableEntries[xx].protocol:0);
-                mLmrtEntries[index].proto_screen_off_lock   = (mLmrtEntries[index].proto_screen_off_lock)  |
-                                                         ((mProtoTableEntries[xx].power & PWR_SWTCH_ON_SCRN_OFF_LOCK_MASK) ? mProtoTableEntries[xx].protocol:0);
-            }
-        }
-    }
-
-    dumpTables(2);
-
-    ALOGV("%s: exit", fn);
-}
-
-void RoutingManager::setProtoRouting()
-{
-    static const char fn [] = "RoutingManager::setProtoRouting";
-    tNFA_STATUS nfaStat     = NFA_STATUS_FAILED;
-
-    ALOGV("%s: enter", fn);
-    SyncEventGuard guard (mRoutingEvent);
-    for(int xx=0;xx<MAX_ROUTE_LOC_ENTRIES;xx++)
-    {
-        ALOGV("%s: nfceeID:0x%X", fn, mLmrtEntries[xx].nfceeID);
-        if( mLmrtEntries[xx].nfceeID           &&
-           (mLmrtEntries[xx].proto_switch_on   ||
-            mLmrtEntries[xx].proto_switch_off  ||
-            mLmrtEntries[xx].proto_battery_off ||
-            mLmrtEntries[xx].proto_screen_lock ||
-            mLmrtEntries[xx].proto_screen_off  ||
-            mLmrtEntries[xx].proto_screen_off_lock) )
-        {
-            /*Clear protocols for NFCEE ID control block */
-            ALOGV("%s: Clear Proto Routing Entries for nfceeID:0x%X", fn, mLmrtEntries[xx].nfceeID);
-            nfaStat = NFA_EeSetDefaultProtoRouting(mLmrtEntries[xx].nfceeID,0,0,0,0,0,0);
-            if(nfaStat == NFA_STATUS_OK)
-            {
-                mRoutingEvent.wait ();
-            }
-            else
-            {
-                ALOGE("Fail to clear proto routing to 0x%X",mLmrtEntries[xx].nfceeID);
-            }
-            /*Set Required protocols for NFCEE ID control block in libnfc-nci*/
-            nfaStat = NFA_EeSetDefaultProtoRouting(mLmrtEntries[xx].nfceeID,
-                                                   mLmrtEntries[xx].proto_switch_on,
-                                                   mLmrtEntries[xx].proto_switch_off,
-                                                   mLmrtEntries[xx].proto_battery_off,
-                                                   mLmrtEntries[xx].proto_screen_lock,
-                                                   mLmrtEntries[xx].proto_screen_off,
-                                                   mLmrtEntries[xx].proto_screen_off_lock);
-            if(nfaStat == NFA_STATUS_OK)
-            {
-                mRoutingEvent.wait ();
-            }
-            else
-            {
-                ALOGE("Fail to set proto routing to 0x%X",mLmrtEntries[xx].nfceeID);
-            }
-        }
-    }
-    ALOGV("%s: exit", fn);
-}
-#if(NXP_EXTNS == TRUE)
-/*
- * In NCI2.0 Protocol 7816 routing is replaced with empty AID
- * Routing entry Format :
- *  Type   = [0x12]
- *  Length = 2 [0x02]
- *  Value  = [Route_loc, Power_state]
- * */
-void RoutingManager::setEmptyAidEntry() {
-
-    ALOGV("%s: enter, ", __func__);
-    tNFA_HANDLE current_handle;
-
-    uint16_t routeLoc;
-    uint8_t power;
-
-    routeLoc = mDefaultIso7816SeID;
-    power    = mCeRouteStrictDisable ? mDefaultIso7816Powerstate : (mDefaultIso7816Powerstate & POWER_STATE_MASK);
-
-    ALOGV("%s: routeLoc 0x%x", __func__,routeLoc);
-    if (routeLoc  == NFA_HANDLE_INVALID)
-    {
-        ALOGV("%s: Invalid routeLoc. Return.", __func__);
-        return;
-    }
-
-    tNFA_STATUS nfaStat = NFA_EeAddAidRouting(routeLoc, 0, NULL, power, 0x10);
-    ALOGV("%s: Status :0x%2x", __func__, nfaStat);
+  tNFA_STATUS nfaStat = NFA_EeAddAidRouting(routeLoc, 0, NULL, power, 0x10);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Status :0x%2x", __func__, nfaStat);
 }
 #endif
 
 /* Compilation of Tech Table entries strictly based on config file parameters
- * Each entry in tech table consistes of route location, technology and power state
+ * Each entry in tech table consistes of route location, technology and power
+ * state
  * */
-void RoutingManager::compileTechEntries(void)
-{
-    static const char fn []          = "RoutingManager::compileTechEntries";
-    uint32_t techSupportedBySelectedEE = 0;
-    unsigned long num = 0;
-    ALOGV("%s: enter", fn);
-
-    /*Check technologies supported by EE selected in conf file*/
-    if(mDefaultTechASeID == SecureElement::getInstance().EE_HANDLE_0xF4)
-        techSupportedBySelectedEE = mTechSupportedByUicc1;
-    else if(mDefaultTechASeID == ROUTE_LOC_UICC2_ID)
-        techSupportedBySelectedEE = mTechSupportedByUicc2;
-    else if(mDefaultTechASeID == ROUTE_LOC_ESE_ID)
-        techSupportedBySelectedEE = mTechSupportedByEse;
-    else
-        techSupportedBySelectedEE = 0; /*For Host, no tech based route supported as Host always reads protocol data*/
-
-    /*Populate the entries on  tech route table*/
-    mTechTableEntries[TECH_A_IDX].routeLoc = mDefaultTechASeID;
-    mTechTableEntries[TECH_A_IDX].power    = mCeRouteStrictDisable ? mDefaultTechAPowerstate : (mDefaultTechAPowerstate & POWER_STATE_MASK);
-    mTechTableEntries[TECH_A_IDX].enable   = (techSupportedBySelectedEE & NFA_TECHNOLOGY_MASK_A)? true : false;
-
-    /*Reuse the same power state and route location used for A*/
-    mTechTableEntries[TECH_B_IDX].routeLoc = mDefaultTechASeID;
-    mTechTableEntries[TECH_B_IDX].power    = mCeRouteStrictDisable ? mDefaultTechAPowerstate : (mDefaultTechAPowerstate & POWER_STATE_MASK);
-    mTechTableEntries[TECH_B_IDX].enable   = (techSupportedBySelectedEE & NFA_TECHNOLOGY_MASK_B)? true : false;
-
-    /*Update Tech F Route in case there is switch between uicc's*/
-    if(nfcFL.eseFL._ESE_FELICA_CLT) {
-        if (GetNxpNumValue (NAME_DEFAULT_FELICA_CLT_ROUTE, (void*)&num, sizeof(num)))
-        {
-            if(nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC && nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) {
-                if((num == 0x02 || num == 0x03) && sCurrentSelectedUICCSlot)
-                {
-                    mDefaultTechFSeID = getUiccRoute(sCurrentSelectedUICCSlot);
-                }
-                else
-                {
-                    mDefaultTechFSeID = ( (num == 0x01) ? ROUTE_LOC_ESE_ID : ((num == 0x02) ? SecureElement::getInstance().EE_HANDLE_0xF4 : ROUTE_LOC_UICC2_ID) );
-                }
-            }else{
-                mDefaultTechFSeID = ( (num == 0x01) ? ROUTE_LOC_ESE_ID : ((num == 0x02) ? SecureElement::getInstance().EE_HANDLE_0xF4 : ROUTE_LOC_UICC2_ID) );
-            }
-        }
-        else
-        {
-            mDefaultTechFSeID = getUiccRoute(sCurrentSelectedUICCSlot);
-        }
+void RoutingManager::compileTechEntries(void) {
+  static const char fn[] = "RoutingManager::compileTechEntries";
+  uint32_t techSupportedBySelectedEE = 0;
+  unsigned long num = 0;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+
+  /*Check technologies supported by EE selected in conf file*/
+  if (mDefaultTechASeID == SecureElement::getInstance().EE_HANDLE_0xF4)
+    techSupportedBySelectedEE = mTechSupportedByUicc1;
+  else if (mDefaultTechASeID == ROUTE_LOC_UICC2_ID)
+    techSupportedBySelectedEE = mTechSupportedByUicc2;
+  else if (mDefaultTechASeID == ROUTE_LOC_ESE_ID)
+    techSupportedBySelectedEE = mTechSupportedByEse;
+  else
+    techSupportedBySelectedEE =
+        0; /*For Host, no tech based route supported as Host always reads
+              protocol data*/
+
+  /*Populate the entries on  tech route table*/
+  mTechTableEntries[TECH_A_IDX].routeLoc = mDefaultTechASeID;
+  mTechTableEntries[TECH_A_IDX].power =
+      mCeRouteStrictDisable ? mDefaultTechAPowerstate
+                            : (mDefaultTechAPowerstate & POWER_STATE_MASK);
+  mTechTableEntries[TECH_A_IDX].enable =
+      (techSupportedBySelectedEE & NFA_TECHNOLOGY_MASK_A) ? true : false;
+
+  /*Reuse the same power state and route location used for A*/
+  mTechTableEntries[TECH_B_IDX].routeLoc = mDefaultTechASeID;
+  mTechTableEntries[TECH_B_IDX].power =
+      mCeRouteStrictDisable ? mDefaultTechAPowerstate
+                            : (mDefaultTechAPowerstate & POWER_STATE_MASK);
+  mTechTableEntries[TECH_B_IDX].enable =
+      (techSupportedBySelectedEE & NFA_TECHNOLOGY_MASK_B) ? true : false;
+
+  /*Update Tech F Route in case there is switch between uicc's*/
+  if (nfcFL.eseFL._ESE_FELICA_CLT) {
+    if (NfcConfig::hasKey(NAME_DEFAULT_NFCF_ROUTE)) {
+      num = NfcConfig::getUnsigned(NAME_DEFAULT_NFCF_ROUTE);
+      if (nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC &&
+          nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) {
+        if ((num == 0x02 || num == 0x03) && sCurrentSelectedUICCSlot) {
+          mDefaultTechFSeID = getUiccRoute(sCurrentSelectedUICCSlot);
+        } else {
+          mDefaultTechFSeID =
+              ((num == 0x01)
+                   ? ROUTE_LOC_ESE_ID
+                   : ((num == 0x02)
+                          ? SecureElement::getInstance().EE_HANDLE_0xF4
+                          : ROUTE_LOC_UICC2_ID));
+        }
+      } else {
+        mDefaultTechFSeID =
+            ((num == 0x01)
+                 ? ROUTE_LOC_ESE_ID
+                 : ((num == 0x02) ? SecureElement::getInstance().EE_HANDLE_0xF4
+                                  : ROUTE_LOC_UICC2_ID));
+      }
     } else {
-        mDefaultTechFSeID = SecureElement::getInstance().EE_HANDLE_0xF4;
-    }
-
-    /*Check technologies supported by EE selected in conf file - For TypeF*/
-    if(mDefaultTechFSeID == SecureElement::getInstance().EE_HANDLE_0xF4)
-        techSupportedBySelectedEE = mTechSupportedByUicc1;
-    else if(mDefaultTechFSeID == ROUTE_LOC_UICC2_ID)
-        techSupportedBySelectedEE = mTechSupportedByUicc2;
-    else if(mDefaultTechFSeID == ROUTE_LOC_ESE_ID)
-        techSupportedBySelectedEE = mTechSupportedByEse;
-    else
-        techSupportedBySelectedEE = 0;/*For Host, no tech based route supported as Host always reads protocol data*/
-
-    mTechTableEntries[TECH_F_IDX].routeLoc = mDefaultTechFSeID;
-    mTechTableEntries[TECH_F_IDX].power    = mCeRouteStrictDisable ? mDefaultTechFPowerstate : (mDefaultTechFPowerstate & POWER_STATE_MASK);
-    mTechTableEntries[TECH_F_IDX].enable   = (techSupportedBySelectedEE & NFA_TECHNOLOGY_MASK_F)? true : false;
-
-    dumpTables(3);
-    if(((mHostListnTechMask) && (mHostListnTechMask != 0X04)) && (mFwdFuntnEnable == true))
-    {
-        processTechEntriesForFwdfunctionality();
-    }
-    ALOGV("%s: exit", fn);
-}
-
-/* Forward Functionality is to handle either technology which is supported by UICC
+      mDefaultTechFSeID = getUiccRoute(sCurrentSelectedUICCSlot);
+    }
+  } else {
+    mDefaultTechFSeID = (sCurrentSelectedUICCSlot==0x2)?SecureElement::getInstance().EE_HANDLE_0xF8:
+                          SecureElement::getInstance().EE_HANDLE_0xF4;
+  }
+
+  /*Check technologies supported by EE selected in conf file - For TypeF*/
+  if (mDefaultTechFSeID == SecureElement::getInstance().EE_HANDLE_0xF4)
+    techSupportedBySelectedEE = mTechSupportedByUicc1;
+  else if (mDefaultTechFSeID == ROUTE_LOC_UICC2_ID)
+    techSupportedBySelectedEE = mTechSupportedByUicc2;
+  else if (mDefaultTechFSeID == ROUTE_LOC_ESE_ID)
+    techSupportedBySelectedEE = mTechSupportedByEse;
+  else
+    techSupportedBySelectedEE =
+        0; /*For Host, no tech based route supported as Host always reads
+              protocol data*/
+
+  mTechTableEntries[TECH_F_IDX].routeLoc = mDefaultTechFSeID;
+  mTechTableEntries[TECH_F_IDX].power =
+      mCeRouteStrictDisable ? mDefaultTechFPowerstate
+                            : (mDefaultTechFPowerstate & POWER_STATE_MASK);
+  mTechTableEntries[TECH_F_IDX].enable =
+      (techSupportedBySelectedEE & NFA_TECHNOLOGY_MASK_F) ? true : false;
+
+  dumpTables(3);
+  if (((mHostListnTechMask) && (mHostListnTechMask != 0X04)) &&
+      (mFwdFuntnEnable == true)) {
+    processTechEntriesForFwdfunctionality();
+  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
+}
+
+/* Forward Functionality is to handle either technology which is supported by
+ * UICC
  * We are handling it by setting the alternate technology(A/B) to HOST
  * */
-void RoutingManager::processTechEntriesForFwdfunctionality(void)
-{
-    static const char fn []    = "RoutingManager::processTechEntriesForFwdfunctionality";
-    uint32_t techSupportedByUICC = mTechSupportedByUicc1;
-    if(nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC && nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) {
-        techSupportedByUICC = (getUiccRoute(sCurrentSelectedUICCSlot) == SecureElement::getInstance().EE_HANDLE_0xF4)?
-                mTechSupportedByUicc1 : mTechSupportedByUicc2;
-    }
-    else if (nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC) {
-        techSupportedByUICC = (mDefaultTechASeID == SecureElement::getInstance().EE_HANDLE_0xF4)?
-                mTechSupportedByUicc1:mTechSupportedByUicc2;
-    }
-    ALOGV("%s: enter", fn);
-
-    switch(mHostListnTechMask)
-    {
-    case 0x01://Host wants to listen ISO-DEP in A tech only then following cases will arises:-
-        //i.Tech A only UICC present(Dont route Tech B to HOST),
-        //ii.Tech B only UICC present(Route Tech A to HOST),
-        //iii.Tech AB UICC present(Dont route any tech to HOST)
-        if(((mTechTableEntries[TECH_B_IDX].routeLoc == SecureElement::getInstance().EE_HANDLE_0xF4) || (mTechTableEntries[TECH_B_IDX].routeLoc == ROUTE_LOC_UICC2_ID)) &&
-                ((((techSupportedByUICC & NFA_TECHNOLOGY_MASK_B) == 0) && (techSupportedByUICC & NFA_TECHNOLOGY_MASK_A) != 0)))//Tech A only supported UICC
-        {
-            //Tech A will goto UICC according to previous table
-            //Disable Tech B entry as host wants to listen A only
-            mTechTableEntries[TECH_B_IDX].enable   = false;
-        }
-        if(((mTechTableEntries[TECH_A_IDX].routeLoc == SecureElement::getInstance().EE_HANDLE_0xF4) || (mTechTableEntries[TECH_A_IDX].routeLoc == ROUTE_LOC_UICC2_ID)) &&
-                ((((techSupportedByUICC & NFA_TECHNOLOGY_MASK_A) == 0) && (techSupportedByUICC & NFA_TECHNOLOGY_MASK_B) != 0)))//Tech B only supported UICC
-        {
-            //Tech B will goto UICC according to previous table
-            //Route Tech A to HOST as Host wants to listen A only
-            mTechTableEntries[TECH_A_IDX].routeLoc = ROUTE_LOC_HOST_ID;
-            /*Allow only (screen On+unlock) and (screen On+lock) power state when routing to HOST*/
-            mTechTableEntries[TECH_A_IDX].power    = (mTechTableEntries[TECH_A_IDX].power & HOST_SCREEN_STATE_MASK);
-            mTechTableEntries[TECH_A_IDX].enable   = true;
-        }
-        if((techSupportedByUICC & 0x03) == 0x03)//AB both supported UICC
-        {
-            //Do Nothing
-            //Tech A and Tech B will goto according to previous table
-            //HCE A only / HCE-B only functionality wont work in this case
-        }
-        break;
-    case 0x02://Host wants to listen ISO-DEP in B tech only then if Cases: Tech A only UICC present(Route Tech B to HOST), Tech B only UICC present(Dont route Tech A to HOST), Tech AB UICC present(Dont route any tech to HOST)
-        if(((mTechTableEntries[TECH_B_IDX].routeLoc == SecureElement::getInstance().EE_HANDLE_0xF4) || (mTechTableEntries[TECH_B_IDX].routeLoc == ROUTE_LOC_UICC2_ID)) &&
-                ((((techSupportedByUICC & NFA_TECHNOLOGY_MASK_B) == 0) && (techSupportedByUICC & NFA_TECHNOLOGY_MASK_A) != 0)))//Tech A only supported UICC
-        {
-            //Tech A will goto UICC according to previous table
-            //Route Tech B to HOST as host wants to listen B only
-            mTechTableEntries[TECH_B_IDX].routeLoc = ROUTE_LOC_HOST_ID;
-            /*Allow only (screen On+unlock) and (screen On+lock) power state when routing to HOST*/
-            mTechTableEntries[TECH_B_IDX].power    = (mTechTableEntries[TECH_A_IDX].power & HOST_SCREEN_STATE_MASK);
-            mTechTableEntries[TECH_B_IDX].enable   = true;
-        }
-        if(((mTechTableEntries[TECH_A_IDX].routeLoc == SecureElement::getInstance().EE_HANDLE_0xF4) || (mTechTableEntries[TECH_A_IDX].routeLoc == ROUTE_LOC_UICC2_ID)) &&
-                ((((techSupportedByUICC & NFA_TECHNOLOGY_MASK_A) == 0) && (techSupportedByUICC & NFA_TECHNOLOGY_MASK_B) != 0)))//Tech B only supported UICC
-        {
-            //Tech B will goto UICC according to previous table
-            //Disable Tech A to HOST as host wants to listen B only
-            mTechTableEntries[TECH_A_IDX].enable   = false;
-        }
-        if((techSupportedByUICC & 0x03) == 0x03)//AB both supported UICC
-        {
-            //Do Nothing
-            //Tech A and Tech B will goto UICC
-            //HCE A only / HCE-B only functionality wont work in this case
-        }
-        break;
+void RoutingManager::processTechEntriesForFwdfunctionality(void) {
+  static const char fn[] =
+      "RoutingManager::processTechEntriesForFwdfunctionality";
+  uint32_t techSupportedByUICC = mTechSupportedByUicc1;
+  if (nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC &&
+      nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) {
+    techSupportedByUICC = (getUiccRoute(sCurrentSelectedUICCSlot) ==
+                           SecureElement::getInstance().EE_HANDLE_0xF4)
+                              ? mTechSupportedByUicc1
+                              : mTechSupportedByUicc2;
+  } else if (nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC) {
+    techSupportedByUICC =
+        (mDefaultTechASeID == SecureElement::getInstance().EE_HANDLE_0xF4)
+            ? mTechSupportedByUicc1
+            : mTechSupportedByUicc2;
+  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+
+  switch (mHostListnTechMask) {
+    case 0x01:  // Host wants to listen ISO-DEP in A tech only then following
+                // cases will arises:-
+      // i.Tech A only UICC present(Dont route Tech B to HOST),
+      // ii.Tech B only UICC present(Route Tech A to HOST),
+      // iii.Tech AB UICC present(Dont route any tech to HOST)
+      if (((mTechTableEntries[TECH_B_IDX].routeLoc ==
+            SecureElement::getInstance().EE_HANDLE_0xF4) ||
+           (mTechTableEntries[TECH_B_IDX].routeLoc == ROUTE_LOC_UICC2_ID)) &&
+          ((((techSupportedByUICC & NFA_TECHNOLOGY_MASK_B) == 0) &&
+            (techSupportedByUICC & NFA_TECHNOLOGY_MASK_A) !=
+                0)))  // Tech A only supported UICC
+      {
+        // Tech A will goto UICC according to previous table
+        // Disable Tech B entry as host wants to listen A only
+        mTechTableEntries[TECH_B_IDX].enable = false;
+      }
+      if (((mTechTableEntries[TECH_A_IDX].routeLoc ==
+            SecureElement::getInstance().EE_HANDLE_0xF4) ||
+           (mTechTableEntries[TECH_A_IDX].routeLoc == ROUTE_LOC_UICC2_ID)) &&
+          ((((techSupportedByUICC & NFA_TECHNOLOGY_MASK_A) == 0) &&
+            (techSupportedByUICC & NFA_TECHNOLOGY_MASK_B) !=
+                0)))  // Tech B only supported UICC
+      {
+        // Tech B will goto UICC according to previous table
+        // Route Tech A to HOST as Host wants to listen A only
+        mTechTableEntries[TECH_A_IDX].routeLoc = ROUTE_LOC_HOST_ID;
+        /*Allow only (screen On+unlock) and (screen On+lock) power state when
+         * routing to HOST*/
+        mTechTableEntries[TECH_A_IDX].power =
+            (mTechTableEntries[TECH_A_IDX].power & HOST_SCREEN_STATE_MASK);
+        mTechTableEntries[TECH_A_IDX].enable = true;
+      }
+      if ((techSupportedByUICC & 0x03) == 0x03)  // AB both supported UICC
+      {
+        // Do Nothing
+        // Tech A and Tech B will goto according to previous table
+        // HCE A only / HCE-B only functionality wont work in this case
+      }
+      break;
+    case 0x02:  // Host wants to listen ISO-DEP in B tech only then if Cases:
+                // Tech A only UICC present(Route Tech B to HOST), Tech B only
+                // UICC present(Dont route Tech A to HOST), Tech AB UICC
+                // present(Dont route any tech to HOST)
+      if (((mTechTableEntries[TECH_B_IDX].routeLoc ==
+            SecureElement::getInstance().EE_HANDLE_0xF4) ||
+           (mTechTableEntries[TECH_B_IDX].routeLoc == ROUTE_LOC_UICC2_ID)) &&
+          ((((techSupportedByUICC & NFA_TECHNOLOGY_MASK_B) == 0) &&
+            (techSupportedByUICC & NFA_TECHNOLOGY_MASK_A) !=
+                0)))  // Tech A only supported UICC
+      {
+        // Tech A will goto UICC according to previous table
+        // Route Tech B to HOST as host wants to listen B only
+        mTechTableEntries[TECH_B_IDX].routeLoc = ROUTE_LOC_HOST_ID;
+        /*Allow only (screen On+unlock) and (screen On+lock) power state when
+         * routing to HOST*/
+        mTechTableEntries[TECH_B_IDX].power =
+            (mTechTableEntries[TECH_A_IDX].power & HOST_SCREEN_STATE_MASK);
+        mTechTableEntries[TECH_B_IDX].enable = true;
+      }
+      if (((mTechTableEntries[TECH_A_IDX].routeLoc ==
+            SecureElement::getInstance().EE_HANDLE_0xF4) ||
+           (mTechTableEntries[TECH_A_IDX].routeLoc == ROUTE_LOC_UICC2_ID)) &&
+          ((((techSupportedByUICC & NFA_TECHNOLOGY_MASK_A) == 0) &&
+            (techSupportedByUICC & NFA_TECHNOLOGY_MASK_B) !=
+                0)))  // Tech B only supported UICC
+      {
+        // Tech B will goto UICC according to previous table
+        // Disable Tech A to HOST as host wants to listen B only
+        mTechTableEntries[TECH_A_IDX].enable = false;
+      }
+      if ((techSupportedByUICC & 0x03) == 0x03)  // AB both supported UICC
+      {
+        // Do Nothing
+        // Tech A and Tech B will goto UICC
+        // HCE A only / HCE-B only functionality wont work in this case
+      }
+      break;
     case 0x03:
-    case 0x07://Host wants to listen ISO-DEP in AB both tech then if Cases: Tech A only UICC present(Route Tech B to HOST), Tech B only UICC present(Route Tech A to HOST), Tech AB UICC present(Dont route any tech to HOST)
-        /*If selected EE is UICC and it supports Bonly , then Set Tech A to Host */
-        /*Host doesn't support Tech Routing, To enable FWD functionality enabling tech route to Host.*/
-        if(((mTechTableEntries[TECH_A_IDX].routeLoc == SecureElement::getInstance().EE_HANDLE_0xF4) || (mTechTableEntries[TECH_A_IDX].routeLoc == ROUTE_LOC_UICC2_ID)) &&
-                ((((techSupportedByUICC & NFA_TECHNOLOGY_MASK_A) == 0) && (techSupportedByUICC & NFA_TECHNOLOGY_MASK_B) != 0)))
-        {
-            mTechTableEntries[TECH_A_IDX].routeLoc = ROUTE_LOC_HOST_ID;
-            /*Allow only (screen On+unlock) and (screen On+lock) power state when routing to HOST*/
-            mTechTableEntries[TECH_A_IDX].power    = (mTechTableEntries[TECH_A_IDX].power & HOST_SCREEN_STATE_MASK);
-            mTechTableEntries[TECH_A_IDX].enable   = true;
-        }
-        /*If selected EE is UICC and it supports Aonly , then Set Tech B to Host*/
-        if(((mTechTableEntries[TECH_B_IDX].routeLoc == SecureElement::getInstance().EE_HANDLE_0xF4) || (mTechTableEntries[TECH_B_IDX].routeLoc == ROUTE_LOC_UICC2_ID)) &&
-                ((((techSupportedByUICC & NFA_TECHNOLOGY_MASK_B) == 0) && (techSupportedByUICC & NFA_TECHNOLOGY_MASK_A) != 0)))
-        {
-            mTechTableEntries[TECH_B_IDX].routeLoc = ROUTE_LOC_HOST_ID;
-            /*Allow only (screen On+unlock) and (screen On+lock) power state when routing to HOST*/
-            mTechTableEntries[TECH_B_IDX].power    = (mTechTableEntries[TECH_A_IDX].power & HOST_SCREEN_STATE_MASK);
-            mTechTableEntries[TECH_B_IDX].enable   = true;
-        }
-        if((techSupportedByUICC & 0x03) == 0x03)//AB both supported UICC
-        {
-            //Do Nothing
-            //Tech A and Tech B will goto UICC
-            //HCE A only / HCE-B only functionality wont work in this case
-        }
-        break;
-    }
-    dumpTables(3);
-    ALOGV("%s: exit", fn);
+    case 0x07:  // Host wants to listen ISO-DEP in AB both tech then if Cases:
+                // Tech A only UICC present(Route Tech B to HOST), Tech B only
+                // UICC present(Route Tech A to HOST), Tech AB UICC present(Dont
+                // route any tech to HOST)
+      /*If selected EE is UICC and it supports Bonly , then Set Tech A to Host
+       */
+      /*Host doesn't support Tech Routing, To enable FWD functionality enabling
+       * tech route to Host.*/
+      if (((mTechTableEntries[TECH_A_IDX].routeLoc ==
+            SecureElement::getInstance().EE_HANDLE_0xF4) ||
+           (mTechTableEntries[TECH_A_IDX].routeLoc == ROUTE_LOC_UICC2_ID)) &&
+          ((((techSupportedByUICC & NFA_TECHNOLOGY_MASK_A) == 0) &&
+            (techSupportedByUICC & NFA_TECHNOLOGY_MASK_B) != 0))) {
+        mTechTableEntries[TECH_A_IDX].routeLoc = ROUTE_LOC_HOST_ID;
+        /*Allow only (screen On+unlock) and (screen On+lock) power state when
+         * routing to HOST*/
+        mTechTableEntries[TECH_A_IDX].power =
+            (mTechTableEntries[TECH_A_IDX].power & HOST_SCREEN_STATE_MASK);
+        mTechTableEntries[TECH_A_IDX].enable = true;
+      }
+      /*If selected EE is UICC and it supports Aonly , then Set Tech B to Host*/
+      if (((mTechTableEntries[TECH_B_IDX].routeLoc ==
+            SecureElement::getInstance().EE_HANDLE_0xF4) ||
+           (mTechTableEntries[TECH_B_IDX].routeLoc == ROUTE_LOC_UICC2_ID)) &&
+          ((((techSupportedByUICC & NFA_TECHNOLOGY_MASK_B) == 0) &&
+            (techSupportedByUICC & NFA_TECHNOLOGY_MASK_A) != 0))) {
+        mTechTableEntries[TECH_B_IDX].routeLoc = ROUTE_LOC_HOST_ID;
+        /*Allow only (screen On+unlock) and (screen On+lock) power state when
+         * routing to HOST*/
+        mTechTableEntries[TECH_B_IDX].power =
+            (mTechTableEntries[TECH_A_IDX].power & HOST_SCREEN_STATE_MASK);
+        mTechTableEntries[TECH_B_IDX].enable = true;
+      }
+      if ((techSupportedByUICC & 0x03) == 0x03)  // AB both supported UICC
+      {
+        // Do Nothing
+        // Tech A and Tech B will goto UICC
+        // HCE A only / HCE-B only functionality wont work in this case
+      }
+      break;
+  }
+  dumpTables(3);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
 }
 
 /* libnfc-nci takes technologies for each power-state for single route location
- * The previous technologies set will be overwritten by new technologies set by NFA_EeSetDefaultTechRouting
+ * The previous technologies set will be overwritten by new technologies set by
+ * NFA_EeSetDefaultTechRouting
  * So consolidate all the techs/power state for a given NFCEE ID's
  * For example:
  * When Tech A and Tech F set to same EE then set (TechA | Tech F) to that EE.
  */
-void RoutingManager::consolidateTechEntries(void)
-{
-    static const char fn [] = "RoutingManager::consolidateTechEntries";
-    ALOGV("%s: enter", fn);
-    int index=-1;
-    for(int xx=0;xx<MAX_TECH_ENTRIES;xx++)
-    {
-        if(mTechTableEntries[xx].enable)
-        {
-            switch(mTechTableEntries[xx].routeLoc)
-            {
-                case ROUTE_LOC_HOST_ID:
-                        index = ROUTE_LOC_HOST_ID_IDX;
-                    break;
-                case ROUTE_LOC_ESE_ID:
-                        index = ROUTE_LOC_ESE_ID_IDX;
-                    break;
-                case ROUTE_LOC_UICC1_ID:
-                case ROUTE_LOC_UICC1_ID_NCI2_0:
-                        index = ROUTE_LOC_UICC1_ID_IDX;
-                    break;
-                case ROUTE_LOC_UICC2_ID:
-                        index = ROUTE_LOC_UICC2_ID_IDX;
-                    break;
-            }
-            if(index != -1)
-            {
-                mLmrtEntries[index].tech_switch_on    = mLmrtEntries[index].tech_switch_on |
-                                                        ((mTechTableEntries[xx].power & PWR_SWTCH_ON_SCRN_UNLCK_MASK)? mTechTableEntries[xx].technology:0);
-                mLmrtEntries[index].tech_switch_off   = mLmrtEntries[index].tech_switch_off |
-                                                        ((mTechTableEntries[xx].power & PWR_SWTCH_OFF_MASK)? mTechTableEntries[xx].technology:0);
-                mLmrtEntries[index].tech_battery_off  = mLmrtEntries[index].tech_battery_off |
-                                                        ((mTechTableEntries[xx].power & PWR_BATT_OFF_MASK)? mTechTableEntries[xx].technology:0);
-                mLmrtEntries[index].tech_screen_lock  = mLmrtEntries[index].tech_screen_lock |
-                                                        ((mTechTableEntries[xx].power & PWR_SWTCH_ON_SCRN_LOCK_MASK)? mTechTableEntries[xx].technology:0);
-                mLmrtEntries[index].tech_screen_off   = mLmrtEntries[index].tech_screen_off |
-                                                        ((mTechTableEntries[xx].power & PWR_SWTCH_ON_SCRN_OFF_MASK)? mTechTableEntries[xx].technology:0);
-                mLmrtEntries[index].tech_screen_off_lock   = mLmrtEntries[index].tech_screen_off_lock |
-                                                        ((mTechTableEntries[xx].power & PWR_SWTCH_ON_SCRN_OFF_LOCK_MASK)? mTechTableEntries[xx].technology:0);
-            }
-        }
-    }
-    dumpTables(4);
-    ALOGV("%s: exit", fn);
-}
-
-void RoutingManager::setTechRouting(void)
-{
-    static const char fn [] = "RoutingManager::setTechRouting";
-    tNFA_STATUS nfaStat     = NFA_STATUS_FAILED;
-    ALOGV("%s: enter", fn);
-    SyncEventGuard guard (mRoutingEvent);
-    for(int xx=0;xx<MAX_ROUTE_LOC_ENTRIES;xx++)
-   {
-       if( mLmrtEntries[xx].nfceeID          &&
-           (mLmrtEntries[xx].tech_switch_on   ||
-            mLmrtEntries[xx].tech_switch_off  ||
-            mLmrtEntries[xx].tech_battery_off ||
-            mLmrtEntries[xx].tech_screen_lock ||
-            mLmrtEntries[xx].tech_screen_off  ||
-            mLmrtEntries[xx].tech_screen_off_lock) )
-        {
-            /*Clear technologies for NFCEE ID control block */
-            ALOGV("%s: Clear Routing Entries for nfceeID:0x%X", fn, mLmrtEntries[xx].nfceeID);
-            nfaStat = NFA_EeSetDefaultTechRouting(mLmrtEntries[xx].nfceeID, 0, 0, 0, 0, 0,0);
-            if(nfaStat == NFA_STATUS_OK)
-            {
-                mRoutingEvent.wait ();
-            }
-            else
-            {
-                ALOGE("Fail to clear tech routing to 0x%x",mLmrtEntries[xx].nfceeID);
-            }
-
-            /*Set Required technologies for NFCEE ID control block */
-            nfaStat = NFA_EeSetDefaultTechRouting(mLmrtEntries[xx].nfceeID,
-                                                  mLmrtEntries[xx].tech_switch_on,
-                                                  mLmrtEntries[xx].tech_switch_off,
-                                                  mLmrtEntries[xx].tech_battery_off,
-                                                  mLmrtEntries[xx].tech_screen_lock,
-                                                  mLmrtEntries[xx].tech_screen_off,
-                                                  mLmrtEntries[xx].tech_screen_off_lock);
-            if(nfaStat == NFA_STATUS_OK)
-            {
-                mRoutingEvent.wait ();
-            }
-            else
-            {
-                ALOGE("Fail to set tech routing to 0x%x",mLmrtEntries[xx].nfceeID);
-            }
-        }
-    }
-    ALOGV("%s: exit", fn);
-}
-
-void RoutingManager::dumpTables(int xx)
-{
-
-
-    switch(xx)
-    {
-    case 1://print only proto table
-        ALOGV("--------------------Proto Table Entries------------------" );
-        for(int xx=0;xx<AVAILABLE_PROTO_ENTRIES();xx++)
-        {
-            ALOGV("|Index=%d|RouteLoc=0x%03X|Proto=0x%02X|Power=0x%02X|Enable=0x%01X|",
-                    xx,mProtoTableEntries[xx].routeLoc,
-                    mProtoTableEntries[xx].protocol,
-                    mProtoTableEntries[xx].power,
-                    mProtoTableEntries[xx].enable);
-        }
-        ALOGV("---------------------------------------------------------" );
-        break;
-    case 2://print Lmrt proto table
-        ALOGV("----------------------------------------Lmrt Proto Entries------------------------------------" );
-        for(int xx=0;xx<AVAILABLE_PROTO_ENTRIES();xx++)
-        {
-            ALOGV("|Index=%d|nfceeID=0x%03X|SWTCH-ON=0x%02X|SWTCH-OFF=0x%02X|BAT-OFF=0x%02X|SCRN-LOCK=0x%02X|SCRN-OFF=0x%02X|SCRN-OFF_LOCK=0x%02X",
-                    xx,
-                    mLmrtEntries[xx].nfceeID,
-                    mLmrtEntries[xx].proto_switch_on,
-                    mLmrtEntries[xx].proto_switch_off,
-                    mLmrtEntries[xx].proto_battery_off,
-                    mLmrtEntries[xx].proto_screen_lock,
-                    mLmrtEntries[xx].proto_screen_off,
-                    mLmrtEntries[xx].proto_screen_off_lock);
-        }
-        ALOGV("----------------------------------------------------------------------------------------------" );
-        break;
-    case 3://print only tech table
-        ALOGV("--------------------Tech Table Entries------------------" );
-        for(int xx=0;xx<MAX_TECH_ENTRIES;xx++)
-        {
-            ALOGV("|Index=%d|RouteLoc=0x%03X|Tech=0x%02X|Power=0x%02X|Enable=0x%01X|",
-                    xx,
-                    mTechTableEntries[xx].routeLoc,
-                    mTechTableEntries[xx].technology,
-                    mTechTableEntries[xx].power,
-                    mTechTableEntries[xx].enable);
-        }
-        ALOGV("--------------------------------------------------------" );
-        break;
-    case 4://print Lmrt tech table
-        ALOGV("-----------------------------------------Lmrt Tech Entries------------------------------------" );
-        for(int xx=0;xx<MAX_TECH_ENTRIES;xx++)
-        {
-            ALOGV("|Index=%d|nfceeID=0x%03X|SWTCH-ON=0x%02X|SWTCH-OFF=0x%02X|BAT-OFF=0x%02X|SCRN-LOCK=0x%02X|SCRN-OFF=0x%02X|SCRN-OFF_LOCK=0x%02X",
-                    xx,
-                    mLmrtEntries[xx].nfceeID,
-                    mLmrtEntries[xx].tech_switch_on,
-                    mLmrtEntries[xx].tech_switch_off,
-                    mLmrtEntries[xx].tech_battery_off,
-                    mLmrtEntries[xx].tech_screen_lock,
-                    mLmrtEntries[xx].tech_screen_off,
-                    mLmrtEntries[xx].tech_screen_off_lock);
-        }
-        ALOGV("----------------------------------------------------------------------------------------------" );
-        break;
-    }
+void RoutingManager::consolidateTechEntries(void) {
+  static const char fn[] = "RoutingManager::consolidateTechEntries";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+  int index = -1;
+  for (int xx = 0; xx < MAX_TECH_ENTRIES; xx++) {
+    if (mTechTableEntries[xx].enable) {
+      switch (mTechTableEntries[xx].routeLoc) {
+        case ROUTE_LOC_HOST_ID:
+          index = ROUTE_LOC_HOST_ID_IDX;
+          break;
+        case ROUTE_LOC_ESE_ID:
+          index = ROUTE_LOC_ESE_ID_IDX;
+          break;
+        case ROUTE_LOC_UICC1_ID:
+        case ROUTE_LOC_UICC1_ID_NCI2_0:
+          index = ROUTE_LOC_UICC1_ID_IDX;
+          break;
+        case ROUTE_LOC_UICC2_ID:
+          index = ROUTE_LOC_UICC2_ID_IDX;
+          break;
+      }
+      if (index != -1) {
+        mLmrtEntries[index].tech_switch_on =
+            mLmrtEntries[index].tech_switch_on |
+            ((mTechTableEntries[xx].power & PWR_SWTCH_ON_SCRN_UNLCK_MASK)
+                 ? mTechTableEntries[xx].technology
+                 : 0);
+        mLmrtEntries[index].tech_switch_off =
+            mLmrtEntries[index].tech_switch_off |
+            ((mTechTableEntries[xx].power & PWR_SWTCH_OFF_MASK)
+                 ? mTechTableEntries[xx].technology
+                 : 0);
+        mLmrtEntries[index].tech_battery_off =
+            mLmrtEntries[index].tech_battery_off |
+            ((mTechTableEntries[xx].power & PWR_BATT_OFF_MASK)
+                 ? mTechTableEntries[xx].technology
+                 : 0);
+        mLmrtEntries[index].tech_screen_lock =
+            mLmrtEntries[index].tech_screen_lock |
+            ((mTechTableEntries[xx].power & PWR_SWTCH_ON_SCRN_LOCK_MASK)
+                 ? mTechTableEntries[xx].technology
+                 : 0);
+        mLmrtEntries[index].tech_screen_off =
+            mLmrtEntries[index].tech_screen_off |
+            ((mTechTableEntries[xx].power & PWR_SWTCH_ON_SCRN_OFF_MASK)
+                 ? mTechTableEntries[xx].technology
+                 : 0);
+        mLmrtEntries[index].tech_screen_off_lock =
+            mLmrtEntries[index].tech_screen_off_lock |
+            ((mTechTableEntries[xx].power & PWR_SWTCH_ON_SCRN_OFF_LOCK_MASK)
+                 ? mTechTableEntries[xx].technology
+                 : 0);
+      }
+    }
+  }
+  dumpTables(4);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
+}
+
+void RoutingManager::setTechRouting(void) {
+  static const char fn[] = "RoutingManager::setTechRouting";
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+  SyncEventGuard guard(mRoutingEvent);
+  for (int xx = 0; xx < MAX_ROUTE_LOC_ENTRIES; xx++) {
+    if (mLmrtEntries[xx].nfceeID &&
+        (mLmrtEntries[xx].tech_switch_on || mLmrtEntries[xx].tech_switch_off ||
+         mLmrtEntries[xx].tech_battery_off ||
+         mLmrtEntries[xx].tech_screen_lock ||
+         mLmrtEntries[xx].tech_screen_off ||
+         mLmrtEntries[xx].tech_screen_off_lock)) {
+      /*Clear technologies for NFCEE ID control block */
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: Clear Routing Entries for nfceeID:0x%X", fn,
+                          mLmrtEntries[xx].nfceeID);
+      nfaStat = NFA_EeSetDefaultTechRouting(mLmrtEntries[xx].nfceeID, 0, 0, 0,
+                                            0, 0, 0);
+      if (nfaStat == NFA_STATUS_OK) {
+        mRoutingEvent.wait();
+      } else {
+        LOG(ERROR) << StringPrintf("Fail to clear tech routing to 0x%x",
+                                   mLmrtEntries[xx].nfceeID);
+      }
+
+      /*Set Required technologies for NFCEE ID control block */
+      nfaStat = NFA_EeSetDefaultTechRouting(
+          mLmrtEntries[xx].nfceeID, mLmrtEntries[xx].tech_switch_on,
+          mLmrtEntries[xx].tech_switch_off, mLmrtEntries[xx].tech_battery_off,
+          mLmrtEntries[xx].tech_screen_lock, mLmrtEntries[xx].tech_screen_off,
+          mLmrtEntries[xx].tech_screen_off_lock);
+      if (nfaStat == NFA_STATUS_OK) {
+        mRoutingEvent.wait();
+      } else {
+        LOG(ERROR) << StringPrintf("Fail to set tech routing to 0x%x",
+                                   mLmrtEntries[xx].nfceeID);
+      }
+    }
+  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
+}
+
+void RoutingManager::dumpTables(int xx) {
+  switch (xx) {
+    case 1:  // print only proto table
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "--------------------Proto Table Entries------------------");
+      for (int xx = 0; xx < AVAILABLE_PROTO_ENTRIES(); xx++) {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "|Index=%d|RouteLoc=0x%03X|Proto=0x%02X|Power=0x%02X|Enable=0x%"
+            "01X|",
+            xx, mProtoTableEntries[xx].routeLoc,
+            mProtoTableEntries[xx].protocol, mProtoTableEntries[xx].power,
+            mProtoTableEntries[xx].enable);
+      }
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "---------------------------------------------------------");
+      break;
+    case 2:  // print Lmrt proto table
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "----------------------------------------Lmrt Proto "
+          "Entries------------------------------------");
+      for (int xx = 0; xx < AVAILABLE_PROTO_ENTRIES(); xx++) {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "|Index=%d|nfceeID=0x%03X|SWTCH-ON=0x%02X|SWTCH-OFF=0x%02X|BAT-OFF="
+            "0x%02X|SCRN-LOCK=0x%02X|SCRN-OFF=0x%02X|SCRN-OFF_LOCK=0x%02X",
+            xx, mLmrtEntries[xx].nfceeID, mLmrtEntries[xx].proto_switch_on,
+            mLmrtEntries[xx].proto_switch_off,
+            mLmrtEntries[xx].proto_battery_off,
+            mLmrtEntries[xx].proto_screen_lock,
+            mLmrtEntries[xx].proto_screen_off,
+            mLmrtEntries[xx].proto_screen_off_lock);
+      }
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "--------------------------------------------------------------------"
+          "--------------------------");
+      break;
+    case 3:  // print only tech table
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "--------------------Tech Table Entries------------------");
+      for (int xx = 0; xx < MAX_TECH_ENTRIES; xx++) {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "|Index=%d|RouteLoc=0x%03X|Tech=0x%02X|Power=0x%02X|Enable=0x%01X|",
+            xx, mTechTableEntries[xx].routeLoc,
+            mTechTableEntries[xx].technology, mTechTableEntries[xx].power,
+            mTechTableEntries[xx].enable);
+      }
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "--------------------------------------------------------");
+      break;
+    case 4:  // print Lmrt tech table
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "-----------------------------------------Lmrt Tech "
+          "Entries------------------------------------");
+      for (int xx = 0; xx < MAX_TECH_ENTRIES; xx++) {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "|Index=%d|nfceeID=0x%03X|SWTCH-ON=0x%02X|SWTCH-OFF=0x%02X|BAT-OFF="
+            "0x%02X|SCRN-LOCK=0x%02X|SCRN-OFF=0x%02X|SCRN-OFF_LOCK=0x%02X",
+            xx, mLmrtEntries[xx].nfceeID, mLmrtEntries[xx].tech_switch_on,
+            mLmrtEntries[xx].tech_switch_off, mLmrtEntries[xx].tech_battery_off,
+            mLmrtEntries[xx].tech_screen_lock, mLmrtEntries[xx].tech_screen_off,
+            mLmrtEntries[xx].tech_screen_off_lock);
+      }
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "--------------------------------------------------------------------"
+          "--------------------------");
+      break;
+  }
 }
 #endif
 
-#if(NXP_EXTNS == TRUE)
-bool RoutingManager::setRoutingEntry(int type, int value, int route, int power)
-{
-    static const char fn [] = "RoutingManager::setRoutingEntry";
-    ALOGV("%s: enter, type:0x%x value =0x%x route:%x power:0x%x", fn, type, value ,route, power);
-    unsigned long max_tech_mask = 0x03;
-    unsigned long uiccListenTech = 0;
-    SecureElement &se = SecureElement::getInstance();
-    max_tech_mask = SecureElement::getInstance().getSETechnology(se.EE_HANDLE_0xF4);
-    ALOGV("%s: enter,max_tech_mask :%lx", fn, max_tech_mask);
-
-    tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
-    tNFA_HANDLE ee_handle = NFA_HANDLE_INVALID;
-    SyncEventGuard guard (mRoutingEvent);
-    uint8_t switch_on_mask = 0x00;
-    uint8_t switch_off_mask   = 0x00;
-    uint8_t battery_off_mask = 0x00;
-    uint8_t screen_lock_mask = 0x00;
-    uint8_t screen_off_mask = 0x00;
-    uint8_t protocol_mask = 0x00;
-    uint8_t screen_off_lock_mask = 0x00;
-
-    ee_handle = (( route == 0x01)? SecureElement::EE_HANDLE_0xF3 : (( route == 0x02)? se.EE_HANDLE_0xF4 : NFA_HANDLE_INVALID));
-    if(0x00 == route)
-    {
-        ee_handle = 0x400;
-    }
-    if(ee_handle == NFA_HANDLE_INVALID )
-    {
-        ALOGV("%s: enter, handle:%x invalid", fn, ee_handle);
-        return nfaStat;
-    }
-
-    tNFA_HANDLE ActDevHandle = NFA_HANDLE_INVALID;
-    uint8_t count,seId=0;
-    uint8_t isSeIDPresent = 0;
-    tNFA_HANDLE ee_handleList[nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED];
-    SecureElement::getInstance().getEeHandleList(ee_handleList, &count);
-
-
-    for (int  i = 0; ((count != 0 ) && (i < count)); i++)
-    {
-        seId = SecureElement::getInstance().getGenericEseId(ee_handleList[i]);
-        ActDevHandle = SecureElement::getInstance().getEseHandleFromGenericId(seId);
-        ALOGV("%s: enter, ee_handleList[%d]:%x", fn, i,ee_handleList[i]);
-        if ((ee_handle != 0x400) &&
-            (ee_handle == ActDevHandle))
-        {
-            isSeIDPresent =1;
-            break;
-        }
-    }
-
-    if(!isSeIDPresent)
-    {
-        ee_handle = 0x400;
-    }
-
-    if(NFA_SET_TECHNOLOGY_ROUTING == type)
-    {
-        switch_on_mask    = (power & 0x01) ? value : 0;
-        switch_off_mask   = (power & 0x02) ? value : 0;
-        battery_off_mask  = (power & 0x04) ? value : 0;
-        screen_off_mask   = (power & 0x08) ? value : 0;
-        screen_lock_mask  = (power & 0x10) ? value : 0;
-        screen_off_lock_mask = (power & 0x20) ? value : 0;
-
-        if(mHostListnTechMask > 0 && mFwdFuntnEnable == true)
-        {
-            if((max_tech_mask != 0x01) && (max_tech_mask == 0x02))
-            {
-                switch_on_mask &= ~NFA_TECHNOLOGY_MASK_A;
-                switch_off_mask &= ~NFA_TECHNOLOGY_MASK_A;
-                battery_off_mask &= ~NFA_TECHNOLOGY_MASK_A;
-                screen_off_mask &= ~NFA_TECHNOLOGY_MASK_A;
-                screen_lock_mask &= ~NFA_TECHNOLOGY_MASK_A;
-
-                if(mCeRouteStrictDisable == 0x01)
-                {
-                    nfaStat =  NFA_EeSetDefaultTechRouting (0x400,
-                                                            NFA_TECHNOLOGY_MASK_A,
-                                                            0,
-                                                            0,
-                                                            NFA_TECHNOLOGY_MASK_A,
-                                                            0,
-                                                            0);
-                }else{
-                    nfaStat =  NFA_EeSetDefaultTechRouting (0x400,
-                                                            NFA_TECHNOLOGY_MASK_A,
-                                                            0, 0, 0, 0,0 );
-                }
-                if (nfaStat == NFA_STATUS_OK)
-                   mRoutingEvent.wait ();
-                else
-                {
-                    ALOGE("Fail to set tech routing");
-                }
-            }
-            else if((max_tech_mask == 0x01) && (max_tech_mask != 0x02))
-            {
-                switch_on_mask &= ~NFA_TECHNOLOGY_MASK_B;
-                switch_off_mask &= ~NFA_TECHNOLOGY_MASK_B;
-                battery_off_mask &= ~NFA_TECHNOLOGY_MASK_B;
-                screen_off_mask &= ~NFA_TECHNOLOGY_MASK_B;
-                screen_lock_mask &= ~NFA_TECHNOLOGY_MASK_B;
-
-                if(mCeRouteStrictDisable == 0x01)
-                {
-                    nfaStat =  NFA_EeSetDefaultTechRouting (0x400,
-                                                           NFA_TECHNOLOGY_MASK_B,
-                                                           0,
-                                                           0,
-                                                           NFA_TECHNOLOGY_MASK_B,
-                                                           0,
-                                                           0);
-                }else{
-                    nfaStat =  NFA_EeSetDefaultTechRouting (0x400,
-                                                           NFA_TECHNOLOGY_MASK_B,
-                                                           0, 0, 0, 0 ,0);
-                }
-                if (nfaStat == NFA_STATUS_OK)
-                   mRoutingEvent.wait ();
-                else
-                {
-                    ALOGE("Fail to set tech routing");
-                }
-            }
-        }
-
-        nfaStat = NFA_EeSetDefaultTechRouting (ee_handle, switch_on_mask, switch_off_mask, battery_off_mask, screen_lock_mask, screen_off_mask, screen_off_lock_mask);
-        if(nfaStat == NFA_STATUS_OK){
-            mRoutingEvent.wait ();
-            ALOGV("tech routing SUCCESS");
-        }
-        else{
-            ALOGE("Fail to set default tech routing");
-        }
-    }else if(NFA_SET_PROTOCOL_ROUTING == type)
-    {
-        if( value == 0x01)
-            protocol_mask = NFA_PROTOCOL_MASK_ISO_DEP;
-        if( value == 0x02)
-            protocol_mask = NFA_PROTOCOL_MASK_NFC_DEP;
-        if( value == 0x04)
-            protocol_mask = NFA_PROTOCOL_MASK_T3T;
-
-        switch_on_mask     = (power & 0x01) ? protocol_mask : 0;
-        switch_off_mask    = (power & 0x02) ? protocol_mask : 0;
-        battery_off_mask   = (power & 0x04) ? protocol_mask : 0;
-        screen_lock_mask   = (power & 0x10) ? protocol_mask : 0;
-        screen_off_mask    = (power & 0x08) ? protocol_mask : 0;
-        screen_off_lock_mask    = (power & 0x20) ? protocol_mask : 0;
-        registerProtoRouteEntry(ee_handle, switch_on_mask, switch_off_mask, battery_off_mask, screen_lock_mask, screen_off_mask, screen_off_lock_mask);
-    }
-
-    if ((GetNumValue(NAME_UICC_LISTEN_TECH_MASK, &uiccListenTech, sizeof(uiccListenTech))))
-    {
-         ALOGV("%s:UICC_TECH_MASK=0x0%lu;", __func__, uiccListenTech);
-    }
-    if((ActDevHandle != NFA_HANDLE_INVALID)  &&  (0 != uiccListenTech))
-    {
-         {
-               SyncEventGuard guard (SecureElement::getInstance().mUiccListenEvent);
-               nfaStat = NFA_CeConfigureUiccListenTech (ActDevHandle, 0x00);
-               if (nfaStat == NFA_STATUS_OK)
-               {
-                     SecureElement::getInstance().mUiccListenEvent.wait ();
-               }
-               else
-                     ALOGE("fail to start UICC listen");
-         }
-         {
-               SyncEventGuard guard (SecureElement::getInstance().mUiccListenEvent);
-               nfaStat = NFA_CeConfigureUiccListenTech (ActDevHandle, (uiccListenTech & 0x07));
-               if(nfaStat == NFA_STATUS_OK)
-               {
-                     SecureElement::getInstance().mUiccListenEvent.wait ();
-               }
-               else
-                     ALOGE("fail to start UICC listen");
-         }
-    }
+#if (NXP_EXTNS == TRUE)
+bool RoutingManager::setRoutingEntry(int type, int value, int route,
+                                     int power) {
+  static const char fn[] = "RoutingManager::setRoutingEntry";
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter, type:0x%x value =0x%x route:%x power:0x%x",
+                      fn, type, value, route, power);
+  unsigned long max_tech_mask = 0x03;
+  unsigned long uiccListenTech = 0;
+  SecureElement& se = SecureElement::getInstance();
+  max_tech_mask =
+      SecureElement::getInstance().getSETechnology(se.EE_HANDLE_0xF4);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter,max_tech_mask :%lx", fn, max_tech_mask);
+
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+  tNFA_HANDLE ee_handle = NFA_HANDLE_INVALID;
+  SyncEventGuard guard(mRoutingEvent);
+  uint8_t switch_on_mask = 0x00;
+  uint8_t switch_off_mask = 0x00;
+  uint8_t battery_off_mask = 0x00;
+  uint8_t screen_lock_mask = 0x00;
+  uint8_t screen_off_mask = 0x00;
+  uint8_t protocol_mask = 0x00;
+  uint8_t screen_off_lock_mask = 0x00;
+
+  ee_handle = ((route == 0x01) ? SecureElement::EE_HANDLE_0xF3
+                               : ((route == 0x02) ? se.EE_HANDLE_0xF4
+                                                  : NFA_HANDLE_INVALID));
+  if (0x00 == route) {
+    ee_handle = 0x400;
+  }
+  if (ee_handle == NFA_HANDLE_INVALID) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: enter, handle:%x invalid", fn, ee_handle);
     return nfaStat;
-}
-
-bool RoutingManager::clearRoutingEntry(int type)
-{
-    static const char fn [] = "RoutingManager::clearRoutingEntry";
-    ALOGV("%s: enter, type:0x%x", fn, type );
-    tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
-    //tNFA_HANDLE ee_handle = NFA_HANDLE_INVLAID;
-    SecureElement &se = SecureElement::getInstance();
-    memset(&gRouteInfo, 0x00, sizeof(RouteInfo_t));
-    SyncEventGuard guard (mRoutingEvent);
-    if(NFA_SET_TECHNOLOGY_ROUTING & type)
-    {
-        nfaStat = NFA_EeSetDefaultTechRouting (0x400, 0x00, 0x00, 0x00, 0x00, 0x00,0x00);
-        if(nfaStat == NFA_STATUS_OK){
-            mRoutingEvent.wait ();
-            ALOGV("tech routing SUCCESS");
-        }
-        else{
-            ALOGE("Fail to set default tech routing");
+  }
+
+  tNFA_HANDLE ActDevHandle = NFA_HANDLE_INVALID;
+  uint8_t count, seId = 0;
+  uint8_t isSeIDPresent = 0;
+  tNFA_HANDLE ee_handleList[nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED];
+  SecureElement::getInstance().getEeHandleList(ee_handleList, &count);
+
+  for (int i = 0; ((count != 0) && (i < count)); i++) {
+    seId = SecureElement::getInstance().getGenericEseId(ee_handleList[i]);
+    ActDevHandle = SecureElement::getInstance().getEseHandleFromGenericId(seId);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: enter, ee_handleList[%d]:%x", fn, i, ee_handleList[i]);
+    if ((ee_handle != 0x400) && (ee_handle == ActDevHandle)) {
+      isSeIDPresent = 1;
+      break;
+    }
+  }
+
+  if (!isSeIDPresent) {
+    ee_handle = 0x400;
+  }
+
+  if (NFA_SET_TECHNOLOGY_ROUTING == type) {
+    switch_on_mask = (power & 0x01) ? value : 0;
+    switch_off_mask = (power & 0x02) ? value : 0;
+    battery_off_mask = (power & 0x04) ? value : 0;
+    screen_off_mask = (power & 0x08) ? value : 0;
+    screen_lock_mask = (power & 0x10) ? value : 0;
+    screen_off_lock_mask = (power & 0x20) ? value : 0;
+
+    if (mHostListnTechMask > 0 && mFwdFuntnEnable == true) {
+      if ((max_tech_mask != 0x01) && (max_tech_mask == 0x02)) {
+        switch_on_mask &= ~NFA_TECHNOLOGY_MASK_A;
+        switch_off_mask &= ~NFA_TECHNOLOGY_MASK_A;
+        battery_off_mask &= ~NFA_TECHNOLOGY_MASK_A;
+        screen_off_mask &= ~NFA_TECHNOLOGY_MASK_A;
+        screen_lock_mask &= ~NFA_TECHNOLOGY_MASK_A;
+
+        if (mCeRouteStrictDisable == 0x01) {
+          nfaStat = NFA_EeSetDefaultTechRouting(0x400, NFA_TECHNOLOGY_MASK_A, 0,
+                                                0, NFA_TECHNOLOGY_MASK_A, 0, 0);
+        } else {
+          nfaStat = NFA_EeSetDefaultTechRouting(0x400, NFA_TECHNOLOGY_MASK_A, 0,
+                                                0, 0, 0, 0);
         }
-        nfaStat = NFA_EeSetDefaultTechRouting (se.EE_HANDLE_0xF4, 0x00, 0x00, 0x00, 0x00, 0x00,0x00);
-        if(nfaStat == NFA_STATUS_OK){
-            mRoutingEvent.wait ();
-            ALOGV("tech routing SUCCESS");
-        }
-        else{
-            ALOGE("Fail to set default tech routing");
-        }
-        nfaStat = NFA_EeSetDefaultTechRouting (SecureElement::EE_HANDLE_0xF3, 0x00, 0x00, 0x00, 0x00, 0x00,0x00);
-        if(nfaStat == NFA_STATUS_OK){
-            mRoutingEvent.wait ();
-            ALOGV("tech routing SUCCESS");
-        }
-        else{
-            ALOGE("Fail to set default tech routing");
+        if (nfaStat == NFA_STATUS_OK)
+          mRoutingEvent.wait();
+        else {
+          LOG(ERROR) << StringPrintf("Fail to set tech routing");
+        }
+      } else if ((max_tech_mask == 0x01) && (max_tech_mask != 0x02)) {
+        switch_on_mask &= ~NFA_TECHNOLOGY_MASK_B;
+        switch_off_mask &= ~NFA_TECHNOLOGY_MASK_B;
+        battery_off_mask &= ~NFA_TECHNOLOGY_MASK_B;
+        screen_off_mask &= ~NFA_TECHNOLOGY_MASK_B;
+        screen_lock_mask &= ~NFA_TECHNOLOGY_MASK_B;
+
+        if (mCeRouteStrictDisable == 0x01) {
+          nfaStat = NFA_EeSetDefaultTechRouting(0x400, NFA_TECHNOLOGY_MASK_B, 0,
+                                                0, NFA_TECHNOLOGY_MASK_B, 0, 0);
+        } else {
+          nfaStat = NFA_EeSetDefaultTechRouting(0x400, NFA_TECHNOLOGY_MASK_B, 0,
+                                                0, 0, 0, 0);
         }
-        if(nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH && nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC) {
-            nfaStat = NFA_EeSetDefaultTechRouting (SecureElement::EE_HANDLE_0xF8, 0x00, 0x00, 0x00, 0x00, 0x00,0x00);
-            if(nfaStat == NFA_STATUS_OK){
-                mRoutingEvent.wait ();
-                ALOGV("tech routing SUCCESS");
-            }
-            else{
-                ALOGE("Fail to set default tech routing");
-            }
+        if (nfaStat == NFA_STATUS_OK)
+          mRoutingEvent.wait();
+        else {
+          LOG(ERROR) << StringPrintf("Fail to set tech routing");
         }
+      }
     }
 
-    if(NFA_SET_PROTOCOL_ROUTING & type)
-    {
-        nfaStat = NFA_EeSetDefaultProtoRouting (0x400, 0x00, 0x00, 0x00, 0x00 ,0x00,0x00);
-        if(nfaStat == NFA_STATUS_OK){
-            mRoutingEvent.wait ();
-            ALOGV("protocol routing SUCCESS");
-        }
-        else{
-            ALOGE("Fail to set default protocol routing");
-        }
-        nfaStat = NFA_EeSetDefaultProtoRouting (se.EE_HANDLE_0xF4, 0x00, 0x00, 0x00, 0x00, 0x00,0x00);
-        if(nfaStat == NFA_STATUS_OK){
-            mRoutingEvent.wait ();
-            ALOGV("protocol routing SUCCESS");
-        }
-        else{
-            ALOGE("Fail to set default protocol routing");
-        }
-        nfaStat = NFA_EeSetDefaultProtoRouting (SecureElement::EE_HANDLE_0xF3, 0x00, 0x00, 0x00, 0x00, 0x00,0x00);
-        if(nfaStat == NFA_STATUS_OK){
-            mRoutingEvent.wait ();
-            ALOGV("protocol routing SUCCESS");
-        }
-        else{
-            ALOGE("Fail to set default protocol routing");
-        }
-        if(nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH && nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC) {
-            nfaStat = NFA_EeSetDefaultProtoRouting (SecureElement::EE_HANDLE_0xF8, 0x00, 0x00, 0x00, 0x00, 0x00,0x00);
-            if(nfaStat == NFA_STATUS_OK){
-                mRoutingEvent.wait ();
-                ALOGV("protocol routing SUCCESS");
-            }
-            else{
-                ALOGE("Fail to set default protocol routing");
-            }
-        }
+    nfaStat = NFA_EeSetDefaultTechRouting(
+        ee_handle, switch_on_mask, switch_off_mask, battery_off_mask,
+        screen_lock_mask, screen_off_mask, screen_off_lock_mask);
+    if (nfaStat == NFA_STATUS_OK) {
+      mRoutingEvent.wait();
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("tech routing SUCCESS");
+    } else {
+      LOG(ERROR) << StringPrintf("Fail to set default tech routing");
+    }
+  } else if (NFA_SET_PROTOCOL_ROUTING == type) {
+    if (value == 0x01) protocol_mask = NFA_PROTOCOL_MASK_ISO_DEP;
+    if (value == 0x02) protocol_mask = NFA_PROTOCOL_MASK_NFC_DEP;
+    if (value == 0x04) protocol_mask = NFA_PROTOCOL_MASK_T3T;
+
+    switch_on_mask = (power & 0x01) ? protocol_mask : 0;
+    switch_off_mask = (power & 0x02) ? protocol_mask : 0;
+    battery_off_mask = (power & 0x04) ? protocol_mask : 0;
+    screen_lock_mask = (power & 0x10) ? protocol_mask : 0;
+    screen_off_mask = (power & 0x08) ? protocol_mask : 0;
+    screen_off_lock_mask = (power & 0x20) ? protocol_mask : 0;
+    registerProtoRouteEntry(ee_handle, switch_on_mask, switch_off_mask,
+                            battery_off_mask, screen_lock_mask, screen_off_mask,
+                            screen_off_lock_mask);
+  }
+
+  if (NfcConfig::hasKey(NAME_UICC_LISTEN_TECH_MASK)) {
+    uiccListenTech = NfcConfig::getUnsigned(NAME_UICC_LISTEN_TECH_MASK);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s:UICC_TECH_MASK=0x0%lu;", __func__, uiccListenTech);
+  }
+
+  if ((ActDevHandle != NFA_HANDLE_INVALID) && (0 != uiccListenTech)) {
+    {
+      SyncEventGuard guard(SecureElement::getInstance().mUiccListenEvent);
+      nfaStat = NFA_CeConfigureUiccListenTech(ActDevHandle, 0x00);
+      if (nfaStat == NFA_STATUS_OK) {
+        SecureElement::getInstance().mUiccListenEvent.wait();
+      } else
+        LOG(ERROR) << StringPrintf("fail to start UICC listen");
+    }
+    {
+      SyncEventGuard guard(SecureElement::getInstance().mUiccListenEvent);
+      nfaStat =
+          NFA_CeConfigureUiccListenTech(ActDevHandle, (uiccListenTech & 0x07));
+      if (nfaStat == NFA_STATUS_OK) {
+        SecureElement::getInstance().mUiccListenEvent.wait();
+      } else
+        LOG(ERROR) << StringPrintf("fail to start UICC listen");
+    }
+  }
+  return nfaStat;
+}
+
+bool RoutingManager::clearRoutingEntry(int type) {
+  static const char fn[] = "RoutingManager::clearRoutingEntry";
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter, type:0x%x", fn, type);
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+  // tNFA_HANDLE ee_handle = NFA_HANDLE_INVLAID;
+  SecureElement& se = SecureElement::getInstance();
+  memset(&gRouteInfo, 0x00, sizeof(RouteInfo_t));
+  SyncEventGuard guard(mRoutingEvent);
+  if (NFA_SET_TECHNOLOGY_ROUTING & type) {
+    nfaStat =
+        NFA_EeSetDefaultTechRouting(0x400, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+    if (nfaStat == NFA_STATUS_OK) {
+      mRoutingEvent.wait();
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("tech routing SUCCESS");
+    } else {
+      LOG(ERROR) << StringPrintf("Fail to set default tech routing");
     }
-
-    if (NFA_SET_AID_ROUTING & type)
-    {
-        clearAidTable();
+    nfaStat = NFA_EeSetDefaultTechRouting(se.EE_HANDLE_0xF4, 0x00, 0x00, 0x00,
+                                          0x00, 0x00, 0x00);
+    if (nfaStat == NFA_STATUS_OK) {
+      mRoutingEvent.wait();
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("tech routing SUCCESS");
+    } else {
+      LOG(ERROR) << StringPrintf("Fail to set default tech routing");
     }
-    return nfaStat;
-}
-#endif
-#if(NXP_EXTNS == TRUE)
-bool RoutingManager::addAidRouting(const uint8_t* aid, uint8_t aidLen, int route, int power, int aidInfo)
-#else
-bool RoutingManager::addAidRouting(const uint8_t* aid, uint8_t aidLen, int route)
-#endif
-{
-    static const char fn [] = "RoutingManager::addAidRouting";
-    ALOGV("%s: enter", fn);
-#if(NXP_EXTNS == TRUE)
-    tNFA_HANDLE handle;
-    tNFA_HANDLE current_handle;
-    SecureElement &se = SecureElement::getInstance();
-    ALOGV("%s: enter, route:%x power:0x%x aidInfo:%x", fn, route, power, aidInfo);
-    handle = SecureElement::getInstance().getEseHandleFromGenericId(route);
-    ALOGV("%s: enter, route:%x", fn, handle);
-    if (handle  == NFA_HANDLE_INVALID)
-    {
-        return false;
-    }
-    if(mAddAid == 0x00)
-    {
-        ALOGV("%s: enter, mAddAid set to 0 from config file, ignoring all aids", fn);
-        return false;
-    }
-    if(nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC) {
-        current_handle = ((handle == SecureElement::EE_HANDLE_0xF3)?0xF3:(handle == se.EE_HANDLE_0xF4)?SecureElement::UICC_ID:SecureElement::UICC2_ID);
-    }
-    else
-        current_handle = ((handle == SecureElement::EE_HANDLE_0xF3)?SecureElement::ESE_ID:SecureElement::UICC_ID);
-
-    if(handle == 0x400)
-        current_handle = 0x00;
-
-    ALOGV("%s: enter, mDefaultEe:%x", fn, current_handle);
-    //SecureElement::getInstance().activate(current_handle);
-    // Set power config
-
-
-    SyncEventGuard guard(SecureElement::getInstance().mAidAddRemoveEvent);
-
-    tNFA_STATUS nfaStat = NFA_EeAddAidRouting(handle, aidLen, (uint8_t*) aid, power, aidInfo);
-#else
-    tNFA_STATUS nfaStat = NFA_EeAddAidRouting(route, aidLen, (uint8_t*) aid, 0x01);
-#endif
-    if (nfaStat == NFA_STATUS_OK)
-    {
-        //        ALOGV("%s: routed AID", fn);
-#if(NXP_EXTNS == TRUE)
-        SecureElement::getInstance().mAidAddRemoveEvent.wait();
-#endif
-        return true;
-    } else
-    {
-        ALOGE("%s: failed to route AID",fn);
-        return false;
-    }
-}
-
-bool RoutingManager::removeAidRouting(const uint8_t* aid, uint8_t aidLen)
-{
-    static const char fn [] = "RoutingManager::removeAidRouting";
-    ALOGV("%s: enter", fn);
-    SyncEventGuard guard(SecureElement::getInstance().mAidAddRemoveEvent);
-    tNFA_STATUS nfaStat = NFA_EeRemoveAidRouting(aidLen, (uint8_t*) aid);
-    if (nfaStat == NFA_STATUS_OK)
-    {
-        SecureElement::getInstance().mAidAddRemoveEvent.wait();
-        ALOGV("%s: removed AID", fn);
-        return true;
-    } else
-    {
-        ALOGE("%s: failed to remove AID",fn);
-        return false;
-    }
-}
-
-bool RoutingManager::addApduRouting(uint8_t route, uint8_t powerState,const uint8_t* apduData,
-     uint8_t apduDataLen ,const uint8_t* apduMask, uint8_t apduMaskLen)
-{
-    static const char fn [] = "RoutingManager::addApduRouting";
-    ALOGV("%s: enter, route:%x power:0x%x", fn, route, powerState);
-#if(NXP_EXTNS == TRUE)
-    SecureElement &se = SecureElement::getInstance();
-    tNFA_HANDLE handle = se.getEseHandleFromGenericId(route);
-    ALOGV("%s: enter, route:%x", fn, handle);
-    if (handle  == NFA_HANDLE_INVALID)
-    {
-        return false;
-    }
-#endif
-    SyncEventGuard guard(SecureElement::getInstance().mApduPaternAddRemoveEvent);
-    tNFA_STATUS nfaStat = NFA_EeAddApduPatternRouting(apduDataLen, (uint8_t*)apduData, apduMaskLen, (uint8_t*)apduMask, handle, powerState);
-    if (nfaStat == NFA_STATUS_OK)
-    {
-#if(NXP_EXTNS == TRUE)
-        SecureElement::getInstance().mApduPaternAddRemoveEvent.wait();
-#endif
-        ALOGV("%s: routed APDU pattern successfully", fn);
-    }
-    return ((nfaStat == NFA_STATUS_OK)?true:false);
-}
-
-bool RoutingManager::removeApduRouting(uint8_t apduDataLen, const uint8_t* apduData)
-{
-    static const char fn [] = "RoutingManager::removeApduRouting";
-    ALOGV("%s: enter", fn);
-    SyncEventGuard guard(SecureElement::getInstance().mApduPaternAddRemoveEvent);
-    tNFA_STATUS nfaStat = NFA_EeRemoveApduPatternRouting(apduDataLen, (uint8_t*) apduData);
-    if (nfaStat == NFA_STATUS_OK)
-    {
-        SecureElement::getInstance().mApduPaternAddRemoveEvent.wait();
-        ALOGV("%s: removed APDU pattern successfully", fn);
-    }
-    return ((nfaStat == NFA_STATUS_OK)?true:false);
-}
-
-#if(NXP_EXTNS == TRUE)
-void RoutingManager::setDefaultTechRouting (int seId, int tech_switchon,int tech_switchoff)
-{
-    SecureElement &se = SecureElement::getInstance();
-    ALOGV("ENTER setDefaultTechRouting");
-    tNFA_STATUS nfaStat;
-    /*// !!! CLEAR ALL REGISTERED TECHNOLOGIES !!!*/
-    {
-        SyncEventGuard guard (mRoutingEvent);
-        tNFA_STATUS status =  NFA_EeSetDefaultTechRouting(0x400,0,0,0,0,0,0); //HOST clear
-        if(status == NFA_STATUS_OK)
-        {
-            mRoutingEvent.wait ();
-        }
-    }
-
-    {
-        SyncEventGuard guard (mRoutingEvent);
-        tNFA_STATUS status =  NFA_EeSetDefaultTechRouting(se.EE_HANDLE_0xF4,0,0,0,0,0,0); //UICC clear
-        if(status == NFA_STATUS_OK)
-        {
-           mRoutingEvent.wait ();
-        }
-    }
-
-    {
-        SyncEventGuard guard (mRoutingEvent);
-        tNFA_STATUS status =  NFA_EeSetDefaultTechRouting(SecureElement::EE_HANDLE_0xF3,0,0,0,0,0,0); //SMX clear
-        if(status == NFA_STATUS_OK)
-        {
-           mRoutingEvent.wait ();
-        }
-    }
-
-    if(nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH ||
-            nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC)
-    {
-        SyncEventGuard guard (mRoutingEvent);
-        tNFA_STATUS status =  NFA_EeSetDefaultTechRouting(SecureElement::EE_HANDLE_0xF8,0,0,0,0,0,0); //SMX clear
-        if(status == NFA_STATUS_OK)
-        {
-            mRoutingEvent.wait ();
-        }
-    }
-
-    {
-        SyncEventGuard guard (mRoutingEvent);
-        if(mCeRouteStrictDisable == 0x01)
-        {
-            nfaStat = NFA_EeSetDefaultTechRouting (seId, tech_switchon, tech_switchoff, 0, NFA_TECHNOLOGY_MASK_A | NFA_TECHNOLOGY_MASK_B, NFA_TECHNOLOGY_MASK_A | NFA_TECHNOLOGY_MASK_B,NFA_TECHNOLOGY_MASK_A | NFA_TECHNOLOGY_MASK_B);
-        }else{
-            nfaStat = NFA_EeSetDefaultTechRouting (seId, tech_switchon, tech_switchoff, 0, 0, 0,0);
-        }
-        if(nfaStat == NFA_STATUS_OK)
-        {
-           mRoutingEvent.wait ();
-           ALOGV("tech routing SUCCESS");
-        }
-        else
-        {
-            ALOGE("Fail to set default tech routing");
-        }
-    }
-
-    nfaStat = NFA_EeUpdateNow();
-    if (nfaStat != NFA_STATUS_OK){
-        ALOGE("Failed to commit routing configuration");
-    }
-}
-
-void RoutingManager::setDefaultProtoRouting (int seId, int proto_switchon,int proto_switchoff)
-{
-    tNFA_STATUS nfaStat;
-    ALOGV("ENTER setDefaultProtoRouting");
-    SyncEventGuard guard (mRoutingEvent);
-    if(mCeRouteStrictDisable == 0x01)
-    {
-        nfaStat = NFA_EeSetDefaultProtoRouting (seId, proto_switchon, proto_switchoff, 0, NFA_PROTOCOL_MASK_ISO_DEP, NFA_PROTOCOL_MASK_ISO_DEP, NFA_PROTOCOL_MASK_ISO_DEP);
-    }else{
-        nfaStat = NFA_EeSetDefaultProtoRouting (seId, proto_switchon, proto_switchoff, 0, 0, 0,0);
-    }
-    if(nfaStat == NFA_STATUS_OK){
-        mRoutingEvent.wait ();
-        ALOGV("proto routing SUCCESS");
-    }
-    else{
-        ALOGE("Fail to set default proto routing");
-    }
-//    nfaStat = NFA_EeUpdateNow();
-//    if (nfaStat != NFA_STATUS_OK){
-//        ALOGE("Failed to commit routing configuration");
-//    }
-}
-
-bool RoutingManager::clearAidTable ()
-{
-    static const char fn [] = "RoutingManager::clearAidTable";
-    ALOGV("%s: enter", fn);
-    SyncEventGuard guard(SecureElement::getInstance().mAidAddRemoveEvent);
-    tNFA_STATUS nfaStat = NFA_EeRemoveAidRouting(NFA_REMOVE_ALL_AID_LEN, (uint8_t*) NFA_REMOVE_ALL_AID);
-    if (nfaStat == NFA_STATUS_OK)
-    {
-        SecureElement::getInstance().mAidAddRemoveEvent.wait();
-        ALOGV("%s: removed AID", fn);
-        return true;
-    } else
-    {
-        ALOGE("%s: failed to remove AID", fn);
-        return false;
-    }
-}
-
-
-#endif
-
-bool RoutingManager::commitRouting()
-{
-    static const char fn [] = "RoutingManager::commitRouting";
-    tNFA_STATUS nfaStat = 0;
-    ALOGV("%s", fn);
-    {
-        RoutingManager::getInstance().LmrtRspTimer.set(1000, LmrtRspTimerCb);
-        SyncEventGuard guard (mEeUpdateEvent);
-        nfaStat = NFA_EeUpdateNow();
-        if (nfaStat == NFA_STATUS_OK)
-        {
-            mEeUpdateEvent.wait (); //wait for NFA_EE_UPDATED_EVT
-        }
-    }
-    return (nfaStat == NFA_STATUS_OK);
-}
-
-void RoutingManager::onNfccShutdown ()
-{
-    static const char fn [] = "RoutingManager:onNfccShutdown";
-    tNFA_STATUS nfaStat     = NFA_STATUS_FAILED;
-    uint8_t actualNumEe       = nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED;
-    tNFA_EE_INFO eeInfo[actualNumEe];
-
-    if (mActiveSe == 0x00)
-        return;
-
-    memset (&eeInfo, 0, sizeof(eeInfo));
-
-    if ((nfaStat = NFA_EeGetInfo (&actualNumEe, eeInfo)) != NFA_STATUS_OK)
-    {
-        ALOGE("%s: fail get info; error=0x%X", fn, nfaStat);
-        return;
-    }
-    if (actualNumEe != 0)
-    {
-        for (uint8_t xx = 0; xx < actualNumEe; xx++)
-        {
-            if ((eeInfo[xx].ee_interface[0] != NCI_NFCEE_INTERFACE_HCI_ACCESS)
-                && (eeInfo[xx].ee_status == NFA_EE_STATUS_ACTIVE))
-            {
-                ALOGV("%s: Handle: 0x%04x Change Status Active to Inactive", fn, eeInfo[xx].ee_handle);
-#if(NXP_EXTNS == TRUE)
-                if ((nfaStat = SecureElement::getInstance().SecElem_EeModeSet (eeInfo[xx].ee_handle, NFA_EE_MD_DEACTIVATE)) != NFA_STATUS_OK)
-#endif
-                {
-                    ALOGE("Failed to set EE inactive");
-                }
-            }
-        }
-    }
-    else
-    {
-        ALOGV("%s: No active EEs found", fn);
-    }
-}
-
-void RoutingManager::notifyActivated (uint8_t technology)
-{
-    JNIEnv* e = NULL;
-    ScopedAttach attach(mNativeData->vm, &e);
-    if (e == NULL)
-    {
-        ALOGE("jni env is null");
-        return;
-    }
-
-    e->CallVoidMethod (mNativeData->manager, android::gCachedNfcManagerNotifyHostEmuActivated, (int)technology);
-    if (e->ExceptionCheck())
-    {
-        e->ExceptionClear();
-        ALOGE("fail notify");
-    }
-}
-
-void RoutingManager::notifyDeactivated (uint8_t technology)
-{
-    SecureElement::getInstance().notifyListenModeState (false);
-    mRxDataBuffer.clear();
-    JNIEnv* e = NULL;
-    ScopedAttach attach(mNativeData->vm, &e);
-    if (e == NULL)
-    {
-        ALOGE("jni env is null");
-        return;
-    }
-
-    e->CallVoidMethod (mNativeData->manager, android::gCachedNfcManagerNotifyHostEmuDeactivated, (int)technology);
-    if (e->ExceptionCheck())
-    {
-        e->ExceptionClear();
-        ALOGE("fail notify");
-    }
-}
-
-void RoutingManager::notifyLmrtFull ()
-{
-    JNIEnv* e = NULL;
-    ScopedAttach attach(mNativeData->vm, &e);
-    if (e == NULL)
-    {
-        ALOGE("jni env is null");
-        return;
-    }
-
-    e->CallVoidMethod (mNativeData->manager, android::gCachedNfcManagerNotifyAidRoutingTableFull);
-    if (e->ExceptionCheck())
-    {
-        e->ExceptionClear();
-        ALOGE("fail notify");
-    }
-}
-#if(NXP_EXTNS == TRUE)
-void RoutingManager::nfcFRspTimerCb(union sigval)
-{
-    if(!nfcFL.nfccFL._NXP_NFCC_EMPTY_DATA_PACKET) {
-        ALOGV("%s; NFCC_EMPTY_DATA_PACKET not available.Returning", __func__);
-        return;
-    }
-    static const char fn[] = "RoutingManager::nfcFRspTimerCb";
-    ALOGV("%s; enter", fn);
-    if(android::gIsEmptyRspSentByHceFApk)
-        android::gIsEmptyRspSentByHceFApk = false;
-    else
-        android::nfcManager_sendEmptyDataMsg();
-    ALOGV("%s; exit", fn);
+    nfaStat = NFA_EeSetDefaultTechRouting(SecureElement::EE_HANDLE_0xF3, 0x00,
+                                          0x00, 0x00, 0x00, 0x00, 0x00);
+    if (nfaStat == NFA_STATUS_OK) {
+      mRoutingEvent.wait();
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("tech routing SUCCESS");
+    } else {
+      LOG(ERROR) << StringPrintf("Fail to set default tech routing");
+    }
+    if (nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH &&
+        nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC) {
+      nfaStat = NFA_EeSetDefaultTechRouting(SecureElement::EE_HANDLE_0xF8, 0x00,
+                                            0x00, 0x00, 0x00, 0x00, 0x00);
+      if (nfaStat == NFA_STATUS_OK) {
+        mRoutingEvent.wait();
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("tech routing SUCCESS");
+      } else {
+        LOG(ERROR) << StringPrintf("Fail to set default tech routing");
+      }
+    }
+  }
+
+  if (NFA_SET_PROTOCOL_ROUTING & type) {
+    nfaStat =
+        NFA_EeSetDefaultProtoRouting(0x400, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+    if (nfaStat == NFA_STATUS_OK) {
+      mRoutingEvent.wait();
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("protocol routing SUCCESS");
+    } else {
+      LOG(ERROR) << StringPrintf("Fail to set default protocol routing");
+    }
+    nfaStat = NFA_EeSetDefaultProtoRouting(se.EE_HANDLE_0xF4, 0x00, 0x00, 0x00,
+                                           0x00, 0x00, 0x00);
+    if (nfaStat == NFA_STATUS_OK) {
+      mRoutingEvent.wait();
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("protocol routing SUCCESS");
+    } else {
+      LOG(ERROR) << StringPrintf("Fail to set default protocol routing");
+    }
+    nfaStat = NFA_EeSetDefaultProtoRouting(SecureElement::EE_HANDLE_0xF3, 0x00,
+                                           0x00, 0x00, 0x00, 0x00, 0x00);
+    if (nfaStat == NFA_STATUS_OK) {
+      mRoutingEvent.wait();
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("protocol routing SUCCESS");
+    } else {
+      LOG(ERROR) << StringPrintf("Fail to set default protocol routing");
+    }
+    if (nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH &&
+        nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC) {
+      nfaStat = NFA_EeSetDefaultProtoRouting(
+          SecureElement::EE_HANDLE_0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+      if (nfaStat == NFA_STATUS_OK) {
+        mRoutingEvent.wait();
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("protocol routing SUCCESS");
+      } else {
+        LOG(ERROR) << StringPrintf("Fail to set default protocol routing");
+      }
+    }
+  }
+
+  if (NFA_SET_AID_ROUTING & type) {
+    clearAidTable();
+  }
+  return nfaStat;
 }
 #endif
-
-void RoutingManager::handleData (uint8_t technology, const uint8_t* data, uint32_t dataLen, tNFA_STATUS status)
-{
-
-    if (status == NFA_STATUS_CONTINUE)
-    {
-        ALOGE("jni env is null");
-        if (dataLen > 0)
-        {
-            mRxDataBuffer.insert (mRxDataBuffer.end(), &data[0], &data[dataLen]); //append data; more to come
-        }
-        return; //expect another NFA_CE_DATA_EVT to come
-    }
-    else if (status == NFA_STATUS_OK)
-    {
-        if (dataLen > 0)
-        {
-            mRxDataBuffer.insert (mRxDataBuffer.end(), &data[0], &data[dataLen]); //append data
-#if(NXP_EXTNS == TRUE)
-            if (nfcFL.nfccFL._NXP_NFCC_EMPTY_DATA_PACKET &&
-                    (technology == NFA_TECHNOLOGY_MASK_F))
-            {
-                bool ret = false;
-                ret = mNfcFRspTimer.set(mDefaultHCEFRspTimeout, nfcFRspTimerCb);
-                if(!ret)
-                    ALOGV("%s; rsp timer create failed", __func__);
-            }
-#endif
-        }
-        //entire data packet has been received; no more NFA_CE_DATA_EVT
-    }
-    else if (status == NFA_STATUS_FAILED)
-    {
-        ALOGE("RoutingManager::handleData: read data fail");
-        goto TheEnd;
-    }
-    {
-        JNIEnv* e = NULL;
-        ScopedAttach attach(mNativeData->vm, &e);
-        if (e == NULL)
-        {
-            ALOGE("jni env is null");
-            goto TheEnd;
-        }
-
-        ScopedLocalRef<jobject> dataJavaArray(e, e->NewByteArray(mRxDataBuffer.size()));
-        if (dataJavaArray.get() == NULL)
-        {
-            ALOGE("fail allocate array");
-            goto TheEnd;
-        }
-
-        e->SetByteArrayRegion ((jbyteArray)dataJavaArray.get(), 0, mRxDataBuffer.size(),
-                (jbyte *)(&mRxDataBuffer[0]));
-        if (e->ExceptionCheck())
-        {
-            e->ExceptionClear();
-            ALOGE("fail fill array");
-            goto TheEnd;
-        }
-
-        e->CallVoidMethod (mNativeData->manager, android::gCachedNfcManagerNotifyHostEmuData,
-             (int)technology, dataJavaArray.get());
-        if (e->ExceptionCheck())
-        {
-            e->ExceptionClear();
-            ALOGE("fail notify");
-        }
-
-    }
-TheEnd:
-    mRxDataBuffer.clear();
-}
-
-void RoutingManager::stackCallback (uint8_t event, tNFA_CONN_EVT_DATA* eventData)
-{
-    static const char fn [] = "RoutingManager::stackCallback";
-    ALOGV("%s: event=0x%X", fn, event);
-    RoutingManager& routingManager = RoutingManager::getInstance();
-
-    SecureElement& se = SecureElement::getInstance();
-
-    switch (event)
-    {
-    case NFA_CE_REGISTERED_EVT:
-        {
-            tNFA_CE_REGISTERED& ce_registered = eventData->ce_registered;
-            ALOGV("%s: NFA_CE_REGISTERED_EVT; status=0x%X; h=0x%X", fn, ce_registered.status, ce_registered.handle);
-            SyncEventGuard guard (routingManager.mCeRegisterEvent);
-            if(ce_registered.status == NFA_STATUS_OK)
-            {
-                lastcehandle = ce_registered.handle;
-            }
-            else
-            {
-                lastcehandle = 0xFF;
-            }
-            routingManager.mCeRegisterEvent.notifyOne();
-        }
-        break;
-
-    case NFA_CE_DEREGISTERED_EVT:
-        {
-            tNFA_CE_DEREGISTERED& ce_deregistered = eventData->ce_deregistered;
-            ALOGV("%s: NFA_CE_DEREGISTERED_EVT; h=0x%X", fn, ce_deregistered.handle);
-            SyncEventGuard guard (routingManager.mCeDeRegisterEvent);
-            routingManager.mCeDeRegisterEvent.notifyOne();
-        }
-        break;
-
-    case NFA_CE_ACTIVATED_EVT:
-        {
 #if (NXP_EXTNS == TRUE)
-            android::rfActivation = true;
+bool RoutingManager::addAidRouting(const uint8_t* aid, uint8_t aidLen,
+                                   int route, int power, int aidInfo)
+#else
+bool RoutingManager::addAidRouting(const uint8_t* aid, uint8_t aidLen,
+                                   int route, int aidInfo)
 #endif
-            android::checkforTranscation(NFA_CE_ACTIVATED_EVT, (void *)eventData);
-            routingManager.notifyActivated(NFA_TECHNOLOGY_MASK_A);
-        }
-        break;
-    case NFA_DEACTIVATED_EVT:
-    case NFA_CE_DEACTIVATED_EVT:
-    {
-        android::checkforTranscation(NFA_CE_DEACTIVATED_EVT, (void *)eventData);
-        routingManager.notifyDeactivated(NFA_TECHNOLOGY_MASK_A);
-        if (nfcFL.nfcNxpEse && nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION &&
-                (se.mIsWiredModeOpen && se.mPassiveListenEnabled))
-        {
-            se.startThread(0x00);
-        }
-    }
+{
+  static const char fn[] = "RoutingManager::addAidRouting";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+  __attribute__((unused)) uint8_t powerState =
+      (route == mDefaultOffHostRoute) ? mOffHostAidRoutingPowerState : 0x01;
 #if (NXP_EXTNS == TRUE)
-        android::rfActivation = false;
+  tNFA_HANDLE handle;
+  tNFA_HANDLE current_handle;
+  SecureElement& se = SecureElement::getInstance();
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: enter, route:%x power:0x%x aidInfo:%x", fn, route, power, aidInfo);
+  handle = SecureElement::getInstance().getEseHandleFromGenericId(route);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter, route:%x", fn, handle);
+  if (handle == NFA_HANDLE_INVALID) {
+    return false;
+  }
+  if (mAddAid == 0x00) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: enter, mAddAid set to 0 from config file, ignoring all aids", fn);
+    return false;
+  }
+  if (nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC) {
+    current_handle =
+        ((handle == SecureElement::EE_HANDLE_0xF3)
+             ? 0xF3
+             : (handle == se.EE_HANDLE_0xF4) ? SecureElement::UICC_ID
+                                             : SecureElement::UICC2_ID);
+  } else
+    current_handle =
+        ((handle == SecureElement::EE_HANDLE_0xF3) ? SecureElement::ESE_ID
+                                                   : SecureElement::UICC_ID);
+
+  if (handle == 0x400) current_handle = 0x00;
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter, mDefaultEe:%x", fn, current_handle);
+  // SecureElement::getInstance().activate(current_handle);
+  // Set power config
+
+  SyncEventGuard guard(SecureElement::getInstance().mAidAddRemoveEvent);
+
+  tNFA_STATUS nfaStat =
+      NFA_EeAddAidRouting(handle, aidLen, (uint8_t*)aid, power, aidInfo);
+#else
+  tNFA_STATUS nfaStat =
+      NFA_EeAddAidRouting(route, aidLen, (uint8_t*)aid, powerState, aidInfo);
 #endif
-        break;
-    case NFA_CE_DATA_EVT:
-        {
+  if (nfaStat == NFA_STATUS_OK) {
+//        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: routed AID",
+//        fn);
 #if (NXP_EXTNS == TRUE)
-            if(nfcFL.nfcNxpEse && nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION &&
-                    (nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME != nfcFL.eseFL._ESE_WIRED_MODE_RESUME)) {
-                se.setDwpTranseiveState(false, NFCC_CE_DATA_EVT);
-            }
+    SecureElement::getInstance().mAidAddRemoveEvent.wait();
 #endif
-            tNFA_CE_DATA& ce_data = eventData->ce_data;
-            ALOGV("%s: NFA_CE_DATA_EVT; stat=0x%X; h=0x%X; data len=%u", fn, ce_data.status, ce_data.handle, ce_data.len);
-            getInstance().handleData(NFA_TECHNOLOGY_MASK_A, ce_data.p_data, ce_data.len, ce_data.status);
-        }
-        break;
-    }
-}
-/*******************************************************************************
-**
-** Function:        nfaEeCallback
-**
-** Description:     Receive execution environment-related events from stack.
-**                  event: Event code.
-**                  eventData: Event data.
-**
-** Returns:         None
-**
-*******************************************************************************/
-void RoutingManager::nfaEeCallback (tNFA_EE_EVT event, tNFA_EE_CBACK_DATA* eventData)
-{
-    static const char fn [] = "RoutingManager::nfaEeCallback";
-
-    SecureElement& se = SecureElement::getInstance();
-    RoutingManager& routingManager = RoutingManager::getInstance();
-    tNFA_EE_DISCOVER_REQ info;
-
-    switch (event)
-    {
-    case NFA_EE_REGISTER_EVT:
-        {
-            SyncEventGuard guard (routingManager.mEeRegisterEvent);
-            ALOGV("%s: NFA_EE_REGISTER_EVT; status=%u", fn, eventData->ee_register);
-            routingManager.mEeRegisterEvent.notifyOne();
-        }
-        break;
-
-    case NFA_EE_MODE_SET_EVT:
-        {
-            SyncEventGuard guard (routingManager.mEeSetModeEvent);
-            ALOGV("%s: NFA_EE_MODE_SET_EVT; status: 0x%04X  handle: 0x%04X  mActiveEeHandle: 0x%04X", fn,
-                    eventData->mode_set.status, eventData->mode_set.ee_handle, se.mActiveEeHandle);
-            routingManager.mEeSetModeEvent.notifyOne();
-            se.notifyModeSet(eventData->mode_set.ee_handle, !(eventData->mode_set.status),eventData->mode_set.ee_status );
-        }
-        break;
+    return true;
+  } else {
+    LOG(ERROR) << StringPrintf("%s: failed to route AID", fn);
+    return false;
+  }
+}
+
+bool RoutingManager::removeAidRouting(const uint8_t* aid, uint8_t aidLen) {
+  static const char fn[] = "RoutingManager::removeAidRouting";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+  SyncEventGuard guard(SecureElement::getInstance().mAidAddRemoveEvent);
+  tNFA_STATUS nfaStat = NFA_EeRemoveAidRouting(aidLen, (uint8_t*)aid);
+  if (nfaStat == NFA_STATUS_OK) {
+    SecureElement::getInstance().mAidAddRemoveEvent.wait();
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: removed AID", fn);
+    return true;
+  } else {
+    LOG(ERROR) << StringPrintf("%s: failed to remove AID", fn);
+    return false;
+  }
+}
+
+bool RoutingManager::addApduRouting(uint8_t route, uint8_t powerState,
+                                    const uint8_t* apduData,
+                                    uint8_t apduDataLen,
+                                    const uint8_t* apduMask,
+                                    uint8_t apduMaskLen) {
+  static const char fn[] = "RoutingManager::addApduRouting";
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter, route:%x power:0x%x", fn, route, powerState);
 #if (NXP_EXTNS == TRUE)
-    case NFA_EE_SET_MODE_INFO_EVT:
-    {
-        ALOGV("%s: NFA_EE_SET_MODE_INFO_EVT; nfcee_id = 0x%02x, status: 0x%04X ", fn,
-            eventData->ee_set_mode_info.nfcee_id, eventData->ee_set_mode_info.status);
-        se.mModeSetInfo = eventData->ee_set_mode_info.status;
-        if(eventData->ee_set_mode_info.nfcee_id == (se.EE_HANDLE_0xF3 & ~NFA_HANDLE_GROUP_EE))
-        {
-            recovery = false;
-            SyncEventGuard guard (se.mModeSetNtf);
-            se.mModeSetNtf.notifyOne();
-        }
-    }
-        break;
-
-    case NFA_EE_DISCONNECT_EVT:
-        {
-            ALOGV("%s: NFA_EE_DISCONNECT_EVT received", fn);
-            SyncEventGuard guard(routingManager.mEEDisconnectEvt);
-            routingManager.mEEDisconnectEvt.notifyOne();
-        }
-        break;
-
-    case NFA_EE_PWR_LINK_CTRL_EVT:
-        if(nfcFL.eseFL._WIRED_MODE_STANDBY) {
-            ALOGV("%s: NFA_EE_PWR_LINK_CTRL_EVT; status: 0x%04X ", fn,
-                    eventData->pwr_lnk_ctrl.status);
-            se.mPwrCmdstatus = eventData->pwr_lnk_ctrl.status;
-            SyncEventGuard guard (se.mPwrLinkCtrlEvent);
-            se.mPwrLinkCtrlEvent.notifyOne();
-        }
-        break;
+  SecureElement& se = SecureElement::getInstance();
+  tNFA_HANDLE handle = se.getEseHandleFromGenericId(route);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter, route:%x", fn, handle);
+  if (handle == NFA_HANDLE_INVALID) {
+    return false;
+  }
 #endif
-    case NFA_EE_SET_TECH_CFG_EVT:
-        {
-            ALOGV("%s: NFA_EE_SET_TECH_CFG_EVT; status=0x%X", fn, eventData->status);
-            SyncEventGuard guard(routingManager.mRoutingEvent);
-            routingManager.mRoutingEvent.notifyOne();
-        }
-        break;
-
-    case NFA_EE_SET_PROTO_CFG_EVT:
-        {
-            ALOGV("%s: NFA_EE_SET_PROTO_CFG_EVT; status=0x%X", fn, eventData->status);
-            SyncEventGuard guard(routingManager.mRoutingEvent);
-            routingManager.mRoutingEvent.notifyOne();
-        }
-        break;
-
-    case NFA_EE_ACTION_EVT:
-        {
-            tNFA_EE_ACTION& action = eventData->action;
-            tNFC_APP_INIT& app_init = action.param.app_init;
-            android::checkforTranscation(NFA_EE_ACTION_EVT, (void *)eventData);
-
-            if (action.trigger == NFC_EE_TRIG_SELECT)
-            {
-                ALOGV("%s: NFA_EE_ACTION_EVT; h=0x%X; trigger=select (0x%X); aid len=%u", fn, action.ee_handle, action.trigger, app_init.len_aid);
-            }
-            else if (action.trigger == NFC_EE_TRIG_APP_INIT)
-            {
-                ALOGV("%s: NFA_EE_ACTION_EVT; h=0x%X; trigger=app-init (0x%X); aid len=%u; data len=%u", fn,
-                        action.ee_handle, action.trigger, app_init.len_aid, app_init.len_data);
-                //if app-init operation is successful;
-                //app_init.data[] contains two bytes, which are the status codes of the event;
-                //app_init.data[] does not contain an APDU response;
-                //see EMV Contactless Specification for Payment Systems; Book B; Entry Point Specification;
-                //version 2.1; March 2011; section 3.3.3.5;
-                if ( (app_init.len_data > 1) &&
-                     (app_init.data[0] == 0x90) &&
-                     (app_init.data[1] == 0x00) )
-                {
-                    se.notifyTransactionListenersOfAid (app_init.aid, app_init.len_aid, app_init.data, app_init.len_data, SecureElement::getInstance().getGenericEseId(action.ee_handle & ~NFA_HANDLE_GROUP_EE));
-                }
-            }
-            else if (action.trigger == NFC_EE_TRIG_RF_PROTOCOL)
-                ALOGV("%s: NFA_EE_ACTION_EVT; h=0x%X; trigger=rf protocol (0x%X)", fn, action.ee_handle, action.trigger);
-            else if (action.trigger == NFC_EE_TRIG_RF_TECHNOLOGY)
-                ALOGV("%s: NFA_EE_ACTION_EVT; h=0x%X; trigger=rf tech (0x%X)", fn, action.ee_handle, action.trigger);
-            else
-                ALOGE("%s: NFA_EE_ACTION_EVT; h=0x%X; unknown trigger (0x%X)", fn, action.ee_handle, action.trigger);
-#if ((NXP_EXTNS == TRUE))
-            if(nfcFL.nfcNxpEse) {
-                if(action.ee_handle == SecureElement::EE_HANDLE_0xF3)
-                {
-                    ALOGE("%s: NFA_EE_ACTION_EVT; h=0x%X;DWP CL activated (0x%X)", fn, action.ee_handle, action.trigger);
-                    se.setCLState(true);
-                }
-
-                if(nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME != nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
-                    if(action.ee_handle == SecureElement::EE_HANDLE_0xF3 && (action.trigger != NFC_EE_TRIG_RF_TECHNOLOGY) &&
-                            ((se.mIsAllowWiredInDesfireMifareCE) || !(action.trigger == NFC_EE_TRIG_RF_PROTOCOL && action.param.protocol == NFA_PROTOCOL_ISO_DEP)))
-                    {
-                        ALOGE("%s,Allow wired mode connection", fn);
-                        se.setDwpTranseiveState(false, NFCC_ACTION_NTF);
-                    }
-                    else
-                    {
-                        ALOGE("%s,Blocked wired mode connection", fn);
-                        se.setDwpTranseiveState(true, NFCC_ACTION_NTF);
-                    }
-                }
-#endif
-            }
-        }
-        break;
-
-    case NFA_EE_DISCOVER_EVT:
-        {
-            uint8_t num_ee = eventData->ee_discover.num_ee;
-            tNFA_EE_DISCOVER ee_disc_info = eventData->ee_discover;
-            ALOGV("%s: NFA_EE_DISCOVER_EVT; status=0x%X; num ee=%u", __func__,eventData->status, eventData->ee_discover.num_ee);
-            if( (nfcFL.nfccFL._NFCEE_REMOVED_NTF_RECOVERY)                                 &&
-                ( ( (mChipId != pn80T) && (android::isNfcInitializationDone() == true) )   ||
-                  ( (mChipId == pn80T) && (SecureElement::getInstance().mETSI12InitStatus == NFA_STATUS_OK) )
-                )
-              )
-            {
-                if((mChipId == pn65T || mChipId == pn66T || mChipId == pn67T || mChipId == pn80T || mChipId == pn81T))
-                {
-                    for(int xx = 0; xx <  num_ee; xx++)
-                    {
-                        ALOGE("xx=%d, ee_handle=0x0%x, status=0x0%x", xx, ee_disc_info.ee_info[xx].ee_handle,ee_disc_info.ee_info[xx].ee_status);
-                        if (ee_disc_info.ee_info[xx].ee_handle == SecureElement::EE_HANDLE_0xF3)
-                        {
-                            if(ee_disc_info.ee_info[xx].ee_status == NFA_EE_STATUS_REMOVED)
-                            {
-                                recovery=true;
-                                routingManager.ee_removed_disc_ntf_handler(ee_disc_info.ee_info[xx].ee_handle, ee_disc_info.ee_info[xx].ee_status);
-                                break;
-                            }
-                            else if((ee_disc_info.ee_info[xx].ee_status == NFA_EE_STATUS_ACTIVE) && (recovery == true))
-                            {
-                                recovery = false;
-                                SyncEventGuard guard(se.mEEdatapacketEvent);
-                                se.mEEdatapacketEvent.notifyOne();
-                            }
-                        }
-                    }
-                }
-            }
-            /*gSeDiscoverycount++ incremented for new NFCEE discovery;*/
-            SecureElement::getInstance().updateNfceeDiscoverInfo();
-            ALOGV(" gSeDiscoverycount = %ld gActualSeCount=%ld", gSeDiscoverycount,gActualSeCount);
-            if(gSeDiscoverycount >= gActualSeCount)
-            {
-                SyncEventGuard g (gNfceeDiscCbEvent);
-                ALOGV("%s: Sem Post for gNfceeDiscCbEvent", __func__);
-                //usleep(1000000); // wait for 1000 millisec
-                //wait for atleast 1 sec to receive all ntf
-                gNfceeDiscCbEvent.notifyOne ();
-            }
-        }
-        break;
-
-    case NFA_EE_DISCOVER_REQ_EVT:
-        info = eventData->discover_req;
-        ALOGV("%s: NFA_EE_DISCOVER_REQ_EVT; status=0x%X; num ee=%u", __func__,
-                eventData->discover_req.status, eventData->discover_req.num_ee);
-        if(nfcFL.nfcNxpEse && nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
-            /* Handle Reader over SWP.
-             * 1. Check if the event is for Reader over SWP.
-             * 2. IF yes than send this info(READER_REQUESTED_EVENT) till FWK level.
-             * 3. Stop the discovery.
-             * 4. MAP the proprietary interface for Reader over SWP.NFC_DiscoveryMap, nfc_api.h
-             * 5. start the discovery with reader req, type and DH configuration.
-             *
-             * 6. IF yes than send this info(STOP_READER_EVENT) till FWK level.
-             * 7. MAP the DH interface for Reader over SWP. NFC_DiscoveryMap, nfc_api.h
-             * 8. start the discovery with DH configuration.
-             */
-            swp_rdr_req_ntf_info.mMutex.lock ();
-            for (uint8_t xx = 0; xx < info.num_ee; xx++)
-            {
-                //for each technology (A, B, F, B'), print the bit field that shows
-                //what protocol(s) is support by that technology
-                ALOGV("%s   EE[%u] Handle: 0x%04x  PA: 0x%02x  PB: 0x%02x",
-                        fn, xx, info.ee_disc_info[xx].ee_handle,
-                        info.ee_disc_info[xx].pa_protocol,
-                        info.ee_disc_info[xx].pb_protocol);
-
-                ALOGV("%s, swp_rd_state=%x", fn, swp_rdr_req_ntf_info.swp_rd_state);
-                if( (info.ee_disc_info[xx].ee_req_op == NFC_EE_DISC_OP_ADD) &&
-                        (swp_rdr_req_ntf_info.swp_rd_state == STATE_SE_RDR_MODE_STOPPED ||
-                                swp_rdr_req_ntf_info.swp_rd_state == STATE_SE_RDR_MODE_START_CONFIG ||
-                                swp_rdr_req_ntf_info.swp_rd_state == STATE_SE_RDR_MODE_STOP_CONFIG)&&
-                                (info.ee_disc_info[xx].pa_protocol ==  0x04 || info.ee_disc_info[xx].pb_protocol == 0x04 ))
-                {
-                    ALOGV("%s NFA_RD_SWP_READER_REQUESTED  EE[%u] Handle: 0x%04x  PA: 0x%02x  PB: 0x%02x",
-                            fn, xx, info.ee_disc_info[xx].ee_handle,
-                            info.ee_disc_info[xx].pa_protocol,
-                            info.ee_disc_info[xx].pb_protocol);
-
-                    swp_rdr_req_ntf_info.swp_rd_req_info.src = info.ee_disc_info[xx].ee_handle;
-                    swp_rdr_req_ntf_info.swp_rd_req_info.tech_mask = 0;
-                    swp_rdr_req_ntf_info.swp_rd_req_info.reCfg = false;
-
-                    if( !(swp_rdr_req_ntf_info.swp_rd_req_info.tech_mask & NFA_TECHNOLOGY_MASK_A) )
-                    {
-                        if(info.ee_disc_info[xx].pa_protocol ==  0x04)
-                        {
-                            swp_rdr_req_ntf_info.swp_rd_req_info.tech_mask |= NFA_TECHNOLOGY_MASK_A;
-                            swp_rdr_req_ntf_info.swp_rd_req_info.reCfg = true;
-                        }
-                    }
-
-                    if( !(swp_rdr_req_ntf_info.swp_rd_req_info.tech_mask & NFA_TECHNOLOGY_MASK_B) )
-                    {
-                        if(info.ee_disc_info[xx].pb_protocol ==  0x04)
-                        {
-                            swp_rdr_req_ntf_info.swp_rd_req_info.tech_mask |= NFA_TECHNOLOGY_MASK_B;
-                            swp_rdr_req_ntf_info.swp_rd_req_info.reCfg = true;
-                        }
-                    }
-
-                    if(swp_rdr_req_ntf_info.swp_rd_req_info.reCfg)
-                    {
-                        ALOGV("%s, swp_rd_state=%x  evt : NFA_RD_SWP_READER_REQUESTED swp_rd_req_timer start", fn, swp_rdr_req_ntf_info.swp_rd_state);
-
-                        swp_rd_req_timer.kill();
-                        if(swp_rdr_req_ntf_info.swp_rd_state != STATE_SE_RDR_MODE_STOP_CONFIG)
-                        {
-                            swp_rd_req_timer.set (rdr_req_handling_timeout, reader_req_event_ntf);
-                            swp_rdr_req_ntf_info.swp_rd_state = STATE_SE_RDR_MODE_START_CONFIG;
-                        }
-                        /*RestartReadermode procedure special case should not de-activate*/
-                        else if(swp_rdr_req_ntf_info.swp_rd_state == STATE_SE_RDR_MODE_STOP_CONFIG)
-                        {
-                            swp_rdr_req_ntf_info.swp_rd_state = STATE_SE_RDR_MODE_STARTED;
-                            /*RFDEACTIVATE_DISCOVERY*/
-                            NFA_Deactivate(false);
-                        }
-                        swp_rdr_req_ntf_info.swp_rd_req_info.reCfg = false;
-                    }
-                    //Reader over SWP - Reader Requested.
-                    //se.handleEEReaderEvent(NFA_RD_SWP_READER_REQUESTED, tech, info.ee_disc_info[xx].ee_handle);
-                    break;
-                }
-                else if((info.ee_disc_info[xx].ee_req_op == NFC_EE_DISC_OP_REMOVE) &&
-                        ((swp_rdr_req_ntf_info.swp_rd_state == STATE_SE_RDR_MODE_STARTED) ||
-                                (swp_rdr_req_ntf_info.swp_rd_state == STATE_SE_RDR_MODE_START_CONFIG) ||
-                                (swp_rdr_req_ntf_info.swp_rd_state == STATE_SE_RDR_MODE_STOP_CONFIG) ||
-                                (swp_rdr_req_ntf_info.swp_rd_state == STATE_SE_RDR_MODE_ACTIVATED)) &&
-                                (info.ee_disc_info[xx].pa_protocol ==  0xFF || info.ee_disc_info[xx].pb_protocol == 0xFF))
-                {
-                    ALOGV("%s NFA_RD_SWP_READER_STOP  EE[%u] Handle: 0x%04x  PA: 0x%02x  PB: 0x%02x",
-                            fn, xx, info.ee_disc_info[xx].ee_handle,
-                            info.ee_disc_info[xx].pa_protocol,
-                            info.ee_disc_info[xx].pb_protocol);
-
-                    if(swp_rdr_req_ntf_info.swp_rd_req_info.src == info.ee_disc_info[xx].ee_handle)
-                    {
-                        if(info.ee_disc_info[xx].pa_protocol ==  0xFF)
-                        {
-                            if(swp_rdr_req_ntf_info.swp_rd_req_info.tech_mask & NFA_TECHNOLOGY_MASK_A)
-                            {
-                                swp_rdr_req_ntf_info.swp_rd_req_info.tech_mask &= ~NFA_TECHNOLOGY_MASK_A;
-                                swp_rdr_req_ntf_info.swp_rd_req_info.reCfg = true;
-                                //swp_rdr_req_ntf_info.swp_rd_state = STATE_SE_RDR_MODE_STOP_CONFIG;
-                            }
-                        }
-
-                        if(info.ee_disc_info[xx].pb_protocol ==  0xFF)
-                        {
-                            if(swp_rdr_req_ntf_info.swp_rd_req_info.tech_mask & NFA_TECHNOLOGY_MASK_B)
-                            {
-                                swp_rdr_req_ntf_info.swp_rd_req_info.tech_mask &= ~NFA_TECHNOLOGY_MASK_B;
-                                swp_rdr_req_ntf_info.swp_rd_req_info.reCfg = true;
-                            }
-
-                        }
-
-                        if(swp_rdr_req_ntf_info.swp_rd_req_info.reCfg)
-                        {
-                            ALOGV("%s, swp_rd_state=%x  evt : NFA_RD_SWP_READER_STOP swp_rd_req_timer start", fn, swp_rdr_req_ntf_info.swp_rd_state);
-                            swp_rdr_req_ntf_info.swp_rd_state = STATE_SE_RDR_MODE_STOP_CONFIG;
-                            swp_rd_req_timer.kill();
-                            swp_rd_req_timer.set (rdr_req_handling_timeout, reader_req_event_ntf);
-                            swp_rdr_req_ntf_info.swp_rd_req_info.reCfg = false;
-                        }
-                    }
-                    break;
-                }
-            }
-            swp_rdr_req_ntf_info.mMutex.unlock();
-            /*Set the configuration for UICC/ESE */
-            se.storeUiccInfo (eventData->discover_req);
-        }
-        break;
-
-    case NFA_EE_NO_CB_ERR_EVT:
-        ALOGV("%s: NFA_EE_NO_CB_ERR_EVT  status=%u", fn, eventData->status);
-        break;
-
-    case NFA_EE_ADD_AID_EVT:
-        {
-            ALOGV("%s: NFA_EE_ADD_AID_EVT  status=%u", fn, eventData->status);
-            if(eventData->status == NFA_STATUS_BUFFER_FULL)
-            {
-                ALOGV("%s: AID routing table is FULL!!!", fn);
-                RoutingManager::getInstance().notifyLmrtFull();
-            }
-            SyncEventGuard guard(se.mAidAddRemoveEvent);
-            se.mAidAddRemoveEvent.notifyOne();
-        }
-        break;
-
-    case NFA_EE_REMOVE_AID_EVT:
-        {
-            ALOGV("%s: NFA_EE_REMOVE_AID_EVT  status=%u", fn, eventData->status);
-            SyncEventGuard guard(se.mAidAddRemoveEvent);
-            se.mAidAddRemoveEvent.notifyOne();
-        }
-        break;
-    case NFA_EE_ADD_APDU_EVT:
-    {
-        ALOGV("%s: NFA_EE_ADD_APDU_EVT  status=%u", fn, eventData->status);
-        if(eventData->status == NFA_STATUS_BUFFER_FULL)
-        {
-            ALOGV("%s: routing table is FULL!!!", fn);
-            RoutingManager::getInstance().notifyLmrtFull();
-        }
-        SyncEventGuard guard(se.mApduPaternAddRemoveEvent);
-        se.mApduPaternAddRemoveEvent.notifyOne();
-    }
-        break;
-    case NFA_EE_REMOVE_APDU_EVT:
-    {
-        ALOGV("%s: NFA_EE_REMOVE_APDU_EVT  status=%u", fn, eventData->status);
-        SyncEventGuard guard(se.mApduPaternAddRemoveEvent);
-        se.mApduPaternAddRemoveEvent.notifyOne();
+  SyncEventGuard guard(SecureElement::getInstance().mApduPaternAddRemoveEvent);
+  tNFA_STATUS nfaStat =
+      NFA_EeAddApduPatternRouting(apduDataLen, (uint8_t*)apduData, apduMaskLen,
+                                  (uint8_t*)apduMask, handle, powerState);
+  if (nfaStat == NFA_STATUS_OK) {
+#if (NXP_EXTNS == TRUE)
+    SecureElement::getInstance().mApduPaternAddRemoveEvent.wait();
+#endif
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: routed APDU pattern successfully", fn);
+  }
+  return ((nfaStat == NFA_STATUS_OK) ? true : false);
+}
+
+bool RoutingManager::removeApduRouting(uint8_t apduDataLen,
+                                       const uint8_t* apduData) {
+  static const char fn[] = "RoutingManager::removeApduRouting";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+  SyncEventGuard guard(SecureElement::getInstance().mApduPaternAddRemoveEvent);
+  tNFA_STATUS nfaStat =
+      NFA_EeRemoveApduPatternRouting(apduDataLen, (uint8_t*)apduData);
+  if (nfaStat == NFA_STATUS_OK) {
+    SecureElement::getInstance().mApduPaternAddRemoveEvent.wait();
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: removed APDU pattern successfully", fn);
+  }
+  return ((nfaStat == NFA_STATUS_OK) ? true : false);
+}
+
+#if (NXP_EXTNS == TRUE)
+void RoutingManager::setDefaultTechRouting(int seId, int tech_switchon,
+                                           int tech_switchoff) {
+  SecureElement& se = SecureElement::getInstance();
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("ENTER setDefaultTechRouting");
+  tNFA_STATUS nfaStat;
+  /*// !!! CLEAR ALL REGISTERED TECHNOLOGIES !!!*/
+  {
+    SyncEventGuard guard(mRoutingEvent);
+    tNFA_STATUS status =
+        NFA_EeSetDefaultTechRouting(0x400, 0, 0, 0, 0, 0, 0);  // HOST clear
+    if (status == NFA_STATUS_OK) {
+      mRoutingEvent.wait();
+    }
+  }
+
+  {
+    SyncEventGuard guard(mRoutingEvent);
+    tNFA_STATUS status = NFA_EeSetDefaultTechRouting(se.EE_HANDLE_0xF4, 0, 0, 0,
+                                                     0, 0, 0);  // UICC clear
+    if (status == NFA_STATUS_OK) {
+      mRoutingEvent.wait();
+    }
+  }
+
+  {
+    SyncEventGuard guard(mRoutingEvent);
+    tNFA_STATUS status = NFA_EeSetDefaultTechRouting(
+        SecureElement::EE_HANDLE_0xF3, 0, 0, 0, 0, 0, 0);  // SMX clear
+    if (status == NFA_STATUS_OK) {
+      mRoutingEvent.wait();
+    }
+  }
+
+  if (nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH ||
+      nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC) {
+    SyncEventGuard guard(mRoutingEvent);
+    tNFA_STATUS status = NFA_EeSetDefaultTechRouting(
+        SecureElement::EE_HANDLE_0xF8, 0, 0, 0, 0, 0, 0);  // SMX clear
+    if (status == NFA_STATUS_OK) {
+      mRoutingEvent.wait();
+    }
+  }
+
+  {
+    SyncEventGuard guard(mRoutingEvent);
+    if (mCeRouteStrictDisable == 0x01) {
+      nfaStat = NFA_EeSetDefaultTechRouting(
+          seId, tech_switchon, tech_switchoff, 0,
+          NFA_TECHNOLOGY_MASK_A | NFA_TECHNOLOGY_MASK_B,
+          NFA_TECHNOLOGY_MASK_A | NFA_TECHNOLOGY_MASK_B,
+          NFA_TECHNOLOGY_MASK_A | NFA_TECHNOLOGY_MASK_B);
+    } else {
+      nfaStat = NFA_EeSetDefaultTechRouting(seId, tech_switchon, tech_switchoff,
+                                            0, 0, 0, 0);
     }
-        break;
-    case NFA_EE_NEW_EE_EVT:
-        {
-            ALOGV("%s: NFA_EE_NEW_EE_EVT  h=0x%X; status=%u", fn,
-                eventData->new_ee.ee_handle, eventData->new_ee.ee_status);
-        }
-        break;
-    case NFA_EE_ROUT_ERR_EVT:
-        {
-            ALOGV("%s: NFA_EE_ROUT_ERR_EVT  status=%u", fn,eventData->status);
-        }
-        break;
-    case NFA_EE_UPDATED_EVT:
+    if (nfaStat == NFA_STATUS_OK) {
+      mRoutingEvent.wait();
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("tech routing SUCCESS");
+    } else {
+      LOG(ERROR) << StringPrintf("Fail to set default tech routing");
+    }
+  }
+
+  nfaStat = NFA_EeUpdateNow();
+  if (nfaStat != NFA_STATUS_OK) {
+    LOG(ERROR) << StringPrintf("Failed to commit routing configuration");
+  }
+}
+
+void RoutingManager::setDefaultProtoRouting(int seId, int proto_switchon,
+                                            int proto_switchoff) {
+  tNFA_STATUS nfaStat;
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("ENTER setDefaultProtoRouting");
+  SyncEventGuard guard(mRoutingEvent);
+  if (mCeRouteStrictDisable == 0x01) {
+    nfaStat = NFA_EeSetDefaultProtoRouting(
+        seId, proto_switchon, proto_switchoff, 0, NFA_PROTOCOL_MASK_ISO_DEP,
+        NFA_PROTOCOL_MASK_ISO_DEP, NFA_PROTOCOL_MASK_ISO_DEP);
+  } else {
+    nfaStat = NFA_EeSetDefaultProtoRouting(seId, proto_switchon,
+                                           proto_switchoff, 0, 0, 0, 0);
+  }
+  if (nfaStat == NFA_STATUS_OK) {
+    mRoutingEvent.wait();
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("proto routing SUCCESS");
+  } else {
+    LOG(ERROR) << StringPrintf("Fail to set default proto routing");
+  }
+  //    nfaStat = NFA_EeUpdateNow();
+  //    if (nfaStat != NFA_STATUS_OK){
+  //        LOG(ERROR) << StringPrintf("Failed to commit routing
+  //        configuration");
+  //    }
+}
+
+bool RoutingManager::clearAidTable() {
+  static const char fn[] = "RoutingManager::clearAidTable";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+  SyncEventGuard guard(SecureElement::getInstance().mAidAddRemoveEvent);
+  tNFA_STATUS nfaStat = NFA_EeRemoveAidRouting(NFA_REMOVE_ALL_AID_LEN,
+                                               (uint8_t*)NFA_REMOVE_ALL_AID);
+  if (nfaStat == NFA_STATUS_OK) {
+    SecureElement::getInstance().mAidAddRemoveEvent.wait();
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: removed AID", fn);
+    return true;
+  } else {
+    LOG(ERROR) << StringPrintf("%s: failed to remove AID", fn);
+    return false;
+  }
+}
+
+#endif
+
+bool RoutingManager::commitRouting() {
+  static const char fn[] = "RoutingManager::commitRouting";
+  tNFA_STATUS nfaStat = 0;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", fn);
+  {
+    RoutingManager::getInstance().LmrtRspTimer.set(1000, LmrtRspTimerCb);
+    SyncEventGuard guard(mEeUpdateEvent);
+    nfaStat = NFA_EeUpdateNow();
+    if (nfaStat == NFA_STATUS_OK) {
+      mEeUpdateEvent.wait();  // wait for NFA_EE_UPDATED_EVT
+    }
+  }
+  return (nfaStat == NFA_STATUS_OK);
+}
+
+void RoutingManager::onNfccShutdown() {
+  static const char fn[] = "RoutingManager:onNfccShutdown";
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+  uint8_t actualNumEe = nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED;
+  tNFA_EE_INFO eeInfo[actualNumEe];
+
+  if (mDefaultOffHostRoute == 0x00) return;
+
+  memset(&eeInfo, 0, sizeof(eeInfo));
+
+  if ((nfaStat = NFA_EeGetInfo(&actualNumEe, eeInfo)) != NFA_STATUS_OK) {
+    LOG(ERROR) << StringPrintf("%s: fail get info; error=0x%X", fn, nfaStat);
+    return;
+  }
+  if (actualNumEe != 0) {
+    for (uint8_t xx = 0; xx < actualNumEe; xx++) {
+      if ((eeInfo[xx].ee_interface[0] != NCI_NFCEE_INTERFACE_HCI_ACCESS) &&
+          (eeInfo[xx].ee_status == NFA_EE_STATUS_ACTIVE)) {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: Handle: 0x%04x Change Status Active to Inactive", fn,
+            eeInfo[xx].ee_handle);
+#if (NXP_EXTNS == TRUE)
+        if ((nfaStat = SecureElement::getInstance().SecElem_EeModeSet(
+                 eeInfo[xx].ee_handle, NFA_EE_MD_DEACTIVATE)) != NFA_STATUS_OK)
+#endif
         {
-            ALOGV("%s: NFA_EE_UPDATED_EVT", fn);
-            SyncEventGuard guard(routingManager.mEeUpdateEvent);
-            routingManager.mEeUpdateEvent.notifyOne();
-            routingManager.LmrtRspTimer.kill();
-        }
-        break;
-    default:
-        ALOGE("%s: unknown event=%u ????", fn, event);
-        break;
-    }
+          LOG(ERROR) << StringPrintf("Failed to set EE inactive");
+        }
+      }
+    }
+  } else {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: No active EEs found", fn);
+  }
+}
+
+void RoutingManager::notifyActivated(uint8_t technology) {
+  JNIEnv* e = NULL;
+  ScopedAttach attach(mNativeData->vm, &e);
+  if (e == NULL) {
+    LOG(ERROR) << StringPrintf("jni env is null");
+    return;
+  }
+
+  e->CallVoidMethod(mNativeData->manager,
+                    android::gCachedNfcManagerNotifyHostEmuActivated,
+                    (int)technology);
+  if (e->ExceptionCheck()) {
+    e->ExceptionClear();
+    LOG(ERROR) << StringPrintf("fail notify");
+  }
+}
+
+void RoutingManager::notifyDeactivated(uint8_t technology) {
+  SecureElement::getInstance().notifyListenModeState(false);
+  mRxDataBuffer.clear();
+  JNIEnv* e = NULL;
+  ScopedAttach attach(mNativeData->vm, &e);
+  if (e == NULL) {
+    LOG(ERROR) << StringPrintf("jni env is null");
+    return;
+  }
+
+  e->CallVoidMethod(mNativeData->manager,
+                    android::gCachedNfcManagerNotifyHostEmuDeactivated,
+                    (int)technology);
+  if (e->ExceptionCheck()) {
+    e->ExceptionClear();
+    LOG(ERROR) << StringPrintf("fail notify");
+  }
+}
+
+void RoutingManager::notifyLmrtFull() {
+  JNIEnv* e = NULL;
+  ScopedAttach attach(mNativeData->vm, &e);
+  if (e == NULL) {
+    LOG(ERROR) << StringPrintf("jni env is null");
+    return;
+  }
+
+  e->CallVoidMethod(mNativeData->manager,
+                    android::gCachedNfcManagerNotifyAidRoutingTableFull);
+  if (e->ExceptionCheck()) {
+    e->ExceptionClear();
+    LOG(ERROR) << StringPrintf("fail notify");
+  }
+}
+#if (NXP_EXTNS == TRUE)
+void RoutingManager::nfcFRspTimerCb(union sigval) {
+  if (!nfcFL.nfccFL._NXP_NFCC_EMPTY_DATA_PACKET) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s; NFCC_EMPTY_DATA_PACKET not available.Returning", __func__);
+    return;
+  }
+  static const char fn[] = "RoutingManager::nfcFRspTimerCb";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s; enter", fn);
+  if (android::gIsEmptyRspSentByHceFApk)
+    android::gIsEmptyRspSentByHceFApk = false;
+  else
+    android::nfcManager_sendEmptyDataMsg();
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s; exit", fn);
 }
+#endif
 
-#if(NXP_EXTNS == TRUE)
-#if(NXP_NFCC_HCE_F == TRUE)
-void RoutingManager::notifyT3tConfigure()
-{
+void RoutingManager::handleData(uint8_t technology, const uint8_t* data,
+                                uint32_t dataLen, tNFA_STATUS status) {
+  if (status == NFC_STATUS_CONTINUE) {
+    LOG(ERROR) << StringPrintf("jni env is null");
+    if (dataLen > 0) {
+      mRxDataBuffer.insert(mRxDataBuffer.end(), &data[0],
+                           &data[dataLen]);  // append data; more to come
+    }
+    return;  // expect another NFA_CE_DATA_EVT to come
+  } else if (status == NFA_STATUS_OK) {
+    if (dataLen > 0) {
+      mRxDataBuffer.insert(mRxDataBuffer.end(), &data[0],
+                           &data[dataLen]);  // append data
+#if (NXP_EXTNS == TRUE)
+      if (nfcFL.nfccFL._NXP_NFCC_EMPTY_DATA_PACKET &&
+          (technology == NFA_TECHNOLOGY_MASK_F)) {
+        bool ret = false;
+        ret = mNfcFRspTimer.set(mDefaultHCEFRspTimeout, nfcFRspTimerCb);
+        if (!ret)
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("%s; rsp timer create failed", __func__);
+      }
+#endif
+    }
+    // entire data packet has been received; no more NFA_CE_DATA_EVT
+  } else if (status == NFA_STATUS_FAILED) {
+    LOG(ERROR) << StringPrintf("RoutingManager::handleData: read data fail");
+    goto TheEnd;
+  }
+  {
     JNIEnv* e = NULL;
     ScopedAttach attach(mNativeData->vm, &e);
-    if (e == NULL)
-    {
-        ALOGE("jni env is null");
-        return;
+    if (e == NULL) {
+      LOG(ERROR) << StringPrintf("jni env is null");
+      goto TheEnd;
     }
 
-    e->CallVoidMethod (mNativeData->manager, android::gCachedNfcManagerNotifyT3tConfigure);
-    if (e->ExceptionCheck())
-    {
-        e->ExceptionClear();
-        ALOGE("fail notify");
+    ScopedLocalRef<jobject> dataJavaArray(
+        e, e->NewByteArray(mRxDataBuffer.size()));
+    if (dataJavaArray.get() == NULL) {
+      LOG(ERROR) << StringPrintf("fail allocate array");
+      goto TheEnd;
     }
-}
-#endif
-void RoutingManager::notifyReRoutingEntry()
-{
-    JNIEnv* e = NULL;
-    ScopedAttach attach(mNativeData->vm, &e);
-    if (e == NULL)
-    {
-        ALOGE("jni env is null");
-        return;
+
+    e->SetByteArrayRegion((jbyteArray)dataJavaArray.get(), 0,
+                          mRxDataBuffer.size(), (jbyte*)(&mRxDataBuffer[0]));
+    if (e->ExceptionCheck()) {
+      e->ExceptionClear();
+      LOG(ERROR) << StringPrintf("fail fill array");
+      goto TheEnd;
     }
 
-    e->CallVoidMethod (mNativeData->manager, android::gCachedNfcManagerNotifyReRoutingEntry);
-    if (e->ExceptionCheck())
-    {
-        e->ExceptionClear();
-        ALOGE("fail notify");
+    e->CallVoidMethod(mNativeData->manager,
+                      android::gCachedNfcManagerNotifyHostEmuData,
+                      (int)technology, dataJavaArray.get());
+    if (e->ExceptionCheck()) {
+      e->ExceptionClear();
+      LOG(ERROR) << StringPrintf("fail notify");
     }
-}
+  }
+TheEnd:
+  mRxDataBuffer.clear();
+}
+
+void RoutingManager::stackCallback(uint8_t event,
+                                   tNFA_CONN_EVT_DATA* eventData) {
+  static const char fn[] = "RoutingManager::stackCallback";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: event=0x%X", fn, event);
+  RoutingManager& routingManager = RoutingManager::getInstance();
+
+  SecureElement& se = SecureElement::getInstance();
+
+  switch (event) {
+    case NFA_CE_REGISTERED_EVT: {
+      tNFA_CE_REGISTERED& ce_registered = eventData->ce_registered;
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: NFA_CE_REGISTERED_EVT; status=0x%X; h=0x%X", fn,
+                          ce_registered.status, ce_registered.handle);
+      SyncEventGuard guard(routingManager.mCeRegisterEvent);
+      if (ce_registered.status == NFA_STATUS_OK) {
+        lastcehandle = ce_registered.handle;
+      } else {
+        lastcehandle = 0xFF;
+      }
+      routingManager.mCeRegisterEvent.notifyOne();
+    } break;
+
+    case NFA_CE_DEREGISTERED_EVT: {
+      tNFA_CE_DEREGISTERED& ce_deregistered = eventData->ce_deregistered;
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_CE_DEREGISTERED_EVT; h=0x%X", fn, ce_deregistered.handle);
+      SyncEventGuard guard(routingManager.mCeDeRegisterEvent);
+      routingManager.mCeDeRegisterEvent.notifyOne();
+    } break;
+
+    case NFA_CE_ACTIVATED_EVT: {
+#if (NXP_EXTNS == TRUE)
+      android::rfActivation = true;
+#endif
+      android::checkforTranscation(NFA_CE_ACTIVATED_EVT, (void*)eventData);
+      routingManager.notifyActivated(NFA_TECHNOLOGY_MASK_A);
+    } break;
+    case NFA_DEACTIVATED_EVT:
+    case NFA_CE_DEACTIVATED_EVT: {
+      android::checkforTranscation(NFA_CE_DEACTIVATED_EVT, (void*)eventData);
+      routingManager.notifyDeactivated(NFA_TECHNOLOGY_MASK_A);
+      if (nfcFL.nfcNxpEse &&
+          nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION &&
+          (se.mIsWiredModeOpen && se.mPassiveListenEnabled)) {
+        se.startThread(0x00);
+      }
+    }
+#if (NXP_EXTNS == TRUE)
+      android::rfActivation = false;
+#endif
+      break;
+    case NFA_CE_DATA_EVT: {
+#if (NXP_EXTNS == TRUE)
+      if (nfcFL.nfcNxpEse &&
+          nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION &&
+          (nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME !=
+           nfcFL.eseFL._ESE_WIRED_MODE_RESUME)) {
+        se.setDwpTranseiveState(false, NFCC_CE_DATA_EVT);
+      }
 #endif
+      tNFA_CE_DATA& ce_data = eventData->ce_data;
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: NFA_CE_DATA_EVT; stat=0x%X; h=0x%X; data len=%u",
+                          fn, ce_data.status, ce_data.handle, ce_data.len);
+      getInstance().handleData(NFA_TECHNOLOGY_MASK_A, ce_data.p_data,
+                               ce_data.len, ce_data.status);
+    } break;
+  }
+}
+/*******************************************************************************
+**
+** Function:        nfaEeCallback
+**
+** Description:     Receive execution environment-related events from stack.
+**                  event: Event code.
+**                  eventData: Event data.
+**
+** Returns:         None
+**
+*******************************************************************************/
+void RoutingManager::nfaEeCallback(tNFA_EE_EVT event,
+                                   tNFA_EE_CBACK_DATA* eventData) {
+  static const char fn[] = "RoutingManager::nfaEeCallback";
+
+  SecureElement& se = SecureElement::getInstance();
+  RoutingManager& routingManager = RoutingManager::getInstance();
+  if (!eventData) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: No eventdata", fn);
+  return;
+  }
+  routingManager.mCbEventData = *eventData;
+
+  switch (event) {
+    case NFA_EE_REGISTER_EVT: {
+      SyncEventGuard guard(routingManager.mEeRegisterEvent);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_EE_REGISTER_EVT; status=%u", fn, eventData->ee_register);
+      routingManager.mEeRegisterEvent.notifyOne();
+    } break;
+
+    case NFA_EE_ADD_SYSCODE_EVT: {
+      SyncEventGuard guard(routingManager.mRoutingEvent);
+      routingManager.mRoutingEvent.notifyOne();
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_EE_ADD_SYSCODE_EVT  status=%u", fn, eventData->status);
+    } break;
+
+    case NFA_EE_REMOVE_SYSCODE_EVT: {
+      SyncEventGuard guard(routingManager.mRoutingEvent);
+      routingManager.mRoutingEvent.notifyOne();
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_EE_REMOVE_SYSCODE_EVT  status=%u", fn, eventData->status);
+    } break;
+
+    case NFA_EE_MODE_SET_EVT: {
+      SyncEventGuard guard(routingManager.mEeSetModeEvent);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_EE_MODE_SET_EVT; status: 0x%04X  handle: 0x%04X  "
+          "mActiveEeHandle: 0x%04X",
+          fn, eventData->mode_set.status, eventData->mode_set.ee_handle,
+          se.mActiveEeHandle);
+      routingManager.mEeSetModeEvent.notifyOne();
+      se.notifyModeSet(eventData->mode_set.ee_handle,
+                       !(eventData->mode_set.status),
+                       eventData->mode_set.ee_status);
+    } break;
+#if (NXP_EXTNS == TRUE)
+    case NFA_EE_SET_MODE_INFO_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_EE_SET_MODE_INFO_EVT; nfcee_id = 0x%02x, status: 0x%04X ",
+          fn, eventData->ee_set_mode_info.nfcee_id,
+          eventData->ee_set_mode_info.status);
+      se.mModeSetInfo = eventData->ee_set_mode_info.status;
+      if (eventData->ee_set_mode_info.nfcee_id ==
+          (se.EE_HANDLE_0xF3 & ~NFA_HANDLE_GROUP_EE)) {
+        recovery = false;
+        SyncEventGuard guard(se.mModeSetNtf);
+        se.mModeSetNtf.notifyOne();
+      }
+    } break;
+
+    case NFA_EE_DISCONNECT_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: NFA_EE_DISCONNECT_EVT received", fn);
+      SyncEventGuard guard(routingManager.mEEDisconnectEvt);
+      routingManager.mEEDisconnectEvt.notifyOne();
+    } break;
 
-int RoutingManager::registerT3tIdentifier(uint8_t* t3tId, uint8_t t3tIdLen)
-{
-    static const char fn [] = "RoutingManager::registerT3tIdentifier";
+    case NFA_EE_PWR_LINK_CTRL_EVT:
+      if (nfcFL.eseFL._WIRED_MODE_STANDBY) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: NFA_EE_PWR_LINK_CTRL_EVT; status: 0x%04X ", fn,
+                            eventData->pwr_lnk_ctrl.status);
+        se.mPwrCmdstatus = eventData->pwr_lnk_ctrl.status;
+        SyncEventGuard guard(se.mPwrLinkCtrlEvent);
+        se.mPwrLinkCtrlEvent.notifyOne();
+      }
+      break;
+#endif
+    case NFA_EE_SET_TECH_CFG_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_EE_SET_TECH_CFG_EVT; status=0x%X", fn, eventData->status);
+      SyncEventGuard guard(routingManager.mRoutingEvent);
+      routingManager.mRoutingEvent.notifyOne();
+    } break;
+
+    case NFA_EE_SET_PROTO_CFG_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_EE_SET_PROTO_CFG_EVT; status=0x%X", fn, eventData->status);
+      SyncEventGuard guard(routingManager.mRoutingEvent);
+      routingManager.mRoutingEvent.notifyOne();
+    } break;
+
+    case NFA_EE_ACTION_EVT: {
+      tNFA_EE_ACTION& action = eventData->action;
+      tNFC_APP_INIT& app_init = action.param.app_init;
+      android::checkforTranscation(NFA_EE_ACTION_EVT, (void*)eventData);
+
+      if (action.trigger == NFC_EE_TRIG_SELECT) {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: NFA_EE_ACTION_EVT; h=0x%X; trigger=select (0x%X); aid len=%u",
+            fn, action.ee_handle, action.trigger, app_init.len_aid);
+      } else if (action.trigger == NFC_EE_TRIG_APP_INIT) {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: NFA_EE_ACTION_EVT; h=0x%X; trigger=app-init (0x%X); aid "
+            "len=%u; data len=%u",
+            fn, action.ee_handle, action.trigger, app_init.len_aid,
+            app_init.len_data);
+        // if app-init operation is successful;
+        // app_init.data[] contains two bytes, which are the status codes of the
+        // event;
+        // app_init.data[] does not contain an APDU response;
+        // see EMV Contactless Specification for Payment Systems; Book B; Entry
+        // Point Specification;
+        // version 2.1; March 2011; section 3.3.3.5;
+        if ((app_init.len_data > 1) && (app_init.data[0] == 0x90) &&
+            (app_init.data[1] == 0x00)) {
+          se.notifyTransactionListenersOfAid(
+              app_init.aid, app_init.len_aid, app_init.data, app_init.len_data,
+              SecureElement::getInstance().getGenericEseId(
+                  action.ee_handle & ~NFA_HANDLE_GROUP_EE));
+        }
+      } else if (action.trigger == NFC_EE_TRIG_RF_PROTOCOL)
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: NFA_EE_ACTION_EVT; h=0x%X; trigger=rf protocol (0x%X)", fn,
+            action.ee_handle, action.trigger);
+      else if (action.trigger == NFC_EE_TRIG_RF_TECHNOLOGY)
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: NFA_EE_ACTION_EVT; h=0x%X; trigger=rf tech (0x%X)", fn,
+            action.ee_handle, action.trigger);
+      else
+        LOG(ERROR) << StringPrintf(
+            "%s: NFA_EE_ACTION_EVT; h=0x%X; unknown trigger (0x%X)", fn,
+            action.ee_handle, action.trigger);
+#if ((NXP_EXTNS == TRUE))
+      if (nfcFL.nfcNxpEse) {
+        if (action.ee_handle == SecureElement::EE_HANDLE_0xF3) {
+          LOG(ERROR) << StringPrintf(
+              "%s: NFA_EE_ACTION_EVT; h=0x%X;DWP CL activated (0x%X)", fn,
+              action.ee_handle, action.trigger);
+          se.setCLState(true);
+        }
+
+        if (nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME !=
+            nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
+          if (action.ee_handle == SecureElement::EE_HANDLE_0xF3 &&
+              (action.trigger != NFC_EE_TRIG_RF_TECHNOLOGY) &&
+              ((se.mIsAllowWiredInDesfireMifareCE) ||
+               !(action.trigger == NFC_EE_TRIG_RF_PROTOCOL &&
+                 action.param.protocol == NFA_PROTOCOL_ISO_DEP))) {
+            LOG(ERROR) << StringPrintf("%s,Allow wired mode connection", fn);
+            se.setDwpTranseiveState(false, NFCC_ACTION_NTF);
+          } else {
+            LOG(ERROR) << StringPrintf("%s,Blocked wired mode connection", fn);
+            se.setDwpTranseiveState(true, NFCC_ACTION_NTF);
+          }
+        }
+#endif
+      }
+    } break;
+
+    case NFA_EE_DISCOVER_EVT: {
+      uint8_t num_ee = eventData->ee_discover.num_ee;
+      tNFA_EE_DISCOVER ee_disc_info = eventData->ee_discover;
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_EE_DISCOVER_EVT; status=0x%X; num ee=%u", __func__,
+          eventData->status, eventData->ee_discover.num_ee);
+      if ((nfcFL.nfccFL._NFCEE_REMOVED_NTF_RECOVERY) &&
+          (((mChipId != pn80T) &&
+            (android::isNfcInitializationDone() == true)) ||
+           ((mChipId == pn80T) &&
+            (SecureElement::getInstance().mETSI12InitStatus ==
+             NFA_STATUS_OK)))) {
+        if ((mChipId == pn65T || mChipId == pn66T || mChipId == pn67T ||
+             mChipId == pn80T || mChipId == pn81T)) {
+          for (int xx = 0; xx < num_ee; xx++) {
+            LOG(ERROR) << StringPrintf("xx=%d, ee_handle=0x0%x, status=0x0%x",
+                                       xx, ee_disc_info.ee_info[xx].ee_handle,
+                                       ee_disc_info.ee_info[xx].ee_status);
+            if (ee_disc_info.ee_info[xx].ee_handle ==
+                SecureElement::EE_HANDLE_0xF3) {
+              if (ee_disc_info.ee_info[xx].ee_status == NFA_EE_STATUS_REMOVED) {
+                recovery = true;
+                routingManager.ee_removed_disc_ntf_handler(
+                    ee_disc_info.ee_info[xx].ee_handle,
+                    ee_disc_info.ee_info[xx].ee_status);
+                break;
+              } else if ((ee_disc_info.ee_info[xx].ee_status ==
+                          NFA_EE_STATUS_ACTIVE) &&
+                         (recovery == true)) {
+                recovery = false;
+                SyncEventGuard guard(se.mEEdatapacketEvent);
+                se.mEEdatapacketEvent.notifyOne();
+              }
+            }
+          }
+        }
+      }
+      /*gSeDiscoverycount++ incremented for new NFCEE discovery;*/
+      SecureElement::getInstance().updateNfceeDiscoverInfo();
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf(" gSeDiscoverycount = %d gActualSeCount=%d",
+                          gSeDiscoverycount, gActualSeCount);
+      if (gSeDiscoverycount >= gActualSeCount) {
+        SyncEventGuard g(gNfceeDiscCbEvent);
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: Sem Post for gNfceeDiscCbEvent", __func__);
+        // usleep(1000000); // wait for 1000 millisec
+        // wait for atleast 1 sec to receive all ntf
+        gNfceeDiscCbEvent.notifyOne();
+      }
+    } break;
+
+    case NFA_EE_DISCOVER_REQ_EVT: {
+      tNFA_EE_DISCOVER_REQ info = eventData->discover_req;
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_EE_DISCOVER_REQ_EVT; status=0x%X; num ee=%u", __func__,
+          eventData->discover_req.status, eventData->discover_req.num_ee);
+      if (nfcFL.nfcNxpEse && nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
+        MposManager::getInstance().hanldeEtsiReaderReqEvent(&info);
+      }
+    }
+      break;
 
-    ALOGV("%s: Start to register NFC-F system on DH", fn);
+    case NFA_EE_NO_CB_ERR_EVT:
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_EE_NO_CB_ERR_EVT  status=%u", fn, eventData->status);
+      break;
+
+    case NFA_EE_ADD_AID_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_EE_ADD_AID_EVT  status=%u", fn, eventData->status);
+      if (eventData->status == NFA_STATUS_BUFFER_FULL) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: AID routing table is FULL!!!", fn);
+        RoutingManager::getInstance().notifyLmrtFull();
+      }
+      SyncEventGuard guard(se.mAidAddRemoveEvent);
+      se.mAidAddRemoveEvent.notifyOne();
+    } break;
+
+    case NFA_EE_REMOVE_AID_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_EE_REMOVE_AID_EVT  status=%u", fn, eventData->status);
+      SyncEventGuard guard(se.mAidAddRemoveEvent);
+      se.mAidAddRemoveEvent.notifyOne();
+    } break;
+    case NFA_EE_ADD_APDU_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_EE_ADD_APDU_EVT  status=%u", fn, eventData->status);
+      if (eventData->status == NFA_STATUS_BUFFER_FULL) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: routing table is FULL!!!", fn);
+        RoutingManager::getInstance().notifyLmrtFull();
+      }
+      SyncEventGuard guard(se.mApduPaternAddRemoveEvent);
+      se.mApduPaternAddRemoveEvent.notifyOne();
+    } break;
+    case NFA_EE_REMOVE_APDU_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_EE_REMOVE_APDU_EVT  status=%u", fn, eventData->status);
+      SyncEventGuard guard(se.mApduPaternAddRemoveEvent);
+      se.mApduPaternAddRemoveEvent.notifyOne();
+    } break;
+    case NFA_EE_NEW_EE_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_EE_NEW_EE_EVT  h=0x%X; status=%u", fn,
+          eventData->new_ee.ee_handle, eventData->new_ee.ee_status);
+    } break;
+    case NFA_EE_ROUT_ERR_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_EE_ROUT_ERR_EVT  status=%u", fn, eventData->status);
+    } break;
+    case NFA_EE_UPDATED_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: NFA_EE_UPDATED_EVT", fn);
+      SyncEventGuard guard(routingManager.mEeUpdateEvent);
+      routingManager.mEeUpdateEvent.notifyOne();
+      routingManager.LmrtRspTimer.kill();
+    } break;
+    default:
+      LOG(ERROR) << StringPrintf("%s: unknown event=%u ????", fn, event);
+      break;
+  }
+}
 
-    if (t3tIdLen != (2 + NCI_RF_F_UID_LEN ))
-    {
-        ALOGE ("%s: Invalid length of T3T Identifier", fn);
-        return NFA_HANDLE_INVALID;
-    }
+#if (NXP_EXTNS == TRUE)
+#if (NXP_NFCC_HCE_F == TRUE)
+void RoutingManager::notifyT3tConfigure() {
+  JNIEnv* e = NULL;
+  ScopedAttach attach(mNativeData->vm, &e);
+  if (e == NULL) {
+    LOG(ERROR) << StringPrintf("jni env is null");
+    return;
+  }
+
+  e->CallVoidMethod(mNativeData->manager,
+                    android::gCachedNfcManagerNotifyT3tConfigure);
+  if (e->ExceptionCheck()) {
+    e->ExceptionClear();
+    LOG(ERROR) << StringPrintf("fail notify");
+  }
+}
+#endif
+void RoutingManager::notifyReRoutingEntry() {
+  JNIEnv* e = NULL;
+  ScopedAttach attach(mNativeData->vm, &e);
+  if (e == NULL) {
+    LOG(ERROR) << StringPrintf("jni env is null");
+    return;
+  }
+
+  e->CallVoidMethod(mNativeData->manager,
+                    android::gCachedNfcManagerNotifyReRoutingEntry);
+  if (e->ExceptionCheck()) {
+    e->ExceptionClear();
+    LOG(ERROR) << StringPrintf("fail notify");
+  }
+}
+#endif
 
-#if(NXP_EXTNS == TRUE && NXP_NFCC_HCE_F == TRUE)
-    if (android::nfcManager_getTransanctionRequest(0, true))
-    {
-        ALOGV("%s: Busy in nfcManager_getTransanctionRequest", fn);
-        return NFA_HANDLE_INVALID;
-    }
+int RoutingManager::registerT3tIdentifier(uint8_t* t3tId, uint8_t t3tIdLen) {
+  static const char fn[] = "RoutingManager::registerT3tIdentifier";
 
-    if (android::isDiscoveryStarted()) {
-      // Stop RF discovery to reconfigure
-      android::startRfDiscovery(false);
-    }
-#endif
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Start to register NFC-F system on DH", fn);
 
-    SyncEventGuard guard (mRoutingEvent);
-    mNfcFOnDhHandle = NFA_HANDLE_INVALID;
+  if (t3tIdLen != (2 + NCI_RF_F_UID_LEN + NCI_T3T_PMM_LEN)) {
+    LOG(ERROR) << StringPrintf("%s: Invalid length of T3T Identifier", fn);
+    return NFA_HANDLE_INVALID;
+  }
 
-    int systemCode;
-    uint8_t nfcid2[NCI_RF_F_UID_LEN];
+#if (NXP_EXTNS == TRUE && NXP_NFCC_HCE_F == TRUE)
+  if (android::nfcManager_getTransanctionRequest(0, true)) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Busy in nfcManager_getTransanctionRequest", fn);
+    return NFA_HANDLE_INVALID;
+  }
 
-    systemCode = (((int)t3tId[0] << 8) | ((int)t3tId[1] << 0));
-    memcpy(nfcid2, t3tId + 2, NCI_RF_F_UID_LEN);
+  if (android::isDiscoveryStarted()) {
+    // Stop RF discovery to reconfigure
+    android::startRfDiscovery(false);
+  }
+#endif
 
-    tNFA_STATUS nfaStat = NFA_CeRegisterFelicaSystemCodeOnDH (systemCode, nfcid2, nfcFCeCallback);
-    if (nfaStat == NFA_STATUS_OK)
-    {
-        mRoutingEvent.wait ();
-    }
-    else
-    {
-        ALOGE ("%s: Fail to register NFC-F system on DH", fn);
-        return NFA_HANDLE_INVALID;
-    }
+  mNfcFOnDhHandle = NFA_HANDLE_INVALID;
 
-    ALOGV("%s: Succeed to register NFC-F system on DH", fn);
+  uint16_t systemCode;
+  uint8_t nfcid2[NCI_RF_F_UID_LEN];
+  uint8_t t3tPmm[NCI_T3T_PMM_LEN];
 
-    return mNfcFOnDhHandle;
-}
+  systemCode = (((int)t3tId[0] << 8) | ((int)t3tId[1] << 0));
+  memcpy(nfcid2, t3tId + 2, NCI_RF_F_UID_LEN);
+  memcpy(t3tPmm, t3tId + 10, NCI_T3T_PMM_LEN);
 
-void RoutingManager::deregisterT3tIdentifier(int handle)
-{
-    static const char fn [] = "RoutingManager::deregisterT3tIdentifier";
-    ALOGV("%s: Start to deregister NFC-F system on DH", fn);
-#if(NXP_EXTNS == TRUE && NXP_NFCC_HCE_F == TRUE)
-    bool enable = false;
-    if (android::nfcManager_getTransanctionRequest(handle, false))
-    {
-        ALOGV("%s: Busy in nfcManager_getTransanctionRequest", fn);
-        return;
-    }
-    else if (android::isDiscoveryStarted())
-    {
-        // Stop RF discovery to reconfigure
-        android::startRfDiscovery(false);
-        enable = true;
-    }
+  {
+    SyncEventGuard guard(mRoutingEvent);
+    tNFA_STATUS nfaStat = NFA_CeRegisterFelicaSystemCodeOnDH(
+        systemCode, nfcid2, t3tPmm, nfcFCeCallback);
+    if (nfaStat == NFA_STATUS_OK) {
+      mRoutingEvent.wait();
+    } else {
+      LOG(ERROR) << StringPrintf("%s: Fail to register NFC-F system on DH", fn);
+      return NFA_HANDLE_INVALID;
+    }
+   }
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Succeed to register NFC-F system on DH", fn);
+
+  // Register System Code for routing
+  if (mIsScbrSupported) {
+    SyncEventGuard guard(mRoutingEvent);
+    tNFA_STATUS nfaStat = NFA_EeAddSystemCodeRouting(systemCode, NCI_DH_ID,
+                                                     SYS_CODE_PWR_STATE_HOST);
+    if (nfaStat == NFA_STATUS_OK) {
+      mRoutingEvent.wait();
+    }
+    if ((nfaStat != NFA_STATUS_OK) || (mCbEventData.status != NFA_STATUS_OK)) {
+      LOG(ERROR) << StringPrintf("%s: Fail to register system code on DH", fn);
+      return NFA_HANDLE_INVALID;
+    }
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Succeed to register system code on DH", fn);
+    // add handle and system code pair to the map
+    mMapScbrHandle.emplace(mNfcFOnDhHandle, systemCode);
+  } else {
+    LOG(ERROR) << StringPrintf("%s: SCBR Not supported", fn);
+  }
+
+  return mNfcFOnDhHandle;
+}
+
+void RoutingManager::deregisterT3tIdentifier(int handle) {
+  static const char fn[] = "RoutingManager::deregisterT3tIdentifier";
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Start to deregister NFC-F system on DH", fn);
+#if (NXP_EXTNS == TRUE && NXP_NFCC_HCE_F == TRUE)
+  bool enable = false;
+  if (android::nfcManager_getTransanctionRequest(handle, false)) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Busy in nfcManager_getTransanctionRequest", fn);
+    return;
+  } else if (android::isDiscoveryStarted()) {
+    // Stop RF discovery to reconfigure
+    android::startRfDiscovery(false);
+    enable = true;
+  }
 #endif
-    SyncEventGuard guard (mRoutingEvent);
-    tNFA_STATUS nfaStat = NFA_CeDeregisterFelicaSystemCodeOnDH (handle);
-    if (nfaStat == NFA_STATUS_OK)
-    {
-        mRoutingEvent.wait ();
-        ALOGV("%s: Succeeded in deregistering NFC-F system on DH", fn);
-    }
-    else
-    {
-        ALOGE("%s: Fail to deregister NFC-F system on DH", fn);
-    }
-#if(NXP_EXTNS == TRUE && NXP_NFCC_HCE_F == TRUE)
-    if(enable)
-    {
-        // Stop RF discovery to reconfigure
-        android::startRfDiscovery(true);
-    }
+   {
+    SyncEventGuard guard(mRoutingEvent);
+    tNFA_STATUS nfaStat = NFA_CeDeregisterFelicaSystemCodeOnDH(handle);
+    if (nfaStat == NFA_STATUS_OK) {
+      mRoutingEvent.wait();
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: Succeeded in deregistering NFC-F system on DH", fn);
+    } else {
+      LOG(ERROR) << StringPrintf("%s: Fail to deregister NFC-F system on DH",
+                                 fn);
+    }
+  }
+  if (mIsScbrSupported) {
+    map<int, uint16_t>::iterator it = mMapScbrHandle.find(handle);
+    // find system code for given handle
+    if (it != mMapScbrHandle.end()) {
+      uint16_t systemCode = it->second;
+      mMapScbrHandle.erase(handle);
+      if (systemCode != 0) {
+        SyncEventGuard guard(mRoutingEvent);
+        tNFA_STATUS nfaStat = NFA_EeRemoveSystemCodeRouting(systemCode);
+        if (nfaStat == NFA_STATUS_OK) {
+          mRoutingEvent.wait();
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "%s: Succeeded in deregistering system Code on DH", fn);
+        } else {
+          LOG(ERROR) << StringPrintf("%s: Fail to deregister system Code on DH",
+                                     fn);
+        }
+      }
+    }
+   }
+#if (NXP_EXTNS == TRUE && NXP_NFCC_HCE_F == TRUE)
+  if (enable) {
+    // Stop RF discovery to reconfigure
+    android::startRfDiscovery(true);
+  }
 #endif
 }
 
-void RoutingManager::nfcFCeCallback (uint8_t event, tNFA_CONN_EVT_DATA* eventData)
-{
-    static const char fn [] = "RoutingManager::nfcFCeCallback";
-    RoutingManager& routingManager = RoutingManager::getInstance();
+void RoutingManager::nfcFCeCallback(uint8_t event,
+                                    tNFA_CONN_EVT_DATA* eventData) {
+  static const char fn[] = "RoutingManager::nfcFCeCallback";
+  RoutingManager& routingManager = RoutingManager::getInstance();
 
 #if (NXP_EXTNS == TRUE)
-    SecureElement& se = SecureElement::getInstance();
+  SecureElement& se = SecureElement::getInstance();
 #endif
 
-    ALOGV("%s: 0x%x", __func__, event);
-
-    switch (event)
-    {
-    case NFA_CE_REGISTERED_EVT:
-        {
-            ALOGV("%s: registerd event notified", fn);
-           routingManager.mNfcFOnDhHandle = eventData->ce_registered.handle;
-            SyncEventGuard guard(routingManager.mRoutingEvent);
-            routingManager.mRoutingEvent.notifyOne();
-        }
-        break;
-    case NFA_CE_DEREGISTERED_EVT:
-        {
-            ALOGV("%s: deregisterd event notified", fn);
-            SyncEventGuard guard(routingManager.mRoutingEvent);
-            routingManager.mRoutingEvent.notifyOne();
-        }
-        break;
-   case NFA_CE_ACTIVATED_EVT:
-        {
-            ALOGV("%s: activated event notified", fn);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: 0x%x", __func__, event);
+
+  switch (event) {
+    case NFA_CE_REGISTERED_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: registerd event notified", fn);
+      routingManager.mNfcFOnDhHandle = eventData->ce_registered.handle;
+      SyncEventGuard guard(routingManager.mRoutingEvent);
+      routingManager.mRoutingEvent.notifyOne();
+    } break;
+    case NFA_CE_DEREGISTERED_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: deregisterd event notified", fn);
+      SyncEventGuard guard(routingManager.mRoutingEvent);
+      routingManager.mRoutingEvent.notifyOne();
+    } break;
+    case NFA_CE_ACTIVATED_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: activated event notified", fn);
 #if (NXP_EXTNS == TRUE)
-            android::checkforTranscation(NFA_CE_ACTIVATED_EVT, (void *)eventData);
+      android::checkforTranscation(NFA_CE_ACTIVATED_EVT, (void*)eventData);
 #endif
-            routingManager.notifyActivated(NFA_TECHNOLOGY_MASK_F);
-        }
-        break;
-    case NFA_CE_DEACTIVATED_EVT:
-        {
-            ALOGV("%s: deactivated event notified", fn);
+      routingManager.notifyActivated(NFA_TECHNOLOGY_MASK_F);
+    } break;
+    case NFA_CE_DEACTIVATED_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: deactivated event notified", fn);
 #if (NXP_EXTNS == TRUE)
-            android::checkforTranscation(NFA_CE_DEACTIVATED_EVT, (void *)eventData);
+      android::checkforTranscation(NFA_CE_DEACTIVATED_EVT, (void*)eventData);
 #endif
-            routingManager.notifyDeactivated(NFA_TECHNOLOGY_MASK_F);
-        }
-        break;
-    case NFA_CE_DATA_EVT:
-        {
-            ALOGV("%s: data event notified", fn);
+      routingManager.notifyDeactivated(NFA_TECHNOLOGY_MASK_F);
+    } break;
+    case NFA_CE_DATA_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: data event notified", fn);
 
 #if (NXP_EXTNS == TRUE)
-            if(nfcFL.nfcNxpEse && (nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME !=
-                    nfcFL.eseFL._ESE_WIRED_MODE_RESUME)) {
-                se.setDwpTranseiveState(false, NFCC_CE_DATA_EVT);
-            }
+      if (nfcFL.nfcNxpEse && (nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME !=
+                              nfcFL.eseFL._ESE_WIRED_MODE_RESUME)) {
+        se.setDwpTranseiveState(false, NFCC_CE_DATA_EVT);
+      }
 #endif
-            tNFA_CE_DATA& ce_data = eventData->ce_data;
-            routingManager.handleData(NFA_TECHNOLOGY_MASK_F, ce_data.p_data, ce_data.len, ce_data.status);
-        }
-        break;
-    default:
-        {
-            ALOGE("%s: unknown event=%u ????", fn, event);
-        }
-        break;
-    }
+      tNFA_CE_DATA& ce_data = eventData->ce_data;
+      routingManager.handleData(NFA_TECHNOLOGY_MASK_F, ce_data.p_data,
+                                ce_data.len, ce_data.status);
+    } break;
+    default: {
+      LOG(ERROR) << StringPrintf("%s: unknown event=%u ????", fn, event);
+    } break;
+  }
 }
 
-int RoutingManager::registerJniFunctions (JNIEnv* e)
-{
-    static const char fn [] = "RoutingManager::registerJniFunctions";
-    ALOGV("%s", fn);
-    return jniRegisterNativeMethods (e, "com/android/nfc/cardemulation/AidRoutingManager", sMethods, NELEM(sMethods));
+int RoutingManager::registerJniFunctions(JNIEnv* e) {
+  static const char fn[] = "RoutingManager::registerJniFunctions";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", fn);
+  return jniRegisterNativeMethods(
+      e, "com/android/nfc/cardemulation/AidRoutingManager", sMethods,
+      NELEM(sMethods));
 }
 
-int RoutingManager::com_android_nfc_cardemulation_doGetDefaultRouteDestination (JNIEnv*)
-{
-    return getInstance().mDefaultEe;
+int RoutingManager::com_android_nfc_cardemulation_doGetDefaultRouteDestination(
+    JNIEnv*) {
+  return getInstance().mDefaultEe;
 }
 
-int RoutingManager::com_android_nfc_cardemulation_doGetDefaultOffHostRouteDestination (JNIEnv*)
-{
-    return getInstance().mOffHostEe;
+int RoutingManager::
+    com_android_nfc_cardemulation_doGetDefaultOffHostRouteDestination(JNIEnv*) {
+  return getInstance().mDefaultOffHostRoute;
 }
 
-int RoutingManager::com_android_nfc_cardemulation_doGetAidMatchingMode (JNIEnv*)
-{
-    return getInstance().mAidMatchingMode;
+int RoutingManager::com_android_nfc_cardemulation_doGetAidMatchingMode(
+    JNIEnv*) {
+  return getInstance().mAidMatchingMode;
 }
 
-
-int RoutingManager::com_android_nfc_cardemulation_doGetAidMatchingPlatform(JNIEnv*)
-{
-    return getInstance().mAidMatchingPlatform;
+int RoutingManager::com_android_nfc_cardemulation_doGetAidMatchingPlatform(
+    JNIEnv*) {
+  return getInstance().mAidMatchingPlatform;
 }
 
 /*
 *This fn gets called when timer gets expired.
-*When reader requested events (add for polling tech - tech A/tech B)comes it is expected to come back to back with in timer expiry value(50ms)
-*case 1:If all the add request comes before the timer expiry , poll request for all isn handled
+*When reader requested events (add for polling tech - tech A/tech B)comes it is
+expected to come back to back with in timer expiry value(50ms)
+*case 1:If all the add request comes before the timer expiry , poll request for
+all isn handled
 *case 2:If the second add request comes after timer expiry, it is not handled
 
-*When reader requested events (remove polling tech - tech A/tech B)comes it is expected to come back to back for the add requestes before
+*When reader requested events (remove polling tech - tech A/tech B)comes it is
+expected to come back to back for the add requestes before
  timer expiry happens(50ms)
-*case 1:If all the removal request comes before the timer expiry , poll removal  request for all is handled
-*case 2:If the only one of the removal request is reached before timer expiry, it is not handled
-           :When ever the second removal request is also reached , it is handled.
+*case 1:If all the removal request comes before the timer expiry , poll removal
+request for all is handled
+*case 2:If the only one of the removal request is reached before timer expiry,
+it is not handled
+           :When ever the second removal request is also reached , it is
+handled.
 
 */
-#if(NXP_EXTNS == TRUE)
-void reader_req_event_ntf (union sigval)
-{
-    if(!nfcFL.nfcNxpEse || !nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
-        ALOGV("%s: nfcNxpEse or ETSI_READER not available. Returning", __func__);
-        return;
-    }
-    static const char fn [] = "RoutingManager::reader_req_event_ntf";
-    ALOGV("%s:  ", fn);
-    JNIEnv* e = NULL;
-    int disc_ntf_timeout = 10;
-    ScopedAttach attach(RoutingManager::getInstance().mNativeData->vm, &e);
-    if (e == NULL)
-    {
-        ALOGE("%s: jni env is null", fn);
-        return;
-    }
-
-    GetNumValue ( NAME_NFA_DM_DISC_NTF_TIMEOUT, &disc_ntf_timeout, sizeof ( disc_ntf_timeout ) );
-
-    Rdr_req_ntf_info_t mSwp_info = RoutingManager::getInstance().getSwpRrdReqInfo();
-
-    ALOGV("%s: swp_rdr_req_ntf_info.swp_rd_req_info.src = 0x%4x ", fn,mSwp_info.swp_rd_req_info.src);
-
-    if(RoutingManager::getInstance().getEtsiReaederState() == STATE_SE_RDR_MODE_START_CONFIG)
-    {
-        e->CallVoidMethod (RoutingManager::getInstance().mNativeData->manager, android::gCachedNfcManagerNotifyETSIReaderModeStartConfig, (uint16_t)mSwp_info.swp_rd_req_info.src);
-    }
-    else if(RoutingManager::getInstance().getEtsiReaederState() == STATE_SE_RDR_MODE_STOP_CONFIG)
-    {
-        ALOGV("%s: sSwpReaderTimer.kill() ", fn);
-        SecureElement::getInstance().sSwpReaderTimer.kill();
-        e->CallVoidMethod (RoutingManager::getInstance().mNativeData->manager, android::gCachedNfcManagerNotifyETSIReaderModeStopConfig,disc_ntf_timeout);
-    }
-}
+#if (NXP_EXTNS == TRUE)
 extern int active_ese_reset_control;
 #endif
 
-void *ee_removed_ntf_handler_thread(void *data)
-{
-    static const char fn [] = "ee_removed_ntf_handler_thread";
-    tNFA_STATUS stat = NFA_STATUS_FAILED;
-    SecureElement &se = SecureElement::getInstance();
-    RoutingManager &rm = RoutingManager::getInstance();
-    ALOGV("%s: Enter: ", fn);
-    rm.mResetHandlerMutex.lock();
-    ALOGV("%s: enter sEseRemovedHandlerMutex lock", fn);
-    if(nfcFL.nfccFL._NFCEE_REMOVED_NTF_RECOVERY) {
-        NFA_HciW4eSETransaction_Complete(Release);
-    }
-
-    if(nfcFL.nfcNxpEse && nfcFL.eseFL._WIRED_MODE_STANDBY && se.mIsWiredModeOpen)
-    {
-        stat = se.setNfccPwrConfig(se.NFCC_DECIDES);
-        if(stat != NFA_STATUS_OK)
-        {
-            ALOGV("%s: power link command failed", __func__);
-        }
-    }
+void* ee_removed_ntf_handler_thread(void* data) {
+  static const char fn[] = "ee_removed_ntf_handler_thread";
+  tNFA_STATUS stat = NFA_STATUS_FAILED;
+  SecureElement& se = SecureElement::getInstance();
+  RoutingManager& rm = RoutingManager::getInstance();
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Enter: ", fn);
+  rm.mResetHandlerMutex.lock();
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter sEseRemovedHandlerMutex lock", fn);
+  if (nfcFL.nfccFL._NFCEE_REMOVED_NTF_RECOVERY) {
+    NFA_HciW4eSETransaction_Complete(Release);
+  }
+
+  if (nfcFL.nfcNxpEse && nfcFL.eseFL._WIRED_MODE_STANDBY &&
+      se.mIsWiredModeOpen) {
+    stat = se.setNfccPwrConfig(se.NFCC_DECIDES);
+    if (stat != NFA_STATUS_OK) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: power link command failed", __func__);
+    }
+  }
+  {
+    SyncEventGuard guard(se.mEeSetModeEvent);
     stat = NFA_EeModeSet(SecureElement::EE_HANDLE_0xF3, NFA_EE_MD_DEACTIVATE);
 
-    if(stat == NFA_STATUS_OK)
-    {
-        SyncEventGuard guard (se.mEeSetModeEvent);
-        se.mEeSetModeEvent.wait ();
-    }
-    if(nfcFL.nfcNxpEse) {
-        se.NfccStandByOperation(STANDBY_GPIO_LOW);
-        usleep(10*1000);
-        se.NfccStandByOperation(STANDBY_GPIO_HIGH);
-        if(nfcFL.eseFL._WIRED_MODE_STANDBY && se.mIsWiredModeOpen)
-        {
-            stat = se.setNfccPwrConfig(se.POWER_ALWAYS_ON|se.COMM_LINK_ACTIVE);
-            if(stat != NFA_STATUS_OK)
-            {
-                ALOGV("%s: power link command failed", __func__);
-            }
-        }
-    }
+    if (stat == NFA_STATUS_OK) {
+      if (se.mEeSetModeEvent.wait(500) == false) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s:SetMode rsp timeout", __func__);
+      }
+    }
+  }
+  if (nfcFL.nfcNxpEse) {
+    se.NfccStandByOperation(STANDBY_GPIO_LOW);
+    usleep(10 * 1000);
+    se.NfccStandByOperation(STANDBY_GPIO_HIGH);
+    if (nfcFL.eseFL._WIRED_MODE_STANDBY && se.mIsWiredModeOpen) {
+      stat = se.setNfccPwrConfig(se.POWER_ALWAYS_ON | se.COMM_LINK_ACTIVE);
+      if (stat != NFA_STATUS_OK) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: power link command failed", __func__);
+      }
+    }
+  }
+  if (nfcFL.eseFL._WIRED_MODE_STANDBY) {
+    SyncEventGuard guard(se.mModeSetNtf);
     stat = NFA_EeModeSet(SecureElement::EE_HANDLE_0xF3, NFA_EE_MD_ACTIVATE);
-
-    if(stat == NFA_STATUS_OK)
-    {
-        SyncEventGuard guard (se.mEeSetModeEvent);
-        if(se.mEeSetModeEvent.wait (500) == false)
-        {
-            ALOGV("%s:SetMode ntf timeout", __func__);
-        }
-    }
-    rm.mResetHandlerMutex.unlock();
-#if(NXP_EXTNS == TRUE)
-    if(nfcFL.nfcNxpEse) {
-        if(active_ese_reset_control & TRANS_WIRED_ONGOING)
-        {
-            SyncEventGuard guard(se.mTransceiveEvent);
-            se.mTransceiveEvent.notifyOne();
-        }
-        if(nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE) {
-            /* restart the discovery */
-            usleep(100 * 100);
-            if (android::isDiscoveryStarted() == true)
-            {
-
-                android::startRfDiscovery(false);
-                usleep(100 * 100);
-                android::startRfDiscovery(true);
-            }
-        }
-    }
-#endif
-    ALOGV("%s: exit sEseRemovedHandlerMutex lock ", fn);
-    ALOGV("%s: exit ", fn);
-    pthread_exit(NULL);
-    return NULL;
-}
-
-void RoutingManager::ee_removed_disc_ntf_handler(tNFA_HANDLE handle, tNFA_EE_STATUS status)
-{
-    static const char fn [] = "RoutingManager::ee_disc_ntf_handler";
-    pthread_t thread;
-    pthread_attr_t attr;
-    pthread_attr_init(&attr);
-    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-    ALOGE("%s; ee_handle=0x0%x, status=0x0%x", fn, handle, status);
-    if (pthread_create (&thread, &attr,  &ee_removed_ntf_handler_thread, (void*)NULL) < 0)
-    {
-        ALOGV("Thread creation failed");
-    }
-    else
-    {
-        ALOGV("Thread creation success");
-    }
-    pthread_attr_destroy(&attr);
-}
-#if(NXP_EXTNS == TRUE)
-/*******************************************************************************
-**
-** Function:        getEtsiReaederState
-**
-** Description:     Get the current ETSI Reader state
-**
-** Returns:         Current ETSI state
-**
-*******************************************************************************/
-se_rd_req_state_t RoutingManager::getEtsiReaederState()
-{
-    if(!nfcFL.nfcNxpEse || !nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
-        ALOGV("%s : nfcNxpEse or ETSI_READER not avaialble.Returning",__func__);
-    }
-    return swp_rdr_req_ntf_info.swp_rd_state;
-}
-
-/*******************************************************************************
-**
-** Function:        setEtsiReaederState
-**
-** Description:     Set the current ETSI Reader state
-**
-** Returns:         None
-**
-*******************************************************************************/
-void RoutingManager::setEtsiReaederState(se_rd_req_state_t newState)
-{
-    if(!nfcFL.nfcNxpEse || !nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
-        ALOGV("%s : nfcNxpEse or ETSI_READER not avaialble.Returning",__func__);
-        return;
+    if (stat == NFA_STATUS_OK) {
+      if (se.mModeSetNtf.wait(500) == false) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s:SetMode ntf timeout", __func__);
+      } else {
+        // do nothing
+      }
+    } else {
+      // do nothing
     }
-    swp_rdr_req_ntf_info.mMutex.lock();
-    if(newState == STATE_SE_RDR_MODE_STOPPED)
-    {
-        swp_rdr_req_ntf_info.swp_rd_req_current_info.tech_mask &= ~NFA_TECHNOLOGY_MASK_A;
-        swp_rdr_req_ntf_info.swp_rd_req_current_info.tech_mask &= ~NFA_TECHNOLOGY_MASK_B;
-
-        //If all the requested tech are removed, set the hande to invalid , so that next time poll add request can be handled
-
-        swp_rdr_req_ntf_info.swp_rd_req_current_info.src = NFA_HANDLE_INVALID;
-        swp_rdr_req_ntf_info.swp_rd_req_info = swp_rdr_req_ntf_info.swp_rd_req_current_info;
+  } else {
+    SyncEventGuard guard(se.mEeSetModeEvent);
+    stat = NFA_EeModeSet(SecureElement::EE_HANDLE_0xF3, NFA_EE_MD_ACTIVATE);
+    if (stat == NFA_STATUS_OK) {
+      if (se.mEeSetModeEvent.wait(500) == false) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s:SetMode rsp timeout", __func__);
+      } else {
+        // do nothing
+      }
+    } else {
+      // do nothing
     }
-    swp_rdr_req_ntf_info.swp_rd_state = newState;
-    swp_rdr_req_ntf_info.mMutex.unlock();
-}
-
-/*******************************************************************************
-**
-** Function:        getSwpRrdReqInfo
-**
-** Description:     get swp_rdr_req_ntf_info
-**
-** Returns:         swp_rdr_req_ntf_info
-**
-*******************************************************************************/
-Rdr_req_ntf_info_t RoutingManager::getSwpRrdReqInfo()
-{
-    ALOGE("%s Enter",__func__);
-    if(!nfcFL.nfcNxpEse || !nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
-        ALOGV("%s : nfcNxpEse or ETSI_READER not avaialble.Returning",__func__);
+  }
+  rm.mResetHandlerMutex.unlock();
+#if (NXP_EXTNS == TRUE)
+  if (nfcFL.nfcNxpEse) {
+    if (active_ese_reset_control & TRANS_WIRED_ONGOING) {
+      SyncEventGuard guard(se.mTransceiveEvent);
+      se.mTransceiveEvent.notifyOne();
+    }
+    if (nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE) {
+      /* restart the discovery */
+      usleep(100 * 100);
+      if (android::isDiscoveryStarted() == true) {
+        android::startRfDiscovery(false);
+        usleep(100 * 100);
+        android::startRfDiscovery(true);
+      }
     }
-    return swp_rdr_req_ntf_info;
-}
+  }
 #endif
-
-#if(NXP_EXTNS == TRUE)
-bool RoutingManager::is_ee_recovery_ongoing()
-{
-    static const char fn [] = "RoutingManager::is_ee_recovery_ongoing";
-    if(!nfcFL.nfccFL._NFCEE_REMOVED_NTF_RECOVERY) {
-        ALOGV("%s : NFCEE_REMOVED_NTF_RECOVERY not avaialble.Returning",__func__);
-        return false;
-    }
-    ALOGV("%s := %s", fn, ((recovery==true) ? "true" : "false" ));
-    return recovery;
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit sEseRemovedHandlerMutex lock ", fn);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit ", fn);
+  pthread_exit(NULL);
+  return NULL;
+}
+
+void RoutingManager::ee_removed_disc_ntf_handler(tNFA_HANDLE handle,
+                                                 tNFA_EE_STATUS status) {
+  static const char fn[] = "RoutingManager::ee_disc_ntf_handler";
+  pthread_t thread;
+  pthread_attr_t attr;
+  pthread_attr_init(&attr);
+  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+  LOG(ERROR) << StringPrintf("%s; ee_handle=0x0%x, status=0x0%x", fn, handle,
+                             status);
+  if (pthread_create(&thread, &attr, &ee_removed_ntf_handler_thread,
+                     (void*)NULL) < 0) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Thread creation failed");
+  } else {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Thread creation success");
+  }
+  pthread_attr_destroy(&attr);
 }
 
-void RoutingManager::setEERecovery(bool value)
-{
-    static const char fn [] = "RoutingManager::setEERecovery";
-    if(!nfcFL.nfccFL._NFCEE_REMOVED_NTF_RECOVERY) {
-        ALOGV("%s : NFCEE_REMOVED_NTF_RECOVERY not avaialble.Returning",__func__);
-        return;
-    }
-    ALOGV("%s: value %x", __func__,value);
-    recovery = value;
+#if (NXP_EXTNS == TRUE)
+bool RoutingManager::is_ee_recovery_ongoing() {
+  static const char fn[] = "RoutingManager::is_ee_recovery_ongoing";
+  if (!nfcFL.nfccFL._NFCEE_REMOVED_NTF_RECOVERY) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s : NFCEE_REMOVED_NTF_RECOVERY not avaialble.Returning", __func__);
+    return false;
+  }
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s := %s", fn, ((recovery == true) ? "true" : "false"));
+  return recovery;
+}
+
+void RoutingManager::setEERecovery(bool value) {
+  if (!nfcFL.nfccFL._NFCEE_REMOVED_NTF_RECOVERY) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s : NFCEE_REMOVED_NTF_RECOVERY not avaialble.Returning", __func__);
+    return;
+  }
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: value %x", __func__, value);
+  recovery = value;
 }
 
 /*******************************************************************************
@@ -3239,14 +3195,12 @@ void RoutingManager::setEERecovery(bool value)
 ** Returns:         None
 **
 *******************************************************************************/
-void RoutingManager::getRouting()
-{
-    tNFA_STATUS nfcStat;
-    nfcStat = NFC_GetRouting();
-    if(nfcStat == NFA_STATUS_OK)
-    {
-        ALOGE("getRouting failed. status=0x0%x", nfcStat);
-    }
+void RoutingManager::getRouting() {
+  tNFA_STATUS nfcStat;
+  nfcStat = NFC_GetRouting();
+  if (nfcStat == NFA_STATUS_OK) {
+    LOG(ERROR) << StringPrintf("getRouting failed. status=0x0%x", nfcStat);
+  }
 }
 
 /*******************************************************************************
@@ -3261,34 +3215,35 @@ void RoutingManager::getRouting()
 ** Returns:         None
 **
 *******************************************************************************/
-void RoutingManager::processGetRoutingRsp(tNFA_DM_CBACK_DATA* eventData, uint8_t* sRoutingBuff)
-{
-    ALOGV("%s : Enter", __func__);
-    uint8_t xx=0,numTLVs = 0,currPos = 0,curTLVLen = 0;
-    uint8_t sRoutingCurrent[256];
-    numTLVs = *(eventData->get_routing.param_tlvs+1);
-    /*Copying only routing Entries.
-    Skipping fields,
-    More                  : 1Byte
-    No of Routing Entries : 1Byte*/
-    memcpy(sRoutingCurrent,eventData->get_routing.param_tlvs+2,eventData->get_routing.tlv_size-2);
-
-    while(xx < numTLVs)
-    {
-        curTLVLen = *(sRoutingCurrent+currPos+1);
-        /*Filtering out Routing Entry corresponding to PROTOCOL_NFC_DEP*/
-        if((*(sRoutingCurrent+currPos) == PROTOCOL_BASED_ROUTING)&&(*(sRoutingCurrent+currPos+(curTLVLen+1))==NFA_PROTOCOL_NFC_DEP))
-        {
-            currPos = currPos + curTLVLen+TYPE_LENGTH_SIZE;
-        }
-        else
-        {
-            memcpy(sRoutingBuff+android::sRoutingBuffLen,sRoutingCurrent+currPos,curTLVLen+TYPE_LENGTH_SIZE);
-            currPos = currPos + curTLVLen+TYPE_LENGTH_SIZE;
-            android::sRoutingBuffLen = android::sRoutingBuffLen + curTLVLen+TYPE_LENGTH_SIZE;
-        }
-        xx++;
+void RoutingManager::processGetRoutingRsp(tNFA_DM_CBACK_DATA* eventData,
+                                          uint8_t* sRoutingBuff) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s : Enter", __func__);
+  uint8_t xx = 0, numTLVs = 0, currPos = 0, curTLVLen = 0;
+  uint8_t sRoutingCurrent[256];
+  numTLVs = *(eventData->get_routing.param_tlvs + 1);
+  /*Copying only routing Entries.
+  Skipping fields,
+  More                  : 1Byte
+  No of Routing Entries : 1Byte*/
+  memcpy(sRoutingCurrent, eventData->get_routing.param_tlvs + 2,
+         eventData->get_routing.tlv_size - 2);
+
+  while (xx < numTLVs) {
+    curTLVLen = *(sRoutingCurrent + currPos + 1);
+    /*Filtering out Routing Entry corresponding to PROTOCOL_NFC_DEP*/
+    if ((*(sRoutingCurrent + currPos) == PROTOCOL_BASED_ROUTING) &&
+        (*(sRoutingCurrent + currPos + (curTLVLen + 1)) ==
+         NFA_PROTOCOL_NFC_DEP)) {
+      currPos = currPos + curTLVLen + TYPE_LENGTH_SIZE;
+    } else {
+      memcpy(sRoutingBuff + android::sRoutingBuffLen, sRoutingCurrent + currPos,
+             curTLVLen + TYPE_LENGTH_SIZE);
+      currPos = currPos + curTLVLen + TYPE_LENGTH_SIZE;
+      android::sRoutingBuffLen =
+          android::sRoutingBuffLen + curTLVLen + TYPE_LENGTH_SIZE;
     }
+    xx++;
+  }
 }
 /*******************************************************************************
 **
@@ -3299,40 +3254,37 @@ void RoutingManager::processGetRoutingRsp(tNFA_DM_CBACK_DATA* eventData, uint8_t
 ** Returns:         None
 **
 *******************************************************************************/
-void RoutingManager::handleSERemovedNtf()
-{
-    if(!nfcFL.nfccFL._NFCEE_REMOVED_NTF_RECOVERY) {
-        ALOGV("%s : NFCEE_REMOVED_NTF_RECOVERY not avaialble.Returning",__func__);
-        return;
-    }
-    static const char fn [] = "RoutingManager::handleSERemovedNtf()";
-    uint8_t ActualNumEe = nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED;
-    tNFA_EE_INFO mEeInfo [ActualNumEe];
-    tNFA_STATUS nfaStat;
-    ALOGE("%s:Enter", __func__);
-    if ((nfaStat = NFA_AllEeGetInfo (&ActualNumEe, mEeInfo)) != NFA_STATUS_OK)
-    {
-        ALOGE("%s: fail get info; error=0x%X", fn, nfaStat);
-        ActualNumEe = 0;
-    }
-    else
-    {
-        if(( mChipId == pn65T) || (mChipId == pn66T) ||
-           (mChipId == pn67T) || (mChipId == pn80T))
-        {
-            for(int xx = 0; xx <  ActualNumEe; xx++)
-            {
-               ALOGE("xx=%d, ee_handle=0x0%x, status=0x0%x", xx, mEeInfo[xx].ee_handle,mEeInfo[xx].ee_status);
-                if ((mEeInfo[xx].ee_handle == SecureElement::EE_HANDLE_0xF3) &&
-                    (mEeInfo[xx].ee_status == 0x02))
-                {
-                    recovery = true;
-                    ee_removed_disc_ntf_handler(mEeInfo[xx].ee_handle, mEeInfo[xx].ee_status);
-                    break;
-                }
-            }
-        }
-    }
+void RoutingManager::handleSERemovedNtf() {
+  if (!nfcFL.nfccFL._NFCEE_REMOVED_NTF_RECOVERY) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s : NFCEE_REMOVED_NTF_RECOVERY not avaialble.Returning", __func__);
+    return;
+  }
+  static const char fn[] = "RoutingManager::handleSERemovedNtf()";
+  uint8_t ActualNumEe = nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED;
+  tNFA_EE_INFO mEeInfo[ActualNumEe];
+  tNFA_STATUS nfaStat;
+  LOG(ERROR) << StringPrintf("%s:Enter", __func__);
+  if ((nfaStat = NFA_AllEeGetInfo(&ActualNumEe, mEeInfo)) != NFA_STATUS_OK) {
+    LOG(ERROR) << StringPrintf("%s: fail get info; error=0x%X", fn, nfaStat);
+    ActualNumEe = 0;
+  } else {
+    if ((mChipId == pn65T) || (mChipId == pn66T) || (mChipId == pn67T) ||
+        (mChipId == pn80T)) {
+      for (int xx = 0; xx < ActualNumEe; xx++) {
+        LOG(ERROR) << StringPrintf("xx=%d, ee_handle=0x0%x, status=0x0%x", xx,
+                                   mEeInfo[xx].ee_handle,
+                                   mEeInfo[xx].ee_status);
+        if ((mEeInfo[xx].ee_handle == SecureElement::EE_HANDLE_0xF3) &&
+            (mEeInfo[xx].ee_status == 0x02)) {
+          recovery = true;
+          ee_removed_disc_ntf_handler(mEeInfo[xx].ee_handle,
+                                      mEeInfo[xx].ee_status);
+          break;
+        }
+      }
+    }
+  }
 }
 /*******************************************************************************
 **
@@ -3341,12 +3293,11 @@ void RoutingManager::handleSERemovedNtf()
 ** Description:     Routing Timer callback
 **
 *******************************************************************************/
-static void LmrtRspTimerCb(union sigval)
-{
-   static const char fn [] = "LmrtRspTimerCb";
-   ALOGV("%s:  ", fn);
-    SyncEventGuard guard(RoutingManager::getInstance().mEeUpdateEvent);
-    RoutingManager::getInstance().mEeUpdateEvent.notifyOne();
+static void LmrtRspTimerCb(union sigval) {
+  static const char fn[] = "LmrtRspTimerCb";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s:  ", fn);
+  SyncEventGuard guard(RoutingManager::getInstance().mEeUpdateEvent);
+  RoutingManager::getInstance().mEeUpdateEvent.notifyOne();
 }
 
 /*******************************************************************************
@@ -3358,25 +3309,20 @@ static void LmrtRspTimerCb(union sigval)
  ** Returns:         route location
  **
  *******************************************************************************/
-static jint getUiccRoute(jint uicc_slot)
-{
-    if(!nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) {
-        ALOGV("%s : STAT_DUAL_UICC_WO_EXT_SWITCH not avaialble.Returning",__func__);
-        0xFF;
-    }
-    ALOGV("%s: Enter slot num = %d", __func__,uicc_slot);
-    if((uicc_slot == 0x00) || (uicc_slot == 0x01))
-    {
-        return SecureElement::getInstance().EE_HANDLE_0xF4;
-    }
-    else if(uicc_slot == 0x02)
-    {
-        return SecureElement::EE_HANDLE_0xF8;
-    }
-    else
-    {
-        return 0xFF;
-    }
+static jint getUiccRoute(jint uicc_slot) {
+  if (!nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s : STAT_DUAL_UICC_WO_EXT_SWITCH not avaialble.Returning", __func__);
+    return 0xFF;
+  }
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Enter slot num = %d", __func__, uicc_slot);
+  if ((uicc_slot == 0x00) || (uicc_slot == 0x01)) {
+    return SecureElement::getInstance().EE_HANDLE_0xF4;
+  } else if (uicc_slot == 0x02) {
+    return SecureElement::EE_HANDLE_0xF8;
+  } else {
+    return 0xFF;
+  }
 }
 #endif
-
diff --git a/nci/jni/RoutingManager.h b/nci/jni/RoutingManager.h
old mode 100644
new mode 100755
index fc3e8dc8..7b1e53a8
--- a/nci/jni/RoutingManager.h
+++ b/nci/jni/RoutingManager.h
@@ -17,7 +17,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -36,299 +36,323 @@
  *  Manage the listen-mode routing table.
  */
 #pragma once
-#include "SyncEvent.h"
+#include <vector>
 #include "NfcJniUtil.h"
 #include "RouteDataSet.h"
 #include "SecureElement.h"
-#include <vector>
-extern "C"
-{
-    #include "nfa_api.h"
-    #include "nfa_ee_api.h"
-}
-#if(NXP_EXTNS == TRUE)
-#define TECHNOLOGY_BASED_ROUTING        0x00
-#define PROTOCOL_BASED_ROUTING          0x01
-#define AID_BASED_ROUTING               0x02
-#define AVAILABLE_PROTO_ENTRIES() ((NFA_GetNCIVersion() == NCI_VERSION_2_0)?0x02:0x03)
+#include "SyncEvent.h"
+#include "nfa_api.h"
+#include "nfa_ee_api.h"
+#include <map>
+
+using namespace std;
+
+#if (NXP_EXTNS == TRUE)
+#define TECHNOLOGY_BASED_ROUTING 0x00
+#define PROTOCOL_BASED_ROUTING 0x01
+#define AID_BASED_ROUTING 0x02
+#define AVAILABLE_PROTO_ENTRIES() \
+  ((NFA_GetNCIVersion() == NCI_VERSION_2_0) ? 0x02 : 0x03)
 
 /*Size of type and length Fields : No of bytes*/
-#define TYPE_LENGTH_SIZE                0x02
+#define TYPE_LENGTH_SIZE 0x02
 
-#define MAX_GET_ROUTING_BUFFER_SIZE     740
-#define EE_HCI_DEFAULT_HANDLE           0x401
+#define MAX_GET_ROUTING_BUFFER_SIZE 740
+#define EE_HCI_DEFAULT_HANDLE 0x401
 
 typedef struct protoroutInfo {
-    uint8_t ee_handle;
-    tNFA_PROTOCOL_MASK  protocols_switch_on;
-    tNFA_PROTOCOL_MASK  protocols_switch_off;
-    tNFA_PROTOCOL_MASK  protocols_battery_off;
-    tNFA_PROTOCOL_MASK  protocols_screen_lock;
-    tNFA_PROTOCOL_MASK  protocols_screen_off;
-    tNFA_PROTOCOL_MASK  protocols_screen_off_lock;
-}ProtoRoutInfo_t;
+  uint8_t ee_handle;
+  tNFA_PROTOCOL_MASK protocols_switch_on;
+  tNFA_PROTOCOL_MASK protocols_switch_off;
+  tNFA_PROTOCOL_MASK protocols_battery_off;
+  tNFA_PROTOCOL_MASK protocols_screen_lock;
+  tNFA_PROTOCOL_MASK protocols_screen_off;
+  tNFA_PROTOCOL_MASK protocols_screen_off_lock;
+} ProtoRoutInfo_t;
 
 typedef struct routeInfo {
-    uint8_t num_entries;
-    ProtoRoutInfo_t protoInfo[4];
-}RouteInfo_t;
+  uint8_t num_entries;
+  ProtoRoutInfo_t protoInfo[4];
+} RouteInfo_t;
 #define POWER_STATE_MASK 0xE7
 #define HOST_SCREEN_STATE_MASK 0x09
 #endif
 
-//FelicaOnHost
-typedef struct{
-
-    uint8_t nfcid2Len;
-    uint8_t sysCodeLen;
-    uint8_t optParamLen;
-    uint16_t nfcid2Handle;
-    uint8_t sysCode[2];
-    uint8_t nfcid2[8];
-    uint8_t* optParam;
-    uint8_t InUse;
+// FelicaOnHost
+typedef struct {
+  uint8_t nfcid2Len;
+  uint8_t sysCodeLen;
+  uint8_t optParamLen;
+  uint16_t nfcid2Handle;
+  uint8_t sysCode[2];
+  uint8_t nfcid2[8];
+  uint8_t* optParam;
+  uint8_t InUse;
 
-   // Mutex mMutex; /*add if it is required */
-}NfcID2_info_t;
+  // Mutex mMutex; /*add if it is required */
+} NfcID2_info_t;
 
-typedef struct
-{
-    uint8_t protocol;
-    uint16_t routeLoc;
-    uint8_t power;
-    uint8_t enable;
+typedef struct {
+  uint8_t protocol;
+  uint16_t routeLoc;
+  uint8_t power;
+  uint8_t enable;
 } protoEntry_t;
 
-typedef struct
-{
-    uint8_t technology;
-    uint16_t routeLoc;
-    uint8_t power;
-    uint8_t enable;
+typedef struct {
+  uint8_t technology;
+  uint16_t routeLoc;
+  uint8_t power;
+  uint8_t enable;
 } techEntry_t;
 
-typedef struct
-{
-    uint16_t nfceeID;//ID for the route location
-    tNFA_TECHNOLOGY_MASK    tech_switch_on;     /* default routing - technologies switch_on  */
-    tNFA_TECHNOLOGY_MASK    tech_switch_off;    /* default routing - technologies switch_off */
-    tNFA_TECHNOLOGY_MASK    tech_battery_off;   /* default routing - technologies battery_off*/
-    tNFA_TECHNOLOGY_MASK    tech_screen_lock;    /* default routing - technologies screen_lock*/
-    tNFA_TECHNOLOGY_MASK    tech_screen_off;   /* default routing - technologies screen_off*/
-    tNFA_TECHNOLOGY_MASK    tech_screen_off_lock;  /* default routing - technologies screen_off_lock*/
-    tNFA_PROTOCOL_MASK      proto_switch_on;    /* default routing - protocols switch_on     */
-    tNFA_PROTOCOL_MASK      proto_switch_off;   /* default routing - protocols switch_off    */
-    tNFA_PROTOCOL_MASK      proto_battery_off;  /* default routing - protocols battery_off   */
-    tNFA_PROTOCOL_MASK      proto_screen_lock;   /* default routing - protocols screen_lock    */
-    tNFA_PROTOCOL_MASK      proto_screen_off;  /* default routing - protocols screen_off  */
-    tNFA_PROTOCOL_MASK      proto_screen_off_lock;  /* default routing - protocols screen_off_lock  */
+typedef struct {
+  uint16_t nfceeID;  // ID for the route location
+  tNFA_TECHNOLOGY_MASK
+      tech_switch_on; /* default routing - technologies switch_on  */
+  tNFA_TECHNOLOGY_MASK
+      tech_switch_off; /* default routing - technologies switch_off */
+  tNFA_TECHNOLOGY_MASK
+      tech_battery_off; /* default routing - technologies battery_off*/
+  tNFA_TECHNOLOGY_MASK
+      tech_screen_lock; /* default routing - technologies screen_lock*/
+  tNFA_TECHNOLOGY_MASK
+      tech_screen_off; /* default routing - technologies screen_off*/
+  tNFA_TECHNOLOGY_MASK
+      tech_screen_off_lock; /* default routing - technologies screen_off_lock*/
+  tNFA_PROTOCOL_MASK
+      proto_switch_on; /* default routing - protocols switch_on     */
+  tNFA_PROTOCOL_MASK
+      proto_switch_off; /* default routing - protocols switch_off    */
+  tNFA_PROTOCOL_MASK
+      proto_battery_off; /* default routing - protocols battery_off   */
+  tNFA_PROTOCOL_MASK
+      proto_screen_lock; /* default routing - protocols screen_lock    */
+  tNFA_PROTOCOL_MASK
+      proto_screen_off; /* default routing - protocols screen_off  */
+  tNFA_PROTOCOL_MASK
+      proto_screen_off_lock; /* default routing - protocols screen_off_lock  */
 
 } LmrtEntry_t;
 
-class RoutingManager
-{
-public:
-#if(NXP_EXTNS == TRUE)
-    static const int NFA_SET_AID_ROUTING = 4;
-    static const int NFA_SET_TECHNOLOGY_ROUTING = 1;
-    static const int NFA_SET_PROTOCOL_ROUTING = 2;
-    nfc_jni_native_data* mNativeData;
+class RoutingManager {
+ public:
+#if (NXP_EXTNS == TRUE)
+  static const int NFA_SET_AID_ROUTING = 4;
+  static const int NFA_SET_TECHNOLOGY_ROUTING = 1;
+  static const int NFA_SET_PROTOCOL_ROUTING = 2;
+  nfc_jni_native_data* mNativeData;
 #endif
 
-    static const int ROUTE_HOST = 0;
-    static const int ROUTE_ESE = 1;
+  static const int ROUTE_HOST = 0;
+  static const int ROUTE_ESE = 1;
 
-    static RoutingManager& getInstance ();
-    bool initialize(nfc_jni_native_data* native);
-#if(NXP_EXTNS == TRUE)
-    void setRouting(bool);
-    void getRouting();
-    void registerProtoRouteEntry(tNFA_HANDLE ee_handle,
-                                 tNFA_PROTOCOL_MASK  protocols_switch_on,
-                                 tNFA_PROTOCOL_MASK  protocols_switch_off,
-                                 tNFA_PROTOCOL_MASK  protocols_battery_off,
-                                 tNFA_PROTOCOL_MASK  protocols_screen_lock,
-                                 tNFA_PROTOCOL_MASK  protocols_screen_off,
-                                 tNFA_PROTOCOL_MASK  protocols_screen_off_lock
-                                 );
-    void notifyReRoutingEntry();
-    void HandleAddNfcID2_Req();
-    void HandleRmvNfcID2_Req();
-    void setCeRouteStrictDisable(uint32_t state);
-    void setDefaultTechRouting (int seId, int tech_switchon,int tech_switchoff);
-    void setDefaultProtoRouting (int seId, int proto_switchon,int proto_switchoff);
-    void processGetRoutingRsp(tNFA_DM_CBACK_DATA* eventData, uint8_t* sRoutingBuff);
-    void nfaEEConnect();
-    void nfaEEDisconnect();
-    SyncEvent mEEDisconnectEvt;
-    bool setRoutingEntry(int type, int value, int route, int power);
-    bool clearRoutingEntry(int type);
-    bool setDefaultRoute(const int defaultRoute, const int protoRoute, const int techRoute);
-    bool clearAidTable ();
-    bool removeNfcid2Routing(uint8_t* nfcID2);
-    bool addAidRouting(const uint8_t* aid, uint8_t aidLen, int route, int power, int aidInfo);
-    int  addNfcid2Routing(uint8_t* nfcid2, uint8_t aidLen,const uint8_t* syscode,
-    int  syscodelen,const uint8_t* optparam, int optparamlen);
-    void handleSERemovedNtf();
-    bool is_ee_recovery_ongoing();
-    void setEtsiReaederState(se_rd_req_state_t newState);
-    se_rd_req_state_t getEtsiReaederState();
-    Rdr_req_ntf_info_t getSwpRrdReqInfo();
-#if(NXP_NFCC_HCE_F == TRUE)
-    void notifyT3tConfigure();
+  static RoutingManager& getInstance();
+  bool initialize(nfc_jni_native_data* native);
+#if (NXP_EXTNS == TRUE)
+  void setRouting(bool);
+  void getRouting();
+  void registerProtoRouteEntry(tNFA_HANDLE ee_handle,
+                               tNFA_PROTOCOL_MASK protocols_switch_on,
+                               tNFA_PROTOCOL_MASK protocols_switch_off,
+                               tNFA_PROTOCOL_MASK protocols_battery_off,
+                               tNFA_PROTOCOL_MASK protocols_screen_lock,
+                               tNFA_PROTOCOL_MASK protocols_screen_off,
+                               tNFA_PROTOCOL_MASK protocols_screen_off_lock);
+  void notifyReRoutingEntry();
+  void HandleAddNfcID2_Req();
+  void HandleRmvNfcID2_Req();
+  void setCeRouteStrictDisable(uint32_t state);
+  void setDefaultTechRouting(int seId, int tech_switchon, int tech_switchoff);
+  void setDefaultProtoRouting(int seId, int proto_switchon,
+                              int proto_switchoff);
+  void processGetRoutingRsp(tNFA_DM_CBACK_DATA* eventData,
+                            uint8_t* sRoutingBuff);
+  void nfaEEConnect();
+  void nfaEEDisconnect();
+  SyncEvent mEEDisconnectEvt;
+  bool setRoutingEntry(int type, int value, int route, int power);
+  bool clearRoutingEntry(int type);
+  bool setDefaultRoute(const int defaultRoute, const int protoRoute,
+                       const int techRoute);
+  bool clearAidTable();
+  bool removeNfcid2Routing(uint8_t* nfcID2);
+  bool addAidRouting(const uint8_t* aid, uint8_t aidLen, int route, int power,
+                     int aidInfo);
+  int addNfcid2Routing(uint8_t* nfcid2, uint8_t aidLen, const uint8_t* syscode,
+                       int syscodelen, const uint8_t* optparam,
+                       int optparamlen);
+  void handleSERemovedNtf();
+  bool is_ee_recovery_ongoing();
+#if (NXP_NFCC_HCE_F == TRUE)
+  void notifyT3tConfigure();
 #endif
 #else
-    bool addAidRouting(const uint8_t* aid, uint8_t aidLen, int route);
+  bool addAidRouting(const uint8_t* aid, uint8_t aidLen, int route,
+                     int aidInfo);
 #endif
 
-    bool addApduRouting(uint8_t route, uint8_t powerState,const uint8_t* apduData,
-         uint8_t apduDataLen ,const uint8_t* apduMask, uint8_t apduMaskLen);
+  bool addApduRouting(uint8_t route, uint8_t powerState,
+                      const uint8_t* apduData, uint8_t apduDataLen,
+                      const uint8_t* apduMask, uint8_t apduMaskLen);
 
-    bool removeApduRouting(uint8_t apduDataLen, const uint8_t* apduData);
-    void setEERecovery(bool value);
-    void cleanRouting();
-    bool removeAidRouting(const uint8_t* aid, uint8_t aidLen);
-    bool commitRouting();
-    int registerT3tIdentifier(uint8_t* t3tId, uint8_t t3tIdLen);
-    void deregisterT3tIdentifier(int handle);
-    void onNfccShutdown();
-    int registerJniFunctions (JNIEnv* e);
-    void ee_removed_disc_ntf_handler(tNFA_HANDLE handle, tNFA_EE_STATUS status);
-    SyncEvent mLmrtEvent;
-    SyncEvent mEeSetModeEvent;
-    SyncEvent mCeRegisterEvent;//FelicaOnHost
-    SyncEvent mCeDeRegisterEvent;
-    Mutex  mResetHandlerMutex;
-    IntervalTimer LmrtRspTimer;
-    SyncEvent mEeUpdateEvent;
-    IntervalTimer mNfcFRspTimer;
-private:
-    RoutingManager();
-    ~RoutingManager();
-    RoutingManager(const RoutingManager&);
-    RoutingManager& operator=(const RoutingManager&);
+  bool removeApduRouting(uint8_t apduDataLen, const uint8_t* apduData);
+  void setEERecovery(bool value);
+  void cleanRouting();
+  bool removeAidRouting(const uint8_t* aid, uint8_t aidLen);
+  bool commitRouting();
+  int registerT3tIdentifier(uint8_t* t3tId, uint8_t t3tIdLen);
+  void deregisterT3tIdentifier(int handle);
+  void onNfccShutdown();
+  int registerJniFunctions(JNIEnv* e);
+  void ee_removed_disc_ntf_handler(tNFA_HANDLE handle, tNFA_EE_STATUS status);
+  SyncEvent mLmrtEvent;
+  SyncEvent mEeSetModeEvent;
+  SyncEvent mCeRegisterEvent;  // FelicaOnHost
+  SyncEvent mCeDeRegisterEvent;
+  Mutex mResetHandlerMutex;
+  IntervalTimer LmrtRspTimer;
+  SyncEvent mEeUpdateEvent;
+  IntervalTimer mNfcFRspTimer;
 
-    void handleData (uint8_t technology, const uint8_t* data, uint32_t dataLen, tNFA_STATUS status);
-    void notifyActivated (uint8_t technology);
-    void notifyDeactivated (uint8_t technology);
-    void notifyLmrtFull();
-    void printMemberData(void);
-    void extractRouteLocationAndPowerStates(const int defaultRoute, const int protoRoute, const int techRoute);
-    uint16_t getUiccRouteLocId(const int route);
-    void initialiseTableEntries(void);
-    void compileProtoEntries(void);
-    void compileTechEntries(void);
-    void consolidateProtoEntries(void);
-    void consolidateTechEntries(void);
-    void setProtoRouting(void);
-#if(NXP_EXTNS == TRUE)
-    void setEmptyAidEntry(void);
+ private:
+  RoutingManager();
+  ~RoutingManager();
+  RoutingManager(const RoutingManager&);
+  RoutingManager& operator=(const RoutingManager&);
+
+  void handleData(uint8_t technology, const uint8_t* data, uint32_t dataLen,
+                  tNFA_STATUS status);
+  void notifyActivated(uint8_t technology);
+  void notifyDeactivated(uint8_t technology);
+  void notifyLmrtFull();
+  void printMemberData(void);
+  void extractRouteLocationAndPowerStates(const int defaultRoute,
+                                          const int protoRoute,
+                                          const int techRoute);
+  uint16_t getUiccRouteLocId(const int route);
+  void initialiseTableEntries(void);
+  void compileProtoEntries(void);
+  void compileTechEntries(void);
+  void consolidateProtoEntries(void);
+  void consolidateTechEntries(void);
+  void setProtoRouting(void);
+#if (NXP_EXTNS == TRUE)
+  void setEmptyAidEntry(void);
 #endif
-    void setTechRouting(void);
-    void processTechEntriesForFwdfunctionality(void);
-    void configureOffHostNfceeTechMask(void);
-    void checkProtoSeID(void);
-    void dumpTables(int);
+  void setTechRouting(void);
+  void processTechEntriesForFwdfunctionality(void);
+  void configureOffHostNfceeTechMask(void);
+  void checkProtoSeID(void);
+  void dumpTables(int);
+
+  static const int DBG = true;
+  // Currently 4 protocols supported namely T3T, ISO-DEP, ISO-7816,
+  // NFC-DEP(taken care internally by the libnfc stack)
+  static const int MAX_PROTO_ENTRIES = 0x03;
+  static const int PROTO_T3T_IDX = 0x00;
+  static const int PROTO_ISODEP_IDX = 0x01;
+  static const int PROTO_ISO7816_IDX = 0x02;
+  // Currently 3 Technologies supported namely A,B,F
+  static const int MAX_TECH_ENTRIES = 0x03;
+  static const int TECH_A_IDX = 0x00;
+  static const int TECH_B_IDX = 0x01;
+  static const int TECH_F_IDX = 0x02;
+  // Fixed number of Lmrt entries
+  static const int MAX_ROUTE_LOC_ENTRIES = 0x04;
+  // Fixed route location Lmrt index
+  static const int ROUTE_LOC_HOST_ID_IDX = 0x00;
+  static const int ROUTE_LOC_ESE_ID_IDX = 0x01;
+  static const int ROUTE_LOC_UICC1_ID_IDX = 0x02;
+  static const int ROUTE_LOC_UICC2_ID_IDX = 0x03;
+  // Fixed route location Lmrt entries
+  static const int ROUTE_LOC_HOST_ID = 0x400;
+  static const int ROUTE_LOC_ESE_ID = SecureElement::EE_HANDLE_0xF3;
+  static const int ROUTE_LOC_UICC1_ID = 0x402;
+  static const int ROUTE_LOC_UICC1_ID_NCI2_0 = 0x480;
+  static const int ROUTE_LOC_UICC2_ID = SecureElement::EE_HANDLE_0xF8;
+  // Fixed power states masks
+  static const int PWR_SWTCH_ON_SCRN_UNLCK_MASK = 0x01;
+  static const int PWR_SWTCH_OFF_MASK = 0x02;
+  static const int PWR_BATT_OFF_MASK = 0x04;
+  static const int PWR_SWTCH_ON_SCRN_LOCK_MASK = 0x08;
+  static const int PWR_SWTCH_ON_SCRN_OFF_MASK = 0x10;
+  static const int PWR_SWTCH_ON_SCRN_OFF_LOCK_MASK = 0x20;
+  // See AidRoutingManager.java for corresponding
+  // AID_MATCHING_ constants
+  // Every routing table entry is matched exact (BCM20793)
+  static const int AID_MATCHING_EXACT_ONLY = 0x00;
+  // Every routing table entry can be matched either exact or prefix
+  static const int AID_MATCHING_EXACT_OR_PREFIX = 0x01;
+  // Every routing table entry is matched as a prefix
+  static const int AID_MATCHING_PREFIX_ONLY = 0x02;
+  // See AidRoutingManager.java for corresponding
+  // AID_MATCHING_ platform constants
+  // Behavior as per Android-L, supporting prefix match and full
+  // match for both OnHost and OffHost apps.
+  static const int AID_MATCHING_L = 0x01;
+  // Behavior as per Android-KitKat by NXP, supporting prefix match for
+  // OffHost and prefix and full both for OnHost apps.
+  static const int AID_MATCHING_K = 0x02;
+  static void nfcFRspTimerCb(union sigval);
+  static void nfaEeCallback(tNFA_EE_EVT event, tNFA_EE_CBACK_DATA* eventData);
+  static void stackCallback(uint8_t event, tNFA_CONN_EVT_DATA* eventData);
+  static void nfcFCeCallback(uint8_t event, tNFA_CONN_EVT_DATA* eventData);
+  static int com_android_nfc_cardemulation_doGetDefaultRouteDestination(
+      JNIEnv* e);
+  static int com_android_nfc_cardemulation_doGetDefaultOffHostRouteDestination(
+      JNIEnv* e);
 
-    static const int DBG               = true;
-    //Currently 4 protocols supported namely T3T, ISO-DEP, ISO-7816, NFC-DEP(taken care internally by the libnfc stack)
-    static const int MAX_PROTO_ENTRIES = 0x03;
-    static const int PROTO_T3T_IDX     = 0x00;
-    static const int PROTO_ISODEP_IDX  = 0x01;
-    static const int PROTO_ISO7816_IDX = 0x02;
-    //Currently 3 Technologies supported namely A,B,F
-    static const int MAX_TECH_ENTRIES  = 0x03;
-    static const int TECH_A_IDX        = 0x00;
-    static const int TECH_B_IDX        = 0x01;
-    static const int TECH_F_IDX        = 0x02;
-    //Fixed number of Lmrt entries
-    static const int MAX_ROUTE_LOC_ENTRIES  = 0x04;
-    //Fixed route location Lmrt index
-    static const int ROUTE_LOC_HOST_ID_IDX  = 0x00;
-    static const int ROUTE_LOC_ESE_ID_IDX   = 0x01;
-    static const int ROUTE_LOC_UICC1_ID_IDX = 0x02;
-    static const int ROUTE_LOC_UICC2_ID_IDX = 0x03;
-    //Fixed route location Lmrt entries
-    static const int ROUTE_LOC_HOST_ID      = 0x400;
-    static const int ROUTE_LOC_ESE_ID       = SecureElement::EE_HANDLE_0xF3;
-    static const int ROUTE_LOC_UICC1_ID     = 0x402;
-    static const int ROUTE_LOC_UICC1_ID_NCI2_0 = 0x480;
-    static const int ROUTE_LOC_UICC2_ID     = SecureElement::EE_HANDLE_0xF8;
-    // Fixed power states masks
-    static const int PWR_SWTCH_ON_SCRN_UNLCK_MASK       = 0x01;
-    static const int PWR_SWTCH_OFF_MASK                 = 0x02;
-    static const int PWR_BATT_OFF_MASK                  = 0x04;
-    static const int PWR_SWTCH_ON_SCRN_LOCK_MASK        = 0x08;
-    static const int PWR_SWTCH_ON_SCRN_OFF_MASK         = 0x10;
-    static const int PWR_SWTCH_ON_SCRN_OFF_LOCK_MASK    = 0x20;
-    // See AidRoutingManager.java for corresponding
-    // AID_MATCHING_ constants
-    // Every routing table entry is matched exact (BCM20793)
-    static const int AID_MATCHING_EXACT_ONLY = 0x00;
-    // Every routing table entry can be matched either exact or prefix
-    static const int AID_MATCHING_EXACT_OR_PREFIX = 0x01;
-    // Every routing table entry is matched as a prefix
-    static const int AID_MATCHING_PREFIX_ONLY = 0x02;
-    // See AidRoutingManager.java for corresponding
-    // AID_MATCHING_ platform constants
-    //Behavior as per Android-L, supporting prefix match and full
-    //match for both OnHost and OffHost apps.
-    static const int AID_MATCHING_L = 0x01;
-    //Behavior as per Android-KitKat by NXP, supporting prefix match for
-    //OffHost and prefix and full both for OnHost apps.
-    static const int AID_MATCHING_K = 0x02;
-    static void nfcFRspTimerCb(union sigval);
-    static void nfaEeCallback (tNFA_EE_EVT event, tNFA_EE_CBACK_DATA* eventData);
-    static void stackCallback (uint8_t event, tNFA_CONN_EVT_DATA* eventData);
-    static void nfcFCeCallback (uint8_t event, tNFA_CONN_EVT_DATA* eventData);
-    static int com_android_nfc_cardemulation_doGetDefaultRouteDestination (JNIEnv* e);
-    static int com_android_nfc_cardemulation_doGetDefaultOffHostRouteDestination (JNIEnv* e);
-    static int com_android_nfc_cardemulation_doGetAidMatchingMode (JNIEnv* e);
-    static int com_android_nfc_cardemulation_doGetAidMatchingPlatform (JNIEnv* e);
+  static int com_android_nfc_cardemulation_doGetAidMatchingMode(JNIEnv* e);
+  static int com_android_nfc_cardemulation_doGetAidMatchingPlatform(JNIEnv* e);
 
-    std::vector<uint8_t> mRxDataBuffer;
+  std::vector<uint8_t> mRxDataBuffer;
+  map<int, uint16_t> mMapScbrHandle;
 
-    // Fields below are final after initialize()
-    //int mDefaultEe;
-    int mDefaultEeNfcF;
-    int mOffHostEe;
-    int mActiveSe;
-    int mActiveSeNfcF;
-    int mAidMatchingMode;
-    int mNfcFOnDhHandle;
-    int mAidMatchingPlatform;
-    tNFA_TECHNOLOGY_MASK mSeTechMask;
-    static const JNINativeMethod sMethods [];
-    int mDefaultEe; //since this variable is used in both cases moved out of compiler switch
-    int mHostListnTechMask;
-    int mUiccListnTechMask;
-    int mFwdFuntnEnable;
-    static int mChipId;
-    SyncEvent mEeRegisterEvent;
-    SyncEvent mRoutingEvent;
-#if(NXP_EXTNS == TRUE)
-    bool mIsDirty;
-    protoEntry_t mProtoTableEntries[MAX_PROTO_ENTRIES];
-    techEntry_t mTechTableEntries[MAX_TECH_ENTRIES];
-    LmrtEntry_t mLmrtEntries[MAX_ROUTE_LOC_ENTRIES];
-    uint32_t mCeRouteStrictDisable;
-    uint32_t mDefaultIso7816SeID;
-    uint32_t mDefaultIso7816Powerstate;
-    uint32_t mDefaultIsoDepSeID;
-    uint32_t mDefaultIsoDepPowerstate;
-    uint32_t mDefaultT3TSeID;
-    uint32_t mDefaultT3TPowerstate;
-    uint32_t mDefaultTechType;
-    uint32_t mDefaultTechASeID;
-    uint32_t mDefaultTechAPowerstate;
-    uint32_t mDefaultTechBSeID;
-    uint32_t mDefaultTechBPowerstate;
-    uint32_t mDefaultTechFSeID;
-    uint32_t mDefaultTechFPowerstate;
-    uint32_t mAddAid;
-    uint32_t mTechSupportedByEse;
-    uint32_t mTechSupportedByUicc1;
-    uint32_t mTechSupportedByUicc2;
+  // Fields below are final after initialize()
+  int mDefaultOffHostRoute;
+  int mAidMatchingMode;
+  int mNfcFOnDhHandle;
+  bool mIsScbrSupported;
+  uint16_t mDefaultSysCode;
+  uint16_t mDefaultSysCodeRoute;
+  uint8_t mDefaultSysCodePowerstate;
+  uint8_t mOffHostAidRoutingPowerState;
+  tNFA_EE_CBACK_DATA mCbEventData;
+  int mAidMatchingPlatform;
+  tNFA_TECHNOLOGY_MASK mSeTechMask;
+  static const JNINativeMethod sMethods[];
+  int mDefaultEe;  // since this variable is used in both cases moved out of
+                   // compiler switch
+  int mHostListnTechMask;
+  int mUiccListnTechMask;
+  int mFwdFuntnEnable;
+  static int mChipId;
+  SyncEvent mEeRegisterEvent;
+  SyncEvent mRoutingEvent;
+#if (NXP_EXTNS == TRUE)
+  bool mIsDirty;
+  protoEntry_t mProtoTableEntries[MAX_PROTO_ENTRIES];
+  techEntry_t mTechTableEntries[MAX_TECH_ENTRIES];
+  LmrtEntry_t mLmrtEntries[MAX_ROUTE_LOC_ENTRIES];
+  uint32_t mCeRouteStrictDisable;
+  uint32_t mDefaultIso7816SeID;
+  uint32_t mDefaultIso7816Powerstate;
+  uint32_t mDefaultIsoDepSeID;
+  uint32_t mDefaultIsoDepPowerstate;
+  uint32_t mDefaultT3TSeID;
+  uint32_t mDefaultT3TPowerstate;
+  uint32_t mDefaultTechType;
+  uint32_t mDefaultTechASeID;
+  uint32_t mDefaultTechAPowerstate;
+  uint32_t mDefaultTechBSeID;
+  uint32_t mDefaultTechBPowerstate;
+  uint32_t mDefaultTechFSeID;
+  uint32_t mDefaultTechFPowerstate;
+  uint32_t mAddAid;
+  uint32_t mTechSupportedByEse;
+  uint32_t mTechSupportedByUicc1;
+  uint32_t mTechSupportedByUicc2;
 #endif
-    uint32_t mDefaultHCEFRspTimeout;
+  uint32_t mDefaultHCEFRspTimeout;
 };
diff --git a/nci/jni/SecureElement.cpp b/nci/jni/SecureElement.cpp
old mode 100644
new mode 100755
index f6a2d756..078595d1
--- a/nci/jni/SecureElement.cpp
+++ b/nci/jni/SecureElement.cpp
@@ -3,7 +3,7 @@
  *  Copyright (c) 2016, The Linux Foundation. All rights reserved.
  *  Not a Contribution.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *  The original Work has been changed by NXP Semiconductors.
  *
  *  Copyright (C) 2012 The Android Open Source Project
@@ -25,200 +25,122 @@
  *  Communicate with secure elements that are attached to the NFC
  *  controller.
  */
-#include <semaphore.h>
-#include <errno.h>
-#include <nativehelper/ScopedLocalRef.h>
-#include "_OverrideLog.h"
 #include "SecureElement.h"
-#include "config.h"
-#include "PowerSwitch.h"
+#include <ScopedLocalRef.h>
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+#include <errno.h>
+#include <semaphore.h>
+#include "DataQueue.h"
+#include "HciEventManager.h"
 #include "JavaClassConstants.h"
-#include "nfc_api.h"
-#include "phNxpConfig.h"
 #include "PeerToPeer.h"
-#include "DataQueue.h"
+#include "PowerSwitch.h"
 #include "TransactionController.h"
-
-#if(NXP_EXTNS == TRUE)
+#include "config.h"
+#include "nfc_api.h"
+#include "nfc_config.h"
+#include "phNxpConfig.h"
+#if (NXP_EXTNS == TRUE)
+#include "MposManager.h"
 #include "RoutingManager.h"
 
 #include <signal.h>
 #include <sys/types.h>
-extern "C"{
 #include "nfa_api.h"
-}
 #endif
-#define ALOGV ALOGD
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
 /*****************************************************************************
 **
 ** public variables
 **
 *****************************************************************************/
-static int gSEId = -1;     // secure element ID to use in connectEE(), -1 means not set
-static int gGatePipe = -1; // gate id or static pipe id to use in connectEE(), -1 means not set
-static bool gUseStaticPipe = false;    // if true, use gGatePipe as static pipe id.  if false, use as gate id
+static int gSEId =
+    -1;  // secure element ID to use in connectEE(), -1 means not set
+static int gGatePipe =
+    -1;  // gate id or static pipe id to use in connectEE(), -1 means not set
+static bool gUseStaticPipe = false;  // if true, use gGatePipe as static pipe
+                                     // id.  if false, use as gate id
 extern bool gTypeB_listen;
-bool gReaderNotificationflag = false;
 bool hold_the_transceive = false;
-int dual_mode_current_state=0;
+int dual_mode_current_state = 0;
 nfc_jni_native_data* mthreadnative;
 #if (NXP_EXTNS == TRUE)
 nfcee_disc_state sNfcee_disc_state;
 extern uint8_t nfcee_swp_discovery_status;
 extern int32_t gSeDiscoverycount;
 static void rfFeildEventTimeoutCallback(union sigval);
-extern Rdr_req_ntf_info_t swp_rdr_req_ntf_info ;
 pthread_t passiveListenEnable_thread;
-void *passiveListenEnableThread(void *arg);
+void* passiveListenEnableThread(void* arg);
 bool ceTransactionPending = false;
 static uint8_t passiveListenState = 0x00;
 static bool isTransceiveOngoing = false;
 static void passiveListenDisablecallBack(union sigval);
 #endif
-namespace android
-{
-    extern void startRfDiscovery (bool isStart);
-    extern void setUiccIdleTimeout (bool enable);
-    extern bool isDiscoveryStarted();
-    extern void requestFwDownload();
-    extern int getScreenState();
-    extern void checkforNfceeConfig(uint8_t type);
+namespace android {
+extern void startRfDiscovery(bool isStart);
+extern void setUiccIdleTimeout(bool enable);
+extern bool isDiscoveryStarted();
+extern void requestFwDownload();
+extern int getScreenState();
+extern void checkforNfceeConfig(uint8_t type);
 #if (NXP_EXTNS == TRUE)
-    extern bool nfcManager_checkNfcStateBusy();
+extern bool nfcManager_checkNfcStateBusy();
 #endif
-    extern bool isp2pActivated();
-    extern SyncEvent sNfaSetConfigEvent;
-    extern tNFA_STATUS EmvCo_dosetPoll(jboolean enable);
-    extern tNFA_STATUS ResetEseSession();
-    extern void start_timer_msec(struct timeval  *start_tv);
-    extern long stop_timer_getdifference_msec(struct timeval  *start_tv, struct timeval  *stop_tv);
-    extern bool nfcManager_isNfcActive();
-    extern bool nfcManager_isNfcDisabling();
-#if(NXP_EXTNS == TRUE)
-    extern int gMaxEERecoveryTimeout;
-    extern uint8_t nfcManager_getNfcState();
+extern bool isp2pActivated();
+extern SyncEvent sNfaSetConfigEvent;
+extern tNFA_STATUS ResetEseSession();
+extern void start_timer_msec(struct timeval* start_tv);
+extern long stop_timer_getdifference_msec(struct timeval* start_tv,
+                                          struct timeval* stop_tv);
+extern bool nfcManager_isNfcActive();
+extern bool nfcManager_isNfcDisabling();
+extern Mutex mSPIDwpSyncMutex;
+#if (NXP_EXTNS == TRUE)
+extern int gMaxEERecoveryTimeout;
+extern uint8_t nfcManager_getNfcState();
 #endif
-}
-#if(NXP_EXTNS == TRUE)
-    static    uint32_t        nfccStandbytimeout;        // timeout for secelem standby mode detection
-    int       active_ese_reset_control = 0;
-    bool      hold_wired_mode = false;
-    static    nfcc_standby_operation_t standby_state = STANDBY_MODE_ON;
-    SyncEvent mWiredModeHoldEvent;
-    static int gWtxCount = 0;
-    static void NFCC_StandbyModeTimerCallBack (union sigval);
-    /*  hold the transceive flag should be set when the prio session is actrive/about to active*/
-    /*  Event used to inform the prio session end and transceive resume*/
-        SyncEvent sSPIPrioSessionEndEvent;
-    SyncEvent sSPISignalHandlerEvent;
-    SyncEvent sSPIForceEnableDWPEvent;
-    SyncEvent sSPISVDDSyncOnOffEvent;
-    int       spiDwpSyncState = STATE_IDLE;
-    void      *spiEventHandlerThread(void *arg);
-    Mutex     mSPIEvtMutex;
-    DataQueue gSPIEvtQueue;
-    volatile  uint16_t  usSPIActEvent = 0;
-    pthread_t spiEvtHandler_thread;
-    bool createSPIEvtHandlerThread();
-    void releaseSPIEvtHandlerThread();
-    static void nfaVSC_SVDDSyncOnOff(bool type);
-    static void nfaVSC_ForceDwpOnOff(bool type);
+}  // namespace android
+#if (NXP_EXTNS == TRUE)
+static uint32_t
+    nfccStandbytimeout;  // timeout for secelem standby mode detection
+int active_ese_reset_control = 0;
+bool hold_wired_mode = false;
+static nfcc_standby_operation_t standby_state = STANDBY_MODE_ON;
+SyncEvent mWiredModeHoldEvent;
+static int gWtxCount = 0;
+static void NFCC_StandbyModeTimerCallBack(union sigval);
+/*  hold the transceive flag should be set when the prio session is
+ * actrive/about to active*/
+/*  Event used to inform the prio session end and transceive resume*/
+SyncEvent sSPIPrioSessionEndEvent;
+SyncEvent sSPISignalHandlerEvent;
+SyncEvent sSPIForceEnableDWPEvent;
+SyncEvent sSPISVDDSyncOnOffEvent;
+int spiDwpSyncState = STATE_IDLE;
+void* spiEventHandlerThread(void* arg);
+Mutex mSPIEvtMutex;
+DataQueue gSPIEvtQueue;
+volatile uint16_t usSPIActEvent = 0;
+pthread_t spiEvtHandler_thread;
+bool createSPIEvtHandlerThread();
+void releaseSPIEvtHandlerThread();
+static void nfaVSC_SVDDSyncOnOff(bool type);
+static tNFA_STATUS nfaVSC_ForceDwpOnOff(bool type);
 #endif
-    SyncEvent mDualModeEvent;
-    static void setSPIState(bool mState);
+SyncEvent mDualModeEvent;
+static void setSPIState(bool mState);
 //////////////////////////////////////////////
 //////////////////////////////////////////////
-#if(NXP_EXTNS == TRUE)
-#define NFC_NUM_INTERFACE_MAP 3
-#define NFC_SWP_RD_NUM_INTERFACE_MAP 1
-#define STATIC_PIPE_0x19 0x19 //PN54X Gemalto's proprietary static pipe
-#define STATIC_PIPE_0x70 0x70 //Broadcom's proprietary static pipe
-uint8_t  SecureElement::mStaticPipeProp;
-
-static const tNCI_DISCOVER_MAPS nfc_interface_mapping_default[NFC_NUM_INTERFACE_MAP] =
-{
-        /* Protocols that use Frame Interface do not need to be included in the interface mapping */
-        {
-                NCI_PROTOCOL_ISO_DEP,
-                NCI_INTERFACE_MODE_POLL_N_LISTEN,
-                NCI_INTERFACE_ISO_DEP
-        }
-        ,
-        {
-                NCI_PROTOCOL_NFC_DEP,
-                NCI_INTERFACE_MODE_POLL_N_LISTEN,
-                NCI_INTERFACE_NFC_DEP
-        }
-        ,
-        {
-                NCI_PROTOCOL_MIFARE,
-                NCI_INTERFACE_MODE_POLL,
-                NCI_INTERFACE_MIFARE
-        }
-};
-static const tNCI_DISCOVER_MAPS nfc_interface_mapping_uicc[NFC_SWP_RD_NUM_INTERFACE_MAP] =
-{
-        /* Protocols that use Frame Interface do not need to be included in the interface mapping */
-        {
-                NCI_PROTOCOL_ISO_DEP,
-                NCI_INTERFACE_MODE_POLL,
-                NCI_INTERFACE_UICC_DIRECT_STAT
-        }
-
-};
-
-static const tNCI_DISCOVER_MAPS nfc_interface_mapping_ese[NFC_SWP_RD_NUM_INTERFACE_MAP] =
-{
-        /* Protocols that use Frame Interface do not need to be included in the interface mapping */
-        {
-                NCI_PROTOCOL_ISO_DEP,
-                NCI_INTERFACE_MODE_POLL,
-                NCI_INTERFACE_ESE_DIRECT_STAT
-        }
-
-};
-
-/*******************************************************************************
-**
-** Function:        startStopSwpReaderProc
-**
-** Description:     handle timeout
-**
-** Returns:         None
-**
-*******************************************************************************/
-static void startStopSwpReaderProc (union sigval)
-{
-    if(!nfcFL.nfcNxpEse || !nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
-        ALOGV("%s: nfcNxpEse or ETSI_READER not enabled. Returning", __func__);
-        return;
-    }
-    ALOGV("%s: Timeout!!!", __func__);
-    JNIEnv* e = NULL;
-    int disc_ntf_timeout = 10;
-
-        ScopedAttach attach(RoutingManager::getInstance().mNativeData->vm, &e);
-        if (e == NULL)
-        {
-            ALOGE("%s: jni env is null", __func__);
-            return;
-        }
-        GetNumValue ( NAME_NFA_DM_DISC_NTF_TIMEOUT, &disc_ntf_timeout, sizeof ( disc_ntf_timeout ) );
-
-        e->CallVoidMethod (RoutingManager::getInstance().mNativeData->manager, android::gCachedNfcManagerNotifyETSIReaderModeSwpTimeout,disc_ntf_timeout);
+#if (NXP_EXTNS == TRUE)
+#define STATIC_PIPE_0x19 0x19  // PN54X Gemalto's proprietary static pipe
+#define STATIC_PIPE_0x70 0x70  // Broadcom's proprietary static pipe
+uint8_t SecureElement::mStaticPipeProp;
 
-}
-void SecureElement::discovery_map_cb (tNFC_DISCOVER_EVT event, tNFC_DISCOVER *p_data)
-{
-    (void)event;
-    (void)p_data;
-    SyncEventGuard guard (sSecElem.mDiscMapEvent);
-//    ALOGV("discovery_map_cb; status=%u", eventData->ee_register);
-    sSecElem.mDiscMapEvent.notifyOne();
-}
 #endif
 
-
 SecureElement SecureElement::sSecElem;
 const char* SecureElement::APP_NAME = "nfc_jni";
 const uint16_t ACTIVE_SE_USE_ANY = 0xFFFF;
@@ -232,56 +154,53 @@ const uint16_t ACTIVE_SE_USE_ANY = 0xFFFF;
 ** Returns:         None
 **
 *******************************************************************************/
-SecureElement::SecureElement ()
-:   mActiveEeHandle (NFA_HANDLE_INVALID),
-#if(NXP_EXTNS == TRUE)
-    mIsWiredModeOpen(false),
-    mIsAllowWiredInDesfireMifareCE(false),
-    mRfFieldEventTimeout(0),
-    mIsIntfRstEnabled (false),
-    mETSI12InitStatus (NFA_STATUS_FAILED),
-    mModeSetInfo(NFA_STATUS_FAILED),
-    meseETSI12Recovery(false),
-    meSESessionIdOk (false),
-    mPwrCmdstatus(NFA_STATUS_FAILED),
-    mNfccPowerMode(0),
-    mPassiveListenCnt(0),
-    mPassiveListenTimeout(0),
+SecureElement::SecureElement()
+    : mActiveEeHandle(NFA_HANDLE_INVALID),
+#if (NXP_EXTNS == TRUE)
+      mETSI12InitStatus(NFA_STATUS_FAILED),
+      mWmMaxWtxCount(0),
+      meseETSI12Recovery(false),
+      mPassiveListenTimeout(0),
+      mPassiveListenCnt(0),
+      meSESessionIdOk(false),
+      mIsWiredModeOpen(false),
+      mIsAllowWiredInDesfireMifareCE(false),
+      mRfFieldEventTimeout(0),
+      mModeSetInfo(NFA_STATUS_FAILED),
+      mPwrCmdstatus(NFA_STATUS_FAILED),
+      mNfccPowerMode(0),
+      mIsIntfRstEnabled(false),
 #endif
-    mDestinationGate (4), //loopback gate
-    mNfaHciHandle (NFA_HANDLE_INVALID),
-    mNativeData (NULL),
-    mIsInit (false),
-    mActualNumEe (0),
-    mNumEePresent(0),
-    mbNewEE (true),   // by default we start w/thinking there are new EE
-    mNewPipeId (0),
-    mNewSourceGate (0),
-    mActiveSeOverride(ACTIVE_SE_USE_ANY),
-    mCommandStatus (NFA_STATUS_OK),
-    mIsPiping (false),
-    mCurrentRouteSelection (NoRoute),
-    mActualResponseSize(0),
-    mAtrInfolen (0),
-    mUseOberthurWarmReset (false),
-    mActivatedInListenMode (false),
-    mOberthurWarmResetCommand (3),
-    mGetAtrRspwait (false),
-    mRfFieldIsOn(false),
-    mTransceiveWaitOk(false),
-    mWmMaxWtxCount(0)
-{
-    memset (&mEeInfo, 0, nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED *sizeof(tNFA_EE_INFO));
-    memset (&mUiccInfo, 0, sizeof(mUiccInfo));
-    memset (&mHciCfg, 0, sizeof(mHciCfg));
-    memset (mResponseData, 0, sizeof(mResponseData));
-    memset (mAidForEmptySelect, 0, sizeof(mAidForEmptySelect));
-    memset (&mLastRfFieldToggle, 0, sizeof(mLastRfFieldToggle));
-    memset (mAtrInfo, 0, sizeof( mAtrInfo));
-    memset (&mNfceeData_t, 0, sizeof(mNfceeData_t));
+      mDestinationGate(4),  // loopback gate
+      mNativeData(NULL),
+      mIsInit(false),
+      mActualNumEe(0),
+      mNumEePresent(0),
+      mbNewEE(true),  // by default we start w/thinking there are new EE
+      mNewPipeId(0),
+      mNewSourceGate(0),
+      mActiveSeOverride(ACTIVE_SE_USE_ANY),
+      mCommandStatus(NFA_STATUS_OK),
+      mIsPiping(false),
+      mCurrentRouteSelection(NoRoute),
+      mActualResponseSize(0),
+      mAtrInfolen(0),
+      mUseOberthurWarmReset(false),
+      mActivatedInListenMode(false),
+      mOberthurWarmResetCommand(3),
+      mGetAtrRspwait(false),
+      mRfFieldIsOn(false),
+      mTransceiveWaitOk(false) {
+  memset(&mEeInfo, 0,
+         nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED * sizeof(tNFA_EE_INFO));
+  memset(&mUiccInfo, 0, sizeof(mUiccInfo));
+  memset(&mHciCfg, 0, sizeof(mHciCfg));
+  memset(mAidForEmptySelect, 0, sizeof(mAidForEmptySelect));
+  memset(&mLastRfFieldToggle, 0, sizeof(mLastRfFieldToggle));
+  memset(mAtrInfo, 0, sizeof(mAtrInfo));
+  memset(&mNfceeData_t, 0, sizeof(mNfceeData_t));
 }
 
-
 /*******************************************************************************
 **
 ** Function:        ~SecureElement
@@ -291,10 +210,7 @@ SecureElement::SecureElement ()
 ** Returns:         None
 **
 *******************************************************************************/
-SecureElement::~SecureElement ()
-{
-}
-
+SecureElement::~SecureElement() {}
 
 /*******************************************************************************
 **
@@ -305,11 +221,7 @@ SecureElement::~SecureElement ()
 ** Returns:         SecureElement object.
 **
 *******************************************************************************/
-SecureElement& SecureElement::getInstance()
-{
-    return sSecElem;
-}
-
+SecureElement& SecureElement::getInstance() { return sSecElem; }
 
 /*******************************************************************************
 **
@@ -321,13 +233,12 @@ SecureElement& SecureElement::getInstance()
 ** Returns:         None
 **
 *******************************************************************************/
-void SecureElement::setActiveSeOverride(uint8_t activeSeOverride)
-{
-    ALOGV("SecureElement::setActiveSeOverride, seid=0x%X", activeSeOverride);
-    mActiveSeOverride = activeSeOverride;
+void SecureElement::setActiveSeOverride(uint8_t activeSeOverride) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "SecureElement::setActiveSeOverride, seid=0x%X", activeSeOverride);
+  mActiveSeOverride = activeSeOverride;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        initialize
@@ -338,170 +249,170 @@ void SecureElement::setActiveSeOverride(uint8_t activeSeOverride)
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-bool SecureElement::initialize (nfc_jni_native_data* native)
-{
-    static const char fn [] = "SecureElement::initialize";
-    tNFA_STATUS nfaStat;
-    unsigned long num = 0;
-    unsigned long retValue;
-
-    ALOGV("%s: enter", fn);
-    if (GetNumValue("NFA_HCI_DEFAULT_DEST_GATE", &num, sizeof(num)))
-        mDestinationGate = num;
-    ALOGV("%s: Default destination gate: 0x%X", fn, mDestinationGate);
-
-    mStaticPipeProp = nfcFL.nfccFL._GEMALTO_SE_SUPPORT ? STATIC_PIPE_0x19 : STATIC_PIPE_0x70;
-    // active SE, if not set active all SEs, use the first one.
-    if (GetNumValue("ACTIVE_SE", &num, sizeof(num)))
-    {
-        mActiveSeOverride = num;
-        ALOGV("%s: Active SE override: 0x%X", fn, mActiveSeOverride);
-    }
-#if(NXP_EXTNS == TRUE)
-    if(nfcFL.nfcNxpEse) {
-        if(nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) {
-            if (GetNxpNumValue(NAME_NXP_NFCC_PASSIVE_LISTEN_TIMEOUT, &mPassiveListenTimeout, sizeof(mPassiveListenTimeout)) == false)
-            {
-                mPassiveListenTimeout = 2500;
-                ALOGV("%s: NFCC Passive Listen Disable timeout =%ld", fn, mPassiveListenTimeout);
-            }
-            ALOGV("%s: NFCC Passive Listen Disable timeout =%ld", fn, mPassiveListenTimeout);
-        }
-        if (GetNxpNumValue(NAME_NXP_NFCC_STANDBY_TIMEOUT, &nfccStandbytimeout, sizeof(nfccStandbytimeout)) == false)
-        {
-            nfccStandbytimeout = 20000;
-        }
-        ALOGV("%s: NFCC standby mode timeout =0x%lx", fn, nfccStandbytimeout);
-        if(nfccStandbytimeout > 0 && nfccStandbytimeout < 5000 )
-        {
-            nfccStandbytimeout = 5000;
-        }
-        else if (nfccStandbytimeout > 20000)
-        {
-            nfccStandbytimeout = 20000;
-        }
-        standby_state = STANDBY_MODE_ON;
-        if(nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION || nfcFL.eseFL._ESE_SVDD_SYNC
-                || nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE) {
-            spiDwpSyncState = STATE_IDLE;
-        }
-        if (GetNxpNumValue(NAME_NXP_WM_MAX_WTX_COUNT, &mWmMaxWtxCount, sizeof(mWmMaxWtxCount)) == false || (mWmMaxWtxCount == 0))
-            mWmMaxWtxCount = 9000;
-        ALOGD ("%s: NFCC Wired Mode Max WTX Count =%ld", fn, mWmMaxWtxCount);
-        dual_mode_current_state = SPI_DWPCL_NOT_ACTIVE;
-        hold_the_transceive = false;
-        active_ese_reset_control = 0;
-        hold_wired_mode = false;
-        mlistenDisabled = false;
-        mIsExclusiveWiredMode = false;
-
-        if (GetNxpNumValue(NAME_NXP_NFCC_RF_FIELD_EVENT_TIMEOUT, &mRfFieldEventTimeout, sizeof(mRfFieldEventTimeout)) == false)
-        {
-            mRfFieldEventTimeout = 2000;
-            ALOGV("%s: RF Field Off event timeout =%ld", fn, mRfFieldEventTimeout);
-        }
+bool SecureElement::initialize(nfc_jni_native_data* native) {
+  static const char fn[] = "SecureElement::initialize";
+  tNFA_STATUS nfaStat;
+  unsigned long num = 0;
+  unsigned long retValue;
 
-        if (GetNxpNumValue(NAME_NXP_ALLOW_WIRED_IN_MIFARE_DESFIRE_CLT, &retValue, sizeof(retValue)) == false)
-        {
-            mIsAllowWiredInDesfireMifareCE = false;
-        }
-        else
-        {
-            mIsAllowWiredInDesfireMifareCE = (retValue == 0x00)? false: true;
-        }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+  if (NfcConfig::hasKey("NFA_HCI_DEFAULT_DEST_GATE")) {
+    mDestinationGate = NfcConfig::getUnsigned("NFA_HCI_DEFAULT_DEST_GATE");
+  }
 
-        if(nfcFL.eseFL._WIRED_MODE_STANDBY) {
-            if (GetNxpNumValue (NAME_NXP_ESE_POWER_DH_CONTROL, (void*)&num, sizeof(num)) == false)
-            {
-                mNfccPowerMode = 0;
-            }
-            else
-            {
-                mNfccPowerMode = (uint8_t)num;
-            }
-        }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: Default destination gate: 0x%X", fn, mDestinationGate);
 
-        retValue = 0;
-        if (GetNxpNumValue(NAME_NXP_DWP_INTF_RESET_ENABLE, &retValue, sizeof(retValue)))
-        {
-            mIsIntfRstEnabled = (retValue == 0x00)? false: true;
-        }
+  mStaticPipeProp =
+      nfcFL.nfccFL._GEMALTO_SE_SUPPORT ? STATIC_PIPE_0x19 : STATIC_PIPE_0x70;
+
+#if (NXP_EXTNS == TRUE)
+  if (nfcFL.nfcNxpEse) {
+    if (nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) {
+      if (NfcConfig::hasKey(NAME_NXP_NFCC_PASSIVE_LISTEN_TIMEOUT)) {
+        mPassiveListenTimeout =
+            NfcConfig::getUnsigned(NAME_NXP_NFCC_PASSIVE_LISTEN_TIMEOUT);
+      } else {
+        mPassiveListenTimeout = 2500;
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: NFCC Passive Listen Disable timeout =%u", fn,
+                            mPassiveListenTimeout);
+      }
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: NFCC Passive Listen Disable timeout =%u", fn,
+                          mPassiveListenTimeout);
+    }
+    if (NfcConfig::hasKey(NAME_NXP_NFCC_STANDBY_TIMEOUT)) {
+      nfccStandbytimeout =
+          NfcConfig::getUnsigned(NAME_NXP_NFCC_STANDBY_TIMEOUT);
+    } else {
+      nfccStandbytimeout = 20000;
+    }
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: NFCC standby mode timeout =0x%u", fn, nfccStandbytimeout);
+    if (nfccStandbytimeout > 0 && nfccStandbytimeout < 5000) {
+      nfccStandbytimeout = 5000;
+    } else if (nfccStandbytimeout > 20000) {
+      nfccStandbytimeout = 20000;
+    }
+    standby_state = STANDBY_MODE_ON;
+    if (nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION || nfcFL.eseFL._ESE_SVDD_SYNC ||
+        nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE) {
+      spiDwpSyncState = STATE_IDLE;
+    }
+
+    if (NfcConfig::hasKey(NAME_NXP_WM_MAX_WTX_COUNT) && (mWmMaxWtxCount != 0)) {
+      mWmMaxWtxCount = NfcConfig::getUnsigned(NAME_NXP_WM_MAX_WTX_COUNT);
+    } else
+      mWmMaxWtxCount = 9000;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: NFCC Wired Mode Max WTX Count =%hu", fn, mWmMaxWtxCount);
+    dual_mode_current_state = SPI_DWPCL_NOT_ACTIVE;
+    hold_the_transceive = false;
+    active_ese_reset_control = 0;
+    hold_wired_mode = false;
+    mlistenDisabled = false;
+    mIsExclusiveWiredMode = false;
+
+    if (NfcConfig::hasKey(NAME_NXP_NFCC_RF_FIELD_EVENT_TIMEOUT)) {
+      mRfFieldEventTimeout =
+          NfcConfig::getUnsigned(NAME_NXP_NFCC_RF_FIELD_EVENT_TIMEOUT);
+    } else {
+      mRfFieldEventTimeout = 2000;
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: RF Field Off event timeout =%u", fn, mRfFieldEventTimeout);
     }
-#endif
-    /*
-     * Since NXP doesn't support OBERTHUR RESET COMMAND, Hence commented
-    if (GetNumValue("OBERTHUR_WARM_RESET_COMMAND", &num, sizeof(num)))
-    {
-        mUseOberthurWarmReset = true;
-        mOberthurWarmResetCommand = (uint8_t) num;
-    }*/
-
-    mActiveEeHandle = NFA_HANDLE_INVALID;
-    mNfaHciHandle = NFA_HANDLE_INVALID;
-
-    mNativeData     = native;
-    mthreadnative    = native;
-    mActualNumEe    = nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED;;
-    mbNewEE         = true;
-    mNewPipeId      = 0;
-    mNewSourceGate  = 0;
-    mRfFieldIsOn    = false;
-    mActivatedInListenMode = false;
-    mCurrentRouteSelection = NoRoute;
-    if(nfcFL.nfcNxpEse && nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) {
-        mPassiveListenEnabled = true;
-        meseUiccConcurrentAccess = false;
+
+    if (NfcConfig::hasKey(NAME_NXP_ALLOW_WIRED_IN_MIFARE_DESFIRE_CLT)) {
+      retValue =
+          NfcConfig::getUnsigned(NAME_NXP_ALLOW_WIRED_IN_MIFARE_DESFIRE_CLT);
+      mIsAllowWiredInDesfireMifareCE = (retValue == 0x00) ? false : true;
+    } else {
+      mIsAllowWiredInDesfireMifareCE = false;
     }
 
-    memset (mEeInfo, 0, sizeof(mEeInfo));
-    memset (&mUiccInfo, 0, sizeof(mUiccInfo));
-    memset (&mHciCfg, 0, sizeof(mHciCfg));
-    mUsedAids.clear ();
-    memset(mAidForEmptySelect, 0, sizeof(mAidForEmptySelect));
-#if(NXP_EXTNS == TRUE)
-    mIsWiredModeBlocked = false;
-#endif
+    if (nfcFL.eseFL._WIRED_MODE_STANDBY) {
+      if (NfcConfig::hasKey(NAME_NXP_ESE_POWER_DH_CONTROL)) {
+        num = NfcConfig::getUnsigned(NAME_NXP_ESE_POWER_DH_CONTROL);
+        mNfccPowerMode = (uint8_t)num;
+      } else {
+        mNfccPowerMode = 0;
+      }
+    }
 
-    // if no SE is to be used, get out.
-    if (mActiveSeOverride == 0)
-    {
-        ALOGV("%s: No SE; No need to initialize SecureElement", fn);
-        return (false);
+    retValue = 0;
+    if (NfcConfig::hasKey(NAME_NXP_DWP_INTF_RESET_ENABLE)) {
+      retValue = NfcConfig::getUnsigned(NAME_NXP_DWP_INTF_RESET_ENABLE);
+      mIsIntfRstEnabled = (retValue == 0x00) ? false : true;
     }
+  }
 
-    // Get Fresh EE info.
-    if (! getEeInfo())
-        return (false);
-    initializeEeHandle();
-    // If the controller has an HCI Network, register for that
-    //for (size_t xx = 0; xx < mActualNumEe; xx++)
-    for (size_t xx = 0; xx < MAX_NUM_EE; xx++)
-    {
+#endif
+  mActiveEeHandle = NFA_HANDLE_INVALID;
+  mNfaHciHandle = NFA_HANDLE_INVALID;
+
+  mNativeData = native;
+  mthreadnative = native;
+  mActualNumEe = nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED;
+  mbNewEE = true;
+  mNewPipeId = 0;
+  mNewSourceGate = 0;
+  mRfFieldIsOn = false;
+  mActivatedInListenMode = false;
+  mCurrentRouteSelection = NoRoute;
+  if (nfcFL.nfcNxpEse &&
+      nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) {
+    mPassiveListenEnabled = true;
+    meseUiccConcurrentAccess = false;
+  }
+
+  memset(mEeInfo, 0, sizeof(mEeInfo));
+  memset(&mUiccInfo, 0, sizeof(mUiccInfo));
+  memset(&mHciCfg, 0, sizeof(mHciCfg));
+  mUsedAids.clear();
+  memset(mAidForEmptySelect, 0, sizeof(mAidForEmptySelect));
+#if (NXP_EXTNS == TRUE)
+  mIsWiredModeBlocked = false;
+#endif
 
-        if((!nfcFL.nfccFL._GEMALTO_SE_SUPPORT && mEeInfo[xx].ee_handle != EE_HANDLE_0xF4)
-           || (nfcFL.nfccFL._GEMALTO_SE_SUPPORT && (((mEeInfo[xx].ee_interface[0] == NCI_NFCEE_INTERFACE_HCI_ACCESS)
-                 && (mEeInfo[xx].ee_status == NFC_NFCEE_STATUS_ACTIVE)) || (NFA_GetNCIVersion() == NCI_VERSION_2_0))))
-            {
-                ALOGV("%s: Found HCI network, try hci register", fn);
-
-                SyncEventGuard guard (mHciRegisterEvent);
-
-                nfaStat = NFA_HciRegister (const_cast<char*>(APP_NAME), nfaHciCallback, true);
-                if (nfaStat != NFA_STATUS_OK)
-                {
-                    ALOGE("%s: fail hci register; error=0x%X", fn, nfaStat);
-                    return (false);
-                }
-                mHciRegisterEvent.wait();
-                break;
-            }
+  // if no SE is to be used, get out.
+  if (mActiveSeOverride == 0) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: No SE; No need to initialize SecureElement", fn);
+    return (false);
+  }
+
+  initializeEeHandle();
+
+  {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: try hci register", fn);
+    SyncEventGuard guard(mHciRegisterEvent);
+    nfaStat =
+        NFA_HciRegister(const_cast<char*>(APP_NAME), nfaHciCallback, true);
+    if (nfaStat != NFA_STATUS_OK) {
+      LOG(ERROR) << StringPrintf("%s: fail hci register; error=0x%X", fn,
+                                 nfaStat);
+      return (false);
+    } else {
+      mHciRegisterEvent.wait();
     }
-    GetStrValue(NAME_AID_FOR_EMPTY_SELECT, (char*)&mAidForEmptySelect[0], sizeof(mAidForEmptySelect));
-    mIsInit = true;
-    ALOGV("%s: exit", fn);
-    return (true);
+  }
+
+  if (NfcConfig::hasKey(NAME_AID_FOR_EMPTY_SELECT)) {
+    std::vector<uint8_t> emptyAidVector;
+    emptyAidVector.resize(9);
+    emptyAidVector = NfcConfig::getBytes(NAME_AID_FOR_EMPTY_SELECT);
+    for(unsigned int i=0;i<emptyAidVector.size();i++) {
+      mAidForEmptySelect[i] = emptyAidVector[i];
+    }
+  }
+
+  mIsInit = true;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
+  return (true);
 }
-#if((NXP_EXTNS == TRUE))
+#if ((NXP_EXTNS == TRUE))
 /*******************************************************************************
  **
  ** Function:        updateEEStatus
@@ -512,41 +423,49 @@ bool SecureElement::initialize (nfc_jni_native_data* native)
  **
  ** Returns:         True if ok.
  **
-*******************************************************************************/
-bool SecureElement::updateEEStatus ()
-{
-    tNFA_STATUS nfaStat;
-    mActualNumEe    = nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED;
-    ALOGV("%s: Enter", __func__);
-
-    if (! getEeInfo())
+ *******************************************************************************/
+bool SecureElement::updateEEStatus() {
+  tNFA_STATUS nfaStat;
+  mActualNumEe = nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Enter", __func__);
+
+  if (!getEeInfo()) return (false);
+
+  // If the controller has an HCI Network, register for that
+  for (size_t xx = 0; xx < mActualNumEe; xx++) {
+    if ((!nfcFL.nfccFL._GEMALTO_SE_SUPPORT &&
+         (mEeInfo[xx].ee_handle != EE_HANDLE_0xF4)) ||
+        (nfcFL.nfccFL._GEMALTO_SE_SUPPORT &&
+         (((mEeInfo[xx].ee_interface[0] == NCI_NFCEE_INTERFACE_HCI_ACCESS)) ||
+          (NFA_GetNCIVersion() == NCI_VERSION_2_0)))) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: Found HCI network, try hci register", __func__);
+
+      SyncEventGuard guard(mHciRegisterEvent);
+
+      nfaStat =
+          NFA_HciRegister(const_cast<char*>(APP_NAME), nfaHciCallback, true);
+      if (nfaStat != NFA_STATUS_OK) {
+        LOG(ERROR) << StringPrintf("%s: fail hci register; error=0x%X",
+                                   __func__, nfaStat);
         return (false);
+      }
+      mHciRegisterEvent.wait();
+      break;
+    }
+  }
 
-    // If the controller has an HCI Network, register for that
-    for (size_t xx = 0; xx < mActualNumEe; xx++)
-    {
-        if((!nfcFL.nfccFL._GEMALTO_SE_SUPPORT && (mEeInfo[xx].ee_handle != EE_HANDLE_0xF4 ))
-            || (nfcFL.nfccFL._GEMALTO_SE_SUPPORT && (((mEeInfo[xx].ee_interface[0] == NCI_NFCEE_INTERFACE_HCI_ACCESS))
-            || (NFA_GetNCIVersion() == NCI_VERSION_2_0))))
-         {
-                ALOGV("%s: Found HCI network, try hci register", __func__);
-
-                SyncEventGuard guard (mHciRegisterEvent);
-
-                nfaStat = NFA_HciRegister (const_cast<char*>(APP_NAME), nfaHciCallback, true);
-                if (nfaStat != NFA_STATUS_OK)
-                {
-                    ALOGE("%s: fail hci register; error=0x%X", __func__, nfaStat);
-                    return (false);
-                }
-                mHciRegisterEvent.wait();
-                break;
-            }
+  if (NfcConfig::hasKey(NAME_AID_FOR_EMPTY_SELECT)) {
+    std::vector<uint8_t> emptyAidVector;
+    emptyAidVector.resize(9);
+    emptyAidVector = NfcConfig::getBytes(NAME_AID_FOR_EMPTY_SELECT);
+    for(unsigned int i=0;i < emptyAidVector.size();i++) {
+      mAidForEmptySelect[i] = emptyAidVector[i];
     }
+  }
 
-    GetStrValue(NAME_AID_FOR_EMPTY_SELECT, (char*)&mAidForEmptySelect[0], sizeof(mAidForEmptySelect));
-    ALOGV("%s: exit", __func__);
-    return (true);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  return (true);
 }
 
 /*******************************************************************************
@@ -560,30 +479,27 @@ bool SecureElement::updateEEStatus ()
  ** Returns:         True if discovery_req_ntf is received.
  **
  *******************************************************************************/
-bool SecureElement::isTeckInfoReceived (uint16_t eeHandle)
-{
-    ALOGV("%s: enter", __func__);
-    bool stat = false;
-    if (! getEeInfo())
-    {
-        ALOGE("%s: No updated eeInfo available", __func__);
-        stat = false;
-    }
-    else
-    {
-        for (uint8_t xx = 0; xx < mActualNumEe; xx++)
-        {
-            if ((mEeInfo[xx].ee_handle == eeHandle) &&
-                    ((mEeInfo[xx].la_protocol != 0x00) || (mEeInfo[xx].lb_protocol != 0x00) ||
-                            (mEeInfo[xx].lf_protocol != 0x00) || (mEeInfo[xx].lbp_protocol != 0x00)))
-            {
-                stat = true;
-                break;
-            }
-        }
+bool SecureElement::isTeckInfoReceived(uint16_t eeHandle) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+  bool stat = false;
+  if (!getEeInfo()) {
+    LOG(ERROR) << StringPrintf("%s: No updated eeInfo available", __func__);
+    stat = false;
+  } else {
+    for (uint8_t xx = 0; xx < mActualNumEe; xx++) {
+      if ((mEeInfo[xx].ee_handle == eeHandle) &&
+          ((mEeInfo[xx].la_protocol != 0x00) ||
+           (mEeInfo[xx].lb_protocol != 0x00) ||
+           (mEeInfo[xx].lf_protocol != 0x00) ||
+           (mEeInfo[xx].lbp_protocol != 0x00))) {
+        stat = true;
+        break;
+      }
     }
-    ALOGV("%s: stat : 0x%02x", __func__,stat);
-    return stat;
+  }
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: stat : 0x%02x", __func__, stat);
+  return stat;
 }
 #endif
 /*******************************************************************************
@@ -595,107 +511,110 @@ bool SecureElement::isTeckInfoReceived (uint16_t eeHandle)
 ** Returns:         None
 **
 *******************************************************************************/
-void SecureElement::finalize ()
-{
-    static const char fn [] = "SecureElement::finalize";
-    ALOGV("%s: enter", fn);
+void SecureElement::finalize() {
+  static const char fn[] = "SecureElement::finalize";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
 
 /*    if (mNfaHciHandle != NFA_HANDLE_INVALID)
         NFA_HciDeregister (const_cast<char*>(APP_NAME));*/
-#if(NXP_EXTNS == TRUE)
-    if(nfcFL.nfcNxpEse) {
-        NfccStandByOperation(STANDBY_TIMER_STOP);
-    }
+#if (NXP_EXTNS == TRUE)
+  if (nfcFL.nfcNxpEse) {
+    NfccStandByOperation(STANDBY_TIMER_STOP);
+  }
 #endif
 
-    mNfaHciHandle = NFA_HANDLE_INVALID;
-    mNativeData   = NULL;
-    mIsInit       = false;
-    mActualNumEe  = 0;
-    mNumEePresent = 0;
-    mNewPipeId    = 0;
-    mNewSourceGate = 0;
-    mIsPiping = false;
-    memset (mEeInfo, 0, sizeof(mEeInfo));
-    memset (&mUiccInfo, 0, sizeof(mUiccInfo));
-
-    ALOGV("%s: exit", fn);
+  mNfaHciHandle = NFA_HANDLE_INVALID;
+  mNativeData = NULL;
+  mIsInit = false;
+  mActualNumEe = 0;
+  mNumEePresent = 0;
+  mNewPipeId = 0;
+  mNewSourceGate = 0;
+  mIsPiping = false;
+  memset(mEeInfo, 0, sizeof(mEeInfo));
+  memset(&mUiccInfo, 0, sizeof(mUiccInfo));
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
 }
 
-
 /*******************************************************************************
 **
 ** Function:        getEeInfo
 **
-** Description:     Get latest information about execution environments from stack.
+** Description:     Get latest information about execution environments from
+*stack.
 **
 ** Returns:         True if at least 1 EE is available.
 **
 *******************************************************************************/
-bool SecureElement::getEeInfo()
-{
-    static const char fn [] = "SecureElement::getEeInfo";
-    ALOGV("%s: enter; mbNewEE=%d, mActualNumEe=%d", fn, mbNewEE, mActualNumEe);
-    tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
-
-    /*Reading latest eEinfo  incase it is updated*/
-#if(NXP_EXTNS == TRUE)
-    mbNewEE = true;
-    mNumEePresent = 0;
-#endif
-    // If mbNewEE is true then there is new EE info.
-    if (mbNewEE)
-    {
+bool SecureElement::getEeInfo() {
+  static const char fn[] = "SecureElement::getEeInfo";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: enter; mbNewEE=%d, mActualNumEe=%d", fn, mbNewEE, mActualNumEe);
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
 
-#if(NXP_EXTNS == TRUE)
-        memset (&mNfceeData_t, 0, sizeof (mNfceeData_t));
+/*Reading latest eEinfo  incase it is updated*/
+#if (NXP_EXTNS == TRUE)
+  mbNewEE = true;
+  mNumEePresent = 0;
+#endif
+  // If mbNewEE is true then there is new EE info.
+  if (mbNewEE) {
+#if (NXP_EXTNS == TRUE)
+    memset(&mNfceeData_t, 0, sizeof(mNfceeData_t));
 #endif
 
-        mActualNumEe = nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED;
+    mActualNumEe = nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED;
 
-        if ((nfaStat = NFA_EeGetInfo (&mActualNumEe, mEeInfo)) != NFA_STATUS_OK)
-        {
-            ALOGE("%s: fail get info; error=0x%X", fn, nfaStat);
-            mActualNumEe = 0;
-        }
-        else
-        {
-            mbNewEE = false;
-
-            ALOGV("%s: num EEs discovered: %u", fn, mActualNumEe);
-            if (mActualNumEe != 0)
-            {
-                for (uint8_t xx = 0; xx < mActualNumEe; xx++)
-                {
-                    if (mEeInfo[xx].ee_interface[0] != NCI_NFCEE_INTERFACE_HCI_ACCESS)
-                        mNumEePresent++;
-
-                    ALOGV("%s: EE[%u] Handle: 0x%04x  Status: %s  Num I/f: %u: (0x%02x, 0x%02x)  Num TLVs: %u, Tech : (LA:0x%02x, LB:0x%02x, "
-                            "LF:0x%02x, LBP:0x%02x)", fn, xx, mEeInfo[xx].ee_handle, eeStatusToString(mEeInfo[xx].ee_status),
-                            mEeInfo[xx].num_interface, mEeInfo[xx].ee_interface[0], mEeInfo[xx].ee_interface[1], mEeInfo[xx].num_tlvs,
-                            mEeInfo[xx].la_protocol, mEeInfo[xx].lb_protocol, mEeInfo[xx].lf_protocol, mEeInfo[xx].lbp_protocol);
-
-#if(NXP_EXTNS == TRUE)
-                    mNfceeData_t.mNfceeHandle[xx] = mEeInfo[xx].ee_handle;
-                    mNfceeData_t.mNfceeStatus[xx] = mEeInfo[xx].ee_status;
+    if ((nfaStat = NFA_EeGetInfo(&mActualNumEe, mEeInfo)) != NFA_STATUS_OK) {
+      LOG(ERROR) << StringPrintf("%s: fail get info; error=0x%X", fn, nfaStat);
+      mActualNumEe = 0;
+    } else {
+      mbNewEE = false;
+
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: num EEs discovered: %u", fn, mActualNumEe);
+      if (mActualNumEe != 0) {
+        for (uint8_t xx = 0; xx < mActualNumEe; xx++) {
+          if (mEeInfo[xx].ee_interface[0] != NCI_NFCEE_INTERFACE_HCI_ACCESS)
+            mNumEePresent++;
+
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "%s: EE[%u] Handle: 0x%04x  Status: %s  Num I/f: %u: (0x%02x, "
+              "0x%02x)  Num TLVs: %u, Tech : (LA:0x%02x, LB:0x%02x, "
+              "LF:0x%02x, LBP:0x%02x)",
+              fn, xx, mEeInfo[xx].ee_handle,
+              eeStatusToString(mEeInfo[xx].ee_status),
+              mEeInfo[xx].num_interface, mEeInfo[xx].ee_interface[0],
+              mEeInfo[xx].ee_interface[1], mEeInfo[xx].num_tlvs,
+              mEeInfo[xx].la_protocol, mEeInfo[xx].lb_protocol,
+              mEeInfo[xx].lf_protocol, mEeInfo[xx].lbp_protocol);
+
+#if (NXP_EXTNS == TRUE)
+          mNfceeData_t.mNfceeHandle[xx] = mEeInfo[xx].ee_handle;
+          mNfceeData_t.mNfceeStatus[xx] = mEeInfo[xx].ee_status;
 #endif
-                    for (size_t yy = 0; yy < mEeInfo[xx].num_tlvs; yy++)
-                    {
-                        ALOGV("%s: EE[%u] TLV[%lu]  Tag: 0x%02x  Len: %u  Values[]: 0x%02x  0x%02x  0x%02x ...",
-                                fn, xx, yy, mEeInfo[xx].ee_tlv[yy].tag, mEeInfo[xx].ee_tlv[yy].len, mEeInfo[xx].ee_tlv[yy].info[0],
-                                mEeInfo[xx].ee_tlv[yy].info[1], mEeInfo[xx].ee_tlv[yy].info[2]);
-                    }
-                }
-            }
-        }
-    }
-    ALOGV("%s: exit; mActualNumEe=%d, mNumEePresent=%d", fn, mActualNumEe,mNumEePresent);
+          for (size_t yy = 0; yy < mEeInfo[xx].num_tlvs; yy++) {
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+                "%s: EE[%u] TLV[%lu]  Tag: 0x%02x  Len: %u  Values[]: 0x%02x  "
+                "0x%02x  0x%02x ...",
+                fn, xx, yy, mEeInfo[xx].ee_tlv[yy].tag,
+                mEeInfo[xx].ee_tlv[yy].len, mEeInfo[xx].ee_tlv[yy].info[0],
+                mEeInfo[xx].ee_tlv[yy].info[1], mEeInfo[xx].ee_tlv[yy].info[2]);
+          }
+        }
+      }
+    }
+  }
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit; mActualNumEe=%d, mNumEePresent=%d", fn,
+                      mActualNumEe, mNumEePresent);
 
-#if(NXP_EXTNS == TRUE)
-    mNfceeData_t.mNfceePresent = mNumEePresent;
+#if (NXP_EXTNS == TRUE)
+  mNfceeData_t.mNfceePresent = mNumEePresent;
 #endif
 
-    return (mActualNumEe != 0);
+  return (mActualNumEe != 0);
 }
 /*******************************************************************************
 **
@@ -706,46 +625,44 @@ bool SecureElement::getEeInfo()
 ** Returns:         True/False based on  activation status.
 **
 *******************************************************************************/
-bool SecureElement::activateAllNfcee()
-{
-    static const char fn [] = "SecureElement::activateAllNfcee";
-    tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
-    int numActivatedEe = 0;
-    uint8_t numEe = SecureElement::MAX_NUM_EE;
-    tNFA_EE_INFO mEeInfo[numEe];
-
-    if((nfaStat = NFA_AllEeGetInfo(&numEe, mEeInfo)) != NFA_STATUS_OK)
-    {
-        ALOGV("%s failed to get info, error = 0x%X ",__func__, nfaStat);
-        mActualNumEe = 0;
-        return false;
+bool SecureElement::activateAllNfcee() {
+  static const char fn[] = "SecureElement::activateAllNfcee";
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+  int numActivatedEe = 0;
+  uint8_t numEe = SecureElement::MAX_NUM_EE;
+  tNFA_EE_INFO mEeInfo[numEe];
+
+  if ((nfaStat = NFA_AllEeGetInfo(&numEe, mEeInfo)) != NFA_STATUS_OK) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s failed to get info, error = 0x%X ", __func__, nfaStat);
+    mActualNumEe = 0;
+    return false;
+  }
+  {
+    if (numEe != 0) {
+      for (uint8_t xx = 0; xx < numEe; xx++) {
+        tNFA_EE_INFO& eeItem = mEeInfo[xx];
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: set EE mode activate; h=0x%X status : %d interface : 0x%X", fn,
+            eeItem.ee_handle, eeItem.ee_status, eeItem.ee_interface[0]);
+        if (eeItem.ee_status != NFC_NFCEE_STATUS_INACTIVE ||
+            eeItem.ee_interface[0] == NCI_NFCEE_INTERFACE_HCI_ACCESS) {
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "%s: h=0x%X already activated", fn, eeItem.ee_handle);
+          numActivatedEe++;
+          continue;
+        } else {
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "%s: set EE mode activate; h=0x%X", fn, eeItem.ee_handle);
+          if ((nfaStat = SecElem_EeModeSet(
+                   eeItem.ee_handle, NFA_EE_MD_ACTIVATE)) == NFA_STATUS_OK) {
+            if (eeItem.ee_status == NFC_NFCEE_STATUS_ACTIVE) numActivatedEe++;
+          }
+        }
+      }
     }
-    {
-        if (numEe != 0)
-        {
-            for (uint8_t xx = 0; xx < numEe; xx++)
-            {
-                tNFA_EE_INFO& eeItem = mEeInfo[xx];
-                ALOGV("%s: set EE mode activate; h=0x%X status : %d interface : 0x%X", fn, eeItem.ee_handle, eeItem.ee_status, eeItem.ee_interface[0]);
-                if (eeItem.ee_status != NFC_NFCEE_STATUS_INACTIVE || eeItem.ee_interface[0] == NCI_NFCEE_INTERFACE_HCI_ACCESS)
-                {
-                    ALOGV("%s: h=0x%X already activated", fn, eeItem.ee_handle);
-                    numActivatedEe++;
-                    continue;
-                }
-                else
-                {
-                    ALOGV("%s: set EE mode activate; h=0x%X", fn, eeItem.ee_handle);
-                    if ((nfaStat = SecElem_EeModeSet (eeItem.ee_handle, NFA_EE_MD_ACTIVATE)) == NFA_STATUS_OK)
-                    {
-                        if (eeItem.ee_status == NFC_NFCEE_STATUS_ACTIVE)
-                            numActivatedEe++;
-                    }
-                }
-             }
-         }
-     }
-    return (nfaStat==NFA_STATUS_OK?true:false);
+  }
+  return (nfaStat == NFA_STATUS_OK ? true : false);
 }
 /*******************************************************************************
 **
@@ -756,17 +673,16 @@ bool SecureElement::activateAllNfcee()
 ** Returns          Time difference in milliseconds
 **
 *******************************************************************************/
-static uint32_t TimeDiff(timespec start, timespec end)
-{
-    end.tv_sec -= start.tv_sec;
-    end.tv_nsec -= start.tv_nsec;
+static uint32_t TimeDiff(timespec start, timespec end) {
+  end.tv_sec -= start.tv_sec;
+  end.tv_nsec -= start.tv_nsec;
 
-    if (end.tv_nsec < 0) {
-        end.tv_nsec += 10e8;
-        end.tv_sec -=1;
-    }
+  if (end.tv_nsec < 0) {
+    end.tv_nsec += 10e8;
+    end.tv_sec -= 1;
+  }
 
-    return (end.tv_sec * 1000) + (end.tv_nsec / 10e5);
+  return (end.tv_sec * 1000) + (end.tv_nsec / 10e5);
 }
 
 /*******************************************************************************
@@ -779,26 +695,25 @@ static uint32_t TimeDiff(timespec start, timespec end)
 **
 *******************************************************************************/
 bool SecureElement::isRfFieldOn() {
-    AutoMutex mutex(mMutex);
-    if (mRfFieldIsOn) {
-        return true;
-    }
-    struct timespec now;
-    int ret = clock_gettime(CLOCK_MONOTONIC, &now);
-    if (ret == -1) {
-        ALOGE("isRfFieldOn(): clock_gettime failed");
-        return false;
-    }
-    if (TimeDiff(mLastRfFieldToggle, now) < 50) {
-        // If it was less than 50ms ago that RF field
-        // was turned off, still return ON.
-        return true;
-    } else {
-        return false;
-    }
+  AutoMutex mutex(mMutex);
+  if (mRfFieldIsOn) {
+    return true;
+  }
+  struct timespec now;
+  int ret = clock_gettime(CLOCK_MONOTONIC, &now);
+  if (ret == -1) {
+    LOG(ERROR) << StringPrintf("isRfFieldOn(): clock_gettime failed");
+    return false;
+  }
+  if (TimeDiff(mLastRfFieldToggle, now) < 50) {
+    // If it was less than 50ms ago that RF field
+    // was turned off, still return ON.
+    return true;
+  } else {
+    return false;
+  }
 }
 
-
 /*******************************************************************************
 **
 ** Function:        setEseListenTechMask
@@ -811,58 +726,51 @@ bool SecureElement::isRfFieldOn() {
 ** Returns:         True if listening is configured.
 **
 *******************************************************************************/
-bool SecureElement::setEseListenTechMask(uint8_t tech_mask ) {
-
-    static const char fn [] = "SecureElement::setEseListenTechMask";
-    tNFA_STATUS nfaStat;
-
-    ALOGV("%s: enter", fn);
-
-    if (!mIsInit)
-    {
-        ALOGE("%s: not init", fn);
-        return false;
-    }
-
-    {
-        SyncEventGuard guard (SecureElement::getInstance().mEseListenEvent);
-        nfaStat = NFA_CeConfigureEseListenTech (EE_HANDLE_0xF3, (0x00));
-        if(nfaStat == NFA_STATUS_OK)
-        {
-            SecureElement::getInstance().mEseListenEvent.wait ();
-            return true;
-        }
-        else
-            ALOGE("fail to stop ESE listen");
-    }
+bool SecureElement::setEseListenTechMask(uint8_t tech_mask) {
+  static const char fn[] = "SecureElement::setEseListenTechMask";
+  tNFA_STATUS nfaStat;
 
-    {
-        SyncEventGuard guard (SecureElement::getInstance().mEseListenEvent);
-        nfaStat = NFA_CeConfigureEseListenTech (EE_HANDLE_0xF3, (tech_mask));
-        if(nfaStat == NFA_STATUS_OK)
-        {
-            SecureElement::getInstance().mEseListenEvent.wait ();
-            return true;
-        }
-        else
-            ALOGE("fail to start ESE listen");
-    }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
 
+  if (!mIsInit) {
+    LOG(ERROR) << StringPrintf("%s: not init", fn);
     return false;
+  }
+
+  {
+    SyncEventGuard guard(SecureElement::getInstance().mEseListenEvent);
+    nfaStat = NFA_CeConfigureEseListenTech(EE_HANDLE_0xF3, (0x00));
+    if (nfaStat == NFA_STATUS_OK) {
+      SecureElement::getInstance().mEseListenEvent.wait();
+      return true;
+    } else
+      LOG(ERROR) << StringPrintf("fail to stop ESE listen");
+  }
+
+  {
+    SyncEventGuard guard(SecureElement::getInstance().mEseListenEvent);
+    nfaStat = NFA_CeConfigureEseListenTech(EE_HANDLE_0xF3, (tech_mask));
+    if (nfaStat == NFA_STATUS_OK) {
+      SecureElement::getInstance().mEseListenEvent.wait();
+      return true;
+    } else
+      LOG(ERROR) << StringPrintf("fail to start ESE listen");
+  }
+
+  return false;
 }
 
 /*******************************************************************************
 **
 ** Function:        isActivatedInListenMode
 **
-** Description:     Can be used to determine if the SE is activated in listen mode
+** Description:     Can be used to determine if the SE is activated in listen
+*mode
 **
 ** Returns:         True if the SE is activated in listen mode
 **
 *******************************************************************************/
-bool SecureElement::isActivatedInListenMode() {
-    return mActivatedInListenMode;
-}
+bool SecureElement::isActivatedInListenMode() { return mActivatedInListenMode; }
 
 /*******************************************************************************
 **
@@ -874,45 +782,42 @@ bool SecureElement::isActivatedInListenMode() {
 ** Returns:         List of handles of all execution environments.
 **
 *******************************************************************************/
-jintArray SecureElement::getListOfEeHandles (JNIEnv* e)
-{
-    static const char fn [] = "SecureElement::getListOfEeHandles";
-    ALOGV("%s: enter", fn);
-    if (mNumEePresent == 0)
-        return NULL;
+jintArray SecureElement::getListOfEeHandles(JNIEnv* e) {
+  static const char fn[] = "SecureElement::getListOfEeHandles";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+  if (mNumEePresent == 0) return NULL;
 
-    if (!mIsInit)
-    {
-        ALOGE("%s: not init", fn);
-        return (NULL);
-    }
+  if (!mIsInit) {
+    LOG(ERROR) << StringPrintf("%s: not init", fn);
+    return (NULL);
+  }
 
-    // Get Fresh EE info.
-    if (! getEeInfo())
-        return (NULL);
+  // Get Fresh EE info.
+  if (!getEeInfo()) return (NULL);
 
-    jintArray list = e->NewIntArray (mNumEePresent); //allocate array
-    jint jj = 0;
-    int cnt = 0;
-    for (int ii = 0; ii < mActualNumEe && cnt < mNumEePresent; ii++)
-    {
-        ALOGV("%s: %u = 0x%X", fn, ii, mEeInfo[ii].ee_handle);
-        if (mEeInfo[ii].ee_interface[0] == NCI_NFCEE_INTERFACE_HCI_ACCESS)
-        {
-            continue;
-        }
+  jintArray list = e->NewIntArray(mNumEePresent);  // allocate array
+  jint jj = 0;
+  int cnt = 0;
+  for (int ii = 0; ii < mActualNumEe && cnt < mNumEePresent; ii++) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: %u = 0x%X", fn, ii, mEeInfo[ii].ee_handle);
+    if (mEeInfo[ii].ee_interface[0] == NCI_NFCEE_INTERFACE_HCI_ACCESS) {
+      continue;
+    }
 
-        jj = mEeInfo[ii].ee_handle & ~NFA_HANDLE_GROUP_EE;
+    jj = mEeInfo[ii].ee_handle & ~NFA_HANDLE_GROUP_EE;
 
-        ALOGV("%s: Handle %u = 0x%X", fn, ii, jj);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Handle %u = 0x%X", fn, ii, jj);
 
-        jj = getGenericEseId(jj);
+    jj = getGenericEseId(jj);
 
-        ALOGV("%s: Generic id %u = 0x%X", fn, ii, jj);
-        e->SetIntArrayRegion (list, cnt++, 1, &jj);
-    }
-    ALOGV("%s: exit", fn);
-    return list;
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Generic id %u = 0x%X", fn, ii, jj);
+    e->SetIntArrayRegion(list, cnt++, 1, &jj);
+  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
+  return list;
 }
 
 /*******************************************************************************
@@ -925,55 +830,56 @@ jintArray SecureElement::getListOfEeHandles (JNIEnv* e)
 ** Returns:         List of Activated Secure elements.
 **
 *******************************************************************************/
-jintArray SecureElement::getActiveSecureElementList (JNIEnv* e)
-{
-    uint8_t num_of_nfcee_present = 0;
-    tNFA_HANDLE nfcee_handle[MAX_NFCEE];
-    tNFA_EE_STATUS nfcee_status[MAX_NFCEE];
-    jint seId = 0;
-    int cnt = 0;
-    int i;
-    ALOGV("%s: ENTER", __func__);
-
-    if (! getEeInfo())
-        return (NULL);
+jintArray SecureElement::getActiveSecureElementList(JNIEnv* e) {
+  uint8_t num_of_nfcee_present = 0;
+  tNFA_HANDLE nfcee_handle[MAX_NFCEE];
+  tNFA_EE_STATUS nfcee_status[MAX_NFCEE];
+  jint seId = 0;
+  int cnt = 0;
+  int i;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
 
-    num_of_nfcee_present = mNfceeData_t.mNfceePresent;
-    ALOGV("num_of_nfcee_present = %d",num_of_nfcee_present);
+  if (!getEeInfo()) return (NULL);
 
-    jintArray list = e->NewIntArray (num_of_nfcee_present); //allocate array
+  num_of_nfcee_present = mNfceeData_t.mNfceePresent;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: num_of_nfcee_present:%d", __func__, num_of_nfcee_present);
 
-    for(i = 0; i< num_of_nfcee_present ; i++)
-    {
-        nfcee_handle[i] = mNfceeData_t.mNfceeHandle[i];
-        nfcee_status[i] = mNfceeData_t.mNfceeStatus[i];
+  jintArray list = e->NewIntArray(num_of_nfcee_present);  // allocate array
 
-        if(nfcee_handle[i] == EE_HANDLE_0xF3 && nfcee_status[i] == NFC_NFCEE_STATUS_ACTIVE)
-        {
-            seId = getGenericEseId(EE_HANDLE_0xF3 & ~NFA_HANDLE_GROUP_EE);
-            ALOGV("eSE  Active");
-        }
+  for (i = 0; i <= num_of_nfcee_present; i++) {
+    nfcee_handle[i] = mNfceeData_t.mNfceeHandle[i];
+    nfcee_status[i] = mNfceeData_t.mNfceeStatus[i];
 
-        if(nfcee_handle[i] == EE_HANDLE_0xF4 && nfcee_status[i] == NFC_NFCEE_STATUS_ACTIVE)
-        {
-            seId = getGenericEseId(EE_HANDLE_0xF4 & ~NFA_HANDLE_GROUP_EE);
-            ALOGV("UICC  Active");
-        }
+    if (nfcee_handle[i] == EE_HANDLE_0xF3 &&
+        nfcee_status[i] == NFC_NFCEE_STATUS_ACTIVE) {
+      seId = getGenericEseId(EE_HANDLE_0xF3 & ~NFA_HANDLE_GROUP_EE);
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: eSE Active", __func__);
+    }
 
-        if(nfcee_handle[i] == EE_HANDLE_0xF8 && nfcee_status[i] == NFC_NFCEE_STATUS_ACTIVE)
-        {
-            seId = getGenericEseId(EE_HANDLE_0xF8 & ~NFA_HANDLE_GROUP_EE);
-            ALOGV("UICC2  Active");
-        }
+    if (nfcee_handle[i] == EE_HANDLE_0xF4 &&
+        nfcee_status[i] == NFC_NFCEE_STATUS_ACTIVE) {
+      seId = getGenericEseId(EE_HANDLE_0xF4 & ~NFA_HANDLE_GROUP_EE);
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: UICC/SIM/SIM1 Active", __func__);
+    }
 
-        ALOGV("%s: Generic id %u = 0x%X", __func__, i, seId);
-        e->SetIntArrayRegion (list, cnt++, 1, &seId);
+    if (nfcee_handle[i] == EE_HANDLE_0xF8 &&
+        nfcee_status[i] == NFC_NFCEE_STATUS_ACTIVE) {
+      seId = getGenericEseId(EE_HANDLE_0xF8 & ~NFA_HANDLE_GROUP_EE);
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: UICC/SIM/SIM1 Active", __func__);
     }
 
-    ALOGV("%s: exit", __func__);
-    return list;
-}
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Generic-ID %u = 0x%02X", __func__, i, seId);
+    e->SetIntArrayRegion(list, cnt++, 1, &seId);
+  }
 
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  return list;
+}
 
 /*******************************************************************************
 **
@@ -985,104 +891,105 @@ jintArray SecureElement::getActiveSecureElementList (JNIEnv* e)
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-bool SecureElement::activate (jint seID)
-{
-    static const char fn [] = "SecureElement::activate";
-    tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
-    int numActivatedEe = 0;
+bool SecureElement::activate(jint seID) {
+  static const char fn[] = "SecureElement::activate";
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+  int numActivatedEe = 0;
 
-    ALOGV("%s: enter; seID=0x%X", fn, seID);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter; seID=0x%X", fn, seID);
 
-    tNFA_HANDLE handle = getEseHandleFromGenericId(seID);
+  tNFA_HANDLE handle = getEseHandleFromGenericId(seID);
 
-    ALOGV("%s: handle=0x%X", fn, handle);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: handle=0x%X", fn, handle);
 
-    if (!mIsInit)
-    {
-        ALOGE("%s: not init", fn);
-        return false;
-    }
-
-    //if (mActiveEeHandle != NFA_HANDLE_INVALID)
-    //{
-    //    ALOGV("%s: already active", fn);
-    //    return true;
-    //}
-
-    // Get Fresh EE info if needed.
-    if (! getEeInfo())
-    {
-        ALOGE("%s: no EE info", fn);
-        return false;
-    }
-
-    uint16_t overrideEeHandle = 0;
-    // If the Active SE is overridden
-    if (mActiveSeOverride && (mActiveSeOverride != ACTIVE_SE_USE_ANY))
-        overrideEeHandle = NFA_HANDLE_GROUP_EE | mActiveSeOverride;
-    else //NXP
-        overrideEeHandle = handle;
-
-    ALOGV("%s: override ee h=0x%X", fn, overrideEeHandle );
+  if (!mIsInit) {
+    LOG(ERROR) << StringPrintf("%s: not init", fn);
+    return false;
+  }
+
+  // if (mActiveEeHandle != NFA_HANDLE_INVALID)
+  //{
+  //    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: already active",
+  //    fn);
+  //    return true;
+  //}
+
+  // Get Fresh EE info if needed.
+  if (!getEeInfo()) {
+    LOG(ERROR) << StringPrintf("%s: no EE info", fn);
+    return false;
+  }
 
-    if (!nfcFL.nfcNxpEse && mRfFieldIsOn) {
-        ALOGE("%s: RF field indication still on, resetting", fn);
-        mRfFieldIsOn = false;
-    }
+  uint16_t overrideEeHandle = 0;
+  // If the Active SE is overridden
+  if (mActiveSeOverride && (mActiveSeOverride != ACTIVE_SE_USE_ANY))
+    overrideEeHandle = NFA_HANDLE_GROUP_EE | mActiveSeOverride;
+  else  // NXP
+    overrideEeHandle = handle;
 
-    //activate every discovered secure element
-    for (int index=0; index < mActualNumEe; index++)
-    {
-        tNFA_EE_INFO& eeItem = mEeInfo[index];
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: override ee h=0x%X", fn, overrideEeHandle);
 
-        if ((eeItem.ee_handle == EE_HANDLE_0xF3) || (eeItem.ee_handle == EE_HANDLE_0xF4) ||
-                (nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC && (eeItem.ee_handle == EE_HANDLE_0xF8)))
-        {
-            if (overrideEeHandle && (overrideEeHandle != eeItem.ee_handle) )
-                continue;   // do not enable all SEs; only the override one
-
-            if (eeItem.ee_status != NFC_NFCEE_STATUS_INACTIVE)
-            {
-                ALOGV("%s: h=0x%X already activated", fn, eeItem.ee_handle);
-                numActivatedEe++;
-                continue;
+  if (!nfcFL.nfcNxpEse && mRfFieldIsOn) {
+    LOG(ERROR) << StringPrintf("%s: RF field indication still on, resetting",
+                               fn);
+    mRfFieldIsOn = false;
+  }
+
+  // activate every discovered secure element
+  for (int index = 0; index < mActualNumEe; index++) {
+    tNFA_EE_INFO& eeItem = mEeInfo[index];
+
+    if ((eeItem.ee_handle == EE_HANDLE_0xF3) ||
+        (eeItem.ee_handle == EE_HANDLE_0xF4) ||
+        (nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC &&
+         (eeItem.ee_handle == EE_HANDLE_0xF8))) {
+      if (overrideEeHandle && (overrideEeHandle != eeItem.ee_handle))
+        continue;  // do not enable all SEs; only the override one
+
+      if (eeItem.ee_status != NFC_NFCEE_STATUS_INACTIVE) {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: h=0x%X already activated", fn, eeItem.ee_handle);
+        numActivatedEe++;
+        continue;
+      }
+
+      {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: set EE mode activate; h=0x%X", fn, eeItem.ee_handle);
+#if (NXP_EXTNS == TRUE)
+        if ((nfaStat = SecElem_EeModeSet(
+                 eeItem.ee_handle, NFA_EE_MD_ACTIVATE)) == NFA_STATUS_OK) {
+          if (eeItem.ee_status == NFC_NFCEE_STATUS_ACTIVE) numActivatedEe++;
+          if (eeItem.ee_handle == EE_HANDLE_0xF3) {
+            SyncEventGuard guard(SecureElement::getInstance().mModeSetNtf);
+            if (SecureElement::getInstance().mModeSetNtf.wait(500) == false) {
+              LOG(ERROR) << StringPrintf("%s: timeout waiting for setModeNtf",
+                                         __func__);
             }
-
-            {
-                ALOGV("%s: set EE mode activate; h=0x%X", fn, eeItem.ee_handle);
-#if(NXP_EXTNS == TRUE)
-                if ((nfaStat = SecElem_EeModeSet (eeItem.ee_handle, NFA_EE_MD_ACTIVATE)) == NFA_STATUS_OK)
-                {
-                    if (eeItem.ee_status == NFC_NFCEE_STATUS_ACTIVE)
-                        numActivatedEe++;
-                    if(eeItem.ee_handle == EE_HANDLE_0xF3)
-                    {
-                        SyncEventGuard guard (SecureElement::getInstance().mModeSetNtf);
-                        if(SecureElement::getInstance().mModeSetNtf.wait(500) == false)
-                        {
-                            ALOGE("%s: timeout waiting for setModeNtf", __func__);
-                        }
-                    }
-                }
-                else
+          }
+        } else
 #endif
-                    ALOGE("%s: NFA_EeModeSet failed; error=0x%X", fn, nfaStat);
-            }
-        }
-    } //for
+          LOG(ERROR) << StringPrintf("%s: NFA_EeModeSet failed; error=0x%X", fn,
+                                     nfaStat);
+      }
+    }
+  }  // for
 #if (NXP_EXTNS == TRUE)
-    mActiveEeHandle = getActiveEeHandle(handle);
+  mActiveEeHandle = getActiveEeHandle(handle);
 #else
-    mActiveEeHandle = getDefaultEeHandle();
+  mActiveEeHandle = getDefaultEeHandle();
 #endif
 
-    if (mActiveEeHandle == NFA_HANDLE_INVALID)
-        ALOGE("%s: ee handle not found", fn);
-    ALOGV("%s: exit; active ee h=0x%X", fn, mActiveEeHandle);
-    return mActiveEeHandle != NFA_HANDLE_INVALID;
+  if (mActiveEeHandle == NFA_HANDLE_INVALID)
+    LOG(ERROR) << StringPrintf("%s: ee handle not found", fn);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit; active ee h=0x%X", fn, mActiveEeHandle);
+  return mActiveEeHandle != NFA_HANDLE_INVALID;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        deactivate
@@ -1093,227 +1000,230 @@ bool SecureElement::activate (jint seID)
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-bool SecureElement::deactivate (jint seID)
-{
-    static const char fn [] = "SecureElement::deactivate";
-    tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
-    bool retval = false;
-
-    ALOGV("%s: enter; seID=0x%X, mActiveEeHandle=0x%X", fn, seID, mActiveEeHandle);
-
-    tNFA_HANDLE handle = getEseHandleFromGenericId(seID);
-
-    ALOGV("%s: handle=0x%X", fn, handle);
-
-    if (!mIsInit)
-    {
-        ALOGE("%s: not init", fn);
-        goto TheEnd;
-    }
-
-    //if the controller is routing to sec elems or piping,
-    //then the secure element cannot be deactivated
-    if ((mCurrentRouteSelection == SecElemRoute) || mIsPiping)
-    {
-        ALOGE("%s: still busy", fn);
-        goto TheEnd;
-    }
-
-//    if (mActiveEeHandle == NFA_HANDLE_INVALID)
-//    {
-//        ALOGE("%s: invalid EE handle", fn);
-//        goto TheEnd;
-//    }
-
-    if (seID == NFA_HANDLE_INVALID)
-    {
-        ALOGE("%s: invalid EE handle", fn);
-        goto TheEnd;
-    }
-
-    mActiveEeHandle = NFA_HANDLE_INVALID;
-
-    //NXP
-    //deactivate secure element
-    for (int index=0; index < mActualNumEe; index++)
-    {
-        tNFA_EE_INFO& eeItem = mEeInfo[index];
-
-        if (eeItem.ee_handle == handle &&
-                ((eeItem.ee_handle == EE_HANDLE_0xF3) || (eeItem.ee_handle == EE_HANDLE_0xF4) ||
-                        (nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC && (eeItem.ee_handle == EE_HANDLE_0xF8)))) {
-            if (eeItem.ee_status == NFC_NFCEE_STATUS_INACTIVE)
-            {
-                ALOGV("%s: h=0x%X already deactivated", fn, eeItem.ee_handle);
-                break;
-            }
+bool SecureElement::deactivate(jint seID) {
+  static const char fn[] = "SecureElement::deactivate";
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+  bool retval = false;
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: enter; seID=0x%X, mActiveEeHandle=0x%X", fn, seID, mActiveEeHandle);
+
+  tNFA_HANDLE handle = getEseHandleFromGenericId(seID);
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: handle=0x%X", fn, handle);
+
+  if (!mIsInit) {
+    LOG(ERROR) << StringPrintf("%s: not init", fn);
+    goto TheEnd;
+  }
+
+  // if the controller is routing to sec elems or piping,
+  // then the secure element cannot be deactivated
+  if ((mCurrentRouteSelection == SecElemRoute) || mIsPiping) {
+    LOG(ERROR) << StringPrintf("%s: still busy", fn);
+    goto TheEnd;
+  }
+
+  //    if (mActiveEeHandle == NFA_HANDLE_INVALID)
+  //    {
+  //        LOG(ERROR) << StringPrintf("%s: invalid EE handle", fn);
+  //        goto TheEnd;
+  //    }
+
+  if (seID == NFA_HANDLE_INVALID) {
+    LOG(ERROR) << StringPrintf("%s: invalid EE handle", fn);
+    goto TheEnd;
+  }
+
+  mActiveEeHandle = NFA_HANDLE_INVALID;
+
+  // NXP
+  // deactivate secure element
+  for (int index = 0; index < mActualNumEe; index++) {
+    tNFA_EE_INFO& eeItem = mEeInfo[index];
+
+    if (eeItem.ee_handle == handle &&
+        ((eeItem.ee_handle == EE_HANDLE_0xF3) ||
+         (eeItem.ee_handle == EE_HANDLE_0xF4) ||
+         (nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC &&
+          (eeItem.ee_handle == EE_HANDLE_0xF8)))) {
+      if (eeItem.ee_status == NFC_NFCEE_STATUS_INACTIVE) {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: h=0x%X already deactivated", fn, eeItem.ee_handle);
+        break;
+      }
 
-            {
-                ALOGV("%s: set EE mode activate; h=0x%X", fn, eeItem.ee_handle);
-#if(NXP_EXTNS == TRUE)
-                if ((nfaStat = SecElem_EeModeSet (eeItem.ee_handle, NFA_EE_MD_DEACTIVATE)) == NFA_STATUS_OK)
-                {
-                    ALOGV("%s: eeItem.ee_status =0x%X  NFC_NFCEE_STATUS_INACTIVE = %x", fn, eeItem.ee_status, NFC_NFCEE_STATUS_INACTIVE);
-                    if (eeItem.ee_status == NFC_NFCEE_STATUS_INACTIVE)
-                    {
-                        ALOGE("%s: NFA_EeModeSet success; status=0x%X", fn, nfaStat);
-                        retval = true;
-                    }
-                }
-                else
+      {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: set EE mode activate; h=0x%X", fn, eeItem.ee_handle);
+#if (NXP_EXTNS == TRUE)
+        if ((nfaStat = SecElem_EeModeSet(
+                 eeItem.ee_handle, NFA_EE_MD_DEACTIVATE)) == NFA_STATUS_OK) {
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "%s: eeItem.ee_status =0x%X  NFC_NFCEE_STATUS_INACTIVE = %x", fn,
+              eeItem.ee_status, NFC_NFCEE_STATUS_INACTIVE);
+          if (eeItem.ee_status == NFC_NFCEE_STATUS_INACTIVE) {
+            LOG(ERROR) << StringPrintf("%s: NFA_EeModeSet success; status=0x%X",
+                                       fn, nfaStat);
+            retval = true;
+          }
+        } else
 #endif
-                    ALOGE("%s: NFA_EeModeSet failed; error=0x%X", fn, nfaStat);
-            }
-        }
-    } //for
+          LOG(ERROR) << StringPrintf("%s: NFA_EeModeSet failed; error=0x%X", fn,
+                                     nfaStat);
+      }
+    }
+  }  // for
 
 TheEnd:
-    ALOGV("%s: exit; ok=%u", fn, retval);
-    return retval;
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit; ok=%u", fn, retval);
+  return retval;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        notifyTransactionListenersOfAid
 **
-** Description:     Notify the NFC service about a transaction event from secure element.
+** Description:     Notify the NFC service about a transaction event from secure
+*element.
 **                  aid: Buffer contains application ID.
 **                  aidLen: Length of application ID.
 **
 ** Returns:         None
 **
 *******************************************************************************/
-void SecureElement::notifyTransactionListenersOfAid (const uint8_t* aidBuffer, uint8_t aidBufferLen, const uint8_t* dataBuffer, uint32_t dataBufferLen,uint32_t evtSrc)
-{
-    static const char fn [] = "SecureElement::notifyTransactionListenersOfAid";
-    ALOGV("%s: enter; aid len=%u data len=%ld", fn, aidBufferLen, dataBufferLen);
-
-    if (aidBufferLen == 0) {
-        return;
-    }
-
-    JNIEnv* e = NULL;
-    ScopedAttach attach(mNativeData->vm, &e);
-    if (e == NULL)
-    {
-        ALOGE("%s: jni env is null", fn);
-        return;
-    }
-
-    const uint16_t tlvMaxLen = aidBufferLen + 10;
-    uint8_t* tlv = new uint8_t [tlvMaxLen];
-    if (tlv == NULL)
-    {
-        ALOGE("%s: fail allocate tlv", fn);
-        return;
-    }
-
-    memcpy (tlv, aidBuffer, aidBufferLen);
-    uint16_t tlvActualLen = aidBufferLen;
-
-    ScopedLocalRef<jobject> tlvJavaArray(e, e->NewByteArray(tlvActualLen));
-    if (tlvJavaArray.get() == NULL)
-    {
-        ALOGE("%s: fail allocate array", fn);
-        goto TheEnd;
-    }
-
-    e->SetByteArrayRegion ((jbyteArray)tlvJavaArray.get(), 0, tlvActualLen, (jbyte *)tlv);
-    if (e->ExceptionCheck())
-    {
-        e->ExceptionClear();
-        ALOGE("%s: fail fill array", fn);
-        goto TheEnd;
-    }
-
-    if(dataBufferLen > 0)
-    {
-        const uint32_t dataTlvMaxLen = dataBufferLen + 10;
-        uint8_t* datatlv = new uint8_t [dataTlvMaxLen];
-        if (datatlv == NULL)
-        {
-            ALOGE("%s: fail allocate tlv", fn);
-            return;
-        }
-
-        memcpy (datatlv, dataBuffer, dataBufferLen);
-        uint16_t dataTlvActualLen = dataBufferLen;
-
-        ScopedLocalRef<jobject> dataTlvJavaArray(e, e->NewByteArray(dataTlvActualLen));
-        if (dataTlvJavaArray.get() == NULL)
-        {
-            ALOGE("%s: fail allocate array", fn);
-            goto Clean;
-        }
-
-        e->SetByteArrayRegion ((jbyteArray)dataTlvJavaArray.get(), 0, dataTlvActualLen, (jbyte *)datatlv);
-        if (e->ExceptionCheck())
-        {
-            e->ExceptionClear();
-            ALOGE("%s: fail fill array", fn);
-            goto Clean;
-        }
-
-        e->CallVoidMethod (mNativeData->manager, android::gCachedNfcManagerNotifyTransactionListeners, tlvJavaArray.get(), dataTlvJavaArray.get(), evtSrc);
-        if (e->ExceptionCheck())
-        {
-            e->ExceptionClear();
-            ALOGE("%s: fail notify", fn);
-            goto Clean;
-        }
-
-     Clean:
-        delete [] datatlv;
-    }
-    else
-    {
-        e->CallVoidMethod (mNativeData->manager, android::gCachedNfcManagerNotifyTransactionListeners, tlvJavaArray.get(), NULL, evtSrc);
-        if (e->ExceptionCheck())
-        {
-            e->ExceptionClear();
-            ALOGE("%s: fail notify", fn);
-            goto TheEnd;
-        }
-    }
+void SecureElement::notifyTransactionListenersOfAid(const uint8_t* aidBuffer,
+                                                    uint8_t aidBufferLen,
+                                                    const uint8_t* dataBuffer,
+                                                    uint32_t dataBufferLen,
+                                                    uint32_t evtSrc) {
+  static const char fn[] = "SecureElement::notifyTransactionListenersOfAid";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: enter; aid len=%u data len=%u", fn, aidBufferLen, dataBufferLen);
+
+  if (aidBufferLen == 0) {
+    return;
+  }
+
+  JNIEnv* e = NULL;
+  ScopedAttach attach(mNativeData->vm, &e);
+  if (e == NULL) {
+    LOG(ERROR) << StringPrintf("%s: jni env is null", fn);
+    return;
+  }
+
+  const uint16_t tlvMaxLen = aidBufferLen + 10;
+  uint8_t* tlv = new uint8_t[tlvMaxLen];
+  if (tlv == NULL) {
+    LOG(ERROR) << StringPrintf("%s: fail allocate tlv", fn);
+    return;
+  }
+
+  memcpy(tlv, aidBuffer, aidBufferLen);
+  uint16_t tlvActualLen = aidBufferLen;
+
+  ScopedLocalRef<jobject> tlvJavaArray(e, e->NewByteArray(tlvActualLen));
+  if (tlvJavaArray.get() == NULL) {
+    LOG(ERROR) << StringPrintf("%s: fail allocate array", fn);
+    goto TheEnd;
+  }
+
+  e->SetByteArrayRegion((jbyteArray)tlvJavaArray.get(), 0, tlvActualLen,
+                        (jbyte*)tlv);
+  if (e->ExceptionCheck()) {
+    e->ExceptionClear();
+    LOG(ERROR) << StringPrintf("%s: fail fill array", fn);
+    goto TheEnd;
+  }
+
+  if (dataBufferLen > 0) {
+    const uint32_t dataTlvMaxLen = dataBufferLen + 10;
+    uint8_t* datatlv = new uint8_t[dataTlvMaxLen];
+    if (datatlv == NULL) {
+      LOG(ERROR) << StringPrintf("%s: fail allocate tlv", fn);
+      return;
+    }
+
+    memcpy(datatlv, dataBuffer, dataBufferLen);
+    uint16_t dataTlvActualLen = dataBufferLen;
+
+    ScopedLocalRef<jobject> dataTlvJavaArray(e,
+                                             e->NewByteArray(dataTlvActualLen));
+    if (dataTlvJavaArray.get() == NULL) {
+      LOG(ERROR) << StringPrintf("%s: fail allocate array", fn);
+      goto Clean;
+    }
+
+    e->SetByteArrayRegion((jbyteArray)dataTlvJavaArray.get(), 0,
+                          dataTlvActualLen, (jbyte*)datatlv);
+    if (e->ExceptionCheck()) {
+      e->ExceptionClear();
+      LOG(ERROR) << StringPrintf("%s: fail fill array", fn);
+      goto Clean;
+    }
+
+    e->CallVoidMethod(mNativeData->manager,
+                      android::gCachedNfcManagerNotifyTransactionListeners,
+                      tlvJavaArray.get(), dataTlvJavaArray.get(), evtSrc);
+    if (e->ExceptionCheck()) {
+      e->ExceptionClear();
+      LOG(ERROR) << StringPrintf("%s: fail notify", fn);
+      goto Clean;
+    }
+
+  Clean:
+    delete[] datatlv;
+  } else {
+    e->CallVoidMethod(mNativeData->manager,
+                      android::gCachedNfcManagerNotifyTransactionListeners,
+                      tlvJavaArray.get(), NULL, evtSrc);
+    if (e->ExceptionCheck()) {
+      e->ExceptionClear();
+      LOG(ERROR) << StringPrintf("%s: fail notify", fn);
+      goto TheEnd;
+    }
+  }
 TheEnd:
-    delete [] tlv;
-    ALOGV("%s: exit", fn);
+  delete[] tlv;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
 }
 
 /*******************************************************************************
 **
 ** Function:        notifyConnectivityListeners
 **
-** Description:     Notify the NFC service about a connectivity event from secure element.
+** Description:     Notify the NFC service about a connectivity event from
+*secure element.
 **                  evtSrc: source of event UICC/eSE.
 **
 ** Returns:         None
 **
 *******************************************************************************/
-void SecureElement::notifyConnectivityListeners (uint8_t evtSrc)
-{
-    static const char fn [] = "SecureElement::notifyConnectivityListeners";
-    ALOGV("%s: enter; evtSrc =%u", fn, evtSrc);
-
-    JNIEnv* e = NULL;
-    ScopedAttach attach(mNativeData->vm, &e);
-    if (e == NULL)
-    {
-        ALOGE("%s: jni env is null", fn);
-        return;
-    }
-
-    e->CallVoidMethod (mNativeData->manager, android::gCachedNfcManagerNotifyConnectivityListeners,evtSrc);
-    if (e->ExceptionCheck())
-    {
-        e->ExceptionClear();
-        ALOGE("%s: fail notify", fn);
-        goto TheEnd;
-    }
+void SecureElement::notifyConnectivityListeners(uint8_t evtSrc) {
+  static const char fn[] = "SecureElement::notifyConnectivityListeners";
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter; evtSrc =%u", fn, evtSrc);
+
+  JNIEnv* e = NULL;
+  ScopedAttach attach(mNativeData->vm, &e);
+  if (e == NULL) {
+    LOG(ERROR) << StringPrintf("%s: jni env is null", fn);
+    return;
+  }
+
+  e->CallVoidMethod(mNativeData->manager,
+                    android::gCachedNfcManagerNotifyConnectivityListeners,
+                    evtSrc);
+  if (e->ExceptionCheck()) {
+    e->ExceptionClear();
+    LOG(ERROR) << StringPrintf("%s: fail notify", fn);
+    goto TheEnd;
+  }
 
 TheEnd:
-    ALOGV("%s: exit", fn);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
 }
 
 /*******************************************************************************
@@ -1326,29 +1236,29 @@ TheEnd:
 ** Returns:         None
 **
 *******************************************************************************/
-void SecureElement::notifyEmvcoMultiCardDetectedListeners ()
-{
-    static const char fn [] = "SecureElement::notifyEmvcoMultiCardDetectedListeners";
-    ALOGV("%s: enter", fn);
-
-    JNIEnv* e = NULL;
-    ScopedAttach attach(mNativeData->vm, &e);
-    if (e == NULL)
-    {
-        ALOGE("%s: jni env is null", fn);
-        return;
-    }
-
-    e->CallVoidMethod (mNativeData->manager, android::gCachedNfcManagerNotifyEmvcoMultiCardDetectedListeners);
-    if (e->ExceptionCheck())
-    {
-        e->ExceptionClear();
-        ALOGE("%s: fail notify", fn);
-        goto TheEnd;
-    }
+void SecureElement::notifyEmvcoMultiCardDetectedListeners() {
+  static const char fn[] =
+      "SecureElement::notifyEmvcoMultiCardDetectedListeners";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+
+  JNIEnv* e = NULL;
+  ScopedAttach attach(mNativeData->vm, &e);
+  if (e == NULL) {
+    LOG(ERROR) << StringPrintf("%s: jni env is null", fn);
+    return;
+  }
+
+  e->CallVoidMethod(
+      mNativeData->manager,
+      android::gCachedNfcManagerNotifyEmvcoMultiCardDetectedListeners);
+  if (e->ExceptionCheck()) {
+    e->ExceptionClear();
+    LOG(ERROR) << StringPrintf("%s: fail notify", fn);
+    goto TheEnd;
+  }
 
 TheEnd:
-    ALOGV("%s: exit", fn);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
 }
 
 /*******************************************************************************
@@ -1360,235 +1270,219 @@ TheEnd:
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-bool SecureElement::connectEE ()
-{
-    static const char fn [] = "SecureElement::connectEE";
-    tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
-    bool        retVal = false;
-    uint8_t     destHost = 0;
-    unsigned long num = 0;
-    char pipeConfName[40];
-    tNFA_HANDLE  eeHandle = mActiveEeHandle;
-
-    ALOGV("%s: enter, mActiveEeHandle: 0x%04x, SEID: 0x%x, pipe_gate_num=%d, use pipe=%d",
-        fn, mActiveEeHandle, gSEId, gGatePipe, gUseStaticPipe);
-
-    if (!mIsInit)
-    {
-        ALOGE("%s: not init", fn);
-        return (false);
-    }
-
-    if (gSEId != -1)
-    {
-        eeHandle = gSEId | NFA_HANDLE_GROUP_EE;
-        ALOGV("%s: Using SEID: 0x%x", fn, eeHandle );
-    }
-
-    if (eeHandle == NFA_HANDLE_INVALID)
-    {
-        ALOGE("%s: invalid handle 0x%X", fn, eeHandle);
-        return (false);
-    }
-
-    tNFA_EE_INFO *pEE = findEeByHandle (eeHandle);
-
-    if (pEE == NULL)
-    {
-        ALOGE("%s: Handle 0x%04x  NOT FOUND !!", fn, eeHandle);
-        return (false);
-    }
+bool SecureElement::connectEE() {
+  static const char fn[] = "SecureElement::connectEE";
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+  bool retVal = false;
+  uint8_t destHost = 0;
+  char pipeConfName[40];
+  tNFA_HANDLE eeHandle = mActiveEeHandle;
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: enter, mActiveEeHandle: 0x%04x, SEID: 0x%x, pipe_gate_num=%d, use "
+      "pipe=%d",
+      fn, mActiveEeHandle, gSEId, gGatePipe, gUseStaticPipe);
+
+  if (!mIsInit) {
+    LOG(ERROR) << StringPrintf("%s: not init", fn);
+    return (false);
+  }
+
+  if (gSEId != -1) {
+    eeHandle = gSEId | NFA_HANDLE_GROUP_EE;
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Using SEID: 0x%x", fn, eeHandle);
+  }
+
+  if (eeHandle == NFA_HANDLE_INVALID) {
+    LOG(ERROR) << StringPrintf("%s: invalid handle 0x%X", fn, eeHandle);
+    return (false);
+  }
+
+  tNFA_EE_INFO* pEE = findEeByHandle(eeHandle);
+
+  if (pEE == NULL) {
+    LOG(ERROR) << StringPrintf("%s: Handle 0x%04x  NOT FOUND !!", fn, eeHandle);
+    return (false);
+  }
 
 #if (NXP_EXTNS == TRUE)
-    if(nfcFL.nfcNxpEse) {
-        if(nfcFL.eseFL._ESE_WIRED_MODE_DISABLE_DISCOVERY) {
-            // Disable RF discovery completely while the DH is connected
-            android::startRfDiscovery(false);
-        }
-    }
-    else {
-        android::startRfDiscovery(false);
+  if (nfcFL.nfcNxpEse) {
+    if (nfcFL.eseFL._ESE_WIRED_MODE_DISABLE_DISCOVERY) {
+      // Disable RF discovery completely while the DH is connected
+      android::startRfDiscovery(false);
     }
-#else
+  } else {
     android::startRfDiscovery(false);
+  }
+#else
+  android::startRfDiscovery(false);
 #endif
 
-    // Disable UICC idle timeout while the DH is connected
-    //android::setUiccIdleTimeout (false);
+  // Disable UICC idle timeout while the DH is connected
+  // android::setUiccIdleTimeout (false);
 
-    mNewSourceGate = 0;
+  mNewSourceGate = 0;
 
-    if (gGatePipe == -1)
-    {
-        // pipe/gate num was not specifed by app, get from config file
-        mNewPipeId     = 0;
+  if (gGatePipe == -1) {
+    // pipe/gate num was not specifed by app, get from config file
+    mNewPipeId = 0;
 
-        // Construct the PIPE name based on the EE handle (e.g. NFA_HCI_STATIC_PIPE_ID_F3 for UICC0).
-        snprintf (pipeConfName, sizeof(pipeConfName), "NFA_HCI_STATIC_PIPE_ID_%02X", eeHandle & NFA_HANDLE_MASK);
+    // Construct the PIPE name based on the EE handle (e.g.
+    // NFA_HCI_STATIC_PIPE_ID_F3 for UICC0).
+    if(eeHandle == 0x4C0) {
+        snprintf(pipeConfName, sizeof(pipeConfName), "OFF_HOST_ESE_PIPE_ID");
+      }
+    else {
+        snprintf(pipeConfName, sizeof(pipeConfName), "OFF_HOST_SIM_PIPE_ID");
+      }
 
-        if (GetNumValue(pipeConfName, &num, sizeof(num)) && (num != 0))
-        {
-            mNewPipeId = num;
-            ALOGV("%s: Using static pipe id: 0x%X", __func__, mNewPipeId);
-        }
-        else
-        {
-            ALOGV("%s: Did not find value '%s' defined in the .conf", __func__, pipeConfName);
-        }
+    if (NfcConfig::hasKey(pipeConfName)) {
+      mNewPipeId = NfcConfig::getUnsigned(pipeConfName);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: Using static pipe id: 0x%X", __func__, mNewPipeId);
+    } else {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: Did not find value '%s' defined in the .conf",
+                          __func__, pipeConfName);
     }
-    else
-    {
-        if (gUseStaticPipe)
-        {
-            mNewPipeId     = gGatePipe;
-        }
-        else
-        {
-            mNewPipeId      = 0;
-            mDestinationGate= gGatePipe;
-        }
+  } else {
+    if (gUseStaticPipe) {
+      mNewPipeId = gGatePipe;
+    } else {
+      mNewPipeId = 0;
+      mDestinationGate = gGatePipe;
     }
+  }
 
-    // If the .conf file had a static pipe to use, just use it.
-    if (mNewPipeId != 0)
-    {
-#if(NXP_EXTNS == TRUE)
-        uint8_t host;
-        if(mActiveEeHandle == EE_HANDLE_0xF3)
-        {
-            host = (mNewPipeId == mStaticPipeProp) ? 0xC0 : 0x03;
-        }
-        else
-        {
-            host = (mNewPipeId == STATIC_PIPE_UICC) ? 0x02 : 0x03;
-        }
+  // If the .conf file had a static pipe to use, just use it.
+  if (mNewPipeId != 0) {
+#if (NXP_EXTNS == TRUE)
+    uint8_t host;
+    if (mActiveEeHandle == EE_HANDLE_0xF3) {
+      host = (mNewPipeId == mStaticPipeProp) ? 0xC0 : 0x03;
+    } else {
+      host = (mNewPipeId == STATIC_PIPE_UICC) ? 0x02 : 0x03;
+    }
 #else
-        uint8_t host = (mNewPipeId == mStaticPipeProp) ? 0x02 : 0x03;
+    uint8_t host = (mNewPipeId == mStaticPipeProp) ? 0x02 : 0x03;
 #endif
-        //TODO according ETSI12 APDU Gate
-#if(NXP_EXTNS == TRUE)
-        uint8_t gate;
-        if(mActiveEeHandle == EE_HANDLE_0xF3)
-        {
-            gate = (mNewPipeId == mStaticPipeProp) ? 0xF0 : 0xF1;
-        }
-        else
-        {
-            gate = (mNewPipeId == STATIC_PIPE_UICC) ? 0x30 : 0x31;
-        }
+// TODO according ETSI12 APDU Gate
+#if (NXP_EXTNS == TRUE)
+    uint8_t gate;
+    if (mActiveEeHandle == EE_HANDLE_0xF3) {
+      gate = (mNewPipeId == mStaticPipeProp) ? 0xF0 : 0xF1;
+    } else {
+      gate = (mNewPipeId == STATIC_PIPE_UICC) ? 0x30 : 0x31;
+    }
 #else
-        uint8_t gate = (mNewPipeId == mStaticPipeProp) ? 0xF0 : 0xF1;
+    uint8_t gate = (mNewPipeId == mStaticPipeProp) ? 0xF0 : 0xF1;
 #endif
-#if(NXP_EXTNS == TRUE)
-        ALOGV("%s: Using host id : 0x%X,gate id : 0x%X,pipe id : 0x%X", __func__,host,gate, mNewPipeId);
+#if (NXP_EXTNS == TRUE)
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: Using host id : 0x%X,gate id : 0x%X,pipe id : 0x%X", __func__,
+        host, gate, mNewPipeId);
 #endif
-        if(nfcFL.eseFL._LEGACY_APDU_GATE && (getApduGateInfo() != ETSI_12_APDU_GATE))
-        {
-            nfaStat = NFA_HciAddStaticPipe(mNfaHciHandle, host, gate, mNewPipeId);
-            if (nfaStat != NFA_STATUS_OK)
-            {
-                ALOGE("%s: fail create static pipe; error=0x%X", fn, nfaStat);
-                retVal = false;
-                goto TheEnd;
-            }
-        }
+    if (nfcFL.eseFL._LEGACY_APDU_GATE &&
+        (getApduGateInfo() != ETSI_12_APDU_GATE)) {
+      nfaStat = NFA_HciAddStaticPipe(mNfaHciHandle, host, gate, mNewPipeId);
+      if (nfaStat != NFA_STATUS_OK) {
+        LOG(ERROR) << StringPrintf("%s: fail create static pipe; error=0x%X",
+                                   fn, nfaStat);
+        retVal = false;
+        goto TheEnd;
+      }
     }
+  } else {
+    if ((pEE->num_tlvs >= 1) && (pEE->ee_tlv[0].tag == NFA_EE_TAG_HCI_HOST_ID))
+      destHost = pEE->ee_tlv[0].info[0];
     else
-    {
-        if ( (pEE->num_tlvs >= 1) && (pEE->ee_tlv[0].tag == NFA_EE_TAG_HCI_HOST_ID) )
-            destHost = pEE->ee_tlv[0].info[0];
-        else
-#if(NXP_EXTNS == TRUE)
-            destHost = (EE_HANDLE_0xF3 & ~NFA_HANDLE_GROUP_EE);
+#if (NXP_EXTNS == TRUE)
+      destHost = (EE_HANDLE_0xF3 & ~NFA_HANDLE_GROUP_EE);
 #else
-            destHost = 2;
+      destHost = 2;
 #endif
 
-        // Get a list of existing gates and pipes
-        {
-            ALOGV("%s: get gate, pipe list", fn);
-            SyncEventGuard guard (mPipeListEvent);
-            nfaStat = NFA_HciGetGateAndPipeList (mNfaHciHandle);
-            if (nfaStat == NFA_STATUS_OK)
-            {
-                mPipeListEvent.wait();
-                if (mHciCfg.status == NFA_STATUS_OK)
-                {
-                    for (uint8_t xx = 0; xx < mHciCfg.num_pipes; xx++)
-                    {
-                        if ( (mHciCfg.pipe[xx].dest_host == destHost)
-                         &&  (mHciCfg.pipe[xx].dest_gate == mDestinationGate) )
-                        {
-                            mNewSourceGate = mHciCfg.pipe[xx].local_gate;
-                            mNewPipeId     = mHciCfg.pipe[xx].pipe_id;
-
-                            ALOGV("%s: found configured gate: 0x%02x  pipe: 0x%02x", fn, mNewSourceGate, mNewPipeId);
-                            break;
-                        }
-                    }
-                }
-            }
-        }
-
-        if (mNewSourceGate == 0)
-        {
-            ALOGV("%s: allocate gate", fn);
-            //allocate a source gate and store in mNewSourceGate
-            SyncEventGuard guard (mAllocateGateEvent);
-            if ((nfaStat = NFA_HciAllocGate (mNfaHciHandle, mDestinationGate)) != NFA_STATUS_OK)
-            {
-                ALOGE("%s: fail allocate source gate; error=0x%X", fn, nfaStat);
-                goto TheEnd;
-            }
-            mAllocateGateEvent.wait ();
-            if (mCommandStatus != NFA_STATUS_OK)
-               goto TheEnd;
-        }
-
-        if (mNewPipeId == 0)
-        {
-            ALOGV("%s: create pipe", fn);
-            SyncEventGuard guard (mCreatePipeEvent);
-            nfaStat = NFA_HciCreatePipe (mNfaHciHandle, mNewSourceGate, destHost, mDestinationGate);
-            if (nfaStat != NFA_STATUS_OK)
-            {
-                ALOGE("%s: fail create pipe; error=0x%X", fn, nfaStat);
-                goto TheEnd;
-            }
-            mCreatePipeEvent.wait ();
-            if (mCommandStatus != NFA_STATUS_OK)
-               goto TheEnd;
-        }
-
-        {
-            ALOGV("%s: open pipe", fn);
-            SyncEventGuard guard (mPipeOpenedEvent);
-            nfaStat = NFA_HciOpenPipe (mNfaHciHandle, mNewPipeId);
-            if (nfaStat != NFA_STATUS_OK)
-            {
-                ALOGE("%s: fail open pipe; error=0x%X", fn, nfaStat);
-                goto TheEnd;
+    // Get a list of existing gates and pipes
+    {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: get gate, pipe list", fn);
+      SyncEventGuard guard(mPipeListEvent);
+      nfaStat = NFA_HciGetGateAndPipeList(mNfaHciHandle);
+      if (nfaStat == NFA_STATUS_OK) {
+        mPipeListEvent.wait();
+        if (mHciCfg.status == NFA_STATUS_OK) {
+          for (uint8_t xx = 0; xx < mHciCfg.num_pipes; xx++) {
+            if ((mHciCfg.pipe[xx].dest_host == destHost) &&
+                (mHciCfg.pipe[xx].dest_gate == mDestinationGate)) {
+              mNewSourceGate = mHciCfg.pipe[xx].local_gate;
+              mNewPipeId = mHciCfg.pipe[xx].pipe_id;
+
+              DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+                  "%s: found configured gate: 0x%02x  pipe: 0x%02x", fn,
+                  mNewSourceGate, mNewPipeId);
+              break;
             }
-            mPipeOpenedEvent.wait ();
-            if (mCommandStatus != NFA_STATUS_OK)
-               goto TheEnd;
+          }
         }
+      }
     }
 
-    retVal = true;
+    if (mNewSourceGate == 0) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: allocate gate", fn);
+      // allocate a source gate and store in mNewSourceGate
+      SyncEventGuard guard(mAllocateGateEvent);
+      if ((nfaStat = NFA_HciAllocGate(mNfaHciHandle, mDestinationGate)) !=
+          NFA_STATUS_OK) {
+        LOG(ERROR) << StringPrintf("%s: fail allocate source gate; error=0x%X",
+                                   fn, nfaStat);
+        goto TheEnd;
+      }
+      mAllocateGateEvent.wait();
+      if (mCommandStatus != NFA_STATUS_OK) goto TheEnd;
+    }
+
+    if (mNewPipeId == 0) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: create pipe", fn);
+      SyncEventGuard guard(mCreatePipeEvent);
+      nfaStat = NFA_HciCreatePipe(mNfaHciHandle, mNewSourceGate, destHost,
+                                  mDestinationGate);
+      if (nfaStat != NFA_STATUS_OK) {
+        LOG(ERROR) << StringPrintf("%s: fail create pipe; error=0x%X", fn,
+                                   nfaStat);
+        goto TheEnd;
+      }
+      mCreatePipeEvent.wait();
+      if (mCommandStatus != NFA_STATUS_OK) goto TheEnd;
+    }
 
-TheEnd:
-    mIsPiping = retVal;
-    if (!retVal)
     {
-        // if open failed we need to de-allocate the gate
-        disconnectEE(0);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: open pipe", fn);
+      SyncEventGuard guard(mPipeOpenedEvent);
+      nfaStat = NFA_HciOpenPipe(mNfaHciHandle, mNewPipeId);
+      if (nfaStat != NFA_STATUS_OK) {
+        LOG(ERROR) << StringPrintf("%s: fail open pipe; error=0x%X", fn,
+                                   nfaStat);
+        goto TheEnd;
+      }
+      mPipeOpenedEvent.wait();
+      if (mCommandStatus != NFA_STATUS_OK) goto TheEnd;
     }
+  }
 
-    ALOGV("%s: exit; ok=%u", fn, retVal);
-    return retVal;
-}
+  retVal = true;
 
+TheEnd:
+  mIsPiping = retVal;
+  if (!retVal) {
+    // if open failed we need to de-allocate the gate
+    disconnectEE(0);
+  }
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit; ok=%u", fn, retVal);
+  return retVal;
+}
 
 /*******************************************************************************
 **
@@ -1600,72 +1494,75 @@ TheEnd:
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-bool SecureElement::disconnectEE (jint seID)
-{
-    static const char fn [] = "SecureElement::disconnectEE";
-    tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
-    tNFA_HANDLE eeHandle = seID;
-
-    ALOGV("%s: seID=0x%X; handle=0x%04x", fn, seID, eeHandle);
-
-    if (mUseOberthurWarmReset)
-    {
-        //send warm-reset command to Oberthur secure element which deselects the applet;
-        //this is an Oberthur-specific command;
-        ALOGV("%s: try warm-reset on pipe id 0x%X; cmd=0x%X", fn, mNewPipeId, mOberthurWarmResetCommand);
-        SyncEventGuard guard (mRegistryEvent);
-        nfaStat = NFA_HciSetRegistry (mNfaHciHandle, mNewPipeId,
-                1, 1, &mOberthurWarmResetCommand);
-        if (nfaStat == NFA_STATUS_OK)
-        {
-            mRegistryEvent.wait ();
-            ALOGV("%s: completed warm-reset on pipe 0x%X", fn, mNewPipeId);
-        }
-    }
-
-    if (mNewSourceGate && (mNewSourceGate != NFA_HCI_ETSI12_APDU_GATE))
-    {
-        SyncEventGuard guard (mDeallocateGateEvent);
-        if ((nfaStat = NFA_HciDeallocGate (mNfaHciHandle, mNewSourceGate)) == NFA_STATUS_OK)
-            mDeallocateGateEvent.wait ();
-        else
-            ALOGE("%s: fail dealloc gate; error=0x%X", fn, nfaStat);
-    }
+bool SecureElement::disconnectEE(jint seID) {
+  static const char fn[] = "SecureElement::disconnectEE";
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+  tNFA_HANDLE eeHandle = seID;
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: seID=0x%X; handle=0x%04x", fn, seID, eeHandle);
+
+  if (mUseOberthurWarmReset) {
+    // send warm-reset command to Oberthur secure element which deselects the
+    // applet;
+    // this is an Oberthur-specific command;
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: try warm-reset on pipe id 0x%X; cmd=0x%X", fn,
+                        mNewPipeId, mOberthurWarmResetCommand);
+    SyncEventGuard guard(mRegistryEvent);
+    nfaStat = NFA_HciSetRegistry(mNfaHciHandle, mNewPipeId, 1, 1,
+                                 &mOberthurWarmResetCommand);
+    if (nfaStat == NFA_STATUS_OK) {
+      mRegistryEvent.wait();
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: completed warm-reset on pipe 0x%X", fn, mNewPipeId);
+    }
+  }
+
+  if (mNewSourceGate && (mNewSourceGate != NFA_HCI_ETSI12_APDU_GATE)) {
+    SyncEventGuard guard(mDeallocateGateEvent);
+    if ((nfaStat = NFA_HciDeallocGate(mNfaHciHandle, mNewSourceGate)) ==
+        NFA_STATUS_OK)
+      mDeallocateGateEvent.wait();
+    else
+      LOG(ERROR) << StringPrintf("%s: fail dealloc gate; error=0x%X", fn,
+                                 nfaStat);
+  }
 
-    mIsPiping = false;
+  mIsPiping = false;
 
-    if(nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE && nfcFL.eseFL._ESE_SVDD_SYNC &&
-            (dual_mode_current_state & SPI_ON)) {
-        /*The state of the SPI should not be cleared based on DWP state close. dual_mode_current_state updated in spi_prio_signal_handler function.*/
-        /*clear the SPI transaction flag*/
-        dual_mode_current_state ^= SPI_ON;
-}
+  if (nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE && nfcFL.eseFL._ESE_SVDD_SYNC &&
+      (dual_mode_current_state & SPI_ON)) {
+    /*The state of the SPI should not be cleared based on DWP state close.
+     * dual_mode_current_state updated in spi_prio_signal_handler function.*/
+    /*clear the SPI transaction flag*/
+    dual_mode_current_state ^= SPI_ON;
+  }
 
-    hold_the_transceive = false;
-#if(NXP_EXTNS == TRUE)
-    if(nfcFL.nfcNxpEse) {
-        hold_wired_mode = false;
-    }
+  hold_the_transceive = false;
+#if (NXP_EXTNS == TRUE)
+  if (nfcFL.nfcNxpEse) {
+    hold_wired_mode = false;
+  }
 #endif
 
-    // Re-enable UICC low-power mode
-    // Re-enable RF discovery
-    // Note that it only effactuates the current configuration,
-    // so if polling/listening were configured OFF (forex because
-    // the screen was off), they will stay OFF with this call.
-    /*Blocked as part  done in connectEE, to allow wired mode during reader mode.*/
-    if(nfcFL.nfcNxpEse && nfcFL.chipType != pn547C2) {
-        // Do Nothing
-    }
-    else {
-        android::setUiccIdleTimeout (true);
-        android::startRfDiscovery(true);
-    }
+  // Re-enable UICC low-power mode
+  // Re-enable RF discovery
+  // Note that it only effactuates the current configuration,
+  // so if polling/listening were configured OFF (forex because
+  // the screen was off), they will stay OFF with this call.
+  /*Blocked as part  done in connectEE, to allow wired mode during reader
+   * mode.*/
+  if (nfcFL.nfcNxpEse && nfcFL.chipType != pn547C2) {
+    // Do Nothing
+  } else {
+    android::setUiccIdleTimeout(true);
+    android::startRfDiscovery(true);
+  }
 
-    return true;
+  return true;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        transceive
@@ -1681,261 +1578,280 @@ bool SecureElement::disconnectEE (jint seID)
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-#if(NXP_EXTNS == TRUE)
-eTransceiveStatus SecureElement::transceive (uint8_t* xmitBuffer, int32_t xmitBufferSize, uint8_t* recvBuffer,
-        int32_t recvBufferMaxSize, int32_t& recvBufferActualSize, int32_t timeoutMillisec)
+#if (NXP_EXTNS == TRUE)
+eTransceiveStatus SecureElement::transceive(uint8_t* xmitBuffer,
+                                            int32_t xmitBufferSize,
+                                            uint8_t* recvBuffer,
+                                            int32_t recvBufferMaxSize,
+                                            int32_t& recvBufferActualSize,
+                                            int32_t timeoutMillisec)
 #else
-bool SecureElement::transceive (uint8_t* xmitBuffer, int32_t xmitBufferSize, uint8_t* recvBuffer,
-        int32_t recvBufferMaxSize, int32_t& recvBufferActualSize, int32_t timeoutMillisec)
+bool SecureElement::transceive(uint8_t* xmitBuffer, int32_t xmitBufferSize,
+                               uint8_t* recvBuffer, int32_t recvBufferMaxSize,
+                               int32_t& recvBufferActualSize,
+                               int32_t timeoutMillisec)
 #endif
 {
 
-
-    static const char fn [] = "SecureElement::transceive";
-    tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
-    bool isSuccess = false;
-    mTransceiveWaitOk = false;
-    uint8_t newSelectCmd[NCI_MAX_AID_LEN + 10];
-#if(NXP_EXTNS == TRUE)
-    eTransceiveStatus tranStatus    = TRANSCEIVE_STATUS_FAILED;
+  static const char fn[] = "SecureElement::transceive";
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+  mTransceiveWaitOk = false;
+  uint8_t newSelectCmd[NCI_MAX_AID_LEN + 10];
+#if (NXP_EXTNS == TRUE)
+  eTransceiveStatus tranStatus = TRANSCEIVE_STATUS_FAILED;
 #else
-    bool isSuccess                  = false;
+  bool isSuccess = false;
 #endif
-#if(NXP_EXTNS == TRUE)
-    bool isEseAccessSuccess = false;
+#if (NXP_EXTNS == TRUE)
+  bool isEseAccessSuccess = false;
 #endif
 
-    ALOGV("%s: enter; xmitBufferSize=%ld; recvBufferMaxSize=%ld; timeout=%ld", fn, xmitBufferSize, recvBufferMaxSize, timeoutMillisec);
-
-    // Check if we need to replace an "empty" SELECT command.
-    // 1. Has there been a AID configured, and
-    // 2. Is that AID a valid length (i.e 16 bytes max), and
-    // 3. Is the APDU at least 4 bytes (for header), and
-    // 4. Is INS == 0xA4 (SELECT command), and
-    // 5. Is P1 == 0x04 (SELECT by AID), and
-    // 6. Is the APDU len 4 or 5 bytes.
-    //
-    // Note, the length of the configured AID is in the first
-    //   byte, and AID starts from the 2nd byte.
-    if (mAidForEmptySelect[0]                           // 1
-                           && (mAidForEmptySelect[0] <= NCI_MAX_AID_LEN)   // 2
-                           && (xmitBufferSize >= 4)                        // 3
-                           && (xmitBuffer[1] == 0xA4)                      // 4
-                           && (xmitBuffer[2] == 0x04)                      // 5
-                           && (xmitBufferSize <= 5))                       // 6
-    {
-        uint8_t idx = 0;
-
-        // Copy APDU command header from the input buffer.
-        memcpy(&newSelectCmd[0], &xmitBuffer[0], 4);
-        idx = 4;
-
-        // Set the Lc value to length of the new AID
-        newSelectCmd[idx++] = mAidForEmptySelect[0];
-
-        // Copy the AID
-        memcpy(&newSelectCmd[idx], &mAidForEmptySelect[1], mAidForEmptySelect[0]);
-        idx += mAidForEmptySelect[0];
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: enter; xmitBufferSize=%d; recvBufferMaxSize=%d; timeout=%d", fn,
+      xmitBufferSize, recvBufferMaxSize, timeoutMillisec);
+
+  // Check if we need to replace an "empty" SELECT command.
+  // 1. Has there been a AID configured, and
+  // 2. Is that AID a valid length (i.e 16 bytes max), and
+  // 3. Is the APDU at least 4 bytes (for header), and
+  // 4. Is INS == 0xA4 (SELECT command), and
+  // 5. Is P1 == 0x04 (SELECT by AID), and
+  // 6. Is the APDU len 4 or 5 bytes.
+  //
+  // Note, the length of the configured AID is in the first
+  //   byte, and AID starts from the 2nd byte.
+  if (mAidForEmptySelect[0]                          // 1
+      && (mAidForEmptySelect[0] <= NCI_MAX_AID_LEN)  // 2
+      && (xmitBufferSize >= 4)                       // 3
+      && (xmitBuffer[1] == 0xA4)                     // 4
+      && (xmitBuffer[2] == 0x04)                     // 5
+      && (xmitBufferSize <= 5))                      // 6
+  {
+    uint8_t idx = 0;
+
+    // Copy APDU command header from the input buffer.
+    memcpy(&newSelectCmd[0], &xmitBuffer[0], 4);
+    idx = 4;
+
+    // Set the Lc value to length of the new AID
+    newSelectCmd[idx++] = mAidForEmptySelect[0];
+
+    // Copy the AID
+    memcpy(&newSelectCmd[idx], &mAidForEmptySelect[1], mAidForEmptySelect[0]);
+    idx += mAidForEmptySelect[0];
+
+    // If there is an Le (5th byte of APDU), add it to the end.
+    if (xmitBufferSize == 5) newSelectCmd[idx++] = xmitBuffer[4];
+
+    // Point to the new APDU
+    xmitBuffer = &newSelectCmd[0];
+    xmitBufferSize = idx;
+
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: Empty AID SELECT cmd detected, substituting AID from config file, "
+        "new length=%d",
+        fn, idx);
+  }
 
-        // If there is an Le (5th byte of APDU), add it to the end.
-        if (xmitBufferSize == 5)
-            newSelectCmd[idx++] = xmitBuffer[4];
-
-        // Point to the new APDU
-        xmitBuffer = &newSelectCmd[0];
-        xmitBufferSize = idx;
-
-        ALOGV("%s: Empty AID SELECT cmd detected, substituting AID from config file, new length=%d", fn, idx);
+#if (NXP_EXTNS == TRUE)
+  NfccStandByOperation(STANDBY_MODE_OFF);
+#endif
+  {
+    SyncEventGuard guard(mTransceiveEvent);
+    mActualResponseSize = 0;
+    memset(recvBuffer, 0, recvBufferMaxSize);
+#if (NXP_EXTNS == TRUE)
+    if (nfcFL.nfcNxpEse) {
+      struct timeval start_timer, end_timer;
+      int32_t time_elapsed = 0;
+      while (hold_the_transceive == true) {
+        android::start_timer_msec(&start_timer);
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: holding the transceive for %d ms.\n", fn,
+                            (timeoutMillisec - time_elapsed));
+        SyncEventGuard guard(sSPIPrioSessionEndEvent);
+        if (sSPIPrioSessionEndEvent.wait(timeoutMillisec - time_elapsed) ==
+            false) {
+          LOG(ERROR) << StringPrintf("%s: wait response timeout \n", fn);
+          time_elapsed =
+              android::stop_timer_getdifference_msec(&start_timer, &end_timer);
+          time_elapsed = 0;
+          goto TheEnd;
+        }
+        time_elapsed +=
+            android::stop_timer_getdifference_msec(&start_timer, &end_timer);
+        if ((timeoutMillisec - time_elapsed) <= 0) {
+          LOG(ERROR) << StringPrintf(
+              "%s: wait response timeout - time_elapsed \n", fn);
+          time_elapsed = 0;
+          goto TheEnd;
+        }
+      }
     }
-
-#if(NXP_EXTNS == TRUE)
-        NfccStandByOperation(STANDBY_MODE_OFF);
 #endif
+    if ((mNewPipeId == mStaticPipeProp) || (mNewPipeId == STATIC_PIPE_0x71))
+#if (NXP_EXTNS == TRUE)
     {
-        SyncEventGuard guard (mTransceiveEvent);
-        mActualResponseSize = 0;
-        memset (mResponseData, 0, sizeof(mResponseData));
-#if(NXP_EXTNS == TRUE)
-        if(nfcFL.nfcNxpEse) {
-            struct timeval start_timer, end_timer;
-            int32_t time_elapsed = 0;
-            while(hold_the_transceive == true)
-            {
-                android::start_timer_msec(&start_timer);
-                ALOGV("%s: holding the transceive for %ld ms.\n", fn, (timeoutMillisec - time_elapsed));
-                SyncEventGuard guard(sSPIPrioSessionEndEvent);
-                if(sSPIPrioSessionEndEvent.wait(timeoutMillisec - time_elapsed)== false)
-                {
-                    ALOGE("%s: wait response timeout \n", fn);
-                    time_elapsed = android::stop_timer_getdifference_msec(&start_timer, &end_timer);
-                    time_elapsed = 0;
-                    goto TheEnd;
-                }
-                time_elapsed += android::stop_timer_getdifference_msec(&start_timer, &end_timer);
-                if((timeoutMillisec - time_elapsed) <= 0)
-                {
-                    ALOGE("%s: wait response timeout - time_elapsed \n", fn);
-                    time_elapsed = 0;
-                    goto TheEnd;
-                }
-            }
-        }
+      if (nfcFL.nfccFL._NFCEE_REMOVED_NTF_RECOVERY) {
+        if ((RoutingManager::getInstance().is_ee_recovery_ongoing())) {
+          SyncEventGuard guard(mEEdatapacketEvent);
+          if (mEEdatapacketEvent.wait(timeoutMillisec) == false) goto TheEnd;
+        }
+      }
+      if (nfcFL.nfcNxpEse) {
+        if (nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME ==
+                nfcFL.eseFL._ESE_WIRED_MODE_RESUME ||
+            nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME ==
+                nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
+          if (!checkForWiredModeAccess()) {
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+                "%s, Dont allow wired mode in this RF state", fn);
+            goto TheEnd;
+          }
+        }
+      }
+
+      if (((nfcFL.eseFL._NXP_ESE_VER == JCOP_VER_3_2) ||
+           (nfcFL.eseFL._NXP_ESE_VER == JCOP_VER_3_3)) &&
+          nfcFL.eseFL._TRIPLE_MODE_PROTECTION) {
+        if (dual_mode_current_state == SPI_DWPCL_BOTH_ACTIVE) {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("%s, Dont allow wired mode...Dual Mode..", fn);
+          SyncEventGuard guard(mDualModeEvent);
+          mDualModeEvent.wait();
+        }
+      }
+
+      if (nfcFL.nfcNxpEse) {
+        active_ese_reset_control |= TRANS_WIRED_ONGOING;
+        if ((((nfcFL.eseFL._NXP_ESE_VER == JCOP_VER_3_1) ||
+              (nfcFL.eseFL._NXP_ESE_VER == JCOP_VER_3_2))) &&
+            (NFC_GetEseAccess((void*)&timeoutMillisec) != 0)) {
+          LOG(ERROR) << StringPrintf("%s: NFC_ReqWiredAccess timeout", fn);
+          goto TheEnd;
+        }
+        isEseAccessSuccess = true;
+      }
 #endif
-        if ((mNewPipeId == mStaticPipeProp) || (mNewPipeId == STATIC_PIPE_0x71))
-#if(NXP_EXTNS == TRUE)
-        {
-            if (nfcFL.nfccFL._NFCEE_REMOVED_NTF_RECOVERY) {
-                if((RoutingManager::getInstance().is_ee_recovery_ongoing()))
-                {
-                    SyncEventGuard guard (mEEdatapacketEvent);
-                    if(mEEdatapacketEvent.wait(timeoutMillisec) == false)
-                        goto TheEnd;
-                }
-            }
-        if(nfcFL.nfcNxpEse) {
-            if(nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME == nfcFL.eseFL._ESE_WIRED_MODE_RESUME ||
-                    nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME == nfcFL.eseFL._ESE_WIRED_MODE_RESUME ) {
-                if(!checkForWiredModeAccess())
-                {
-                    ALOGV("%s, Dont allow wired mode in this RF state", fn);
-                    goto TheEnd;
-                }
-            }
-        }
-
-        if(((nfcFL.eseFL._NXP_ESE_VER == JCOP_VER_3_2) || (nfcFL.eseFL._NXP_ESE_VER == JCOP_VER_3_3)) &&nfcFL.eseFL._TRIPLE_MODE_PROTECTION){
-            if((dual_mode_current_state == SPI_DWPCL_BOTH_ACTIVE))
-            {
-                ALOGV("%s, Dont allow wired mode...Dual Mode..", fn);
-                SyncEventGuard guard (mDualModeEvent);
-                mDualModeEvent.wait();
-            }
-        }
-
-        if(nfcFL.nfcNxpEse) {
-            active_ese_reset_control |= TRANS_WIRED_ONGOING;
-            if ((((nfcFL.eseFL._NXP_ESE_VER == JCOP_VER_3_1) || (nfcFL.eseFL._NXP_ESE_VER == JCOP_VER_3_2))) && (NFC_GetEseAccess((void *)&timeoutMillisec) != 0))
-            {
-                ALOGE("%s: NFC_ReqWiredAccess timeout", fn);
-                goto TheEnd;
-            }
-            isEseAccessSuccess = true;
-        }
+      if (nfcFL.nfcNxpEse &&
+          nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) {
+        isTransceiveOngoing = true;
+      }
+      nfaStat = NFA_HciSendEvent(mNfaHciHandle, mNewPipeId, EVT_SEND_DATA,
+                                 xmitBufferSize, xmitBuffer, recvBufferMaxSize,
+                                 recvBuffer, timeoutMillisec);
+#if (NXP_EXTNS == TRUE)
+    } else if (mNewPipeId == STATIC_PIPE_UICC) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s, Starting UICC wired mode!!!!!!.....", fn);
+      nfaStat = NFA_HciSendEvent(mNfaHciHandle, mNewPipeId, EVT_SEND_DATA,
+                                 xmitBufferSize, xmitBuffer, recvBufferMaxSize,
+                                 recvBuffer, timeoutMillisec);
+    }
 #endif
-        if(nfcFL.nfcNxpEse && nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) {
-            isTransceiveOngoing = true;
-        }
-            nfaStat = NFA_HciSendEvent (mNfaHciHandle, mNewPipeId, EVT_SEND_DATA, xmitBufferSize, xmitBuffer, sizeof(mResponseData), mResponseData, timeoutMillisec);
-#if(NXP_EXTNS == TRUE)
-        }
-        else if (mNewPipeId == STATIC_PIPE_UICC)
-        {
-            ALOGV("%s, Starting UICC wired mode!!!!!!.....", fn);
-            nfaStat = NFA_HciSendEvent (mNfaHciHandle, mNewPipeId, EVT_SEND_DATA, xmitBufferSize, xmitBuffer, sizeof(mResponseData), mResponseData, timeoutMillisec);
+    else
+#if (NXP_EXTNS == TRUE)
+    {
+      if (nfcFL.nfcNxpEse) {
+        active_ese_reset_control |= TRANS_WIRED_ONGOING;
+        if (((nfcFL.eseFL._NXP_ESE_VER == JCOP_VER_3_1) ||
+             (nfcFL.eseFL._NXP_ESE_VER == JCOP_VER_3_2)) &&
+            (NFC_GetEseAccess((void*)&timeoutMillisec) != 0)) {
+          LOG(ERROR) << StringPrintf("%s: NFC_ReqWiredAccess timeout", fn);
+          goto TheEnd;
         }
+        isEseAccessSuccess = true;
+      }
 #endif
-        else
-#if(NXP_EXTNS == TRUE)
-        {
-            if(nfcFL.nfcNxpEse) {
-                active_ese_reset_control |= TRANS_WIRED_ONGOING;
-                if (((nfcFL.eseFL._NXP_ESE_VER == JCOP_VER_3_1) || (nfcFL.eseFL._NXP_ESE_VER == JCOP_VER_3_2)) &&
-                        (NFC_GetEseAccess((void *)&timeoutMillisec) != 0))
-                {
-                    ALOGE("%s: NFC_ReqWiredAccess timeout", fn);
-                    goto TheEnd;
-                }
-                isEseAccessSuccess = true;
-            }
-#endif
-            if(nfcFL.nfcNxpEse && nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) {
-                isTransceiveOngoing = true;
-            }
-            nfaStat = NFA_HciSendEvent (mNfaHciHandle, mNewPipeId, NFA_HCI_EVT_POST_DATA, xmitBufferSize, xmitBuffer, sizeof(mResponseData), mResponseData, timeoutMillisec);
-#if(NXP_EXTNS == TRUE)
-        }
+      if (nfcFL.nfcNxpEse &&
+          nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) {
+        isTransceiveOngoing = true;
+      }
+      nfaStat = NFA_HciSendEvent(
+          mNfaHciHandle, mNewPipeId, NFA_HCI_EVT_POST_DATA, xmitBufferSize,
+          xmitBuffer, recvBufferMaxSize, recvBuffer, timeoutMillisec);
+#if (NXP_EXTNS == TRUE)
+    }
 #endif
-        if (nfaStat == NFA_STATUS_OK)
-        {
-            //          waitOk = mTransceiveEvent.wait (timeoutMillisec);
-            mTransceiveEvent.wait ();
-#if(NXP_EXTNS == TRUE)
-            if(nfcFL.nfcNxpEse && (gWtxCount > mWmMaxWtxCount))
-            {
-                tranStatus = TRANSCEIVE_STATUS_MAX_WTX_REACHED;
-                gWtxCount = 0;
-                goto TheEnd;
-            }
+    if (nfaStat == NFA_STATUS_OK) {
+      //          waitOk = mTransceiveEvent.wait (timeoutMillisec);
+      mTransceiveEvent.wait();
+#if (NXP_EXTNS == TRUE)
+      if (nfcFL.nfcNxpEse && (gWtxCount > mWmMaxWtxCount)) {
+        tranStatus = TRANSCEIVE_STATUS_MAX_WTX_REACHED;
+        gWtxCount = 0;
+        goto TheEnd;
+      }
 #endif
-            if(nfcFL.nfcNxpEse && nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) {
-                isTransceiveOngoing = false;
-            }
+      if (nfcFL.nfcNxpEse &&
+          nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) {
+        isTransceiveOngoing = false;
+      }
 
-#if(NXP_EXTNS == TRUE)
-            if(nfcFL.nfcNxpEse) {
-                if(nfcFL.eseFL._JCOP_WA_ENABLE &&
-                        (active_ese_reset_control & TRANS_WIRED_ONGOING))
-                {
-                    active_ese_reset_control ^= TRANS_WIRED_ONGOING;
-
-                    /*If only reset event is pending*/
-                    if((active_ese_reset_control&RESET_BLOCKED))
-                    {
-                        SyncEventGuard guard (mResetOngoingEvent);
-                        mResetOngoingEvent.wait();
-                    }
-                    if(!(active_ese_reset_control&TRANS_CL_ONGOING) &&
-                            (active_ese_reset_control&RESET_BLOCKED))
-                    {
-                        active_ese_reset_control ^= RESET_BLOCKED;
-                    }
-                }
-                if(mTransceiveWaitOk == false)
-                {
-                    ALOGE("%s: transceive timed out", fn);
-                    goto TheEnd;
-                }
-            }
+#if (NXP_EXTNS == TRUE)
+      if (nfcFL.nfcNxpEse) {
+        if (nfcFL.eseFL._JCOP_WA_ENABLE &&
+            (active_ese_reset_control & TRANS_WIRED_ONGOING)) {
+          active_ese_reset_control ^= TRANS_WIRED_ONGOING;
+
+          /*If only reset event is pending*/
+          if ((active_ese_reset_control & RESET_BLOCKED)) {
+            SyncEventGuard guard(mResetOngoingEvent);
+            mResetOngoingEvent.wait();
+          }
+
+          if (!(active_ese_reset_control & TRANS_CL_ONGOING) &&
+              (active_ese_reset_control & RESET_BLOCKED)) {
+            active_ese_reset_control ^= RESET_BLOCKED;
+          }
+        }
+        if (mTransceiveWaitOk == false) {
+          LOG(ERROR) << StringPrintf("%s: transceive timed out", fn);
+          goto TheEnd;
+        }
+      }
 #endif
-        }
-        else
-        {
-            ALOGE("%s: fail send data; error=0x%X", fn, nfaStat);
-            goto TheEnd;
-        }
+    } else {
+      LOG(ERROR) << StringPrintf("%s: fail send data; error=0x%X", fn, nfaStat);
+      goto TheEnd;
     }
-        if (mActualResponseSize > recvBufferMaxSize)
-            recvBufferActualSize = recvBufferMaxSize;
-        else
-            recvBufferActualSize = mActualResponseSize;
-
-        memcpy (recvBuffer, mResponseData, recvBufferActualSize);
-#if(NXP_EXTNS == TRUE)
-    tranStatus = TRANSCEIVE_STATUS_OK;
+  }
+  if (mActualResponseSize > recvBufferMaxSize)
+    recvBufferActualSize = recvBufferMaxSize;
+  else
+    recvBufferActualSize = mActualResponseSize;
+
+#if (NXP_EXTNS == TRUE)
+  tranStatus = TRANSCEIVE_STATUS_OK;
 #else
-     isSuccess = true;
+  isSuccess = true;
 #endif
-        TheEnd:
-#if(NXP_EXTNS == TRUE)
-        if(nfcFL.nfcNxpEse) {
-            if ((((nfcFL.eseFL._NXP_ESE_VER == JCOP_VER_3_1) || (nfcFL.eseFL._NXP_ESE_VER == JCOP_VER_3_2))) && isEseAccessSuccess == true)
-            {
-                if (NFC_RelEseAccess((void *)&nfaStat) != 0)
-                {
-                    ALOGE("%s: NFC_RelEseAccess failed", fn);
-                }
-            }
-            if((nfcFL.eseFL._JCOP_WA_ENABLE) && (active_ese_reset_control&TRANS_WIRED_ONGOING))
-                active_ese_reset_control ^= TRANS_WIRED_ONGOING;
-        }
+TheEnd:
+#if (NXP_EXTNS == TRUE)
+  if (nfcFL.nfcNxpEse) {
+    if ((((nfcFL.eseFL._NXP_ESE_VER == JCOP_VER_3_1) ||
+          (nfcFL.eseFL._NXP_ESE_VER == JCOP_VER_3_2))) &&
+        isEseAccessSuccess == true) {
+      if (NFC_RelEseAccess((void*)&nfaStat) != 0) {
+        LOG(ERROR) << StringPrintf("%s: NFC_RelEseAccess failed", fn);
+      }
+    }
+    if ((nfcFL.eseFL._JCOP_WA_ENABLE) &&
+        (active_ese_reset_control & TRANS_WIRED_ONGOING))
+      active_ese_reset_control ^= TRANS_WIRED_ONGOING;
+  }
 #endif
 
-#if(NXP_EXTNS == TRUE)
-    ALOGV ("%s: exit; tranStatus: %d; recvBufferActualSize: %ld", fn, tranStatus, recvBufferActualSize);
-    return (tranStatus);
+#if (NXP_EXTNS == TRUE)
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit; tranStatus: %d; recvBufferActualSize: %d", fn,
+                      tranStatus, recvBufferActualSize);
+  return (tranStatus);
 #else
-     ALOGV ("%s: exit; isSuccess: %d; recvBufferActualSize: %ld", fn, isSuccess, recvBufferActualSize);
-     return (isSuccess);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit; isSuccess: %d; recvBufferActualSize: %d", fn,
+                      isSuccess, recvBufferActualSize);
+  return (isSuccess);
 #endif
 }
 /*******************************************************************************
@@ -1947,80 +1863,78 @@ bool SecureElement::transceive (uint8_t* xmitBuffer, int32_t xmitBufferSize, uin
  ** Returns:        None .
  **
  *******************************************************************************/
-void SecureElement::setCLState(bool mState)
-{
-    ALOGV("%s: Entry setCLState \n", __func__);
-    /*Check if the state is already dual mode*/
-    bool inDualModeAlready = (dual_mode_current_state == SPI_DWPCL_BOTH_ACTIVE);
-    if(mState)
-    {
-        dual_mode_current_state |= CL_ACTIVE;
-#if(NXP_EXTNS == TRUE)
-        if(nfcFL.nfcNxpEse && nfcFL.eseFL._JCOP_WA_ENABLE) {
-            active_ese_reset_control |= TRANS_CL_ONGOING;
-        }
-#endif
+void SecureElement::setCLState(bool mState) {
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Entry setCLState \n", __func__);
+  /*Check if the state is already dual mode*/
+  bool inDualModeAlready = (dual_mode_current_state == SPI_DWPCL_BOTH_ACTIVE);
+  if (mState) {
+    dual_mode_current_state |= CL_ACTIVE;
+#if (NXP_EXTNS == TRUE)
+    if (nfcFL.nfcNxpEse && nfcFL.eseFL._JCOP_WA_ENABLE) {
+      active_ese_reset_control |= TRANS_CL_ONGOING;
     }
-    else
-    {
-       if(dual_mode_current_state & CL_ACTIVE)
-       {
-           dual_mode_current_state ^= CL_ACTIVE;
-#if(NXP_EXTNS == TRUE)
-           if(nfcFL.nfcNxpEse) {
-               if(nfcFL.eseFL._JCOP_WA_ENABLE && (active_ese_reset_control&TRANS_CL_ONGOING))
-               {
-                   active_ese_reset_control ^= TRANS_CL_ONGOING;
-
-                   /*If there is no pending wired rapdu or CL session*/
-                   if(((active_ese_reset_control&RESET_BLOCKED))&&
-                           (!(active_ese_reset_control &(TRANS_WIRED_ONGOING))))
-                   {
-                       /*unblock pending reset event*/
-                       SyncEventGuard guard (sSecElem.mResetEvent);
-                       sSecElem.mResetEvent.notifyOne();
-                       active_ese_reset_control ^= RESET_BLOCKED;
-                   }
-               }
-           }
 #endif
-           if(inDualModeAlready)
-           {
-               SyncEventGuard guard (mDualModeEvent);
-               mDualModeEvent.notifyOne();
-           }
-       }
-    }
-    ALOGV("%s: Exit setCLState = %d\n", __func__, dual_mode_current_state);
+  } else {
+    if (dual_mode_current_state & CL_ACTIVE) {
+      dual_mode_current_state ^= CL_ACTIVE;
+#if (NXP_EXTNS == TRUE)
+      if (nfcFL.nfcNxpEse) {
+        if (nfcFL.eseFL._JCOP_WA_ENABLE &&
+            (active_ese_reset_control & TRANS_CL_ONGOING)) {
+          active_ese_reset_control ^= TRANS_CL_ONGOING;
+
+          /*If there is no pending wired rapdu or CL session*/
+          if (((active_ese_reset_control & RESET_BLOCKED)) &&
+              (!(active_ese_reset_control & (TRANS_WIRED_ONGOING)))) {
+            /*unblock pending reset event*/
+            SyncEventGuard guard(sSecElem.mResetEvent);
+            sSecElem.mResetEvent.notifyOne();
+            active_ese_reset_control ^= RESET_BLOCKED;
+          }
+        }
+      }
+#endif
+      if (inDualModeAlready) {
+        SyncEventGuard guard(mDualModeEvent);
+        mDualModeEvent.notifyOne();
+      }
+    }
+  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: Exit setCLState = %d\n", __func__, dual_mode_current_state);
 }
 
-void SecureElement::notifyModeSet (tNFA_HANDLE eeHandle, bool success, tNFA_EE_STATUS eeStatus)
-{
-    static const char* fn = "SecureElement::notifyModeSet";
-    if (success)
-    {
-        tNFA_EE_INFO *pEE = sSecElem.findEeByHandle (eeHandle);
-        if (pEE)
-        {
-            pEE->ee_status = eeStatus;
-            ALOGV("%s: NFA_EE_MODE_SET_EVT; pEE->ee_status: %s (0x%04x)", fn, SecureElement::eeStatusToString(pEE->ee_status), pEE->ee_status);
-        }
-        else
-            ALOGE("%s: NFA_EE_MODE_SET_EVT; EE: 0x%04x not found.  mActiveEeHandle: 0x%04x", fn, eeHandle, sSecElem.mActiveEeHandle);
-    }
-    SyncEventGuard guard (sSecElem.mEeSetModeEvent);
-    sSecElem.mEeSetModeEvent.notifyOne();
+void SecureElement::notifyModeSet(tNFA_HANDLE eeHandle, bool success,
+                                  tNFA_EE_STATUS eeStatus) {
+  static const char* fn = "SecureElement::notifyModeSet";
+  if (success) {
+    tNFA_EE_INFO* pEE = sSecElem.findEeByHandle(eeHandle);
+    if (pEE) {
+      pEE->ee_status = eeStatus;
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_EE_MODE_SET_EVT; pEE->ee_status: %s (0x%04x)", fn,
+          SecureElement::eeStatusToString(pEE->ee_status), pEE->ee_status);
+    } else
+      LOG(ERROR) << StringPrintf(
+          "%s: NFA_EE_MODE_SET_EVT; EE: 0x%04x not found.  mActiveEeHandle: "
+          "0x%04x",
+          fn, eeHandle, sSecElem.mActiveEeHandle);
+  }
+  SyncEventGuard guard(sSecElem.mEeSetModeEvent);
+  sSecElem.mEeSetModeEvent.notifyOne();
 }
 
-#if(NXP_EXTNS == TRUE)
-static void NFCC_StandbyModeTimerCallBack (union sigval)
-{
-    if(!nfcFL.nfcNxpEse) {
-        ALOGV("%s tnfcNxpEse not available. Returning", __func__);
-        return;
-    }
-    ALOGV("%s timer timedout , sending standby mode cmd", __func__);
-    SecureElement::getInstance().NfccStandByOperation(STANDBY_TIMER_TIMEOUT);
+#if (NXP_EXTNS == TRUE)
+static void NFCC_StandbyModeTimerCallBack(union sigval) {
+  if (!nfcFL.nfcNxpEse) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s tnfcNxpEse not available. Returning", __func__);
+    return;
+  }
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s timer timedout , sending standby mode cmd", __func__);
+  SecureElement::getInstance().NfccStandByOperation(STANDBY_TIMER_TIMEOUT);
 }
 #endif
 /*******************************************************************************
@@ -2034,60 +1948,58 @@ static void NFCC_StandbyModeTimerCallBack (union sigval)
 ** Returns:         None
 **
 *******************************************************************************/
-void SecureElement::notifyListenModeState (bool isActivated) {
-    static const char fn [] = "SecureElement::notifyListenMode";
+void SecureElement::notifyListenModeState(bool isActivated) {
+  static const char fn[] = "SecureElement::notifyListenMode";
 
-    ALOGV("%s: enter; listen mode active=%u", fn, isActivated);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter; listen mode active=%u", fn, isActivated);
 
-    JNIEnv* e = NULL;
-    if (mNativeData == NULL)
-    {
-        ALOGE("%s: mNativeData is null", fn);
-        return;
-    }
+  JNIEnv* e = NULL;
+  if (mNativeData == NULL) {
+    LOG(ERROR) << StringPrintf("%s: mNativeData is null", fn);
+    return;
+  }
 
-    ScopedAttach attach(mNativeData->vm, &e);
-    if (e == NULL)
-    {
-        ALOGE("%s: jni env is null", fn);
-        return;
-    }
+  ScopedAttach attach(mNativeData->vm, &e);
+  if (e == NULL) {
+    LOG(ERROR) << StringPrintf("%s: jni env is null", fn);
+    return;
+  }
 
-    mActivatedInListenMode = isActivated;
+  mActivatedInListenMode = isActivated;
 #if (NXP_EXTNS == TRUE)
-    if(nfcFL.nfcNxpEse) {
-        if(!isActivated)
-        {
-            setCLState(false);
-            if(nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME != nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
-                setDwpTranseiveState(false, NFCC_DEACTIVATED_NTF);
-            }
-        }
-        else
-        {
-            /* activated in listen mode */
-            if(nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME != nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
-                setDwpTranseiveState(true, NFCC_ACTIVATED_NTF);
-            }
-        }
+  if (nfcFL.nfcNxpEse) {
+    if (!isActivated) {
+      setCLState(false);
+      if (nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME !=
+          nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
+        setDwpTranseiveState(false, NFCC_DEACTIVATED_NTF);
+      }
+    } else {
+      /* activated in listen mode */
+      if (nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME !=
+          nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
+        setDwpTranseiveState(true, NFCC_ACTIVATED_NTF);
+      }
     }
+  }
 #endif
-    if (mNativeData != NULL) {
-        if (isActivated) {
-            e->CallVoidMethod (mNativeData->manager, android::gCachedNfcManagerNotifySeListenActivated);
-        }
-        else {
-            e->CallVoidMethod (mNativeData->manager, android::gCachedNfcManagerNotifySeListenDeactivated);
-        }
+  if (mNativeData != NULL) {
+    if (isActivated) {
+      e->CallVoidMethod(mNativeData->manager,
+                        android::gCachedNfcManagerNotifySeListenActivated);
+    } else {
+      e->CallVoidMethod(mNativeData->manager,
+                        android::gCachedNfcManagerNotifySeListenDeactivated);
     }
+  }
 
-    if (e->ExceptionCheck())
-    {
-        e->ExceptionClear();
-        ALOGE("%s: fail notify", fn);
-    }
+  if (e->ExceptionCheck()) {
+    e->ExceptionClear();
+    LOG(ERROR) << StringPrintf("%s: fail notify", fn);
+  }
 
-    ALOGV("%s: exit", fn);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
 }
 
 /*******************************************************************************
@@ -2100,157 +2012,48 @@ void SecureElement::notifyListenModeState (bool isActivated) {
 ** Returns:         None
 **
 *******************************************************************************/
-void SecureElement::notifyRfFieldEvent (bool isActive)
-{
-    static const char fn [] = "SecureElement::notifyRfFieldEvent";
-    ALOGV("%s: enter; is active=%u", fn, isActive);
-
-    JNIEnv* e = NULL;
-    ScopedAttach attach(mNativeData->vm, &e);
-    if (e == NULL)
-    {
-        ALOGE("%s: jni env is null", fn);
-        return;
+void SecureElement::notifyRfFieldEvent(bool isActive) {
+  static const char fn[] = "SecureElement::notifyRfFieldEvent";
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter; is active=%u", fn, isActive);
+
+  mMutex.lock();
+  int ret = clock_gettime(CLOCK_MONOTONIC, &mLastRfFieldToggle);
+  if (ret == -1) {
+    LOG(ERROR) << StringPrintf("%s: clock_gettime failed", fn);
+    // There is no good choice here...
+  }
+
+  if (isActive) {
+    mRfFieldIsOn = true;
+#if (NXP_EXTNS == TRUE)
+    if (nfcFL.nfcNxpEse) {
+      if (nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION &&
+          (isTransceiveOngoing == false && meseUiccConcurrentAccess == true &&
+           mPassiveListenEnabled == false)) {
+        startThread(0x01);
+      }
+      if (nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME !=
+          nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
+        setDwpTranseiveState(true, NFCC_RF_FIELD_EVT);
+      }
     }
-
-    mMutex.lock();
-    int ret = clock_gettime (CLOCK_MONOTONIC, &mLastRfFieldToggle);
-    if (ret == -1) {
-        ALOGE("%s: clock_gettime failed", fn);
-        // There is no good choice here...
-    }
-
-    if (isActive)
-    {
-        mRfFieldIsOn = true;
-#if (NXP_EXTNS == TRUE)
-        if(nfcFL.nfcNxpEse) {
-            if(nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION &&
-                    (isTransceiveOngoing == false && meseUiccConcurrentAccess == true &&
-                            mPassiveListenEnabled == false))
-            {
-                startThread(0x01);
-            }
-            if(nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME != nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
-                setDwpTranseiveState(true, NFCC_RF_FIELD_EVT);
-            }
-        }
 #endif
-        e->CallVoidMethod (mNativeData->manager, android::gCachedNfcManagerNotifySeFieldActivated);
-    }
-    else
-    {
-        mRfFieldIsOn = false;
-        setCLState(false);
+  } else {
+    mRfFieldIsOn = false;
+    setCLState(false);
 #if (NXP_EXTNS == TRUE)
-        if(nfcFL.nfcNxpEse &&
-                (nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME !=
-                        nfcFL.eseFL._ESE_WIRED_MODE_RESUME)) {
-            setDwpTranseiveState(false, NFCC_RF_FIELD_EVT);
-        }
-#endif
-        e->CallVoidMethod (mNativeData->manager, android::gCachedNfcManagerNotifySeFieldDeactivated);
+    if (nfcFL.nfcNxpEse && (nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME !=
+                            nfcFL.eseFL._ESE_WIRED_MODE_RESUME)) {
+      setDwpTranseiveState(false, NFCC_RF_FIELD_EVT);
     }
-    mMutex.unlock();
+#endif
+  }
+  mMutex.unlock();
 
-    if (e->ExceptionCheck())
-    {
-        e->ExceptionClear();
-        ALOGE("%s: fail notify", fn);
-    }
-    ALOGV("%s: exit", fn);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
 }
 
-#if(NXP_EXTNS == TRUE)
-/*Reader over SWP*/
-void SecureElement::notifyEEReaderEvent (int evt, int data)
-{
-    if(!nfcFL.nfcNxpEse || !nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
-        ALOGV("%s: nfcNxpEse or ETSI_READER not available. Returning", __func__);
-        return;
-    }
-    static const char fn [] = "SecureElement::notifyEEReaderEvent";
-    ALOGV("%s: enter; event=%x", fn, evt);
-
-
-
-    mMutex.lock();
-    int ret = clock_gettime (CLOCK_MONOTONIC, &mLastRfFieldToggle);
-    if (ret == -1) {
-        ALOGE("%s: clock_gettime failed", fn);
-        // There is no good choice here...
-    }
-    switch (evt) {
-        case NFA_RD_SWP_READER_REQUESTED:
-            ALOGV("%s: NFA_RD_SWP_READER_REQUESTED for tech %x", fn, data);
-            {
-                jboolean istypeA = false;
-                jboolean istypeB = false;
-
-                if(data & NFA_TECHNOLOGY_MASK_A)
-                    istypeA = true;
-                if(data & NFA_TECHNOLOGY_MASK_B)
-                    istypeB = true;
-
-                /*
-                 * Start the protection time.This is to give user a specific time window to wait for the TAG,
-                 * and prevents MW from infinite waiting to switch back to normal NFC-Fouram polling mode.
-                 * */
-                unsigned long timeout = 0;
-                GetNxpNumValue(NAME_NXP_SWP_RD_START_TIMEOUT, (void *)&timeout, sizeof(timeout));
-                ALOGV("SWP_RD_START_TIMEOUT : %ld", timeout);
-                if (timeout > 0)
-                    sSwpReaderTimer.set(1000*timeout,startStopSwpReaderProc);
-            }
-            break;
-        case NFA_RD_SWP_READER_START:
-            ALOGV("%s: NFA_RD_SWP_READER_START", fn);
-            {
-                JNIEnv* e = NULL;
-                    ScopedAttach attach(mNativeData->vm, &e);
-                    if (e == NULL)
-                    {
-                        ALOGE("%s: jni env is null", fn);
-                        break;
-                    }
-                    sSwpReaderTimer.kill();
-                /*
-                 * Start the protection time.This is to give user a specific time window to wait for the
-                 * SWP Reader to finish with card, and prevents MW from infinite waiting to switch back to
-                 * normal NFC-Forum polling mode.
-                 *
-                 *  configuring timeout.
-                 * */
-                unsigned long timeout = 0;
-                GetNxpNumValue(NAME_NXP_SWP_RD_TAG_OP_TIMEOUT, (void *)&timeout, sizeof(timeout));
-                ALOGV("SWP_RD_TAG_OP_TIMEOUT : %ld", timeout);
-                if (timeout > 0)
-                    sSwpReaderTimer.set(2000*timeout,startStopSwpReaderProc);
-
-                e->CallVoidMethod (mNativeData->manager, android::gCachedNfcManagerNotifySWPReaderActivated);
-            }
-            break;
-        case NFA_RD_SWP_READER_STOP:
-            ALOGV("%s: NFA_RD_SWP_READER_STOP", fn);
-            break;
-
-            //TODO: Check this later. Need to update libnfc-nci for this symbol.
-//        case NFA_RD_SWP_READER_START_FAIL:
-//            ALOGV("%s: NFA_RD_SWP_READER_STOP", fn);
-//            //sStopSwpReaderTimer.kill();
-//            e->CallVoidMethod (mNativeData->manager, android::gCachedNfcManagerNotifySWPReaderRequestedFail);
-//            break;
-
-        default:
-            ALOGV("%s: UNKNOWN EVENT ??", fn);
-            break;
-    }
-
-    mMutex.unlock();
-
-    ALOGV("%s: exit", fn);
-}
-#endif
 /*******************************************************************************
 **
 ** Function:        resetRfFieldStatus
@@ -2261,53 +2064,51 @@ void SecureElement::notifyEEReaderEvent (int evt, int data)
 ** Returns:         None
 **
 *******************************************************************************/
-void SecureElement::resetRfFieldStatus ()
-{
-    static const char fn [] = "SecureElement::resetRfFieldStatus`";
-    ALOGV("%s: enter;", fn);
-
-    mMutex.lock();
-    mRfFieldIsOn = false;
-    int ret = clock_gettime (CLOCK_MONOTONIC, &mLastRfFieldToggle);
-    if (ret == -1) {
-        ALOGE("%s: clock_gettime failed", fn);
-        // There is no good choice here...
-    }
-    mMutex.unlock();
-
-    ALOGV("%s: exit", fn);
+void SecureElement::resetRfFieldStatus() {
+  static const char fn[] = "SecureElement::resetRfFieldStatus`";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter;", fn);
+
+  mMutex.lock();
+  mRfFieldIsOn = false;
+  int ret = clock_gettime(CLOCK_MONOTONIC, &mLastRfFieldToggle);
+  if (ret == -1) {
+    LOG(ERROR) << StringPrintf("%s: clock_gettime failed", fn);
+    // There is no good choice here...
+  }
+  mMutex.unlock();
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", fn);
 }
 
-
 /*******************************************************************************
 **
 ** Function:        storeUiccInfo
 **
-** Description:     Store a copy of the execution environment information from the stack.
+** Description:     Store a copy of the execution environment information from
+*the stack.
 **                  info: execution environment information.
 **
 ** Returns:         None
 **
 *******************************************************************************/
-void SecureElement::storeUiccInfo (tNFA_EE_DISCOVER_REQ& info)
-{
-    static const char fn [] = "SecureElement::storeUiccInfo";
-    ALOGV("%s:  Status: %u   Num EE: %u", fn, info.status, info.num_ee);
-
-    SyncEventGuard guard (mUiccInfoEvent);
-    memcpy (&mUiccInfo, &info, sizeof(mUiccInfo));
-    for (uint8_t xx = 0; xx < info.num_ee; xx++)
-    {
-        //for each technology (A, B, F, B'), print the bit field that shows
-        //what protocol(s) is support by that technology
-        ALOGV("%s   EE[%u] Handle: 0x%04x  techA: 0x%02x  techB: 0x%02x  techF: 0x%02x  techBprime: 0x%02x",
-                fn, xx, info.ee_disc_info[xx].ee_handle,
-                info.ee_disc_info[xx].la_protocol,
-                info.ee_disc_info[xx].lb_protocol,
-                info.ee_disc_info[xx].lf_protocol,
-                info.ee_disc_info[xx].lbp_protocol);
-    }
-    mUiccInfoEvent.notifyOne ();
+void SecureElement::storeUiccInfo(tNFA_EE_DISCOVER_REQ& info) {
+  static const char fn[] = "SecureElement::storeUiccInfo";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s:  Status: %u   Num EE: %u", fn, info.status, info.num_ee);
+
+  SyncEventGuard guard(mUiccInfoEvent);
+  memcpy(&mUiccInfo, &info, sizeof(mUiccInfo));
+  for (uint8_t xx = 0; xx < info.num_ee; xx++) {
+    // for each technology (A, B, F, B'), print the bit field that shows
+    // what protocol(s) is support by that technology
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s   EE[%u] Handle: 0x%04x  techA: 0x%02x  techB: 0x%02x  techF: "
+        "0x%02x  techBprime: 0x%02x",
+        fn, xx, info.ee_disc_info[xx].ee_handle,
+        info.ee_disc_info[xx].la_protocol, info.ee_disc_info[xx].lb_protocol,
+        info.ee_disc_info[xx].lf_protocol, info.ee_disc_info[xx].lbp_protocol);
+  }
+  mUiccInfoEvent.notifyOne();
 }
 
 /*******************************************************************************
@@ -2322,54 +2123,54 @@ void SecureElement::storeUiccInfo (tNFA_EE_DISCOVER_REQ& info)
 ** Returns          ture on success, false on failure
 **
 *******************************************************************************/
-bool SecureElement::getSeVerInfo(int seIndex, char * verInfo, int verInfoSz, uint8_t * seid)
-{
-    ALOGV("%s: enter, seIndex=%d", __func__, seIndex);
-
-    if (seIndex > (mActualNumEe-1))
-    {
-        ALOGE("%s: invalid se index: %d, only %d SEs in system", __func__, seIndex, mActualNumEe);
-        return false;
-    }
+bool SecureElement::getSeVerInfo(int seIndex, char* verInfo, int verInfoSz,
+                                 uint8_t* seid) {
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter, seIndex=%d", __func__, seIndex);
+
+  if (seIndex > (mActualNumEe - 1)) {
+    LOG(ERROR) << StringPrintf(
+        "%s: invalid se index: %d, only %d SEs in system", __func__, seIndex,
+        mActualNumEe);
+    return false;
+  }
 
-    *seid = mEeInfo[seIndex].ee_handle;
+  *seid = mEeInfo[seIndex].ee_handle;
 
-    if ((mEeInfo[seIndex].num_interface == 0) || (mEeInfo[seIndex].ee_interface[0] == NCI_NFCEE_INTERFACE_HCI_ACCESS) )
-    {
-        return false;
-    }
+  if ((mEeInfo[seIndex].num_interface == 0) ||
+      (mEeInfo[seIndex].ee_interface[0] == NCI_NFCEE_INTERFACE_HCI_ACCESS)) {
+    return false;
+  }
 
     strlcpy(verInfo, "Version info not available", verInfoSz-2);
 
-    uint8_t pipe = (mEeInfo[seIndex].ee_handle == EE_HANDLE_0xF3) ? 0x70 : 0x71;
-    uint8_t host = (pipe == mStaticPipeProp) ? 0x02 : 0x03;
-    uint8_t gate = (pipe == mStaticPipeProp) ? 0xF0 : 0xF1;
-
-    tNFA_STATUS nfaStat = NFA_HciAddStaticPipe(mNfaHciHandle, host, gate, pipe);
-    if (nfaStat != NFA_STATUS_OK)
-    {
-        ALOGE("%s: NFA_HciAddStaticPipe() failed, pipe = 0x%x, error=0x%X", __func__, pipe, nfaStat);
-        return true;
-    }
+  uint8_t pipe = (mEeInfo[seIndex].ee_handle == EE_HANDLE_0xF3) ? 0x70 : 0x71;
+  uint8_t host = (pipe == mStaticPipeProp) ? 0x02 : 0x03;
+  uint8_t gate = (pipe == mStaticPipeProp) ? 0xF0 : 0xF1;
 
-    SyncEventGuard guard (mVerInfoEvent);
-    if (NFA_STATUS_OK == (nfaStat = NFA_HciGetRegistry (mNfaHciHandle, pipe, 0x02)))
-    {
-        if (false == mVerInfoEvent.wait(200))
-        {
-            ALOGE("%s: wait response timeout", __func__);
-        }
-        else
-        {
-            snprintf(verInfo, verInfoSz-1, "Oberthur OS S/N: 0x%02x%02x%02x", mVerInfo[0], mVerInfo[1], mVerInfo[2]);
-            verInfo[verInfoSz-1] = '\0';
-        }
-    }
-    else
-    {
-        ALOGE("%s: NFA_HciGetRegistry () failed: 0x%X", __func__, nfaStat);
-    }
+  tNFA_STATUS nfaStat = NFA_HciAddStaticPipe(mNfaHciHandle, host, gate, pipe);
+  if (nfaStat != NFA_STATUS_OK) {
+    LOG(ERROR) << StringPrintf(
+        "%s: NFA_HciAddStaticPipe() failed, pipe = 0x%x, error=0x%X", __func__,
+        pipe, nfaStat);
     return true;
+  }
+
+  SyncEventGuard guard(mVerInfoEvent);
+  if (NFA_STATUS_OK ==
+      (nfaStat = NFA_HciGetRegistry(mNfaHciHandle, pipe, 0x02))) {
+    if (false == mVerInfoEvent.wait(200)) {
+      LOG(ERROR) << StringPrintf("%s: wait response timeout", __func__);
+    } else {
+      snprintf(verInfo, verInfoSz - 1, "Oberthur OS S/N: 0x%02x%02x%02x",
+               mVerInfo[0], mVerInfo[1], mVerInfo[2]);
+      verInfo[verInfoSz - 1] = '\0';
+    }
+  } else {
+    LOG(ERROR) << StringPrintf("%s: NFA_HciGetRegistry () failed: 0x%X",
+                               __func__, nfaStat);
+  }
+  return true;
 }
 
 /*******************************************************************************
@@ -2381,42 +2182,48 @@ bool SecureElement::getSeVerInfo(int seIndex, char * verInfo, int verInfoSz, uin
 ** Returns          Number of secure elements we know about.
 **
 *******************************************************************************/
-uint8_t SecureElement::getActualNumEe()
-{
-    if(NFA_GetNCIVersion() == NCI_VERSION_2_0)
-        return mActualNumEe + 1;
-    else
-        return mActualNumEe;
+uint8_t SecureElement::getActualNumEe() {
+  if (NFA_GetNCIVersion() == NCI_VERSION_2_0)
+    return mActualNumEe + 1;
+  else
+    return mActualNumEe;
 }
 
 /*******************************************************************************
 **
 ** Function:        handleClearAllPipe
 **
-** Description:     To handle clear all pipe event received from HCI based on the
+** Description:     To handle clear all pipe event received from HCI based on
+*the
 **                  deleted host
 **                  eventData: Event data.
 **
 ** Returns:         None
 **
 *******************************************************************************/
-void SecureElement::handleClearAllPipe (tNFA_HCI_EVT_DATA* eventData)
-{
-    static const char fn [] = "SecureElement::handleClearAllPipe";
-    ALOGV("%s: Deleted host=0x%X", fn, eventData->deleted.host);
-    if(eventData->deleted.host == (SecureElement::getInstance().EE_HANDLE_0xF4 & ~NFA_HANDLE_GROUP_EE))
-     { /* To stop mode-set being called when a clear all pipe is being issued */
-        ALOGV("%s: NFA_HCI_DELETE_PIPE_EVT for UICC1 start", fn);
-        sSecElem.eSE_ClearAllPipe_handler(SecureElement::getInstance().EE_HANDLE_0xF4 & ~NFA_HANDLE_GROUP_EE);
-        ALOGV("%s: NFA_HCI_DELETE_PIPE_EVT for UICC1 poll end", fn);
-     }
-     else if(eventData->deleted.host == (EE_HANDLE_0xF8 & ~NFA_HANDLE_GROUP_EE))
-     {
-        /* To stop mode-set being called when a clear all pipe is being issued */
-        ALOGV("%s: NFA_HCI_DELETE_PIPE_EVT for UICC2 start", fn);
-        sSecElem.eSE_ClearAllPipe_handler(EE_HANDLE_0xF8 & ~NFA_HANDLE_GROUP_EE);
-        ALOGV("%s: NFA_HCI_DELETE_PIPE_EVT for UICC2 poll end", fn);
-     }
+void SecureElement::handleClearAllPipe(tNFA_HCI_EVT_DATA* eventData) {
+  static const char fn[] = "SecureElement::handleClearAllPipe";
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Deleted host=0x%X", fn, eventData->deleted.host);
+  if (eventData->deleted.host ==
+      (SecureElement::getInstance().EE_HANDLE_0xF4 &
+       ~NFA_HANDLE_GROUP_EE)) { /* To stop mode-set being called when a clear
+                                   all pipe is being issued */
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: NFA_HCI_DELETE_PIPE_EVT for UICC1 start", fn);
+    sSecElem.eSE_ClearAllPipe_handler(
+        SecureElement::getInstance().EE_HANDLE_0xF4 & ~NFA_HANDLE_GROUP_EE);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: NFA_HCI_DELETE_PIPE_EVT for UICC1 poll end", fn);
+  } else if (eventData->deleted.host ==
+             (EE_HANDLE_0xF8 & ~NFA_HANDLE_GROUP_EE)) {
+    /* To stop mode-set being called when a clear all pipe is being issued */
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: NFA_HCI_DELETE_PIPE_EVT for UICC2 start", fn);
+    sSecElem.eSE_ClearAllPipe_handler(EE_HANDLE_0xF8 & ~NFA_HANDLE_GROUP_EE);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: NFA_HCI_DELETE_PIPE_EVT for UICC2 poll end", fn);
+  }
 }
 
 /*******************************************************************************
@@ -2430,339 +2237,396 @@ void SecureElement::handleClearAllPipe (tNFA_HCI_EVT_DATA* eventData)
 ** Returns:         None
 **
 *******************************************************************************/
-void SecureElement::nfaHciCallback (tNFA_HCI_EVT event, tNFA_HCI_EVT_DATA* eventData)
-{
-    static const char fn [] = "SecureElement::nfaHciCallback";
-    ALOGV("%s: event=0x%X", fn, event);
-    int evtSrc = 0xFF;
-
-    switch (event)
-    {
-    case NFA_HCI_REGISTER_EVT:
-        {
-            ALOGV("%s: NFA_HCI_REGISTER_EVT; status=0x%X; handle=0x%X", fn,
-                    eventData->hci_register.status, eventData->hci_register.hci_handle);
-            SyncEventGuard guard (sSecElem.mHciRegisterEvent);
-            sSecElem.mNfaHciHandle = eventData->hci_register.hci_handle;
-            sSecElem.mHciRegisterEvent.notifyOne();
-        }
-        break;
-
-    case NFA_HCI_ALLOCATE_GATE_EVT:
-        {
-            ALOGV("%s: NFA_HCI_ALLOCATE_GATE_EVT; status=0x%X; gate=0x%X", fn, eventData->status, eventData->allocated.gate);
-            SyncEventGuard guard (sSecElem.mAllocateGateEvent);
-            sSecElem.mCommandStatus = eventData->status;
-            sSecElem.mNewSourceGate = (eventData->allocated.status == NFA_STATUS_OK) ? eventData->allocated.gate : 0;
-            sSecElem.mAllocateGateEvent.notifyOne();
-        }
-        break;
-
-    case NFA_HCI_DEALLOCATE_GATE_EVT:
-        {
-            tNFA_HCI_DEALLOCATE_GATE& deallocated = eventData->deallocated;
-            ALOGV("%s: NFA_HCI_DEALLOCATE_GATE_EVT; status=0x%X; gate=0x%X", fn, deallocated.status, deallocated.gate);
-            SyncEventGuard guard (sSecElem.mDeallocateGateEvent);
-            sSecElem.mDeallocateGateEvent.notifyOne();
-        }
-        break;
-
-    case NFA_HCI_GET_GATE_PIPE_LIST_EVT:
-        {
-            ALOGV("%s: NFA_HCI_GET_GATE_PIPE_LIST_EVT; status=0x%X; num_pipes: %u  num_gates: %u", fn,
-                    eventData->gates_pipes.status, eventData->gates_pipes.num_pipes, eventData->gates_pipes.num_gates);
-            SyncEventGuard guard (sSecElem.mPipeListEvent);
-            sSecElem.mCommandStatus = eventData->gates_pipes.status;
-            sSecElem.mHciCfg = eventData->gates_pipes;
-            sSecElem.mPipeListEvent.notifyOne();
-        }
-        break;
-
-    case NFA_HCI_CREATE_PIPE_EVT:
-        {
-            ALOGV("%s: NFA_HCI_CREATE_PIPE_EVT; status=0x%X; pipe=0x%X; src gate=0x%X; dest host=0x%X; dest gate=0x%X", fn,
-                    eventData->created.status, eventData->created.pipe, eventData->created.source_gate, eventData->created.dest_host, eventData->created.dest_gate);
-            SyncEventGuard guard (sSecElem.mCreatePipeEvent);
-            sSecElem.mCommandStatus = eventData->created.status;
-            if(eventData->created.dest_gate == 0xF0)
-            {
-                ALOGE("Pipe=0x%x is created and updated for se transcieve", eventData->created.pipe);
-                sSecElem.mNewPipeId = eventData->created.pipe;
-            }
+void SecureElement::nfaHciCallback(tNFA_HCI_EVT event,
+                                   tNFA_HCI_EVT_DATA* eventData) {
+  static const char fn[] = "SecureElement::nfaHciCallback";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: event=0x%X", fn, event);
+
+  switch (event) {
+    case NFA_HCI_REGISTER_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_HCI_REGISTER_EVT; status=0x%X; handle=0x%X", fn,
+          eventData->hci_register.status, eventData->hci_register.hci_handle);
+      SyncEventGuard guard(sSecElem.mHciRegisterEvent);
+      sSecElem.mNfaHciHandle = eventData->hci_register.hci_handle;
+      sSecElem.mHciRegisterEvent.notifyOne();
+    } break;
+
+    case NFA_HCI_ALLOCATE_GATE_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_HCI_ALLOCATE_GATE_EVT; status=0x%X; gate=0x%X", fn,
+          eventData->status, eventData->allocated.gate);
+      SyncEventGuard guard(sSecElem.mAllocateGateEvent);
+      sSecElem.mCommandStatus = eventData->status;
+      sSecElem.mNewSourceGate = (eventData->allocated.status == NFA_STATUS_OK)
+                                    ? eventData->allocated.gate
+                                    : 0;
+      sSecElem.mAllocateGateEvent.notifyOne();
+    } break;
+
+    case NFA_HCI_DEALLOCATE_GATE_EVT: {
+      tNFA_HCI_DEALLOCATE_GATE& deallocated = eventData->deallocated;
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_HCI_DEALLOCATE_GATE_EVT; status=0x%X; gate=0x%X", fn,
+          deallocated.status, deallocated.gate);
+      SyncEventGuard guard(sSecElem.mDeallocateGateEvent);
+      sSecElem.mDeallocateGateEvent.notifyOne();
+    } break;
+
+    case NFA_HCI_GET_GATE_PIPE_LIST_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_HCI_GET_GATE_PIPE_LIST_EVT; status=0x%X; num_pipes: %u  "
+          "num_gates: %u",
+          fn, eventData->gates_pipes.status, eventData->gates_pipes.num_pipes,
+          eventData->gates_pipes.num_gates);
+      SyncEventGuard guard(sSecElem.mPipeListEvent);
+      sSecElem.mCommandStatus = eventData->gates_pipes.status;
+      sSecElem.mHciCfg = eventData->gates_pipes;
+      sSecElem.mPipeListEvent.notifyOne();
+    } break;
+
+    case NFA_HCI_CREATE_PIPE_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_HCI_CREATE_PIPE_EVT; status=0x%X; pipe=0x%X; src gate=0x%X; "
+          "dest host=0x%X; dest gate=0x%X",
+          fn, eventData->created.status, eventData->created.pipe,
+          eventData->created.source_gate, eventData->created.dest_host,
+          eventData->created.dest_gate);
+      SyncEventGuard guard(sSecElem.mCreatePipeEvent);
+      sSecElem.mCommandStatus = eventData->created.status;
+      if (eventData->created.dest_gate == 0xF0) {
+        LOG(ERROR) << StringPrintf(
+            "Pipe=0x%x is created and updated for se transcieve",
+            eventData->created.pipe);
+        sSecElem.mNewPipeId = eventData->created.pipe;
+      }
 #if (NXP_EXTNS == TRUE)
-            sSecElem.mCreatedPipe = eventData->created.pipe;
-            ALOGV("%s: NFA_HCI_CREATE_PIPE_EVT; pipe=0x%X", fn, eventData->created.pipe);
+      sSecElem.mCreatedPipe = eventData->created.pipe;
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: NFA_HCI_CREATE_PIPE_EVT; pipe=0x%X", fn,
+                          eventData->created.pipe);
 #endif
-            sSecElem.mCreatePipeEvent.notifyOne();
-        }
-        break;
+      sSecElem.mCreatePipeEvent.notifyOne();
+    } break;
 #if (NXP_EXTNS == TRUE)
-    case NFA_HCI_DELETE_PIPE_EVT:
-        {
-             ALOGV("%s: NFA_HCI_DELETE_PIPE_EVT; status=0x%X; host=0x%X", fn, eventData->deleted.status, eventData->deleted.host);
-              sSecElem.handleClearAllPipe(eventData);
-        }
-        break;
+    case NFA_HCI_DELETE_PIPE_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_HCI_DELETE_PIPE_EVT; status=0x%X; host=0x%X", fn,
+          eventData->deleted.status, eventData->deleted.host);
+      sSecElem.handleClearAllPipe(eventData);
+    } break;
 #endif
-    case NFA_HCI_OPEN_PIPE_EVT:
-        {
-            ALOGV("%s: NFA_HCI_OPEN_PIPE_EVT; status=0x%X; pipe=0x%X", fn, eventData->opened.status, eventData->opened.pipe);
-            SyncEventGuard guard (sSecElem.mPipeOpenedEvent);
-            sSecElem.mCommandStatus = eventData->opened.status;
-            sSecElem.mPipeOpenedEvent.notifyOne();
-        }
-        break;
+    case NFA_HCI_OPEN_PIPE_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: NFA_HCI_OPEN_PIPE_EVT; status=0x%X; pipe=0x%X",
+                          fn, eventData->opened.status, eventData->opened.pipe);
+      SyncEventGuard guard(sSecElem.mPipeOpenedEvent);
+      sSecElem.mCommandStatus = eventData->opened.status;
+      sSecElem.mPipeOpenedEvent.notifyOne();
+    } break;
 
     case NFA_HCI_EVENT_SENT_EVT:
-        ALOGV("%s: NFA_HCI_EVENT_SENT_EVT; status=0x%X", fn, eventData->evt_sent.status);
-        break;
-
-    case NFA_HCI_RSP_RCVD_EVT: //response received from secure element
-        {
-            tNFA_HCI_RSP_RCVD& rsp_rcvd = eventData->rsp_rcvd;
-            ALOGV("%s: NFA_HCI_RSP_RCVD_EVT; status: 0x%X; code: 0x%X; pipe: 0x%X; len: %u", fn,
-                    rsp_rcvd.status, rsp_rcvd.rsp_code, rsp_rcvd.pipe, rsp_rcvd.rsp_len);
-        }
-        break;
-
-    case NFA_HCI_GET_REG_RSP_EVT :
-        ALOGV("%s: NFA_HCI_GET_REG_RSP_EVT; status: 0x%X; pipe: 0x%X, len: %d", fn,
-                eventData->registry.status, eventData->registry.pipe, eventData->registry.data_len);
-        if(sSecElem.mGetAtrRspwait == true)
-        {
-            /*GetAtr response*/
-            sSecElem.mGetAtrRspwait = false;
-            SyncEventGuard guard (sSecElem.mGetRegisterEvent);
-            memcpy(sSecElem.mAtrInfo, eventData->registry.reg_data, eventData->registry.data_len);
-            sSecElem.mAtrInfolen = eventData->registry.data_len;
-            sSecElem.mAtrStatus = eventData->registry.status;
-            sSecElem.mGetRegisterEvent.notifyOne();
-        }
-        else if (eventData->registry.data_len >= 19 && ((eventData->registry.pipe == mStaticPipeProp) || (eventData->registry.pipe == STATIC_PIPE_0x71)))
-        {
-            SyncEventGuard guard (sSecElem.mVerInfoEvent);
-            // Oberthur OS version is in bytes 16,17, and 18
-            sSecElem.mVerInfo[0] = eventData->registry.reg_data[16];
-            sSecElem.mVerInfo[1] = eventData->registry.reg_data[17];
-            sSecElem.mVerInfo[2] = eventData->registry.reg_data[18];
-            sSecElem.mVerInfoEvent.notifyOne ();
-        }
-        break;
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: NFA_HCI_EVENT_SENT_EVT; status=0x%X", fn,
+                          eventData->evt_sent.status);
+      break;
+
+    case NFA_HCI_RSP_RCVD_EVT:  // response received from secure element
+    {
+      tNFA_HCI_RSP_RCVD& rsp_rcvd = eventData->rsp_rcvd;
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_HCI_RSP_RCVD_EVT; status: 0x%X; code: 0x%X; pipe: 0x%X; "
+          "len: %u",
+          fn, rsp_rcvd.status, rsp_rcvd.rsp_code, rsp_rcvd.pipe,
+          rsp_rcvd.rsp_len);
+      if ((rsp_rcvd.rsp_code == NFA_HCI_ANY_E_PIPE_NOT_OPENED) &&
+          (sSecElem.IsCmdsentOnOpenDwpSession)) {
+        SyncEventGuard guard(sSecElem.mPipeStatusCheckEvent);
+        sSecElem.mCommandStatus = eventData->closed.status;
+        sSecElem.pipeStatus = NFA_HCI_ANY_E_PIPE_NOT_OPENED;
+        sSecElem.mPipeStatusCheckEvent.notifyOne();
+        sSecElem.IsCmdsentOnOpenDwpSession = false;
+      }
+    } break;
+
+    case NFA_HCI_GET_REG_RSP_EVT:
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_HCI_GET_REG_RSP_EVT; status: 0x%X; pipe: 0x%X, len: %d", fn,
+          eventData->registry.status, eventData->registry.pipe,
+          eventData->registry.data_len);
+      if (sSecElem.mGetAtrRspwait == true) {
+        /*GetAtr response*/
+        sSecElem.mGetAtrRspwait = false;
+        SyncEventGuard guard(sSecElem.mGetRegisterEvent);
+        memcpy(sSecElem.mAtrInfo, eventData->registry.reg_data,
+               eventData->registry.data_len);
+        sSecElem.mAtrInfolen = eventData->registry.data_len;
+        sSecElem.mAtrStatus = eventData->registry.status;
+        sSecElem.mGetRegisterEvent.notifyOne();
+      } else if (eventData->registry.data_len >= 19 &&
+                 ((eventData->registry.pipe == mStaticPipeProp) ||
+                  (eventData->registry.pipe == STATIC_PIPE_0x71))) {
+        SyncEventGuard guard(sSecElem.mVerInfoEvent);
+        // Oberthur OS version is in bytes 16,17, and 18
+        sSecElem.mVerInfo[0] = eventData->registry.reg_data[16];
+        sSecElem.mVerInfo[1] = eventData->registry.reg_data[17];
+        sSecElem.mVerInfo[2] = eventData->registry.reg_data[18];
+        sSecElem.mVerInfoEvent.notifyOne();
+      }
+      break;
 
     case NFA_HCI_EVENT_RCVD_EVT:
-        ALOGV("%s: NFA_HCI_EVENT_RCVD_EVT; code: 0x%X; pipe: 0x%X; data len: %u", fn,
-                eventData->rcvd_evt.evt_code, eventData->rcvd_evt.pipe, eventData->rcvd_evt.evt_len);
-        if(eventData->rcvd_evt.pipe == 0x0A) //UICC
-        {
-            ALOGV("%s: NFA_HCI_EVENT_RCVD_EVT; source UICC",fn);
-            evtSrc = SecureElement::getInstance().getGenericEseId(SecureElement::getInstance().EE_HANDLE_0xF4 & ~NFA_HANDLE_GROUP_EE); //UICC
-        }
-        else if(eventData->rcvd_evt.pipe == 0x16) //ESE
-        {
-            ALOGV("%s: NFA_HCI_EVENT_RCVD_EVT; source ESE",fn);
-            evtSrc = SecureElement::getInstance().getGenericEseId(EE_HANDLE_0xF3 & ~NFA_HANDLE_GROUP_EE); //ESE
-        }
-        else if(nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH && (eventData->rcvd_evt.pipe == 0x23)) /*UICC2*/
-        {
-            ALOGV("%s: NFA_HCI_EVENT_RCVD_EVT; source UICC2",fn);
-            evtSrc = SecureElement::getInstance().getGenericEseId(EE_HANDLE_0xF8 & ~NFA_HANDLE_GROUP_EE); /*UICC2*/
-        }
-        ALOGV("%s: NFA_HCI_EVENT_RCVD_EVT; ################################### ", fn);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_HCI_EVENT_RCVD_EVT; code: 0x%X; pipe: 0x%X; data len: %u",
+          fn, eventData->rcvd_evt.evt_code, eventData->rcvd_evt.pipe,
+          eventData->rcvd_evt.evt_len);
 
-        if(eventData->rcvd_evt.evt_code == NFA_HCI_EVT_WTX)
-        {
-#if(NXP_EXTNS == TRUE)
-            gWtxCount++;
-            if(sSecElem.mWmMaxWtxCount >= gWtxCount)
-            {
-                ALOGV ("%s: NFA_HCI_EVENT_RCVD_EVT: NFA_HCI_EVT_WTX gWtxCount:%d", fn, gWtxCount);
-            }
-            else
-            {
-                ALOGV ("%s: NFA_HCI_EVENT_RCVD_EVT: NFA_HCI_EVT_WTX gWtxCount:%d", fn, gWtxCount);
-                sSecElem.mTransceiveEvent.notifyOne ();
-                break;
-            }
-#endif
+      if (eventData->rcvd_evt.evt_code == NFA_HCI_EVT_WTX) {
+#if (NXP_EXTNS == TRUE)
+        gWtxCount++;
+        if (sSecElem.mWmMaxWtxCount >= gWtxCount) {
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "%s: NFA_HCI_EVENT_RCVD_EVT: NFA_HCI_EVT_WTX gWtxCount:%d", fn,
+              gWtxCount);
+        } else {
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "%s: NFA_HCI_EVENT_RCVD_EVT: NFA_HCI_EVT_WTX gWtxCount:%d", fn,
+              gWtxCount);
+          sSecElem.mTransceiveEvent.notifyOne();
+          break;
         }
-#if(NXP_EXTNS == TRUE)
-        else if (((eventData->rcvd_evt.evt_code == NFA_HCI_ABORT) || (eventData->rcvd_evt.last_SentEvtType == EVT_ABORT))
-                &&(eventData->rcvd_evt.pipe == mStaticPipeProp))
-        {
-            ALOGV("%s: NFA_HCI_EVENT_RCVD_EVT: NFA_HCI_ABORT; status:0x%X, pipe:0x%X, len:%d", fn,\
-                eventData->rcvd_evt.status, eventData->rcvd_evt.pipe, eventData->rcvd_evt.evt_len);
-            if(eventData->rcvd_evt.evt_len > 0)
-            {
-                sSecElem.mAbortEventWaitOk = true;
-                SyncEventGuard guard(sSecElem.mAbortEvent);
-                memcpy(sSecElem.mAtrInfo, eventData->rcvd_evt.p_evt_buf, eventData->rcvd_evt.evt_len);
-                sSecElem.mAtrInfolen = eventData->rcvd_evt.evt_len;
-                sSecElem.mAtrStatus = eventData->rcvd_evt.status;
-                sSecElem.mAbortEvent.notifyOne();
-            }
-            else
-            {
-                sSecElem.mAbortEventWaitOk = false;
-                SyncEventGuard guard(sSecElem.mAbortEvent);
-                sSecElem.mAbortEvent.notifyOne();
-            }
+#endif
+      }
+#if (NXP_EXTNS == TRUE)
+      else if (sSecElem.IsCmdsentOnOpenDwpSession) {
+        SyncEventGuard guard(sSecElem.mPipeStatusCheckEvent);
+        sSecElem.mCommandStatus = eventData->closed.status;
+        sSecElem.mPipeStatusCheckEvent.notifyOne();
+        sSecElem.IsCmdsentOnOpenDwpSession = false;
+
+      } else if (((eventData->rcvd_evt.evt_code == NFA_HCI_ABORT) ||
+                  (eventData->rcvd_evt.last_SentEvtType == EVT_ABORT)) &&
+                 (eventData->rcvd_evt.pipe == mStaticPipeProp)) {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: NFA_HCI_EVENT_RCVD_EVT: NFA_HCI_ABORT; status:0x%X, "
+            "pipe:0x%X, len:%d",
+            fn, eventData->rcvd_evt.status, eventData->rcvd_evt.pipe,
+            eventData->rcvd_evt.evt_len);
+        if (eventData->rcvd_evt.evt_len > 0) {
+          sSecElem.mAbortEventWaitOk = true;
+          SyncEventGuard guard(sSecElem.mAbortEvent);
+          memcpy(sSecElem.mAtrInfo, eventData->rcvd_evt.p_evt_buf,
+                 eventData->rcvd_evt.evt_len);
+          sSecElem.mAtrInfolen = eventData->rcvd_evt.evt_len;
+          sSecElem.mAtrStatus = eventData->rcvd_evt.status;
+          sSecElem.mAbortEvent.notifyOne();
+        } else {
+          sSecElem.mAbortEventWaitOk = false;
+          SyncEventGuard guard(sSecElem.mAbortEvent);
+          sSecElem.mAbortEvent.notifyOne();
         }
+      }
 #endif
-        else if ((eventData->rcvd_evt.pipe == mStaticPipeProp) || (eventData->rcvd_evt.pipe == STATIC_PIPE_0x71))
-        {
-            ALOGV("%s: NFA_HCI_EVENT_RCVD_EVT; data from static pipe", fn);
+      else if ((eventData->rcvd_evt.pipe == mStaticPipeProp) ||
+               (eventData->rcvd_evt.pipe == STATIC_PIPE_0x71)) {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: NFA_HCI_EVENT_RCVD_EVT; data from static pipe", fn);
 #if (NXP_EXTNS == TRUE)
-            if(nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE &&
-                    ((spiDwpSyncState & STATE_WK_WAIT_RSP) && (eventData->rcvd_evt.evt_len == 2)))
-            {
-                spiDwpSyncState ^= STATE_WK_WAIT_RSP;
-                SyncEventGuard guard (sSPIForceEnableDWPEvent);
-                sSPIForceEnableDWPEvent.notifyOne();
-                break;
-            }
+        if (nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE &&
+            ((spiDwpSyncState & STATE_WK_WAIT_RSP) &&
+             (eventData->rcvd_evt.evt_len == 2))) {
+          spiDwpSyncState ^= STATE_WK_WAIT_RSP;
+          SyncEventGuard guard(sSPIForceEnableDWPEvent);
+          sSPIForceEnableDWPEvent.notifyOne();
+          break;
+        }
 #endif
-            SyncEventGuard guard (sSecElem.mTransceiveEvent);
-            sSecElem.mActualResponseSize = (eventData->rcvd_evt.evt_len > MAX_RESPONSE_SIZE) ? MAX_RESPONSE_SIZE : eventData->rcvd_evt.evt_len;
-#if(NXP_EXTNS == TRUE)
-            if(nfcFL.nfcNxpEse) {
-                if(eventData->rcvd_evt.evt_len > 0)
-                {
-                    sSecElem.mTransceiveWaitOk = true;
-                    sSecElem.NfccStandByOperation(STANDBY_TIMER_START);
-                }
-                /*If there is pending reset event to process*/
-                if((nfcFL.eseFL._JCOP_WA_ENABLE) &&(active_ese_reset_control&RESET_BLOCKED)&&
-                        (!(active_ese_reset_control &(TRANS_CL_ONGOING))))
-                {
-                    SyncEventGuard guard (sSecElem.mResetEvent);
-                    sSecElem.mResetEvent.notifyOne();
-                }
-                gWtxCount = 0;
+        SyncEventGuard guard(sSecElem.mTransceiveEvent);
+        sSecElem.mActualResponseSize =
+            (eventData->rcvd_evt.evt_len > MAX_RESPONSE_SIZE)
+                ? MAX_RESPONSE_SIZE
+                : eventData->rcvd_evt.evt_len;
+#if (NXP_EXTNS == TRUE)
+        if (nfcFL.nfcNxpEse) {
+          if (eventData->rcvd_evt.evt_len > 0) {
+            sSecElem.mTransceiveWaitOk = true;
+            if (nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
+              se_rd_req_state_t state =
+                  MposManager::getInstance().getEtsiReaederState();
+              if ((state == STATE_SE_RDR_MODE_STOPPED) ||
+                  (state == STATE_SE_RDR_MODE_STOP_CONFIG)) {
+                sSecElem.NfccStandByOperation(STANDBY_TIMER_START);
+              } else {
+                DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+                    "ETSI in progress, do not start standby timer");
+              }
             } else {
-                if(eventData->rcvd_evt.evt_len > 0)
-                {
-                    sSecElem.mTransceiveWaitOk = true;
-                }
+              sSecElem.NfccStandByOperation(STANDBY_TIMER_START);
             }
-#endif
-            sSecElem.mTransceiveEvent.notifyOne ();
-        }
-        else if (eventData->rcvd_evt.evt_code == NFA_HCI_EVT_POST_DATA)
-        {
-            ALOGV("%s: NFA_HCI_EVENT_RCVD_EVT; NFA_HCI_EVT_POST_DATA", fn);
-            SyncEventGuard guard (sSecElem.mTransceiveEvent);
-            sSecElem.mActualResponseSize = (eventData->rcvd_evt.evt_len > MAX_RESPONSE_SIZE) ? MAX_RESPONSE_SIZE : eventData->rcvd_evt.evt_len;
-            sSecElem.mTransceiveEvent.notifyOne ();
+          }
+          /*If there is pending reset event to process*/
+          if ((nfcFL.eseFL._JCOP_WA_ENABLE) &&
+              (active_ese_reset_control & RESET_BLOCKED) &&
+              (!(active_ese_reset_control & (TRANS_CL_ONGOING)))) {
+            SyncEventGuard guard(sSecElem.mResetEvent);
+            sSecElem.mResetEvent.notifyOne();
+          }
+          gWtxCount = 0;
+        } else {
+          if (eventData->rcvd_evt.evt_len > 0) {
+            sSecElem.mTransceiveWaitOk = true;
+          }
         }
-        else if (eventData->rcvd_evt.evt_code == NFA_HCI_EVT_TRANSACTION)
-        {
-            ALOGV("%s: NFA_HCI_EVENT_RCVD_EVT; NFA_HCI_EVT_TRANSACTION", fn);
-            // If we got an AID, notify any listeners
-            if ((eventData->rcvd_evt.evt_len > 3) && (eventData->rcvd_evt.p_evt_buf[0] == 0x81) )
-            {
-                int aidlen = eventData->rcvd_evt.p_evt_buf[1];
-                uint8_t* data = NULL;
-                int32_t datalen = 0;
-                uint8_t dataStartPosition = 0;
-                if((eventData->rcvd_evt.evt_len > 2+aidlen) && (eventData->rcvd_evt.p_evt_buf[2+aidlen] == 0x82))
-                {
-                    //BERTLV decoding here, to support extended data length for params.
-                    datalen = SecureElement::decodeBerTlvLength((uint8_t *)eventData->rcvd_evt.p_evt_buf, 2+aidlen+1, eventData->rcvd_evt.evt_len);
-                }
-                if(datalen >= 0)
-                {
-                    /* Over 128 bytes data of transaction can not receive on PN547, Ref. BER-TLV length fields in ISO/IEC 7816 */
-                    if ( datalen < 0x80)
-                    {
-                        dataStartPosition = 2+aidlen+2;
-                    }
-                    else if ( datalen < 0x100)
-                    {
-                        dataStartPosition = 2+aidlen+3;
-                    }
-                    else if ( datalen < 0x10000)
-                    {
-                        dataStartPosition = 2+aidlen+4;
-                    }
-                    else if ( datalen < 0x1000000)
-                    {
-                        dataStartPosition = 2+aidlen+5;
-                    }
-                    data  = &eventData->rcvd_evt.p_evt_buf[dataStartPosition];
-                    sSecElem.notifyTransactionListenersOfAid (&eventData->rcvd_evt.p_evt_buf[2],aidlen,data,datalen,evtSrc);
-                }
-                else
-                {
-                    ALOGE("Event data TLV length encoding Unsupported!");
-                }
+#endif
+        sSecElem.mTransceiveEvent.notifyOne();
+      } else if (eventData->rcvd_evt.evt_code == NFA_HCI_EVT_POST_DATA) {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: NFA_HCI_EVENT_RCVD_EVT; NFA_HCI_EVT_POST_DATA", fn);
+        SyncEventGuard guard(sSecElem.mTransceiveEvent);
+        sSecElem.mActualResponseSize =
+            (eventData->rcvd_evt.evt_len > MAX_RESPONSE_SIZE)
+                ? MAX_RESPONSE_SIZE
+                : eventData->rcvd_evt.evt_len;
+        sSecElem.mTransceiveEvent.notifyOne();
+      } else if (eventData->rcvd_evt.evt_code == NFA_HCI_EVT_TRANSACTION) {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: NFA_HCI_EVENT_RCVD_EVT; NFA_HCI_EVT_TRANSACTION", fn);
+        // If we got an AID, notify any listeners
+        if ((eventData->rcvd_evt.evt_len > 3) &&
+            (eventData->rcvd_evt.p_evt_buf[0] == 0x81)) {
+          int aidlen = eventData->rcvd_evt.p_evt_buf[1];
+          uint8_t* data = NULL;
+          int32_t datalen = 0;
+          uint8_t dataStartPosition = 0;
+          if ((eventData->rcvd_evt.evt_len > 2 + aidlen) &&
+              (eventData->rcvd_evt.p_evt_buf[2 + aidlen] == 0x82)) {
+            // BERTLV decoding here, to support extended data length for params.
+            datalen = SecureElement::decodeBerTlvLength(
+                (uint8_t*)eventData->rcvd_evt.p_evt_buf, 2 + aidlen + 1,
+                eventData->rcvd_evt.evt_len);
+          }
+          if (datalen >= 0) {
+            /* Over 128 bytes data of transaction can not receive on PN547, Ref.
+             * BER-TLV length fields in ISO/IEC 7816 */
+            if (datalen < 0x80) {
+              dataStartPosition = 2 + aidlen + 2;
+            } else if (datalen < 0x100) {
+              dataStartPosition = 2 + aidlen + 3;
+            } else if (datalen < 0x10000) {
+              dataStartPosition = 2 + aidlen + 4;
+            } else if (datalen < 0x1000000) {
+              dataStartPosition = 2 + aidlen + 5;
             }
-        }
-        else if (eventData->rcvd_evt.evt_code == NFA_HCI_EVT_CONNECTIVITY)
-        {
-            ALOGV("%s: NFA_HCI_EVENT_RCVD_EVT; NFA_HCI_EVT_CONNECTIVITY", fn);
-
-//            int pipe = (eventData->rcvd_evt.pipe);                            /*commented to eliminate unused variable warning*/
-                sSecElem.notifyConnectivityListeners (evtSrc);
-        }
-        else
-        {
-            ALOGV("%s: NFA_HCI_EVENT_RCVD_EVT; ################################### eventData->rcvd_evt.evt_code = 0x%x , NFA_HCI_EVT_CONNECTIVITY = 0x%x", fn, eventData->rcvd_evt.evt_code, NFA_HCI_EVT_CONNECTIVITY);
-
-            ALOGV("%s: NFA_HCI_EVENT_RCVD_EVT; ################################### ", fn);
-
-        }
-        break;
-
-    case NFA_HCI_SET_REG_RSP_EVT: //received response to write registry command
-        {
-            tNFA_HCI_REGISTRY& registry = eventData->registry;
-            ALOGV("%s: NFA_HCI_SET_REG_RSP_EVT; status=0x%X; pipe=0x%X", fn, registry.status, registry.pipe);
-            SyncEventGuard guard (sSecElem.mRegistryEvent);
-            sSecElem.mRegistryEvent.notifyOne ();
-            break;
-        }
-#if(NXP_EXTNS == TRUE)
-    case NFA_HCI_CONFIG_DONE_EVT:
-        {
-            ALOGV("%s: NFA_HCI_CONFIG_DONE_EVT; status=0x%X", fn, eventData->admin_rsp_rcvd.status);
-            sSecElem.mETSI12InitStatus = eventData->admin_rsp_rcvd.status;
-            SyncEventGuard guard(sSecElem.mNfceeInitCbEvent);
-            sSecElem.mNfceeInitCbEvent.notifyOne();
-            break;
-        }
-    case NFA_HCI_EE_RECOVERY_EVT:
-    {
-        tNFA_HCI_EE_RECOVERY_EVT &ee_recovery = eventData->ee_recovery;
-        ALOGV("%s: NFA_HCI_EE_RECOVERY_EVT; status=0x%X", fn, ee_recovery.status);
-        if(ee_recovery.status == NFA_HCI_EE_RECOVERY_STARTED)
-            RoutingManager::getInstance().setEERecovery(true);
-        else if(ee_recovery.status == NFA_HCI_EE_RECOVERY_COMPLETED)
-        {
-            ALOGV("%s: NFA_HCI_EE_RECOVERY_EVT; recovery completed status=0x%X", fn, ee_recovery.status);
-            RoutingManager::getInstance().setEERecovery(false);
-            if(active_ese_reset_control & TRANS_WIRED_ONGOING)
-            {
-                SyncEventGuard guard(sSecElem.mTransceiveEvent);
-                sSecElem.mTransceiveEvent.notifyOne();
+            data = &eventData->rcvd_evt.p_evt_buf[dataStartPosition];
+            if (nfcFL.nfcNxpEse && nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
+              if (MposManager::getInstance().validateHCITransactionEventParams(
+                      data, datalen) == NFA_STATUS_OK) {
+                HciEventManager::getInstance().nfaHciEvtHandler(event,
+                                                                eventData);
+              }
+            } else {
+              HciEventManager::getInstance().nfaHciEvtHandler(event, eventData);
             }
-        }
-        break;
+          } else {
+            LOG(ERROR) << StringPrintf(
+                "Event data TLV length encoding Unsupported!");
+          }
+        }
+      } else if (eventData->rcvd_evt.evt_code == NFA_HCI_EVT_CONNECTIVITY) {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: NFA_HCI_EVENT_RCVD_EVT; NFA_HCI_EVT_CONNECTIVITY", fn);
+        int evtSrc = 0xFF;
+        if (eventData->rcvd_evt.pipe == 0x0A)  // UICC
+        {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("%s: NFA_HCI_EVENT_RCVD_EVT; source UICC", fn);
+          evtSrc = SecureElement::getInstance().getGenericEseId(
+              SecureElement::getInstance().EE_HANDLE_0xF4 &
+              ~NFA_HANDLE_GROUP_EE);                  // UICC
+        } else if (eventData->rcvd_evt.pipe == 0x16)  // ESE
+        {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("%s: NFA_HCI_EVENT_RCVD_EVT; source ESE", fn);
+          evtSrc = SecureElement::getInstance().getGenericEseId(
+              EE_HANDLE_0xF3 & ~NFA_HANDLE_GROUP_EE);  // ESE
+        } else if (nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH &&
+                   (eventData->rcvd_evt.pipe == 0x23)) /*UICC2*/
+        {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("%s: NFA_HCI_EVENT_RCVD_EVT; source UICC2", fn);
+          evtSrc = SecureElement::getInstance().getGenericEseId(
+              EE_HANDLE_0xF8 & ~NFA_HANDLE_GROUP_EE); /*UICC2*/
+        }
+        //            int pipe = (eventData->rcvd_evt.pipe);
+        //            /*commented to eliminate unused variable warning*/
+        sSecElem.notifyConnectivityListeners(evtSrc);
+      } else {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: NFA_HCI_EVENT_RCVD_EVT; ################################### "
+            "eventData->rcvd_evt.evt_code = 0x%x , NFA_HCI_EVT_CONNECTIVITY = "
+            "0x%x",
+            fn, eventData->rcvd_evt.evt_code, NFA_HCI_EVT_CONNECTIVITY);
+
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: NFA_HCI_EVENT_RCVD_EVT; ################################### ",
+            fn);
+      }
+      break;
+
+    case NFA_HCI_SET_REG_RSP_EVT:  // received response to write registry
+                                   // command
+    {
+      tNFA_HCI_REGISTRY& registry = eventData->registry;
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: NFA_HCI_SET_REG_RSP_EVT; status=0x%X; pipe=0x%X",
+                          fn, registry.status, registry.pipe);
+      SyncEventGuard guard(sSecElem.mRegistryEvent);
+      sSecElem.mRegistryEvent.notifyOne();
+      break;
     }
-    case NFA_HCI_ADD_STATIC_PIPE_EVT:
-    {
-        ALOGV("%s: NFA_HCI_ADD_STATIC_PIPE_EVT; status=0x%X", fn, eventData->admin_rsp_rcvd.status);
-        SyncEventGuard guard(sSecElem.mHciAddStaticPipe);
-        sSecElem.mHciAddStaticPipe.notifyOne();
-        break;
+#if (NXP_EXTNS == TRUE)
+    case NFA_HCI_CONFIG_DONE_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: NFA_HCI_CONFIG_DONE_EVT; status=0x%X", fn,
+                          eventData->admin_rsp_rcvd.status);
+      sSecElem.mETSI12InitStatus = eventData->admin_rsp_rcvd.status;
+      SyncEventGuard guard(sSecElem.mNfceeInitCbEvent);
+      sSecElem.mNfceeInitCbEvent.notifyOne();
+      break;
+    }
+    case NFA_HCI_EE_RECOVERY_EVT: {
+      tNFA_HCI_EE_RECOVERY_EVT& ee_recovery = eventData->ee_recovery;
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: NFA_HCI_EE_RECOVERY_EVT; status=0x%X", fn, ee_recovery.status);
+      if (ee_recovery.status == NFA_HCI_EE_RECOVERY_STARTED)
+        RoutingManager::getInstance().setEERecovery(true);
+      else if (ee_recovery.status == NFA_HCI_EE_RECOVERY_COMPLETED) {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: NFA_HCI_EE_RECOVERY_EVT; recovery completed status=0x%X", fn,
+            ee_recovery.status);
+        RoutingManager::getInstance().setEERecovery(false);
+        if (active_ese_reset_control & TRANS_WIRED_ONGOING) {
+          SyncEventGuard guard(sSecElem.mTransceiveEvent);
+          sSecElem.mTransceiveEvent.notifyOne();
+        }
+      }
+      break;
+    }
+    case NFA_HCI_ADD_STATIC_PIPE_EVT: {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: NFA_HCI_ADD_STATIC_PIPE_EVT; status=0x%X", fn,
+                          eventData->admin_rsp_rcvd.status);
+      SyncEventGuard guard(sSecElem.mHciAddStaticPipe);
+      sSecElem.mHciAddStaticPipe.notifyOne();
+      break;
     }
 #endif
     default:
-        ALOGE("%s: unknown event code=0x%X ????", fn, event);
-        break;
-    }
+      LOG(ERROR) << StringPrintf("%s: unknown event code=0x%X ????", fn, event);
+      break;
+  }
 }
 
-
 /*******************************************************************************
 **
 ** Function:        findEeByHandle
@@ -2773,14 +2637,11 @@ void SecureElement::nfaHciCallback (tNFA_HCI_EVT event, tNFA_HCI_EVT_DATA* event
 ** Returns:         Information about an execution environment.
 **
 *******************************************************************************/
-tNFA_EE_INFO *SecureElement::findEeByHandle (tNFA_HANDLE eeHandle)
-{
-    for (uint8_t xx = 0; xx < mActualNumEe; xx++)
-    {
-        if (mEeInfo[xx].ee_handle == eeHandle)
-            return (&mEeInfo[xx]);
-    }
-    return (NULL);
+tNFA_EE_INFO* SecureElement::findEeByHandle(tNFA_HANDLE eeHandle) {
+  for (uint8_t xx = 0; xx < mActualNumEe; xx++) {
+    if (mEeInfo[xx].ee_handle == eeHandle) return (&mEeInfo[xx]);
+  }
+  return (NULL);
 }
 
 /*******************************************************************************
@@ -2793,36 +2654,31 @@ tNFA_EE_INFO *SecureElement::findEeByHandle (tNFA_HANDLE eeHandle)
 ** Returns:         Information about an execution environment.
 **
 *******************************************************************************/
-jint SecureElement::getSETechnology(tNFA_HANDLE eeHandle)
-{
-    int tech_mask = 0x00;
-    static const char fn [] = "SecureElement::getSETechnology";
-    // Get Fresh EE info.
-    if (! getEeInfo())
-    {
-        ALOGE("%s: No updated eeInfo available", fn);
-    }
+jint SecureElement::getSETechnology(tNFA_HANDLE eeHandle) {
+  int tech_mask = 0x00;
+  static const char fn[] = "SecureElement::getSETechnology";
+  // Get Fresh EE info.
+  if (!getEeInfo()) {
+    LOG(ERROR) << StringPrintf("%s: No updated eeInfo available", fn);
+  }
 
-    tNFA_EE_INFO* eeinfo = findEeByHandle(eeHandle);
+  tNFA_EE_INFO* eeinfo = findEeByHandle(eeHandle);
 
-    if(eeinfo!=NULL){
-        if(eeinfo->la_protocol != 0x00)
-        {
-            tech_mask |= 0x01;
-        }
+  if (eeinfo != NULL) {
+    if (eeinfo->la_protocol != 0x00) {
+      tech_mask |= 0x01;
+    }
 
-        if(eeinfo->lb_protocol != 0x00)
-        {
-            tech_mask |= 0x02;
-        }
+    if (eeinfo->lb_protocol != 0x00) {
+      tech_mask |= 0x02;
+    }
 
-        if(eeinfo->lf_protocol != 0x00)
-        {
-            tech_mask |= 0x04;
-        }
+    if (eeinfo->lf_protocol != 0x00) {
+      tech_mask |= 0x04;
     }
+  }
 
-    return tech_mask;
+  return tech_mask;
 }
 /*******************************************************************************
 **
@@ -2833,37 +2689,40 @@ jint SecureElement::getSETechnology(tNFA_HANDLE eeHandle)
 ** Returns:         Handle to the execution environment.
 **
 *******************************************************************************/
-tNFA_HANDLE SecureElement::getDefaultEeHandle ()
-{
-    static const char fn [] = "SecureElement::activate";
-
-    ALOGV("%s: - Enter", fn);
-    ALOGV("%s: - mActualNumEe = %x mActiveSeOverride = 0x%02X", fn,mActualNumEe, mActiveSeOverride);
-
-    uint16_t overrideEeHandle = NFA_HANDLE_GROUP_EE | mActiveSeOverride;
-    // Find the first EE that is not the HCI Access i/f.
-    for (uint8_t xx = 0; xx < mActualNumEe; xx++)
-    {
-        if ( (mActiveSeOverride != ACTIVE_SE_USE_ANY) && (overrideEeHandle != mEeInfo[xx].ee_handle))
-            continue; //skip all the EE's that are ignored
-        ALOGV("%s: - mEeInfo[xx].ee_handle = 0x%02x, mEeInfo[xx].ee_status = 0x%02x", fn,mEeInfo[xx].ee_handle, mEeInfo[xx].ee_status);
-
-              if((nfcFL.nfccFL._GEMALTO_SE_SUPPORT && (mEeInfo[xx].ee_interface[0] != NCI_NFCEE_INTERFACE_HCI_ACCESS)))
-              {
-                  return (mEeInfo[xx].ee_handle);
-              }
-              else if((!nfcFL.nfccFL._GEMALTO_SE_SUPPORT && ((mEeInfo[xx].ee_handle == EE_HANDLE_0xF3
-                  || mEeInfo[xx].ee_handle == SecureElement::getInstance().EE_HANDLE_0xF4
-                  || (mEeInfo[xx].ee_handle == EE_HANDLE_0xF8 && nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC))
-                  && (mEeInfo[xx].ee_status != NFC_NFCEE_STATUS_INACTIVE))))
-              {
-                  return (mEeInfo[xx].ee_handle);
-              }
-
-    }
-    return NFA_HANDLE_INVALID;
+tNFA_HANDLE SecureElement::getDefaultEeHandle() {
+  static const char fn[] = "SecureElement::activate";
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: - Enter", fn);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: - mActualNumEe = %x mActiveSeOverride = 0x%02X", fn,
+                      mActualNumEe, mActiveSeOverride);
+
+  uint16_t overrideEeHandle = NFA_HANDLE_GROUP_EE | mActiveSeOverride;
+  // Find the first EE that is not the HCI Access i/f.
+  for (uint8_t xx = 0; xx < mActualNumEe; xx++) {
+    if ((mActiveSeOverride != ACTIVE_SE_USE_ANY) &&
+        (overrideEeHandle != mEeInfo[xx].ee_handle))
+      continue;  // skip all the EE's that are ignored
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: - mEeInfo[xx].ee_handle = 0x%02x, mEeInfo[xx].ee_status = 0x%02x",
+        fn, mEeInfo[xx].ee_handle, mEeInfo[xx].ee_status);
+
+    if ((nfcFL.nfccFL._GEMALTO_SE_SUPPORT &&
+         (mEeInfo[xx].ee_interface[0] != NCI_NFCEE_INTERFACE_HCI_ACCESS))) {
+      return (mEeInfo[xx].ee_handle);
+    } else if ((!nfcFL.nfccFL._GEMALTO_SE_SUPPORT &&
+                ((mEeInfo[xx].ee_handle == EE_HANDLE_0xF3 ||
+                  mEeInfo[xx].ee_handle ==
+                      SecureElement::getInstance().EE_HANDLE_0xF4 ||
+                  (mEeInfo[xx].ee_handle == EE_HANDLE_0xF8 &&
+                   nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC)) &&
+                 (mEeInfo[xx].ee_status != NFC_NFCEE_STATUS_INACTIVE)))) {
+      return (mEeInfo[xx].ee_handle);
+    }
+  }
+  return NFA_HANDLE_INVALID;
 }
-#if(NXP_EXTNS == TRUE)
+#if (NXP_EXTNS == TRUE)
 /*******************************************************************************
 **
 ** Function:        getActiveEeHandle
@@ -2873,35 +2732,44 @@ tNFA_HANDLE SecureElement::getDefaultEeHandle ()
 ** Returns:         Handle to the execution environment.
 **
 *******************************************************************************/
-tNFA_HANDLE SecureElement::getActiveEeHandle (tNFA_HANDLE handle)
-{
-    static const char fn [] = "SecureElement::getActiveEeHandle";
-
-    ALOGE("%s: - Enter", fn);
-    ALOGE("%s: - mActualNumEe = %x mActiveSeOverride = 0x%02X", fn,mActualNumEe, mActiveSeOverride);
-
-    uint16_t overrideEeHandle = NFA_HANDLE_GROUP_EE | mActiveSeOverride;
-    ALOGE("%s: - mActualNumEe = %x overrideEeHandle = 0x%02X", fn,mActualNumEe, overrideEeHandle);
-
-    for (uint8_t xx = 0; xx < mActualNumEe; xx++)
-    {
-        if ( (mActiveSeOverride != ACTIVE_SE_USE_ANY) && (overrideEeHandle != mEeInfo[xx].ee_handle))
-             ALOGE("%s: - mEeInfo[xx].ee_handle = 0x%02x, mEeInfo[xx].ee_status = 0x%02x", fn,mEeInfo[xx].ee_handle, mEeInfo[xx].ee_status);
-
-        if(nfcFL.nfccFL._GEMALTO_SE_SUPPORT && (mEeInfo[xx].ee_interface[0] != NCI_NFCEE_INTERFACE_HCI_ACCESS)
-             && (mEeInfo[xx].ee_status != NFC_NFCEE_STATUS_INACTIVE) && (mEeInfo[xx].ee_handle == handle))
-         {
-             return (mEeInfo[xx].ee_handle);
-         }
-         else if (!nfcFL.nfccFL._GEMALTO_SE_SUPPORT && (mEeInfo[xx].ee_handle == EE_HANDLE_0xF3 || mEeInfo[xx].ee_handle == SecureElement::getInstance().EE_HANDLE_0xF4
-              || (mEeInfo[xx].ee_handle == EE_HANDLE_0xF8 && nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC))
-              && (mEeInfo[xx].ee_status != NFC_NFCEE_STATUS_INACTIVE) && (mEeInfo[xx].ee_handle == handle))
-         {
-             return (mEeInfo[xx].ee_handle);
-         }
-
-    }
-    return NFA_HANDLE_INVALID;
+tNFA_HANDLE SecureElement::getActiveEeHandle(tNFA_HANDLE handle) {
+  static const char fn[] = "SecureElement::getActiveEeHandle";
+
+  LOG(ERROR) << StringPrintf("%s: - Enter", fn);
+  LOG(ERROR) << StringPrintf(
+      "%s: - mActualNumEe = %x mActiveSeOverride = 0x%02X", fn, mActualNumEe,
+      mActiveSeOverride);
+
+  uint16_t overrideEeHandle = NFA_HANDLE_GROUP_EE | mActiveSeOverride;
+  LOG(ERROR) << StringPrintf(
+      "%s: - mActualNumEe = %x overrideEeHandle = 0x%02X", fn, mActualNumEe,
+      overrideEeHandle);
+
+  for (uint8_t xx = 0; xx < mActualNumEe; xx++) {
+    if ((mActiveSeOverride != ACTIVE_SE_USE_ANY) &&
+        (overrideEeHandle != mEeInfo[xx].ee_handle))
+      LOG(ERROR) << StringPrintf(
+          "%s: - mEeInfo[xx].ee_handle = 0x%02x, mEeInfo[xx].ee_status = "
+          "0x%02x",
+          fn, mEeInfo[xx].ee_handle, mEeInfo[xx].ee_status);
+
+    if (nfcFL.nfccFL._GEMALTO_SE_SUPPORT &&
+        (mEeInfo[xx].ee_interface[0] != NCI_NFCEE_INTERFACE_HCI_ACCESS) &&
+        (mEeInfo[xx].ee_status != NFC_NFCEE_STATUS_INACTIVE) &&
+        (mEeInfo[xx].ee_handle == handle)) {
+      return (mEeInfo[xx].ee_handle);
+    } else if (!nfcFL.nfccFL._GEMALTO_SE_SUPPORT &&
+               (mEeInfo[xx].ee_handle == EE_HANDLE_0xF3 ||
+                mEeInfo[xx].ee_handle ==
+                    SecureElement::getInstance().EE_HANDLE_0xF4 ||
+                (mEeInfo[xx].ee_handle == EE_HANDLE_0xF8 &&
+                 nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC)) &&
+               (mEeInfo[xx].ee_status != NFC_NFCEE_STATUS_INACTIVE) &&
+               (mEeInfo[xx].ee_handle == handle)) {
+      return (mEeInfo[xx].ee_handle);
+    }
+  }
+  return NFA_HANDLE_INVALID;
 }
 #endif
 /*******************************************************************************
@@ -2914,20 +2782,17 @@ tNFA_HANDLE SecureElement::getActiveEeHandle (tNFA_HANDLE handle)
 ** Returns:         Information about the execution environment.
 **
 *******************************************************************************/
-tNFA_EE_DISCOVER_INFO *SecureElement::findUiccByHandle (tNFA_HANDLE eeHandle)
-{
-    for (uint8_t index = 0; index < mUiccInfo.num_ee; index++)
-    {
-        if (mUiccInfo.ee_disc_info[index].ee_handle == eeHandle)
-        {
-            return (&mUiccInfo.ee_disc_info[index]);
-        }
-    }
-    ALOGE("SecureElement::findUiccByHandle:  ee h=0x%4x not found", eeHandle);
-    return NULL;
+tNFA_EE_DISCOVER_INFO* SecureElement::findUiccByHandle(tNFA_HANDLE eeHandle) {
+  for (uint8_t index = 0; index < mUiccInfo.num_ee; index++) {
+    if (mUiccInfo.ee_disc_info[index].ee_handle == eeHandle) {
+      return (&mUiccInfo.ee_disc_info[index]);
+    }
+  }
+  LOG(ERROR) << StringPrintf(
+      "SecureElement::findUiccByHandle:  ee h=0x%4x not found", eeHandle);
+  return NULL;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        eeStatusToString
@@ -2938,21 +2803,18 @@ tNFA_EE_DISCOVER_INFO *SecureElement::findUiccByHandle (tNFA_HANDLE eeHandle)
 ** Returns:         None
 **
 *******************************************************************************/
-const char* SecureElement::eeStatusToString (uint8_t status)
-{
-    switch (status)
-    {
+const char* SecureElement::eeStatusToString(uint8_t status) {
+  switch (status) {
     case NFC_NFCEE_STATUS_ACTIVE:
-        return("Connected/Active");
+      return ("Connected/Active");
     case NFC_NFCEE_STATUS_INACTIVE:
-        return("Connected/Inactive");
+      return ("Connected/Inactive");
     case NFC_NFCEE_STATUS_REMOVED:
-        return("Removed");
-    }
-    return("?? Unknown ??");
+      return ("Removed");
+  }
+  return ("?? Unknown ??");
 }
 
-
 /*******************************************************************************
 **
 ** Function:        connectionEventHandler
@@ -2964,25 +2826,19 @@ const char* SecureElement::eeStatusToString (uint8_t status)
 ** Returns:         None
 **
 *******************************************************************************/
-void SecureElement::connectionEventHandler (uint8_t event, tNFA_CONN_EVT_DATA* /*eventData*/)
-{
-    switch (event)
-    {
-    case NFA_CE_UICC_LISTEN_CONFIGURED_EVT:
-        {
-            SyncEventGuard guard (mUiccListenEvent);
-            mUiccListenEvent.notifyOne ();
-        }
-        break;
-
-    case NFA_CE_ESE_LISTEN_CONFIGURED_EVT:
-        {
-            SyncEventGuard guard (mEseListenEvent);
-            mEseListenEvent.notifyOne ();
-        }
-        break;
-    }
-
+void SecureElement::connectionEventHandler(uint8_t event,
+                                           tNFA_CONN_EVT_DATA* /*eventData*/) {
+  switch (event) {
+    case NFA_CE_UICC_LISTEN_CONFIGURED_EVT: {
+      SyncEventGuard guard(mUiccListenEvent);
+      mUiccListenEvent.notifyOne();
+    } break;
+
+    case NFA_CE_ESE_LISTEN_CONFIGURED_EVT: {
+      SyncEventGuard guard(mEseListenEvent);
+      mEseListenEvent.notifyOne();
+    } break;
+  }
 }
 /*******************************************************************************
 **
@@ -2993,136 +2849,130 @@ void SecureElement::connectionEventHandler (uint8_t event, tNFA_CONN_EVT_DATA* /
 ** Returns:         Returns True if success
 **
 *******************************************************************************/
-bool SecureElement::getAtr(jint seID, uint8_t* recvBuffer, int32_t *recvBufferSize)
-{
-    static const char fn[] = "SecureElement::getAtr";
-    tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
-    uint8_t reg_index = 0x01;
-    int timeoutMillisec = 10000;
-    ALOGV("%s: enter; seID=0x%X", fn, seID);
+bool SecureElement::getAtr(jint seID, uint8_t* recvBuffer,
+                           int32_t* recvBufferSize) {
+  static const char fn[] = "SecureElement::getAtr";
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+  uint8_t reg_index = 0x01;
+  int timeoutMillisec = 10000;
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter; seID=0x%X", fn, seID);
 #if (NXP_EXTNS == TRUE)
-    if(nfcFL.nfcNxpEse) {
-        se_apdu_gate_info gateInfo = NO_APDU_GATE;
-
-        if(nfcFL.nfccFL._NFCEE_REMOVED_NTF_RECOVERY) {
-            if((RoutingManager::getInstance().is_ee_recovery_ongoing()))
-            {
-                SyncEventGuard guard (mEEdatapacketEvent);
-                if(mEEdatapacketEvent.wait(android::gMaxEERecoveryTimeout) == false)
-                {
-                    return false;
-                }
-            }
-        }
-        if(!checkForWiredModeAccess())
-        {
-            ALOGV("Denying /atr in SE listen mode active");
-            return false;
-        }
-        if ((((nfcFL.eseFL._NXP_ESE_VER == JCOP_VER_3_1) || (nfcFL.eseFL._NXP_ESE_VER == JCOP_VER_3_2))) &&NFC_GetEseAccess((void *)&timeoutMillisec) != 0)
-        {
-            ALOGE("%s: NFC_ReqWiredAccess timeout", fn);
-            return false;
-        }
-        NfccStandByOperation(STANDBY_MODE_OFF);
-
-        gateInfo = getApduGateInfo();
-        if(gateInfo == PROPREITARY_APDU_GATE)
-        {
-            SyncEventGuard guard (mGetRegisterEvent);
-            nfaStat = NFA_HciGetRegistry (mNfaHciHandle, mNewPipeId, reg_index);
-            if(nfaStat == NFA_STATUS_OK)
-            {
-                mGetAtrRspwait = true;
-                mGetRegisterEvent.wait();
-                ALOGV("%s: Received ATR response on pipe 0x%x ", fn, mNewPipeId);
-            }
-            *recvBufferSize = mAtrInfolen;
-            memcpy(recvBuffer, mAtrInfo, mAtrInfolen);
-        }
-        else if(gateInfo == ETSI_12_APDU_GATE)
-        {
-            mAbortEventWaitOk = false;
-            uint8_t mAtrInfo1[EVT_ABORT_MAX_RSP_LEN]={0};
-            uint8_t atr_len = EVT_ABORT_MAX_RSP_LEN;
-            SyncEventGuard guard (mAbortEvent);
-            nfaStat = NFA_HciSendEvent(mNfaHciHandle, mNewPipeId, EVT_ABORT, 0, NULL, atr_len, mAtrInfo1, timeoutMillisec);
-            if(nfaStat == NFA_STATUS_OK)
-            {
-                mAbortEvent.wait();
-            }
-            if(mAbortEventWaitOk == false)
-            {
-                ALOGE("%s (EVT_ABORT)Wait reposne timeout", fn);
-                nfaStat = NFA_STATUS_FAILED;
-            }
-            else
-            {
-                *recvBufferSize = mAtrInfolen;
-                memcpy(recvBuffer, mAtrInfo, mAtrInfolen);
-            }
-        }
+  if (nfcFL.nfcNxpEse) {
+    se_apdu_gate_info gateInfo = NO_APDU_GATE;
+
+    if (nfcFL.nfccFL._NFCEE_REMOVED_NTF_RECOVERY) {
+      if ((RoutingManager::getInstance().is_ee_recovery_ongoing())) {
+        SyncEventGuard guard(mEEdatapacketEvent);
+        if (mEEdatapacketEvent.wait(android::gMaxEERecoveryTimeout) == false) {
+          return false;
+        }
+      }
+    }
+    if (!checkForWiredModeAccess()) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("Denying /atr in SE listen mode active");
+      return false;
+    }
+    if ((((nfcFL.eseFL._NXP_ESE_VER == JCOP_VER_3_1) ||
+          (nfcFL.eseFL._NXP_ESE_VER == JCOP_VER_3_2))) &&
+        NFC_GetEseAccess((void*)&timeoutMillisec) != 0) {
+      LOG(ERROR) << StringPrintf("%s: NFC_ReqWiredAccess timeout", fn);
+      return false;
+    }
+    NfccStandByOperation(STANDBY_MODE_OFF);
+
+    gateInfo = getApduGateInfo();
+    if (gateInfo == PROPREITARY_APDU_GATE) {
+      SyncEventGuard guard(mGetRegisterEvent);
+      nfaStat = NFA_HciGetRegistry(mNfaHciHandle, mNewPipeId, reg_index);
+      if (nfaStat == NFA_STATUS_OK) {
+        mGetAtrRspwait = true;
+        mGetRegisterEvent.wait();
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: Received ATR response on pipe 0x%x ", fn, mNewPipeId);
+      }
+      *recvBufferSize = mAtrInfolen;
+      memcpy(recvBuffer, mAtrInfo, mAtrInfolen);
+    } else if (gateInfo == ETSI_12_APDU_GATE) {
+      mAbortEventWaitOk = false;
+      uint8_t mAtrInfo1[EVT_ABORT_MAX_RSP_LEN] = {0};
+      uint8_t atr_len = EVT_ABORT_MAX_RSP_LEN;
+      SyncEventGuard guard(mAbortEvent);
+      nfaStat = NFA_HciSendEvent(mNfaHciHandle, mNewPipeId, EVT_ABORT, 0, NULL,
+                                 atr_len, mAtrInfo1, timeoutMillisec);
+      if (nfaStat == NFA_STATUS_OK) {
+        mAbortEvent.wait();
+      }
+      if (mAbortEventWaitOk == false) {
+        LOG(ERROR) << StringPrintf("%s (EVT_ABORT)Wait reposne timeout", fn);
+        nfaStat = NFA_STATUS_FAILED;
+      } else {
+        *recvBufferSize = mAtrInfolen;
+        memcpy(recvBuffer, mAtrInfo, mAtrInfolen);
+      }
+    }
 
-        if((nfcFL.eseFL._JCOP_WA_ENABLE) && (mAtrStatus == NFA_HCI_ANY_E_NOK))
-            reconfigureEseHciInit();
+    if ((nfcFL.eseFL._JCOP_WA_ENABLE) && (mAtrStatus == NFA_HCI_ANY_E_NOK))
+      reconfigureEseHciInit();
 
-        if (((nfcFL.eseFL._NXP_ESE_VER == JCOP_VER_3_1) || (nfcFL.eseFL._NXP_ESE_VER == JCOP_VER_3_2)) &&NFC_RelEseAccess((void *)&nfaStat) != 0)
-        {
-            ALOGE("%s: NFC_ReqWiredAccess timeout", fn);
-        }
-#endif
+    if (((nfcFL.eseFL._NXP_ESE_VER == JCOP_VER_3_1) ||
+         (nfcFL.eseFL._NXP_ESE_VER == JCOP_VER_3_2)) &&
+        NFC_RelEseAccess((void*)&nfaStat) != 0) {
+      LOG(ERROR) << StringPrintf("%s: NFC_ReqWiredAccess timeout", fn);
     }
-    return (nfaStat == NFA_STATUS_OK)?true:false;
+#endif
+  }
+  return (nfaStat == NFA_STATUS_OK) ? true : false;
 }
 
 /*******************************************************************************
 **
 ** Function:        routeToSecureElement
 **
-** Description:     Adjust controller's listen-mode routing table so transactions
+** Description:     Adjust controller's listen-mode routing table so
+*transactions
 **                  are routed to the secure elements.
 **
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-bool SecureElement::routeToSecureElement ()
-{
-    static const char fn [] = "SecureElement::routeToSecureElement";
-    ALOGV("%s: enter", fn);
+bool SecureElement::routeToSecureElement() {
+  static const char fn[] = "SecureElement::routeToSecureElement";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
 
-//    tNFA_TECHNOLOGY_MASK tech_mask = NFA_TECHNOLOGY_MASK_A | NFA_TECHNOLOGY_MASK_B;   /*commented to eliminate unused variable warning*/
-    bool retval = false;
+  //    tNFA_TECHNOLOGY_MASK tech_mask = NFA_TECHNOLOGY_MASK_A |
+  //    NFA_TECHNOLOGY_MASK_B;   /*commented to eliminate unused variable
+  //    warning*/
+  bool retval = false;
 
-    if (! mIsInit)
-    {
-        ALOGE("%s: not init", fn);
-        return false;
-    }
+  if (!mIsInit) {
+    LOG(ERROR) << StringPrintf("%s: not init", fn);
+    return false;
+  }
 
-    if (mCurrentRouteSelection == SecElemRoute)
-    {
-        ALOGE("%s: already sec elem route", fn);
-        return true;
-    }
-
-    if (mActiveEeHandle == NFA_HANDLE_INVALID)
-    {
-        ALOGE("%s: invalid EE handle", fn);
-        return false;
-    }
-
-/*    tNFA_EE_INFO* eeinfo = findEeByHandle(mActiveEeHandle);
-    if(eeinfo!=NULL){
-        if(eeinfo->la_protocol == 0x00 && eeinfo->lb_protocol != 0x00 )
-        {
-            gTypeB_listen = true;
-        }
-    }*/
-
-    ALOGV("%s: exit; ok=%u", fn, retval);
-    return retval;
-}
+  if (mCurrentRouteSelection == SecElemRoute) {
+    LOG(ERROR) << StringPrintf("%s: already sec elem route", fn);
+    return true;
+  }
 
+  if (mActiveEeHandle == NFA_HANDLE_INVALID) {
+    LOG(ERROR) << StringPrintf("%s: invalid EE handle", fn);
+    return false;
+  }
+
+  /*    tNFA_EE_INFO* eeinfo = findEeByHandle(mActiveEeHandle);
+      if(eeinfo!=NULL){
+          if(eeinfo->la_protocol == 0x00 && eeinfo->lb_protocol != 0x00 )
+          {
+              gTypeB_listen = true;
+          }
+      }*/
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit; ok=%u", fn, retval);
+  return retval;
+}
 
 /*******************************************************************************
 **
@@ -3134,11 +2984,11 @@ bool SecureElement::routeToSecureElement ()
 ** Returns:         True if either case is true.
 **
 *******************************************************************************/
-bool SecureElement::isBusy ()
-{
-    bool retval = mIsPiping ;
-    ALOGV("SecureElement::isBusy: %u", retval);
-    return retval;
+bool SecureElement::isBusy() {
+  bool retval = mIsPiping;
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("SecureElement::isBusy: %u", retval);
+  return retval;
 }
 
 /*******************************************************************************
@@ -3151,28 +3001,29 @@ bool SecureElement::isBusy ()
 ** Returns:         Return the generic SE id ex:- 00,01,02,04
 **
 *******************************************************************************/
-jint SecureElement::getGenericEseId(tNFA_HANDLE handle)
-{
-    jint ret = 0xFF;
-    static const char fn [] = "SecureElement::getGenericEseId";
-    ALOGV("%s: enter; ESE-Handle = 0x%X", fn, handle);
-    //Map the actual handle to generic id
-    if(handle == (EE_HANDLE_0xF3 & ~NFA_HANDLE_GROUP_EE) ) //ESE - 0xC0
-    {
-        ret = ESE_ID;
-    }
-    else if(handle ==  (SecureElement::getInstance().EE_HANDLE_0xF4 & ~NFA_HANDLE_GROUP_EE) ) //UICC - 0x02
-    {
-        ret = UICC_ID;
-    }
-    else if((nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC ||
-            nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) &&
-            (handle ==  (EE_HANDLE_0xF8 & ~NFA_HANDLE_GROUP_EE))) //UICC2 - 0x04
-    {
-        ret = UICC2_ID;
-    }
-    ALOGV("%s: exit; ESE-Generic-ID = 0x%02X", fn, ret);
-    return ret;
+jint SecureElement::getGenericEseId(tNFA_HANDLE handle) {
+  jint ret = 0xFF;
+  static const char fn[] = "SecureElement::getGenericEseId";
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter; SE-Handle = 0x%X", fn, handle);
+  // Map the actual handle to generic id
+  if (handle == (EE_HANDLE_0xF3 & ~NFA_HANDLE_GROUP_EE))  // ESE - 0xC0
+  {
+    ret = ESE_ID;
+  } else if (handle == (SecureElement::getInstance().EE_HANDLE_0xF4 &
+                        ~NFA_HANDLE_GROUP_EE))  // UICC - 0x02
+  {
+    ret = UICC_ID;
+  } else if ((nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC ||
+              nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) &&
+             (handle ==
+              (EE_HANDLE_0xF8 & ~NFA_HANDLE_GROUP_EE)))  // UICC2 - 0x04
+  {
+    ret = UICC2_ID;
+  }
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit; SE-Generic-ID = 0x%02X", fn, ret);
+  return ret;
 }
 
 /*******************************************************************************
@@ -3185,73 +3036,59 @@ jint SecureElement::getGenericEseId(tNFA_HANDLE handle)
 ** Returns:         Returns Secure element Handle ex:- 402, 4C0, 481
 **
 *******************************************************************************/
-tNFA_HANDLE SecureElement::getEseHandleFromGenericId(jint eseId)
-{
-    uint16_t handle = NFA_HANDLE_INVALID;
-    static const char fn [] = "SecureElement::getEseHandleFromGenericId";
-    ALOGV("%s: enter; ESE-ID = 0x%02X", fn, eseId);
-
-    //Map the generic id to actual handle
-    if(eseId == ESE_ID) //ESE
-    {
-        handle = EE_HANDLE_0xF3; //0x4C0;
-    }
-    else if(eseId == UICC_ID) //UICC
-    {
-        handle = SecureElement::getInstance().EE_HANDLE_0xF4; //0x402;
-    }
-    else if((nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC ||
-            nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) && (eseId == UICC2_ID)) //UICC
-    {
-        handle = EE_HANDLE_0xF8; //0x481;
-    }
-    else if(eseId == DH_ID) //Host
-    {
-        handle = NFA_EE_HANDLE_DH; //0x400;
-    }
-    else if(eseId == EE_HANDLE_0xF3 || eseId == EE_HANDLE_0xF4)
-    {
-        handle = eseId;
-    }
-    ALOGV("%s: enter; ESE-Handle = 0x%03X", fn, handle);
-    return handle;
+tNFA_HANDLE SecureElement::getEseHandleFromGenericId(jint eseId) {
+  uint16_t handle = NFA_HANDLE_INVALID;
+  static const char fn[] = "SecureElement::getEseHandleFromGenericId";
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: enter; SE-Generic-ID = 0x%02X", fn, eseId);
+
+  // Map the generic id to actual handle
+  if (eseId == ESE_ID)  // ESE
+  {
+    handle = EE_HANDLE_0xF3;    // 0x4C0;
+  } else if (eseId == UICC_ID)  // UICC
+  {
+    handle = SecureElement::getInstance().EE_HANDLE_0xF4;  // 0x402;
+  } else if ((nfcFL.nfccFL._NFCC_DYNAMIC_DUAL_UICC ||
+              nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) &&
+             (eseId == UICC2_ID))  // UICC
+  {
+    handle = EE_HANDLE_0xF8;  // 0x481;
+  } else if (eseId == DH_ID)  // Host
+  {
+    handle = NFA_EE_HANDLE_DH;  // 0x400;
+  } else if (eseId == EE_HANDLE_0xF3 || eseId == EE_HANDLE_0xF4) {
+    handle = eseId;
+  }
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: exit; SE-Handle = 0x%03X", fn, handle);
+  return handle;
 }
-bool SecureElement::SecEle_Modeset(uint8_t type)
-{
-    tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
-    bool retval = true;
+bool SecureElement::SecEle_Modeset(uint8_t type) {
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+  bool retval = true;
 
-    ALOGV("set EE mode = 0x%X", type);
-#if(NXP_EXTNS == TRUE)
-    if ((nfaStat = SecElem_EeModeSet (EE_HANDLE_0xF3, type)) == NFA_STATUS_OK)
-    {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("set EE mode = 0x%X", type);
+#if (NXP_EXTNS == TRUE)
+  if ((nfaStat = SecElem_EeModeSet(EE_HANDLE_0xF3, type)) == NFA_STATUS_OK) {
 #if 0
         if (eeItem.ee_status == NFC_NFCEE_STATUS_INACTIVE)
         {
-            ALOGE("NFA_EeModeSet enable or disable success; status=0x%X", nfaStat);
+            LOG(ERROR) << StringPrintf("NFA_EeModeSet enable or disable success; status=0x%X", nfaStat);
             retval = true;
         }
 #endif
-        /*Mode set on wait for ntf*/
-        if(type)
-        {
-            SyncEventGuard guard (SecureElement::getInstance().mEeSetModeEvent);
-            if(SecureElement::getInstance().mEeSetModeEvent.wait(500) == false)
-            {
-                ALOGE("%s: timeout waiting for setModeNtf", __func__);
-            }
-        }
-    }
-    else
+  } else
 #endif
-    {
-        retval = false;
-        ALOGE("NFA_EeModeSet failed; error=0x%X",nfaStat);
-    }
-    return retval;
+  {
+    retval = false;
+    LOG(ERROR) << StringPrintf("NFA_EeModeSet failed");
+  }
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s stat = 0x%X", __func__, retval);
+  return retval;
 }
 
-
 /*******************************************************************************
 **
 ** Function:        getEeHandleList
@@ -3262,58 +3099,100 @@ bool SecureElement::SecEle_Modeset(uint8_t type)
 ** Returns:         Returns Secure Element list and count.
 **
 *******************************************************************************/
-void SecureElement::getEeHandleList(tNFA_HANDLE *list, uint8_t* count)
-{
-    tNFA_HANDLE handle;
-    int i;
-    static const char fn [] = "SecureElement::getEeHandleList";
-    *count = 0;
-    for ( i = 0; i < mActualNumEe; i++)
-    {
-        ALOGV("%s: %d = 0x%X", fn, i, mEeInfo[i].ee_handle);
-        if ((mEeInfo[i].ee_handle == 0x401) || (mEeInfo[i].ee_interface[0] == NCI_NFCEE_INTERFACE_HCI_ACCESS) ||
-            (mEeInfo[i].ee_status == NFC_NFCEE_STATUS_INACTIVE))
-        {
-            ALOGV("%s: %u = 0x%X", fn, i, mEeInfo[i].ee_handle);
-            ALOGV("0x%x: 0x%x 0x%x 0x%x",mEeInfo[i].ee_handle, mEeInfo[i].num_interface, mEeInfo[i].ee_interface[0], mEeInfo[i].ee_status);
-            continue;
-        }
-
-        handle = mEeInfo[i].ee_handle & ~NFA_HANDLE_GROUP_EE;
-        list[*count] = handle;
-        *count = *count + 1 ;
-        ALOGV("%s: Handle %d = 0x%X", fn, i, handle);
-    }
+void SecureElement::getEeHandleList(tNFA_HANDLE* list, uint8_t* count) {
+  tNFA_HANDLE handle;
+  int i;
+  static const char fn[] = "SecureElement::getEeHandleList";
+  *count = 0;
+  for (i = 0; i < mActualNumEe; i++) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: %d = 0x%X", fn, i, mEeInfo[i].ee_handle);
+    if ((mEeInfo[i].ee_handle == 0x401) ||
+        (mEeInfo[i].ee_interface[0] == NCI_NFCEE_INTERFACE_HCI_ACCESS) ||
+        (mEeInfo[i].ee_status == NFC_NFCEE_STATUS_INACTIVE)) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: %u = 0x%X", fn, i, mEeInfo[i].ee_handle);
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("0x%x: 0x%x 0x%x 0x%x", mEeInfo[i].ee_handle,
+                          mEeInfo[i].num_interface, mEeInfo[i].ee_interface[0],
+                          mEeInfo[i].ee_status);
+      continue;
+    }
+
+    handle = mEeInfo[i].ee_handle & ~NFA_HANDLE_GROUP_EE;
+    list[*count] = handle;
+    *count = *count + 1;
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Handle %d = 0x%X", fn, i, handle);
+  }
 }
 
-bool SecureElement::sendEvent(uint8_t event)
-{
-    tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
-    bool retval = true;
+bool SecureElement::sendEvent(uint8_t event) {
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+  bool retval = true;
 
-    nfaStat = NFA_HciSendEvent (mNfaHciHandle, mNewPipeId, event, 0x00, NULL, 0x00,NULL, 0);
+  nfaStat = NFA_HciSendEvent(mNfaHciHandle, mNewPipeId, event, 0x00, NULL, 0x00,
+                             NULL, 0);
 
-    if(nfaStat != NFA_STATUS_OK)
-        retval = false;
+  if (nfaStat != NFA_STATUS_OK) retval = false;
 
-    return retval;
+  return retval;
 }
 #if (NXP_EXTNS == TRUE)
-bool SecureElement::configureNfceeETSI12()
-{
-    static const char fn [] = "SecureElement::configureNfceeETSI12";
-    ALOGV("%s: enter", fn);
-    tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
-    bool retval = true;
+bool SecureElement::configureNfceeETSI12() {
+  static const char fn[] = "SecureElement::configureNfceeETSI12";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", fn);
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+  bool retval = true;
 
-    nfaStat = NFA_HciConfigureNfceeETSI12();
+  nfaStat = NFA_HciConfigureNfceeETSI12();
 
-    if(nfaStat != NFA_STATUS_OK)
-        retval = false;
+  if (nfaStat != NFA_STATUS_OK) retval = false;
 
-    return retval;
+  return retval;
 }
 
+bool SecureElement::checkPipeStatusAndRecreate() {
+  bool pipeCorrectStatus = false;
+  bool success = true;
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+  se_apdu_gate_info gateInfo = NO_APDU_GATE;
+  uint8_t xmitBuffer[] = {0x00, 0x00, 0x00, 0x00};
+  uint8_t EVT_SEND_DATA = 0x10;
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("checkPipeStatusAndRecreate: Enter");
+  pipeCorrectStatus = NFA_IsPipeStatusNotCorrect();
+  if (pipeCorrectStatus) {
+    gateInfo = getApduGateInfo();
+    if (gateInfo == ETSI_12_APDU_GATE) {
+      pipeStatus = NFA_HCI_ANY_OK;
+      IsCmdsentOnOpenDwpSession = true;
+      SyncEventGuard guard(mPipeStatusCheckEvent);
+
+      nfaStat = NFA_HciSendEvent(mNfaHciHandle, mNewPipeId, EVT_SEND_DATA,
+                                 sizeof(xmitBuffer), xmitBuffer, 0x00, NULL, 0);
+      if (nfaStat == NFA_STATUS_OK) {
+        mPipeStatusCheckEvent.wait(500);
+      }
+      IsCmdsentOnOpenDwpSession = false;
+      if (pipeStatus == NFA_HCI_ANY_E_PIPE_NOT_OPENED) {
+        SyncEventGuard guard(mPipeOpenedEvent);
+        nfaStat = NFA_HciOpenPipe(mNfaHciHandle, mNewPipeId);
+        if (nfaStat != NFA_STATUS_OK) {
+          LOG(ERROR) << StringPrintf(
+              "checkPipeStatusAndRecreate:fail open pipe; error=0x%X", nfaStat);
+        }
+
+        if (!mPipeOpenedEvent.wait(500) || (mCommandStatus != NFA_STATUS_OK)) {
+          success = false;
+        }
+      }
+    }
+  }
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("checkPipeStatusAndRecreate: Exit status x%x", success);
+  return success;
+}
 /*******************************************************************************
 **
 ** Function:        getUiccGateAndPipeList
@@ -3323,46 +3202,50 @@ bool SecureElement::configureNfceeETSI12()
 ** Returns:         Returns valid PipeId(success) or zero(Failure).
 **
 *******************************************************************************/
-uint8_t SecureElement::getUiccGateAndPipeList(uint8_t uiccNo)
-{
-    tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
-    uint8_t pipeId = 0;
-    static const char fn[] = "SecureElement::getUiccGateAndPipeList";
-    ALOGV("%s : get gate, pipe list mNfaHandle = %x ", fn, mNfaHciHandle);
-    /*HCI initialised and secure element available*/
-    if((mNfaHciHandle != NFA_HANDLE_INVALID))
-    {
-        SyncEventGuard guard (mPipeListEvent);
-        nfaStat = NFA_HciGetGateAndPipeList (mNfaHciHandle);
-        if (nfaStat == NFA_STATUS_OK)
-        {
-            mPipeListEvent.wait();
-            if (mHciCfg.status == NFA_STATUS_OK)
-            {
-                for (uint8_t xx = 0; xx < mHciCfg.num_uicc_created_pipes; xx++)
-                {
-                    ALOGV("%s : get gate, pipe list host = 0x%x gate = 0x%x",fn, mHciCfg.pipe[xx].dest_host,
-                            mHciCfg.uicc_created_pipe[xx].dest_gate);
-                    if (mHciCfg.uicc_created_pipe[xx].dest_gate == NFA_HCI_CONNECTIVITY_GATE)
-                    {
-                        ALOGV("%s: found configured gate: 0x%02x  pipe: 0x%02x",fn, mNewSourceGate, mNewPipeId);
-                        if((uiccNo == (EE_HANDLE_0xF4 & ~NFA_HANDLE_GROUP_EE) && mHciCfg.uicc_created_pipe[xx].pipe_id == CONNECTIVITY_PIPE_ID_UICC1) ||
-                            (uiccNo == (EE_HANDLE_0xF8 & ~NFA_HANDLE_GROUP_EE) && mHciCfg.uicc_created_pipe[xx].pipe_id == CONNECTIVITY_PIPE_ID_UICC2))
-                        {
-                            ALOGV("Found the pipeId = %x", mHciCfg.uicc_created_pipe[xx].pipe_id);
-                            pipeId = mHciCfg.uicc_created_pipe[xx].pipe_id;
-                            break;
-                        }
-                    }
-                    else
-                    {
-                        ALOGV("%s : No GatePresent", fn);
-                    }
-                }
+uint8_t SecureElement::getUiccGateAndPipeList(uint8_t uiccNo) {
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+  uint8_t pipeId = 0;
+  static const char fn[] = "SecureElement::getUiccGateAndPipeList";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s : get gate, pipe list mNfaHandle = %x ", fn, mNfaHciHandle);
+  /*HCI initialised and secure element available*/
+  if ((mNfaHciHandle != NFA_HANDLE_INVALID)) {
+    SyncEventGuard guard(mPipeListEvent);
+    nfaStat = NFA_HciGetGateAndPipeList(mNfaHciHandle);
+    if (nfaStat == NFA_STATUS_OK) {
+      mPipeListEvent.wait();
+      if (mHciCfg.status == NFA_STATUS_OK) {
+        for (uint8_t xx = 0; xx < mHciCfg.num_uicc_created_pipes; xx++) {
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "%s : get gate, pipe list host = 0x%x gate = 0x%x", fn,
+              mHciCfg.pipe[xx].dest_host,
+              mHciCfg.uicc_created_pipe[xx].dest_gate);
+          if (mHciCfg.uicc_created_pipe[xx].dest_gate ==
+              NFA_HCI_CONNECTIVITY_GATE) {
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+                "%s: found configured gate: 0x%02x  pipe: 0x%02x", fn,
+                mNewSourceGate, mNewPipeId);
+            if ((uiccNo == (EE_HANDLE_0xF4 & ~NFA_HANDLE_GROUP_EE) &&
+                 mHciCfg.uicc_created_pipe[xx].pipe_id ==
+                     CONNECTIVITY_PIPE_ID_UICC1) ||
+                (uiccNo == (EE_HANDLE_0xF8 & ~NFA_HANDLE_GROUP_EE) &&
+                 mHciCfg.uicc_created_pipe[xx].pipe_id ==
+                     CONNECTIVITY_PIPE_ID_UICC2)) {
+              DLOG_IF(INFO, nfc_debug_enabled)
+                  << StringPrintf("Found the pipeId = %x",
+                                  mHciCfg.uicc_created_pipe[xx].pipe_id);
+              pipeId = mHciCfg.uicc_created_pipe[xx].pipe_id;
+              break;
             }
+          } else {
+            DLOG_IF(INFO, nfc_debug_enabled)
+                << StringPrintf("%s : No GatePresent", fn);
+          }
         }
+      }
     }
-    return pipeId;
+  }
+  return pipeId;
 }
 /*******************************************************************************
 **
@@ -3373,60 +3256,56 @@ uint8_t SecureElement::getUiccGateAndPipeList(uint8_t uiccNo)
 ** Returns:         Returns valid PipeId(success) or zero(Failure).
 **
 *******************************************************************************/
-tNFA_HANDLE SecureElement::getHciHandleInfo()
-{
-    return mNfaHciHandle;
-}
+tNFA_HANDLE SecureElement::getHciHandleInfo() { return mNfaHciHandle; }
 /*******************************************************************************
 **
 ** Function:        eSE_ClearAllPipe_thread_handler
 **
-** Description:     Upon receiving the Clear ALL pipes take lock and start polling
+** Description:     Upon receiving the Clear ALL pipes take lock and start
+*polling
 **
 ** Returns:         void.
 **
 *******************************************************************************/
-void *eSE_ClearAllPipe_thread_handler(void *data)
-{
-    static const char fn [] = "eSE_ClearAllPipe_thread_handler";
-    uint8_t *host = NULL, nfcee_type = 0;
-    SecureElement &se = SecureElement::getInstance();
-    ALOGV("%s: enter:", fn);
-    if(NULL == data)
-    {
-        ALOGE("%s: Invalid argument", fn);
-        return NULL;
-    }
-    /*Nfc initialization not completed*/
-    if(sNfcee_disc_state < UICC_SESSION_INTIALIZATION_DONE)
-    {
-        ALOGV("eSE_ClearAllPipe_thread_handler PENDING return");
-        sNfcee_disc_state = UICC_CLEAR_ALL_PIPE_NTF_RECEIVED;
-        return NULL;
-    }
-    ALOGV("eSE_ClearAllPipe_thread_handler state NFCEE_STATE_DISCOVERED");
-    /* Copying the host-id from the parent thread and freeing allocated space */
-    host = (uint8_t *) data;
-    nfcee_type = *host;
-    free(data);
-
-    SyncEventGuard guard (se.mNfceeInitCbEvent);
-    switch(nfcee_type)
-    {
-        case 0x02:
-        case 0x80:
-            /* Poll for UICC1 session */
-            android ::checkforNfceeConfig(UICC1|UICC2);
-            break;
-        case 0x81:
-            /* Poll for UICC2 session */
-            android ::checkforNfceeConfig(UICC1|UICC2);
-            break;
-        default:
-            break;
-    }
-    se.mNfceeInitCbEvent.notifyOne();
+void* eSE_ClearAllPipe_thread_handler(void* data) {
+  static const char fn[] = "eSE_ClearAllPipe_thread_handler";
+  uint8_t *host = NULL, nfcee_type = 0;
+  SecureElement& se = SecureElement::getInstance();
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter:", fn);
+  if (NULL == data) {
+    LOG(ERROR) << StringPrintf("%s: Invalid argument", fn);
+    return NULL;
+  }
+  /*Nfc initialization not completed*/
+  if (sNfcee_disc_state < UICC_SESSION_INTIALIZATION_DONE) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("eSE_ClearAllPipe_thread_handler PENDING return");
+    sNfcee_disc_state = UICC_CLEAR_ALL_PIPE_NTF_RECEIVED;
     return NULL;
+  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "eSE_ClearAllPipe_thread_handler state NFCEE_STATE_DISCOVERED");
+  /* Copying the host-id from the parent thread and freeing allocated space */
+  host = (uint8_t*)data;
+  nfcee_type = *host;
+  free(data);
+
+  SyncEventGuard guard(se.mNfceeInitCbEvent);
+  switch (nfcee_type) {
+    case 0x02:
+    case 0x80:
+      /* Poll for UICC1 session */
+      android::checkforNfceeConfig(UICC1 | UICC2);
+      break;
+    case 0x81:
+      /* Poll for UICC2 session */
+      android::checkforNfceeConfig(UICC1 | UICC2);
+      break;
+    default:
+      break;
+  }
+  se.mNfceeInitCbEvent.notifyOne();
+  return NULL;
 }
 
 /*******************************************************************************
@@ -3438,13 +3317,12 @@ void *eSE_ClearAllPipe_thread_handler(void *data)
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-bool SecureElement::initializeEeHandle ()
-{
-    if(NFA_GetNCIVersion() == NCI_VERSION_2_0)
-        EE_HANDLE_0xF4 = 0x480;
-    else
-        EE_HANDLE_0xF4 = 0x402;
-    return true;
+bool SecureElement::initializeEeHandle() {
+  if (NFA_GetNCIVersion() == NCI_VERSION_2_0)
+    EE_HANDLE_0xF4 = 0x480;
+  else
+    EE_HANDLE_0xF4 = 0x402;
+  return true;
 }
 /*******************************************************************************
 **
@@ -3456,33 +3334,26 @@ bool SecureElement::initializeEeHandle ()
 ** Returns:         void.
 **
 *******************************************************************************/
-void SecureElement::eSE_ClearAllPipe_handler(uint8_t host)
-{
-
-    static const char fn [] = "SecureElement::eSE_ClearAllPipe_handler";
-    pthread_t thread;
-    pthread_attr_t attr;
-    pthread_attr_init(&attr);
-    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-    uint8_t *host_id = (uint8_t *) malloc(sizeof(uint8_t));
-    *host_id = host;
-    ALOGE("%s; Enter", fn);
-    if (pthread_create (&thread, &attr,  &eSE_ClearAllPipe_thread_handler, (void*)host_id) < 0)
-    {
-        ALOGV("Thread creation failed");
-    }
-    else
-    {
-        ALOGV("Thread creation success");
-    }
-    pthread_attr_destroy(&attr);
-
+void SecureElement::eSE_ClearAllPipe_handler(uint8_t host) {
+  static const char fn[] = "SecureElement::eSE_ClearAllPipe_handler";
+  pthread_t thread;
+  pthread_attr_t attr;
+  pthread_attr_init(&attr);
+  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+  uint8_t* host_id = (uint8_t*)malloc(sizeof(uint8_t));
+  *host_id = host;
+  LOG(ERROR) << StringPrintf("%s; Enter", fn);
+  if (pthread_create(&thread, &attr, &eSE_ClearAllPipe_thread_handler,
+                     (void*)host_id) < 0) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Thread creation failed");
+  } else {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Thread creation success");
+  }
+  pthread_attr_destroy(&attr);
 }
-
 #endif
 
-
-#if(NXP_EXTNS == TRUE)
+#if (NXP_EXTNS == TRUE)
 /*******************************************************************************
 **
 ** Function         NfccStandByTimerOperation
@@ -3492,178 +3363,195 @@ void SecureElement::eSE_ClearAllPipe_handler(uint8_t host)
 ** Returns          void
 **
 *******************************************************************************/
-void SecureElement::NfccStandByOperation(nfcc_standby_operation_t value)
-{
-    if(!nfcFL.nfcNxpEse) {
-        ALOGV("%s  nfcNxpEse not available. Returning",__func__);
-        return;
-    }
-    static IntervalTimer   mNFCCStandbyModeTimer; // timer to enable standby mode for NFCC
-    tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
-    bool stat = false;
-    mNfccStandbyMutex.lock();
-    ALOGV("In SecureElement::NfccStandByOperation value = %d, state = %d", value, standby_state);
-    switch(value)
-    {
+void SecureElement::NfccStandByOperation(nfcc_standby_operation_t value) {
+  if (!nfcFL.nfcNxpEse) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s  nfcNxpEse not available. Returning", __func__);
+    return;
+  }
+  static IntervalTimer
+      mNFCCStandbyModeTimer;  // timer to enable standby mode for NFCC
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+  bool stat = false;
+  mNfccStandbyMutex.lock();
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "In SecureElement::NfccStandByOperation value = %d, state = %d", value,
+      standby_state);
+  switch (value) {
     case STANDBY_TIMER_START:
-        standby_state = STANDBY_MODE_TIMER_ON;
-        if(nfccStandbytimeout > 0)
-        {
-            mNFCCStandbyModeTimer.set(nfccStandbytimeout , NFCC_StandbyModeTimerCallBack );
-        }
-        break;
-    case STANDBY_MODE_OFF:
-    {
-        if(nfcFL.eseFL._WIRED_MODE_STANDBY) {
-            if(standby_state == STANDBY_MODE_SUSPEND) {
-                if(mNfccPowerMode == 1) {
-                    nfaStat = setNfccPwrConfig(POWER_ALWAYS_ON|COMM_LINK_ACTIVE);
-                    if(nfaStat != NFA_STATUS_OK) {
-                        ALOGV("%s: power link command failed", __func__);
-                        break;
-                    } else {
-                        SecEle_Modeset(0x01);
-                    }
-                }
-            }
-        }
-    }// this is to handle stop timer also.
-    case STANDBY_TIMER_STOP:
-        {
-            if(nfccStandbytimeout > 0)
-                mNFCCStandbyModeTimer.kill();
-        }
-        standby_state = STANDBY_MODE_OFF;
-        if(spiDwpSyncState & STATE_DWP_CLOSE) {
-            spiDwpSyncState ^= STATE_DWP_CLOSE;
-        }
-    break;
-    case STANDBY_MODE_ON:
-    {
-        if(nfcFL.eseFL._WIRED_MODE_STANDBY_PROP) {
-            if(standby_state == STANDBY_MODE_ON)
-                break;
-            else if(nfccStandbytimeout > 0)
-                mNFCCStandbyModeTimer.kill();
-        }
-        if(nfcFL.eseFL._WIRED_MODE_STANDBY)
-            if(nfccStandbytimeout > 0)
-                mNFCCStandbyModeTimer.kill();
-
-        if (nfcFL.eseFL._WIRED_MODE_STANDBY) {
-            if (nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE) {
-                /*To maintain dwp standby mode on case when spi is close later*/
-                spiDwpSyncState = STATE_IDLE;
-            if(dual_mode_current_state & SPI_ON)
-            {
-                ALOGV("%s: SPI is ON-StandBy not allowed", __func__);
-                standby_state = STANDBY_MODE_ON;
-                /*To maintain wired session close state during SPI on*/
-                spiDwpSyncState = STATE_DWP_CLOSE;
-                break;
-            }
-            nfaStat = setNfccPwrConfig(NFCC_DECIDES);
-            stat = SecureElement::getInstance().sendEvent(SecureElement::EVT_END_OF_APDU_TRANSFER);
-            if(stat)
-            {
-                standby_state = STANDBY_MODE_ON;
-                ALOGV("%s sending standby mode command EVT_END_OF_APDU_TRANSFER successful", __func__);
+      standby_state = STANDBY_MODE_TIMER_ON;
+      if (nfccStandbytimeout > 0) {
+        mNFCCStandbyModeTimer.set(nfccStandbytimeout,
+                                  NFCC_StandbyModeTimerCallBack);
+      }
+      break;
+    case STANDBY_MODE_OFF: {
+      if (nfcFL.eseFL._WIRED_MODE_STANDBY) {
+        if (standby_state == STANDBY_MODE_SUSPEND) {
+          if ((mNfccPowerMode == 1) && !(dual_mode_current_state & SPI_ON)) {
+            nfaStat = setNfccPwrConfig(POWER_ALWAYS_ON | COMM_LINK_ACTIVE);
+            if (nfaStat != NFA_STATUS_OK) {
+              DLOG_IF(INFO, nfc_debug_enabled)
+                  << StringPrintf("%s: power link command failed", __func__);
+              break;
+            } else {
+              SecEle_Modeset(0x01);
             }
-        }
-    }
-}
-    if(nfcFL.eseFL._WIRED_MODE_STANDBY == true)
-        break;
-    case STANDBY_TIMER_TIMEOUT:
-    {
-        bool stat = false;
+          }
+        }
+      }
+    }  // this is to handle stop timer also.
+    case STANDBY_TIMER_STOP: {
+      if (nfccStandbytimeout > 0) mNFCCStandbyModeTimer.kill();
+    }
+      standby_state = STANDBY_MODE_OFF;
+      if (spiDwpSyncState & STATE_DWP_CLOSE) {
+        spiDwpSyncState ^= STATE_DWP_CLOSE;
+      }
+      break;
+    case STANDBY_MODE_ON: {
+      if (nfcFL.eseFL._WIRED_MODE_STANDBY_PROP) {
+        if (standby_state == STANDBY_MODE_ON)
+          break;
+        else if (nfccStandbytimeout > 0)
+          mNFCCStandbyModeTimer.kill();
+      }
+      if (nfcFL.eseFL._WIRED_MODE_STANDBY)
+        if (nfccStandbytimeout > 0) mNFCCStandbyModeTimer.kill();
+
+      if (nfcFL.eseFL._WIRED_MODE_STANDBY) {
         if (nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE) {
-            if (nfcFL.eseFL._WIRED_MODE_STANDBY) {
-                /*Maintain suspend apdu state to send when spi is closed later*/
-                spiDwpSyncState |= STATE_TIME_OUT;
-        /*Clear apdu state to activate DWP link once spi stand-alone triggered */
-        if(spiDwpSyncState & STATE_WK_ENBLE)
-        {
+          /*To maintain dwp standby mode on case when spi is close later*/
+          spiDwpSyncState = STATE_IDLE;
+          if (dual_mode_current_state & SPI_ON) {
+            DLOG_IF(INFO, nfc_debug_enabled)
+                << StringPrintf("%s: SPI is ON-StandBy not allowed", __func__);
+            standby_state = STANDBY_MODE_ON;
+            /*To maintain wired session close state during SPI on*/
+            spiDwpSyncState = STATE_DWP_CLOSE;
+            break;
+          }
+          nfaStat = setNfccPwrConfig(NFCC_DECIDES);
+          stat = SecureElement::getInstance().sendEvent(
+              SecureElement::EVT_END_OF_APDU_TRANSFER);
+          if (stat) {
+            standby_state = STANDBY_MODE_ON;
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+                "%s sending standby mode command EVT_END_OF_APDU_TRANSFER "
+                "successful",
+                __func__);
+          }
+        }
+      }
+    }
+      if (nfcFL.eseFL._WIRED_MODE_STANDBY == true) break;
+    case STANDBY_TIMER_TIMEOUT: {
+      bool stat = false;
+      if (nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE) {
+        if (nfcFL.eseFL._WIRED_MODE_STANDBY) {
+          /*Maintain suspend apdu state to send when spi is closed later*/
+          spiDwpSyncState |= STATE_TIME_OUT;
+          /*Clear apdu state to activate DWP link once spi stand-alone triggered
+           */
+          if (spiDwpSyncState & STATE_WK_ENBLE) {
             spiDwpSyncState ^= STATE_WK_ENBLE;
-        }
-    }
-    if(dual_mode_current_state & SPI_ON)
-    {
-        ALOGV("%s: SPI is ON-StandBy not allowed", __func__);
-        standby_state = STANDBY_MODE_ON;
-        mNfccStandbyMutex.unlock();
-        return;
-    }
-    }
-        if(nfcFL.eseFL._WIRED_MODE_STANDBY == true) {
-            if(standby_state != STANDBY_MODE_TIMER_ON) {
-                ALOGV("%s the timer must be stopped by next atr/transceive, ignoring timeout", __func__);
-                break;
-            }
-        }
-    if(nfcFL.eseFL._WIRED_MODE_STANDBY_PROP)
-        /*Send the EVT_END_OF_APDU_TRANSFER  after the transceive timer timed out*/
-        stat = SecureElement::getInstance().sendEvent(SecureElement::EVT_END_OF_APDU_TRANSFER);
-    if (nfcFL.eseFL._WIRED_MODE_STANDBY) {
+          }
+        }
+        if (dual_mode_current_state & SPI_ON) {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("%s: SPI is ON-StandBy not allowed", __func__);
+          standby_state = STANDBY_MODE_ON;
+          mNfccStandbyMutex.unlock();
+          return;
+        }
+      }
+      if (nfcFL.eseFL._WIRED_MODE_STANDBY == true) {
+        if (standby_state != STANDBY_MODE_TIMER_ON) {
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "%s the timer must be stopped by next atr/transceive, ignoring "
+              "timeout",
+              __func__);
+          break;
+        }
+      }
+      if (nfcFL.eseFL._WIRED_MODE_STANDBY_PROP)
+        /*Send the EVT_END_OF_APDU_TRANSFER  after the transceive timer timed
+         * out*/
+        stat = SecureElement::getInstance().sendEvent(
+            SecureElement::EVT_END_OF_APDU_TRANSFER);
+      if (nfcFL.eseFL._WIRED_MODE_STANDBY) {
         setNfccPwrConfig(POWER_ALWAYS_ON);
-        stat = SecureElement::getInstance().sendEvent(SecureElement::EVT_SUSPEND_APDU_TRANSFER);
-    }
-        if(stat)
-        {
-            standby_state = STANDBY_MODE_SUSPEND;
-            ALOGV("%s sending standby command successful", __func__);
-            if (nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE && nfcFL.eseFL._WIRED_MODE_STANDBY_PROP)
-                spiDwpSyncState = STATE_IDLE;
-        }
-    }
-    break;
-    case STANDBY_GPIO_HIGH:
-    {
-        jint ret_val = -1;
-        NFCSTATUS status = NFCSTATUS_FAILED;
-
-        /* Set the ESE VDD gpio to high to make sure P61 is powered, even if NFCC
-         * is in standby
-         */
-        ret_val = NFC_EnableWired ((void *)&status);
-        if (ret_val < 0)
-        {
-            ALOGV("NFC_EnableWired failed");
-        }
-        else
-        {
-             if (status != NFCSTATUS_SUCCESS)
-             {
-                 ALOGV("SE is being used by SPI");
-             }
-        }
-    }
-    break;
-    case STANDBY_GPIO_LOW:
-    {
-        jint ret_val = -1;
-        NFCSTATUS status = NFCSTATUS_FAILED;
-        /* Set the ESE VDD gpio to low to make sure P61 is reset. */
-        ret_val = NFC_DisableWired ((void *)&status);
-        if (ret_val < 0)
-        {
-            ALOGV("NFC_DisableWired failed");
-        }
-        else
-        {
-            if (status != NFCSTATUS_SUCCESS)
-            {
-                ALOGV("SE is not being released by Pn54x driver");
-            }
-        }
-    }
-    break;
+        stat = SecureElement::getInstance().sendEvent(
+            SecureElement::EVT_SUSPEND_APDU_TRANSFER);
+      }
+      if (stat) {
+        standby_state = STANDBY_MODE_SUSPEND;
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s sending standby command successful", __func__);
+        if (nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE &&
+            nfcFL.eseFL._WIRED_MODE_STANDBY_PROP)
+          spiDwpSyncState = STATE_IDLE;
+      }
+    } break;
+    case STANDBY_GPIO_HIGH: {
+      jint ret_val = -1;
+      NFCSTATUS status = NFCSTATUS_FAILED;
+
+      /* Set the ESE VDD gpio to high to make sure P61 is powered, even if NFCC
+       * is in standby
+       */
+      ret_val = NFC_EnableWired((void*)&status);
+      if (ret_val < 0) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("NFC_EnableWired failed");
+      } else {
+        if (status != NFCSTATUS_SUCCESS) {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("SE is being used by SPI");
+        }
+      }
+    } break;
+    case STANDBY_GPIO_LOW: {
+      jint ret_val = -1;
+      NFCSTATUS status = NFCSTATUS_FAILED;
+      /* Set the ESE VDD gpio to low to make sure P61 is reset. */
+      ret_val = NFC_DisableWired((void*)&status);
+      if (ret_val < 0) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("NFC_DisableWired failed");
+      } else {
+        if (status != NFCSTATUS_SUCCESS) {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("SE is not being released by Pn54x driver");
+        }
+      }
+    } break;
+    case STANDBY_ESE_PWR_RELEASE: {
+      int ret_val = -1;
+      tNFA_STATUS status = NFCSTATUS_FAILED;
+      /* Set the ESE VDD gpio to HIGH. */
+      ret_val = NFC_ReleaseEsePwr((void*)&status);
+      if (ret_val < 0) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("NFC_ReleaseEsePwr: Failed");
+      }
+    } break;
+
+    case STANDBY_ESE_PWR_ACQUIRE: {
+      int ret_val = -1;
+      tNFA_STATUS status = NFCSTATUS_FAILED;
+      /* Set the ESE VDD gpio to low. */
+      ret_val = NFC_AcquireEsePwr((void*)&status);
+      if (ret_val < 0) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("NFC_AcquireEsePwr: Failed");
+      }
+    } break;
     default:
-        ALOGE("Wrong param");
-    break;
-
-    }
-    mNfccStandbyMutex.unlock();
+      LOG(ERROR) << StringPrintf("Wrong param");
+      break;
+  }
+  mNfccStandbyMutex.unlock();
 }
 /*******************************************************************************
 **
@@ -3674,27 +3562,23 @@ void SecureElement::NfccStandByOperation(nfcc_standby_operation_t value)
 ** Returns          Returns Status SUCCESS or FAILED.
 **
 *******************************************************************************/
-NFCSTATUS SecureElement::eSE_Chip_Reset(void)
-{
-    jint ret_val = -1;
-    NFCSTATUS status = NFCSTATUS_FAILED;
-    ALOGV("eSE_Chip_Reset");
-    SecureElement::getInstance().SecEle_Modeset(0x00);
-    /* Reset P73 using ISO Reset Pin. */
-    ret_val = NFC_eSEChipReset ((void *)&status);
-    if (ret_val < 0)
-    {
-        ALOGV("Reset eSE failed");
-    }
-    else
-    {
-        if (status != NFCSTATUS_SUCCESS)
-        {
-            ALOGV("SE is not being released by Pn54x driver");
-        }
-    }
-    SecureElement::getInstance().SecEle_Modeset(0x01);
-    return status;
+NFCSTATUS SecureElement::eSE_Chip_Reset(void) {
+  jint ret_val = -1;
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("eSE_Chip_Reset");
+  SecureElement::getInstance().SecEle_Modeset(0x00);
+  /* Reset P73 using ISO Reset Pin. */
+  ret_val = NFC_eSEChipReset((void*)&status);
+  if (ret_val < 0) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Reset eSE failed");
+  } else {
+    if (status != NFCSTATUS_SUCCESS) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("SE is not being released by Pn54x driver");
+    }
+  }
+  SecureElement::getInstance().SecEle_Modeset(0x01);
+  return status;
 }
 
 /*******************************************************************************
@@ -3706,343 +3590,232 @@ NFCSTATUS SecureElement::eSE_Chip_Reset(void)
 ** Returns:         Returns Status SUCCESS or FAILED.
 **
 *******************************************************************************/
-tNFA_STATUS SecureElement::reconfigureEseHciInit()
-{
-    tNFA_STATUS status = NFA_STATUS_FAILED;
-    if(!nfcFL.eseFL._JCOP_WA_ENABLE) {
-        ALOGV("reconfigureEseHciInit JCOP_WA_ENABLE not found. Returning");
-        return status;
-    }
-
-    if (isActivatedInListenMode()) {
-        ALOGV("Denying HCI re-initialization due to SE listen mode active");
-        return status;
-    }
-
-    if (isRfFieldOn()) {
-        ALOGV("Denying HCI re-initialization due to SE in active RF field");
-        return status;
-    }
-    if(android::isDiscoveryStarted() == true)
-    {
-        android::startRfDiscovery(false);
-    }
-    status = android::ResetEseSession();
-    if(status == NFA_STATUS_OK)
-    {
-        SecEle_Modeset(0x00);
-        usleep(100 * 1000);
+tNFA_STATUS SecureElement::reconfigureEseHciInit() {
+  tNFA_STATUS status = NFA_STATUS_FAILED;
+  if (!nfcFL.eseFL._JCOP_WA_ENABLE) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "reconfigureEseHciInit JCOP_WA_ENABLE not found. Returning");
+    return status;
+  }
 
-        SecEle_Modeset(0x01);
-        usleep(300 * 1000);
-    }
+  if (isActivatedInListenMode()) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "Denying HCI re-initialization due to SE listen mode active");
+    return status;
+  }
 
-    android::startRfDiscovery(true);
+  if (isRfFieldOn()) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "Denying HCI re-initialization due to SE in active RF field");
     return status;
+  }
+  if (android::isDiscoveryStarted() == true) {
+    android::startRfDiscovery(false);
+  }
+  status = android::ResetEseSession();
+  if (status == NFA_STATUS_OK) {
+    SecEle_Modeset(0x00);
+    usleep(100 * 1000);
+
+    SecEle_Modeset(0x01);
+    usleep(300 * 1000);
+  }
+
+  android::startRfDiscovery(true);
+  return status;
 }
 
-se_apdu_gate_info SecureElement::getApduGateInfo()
-{
-    tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
-    se_apdu_gate_info ret = NO_APDU_GATE;
-
-    ALOGV("getApduGateInfo : get gate, pipe list");
-    /*HCI initialised and secure element available*/
-    if((mNfaHciHandle != NFA_HANDLE_INVALID) && (mActiveEeHandle != NFA_HANDLE_INVALID))
-    {
-        SyncEventGuard guard (mPipeListEvent);
-        nfaStat = NFA_HciGetGateAndPipeList (mNfaHciHandle);
-        if (nfaStat == NFA_STATUS_OK)
-        {
-            mPipeListEvent.wait();
-            if (mHciCfg.status == NFA_STATUS_OK)
-            {
-                for (uint8_t xx = 0; xx < mHciCfg.num_pipes; xx++)
-                {
-                    ALOGV("getApduGateInfo : get gate, pipe list host = 0x%x gate = 0x%x", mHciCfg.pipe[xx].dest_host,
-                            mHciCfg.pipe[xx].dest_gate);
-                    if ( (mHciCfg.pipe[xx].dest_host == (EE_HANDLE_0xF3 & ~NFA_HANDLE_GROUP_EE)) && (mHciCfg.pipe[xx].dest_gate == NFA_HCI_ETSI12_APDU_GATE) )
-                    {
-                        ret = ETSI_12_APDU_GATE;
-                        ALOGV("getApduGateInfo: found configured gate: 0x%02x  pipe: 0x%02x", mNewSourceGate, mNewPipeId);
-                        break;
-                    }
-                    else if( (mHciCfg.pipe[xx].dest_host == (EE_HANDLE_0xF3 & ~NFA_HANDLE_GROUP_EE)) && (mHciCfg.pipe[xx].dest_gate == 0xF0) )
-                    {
-                        ret = PROPREITARY_APDU_GATE;
-                        ALOGV("propreitary ApduGatePresent: found configured gate: 0x%02x  pipe: 0x%02x", mNewSourceGate, mNewPipeId);
-                        break;
-                    }
-                    else
-                    {
-                        ALOGV("No ApduGatePresent");
-                    }
-                }
-            }
+se_apdu_gate_info SecureElement::getApduGateInfo() {
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+  se_apdu_gate_info ret = NO_APDU_GATE;
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("getApduGateInfo : get gate, pipe list");
+  /*HCI initialised and secure element available*/
+  if ((mNfaHciHandle != NFA_HANDLE_INVALID) &&
+      (mActiveEeHandle != NFA_HANDLE_INVALID)) {
+    SyncEventGuard guard(mPipeListEvent);
+    nfaStat = NFA_HciGetGateAndPipeList(mNfaHciHandle);
+    if (nfaStat == NFA_STATUS_OK) {
+      mPipeListEvent.wait();
+      if (mHciCfg.status == NFA_STATUS_OK) {
+        for (uint8_t xx = 0; xx < mHciCfg.num_pipes; xx++) {
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "getApduGateInfo : get gate, pipe list host = 0x%x gate = 0x%x",
+              mHciCfg.pipe[xx].dest_host, mHciCfg.pipe[xx].dest_gate);
+          if ((mHciCfg.pipe[xx].dest_host ==
+               (EE_HANDLE_0xF3 & ~NFA_HANDLE_GROUP_EE)) &&
+              (mHciCfg.pipe[xx].dest_gate == NFA_HCI_ETSI12_APDU_GATE)) {
+            ret = ETSI_12_APDU_GATE;
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+                "getApduGateInfo: found configured gate: 0x%02x  pipe: 0x%02x",
+                mNewSourceGate, mNewPipeId);
+            break;
+          } else if ((mHciCfg.pipe[xx].dest_host ==
+                      (EE_HANDLE_0xF3 & ~NFA_HANDLE_GROUP_EE)) &&
+                     (mHciCfg.pipe[xx].dest_gate == 0xF0)) {
+            ret = PROPREITARY_APDU_GATE;
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+                "propreitary ApduGatePresent: found configured gate: 0x%02x  "
+                "pipe: 0x%02x",
+                mNewSourceGate, mNewPipeId);
+            break;
+          } else {
+            DLOG_IF(INFO, nfc_debug_enabled)
+                << StringPrintf("No ApduGatePresent");
+          }
         }
+      }
     }
-    return ret;
+  }
+  return ret;
 }
 
-bool SecureElement::checkForWiredModeAccess()
-{
-    static const char fn[] = "checkForWiredModeAccess";
-    bool status = true;
-    ALOGV("%s; enter", fn);
-
-    if(mIsExclusiveWiredMode)
-    {
-        if(mIsWiredModeOpen)
-        {
-            return status;
-        }
-        if(android::isp2pActivated()||isActivatedInListenMode()||isRfFieldOn())
-        {
-            status = false;
-            return status;
-        }
-    }
-    else
-    {
-        if(mIsWiredModeBlocked)
-        {
-             hold_wired_mode = true;
-             SyncEventGuard guard (mWiredModeHoldEvent);
-             mWiredModeHoldEvent.wait();
-             status = true;
-             return status;
-        }
-        else
-        {
-            status = true;
-            return status;
-        }
+bool SecureElement::checkForWiredModeAccess() {
+  static const char fn[] = "checkForWiredModeAccess";
+  bool status = true;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s; enter", fn);
+
+  if (mIsExclusiveWiredMode) {
+    if (mIsWiredModeOpen) {
+      return status;
+    }
+    if (android::isp2pActivated() || isActivatedInListenMode() ||
+        isRfFieldOn()) {
+      status = false;
+      return status;
+    }
+  } else {
+    if (mIsWiredModeBlocked) {
+      hold_wired_mode = true;
+      SyncEventGuard guard(mWiredModeHoldEvent);
+      mWiredModeHoldEvent.wait();
+      status = true;
+      return status;
+    } else {
+      status = true;
+      return status;
     }
-    ALOGV("%s; status:%d  ",fn, status);
-    return status;
+  }
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s; status:%d  ", fn, status);
+  return status;
 }
 #endif
-/*******************************************************************************
-**
-** Function:        etsiInitConfig
-**
-** Description:     Chnage the ETSI state before start configuration
-**
-** Returns:         None
-**
-*******************************************************************************/
-void SecureElement::etsiInitConfig()
-{
-    if(!nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
-        ALOGV("%s: ETSI_READER not available. Returning", __func__);
-        return;
-    }
-
-    ALOGV("%s: Enter", __func__);
-    swp_rdr_req_ntf_info.mMutex.lock();
 
-    if((swp_rdr_req_ntf_info.swp_rd_state == STATE_SE_RDR_MODE_START_CONFIG) &&
-      ((swp_rdr_req_ntf_info.swp_rd_req_info.tech_mask & NFA_TECHNOLOGY_MASK_A) ||
-      (swp_rdr_req_ntf_info.swp_rd_req_info.tech_mask & NFA_TECHNOLOGY_MASK_B)))
-    {
-        if((swp_rdr_req_ntf_info.swp_rd_req_info.tech_mask & NFA_TECHNOLOGY_MASK_A))
-        {
-            swp_rdr_req_ntf_info.swp_rd_req_current_info.tech_mask |= NFA_TECHNOLOGY_MASK_A;
-        }
-
-        if((swp_rdr_req_ntf_info.swp_rd_req_info.tech_mask & NFA_TECHNOLOGY_MASK_B))
-        {
-            swp_rdr_req_ntf_info.swp_rd_req_current_info.tech_mask |= NFA_TECHNOLOGY_MASK_B;
-        }
-
-        swp_rdr_req_ntf_info.swp_rd_req_current_info.src = swp_rdr_req_ntf_info.swp_rd_req_info.src;
-        swp_rdr_req_ntf_info.swp_rd_state = STATE_SE_RDR_MODE_START_IN_PROGRESS;
-        ALOGV("%s: new ETSI state : STATE_SE_RDR_MODE_START_IN_PROGRESS", __func__);
-    }
-    else if((swp_rdr_req_ntf_info.swp_rd_state == STATE_SE_RDR_MODE_STOP_CONFIG) &&
-            (swp_rdr_req_ntf_info.swp_rd_req_current_info.src == swp_rdr_req_ntf_info.swp_rd_req_info.src))
-    {
-        pTransactionController->transactionEnd(TRANSACTION_REQUESTOR(etsiReader));
-        swp_rdr_req_ntf_info.swp_rd_state = STATE_SE_RDR_MODE_STOP_IN_PROGRESS;
-        ALOGV("%s: new ETSI state : STATE_SE_RDR_MODE_STOP_IN_PROGRESS", __func__);
+int SecureElement::decodeBerTlvLength(uint8_t* data, int index,
+                                      int data_length) {
+  int decoded_length = -1;
+  int length = 0;
+  int temp = data[index] & 0xff;
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "decodeBerTlvLength index= %d data[index+0]=0x%x data[index+1]=0x%x "
+      "len=%d",
+      index, data[index], data[index + 1], data_length);
+
+  if (temp < 0x80) {
+    decoded_length = temp;
+  } else if (temp == 0x81) {
+    if (index < data_length) {
+      length = data[index + 1] & 0xff;
+      if (length < 0x80) {
+        LOG(ERROR) << StringPrintf("Invalid TLV length encoding!");
+        goto TheEnd;
+      }
+      if (data_length < length + index) {
+        LOG(ERROR) << StringPrintf("Not enough data provided!");
+        goto TheEnd;
+      }
+    } else {
+      LOG(ERROR) << StringPrintf("Index %d out of range! [0..[%d", index,
+                                 data_length);
+      goto TheEnd;
+    }
+    decoded_length = length;
+  } else if (temp == 0x82) {
+    if ((index + 1) < data_length) {
+      length = ((data[index] & 0xff) << 8) | (data[index + 1] & 0xff);
+    } else {
+      LOG(ERROR) << StringPrintf("Index out of range! [0..[%d", data_length);
+      goto TheEnd;
+    }
+    index += 2;
+    if (length < 0x100) {
+      LOG(ERROR) << StringPrintf("Invalid TLV length encoding!");
+      goto TheEnd;
+    }
+    if (data_length < length + index) {
+      LOG(ERROR) << StringPrintf("Not enough data provided!");
+      goto TheEnd;
+    }
+    decoded_length = length;
+  } else if (temp == 0x83) {
+    if ((index + 2) < data_length) {
+      length = ((data[index] & 0xff) << 16) | ((data[index + 1] & 0xff) << 8) |
+               (data[index + 2] & 0xff);
+    } else {
+      LOG(ERROR) << StringPrintf("Index out of range! [0..[%d", data_length);
+      goto TheEnd;
+    }
+    index += 3;
+    if (length < 0x10000) {
+      LOG(ERROR) << StringPrintf("Invalid TLV length encoding!");
+      goto TheEnd;
+    }
+    if (data_length < length + index) {
+      LOG(ERROR) << StringPrintf("Not enough data provided!");
+      goto TheEnd;
+    }
+    decoded_length = length;
+  } else {
+    LOG(ERROR) << StringPrintf("Unsupported TLV length encoding!");
+  }
+TheEnd:
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("decoded_length = %d", decoded_length);
 
-    }
-    swp_rdr_req_ntf_info.mMutex.unlock();
+  return decoded_length;
 }
+#if (NXP_EXTNS == TRUE)
+void cleanupStack(void* p) { return; }
 
 /*******************************************************************************
 **
-** Function:        etsiReaderConfig
+** Function:       spiEventHandlerThread_cleanup_handler
 **
-** Description:     Configuring to Emvco Profile
+** Description:    Handler to cleanup before the spiEventHandler Thread exits
 **
-** Returns:         Status
+**
+** Returns:        None .
 **
 *******************************************************************************/
-tNFC_STATUS SecureElement::etsiReaderConfig(int eeHandle)
-{
-    if(!nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
-        ALOGV("%s: ETSI_READER not available. Returning", __func__);
-        return NFA_STATUS_FAILED;
-    }
-    tNFC_STATUS status;
-
-    ALOGV("%s: Enter", __func__);
-    ALOGV("%s: eeHandle : 0x%4x", __func__,eeHandle);
-    /* Setting up the emvco poll profile*/
-    status = android::EmvCo_dosetPoll(true);
-    if (status != NFA_STATUS_OK)
-    {
-        ALOGE("%s: fail enable polling; error=0x%X", __func__, status);
-    }
-
-    ALOGV("%s: NFA_RD_SWP_READER_REQUESTED EE_HANDLE_0xF4 %x", __func__, EE_HANDLE_0xF4);
-    ALOGV("%s: NFA_RD_SWP_READER_REQUESTED EE_HANDLE_0xF3 %x", __func__, EE_HANDLE_0xF3);
-
-    if(eeHandle == EE_HANDLE_0xF4) //UICC
-    {
-        SyncEventGuard guard (mDiscMapEvent);
-        ALOGV("%s: mapping intf for UICC", __func__);
-        status = NFC_DiscoveryMap (NFC_SWP_RD_NUM_INTERFACE_MAP,(tNCI_DISCOVER_MAPS *)nfc_interface_mapping_uicc
-                ,SecureElement::discovery_map_cb);
-        if (status != NFA_STATUS_OK)
-        {
-            ALOGE("%s: fail intf mapping for UICC; error=0x%X", __func__, status);
-            return status;
-        }
-        mDiscMapEvent.wait ();
-    }
-    else if(eeHandle == EE_HANDLE_0xF3) //ESE
-    {
-        SyncEventGuard guard (mDiscMapEvent);
-        ALOGV("%s: mapping intf for ESE", __func__);
-        status = NFC_DiscoveryMap (NFC_SWP_RD_NUM_INTERFACE_MAP,(tNCI_DISCOVER_MAPS *)nfc_interface_mapping_ese
-                ,SecureElement::discovery_map_cb);
-        if (status != NFA_STATUS_OK)
-        {
-            ALOGE("%s: fail intf mapping for ESE; error=0x%X", __func__, status);
-            return status;
-        }
-        mDiscMapEvent.wait ();
-    }
-    else
-    {
-        ALOGV("%s: UNKNOWN SOURCE!!! ", __func__);
-        return NFA_STATUS_FAILED;
-    }
-    return NFA_STATUS_OK;
+static void spiEventHandlerThread_cleanup_handler(void* arg) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Inside", __func__);
+  /* Releasing if DWP/SPI mutex is in locked state */
+  if (!android::mSPIDwpSyncMutex.tryLock()) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: SE access is ongoing", __func__);
+  }
+  android::mSPIDwpSyncMutex.unlock();
 }
 
 /*******************************************************************************
 **
-** Function:        etsiResetReaderConfig
+** Function:       spiEventHandlerThread_exit_handler
 **
-** Description:     Configuring from Emvco profile to Nfc forum profile
+** Description:    Handler to receive the signal
+**                    (signal:SIG_SPI_EVENT_HANDLER=45 ) to exit
 **
-** Returns:         Status
+** Returns:        None .
 **
 *******************************************************************************/
-tNFC_STATUS SecureElement::etsiResetReaderConfig()
-{
-    if(!nfcFL.eseFL._ESE_ETSI_READER_ENABLE) {
-        ALOGV("%s: ETSI_READER not available. Returning", __func__);
-        return NFA_STATUS_FAILED;
-    }
-    tNFC_STATUS status;
-    ALOGV("%s: Enter", __func__);
-
-    status = android::EmvCo_dosetPoll(false);
-    if (status != NFA_STATUS_OK)
-    {
-        ALOGE("%s: fail enable polling; error=0x%X", __func__, status);
-    }
-    {
-        SyncEventGuard guard (mDiscMapEvent);
-        ALOGV("%s: mapping intf for DH", __func__);
-        status = NFC_DiscoveryMap (NFC_NUM_INTERFACE_MAP,(tNCI_DISCOVER_MAPS *) nfc_interface_mapping_default
-                ,SecureElement::discovery_map_cb);
-        if (status != NFA_STATUS_OK)
-        {
-            ALOGE("%s: fail intf mapping for ESE; error=0x%X", __func__, status);
-            return status;
-        }
-        mDiscMapEvent.wait ();
-        return NFA_STATUS_OK;
-    }
+void spiEventHandlerThread_exit_handler(int sig) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: spiEventHandlerThread exit handler %d", __func__, sig);
+  pthread_exit(0);
 }
 
-int SecureElement::decodeBerTlvLength(uint8_t* data,int index, int data_length )
-{
-    int decoded_length = -1;
-    int length = 0;
-    int temp = data[index] & 0xff;
-
-    ALOGV("decodeBerTlvLength index= %d data[index+0]=0x%x data[index+1]=0x%x len=%d",index, data[index], data[index+1], data_length);
-
-    if (temp < 0x80) {
-        decoded_length = temp;
-    } else if (temp == 0x81) {
-        if( index < data_length ) {
-            length = data[index+1] & 0xff;
-            if (length < 0x80) {
-                ALOGE("Invalid TLV length encoding!");
-                goto TheEnd;
-            }
-            if (data_length < length + index) {
-                ALOGE("Not enough data provided!");
-                goto TheEnd;
-            }
-        } else {
-            ALOGE("Index %d out of range! [0..[%d",index, data_length);
-            goto TheEnd;
-        }
-        decoded_length = length;
-    } else if (temp == 0x82) {
-        if( (index + 1)< data_length ) {
-            length = ((data[index] & 0xff) << 8)
-                    | (data[index + 1] & 0xff);
-        } else {
-            ALOGE("Index out of range! [0..[%d" , data_length);
-            goto TheEnd;
-        }
-        index += 2;
-        if (length < 0x100) {
-            ALOGE("Invalid TLV length encoding!");
-            goto TheEnd;
-        }
-        if (data_length < length + index) {
-            ALOGE("Not enough data provided!");
-            goto TheEnd;
-        }
-        decoded_length = length;
-    } else if (temp == 0x83) {
-        if( (index + 2)< data_length ) {
-            length = ((data[index] & 0xff) << 16)
-                    | ((data[index + 1] & 0xff) << 8)
-                    | (data[index + 2] & 0xff);
-        } else {
-            ALOGE("Index out of range! [0..[%d", data_length);
-            goto TheEnd;
-        }
-        index += 3;
-        if (length < 0x10000) {
-            ALOGE("Invalid TLV length encoding!");
-            goto TheEnd;
-        }
-        if (data_length < length + index) {
-            ALOGE("Not enough data provided!");
-            goto TheEnd;
-        }
-        decoded_length = length;
-    } else {
-        ALOGE("Unsupported TLV length encoding!");
-    }
-TheEnd:
-    ALOGV("decoded_length = %d", decoded_length);
-
-    return decoded_length;
-}
-#if(NXP_EXTNS == TRUE)
 /*******************************************************************************
 **
 ** Function:       spiEventHandlerThread
@@ -4052,190 +3825,236 @@ TheEnd:
 ** Returns:        None .
 **
 *******************************************************************************/
-void *spiEventHandlerThread(void *arg)
-{
-    if(!nfcFL.nfcNxpEse) {
-        ALOGV("%s: nfcNxpEse not available. Returning", __func__);
-        return NULL;
-    }
-    if(!nfcFL.eseFL._ESE_SVDD_SYNC && !nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION &&
-            !nfcFL.nfccFL._NFCC_SPI_FW_DOWNLOAD_SYNC && !nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE) {
-        ALOGV("%s: Not allowed. Returning", __func__);
-        return NULL;
-    }
-    (void)arg;
-    uint16_t usEvent = 0, usEvtLen = 0;
-
-
-    NFCSTATUS ese_status = NFA_STATUS_FAILED;
+void* spiEventHandlerThread(void* arg) {
+  SecureElement& se = SecureElement::getInstance();
 
-    ALOGV("%s: enter", __func__);
-    while(android::nfcManager_isNfcActive()&&
-            !android::nfcManager_isNfcDisabling() &&
-            (android::nfcManager_getNfcState() != NFC_OFF))
-    {
-        if(true == gSPIEvtQueue.isEmpty()) /* Wait for the event only if the queue is empty */
-        { /* scope of the guard start */
-            SyncEventGuard guard(sSPISignalHandlerEvent);
-            sSPISignalHandlerEvent.wait();
-            ALOGE("%s: Empty evt received", __FUNCTION__);
-        } /* scope of the guard end */
-        /* Dequeue the received signal */
-        gSPIEvtQueue.dequeue((uint8_t*)&usEvent, (uint16_t)SIGNAL_EVENT_SIZE, usEvtLen);
-        ALOGV("%s: evt received %x len %x", __FUNCTION__, usEvent, usEvtLen);
-
-        if(usEvent & P61_STATE_SPI_PRIO)
-        {
-            ALOGV("%s: SPI PRIO request Signal....\n", __func__);
-            hold_the_transceive = true;
-            setSPIState(true);
-         }
-         else if(usEvent & P61_STATE_SPI_PRIO_END)
-         {
-             ALOGV("%s: SPI PRIO End Signal\n", __func__);
-             hold_the_transceive = false;
-             setSPIState(false);
-             SyncEventGuard guard (sSPIPrioSessionEndEvent);
-             sSPIPrioSessionEndEvent.notifyOne ();
-         }
-        else if(usEvent & P61_STATE_SPI)
-        {
-            ALOGV("%s: SPI OPEN request Signal....\n", __func__);
-            setSPIState(true);
-        }
-        else if(usEvent & P61_STATE_SPI_END)
-        {
-            ALOGV("%s: SPI End Signal\n", __func__);
-            hold_the_transceive = false;
-            setSPIState(false);
-        }
-
-        if((usEvent & P61_STATE_SPI_SVDD_SYNC_START) ||
-                (usEvent & P61_STATE_DWP_SVDD_SYNC_START))
-        {
-            if(nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE) {
-                if((usEvent & P61_STATE_SPI_PRIO) ||
-                        (usEvent & P61_STATE_SPI))
-                {
-                    nfaVSC_ForceDwpOnOff(true);
-                }
-                else if((usEvent & P61_STATE_SPI_PRIO_END) ||
-                        (usEvent & P61_STATE_SPI_END))
-                {
-                    nfaVSC_ForceDwpOnOff(false);
-                }
-            }
-
-            if(nfcFL.eseFL._ESE_SVDD_SYNC) {
-                nfaVSC_SVDDSyncOnOff(true);
-            }
-        }
-        else if(nfcFL.eseFL._ESE_SVDD_SYNC &&
-                ((usEvent & P61_STATE_SPI_SVDD_SYNC_END) ||
-                        (usEvent & P61_STATE_DWP_SVDD_SYNC_END))) {
-            nfaVSC_SVDDSyncOnOff(false);
-        }
-
-        else if(nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE &&
-                ((usEvent & P61_STATE_SPI_PRIO) ||
-                        (usEvent & P61_STATE_SPI)))
-        {
-            nfaVSC_ForceDwpOnOff(true);
-        }
-        else if(nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE &&
-                ((usEvent & P61_STATE_SPI_PRIO_END) ||
-                        (usEvent & P61_STATE_SPI_END)))
-        {
-            nfaVSC_ForceDwpOnOff(false);
-        }
-
-        if(nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION) {
-            if(usEvent == JCP_DWNLD_INIT)
-            {
-                ALOGV("%s: JCOP OS download  init request....=%d\n", __func__, usEvent);
-                if(android::nfcManager_checkNfcStateBusy() ==  false)
-                {
-                    if(android::isDiscoveryStarted() == true)
-                    {
-                        android::startRfDiscovery(false);
-                    }
-                    NFC_SetP61Status ((void *)&ese_status, JCP_DWNLD_START);
-                }
-            }
-            else if(usEvent == JCP_DWP_DWNLD_COMPLETE)
-            {
-                ALOGV("%s: JCOP OS download  end request...=%d\n", __func__, usEvent);
-                if(android::isDiscoveryStarted() == false)
-                {
-                    android::startRfDiscovery(true);
-                }
-            }
-        }
-        else if(nfcFL.nfccFL._NFCC_SPI_FW_DOWNLOAD_SYNC &&
-                ((usEvent & P61_STATE_SPI_PRIO_END) ||
-                        (usEvent & P61_STATE_SPI_END))) {
-            if(android::nfcManager_isNfcActive()&&
-                !android::nfcManager_isNfcDisabling() &&
-                    (android::nfcManager_getNfcState() != NFC_OFF)) {
-                android::requestFwDownload();
-            }
-        }
-    }
-    ALOGV("%s: exit", __func__);
-    pthread_exit(NULL);
+  if (!nfcFL.nfcNxpEse) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: nfcNxpEse not available. Returning", __func__);
+    return NULL;
+  }
+  if (!nfcFL.eseFL._ESE_SVDD_SYNC && !nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION &&
+      !nfcFL.nfccFL._NFCC_SPI_FW_DOWNLOAD_SYNC &&
+      !nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Not allowed. Returning", __func__);
     return NULL;
+  }
+  (void)arg;
+  uint16_t usEvent = 0, usEvtLen = 0;
+  tNFC_STATUS stat;
+
+  NFCSTATUS ese_status = NFA_STATUS_FAILED;
+
+  struct sigaction actions;
+  static sigset_t mask;
+  memset(&actions, 0, sizeof(actions));
+  sigemptyset(&actions.sa_mask);
+  sigaddset(&mask, SIG_SPI_EVENT_HANDLER);
+  actions.sa_flags = 0;
+  actions.sa_handler = spiEventHandlerThread_exit_handler;
+  sigaction(SIG_SPI_EVENT_HANDLER, &actions, NULL);
+  if (pthread_sigmask(SIG_UNBLOCK, &mask, NULL) != 0) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: spiEventHandlerThread pthread_sigmask %d", __func__, errno);
+  }
+  pthread_cleanup_push(spiEventHandlerThread_cleanup_handler, NULL);
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
+  while (android::nfcManager_isNfcActive() &&
+         !android::nfcManager_isNfcDisabling() &&
+         (android::nfcManager_getNfcState() != NFC_OFF)) {
+    if (true ==
+        gSPIEvtQueue
+            .isEmpty()) /* Wait for the event only if the queue is empty */
+    {                   /* scope of the guard start */
+      SyncEventGuard guard(sSPISignalHandlerEvent);
+      sSPISignalHandlerEvent.wait();
+      LOG(ERROR) << StringPrintf("%s: Empty evt received", __FUNCTION__);
+    } /* scope of the guard end */
+    /* Dequeue the received signal */
+    gSPIEvtQueue.dequeue((uint8_t*)&usEvent, (uint16_t)SIGNAL_EVENT_SIZE,
+                         usEvtLen);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: evt received %x len %x", __FUNCTION__, usEvent, usEvtLen);
+
+    if (usEvent & P61_STATE_SPI_PRIO) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: SPI PRIO request Signal....\n", __func__);
+      hold_the_transceive = true;
+      setSPIState(true);
+    } else if (usEvent & P61_STATE_SPI_PRIO_END) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: SPI PRIO End Signal\n", __func__);
+      hold_the_transceive = false;
+      if (!se.mIsWiredModeOpen) spiDwpSyncState = STATE_DWP_CLOSE;
+      setSPIState(false);
+      SyncEventGuard guard(sSPIPrioSessionEndEvent);
+      sSPIPrioSessionEndEvent.notifyOne();
+    } else if (usEvent & P61_STATE_SPI) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: SPI OPEN request Signal....\n", __func__);
+      setSPIState(true);
+    } else if (usEvent & P61_STATE_SPI_END) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s: SPI End Signal\n", __func__);
+      hold_the_transceive = false;
+      if (!se.mIsWiredModeOpen) spiDwpSyncState = STATE_DWP_CLOSE;
+      setSPIState(false);
+    }
+
+    if ((usEvent & P61_STATE_SPI_SVDD_SYNC_START) ||
+        (usEvent & P61_STATE_DWP_SVDD_SYNC_START)) {
+      if (nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE) {
+        if ((usEvent & P61_STATE_SPI_PRIO) || (usEvent & P61_STATE_SPI)) {
+          stat = nfaVSC_ForceDwpOnOff(true);
+          if (nfcFL.eseFL._WIRED_MODE_STANDBY) {
+            if (android::nfcManager_getNfcState() != NFC_OFF)
+              NFC_RelForceDwpOnOffWait((void*)&stat);
+          }
+        } else if ((usEvent & P61_STATE_SPI_PRIO_END) ||
+                   (usEvent & P61_STATE_SPI_END)) {
+          /* Locking the eSE(DWP/SPI) access, will be released after SVDD SYNC
+           * OFF command callback ioctl returns */
+          android::mSPIDwpSyncMutex.lock();
+          stat = nfaVSC_ForceDwpOnOff(false);
+        }
+      }
+      if (stat != NFA_STATUS_OK) {
+        NFC_RelSvddWait((void*)&stat);
+        android::mSPIDwpSyncMutex.unlock();
+      } else if (nfcFL.eseFL._ESE_SVDD_SYNC) {
+        nfaVSC_SVDDSyncOnOff(true);
+      }
+    } else if (nfcFL.eseFL._ESE_SVDD_SYNC &&
+               ((usEvent & P61_STATE_SPI_SVDD_SYNC_END) ||
+                (usEvent & P61_STATE_DWP_SVDD_SYNC_END))) {
+      nfaVSC_SVDDSyncOnOff(false);
+    }
+
+    else if (nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE &&
+             ((usEvent & P61_STATE_SPI_PRIO) || (usEvent & P61_STATE_SPI))) {
+      /* Locking the eSE(DWP/SPI) access, will be released after Force DWP
+       * ON/OFF callback ioctl returns */
+      android::mSPIDwpSyncMutex.lock();
+      stat = nfaVSC_ForceDwpOnOff(true);
+      if (nfcFL.eseFL._WIRED_MODE_STANDBY) {
+        if (android::nfcManager_getNfcState() != NFC_OFF) {
+          NFC_RelForceDwpOnOffWait((void*)&stat);
+        }
+      }
+      /* Releasing the eSE access lock */
+      android::mSPIDwpSyncMutex.unlock();
+    } else if (nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE &&
+               ((usEvent & P61_STATE_SPI_PRIO_END) ||
+                (usEvent & P61_STATE_SPI_END))) {
+      nfaVSC_ForceDwpOnOff(false);
+    }
+
+    if (nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION) {
+      if (usEvent == JCP_DWNLD_INIT) {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: JCOP OS download  init request....=%d\n", __func__, usEvent);
+        if (android::nfcManager_checkNfcStateBusy() == false) {
+          if (android::isDiscoveryStarted() == true) {
+            android::startRfDiscovery(false);
+          }
+          NFC_SetP61Status((void*)&ese_status, JCP_DWNLD_START);
+        }
+      } else if (usEvent == JCP_DWP_DWNLD_COMPLETE) {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "%s: JCOP OS download  end request...=%d\n", __func__, usEvent);
+        if (android::isDiscoveryStarted() == false) {
+          android::startRfDiscovery(true);
+        }
+      }
+    } else if (nfcFL.nfccFL._NFCC_SPI_FW_DOWNLOAD_SYNC &&
+               ((usEvent & P61_STATE_SPI_PRIO_END) ||
+                (usEvent & P61_STATE_SPI_END))) {
+      if (android::nfcManager_isNfcActive() &&
+          !android::nfcManager_isNfcDisabling() &&
+          (android::nfcManager_getNfcState() != NFC_OFF)) {
+        android::requestFwDownload();
+      }
+    }
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: Event handled EXIT %x %d %d %d", __func__, usEvent,
+        android::nfcManager_isNfcActive(), android::nfcManager_isNfcDisabling(),
+        android::nfcManager_getNfcState());
+    usEvent = 0x00;
+  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", __func__);
+  pthread_cleanup_pop(1);
+  return NULL;
 }
 
-bool createSPIEvtHandlerThread()
-{
-    if(!nfcFL.nfcNxpEse) {
-        ALOGV("%s: nfcNxpEse not available. Returning", __func__);
-        return false;
-    }
-    if(!nfcFL.eseFL._ESE_SVDD_SYNC && !nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION &&
-            !nfcFL.nfccFL._NFCC_SPI_FW_DOWNLOAD_SYNC && !nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE) {
-        ALOGV("%s: Not allowed. Returning", __func__);
-        return false;
-    }
-
-    bool stat = true;
-    pthread_attr_t attr;
-    pthread_attr_init(&attr);
-    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-    if (pthread_create(&spiEvtHandler_thread, &attr, spiEventHandlerThread, NULL) != 0)
-    {
-        ALOGV("Unable to create the thread");
-        stat = false;
-    }
-    pthread_attr_destroy(&attr);
-    return stat;
+bool createSPIEvtHandlerThread() {
+  if (!nfcFL.nfcNxpEse) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: nfcNxpEse not available. Returning", __func__);
+    return false;
+  }
+  if (!nfcFL.eseFL._ESE_SVDD_SYNC && !nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION &&
+      !nfcFL.nfccFL._NFCC_SPI_FW_DOWNLOAD_SYNC &&
+      !nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Not allowed. Returning", __func__);
+    return false;
+  }
+
+  bool stat = true;
+  pthread_attr_t attr;
+  pthread_attr_init(&attr);
+  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
+  if (pthread_create(&spiEvtHandler_thread, &attr, spiEventHandlerThread,
+                     NULL) != 0) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("Unable to create the thread");
+    stat = false;
+  }
+  pthread_attr_destroy(&attr);
+  return stat;
 }
 
-void releaseSPIEvtHandlerThread()
-{
-    if(!nfcFL.nfcNxpEse) {
-        ALOGV("%s: nfcNxpEse not available. Returning", __func__);
-        return;
-    }
-    if(!nfcFL.eseFL._ESE_SVDD_SYNC && !nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION &&
-            !nfcFL.nfccFL._NFCC_SPI_FW_DOWNLOAD_SYNC && !nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE) {
-        ALOGV("%s: Not allowed. Returning", __func__);
-        return;
-    }
-
-    uint16_t usEvent = 0;
-    uint16_t usEvtLen = 0;
-    ALOGV("releaseSPIEvtHandlerThread");
-    while(!gSPIEvtQueue.isEmpty()) /* Wait for the event only if the queue is empty */
-    { /* scope of the guard start */
-        /* Dequeue the received signal */
-        gSPIEvtQueue.dequeue((uint8_t*)&usEvent, (uint16_t)SIGNAL_EVENT_SIZE, usEvtLen);
-        ALOGE("%s: Clearing queue ", __func__);
-    } /* scope of the guard end */
-
-    /* Notifying the signal handler thread to exit if it is waiting */
-    SyncEventGuard guard(sSPISignalHandlerEvent);
-    sSPISignalHandlerEvent.notifyOne ();
+void releaseSPIEvtHandlerThread() {
+  if (!nfcFL.nfcNxpEse) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: nfcNxpEse not available. Returning", __func__);
+    return;
+  }
+  if (!nfcFL.eseFL._ESE_SVDD_SYNC && !nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION &&
+      !nfcFL.nfccFL._NFCC_SPI_FW_DOWNLOAD_SYNC &&
+      !nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Not allowed. Returning", __func__);
+    return;
+  }
+
+  uint16_t usEvent = 0;
+  uint16_t usEvtLen = 0;
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("releaseSPIEvtHandlerThread");
+  while (!gSPIEvtQueue
+              .isEmpty()) /* Wait for the event only if the queue is empty */
+  {                       /* scope of the guard start */
+    /* Dequeue the received signal */
+    gSPIEvtQueue.dequeue((uint8_t*)&usEvent, (uint16_t)SIGNAL_EVENT_SIZE,
+                         usEvtLen);
+    LOG(ERROR) << StringPrintf("%s: Clearing queue ", __func__);
+  } /* scope of the guard end */
+  {
+    SyncEventGuard guard(SecureElement::getInstance().mModeSetNtf);
+    SecureElement::getInstance().mModeSetNtf.notifyOne();
+  }
+  /* Notifying/Signalling the signal handler thread to exit */
+  if (pthread_kill(spiEvtHandler_thread, SIG_SPI_EVENT_HANDLER) != 0) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("Killed spiEvtHandler_thread error status:%d", errno);
+  } else {
+    pthread_join(spiEvtHandler_thread, NULL);
+  }
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("Exit releaseSPIEvtHandlerThread");
 }
 /*******************************************************************************
 **
@@ -4247,26 +4066,30 @@ void releaseSPIEvtHandlerThread()
 ** Returns:         void.
 **
 *******************************************************************************/
-static void nfaVSC_SVDDSyncOnOffCallback(uint8_t event, uint16_t param_len, uint8_t *p_param)
-{
-    if(!nfcFL.nfcNxpEse || !nfcFL.eseFL._ESE_SVDD_SYNC) {
-        ALOGV("%s: nfcNxpEse or ESE_SVDD_SYNC not available. Returning", __func__);
-        return;
-    }
-
-    (void)event;
-    tNFC_STATUS nfaStat;
-    char fn[] = "nfaVSC_SVDDProtectionCallback";
-    ALOGV("%s", __func__);
-    ALOGV("%s param_len = %d ", __func__, param_len);
-    ALOGV("%s status = 0x%X ", __func__, p_param[3]);
-    SyncEventGuard guard(sSPISVDDSyncOnOffEvent);
-    sSPISVDDSyncOnOffEvent.notifyOne();
-    if (NFC_RelSvddWait((void *)&nfaStat) != 0)
-    {
-        ALOGE("%s: NFC_RelSvddWait failed ret = %d", fn, nfaStat);
-    }
+static void nfaVSC_SVDDSyncOnOffCallback(uint8_t event, uint16_t param_len,
+                                         uint8_t* p_param) {
+  if (!nfcFL.nfcNxpEse || !nfcFL.eseFL._ESE_SVDD_SYNC) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: nfcNxpEse or ESE_SVDD_SYNC not available. Returning", __func__);
+    return;
+  }
+
+  (void)event;
+  tNFC_STATUS nfaStat = NFA_STATUS_OK;
+  char fn[] = "nfaVSC_SVDDProtectionCallback";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s param_len = %d ", __func__, param_len);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s status = 0x%X ", __func__, p_param[3]);
+  SyncEventGuard guard(sSPISVDDSyncOnOffEvent);
+  sSPISVDDSyncOnOffEvent.notifyOne();
+  if (NFC_RelSvddWait((void*)&nfaStat) != 0) {
+    LOG(ERROR) << StringPrintf("%s: NFC_RelSvddWait failed ret = %d", fn,
+                               nfaStat);
+  }
 }
+
 /*******************************************************************************
 **
 ** Function:        nfaVSC_SVDDSyncOnOff
@@ -4277,259 +4100,223 @@ static void nfaVSC_SVDDSyncOnOffCallback(uint8_t event, uint16_t param_len, uint
 ** Returns:         void.
 **
 *******************************************************************************/
-static void nfaVSC_SVDDSyncOnOff(bool type)
-{
-    if(!nfcFL.nfcNxpEse || !nfcFL.eseFL._ESE_SVDD_SYNC) {
-        ALOGV("%s: nfcNxpEse or ESE_SVDD_SYNC not available. Returning", __func__);
-        return;
-    }
-    tNFC_STATUS stat;
-    uint8_t param = 0x00;
-    if(type == true)
-    {
-        param = 0x01; //SVDD protection on
-    }
-    if (!android::nfcManager_isNfcActive()||
-            android::nfcManager_isNfcDisabling() ||
-                (android::nfcManager_getNfcState() == NFC_OFF))
-    {
-        ALOGE("%s: NFC is no longer active.", __func__);
-        return;
-    }
-    stat = NFA_SendVsCommand (0x31, 0x01, &param, nfaVSC_SVDDSyncOnOffCallback);
-    if(NFA_STATUS_OK == stat)
-    {
-        SyncEventGuard guard(sSPISVDDSyncOnOffEvent);
-        sSPISVDDSyncOnOffEvent.wait(50);
-        ALOGV("%s: NFA_SendVsCommand pass stat = %d", __func__,stat);
-    }
-    else
-    {
-        ALOGV("%s: NFA_SendVsCommand failed stat = %d", __func__,stat);
-    }
+static void nfaVSC_SVDDSyncOnOff(bool type) {
+  if (!nfcFL.nfcNxpEse || !nfcFL.eseFL._ESE_SVDD_SYNC) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: nfcNxpEse or ESE_SVDD_SYNC not available. Returning", __func__);
+    return;
+  }
+
+  SecureElement& se = SecureElement::getInstance();
+  if (se.mIsWiredModeOpen) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("nfaVSC_SVDDSyncOnOff wiredModeOpen");
+    if (type == false) android::mSPIDwpSyncMutex.unlock();
+    tNFC_STATUS nfaStat = NFA_STATUS_OK;
+    if (NFC_RelSvddWait((void*)&nfaStat) != 0) {
+      LOG(ERROR) << StringPrintf("%s: NFC_RelSvddWait failed ret = %d",
+                                 __func__, nfaStat);
+    }
+    return;
+  }
+
+  if (!android::nfcManager_isNfcActive() ||
+      android::nfcManager_isNfcDisabling() ||
+      (android::nfcManager_getNfcState() == NFC_OFF)) {
+    LOG(ERROR) << StringPrintf("%s: NFC is no longer active.", __func__);
+    android::mSPIDwpSyncMutex.unlock();
+    tNFC_STATUS nfaStat = NFA_STATUS_OK;
+    if (NFC_RelSvddWait((void*)&nfaStat) != 0) {
+      LOG(ERROR) << StringPrintf("%s: NFC_RelSvddWait failed ret = %d",
+                                 __func__, nfaStat);
+    }
+    return;
+  }
+
+  tNFC_STATUS stat;
+  uint8_t param = 0x00;
+  if (type == true) {
+    param = 0x01;  // SVDD protection on
+  }
+  stat = NFA_SendVsCommand(0x31, 0x01, &param, nfaVSC_SVDDSyncOnOffCallback);
+  if (NFA_STATUS_OK == stat) {
+    SyncEventGuard guard(sSPISVDDSyncOnOffEvent);
+    sSPISVDDSyncOnOffEvent.wait(50);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: NFA_SendVsCommand pass stat = %d", __func__, stat);
+  } else {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: NFA_SendVsCommand failed stat = %d", __func__, stat);
+  }
+  if (type == false) android::mSPIDwpSyncMutex.unlock();
 }
 
 /*******************************************************************************
  **
  ** Function:        nfaVSC_ForceDwpOnOff
-**
+ **
  ** Description:     starts and stops the dwp channel
  **
  **
  ** Returns:         void.
  **
-*******************************************************************************/
-static void nfaVSC_ForceDwpOnOff(bool type)
-{
-    if(!nfcFL.nfcNxpEse || !nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE) {
-        ALOGV("%s: nfcNxpEse or DWP_SPI_SYNC_ENABLE not available."
-                " Returning", __func__);
-        return;
-    }
-    tNFC_STATUS stat = NFA_STATUS_FAILED;
-    uint8_t xmitBuffer[] = {0x00, 0x00, 0x00, 0x00};
-    uint8_t EVT_SEND_DATA = 0x10;
-    uint8_t EVT_END_OF_APDU_TRANSFER = 0x21;
-
-    if(standby_state == STANDBY_MODE_OFF)
-    {
-        ALOGV("%s: DWP wired mode is On", __func__);
-        return;
-    }
+ *******************************************************************************/
+static tNFA_STATUS nfaVSC_ForceDwpOnOff(bool type) {
+  if (!nfcFL.nfcNxpEse || !nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: nfcNxpEse or DWP_SPI_SYNC_ENABLE not available."
+        " Returning",
+        __func__);
+    return NFA_STATUS_OK;
+  }
+
+  tNFC_STATUS stat = NFA_STATUS_FAILED;
+  uint8_t xmitBuffer[] = {0x00, 0x00, 0x00, 0x00};
+  uint8_t EVT_SEND_DATA = 0x10;
+  uint8_t EVT_END_OF_APDU_TRANSFER = 0x21;
+  SecureElement& se = SecureElement::getInstance();
+
+  /*Do not set powerLink and modeSet if wiredMode is open, except in case of
+   * standby timeout. In case of wiredMode standby timeout, and SPI open/close,
+   * send necessary powerLink and modeSet commands for SPI communications*/
+  if (!(spiDwpSyncState & STATE_TIME_OUT) && (se.mIsWiredModeOpen)) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: DWP wired mode is On", __func__);
+    return NFA_STATUS_OK;
+  }
 
-    if(!android::nfcManager_isNfcActive()||
-            android::nfcManager_isNfcDisabling() ||
-                (android::nfcManager_getNfcState() == NFC_OFF))
-    {
-        ALOGV ("%s: NFC is not activated", __FUNCTION__);
-        return;
-    }
+  if (!android::nfcManager_isNfcActive() ||
+      android::nfcManager_isNfcDisabling() ||
+      (android::nfcManager_getNfcState() == NFC_OFF)) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: NFC is not activated", __FUNCTION__);
+    return NFA_STATUS_OK;
+  }
 
-    ALOGV("nfaVSC_ForceDwpOnOff: syncstate = %d, type = %d", spiDwpSyncState, type);
-    if((type == true) && !(spiDwpSyncState & STATE_WK_ENBLE))
-    {
-        if(nfcFL.eseFL._WIRED_MODE_STANDBY) {
-            SecureElement::getInstance().setNfccPwrConfig(SecureElement::getInstance().POWER_ALWAYS_ON | SecureElement::getInstance().COMM_LINK_ACTIVE);
-            SecureElement::getInstance().SecEle_Modeset(0x1);
-            spiDwpSyncState |= STATE_WK_ENBLE;
-        }
-        else  {
-            spiDwpSyncState |= STATE_WK_ENBLE;
-            memset(xmitBuffer, 0, sizeof(xmitBuffer));
-            stat = NFA_HciSendEvent (NFA_HANDLE_GROUP_HCI, 0x19, EVT_SEND_DATA, sizeof(xmitBuffer), xmitBuffer,
-                    0, NULL, 0);
-            if(stat == NFA_STATUS_OK)
-            {
-                spiDwpSyncState |= STATE_WK_WAIT_RSP;
-                SyncEventGuard guard(sSPIForceEnableDWPEvent);
-                sSPIForceEnableDWPEvent.wait(50);
-            }
-            else
-            {
-                ALOGV("%s: NFA_HciSendEvent failed stat = %d type = %d", __func__,stat, type);
-            }
-        }
-    }
-    else if (type == false)
-    {
-        if(nfcFL.eseFL._WIRED_MODE_STANDBY) {
-            /*Just stand by timer expired*/
-            if(spiDwpSyncState & STATE_TIME_OUT)
-            {
-                /*Clear APDU state to activate DWP link once spi standalone is triggered*/
-                if(spiDwpSyncState & STATE_WK_ENBLE)
-                {
-                    spiDwpSyncState ^= STATE_WK_ENBLE;
-                }
-                SecureElement::getInstance().setNfccPwrConfig(SecureElement::getInstance().POWER_ALWAYS_ON);
-                stat = SecureElement::getInstance().sendEvent(SecureElement::EVT_SUSPEND_APDU_TRANSFER);
-                if(stat)
-                {
-                    ALOGV("%s sending standby mode command successful", __func__);
-                }
-                standby_state = STANDBY_MODE_SUSPEND;
-                spiDwpSyncState = STATE_IDLE;
-                return;
-            }
-            /*If DWP session is closed*/
-            (void)SecureElement::getInstance().setNfccPwrConfig(SecureElement::getInstance().NFCC_DECIDES);
-        }
-        if(spiDwpSyncState & STATE_DWP_CLOSE)
-        {
-            stat = NFA_HciSendEvent (NFA_HANDLE_GROUP_HCI, 0x19, EVT_END_OF_APDU_TRANSFER,
-                    0x00, NULL, 0x00,NULL, 0);
-            if(NFA_STATUS_OK != stat)
-                ALOGV("%s: NFA_HciSendEvent failed stat = %d, type = %d", __func__,stat, type);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "nfaVSC_ForceDwpOnOff: syncstate = %d, type = %d", spiDwpSyncState, type);
+  if ((type == true) && !(spiDwpSyncState & STATE_WK_ENBLE)) {
+    if (nfcFL.eseFL._WIRED_MODE_STANDBY) {
+      stat = SecureElement::getInstance().setNfccPwrConfig(
+          SecureElement::getInstance().POWER_ALWAYS_ON |
+          SecureElement::getInstance().COMM_LINK_ACTIVE);
+      if (stat != NFA_STATUS_OK) return stat;
+      if (!SecureElement::getInstance().SecEle_Modeset(0x1))
+        return NFA_STATUS_FAILED;
+      spiDwpSyncState |= STATE_WK_ENBLE;
+    } else {
+      spiDwpSyncState |= STATE_WK_ENBLE;
+      memset(xmitBuffer, 0, sizeof(xmitBuffer));
+      stat = NFA_HciSendEvent(NFA_HANDLE_GROUP_HCI, 0x19, EVT_SEND_DATA,
+                              sizeof(xmitBuffer), xmitBuffer, 0, NULL, 0);
+      if (stat == NFA_STATUS_OK) {
+        spiDwpSyncState |= STATE_WK_WAIT_RSP;
+        SyncEventGuard guard(sSPIForceEnableDWPEvent);
+        sSPIForceEnableDWPEvent.wait(50);
+      } else {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: NFA_HciSendEvent failed stat = %d type = %d",
+                            __func__, stat, type);
+      }
+    }
+  } else if (type == false) {
+    if (nfcFL.eseFL._WIRED_MODE_STANDBY) {
+      /*Just stand by timer expired*/
+      if (spiDwpSyncState & STATE_TIME_OUT) {
+        /*Clear APDU state to activate DWP link once spi standalone is
+         * triggered*/
+        if (spiDwpSyncState & STATE_WK_ENBLE) {
+          spiDwpSyncState ^= STATE_WK_ENBLE;
+        }
+        stat = SecureElement::getInstance().setNfccPwrConfig(
+            SecureElement::getInstance().POWER_ALWAYS_ON);
+        if (stat != NFA_STATUS_OK) return stat;
+        stat = SecureElement::getInstance().sendEvent(
+            SecureElement::EVT_SUSPEND_APDU_TRANSFER);
+        if (stat) {
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+              "%s sending standby mode command successful", __func__);
+        } else {
+          return stat;
         }
+        standby_state = STANDBY_MODE_SUSPEND;
+        /* DWP is still in standby timeout state */
+        spiDwpSyncState = STATE_IDLE | STATE_TIME_OUT;
+        return NFA_STATUS_OK;
+      }
+      /*If DWP session is closed*/
+      stat = SecureElement::getInstance().setNfccPwrConfig(
+          SecureElement::getInstance().NFCC_DECIDES);
+      if (stat != NFA_STATUS_OK) {
         spiDwpSyncState = STATE_IDLE;
+        return stat;
+      }
     }
 
-    ALOGV("nfaVSC_ForceDwpOnOff: syncstate = %d, type = %d", spiDwpSyncState, type);
-}
-
-bool SecureElement::enableDwp(void)
-{
-    if(!nfcFL.nfcNxpEse || !nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE) {
-        ALOGV("%s: nfcNxpEse or DWP_SPI_SYNC_ENABLE not available."
-                " Returning", __func__);
-        return false;
+    if (spiDwpSyncState & STATE_DWP_CLOSE) {
+      stat =
+          NFA_HciSendEvent(NFA_HANDLE_GROUP_HCI, 0x19, EVT_END_OF_APDU_TRANSFER,
+                           0x00, NULL, 0x00, NULL, 0);
+      if (NFA_STATUS_OK != stat)
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("%s: NFA_HciSendEvent failed stat = %d, type = %d",
+                            __func__, stat, type);
     }
-    bool stat = false;
-    static const char fn [] = "SecureElement::enableDwp";
-    ALOGV("enter %s", fn);
+    spiDwpSyncState = STATE_IDLE;
+  }
 
-    mActiveEeHandle = getDefaultEeHandle();
-    if(mActiveEeHandle == EE_HANDLE_0xF3)
-    {
-        stat = connectEE();
-    }
-    mIsPiping = false;
-    ALOGV("exit %s.. stat = %d", fn, stat);
-    return stat;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "nfaVSC_ForceDwpOnOff: syncstate = %d, type = %d", spiDwpSyncState, type);
+  return NFA_STATUS_OK;
 }
 
-void spi_prio_signal_handler (int signum, siginfo_t *info, void * /*unused */)
-{
-    ALOGV("%s: Inside the Signal Handler %d\n", __func__, SIG_NFC);
-    uint16_t usEvent = 0;
-    if (signum == SIG_NFC)
-    {
-        ALOGV("%s: Signal is SIG_NFC\n", __func__);
-        if(nfcFL.eseFL._ESE_SVDD_SYNC || nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION ||
-                nfcFL.nfccFL._NFCC_SPI_FW_DOWNLOAD_SYNC || nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE) {
-            usEvent = info->si_int;
-            gSPIEvtQueue.enqueue((uint8_t*)&usEvent, (uint16_t)SIGNAL_EVENT_SIZE);
-            SyncEventGuard guard(sSPISignalHandlerEvent);
-            sSPISignalHandlerEvent.notifyOne ();
-        }
-    }
+bool SecureElement::enableDwp(void) {
+  if (!nfcFL.nfcNxpEse || !nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: nfcNxpEse or DWP_SPI_SYNC_ENABLE not available."
+        " Returning",
+        __func__);
+    return false;
+  }
+  bool stat = false;
+  static const char fn[] = "SecureElement::enableDwp";
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("enter %s", fn);
+
+  mActiveEeHandle = getDefaultEeHandle();
+  if (mActiveEeHandle == EE_HANDLE_0xF3) {
+    stat = connectEE();
+  }
+  mIsPiping = false;
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("exit %s.. stat = %d", fn, stat);
+  return stat;
 }
 
-/*******************************************************************************
-**
-** Function:        setCPTimeout
-**
-** Description:     sets the CP timeout for SE -P61 if its present.
-**
-**
-** Returns:         void.
-**
-*******************************************************************************/
-void SecureElement::setCPTimeout()
-{
-    tNFA_HANDLE handle;
-    tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
-    uint8_t received_getatr[32];
-    uint8_t selectISD[]= {0x00,0xa4,0x04,0x00,0x08,0xA0,0x00,0x00,0x01,0x51,0x00,0x00,0x00,0x00};
-    uint8_t received_selectISD[64];
-    uint8_t setCPTimeoutcmdbuff[]= {0x80,0xDC,0x00,0x00,0x08,0xEF,0x06,0xA0,0x04,0x84,0x02,0x00,0x00};
-    uint8_t CPTimeoutvalue[2]= {0x00,0x00};
-    uint8_t received_setCPTimeout[32];
-    int i;
-    bool found =false;
-    long retlen = 0;
-    int32_t timeout =12000;
-    int32_t recvBufferActualSize = 0;
-    static const char fn [] = "SecureElement::setCPTimeout";
-    for ( i = 0; i < mActualNumEe; i++)
-    {
-        if (mEeInfo[i].ee_handle == EE_HANDLE_0xF3)
-        {
-            nfaStat = NFA_STATUS_OK;
-            handle = mEeInfo[i].ee_handle & ~NFA_HANDLE_GROUP_EE;
-            ALOGV("%s: %u = 0x%X", fn, i, mEeInfo[i].ee_handle);
-            break;
-        }
-    }
-    if(nfaStat == NFA_STATUS_OK)
-    {
-        if (GetNxpByteArrayValue(NAME_NXP_CP_TIMEOUT,(char *) CPTimeoutvalue,
-                sizeof(CPTimeoutvalue), &retlen))
-        {
-           ALOGV("%s: READ NAME_CP_TIMEOUT Value", __func__);
-           memcpy((setCPTimeoutcmdbuff+(sizeof(setCPTimeoutcmdbuff)-2)),CPTimeoutvalue,2);
-           found = true;
-        }
-        else
-        {
-            ALOGV("%s:CP_TIMEOUT Value not found!!!", __func__);
-        }
-        if(found)
-        {
-            bool stat = false;
-            stat = SecEle_Modeset(0x01);
-            if(stat == true)
-            {
-                mActiveEeHandle = getDefaultEeHandle();
-                if(mActiveEeHandle == EE_HANDLE_0xF3 && (getApduGateInfo() != NO_APDU_GATE))
-                {
-                    stat = connectEE();
-                    if(stat == true)
-                    {
-                        stat = getAtr(ESE_ID,received_getatr,&recvBufferActualSize);
-                        if(stat == true)
-                        {
-                            /*select card manager*/
-                            stat = transceive(selectISD,(int32_t)sizeof(selectISD),received_selectISD,
-                                               (int)sizeof(received_selectISD), recvBufferActualSize, timeout);
-                            if(stat == true)
-                            {
-                                /*set timeout value in CP registry*/
-                                transceive(setCPTimeoutcmdbuff,(int32_t)sizeof(setCPTimeoutcmdbuff),
-                                            received_setCPTimeout, (int)sizeof(received_setCPTimeout), recvBufferActualSize, timeout);
-                            }
-                        }
-                        NfccStandByOperation(STANDBY_MODE_ON);
-                        disconnectEE(ESE_ID);
-                    }
-                }
-            }
-            sendEvent(SecureElement::EVT_END_OF_APDU_TRANSFER);
-            NfccStandByOperation(STANDBY_TIMER_STOP);
-            disconnectEE(ESE_ID);
-        }
-    }
-
+void spi_prio_signal_handler(int signum, siginfo_t* info, void* unused) {
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Inside the Signal Handler %d\n", __func__, SIG_NFC);
+  if (nfcFL.chipType == pn557) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: for pn557/pn81T, signal_handler not supported. Returning\n",
+        __func__);
+    return;
+  }
+
+  uint16_t usEvent = 0;
+  if (signum == SIG_NFC && (android::nfcManager_isNfcActive() != false &&
+                            !(android::nfcManager_isNfcDisabling()) &&
+                            (android::nfcManager_getNfcState() != NFC_OFF))) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Signal is SIG_NFC\n", __func__);
+    if (nfcFL.eseFL._ESE_SVDD_SYNC || nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION ||
+        nfcFL.nfccFL._NFCC_SPI_FW_DOWNLOAD_SYNC ||
+        nfcFL.eseFL._ESE_DWP_SPI_SYNC_ENABLE) {
+      usEvent = info->si_int;
+      gSPIEvtQueue.enqueue((uint8_t*)&usEvent, (uint16_t)SIGNAL_EVENT_SIZE);
+      SyncEventGuard guard(sSPISignalHandlerEvent);
+      sSPISignalHandlerEvent.notifyOne();
+    }
+  }
 }
 
 /*******************************************************************************
@@ -4541,61 +4328,54 @@ void SecureElement::setCPTimeout()
 ** Returns:         True if ok.
 **
 *******************************************************************************/
-uint16_t SecureElement::enablePassiveListen (uint8_t event)
-{
-    if(!nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) {
-        ALOGV("%s NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION not available."
-                " Returning",__func__);
-        return NFA_STATUS_FAILED;
-    }
-
-    tNFA_STATUS status = NFA_STATUS_FAILED;
-
-    mPassiveListenMutex.lock();
-
-    if(event == 0x00 && mPassiveListenEnabled == true)
-    {
-        if(android::isDiscoveryStarted() == true)
-        {
-            android::startRfDiscovery(false);
-        }
-        status = NFA_DisablePassiveListening();
-        if(status == NFA_STATUS_OK)
-        {
-            SyncEventGuard g (mPassiveListenEvt);
-            mPassiveListenEvt.wait(100);
-        }
-        resetRfFieldStatus();
-        setDwpTranseiveState(false, NFCC_RF_FIELD_EVT);
-        mPassiveListenEnabled = false;
-
-        if(android::isDiscoveryStarted() == false)
-        {
-            android::startRfDiscovery(true);
-        }
-    }
-    else if (event == 0x01 && mPassiveListenEnabled == false)
-    {
-        if(android::isDiscoveryStarted() == true)
-        {
-            android::startRfDiscovery(false);
-        }
-        status = NFA_EnableListening();
-        if(status == NFA_STATUS_OK)
-        {
-            SyncEventGuard g (mPassiveListenEvt);
-            mPassiveListenEvt.wait(100);
-        }
-        mPassiveListenTimer.set(mPassiveListenTimeout , passiveListenDisablecallBack);
-        mPassiveListenEnabled = true;
-        if(android::isDiscoveryStarted() == false)
-        {
-            android::startRfDiscovery(true);
-        }
-    }
-    mPassiveListenMutex.unlock();
-    ALOGV(" enablePassiveListen exit");
-    return 0x00;
+uint16_t SecureElement::enablePassiveListen(uint8_t event) {
+  if (!nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION not available."
+        " Returning",
+        __func__);
+    return NFA_STATUS_FAILED;
+  }
+
+  tNFA_STATUS status = NFA_STATUS_FAILED;
+
+  mPassiveListenMutex.lock();
+
+  if (event == 0x00 && mPassiveListenEnabled == true) {
+    if (android::isDiscoveryStarted() == true) {
+      android::startRfDiscovery(false);
+    }
+    status = NFA_DisablePassiveListening();
+    if (status == NFA_STATUS_OK) {
+      SyncEventGuard g(mPassiveListenEvt);
+      mPassiveListenEvt.wait(100);
+    }
+    resetRfFieldStatus();
+    setDwpTranseiveState(false, NFCC_RF_FIELD_EVT);
+    mPassiveListenEnabled = false;
+
+    if (android::isDiscoveryStarted() == false) {
+      android::startRfDiscovery(true);
+    }
+  } else if (event == 0x01 && mPassiveListenEnabled == false) {
+    if (android::isDiscoveryStarted() == true) {
+      android::startRfDiscovery(false);
+    }
+    status = NFA_EnableListening();
+    if (status == NFA_STATUS_OK) {
+      SyncEventGuard g(mPassiveListenEvt);
+      mPassiveListenEvt.wait(100);
+    }
+    mPassiveListenTimer.set(mPassiveListenTimeout,
+                            passiveListenDisablecallBack);
+    mPassiveListenEnabled = true;
+    if (android::isDiscoveryStarted() == false) {
+      android::startRfDiscovery(true);
+    }
+  }
+  mPassiveListenMutex.unlock();
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(" enablePassiveListen exit");
+  return 0x00;
 }
 
 /*******************************************************************************
@@ -4607,39 +4387,39 @@ uint16_t SecureElement::enablePassiveListen (uint8_t event)
  ** Returns:        None
  **
  *******************************************************************************/
-void *passiveListenEnableThread(void *arg)
-{
-    if(!nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) {
-        ALOGV("%s NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION not available."
-                " Returning",__func__);
-        return NULL;
-    }
-    ALOGV(" passiveListenEnableThread  %d",*((uint8_t*)arg));
-    if (*((uint8_t*)arg))
-    {
-        SecureElement::getInstance().enablePassiveListen(0x01);
-    }
-    else
-    {
-        SecureElement::getInstance().enablePassiveListen(0x00);
-    }
-    pthread_exit(NULL);
+void* passiveListenEnableThread(void* arg) {
+  if (!nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION not available."
+        " Returning",
+        __func__);
     return NULL;
+  }
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf(" passiveListenEnableThread  %d", *((uint8_t*)arg));
+  if (*((uint8_t*)arg)) {
+    SecureElement::getInstance().enablePassiveListen(0x01);
+  } else {
+    SecureElement::getInstance().enablePassiveListen(0x00);
+  }
+  pthread_exit(NULL);
+  return NULL;
 }
 
-uint16_t SecureElement::startThread(uint8_t thread_arg)
-{
-    passiveListenState = thread_arg;
-    pthread_attr_t attr;
-    pthread_attr_init(&attr);
-    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-    mPassiveListenCnt = 0x00;
-    if (pthread_create(&passiveListenEnable_thread, &attr, passiveListenEnableThread, (void*) &passiveListenState) != 0)
-    {
-        ALOGV("Unable to create the thread");
-    }
-    pthread_attr_destroy(&attr);
-    return 0x00;
+uint16_t SecureElement::startThread(uint8_t thread_arg) {
+  passiveListenState = thread_arg;
+  pthread_attr_t attr;
+  pthread_attr_init(&attr);
+  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+  mPassiveListenCnt = 0x00;
+  if (pthread_create(&passiveListenEnable_thread, &attr,
+                     passiveListenEnableThread,
+                     (void*)&passiveListenState) != 0) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("Unable to create the thread");
+  }
+  pthread_attr_destroy(&attr);
+  return 0x00;
 }
 
 /*******************************************************************************
@@ -4651,36 +4431,39 @@ uint16_t SecureElement::startThread(uint8_t thread_arg)
 ** Returns:         None
 **
 *******************************************************************************/
-static void passiveListenDisablecallBack(union sigval)
-{
-    if(!nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) {
-        ALOGV("%s NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION not available."
-                " Returning",__func__);
-        return;
-    }
-    ALOGV(" passiveListenDisablecallBack enter");
-
-    if(SecureElement::getInstance().isRfFieldOn() == true)
-    {
-        if(SecureElement::getInstance().isActivatedInListenMode())
-        {
-            //do nothing ,
-            return;
-        }
-        else if((SecureElement::getInstance().isActivatedInListenMode() == false) && (SecureElement::getInstance().mPassiveListenCnt < 0x02))
-        {
-            ALOGV(" passiveListenEnableThread timer restart");
-            SecureElement::getInstance().mPassiveListenTimer.set(SecureElement::getInstance().mPassiveListenTimeout , passiveListenDisablecallBack);
-            SecureElement::getInstance().mPassiveListenCnt++;
-            return;
-        }
-    }
-    SecureElement::getInstance().enablePassiveListen (0x00);
+static void passiveListenDisablecallBack(union sigval) {
+  if (!nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION not available."
+        " Returning",
+        __func__);
+    return;
+  }
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf(" passiveListenDisablecallBack enter");
+
+  if (SecureElement::getInstance().isRfFieldOn() == true) {
+    if (SecureElement::getInstance().isActivatedInListenMode()) {
+      // do nothing ,
+      return;
+    } else if ((SecureElement::getInstance().isActivatedInListenMode() ==
+                false) &&
+               (SecureElement::getInstance().mPassiveListenCnt < 0x02)) {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf(" passiveListenEnableThread timer restart");
+      SecureElement::getInstance().mPassiveListenTimer.set(
+          SecureElement::getInstance().mPassiveListenTimeout,
+          passiveListenDisablecallBack);
+      SecureElement::getInstance().mPassiveListenCnt++;
+      return;
+    }
+  }
+  SecureElement::getInstance().enablePassiveListen(0x00);
 }
 
 #endif
 
-#if(NXP_EXTNS == TRUE)
+#if (NXP_EXTNS == TRUE)
 /*******************************************************************************
  **
  ** Function:       setSPIState
@@ -4690,28 +4473,24 @@ static void passiveListenDisablecallBack(union sigval)
  ** Returns:        None .
  **
  *******************************************************************************/
-static void setSPIState(bool mState)
-{
-    ALOGV("%s: Enter setSPIState \n", __func__);
-    /*Check if the state is already dual mode*/
-    bool inDualModeAlready = (dual_mode_current_state == SPI_DWPCL_BOTH_ACTIVE);
-    if(mState)
-    {
-        dual_mode_current_state |= SPI_ON;
-    }
-    else
-    {
-        if(dual_mode_current_state & SPI_ON)
-        {
-            dual_mode_current_state ^= SPI_ON;
-            if(inDualModeAlready)
-            {
-                SyncEventGuard guard (mDualModeEvent);
-                mDualModeEvent.notifyOne();
-            }
-        }
-    }
-    ALOGV("%s: Exit setSPIState = %d\n", __func__, dual_mode_current_state);
+static void setSPIState(bool mState) {
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Enter setSPIState \n", __func__);
+  /*Check if the state is already dual mode*/
+  bool inDualModeAlready = (dual_mode_current_state == SPI_DWPCL_BOTH_ACTIVE);
+  if (mState) {
+    dual_mode_current_state |= SPI_ON;
+  } else {
+    if (dual_mode_current_state & SPI_ON) {
+      dual_mode_current_state ^= SPI_ON;
+      if (inDualModeAlready) {
+        SyncEventGuard guard(mDualModeEvent);
+        mDualModeEvent.notifyOne();
+      }
+    }
+  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: Exit setSPIState = %d\n", __func__, dual_mode_current_state);
 }
 
 /*******************************************************************************
@@ -4723,35 +4502,81 @@ static void setSPIState(bool mState)
  ** Returns:        NFA_STATUS_OK/NFA_STATUS_FAILED.
  **
  *******************************************************************************/
-tNFA_STATUS SecureElement::SecElem_EeModeSet(uint16_t handle, uint8_t mode)
-{
-    tNFA_STATUS stat = NFA_STATUS_FAILED;
-    ALOGV("%s:Enter mode = %d", __func__, mode);
+tNFA_STATUS SecureElement::SecElem_EeModeSet(uint16_t handle, uint8_t mode) {
+  tNFA_STATUS stat = NFA_STATUS_FAILED;
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s:Enter mode = %d", __func__, mode);
+
+  if (nfcFL.nfcNxpEse) {
+    if (nfcFL.eseFL._JCOP_WA_ENABLE &&
+        ((mode == NFA_EE_MD_DEACTIVATE) &&
+         (active_ese_reset_control &
+          (TRANS_WIRED_ONGOING | TRANS_CL_ONGOING)))) {
+      active_ese_reset_control |= RESET_BLOCKED;
+      SyncEventGuard guard(sSecElem.mResetEvent);
+      sSecElem.mResetEvent.wait();
+    }
+  }
+  if ((dual_mode_current_state & SPI_ON) && (handle == EE_HANDLE_0xF3) &&
+      (mode == NFA_EE_MD_DEACTIVATE))
+    return NFA_STATUS_OK;
 
-    if(nfcFL.nfcNxpEse) {
-        if(nfcFL.eseFL._JCOP_WA_ENABLE &&
-                ((mode == NFA_EE_MD_DEACTIVATE)&&(active_ese_reset_control&(TRANS_WIRED_ONGOING|TRANS_CL_ONGOING))))
-        {
-            active_ese_reset_control |= RESET_BLOCKED;
-            SyncEventGuard guard (sSecElem.mResetEvent);
-            sSecElem.mResetEvent.wait();
-        }
-    }
-    SyncEventGuard guard (sSecElem.mEeSetModeEvent);
-    stat =  NFA_EeModeSet(handle, mode);
-    if(stat == NFA_STATUS_OK && !android::nfcManager_isNfcDisabling())
-    {
-        sSecElem.mEeSetModeEvent.wait ();
+  if (nfcFL.eseFL._WIRED_MODE_STANDBY) {
+    if ((handle == EE_HANDLE_0xF3) && (mode == NFA_EE_MD_ACTIVATE)) {
+      SyncEvent* pEeSetModeEvent;
+      if (NFA_GetNCIVersion() == NCI_VERSION_2_0) {
+        pEeSetModeEvent = &mEeSetModeEvent;
+      } else {
+        pEeSetModeEvent = &mModeSetNtf;
+      }
+      SyncEventGuard guard(*pEeSetModeEvent);
+      stat = NFA_EeModeSet(handle, mode);
+      if (stat == NFA_STATUS_OK && !android::nfcManager_isNfcDisabling() &&
+          (android::nfcManager_getNfcState() != NFC_OFF)) {
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("Waiting for Mode Set Ntf");
+        /*ModeSetNtf wait timeout is increased for the synchronization with
+         *dual mode involving with RF and triple mode*/
+        if (pEeSetModeEvent->wait(DWP_LINK_ACTV_TIMEOUT) == false) {
+          LOG(ERROR) << StringPrintf("%s: timeout waiting for setModeNtf",
+                                     __func__);
+          stat = NFA_STATUS_FAILED;
+        }
+      }
+    } else {
+      SyncEventGuard guard(mEeSetModeEvent);
+      stat = NFA_EeModeSet(handle, mode);
+      if (stat == NFA_STATUS_OK && !android::nfcManager_isNfcDisabling() &&
+          (android::nfcManager_getNfcState() != NFC_OFF)) {
+        /*EeSetModeEvent wait timeout is increased for the synchronization with
+         * dual mode involving with RF and triple mode*/
+        if (mEeSetModeEvent.wait(DWP_LINK_ACTV_TIMEOUT) == false) {
+          LOG(ERROR) << StringPrintf("%s: timeout waiting for setModeEvt",
+                                     __func__);
+          stat = NFA_STATUS_FAILED;
+        }
+      } else {
+        // do nothing
+      }
+    }
+  } else {
+    SyncEventGuard guard(mEeSetModeEvent);
+    stat = NFA_EeModeSet(handle, mode);
+    if (stat == NFA_STATUS_OK && !android::nfcManager_isNfcDisabling() &&
+        (android::nfcManager_getNfcState() != NFC_OFF)) {
+      mEeSetModeEvent.wait();
+    } else {
+      // do nothing
     }
-
-    if(nfcFL.nfcNxpEse) {
-        if(nfcFL.eseFL._JCOP_WA_ENABLE && (active_ese_reset_control&RESET_BLOCKED))
-        {
-            SyncEventGuard guard (sSecElem.mResetOngoingEvent);
-            sSecElem.mResetOngoingEvent.notifyOne();
-        }
+  }
+  if (nfcFL.nfcNxpEse) {
+    if (nfcFL.eseFL._JCOP_WA_ENABLE &&
+        (active_ese_reset_control & RESET_BLOCKED)) {
+      SyncEventGuard guard(sSecElem.mResetOngoingEvent);
+      sSecElem.mResetOngoingEvent.notifyOne();
     }
-    return stat;
+  }
+  return stat;
 }
 /**********************************************************************************
  **
@@ -4762,24 +4587,24 @@ tNFA_STATUS SecureElement::SecElem_EeModeSet(uint16_t handle, uint8_t mode)
  ** Returns:         EE status
  **
  **********************************************************************************/
-uint16_t SecureElement::getEeStatus(uint16_t eehandle)
-{
-    int i;
-    uint16_t ee_status = NFA_EE_STATUS_REMOVED;
-    ALOGV("%s  num_nfcee_present = %d",__func__,mNfceeData_t.mNfceePresent);
-
-    for(i = 1; i<= mNfceeData_t.mNfceePresent ; i++)
-    {
-        if(mNfceeData_t.mNfceeHandle[i] == eehandle)
-        {
-            ee_status = mNfceeData_t.mNfceeStatus[i];
-            ALOGV("%s  EE is detected 0x%02x  status = 0x%02x",__func__,eehandle,ee_status);
-            break;
-        }
-    }
-    return ee_status;
+uint16_t SecureElement::getEeStatus(uint16_t eehandle) {
+  int i;
+  uint16_t ee_status = NFA_EE_STATUS_REMOVED;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s  num_nfcee_present = %d", __func__, mNfceeData_t.mNfceePresent);
+
+  for (i = 1; i <= mNfceeData_t.mNfceePresent; i++) {
+    if (mNfceeData_t.mNfceeHandle[i] == eehandle) {
+      ee_status = mNfceeData_t.mNfceeStatus[i];
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s  EE is detected 0x%02x  status = 0x%02x",
+                          __func__, eehandle, ee_status);
+      break;
+    }
+  }
+  return ee_status;
 }
-#if(NXP_EXTNS == TRUE)
+#if (NXP_EXTNS == TRUE)
 /**********************************************************************************
  **
  ** Function:        getUiccStatus
@@ -4789,53 +4614,46 @@ uint16_t SecureElement::getEeStatus(uint16_t eehandle)
  ** Returns:         UICC Status
  **
  **********************************************************************************/
-uicc_stat_t SecureElement::getUiccStatus(uint8_t selected_uicc)
-{
-    uint16_t ee_stat = NFA_EE_STATUS_REMOVED;
-
-    if(nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH)
-    {
-        if(selected_uicc == 0x01)
-            ee_stat = getEeStatus(EE_HANDLE_0xF4);
-        else if(selected_uicc == 0x02)
-            ee_stat = getEeStatus(EE_HANDLE_0xF8);
-    }
-    if(nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH)
-        ee_stat = getEeStatus(EE_HANDLE_0xF4);
-
-    uicc_stat_t uicc_stat = UICC_STATUS_UNKNOWN;
-
-    if(selected_uicc == 0x01)
-    {
-        switch(ee_stat)
-        {
-        case 0x00:
-            uicc_stat = UICC_01_SELECTED_ENABLED;
-            break;
-        case 0x01:
-            uicc_stat = UICC_01_SELECTED_DISABLED;
-            break;
-        case 0x02:
-            uicc_stat = UICC_01_REMOVED;
-            break;
-        }
+uicc_stat_t SecureElement::getUiccStatus(uint8_t selected_uicc) {
+  uint16_t ee_stat = NFA_EE_STATUS_REMOVED;
+
+  if (nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) {
+    if (selected_uicc == 0x01)
+      ee_stat = getEeStatus(EE_HANDLE_0xF4);
+    else if (selected_uicc == 0x02)
+      ee_stat = getEeStatus(EE_HANDLE_0xF8);
+  }
+  if (nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH)
+    ee_stat = getEeStatus(EE_HANDLE_0xF4);
+
+  uicc_stat_t uicc_stat = UICC_STATUS_UNKNOWN;
+
+  if (selected_uicc == 0x01) {
+    switch (ee_stat) {
+      case 0x00:
+        uicc_stat = UICC_01_SELECTED_ENABLED;
+        break;
+      case 0x01:
+        uicc_stat = UICC_01_SELECTED_DISABLED;
+        break;
+      case 0x02:
+        uicc_stat = UICC_01_REMOVED;
+        break;
     }
-    else if(selected_uicc == 0x02)
-    {
-        switch(ee_stat)
-        {
-        case 0x00:
-            uicc_stat = UICC_02_SELECTED_ENABLED;
-            break;
-        case 0x01:
-            uicc_stat = UICC_02_SELECTED_DISABLED;
-            break;
-        case 0x02:
-            uicc_stat = UICC_02_REMOVED;
-            break;
-        }
+  } else if (selected_uicc == 0x02) {
+    switch (ee_stat) {
+      case 0x00:
+        uicc_stat = UICC_02_SELECTED_ENABLED;
+        break;
+      case 0x01:
+        uicc_stat = UICC_02_SELECTED_DISABLED;
+        break;
+      case 0x02:
+        uicc_stat = UICC_02_REMOVED;
+        break;
     }
-    return uicc_stat;
+  }
+  return uicc_stat;
 }
 
 /**********************************************************************************
@@ -4847,67 +4665,52 @@ uicc_stat_t SecureElement::getUiccStatus(uint8_t selected_uicc)
  ** Returns:         Number of new NFCEEs discovered
  **
  **********************************************************************************/
-uint8_t SecureElement::updateNfceeDiscoverInfo()
-{
-    uint8_t numEe = nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED;
-    tNFA_EE_INFO mEeInfo[numEe];
-    tNFA_STATUS nfaStat;
-
-    if((nfaStat = NFA_AllEeGetInfo(&numEe, mEeInfo)) != NFA_STATUS_OK)
-    {
-        ALOGV("%s failed to get info, error = 0x%X ",__func__, nfaStat);
-        mActualNumEe = 0;
-
-    }
-    for(int xx = 0; xx < numEe ; xx++ )
-    {
-        if(mEeInfo[xx].ee_handle == EE_HANDLE_0xF3)
-        {
-            if(!(nfcee_swp_discovery_status & SWP2_ESE))
-            {
-                nfcee_swp_discovery_status |= SWP2_ESE;
-                gSeDiscoverycount++;
-            }
-        }else if(mEeInfo[xx].ee_handle == EE_HANDLE_0xF4)
-        {
-            if(!(nfcee_swp_discovery_status & SWP1_UICC1))
-            {
-                nfcee_swp_discovery_status |= SWP1_UICC1;
-                gSeDiscoverycount++;
-            }
-        }
-        else if(mEeInfo[xx].ee_handle == EE_HANDLE_0xF8)
-        {
-            if(!(nfcee_swp_discovery_status & SWP1A_UICC2))
-            {
-                nfcee_swp_discovery_status |= SWP1A_UICC2;
-                gSeDiscoverycount++;
-            }
-        }else if(mEeInfo[xx].ee_handle == EE_HANDLE_HCI)
-        {
-            if(!(nfcee_swp_discovery_status & HCI_ACESS))
-            {
-                nfcee_swp_discovery_status |= HCI_ACESS;
-                gSeDiscoverycount++;
-            }
-        }else if(mEeInfo[xx].ee_handle == EE_HANDLE_NDEFEE)
-        {
-            if(!(nfcee_swp_discovery_status & T4T_NDEFEE))
-            {
-                nfcee_swp_discovery_status |= T4T_NDEFEE;
-                gSeDiscoverycount++;
-            }
-        }
-        else
-        {
-            ALOGV("%s INVALID HANDLE ",__func__);
-        }
+uint8_t SecureElement::updateNfceeDiscoverInfo() {
+  uint8_t numEe = nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED;
+  tNFA_EE_INFO mEeInfo[numEe];
+  tNFA_STATUS nfaStat;
+
+  if ((nfaStat = NFA_AllEeGetInfo(&numEe, mEeInfo)) != NFA_STATUS_OK) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s failed to get info, error = 0x%X ", __func__, nfaStat);
+    mActualNumEe = 0;
+  }
+  for (int xx = 0; xx < numEe; xx++) {
+    if (mEeInfo[xx].ee_handle == EE_HANDLE_0xF3) {
+      if (!(nfcee_swp_discovery_status & SWP2_ESE)) {
+        nfcee_swp_discovery_status |= SWP2_ESE;
+        gSeDiscoverycount++;
+      }
+    } else if (mEeInfo[xx].ee_handle == EE_HANDLE_0xF4) {
+      if (!(nfcee_swp_discovery_status & SWP1_UICC1)) {
+        nfcee_swp_discovery_status |= SWP1_UICC1;
+        gSeDiscoverycount++;
+      }
+    } else if (mEeInfo[xx].ee_handle == EE_HANDLE_0xF8) {
+      if (!(nfcee_swp_discovery_status & SWP1A_UICC2)) {
+        nfcee_swp_discovery_status |= SWP1A_UICC2;
+        gSeDiscoverycount++;
+      }
+    } else if (mEeInfo[xx].ee_handle == EE_HANDLE_HCI) {
+      if (!(nfcee_swp_discovery_status & HCI_ACESS)) {
+        nfcee_swp_discovery_status |= HCI_ACESS;
+        gSeDiscoverycount++;
+      }
+    } else if (mEeInfo[xx].ee_handle == EE_HANDLE_NDEFEE) {
+      if (!(nfcee_swp_discovery_status & T4T_NDEFEE)) {
+        nfcee_swp_discovery_status |= T4T_NDEFEE;
+        gSeDiscoverycount++;
+      }
+    } else {
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("%s INVALID HANDLE ", __func__);
     }
-    return gSeDiscoverycount;
+  }
+  return gSeDiscoverycount;
 }
 
 #endif
-#if(NXP_EXTNS == TRUE)
+#if (NXP_EXTNS == TRUE)
 /*******************************************************************************
  **
  ** Function:       SecElem_sendEvt_Abort
@@ -4918,40 +4721,38 @@ uint8_t SecureElement::updateNfceeDiscoverInfo()
  **
  *******************************************************************************/
 
-tNFA_STATUS SecureElement::SecElem_sendEvt_Abort()
-{
-    if(!nfcFL.nfcNxpEse) {
-        ALOGE("%s nfcNxpEse not available. Returning",__func__);
-        return NFA_STATUS_FAILED;
-    }
-    static const char fn[] = "SecureElement::SecElem_sendEvt_Abort";
-    tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
-    int32_t timeoutMillisec = 10000;
-    uint8_t atr_len = 0x10;
-    uint8_t recvBuffer[MAX_RESPONSE_SIZE];
-    mAbortEventWaitOk = false;
-
-    if(nfcFL.nfccFL._NFCEE_REMOVED_NTF_RECOVERY &&
-            (RoutingManager::getInstance().is_ee_recovery_ongoing())) {
-        SyncEventGuard guard (mEEdatapacketEvent);
-        if(mEEdatapacketEvent.wait(android::gMaxEERecoveryTimeout) == false)
-        {
-            return nfaStat;
-        }
-    }
-
-    SyncEventGuard guard (mAbortEvent);
-    nfaStat = NFA_HciSendEvent(mNfaHciHandle, mNewPipeId, EVT_ABORT, 0, NULL, atr_len, recvBuffer, timeoutMillisec);
-    if(nfaStat == NFA_STATUS_OK)
-    {
-        mAbortEvent.wait();
-    }
-    if(mAbortEventWaitOk == false)
-    {
-        ALOGE("%s (EVT_ABORT)Wait reposne timeout",fn);
-        return NFA_STATUS_FAILED;
-    }
-    return nfaStat;
+tNFA_STATUS SecureElement::SecElem_sendEvt_Abort() {
+  if (!nfcFL.nfcNxpEse) {
+    LOG(ERROR) << StringPrintf("%s nfcNxpEse not available. Returning",
+                               __func__);
+    return NFA_STATUS_FAILED;
+  }
+  static const char fn[] = "SecureElement::SecElem_sendEvt_Abort";
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+  int32_t timeoutMillisec = 10000;
+  uint8_t atr_len = 0x10;
+  uint8_t recvBuffer[MAX_RESPONSE_SIZE];
+  mAbortEventWaitOk = false;
+
+  if (nfcFL.nfccFL._NFCEE_REMOVED_NTF_RECOVERY &&
+      (RoutingManager::getInstance().is_ee_recovery_ongoing())) {
+    SyncEventGuard guard(mEEdatapacketEvent);
+    if (mEEdatapacketEvent.wait(android::gMaxEERecoveryTimeout) == false) {
+      return nfaStat;
+    }
+  }
+
+  SyncEventGuard guard(mAbortEvent);
+  nfaStat = NFA_HciSendEvent(mNfaHciHandle, mNewPipeId, EVT_ABORT, 0, NULL,
+                             atr_len, recvBuffer, timeoutMillisec);
+  if (nfaStat == NFA_STATUS_OK) {
+    mAbortEvent.wait();
+  }
+  if (mAbortEventWaitOk == false) {
+    LOG(ERROR) << StringPrintf("%s (EVT_ABORT)Wait reposne timeout", fn);
+    return NFA_STATUS_FAILED;
+  }
+  return nfaStat;
 }
 
 /*******************************************************************************
@@ -4964,110 +4765,118 @@ tNFA_STATUS SecureElement::SecElem_sendEvt_Abort()
  **
  *******************************************************************************/
 
-void SecureElement::setDwpTranseiveState(bool block, tNFCC_EVTS_NTF action)
-{
-    if(!nfcFL.nfcNxpEse) {
-        ALOGE("%s nfcNxpEse not available. Returning",__func__);
-        return;
-    }
-    ALOGV("%s  block = %d action = %d ",__func__,block,action);
-
-    switch(action)
-    {
-        case NFCC_RF_FIELD_EVT:
-            if(!block)
-            {
-                SyncEventGuard guard (mRfFieldOffEvent);
-                mRfFieldOffEvent.notifyOne();
-            }
-        case NFCC_DEACTIVATED_NTF:
-        case NFCC_CE_DATA_EVT:
-            if(block)
-            {
-                mIsWiredModeBlocked = true;
-                if(action == NFCC_RF_FIELD_EVT)
-                {
-                    if(nfcFL.nfcNxpEse &&
-                            nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION &&
-                            (meseUiccConcurrentAccess == false)) {
-                        if(nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME != nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
-                            SecureElement::getInstance().mRfFieldEventTimer.set(
-                                    SecureElement::getInstance().mRfFieldEventTimeout, rfFeildEventTimeoutCallback);
-                        }
-                    }
-                    else if(nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME == nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
-                        SecureElement::getInstance().mRfFieldEventTimer.set(
-                                SecureElement::getInstance().mRfFieldEventTimeout, rfFeildEventTimeoutCallback);
-
-                    }
-                }
-            }
-            else
-            {
-                mIsWiredModeBlocked = false;
-
-                if(nfcFL.nfcNxpEse &&
-                        nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION &&
-                        (meseUiccConcurrentAccess == false)) {
-                    if(nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME != nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
-                        SecureElement::getInstance().mRfFieldEventTimer.kill();
-                    }
-                }
-                else if(nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME == nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
-                    SecureElement::getInstance().mRfFieldEventTimer.kill();
-                }
-                if(hold_wired_mode)
-                {
-                    SyncEventGuard guard (mWiredModeHoldEvent);
-                    mWiredModeHoldEvent.notifyOne();
-                    hold_wired_mode = false;
-                }
-            }
-            break;
-        case NFCC_ACTIVATED_NTF:
-        case NFCC_ACTION_NTF:
-        case NFCC_RF_TIMEOUT_EVT:
-            if(nfcFL.nfcNxpEse &&
-                    nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION &&
-                    (meseUiccConcurrentAccess == false)) {
-                if(nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME != nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
-                    SecureElement::getInstance().mRfFieldEventTimer.kill();
-                }
-            }
-            else if(nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME == nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
-                SecureElement::getInstance().mRfFieldEventTimer.kill();
+void SecureElement::setDwpTranseiveState(bool block, tNFCC_EVTS_NTF action) {
+  if (!nfcFL.nfcNxpEse) {
+    LOG(ERROR) << StringPrintf("%s nfcNxpEse not available. Returning",
+                               __func__);
+    return;
+  }
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s  block = %d action = %d ", __func__, block, action);
+
+  switch (action) {
+    case NFCC_RF_FIELD_EVT:
+      if (!block) {
+        SyncEventGuard guard(mRfFieldOffEvent);
+        mRfFieldOffEvent.notifyOne();
+      }
+    case NFCC_DEACTIVATED_NTF:
+    case NFCC_CE_DATA_EVT:
+      if (block) {
+        mIsWiredModeBlocked = true;
+        if (action == NFCC_RF_FIELD_EVT) {
+          if (nfcFL.nfcNxpEse &&
+              nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION &&
+              (meseUiccConcurrentAccess == false)) {
+            if (nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME !=
+                nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
+              SecureElement::getInstance().mRfFieldEventTimer.set(
+                  SecureElement::getInstance().mRfFieldEventTimeout,
+                  rfFeildEventTimeoutCallback);
             }
-            if(!block)
-            {
-                mIsWiredModeBlocked = false;
-                if(hold_wired_mode)
-                {
-                    SyncEventGuard guard (mWiredModeHoldEvent);
-                    mWiredModeHoldEvent.notifyOne();
-                    hold_wired_mode = false;
-                }
-            }
-            else
-            {
-                mIsWiredModeBlocked = true;
-            }
-    }
-    ALOGV("%s  Exit",__func__);
+          } else if (nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME ==
+                     nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
+            SecureElement::getInstance().mRfFieldEventTimer.set(
+                SecureElement::getInstance().mRfFieldEventTimeout,
+                rfFeildEventTimeoutCallback);
+          }
+        }
+      } else {
+        mIsWiredModeBlocked = false;
+
+        if (nfcFL.nfcNxpEse &&
+            nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION &&
+            (meseUiccConcurrentAccess == false)) {
+          if (nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME !=
+              nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
+            SecureElement::getInstance().mRfFieldEventTimer.kill();
+          }
+        } else if (nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME ==
+                   nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
+          SecureElement::getInstance().mRfFieldEventTimer.kill();
+        }
+        if (hold_wired_mode) {
+          SyncEventGuard guard(mWiredModeHoldEvent);
+          mWiredModeHoldEvent.notifyOne();
+          hold_wired_mode = false;
+        }
+      }
+      break;
+    case NFCC_ACTIVATED_NTF:
+    case NFCC_ACTION_NTF:
+    case NFCC_RF_TIMEOUT_EVT:
+      if (nfcFL.nfcNxpEse &&
+          nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION &&
+          (meseUiccConcurrentAccess == false)) {
+        if (nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME !=
+            nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
+          SecureElement::getInstance().mRfFieldEventTimer.kill();
+        }
+      } else if (nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME ==
+                 nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
+        SecureElement::getInstance().mRfFieldEventTimer.kill();
+      }
+      if (!block) {
+        mIsWiredModeBlocked = false;
+        if (hold_wired_mode) {
+          SyncEventGuard guard(mWiredModeHoldEvent);
+          mWiredModeHoldEvent.notifyOne();
+          hold_wired_mode = false;
+        }
+      } else {
+        mIsWiredModeBlocked = true;
+      }
+  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s  Exit", __func__);
 }
 
 /*******************************************************************************
 **
 ** Function         rfFeildEventTimeoutCallback
 **
-** Description      Call back funtion to resume wired mode after RF field event timeout
+** Description      Call back funtion to resume wired mode after RF field event
+*timeout
 **
 ** Returns          void
 **
 *******************************************************************************/
-static void rfFeildEventTimeoutCallback(union sigval)
-{
-    ALOGV("rfFeildEventTimeoutCallback  Enter");
-    SecureElement::getInstance().setDwpTranseiveState(false, NFCC_RF_FIELD_EVT);
+static void rfFeildEventTimeoutCallback(union sigval) {
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("rfFeildEventTimeoutCallback  Enter");
+  SecureElement::getInstance().setDwpTranseiveState(false, NFCC_RF_FIELD_EVT);
+}
+
+/*******************************************************************************
+**
+** Function         getLastRfFiledToggleTime
+**
+** Description      Provides the last RF filed toggile timer
+**
+** Returns          timespec
+**
+*******************************************************************************/
+struct timespec SecureElement::getLastRfFiledToggleTime(void) {
+  return mLastRfFieldToggle;
 }
 #endif
 
@@ -5080,37 +4889,63 @@ static void rfFeildEventTimeoutCallback(union sigval)
 ** Returns          status
 **
 *******************************************************************************/
-tNFA_STATUS SecureElement::setNfccPwrConfig(uint8_t value)
-{
-    if(!nfcFL.eseFL._WIRED_MODE_STANDBY) {
-        ALOGV("WIRED_MODE_STANDBY not enabled. Returning");
-        return NFA_STATUS_FAILED;
-    }
-
-    tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
-    static uint8_t cur_value = 0xFF;
-
-    /*if(cur_value == value)
-    {
-        mPwrCmdstatus = NFA_STATUS_OK;
-    }
-    else*/
-    if(!android::nfcManager_isNfcActive()||
-            android::nfcManager_isNfcDisabling() ||
-                (android::nfcManager_getNfcState() == NFC_OFF))
-    {
-       ALOGE("%s: NFC is no longer active.", __func__);
-       return NFA_STATUS_OK;
-    }
-    else
-    {
-        cur_value = value;
-        SyncEventGuard guard (mPwrLinkCtrlEvent);
-        nfaStat = NFA_SendPowerLinkCommand((uint8_t)EE_HANDLE_0xF3, value);
-        if(nfaStat ==  NFA_STATUS_OK && !android::nfcManager_isNfcDisabling())
-            mPwrLinkCtrlEvent.wait(NFC_CMD_TIMEOUT);
-    }
-    return mPwrCmdstatus;
+tNFA_STATUS SecureElement::setNfccPwrConfig(uint8_t value) {
+  if (!nfcFL.eseFL._WIRED_MODE_STANDBY) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("WIRED_MODE_STANDBY not enabled. Returning");
+    return NFA_STATUS_FAILED;
+  }
+
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+  static uint8_t cur_value = 0xFF;
+
+  /*if(cur_value == value)
+  {
+      mPwrCmdstatus = NFA_STATUS_OK;
+  }
+  else*/
+  if (!android::nfcManager_isNfcActive() ||
+      android::nfcManager_isNfcDisabling() ||
+      (android::nfcManager_getNfcState() == NFC_OFF)) {
+    LOG(ERROR) << StringPrintf("%s: NFC is no longer active.", __func__);
+    return NFA_STATUS_OK;
+  } else {
+    if ((dual_mode_current_state & SPI_ON) && (value == NFCC_DECIDES)) {
+      DLOG_IF(ERROR, nfc_debug_enabled) << StringPrintf(
+          "%s: SPI session is open. Host controls power-link configuration to eSE", __func__);
+      return NFA_STATUS_FAILED;
+    }
+    cur_value = value;
+    SyncEventGuard guard(mPwrLinkCtrlEvent);
+    nfaStat = NFA_SendPowerLinkCommand((uint8_t)EE_HANDLE_0xF3, value);
+    if (nfaStat == NFA_STATUS_OK && !android::nfcManager_isNfcDisabling())
+      if (mPwrLinkCtrlEvent.wait(DWP_LINK_ACTV_TIMEOUT) == false) {
+        DLOG_IF(ERROR, nfc_debug_enabled)
+            << StringPrintf("%s: DWP_LINK_ACTV_TIMEOUT..", __func__);
+        mPwrCmdstatus = NFA_STATUS_FAILED;
+      }
+  }
+  return mPwrCmdstatus;
 }
 
+/*******************************************************************************
+**
+** Function         getGateAndPipeInfo
+**
+** Description      Retrieves already configured gate and pipe ID
+**
+** Returns          Gate and pipe id list
+**
+*******************************************************************************/
+tNFA_HCI_GET_GATE_PIPE_LIST SecureElement::getGateAndPipeInfo() {
+  tNFA_STATUS nfaStat = NFA_STATUS_FAILED;
+  SyncEventGuard guard(SecureElement::getInstance().mPipeListEvent);
+  SecureElement::getInstance().mNfaHciHandle = NFA_HANDLE_GROUP_HCI;
+  nfaStat =
+      NFA_HciGetGateAndPipeList(SecureElement::getInstance().mNfaHciHandle);
+  if (nfaStat == NFA_STATUS_OK) {
+    SecureElement::getInstance().mPipeListEvent.wait();
+  }
+  return mHciCfg;
+}
 #endif
diff --git a/nci/jni/SecureElement.h b/nci/jni/SecureElement.h
index 5043726b..67ab6bc3 100644
--- a/nci/jni/SecureElement.h
+++ b/nci/jni/SecureElement.h
@@ -17,7 +17,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -37,1055 +37,1015 @@
  *  controller.
  */
 #pragma once
-#include "SyncEvent.h"
 #include "DataQueue.h"
+#include "IntervalTimer.h"
 #include "NfcJniUtil.h"
 #include "RouteDataSet.h"
-#include "IntervalTimer.h"
-extern "C"
-{
-    #include "nfa_ee_api.h"
-    #include "nfa_hci_api.h"
-    #include "nfa_hci_defs.h"
-    #include "nfa_ce_api.h"
-    #include "phNxpExtns.h"
-#if(NXP_EXTNS == TRUE)
-    #include "phNfcTypes.h"
+#include "SyncEvent.h"
+#include "nfa_ce_api.h"
+#include "nfa_ee_api.h"
+#include "nfa_hci_api.h"
+#include "nfa_hci_defs.h"
+#include "phNxpExtns.h"
+#if (NXP_EXTNS == TRUE)
+#include "phNfcTypes.h"
 #endif
-}
-#if(NXP_EXTNS == TRUE)
+#if (NXP_EXTNS == TRUE)
 #define CONNECTIVITY_PIPE_ID_UICC1 0x0A
 #define CONNECTIVITY_PIPE_ID_UICC2 0x23
 
 #define SIG_NFC 44
+#define SIG_SPI_EVENT_HANDLER 45
 #endif
 #define SIGNAL_EVENT_SIZE 0x02
 typedef enum {
-    RESET_TRANSACTION_STATE,
-    SET_TRANSACTION_STATE
-}transaction_state_t;
-
-
-typedef enum dual_mode{
- SPI_DWPCL_NOT_ACTIVE = 0x00,
- CL_ACTIVE = 0x01,
- SPI_ON = 0x02,
- SPI_DWPCL_BOTH_ACTIVE = 0x03,
-}dual_mode_state;
-#if(NXP_EXTNS == TRUE)
-typedef enum connectivity_pipe_status{
-PIPE_DELETED,
-PIPE_CLOSED,
-PIPE_OPENED
-}pipe_status;
-
-typedef enum
-{
-    UICC_SESSION_NOT_INTIALIZED = 0x00,
-    UICC_CLEAR_ALL_PIPE_NTF_RECEIVED = 0x01,
-    UICC_SESSION_INTIALIZATION_DONE = 0x02
-}nfcee_disc_state;
-
-typedef enum
-{
-    TRANSCEIVE_STATUS_OK,
-    TRANSCEIVE_STATUS_FAILED,
-    TRANSCEIVE_STATUS_MAX_WTX_REACHED
+  RESET_TRANSACTION_STATE,
+  SET_TRANSACTION_STATE
+} transaction_state_t;
+
+typedef enum dual_mode {
+  SPI_DWPCL_NOT_ACTIVE = 0x00,
+  CL_ACTIVE = 0x01,
+  SPI_ON = 0x02,
+  SPI_DWPCL_BOTH_ACTIVE = 0x03,
+} dual_mode_state;
+#if (NXP_EXTNS == TRUE)
+typedef enum connectivity_pipe_status {
+  PIPE_DELETED,
+  PIPE_CLOSED,
+  PIPE_OPENED
+} pipe_status;
+
+typedef enum {
+  UICC_SESSION_NOT_INTIALIZED = 0x00,
+  UICC_CLEAR_ALL_PIPE_NTF_RECEIVED = 0x01,
+  UICC_SESSION_INTIALIZATION_DONE = 0x02
+} nfcee_disc_state;
+
+typedef enum {
+  TRANSCEIVE_STATUS_OK,
+  TRANSCEIVE_STATUS_FAILED,
+  TRANSCEIVE_STATUS_MAX_WTX_REACHED
 } eTransceiveStatus;
 #endif
 typedef enum {
-    STATE_IDLE = 0x00,
-    STATE_WK_ENBLE = 0x01,
-    STATE_WK_WAIT_RSP = 0x02,
-    STATE_TIME_OUT = 0x04,
-    STATE_DWP_CLOSE = 0x08,
-}spiDwpSyncState_t;
-
-typedef enum reset_management{
- TRANS_IDLE = 0x00,
- TRANS_WIRED_ONGOING = 0x01,
- TRANS_CL_ONGOING = 0x02,
- RESET_BLOCKED = 0x04,
-}ese_reset_control;
-typedef struct {
-    tNFA_HANDLE src;
-    tNFA_TECHNOLOGY_MASK tech_mask;
-    bool reCfg;
-}rd_swp_req_t;
-
-typedef enum
-{
-    STATE_SE_RDR_MODE_INVALID =0x00,
-    STATE_SE_RDR_MODE_START_CONFIG,
-    STATE_SE_RDR_MODE_START_IN_PROGRESS,
-    STATE_SE_RDR_MODE_STARTED,
-    STATE_SE_RDR_MODE_ACTIVATED,
-    STATE_SE_RDR_MODE_STOP_CONFIG,
-    STATE_SE_RDR_MODE_STOP_IN_PROGRESS,
-    STATE_SE_RDR_MODE_STOPPED,
-
-}se_rd_req_state_t;
-
-#if(NXP_EXTNS == TRUE)
-
-typedef enum
-{
-    UICC_01_SELECTED_ENABLED = 0x01,
-    UICC_01_SELECTED_DISABLED,
-    UICC_01_REMOVED,
-    UICC_02_SELECTED_ENABLED,
-    UICC_02_SELECTED_DISABLED,
-    UICC_02_REMOVED,
-    UICC_STATUS_UNKNOWN
-}uicc_stat_t;
-typedef enum
-{
-    SWP_DEFAULT = 0x00,
-    SWP1_UICC1 = 0x01,
-    SWP2_ESE = 0x02,
-    SWP1A_UICC2 = 0x04,
-    T4T_NDEFEE = 0x08,
-    HCI_ACESS = 0x10
-}nfcee_swp_getconfig_status;
-#endif
-typedef enum
-{   STATE_SE_RDR_FAILURE_NOT_SUPPORTED ,
-    STATE_SE_RDR_FAILURE_NOT_ALLOWED
+  STATE_IDLE = 0x00,
+  STATE_WK_ENBLE = 0x01,
+  STATE_WK_WAIT_RSP = 0x02,
+  STATE_TIME_OUT = 0x04,
+  STATE_DWP_CLOSE = 0x08,
+} spiDwpSyncState_t;
+
+typedef enum reset_management {
+  TRANS_IDLE = 0x00,
+  TRANS_WIRED_ONGOING = 0x01,
+  TRANS_CL_ONGOING = 0x02,
+  RESET_BLOCKED = 0x04,
+} ese_reset_control;
+
+#if (NXP_EXTNS == TRUE)
 
-}se_rd_req_failures_t;
+typedef enum {
+  UICC_01_SELECTED_ENABLED = 0x01,
+  UICC_01_SELECTED_DISABLED,
+  UICC_01_REMOVED,
+  UICC_02_SELECTED_ENABLED,
+  UICC_02_SELECTED_DISABLED,
+  UICC_02_REMOVED,
+  UICC_STATUS_UNKNOWN
+} uicc_stat_t;
+typedef enum {
+  SWP_DEFAULT = 0x00,
+  SWP1_UICC1 = 0x01,
+  SWP2_ESE = 0x02,
+  SWP1A_UICC2 = 0x04,
+  T4T_NDEFEE = 0x08,
+  HCI_ACESS = 0x10
+} nfcee_swp_getconfig_status;
+#endif
 
 #if (NXP_EXTNS == TRUE)
-typedef struct{
-    rd_swp_req_t swp_rd_req_info ;
-    rd_swp_req_t swp_rd_req_current_info ;
-    se_rd_req_state_t swp_rd_state;
-    se_rd_req_failures_t swp_rd_req_fail_cause;
-    Mutex mMutex;
-}Rdr_req_ntf_info_t;
-
-typedef enum operation{
-    STANDBY_TIMER_START,
-    STANDBY_TIMER_STOP,
-    STANDBY_TIMER_TIMEOUT,
-    STANDBY_GPIO_HIGH,
-    STANDBY_GPIO_LOW,
-    STANDBY_MODE_ON,      /* standby mode is on */
-    STANDBY_MODE_OFF,     /* standby mode is off */
-    STANDBY_MODE_SUSPEND, /* standby timer timed out */
-    STANDBY_MODE_TIMER_ON /* standby timer running */
-}nfcc_standby_operation_t;
-
-void spi_prio_signal_handler (int signum, siginfo_t *info, void *unused);
-
-typedef enum apdu_gate{
-    NO_APDU_GATE,
-    PROPREITARY_APDU_GATE,
-    ETSI_12_APDU_GATE
-}se_apdu_gate_info;
+typedef enum operation {
+  STANDBY_TIMER_START,
+  STANDBY_TIMER_STOP,
+  STANDBY_TIMER_TIMEOUT,
+  STANDBY_GPIO_HIGH,
+  STANDBY_GPIO_LOW,
+  STANDBY_MODE_ON,       /* standby mode is on */
+  STANDBY_MODE_OFF,      /* standby mode is off */
+  STANDBY_MODE_SUSPEND,  /* standby timer timed out */
+  STANDBY_MODE_TIMER_ON, /* standby timer running */
+  STANDBY_ESE_PWR_RELEASE,
+  STANDBY_ESE_PWR_ACQUIRE
+
+} nfcc_standby_operation_t;
+
+void spi_prio_signal_handler(int signum, siginfo_t* info, void* unused);
+
+typedef enum apdu_gate {
+  NO_APDU_GATE,
+  PROPREITARY_APDU_GATE,
+  ETSI_12_APDU_GATE
+} se_apdu_gate_info;
 #endif
-typedef enum nfcee_type
-{
-    UICC1 = 0x01,
-    UICC2 = 0x02,
-    ESE   = 0x04
-}nfcee_type_t;
-typedef enum
-{
-    NONE = 0x00,
-    FW_DOWNLOAD,
-    JCOP_DOWNLOAD
-}Downlaod_mode_t;
+typedef enum nfcee_type { UICC1 = 0x01, UICC2 = 0x02, ESE = 0x04 } nfcee_type_t;
+typedef enum { NONE = 0x00, FW_DOWNLOAD, JCOP_DOWNLOAD } Downlaod_mode_t;
 namespace android {
 extern SyncEvent sNfaEnableDisablePollingEvent;
-extern void startStopPolling (bool isStartPolling);
+extern void startStopPolling(bool isStartPolling);
 
 }  // namespace android
 
-class SecureElement
-{
-public:
-    tNFA_HANDLE  mActiveEeHandle;
-#if(NXP_EXTNS == TRUE)
+class SecureElement {
+ public:
+  tNFA_HANDLE mActiveEeHandle;
+#if (NXP_EXTNS == TRUE)
 #define MAX_NFCEE 5
-    struct mNfceeData
-    {
-        tNFA_HANDLE mNfceeHandle[MAX_NFCEE];
-        tNFA_EE_STATUS mNfceeStatus[MAX_NFCEE];
-        uint8_t mNfceePresent;
-    };
-    mNfceeData  mNfceeData_t;
-    uint8_t     mHostsPresent;
-    uint8_t     mETSI12InitStatus;
-    uint8_t     mHostsId[MAX_NFCEE];
-    uint8_t     eSE_Compliancy;
-    uint8_t     mCreatedPipe;
-    uint8_t     mDeletePipeHostId;
-    uint16_t    mWmMaxWtxCount;
-    bool        meseETSI12Recovery;
-    SyncEvent   mCreatePipeEvent;
-    SyncEvent   mPipeOpenedEvent;
-    SyncEvent   mAbortEvent;
-    bool        mAbortEventWaitOk;
-    bool enableDwp(void);
-    IntervalTimer sSwpReaderTimer; /*timer swp reader timeout*/
-    static const tNFA_HANDLE EE_HANDLE_0xF3 = 0x4C0;//0x401; //handle to secure element in slot 0
-    static const tNFA_HANDLE EE_HANDLE_0xF8 = 0x481; //handle to secure element in slot 2
-    tNFA_HANDLE EE_HANDLE_0xF4;               //handle to secure element in slot 1
-    static const tNFA_HANDLE EE_HANDLE_0xF0 = 0x400;//NFCEE handle for host
+  struct mNfceeData {
+    tNFA_HANDLE mNfceeHandle[MAX_NFCEE];
+    tNFA_EE_STATUS mNfceeStatus[MAX_NFCEE];
+    uint8_t mNfceePresent;
+  };
+  mNfceeData mNfceeData_t;
+  uint8_t mHostsPresent;
+  uint8_t mETSI12InitStatus;
+  uint8_t mHostsId[MAX_NFCEE];
+  uint8_t eSE_Compliancy;
+  uint8_t mCreatedPipe;
+  uint8_t mDeletePipeHostId;
+  uint16_t mWmMaxWtxCount;
+  bool meseETSI12Recovery;
+  SyncEvent mCreatePipeEvent;
+  SyncEvent mPipeOpenedEvent;
+  SyncEvent mAbortEvent;
+  SyncEvent mPipeStatusCheckEvent;
+  bool mAbortEventWaitOk;
+  SyncEvent mPipeListEvent;
+  tNFA_HANDLE mNfaHciHandle;  // NFA handle to NFA's HCI component
+  uint8_t pipeStatus;
+  bool IsCmdsentOnOpenDwpSession;
+  bool enableDwp(void);
+  static const tNFA_HANDLE EE_HANDLE_0xF3 =
+      0x4C0;  // 0x401; //handle to secure element in slot 0
+  static const tNFA_HANDLE EE_HANDLE_0xF8 =
+      0x481;                   // handle to secure element in slot 2
+  tNFA_HANDLE EE_HANDLE_0xF4;  // handle to secure element in slot 1
+  static const tNFA_HANDLE EE_HANDLE_0xF0 = 0x400;  // NFCEE handle for host
 #endif
-#define NCI_INTERFACE_UICC_DIRECT_STAT  0x82
-#define NCI_INTERFACE_ESE_DIRECT_STAT  0x83
-    static const int MAX_NUM_EE = NFA_EE_MAX_EE_SUPPORTED;    /*max number of EE's*/
-
-    /*******************************************************************************
-    **
-    ** Function:        getInstance
-    **
-    ** Description:     Get the SecureElement singleton object.
-    **
-    ** Returns:         SecureElement object.
-    **
-    *******************************************************************************/
-    static SecureElement& getInstance ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        initialize
-    **
-    ** Description:     Initialize all member variables.
-    **                  native: Native data.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    bool initialize (nfc_jni_native_data* native);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        finalize
-    **
-    ** Description:     Release all resources.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void finalize ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        getListOfEeHandles
-    **
-    ** Description:     Get the list of handles of all execution environments.
-    **                  e: Java Virtual Machine.
-    **
-    ** Returns:         List of handles of all execution environments.
-    **
-    *******************************************************************************/
-    jintArray getListOfEeHandles (JNIEnv* e);
-
-    /*******************************************************************************
-    **
-    ** Function:        getActiveSecureElementList
-    **
-    ** Description:     Get the list of handles of all execution environments.
-    **                  e: Java Virtual Machine.
-    **
-    ** Returns:         List of handles of all execution environments.
-    **
-    *******************************************************************************/
-    jintArray getActiveSecureElementList (JNIEnv* e);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        activate
-    **
-    ** Description:     Turn on the secure element.
-    **                  seID: ID of secure element.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    bool activate (jint seID);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        deactivate
-    **
-    ** Description:     Turn off the secure element.
-    **                  seID: ID of secure element.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    bool deactivate (jint seID);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        connectEE
-    **
-    ** Description:     Connect to the execution environment.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    bool connectEE ();
-
-    bool activateAllNfcee();
-    /*******************************************************************************
-    **
-    ** Function:        disconnectEE
-    **
-    ** Description:     Disconnect from the execution environment.
-    **                  seID: ID of secure element.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    bool disconnectEE (jint seID);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        transceive
-    **
-    ** Description:     Send data to the secure element; read it's response.
-    **                  xmitBuffer: Data to transmit.
-    **                  xmitBufferSize: Length of data.
-    **                  recvBuffer: Buffer to receive response.
-    **                  recvBufferMaxSize: Maximum size of buffer.
-    **                  recvBufferActualSize: Actual length of response.
-    **                  timeoutMillisec: timeout in millisecond
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-#if(NXP_EXTNS == TRUE)
-    eTransceiveStatus transceive (uint8_t* xmitBuffer, int32_t xmitBufferSize, uint8_t* recvBuffer,
-                     int32_t recvBufferMaxSize, int32_t& recvBufferActualSize, int32_t timeoutMillisec);
+#define NCI_INTERFACE_UICC_DIRECT_STAT 0x82
+#define NCI_INTERFACE_ESE_DIRECT_STAT 0x83
+  static const int MAX_NUM_EE = NFA_EE_MAX_EE_SUPPORTED; /*max number of EE's*/
+
+  /*******************************************************************************
+  **
+  ** Function:        getInstance
+  **
+  ** Description:     Get the SecureElement singleton object.
+  **
+  ** Returns:         SecureElement object.
+  **
+  *******************************************************************************/
+  static SecureElement& getInstance();
+
+  /*******************************************************************************
+  **
+  ** Function:        initialize
+  **
+  ** Description:     Initialize all member variables.
+  **                  native: Native data.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool initialize(nfc_jni_native_data* native);
+
+  /*******************************************************************************
+  **
+  ** Function:        finalize
+  **
+  ** Description:     Release all resources.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void finalize();
+
+  /*******************************************************************************
+  **
+  ** Function:        getListOfEeHandles
+  **
+  ** Description:     Get the list of handles of all execution environments.
+  **                  e: Java Virtual Machine.
+  **
+  ** Returns:         List of handles of all execution environments.
+  **
+  *******************************************************************************/
+  jintArray getListOfEeHandles(JNIEnv* e);
+
+  /*******************************************************************************
+  **
+  ** Function:        getActiveSecureElementList
+  **
+  ** Description:     Get the list of handles of all execution environments.
+  **                  e: Java Virtual Machine.
+  **
+  ** Returns:         List of handles of all execution environments.
+  **
+  *******************************************************************************/
+  jintArray getActiveSecureElementList(JNIEnv* e);
+
+  /*******************************************************************************
+  **
+  ** Function:        activate
+  **
+  ** Description:     Turn on the secure element.
+  **                  seID: ID of secure element.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool activate(jint seID);
+
+  /*******************************************************************************
+  **
+  ** Function:        deactivate
+  **
+  ** Description:     Turn off the secure element.
+  **                  seID: ID of secure element.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool deactivate(jint seID);
+
+  /*******************************************************************************
+  **
+  ** Function:        connectEE
+  **
+  ** Description:     Connect to the execution environment.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool connectEE();
+
+  bool activateAllNfcee();
+  /*******************************************************************************
+  **
+  ** Function:        disconnectEE
+  **
+  ** Description:     Disconnect from the execution environment.
+  **                  seID: ID of secure element.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool disconnectEE(jint seID);
+
+/*******************************************************************************
+**
+** Function:        transceive
+**
+** Description:     Send data to the secure element; read it's response.
+**                  xmitBuffer: Data to transmit.
+**                  xmitBufferSize: Length of data.
+**                  recvBuffer: Buffer to receive response.
+**                  recvBufferMaxSize: Maximum size of buffer.
+**                  recvBufferActualSize: Actual length of response.
+**                  timeoutMillisec: timeout in millisecond
+**
+** Returns:         True if ok.
+**
+*******************************************************************************/
+#if (NXP_EXTNS == TRUE)
+  eTransceiveStatus transceive(uint8_t* xmitBuffer, int32_t xmitBufferSize,
+                               uint8_t* recvBuffer, int32_t recvBufferMaxSize,
+                               int32_t& recvBufferActualSize,
+                               int32_t timeoutMillisec);
 #else
-    bool transceive (uint8_t* xmitBuffer, int32_t xmitBufferSize, uint8_t* recvBuffer,
-                     int32_t recvBufferMaxSize, int32_t& recvBufferActualSize, int32_t timeoutMillisec);
+  bool transceive(uint8_t* xmitBuffer, int32_t xmitBufferSize,
+                  uint8_t* recvBuffer, int32_t recvBufferMaxSize,
+                  int32_t& recvBufferActualSize, int32_t timeoutMillisec);
 #endif
 
-    void notifyModeSet (tNFA_HANDLE eeHandle, bool success, tNFA_EE_STATUS eeStatus);
-
-    /*******************************************************************************
-    **
-    ** Function:        notifyListenModeState
-    **
-    ** Description:     Notify the NFC service about whether the SE was activated
-    **                  in listen mode.
-    **                  isActive: Whether the secure element is activated.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void notifyListenModeState (bool isActivated);
-
-    /*******************************************************************************
-    **
-    ** Function:        notifyRfFieldEvent
-    **
-    ** Description:     Notify the NFC service about RF field events from the stack.
-    **                  isActive: Whether any secure element is activated.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void notifyRfFieldEvent (bool isActive);
-
-#if(NXP_EXTNS == TRUE)
-    /*******************************************************************************
-    **
-    ** Function:        notifyEEReaderEvent
-    **
-    ** Description:     Notify the NFC service about Reader over SWP events from the stack.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void notifyEEReaderEvent (int evt, int data);
-
-    /*******************************************************************************
-    **
-    ** Function:        initializeEeHandle
-    **
-    ** Description:     Set NFCEE handle.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    bool initializeEeHandle ();
+  void notifyModeSet(tNFA_HANDLE eeHandle, bool success,
+                     tNFA_EE_STATUS eeStatus);
+
+  /*******************************************************************************
+  **
+  ** Function:        notifyListenModeState
+  **
+  ** Description:     Notify the NFC service about whether the SE was activated
+  **                  in listen mode.
+  **                  isActive: Whether the secure element is activated.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void notifyListenModeState(bool isActivated);
+
+  /*******************************************************************************
+  **
+  ** Function:        notifyRfFieldEvent
+  **
+  ** Description:     Notify the NFC service about RF field events from the
+  *stack.
+  **                  isActive: Whether any secure element is activated.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void notifyRfFieldEvent(bool isActive);
+
+#if (NXP_EXTNS == TRUE)
+  /*******************************************************************************
+  **
+  ** Function:        initializeEeHandle
+  **
+  ** Description:     Set NFCEE handle.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool initializeEeHandle();
 #endif
 
-    /*******************************************************************************
-    **
-    ** Function:        resetRfFieldStatus ();
-    **
-    ** Description:     Resets the field status.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void resetRfFieldStatus ();
-
-    /*******************************************************************************
-    **
-    ** Function:        storeUiccInfo
-    **
-    ** Description:     Store a copy of the execution environment information from the stack.
-    **                  info: execution environment information.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void storeUiccInfo (tNFA_EE_DISCOVER_REQ& info);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        getUiccId
-    **
-    ** Description:     Get the ID of the secure element.
-    **                  eeHandle: Handle to the secure element.
-    **                  uid: Array to receive the ID.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    bool getUiccId (tNFA_HANDLE eeHandle, jbyteArray& uid);
-
-    /*******************************************************************************
-    **
-    ** Function:        notifyTransactionListenersOfAid
-    **
-    ** Description:     Notify the NFC service about a transaction event from secure element.
-    **                  aid: Buffer contains application ID.
-    **                  aidLen: Length of application ID.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void notifyTransactionListenersOfAid (const uint8_t* aid, uint8_t aidLen, const uint8_t* data, uint32_t dataLen,uint32_t evtSrc);
-
-    /*******************************************************************************
-    **
-    ** Function:        notifyConnectivityListeners
-    **
-    ** Description:     Notify the NFC service about a connectivity event from secure element.
-    **                  evtSrc: source of event UICC/eSE.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void notifyConnectivityListeners (uint8_t evtSrc);
-
-    /*******************************************************************************
-    **
-    ** Function:        notifyEmvcoMultiCardDetectedListeners
-    **
-    ** Description:     Notify the NFC service about a multiple card presented to
-    **                  Emvco reader.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void notifyEmvcoMultiCardDetectedListeners ();
-
-    /*******************************************************************************
-    **
-    ** Function:        notifyTransactionListenersOfTlv
-    **
-    ** Description:     Notify the NFC service about a transaction event from secure element.
-    **                  The type-length-value contains AID and parameter.
-    **                  tlv: type-length-value encoded in Basic Encoding Rule.
-    **                  tlvLen: Length tlv.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void notifyTransactionListenersOfTlv (const uint8_t* tlv, uint8_t tlvLen);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        connectionEventHandler
-    **
-    ** Description:     Receive card-emulation related events from stack.
-    **                  event: Event code.
-    **                  eventData: Event data.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void connectionEventHandler (uint8_t event, tNFA_CONN_EVT_DATA* eventData);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        applyRoutes
-    **
-    ** Description:     Read route data from XML and apply them again
-    **                  to every secure element.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void applyRoutes ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        setActiveSeOverride
-    **
-    ** Description:     Specify which secure element to turn on.
-    **                  activeSeOverride: ID of secure element
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void setActiveSeOverride (uint8_t activeSeOverride);
-
-    bool SecEle_Modeset(uint8_t type);
-    /*******************************************************************************
-    **
-    ** Function:        routeToSecureElement
-    **
-    ** Description:     Adjust controller's listen-mode routing table so transactions
-    **                  are routed to the secure elements as specified in route.xml.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    bool routeToSecureElement ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        isBusy
-    **
-    ** Description:     Whether NFC controller is routing listen-mode events or a pipe is connected.
-    **
-    ** Returns:         True if either case is true.
-    **
-    *******************************************************************************/
-    bool isBusy ();
-
-
-    /*******************************************************************************
-    **
-    ** Function         getActualNumEe
-    **
-    ** Description      Returns number of secure elements we know about.
-    **
-    ** Returns          Number of secure elements we know about.
-    **
-    *******************************************************************************/
-    uint8_t getActualNumEe();
-
-
-    /*******************************************************************************
-    **
-    ** Function         getSeVerInfo
-    **
-    ** Description      Gets version information and id for a secure element.  The
-    **                  seIndex parmeter is the zero based index of the secure
-    **                  element to get verion info for.  The version infommation
-    **                  is returned as a string int the verInfo parameter.
-    **
-    ** Returns          ture on success, false on failure
-    **
-    *******************************************************************************/
-    bool getSeVerInfo(int seIndex, char * verInfo, int verInfoSz, uint8_t * seid);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        isActivatedInListenMode
-    **
-    ** Description:     Can be used to determine if the SE is activated in listen mode
-    **
-    ** Returns:         True if the SE is activated in listen mode
-    **
-    *******************************************************************************/
-    bool isActivatedInListenMode();
-
-    /*******************************************************************************
-    **
-    ** Function:        isRfFieldOn
-    **
-    ** Description:     Can be used to determine if the SE is in an RF field
-    **
-    ** Returns:         True if the SE is activated in an RF field
-    **
-    *******************************************************************************/
-    bool isRfFieldOn();
-
-    /*******************************************************************************
-    **
-    ** Function:        setEseListenTechMask
-    **
-    ** Description:     Can be used to force ESE to only listen the specific
-    **                  Technologies.
-    **                  NFA_TECHNOLOGY_MASK_A       0x01
-    **                  NFA_TECHNOLOGY_MASK_B       0x02
-    **
-    ** Returns:         True if listening is configured.
-    **
-    *******************************************************************************/
-    bool setEseListenTechMask(uint8_t tech_mask);
-
-    bool sendEvent(uint8_t event);
-    /*******************************************************************************
-    **
-    ** Function:        getAtr
-    **
-    ** Description:     Can be used to get the ATR response from connected eSE
-    **
-    ** Returns:         True if ATR response is returned successfully
-    **
-    *******************************************************************************/
-    bool getAtr(jint seID, uint8_t* recvBuffer, int32_t *recvBufferSize);
-#if(NXP_EXTNS == TRUE)
-    bool getNfceeHostTypeList (void);
-    bool configureNfceeETSI12 ();
-    void eSE_ClearAllPipe_handler(uint8_t host);
-    /**********************************************************************************
-     **
-     ** Function:        getEeStatus
-     **
-     ** Description:     get the status of EE
-     **
-     ** Returns:         EE status .
-     **
-     **********************************************************************************/
-    uint16_t getEeStatus(uint16_t eehandle);
-
-    /**********************************************************************************
-     **
-     ** Function:        getUiccStatus
-     **
-     ** Description:     get the status of EE
-     **
-     ** Returns:         EE status .
-     **
-     **********************************************************************************/
-    uicc_stat_t getUiccStatus(uint8_t selected_uicc);
-
-    /*******************************************************************************
-     **
-     ** Function:        updateEEStatus
-     **
-     ** Description:     updateEEStatus
-     **                  Reads EE related information from libnfc
-     **                  and updates in JNI
-     **
-     ** Returns:         True if ok.
-     **
-    *******************************************************************************/
-    bool updateEEStatus ();
-
-    /*******************************************************************************
-     **
-     ** Function:        isTeckInfoReceived
-     **
-     ** Description:     isTeckInfoReceived
-     **                  Checks if discovery_req_ntf received
-     **                  for a given EE
-     **
-     ** Returns:         True if ok.
-     **
-     *******************************************************************************/
-    bool isTeckInfoReceived (uint16_t eeHandle);
+  /*******************************************************************************
+  **
+  ** Function:        resetRfFieldStatus ();
+  **
+  ** Description:     Resets the field status.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void resetRfFieldStatus();
+
+  /*******************************************************************************
+  **
+  ** Function:        storeUiccInfo
+  **
+  ** Description:     Store a copy of the execution environment information from
+  *the stack.
+  **                  info: execution environment information.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void storeUiccInfo(tNFA_EE_DISCOVER_REQ& info);
+
+  /*******************************************************************************
+  **
+  ** Function:        getUiccId
+  **
+  ** Description:     Get the ID of the secure element.
+  **                  eeHandle: Handle to the secure element.
+  **                  uid: Array to receive the ID.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool getUiccId(tNFA_HANDLE eeHandle, jbyteArray& uid);
+
+  /*******************************************************************************
+  **
+  ** Function:        notifyTransactionListenersOfAid
+  **
+  ** Description:     Notify the NFC service about a transaction event from
+  *secure element.
+  **                  aid: Buffer contains application ID.
+  **                  aidLen: Length of application ID.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void notifyTransactionListenersOfAid(const uint8_t* aid, uint8_t aidLen,
+                                       const uint8_t* data, uint32_t dataLen,
+                                       uint32_t evtSrc);
+
+  /*******************************************************************************
+  **
+  ** Function:        notifyConnectivityListeners
+  **
+  ** Description:     Notify the NFC service about a connectivity event from
+  *secure element.
+  **                  evtSrc: source of event UICC/eSE.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void notifyConnectivityListeners(uint8_t evtSrc);
+
+  /*******************************************************************************
+  **
+  ** Function:        notifyEmvcoMultiCardDetectedListeners
+  **
+  ** Description:     Notify the NFC service about a multiple card presented to
+  **                  Emvco reader.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void notifyEmvcoMultiCardDetectedListeners();
+
+  /*******************************************************************************
+  **
+  ** Function:        notifyTransactionListenersOfTlv
+  **
+  ** Description:     Notify the NFC service about a transaction event from
+  *secure element.
+  **                  The type-length-value contains AID and parameter.
+  **                  tlv: type-length-value encoded in Basic Encoding Rule.
+  **                  tlvLen: Length tlv.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void notifyTransactionListenersOfTlv(const uint8_t* tlv, uint8_t tlvLen);
+
+  /*******************************************************************************
+  **
+  ** Function:        connectionEventHandler
+  **
+  ** Description:     Receive card-emulation related events from stack.
+  **                  event: Event code.
+  **                  eventData: Event data.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void connectionEventHandler(uint8_t event, tNFA_CONN_EVT_DATA* eventData);
+
+  /*******************************************************************************
+  **
+  ** Function:        applyRoutes
+  **
+  ** Description:     Read route data from XML and apply them again
+  **                  to every secure element.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void applyRoutes();
+
+  /*******************************************************************************
+  **
+  ** Function:        setActiveSeOverride
+  **
+  ** Description:     Specify which secure element to turn on.
+  **                  activeSeOverride: ID of secure element
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void setActiveSeOverride(uint8_t activeSeOverride);
+
+  bool SecEle_Modeset(uint8_t type);
+  /*******************************************************************************
+  **
+  ** Function:        routeToSecureElement
+  **
+  ** Description:     Adjust controller's listen-mode routing table so
+  *transactions
+  **                  are routed to the secure elements as specified in
+  *route.xml.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool routeToSecureElement();
+
+  /*******************************************************************************
+  **
+  ** Function:        isBusy
+  **
+  ** Description:     Whether NFC controller is routing listen-mode events or a
+  *pipe is connected.
+  **
+  ** Returns:         True if either case is true.
+  **
+  *******************************************************************************/
+  bool isBusy();
+
+  /*******************************************************************************
+  **
+  ** Function         getActualNumEe
+  **
+  ** Description      Returns number of secure elements we know about.
+  **
+  ** Returns          Number of secure elements we know about.
+  **
+  *******************************************************************************/
+  uint8_t getActualNumEe();
+
+  /*******************************************************************************
+  **
+  ** Function         getSeVerInfo
+  **
+  ** Description      Gets version information and id for a secure element.  The
+  **                  seIndex parmeter is the zero based index of the secure
+  **                  element to get verion info for.  The version infommation
+  **                  is returned as a string int the verInfo parameter.
+  **
+  ** Returns          ture on success, false on failure
+  **
+  *******************************************************************************/
+  bool getSeVerInfo(int seIndex, char* verInfo, int verInfoSz, uint8_t* seid);
+
+  /*******************************************************************************
+  **
+  ** Function:        isActivatedInListenMode
+  **
+  ** Description:     Can be used to determine if the SE is activated in listen
+  *mode
+  **
+  ** Returns:         True if the SE is activated in listen mode
+  **
+  *******************************************************************************/
+  bool isActivatedInListenMode();
+
+  /*******************************************************************************
+  **
+  ** Function:        isRfFieldOn
+  **
+  ** Description:     Can be used to determine if the SE is in an RF field
+  **
+  ** Returns:         True if the SE is activated in an RF field
+  **
+  *******************************************************************************/
+  bool isRfFieldOn();
+
+  /*******************************************************************************
+  **
+  ** Function:        setEseListenTechMask
+  **
+  ** Description:     Can be used to force ESE to only listen the specific
+  **                  Technologies.
+  **                  NFA_TECHNOLOGY_MASK_A       0x01
+  **                  NFA_TECHNOLOGY_MASK_B       0x02
+  **
+  ** Returns:         True if listening is configured.
+  **
+  *******************************************************************************/
+  bool setEseListenTechMask(uint8_t tech_mask);
+
+  bool sendEvent(uint8_t event);
+  /*******************************************************************************
+  **
+  ** Function:        getAtr
+  **
+  ** Description:     Can be used to get the ATR response from connected eSE
+  **
+  ** Returns:         True if ATR response is returned successfully
+  **
+  *******************************************************************************/
+  bool getAtr(jint seID, uint8_t* recvBuffer, int32_t* recvBufferSize);
+#if (NXP_EXTNS == TRUE)
+  bool getNfceeHostTypeList(void);
+  bool configureNfceeETSI12();
+  bool checkPipeStatusAndRecreate();
+  void eSE_ClearAllPipe_handler(uint8_t host);
+  /**********************************************************************************
+   **
+   ** Function:        getEeStatus
+   **
+   ** Description:     get the status of EE
+   **
+   ** Returns:         EE status .
+   **
+   **********************************************************************************/
+  uint16_t getEeStatus(uint16_t eehandle);
+
+  /**********************************************************************************
+   **
+   ** Function:        getUiccStatus
+   **
+   ** Description:     get the status of EE
+   **
+   ** Returns:         EE status .
+   **
+   **********************************************************************************/
+  uicc_stat_t getUiccStatus(uint8_t selected_uicc);
+
+  /*******************************************************************************
+   **
+   ** Function:        updateEEStatus
+   **
+   ** Description:     updateEEStatus
+   **                  Reads EE related information from libnfc
+   **                  and updates in JNI
+   **
+   ** Returns:         True if ok.
+   **
+   *******************************************************************************/
+  bool updateEEStatus();
+
+  /*******************************************************************************
+   **
+   ** Function:        isTeckInfoReceived
+   **
+   ** Description:     isTeckInfoReceived
+   **                  Checks if discovery_req_ntf received
+   **                  for a given EE
+   **
+   ** Returns:         True if ok.
+   **
+   *******************************************************************************/
+  bool isTeckInfoReceived(uint16_t eeHandle);
 
 #endif
 
-#if(NXP_EXTNS == TRUE)
-    void etsiInitConfig();
-    tNFC_STATUS etsiReaderConfig(int eeHandle);
-    tNFC_STATUS etsiResetReaderConfig();
-
-    /*******************************************************************************
-    **
-    ** Function:        enablePassiveListen
-    **
-    ** Description:     Enable or disable listening to Passive A/B
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    uint16_t enablePassiveListen (uint8_t event);
-
-    uint16_t startThread(uint8_t thread_arg);
-
-    bool            mPassiveListenEnabled;
-    bool            meseUiccConcurrentAccess;
-    IntervalTimer   mPassiveListenTimer;
-    uint32_t        mPassiveListenTimeout;             //Retry timout value for passive listen enable timer
-    uint8_t         mPassiveListenCnt;                 //Retry cnt for passive listen enable timer
-    SyncEvent       mPassiveListenEvt;
-    Mutex           mPassiveListenMutex;
-    Mutex           mNfccStandbyMutex;
+#if (NXP_EXTNS == TRUE)
+  /*******************************************************************************
+  **
+  ** Function:        enablePassiveListen
+  **
+  ** Description:     Enable or disable listening to Passive A/B
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  uint16_t enablePassiveListen(uint8_t event);
+
+  uint16_t startThread(uint8_t thread_arg);
+
+  bool mPassiveListenEnabled;
+  bool meseUiccConcurrentAccess;
+  IntervalTimer mPassiveListenTimer;
+  uint32_t mPassiveListenTimeout;  // Retry timout value for passive listen
+                                   // enable timer
+  uint8_t mPassiveListenCnt;       // Retry cnt for passive listen enable timer
+  SyncEvent mPassiveListenEvt;
+  Mutex mPassiveListenMutex;
+  Mutex mNfccStandbyMutex;
 #endif
-    jint getSETechnology(tNFA_HANDLE eeHandle);
-    static const uint8_t UICC_ID = 0x02;
-    static const uint8_t UICC2_ID = 0x04;
-    static const uint8_t ESE_ID = 0x01;
-    static const uint8_t DH_ID = 0x00;
-#if(NXP_EXTNS == TRUE)
-    static const uint8_t eSE_Compliancy_ETSI_9 = 9;
-    static const uint8_t eSE_Compliancy_ETSI_12 = 12;
+  jint getSETechnology(tNFA_HANDLE eeHandle);
+  static const uint8_t UICC_ID = 0x02;
+  static const uint8_t UICC2_ID = 0x04;
+  static const uint8_t ESE_ID = 0x01;
+  static const uint8_t DH_ID = 0x00;
+#if (NXP_EXTNS == TRUE)
+  static const uint8_t eSE_Compliancy_ETSI_9 = 9;
+  static const uint8_t eSE_Compliancy_ETSI_12 = 12;
 #endif
 
-    void getEeHandleList(tNFA_HANDLE *list, uint8_t* count);
+  void getEeHandleList(tNFA_HANDLE* list, uint8_t* count);
 
-    tNFA_HANDLE getEseHandleFromGenericId(jint eseId);
+  tNFA_HANDLE getEseHandleFromGenericId(jint eseId);
 
-    jint getGenericEseId(tNFA_HANDLE handle);
-    uint8_t     mDownloadMode;
-#if(NXP_EXTNS == TRUE)
+  jint getGenericEseId(tNFA_HANDLE handle);
+  uint8_t mDownloadMode;
+#if (NXP_EXTNS == TRUE)
 
-    bool        meSESessionIdOk;
-    void        setCPTimeout();
-    SyncEvent   mRfFieldOffEvent;
-    void        NfccStandByOperation(nfcc_standby_operation_t value);
-    NFCSTATUS   eSE_Chip_Reset(void);
-    tNFA_STATUS SecElem_sendEvt_Abort();
-    tNFA_STATUS reconfigureEseHciInit();
+  bool meSESessionIdOk;
+  SyncEvent mRfFieldOffEvent;
+  void NfccStandByOperation(nfcc_standby_operation_t value);
+  NFCSTATUS eSE_Chip_Reset(void);
+  tNFA_STATUS SecElem_sendEvt_Abort();
+  tNFA_STATUS reconfigureEseHciInit();
 #endif
-    bool checkForWiredModeAccess();
-#if(NXP_EXTNS == TRUE)
-    se_apdu_gate_info getApduGateInfo();
+  bool checkForWiredModeAccess();
+#if (NXP_EXTNS == TRUE)
+  se_apdu_gate_info getApduGateInfo();
 #endif
-    SyncEvent       mRoutingEvent;
-    SyncEvent       mAidAddRemoveEvent;
-    SyncEvent       mUiccListenEvent;
-    SyncEvent       mEseListenEvent;
-    SyncEvent       mEeSetModeEvent;
-    SyncEvent       mModeSetNtf;
-    SyncEvent       mHciAddStaticPipe;
-    SyncEvent       mApduPaternAddRemoveEvent;
+  SyncEvent mRoutingEvent;
+  SyncEvent mAidAddRemoveEvent;
+  SyncEvent mUiccListenEvent;
+  SyncEvent mEseListenEvent;
+  SyncEvent mEeSetModeEvent;
+  SyncEvent mModeSetNtf;
+  SyncEvent mHciAddStaticPipe;
+  SyncEvent mApduPaternAddRemoveEvent;
 #if ((NXP_EXTNS == TRUE))
-    SyncEvent       mPwrLinkCtrlEvent;
+  SyncEvent mPwrLinkCtrlEvent;
 #endif
 
-#if(NXP_EXTNS == TRUE)
-    uint8_t getUiccGateAndPipeList(uint8_t uiccNo);
-    /*******************************************************************************
-    **
-    ** Function:        updateNfceeDiscoverInfo
-    **
-    ** Description:     Update the gSeDiscoverycount based on new NFCEE handle
-    **                  discovered
-    **
-    ** Returns:         Count of NFCEE discovered.
-    **
-    *******************************************************************************/
-    uint8_t updateNfceeDiscoverInfo();
-    tNFA_HANDLE getHciHandleInfo();
-    SyncEvent       mNfceeInitCbEvent;
-    tNFA_STATUS SecElem_EeModeSet(uint16_t handle, uint8_t mode);
-    SyncEvent       mEEdatapacketEvent;
-    SyncEvent       mTransceiveEvent;
-    static const uint8_t EVT_END_OF_APDU_TRANSFER = 0x21;    //NXP Propritory
-    bool            mIsWiredModeOpen;
-    bool            mlistenDisabled;
-    bool            mIsExclusiveWiredMode;
-    bool            mIsAllowWiredInDesfireMifareCE;
-    static const uint8_t EVT_ABORT = 0x11;  //ETSI12
-    static const uint8_t EVT_ABORT_MAX_RSP_LEN = 40;
-    bool    mIsWiredModeBlocked;   /* for wired mode resume feature support */
-    IntervalTimer   mRfFieldEventTimer;
-    uint32_t        mRfFieldEventTimeout;
-    tNFA_STATUS  mModeSetInfo;/*Mode set info status*/
-    static const uint8_t NFCC_DECIDES     = 0x00;     //NFCC decides
-    static const uint8_t POWER_ALWAYS_ON  = 0x01;     //NFCEE Power Supply always On
-    static const uint8_t COMM_LINK_ACTIVE = 0x02;     //NFCC to NFCEE Communication link always active when the NFCEE  is powered on.
-    static const uint8_t EVT_SUSPEND_APDU_TRANSFER = 0x31;
-    tNFA_STATUS  mPwrCmdstatus;     //completion status of the power link control command
-    uint8_t      mNfccPowerMode;
-    tNFA_STATUS  setNfccPwrConfig(uint8_t value);
-    bool mIsIntfRstEnabled;
-    void setCLState(bool mState);
-    void setDwpTranseiveState(bool state, tNFCC_EVTS_NTF action);
+#if (NXP_EXTNS == TRUE)
+  uint8_t getUiccGateAndPipeList(uint8_t uiccNo);
+  /*******************************************************************************
+  **
+  ** Function:        updateNfceeDiscoverInfo
+  **
+  ** Description:     Update the gSeDiscoverycount based on new NFCEE handle
+  **                  discovered
+  **
+  ** Returns:         Count of NFCEE discovered.
+  **
+  *******************************************************************************/
+  uint8_t updateNfceeDiscoverInfo();
+  tNFA_HANDLE getHciHandleInfo();
+  SyncEvent mNfceeInitCbEvent;
+  tNFA_STATUS SecElem_EeModeSet(uint16_t handle, uint8_t mode);
+  SyncEvent mEEdatapacketEvent;
+  SyncEvent mTransceiveEvent;
+  static const uint8_t EVT_END_OF_APDU_TRANSFER = 0x21;  // NXP Propritory
+  bool mIsWiredModeOpen;
+  bool mlistenDisabled;
+  bool mIsExclusiveWiredMode;
+  bool mIsAllowWiredInDesfireMifareCE;
+  static const uint8_t EVT_ABORT = 0x11;  // ETSI12
+  static const uint8_t EVT_ABORT_MAX_RSP_LEN = 40;
+  bool mIsWiredModeBlocked; /* for wired mode resume feature support */
+  IntervalTimer mRfFieldEventTimer;
+  uint32_t mRfFieldEventTimeout;
+  tNFA_STATUS mModeSetInfo;                      /*Mode set info status*/
+  static const uint8_t NFCC_DECIDES = 0x00;      // NFCC decides
+  static const uint8_t POWER_ALWAYS_ON = 0x01;   // NFCEE Power Supply always On
+  static const uint8_t COMM_LINK_ACTIVE = 0x02;  // NFCC to NFCEE Communication
+                                                 // link always active when the
+                                                 // NFCEE  is powered on.
+  static const uint8_t EVT_SUSPEND_APDU_TRANSFER = 0x31;
+  tNFA_STATUS
+      mPwrCmdstatus;  // completion status of the power link control command
+  uint8_t mNfccPowerMode;
+  tNFA_STATUS setNfccPwrConfig(uint8_t value);
+  tNFA_HCI_GET_GATE_PIPE_LIST getGateAndPipeInfo();
+  bool mIsIntfRstEnabled;
+  void setCLState(bool mState);
+  void setDwpTranseiveState(bool state, tNFCC_EVTS_NTF action);
+
+  /*******************************************************************************
+  **
+  ** Function         getLastRfFiledToggleTime
+  **
+  ** Description      Provides the last RF filed toggile timer
+  **
+  ** Returns          timespec
+  **
+  *******************************************************************************/
+  struct timespec getLastRfFiledToggleTime(void);
 #endif
 
-private:
-    static uint8_t mStaticPipeProp;
-    static const unsigned int MAX_RESPONSE_SIZE = 0x8800;//1024; //34K
-    enum RouteSelection {NoRoute, DefaultRoute, SecElemRoute};
-    static const uint8_t STATIC_PIPE_0x71 = 0x71; //Broadcom's proprietary static pipe
-    static const uint8_t EVT_SEND_DATA = 0x10;    //see specification ETSI TS 102 622 v9.0.0 (Host Controller Interface); section 9.3.3.3
-#if(NXP_EXTNS == TRUE)
-    static const uint8_t STATIC_PIPE_UICC = 0x20; //UICC's proprietary static pipe
-    static const tNFA_HANDLE EE_HANDLE_HCI  = 0x401;
-    static const tNFA_HANDLE EE_HANDLE_NDEFEE = 0x410;
+ private:
+  static uint8_t mStaticPipeProp;
+  static const unsigned int MAX_RESPONSE_SIZE = 0x8800;  // 1024; //34K
+  enum RouteSelection { NoRoute, DefaultRoute, SecElemRoute };
+  static const uint8_t STATIC_PIPE_0x71 =
+      0x71;  // Broadcom's proprietary static pipe
+  static const uint8_t EVT_SEND_DATA = 0x10;  // see specification ETSI TS 102
+                                              // 622 v9.0.0 (Host Controller
+                                              // Interface); section 9.3.3.3
+#if (NXP_EXTNS == TRUE)
+  static const uint8_t STATIC_PIPE_UICC =
+      0x20;  // UICC's proprietary static pipe
+  static const tNFA_HANDLE EE_HANDLE_HCI = 0x401;
+  static const tNFA_HANDLE EE_HANDLE_NDEFEE = 0x410;
 #else
-    static const tNFA_HANDLE EE_HANDLE_0xF3 = 0x4F3; //handle to secure element in slot 0
-    static const tNFA_HANDLE EE_HANDLE_0xF4 = 0x4F4; //handle to secure element in slot 1
+  static const tNFA_HANDLE EE_HANDLE_0xF3 =
+      0x4F3;  // handle to secure element in slot 0
+  static const tNFA_HANDLE EE_HANDLE_0xF4 =
+      0x4F4;  // handle to secure element in slot 1
 #endif
 
-    static SecureElement sSecElem;
-    static const char* APP_NAME;
-
-    uint8_t         mDestinationGate;       //destination gate of the UICC
-    tNFA_HANDLE     mNfaHciHandle;          //NFA handle to NFA's HCI component
-    nfc_jni_native_data* mNativeData;
-    bool    mIsInit;                // whether EE is initialized
-    uint8_t mActualNumEe;           // actual number of EE's reported by the stack
-    uint8_t mNumEePresent;          // actual number of usable EE's
-    bool    mbNewEE;
-    uint8_t mNewPipeId;
-    uint8_t mNewSourceGate;
-    uint16_t  mActiveSeOverride;      // active "enable" seid, 0 means activate all SEs
-    tNFA_STATUS mCommandStatus;     //completion status of the last command
-    bool    mIsPiping;              //is a pipe connected to the controller?
-    RouteSelection mCurrentRouteSelection;
-    int     mActualResponseSize;         //number of bytes in the response received from secure element
-    int     mAtrInfolen;
-    uint8_t mAtrStatus;
-    bool    mUseOberthurWarmReset;  //whether to use warm-reset command
-    bool    mActivatedInListenMode; // whether we're activated in listen mode
-    uint8_t mOberthurWarmResetCommand; //warm-reset command byte
-    tNFA_EE_INFO mEeInfo [MAX_NUM_EE];  //actual size stored in mActualNumEe
-    tNFA_EE_DISCOVER_REQ mUiccInfo;
-    tNFA_HCI_GET_GATE_PIPE_LIST mHciCfg;
-    SyncEvent       mEeRegisterEvent;
-    SyncEvent       mHciRegisterEvent;
-    SyncEvent       mResetEvent;
-    SyncEvent       mResetOngoingEvent;
-    SyncEvent       mPipeListEvent;
-#if(NXP_EXTNS != TRUE)
-    SyncEvent       mCreatePipeEvent;
-    SyncEvent       mPipeOpenedEvent;
-#endif
-    SyncEvent       mAllocateGateEvent;
-    SyncEvent       mDeallocateGateEvent;
-//    SyncEvent       mRoutingEvent;
-    SyncEvent       mUiccInfoEvent;
-//    SyncEvent       mAidAddRemoveEvent;
-    SyncEvent       mGetRegisterEvent;
-    SyncEvent       mVerInfoEvent;
-    SyncEvent       mRegistryEvent;
-    SyncEvent       mDiscMapEvent;
-    uint8_t         mVerInfo [3];
-    uint8_t         mAtrInfo[40];
-    bool            mGetAtrRspwait;
-    uint8_t         mResponseData [MAX_RESPONSE_SIZE];
-    RouteDataSet    mRouteDataSet; //routing data
-    std::vector<std::string> mUsedAids; //AID's that are used in current routes
-    uint8_t         mAidForEmptySelect[NCI_MAX_AID_LEN+1];
-    Mutex           mMutex; // protects fields below
-    bool            mRfFieldIsOn; // last known RF field state
-    struct timespec mLastRfFieldToggle; // last time RF field went off
-    IntervalTimer   mTransceiveTimer;
-    bool            mTransceiveWaitOk;
-
-#if(NXP_EXTNS == TRUE)
-#define             WIRED_MODE_TRANSCEIVE_TIMEOUT 120000
+  static SecureElement sSecElem;
+  static const char* APP_NAME;
+
+  uint8_t mDestinationGate;   // destination gate of the UICC
+  nfc_jni_native_data* mNativeData;
+  bool mIsInit;           // whether EE is initialized
+  uint8_t mActualNumEe;   // actual number of EE's reported by the stack
+  uint8_t mNumEePresent;  // actual number of usable EE's
+  bool mbNewEE;
+  uint8_t mNewPipeId;
+  uint8_t mNewSourceGate;
+  uint16_t mActiveSeOverride;  // active "enable" seid, 0 means activate all SEs
+  tNFA_STATUS mCommandStatus;  // completion status of the last command
+  bool mIsPiping;              // is a pipe connected to the controller?
+  RouteSelection mCurrentRouteSelection;
+  int mActualResponseSize;  // number of bytes in the response received from
+                            // secure element
+  int mAtrInfolen;
+  uint8_t mAtrStatus;
+  bool mUseOberthurWarmReset;         // whether to use warm-reset command
+  bool mActivatedInListenMode;        // whether we're activated in listen mode
+  uint8_t mOberthurWarmResetCommand;  // warm-reset command byte
+  tNFA_EE_INFO mEeInfo[MAX_NUM_EE];   // actual size stored in mActualNumEe
+  tNFA_EE_DISCOVER_REQ mUiccInfo;
+  tNFA_HCI_GET_GATE_PIPE_LIST mHciCfg;
+  SyncEvent mEeRegisterEvent;
+  SyncEvent mHciRegisterEvent;
+  SyncEvent mResetEvent;
+  SyncEvent mResetOngoingEvent;
+#if (NXP_EXTNS != TRUE)
+  SyncEvent mCreatePipeEvent;
+  SyncEvent mPipeOpenedEvent;
 #endif
-    /*******************************************************************************
-    **
-    ** Function:        SecureElement
-    **
-    ** Description:     Initialize member variables.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    SecureElement ();
-
-
-    /*******************************************************************************
-    **
-    ** Function:        ~SecureElement
-    **
-    ** Description:     Release all resources.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    ~SecureElement ();
-
-    /*******************************************************************************
-    **
-    ** Function:        handleClearAllPipe
-    **
-    ** Description:     To handle clear all pipe event received from HCI based on the
-    **                  deleted host
-    **                  eventData: Event data.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    static void handleClearAllPipe (tNFA_HCI_EVT_DATA* eventData);
-
-    /*******************************************************************************
-    **
-    ** Function:        nfaEeCallback
-    **
-    ** Description:     Receive execution environment-related events from stack.
-    **                  event: Event code.
-    **                  eventData: Event data.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    static void nfaEeCallback (tNFA_EE_EVT event, tNFA_EE_CBACK_DATA* eventData);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        nfaHciCallback
-    **
-    ** Description:     Receive Host Controller Interface-related events from stack.
-    **                  event: Event code.
-    **                  eventData: Event data.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    static void nfaHciCallback (tNFA_HCI_EVT event, tNFA_HCI_EVT_DATA* eventData);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        findEeByHandle
-    **
-    ** Description:     Find information about an execution environment.
-    **                  eeHandle: Handle to execution environment.
-    **
-    ** Returns:         Information about an execution environment.
-    **
-    *******************************************************************************/
-    tNFA_EE_INFO *findEeByHandle (tNFA_HANDLE eeHandle);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        findUiccByHandle
-    **
-    ** Description:     Find information about an execution environment.
-    **                  eeHandle: Handle of the execution environment.
-    **
-    ** Returns:         Information about the execution environment.
-    **
-    *******************************************************************************/
-    tNFA_EE_DISCOVER_INFO *findUiccByHandle (tNFA_HANDLE eeHandle);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        getDefaultEeHandle
-    **
-    ** Description:     Get the handle to the execution environment.
-    **
-    ** Returns:         Handle to the execution environment.
-    **
-    *******************************************************************************/
-    tNFA_HANDLE getDefaultEeHandle ();
-
-
-#if(NXP_EXTNS == TRUE)
-    /*******************************************************************************
-    **
-    ** Function:        getActiveEeHandle
-    **
-    ** Description:     Get the handle of the active execution environment.
-    **
-    ** Returns:         Handle to the execution environment.
-    **
-    *******************************************************************************/
-    tNFA_HANDLE getActiveEeHandle (tNFA_HANDLE eeHandle);
+  SyncEvent mAllocateGateEvent;
+  SyncEvent mDeallocateGateEvent;
+  //    SyncEvent       mRoutingEvent;
+  SyncEvent mUiccInfoEvent;
+  //    SyncEvent       mAidAddRemoveEvent;
+  SyncEvent mGetRegisterEvent;
+  SyncEvent mVerInfoEvent;
+  SyncEvent mRegistryEvent;
+  uint8_t mVerInfo[3];
+  uint8_t mAtrInfo[40];
+  bool mGetAtrRspwait;
+  RouteDataSet mRouteDataSet;          // routing data
+  std::vector<std::string> mUsedAids;  // AID's that are used in current routes
+  uint8_t mAidForEmptySelect[NCI_MAX_AID_LEN + 1];
+  Mutex mMutex;                        // protects fields below
+  bool mRfFieldIsOn;                   // last known RF field state
+  struct timespec mLastRfFieldToggle;  // last time RF field went off
+  IntervalTimer mTransceiveTimer;
+  bool mTransceiveWaitOk;
+
+#if (NXP_EXTNS == TRUE)
+#define WIRED_MODE_TRANSCEIVE_TIMEOUT 120000
 #endif
-    /*******************************************************************************
-    **
-    ** Function:        adjustRoutes
-    **
-    ** Description:     Adjust routes in the controller's listen-mode routing table.
-    **                  selection: which set of routes to configure the controller.
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void adjustRoutes (RouteSelection selection);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        adjustProtocolRoutes
-    **
-    ** Description:     Adjust default routing based on protocol in NFC listen mode.
-    **                  isRouteToEe: Whether routing to EE (true) or host (false).
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void adjustProtocolRoutes (RouteDataSet::Database* db, RouteSelection routeSelection);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        adjustTechnologyRoutes
-    **
-    ** Description:     Adjust default routing based on technology in NFC listen mode.
-    **                  isRouteToEe: Whether routing to EE (true) or host (false).
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    void adjustTechnologyRoutes (RouteDataSet::Database* db, RouteSelection routeSelection);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        getEeInfo
-    **
-    ** Description:     Get latest information about execution environments from stack.
-    **
-    ** Returns:         True if at least 1 EE is available.
-    **
-    *******************************************************************************/
-    bool getEeInfo ();
-
-    /*******************************************************************************
-    **
-    ** Function:        eeStatusToString
-    **
-    ** Description:     Convert status code to status text.
-    **                  status: Status code
-    **
-    ** Returns:         None
-    **
-    *******************************************************************************/
-    static const char* eeStatusToString (uint8_t status);
-
-
-    /*******************************************************************************
-    **
-    ** Function:        encodeAid
-    **
-    ** Description:     Encode AID in type-length-value using Basic Encoding Rule.
-    **                  tlv: Buffer to store TLV.
-    **                  tlvMaxLen: TLV buffer's maximum length.
-    **                  tlvActualLen: TLV buffer's actual length.
-    **                  aid: Buffer of Application ID.
-    **                  aidLen: Aid buffer's actual length.
-    **
-    ** Returns:         True if ok.
-    **
-    *******************************************************************************/
-    bool encodeAid (uint8_t* tlv, uint16_t tlvMaxLen, uint16_t& tlvActualLen, const uint8_t* aid, uint8_t aidLen);
-
-    static int decodeBerTlvLength(uint8_t* data,int index, int data_length );
-
-    static void discovery_map_cb (tNFC_DISCOVER_EVT event, tNFC_DISCOVER *p_data);
+  /*******************************************************************************
+  **
+  ** Function:        SecureElement
+  **
+  ** Description:     Initialize member variables.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  SecureElement();
+
+  /*******************************************************************************
+  **
+  ** Function:        ~SecureElement
+  **
+  ** Description:     Release all resources.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  ~SecureElement();
+
+  /*******************************************************************************
+  **
+  ** Function:        handleClearAllPipe
+  **
+  ** Description:     To handle clear all pipe event received from HCI based on
+  *the
+  **                  deleted host
+  **                  eventData: Event data.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  static void handleClearAllPipe(tNFA_HCI_EVT_DATA* eventData);
+
+  /*******************************************************************************
+  **
+  ** Function:        nfaEeCallback
+  **
+  ** Description:     Receive execution environment-related events from stack.
+  **                  event: Event code.
+  **                  eventData: Event data.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  static void nfaEeCallback(tNFA_EE_EVT event, tNFA_EE_CBACK_DATA* eventData);
+
+  /*******************************************************************************
+  **
+  ** Function:        nfaHciCallback
+  **
+  ** Description:     Receive Host Controller Interface-related events from
+  *stack.
+  **                  event: Event code.
+  **                  eventData: Event data.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  static void nfaHciCallback(tNFA_HCI_EVT event, tNFA_HCI_EVT_DATA* eventData);
+
+  /*******************************************************************************
+  **
+  ** Function:        findEeByHandle
+  **
+  ** Description:     Find information about an execution environment.
+  **                  eeHandle: Handle to execution environment.
+  **
+  ** Returns:         Information about an execution environment.
+  **
+  *******************************************************************************/
+  tNFA_EE_INFO* findEeByHandle(tNFA_HANDLE eeHandle);
+
+  /*******************************************************************************
+  **
+  ** Function:        findUiccByHandle
+  **
+  ** Description:     Find information about an execution environment.
+  **                  eeHandle: Handle of the execution environment.
+  **
+  ** Returns:         Information about the execution environment.
+  **
+  *******************************************************************************/
+  tNFA_EE_DISCOVER_INFO* findUiccByHandle(tNFA_HANDLE eeHandle);
+
+  /*******************************************************************************
+  **
+  ** Function:        getDefaultEeHandle
+  **
+  ** Description:     Get the handle to the execution environment.
+  **
+  ** Returns:         Handle to the execution environment.
+  **
+  *******************************************************************************/
+  tNFA_HANDLE getDefaultEeHandle();
 
+#if (NXP_EXTNS == TRUE)
+  /*******************************************************************************
+  **
+  ** Function:        getActiveEeHandle
+  **
+  ** Description:     Get the handle of the active execution environment.
+  **
+  ** Returns:         Handle to the execution environment.
+  **
+  *******************************************************************************/
+  tNFA_HANDLE getActiveEeHandle(tNFA_HANDLE eeHandle);
 
+#endif
+  /*******************************************************************************
+  **
+  ** Function:        adjustRoutes
+  **
+  ** Description:     Adjust routes in the controller's listen-mode routing
+  *table.
+  **                  selection: which set of routes to configure the
+  *controller.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void adjustRoutes(RouteSelection selection);
+
+  /*******************************************************************************
+  **
+  ** Function:        adjustProtocolRoutes
+  **
+  ** Description:     Adjust default routing based on protocol in NFC listen
+  *mode.
+  **                  isRouteToEe: Whether routing to EE (true) or host (false).
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void adjustProtocolRoutes(RouteDataSet::Database* db,
+                            RouteSelection routeSelection);
+
+  /*******************************************************************************
+  **
+  ** Function:        adjustTechnologyRoutes
+  **
+  ** Description:     Adjust default routing based on technology in NFC listen
+  *mode.
+  **                  isRouteToEe: Whether routing to EE (true) or host (false).
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void adjustTechnologyRoutes(RouteDataSet::Database* db,
+                              RouteSelection routeSelection);
+
+  /*******************************************************************************
+  **
+  ** Function:        getEeInfo
+  **
+  ** Description:     Get latest information about execution environments from
+  *stack.
+  **
+  ** Returns:         True if at least 1 EE is available.
+  **
+  *******************************************************************************/
+  bool getEeInfo();
+
+  /*******************************************************************************
+  **
+  ** Function:        eeStatusToString
+  **
+  ** Description:     Convert status code to status text.
+  **                  status: Status code
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  static const char* eeStatusToString(uint8_t status);
+
+  /*******************************************************************************
+  **
+  ** Function:        encodeAid
+  **
+  ** Description:     Encode AID in type-length-value using Basic Encoding Rule.
+  **                  tlv: Buffer to store TLV.
+  **                  tlvMaxLen: TLV buffer's maximum length.
+  **                  tlvActualLen: TLV buffer's actual length.
+  **                  aid: Buffer of Application ID.
+  **                  aidLen: Aid buffer's actual length.
+  **
+  ** Returns:         True if ok.
+  **
+  *******************************************************************************/
+  bool encodeAid(uint8_t* tlv, uint16_t tlvMaxLen, uint16_t& tlvActualLen,
+                 const uint8_t* aid, uint8_t aidLen);
+
+  static int decodeBerTlvLength(uint8_t* data, int index, int data_length);
 };
diff --git a/nci/jni/SyncEvent.h b/nci/jni/SyncEvent.h
index 01cab581..b4417595 100644
--- a/nci/jni/SyncEvent.h
+++ b/nci/jni/SyncEvent.h
@@ -21,110 +21,87 @@
 #include "CondVar.h"
 #include "Mutex.h"
 
-
-class SyncEvent
-{
-public:
-    /*******************************************************************************
-    **
-    ** Function:        ~SyncEvent
-    **
-    ** Description:     Cleanup all resources.
-    **
-    ** Returns:         None.
-    **
-    *******************************************************************************/
-    ~SyncEvent ()
-    {
-    }
-
-
-    /*******************************************************************************
-    **
-    ** Function:        start
-    **
-    ** Description:     Start a synchronization operation.
-    **
-    ** Returns:         None.
-    **
-    *******************************************************************************/
-    void start ()
-    {
-        mMutex.lock ();
-    }
-
-
-    /*******************************************************************************
-    **
-    ** Function:        wait
-    **
-    ** Description:     Block the thread and wait for the event to occur.
-    **
-    ** Returns:         None.
-    **
-    *******************************************************************************/
-    void wait ()
-    {
-        mCondVar.wait (mMutex);
-    }
-
-
-    /*******************************************************************************
-    **
-    ** Function:        wait
-    **
-    ** Description:     Block the thread and wait for the event to occur.
-    **                  millisec: Timeout in milliseconds.
-    **
-    ** Returns:         True if wait is successful; false if timeout occurs.
-    **
-    *******************************************************************************/
-    bool wait (long millisec)
-    {
-        bool retVal = mCondVar.wait (mMutex, millisec);
-        return retVal;
-    }
-
-
-    /*******************************************************************************
-    **
-    ** Function:        notifyOne
-    **
-    ** Description:     Notify a blocked thread that the event has occured. Unblocks it.
-    **
-    ** Returns:         None.
-    **
-    *******************************************************************************/
-    void notifyOne ()
-    {
-        mCondVar.notifyOne ();
-    }
-
-
-    /*******************************************************************************
-    **
-    ** Function:        end
-    **
-    ** Description:     End a synchronization operation.
-    **
-    ** Returns:         None.
-    **
-    *******************************************************************************/
-    void end ()
-    {
-        mMutex.unlock ();
-    }
-
-private:
-    CondVar mCondVar;
-    Mutex mMutex;
+class SyncEvent {
+ public:
+  /*******************************************************************************
+  **
+  ** Function:        ~SyncEvent
+  **
+  ** Description:     Cleanup all resources.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  ~SyncEvent() {}
+
+  /*******************************************************************************
+  **
+  ** Function:        start
+  **
+  ** Description:     Start a synchronization operation.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  void start() { mMutex.lock(); }
+
+  /*******************************************************************************
+  **
+  ** Function:        wait
+  **
+  ** Description:     Block the thread and wait for the event to occur.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  void wait() { mCondVar.wait(mMutex); }
+
+  /*******************************************************************************
+  **
+  ** Function:        wait
+  **
+  ** Description:     Block the thread and wait for the event to occur.
+  **                  millisec: Timeout in milliseconds.
+  **
+  ** Returns:         True if wait is successful; false if timeout occurs.
+  **
+  *******************************************************************************/
+  bool wait(long millisec) {
+    bool retVal = mCondVar.wait(mMutex, millisec);
+    return retVal;
+  }
+
+  /*******************************************************************************
+  **
+  ** Function:        notifyOne
+  **
+  ** Description:     Notify a blocked thread that the event has occured.
+  *Unblocks it.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  void notifyOne() { mCondVar.notifyOne(); }
+
+  /*******************************************************************************
+  **
+  ** Function:        end
+  **
+  ** Description:     End a synchronization operation.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  void end() { mMutex.unlock(); }
+
+ private:
+  CondVar mCondVar;
+  Mutex mMutex;
 };
 
-
 /*****************************************************************************/
 /*****************************************************************************/
 
-
 /*****************************************************************************
 **
 **  Name:           SyncEventGuard
@@ -132,39 +109,34 @@ private:
 **  Description:    Automatically start and end a synchronization event.
 **
 *****************************************************************************/
-class SyncEventGuard
-{
-public:
-    /*******************************************************************************
-    **
-    ** Function:        SyncEventGuard
-    **
-    ** Description:     Start a synchronization operation.
-    **
-    ** Returns:         None.
-    **
-    *******************************************************************************/
-    SyncEventGuard (SyncEvent& event)
-    :   mEvent (event)
-    {
-        event.start (); //automatically start operation
-    };
-
-
-    /*******************************************************************************
-    **
-    ** Function:        ~SyncEventGuard
-    **
-    ** Description:     End a synchronization operation.
-    **
-    ** Returns:         None.
-    **
-    *******************************************************************************/
-    ~SyncEventGuard ()
-    {
-        mEvent.end (); //automatically end operation
-    };
-
-private:
-    SyncEvent& mEvent;
+class SyncEventGuard {
+ public:
+  /*******************************************************************************
+  **
+  ** Function:        SyncEventGuard
+  **
+  ** Description:     Start a synchronization operation.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  SyncEventGuard(SyncEvent& event) : mEvent(event) {
+    event.start();  // automatically start operation
+  };
+
+  /*******************************************************************************
+  **
+  ** Function:        ~SyncEventGuard
+  **
+  ** Description:     End a synchronization operation.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  ~SyncEventGuard() {
+    mEvent.end();  // automatically end operation
+  };
+
+ private:
+  SyncEvent& mEvent;
 };
diff --git a/nci/jni/TransactionController.cpp b/nci/jni/TransactionController.cpp
index 7250523d..5f7798ad 100644
--- a/nci/jni/TransactionController.cpp
+++ b/nci/jni/TransactionController.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 NXP Semiconductors
+ * Copyright (C) 2015-2018 NXP Semiconductors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,23 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-#include "IntervalTimer.h"
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
 #include "TransactionController.h"
 #include <time.h>
-//#include <OverrideLog.h>
-#include "_OverrideLog.h"
 #include <string.h>
 
-namespace android
-{
-extern void* enableThread(void *arg);
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+namespace android {
+extern void* enableThread(void* arg);
 extern Transcation_Check_t* nfcManager_transactionDetail(void);
 extern bool nfcManager_isRequestPending(void);
-}
-
+}  // namespace android
 
-
- /*Transaction Controller Instance Reference*/
+/*Transaction Controller Instance Reference*/
 transactionController* transactionController::pInstance = NULL;
 
 /*******************************************************************************
@@ -42,26 +41,44 @@ transactionController* transactionController::pInstance = NULL;
  ** Returns:     None
  **
  *******************************************************************************/
-void transactionController::lastRequestResume(void)
-{
-    pthread_t transaction_thread;
-    int irret = -1;
-    ALOGD ("%s", __FUNCTION__);
-
-    pthread_attr_t attr;
-    pthread_attr_init(&attr);
-    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-
-    //Fork a thread which shall abort a stuck transaction and resume last trasaction*/
-    irret = pthread_create(&transaction_thread, &attr, android::enableThread, NULL);
-    if(irret != 0)
-    {
-        ALOGE("Unable to create the thread");
-    }
-    pthread_attr_destroy(&attr);
-    pTransactionDetail->current_transcation_state = NFA_TRANS_DM_RF_TRANS_END;
+void transactionController::lastRequestResume(void) {
+  pthread_t transaction_thread;
+  int irret = -1;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __FUNCTION__);
+
+  pthread_attr_t attr;
+  pthread_attr_init(&attr);
+  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+  pendingTransHandleTimer->kill();
+  pendingTransHandleTimer = new IntervalTimer();
+
+  // Fork a thread which shall abort a stuck transaction and resume last
+  // trasaction*/
+  irret =
+      pthread_create(&transaction_thread, &attr, android::enableThread, NULL);
+  if (irret != 0) {
+    LOG(ERROR) << StringPrintf("Unable to create the thread");
+  }
+  pthread_attr_destroy(&attr);
+  pTransactionDetail->current_transcation_state = NFA_TRANS_DM_RF_TRANS_END;
 }
+/*******************************************************************************
+ **
+ ** Function:       transactionHandlePendingCb
+ **
+ ** Description:    This is a callback function registered against
+ **                 pendingTransHandleTimer timer. This timer handler
+ **                 triggers enable_thread for handling pending transactions
+ **
+ ** Returns:       None
+ **
+ *******************************************************************************/
 
+void transactionController::transactionHandlePendingCb(union sigval) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Inside %s", __FUNCTION__);
+
+  pInstance->lastRequestResume();
+}
 /*******************************************************************************
  **
  ** Function:       transactionAbortTimerCb
@@ -72,11 +89,10 @@ void transactionController::lastRequestResume(void)
  **
  *******************************************************************************/
 
-extern "C" void transactionController::transactionAbortTimerCb(union sigval)
-{
-    ALOGD("Inside %s", __FUNCTION__);
+void transactionController::transactionAbortTimerCb(union sigval) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Inside %s", __FUNCTION__);
 
-    pInstance->lastRequestResume();
+  pInstance->transactionTerminate(TRANSACTION_REQUESTOR(exec_pending_req));
 }
 
 /*******************************************************************************
@@ -89,15 +105,16 @@ extern "C" void transactionController::transactionAbortTimerCb(union sigval)
  **
  *******************************************************************************/
 
-transactionController::transactionController(void)
-{
-    ALOGD ("%s: transaction controller created", __FUNCTION__);
+transactionController::transactionController(void) {
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: transaction controller created", __FUNCTION__);
 
-    sem_init(&barrier, 0, 1);
+  sem_init(&barrier, 0, 1);
 
-    pTransactionDetail = android::nfcManager_transactionDetail();
-    abortTimer = new IntervalTimer();
-    requestor = NULL;
+  pTransactionDetail = android::nfcManager_transactionDetail();
+  abortTimer = new IntervalTimer();
+  pendingTransHandleTimer = new IntervalTimer();
+  requestor = NO_REQUESTOR;
 }
 /*******************************************************************************
  **
@@ -108,126 +125,153 @@ transactionController::transactionController(void)
  ** Returns:        true/false
  **
  *******************************************************************************/
-bool transactionController::transactionLiveLockable(const char* transactionRequestor)
-{
-    ALOGD ("%s: Performing check for long duration transaction", __FUNCTION__);
-    return !(strcmp(transactionRequestor,"NFA_ACTIVATED_EVENT") ||
-             strcmp(transactionRequestor,"NFA_EE_ACTION_EVENT") ||
-             strcmp(transactionRequestor,"NFA_TRANS_CE_ACTIVATED_EVENT") ||
-             strcmp(transactionRequestor,"RF_FIELD_EVT"));
+bool transactionController::transactionLiveLockable(
+    eTransactionId transactionRequestor) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: Performing check for long duration transaction", __FUNCTION__);
+  return ((transactionRequestor == NFA_ACTIVATED_EVENT) ||
+          (transactionRequestor == NFA_EE_ACTION_EVENT) ||
+          (transactionRequestor == NFA_TRANS_CE_ACTIVATED_EVENT) ||
+          (transactionRequestor == RF_FIELD_EVT));
 }
 /*******************************************************************************
  **
  ** Function:       transactionStartBlockWait
  **
- ** Description:    The caller of the function block waits to start a transaction
+ ** Description:    The caller of the function block waits to start a
+ *transaction
  **
  ** Returns:        None
  **
  *******************************************************************************/
-bool transactionController::transactionAttempt(const char* transactionRequestor, unsigned int timeoutInSec)
-{
-    struct timespec timeout = {.tv_sec = 0, .tv_nsec = 0};
-    int semVal = 0;
-
-    //Get current time
-    clock_gettime(CLOCK_REALTIME, &timeout);
-
-    //Set timeout factor relative to current time
-    timeout.tv_sec += timeoutInSec;
-
-    sem_getvalue(&barrier, &semVal);
-    ALOGD ("%s: Transaction attempted : %s when barrier is: %d", __FUNCTION__, transactionRequestor, semVal);
-
-    //Block wait on barrier
-    if(sem_timedwait(&barrier, &timeout) != 0)
-    {
-        ALOGD ("%s: Transaction denied : %s ", __FUNCTION__, transactionRequestor);
-        return false;
-    }
-
-
-    pTransactionDetail->trans_in_progress = true;
-    requestor = transactionRequestor;
-
-    //In case there is a chance that transaction will be stuck; start transaction abort timer
-    if(transactionLiveLockable(transactionRequestor))
-    {
-        abortTimer->set(10000, transactionAbortTimerCb);
-    }
-    sem_getvalue(&barrier, &semVal);
-    ALOGD ("%s: Transaction granted : %s and barrier is: %d", __FUNCTION__, transactionRequestor, semVal);
-    return true;
-
+bool transactionController::transactionAttempt(
+    eTransactionId transactionRequestor, unsigned int timeoutInSec) {
+  struct timespec timeout = {.tv_sec = 0, .tv_nsec = 0};
+  int semVal = 0;
+
+  // Get current time
+  clock_gettime(CLOCK_REALTIME, &timeout);
+
+  // Set timeout factor relative to current time
+  timeout.tv_sec += timeoutInSec;
+
+  sem_getvalue(&barrier, &semVal);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Transaction attempted : %d when barrier is: %d",
+                      __FUNCTION__, transactionRequestor, semVal);
+
+  if (pendingTransHandleTimer->isRunning()) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: Transaction denied due to pending transaction: %d ", __FUNCTION__,
+        transactionRequestor);
+    return false;
+  }
+  // Block wait on barrier
+  if (sem_timedwait(&barrier, &timeout) != 0) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: Transaction denied : %d ", __FUNCTION__, transactionRequestor);
+    return false;
+  }
+
+  pTransactionDetail->trans_in_progress = true;
+  requestor = transactionRequestor;
+
+  // In case there is a chance that transaction will be stuck; start transaction
+  // abort timer
+  if (transactionLiveLockable(transactionRequestor)) {
+    abortTimer->set(1000000, transactionAbortTimerCb);
+  }
+  sem_getvalue(&barrier, &semVal);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Transaction granted : %d and barrier is: %d",
+                      __FUNCTION__, transactionRequestor, semVal);
+  return true;
 }
 /*******************************************************************************
  **
  ** Function:       transactionAttempt
  **
- ** Description:   Caller of this function will try to start a transaction(if none is ongoing)
+ ** Description:   Caller of this function will try to start a transaction(if
+ *none is ongoing)
  **
  ** Returns:      true: If transaction start attempt is successful
  **                  false: If transaction attempt fails
  **
  *******************************************************************************/
-bool transactionController::transactionAttempt(const char* transactionRequestor)
-{
-    int semVal = 0;
+bool transactionController::transactionAttempt(
+    eTransactionId transactionRequestor) {
+  int semVal = 0;
+
+  sem_getvalue(&barrier, &semVal);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: Transaction attempted : %d when barrier is: %d",
+                      __FUNCTION__, transactionRequestor, semVal);
+
+  if (pendingTransHandleTimer->isRunning()) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: Transaction denied due to pending transaction: %d ", __FUNCTION__,
+        transactionRequestor);
+    return false;
+  }
 
-    sem_getvalue(&barrier, &semVal);
-    ALOGD ("%s: Transaction attempted : %s when barrier is: %d", __FUNCTION__, transactionRequestor, semVal);
-
-    if(sem_trywait(&barrier) == 0)
-    {
-        pTransactionDetail->trans_in_progress = true;
-
-        if(transactionLiveLockable(transactionRequestor))
-        {
-            abortTimer->set(10000, transactionAbortTimerCb);
-        }
-        ALOGD ("%s: Transaction granted : %s ", __FUNCTION__, transactionRequestor);
-
-        requestor = transactionRequestor;
-        sem_getvalue(&barrier, &semVal);
-        ALOGD ("%s: Transaction granted : %s and barrier is: %d", __FUNCTION__, transactionRequestor, semVal);
-        return true;
+  if (sem_trywait(&barrier) == 0) {
+    pTransactionDetail->trans_in_progress = true;
+
+    if (transactionLiveLockable(transactionRequestor)) {
+      abortTimer->set(1000000, transactionAbortTimerCb);
     }
-    ALOGD ("%s: Transaction denied : %s ", __FUNCTION__, transactionRequestor);
-    return false;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: Transaction granted : %d ", __FUNCTION__, transactionRequestor);
+
+    requestor = transactionRequestor;
+    sem_getvalue(&barrier, &semVal);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Transaction granted : %d and barrier is: %d",
+                        __FUNCTION__, transactionRequestor, semVal);
+    return true;
+  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: Transaction denied : %d ", __FUNCTION__, transactionRequestor);
+  return false;
 }
 /*******************************************************************************
  **
  ** Function:       transactionEnd
  **
- ** Description:    If the transaction requestor has started the transaction then this function ends it.
+ ** Description:    If the transaction requestor has started the transaction
+ *then this function ends it.
  **
  ** Returns:        None
  **
  *******************************************************************************/
-void transactionController::transactionEnd(const char* transactionRequestor)
-{
-    int val;
-
-    if(requestor == transactionRequestor)
-    {
-        pTransactionDetail->trans_in_progress = false;
-
-        sem_getvalue(&barrier, &val);
-
-        if(!val)
-            sem_post(&barrier);
-
-        ALOGD ("%s: Transaction ended : %s ", __FUNCTION__, transactionRequestor);
-
-        /*
-        ** TODO: The below code needs to improved and thread dependency shall be reduced
-        **/
-        if(android::nfcManager_isRequestPending())
-        {
-            abortTimer->set(5, transactionAbortTimerCb);
-        }
-
+void transactionController::transactionEnd(
+    eTransactionId transactionRequestor) {
+  int val;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Enter", __FUNCTION__);
+  if (requestor == transactionRequestor) {
+    /*If any abort timer is running for this transaction then stop it*/
+    abortTimer->kill();
+    /*Create new abort timer for next use*/
+    abortTimer = new IntervalTimer();
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: Transaction control timer killed", __FUNCTION__);
+
+    pTransactionDetail->trans_in_progress = false;
+    requestor = NO_REQUESTOR;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: Transaction ended : %d ", __FUNCTION__, transactionRequestor);
+
+    /*
+    ** TODO: The below code needs to improved and thread dependency shall be
+    *reduced
+    **/
+    if (android::nfcManager_isRequestPending()) {
+      pendingTransHandleTimer->set(1, transactionHandlePendingCb);
     }
+
+    sem_getvalue(&barrier, &val);
+    if (!val) sem_post(&barrier);
+  }
 }
 /*******************************************************************************
  **
@@ -239,26 +283,30 @@ void transactionController::transactionEnd(const char* transactionRequestor)
  **                 false: If attempt to terminate fails
  **
  *******************************************************************************/
-bool  transactionController::transactionTerminate(const char* transactionRequestor)
-{
-    int val;
+bool transactionController::transactionTerminate(
+    eTransactionId transactionRequestor) {
+  int val;
 
-    ALOGD ("%s: Enter. Requested by : %s ", __FUNCTION__, transactionRequestor);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: Enter. Requested by : %d ", __FUNCTION__, transactionRequestor);
 
-    if((requestor != NULL) &&
-       (requestor == transactionRequestor || !strcmp(transactionRequestor,"exec_pending_req")))
-    {
-        pTransactionDetail->trans_in_progress = false;
-        abortTimer->kill();
+  if ((requestor != 0) && (requestor == transactionRequestor ||
+                           transactionRequestor == exec_pending_req)) {
+    pTransactionDetail->trans_in_progress = false;
+    requestor = NO_REQUESTOR;
+    killAbortTimer();
 
-        sem_getvalue(&barrier, &val);
-        if(!val)
-            sem_post(&barrier);
-
-        ALOGD ("%s: Transaction terminated : %s ", __FUNCTION__, transactionRequestor);
-        return true;
+    if (android::nfcManager_isRequestPending()) {
+      pendingTransHandleTimer->set(1, transactionHandlePendingCb);
     }
-    return false;
+
+    sem_getvalue(&barrier, &val);
+    if (!val) sem_post(&barrier);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: Transaction terminated : %d ", __FUNCTION__, transactionRequestor);
+    return true;
+  }
+  return false;
 }
 /*******************************************************************************
  **
@@ -269,9 +317,8 @@ bool  transactionController::transactionTerminate(const char* transactionRequest
  ** Returns:         true/false
  **
  *******************************************************************************/
-bool transactionController::transactionInProgress(void)
-{
-    return (pTransactionDetail->trans_in_progress == true);
+bool transactionController::transactionInProgress(void) {
+  return (pTransactionDetail->trans_in_progress == true);
 }
 /*******************************************************************************
  **
@@ -282,41 +329,41 @@ bool transactionController::transactionInProgress(void)
  ** Returns:         transaction controller instance
  **
  *******************************************************************************/
-transactionController* transactionController::getInstance(void)
-{
-    return pInstance;
+transactionController* transactionController::getInstance(void) {
+  return pInstance;
 }
 /*******************************************************************************
  **
  ** Function:       controller
  **
- ** Description:   This routine initializes transaction controller fields on every
+ ** Description:   This routine initializes transaction controller fields on
+ *every
  **                invocation.
  **
  ** Returns:       Reference to transaction controller
  **
  *******************************************************************************/
-transactionController* transactionController::controller(void)
-{
-    if(pInstance == NULL)
-    {
-        pInstance = new transactionController();
-    }
-    else
-    {
-        pInstance->pTransactionDetail->trans_in_progress = false;
-        pInstance->requestor = NULL;
-
-        pInstance->abortTimer->kill();
-
-        sem_destroy(&pInstance->barrier);
-
-        sem_init(&pInstance->barrier, 0, 1);
-
-        ALOGD ("%s: transaction controller initialized", __FUNCTION__);
-
-    }
-    return pInstance;
+transactionController* transactionController::controller(void) {
+  if (pInstance == NULL) {
+    pInstance = new transactionController();
+  } else {
+    pInstance->pTransactionDetail->trans_in_progress = false;
+    pInstance->requestor = NO_REQUESTOR;
+    pInstance->abortTimer->kill();
+    pInstance->pendingTransHandleTimer->kill();
+    pInstance->abortTimer = new IntervalTimer();
+    pInstance->pendingTransHandleTimer = new IntervalTimer();
+
+    sem_destroy(&pInstance->barrier);
+
+    sem_init(&pInstance->barrier, 0, 1);
+
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s: transaction controller initialized", __FUNCTION__);
+  }
+  memset(pInstance->pTransactionDetail, 0x00,
+         sizeof(*(pInstance->pTransactionDetail)));
+  return pInstance;
 }
 /*******************************************************************************
  **
@@ -327,26 +374,41 @@ transactionController* transactionController::controller(void)
  ** Returns:        None
  **
  *******************************************************************************/
-void transactionController::killAbortTimer(void)
-{
-    ALOGD ("%s: transaction controller abort timer killed", __FUNCTION__);
+void transactionController::killAbortTimer(void) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: transaction controller abort timer killed", __FUNCTION__);
 
-    if(transactionInProgress())
-        abortTimer->kill();
+  if (transactionInProgress()) {
+    abortTimer->kill();
+    abortTimer = new IntervalTimer();
+  }
 }
 /*******************************************************************************
  **
  ** Function:       setAbortTimer
  **
- ** Description:   This function starts transaction timer for specified timeout value
+ ** Description:   This function starts transaction timer for specified timeout
+ *value
  **
  ** Returns:       None
  **
  *******************************************************************************/
-void transactionController::setAbortTimer(unsigned int msec)
-{
-    ALOGD ("%s: transaction controller abort timer set", __FUNCTION__);
+void transactionController::setAbortTimer(unsigned int msec) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: transaction controller abort timer set", __FUNCTION__);
 
-    if(transactionInProgress())
-        abortTimer->set(msec, transactionAbortTimerCb);
-}
\ No newline at end of file
+  if (transactionInProgress()) abortTimer->set(msec, transactionAbortTimerCb);
+}
+
+/*******************************************************************************
+ **
+ ** Function:       getCurTransactionRequestor
+ **
+ ** Description:   This function returns current active requestor
+ **
+ ** Returns:       active requestor
+ **
+ *******************************************************************************/
+eTransactionId transactionController::getCurTransactionRequestor() {
+  return requestor;
+}
diff --git a/nci/jni/TransactionController.h b/nci/jni/TransactionController.h
index d3965dd9..a3210d88 100644
--- a/nci/jni/TransactionController.h
+++ b/nci/jni/TransactionController.h
@@ -1,96 +1,124 @@
-/******************************************************************************
- *
- *  Copyright (C) 2015 NXP Semiconductors
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-#pragma once
-#include <semaphore.h>
-#include <NfcJniUtil.h>
-extern "C"
-{
-    #include "nfa_api.h"
-}
-#define TRANSACTION_REQUESTOR(name) #name
-#define TRANSACTION_ATTEMPT_FOR_SECONDS(seconds)  (seconds)
-#define pTransactionController      (transactionController::getInstance())
-
-
-
-/* Transaction Events in order */
-typedef enum transcation_events
-{
-    NFA_TRANS_DEFAULT = 0x00,
-    NFA_TRANS_ACTIVATED_EVT,
-    NFA_TRANS_EE_ACTION_EVT,
-    NFA_TRANS_DM_RF_FIELD_EVT,
-    NFA_TRANS_DM_RF_FIELD_EVT_ON,
-    NFA_TRANS_DM_RF_TRANS_START,
-    NFA_TRANS_DM_RF_FIELD_EVT_OFF,
-    NFA_TRANS_DM_RF_TRANS_PROGRESS,
-    NFA_TRANS_DM_RF_TRANS_END,
-    NFA_TRANS_MIFARE_ACT_EVT,
-    NFA_TRANS_CE_ACTIVATED = 0x18,
-    NFA_TRANS_CE_DEACTIVATED = 0x19,
-}eTranscation_events_t;
-/*Structure to store  discovery parameters*/
-typedef struct discovery_Parameters
-{
-    int technologies_mask;
-    bool enable_lptd;
-    bool reader_mode;
-    bool enable_p2p;
-    bool restart;
-}discovery_Parameters_t;
-/*Structure to store transcation result*/
-typedef struct Transcation_Check
-{
-    bool trans_in_progress;
-    char last_request;
-    struct nfc_jni_native_data *transaction_nat;
-    eScreenState_t last_screen_state_request;
-    eTranscation_events_t current_transcation_state;
-    discovery_Parameters_t discovery_params;
-#if(NXP_EXTNS == TRUE)
-#if(NXP_NFCC_HCE_F == TRUE)
-    int t3thandle;
-    bool isInstallRequest;
-#endif
-#endif
-} Transcation_Check_t;
-
-class transactionController
-{
-    private:
-        static transactionController* pInstance;    //Reference to controller
-        sem_t barrier;                             //barrier: Guard for controlling access to NFCC when profile switch happening
-        IntervalTimer* abortTimer;                //abortTimer: Used for aborting a stuck transaction
-        Transcation_Check_t* pTransactionDetail; //transactionDetail: holds last transaction detail
-        const char* requestor;                  //requestor: Identifier of transaction trigger
-
-        transactionController(void);           //Constructor
-        bool transactionLiveLockable(const char* transactionRequestor);
-    public:
-        void lastRequestResume(void);
-        bool transactionAttempt(const char* transactionRequestor, unsigned int timeoutInMsec);
-        bool transactionAttempt(const char* transactionRequestor);
-        bool transactionTerminate(const char* transactionRequestor);
-        void transactionEnd(const char* transactionRequestor);
-        bool transactionInProgress(void);
-        void killAbortTimer(void);
-        void setAbortTimer(unsigned int msec);
-        static void  transactionAbortTimerCb(union sigval);
-        static transactionController* controller(void);
-        static transactionController* getInstance(void);
-};
+/******************************************************************************
+ *
+ *  Copyright (C) 2015-2018 NXP Semiconductors
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#pragma once
+#include <NfcJniUtil.h>
+#include <semaphore.h>
+#include "IntervalTimer.h"
+#include "nfa_api.h"
+
+#define TRANSACTION_REQUESTOR(name) name
+#define TRANSACTION_ATTEMPT_FOR_SECONDS(seconds) (seconds)
+#define pTransactionController (transactionController::getInstance())
+
+typedef enum transactionId {
+  NO_REQUESTOR = 0,
+  AppletLoadApplet = 1,
+  lsExecuteScript,
+  lsGetVersion,
+  RF_FIELD_EVT,
+  setDefaultRoute,
+  commitRouting,
+  enablep2p,
+  enableDiscovery,
+  disableDiscovery,
+  NFA_ACTIVATED_EVENT,
+  NFA_EE_ACTION_EVENT,
+  NFA_TRANS_CE_ACTIVATED_EVENT,
+  etsiReader,
+  jcosDownload,
+  setScreenState,
+  staticDualUicc,
+  getTransanctionRequest,
+  isTransanctionOnGoing,
+  exec_pending_req,
+  TAG_PRESENCE_CHECK,
+  /* add new requestors here in capital letters*/
+} eTransactionId;
+
+/* Transaction Events in order */
+typedef enum transcation_events {
+  NFA_TRANS_DEFAULT = 0x00,
+  NFA_TRANS_ACTIVATED_EVT,
+  NFA_TRANS_EE_ACTION_EVT,
+  NFA_TRANS_DM_RF_FIELD_EVT,
+  NFA_TRANS_DM_RF_FIELD_EVT_ON,
+  NFA_TRANS_DM_RF_TRANS_START,
+  NFA_TRANS_DM_RF_FIELD_EVT_OFF,
+  NFA_TRANS_DM_RF_TRANS_PROGRESS,
+  NFA_TRANS_DM_RF_TRANS_END,
+  NFA_TRANS_MIFARE_ACT_EVT,
+  NFA_TRANS_CE_ACTIVATED = 0x18,
+  NFA_TRANS_CE_DEACTIVATED = 0x19,
+} eTranscation_events_t;
+/*Structure to store  discovery parameters*/
+typedef struct discovery_Parameters {
+  int technologies_mask;
+  bool enable_lptd;
+  bool reader_mode;
+  bool enable_p2p;
+  bool restart;
+} discovery_Parameters_t;
+/*Structure to store transcation result*/
+typedef struct Transcation_Check {
+  bool trans_in_progress;
+  char last_request;
+  struct nfc_jni_native_data* transaction_nat;
+  eScreenState_t last_screen_state_request;
+  eTranscation_events_t current_transcation_state;
+  discovery_Parameters_t discovery_params;
+#if (NXP_EXTNS == TRUE)
+#if (NXP_NFCC_HCE_F == TRUE)
+  int t3thandle;
+  bool isInstallRequest;
+#endif
+#endif
+} Transcation_Check_t;
+
+class transactionController {
+ private:
+  static transactionController* pInstance;  // Reference to controller
+  sem_t barrier;  // barrier: Guard for controlling access to NFCC when profile
+                  // switch happening
+  IntervalTimer*
+      abortTimer;  // abortTimer: Used for aborting a stuck transaction
+  IntervalTimer* pendingTransHandleTimer;  // pendingTransHandleTimer: Used to
+                                           // schedule pending transaction
+                                           // handler thread
+  Transcation_Check_t*
+      pTransactionDetail;    // transactionDetail: holds last transaction detail
+  eTransactionId requestor;  // requestor: Identifier of transaction trigger
+
+  transactionController(void);  // Constructor
+  bool transactionLiveLockable(eTransactionId transactionRequestor);
+
+ public:
+  void lastRequestResume(void);
+  bool transactionAttempt(eTransactionId transactionRequestor,
+                          unsigned int timeoutInMsec);
+  bool transactionAttempt(eTransactionId transactionRequestor);
+  bool transactionTerminate(eTransactionId transactionRequestor);
+  void transactionEnd(eTransactionId transactionRequestor);
+  bool transactionInProgress(void);
+  void killAbortTimer(void);
+  void setAbortTimer(unsigned int msec);
+  static void transactionAbortTimerCb(union sigval);
+  static void transactionHandlePendingCb(union sigval);
+  static transactionController* controller(void);
+  static transactionController* getInstance(void);
+  eTransactionId getCurTransactionRequestor();
+};
diff --git a/nci/jni/extns/pn54x/Android.mk b/nci/jni/extns/pn54x/Android.mk
index 2b5f00e4..eec7fc99 100644
--- a/nci/jni/extns/pn54x/Android.mk
+++ b/nci/jni/extns/pn54x/Android.mk
@@ -1,5 +1,9 @@
 EXTN_PN54X_PATH:= $(call my-dir)
 
+LOCAL_SHARED_LIBRARIES := \
+    libchrome \
+    libbase \
+
 LOCAL_C_INCLUDES += \
     $(EXTN_PN54X_PATH)/inc \
     $(EXTN_PN54X_PATH)/src/common \
diff --git a/nci/jni/extns/pn54x/inc/phNxpExtns.h b/nci/jni/extns/pn54x/inc/phNxpExtns.h
index 62809d40..30955a2c 100644
--- a/nci/jni/extns/pn54x/inc/phNxpExtns.h
+++ b/nci/jni/extns/pn54x/inc/phNxpExtns.h
@@ -17,55 +17,50 @@
 #ifndef _PHNXPEXTNS_H_
 #define _PHNXPEXTNS_H_
 
-#include <nfa_api.h>
-#include <sys/types.h>
 #include <errno.h>
+#include <nfa_api.h>
 #include <phNfcStatus.h>
-#ifdef __cplusplus
-extern "C" {
-#endif
+#include <sys/types.h>
 
-NFCSTATUS EXTNS_Init (tNFA_DM_CBACK        *p_dm_cback,
-                     tNFA_CONN_CBACK      *p_conn_cback);
-void EXTNS_Close (void);
-NFCSTATUS EXTNS_MfcInit (tNFA_ACTIVATED activationData);
-NFCSTATUS EXTNS_MfcCheckNDef (void);
-NFCSTATUS EXTNS_MfcReadNDef (void);
-NFCSTATUS EXTNS_MfcPresenceCheck (void);
-NFCSTATUS EXTNS_MfcWriteNDef (uint8_t *pBuf, uint32_t len);
-NFCSTATUS EXTNS_MfcFormatTag (uint8_t *key, uint8_t len);
-NFCSTATUS EXTNS_MfcDisconnect (void);
-NFCSTATUS EXTNS_MfcActivated (void);
-NFCSTATUS EXTNS_MfcTransceive (uint8_t *p_data, uint32_t len);
-NFCSTATUS EXTNS_MfcRegisterNDefTypeHandler (tNFA_NDEF_CBACK *ndefHandlerCallback);
-NFCSTATUS EXTNS_MfcCallBack (uint8_t *buf, uint32_t buflen);
-NFCSTATUS EXTNS_MfcSetReadOnly (uint8_t *key, uint8_t len);
-void EXTNS_SetConnectFlag (bool_t flagval);
-bool_t EXTNS_GetConnectFlag (void);
-void EXTNS_SetDeactivateFlag (bool_t flagval);
-bool_t EXTNS_GetDeactivateFlag (void);
-void EXTNS_SetCallBackFlag (bool_t flagval);
-bool_t EXTNS_GetCallBackFlag (void);
-NFCSTATUS EXTNS_CheckMfcResponse (uint8_t** sTransceiveData, uint32_t *sTransceiveDataLen);
-void MfcPresenceCheckResult (NFCSTATUS status);
-void MfcResetPresenceCheckStatus (void);
-NFCSTATUS EXTNS_GetPresenceCheckStatus (void);
-#ifdef __cplusplus
-}
-#endif
+NFCSTATUS EXTNS_Init(tNFA_DM_CBACK* p_dm_cback, tNFA_CONN_CBACK* p_conn_cback);
+void EXTNS_Close(void);
+NFCSTATUS EXTNS_MfcInit(tNFA_ACTIVATED activationData);
+NFCSTATUS EXTNS_MfcCheckNDef(void);
+NFCSTATUS EXTNS_MfcReadNDef(void);
+NFCSTATUS EXTNS_MfcPresenceCheck(void);
+NFCSTATUS EXTNS_MfcWriteNDef(uint8_t* pBuf, uint32_t len);
+NFCSTATUS EXTNS_MfcFormatTag(uint8_t* key, uint8_t len);
+NFCSTATUS EXTNS_MfcDisconnect(void);
+NFCSTATUS EXTNS_MfcActivated(void);
+NFCSTATUS EXTNS_MfcTransceive(uint8_t* p_data, uint32_t len);
+NFCSTATUS EXTNS_MfcRegisterNDefTypeHandler(
+    tNFA_NDEF_CBACK* ndefHandlerCallback);
+NFCSTATUS EXTNS_MfcCallBack(uint8_t* buf, uint32_t buflen);
+NFCSTATUS EXTNS_MfcSetReadOnly(uint8_t* key, uint8_t len);
+void EXTNS_SetConnectFlag(bool_t flagval);
+bool_t EXTNS_GetConnectFlag(void);
+void EXTNS_SetDeactivateFlag(bool_t flagval);
+bool_t EXTNS_GetDeactivateFlag(void);
+void EXTNS_SetCallBackFlag(bool_t flagval);
+bool_t EXTNS_GetCallBackFlag(void);
+NFCSTATUS EXTNS_CheckMfcResponse(uint8_t** sTransceiveData,
+                                 uint32_t* sTransceiveDataLen);
+void MfcPresenceCheckResult(NFCSTATUS status);
+void MfcResetPresenceCheckStatus(void);
+NFCSTATUS EXTNS_GetPresenceCheckStatus(void);
 
 /*
  * Events from JNI for NXP Extensions
  */
-#define PH_NXPEXTNS_MIFARE_CHECK_NDEF        0x01   /* MIFARE Check Ndef */
-#define PH_NXPEXTNS_MIFARE_READ_NDEF         0x02   /* MIFARE Read Ndef */
-#define PH_NXPEXTNS_MIFARE_WRITE_NDEF        0x03   /* MIFARE Write Ndef */
-#define PH_NXPEXTNS_MIFARE_FORMAT_NDEF       0x04   /* MIFARE Format */
-#define PH_NXPEXTNS_DISCONNECT               0x05   /* Target Disconnect */
-#define PH_NXPEXTNS_ACTIVATED                0x06   /* Target Activated */
-#define PH_NXPEXTNS_MIFARE_TRANSCEIVE        0x07   /* MIFARE Raw Transceive */
-#define PH_NXPEXTNS_MIFARE_READ_ONLY         0x08   /* MIFARE Read Only */
-#define PH_NXPEXTNS_MIFARE_PRESENCE_CHECK    0x09   /* MIFARE Presence Check */
-#define PH_NXPEXTNS_RX_DATA                  0xF1   /* Receive Data */
+#define PH_NXPEXTNS_MIFARE_CHECK_NDEF 0x01     /* MIFARE Check Ndef */
+#define PH_NXPEXTNS_MIFARE_READ_NDEF 0x02      /* MIFARE Read Ndef */
+#define PH_NXPEXTNS_MIFARE_WRITE_NDEF 0x03     /* MIFARE Write Ndef */
+#define PH_NXPEXTNS_MIFARE_FORMAT_NDEF 0x04    /* MIFARE Format */
+#define PH_NXPEXTNS_DISCONNECT 0x05            /* Target Disconnect */
+#define PH_NXPEXTNS_ACTIVATED 0x06             /* Target Activated */
+#define PH_NXPEXTNS_MIFARE_TRANSCEIVE 0x07     /* MIFARE Raw Transceive */
+#define PH_NXPEXTNS_MIFARE_READ_ONLY 0x08      /* MIFARE Read Only */
+#define PH_NXPEXTNS_MIFARE_PRESENCE_CHECK 0x09 /* MIFARE Presence Check */
+#define PH_NXPEXTNS_RX_DATA 0xF1               /* Receive Data */
 
 #endif /* _PHNXPEXTNS_H_ */
diff --git a/nci/jni/extns/pn54x/inc/phNxpExtns_Custom.h b/nci/jni/extns/pn54x/inc/phNxpExtns_Custom.h
index a9d10c8d..5c3b88b2 100644
--- a/nci/jni/extns/pn54x/inc/phNxpExtns_Custom.h
+++ b/nci/jni/extns/pn54x/inc/phNxpExtns_Custom.h
@@ -17,14 +17,10 @@
 #ifndef _PHNXPEXTNS_CUSTOM_H_
 #define _PHNXPEXTNS_CUSTOM_H_
 
-#include <nfa_api.h>
-#include <sys/types.h>
 #include <errno.h>
+#include <nfa_api.h>
 #include <phNfcStatus.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
+#include <sys/types.h>
 
 /*
  * TLV structure
@@ -32,30 +28,30 @@ extern "C" {
  * For extended TLV, type[0] == 0xA0
  */
 typedef struct {
-    uint8_t type[2];
-    uint8_t len;
-    uint8_t *val;
+  uint8_t type[2];
+  uint8_t len;
+  uint8_t* val;
 } tlv_t;
 
 typedef enum {
-    passive_106 = 0x01,
-    passive_212 = 0x02,
-    passive_424 = 0x04,
-    active_106 = 0x10,
-    active_212 = 0x20,
-    active_424 = 0x40,
+  passive_106 = 0x01,
+  passive_212 = 0x02,
+  passive_424 = 0x04,
+  active_106 = 0x10,
+  active_212 = 0x20,
+  active_424 = 0x40,
 } p2p_speed_t;
 
 typedef enum {
-    NO_SE,
-    UICC,
-    eSE,
+  NO_SE,
+  UICC,
+  eSE,
 } SE_t;
 
 typedef enum {
-    ReaderMode = 0x01,
-    P2PMode = 0x02,
-    CEMode = 0x04,
+  ReaderMode = 0x01,
+  P2PMode = 0x02,
+  CEMode = 0x04,
 } PollMode_t;
 
 /*******************************************************************************
@@ -69,15 +65,18 @@ typedef enum {
  ** NOTE: Internally this function will use phNxpNciHal_get_version from HAL.
  *******************************************************************************/
 
-NFCSTATUS phNxpExtns_get_version (uint32_t *hw_ver, uint32_t *fw_ver, uint32_t *sw_ver);
+NFCSTATUS phNxpExtns_get_version(uint32_t* hw_ver, uint32_t* fw_ver,
+                                 uint32_t* sw_ver);
 
 /*******************************************************************************
  **
  ** Function         phNxpNciHal_read_tlv
  **
  ** Description      Function to read simple TLV and extended TLV.
- **                  Memory for TLV and fields are allocated and freed by calling
- **                  function. Input is type and len. Response is provied in *val.
+ **                  Memory for TLV and fields are allocated and freed by
+ *calling
+ **                  function. Input is type and len. Response is provied in
+ **val.
  **
  ** Returns          NFCSTATUS_SUCCESS if successful,otherwise NFCSTATUS_FAILED.
  **
@@ -85,14 +84,15 @@ NFCSTATUS phNxpExtns_get_version (uint32_t *hw_ver, uint32_t *fw_ver, uint32_t *
  **       For extended TLV, it will use NFA_SendRawFrame.
  *******************************************************************************/
 
-NFCSTATUS phNxpNciHal_read_tlv (tlv_t *tlv);
+NFCSTATUS phNxpNciHal_read_tlv(tlv_t* tlv);
 
 /*******************************************************************************
  **
  ** Function         phNxpNciHal_write_tlv
  **
  ** Description      Function to write simple TLV and extended TLV.
- **                  Memory for TLV and fields are allocated and freed by calling
+ **                  Memory for TLV and fields are allocated and freed by
+ *calling
  **                  function. Input is type, len, *val.
  **
  ** Returns          NFCSTATUS_SUCCESS if successful,otherwise NFCSTATUS_FAILED.
@@ -101,7 +101,7 @@ NFCSTATUS phNxpNciHal_read_tlv (tlv_t *tlv);
  **       For extended TLV, it will use NFA_SendRawFrame.
  *******************************************************************************/
 
-NFCSTATUS phNxpNciHal_write_tlv (tlv_t *tlv);
+NFCSTATUS phNxpNciHal_write_tlv(tlv_t* tlv);
 
 /*******************************************************************************
  **
@@ -117,7 +117,7 @@ NFCSTATUS phNxpNciHal_write_tlv (tlv_t *tlv);
  ** NOTE: Internally this function is using NFA_EnablePolling function.
  *******************************************************************************/
 
-NFCSTATUS phNxpExtns_select_poll_tech (tNFA_TECHNOLOGY_MASK tech_mask);
+NFCSTATUS phNxpExtns_select_poll_tech(tNFA_TECHNOLOGY_MASK tech_mask);
 
 /*******************************************************************************
  **
@@ -134,17 +134,19 @@ NFCSTATUS phNxpExtns_select_poll_tech (tNFA_TECHNOLOGY_MASK tech_mask);
  **       Not sure which handle to use, from UICC or eSE.
  *******************************************************************************/
 
-NFCSTATUS phNxpExtns_select_ce_listen_tech (tNFA_TECHNOLOGY_MASK tech_mask);
+NFCSTATUS phNxpExtns_select_ce_listen_tech(tNFA_TECHNOLOGY_MASK tech_mask);
 
 /*******************************************************************************
  **
  ** Function        phNxpExtns_select_p2p_poll_speed
  **
  ** Description     This function will select the P2P polling speed.
- **                 phNxpExtns_select_poll_tech overwrite the settings of poll if
+ **                 phNxpExtns_select_poll_tech overwrite the settings of poll
+ *if
  **                 reader mode is enabled.
  **                 There is only one active poll phase but device can use one
- **                 active speed and can move to higher speed if target supports.
+ **                 active speed and can move to higher speed if target
+ *supports.
  **
  ** Returns         NFCSTATUS_SUCCESS if operation successful,
  **                 otherwise NFCSTATUS_FAILED.
@@ -152,7 +154,7 @@ NFCSTATUS phNxpExtns_select_ce_listen_tech (tNFA_TECHNOLOGY_MASK tech_mask);
  ** NOTE: Internally this function will use NFA_EnablePolling and NFA_SetConfig
  *******************************************************************************/
 
-NFCSTATUS phNxpExtns_select_p2p_poll_speed (p2p_speed_t p2p_initiator_speed);
+NFCSTATUS phNxpExtns_select_p2p_poll_speed(p2p_speed_t p2p_initiator_speed);
 
 /*******************************************************************************
  **
@@ -165,16 +167,18 @@ NFCSTATUS phNxpExtns_select_p2p_poll_speed (p2p_speed_t p2p_initiator_speed);
  ** Returns         NFCSTATUS_SUCCESS if operation successful,
  **                 otherwise NFCSTATUS_FAILED.
  **
- ** NOTE: Internally this function will use NFA_SetP2pListenTech and NFA_SetConfig
+ ** NOTE: Internally this function will use NFA_SetP2pListenTech and
+ *NFA_SetConfig
  *******************************************************************************/
 
-NFCSTATUS phNxpExtns_select_p2p_listen_speed (p2p_speed_t p2p_target_speed);
+NFCSTATUS phNxpExtns_select_p2p_listen_speed(p2p_speed_t p2p_target_speed);
 
 /*******************************************************************************
  **
  ** Function        phNxpExtns_select_se
  **
- ** Description     This function will set the routing of the traffic to selected
+ ** Description     This function will set the routing of the traffic to
+ *selected
  **                 SE. This function also does not start polling loop.
  **
  ** Returns         NFCSTATUS_SUCCESS if operation successful,
@@ -183,7 +187,7 @@ NFCSTATUS phNxpExtns_select_p2p_listen_speed (p2p_speed_t p2p_target_speed);
  ** NOTE:
  *******************************************************************************/
 
-NFCSTATUS phNxpExtns_select_se (SE_t se);
+NFCSTATUS phNxpExtns_select_se(SE_t se);
 
 /*******************************************************************************
  **
@@ -198,14 +202,15 @@ NFCSTATUS phNxpExtns_select_se (SE_t se);
  ** NOTE:
  *******************************************************************************/
 
-NFCSTATUS phNxpExtns_set_poll_mode (PollMode_t poll_mode);
+NFCSTATUS phNxpExtns_set_poll_mode(PollMode_t poll_mode);
 
 /*******************************************************************************
  **
  ** Function        phNxpExtns_start_poll
  **
  ** Description     This function starts polling loop based on the configuration
- **                 of the previous calls. If no configuration done through other
+ **                 of the previous calls. If no configuration done through
+ *other
  **                 function call then it uses the default configuration from
  **                 configuration files.
  **                 This function internally stops the polling loop if it is
@@ -217,7 +222,7 @@ NFCSTATUS phNxpExtns_set_poll_mode (PollMode_t poll_mode);
  ** NOTE: Internally this function uses NFA_StartRfDiscovery.
  *******************************************************************************/
 
-NFCSTATUS phNxpExtns_start_poll (void);
+NFCSTATUS phNxpExtns_start_poll(void);
 
 /*******************************************************************************
  **
@@ -231,7 +236,7 @@ NFCSTATUS phNxpExtns_start_poll (void);
  ** NOTE:Internally this function uses NFA_StopRfDiscovery.
  *******************************************************************************/
 
-NFCSTATUS phNxpExtns_stop_poll (void);
+NFCSTATUS phNxpExtns_stop_poll(void);
 
 /*******************************************************************************
  **
@@ -245,7 +250,7 @@ NFCSTATUS phNxpExtns_stop_poll (void);
  ** NOTE:
  *******************************************************************************/
 
-NFCSTATUS phNxpExtns_enable_Felica_CLT (bool enable);
+NFCSTATUS phNxpExtns_enable_Felica_CLT(bool enable);
 
 /*******************************************************************************
  **
@@ -259,6 +264,6 @@ NFCSTATUS phNxpExtns_enable_Felica_CLT (bool enable);
  ** NOTE:
  *******************************************************************************/
 
-NFCSTATUS phNxpExtns_enable_Mifare_CLT (bool enable);
+NFCSTATUS phNxpExtns_enable_Mifare_CLT(bool enable);
 
 #endif /* _PHNXPEXTNS_CUSTOM_H_ */
diff --git a/nci/jni/extns/pn54x/src/common/phNciNfcTypes.h b/nci/jni/extns/pn54x/src/common/phNciNfcTypes.h
index fc272057..9f748182 100644
--- a/nci/jni/extns/pn54x/src/common/phNciNfcTypes.h
+++ b/nci/jni/extns/pn54x/src/common/phNciNfcTypes.h
@@ -23,131 +23,134 @@
 
 /*
  ################################################################################
- ***************************** Header File Inclusion ****************************
+ ***************************** Header File Inclusion
+ ****************************
  ################################################################################
  */
 #include <phNfcStatus.h>
 
 /*
  ################################################################################
- ****************************** Macro Definitions *******************************
+ ****************************** Macro Definitions
+ *******************************
  ################################################################################
  */
-#define PH_NCINFCTYPES_MAX_UID_LENGTH           (0x0AU)
+#define PH_NCINFCTYPES_MAX_UID_LENGTH (0x0AU)
 /* Maximum length of ATR_RES (General Bytes) length expected */
-#define PH_NCINFCTYPES_MAX_ATR_LENGTH           (0x30U)
-#define PH_NCINFCTYPES_ATQA_LENGTH              (0x02U)    /* ATQA length */
-#define PH_NCINFCTYPES_MAX_HIST_BYTES           (0x0FU)    /* Max Historical bytes returned by Type A tag */
+#define PH_NCINFCTYPES_MAX_ATR_LENGTH (0x30U)
+#define PH_NCINFCTYPES_ATQA_LENGTH (0x02U) /* ATQA length */
+#define PH_NCINFCTYPES_MAX_HIST_BYTES \
+  (0x0FU) /* Max Historical bytes returned by Type A tag */
 
 /*
  * Enum definition contains supported RF Protocols
  */
-typedef enum
-{
-    phNciNfc_e_RfProtocolsUnknownProtocol = 0x00,  /* Protocol is not known */
-    phNciNfc_e_RfProtocolsT1tProtocol     = 0x01,  /* Type 1 Tag protocol */
-    phNciNfc_e_RfProtocolsT2tProtocol     = 0x02,  /* Type 2 Tag protocol */
-    phNciNfc_e_RfProtocolsT3tProtocol     = 0x03,  /* Type 3 Tag protocol */
-    phNciNfc_e_RfProtocolsIsoDepProtocol  = 0x04,  /* ISO DEP protocol */
-    phNciNfc_e_RfProtocolsNfcDepProtocol  = 0x05,  /* NFC DEP protocol */
-    phNciNfc_e_RfProtocols15693Protocol   = 0x06,  /* 15693 protocol */
-    phNciNfc_e_RfProtocolsMifCProtocol    = 0x80,  /* Mifare Classic protocol */
-    phNciNfc_e_RfProtocolsHidProtocol     = 0x81,  /* Hid protocol */
-    phNciNfc_e_RfProtocolsEpcGen2Protocol = 0x82,  /* EpcGen2 protocol */
-    phNciNfc_e_RfProtocolsKovioProtocol   = 0x83   /* Kovio protocol */
+typedef enum {
+  phNciNfc_e_RfProtocolsUnknownProtocol = 0x00, /* Protocol is not known */
+  phNciNfc_e_RfProtocolsT1tProtocol = 0x01,     /* Type 1 Tag protocol */
+  phNciNfc_e_RfProtocolsT2tProtocol = 0x02,     /* Type 2 Tag protocol */
+  phNciNfc_e_RfProtocolsT3tProtocol = 0x03,     /* Type 3 Tag protocol */
+  phNciNfc_e_RfProtocolsIsoDepProtocol = 0x04,  /* ISO DEP protocol */
+  phNciNfc_e_RfProtocolsNfcDepProtocol = 0x05,  /* NFC DEP protocol */
+  phNciNfc_e_RfProtocols15693Protocol = 0x06,   /* 15693 protocol */
+  phNciNfc_e_RfProtocolsMifCProtocol = 0x80,    /* Mifare Classic protocol */
+  phNciNfc_e_RfProtocolsHidProtocol = 0x81,     /* Hid protocol */
+  phNciNfc_e_RfProtocolsEpcGen2Protocol = 0x82, /* EpcGen2 protocol */
+  phNciNfc_e_RfProtocolsKovioProtocol = 0x83    /* Kovio protocol */
 } phNciNfc_RfProtocols_t;
 
 /*
  * Supported RF Interfaces
  */
-typedef enum
-{
-    phNciNfc_e_RfInterfacesNfceeDirect_RF = 0x00,   /* Nfcee Direct RF Interface */
-    phNciNfc_e_RfInterfacesFrame_RF =       0x01,   /* Frame RF Interface */
-    phNciNfc_e_RfInterfacesISODEP_RF =      0x02,   /* ISO DEP RF Interface */
-    phNciNfc_e_RfInterfacesNFCDEP_RF =      0x03,   /* NFC DEP RF Interface */
-    phNciNfc_e_RfInterfacesTagCmd_RF =      0x80,   /* Tag-Cmd RF Interface (Nxp prop) */
-    phNciNfc_e_RfInterfacesHID_RF =         0x81    /* Hid RF Interface (Nxp prop) */
+typedef enum {
+  phNciNfc_e_RfInterfacesNfceeDirect_RF = 0x00, /* Nfcee Direct RF Interface */
+  phNciNfc_e_RfInterfacesFrame_RF = 0x01,       /* Frame RF Interface */
+  phNciNfc_e_RfInterfacesISODEP_RF = 0x02,      /* ISO DEP RF Interface */
+  phNciNfc_e_RfInterfacesNFCDEP_RF = 0x03,      /* NFC DEP RF Interface */
+  phNciNfc_e_RfInterfacesTagCmd_RF = 0x80, /* Tag-Cmd RF Interface (Nxp prop) */
+  phNciNfc_e_RfInterfacesHID_RF = 0x81     /* Hid RF Interface (Nxp prop) */
 } phNciNfc_RfInterfaces_t;
 
 /*
  * Enum definition contains RF technology modes supported.
  * This information is a part of RF_DISCOVER_NTF or RF_INTF_ACTIVATED_NTF.
  */
-typedef enum
-{
-    phNciNfc_NFCA_Poll                 = 0x00,  /* Nfc A Technology in Poll Mode */
-    phNciNfc_NFCB_Poll                 = 0x01,  /* Nfc B Technology in Poll Mode */
-    phNciNfc_NFCF_Poll                 = 0x02,  /* Nfc F Technology in Poll Mode */
-    phNciNfc_NFCA_Active_Poll          = 0x03,  /* Nfc A Technology in Active Poll Mode */
-    phNciNfc_NFCF_Active_Poll          = 0x05,  /* Nfc F Technology in Active Poll Mode */
-    phNciNfc_NFCISO15693_Poll          = 0x06, /* Nfc ISO15693 Technology in Poll Mode */
-    phNciNfc_NxpProp_NFCHID_Poll       = 0x70,      /* Nfc Hid Technology in Poll Mode */
-    phNciNfc_NxpProp_NFCEPFGEN2_Poll   = 0x71,  /* Nfc EpcGen2 Technology in Poll Mode */
-    phNciNfc_NxpProp_NFCKOVIO_Poll     = 0x72,    /* Nfc Kovio Technology in Poll Mode */
-    phNciNfc_NFCA_Listen               = 0x80,/* Nfc A Technology in Listen Mode */
-    phNciNfc_NFCB_Listen               = 0x81,/* Nfc B Technology in Listen Mode */
-    phNciNfc_NFCF_Listen               = 0x82,/* Nfc F Technology in Listen Mode */
-    phNciNfc_NFCA_Active_Listen        = 0x83,/* Nfc A Technology in Active Listen Mode */
-    phNciNfc_NFCF_Active_Listen        = 0x85,  /* Nfc F Technology in Active Listen Mode */
-    phNciNfc_NFCISO15693_Active_Listen = 0x86   /* Nfc ISO15693 Technology in Listen Mode */
+typedef enum {
+  phNciNfc_NFCA_Poll = 0x00,        /* Nfc A Technology in Poll Mode */
+  phNciNfc_NFCB_Poll = 0x01,        /* Nfc B Technology in Poll Mode */
+  phNciNfc_NFCF_Poll = 0x02,        /* Nfc F Technology in Poll Mode */
+  phNciNfc_NFCA_Active_Poll = 0x03, /* Nfc A Technology in Active Poll Mode */
+  phNciNfc_NFCF_Active_Poll = 0x05, /* Nfc F Technology in Active Poll Mode */
+  phNciNfc_NFCISO15693_Poll = 0x06, /* Nfc ISO15693 Technology in Poll Mode */
+  phNciNfc_NxpProp_NFCHID_Poll = 0x70, /* Nfc Hid Technology in Poll Mode */
+  phNciNfc_NxpProp_NFCEPFGEN2_Poll =
+      0x71, /* Nfc EpcGen2 Technology in Poll Mode */
+  phNciNfc_NxpProp_NFCKOVIO_Poll = 0x72, /* Nfc Kovio Technology in Poll Mode */
+  phNciNfc_NFCA_Listen = 0x80,           /* Nfc A Technology in Listen Mode */
+  phNciNfc_NFCB_Listen = 0x81,           /* Nfc B Technology in Listen Mode */
+  phNciNfc_NFCF_Listen = 0x82,           /* Nfc F Technology in Listen Mode */
+  phNciNfc_NFCA_Active_Listen =
+      0x83, /* Nfc A Technology in Active Listen Mode */
+  phNciNfc_NFCF_Active_Listen =
+      0x85, /* Nfc F Technology in Active Listen Mode */
+  phNciNfc_NFCISO15693_Active_Listen =
+      0x86 /* Nfc ISO15693 Technology in Listen Mode */
 } phNciNfc_RfTechMode_t;
 
 /*
  * This is used to identify the exact device type
  */
-typedef enum
-{
-    phNciNfc_eUnknown_DevType        = 0x00U,
+typedef enum {
+  phNciNfc_eUnknown_DevType = 0x00U,
 
-    /* Generic PICC Type */
-    phNciNfc_ePICC_DevType,
-    /* Specific PICC Devices */
-    /* This PICC type explains that the card is compliant to the
-     * ISO 14443-1 and 2A specification. This type can be used for the
-     * cards that is supporting these specifications
-     */
-    phNciNfc_eISO14443_A_PICC,
-    /* This PICC type explains that the card is compliant to the
-     * ISO 14443-4A specification
-     */
-    phNciNfc_eISO14443_4A_PICC,
-    /* This PICC type explains that the card is compliant to the
-     * ISO 14443-3A specification
-     */
-    phNciNfc_eISO14443_3A_PICC,
-    /* This PICC type explains that the card is Mifare UL/1k/4k and
-     * also it is compliant to ISO 14443-3A. There can also be other
-     * ISO 14443-3A cards, so the phNciNfc_eISO14443_3A_PICC is also used for
-     * PICC detection
-     */
-    phNciNfc_eMifareUL_PICC,
-    phNciNfc_eMifare1k_PICC,
-    phNciNfc_eMifare4k_PICC,
-    phNciNfc_eMifareMini_PICC,
-    /* This PICC type explains that the card is compliant to the
-     * ISO 14443-1, 2 and 3B specification
-     */
-    phNciNfc_eISO14443_B_PICC,
-    /* This PICC type explains that the card is compliant to the
-     * ISO 14443-4B specification
-     */
-    phNciNfc_eISO14443_4B_PICC,
-    /* This PICC type explains that the card is B-Prime type */
-    phNciNfc_eISO14443_BPrime_PICC,
-    phNciNfc_eFelica_PICC,
-    phNciNfc_eJewel_PICC,
-    /* This PICC type explains that the card is ISO15693 type */
-    phNciNfc_eISO15693_PICC,
-    /* This PICC type explains that the card is EpcGen2 type */
-    phNciNfc_eEpcGen_PICC,
+  /* Generic PICC Type */
+  phNciNfc_ePICC_DevType,
+  /* Specific PICC Devices */
+  /* This PICC type explains that the card is compliant to the
+   * ISO 14443-1 and 2A specification. This type can be used for the
+   * cards that is supporting these specifications
+   */
+  phNciNfc_eISO14443_A_PICC,
+  /* This PICC type explains that the card is compliant to the
+   * ISO 14443-4A specification
+   */
+  phNciNfc_eISO14443_4A_PICC,
+  /* This PICC type explains that the card is compliant to the
+   * ISO 14443-3A specification
+   */
+  phNciNfc_eISO14443_3A_PICC,
+  /* This PICC type explains that the card is Mifare UL/1k/4k and
+   * also it is compliant to ISO 14443-3A. There can also be other
+   * ISO 14443-3A cards, so the phNciNfc_eISO14443_3A_PICC is also used for
+   * PICC detection
+   */
+  phNciNfc_eMifareUL_PICC,
+  phNciNfc_eMifare1k_PICC,
+  phNciNfc_eMifare4k_PICC,
+  phNciNfc_eMifareMini_PICC,
+  /* This PICC type explains that the card is compliant to the
+   * ISO 14443-1, 2 and 3B specification
+   */
+  phNciNfc_eISO14443_B_PICC,
+  /* This PICC type explains that the card is compliant to the
+   * ISO 14443-4B specification
+   */
+  phNciNfc_eISO14443_4B_PICC,
+  /* This PICC type explains that the card is B-Prime type */
+  phNciNfc_eISO14443_BPrime_PICC,
+  phNciNfc_eFelica_PICC,
+  phNciNfc_eJewel_PICC,
+  /* This PICC type explains that the card is ISO15693 type */
+  phNciNfc_eISO15693_PICC,
+  /* This PICC type explains that the card is EpcGen2 type */
+  phNciNfc_eEpcGen_PICC,
 
-    /* NFC-IP1 Device Types */
-    phNciNfc_eNfcIP1_Target,
-    phNciNfc_eNfcIP1_Initiator,
+  /* NFC-IP1 Device Types */
+  phNciNfc_eNfcIP1_Target,
+  phNciNfc_eNfcIP1_Initiator,
 
-    /* Other Sources */
-    phNciNfc_eInvalid_DevType
+  /* Other Sources */
+  phNciNfc_eInvalid_DevType
 
 } phNciNfc_RFDevType_t;
 
@@ -155,11 +158,12 @@ typedef enum
  * RATS Response Params structure
  */
 typedef struct phNciNfc_RATSResp {
-    uint8_t   bFormatByte;                 /* Format Byte */
-    uint8_t   bIByteTA;                    /* Interface Byte TA(1) */
-    uint8_t   bIByteTB;                    /* Interface Byte TB(1) */
-    uint8_t   bIByteTC;                    /* Interface Byte TC(1) */
-    uint8_t   bHistByte[PH_NCINFCTYPES_MAX_HIST_BYTES];   /* Historical Bytes - Max size 15 */
+  uint8_t bFormatByte;                              /* Format Byte */
+  uint8_t bIByteTA;                                 /* Interface Byte TA(1) */
+  uint8_t bIByteTB;                                 /* Interface Byte TB(1) */
+  uint8_t bIByteTC;                                 /* Interface Byte TC(1) */
+  uint8_t bHistByte[PH_NCINFCTYPES_MAX_HIST_BYTES]; /* Historical Bytes - Max
+                                                       size 15 */
 } phNciNfc_RATSResp_t;
 
 /*
@@ -167,102 +171,109 @@ typedef struct phNciNfc_RATSResp {
  * related to the discovered ISO14443A remote device. This information
  * is updated for every device discovery.
  */
-typedef struct phNciNfc_Iso14443AInfo
-{
-    uint8_t         Uid[PH_NCINFCTYPES_MAX_UID_LENGTH]; /* UID information of the TYPE A
-                                                        Tag Discovered NFCID1 -
-                                                        Considering max size of NFCID1*/
-    uint8_t         UidLength;                          /* UID information length, shall not be greater
-                                                        than PHNCINFC_MAX_UID_LENGTH i.e., 10 */
-    uint8_t         AppData[PH_NCINFCTYPES_MAX_ATR_LENGTH]; /* Application data information of the
-                                                        tag discovered (= Historical bytes for
-                                                        type A) */
-    uint8_t         AppDataLength;                      /* Application data length */
-    uint8_t         Sak;                                /* SAK information of the TYPE ATag Discovered
-                                                        Mapped to SEL_RES Response*/
-    uint8_t         AtqA[PH_NCINFCTYPES_ATQA_LENGTH];        /* ATQA information of the TYPE A
-                                                        Tag Discovered */
-    uint8_t         MaxDataRate;                        /* Maximum data rate supported by the TYPE A
-                                                        Tag Discovered */
-    uint8_t         Fwi_Sfgt;                           /* Frame waiting time and start up frame guard
-                                                        time as defined in ISO/IEC 14443-4[7] for type A */
-    uint8_t         bSensResResp[2];                    /* SENS_RES Response */
-    uint8_t         bSelResRespLen;                     /* SEL_RES Response Length */
-    uint8_t         bRatsRespLen;                       /* Length of RATS Response */
-    phNciNfc_RATSResp_t   tRatsResp;                    /* RATS Response Info */
+typedef struct phNciNfc_Iso14443AInfo {
+  uint8_t Uid[PH_NCINFCTYPES_MAX_UID_LENGTH]; /* UID information of the TYPE A
+                                              Tag Discovered NFCID1 -
+                                              Considering max size of NFCID1*/
+  uint8_t UidLength; /* UID information length, shall not be greater
+                     than PHNCINFC_MAX_UID_LENGTH i.e., 10 */
+  uint8_t AppData[PH_NCINFCTYPES_MAX_ATR_LENGTH]; /* Application data
+                                              information of the
+                                              tag discovered (= Historical bytes
+                                              for
+                                              type A) */
+  uint8_t AppDataLength;                          /* Application data length */
+  uint8_t Sak; /* SAK information of the TYPE ATag Discovered
+               Mapped to SEL_RES Response*/
+  uint8_t AtqA[PH_NCINFCTYPES_ATQA_LENGTH]; /* ATQA information of the TYPE A
+                                       Tag Discovered */
+  uint8_t MaxDataRate;           /* Maximum data rate supported by the TYPE A
+                                 Tag Discovered */
+  uint8_t Fwi_Sfgt;              /* Frame waiting time and start up frame guard
+                                 time as defined in ISO/IEC 14443-4[7] for type A */
+  uint8_t bSensResResp[2];       /* SENS_RES Response */
+  uint8_t bSelResRespLen;        /* SEL_RES Response Length */
+  uint8_t bRatsRespLen;          /* Length of RATS Response */
+  phNciNfc_RATSResp_t tRatsResp; /* RATS Response Info */
 } phNciNfc_Iso14443AInfo_t;
 
 /*
- * The Remote Device Information Union includes the available Remote Device Information
- * structures. Following the device detected, the corresponding data structure is used.
+ * The Remote Device Information Union includes the available Remote Device
+ * Information
+ * structures. Following the device detected, the corresponding data structure
+ * is used.
  */
-typedef union phNciNfc_RemoteDevInfo
-{
-    phNciNfc_Iso14443AInfo_t          Iso14443A_Info;/* Type A tag Info */
+typedef union phNciNfc_RemoteDevInfo {
+  phNciNfc_Iso14443AInfo_t Iso14443A_Info; /* Type A tag Info */
 } phNciNfc_RemoteDevInfo_t;
 
 /* Contains Details of Discovered Target */
-typedef struct phNciNfc_RemoteDevInformation
-{
-    uint8_t                    SessionOpened;      /* Flag indicating the validity of the handle of the remote device. */
-    phNciNfc_RFDevType_t       RemDevType;         /* Remote device type which says that remote
-                                                    is Reader A or Reader B or NFCIP or Felica or
-                                                    Reader B Prime or Jewel*/
-    uint8_t bRfDiscId;                              /* ID of the Tag */
-    phNciNfc_RfInterfaces_t    eRfIf;               /* RF Interface */
-    phNciNfc_RfProtocols_t eRFProtocol;             /* RF protocol of the target */
-    phNciNfc_RfTechMode_t eRFTechMode;              /* RF Technology mode of the discovered/activated target */
-    uint8_t bMaxPayLoadSize;                        /* Max data payload size*/
-    uint8_t bInitialCredit;                         /* Initial credit*/
-    uint8_t bTechSpecificParamLen;                  /* Technology Specific parameter length, for Debugging purpose only*/
-    phNciNfc_RfTechMode_t eDataXchgRFTechMode;      /* Data Exchange RF Technology mode of the activated target */
-    uint8_t   bTransBitRate;                        /* Transmit Bit Rate */
-    uint8_t   bRecvBitRate;                         /* Receive Bit Rate */
-    phNciNfc_RemoteDevInfo_t tRemoteDevInfo;        /* Structure object to #phNciNfc_RemoteDevInfo_t*/
-} phNciNfc_RemoteDevInformation_t,*pphNciNfc_RemoteDevInformation_t;/* Pointer to Remote Dev Info*/
+typedef struct phNciNfc_RemoteDevInformation {
+  uint8_t SessionOpened; /* Flag indicating the validity of the handle of the
+                            remote device. */
+  phNciNfc_RFDevType_t
+      RemDevType;                /* Remote device type which says that remote
+                                  is Reader A or Reader B or NFCIP or Felica or
+                                  Reader B Prime or Jewel*/
+  uint8_t bRfDiscId;             /* ID of the Tag */
+  phNciNfc_RfInterfaces_t eRfIf; /* RF Interface */
+  phNciNfc_RfProtocols_t eRFProtocol; /* RF protocol of the target */
+  phNciNfc_RfTechMode_t
+      eRFTechMode; /* RF Technology mode of the discovered/activated target */
+  uint8_t bMaxPayLoadSize;       /* Max data payload size*/
+  uint8_t bInitialCredit;        /* Initial credit*/
+  uint8_t bTechSpecificParamLen; /* Technology Specific parameter length, for
+                                    Debugging purpose only*/
+  phNciNfc_RfTechMode_t
+      eDataXchgRFTechMode; /* Data Exchange RF Technology mode of the activated
+                              target */
+  uint8_t bTransBitRate;   /* Transmit Bit Rate */
+  uint8_t bRecvBitRate;    /* Receive Bit Rate */
+  phNciNfc_RemoteDevInfo_t
+      tRemoteDevInfo; /* Structure object to #phNciNfc_RemoteDevInfo_t*/
+} phNciNfc_RemoteDevInformation_t,
+    *pphNciNfc_RemoteDevInformation_t; /* Pointer to Remote Dev Info*/
 
 /*
  * Structure contains buffer where payload of the received data packet
  * shall be stored and length of the payload stored in the buffer.
  */
-typedef struct phNciNfc_Data
-{
-    uint8_t *pBuff;     /* Buffer to store received data packet's payload */
-    uint16_t wLen;      /* Length of the payload */
+typedef struct phNciNfc_Data {
+  uint8_t* pBuff; /* Buffer to store received data packet's payload */
+  uint16_t wLen;  /* Length of the payload */
 } phNciNfc_Data_t, *pphNciNfc_Data_t;
 
-
 /*
  * Type 2 tag command list supported by NCI stack
  * It includes command lists applicable to Mifare family cards also
  */
-typedef enum phNciNfc_T2TCmdList
-{
-    phNciNfc_eT2TRaw    = 0x00,   /* Performs Raw communication over T2T Tag*/
-    phNciNfc_eT2TWriteN,   /* Write Multiple blocks to T2T tag*/
-    phNciNfc_eT2TreadN,   /* Read Multiple blocks to T2T tag*/
-    phNciNfc_eT2TSectorSel,   /* Sector Select for MifareStd Cards*/
-    phNciNfc_eT2TAuth,   /* Sector Select for MifareStd Cards*/
-    phNciNfc_eT2TProxCheck,/* Proxy Check command for MF+*/
-    phNciNfc_eT2TInvalidCmd /* Invalid Command*/
-} phNciNfc_T2TCmdList_t;    /* Type2 Tag and Mifare specicific command list*/
+typedef enum phNciNfc_T2TCmdList {
+  phNciNfc_eT2TRaw = 0x00, /* Performs Raw communication over T2T Tag*/
+  phNciNfc_eT2TWriteN,     /* Write Multiple blocks to T2T tag*/
+  phNciNfc_eT2TreadN,      /* Read Multiple blocks to T2T tag*/
+  phNciNfc_eT2TSectorSel,  /* Sector Select for MifareStd Cards*/
+  phNciNfc_eT2TAuth,       /* Sector Select for MifareStd Cards*/
+  phNciNfc_eT2TProxCheck,  /* Proxy Check command for MF+*/
+  phNciNfc_eT2TInvalidCmd  /* Invalid Command*/
+} phNciNfc_T2TCmdList_t;   /* Type2 Tag and Mifare specicific command list*/
 
 /* All command list for tag operation supported by NCI stack */
-typedef union phNciNfc_TagCmdList
-{
-    phNciNfc_T2TCmdList_t T2TCmd; /* T2T Specific command*/
-} phNciNfc_TagCmdList_t; /* Tag specific command */
+typedef union phNciNfc_TagCmdList {
+  phNciNfc_T2TCmdList_t T2TCmd; /* T2T Specific command*/
+} phNciNfc_TagCmdList_t;        /* Tag specific command */
 
 /* Transceive info */
-typedef struct phNciNfc_TransceiveInfo
-{
-    phNciNfc_TagCmdList_t   uCmd;     /* Technology Specific commands */
-    uint8_t                 bAddr;    /* Start address to perform operation,Valid for T1T T2T T3T and some Propriatery tags */
-    uint8_t                 bNumBlock;/* Number of blocks */
-    uint16_t                wTimeout; /* Timeout value to be used during transceive */
-    phNciNfc_Data_t         tSendData;/* Buffer information for sending data */
-    phNciNfc_Data_t         tRecvData;/* Buffer information for receiving data */
-    /* Details for Felica To be Added if Check and Update supported */
-} phNciNfc_TransceiveInfo_t, *pphNciNfc_TransceiveInfo_t; /* pointer to struct #phNciNfc_TransceiveInfo_t */
+typedef struct phNciNfc_TransceiveInfo {
+  phNciNfc_TagCmdList_t uCmd; /* Technology Specific commands */
+  uint8_t bAddr; /* Start address to perform operation,Valid for T1T T2T T3T and
+                    some Propriatery tags */
+  uint8_t bNumBlock;         /* Number of blocks */
+  uint16_t wTimeout;         /* Timeout value to be used during transceive */
+  phNciNfc_Data_t tSendData; /* Buffer information for sending data */
+  phNciNfc_Data_t tRecvData; /* Buffer information for receiving data */
+  /* Details for Felica To be Added if Check and Update supported */
+} phNciNfc_TransceiveInfo_t,
+    *pphNciNfc_TransceiveInfo_t; /* pointer to struct #phNciNfc_TransceiveInfo_t
+                                  */
 
-#endif                          /* end of #ifndef PHNCINFCTYPES_H */
+#endif /* end of #ifndef PHNCINFCTYPES_H */
diff --git a/nci/jni/extns/pn54x/src/common/phNfcCompId.h b/nci/jni/extns/pn54x/src/common/phNfcCompId.h
index e41f1c68..35fa62e3 100644
--- a/nci/jni/extns/pn54x/src/common/phNfcCompId.h
+++ b/nci/jni/extns/pn54x/src/common/phNfcCompId.h
@@ -24,7 +24,8 @@
 /*
  *  Component IDs
  *
- *  IDs for all NFC components. Combined with the Status Code they build the value (status)
+ *  IDs for all NFC components. Combined with the Status Code they build the
+ *value (status)
  *  returned by each function.
  *
  *  ID Number Spaces:
@@ -33,27 +34,29 @@
  *  - 40..5F: NFC-MW (Remote Device)
  *  .
  *
- *         The value CID_NFC_NONE does not exist for Component IDs. Do not use this value except
+ *         The value CID_NFC_NONE does not exist for Component IDs. Do not use
+ *this value except
  *         for NFCSTATUS_SUCCESS. The enumeration function uses CID_NFC_NONE
  *         to mark unassigned "References".
  */
-#define CID_NFC_NONE                    0x00    /* Unassigned or doesn't apply (see #NFCSTATUS_SUCCESS) */
-#define CID_NFC_TML                     0x01    /* Transport Mapping Layer */
-#define CID_NFC_LLC                     0x07    /* Logical Link Control Layer */
-#define CID_NFC_NCI                     0x08    /* NFC Controller(NFCC) Interface Layer */
-#define CID_NFC_DNLD                    0x09    /* Firmware Download Management Layer */
-#define CID_NFC_HAL                     0x10    /* Hardware Abstraction Layer */
-#define CID_NFC_OSAL                    CID_NFC_NONE  /* Operating System Abstraction Layer*/
-#define CID_FRI_NFC_OVR_HAL             0x20    /* NFC-Device, HAL-based */
-#define CID_FRI_NFC_NDEF_RECORD         0x22    /* NDEF Record Tools Library. */
-#define CID_FRI_NFC_NDEF_MAP            0x23    /* NDEF Mapping. */
-#define CID_FRI_NFC_NDEF_REGISTRY       0x24    /* NDEF_REGISTRY. */
-#define CID_FRI_NFC_AUTO_DEV_DIS        0x25    /* Automatic Device Discovery. */
-#define CID_FRI_NFC_NDEF_SMTCRDFMT      0x26    /* Smart Card Formatting */
-#define CID_NFC_LIB                     0x30    /* NFC Library Layer*/
-#define CID_MAX_VALUE                   0xF0    /* The maximum CID value that is defined. */
-#define CID_FRI_NFC_LLCP                0x40    /* Logical Link Control Protocol */
-#define CID_FRI_NFC_LLCP_TRANSPORT      0x50
-#define CID_FRI_NFC_LLCP_MAC            0x60
+#define CID_NFC_NONE \
+  0x00 /* Unassigned or doesn't apply (see #NFCSTATUS_SUCCESS) */
+#define CID_NFC_TML 0x01             /* Transport Mapping Layer */
+#define CID_NFC_LLC 0x07             /* Logical Link Control Layer */
+#define CID_NFC_NCI 0x08             /* NFC Controller(NFCC) Interface Layer */
+#define CID_NFC_DNLD 0x09            /* Firmware Download Management Layer */
+#define CID_NFC_HAL 0x10             /* Hardware Abstraction Layer */
+#define CID_NFC_OSAL CID_NFC_NONE    /* Operating System Abstraction Layer*/
+#define CID_FRI_NFC_OVR_HAL 0x20     /* NFC-Device, HAL-based */
+#define CID_FRI_NFC_NDEF_RECORD 0x22 /* NDEF Record Tools Library. */
+#define CID_FRI_NFC_NDEF_MAP 0x23    /* NDEF Mapping. */
+#define CID_FRI_NFC_NDEF_REGISTRY 0x24  /* NDEF_REGISTRY. */
+#define CID_FRI_NFC_AUTO_DEV_DIS 0x25   /* Automatic Device Discovery. */
+#define CID_FRI_NFC_NDEF_SMTCRDFMT 0x26 /* Smart Card Formatting */
+#define CID_NFC_LIB 0x30                /* NFC Library Layer*/
+#define CID_MAX_VALUE 0xF0    /* The maximum CID value that is defined. */
+#define CID_FRI_NFC_LLCP 0x40 /* Logical Link Control Protocol */
+#define CID_FRI_NFC_LLCP_TRANSPORT 0x50
+#define CID_FRI_NFC_LLCP_MAC 0x60
 
 #endif /* PHNFCCOMPID_H */
diff --git a/nci/jni/extns/pn54x/src/common/phNfcStatus.h b/nci/jni/extns/pn54x/src/common/phNfcStatus.h
index ccd955f8..298148e3 100644
--- a/nci/jni/extns/pn54x/src/common/phNfcStatus.h
+++ b/nci/jni/extns/pn54x/src/common/phNfcStatus.h
@@ -24,9 +24,9 @@
 #include <phNfcTypes.h>
 
 /* Internally required by PHNFCSTVAL. */
-#define PHNFCSTSHL8                          (8U)
+#define PHNFCSTSHL8 (8U)
 /* Required by PHNFCSTVAL. */
-#define PHNFCSTBLOWER                        ((NFCSTATUS)(0x00FFU))
+#define PHNFCSTBLOWER ((NFCSTATUS)(0x00FFU))
 
 /*
  *  NFC Status Composition Macro
@@ -38,21 +38,23 @@
  *
  *  The macro is not required for the NFCSTATUS_SUCCESS value.
  *  This is the only return value to be used directly.
- *  For all other values it shall be used in assignment and conditional statements, e.g.:
+ *  For all other values it shall be used in assignment and conditional
+ *statements, e.g.:
  *     NFCSTATUS status = PHNFCSTVAL(phNfcCompID, phNfcStatus); ...
  *     if (status == PHNFCSTVAL(phNfcCompID, phNfcStatus)) ...
  */
-#define PHNFCSTVAL(phNfcCompID, phNfcStatus)                                  \
-            ( ((phNfcStatus) == (NFCSTATUS_SUCCESS)) ? (NFCSTATUS_SUCCESS) :  \
-                ( (((NFCSTATUS)(phNfcStatus)) & (PHNFCSTBLOWER)) |            \
-                    (((uint16_t)(phNfcCompID)) << (PHNFCSTSHL8)) ) )
+#define PHNFCSTVAL(phNfcCompID, phNfcStatus)               \
+  (((phNfcStatus) == (NFCSTATUS_SUCCESS))                  \
+       ? (NFCSTATUS_SUCCESS)                               \
+       : ((((NFCSTATUS)(phNfcStatus)) & (PHNFCSTBLOWER)) | \
+          (((uint16_t)(phNfcCompID)) << (PHNFCSTSHL8))))
 
 /*
  * PHNFCSTATUS
  * Get grp_retval from Status Code
  */
-#define PHNFCSTATUS(phNfcStatus)  ((phNfcStatus) & 0x00FFU)
-#define PHNFCCID(phNfcStatus)  (((phNfcStatus) & 0xFF00U)>>8)
+#define PHNFCSTATUS(phNfcStatus) ((phNfcStatus)&0x00FFU)
+#define PHNFCCID(phNfcStatus) (((phNfcStatus)&0xFF00U) >> 8)
 
 /*
  *  Status Codes
@@ -68,300 +70,294 @@
 /*
  * The function indicates successful completion
  */
-#define NFCSTATUS_SUCCESS                                     (0x0000)
+#define NFCSTATUS_SUCCESS (0x0000)
 
 /*
  *  The function indicates successful completion
  */
-#define NFCSTATUS_OK                                (NFCSTATUS_SUCCESS)
+#define NFCSTATUS_OK (NFCSTATUS_SUCCESS)
 
 /*
  * At least one parameter could not be properly interpreted
  */
-#define NFCSTATUS_INVALID_PARAMETER                           (0x0001)
+#define NFCSTATUS_INVALID_PARAMETER (0x0001)
 
 /*
  * The buffer provided by the caller is too small
  */
-#define NFCSTATUS_BUFFER_TOO_SMALL                            (0x0003)
+#define NFCSTATUS_BUFFER_TOO_SMALL (0x0003)
 
 /*
  * Device specifier/handle value is invalid for the operation
  */
-#define NFCSTATUS_INVALID_DEVICE                              (0x0006)
+#define NFCSTATUS_INVALID_DEVICE (0x0006)
 
 /*
  * The function executed successfully but could have returned
  * more information than space provided by the caller
  */
-#define NFCSTATUS_MORE_INFORMATION                            (0x0008)
+#define NFCSTATUS_MORE_INFORMATION (0x0008)
 
 /*
  * No response from the remote device received: Time-out
  */
-#define NFCSTATUS_RF_TIMEOUT                                  (0x0009)
+#define NFCSTATUS_RF_TIMEOUT (0x0009)
 
 /*
  * RF Error during data transaction with the remote device
  */
-#define NFCSTATUS_RF_ERROR                                    (0x000A)
+#define NFCSTATUS_RF_ERROR (0x000A)
 
 /*
  * Not enough resources Memory, Timer etc(e.g. allocation failed.)
  */
-#define NFCSTATUS_INSUFFICIENT_RESOURCES                      (0x000C)
+#define NFCSTATUS_INSUFFICIENT_RESOURCES (0x000C)
 
 /*
  * A non-blocking function returns this immediately to indicate
  * that an internal operation is in progress
  */
-#define NFCSTATUS_PENDING                                     (0x000D)
+#define NFCSTATUS_PENDING (0x000D)
 
 /*
  * A board communication error occurred
  * (e.g. Configuration went wrong)
  */
-#define NFCSTATUS_BOARD_COMMUNICATION_ERROR                   (0x000F)
+#define NFCSTATUS_BOARD_COMMUNICATION_ERROR (0x000F)
 
 /*
  * Invalid State of the particular state machine
  */
-#define NFCSTATUS_INVALID_STATE                               (0x0011)
-
+#define NFCSTATUS_INVALID_STATE (0x0011)
 
 /*
  * This Layer is Not initialized, hence initialization required.
  */
-#define NFCSTATUS_NOT_INITIALISED                             (0x0031)
-
+#define NFCSTATUS_NOT_INITIALISED (0x0031)
 
 /*
  * The Layer is already initialized, hence initialization repeated.
  */
-#define NFCSTATUS_ALREADY_INITIALISED                         (0x0032)
-
+#define NFCSTATUS_ALREADY_INITIALISED (0x0032)
 
 /*
  * Feature not supported
  */
-#define NFCSTATUS_FEATURE_NOT_SUPPORTED                       (0x0033)
+#define NFCSTATUS_FEATURE_NOT_SUPPORTED (0x0033)
 
-/*  The Unregistration command has failed because the user wants to unregister on
+/*  The Unregistration command has failed because the user wants to unregister
+ * on
  * an element for which he was not registered
  */
-#define NFCSTATUS_NOT_REGISTERED                              (0x0034)
-
+#define NFCSTATUS_NOT_REGISTERED (0x0034)
 
 /* The Registration command has failed because the user wants to register on
  * an element for which he is already registered
  */
-#define NFCSTATUS_ALREADY_REGISTERED                          (0x0035)
+#define NFCSTATUS_ALREADY_REGISTERED (0x0035)
 
 /*  Single Tag with Multiple
     Protocol support detected */
-#define NFCSTATUS_MULTIPLE_PROTOCOLS                          (0x0036)
+#define NFCSTATUS_MULTIPLE_PROTOCOLS (0x0036)
 
 /*
  * Feature not supported
  */
-#define NFCSTATUS_MULTIPLE_TAGS                               (0x0037)
+#define NFCSTATUS_MULTIPLE_TAGS (0x0037)
 
 /*
  * A DESELECT event has occurred
  */
-#define NFCSTATUS_DESELECTED                                  (0x0038)
+#define NFCSTATUS_DESELECTED (0x0038)
 
 /*
  * A RELEASE event has occurred
  */
-#define NFCSTATUS_RELEASED                                    (0x0039)
+#define NFCSTATUS_RELEASED (0x0039)
 
 /*
  * The operation is currently not possible or not allowed
  */
-#define NFCSTATUS_NOT_ALLOWED                                 (0x003A)
+#define NFCSTATUS_NOT_ALLOWED (0x003A)
 
 /*
  *  The system is busy with the previous operation.
  */
-#define NFCSTATUS_BUSY                                        (0x006F)
-
+#define NFCSTATUS_BUSY (0x006F)
 
 /* NDEF Mapping error codes */
 
 /* The remote device (type) is not valid for this request. */
-#define NFCSTATUS_INVALID_REMOTE_DEVICE                       (0x001D)
+#define NFCSTATUS_INVALID_REMOTE_DEVICE (0x001D)
 
 /* Read operation failed */
-#define NFCSTATUS_READ_FAILED                                 (0x0014)
+#define NFCSTATUS_READ_FAILED (0x0014)
 
 /*
  * Write operation failed
  */
-#define NFCSTATUS_WRITE_FAILED                                (0x0015)
+#define NFCSTATUS_WRITE_FAILED (0x0015)
 
 /* Non Ndef Compliant */
-#define NFCSTATUS_NO_NDEF_SUPPORT                             (0x0016)
+#define NFCSTATUS_NO_NDEF_SUPPORT (0x0016)
 
 /* Could not proceed further with the write operation: reached card EOF*/
-#define NFCSTATUS_EOF_NDEF_CONTAINER_REACHED                  (0x001A)
+#define NFCSTATUS_EOF_NDEF_CONTAINER_REACHED (0x001A)
 
 /* Incorrect number of bytes received from the card*/
-#define NFCSTATUS_INVALID_RECEIVE_LENGTH                      (0x001B)
+#define NFCSTATUS_INVALID_RECEIVE_LENGTH (0x001B)
 
 /* The data format/composition is not understood/correct. */
-#define NFCSTATUS_INVALID_FORMAT                              (0x001C)
-
+#define NFCSTATUS_INVALID_FORMAT (0x001C)
 
 /* There is not sufficient storage available. */
-#define NFCSTATUS_INSUFFICIENT_STORAGE                        (0x001F)
+#define NFCSTATUS_INSUFFICIENT_STORAGE (0x001F)
 
 /* The Ndef Format procedure has failed. */
-#define NFCSTATUS_FORMAT_ERROR                                (0x0023)
+#define NFCSTATUS_FORMAT_ERROR (0x0023)
 
 /* The NCI Cedit error */
-#define NFCSTATUS_CREDIT_TIMEOUT                              (0x0024)
+#define NFCSTATUS_CREDIT_TIMEOUT (0x0024)
 
 /*
  * Response Time out for the control message(NFCC not responded)
  */
-#define NFCSTATUS_RESPONSE_TIMEOUT                            (0x0025)
+#define NFCSTATUS_RESPONSE_TIMEOUT (0x0025)
 
 /*
  * Device is already connected
  */
-#define NFCSTATUS_ALREADY_CONNECTED                           (0x0026)
+#define NFCSTATUS_ALREADY_CONNECTED (0x0026)
 
 /*
  * Device is already connected
  */
-#define NFCSTATUS_ANOTHER_DEVICE_CONNECTED                    (0x0027)
+#define NFCSTATUS_ANOTHER_DEVICE_CONNECTED (0x0027)
 
 /*
  * Single Target Detected and Activated
  */
-#define NFCSTATUS_SINGLE_TAG_ACTIVATED                        (0x0028)
+#define NFCSTATUS_SINGLE_TAG_ACTIVATED (0x0028)
 
 /*
  * Single Target Detected
  */
-#define NFCSTATUS_SINGLE_TAG_DISCOVERED                       (0x0029)
+#define NFCSTATUS_SINGLE_TAG_DISCOVERED (0x0029)
 
 /*
  * Secure element Detected and Activated
  */
-#define NFCSTATUS_SECURE_ELEMENT_ACTIVATED                    (0x0028)
+#define NFCSTATUS_SECURE_ELEMENT_ACTIVATED (0x0028)
 
 /*
  * Unknown error Status Codes
  */
-#define NFCSTATUS_UNKNOWN_ERROR                               (0x00FE)
+#define NFCSTATUS_UNKNOWN_ERROR (0x00FE)
 
 /*
  * Status code for failure
  */
-#define NFCSTATUS_FAILED                                      (0x00FF)
+#define NFCSTATUS_FAILED (0x00FF)
 
 /*
  * The function/command has been aborted
  */
-#define NFCSTATUS_CMD_ABORTED                                 (0x0002)
+#define NFCSTATUS_CMD_ABORTED (0x0002)
 
 /*
  * No target found after poll
  */
-#define NFCSTATUS_NO_TARGET_FOUND                             (0x000A)
+#define NFCSTATUS_NO_TARGET_FOUND (0x000A)
 
 /* Attempt to disconnect a not connected remote device. */
-#define NFCSTATUS_NO_DEVICE_CONNECTED                         (0x000B)
+#define NFCSTATUS_NO_DEVICE_CONNECTED (0x000B)
 
 /* External RF field detected. */
-#define NFCSTATUS_EXTERNAL_RF_DETECTED                        (0x000E)
+#define NFCSTATUS_EXTERNAL_RF_DETECTED (0x000E)
 
 /* Message is not allowed by the state machine
  * (e.g. configuration went wrong)
  */
-#define NFCSTATUS_MSG_NOT_ALLOWED_BY_FSM                      (0x0010)
+#define NFCSTATUS_MSG_NOT_ALLOWED_BY_FSM (0x0010)
 
 /*
  * No access has been granted
  */
-#define NFCSTATUS_ACCESS_DENIED                               (0x001E)
+#define NFCSTATUS_ACCESS_DENIED (0x001E)
 
 /* No registry node matches the specified input data. */
-#define NFCSTATUS_NODE_NOT_FOUND                              (0x0017)
+#define NFCSTATUS_NODE_NOT_FOUND (0x0017)
 
 /* The current module is busy ; one might retry later */
-#define NFCSTATUS_SMX_BAD_STATE                               (0x00F0)
-
+#define NFCSTATUS_SMX_BAD_STATE (0x00F0)
 
 /* The Abort mechanism has failed for unexpected reason: user can try again*/
-#define NFCSTATUS_ABORT_FAILED                                (0x00F2)
-
+#define NFCSTATUS_ABORT_FAILED (0x00F2)
 
-/* The Registration command has failed because the user wants to register as target
+/* The Registration command has failed because the user wants to register as
+ * target
  * on a operating mode not supported
  */
-#define NFCSTATUS_REG_OPMODE_NOT_SUPPORTED                    (0x00F5)
+#define NFCSTATUS_REG_OPMODE_NOT_SUPPORTED (0x00F5)
 
 /*
  * Shutdown in progress, cannot handle the request at this time.
  */
-#define NFCSTATUS_SHUTDOWN                  (0x0091)
+#define NFCSTATUS_SHUTDOWN (0x0091)
 
 /*
  * Target is no more in RF field
  */
-#define NFCSTATUS_TARGET_LOST               (0x0092)
+#define NFCSTATUS_TARGET_LOST (0x0092)
 
 /*
  * Request is rejected
  */
-#define NFCSTATUS_REJECTED                  (0x0093)
+#define NFCSTATUS_REJECTED (0x0093)
 
 /*
  * Target is not connected
  */
-#define NFCSTATUS_TARGET_NOT_CONNECTED      (0x0094)
+#define NFCSTATUS_TARGET_NOT_CONNECTED (0x0094)
 
 /*
  * Invalid handle for the operation
  */
-#define NFCSTATUS_INVALID_HANDLE            (0x0095)
+#define NFCSTATUS_INVALID_HANDLE (0x0095)
 
 /*
  * Process aborted
  */
-#define NFCSTATUS_ABORTED                   (0x0096)
+#define NFCSTATUS_ABORTED (0x0096)
 
 /*
  * Requested command is not supported
  */
-#define NFCSTATUS_COMMAND_NOT_SUPPORTED     (0x0097)
+#define NFCSTATUS_COMMAND_NOT_SUPPORTED (0x0097)
 
 /*
  * Tag is not NDEF compliant
  */
-#define NFCSTATUS_NON_NDEF_COMPLIANT        (0x0098)
+#define NFCSTATUS_NON_NDEF_COMPLIANT (0x0098)
 
 /*
  * Not enough memory available to complete the requested operation
  */
-#define NFCSTATUS_NOT_ENOUGH_MEMORY         (0x001F)
+#define NFCSTATUS_NOT_ENOUGH_MEMORY (0x001F)
 
 /*
  * Indicates incoming connection
  */
-#define NFCSTATUS_INCOMING_CONNECTION        (0x0045)
+#define NFCSTATUS_INCOMING_CONNECTION (0x0045)
 
 /*
  * Indicates Connection was successful
  */
-#define NFCSTATUS_CONNECTION_SUCCESS         (0x0046)
+#define NFCSTATUS_CONNECTION_SUCCESS (0x0046)
 
 /*
  * Indicates Connection failed
  */
-#define NFCSTATUS_CONNECTION_FAILED          (0x0047)
+#define NFCSTATUS_CONNECTION_FAILED (0x0047)
 
 #endif /* PHNFCSTATUS_H */
diff --git a/nci/jni/extns/pn54x/src/common/phNfcTypes.h b/nci/jni/extns/pn54x/src/common/phNfcTypes.h
index 0b448eae..e11fe027 100644
--- a/nci/jni/extns/pn54x/src/common/phNfcTypes.h
+++ b/nci/jni/extns/pn54x/src/common/phNfcTypes.h
@@ -18,229 +18,230 @@
 #define PHNFCTYPES_H
 
 #include <stdint.h>
-#include <string.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <string.h>
 #include <unistd.h>
 
 #ifndef true
-#define true            (0x01)        /* Logical True Value */
+#define true (0x01) /* Logical True Value */
 #endif
 #ifndef TRUE
-#define TRUE            (0x01)        /* Logical True Value */
+#define TRUE (0x01) /* Logical True Value */
 #endif
 #ifndef false
-#define false           (0x00)        /* Logical False Value */
+#define false (0x00) /* Logical False Value */
 #endif
 #ifndef FALSE
-#define FALSE           (0x00)        /* Logical False Value */
+#define FALSE (0x00) /* Logical False Value */
 #endif
-typedef uint8_t         utf8_t;       /* UTF8 Character String */
-typedef uint8_t         bool_t;       /* boolean data type */
-typedef uint16_t        NFCSTATUS;    /* Return values */
+typedef uint8_t utf8_t;     /* UTF8 Character String */
+typedef uint8_t bool_t;     /* boolean data type */
+typedef uint16_t NFCSTATUS; /* Return values */
 #define STATIC static
 
-#define PHNFC_MAX_UID_LENGTH            0x0AU    /* Maximum UID length expected */
-#define PHNFC_MAX_ATR_LENGTH            0x30U    /* Maximum ATR_RES (General Bytes) length expected */
-#define PHNFC_NFCID_LENGTH              0x0AU    /* Maximum length of NFCID 1.3*/
-#define PHNFC_ATQA_LENGTH               0x02U    /* ATQA length */
+#define PHNFC_MAX_UID_LENGTH 0x0AU /* Maximum UID length expected */
+#define PHNFC_MAX_ATR_LENGTH \
+  0x30U /* Maximum ATR_RES (General Bytes) length expected */
+#define PHNFC_NFCID_LENGTH 0x0AU /* Maximum length of NFCID 1.3*/
+#define PHNFC_ATQA_LENGTH 0x02U  /* ATQA length */
 
 /*
  * NFC Data structure
  */
-typedef struct phNfc_sData
-{
-    uint8_t             *buffer;    /* Buffer to store data */
-    uint32_t            length;     /* Buffer length */
+typedef struct phNfc_sData {
+  uint8_t* buffer; /* Buffer to store data */
+  uint32_t length; /* Buffer length */
 } phNfc_sData_t;
 
 /*
  * Possible Hardware Configuration exposed to upper layer.
- * Typically this should be port name (Ex:"COM1","COM2") to which PN547 is connected.
+ * Typically this should be port name (Ex:"COM1","COM2") to which PN547 is
+ * connected.
  */
-typedef enum
-{
-    ENUM_LINK_TYPE_COM1,
-    ENUM_LINK_TYPE_COM2,
-    ENUM_LINK_TYPE_COM3,
-    ENUM_LINK_TYPE_COM4,
-    ENUM_LINK_TYPE_COM5,
-    ENUM_LINK_TYPE_COM6,
-    ENUM_LINK_TYPE_COM7,
-    ENUM_LINK_TYPE_COM8,
-    ENUM_LINK_TYPE_I2C,
-    ENUM_LINK_TYPE_SPI,
-    ENUM_LINK_TYPE_USB,
-    ENUM_LINK_TYPE_TCP,
-    ENUM_LINK_TYPE_NB
+typedef enum {
+  ENUM_LINK_TYPE_COM1,
+  ENUM_LINK_TYPE_COM2,
+  ENUM_LINK_TYPE_COM3,
+  ENUM_LINK_TYPE_COM4,
+  ENUM_LINK_TYPE_COM5,
+  ENUM_LINK_TYPE_COM6,
+  ENUM_LINK_TYPE_COM7,
+  ENUM_LINK_TYPE_COM8,
+  ENUM_LINK_TYPE_I2C,
+  ENUM_LINK_TYPE_SPI,
+  ENUM_LINK_TYPE_USB,
+  ENUM_LINK_TYPE_TCP,
+  ENUM_LINK_TYPE_NB
 } phLibNfc_eConfigLinkType;
 
 /*
- * Deferred message. This message type will be posted to the client application thread
+ * Deferred message. This message type will be posted to the client application
+ * thread
  * to notify that a deferred call must be invoked.
  */
-#define PH_LIBNFC_DEFERREDCALL_MSG        (0x311)
+#define PH_LIBNFC_DEFERREDCALL_MSG (0x311)
 
 /*
  * Deferred call declaration.
  * This type of API is called from ClientApplication ( main thread) to notify
  * specific callback.
  */
-typedef void (*pphLibNfc_DeferredCallback_t) (void*);
+typedef void (*pphLibNfc_DeferredCallback_t)(void*);
 
 /*
  * Deferred parameter declaration.
- * This type of data is passed as parameter from ClientApplication (main thread) to the
+ * This type of data is passed as parameter from ClientApplication (main thread)
+ * to the
  * callback.
  */
-typedef void *pphLibNfc_DeferredParameter_t;
+typedef void* pphLibNfc_DeferredParameter_t;
 
 /*
  * Possible Hardware Configuration exposed to upper layer.
  * Typically this should be at least the communication link (Ex:"COM1","COM2")
  * the controller is connected to.
  */
-typedef struct phLibNfc_sConfig
-{
-    uint8_t *pLogFile; /* Log File Name*/
-    /* Hardware communication link to the controller */
-    phLibNfc_eConfigLinkType nLinkType;
-    /* The client ID (thread ID or message queue ID) */
-    unsigned int nClientId;
+typedef struct phLibNfc_sConfig {
+  uint8_t* pLogFile; /* Log File Name*/
+  /* Hardware communication link to the controller */
+  phLibNfc_eConfigLinkType nLinkType;
+  /* The client ID (thread ID or message queue ID) */
+  unsigned int nClientId;
 } phLibNfc_sConfig_t, *pphLibNfc_sConfig_t;
 
 /*
  * NFC Message structure contains message specific details like
  * message type, message specific data block details, etc.
  */
-typedef struct phLibNfc_Message
-{
-    uint32_t eMsgType;   /* Type of the message to be posted*/
-    void   * pMsgData;   /* Pointer to message specific data block in case any*/
-    uint32_t Size;       /* Size of the datablock*/
+typedef struct phLibNfc_Message {
+  uint32_t eMsgType; /* Type of the message to be posted*/
+  void* pMsgData;    /* Pointer to message specific data block in case any*/
+  uint32_t Size;     /* Size of the datablock*/
 } phLibNfc_Message_t, *pphLibNfc_Message_t;
 
 /*
  * Deferred message specific info declaration.
- * This type of information is packed as message data when PH_LIBNFC_DEFERREDCALL_MSG
+ * This type of information is packed as message data when
+ * PH_LIBNFC_DEFERREDCALL_MSG
  * type message is posted to message handler thread.
  */
-typedef struct phLibNfc_DeferredCall
-{
-    pphLibNfc_DeferredCallback_t pCallback;/* pointer to Deferred callback */
-    pphLibNfc_DeferredParameter_t pParameter;/* pointer to Deferred parameter */
+typedef struct phLibNfc_DeferredCall {
+  pphLibNfc_DeferredCallback_t pCallback;   /* pointer to Deferred callback */
+  pphLibNfc_DeferredParameter_t pParameter; /* pointer to Deferred parameter */
 } phLibNfc_DeferredCall_t;
 
 /*
  * Definitions for supported protocol
  */
-typedef struct phNfc_sSupProtocol
-{
-    unsigned int MifareUL    : 1;    /* Protocol Mifare Ultra Light or any NFC Forum Type-2 tags */
-    unsigned int MifareStd   : 1;    /* Protocol Mifare Standard. */
-    unsigned int ISO14443_4A : 1;    /* Protocol ISO14443-4 Type A.  */
-    unsigned int ISO14443_4B : 1;    /* Protocol ISO14443-4 Type B.  */
-    unsigned int ISO15693    : 1;    /* Protocol ISO15693 HiTag.  */
-    unsigned int Felica      : 1;    /* Protocol Felica. */
-    unsigned int NFC         : 1;    /* Protocol NFC. */
-    unsigned int Jewel       : 1;    /* Protocol Innovision Jewel Tag. or Any T1T*/
-    unsigned int Desfire     : 1;    /* true indicates specified feature (mapping
-                                        or formatting)for DESFire tag supported else not supported.*/
-    unsigned int Kovio       : 1;    /* Protocol Kovio Tag*/
-    unsigned int HID         : 1;    /* Protocol HID(Picopass) Tag*/
-    unsigned int Bprime      : 1;    /* Protocol BPrime Tag*/
-    unsigned int EPCGEN2     : 1;    /* Protocol EPCGEN2 Tag*/
+typedef struct phNfc_sSupProtocol {
+  unsigned int MifareUL : 1;    /* Protocol Mifare Ultra Light or any NFC Forum
+                                   Type-2 tags */
+  unsigned int MifareStd : 1;   /* Protocol Mifare Standard. */
+  unsigned int ISO14443_4A : 1; /* Protocol ISO14443-4 Type A.  */
+  unsigned int ISO14443_4B : 1; /* Protocol ISO14443-4 Type B.  */
+  unsigned int ISO15693 : 1;    /* Protocol ISO15693 HiTag.  */
+  unsigned int Felica : 1;      /* Protocol Felica. */
+  unsigned int NFC : 1;         /* Protocol NFC. */
+  unsigned int Jewel : 1;       /* Protocol Innovision Jewel Tag. or Any T1T*/
+  unsigned int Desfire : 1;     /* true indicates specified feature (mapping
+                                   or formatting)for DESFire tag supported else not
+                                   supported.*/
+  unsigned int Kovio : 1;       /* Protocol Kovio Tag*/
+  unsigned int HID : 1;         /* Protocol HID(Picopass) Tag*/
+  unsigned int Bprime : 1;      /* Protocol BPrime Tag*/
+  unsigned int EPCGEN2 : 1;     /* Protocol EPCGEN2 Tag*/
 } phNfc_sSupProtocol_t;
 
 /*
  *  Enumerated MIFARE Commands
  */
 
-typedef enum phNfc_eMifareCmdList
-{
-    phNfc_eMifareRaw        = 0x00U,     /* This command performs raw transcations */
-    phNfc_eMifareAuthentA   = 0x60U,     /* This command performs an authentication with KEY A for a sector. */
-    phNfc_eMifareAuthentB   = 0x61U,     /* This command performs an authentication with KEY B for a sector. */
-    phNfc_eMifareRead16     = 0x30U,     /* Read 16 Bytes from a Mifare Standard block */
-    phNfc_eMifareRead       = 0x30U,     /* Read Mifare Standard */
-    phNfc_eMifareWrite16    = 0xA0U,     /* Write 16 Bytes to a Mifare Standard block */
-    phNfc_eMifareWrite4     = 0xA2U,     /* Write 4 bytes. */
-    phNfc_eMifareInc        = 0xC1U,     /* Increment */
-    phNfc_eMifareDec        = 0xC0U,     /* Decrement */
-    phNfc_eMifareTransfer   = 0xB0U,     /* Transfer */
-    phNfc_eMifareRestore    = 0xC2U,     /* Restore.   */
-    phNfc_eMifareReadSector = 0x38U,     /* Read Sector.   */
-    phNfc_eMifareWriteSector= 0xA8U,     /* Write Sector.   */
-    /* Above commands could be used for preparing raw command but below one can not be */
-    phNfc_eMifareReadN      = 0x01,      /* Proprietary Command */
-    phNfc_eMifareWriteN     = 0x02,      /* Proprietary Command */
-    phNfc_eMifareSectorSel  = 0x03,      /* Proprietary Command */
-    phNfc_eMifareAuth       = 0x04,      /* Proprietary Command */
-    phNfc_eMifareProxCheck  = 0x05,      /* Proprietary Command */
-    phNfc_eMifareInvalidCmd = 0xFFU      /* Invalid Command */
+typedef enum phNfc_eMifareCmdList {
+  phNfc_eMifareRaw = 0x00U,      /* This command performs raw transcations */
+  phNfc_eMifareAuthentA = 0x60U, /* This command performs an authentication with
+                                    KEY A for a sector. */
+  phNfc_eMifareAuthentB = 0x61U, /* This command performs an authentication with
+                                    KEY B for a sector. */
+  phNfc_eMifareRead16 = 0x30U,  /* Read 16 Bytes from a Mifare Standard block */
+  phNfc_eMifareRead = 0x30U,    /* Read Mifare Standard */
+  phNfc_eMifareWrite16 = 0xA0U, /* Write 16 Bytes to a Mifare Standard block */
+  phNfc_eMifareWrite4 = 0xA2U,  /* Write 4 bytes. */
+  phNfc_eMifareInc = 0xC1U,     /* Increment */
+  phNfc_eMifareDec = 0xC0U,     /* Decrement */
+  phNfc_eMifareTransfer = 0xB0U,    /* Transfer */
+  phNfc_eMifareRestore = 0xC2U,     /* Restore.   */
+  phNfc_eMifareReadSector = 0x38U,  /* Read Sector.   */
+  phNfc_eMifareWriteSector = 0xA8U, /* Write Sector.   */
+  /* Above commands could be used for preparing raw command but below one can
+     not be */
+  phNfc_eMifareReadN = 0x01,      /* Proprietary Command */
+  phNfc_eMifareWriteN = 0x02,     /* Proprietary Command */
+  phNfc_eMifareSectorSel = 0x03,  /* Proprietary Command */
+  phNfc_eMifareAuth = 0x04,       /* Proprietary Command */
+  phNfc_eMifareProxCheck = 0x05,  /* Proprietary Command */
+  phNfc_eMifareInvalidCmd = 0xFFU /* Invalid Command */
 } phNfc_eMifareCmdList_t;
 
 /*
  * Information about ISO14443A
  */
-typedef struct phNfc_sIso14443AInfo
-{
-    uint8_t         Uid[PHNFC_MAX_UID_LENGTH];      /* UID information of the TYPE A
-                                                     * Tag Discovered */
-    uint8_t         UidLength;                      /* UID information length */
-    uint8_t         AppData[PHNFC_MAX_ATR_LENGTH];  /* Application data information of the
-                              1                      * tag discovered (= Historical bytes for
-                                                     * type A) */
-    uint8_t         AppDataLength;                  /* Application data length */
-    uint8_t         Sak;                            /* SAK information of the TYPE A
-                                                     * Tag Discovered */
-    uint8_t         AtqA[PHNFC_ATQA_LENGTH];        /* ATQA informationof the TYPE A
-                                                     * Tag Discovered */
-    uint8_t         MaxDataRate;                    /* Maximum data rate supported
-                                                     * by the tag Discovered */
-    uint8_t         Fwi_Sfgt;                       /* Frame waiting time and start up
-                                                     * frame guard */
+typedef struct phNfc_sIso14443AInfo {
+  uint8_t Uid[PHNFC_MAX_UID_LENGTH]; /* UID information of the TYPE A
+                                      * Tag Discovered */
+  uint8_t UidLength;                 /* UID information length */
+  uint8_t
+      AppData[PHNFC_MAX_ATR_LENGTH]; /* Application data information of the
+               1                      * tag discovered (= Historical bytes for
+                                      * type A) */
+  uint8_t AppDataLength;             /* Application data length */
+  uint8_t Sak;                       /* SAK information of the TYPE A
+                                      * Tag Discovered */
+  uint8_t AtqA[PHNFC_ATQA_LENGTH];   /* ATQA informationof the TYPE A
+                                      * Tag Discovered */
+  uint8_t MaxDataRate;               /* Maximum data rate supported
+                                      * by the tag Discovered */
+  uint8_t Fwi_Sfgt;                  /* Frame waiting time and start up
+                                      * frame guard */
 } phNfc_sIso14443AInfo_t;
 
 /* Remote device information structure */
-typedef union phNfc_uRemoteDevInfo
-{
-    phNfc_sIso14443AInfo_t Iso14443A_Info;/* ISO1443A Remote device info */
+typedef union phNfc_uRemoteDevInfo {
+  phNfc_sIso14443AInfo_t Iso14443A_Info; /* ISO1443A Remote device info */
 } phNfc_uRemoteDevInfo_t;
 
 /*
-*
-*  The RF Device Type List is used to identify the type of
-*  remote device that is discovered and connected.
-*
-*/
+ *
+ *  The RF Device Type List is used to identify the type of
+ *  remote device that is discovered and connected.
+ *
+ */
 
-typedef enum phNfc_eRFDevType
-{
-    phNfc_eUnknown_DevType        = 0x00U,
-    phNfc_eISO14443_A_PCD,
-    phNfc_eISO14443_B_PCD,
-    phNfc_eISO14443_BPrime_PCD,
-    phNfc_eFelica_PCD,
-    phNfc_eJewel_PCD,
-    phNfc_eISO15693_PCD,
-    phNfc_eEpcGen2_PCD,
-    phNfc_ePCD_DevType,
-    phNfc_ePICC_DevType,
-    phNfc_eISO14443_A_PICC,
-    phNfc_eISO14443_4A_PICC,
-    phNfc_eISO14443_3A_PICC,
-    phNfc_eMifare_PICC,
-    phNfc_eISO14443_B_PICC,
-    phNfc_eISO14443_4B_PICC,
-    phNfc_eISO14443_BPrime_PICC,
-    phNfc_eFelica_PICC,
-    phNfc_eJewel_PICC,
-    phNfc_eISO15693_PICC,
-    phNfc_eEpcGen2_PICC,
-    phNfc_eNfcIP1_Target,
-    phNfc_eNfcIP1_Initiator,
-    phNfc_eInvalid_DevType
+typedef enum phNfc_eRFDevType {
+  phNfc_eUnknown_DevType = 0x00U,
+  phNfc_eISO14443_A_PCD,
+  phNfc_eISO14443_B_PCD,
+  phNfc_eISO14443_BPrime_PCD,
+  phNfc_eFelica_PCD,
+  phNfc_eJewel_PCD,
+  phNfc_eISO15693_PCD,
+  phNfc_eEpcGen2_PCD,
+  phNfc_ePCD_DevType,
+  phNfc_ePICC_DevType,
+  phNfc_eISO14443_A_PICC,
+  phNfc_eISO14443_4A_PICC,
+  phNfc_eISO14443_3A_PICC,
+  phNfc_eMifare_PICC,
+  phNfc_eISO14443_B_PICC,
+  phNfc_eISO14443_4B_PICC,
+  phNfc_eISO14443_BPrime_PICC,
+  phNfc_eFelica_PICC,
+  phNfc_eJewel_PICC,
+  phNfc_eISO15693_PICC,
+  phNfc_eEpcGen2_PICC,
+  phNfc_eNfcIP1_Target,
+  phNfc_eNfcIP1_Initiator,
+  phNfc_eInvalid_DevType
 } phNfc_eRFDevType_t;
 
 /*
@@ -254,67 +255,64 @@ typedef phNfc_eRemDevType_t phHal_eRemDevType_t;
  *   Union for each available type of Commands.
  */
 
-typedef union phNfc_uCommand
-{
-    phNfc_eMifareCmdList_t MfCmd;  /* Mifare command structure.  */
+typedef union phNfc_uCommand {
+  phNfc_eMifareCmdList_t MfCmd; /* Mifare command structure.  */
 } phNfc_uCmdList_t;
 
 /*
- *  The Remote Device Information Structure holds information about one single Remote
+ *  The Remote Device Information Structure holds information about one single
+ * Remote
  *  Device detected.
  */
-typedef struct phNfc_sRemoteDevInformation
-{
-    uint8_t                    SessionOpened;       /* Flag indicating the validity of
-                                                     * the handle of the remote device.
-                                                     * 1 = Device is not activer (Only discovered), 2 = Device is active and ready for use*/
-    phNfc_eRemDevType_t        RemDevType;          /* Remote device type */
-    phNfc_uRemoteDevInfo_t     RemoteDevInfo;       /* Union of available Remote Device */
+typedef struct phNfc_sRemoteDevInformation {
+  uint8_t SessionOpened;                /* Flag indicating the validity of
+                                         * the handle of the remote device.
+                                         * 1 = Device is not activer (Only discovered), 2 =
+                                         * Device is active and ready for use*/
+  phNfc_eRemDevType_t RemDevType;       /* Remote device type */
+  phNfc_uRemoteDevInfo_t RemoteDevInfo; /* Union of available Remote Device */
 } phNfc_sRemoteDevInformation_t;
 
-
 /*
- * Transceive Information Data Structure for sending commands/response to the remote device
+ * Transceive Information Data Structure for sending commands/response to the
+ * remote device
  */
 
-typedef struct phNfc_sTransceiveInfo
-{
-    phNfc_uCmdList_t                cmd;         /* Command for transceive */
-    uint8_t                         addr;        /* Start Block Number */
-    uint8_t                         NumBlock;    /* Number of Blocks to perform operation */
-    /* For Felica only*/
-    uint16_t *ServiceCodeList;                   /* 2 Byte service Code List */
-    uint16_t *Blocklist;                         /* 2 Byte Block list */
-    phNfc_sData_t                   sSendData;   /* Send data */
-    phNfc_sData_t                   sRecvData;   /* Recv data */
-    /* For EPC-GEN */
-    uint32_t                        dwWordPtr;   /* Word address for the memory write */
-    uint8_t                         bWordPtrLen; /* Specifies the length of word pointer
-                                                    00: 8  bits
-                                                    01: 16 bits
-                                                    10: 24 bits
-                                                    11: 32 bits
-                                                 */
-    uint8_t                        bWordCount;   /* Number of words to be read or written */
+typedef struct phNfc_sTransceiveInfo {
+  phNfc_uCmdList_t cmd; /* Command for transceive */
+  uint8_t addr;         /* Start Block Number */
+  uint8_t NumBlock;     /* Number of Blocks to perform operation */
+  /* For Felica only*/
+  uint16_t* ServiceCodeList; /* 2 Byte service Code List */
+  uint16_t* Blocklist;       /* 2 Byte Block list */
+  phNfc_sData_t sSendData;   /* Send data */
+  phNfc_sData_t sRecvData;   /* Recv data */
+  /* For EPC-GEN */
+  uint32_t dwWordPtr;  /* Word address for the memory write */
+  uint8_t bWordPtrLen; /* Specifies the length of word pointer
+                          00: 8  bits
+                          01: 16 bits
+                          10: 24 bits
+                          11: 32 bits
+                       */
+  uint8_t bWordCount;  /* Number of words to be read or written */
 } phNfc_sTransceiveInfo_t;
 
-typedef enum p61_access_state{
-    P61_STATE_INVALID = 0x0000,
-    P61_STATE_IDLE = 0x0100, /* p61 is free to use */
-    P61_STATE_WIRED = 0x0200, /* p61 is being accessed by DWP (NFCC)*/
-    P61_STATE_SPI = 0x0400, /* P61 is being accessed by SPI */
-    P61_STATE_DWNLD = 0x0800, /* NFCC fw download is in progress */
-    P61_STATE_SPI_PRIO = 0x1000, /*Start of p61 access by SPI on priority*/
-    P61_STATE_SPI_PRIO_END = 0x2000, /*End of p61 access by SPI on priority*/
-    P61_STATE_SPI_END = 0x4000, /*End of p61 access by SPI*/
-    P61_STATE_SPI_SVDD_SYNC_START = 0x0001, /*ESE_VDD Low req by SPI*/
-    P61_STATE_SPI_SVDD_SYNC_END = 0x0002, /*ESE_VDD is Low by SPI*/
-    P61_STATE_DWP_SVDD_SYNC_START = 0x0004, /*ESE_VDD  Low req by Nfc*/
-    P61_STATE_DWP_SVDD_SYNC_END = 0x0008, /*ESE_VDD is Low by Nfc*/
-    P61_STATE_DWP_SESSION_CLOSE = 0xFFFF,
-    P61_STATE_JCP_DWNLD         = 0x8000, /* JCOP download is in progress */
+typedef enum p61_access_state {
+  P61_STATE_INVALID = 0x0000,
+  P61_STATE_IDLE = 0x0100,         /* p61 is free to use */
+  P61_STATE_WIRED = 0x0200,        /* p61 is being accessed by DWP (NFCC)*/
+  P61_STATE_SPI = 0x0400,          /* P61 is being accessed by SPI */
+  P61_STATE_DWNLD = 0x0800,        /* NFCC fw download is in progress */
+  P61_STATE_SPI_PRIO = 0x1000,     /*Start of p61 access by SPI on priority*/
+  P61_STATE_SPI_PRIO_END = 0x2000, /*End of p61 access by SPI on priority*/
+  P61_STATE_SPI_END = 0x4000,      /*End of p61 access by SPI*/
+  P61_STATE_SPI_SVDD_SYNC_START = 0x0001, /*ESE_VDD Low req by SPI*/
+  P61_STATE_SPI_SVDD_SYNC_END = 0x0002,   /*ESE_VDD is Low by SPI*/
+  P61_STATE_DWP_SVDD_SYNC_START = 0x0004, /*ESE_VDD  Low req by Nfc*/
+  P61_STATE_DWP_SVDD_SYNC_END = 0x0008,   /*ESE_VDD is Low by Nfc*/
+  P61_STATE_DWP_SESSION_CLOSE = 0xFFFF,
+  P61_STATE_JCP_DWNLD = 0x8000, /* JCOP download is in progress */
 } p61_access_state_t;
 
-#define UNUSED(X) (void)(X);
-
 #endif /* PHNFCTYPES_H */
diff --git a/nci/jni/extns/pn54x/src/common/phNfcTypes_Mapping.h b/nci/jni/extns/pn54x/src/common/phNfcTypes_Mapping.h
index 9a1a5252..f23c5fe4 100644
--- a/nci/jni/extns/pn54x/src/common/phNfcTypes_Mapping.h
+++ b/nci/jni/extns/pn54x/src/common/phNfcTypes_Mapping.h
@@ -17,7 +17,6 @@
 #ifndef PHNFCTYPES_MAPPING_H_
 #define PHNFCTYPES_MAPPING_H_
 
-
 typedef phNfc_sData_t phHal_sData_t;
 typedef phNfc_sSupProtocol_t phHal_sSupProtocol_t;
 #define phHal_eMifareRaw phNfc_eMifareRaw
diff --git a/nci/jni/extns/pn54x/src/log/phNxpLog.c b/nci/jni/extns/pn54x/src/log/phNxpLog.c
deleted file mode 100644
index 9a8f94f0..00000000
--- a/nci/jni/extns/pn54x/src/log/phNxpLog.c
+++ /dev/null
@@ -1,271 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#define LOG_TAG "pn54x"
-
-#include <stdio.h>
-#include <string.h>
-#if !defined (NXPLOG__H_INCLUDED)
-#include "phNxpLog.h"
-#include "phNxpConfig.h"
-#endif
-#include <cutils/properties.h>
-#include <log/log.h>
-
-const char * NXPLOG_ITEM_EXTNS   = "NxpExtns";
-const char * NXPLOG_ITEM_NCIHAL  = "NxpHal";
-const char * NXPLOG_ITEM_NCIX    = "NxpNciX";
-const char * NXPLOG_ITEM_NCIR    = "NxpNciR";
-const char * NXPLOG_ITEM_FWDNLD  = "NxpFwDnld";
-const char * NXPLOG_ITEM_TML     = "NxpTml";
-
-#ifdef NXP_HCI_REQ
-const char * NXPLOG_ITEM_HCPX    = "NxpHcpX";
-const char * NXPLOG_ITEM_HCPR    = "NxpHcpR";
-#endif /*NXP_HCI_REQ*/
-
-/* global log level structure */
-nci_log_level_t gLog_level;
-
-
-/*******************************************************************************
- *
- * Function         phNxpLog_SetGlobalLogLevel
- *
- * Description      Sets the global log level for all modules.
- *                  This value is set by Android property nfc.nxp_log_level_global.
- *                  If value can be overridden by module log level.
- *
- * Returns          The value of global log level
- *
- ******************************************************************************/
-static uint8_t phNxpLog_SetGlobalLogLevel (void)
-{
-    uint8_t level = NXPLOG_DEFAULT_LOGLEVEL;
-    unsigned long num = 0;
-    char valueStr [PROPERTY_VALUE_MAX] = {0};
-
-    int len = property_get (PROP_NAME_NXPLOG_GLOBAL_LOGLEVEL, valueStr, "");
-    if (len > 0)
-    {
-        /* let Android property override .conf variable */
-        sscanf (valueStr, "%lu", &num);
-        level = (unsigned char) num;
-    }
-    memset(&gLog_level, level, sizeof(nci_log_level_t));
-    return level;
-}
-
-/*******************************************************************************
- *
- * Function         phNxpLog_SetHALLogLevel
- *
- * Description      Sets the HAL layer log level.
- *
- * Returns          void
- *
- ******************************************************************************/
-static void phNxpLog_SetHALLogLevel (uint8_t level)
-{
-    unsigned long num = 0;
-    int len;
-    char valueStr [PROPERTY_VALUE_MAX] = {0};
-
-    if (GetNxpNumValue (NAME_NXPLOG_HAL_LOGLEVEL, &num, sizeof(num)))
-    {
-        gLog_level.hal_log_level = (level > (unsigned char) num) ? level : (unsigned char) num;;
-    }
-
-    len = property_get (PROP_NAME_NXPLOG_HAL_LOGLEVEL, valueStr, "");
-    if (len > 0)
-    {
-        /* let Android property override .conf variable */
-        sscanf (valueStr, "%lu", &num);
-        gLog_level.hal_log_level = (unsigned char) num;
-    }
-
-    return;
-}
-
-/*******************************************************************************
- *
- * Function         phNxpLog_SetExtnsLogLevel
- *
- * Description      Sets the Extensions layer log level.
- *
- * Returns          void
- *
- ******************************************************************************/
-static void phNxpLog_SetExtnsLogLevel (uint8_t level)
-{
-    unsigned long num = 0;
-    int len;
-    char valueStr [PROPERTY_VALUE_MAX] = {0};
-    if (GetNxpNumValue (NAME_NXPLOG_EXTNS_LOGLEVEL, &num, sizeof(num)))
-    {
-        gLog_level.extns_log_level = (level > (unsigned char) num) ? level : (unsigned char) num;;
-    }
-
-    len = property_get (PROP_NAME_NXPLOG_EXTNS_LOGLEVEL, valueStr, "");
-    if (len > 0)
-    {
-        /* let Android property override .conf variable */
-        sscanf (valueStr, "%lu", &num);
-        gLog_level.extns_log_level = (unsigned char) num;
-    }
-
-    return;
-}
-
-/*******************************************************************************
- *
- * Function         phNxpLog_SetTmlLogLevel
- *
- * Description      Sets the TML layer log level.
- *
- * Returns          void
- *
- ******************************************************************************/
-static void phNxpLog_SetTmlLogLevel (uint8_t level)
-{
-    unsigned long num = 0;
-    int len;
-    char valueStr [PROPERTY_VALUE_MAX] = {0};
-    if (GetNxpNumValue (NAME_NXPLOG_TML_LOGLEVEL, &num, sizeof(num)))
-    {
-        gLog_level.tml_log_level = (level > (unsigned char) num) ? level : (unsigned char) num;;
-    }
-
-    len = property_get (PROP_NAME_NXPLOG_TML_LOGLEVEL, valueStr, "");
-    if (len > 0)
-    {
-        /* let Android property override .conf variable */
-        sscanf (valueStr, "%lu", &num);
-        gLog_level.tml_log_level = (unsigned char) num;
-    }
-
-    return;
-}
-
-/*******************************************************************************
- *
- * Function         phNxpLog_SetDnldLogLevel
- *
- * Description      Sets the FW download layer log level.
- *
- * Returns          void
- *
- ******************************************************************************/
-static void phNxpLog_SetDnldLogLevel (uint8_t level)
-{
-    unsigned long num = 0;
-    int len;
-    char valueStr [PROPERTY_VALUE_MAX] = {0};
-    if (GetNxpNumValue (NAME_NXPLOG_FWDNLD_LOGLEVEL, &num, sizeof(num)))
-    {
-        gLog_level.dnld_log_level = (level > (unsigned char) num) ? level : (unsigned char) num;;
-    }
-
-    len = property_get (PROP_NAME_NXPLOG_FWDNLD_LOGLEVEL, valueStr, "");
-    if (len > 0)
-    {
-        /* let Android property override .conf variable */
-        sscanf (valueStr, "%lu", &num);
-        gLog_level.dnld_log_level = (unsigned char) num;
-    }
-
-    return;
-}
-
-/*******************************************************************************
- *
- * Function         phNxpLog_SetNciTxLogLevel
- *
- * Description      Sets the NCI transaction layer log level.
- *
- * Returns          void
- *
- ******************************************************************************/
-static void phNxpLog_SetNciTxLogLevel (uint8_t level)
-{
-    unsigned long num = 0;
-    int len;
-    char valueStr [PROPERTY_VALUE_MAX] = {0};
-    if (GetNxpNumValue (NAME_NXPLOG_NCIX_LOGLEVEL, &num, sizeof(num)))
-    {
-        gLog_level.ncix_log_level = (level > (unsigned char) num) ? level : (unsigned char) num;
-    }
-    if (GetNxpNumValue (NAME_NXPLOG_NCIR_LOGLEVEL, &num, sizeof(num)))
-    {
-        gLog_level.ncir_log_level = (level > (unsigned char) num) ? level : (unsigned char) num;;
-    }
-
-    len = property_get (PROP_NAME_NXPLOG_NCI_LOGLEVEL, valueStr, "");
-    if (len > 0)
-    {
-        /* let Android property override .conf variable */
-        sscanf (valueStr, "%lu", &num);
-        gLog_level.ncix_log_level = (unsigned char) num;
-        gLog_level.ncir_log_level = (unsigned char) num;
-    }
-
-    return;
-}
-
-/******************************************************************************
- * Function         phNxpLog_InitializeLogLevel
- *
- * Description      Initialize and get log level of module from libnfc-nxp.conf or
- *                  Android runtime properties.
- *                  The Android property nfc.nxp_global_log_level is to
- *                  define log level for all modules. Modules log level will override global level.
- *                  The Android property will override the level
- *                  in libnfc-nxp.conf
- *
- *                  Android property names:
- *                      nfc.nxp_log_level_global    * defines log level for all modules
- *                      nfc.nxp_log_level_extns     * extensions module log
- *                      nfc.nxp_log_level_hal       * Hal module log
- *                      nfc.nxp_log_level_dnld      * firmware download module log
- *                      nfc.nxp_log_level_tml       * TML module log
- *                      nfc.nxp_log_level_nci       * NCI transaction log
- *
- *                  Log Level values:
- *                      NXPLOG_LOG_SILENT_LOGLEVEL  0        * No trace to show
- *                      NXPLOG_LOG_ERROR_LOGLEVEL   1        * Show Error trace only
- *                      NXPLOG_LOG_WARN_LOGLEVEL    2        * Show Warning trace and Error trace
- *                      NXPLOG_LOG_DEBUG_LOGLEVEL   3        * Show all traces
- *
- * Returns          void
- *
- ******************************************************************************/
-void phNxpLog_InitializeLogLevel(void)
-{
-    uint8_t level = phNxpLog_SetGlobalLogLevel ();
-    phNxpLog_SetHALLogLevel (level);
-    phNxpLog_SetExtnsLogLevel (level);
-    phNxpLog_SetTmlLogLevel (level);
-    phNxpLog_SetDnldLogLevel (level);
-    phNxpLog_SetNciTxLogLevel (level);
-
-    ALOGV("%s: global =%u, Fwdnld =%u, extns =%u, \
-                hal =%u, tml =%u, ncir =%u, \
-                ncix =%u", \
-                __func__, gLog_level.global_log_level, gLog_level.dnld_log_level,
-                    gLog_level.extns_log_level, gLog_level.hal_log_level, gLog_level.tml_log_level,
-                    gLog_level.ncir_log_level, gLog_level.ncix_log_level);
-
-    return;
-}
diff --git a/nci/jni/extns/pn54x/src/log/phNxpLog.cpp b/nci/jni/extns/pn54x/src/log/phNxpLog.cpp
new file mode 100644
index 00000000..ee24142b
--- /dev/null
+++ b/nci/jni/extns/pn54x/src/log/phNxpLog.cpp
@@ -0,0 +1,281 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#if !defined(NXPLOG__H_INCLUDED)
+#include "phNxpConfig.h"
+#include "phNxpLog.h"
+#endif
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+#include <cutils/properties.h>
+#include "nfc_config.h"
+
+using android::base::StringPrintf;
+extern bool nfc_debug_enabled;
+
+const char* NXPLOG_ITEM_EXTNS = "NxpExtns";
+const char* NXPLOG_ITEM_NCIHAL = "NxpHal";
+const char* NXPLOG_ITEM_NCIX = "NxpNciX";
+const char* NXPLOG_ITEM_NCIR = "NxpNciR";
+const char* NXPLOG_ITEM_FWDNLD = "NxpFwDnld";
+const char* NXPLOG_ITEM_TML = "NxpTml";
+
+#ifdef NXP_HCI_REQ
+const char* NXPLOG_ITEM_HCPX = "NxpHcpX";
+const char* NXPLOG_ITEM_HCPR = "NxpHcpR";
+#endif /*NXP_HCI_REQ*/
+
+/* global log level structure */
+nci_log_level_t gLog_level;
+
+/*******************************************************************************
+ *
+ * Function         phNxpLog_SetGlobalLogLevel
+ *
+ * Description      Sets the global log level for all modules.
+ *                  This value is set by Android property
+ *nfc.nxp_log_level_global.
+ *                  If value can be overridden by module log level.
+ *
+ * Returns          The value of global log level
+ *
+ ******************************************************************************/
+static uint8_t phNxpLog_SetGlobalLogLevel(void) {
+  uint8_t level = NXPLOG_DEFAULT_LOGLEVEL;
+  unsigned long num = 0;
+  char valueStr[PROPERTY_VALUE_MAX] = {0};
+
+  int len = property_get(PROP_NAME_NXPLOG_GLOBAL_LOGLEVEL, valueStr, "");
+  if (len > 0) {
+    /* let Android property override .conf variable */
+    sscanf(valueStr, "%lu", &num);
+    level = (unsigned char)num;
+  }
+  memset(&gLog_level, level, sizeof(nci_log_level_t));
+  return level;
+}
+
+/*******************************************************************************
+ *
+ * Function         phNxpLog_SetHALLogLevel
+ *
+ * Description      Sets the HAL layer log level.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void phNxpLog_SetHALLogLevel(uint8_t level) {
+  unsigned long num = 0;
+  int len;
+  char valueStr[PROPERTY_VALUE_MAX] = {0};
+
+  if (NfcConfig::hasKey(NAME_NXPLOG_HAL_LOGLEVEL)) {
+    num = NfcConfig::getUnsigned(NAME_NXPLOG_HAL_LOGLEVEL);
+    gLog_level.hal_log_level =
+        (level > (unsigned char)num) ? level : (unsigned char)num;
+    ;
+  }
+
+  len = property_get(PROP_NAME_NXPLOG_HAL_LOGLEVEL, valueStr, "");
+  if (len > 0) {
+    /* let Android property override .conf variable */
+    sscanf(valueStr, "%lu", &num);
+    gLog_level.hal_log_level = (unsigned char)num;
+  }
+
+  return;
+}
+
+/*******************************************************************************
+ *
+ * Function         phNxpLog_SetExtnsLogLevel
+ *
+ * Description      Sets the Extensions layer log level.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void phNxpLog_SetExtnsLogLevel(uint8_t level) {
+  unsigned long num = 0;
+  int len;
+  char valueStr[PROPERTY_VALUE_MAX] = {0};
+  if (NfcConfig::hasKey(NAME_NXPLOG_EXTNS_LOGLEVEL)) {
+    num = NfcConfig::getUnsigned(NAME_NXPLOG_EXTNS_LOGLEVEL);
+    gLog_level.extns_log_level =
+        (level > (unsigned char)num) ? level : (unsigned char)num;
+    ;
+  }
+
+  len = property_get(PROP_NAME_NXPLOG_EXTNS_LOGLEVEL, valueStr, "");
+  if (len > 0) {
+    /* let Android property override .conf variable */
+    sscanf(valueStr, "%lu", &num);
+    gLog_level.extns_log_level = (unsigned char)num;
+  }
+
+  return;
+}
+
+/*******************************************************************************
+ *
+ * Function         phNxpLog_SetTmlLogLevel
+ *
+ * Description      Sets the TML layer log level.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void phNxpLog_SetTmlLogLevel(uint8_t level) {
+  unsigned long num = 0;
+  int len;
+  char valueStr[PROPERTY_VALUE_MAX] = {0};
+  if (NfcConfig::hasKey(NAME_NXPLOG_TML_LOGLEVEL)) {
+    num = NfcConfig::getUnsigned(NAME_NXPLOG_TML_LOGLEVEL);
+    gLog_level.tml_log_level =
+        (level > (unsigned char)num) ? level : (unsigned char)num;
+    ;
+  }
+
+  len = property_get(PROP_NAME_NXPLOG_TML_LOGLEVEL, valueStr, "");
+  if (len > 0) {
+    /* let Android property override .conf variable */
+    sscanf(valueStr, "%lu", &num);
+    gLog_level.tml_log_level = (unsigned char)num;
+  }
+
+  return;
+}
+
+/*******************************************************************************
+ *
+ * Function         phNxpLog_SetDnldLogLevel
+ *
+ * Description      Sets the FW download layer log level.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void phNxpLog_SetDnldLogLevel(uint8_t level) {
+  unsigned long num = 0;
+  int len;
+  char valueStr[PROPERTY_VALUE_MAX] = {0};
+  if (NfcConfig::hasKey(NAME_NXPLOG_FWDNLD_LOGLEVEL)) {
+    num = NfcConfig::getUnsigned(NAME_NXPLOG_FWDNLD_LOGLEVEL);
+    gLog_level.dnld_log_level =
+        (level > (unsigned char)num) ? level : (unsigned char)num;
+    ;
+  }
+
+  len = property_get(PROP_NAME_NXPLOG_FWDNLD_LOGLEVEL, valueStr, "");
+  if (len > 0) {
+    /* let Android property override .conf variable */
+    sscanf(valueStr, "%lu", &num);
+    gLog_level.dnld_log_level = (unsigned char)num;
+  }
+
+  return;
+}
+
+/*******************************************************************************
+ *
+ * Function         phNxpLog_SetNciTxLogLevel
+ *
+ * Description      Sets the NCI transaction layer log level.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void phNxpLog_SetNciTxLogLevel(uint8_t level) {
+  unsigned long num = 0;
+  int len;
+  char valueStr[PROPERTY_VALUE_MAX] = {0};
+  if (NfcConfig::hasKey(NAME_NXPLOG_NCIX_LOGLEVEL)) {
+    num = NfcConfig::getUnsigned(NAME_NXPLOG_NCIX_LOGLEVEL);
+    gLog_level.ncix_log_level =
+        (level > (unsigned char)num) ? level : (unsigned char)num;
+  }
+  if (NfcConfig::hasKey(NAME_NXPLOG_NCIR_LOGLEVEL)) {
+    num = NfcConfig::getUnsigned(NAME_NXPLOG_NCIR_LOGLEVEL);
+    gLog_level.ncir_log_level =
+        (level > (unsigned char)num) ? level : (unsigned char)num;
+    ;
+  }
+
+  len = property_get(PROP_NAME_NXPLOG_NCI_LOGLEVEL, valueStr, "");
+  if (len > 0) {
+    /* let Android property override .conf variable */
+    sscanf(valueStr, "%lu", &num);
+    gLog_level.ncix_log_level = (unsigned char)num;
+    gLog_level.ncir_log_level = (unsigned char)num;
+  }
+
+  return;
+}
+
+/******************************************************************************
+ * Function         phNxpLog_InitializeLogLevel
+ *
+ * Description      Initialize and get log level of module from libnfc-nxp.conf
+ *or
+ *                  Android runtime properties.
+ *                  The Android property nfc.nxp_global_log_level is to
+ *                  define log level for all modules. Modules log level will
+ *override global level.
+ *                  The Android property will override the level
+ *                  in libnfc-nxp.conf
+ *
+ *                  Android property names:
+ *                      nfc.nxp_log_level_global    * defines log level for all
+ *modules
+ *                      nfc.nxp_log_level_extns     * extensions module log
+ *                      nfc.nxp_log_level_hal       * Hal module log
+ *                      nfc.nxp_log_level_dnld      * firmware download module
+ *log
+ *                      nfc.nxp_log_level_tml       * TML module log
+ *                      nfc.nxp_log_level_nci       * NCI transaction log
+ *
+ *                  Log Level values:
+ *                      NXPLOG_LOG_SILENT_LOGLEVEL  0        * No trace to show
+ *                      NXPLOG_LOG_ERROR_LOGLEVEL   1        * Show Error trace
+ *only
+ *                      NXPLOG_LOG_WARN_LOGLEVEL    2        * Show Warning
+ *trace and Error trace
+ *                      NXPLOG_LOG_DEBUG_LOGLEVEL   3        * Show all traces
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+void phNxpLog_InitializeLogLevel(void) {
+  uint8_t level = phNxpLog_SetGlobalLogLevel();
+  phNxpLog_SetHALLogLevel(level);
+  phNxpLog_SetExtnsLogLevel(level);
+  phNxpLog_SetTmlLogLevel(level);
+  phNxpLog_SetDnldLogLevel(level);
+  phNxpLog_SetNciTxLogLevel(level);
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: global =%u, Fwdnld =%u, extns =%u, \
+                hal =%u, tml =%u, ncir =%u, \
+                ncix =%u",
+      __func__, gLog_level.global_log_level, gLog_level.dnld_log_level,
+      gLog_level.extns_log_level, gLog_level.hal_log_level,
+      gLog_level.tml_log_level, gLog_level.ncir_log_level,
+      gLog_level.ncix_log_level);
+
+  return;
+}
diff --git a/nci/jni/extns/pn54x/src/log/phNxpLog.h b/nci/jni/extns/pn54x/src/log/phNxpLog.h
index 55574648..827ff56b 100644
--- a/nci/jni/extns/pn54x/src/log/phNxpLog.h
+++ b/nci/jni/extns/pn54x/src/log/phNxpLog.h
@@ -14,108 +14,117 @@
  * limitations under the License.
  */
 
-#if !defined (NXPLOG__H_INCLUDED)
+#if !defined(NXPLOG__H_INCLUDED)
 #define NXPLOG__H_INCLUDED
 
 #include <log/log.h>
 #include <string.h>
 
-typedef struct nci_log_level
-{
-    uint8_t global_log_level;
-    uint8_t extns_log_level;
-    uint8_t hal_log_level;
-    uint8_t dnld_log_level;
-    uint8_t tml_log_level;
-    uint8_t ncix_log_level;
-    uint8_t ncir_log_level;
+typedef struct nci_log_level {
+  uint8_t global_log_level;
+  uint8_t extns_log_level;
+  uint8_t hal_log_level;
+  uint8_t dnld_log_level;
+  uint8_t tml_log_level;
+  uint8_t ncix_log_level;
+  uint8_t ncir_log_level;
 } nci_log_level_t;
 
 /* global log level Ref */
 extern nci_log_level_t gLog_level;
 
 /* define log module included when compile */
-#define ENABLE_EXTNS_TRACES   true
-#define ENABLE_HAL_TRACES     true
-#define ENABLE_TML_TRACES     true
-#define ENABLE_FWDNLD_TRACES  true
-#define ENABLE_NCIX_TRACES    true
-#define ENABLE_NCIR_TRACES    true
-
-#define ENABLE_HCPX_TRACES    false
-#define ENABLE_HCPR_TRACES    false
-
-/* ####################### Set the log module name in .conf file ########################## */
-#define NAME_NXPLOG_EXTNS_LOGLEVEL          "NXPLOG_EXTNS_LOGLEVEL"
-#define NAME_NXPLOG_HAL_LOGLEVEL            "NXPLOG_NCIHAL_LOGLEVEL"
-#define NAME_NXPLOG_NCIX_LOGLEVEL           "NXPLOG_NCIX_LOGLEVEL"
-#define NAME_NXPLOG_NCIR_LOGLEVEL           "NXPLOG_NCIR_LOGLEVEL"
-#define NAME_NXPLOG_FWDNLD_LOGLEVEL         "NXPLOG_FWDNLD_LOGLEVEL"
-#define NAME_NXPLOG_TML_LOGLEVEL            "NXPLOG_TML_LOGLEVEL"
-
-/* ####################### Set the log module name by Android property ########################## */
-#define PROP_NAME_NXPLOG_GLOBAL_LOGLEVEL       "nfc.nxp_log_level_global"
-#define PROP_NAME_NXPLOG_EXTNS_LOGLEVEL        "nfc.nxp_log_level_extns"
-#define PROP_NAME_NXPLOG_HAL_LOGLEVEL          "nfc.nxp_log_level_hal"
-#define PROP_NAME_NXPLOG_NCI_LOGLEVEL          "nfc.nxp_log_level_nci"
-#define PROP_NAME_NXPLOG_FWDNLD_LOGLEVEL       "nfc.nxp_log_level_dnld"
-#define PROP_NAME_NXPLOG_TML_LOGLEVEL          "nfc.nxp_log_level_tml"
-
-/* ####################### Set the logging level for EVERY COMPONENT here ######################## :START: */
-#define NXPLOG_LOG_SILENT_LOGLEVEL             0x00
-#define NXPLOG_LOG_ERROR_LOGLEVEL              0x01
-#define NXPLOG_LOG_WARN_LOGLEVEL               0x02
-#define NXPLOG_LOG_DEBUG_LOGLEVEL              0x03
-/* ####################### Set the default logging level for EVERY COMPONENT here ########################## :END: */
-
+#define ENABLE_HAL_TRACES true
+#define ENABLE_TML_TRACES true
+#define ENABLE_FWDNLD_TRACES true
+#define ENABLE_NCIX_TRACES true
+#define ENABLE_NCIR_TRACES true
+
+#define ENABLE_HCPX_TRACES false
+#define ENABLE_HCPR_TRACES false
+
+/* ####################### Set the log module name in .conf file
+ * ########################## */
+#define NAME_NXPLOG_EXTNS_LOGLEVEL "NXPLOG_EXTNS_LOGLEVEL"
+#define NAME_NXPLOG_HAL_LOGLEVEL "NXPLOG_NCIHAL_LOGLEVEL"
+#define NAME_NXPLOG_NCIX_LOGLEVEL "NXPLOG_NCIX_LOGLEVEL"
+#define NAME_NXPLOG_NCIR_LOGLEVEL "NXPLOG_NCIR_LOGLEVEL"
+#define NAME_NXPLOG_FWDNLD_LOGLEVEL "NXPLOG_FWDNLD_LOGLEVEL"
+#define NAME_NXPLOG_TML_LOGLEVEL "NXPLOG_TML_LOGLEVEL"
+
+/* ####################### Set the log module name by Android property
+ * ########################## */
+#define PROP_NAME_NXPLOG_GLOBAL_LOGLEVEL "nfc.nxp_log_level_global"
+#define PROP_NAME_NXPLOG_EXTNS_LOGLEVEL "nfc.nxp_log_level_extns"
+#define PROP_NAME_NXPLOG_HAL_LOGLEVEL "nfc.nxp_log_level_hal"
+#define PROP_NAME_NXPLOG_NCI_LOGLEVEL "nfc.nxp_log_level_nci"
+#define PROP_NAME_NXPLOG_FWDNLD_LOGLEVEL "nfc.nxp_log_level_dnld"
+#define PROP_NAME_NXPLOG_TML_LOGLEVEL "nfc.nxp_log_level_tml"
+
+/* ####################### Set the logging level for EVERY COMPONENT here
+ * ######################## :START: */
+#define NXPLOG_LOG_SILENT_LOGLEVEL 0x00
+#define NXPLOG_LOG_ERROR_LOGLEVEL 0x01
+#define NXPLOG_LOG_WARN_LOGLEVEL 0x02
+#define NXPLOG_LOG_DEBUG_LOGLEVEL 0x03
+/* ####################### Set the default logging level for EVERY COMPONENT
+ * here ########################## :END: */
 
 /* The Default log level for all the modules. */
-#define NXPLOG_DEFAULT_LOGLEVEL                NXPLOG_LOG_ERROR_LOGLEVEL
-
+#define NXPLOG_DEFAULT_LOGLEVEL NXPLOG_LOG_ERROR_LOGLEVEL
 
-/* ################################################################################################################ */
-/* ############################################### Component Names ################################################ */
-/* ################################################################################################################ */
+/* ################################################################################################################
+ */
+/* ############################################### Component Names
+ * ################################################ */
+/* ################################################################################################################
+ */
 
-extern const char * NXPLOG_ITEM_EXTNS;   /* Android logging tag for NxpExtns  */
-extern const char * NXPLOG_ITEM_NCIHAL;  /* Android logging tag for NxpNciHal */
-extern const char * NXPLOG_ITEM_NCIX;    /* Android logging tag for NxpNciX   */
-extern const char * NXPLOG_ITEM_NCIR;    /* Android logging tag for NxpNciR   */
-extern const char * NXPLOG_ITEM_FWDNLD;  /* Android logging tag for NxpFwDnld */
-extern const char * NXPLOG_ITEM_TML;     /* Android logging tag for NxpTml    */
+extern const char* NXPLOG_ITEM_EXTNS;  /* Android logging tag for NxpExtns  */
+extern const char* NXPLOG_ITEM_NCIHAL; /* Android logging tag for NxpNciHal */
+extern const char* NXPLOG_ITEM_NCIX;   /* Android logging tag for NxpNciX   */
+extern const char* NXPLOG_ITEM_NCIR;   /* Android logging tag for NxpNciR   */
+extern const char* NXPLOG_ITEM_FWDNLD; /* Android logging tag for NxpFwDnld */
+extern const char* NXPLOG_ITEM_TML;    /* Android logging tag for NxpTml    */
 
 #ifdef NXP_HCI_REQ
-extern const char * NXPLOG_ITEM_HCPX;    /* Android logging tag for NxpHcpX   */
-extern const char * NXPLOG_ITEM_HCPR;    /* Android logging tag for NxpHcpR   */
-#endif /*NXP_HCI_REQ*/
+extern const char* NXPLOG_ITEM_HCPX; /* Android logging tag for NxpHcpX   */
+extern const char* NXPLOG_ITEM_HCPR; /* Android logging tag for NxpHcpR   */
+#endif                               /*NXP_HCI_REQ*/
 
-/* ######################################## Defines used for Logging data ######################################### */
+/* ######################################## Defines used for Logging data
+ * ######################################### */
 #ifdef NXP_VRBS_REQ
 #define NXPLOG_FUNC_ENTRY(COMP) \
-    LOG_PRI( ANDROID_LOG_VERBOSE, (COMP), "+:%s", (__func__))
+  LOG_PRI(ANDROID_LOG_VERBOSE, (COMP), "+:%s", (__func__))
 #define NXPLOG_FUNC_EXIT(COMP) \
-    LOG_PRI( ANDROID_LOG_VERBOSE, (COMP), "-:%s", (__func__))
+  LOG_PRI(ANDROID_LOG_VERBOSE, (COMP), "-:%s", (__func__))
 #endif /*NXP_VRBS_REQ*/
 
-/* ################################################################################################################ */
-/* ######################################## Logging APIs of actual modules ######################################## */
-/* ################################################################################################################ */
-/* Logging APIs used by NxpExtns module */
-#if (ENABLE_EXTNS_TRACES == true )
-#define NXPLOG_EXTNS_D(...)  {if (gLog_level.extns_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL) LOG_PRI (ANDROID_LOG_DEBUG, NXPLOG_ITEM_EXTNS, __VA_ARGS__);}
-#define NXPLOG_EXTNS_W(...)  {if (gLog_level.extns_log_level >= NXPLOG_LOG_WARN_LOGLEVEL) LOG_PRI (ANDROID_LOG_WARN, NXPLOG_ITEM_EXTNS, __VA_ARGS__);}
-#define NXPLOG_EXTNS_E(...)  {if (gLog_level.extns_log_level >= NXPLOG_LOG_ERROR_LOGLEVEL) LOG_PRI (ANDROID_LOG_ERROR, NXPLOG_ITEM_EXTNS, __VA_ARGS__);}
-#else
-#define NXPLOG_EXTNS_D(...)
-#define NXPLOG_EXTNS_W(...)
-#define NXPLOG_EXTNS_E(...)
-#endif /* Logging APIs used by NxpExtns module */
+/* ################################################################################################################
+ */
+/* ######################################## Logging APIs of actual modules
+ * ######################################## */
+/* ################################################################################################################
+ */
 
 /* Logging APIs used by NxpNciHal module */
-#if (ENABLE_HAL_TRACES == true )
-#define NXPLOG_NCIHAL_D(...)  {if (gLog_level.hal_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL) LOG_PRI (ANDROID_LOG_DEBUG, NXPLOG_ITEM_NCIHAL, __VA_ARGS__);}
-#define NXPLOG_NCIHAL_W(...)  {if (gLog_level.hal_log_level >= NXPLOG_LOG_WARN_LOGLEVEL) LOG_PRI (ANDROID_LOG_WARN, NXPLOG_ITEM_NCIHAL, __VA_ARGS__);}
-#define NXPLOG_NCIHAL_E(...)  {if (gLog_level.hal_log_level >= NXPLOG_LOG_ERROR_LOGLEVEL) LOG_PRI (ANDROID_LOG_ERROR, NXPLOG_ITEM_NCIHAL, __VA_ARGS__);}
+#if (ENABLE_HAL_TRACES == true)
+#define NXPLOG_NCIHAL_D(...)                                       \
+  {                                                                \
+    if (gLog_level.hal_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL)     \
+      LOG_PRI(ANDROID_LOG_DEBUG, NXPLOG_ITEM_NCIHAL, __VA_ARGS__); \
+  }
+#define NXPLOG_NCIHAL_W(...)                                      \
+  {                                                               \
+    if (gLog_level.hal_log_level >= NXPLOG_LOG_WARN_LOGLEVEL)     \
+      LOG_PRI(ANDROID_LOG_WARN, NXPLOG_ITEM_NCIHAL, __VA_ARGS__); \
+  }
+#define NXPLOG_NCIHAL_E(...)                                       \
+  {                                                                \
+    if (gLog_level.hal_log_level >= NXPLOG_LOG_ERROR_LOGLEVEL)     \
+      LOG_PRI(ANDROID_LOG_ERROR, NXPLOG_ITEM_NCIHAL, __VA_ARGS__); \
+  }
 #else
 #define NXPLOG_NCIHAL_D(...)
 #define NXPLOG_NCIHAL_W(...)
@@ -123,10 +132,22 @@ extern const char * NXPLOG_ITEM_HCPR;    /* Android logging tag for NxpHcpR   */
 #endif /* Logging APIs used by HAL module */
 
 /* Logging APIs used by NxpNciX module */
-#if (ENABLE_NCIX_TRACES == true )
-#define NXPLOG_NCIX_D(...)  {if (gLog_level.ncix_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL) LOG_PRI (ANDROID_LOG_DEBUG, NXPLOG_ITEM_NCIX, __VA_ARGS__);}
-#define NXPLOG_NCIX_W(...)  {if (gLog_level.ncix_log_level >= NXPLOG_LOG_WARN_LOGLEVEL) LOG_PRI (ANDROID_LOG_WARN, NXPLOG_ITEM_NCIX, __VA_ARGS__);}
-#define NXPLOG_NCIX_E(...)  {if (gLog_level.ncix_log_level >= NXPLOG_LOG_ERROR_LOGLEVEL) LOG_PRI (ANDROID_LOG_ERROR, NXPLOG_ITEM_NCIX, __VA_ARGS__);}
+#if (ENABLE_NCIX_TRACES == true)
+#define NXPLOG_NCIX_D(...)                                       \
+  {                                                              \
+    if (gLog_level.ncix_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL)  \
+      LOG_PRI(ANDROID_LOG_DEBUG, NXPLOG_ITEM_NCIX, __VA_ARGS__); \
+  }
+#define NXPLOG_NCIX_W(...)                                      \
+  {                                                             \
+    if (gLog_level.ncix_log_level >= NXPLOG_LOG_WARN_LOGLEVEL)  \
+      LOG_PRI(ANDROID_LOG_WARN, NXPLOG_ITEM_NCIX, __VA_ARGS__); \
+  }
+#define NXPLOG_NCIX_E(...)                                       \
+  {                                                              \
+    if (gLog_level.ncix_log_level >= NXPLOG_LOG_ERROR_LOGLEVEL)  \
+      LOG_PRI(ANDROID_LOG_ERROR, NXPLOG_ITEM_NCIX, __VA_ARGS__); \
+  }
 #else
 #define NXPLOG_NCIX_D(...)
 #define NXPLOG_NCIX_W(...)
@@ -134,10 +155,22 @@ extern const char * NXPLOG_ITEM_HCPR;    /* Android logging tag for NxpHcpR   */
 #endif /* Logging APIs used by NCIx module */
 
 /* Logging APIs used by NxpNciR module */
-#if (ENABLE_NCIR_TRACES == true )
-#define NXPLOG_NCIR_D(...)  {if (gLog_level.ncir_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL) LOG_PRI (ANDROID_LOG_DEBUG, NXPLOG_ITEM_NCIR, __VA_ARGS__);}
-#define NXPLOG_NCIR_W(...)  {if (gLog_level.ncir_log_level >= NXPLOG_LOG_WARN_LOGLEVEL) LOG_PRI (ANDROID_LOG_WARN, NXPLOG_ITEM_NCIR, __VA_ARGS__);}
-#define NXPLOG_NCIR_E(...)  {if (gLog_level.ncir_log_level >= NXPLOG_LOG_ERROR_LOGLEVEL) LOG_PRI (ANDROID_LOG_ERROR, NXPLOG_ITEM_NCIR, __VA_ARGS__);}
+#if (ENABLE_NCIR_TRACES == true)
+#define NXPLOG_NCIR_D(...)                                       \
+  {                                                              \
+    if (gLog_level.ncir_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL)  \
+      LOG_PRI(ANDROID_LOG_DEBUG, NXPLOG_ITEM_NCIR, __VA_ARGS__); \
+  }
+#define NXPLOG_NCIR_W(...)                                      \
+  {                                                             \
+    if (gLog_level.ncir_log_level >= NXPLOG_LOG_WARN_LOGLEVEL)  \
+      LOG_PRI(ANDROID_LOG_WARN, NXPLOG_ITEM_NCIR, __VA_ARGS__); \
+  }
+#define NXPLOG_NCIR_E(...)                                       \
+  {                                                              \
+    if (gLog_level.ncir_log_level >= NXPLOG_LOG_ERROR_LOGLEVEL)  \
+      LOG_PRI(ANDROID_LOG_ERROR, NXPLOG_ITEM_NCIR, __VA_ARGS__); \
+  }
 #else
 #define NXPLOG_NCIR_D(...)
 #define NXPLOG_NCIR_W(...)
@@ -145,10 +178,22 @@ extern const char * NXPLOG_ITEM_HCPR;    /* Android logging tag for NxpHcpR   */
 #endif /* Logging APIs used by NCIR module */
 
 /* Logging APIs used by NxpFwDnld module */
-#if (ENABLE_FWDNLD_TRACES == true )
-#define NXPLOG_FWDNLD_D(...)  {if (gLog_level.dnld_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL) LOG_PRI (ANDROID_LOG_DEBUG, NXPLOG_ITEM_FWDNLD, __VA_ARGS__);}
-#define NXPLOG_FWDNLD_W(...)  {if (gLog_level.dnld_log_level >= NXPLOG_LOG_WARN_LOGLEVEL) LOG_PRI (ANDROID_LOG_WARN, NXPLOG_ITEM_FWDNLD, __VA_ARGS__);}
-#define NXPLOG_FWDNLD_E(...)  {if (gLog_level.dnld_log_level >= NXPLOG_LOG_ERROR_LOGLEVEL) LOG_PRI (ANDROID_LOG_ERROR, NXPLOG_ITEM_FWDNLD, __VA_ARGS__);}
+#if (ENABLE_FWDNLD_TRACES == true)
+#define NXPLOG_FWDNLD_D(...)                                       \
+  {                                                                \
+    if (gLog_level.dnld_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL)    \
+      LOG_PRI(ANDROID_LOG_DEBUG, NXPLOG_ITEM_FWDNLD, __VA_ARGS__); \
+  }
+#define NXPLOG_FWDNLD_W(...)                                      \
+  {                                                               \
+    if (gLog_level.dnld_log_level >= NXPLOG_LOG_WARN_LOGLEVEL)    \
+      LOG_PRI(ANDROID_LOG_WARN, NXPLOG_ITEM_FWDNLD, __VA_ARGS__); \
+  }
+#define NXPLOG_FWDNLD_E(...)                                       \
+  {                                                                \
+    if (gLog_level.dnld_log_level >= NXPLOG_LOG_ERROR_LOGLEVEL)    \
+      LOG_PRI(ANDROID_LOG_ERROR, NXPLOG_ITEM_FWDNLD, __VA_ARGS__); \
+  }
 #else
 #define NXPLOG_FWDNLD_D(...)
 #define NXPLOG_FWDNLD_W(...)
@@ -156,10 +201,22 @@ extern const char * NXPLOG_ITEM_HCPR;    /* Android logging tag for NxpHcpR   */
 #endif /* Logging APIs used by NxpFwDnld module */
 
 /* Logging APIs used by NxpTml module */
-#if (ENABLE_TML_TRACES == true )
-#define NXPLOG_TML_D(...)  {if (gLog_level.tml_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL) LOG_PRI (ANDROID_LOG_DEBUG, NXPLOG_ITEM_TML, __VA_ARGS__);}
-#define NXPLOG_TML_W(...)  {if (gLog_level.tml_log_level >= NXPLOG_LOG_WARN_LOGLEVEL) LOG_PRI (ANDROID_LOG_WARN, NXPLOG_ITEM_TML, __VA_ARGS__);}
-#define NXPLOG_TML_E(...)  {if (gLog_level.tml_log_level >= NXPLOG_LOG_ERROR_LOGLEVEL) LOG_PRI (ANDROID_LOG_ERROR, NXPLOG_ITEM_TML, __VA_ARGS__);}
+#if (ENABLE_TML_TRACES == true)
+#define NXPLOG_TML_D(...)                                       \
+  {                                                             \
+    if (gLog_level.tml_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL)  \
+      LOG_PRI(ANDROID_LOG_DEBUG, NXPLOG_ITEM_TML, __VA_ARGS__); \
+  }
+#define NXPLOG_TML_W(...)                                      \
+  {                                                            \
+    if (gLog_level.tml_log_level >= NXPLOG_LOG_WARN_LOGLEVEL)  \
+      LOG_PRI(ANDROID_LOG_WARN, NXPLOG_ITEM_TML, __VA_ARGS__); \
+  }
+#define NXPLOG_TML_E(...)                                       \
+  {                                                             \
+    if (gLog_level.tml_log_level >= NXPLOG_LOG_ERROR_LOGLEVEL)  \
+      LOG_PRI(ANDROID_LOG_ERROR, NXPLOG_ITEM_TML, __VA_ARGS__); \
+  }
 #else
 #define NXPLOG_TML_D(...)
 #define NXPLOG_TML_W(...)
@@ -168,10 +225,22 @@ extern const char * NXPLOG_ITEM_HCPR;    /* Android logging tag for NxpHcpR   */
 
 #ifdef NXP_HCI_REQ
 /* Logging APIs used by NxpHcpX module */
-#if (ENABLE_HCPX_TRACES == true )
-#define NXPLOG_HCPX_D(...)  {if (gLog_level.dnld_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL) LOG_PRI (ANDROID_LOG_DEBUG, NXPLOG_ITEM_FWDNLD, __VA_ARGS__);}
-#define NXPLOG_HCPX_W(...)  {if (gLog_level.dnld_log_level >= NXPLOG_LOG_WARN_LOGLEVEL) LOG_PRI (ANDROID_LOG_WARN, NXPLOG_ITEM_FWDNLD, __VA_ARGS__);}
-#define NXPLOG_HCPX_E(...)  {if (gLog_level.dnld_log_level >= NXPLOG_LOG_ERROR_LOGLEVEL) LOG_PRI (ANDROID_LOG_ERROR, NXPLOG_ITEM_FWDNLD, __VA_ARGS__);}
+#if (ENABLE_HCPX_TRACES == true)
+#define NXPLOG_HCPX_D(...)                                         \
+  {                                                                \
+    if (gLog_level.dnld_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL)    \
+      LOG_PRI(ANDROID_LOG_DEBUG, NXPLOG_ITEM_FWDNLD, __VA_ARGS__); \
+  }
+#define NXPLOG_HCPX_W(...)                                        \
+  {                                                               \
+    if (gLog_level.dnld_log_level >= NXPLOG_LOG_WARN_LOGLEVEL)    \
+      LOG_PRI(ANDROID_LOG_WARN, NXPLOG_ITEM_FWDNLD, __VA_ARGS__); \
+  }
+#define NXPLOG_HCPX_E(...)                                         \
+  {                                                                \
+    if (gLog_level.dnld_log_level >= NXPLOG_LOG_ERROR_LOGLEVEL)    \
+      LOG_PRI(ANDROID_LOG_ERROR, NXPLOG_ITEM_FWDNLD, __VA_ARGS__); \
+  }
 #else
 #define NXPLOG_HCPX_D(...)
 #define NXPLOG_HCPX_W(...)
@@ -179,10 +248,22 @@ extern const char * NXPLOG_ITEM_HCPR;    /* Android logging tag for NxpHcpR   */
 #endif /* Logging APIs used by NxpHcpX module */
 
 /* Logging APIs used by NxpHcpR module */
-#if (ENABLE_HCPR_TRACES == true )
-#define NXPLOG_HCPR_D(...)  {if (gLog_level.dnld_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL) LOG_PRI (ANDROID_LOG_DEBUG, NXPLOG_ITEM_FWDNLD, __VA_ARGS__);}
-#define NXPLOG_HCPR_W(...)  {if (gLog_level.dnld_log_level >= NXPLOG_LOG_WARN_LOGLEVEL) LOG_PRI (ANDROID_LOG_WARN, NXPLOG_ITEM_FWDNLD, __VA_ARGS__);}
-#define NXPLOG_HCPR_E(...)  {if (gLog_level.dnld_log_level >= NXPLOG_LOG_ERROR_LOGLEVEL) LOG_PRI (ANDROID_LOG_ERROR, NXPLOG_ITEM_FWDNLD, __VA_ARGS__);}
+#if (ENABLE_HCPR_TRACES == true)
+#define NXPLOG_HCPR_D(...)                                         \
+  {                                                                \
+    if (gLog_level.dnld_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL)    \
+      LOG_PRI(ANDROID_LOG_DEBUG, NXPLOG_ITEM_FWDNLD, __VA_ARGS__); \
+  }
+#define NXPLOG_HCPR_W(...)                                        \
+  {                                                               \
+    if (gLog_level.dnld_log_level >= NXPLOG_LOG_WARN_LOGLEVEL)    \
+      LOG_PRI(ANDROID_LOG_WARN, NXPLOG_ITEM_FWDNLD, __VA_ARGS__); \
+  }
+#define NXPLOG_HCPR_E(...)                                         \
+  {                                                                \
+    if (gLog_level.dnld_log_level >= NXPLOG_LOG_ERROR_LOGLEVEL)    \
+      LOG_PRI(ANDROID_LOG_ERROR, NXPLOG_ITEM_FWDNLD, __VA_ARGS__); \
+  }
 #else
 #define NXPLOG_HCPR_D(...)
 #define NXPLOG_HCPR_W(...)
@@ -191,33 +272,26 @@ extern const char * NXPLOG_ITEM_HCPR;    /* Android logging tag for NxpHcpR   */
 #endif /* NXP_HCI_REQ */
 
 #ifdef NXP_VRBS_REQ
-#if (ENABLE_EXTNS_TRACES == true )
-#define NXPLOG_EXTNS_ENTRY() NXPLOG_FUNC_ENTRY (NXPLOG_ITEM_EXTNS)
-#define NXPLOG_EXTNS_EXIT()  NXPLOG_FUNC_EXIT (NXPLOG_ITEM_EXTNS)
-#else
-#define NXPLOG_EXTNS_ENTRY()
-#define NXPLOG_EXTNS_EXIT()
-#endif
 
-#if (ENABLE_HAL_TRACES == true )
-#define NXPLOG_NCIHAL_ENTRY() NXPLOG_FUNC_ENTRY (NXPLOG_ITEM_NCIHAL)
-#define NXPLOG_NCIHAL_EXIT()  NXPLOG_FUNC_EXIT (NXPLOG_ITEM_NCIHAL)
+#if (ENABLE_HAL_TRACES == true)
+#define NXPLOG_NCIHAL_ENTRY() NXPLOG_FUNC_ENTRY(NXPLOG_ITEM_NCIHAL)
+#define NXPLOG_NCIHAL_EXIT() NXPLOG_FUNC_EXIT(NXPLOG_ITEM_NCIHAL)
 #else
 #define NXPLOG_NCIHAL_ENTRY()
 #define NXPLOG_NCIHAL_EXIT()
 #endif
 
-#if (ENABLE_NCIX_TRACES == true )
-#define NXPLOG_NCIX_ENTRY() NXPLOG_FUNC_ENTRY (NXPLOG_ITEM_NCIX)
-#define NXPLOG_NCIX_EXIT()  NXPLOG_FUNC_EXIT (NXPLOG_ITEM_NCIX)
+#if (ENABLE_NCIX_TRACES == true)
+#define NXPLOG_NCIX_ENTRY() NXPLOG_FUNC_ENTRY(NXPLOG_ITEM_NCIX)
+#define NXPLOG_NCIX_EXIT() NXPLOG_FUNC_EXIT(NXPLOG_ITEM_NCIX)
 #else
 #define NXPLOG_NCIX_ENTRY()
 #define NXPLOG_NCIX_EXIT()
 #endif
 
-#if (ENABLE_NCIR_TRACES == true )
-#define NXPLOG_NCIR_ENTRY() NXPLOG_FUNC_ENTRY (NXPLOG_ITEM_NCIR)
-#define NXPLOG_NCIR_EXIT()  NXPLOG_FUNC_EXIT (NXPLOG_ITEM_NCIR)
+#if (ENABLE_NCIR_TRACES == true)
+#define NXPLOG_NCIR_ENTRY() NXPLOG_FUNC_ENTRY(NXPLOG_ITEM_NCIR)
+#define NXPLOG_NCIR_EXIT() NXPLOG_FUNC_EXIT(NXPLOG_ITEM_NCIR)
 #else
 #define NXPLOG_NCIR_ENTRY()
 #define NXPLOG_NCIR_EXIT()
@@ -225,17 +299,17 @@ extern const char * NXPLOG_ITEM_HCPR;    /* Android logging tag for NxpHcpR   */
 
 #ifdef NXP_HCI_REQ
 
-#if (ENABLE_HCPX_TRACES == true )
-#define NXPLOG_HCPX_ENTRY() NXPLOG_FUNC_ENTRY (NXPLOG_ITEM_HCPX)
-#define NXPLOG_HCPX_EXIT()  NXPLOG_FUNC_EXIT (NXPLOG_ITEM_HCPX)
+#if (ENABLE_HCPX_TRACES == true)
+#define NXPLOG_HCPX_ENTRY() NXPLOG_FUNC_ENTRY(NXPLOG_ITEM_HCPX)
+#define NXPLOG_HCPX_EXIT() NXPLOG_FUNC_EXIT(NXPLOG_ITEM_HCPX)
 #else
 #define NXPLOG_HCPX_ENTRY()
 #define NXPLOG_HCPX_EXIT()
 #endif
 
-#if (ENABLE_HCPR_TRACES == true )
-#define NXPLOG_HCPR_ENTRY() NXPLOG_FUNC_ENTRY (NXPLOG_ITEM_HCPR)
-#define NXPLOG_HCPR_EXIT()  NXPLOG_FUNC_EXIT (NXPLOG_ITEM_HCPR)
+#if (ENABLE_HCPR_TRACES == true)
+#define NXPLOG_HCPR_ENTRY() NXPLOG_FUNC_ENTRY(NXPLOG_ITEM_HCPR)
+#define NXPLOG_HCPR_EXIT() NXPLOG_FUNC_EXIT(NXPLOG_ITEM_HCPR)
 #else
 #define NXPLOG_HCPR_ENTRY()
 #define NXPLOG_HCPR_EXIT()
@@ -244,6 +318,6 @@ extern const char * NXPLOG_ITEM_HCPR;    /* Android logging tag for NxpHcpR   */
 
 #endif /* NXP_VRBS_REQ */
 
-void phNxpLog_InitializeLogLevel (void);
+void phNxpLog_InitializeLogLevel(void);
 
 #endif /* NXPLOG__H_INCLUDED */
diff --git a/nci/jni/extns/pn54x/src/mifare/phFriNfc.h b/nci/jni/extns/pn54x/src/mifare/phFriNfc.h
index 8aba23b9..bbbb42a2 100644
--- a/nci/jni/extns/pn54x/src/mifare/phFriNfc.h
+++ b/nci/jni/extns/pn54x/src/mifare/phFriNfc.h
@@ -24,62 +24,88 @@
 
 #define LOCK_BITS_CHECK_ENABLE
 
-#define NFCSTATUS_INVALID_DEVICE_REQUEST                        (0x10F5)
+#define NFCSTATUS_INVALID_DEVICE_REQUEST (0x10F5)
 
 /*
  * Completion Routine
  *
- * NFC-FRI components that work in an overlapped style need to provide a function that is compatible
+ * NFC-FRI components that work in an overlapped style need to provide a
+ *function that is compatible
  * to this definition.
- * It is mandatory to define such a routine for components that interact with other components up or
- * down the stack. Moreover, such components shall provide a function within their API to enable the
+ * It is mandatory to define such a routine for components that interact with
+ *other components up or
+ * down the stack. Moreover, such components shall provide a function within
+ *their API to enable the
  * setting of the Completion Routine address and parameters.
  *
  *      First Parameter: Context
- *      Set to the address of the called instance (component instance context structure). For instance,
- *      a component that needs to give control to a component up the stack needs to call the completion
- *      routine of the upper component. The value to assign to this parameter is the address of
- *      the context structure instance of the called component. Such a structure usually contains all
- *      variables, data or state information a component member needs for operation. The address of the
- *      upper instance must be known by the lower (completing) instance. The mechanism to ensure that this
- *      information is present involves the structure phFriNfc_CplRt_t . See its documentation for
+ *      Set to the address of the called instance (component instance context
+ *structure). For instance,
+ *      a component that needs to give control to a component up the stack needs
+ *to call the completion
+ *      routine of the upper component. The value to assign to this parameter is
+ *the address of
+ *      the context structure instance of the called component. Such a structure
+ *usually contains all
+ *      variables, data or state information a component member needs for
+ *operation. The address of the
+ *      upper instance must be known by the lower (completing) instance. The
+ *mechanism to ensure that this
+ *      information is present involves the structure phFriNfc_CplRt_t . See its
+ *documentation for
  *      further information.
  *
  *      Second Parameter: Status Value
- *      The lower layer hands over the completion status via this parameter. The completion
- *      routine that has been called needs to process the status in a way that is comparable to what
+ *      The lower layer hands over the completion status via this parameter. The
+ *completion
+ *      routine that has been called needs to process the status in a way that
+ *is comparable to what
  *      a regular function return value would require.
  *
- *       The prototype of the component's Process(ing) functions has to be compatible to this
- *       function pointer declaration for components interacting with others. In other cases, where
- *       there is no interaction or asynchronous processing the definition of the Process(ing)
+ *       The prototype of the component's Process(ing) functions has to be
+ *compatible to this
+ *       function pointer declaration for components interacting with others. In
+ *other cases, where
+ *       there is no interaction or asynchronous processing the definition of
+ *the Process(ing)
  *       function can be arbitrary, if present at all.
  */
-typedef void (*pphFriNfc_Cr_t) (void*, NFCSTATUS);
+typedef void (*pphFriNfc_Cr_t)(void*, NFCSTATUS);
 
 /*
  * Completion Routine structure
  *
- * This structure finds itself within each component that requires to report completion
+ * This structure finds itself within each component that requires to report
+ *completion
  * to an upper (calling) component.
- * Depending on the actual implementation (static or dynamic completion information) the stack
- * Initialization or the calling component needs to inform the initialized or called component
+ * Depending on the actual implementation (static or dynamic completion
+ *information) the stack
+ * Initialization or the calling component needs to inform the initialized or
+ *called component
  * about the completion path. This information is submitted via this structure.
  */
-typedef struct phFriNfc_CplRt
-{
-    pphFriNfc_Cr_t    CompletionRoutine; /* Address of the upper Layer's Process(ing) function to call upon completion.
-                                          *   The stack initializer (or depending on the implementation: the calling component)
-                                          *   needs to set this member to the address of the function that needs to be within
-                                          *   the completion path: A calling component would give its own processing function
-                                          *   address to the lower layer.
-                                          */
-    void             *Context;           /* Instance address (context) parameter.
-                                          *   The stack initializer (or depending on the implementation: the calling component)
-                                          *   needs to set this member to the address of the component context structure instance
-                                          *   within the completion path: A calling component would give its own instance address
-                                          *   to the lower layer.
-                                          */
+typedef struct phFriNfc_CplRt {
+  pphFriNfc_Cr_t CompletionRoutine; /* Address of the upper Layer's Process(ing)
+                                     * function to call upon completion.
+                                     *   The stack initializer (or depending on
+                                     * the implementation: the calling
+                                     * component)
+                                     *   needs to set this member to the address
+                                     * of the function that needs to be within
+                                     *   the completion path: A calling
+                                     * component would give its own processing
+                                     * function
+                                     *   address to the lower layer.
+                                     */
+  void* Context;                    /* Instance address (context) parameter.
+                                     *   The stack initializer (or depending on the implementation:
+                                     * the calling component)
+                                     *   needs to set this member to the address of the component
+                                     * context structure instance
+                                     *   within the completion path: A calling component would give
+                                     * its own instance address
+                                     *   to the lower layer.
+                                     */
 } phFriNfc_CplRt_t;
 
 #endif /* __PHFRINFC_H__ */
diff --git a/nci/jni/extns/pn54x/src/mifare/phFriNfc_MifStdFormat.c b/nci/jni/extns/pn54x/src/mifare/phFriNfc_MifStdFormat.c
deleted file mode 100644
index 7018e812..00000000
--- a/nci/jni/extns/pn54x/src/mifare/phFriNfc_MifStdFormat.c
+++ /dev/null
@@ -1,1385 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Mifare Standard Format implementation
- */
-
-#include <phFriNfc_MifStdFormat.h>
-#include <phNxpExtns_MifareStd.h>
-#include <phNfcCompId.h>
-#include <phNxpLog.h>
-
-/* Function prototype declarations */
-static void phFriNfc_MfStd_H_FillSendBuf(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt, uint16_t BlockNo);
-static NFCSTATUS phFriNfc_MfStd_H_Transceive(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt);
-static NFCSTATUS phFriNfc_MfStd_H_CallDisCon(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt, NFCSTATUS Status);
-static NFCSTATUS phFriNfc_MfStd_H_CallCon(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt);
-static NFCSTATUS phFriNfc_MfStd_H_ProCon(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt);
-static NFCSTATUS phFriNfc_MfStd_H_ProAuth(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt);
-static NFCSTATUS phFriNfc_MfStd_H_ProRdSectTr(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt);
-static NFCSTATUS phFriNfc_MfStd_H_ProWrSectTr(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt);
-static NFCSTATUS phFriNfc_MfStd_H_WrRdAuth(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt);
-static uint32_t phFriNfc_MfStd_H_ChkAcsBit(uint16_t BlockNo, const uint8_t *RecvBuf, const uint8_t AcsBits1[], const uint8_t AcsBits2[]);
-static void phFriNfc_MfStd_H_ChangeAuthSt(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt);
-static void phFriNfc_MfStd_H_NdefComplSect(uint8_t CardTypes, uint8_t Sector[]);
-static NFCSTATUS phFriNfc_MfStd_H_ProWrMADBlk(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt);
-static NFCSTATUS phFriNfc_MfStd_H_ProErrAuth(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt);
-static NFCSTATUS phFriNfc_MfStd_H_ErrWrSectTr(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt);
-static NFCSTATUS phFriNfc_MfStd_H_ErrRdSectTr(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt);
-static NFCSTATUS phFriNfc_MfStd_H_ProUpdMADBlk(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt);
-static void phFriNfc_MfStd_H_StrNdefData(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt);
-static void phFriNfc_MfStd_H_BlkNoToWrTLV(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt);
-static int phFriNfc_MfStd_MemCompare(void *s1, void *s2, unsigned int n );
-
-/*
- * Enum definition contains format states
- */
-typedef enum Mfc_format_state{
-    MFC_FORMAT_INIT = 0x00,
-    MFC_FORMAT_NFC_KEY,
-    MFC_FORMAT_DEF_KEY,
-    MFC_FORMAT_INVALID
-}MFC_FORMAT_STATE;
-
-/* format key status */
-static MFC_FORMAT_STATE  FormatKeyState = MFC_FORMAT_INIT;
-
-/*******************************************************************************
-**
-** Function         phFriNfc_MfStd_Reset
-**
-** Description      Resets the component instance to the initial state and initializes the
-**                  internal variables.
-**
-** Returns          none
-**
-*******************************************************************************/
-void phFriNfc_MfStd_Reset(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt)
-{
-    uint8_t NfcForSectArray[] = PH_FRINFC_SMTCRDFMT_NFCFORUMSECT_KEYA_ACS_BIT,
-    MADSectArray[] = PH_FRINFC_SMTCRDFMT_MSTD_MADSECT_KEYA_ACS_BIT_1K;
-
-    /* Authentication state */
-    NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState = PH_FRINFC_MFSTD_FMT_VAL_1;
-
-    /* Set default key for A or B */
-    memset(NdefSmtCrdFmt->AddInfo.MfStdInfo.Default_KeyA_OR_B,
-                PH_FRINFC_MFSTD_FMT_DEFAULT_KEY, /* 0xFF */
-                PH_FRINFC_MFSTD_FMT_VAL_6);
-
-    /* MAD sector key A */
-    memcpy(NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSect_KeyA,
-                MADSectArray, /*PH_FRINFC_MFSTD_FMT_VAL_0, */
-                PH_FRINFC_MFSTD_FMT_VAL_6);
-
-    /* Copy access bits for MAD sectors */
-    memcpy(NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSect_AccessBits,
-                &MADSectArray[PH_FRINFC_MFSTD_FMT_VAL_6],
-                PH_FRINFC_MFSTD_FMT_VAL_3);
-
-    /* NFC forum sector key A */
-    (void)memcpy(NdefSmtCrdFmt->AddInfo.MfStdInfo.NFCForumSect_KeyA,
-                NfcForSectArray, /*PH_FRINFC_MFSTD_FMT_VAL_0, */
-                PH_FRINFC_MFSTD_FMT_VAL_6);
-
-    /* Copy access bits for NFC forum sectors */
-    (void)memcpy(NdefSmtCrdFmt->AddInfo.MfStdInfo.NFCForumSect_AccessBits,
-                &NfcForSectArray[PH_FRINFC_MFSTD_FMT_VAL_6],
-                PH_FRINFC_MFSTD_FMT_VAL_3);
-
-    /* Sector compliant array initialised to 0 */
-    memset(NdefSmtCrdFmt->AddInfo.MfStdInfo.SectCompl,
-                PH_FRINFC_MFSTD_FMT_VAL_0, /* 0x00 */
-                PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_4K);
-
-    NdefSmtCrdFmt->AddInfo.MfStdInfo.WrMADBlkFlag = (uint8_t)PH_FRINFC_MFSTD_FMT_VAL_0;
-    NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk = (uint8_t)PH_FRINFC_MFSTD_FMT_NOT_A_MAD_BLK;
-
-    return;
-}
-
-/*******************************************************************************
-**
-** Function         phFriNfc_MfStd_Format
-**
-** Description      The function initiates and formats the Smart Card.After this formation, remote
-**                  card would be properly initialized and Ndef Compliant.
-**
-** Returns          NFCSTATUS_PENDING if successful
-**                  Other values if an error has occurred
-**
-*******************************************************************************/
-NFCSTATUS phFriNfc_MfStd_Format( phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt, const uint8_t *ScrtKeyB )
-{
-    NFCSTATUS    Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_SMTCRDFMT,
-                                                NFCSTATUS_INVALID_PARAMETER);
-    uint8_t      index = PH_FRINFC_MFSTD_FMT_VAL_0;
-
-    if(ScrtKeyB != NULL)
-    {
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk =
-            PH_FRINFC_MFSTD_FMT_NOT_A_MAD_BLK;
-        /* Store Key B in the context */
-        while(index < PH_FRINFC_MFSTD_FMT_VAL_6)
-        {
-            NdefSmtCrdFmt->AddInfo.MfStdInfo.ScrtKeyB[index] = ScrtKeyB[index];
-            index++;
-        }
-        /* Set the state */
-        NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_AUTH_SECT;
-        /* Initialize current block to the first sector trailer */
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock = PH_FRINFC_MFSTD_FMT_VAL_3;
-        /* Set the authenticate state */
-        if( MFC_FORMAT_DEF_KEY == FormatKeyState)
-        {
-            FormatKeyState = MFC_FORMAT_INIT;
-            NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState = PH_FRINFC_MFSTD_FMT_AUTH_DEF_KEY;
-        }
-        else
-        {
-            FormatKeyState = MFC_FORMAT_NFC_KEY;
-            NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState = PH_FRINFC_MFSTD_FMT_AUTH_NFC_KEY; /* Key Chnage for some cards */
-        }
-        /* Start authentication */
-        Result = phFriNfc_MfStd_H_WrRdAuth(NdefSmtCrdFmt);
-    }
-    return Result;
-}
-
-/*******************************************************************************
-**
-** Function         phFriNfc_MfStd_Process
-**
-** Description      Completion Routine: This function is called by the lower layer (OVR HAL)
-**                  when an I/O operation has finished. The internal state machine decides
-**                  whether to call into the lower device again or to complete the process
-**                  by calling into the upper layer's completion routine, stored within this
-**                  component's context (phFriNfc_sNdefSmtCrdFmt_t).
-**
-** Returns          none
-**
-*******************************************************************************/
-void phFriNfc_MfStd_Process(void *Context, NFCSTATUS Status)
-{
-    phFriNfc_sNdefSmtCrdFmt_t  *NdefSmtCrdFmt = (phFriNfc_sNdefSmtCrdFmt_t *)Context;
-    /* Copy the formatting status */
-    NdefSmtCrdFmt->FmtProcStatus = Status;
-
-    if(Status == NFCSTATUS_SUCCESS)
-    {
-        switch(NdefSmtCrdFmt->State)
-        {
-        case PH_FRINFC_MFSTD_FMT_AUTH_SECT:
-            Status = phFriNfc_MfStd_H_ProAuth(NdefSmtCrdFmt);
-            break;
-
-        case PH_FRINFC_MFSTD_FMT_DIS_CON:
-            Status = phFriNfc_MfStd_H_CallCon(NdefSmtCrdFmt);
-            break;
-
-        case PH_FRINFC_MFSTD_FMT_CON:
-            if( MFC_FORMAT_DEF_KEY == FormatKeyState)
-            {
-                /* retry the format with other key */
-                Mfc_FormatNdef(current_key,6);
-                return;
-            }
-            Status = phFriNfc_MfStd_H_ProCon(NdefSmtCrdFmt);
-            break;
-
-        case PH_FRINFC_MFSTD_FMT_RD_SECT_TR:
-            Status = phFriNfc_MfStd_H_ProRdSectTr(NdefSmtCrdFmt);
-            break;
-
-        case PH_FRINFC_MFSTD_FMT_WR_SECT_TR:
-            Status = phFriNfc_MfStd_H_ProWrSectTr(NdefSmtCrdFmt);
-            break;
-
-        case PH_FRINFC_MFSTD_FMT_WR_MAD_BLK:
-            Status = phFriNfc_MfStd_H_ProWrMADBlk(NdefSmtCrdFmt);
-            break;
-
-        case PH_FRINFC_MFSTD_FMT_WR_TLV:
-            break;
-
-        case PH_FRINFC_MFSTD_FMT_UPD_MAD_BLK:
-            Status = phFriNfc_MfStd_H_ProUpdMADBlk(NdefSmtCrdFmt);
-            break;
-
-        default:
-            Status = PHNFCSTVAL(CID_FRI_NFC_NDEF_SMTCRDFMT,
-                                NFCSTATUS_INVALID_DEVICE_REQUEST);
-            break;
-        }
-    }
-    else
-    {
-        switch(NdefSmtCrdFmt->State)
-        {
-        case PH_FRINFC_MFSTD_FMT_AUTH_SECT:
-            if(MFC_FORMAT_NFC_KEY == FormatKeyState)
-            {
-                FormatKeyState = MFC_FORMAT_DEF_KEY;
-            }
-            Status = phFriNfc_MfStd_H_ProErrAuth(NdefSmtCrdFmt);
-            break;
-
-        case PH_FRINFC_MFSTD_FMT_WR_SECT_TR:
-            Status = phFriNfc_MfStd_H_ErrWrSectTr(NdefSmtCrdFmt);
-            break;
-
-        case PH_FRINFC_MFSTD_FMT_RD_SECT_TR:
-            Status = phFriNfc_MfStd_H_ErrRdSectTr(NdefSmtCrdFmt);
-            break;
-
-        default:
-            Status = NdefSmtCrdFmt->FmtProcStatus;
-            break;
-        }
-    }
-
-    /* Status is not success then call completion routine */
-    if(Status != NFCSTATUS_PENDING)
-    {
-        phFriNfc_SmtCrdFmt_HCrHandler(NdefSmtCrdFmt, Status);
-    }
-
-    return;
-}
-
-/*******************************************************************************
-**
-** Function         phFriNfc_MfStd_H_FillSendBuf
-**
-** Description      This function fills the send buffer for transceive function
-**
-** Returns          none
-**
-*******************************************************************************/
-static void phFriNfc_MfStd_H_FillSendBuf(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt, uint16_t BlockNo)
-{
-//    void        *mem = NULL;                                                    /*commented to eliminate unused variable warning*/
-    uint8_t     MADSectTr1k[] = PH_FRINFC_SMTCRDFMT_MSTD_MADSECT_KEYA_ACS_BIT_1K, /* MAD key A,
-                                                                            Access bits and GPB of MAD sector */
-                MADSectTr2k[] = PH_FRINFC_SMTCRDFMT_MSTD_MADSECT_KEYA_ACS_BIT_2K, /* MAD key A,
-                                                                            Access bits and GPB of MAD sector */
-                MADSectTr4k[] = PH_FRINFC_SMTCRDFMT_MSTD_MADSECT_KEYA_ACS_BIT_4K, /* MAD key A,
-                                                                                    Access bits and GPB of MAD sector */
-                NFCSectTr[] = PH_FRINFC_SMTCRDFMT_NFCFORUMSECT_KEYA_ACS_BIT, /* NFC forum key A,
-                                                                             Access bits and GPB of NFC sector */
-                NDEFMsgTLV[16] = {0x03, 0x00, 0xFE, 0x00, 0x00, 0x00, /* NDEF message TLV (INITIALISED state) */
-                                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-                                  0x00, 0x00, 0x00, 0x00},
-                MADBlk[16] = {0x0F, 0x00, 0x03, 0xE1, 0x03, 0xE1,
-                              0x03, 0xE1, 0x03, 0xE1,
-                              0x03, 0xE1, 0x03, 0xE1, 0x03, 0xE1};
-    /* Block number in send buffer */
-    NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_0] = (uint8_t)BlockNo;
-    /* Initialize send receive length */
-    *NdefSmtCrdFmt->SendRecvLength = PH_FRINFC_MFSTD_FMT_MAX_RECV_LENGTH;
-
-    /* Depending on the different state, fill the send buffer */
-    switch(NdefSmtCrdFmt->State)
-    {
-        case PH_FRINFC_MFSTD_FMT_AUTH_SECT:
-            /* Depending on the authentication state, fill the send buffer */
-            switch(NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState)
-            {
-                case PH_FRINFC_MFSTD_FMT_AUTH_DEF_KEY:
-                case PH_FRINFC_MFSTD_FMT_AUTH_KEYB:
-                    /* Fill send buffer with the default key */
-                    PH_FRINFC_MFSTD_FMT_AUTH_SEND_BUF_DEF(mem);
-                break;
-
-                case PH_FRINFC_MFSTD_FMT_AUTH_NFC_KEY:
-                    /* Fill send buffer with NFC forum sector key */
-                    PH_FRINFC_MFSTD_FMT_AUTH_SEND_BUF_NFCSECT_KEYA(mem);
-                break;
-
-                case PH_FRINFC_MFSTD_FMT_AUTH_SCRT_KEYB:
-                    /* Fill send buffer with NFC forum sector key */
-                    PH_FRINFC_MFSTD_FMT_AUTH_SEND_BUF_SCRT_KEY(mem);
-                    break;
-
-                case PH_FRINFC_MFSTD_FMT_AUTH_MAD_KEY:
-                default:
-                    /* Fill send buffer with MAD sector key */
-                    PH_FRINFC_MFSTD_FMT_AUTH_SEND_BUF_MADSECT_KEYA(mem);
-                break;
-            }
-        break;
-
-        case PH_FRINFC_MFSTD_FMT_RD_SECT_TR:
-            NdefSmtCrdFmt->Cmd.MfCmd = phHal_eMifareRead;
-
-            /* Send length is always one for read operation */
-            NdefSmtCrdFmt->SendLength = PH_FRINFC_MFSTD_FMT_VAL_1;
-        break;
-
-        case PH_FRINFC_MFSTD_FMT_WR_SECT_TR:
-            /* Fill send buffer for writing sector trailer */
-            NdefSmtCrdFmt->Cmd.MfCmd = phHal_eMifareWrite16;
-            /* Copy the relevant sector trailer value in the buffer */
-            switch(NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock)
-            {
-            case PH_FRINFC_MFSTD_FMT_VAL_3:
-                if (NdefSmtCrdFmt->CardType == PH_FRINFC_SMTCRDFMT_MFSTD_1K_CRD)
-                {
-                    memcpy(&NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1],
-                                MADSectTr1k,
-                                sizeof(MADSectTr1k));
-                }
-                else if (NdefSmtCrdFmt->CardType == PH_FRINFC_SMTCRDFMT_MFSTD_2K_CRD)
-                {
-                    memcpy(&NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1],
-                                 MADSectTr2k,
-                                 sizeof(MADSectTr2k));
-                }
-                else
-                {
-                    memcpy(&NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1],
-                                MADSectTr4k,
-                                sizeof(MADSectTr4k));
-                }
-                break;
-            case 67:
-                (void)memcpy(&NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1],
-                            MADSectTr4k,
-                            sizeof(MADSectTr4k));
-                break;
-            default:
-                (void)memcpy(&NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1],
-                            NFCSectTr,
-                            sizeof(NFCSectTr));
-                break;
-            }
-            memcpy(&NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_11],
-                NdefSmtCrdFmt->AddInfo.MfStdInfo.ScrtKeyB,
-                sizeof(NdefSmtCrdFmt->AddInfo.MfStdInfo.ScrtKeyB));
-
-            /* Send length is always 17 for write operation */
-            NdefSmtCrdFmt->SendLength = PH_FRINFC_MFSTD_FMT_WR_SEND_LENGTH;
-        break;
-
-        case PH_FRINFC_MFSTD_FMT_WR_TLV:
-            /* Fill send buffer for writing TLV */
-            NdefSmtCrdFmt->Cmd.MfCmd = phHal_eMifareWrite16;
-            /* Copy the NDEF message TLV */
-            memcpy(&NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1],
-                        NDEFMsgTLV, sizeof(NDEFMsgTLV));
-            /* Send length is always 17 for write operation */
-            NdefSmtCrdFmt->SendLength = PH_FRINFC_MFSTD_FMT_WR_SEND_LENGTH;
-        break;
-
-        case PH_FRINFC_MFSTD_FMT_WR_MAD_BLK:
-            /* Fill send buffer for writing MAD block */
-            NdefSmtCrdFmt->Cmd.MfCmd = phHal_eMifareWrite16;
-            if((BlockNo == PH_FRINFC_MFSTD_FMT_VAL_2) ||
-                (BlockNo == 65) || (BlockNo == 66))
-            {
-                /* MAD block number 2, 65 and 66 has 0x03, 0xE1 in the
-                 * first two bytes
-                 */
-                MADBlk[PH_FRINFC_MFSTD_FMT_VAL_0] = 0x03;
-                MADBlk[PH_FRINFC_MFSTD_FMT_VAL_1] = 0xE1;
-            }
-            /* Copy the MAD Block values */
-            memcpy(&NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1],
-                            MADBlk, sizeof(MADBlk));
-            /* Send length is always 17 for write operation */
-            NdefSmtCrdFmt->SendLength = PH_FRINFC_MFSTD_FMT_WR_SEND_LENGTH;
-        break;
-
-        case PH_FRINFC_MFSTD_FMT_UPD_MAD_BLK:
-        default:
-            /* Fill send buffer for writing MAD block */
-            NdefSmtCrdFmt->Cmd.MfCmd = phHal_eMifareWrite16;
-            NdefSmtCrdFmt->SendLength = PH_FRINFC_MFSTD_FMT_WR_SEND_LENGTH;
-            switch(NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk)
-            {
-            case PH_FRINFC_MFSTD_FMT_MAD_BLK_1:
-                memcpy(&NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1],
-                            NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSectBlk,
-                            (PH_FRINFC_MFSTD_FMT_WR_SEND_LENGTH - PH_FRINFC_MFSTD_FMT_VAL_1));
-                break;
-
-            case PH_FRINFC_MFSTD_FMT_MAD_BLK_2:
-                memcpy(&NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1],
-                    &NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSectBlk[16],
-                    (PH_FRINFC_MFSTD_FMT_WR_SEND_LENGTH - PH_FRINFC_MFSTD_FMT_VAL_1));
-                break;
-
-            case PH_FRINFC_MFSTD_FMT_MAD_BLK_64:
-                memcpy(&NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1],
-                    &NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSectBlk[32],
-                    (PH_FRINFC_MFSTD_FMT_WR_SEND_LENGTH - PH_FRINFC_MFSTD_FMT_VAL_1));
-                break;
-
-            case PH_FRINFC_MFSTD_FMT_MAD_BLK_65:
-                memcpy(&NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1],
-                    &NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSectBlk[48],
-                    (PH_FRINFC_MFSTD_FMT_WR_SEND_LENGTH - PH_FRINFC_MFSTD_FMT_VAL_1));
-                break;
-
-            case PH_FRINFC_MFSTD_FMT_MAD_BLK_66:
-            default:
-                memcpy(&NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1],
-                    &NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSectBlk[64],
-                    (PH_FRINFC_MFSTD_FMT_WR_SEND_LENGTH - PH_FRINFC_MFSTD_FMT_VAL_1));
-                break;
-            }
-            break;
-    }
-
-    return;
-}
-
-/*******************************************************************************
-**
-** Function         phFriNfc_MfStd_H_Transceive
-**
-** Description      This function authenticates a block or a sector from the card.
-**
-** Returns          NFCSTATUS_PENDING if successful
-**                  Other values if an error has occurred
-**
-*******************************************************************************/
-static NFCSTATUS phFriNfc_MfStd_H_Transceive(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-
-    /*set the completion routines for the card operations*/
-    NdefSmtCrdFmt->SmtCrdFmtCompletionInfo.CompletionRoutine = phFriNfc_NdefSmtCrd_Process;
-    NdefSmtCrdFmt->SmtCrdFmtCompletionInfo.Context = NdefSmtCrdFmt;
-
-    *NdefSmtCrdFmt->SendRecvLength = PH_FRINFC_SMTCRDFMT_MAX_SEND_RECV_BUF_SIZE;
-
-    /* Call the Overlapped HAL Transceive function */
-    Result = phFriNfc_ExtnsTransceive(NdefSmtCrdFmt->pTransceiveInfo,
-                          NdefSmtCrdFmt->Cmd,
-                          NdefSmtCrdFmt->SendRecvBuf,
-                          NdefSmtCrdFmt->SendLength,
-                          NdefSmtCrdFmt->SendRecvLength);
-    return Result;
-}
-
-/*******************************************************************************
-**
-** Function         phFriNfc_MfStd_H_CallDisCon
-**
-** Description      This function calls disconnect.
-**
-** Returns          NFCSTATUS_PENDING if successful
-**                  Other values if an error has occurred
-**
-*******************************************************************************/
-static NFCSTATUS phFriNfc_MfStd_H_CallDisCon(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt, NFCSTATUS Status)
-{
-    NFCSTATUS   Result = Status;
-
-    /*Set Ndef State*/
-    NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_DIS_CON;
-
-    Result = phNxNciExtns_MifareStd_Reconnect();
-    return Result;
-}
-
-/*******************************************************************************
-**
-** Function         phFriNfc_MfStd_H_CallCon
-**
-** Description      This function calls reconnect.
-**
-** Returns          NFCSTATUS_PENDING if successful
-**                  Other values if an error has occurred
-**
-*******************************************************************************/
-static NFCSTATUS phFriNfc_MfStd_H_CallCon(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-    /*Set Ndef State*/
-    NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_CON;
-
-    Result = phNxNciExtns_MifareStd_Reconnect();
-    return Result;
-}
-
-/*******************************************************************************
-**
-** Function         phFriNfc_MfStd_H_ProCon
-**
-** Description      This function shall process the poll call.
-**
-** Returns          NFCSTATUS_PENDING if successful
-**                  Other values if an error has occurred
-**
-*******************************************************************************/
-static NFCSTATUS phFriNfc_MfStd_H_ProCon(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-    uint8_t     Buffer[1] = {PH_FRINFC_MFSTD_FMT_NDEF_COMPL};
-    uint8_t     index = PH_FRINFC_MFSTD_FMT_VAL_1;
-    uint32_t    memcompare = PH_FRINFC_MFSTD_FMT_VAL_1;
-
-    phFriNfc_MfStd_H_ChangeAuthSt(NdefSmtCrdFmt);
-    if(PH_FRINFC_MFSTD_FMT_CUR_BLK_CHK)
-    {
-        PH_FRINFC_MFSTD_FMT_CHK_END_OF_CARD();
-    }
-    else
-    {
-        /* Set the state */
-        NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_AUTH_SECT;
-        /* Start authentication */
-        Result = phFriNfc_MfStd_H_WrRdAuth(NdefSmtCrdFmt);
-    }
-    return Result;
-}
-
-/*******************************************************************************
-**
-** Function         phFriNfc_MfStd_H_ProAuth
-**
-** Description      This function shall process the authenticate call.
-**
-** Returns          NFCSTATUS_PENDING if successful
-**                  Other values if an error has occurred
-**
-*******************************************************************************/
-static NFCSTATUS phFriNfc_MfStd_H_ProAuth(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-
-    /* Depending on the authentication key check the  */
-    switch(NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState)
-    {
-        case PH_FRINFC_MFSTD_FMT_AUTH_DEF_KEY:
-            if((NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock ==
-                PH_FRINFC_MFSTD_FMT_VAL_3) &&
-                (NdefSmtCrdFmt->AddInfo.MfStdInfo.WrMADBlkFlag ==
-                PH_FRINFC_MFSTD_FMT_VAL_0))
-            {
-                /* Authenticate with default key for block 3 is successful,
-                 * so fill the MAD block of sector 0
-                 */
-                NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock =
-                                    PH_FRINFC_MFSTD_FMT_VAL_1;
-                /* Write the MAD block */
-                NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_WR_MAD_BLK;
-            }
-            else if((NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock == 67)
-                && (NdefSmtCrdFmt->AddInfo.MfStdInfo.WrMADBlkFlag ==
-                PH_FRINFC_MFSTD_FMT_VAL_0))
-            {
-                /* Authenticate with default key for block 3 is successful,
-                 * so fill the MAD block of sector 64
-                 */
-                NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock = 64;
-                /* Write the MAD block */
-                NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_WR_MAD_BLK;
-            }
-            else
-            {
-                /* Not a MAD sector */
-                NdefSmtCrdFmt->AddInfo.MfStdInfo.WrMADBlkFlag =
-                                        PH_FRINFC_MFSTD_FMT_VAL_0;
-                /* Write the MAD block */
-                NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_WR_SECT_TR;
-            }
-        break;
-
-        case PH_FRINFC_MFSTD_FMT_AUTH_KEYB:
-            if((NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk ==
-                PH_FRINFC_MFSTD_FMT_MAD_BLK_1) ||
-                (NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk ==
-                PH_FRINFC_MFSTD_FMT_MAD_BLK_2) ||
-                (NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk ==
-                PH_FRINFC_MFSTD_FMT_MAD_BLK_64) ||
-                (NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk ==
-                PH_FRINFC_MFSTD_FMT_MAD_BLK_65) ||
-                (NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk ==
-                PH_FRINFC_MFSTD_FMT_MAD_BLK_66))
-            {
-                NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock =
-                            NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk;
-                NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_UPD_MAD_BLK;
-            }
-            else
-            {
-                NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk =
-                                PH_FRINFC_MFSTD_FMT_NOT_A_MAD_BLK;
-                NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_WR_SECT_TR;
-            }
-
-        break;
-
-        case PH_FRINFC_MFSTD_FMT_AUTH_SCRT_KEYB:
-            if((NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk ==
-                PH_FRINFC_MFSTD_FMT_MAD_BLK_1) ||
-                (NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk ==
-                PH_FRINFC_MFSTD_FMT_MAD_BLK_2) ||
-                (NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk ==
-                PH_FRINFC_MFSTD_FMT_MAD_BLK_64) ||
-                (NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk ==
-                PH_FRINFC_MFSTD_FMT_MAD_BLK_65) ||
-                (NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk ==
-                PH_FRINFC_MFSTD_FMT_MAD_BLK_66))
-            {
-                NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock =
-                    NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk;
-                NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_UPD_MAD_BLK;
-            }
-            else
-            {
-                NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk =
-                    PH_FRINFC_MFSTD_FMT_NOT_A_MAD_BLK;
-                NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_WR_SECT_TR;
-            }
-            break;
-
-        case PH_FRINFC_MFSTD_FMT_AUTH_NFC_KEY:
-        case PH_FRINFC_MFSTD_FMT_AUTH_MAD_KEY:
-        default:
-            if((NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk ==
-                PH_FRINFC_MFSTD_FMT_MAD_BLK_66) ||
-                (NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk ==
-                PH_FRINFC_MFSTD_FMT_MAD_BLK_2))
-            {
-                /* Updating the MAD block is complete */
-                NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk =
-                                PH_FRINFC_MFSTD_FMT_NOT_A_MAD_BLK;
-                /* If Mifare 4k card, write the TLV */
-                NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_WR_TLV;
-            }
-            else
-            {
-                /* Depending on the sector trailer, check the access bit */
-                NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_RD_SECT_TR;
-            }
-        break;
-    }
-    /* Call read, write or authenticate */
-    Result = phFriNfc_MfStd_H_WrRdAuth(NdefSmtCrdFmt);
-    return Result;
-}
-
-/*******************************************************************************
-**
-** Function         phFriNfc_MfStd_H_ErrWrSectTr
-**
-** Description      This function shall process the error status of the writing sector trailer.
-**
-** Returns          NFCSTATUS_PENDING if successful
-**                  Other values if an error has occurred
-**
-*******************************************************************************/
-static NFCSTATUS phFriNfc_MfStd_H_ErrWrSectTr(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt )
-{
-    NFCSTATUS   Result = NdefSmtCrdFmt->FmtProcStatus;
-    /* If default key A is used for authentication and if write fails, then try to
-     * authenticate using key B
-     */
-    if(NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState ==
-        PH_FRINFC_MFSTD_FMT_AUTH_DEF_KEY)
-    {
-        /* Change the state to authentication */
-        NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_AUTH_SECT;
-        /* internal authenticate state = key B */
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState = PH_FRINFC_MFSTD_FMT_AUTH_KEYB;
-        /* Now call authenticate */
-        Result = phFriNfc_MfStd_H_WrRdAuth(NdefSmtCrdFmt);
-    }
-    else
-    {
-        Result = phFriNfc_MfStd_H_ProWrSectTr(NdefSmtCrdFmt);
-    }
-    return Result;
-}
-
-/*******************************************************************************
-**
-** Function         phFriNfc_MfStd_H_ProRdSectTr
-**
-** Description      This function shall process the read access bit call.
-**
-** Returns          NFCSTATUS_PENDING if successful
-**                  Other values if an error has occurred
-**
-*******************************************************************************/
-static NFCSTATUS phFriNfc_MfStd_H_ProRdSectTr(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-    uint8_t     Buffer[1] = {PH_FRINFC_MFSTD_FMT_NDEF_COMPL},
-                index = PH_FRINFC_MFSTD_FMT_VAL_1,
-                SectIndex = PH_FRINFC_MFSTD_FMT_VAL_0;
-    uint32_t    memcompare = PH_FRINFC_MFSTD_FMT_VAL_1;
-
-    /* Calculate sector index */
-    SectIndex = (uint8_t)PH_FRINFC_MFSTD_FMT_SECT_INDEX_CALC;
-
-    /* Depending on the sector trailer, check the access bit */
-    memcompare = phFriNfc_MfStd_H_ChkAcsBit(NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock,
-                                            NdefSmtCrdFmt->SendRecvBuf,
-                                            NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSect_AccessBits,
-                                            NdefSmtCrdFmt->AddInfo.MfStdInfo.NFCForumSect_AccessBits);
-
-    /* Check the sector for ndef compliance */
-    NdefSmtCrdFmt->AddInfo.MfStdInfo.SectCompl[SectIndex] = (uint8_t)
-                ((memcompare != PH_FRINFC_MFSTD_FMT_VAL_0)?
-                PH_FRINFC_MFSTD_FMT_NON_NDEF_COMPL:
-                PH_FRINFC_MFSTD_FMT_NDEF_COMPL);
-
-    /* Increment the current block */
-    PH_FRINFC_MFSTD_FMT_CUR_BLK_INC();
-    SectIndex++;
-    if(PH_FRINFC_MFSTD_FMT_CUR_BLK_CHK)
-    {
-       PH_FRINFC_MFSTD_FMT_CHK_END_OF_CARD();
-    }
-    else
-    {
-        /* Set the state */
-        NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_AUTH_SECT;
-        /* Set the authenticate state */
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState =
-                            PH_FRINFC_MFSTD_FMT_AUTH_DEF_KEY;
-        /* Start authentication */
-        Result = phFriNfc_MfStd_H_WrRdAuth(NdefSmtCrdFmt);
-    }
-    return Result;
-}
-
-/*******************************************************************************
-**
-** Function         phFriNfc_MfStd_H_ProWrSectTr
-**
-** Description      This function shall process the write access bit call.
-**
-** Returns          NFCSTATUS_PENDING if successful
-**                  Other values if an error has occurred
-**
-*******************************************************************************/
-static NFCSTATUS phFriNfc_MfStd_H_ProWrSectTr(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-    uint8_t     Buffer[1] = {PH_FRINFC_MFSTD_FMT_NDEF_COMPL},
-                index = PH_FRINFC_MFSTD_FMT_VAL_1,
-                SectIndex = PH_FRINFC_MFSTD_FMT_VAL_0;
-    uint32_t    memcompare = PH_FRINFC_MFSTD_FMT_VAL_1;
-
-    /* Calculate sector index */
-    SectIndex = (uint8_t)PH_FRINFC_MFSTD_FMT_SECT_INDEX_CALC;
-
-    /* Sector is ndef compliance */
-    NdefSmtCrdFmt->AddInfo.MfStdInfo.SectCompl[SectIndex] = (uint8_t)
-                    ((NdefSmtCrdFmt->FmtProcStatus != NFCSTATUS_SUCCESS)?
-                        PH_FRINFC_MFSTD_FMT_NON_NDEF_COMPL:
-                        PH_FRINFC_MFSTD_FMT_NDEF_COMPL);
-
-    /* Increment the current block */
-    PH_FRINFC_MFSTD_FMT_CUR_BLK_INC();
-    SectIndex++;
-    if(PH_FRINFC_MFSTD_FMT_CUR_BLK_CHK)
-    {
-        PH_FRINFC_MFSTD_FMT_CHK_END_OF_CARD();
-    }
-    else
-    {
-        /* Set the state */
-        NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_AUTH_SECT;
-        /* Set the authenticate state */
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState =
-                            PH_FRINFC_MFSTD_FMT_AUTH_DEF_KEY;
-        /* Start authentication */
-        Result = phFriNfc_MfStd_H_WrRdAuth(NdefSmtCrdFmt);
-    }
-    return Result;
-}
-
-/*******************************************************************************
-**
-** Function         phFriNfc_MfStd_H_ChkAcsBit
-**
-** Description      This function checks access bits of each sector trailer.
-**
-** Returns          compare value
-**
-*******************************************************************************/
-static uint32_t phFriNfc_MfStd_H_ChkAcsBit(uint16_t                 BlockNo,
-                                           const uint8_t            *RecvBuf,
-                                           const uint8_t            AcsBits1[],
-                                           const uint8_t            AcsBits2[])
-{
-    uint32_t    mem = PH_FRINFC_MFSTD_FMT_VAL_0;
-
-    /* Compare the access bits read from the sector trailer */
-    mem = (uint32_t)(((BlockNo == PH_FRINFC_MFSTD_FMT_VAL_3) ||
-                    (BlockNo == 67))?
-                    phFriNfc_MfStd_MemCompare((void*)&RecvBuf[PH_FRINFC_MFSTD_FMT_VAL_6],
-                            (void*)AcsBits1,
-                            PH_FRINFC_MFSTD_FMT_VAL_3):
-                    phFriNfc_MfStd_MemCompare((void*)&RecvBuf[PH_FRINFC_MFSTD_FMT_VAL_6],
-                            (void*)AcsBits2,
-                            PH_FRINFC_MFSTD_FMT_VAL_3));
-
-    return mem;
-}
-
-/*******************************************************************************
-**
-** Function         phFriNfc_MfStd_H_WrRdAuth
-**
-** Description      This function writes sector trailer using the block number.
-**
-** Returns          NFCSTATUS_PENDING if successful
-**                  Other values if an error has occurred
-**
-*******************************************************************************/
-static NFCSTATUS phFriNfc_MfStd_H_WrRdAuth(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-    /* Fill send buffer and send length */
-    phFriNfc_MfStd_H_FillSendBuf(NdefSmtCrdFmt,
-                                 NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock);
-    /* Call ovrhal transceive */
-    Result = phFriNfc_MfStd_H_Transceive(NdefSmtCrdFmt);
-
-    return Result;
-}
-
-/*******************************************************************************
-**
-** Function         phFriNfc_MfStd_H_ChangeAuthSt
-**
-** Description      This function changes authentication state and change the block number if required.
-**
-** Returns          none
-**
-*******************************************************************************/
-static void phFriNfc_MfStd_H_ChangeAuthSt(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt)
-{
-    uint8_t     SectIndex = PH_FRINFC_MFSTD_FMT_VAL_0;
-
-    if( NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState ==
-        PH_FRINFC_MFSTD_FMT_AUTH_SCRT_KEYB)
-    {
-        /* Calculate sector index */
-        SectIndex = (uint8_t)PH_FRINFC_MFSTD_FMT_SECT_INDEX_CALC;
-
-        /* Check the sector for ndef compliance */
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.SectCompl[SectIndex] =
-                    PH_FRINFC_MFSTD_FMT_NON_NDEF_COMPL;
-
-        PH_FRINFC_MFSTD_FMT_CUR_BLK_INC();
-    }
-    PH_FRINFC_MFSTD_FMT_NXT_AUTH_STATE();
-
-    return;
-}
-
-/*******************************************************************************
-**
-** Function         phFriNfc_MfStd_H_NdefComplSect
-**
-** Description      This function finds contiguous ndef compliant blocks.
-**
-** Returns          none
-**
-*******************************************************************************/
- static void phFriNfc_MfStd_H_NdefComplSect(uint8_t CardTypes, uint8_t Sector[])
-{
-    uint8_t     count = PH_FRINFC_MFSTD_FMT_VAL_0,
-                NdefComplSectMax = PH_FRINFC_MFSTD_FMT_VAL_0,
-                NdefComplSectTemp = PH_FRINFC_MFSTD_FMT_VAL_1,
-                SectIndex = PH_FRINFC_MFSTD_FMT_VAL_0,
-                MaxCont = PH_FRINFC_MFSTD_FMT_VAL_0,
-                MaxSect = PH_FRINFC_MFSTD_FMT_VAL_0;
-
-    /* Get the maximum sector depending on the sector */
-    MaxSect = ((CardTypes == PH_FRINFC_SMTCRDFMT_MFSTD_1K_CRD)?
-                PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_1K:
-                ((CardTypes == PH_FRINFC_SMTCRDFMT_MFSTD_2K_CRD)?
-                  PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_2K:
-                  PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_4K));
-    /* Sector index */
-    NdefComplSectTemp = SectIndex = PH_FRINFC_MFSTD_FMT_VAL_1;
-    /* Check the sector index depending on the card type */
-    while(((SectIndex < PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_4K) &&
-        (CardTypes == PH_FRINFC_SMTCRDFMT_MFSTD_4K_CRD)) ||
-        ((SectIndex < PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_1K) &&
-        (CardTypes == PH_FRINFC_SMTCRDFMT_MFSTD_1K_CRD))||
-        ((SectIndex < PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_2K) &&
-        (CardTypes == PH_FRINFC_SMTCRDFMT_MFSTD_2K_CRD)))
-    {
-        if (Sector[SectIndex] ==
-            PH_FRINFC_MFSTD_FMT_NON_NDEF_COMPL)
-        {
-            if (MaxCont > count)
-            {
-                /* Store the maximum contiguous */
-                NdefComplSectMax = NdefComplSectTemp;
-                count = MaxCont;
-            }
-            MaxCont = PH_FRINFC_MFSTD_FMT_VAL_0;
-            /* Increment the sector index */
-            PH_FRINFC_MFSTD_FMT_INCR_SECT;
-            /* Get the next compliant sector */
-            NdefComplSectTemp = SectIndex;
-        }
-        else
-        {
-            /* Increment the sector index */
-            PH_FRINFC_MFSTD_FMT_INCR_SECT;
-        }
-        MaxCont ++;
-
-    }
-    if (MaxCont > count)
-    {
-        /* Store the maximum contiguous */
-        NdefComplSectMax = NdefComplSectTemp;
-        count = MaxCont;
-    }
-    /* Set the sector value has non ndef compliant which are not present with
-     * contiguous ndef compliant sectors
-     */
-    if((((count < (MaxSect - PH_FRINFC_MFSTD_FMT_VAL_1)) && (CardTypes
-        == PH_FRINFC_SMTCRDFMT_MFSTD_1K_CRD)) ||
-        ((count < (MaxSect - PH_FRINFC_MFSTD_FMT_VAL_2)) && (CardTypes
-        == PH_FRINFC_SMTCRDFMT_MFSTD_4K_CRD)) ||
-        ((count < (MaxSect - PH_FRINFC_MFSTD_FMT_VAL_2)) && (CardTypes
-        == PH_FRINFC_SMTCRDFMT_MFSTD_2K_CRD)))&&
-        ((NdefComplSectMax > PH_FRINFC_MFSTD_FMT_VAL_0) &&
-        (NdefComplSectMax < (MaxSect - PH_FRINFC_MFSTD_FMT_VAL_2))))
-    {
-        memset(&Sector[PH_FRINFC_MFSTD_FMT_VAL_1],
-            PH_FRINFC_MFSTD_FMT_NON_NDEF_COMPL,
-            (NdefComplSectMax - PH_FRINFC_MFSTD_FMT_VAL_1));
-
-
-        memset(&Sector[(NdefComplSectMax + count)],
-            PH_FRINFC_MFSTD_FMT_NON_NDEF_COMPL,
-            (MaxSect - (NdefComplSectMax + count)));
-    }
-
-    return;
-}
-
-/*******************************************************************************
-**
-** Function         phFriNfc_MfStd_H_ProWrMADBlk
-**
-** Description      This function writes the finds MAD block values.
-**
-** Returns          NFCSTATUS_PENDING if successful
-**                  Other values if an error has occurred
-**
-*******************************************************************************/
-static NFCSTATUS phFriNfc_MfStd_H_ProWrMADBlk(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-
-    switch(NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock)
-    {
-    case PH_FRINFC_MFSTD_FMT_VAL_1:
-        /* MAD blocks, still not completed */
-        NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_WR_MAD_BLK;
-        /* MAD block number 2 */
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock =
-                            PH_FRINFC_MFSTD_FMT_VAL_2;
-        break;
-
-    case PH_FRINFC_MFSTD_FMT_VAL_2:
-        /* Now write to MAD block is completed */
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.WrMADBlkFlag =
-                                        PH_FRINFC_MFSTD_FMT_VAL_1;
-        /* Now write the sector trailer, so change the state */
-        NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_WR_SECT_TR;
-        /* MAD block number 3 = Sector trailer */
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock =
-                            PH_FRINFC_MFSTD_FMT_VAL_3;
-        break;
-
-    case 64:
-        /* MAD blocks, still not completed */
-        NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_WR_MAD_BLK;
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock = 65;
-        break;
-
-    case 65:
-        /* MAD blocks, still not completed */
-        NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_WR_MAD_BLK;
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock = 66;
-        break;
-
-    case 66:
-    default:
-        /* Now write to MAD block is completed */
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.WrMADBlkFlag =
-                                        PH_FRINFC_MFSTD_FMT_VAL_1;
-        /* Now write the sector trailer, so change the state */
-        NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_WR_SECT_TR;
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock = 67;
-        break;
-
-    }
-    /* Write the block */
-    Result = phFriNfc_MfStd_H_WrRdAuth(NdefSmtCrdFmt);
-
-    return Result;
-}
-
-/*******************************************************************************
-**
-** Function         phFriNfc_MfStd_H_ProErrAuth
-**
-** Description      This function shall process the error status of the authentication.
-**
-** Returns          NFCSTATUS_PENDING if successful
-**                  Other values if an error has occurred
-**
-*******************************************************************************/
-static NFCSTATUS phFriNfc_MfStd_H_ProErrAuth(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt )
-{
-    NFCSTATUS   Result = NdefSmtCrdFmt->FmtProcStatus;
-    uint8_t     Buffer[1] = {PH_FRINFC_MFSTD_FMT_NDEF_COMPL},
-                index = PH_FRINFC_MFSTD_FMT_VAL_1;
-    uint32_t    memcompare = PH_FRINFC_MFSTD_FMT_VAL_1;
-
-    if ((NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock == 67) &&
-        (NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState ==
-                    PH_FRINFC_MFSTD_FMT_AUTH_SCRT_KEYB))
-    {
-        /* Error in the MAD sector 16, so the remaining sector
-         * information can't be updated
-         */
-        memset(&NdefSmtCrdFmt->AddInfo.MfStdInfo.SectCompl[16],
-                    PH_FRINFC_MFSTD_FMT_NON_NDEF_COMPL,
-                    (PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_4K - 16));
-        PH_FRINFC_MFSTD_FMT_CHK_END_OF_CARD();
-    }
-    else if(((NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock >
-        PH_FRINFC_MFSTD_FMT_VAL_3) &&
-        (NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState !=
-        PH_FRINFC_MFSTD_FMT_AUTH_SCRT_KEYB)) ||
-        ((NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock ==
-        PH_FRINFC_MFSTD_FMT_VAL_3) &&
-        (NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState <
-        PH_FRINFC_MFSTD_FMT_AUTH_SCRT_KEYB)))
-    {
-        /* Authenticate failed, so disconnect, poll and connect */
-        Result = phFriNfc_MfStd_H_CallDisCon(NdefSmtCrdFmt,
-                                             Result);
-    }
-    else
-    {
-        if (NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock ==
-            PH_FRINFC_MFSTD_FMT_VAL_3)
-        {
-            memset(NdefSmtCrdFmt->AddInfo.MfStdInfo.SectCompl,
-                        PH_FRINFC_MFSTD_FMT_NON_NDEF_COMPL,
-                        PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_4K);
-        }
-    }
-
-    return Result;
-}
-
-/*******************************************************************************
-**
-** Function         phFriNfc_MfStd_H_ProUpdMADBlk
-**
-** Description      This function shall process the error status of the writing sector trailer.
-**
-** Returns          NFCSTATUS_PENDING if successful
-**                  Other values if an error has occurred
-**
-*******************************************************************************/
-static NFCSTATUS phFriNfc_MfStd_H_ProUpdMADBlk(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-    switch(NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk)
-    {
-    case PH_FRINFC_MFSTD_FMT_MAD_BLK_1:
-        /* Write the next MAD Block */
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk = (uint8_t)
-                                PH_FRINFC_MFSTD_FMT_MAD_BLK_2;
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock =
-                                PH_FRINFC_MFSTD_FMT_MAD_BLK_2;
-        break;
-
-    case PH_FRINFC_MFSTD_FMT_MAD_BLK_2:
-    case PH_FRINFC_MFSTD_FMT_MAD_BLK_66:
-        if((NdefSmtCrdFmt->CardType == PH_FRINFC_SMTCRDFMT_MFSTD_1K_CRD) ||
-           (NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock ==
-           PH_FRINFC_MFSTD_FMT_MAD_BLK_66))
-        {
-            /* Get the block from where the TLV has to be written */
-            phFriNfc_MfStd_H_BlkNoToWrTLV(NdefSmtCrdFmt);
-
-            NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_AUTH_SECT;
-            NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState =
-                                    PH_FRINFC_MFSTD_FMT_AUTH_NFC_KEY;
-        }
-        else
-        {
-            /* Write the next MAD Block */
-            NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk = (uint8_t)
-                            PH_FRINFC_MFSTD_FMT_MAD_BLK_64;
-                NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock =
-                            PH_FRINFC_MFSTD_FMT_MAD_BLK_64;
-            NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_AUTH_SECT;
-            NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState =
-                                PH_FRINFC_MFSTD_FMT_AUTH_SCRT_KEYB;
-        }
-        break;
-
-    case PH_FRINFC_MFSTD_FMT_MAD_BLK_64:
-        /* Write the next MAD Block */
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk = (uint8_t)
-                                PH_FRINFC_MFSTD_FMT_MAD_BLK_65;
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock =
-                                PH_FRINFC_MFSTD_FMT_MAD_BLK_65;
-        break;
-
-    case PH_FRINFC_MFSTD_FMT_MAD_BLK_65:
-    default:
-        /* Write the next MAD Block */
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk = (uint8_t)
-                                    PH_FRINFC_MFSTD_FMT_MAD_BLK_66;
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock =
-                                    PH_FRINFC_MFSTD_FMT_MAD_BLK_66;
-        break;
-    }
-    Result = phFriNfc_MfStd_H_WrRdAuth(NdefSmtCrdFmt);
-    return Result;
-}
-
-/*******************************************************************************
-**
-** Function         phFriNfc_MfStd_H_StrNdefData
-**
-** Description      This function shall store ndef compliant in the MAD array
-**                  which will be later used for updating the MAD sector.
-**
-** Returns          none
-**
-*******************************************************************************/
-static void phFriNfc_MfStd_H_StrNdefData(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt )
-{
-    uint8_t     SectIndex = PH_FRINFC_MFSTD_FMT_VAL_1,
-                index = PH_FRINFC_MFSTD_FMT_VAL_0;
-
-    memset(NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSectBlk,
-                0x00,
-                PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_4K);
-
-    /* Zeroth sector of the Mifare card is MAD sector, CRC is 0x14 */
-    NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSectBlk[PH_FRINFC_MFSTD_FMT_VAL_0] = 0x14;
-    /* Info byte is 0x01, because the NDEF application is written and as per the MAD spec,
-     * the value for miscellaneous application is 0x01
-     */
-    NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSectBlk[PH_FRINFC_MFSTD_FMT_VAL_1] = 0x01;
-
-    if((NdefSmtCrdFmt->CardType == PH_FRINFC_SMTCRDFMT_MFSTD_4K_CRD) ||
-       (NdefSmtCrdFmt->CardType == PH_FRINFC_SMTCRDFMT_MFSTD_2K_CRD))
-    {
-        /* If 4k card then sector number 16 is MAD sector, CRC is 0xE8 */
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSectBlk[32] = 0xE8;
-        /* Info byte is 0x01, because the NDEF application is written and
-         * as per the MAD spec,
-         * the value for miscellaneous application is 0x01
-         */
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSectBlk[33] = 0x01;
-    }
-    /* NDEF information has to be updated from */
-    index = PH_FRINFC_MFSTD_FMT_VAL_2;
-    /* Depending on the card type, check the sector index */
-    while (((SectIndex < PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_4K) &&
-        (NdefSmtCrdFmt->CardType == PH_FRINFC_SMTCRDFMT_MFSTD_4K_CRD)) ||
-        ((SectIndex < PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_1K) &&
-        (NdefSmtCrdFmt->CardType == PH_FRINFC_SMTCRDFMT_MFSTD_1K_CRD)) ||
-        ((SectIndex < PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_2K) &&
-        (NdefSmtCrdFmt->CardType == PH_FRINFC_SMTCRDFMT_MFSTD_2K_CRD)))
-    {
-        /* Is the sector ndef compliant? */
-        if(NdefSmtCrdFmt->AddInfo.MfStdInfo.SectCompl[SectIndex] ==
-            PH_FRINFC_MFSTD_FMT_NDEF_COMPL)
-        {
-            /* Ndef compliant sector, update the MAD sector array
-             * in the context with values 0x03 and 0xE1
-             * 0x03 and 0xE1 is NDEF information in MAD sector
-             */
-            NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSectBlk[index] =
-                                        PH_FRINFC_MFSTD_FMT_NDEF_INFO1;
-            index++;
-            NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSectBlk[index] =
-                                        PH_FRINFC_MFSTD_FMT_NDEF_INFO2;
-            index++;
-        }
-        else
-        {
-            /* Not a Ndef compliant sector, update the MAD sector array
-             * in the context with values 0x00 and 0x00
-             * 0x00 and 0x00 is NDEF information in MAD sector
-             */
-            NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSectBlk[index] = 0x00;
-            index++;
-            NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSectBlk[index] = 0x00;
-            index++;
-        }
-        /* Go to next sector */
-        SectIndex++;
-        /* is the sector, a MAD sector 16? */
-        if(SectIndex == PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_1K)
-        {
-            /* MAD sector number 16, so skip this sector */
-            SectIndex = SectIndex + PH_FRINFC_MFSTD_FMT_VAL_1;
-            index = index + PH_FRINFC_MFSTD_FMT_VAL_2;
-        }
-    }
-
-    return;
-}
-
-/*******************************************************************************
-**
-** Function         phFriNfc_MfStd_H_BlkNoToWrTLV
-**
-** Description      This function shall find the ndef compliant
-**                  and calculate the block number to write the NDEF TLV.
-**
-** Returns          none
-**
-*******************************************************************************/
-static void phFriNfc_MfStd_H_BlkNoToWrTLV(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt )
-{
-    uint8_t     SectIndex = (uint8_t)PH_FRINFC_MFSTD_FMT_VAL_1;
-    while (((SectIndex < (uint8_t)PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_4K) &&
-        (NdefSmtCrdFmt->CardType == (uint8_t)PH_FRINFC_SMTCRDFMT_MFSTD_4K_CRD)) ||
-        ((SectIndex < (uint8_t)PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_1K) &&
-        (NdefSmtCrdFmt->CardType == (uint8_t)PH_FRINFC_SMTCRDFMT_MFSTD_1K_CRD)) ||
-        ((SectIndex < (uint8_t)PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_2K) &&
-        (NdefSmtCrdFmt->CardType == (uint8_t)PH_FRINFC_SMTCRDFMT_MFSTD_2K_CRD)))
-    {
-        if (NdefSmtCrdFmt->AddInfo.MfStdInfo.SectCompl[SectIndex] ==
-            (uint8_t)PH_FRINFC_MFSTD_FMT_NDEF_COMPL)
-        {
-            /* Get the first NFC forum sector's block */
-            NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock = (uint16_t)
-                                          (((SectIndex & 0xE0) >= 32)?
-                                        (128 + ((SectIndex % 32) * 16)):
-                                        (SectIndex * (uint8_t)PH_FRINFC_MFSTD_FMT_VAL_4));
-            /* Break out of the loop */
-            SectIndex += (uint8_t)PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_4K;
-        }
-        SectIndex++;
-    }
-
-    return;
-}
-
-/*******************************************************************************
-**
-** Function         phFriNfc_MfStd_H_ErrRdSectTr
-**
-** Description      This function shall process the error status of the reading sector trailer.
-**
-** Returns          NFCSTATUS_PENDING if successful
-**                  Other values if an error has occurred
-**
-*******************************************************************************/
-static NFCSTATUS phFriNfc_MfStd_H_ErrRdSectTr(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt )
-{
-    NFCSTATUS   Result = NdefSmtCrdFmt->FmtProcStatus;
-    uint8_t     Buffer[1] = {PH_FRINFC_MFSTD_FMT_NDEF_COMPL},
-                index = PH_FRINFC_MFSTD_FMT_VAL_1,
-                SectIndex = PH_FRINFC_MFSTD_FMT_VAL_0;
-    uint32_t    memcompare = PH_FRINFC_MFSTD_FMT_VAL_1;
-    /* If default key A is used for authentication and if write fails, then try to
-     * authenticate using key B
-     */
-    if(NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState ==
-        PH_FRINFC_MFSTD_FMT_AUTH_DEF_KEY)
-    {
-        /* Change the state to authentication */
-        NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_AUTH_SECT;
-        /* internal authenticate state = key B */
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState = PH_FRINFC_MFSTD_FMT_AUTH_KEYB;
-        /* Now call authenticate */
-        Result = phFriNfc_MfStd_H_WrRdAuth(NdefSmtCrdFmt);
-    }
-    else
-    {
-        /* Calculate sector index */
-        SectIndex = (uint8_t)PH_FRINFC_MFSTD_FMT_SECT_INDEX_CALC;
-
-        /* Sector is ndef compliance */
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.SectCompl[SectIndex] = (uint8_t)
-                            ((NdefSmtCrdFmt->FmtProcStatus != NFCSTATUS_SUCCESS)?
-                            PH_FRINFC_MFSTD_FMT_NON_NDEF_COMPL:
-                            PH_FRINFC_MFSTD_FMT_NDEF_COMPL);
-
-        /* Increment the current block */
-        PH_FRINFC_MFSTD_FMT_CUR_BLK_INC();
-        SectIndex++;
-        if(PH_FRINFC_MFSTD_FMT_CUR_BLK_CHK)
-        {
-            PH_FRINFC_MFSTD_FMT_CHK_END_OF_CARD();
-        }
-        else
-        {
-            /* Set the state */
-            NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_AUTH_SECT;
-            /* Set the authenticate state */
-            NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState =
-                PH_FRINFC_MFSTD_FMT_AUTH_DEF_KEY;
-            /* Start authentication */
-            Result = phFriNfc_MfStd_H_WrRdAuth(NdefSmtCrdFmt);
-        }
-    }
-    return Result;
-}
-
-/*******************************************************************************
-**
-** Function         phFriNfc_MfStd_MemCompare
-**
-** Description      This function shall process memory comparison.
-**
-** Returns          0 if memory is same
-**                  Not 0 if different
-**
-*******************************************************************************/
-static int phFriNfc_MfStd_MemCompare(void *s1, void *s2, unsigned int n )
-{
-    int8_t   diff = 0;
-    int8_t *char_1  =(int8_t *)s1;
-    int8_t *char_2  =(int8_t *)s2;
-    if(NULL == s1 || NULL == s2)
-    {
-        NXPLOG_EXTNS_E("NULL pointer passed to memcompare");
-    }
-    else
-    {
-        for(;((n>0)&&(diff==0));n--,char_1++,char_2++)
-        {
-            diff = *char_1 - *char_2;
-        }
-    }
-    return (int)diff;
-}
diff --git a/nci/jni/extns/pn54x/src/mifare/phFriNfc_MifStdFormat.cpp b/nci/jni/extns/pn54x/src/mifare/phFriNfc_MifStdFormat.cpp
new file mode 100644
index 00000000..3b722dae
--- /dev/null
+++ b/nci/jni/extns/pn54x/src/mifare/phFriNfc_MifStdFormat.cpp
@@ -0,0 +1,1340 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Mifare Standard Format implementation
+ */
+
+#include <phFriNfc_MifStdFormat.h>
+#include <phNfcCompId.h>
+#include <phNxpExtns_MifareStd.h>
+#include <phNxpLog.h>
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
+using android::base::StringPrintf;
+
+/* Function prototype declarations */
+static void phFriNfc_MfStd_H_FillSendBuf(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt, uint16_t BlockNo);
+static NFCSTATUS phFriNfc_MfStd_H_Transceive(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt);
+static NFCSTATUS phFriNfc_MfStd_H_CallDisCon(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt, NFCSTATUS Status);
+static NFCSTATUS phFriNfc_MfStd_H_CallCon(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt);
+static NFCSTATUS phFriNfc_MfStd_H_ProCon(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt);
+static NFCSTATUS phFriNfc_MfStd_H_ProAuth(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt);
+static NFCSTATUS phFriNfc_MfStd_H_ProRdSectTr(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt);
+static NFCSTATUS phFriNfc_MfStd_H_ProWrSectTr(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt);
+static NFCSTATUS phFriNfc_MfStd_H_WrRdAuth(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt);
+static uint32_t phFriNfc_MfStd_H_ChkAcsBit(uint16_t BlockNo,
+                                           const uint8_t* RecvBuf,
+                                           const uint8_t AcsBits1[],
+                                           const uint8_t AcsBits2[]);
+static void phFriNfc_MfStd_H_ChangeAuthSt(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt);
+static void phFriNfc_MfStd_H_NdefComplSect(uint8_t CardTypes, uint8_t Sector[]);
+static NFCSTATUS phFriNfc_MfStd_H_ProWrMADBlk(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt);
+static NFCSTATUS phFriNfc_MfStd_H_ProErrAuth(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt);
+static NFCSTATUS phFriNfc_MfStd_H_ErrWrSectTr(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt);
+static NFCSTATUS phFriNfc_MfStd_H_ErrRdSectTr(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt);
+static NFCSTATUS phFriNfc_MfStd_H_ProUpdMADBlk(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt);
+static void phFriNfc_MfStd_H_StrNdefData(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt);
+static void phFriNfc_MfStd_H_BlkNoToWrTLV(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt);
+static int phFriNfc_MfStd_MemCompare(void* s1, void* s2, unsigned int n);
+
+/*
+ * Enum definition contains format states
+ */
+typedef enum Mfc_format_state {
+  MFC_FORMAT_INIT = 0x00,
+  MFC_FORMAT_NFC_KEY,
+  MFC_FORMAT_DEF_KEY,
+  MFC_FORMAT_INVALID
+} MFC_FORMAT_STATE;
+
+/* format key status */
+static MFC_FORMAT_STATE FormatKeyState = MFC_FORMAT_INIT;
+
+/*******************************************************************************
+**
+** Function         phFriNfc_MfStd_Reset
+**
+** Description      Resets the component instance to the initial state and
+*initializes the
+**                  internal variables.
+**
+** Returns          none
+**
+*******************************************************************************/
+void phFriNfc_MfStd_Reset(phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt) {
+  uint8_t NfcForSectArray[] = PH_FRINFC_SMTCRDFMT_NFCFORUMSECT_KEYA_ACS_BIT,
+          MADSectArray[] = PH_FRINFC_SMTCRDFMT_MSTD_MADSECT_KEYA_ACS_BIT_1K;
+
+  /* Authentication state */
+  NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState = PH_FRINFC_MFSTD_FMT_VAL_1;
+
+  /* Set default key for A or B */
+  memset(NdefSmtCrdFmt->AddInfo.MfStdInfo.Default_KeyA_OR_B,
+         PH_FRINFC_MFSTD_FMT_DEFAULT_KEY, /* 0xFF */
+         PH_FRINFC_MFSTD_FMT_VAL_6);
+
+  /* MAD sector key A */
+  memcpy(NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSect_KeyA,
+         MADSectArray, /*PH_FRINFC_MFSTD_FMT_VAL_0, */
+         PH_FRINFC_MFSTD_FMT_VAL_6);
+
+  /* Copy access bits for MAD sectors */
+  memcpy(NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSect_AccessBits,
+         &MADSectArray[PH_FRINFC_MFSTD_FMT_VAL_6], PH_FRINFC_MFSTD_FMT_VAL_3);
+
+  /* NFC forum sector key A */
+  (void)memcpy(NdefSmtCrdFmt->AddInfo.MfStdInfo.NFCForumSect_KeyA,
+               NfcForSectArray, /*PH_FRINFC_MFSTD_FMT_VAL_0, */
+               PH_FRINFC_MFSTD_FMT_VAL_6);
+
+  /* Copy access bits for NFC forum sectors */
+  (void)memcpy(NdefSmtCrdFmt->AddInfo.MfStdInfo.NFCForumSect_AccessBits,
+               &NfcForSectArray[PH_FRINFC_MFSTD_FMT_VAL_6],
+               PH_FRINFC_MFSTD_FMT_VAL_3);
+
+  /* Sector compliant array initialised to 0 */
+  memset(NdefSmtCrdFmt->AddInfo.MfStdInfo.SectCompl,
+         PH_FRINFC_MFSTD_FMT_VAL_0, /* 0x00 */
+         PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_4K);
+
+  NdefSmtCrdFmt->AddInfo.MfStdInfo.WrMADBlkFlag =
+      (uint8_t)PH_FRINFC_MFSTD_FMT_VAL_0;
+  NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk =
+      (uint8_t)PH_FRINFC_MFSTD_FMT_NOT_A_MAD_BLK;
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phFriNfc_MfStd_Format
+**
+** Description      The function initiates and formats the Smart Card.After this
+*formation, remote
+**                  card would be properly initialized and Ndef Compliant.
+**
+** Returns          NFCSTATUS_PENDING if successful
+**                  Other values if an error has occurred
+**
+*******************************************************************************/
+NFCSTATUS phFriNfc_MfStd_Format(phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt,
+                                const uint8_t* ScrtKeyB) {
+  NFCSTATUS Result =
+      PHNFCSTVAL(CID_FRI_NFC_NDEF_SMTCRDFMT, NFCSTATUS_INVALID_PARAMETER);
+  uint8_t index = PH_FRINFC_MFSTD_FMT_VAL_0;
+
+  if (ScrtKeyB != NULL) {
+    NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk =
+        PH_FRINFC_MFSTD_FMT_NOT_A_MAD_BLK;
+    /* Store Key B in the context */
+    while (index < PH_FRINFC_MFSTD_FMT_VAL_6) {
+      NdefSmtCrdFmt->AddInfo.MfStdInfo.ScrtKeyB[index] = ScrtKeyB[index];
+      index++;
+    }
+    /* Set the state */
+    NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_AUTH_SECT;
+    /* Initialize current block to the first sector trailer */
+    NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock = PH_FRINFC_MFSTD_FMT_VAL_3;
+    /* Set the authenticate state */
+    if (MFC_FORMAT_DEF_KEY == FormatKeyState) {
+      FormatKeyState = MFC_FORMAT_INIT;
+      NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState =
+          PH_FRINFC_MFSTD_FMT_AUTH_DEF_KEY;
+    } else {
+      FormatKeyState = MFC_FORMAT_NFC_KEY;
+      NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState =
+          PH_FRINFC_MFSTD_FMT_AUTH_NFC_KEY; /* Key Chnage for some cards */
+    }
+    /* Start authentication */
+    Result = phFriNfc_MfStd_H_WrRdAuth(NdefSmtCrdFmt);
+  }
+  return Result;
+}
+
+/*******************************************************************************
+**
+** Function         phFriNfc_MfStd_Process
+**
+** Description      Completion Routine: This function is called by the lower
+*layer (OVR HAL)
+**                  when an I/O operation has finished. The internal state
+*machine decides
+**                  whether to call into the lower device again or to complete
+*the process
+**                  by calling into the upper layer's completion routine, stored
+*within this
+**                  component's context (phFriNfc_sNdefSmtCrdFmt_t).
+**
+** Returns          none
+**
+*******************************************************************************/
+void phFriNfc_MfStd_Process(void* Context, NFCSTATUS Status) {
+  phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt =
+      (phFriNfc_sNdefSmtCrdFmt_t*)Context;
+  /* Copy the formatting status */
+  NdefSmtCrdFmt->FmtProcStatus = Status;
+
+  if (Status == NFCSTATUS_SUCCESS) {
+    switch (NdefSmtCrdFmt->State) {
+      case PH_FRINFC_MFSTD_FMT_AUTH_SECT:
+        Status = phFriNfc_MfStd_H_ProAuth(NdefSmtCrdFmt);
+        break;
+
+      case PH_FRINFC_MFSTD_FMT_DIS_CON:
+        Status = phFriNfc_MfStd_H_CallCon(NdefSmtCrdFmt);
+        break;
+
+      case PH_FRINFC_MFSTD_FMT_CON:
+        if (MFC_FORMAT_DEF_KEY == FormatKeyState) {
+          /* retry the format with other key */
+          Mfc_FormatNdef(current_key, 6);
+          return;
+        }
+        Status = phFriNfc_MfStd_H_ProCon(NdefSmtCrdFmt);
+        break;
+
+      case PH_FRINFC_MFSTD_FMT_RD_SECT_TR:
+        Status = phFriNfc_MfStd_H_ProRdSectTr(NdefSmtCrdFmt);
+        break;
+
+      case PH_FRINFC_MFSTD_FMT_WR_SECT_TR:
+        Status = phFriNfc_MfStd_H_ProWrSectTr(NdefSmtCrdFmt);
+        break;
+
+      case PH_FRINFC_MFSTD_FMT_WR_MAD_BLK:
+        Status = phFriNfc_MfStd_H_ProWrMADBlk(NdefSmtCrdFmt);
+        break;
+
+      case PH_FRINFC_MFSTD_FMT_WR_TLV:
+        break;
+
+      case PH_FRINFC_MFSTD_FMT_UPD_MAD_BLK:
+        Status = phFriNfc_MfStd_H_ProUpdMADBlk(NdefSmtCrdFmt);
+        break;
+
+      default:
+        Status = PHNFCSTVAL(CID_FRI_NFC_NDEF_SMTCRDFMT,
+                            NFCSTATUS_INVALID_DEVICE_REQUEST);
+        break;
+    }
+  } else {
+    switch (NdefSmtCrdFmt->State) {
+      case PH_FRINFC_MFSTD_FMT_AUTH_SECT:
+        if (MFC_FORMAT_NFC_KEY == FormatKeyState) {
+          FormatKeyState = MFC_FORMAT_DEF_KEY;
+        }
+        Status = phFriNfc_MfStd_H_ProErrAuth(NdefSmtCrdFmt);
+        break;
+
+      case PH_FRINFC_MFSTD_FMT_WR_SECT_TR:
+        Status = phFriNfc_MfStd_H_ErrWrSectTr(NdefSmtCrdFmt);
+        break;
+
+      case PH_FRINFC_MFSTD_FMT_RD_SECT_TR:
+        Status = phFriNfc_MfStd_H_ErrRdSectTr(NdefSmtCrdFmt);
+        break;
+
+      default:
+        Status = NdefSmtCrdFmt->FmtProcStatus;
+        break;
+    }
+  }
+
+  /* Status is not success then call completion routine */
+  if (Status != NFCSTATUS_PENDING) {
+    phFriNfc_SmtCrdFmt_HCrHandler(NdefSmtCrdFmt, Status);
+  }
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phFriNfc_MfStd_H_FillSendBuf
+**
+** Description      This function fills the send buffer for transceive function
+**
+** Returns          none
+**
+*******************************************************************************/
+static void phFriNfc_MfStd_H_FillSendBuf(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt, uint16_t BlockNo) {
+  //    void        *mem = NULL;
+  //    /*commented to eliminate unused variable warning*/
+  uint8_t MADSectTr1k[] =
+      PH_FRINFC_SMTCRDFMT_MSTD_MADSECT_KEYA_ACS_BIT_1K, /* MAD key A,
+                                                  Access bits and GPB of MAD
+                                                  sector */
+      MADSectTr2k[] =
+          PH_FRINFC_SMTCRDFMT_MSTD_MADSECT_KEYA_ACS_BIT_2K, /* MAD key A,
+                                                      Access bits and GPB
+                                                      of MAD sector */
+      MADSectTr4k[] =
+          PH_FRINFC_SMTCRDFMT_MSTD_MADSECT_KEYA_ACS_BIT_4K,        /* MAD key A,
+                                                                     Access bits
+                                                                     and GPB of
+                                                                     MAD sector */
+      NFCSectTr[] = PH_FRINFC_SMTCRDFMT_NFCFORUMSECT_KEYA_ACS_BIT, /* NFC forum
+                                                                   key A,
+                                                                   Access bits
+                                                                   and GPB of
+                                                                   NFC sector */
+      NDEFMsgTLV[16] =
+          {0x03, 0x00, 0xFE, 0x00, 0x00, 0x00, /* NDEF message TLV
+                                                  (INITIALISED state) */
+           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+          MADBlk[16] = {0x0F, 0x00, 0x03, 0xE1, 0x03, 0xE1, 0x03, 0xE1,
+                        0x03, 0xE1, 0x03, 0xE1, 0x03, 0xE1, 0x03, 0xE1};
+  /* Block number in send buffer */
+  NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_0] = (uint8_t)BlockNo;
+  /* Initialize send receive length */
+  *NdefSmtCrdFmt->SendRecvLength = PH_FRINFC_MFSTD_FMT_MAX_RECV_LENGTH;
+
+  /* Depending on the different state, fill the send buffer */
+  switch (NdefSmtCrdFmt->State) {
+    case PH_FRINFC_MFSTD_FMT_AUTH_SECT:
+      /* Depending on the authentication state, fill the send buffer */
+      switch (NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState) {
+        case PH_FRINFC_MFSTD_FMT_AUTH_DEF_KEY:
+        case PH_FRINFC_MFSTD_FMT_AUTH_KEYB:
+          /* Fill send buffer with the default key */
+          PH_FRINFC_MFSTD_FMT_AUTH_SEND_BUF_DEF(mem);
+          break;
+
+        case PH_FRINFC_MFSTD_FMT_AUTH_NFC_KEY:
+          /* Fill send buffer with NFC forum sector key */
+          PH_FRINFC_MFSTD_FMT_AUTH_SEND_BUF_NFCSECT_KEYA(mem);
+          break;
+
+        case PH_FRINFC_MFSTD_FMT_AUTH_SCRT_KEYB:
+          /* Fill send buffer with NFC forum sector key */
+          PH_FRINFC_MFSTD_FMT_AUTH_SEND_BUF_SCRT_KEY(mem);
+          break;
+
+        case PH_FRINFC_MFSTD_FMT_AUTH_MAD_KEY:
+        default:
+          /* Fill send buffer with MAD sector key */
+          PH_FRINFC_MFSTD_FMT_AUTH_SEND_BUF_MADSECT_KEYA(mem);
+          break;
+      }
+      break;
+
+    case PH_FRINFC_MFSTD_FMT_RD_SECT_TR:
+      NdefSmtCrdFmt->Cmd.MfCmd = phHal_eMifareRead;
+
+      /* Send length is always one for read operation */
+      NdefSmtCrdFmt->SendLength = PH_FRINFC_MFSTD_FMT_VAL_1;
+      break;
+
+    case PH_FRINFC_MFSTD_FMT_WR_SECT_TR:
+      /* Fill send buffer for writing sector trailer */
+      NdefSmtCrdFmt->Cmd.MfCmd = phHal_eMifareWrite16;
+      /* Copy the relevant sector trailer value in the buffer */
+      switch (NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock) {
+        case PH_FRINFC_MFSTD_FMT_VAL_3:
+          if (NdefSmtCrdFmt->CardType == PH_FRINFC_SMTCRDFMT_MFSTD_1K_CRD) {
+            memcpy(&NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1],
+                   MADSectTr1k, sizeof(MADSectTr1k));
+          } else if (NdefSmtCrdFmt->CardType ==
+                     PH_FRINFC_SMTCRDFMT_MFSTD_2K_CRD) {
+            memcpy(&NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1],
+                   MADSectTr2k, sizeof(MADSectTr2k));
+          } else {
+            memcpy(&NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1],
+                   MADSectTr4k, sizeof(MADSectTr4k));
+          }
+          break;
+        case 67:
+          (void)memcpy(&NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1],
+                       MADSectTr4k, sizeof(MADSectTr4k));
+          break;
+        default:
+          (void)memcpy(&NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1],
+                       NFCSectTr, sizeof(NFCSectTr));
+          break;
+      }
+      memcpy(&NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_11],
+             NdefSmtCrdFmt->AddInfo.MfStdInfo.ScrtKeyB,
+             sizeof(NdefSmtCrdFmt->AddInfo.MfStdInfo.ScrtKeyB));
+
+      /* Send length is always 17 for write operation */
+      NdefSmtCrdFmt->SendLength = PH_FRINFC_MFSTD_FMT_WR_SEND_LENGTH;
+      break;
+
+    case PH_FRINFC_MFSTD_FMT_WR_TLV:
+      /* Fill send buffer for writing TLV */
+      NdefSmtCrdFmt->Cmd.MfCmd = phHal_eMifareWrite16;
+      /* Copy the NDEF message TLV */
+      memcpy(&NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1], NDEFMsgTLV,
+             sizeof(NDEFMsgTLV));
+      /* Send length is always 17 for write operation */
+      NdefSmtCrdFmt->SendLength = PH_FRINFC_MFSTD_FMT_WR_SEND_LENGTH;
+      break;
+
+    case PH_FRINFC_MFSTD_FMT_WR_MAD_BLK:
+      /* Fill send buffer for writing MAD block */
+      NdefSmtCrdFmt->Cmd.MfCmd = phHal_eMifareWrite16;
+      if ((BlockNo == PH_FRINFC_MFSTD_FMT_VAL_2) || (BlockNo == 65) ||
+          (BlockNo == 66)) {
+        /* MAD block number 2, 65 and 66 has 0x03, 0xE1 in the
+         * first two bytes
+         */
+        MADBlk[PH_FRINFC_MFSTD_FMT_VAL_0] = 0x03;
+        MADBlk[PH_FRINFC_MFSTD_FMT_VAL_1] = 0xE1;
+      }
+      /* Copy the MAD Block values */
+      memcpy(&NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1], MADBlk,
+             sizeof(MADBlk));
+      /* Send length is always 17 for write operation */
+      NdefSmtCrdFmt->SendLength = PH_FRINFC_MFSTD_FMT_WR_SEND_LENGTH;
+      break;
+
+    case PH_FRINFC_MFSTD_FMT_UPD_MAD_BLK:
+    default:
+      /* Fill send buffer for writing MAD block */
+      NdefSmtCrdFmt->Cmd.MfCmd = phHal_eMifareWrite16;
+      NdefSmtCrdFmt->SendLength = PH_FRINFC_MFSTD_FMT_WR_SEND_LENGTH;
+      switch (NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk) {
+        case PH_FRINFC_MFSTD_FMT_MAD_BLK_1:
+          memcpy(
+              &NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1],
+              NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSectBlk,
+              (PH_FRINFC_MFSTD_FMT_WR_SEND_LENGTH - PH_FRINFC_MFSTD_FMT_VAL_1));
+          break;
+
+        case PH_FRINFC_MFSTD_FMT_MAD_BLK_2:
+          memcpy(
+              &NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1],
+              &NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSectBlk[16],
+              (PH_FRINFC_MFSTD_FMT_WR_SEND_LENGTH - PH_FRINFC_MFSTD_FMT_VAL_1));
+          break;
+
+        case PH_FRINFC_MFSTD_FMT_MAD_BLK_64:
+          memcpy(
+              &NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1],
+              &NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSectBlk[32],
+              (PH_FRINFC_MFSTD_FMT_WR_SEND_LENGTH - PH_FRINFC_MFSTD_FMT_VAL_1));
+          break;
+
+        case PH_FRINFC_MFSTD_FMT_MAD_BLK_65:
+          memcpy(
+              &NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1],
+              &NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSectBlk[48],
+              (PH_FRINFC_MFSTD_FMT_WR_SEND_LENGTH - PH_FRINFC_MFSTD_FMT_VAL_1));
+          break;
+
+        case PH_FRINFC_MFSTD_FMT_MAD_BLK_66:
+        default:
+          memcpy(
+              &NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1],
+              &NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSectBlk[64],
+              (PH_FRINFC_MFSTD_FMT_WR_SEND_LENGTH - PH_FRINFC_MFSTD_FMT_VAL_1));
+          break;
+      }
+      break;
+  }
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phFriNfc_MfStd_H_Transceive
+**
+** Description      This function authenticates a block or a sector from the
+*card.
+**
+** Returns          NFCSTATUS_PENDING if successful
+**                  Other values if an error has occurred
+**
+*******************************************************************************/
+static NFCSTATUS phFriNfc_MfStd_H_Transceive(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+
+  /*set the completion routines for the card operations*/
+  NdefSmtCrdFmt->SmtCrdFmtCompletionInfo.CompletionRoutine =
+      phFriNfc_NdefSmtCrd_Process;
+  NdefSmtCrdFmt->SmtCrdFmtCompletionInfo.Context = NdefSmtCrdFmt;
+
+  *NdefSmtCrdFmt->SendRecvLength = PH_FRINFC_SMTCRDFMT_MAX_SEND_RECV_BUF_SIZE;
+
+  /* Call the Overlapped HAL Transceive function */
+  Result = phFriNfc_ExtnsTransceive(
+      NdefSmtCrdFmt->pTransceiveInfo, NdefSmtCrdFmt->Cmd,
+      NdefSmtCrdFmt->SendRecvBuf, NdefSmtCrdFmt->SendLength,
+      NdefSmtCrdFmt->SendRecvLength);
+  return Result;
+}
+
+/*******************************************************************************
+**
+** Function         phFriNfc_MfStd_H_CallDisCon
+**
+** Description      This function calls disconnect.
+**
+** Returns          NFCSTATUS_PENDING if successful
+**                  Other values if an error has occurred
+**
+*******************************************************************************/
+static NFCSTATUS phFriNfc_MfStd_H_CallDisCon(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt, NFCSTATUS Status) {
+  NFCSTATUS Result = Status;
+
+  /*Set Ndef State*/
+  NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_DIS_CON;
+
+  Result = phNxNciExtns_MifareStd_Reconnect();
+  return Result;
+}
+
+/*******************************************************************************
+**
+** Function         phFriNfc_MfStd_H_CallCon
+**
+** Description      This function calls reconnect.
+**
+** Returns          NFCSTATUS_PENDING if successful
+**                  Other values if an error has occurred
+**
+*******************************************************************************/
+static NFCSTATUS phFriNfc_MfStd_H_CallCon(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+  /*Set Ndef State*/
+  NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_CON;
+
+  Result = phNxNciExtns_MifareStd_Reconnect();
+  return Result;
+}
+
+/*******************************************************************************
+**
+** Function         phFriNfc_MfStd_H_ProCon
+**
+** Description      This function shall process the poll call.
+**
+** Returns          NFCSTATUS_PENDING if successful
+**                  Other values if an error has occurred
+**
+*******************************************************************************/
+static NFCSTATUS phFriNfc_MfStd_H_ProCon(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+  uint8_t Buffer[1] = {PH_FRINFC_MFSTD_FMT_NDEF_COMPL};
+  uint8_t index = PH_FRINFC_MFSTD_FMT_VAL_1;
+  uint32_t memcompare = PH_FRINFC_MFSTD_FMT_VAL_1;
+
+  phFriNfc_MfStd_H_ChangeAuthSt(NdefSmtCrdFmt);
+  if (PH_FRINFC_MFSTD_FMT_CUR_BLK_CHK) {
+    PH_FRINFC_MFSTD_FMT_CHK_END_OF_CARD();
+  } else {
+    /* Set the state */
+    NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_AUTH_SECT;
+    /* Start authentication */
+    Result = phFriNfc_MfStd_H_WrRdAuth(NdefSmtCrdFmt);
+  }
+  return Result;
+}
+
+/*******************************************************************************
+**
+** Function         phFriNfc_MfStd_H_ProAuth
+**
+** Description      This function shall process the authenticate call.
+**
+** Returns          NFCSTATUS_PENDING if successful
+**                  Other values if an error has occurred
+**
+*******************************************************************************/
+static NFCSTATUS phFriNfc_MfStd_H_ProAuth(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+
+  /* Depending on the authentication key check the  */
+  switch (NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState) {
+    case PH_FRINFC_MFSTD_FMT_AUTH_DEF_KEY:
+      if ((NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock ==
+           PH_FRINFC_MFSTD_FMT_VAL_3) &&
+          (NdefSmtCrdFmt->AddInfo.MfStdInfo.WrMADBlkFlag ==
+           PH_FRINFC_MFSTD_FMT_VAL_0)) {
+        /* Authenticate with default key for block 3 is successful,
+         * so fill the MAD block of sector 0
+         */
+        NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock =
+            PH_FRINFC_MFSTD_FMT_VAL_1;
+        /* Write the MAD block */
+        NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_WR_MAD_BLK;
+      } else if ((NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock == 67) &&
+                 (NdefSmtCrdFmt->AddInfo.MfStdInfo.WrMADBlkFlag ==
+                  PH_FRINFC_MFSTD_FMT_VAL_0)) {
+        /* Authenticate with default key for block 3 is successful,
+         * so fill the MAD block of sector 64
+         */
+        NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock = 64;
+        /* Write the MAD block */
+        NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_WR_MAD_BLK;
+      } else {
+        /* Not a MAD sector */
+        NdefSmtCrdFmt->AddInfo.MfStdInfo.WrMADBlkFlag =
+            PH_FRINFC_MFSTD_FMT_VAL_0;
+        /* Write the MAD block */
+        NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_WR_SECT_TR;
+      }
+      break;
+
+    case PH_FRINFC_MFSTD_FMT_AUTH_KEYB:
+      if ((NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk ==
+           PH_FRINFC_MFSTD_FMT_MAD_BLK_1) ||
+          (NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk ==
+           PH_FRINFC_MFSTD_FMT_MAD_BLK_2) ||
+          (NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk ==
+           PH_FRINFC_MFSTD_FMT_MAD_BLK_64) ||
+          (NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk ==
+           PH_FRINFC_MFSTD_FMT_MAD_BLK_65) ||
+          (NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk ==
+           PH_FRINFC_MFSTD_FMT_MAD_BLK_66)) {
+        NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock =
+            NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk;
+        NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_UPD_MAD_BLK;
+      } else {
+        NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk =
+            PH_FRINFC_MFSTD_FMT_NOT_A_MAD_BLK;
+        NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_WR_SECT_TR;
+      }
+
+      break;
+
+    case PH_FRINFC_MFSTD_FMT_AUTH_SCRT_KEYB:
+      if ((NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk ==
+           PH_FRINFC_MFSTD_FMT_MAD_BLK_1) ||
+          (NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk ==
+           PH_FRINFC_MFSTD_FMT_MAD_BLK_2) ||
+          (NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk ==
+           PH_FRINFC_MFSTD_FMT_MAD_BLK_64) ||
+          (NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk ==
+           PH_FRINFC_MFSTD_FMT_MAD_BLK_65) ||
+          (NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk ==
+           PH_FRINFC_MFSTD_FMT_MAD_BLK_66)) {
+        NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock =
+            NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk;
+        NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_UPD_MAD_BLK;
+      } else {
+        NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk =
+            PH_FRINFC_MFSTD_FMT_NOT_A_MAD_BLK;
+        NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_WR_SECT_TR;
+      }
+      break;
+
+    case PH_FRINFC_MFSTD_FMT_AUTH_NFC_KEY:
+    case PH_FRINFC_MFSTD_FMT_AUTH_MAD_KEY:
+    default:
+      if ((NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk ==
+           PH_FRINFC_MFSTD_FMT_MAD_BLK_66) ||
+          (NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk ==
+           PH_FRINFC_MFSTD_FMT_MAD_BLK_2)) {
+        /* Updating the MAD block is complete */
+        NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk =
+            PH_FRINFC_MFSTD_FMT_NOT_A_MAD_BLK;
+        /* If Mifare 4k card, write the TLV */
+        NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_WR_TLV;
+      } else {
+        /* Depending on the sector trailer, check the access bit */
+        NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_RD_SECT_TR;
+      }
+      break;
+  }
+  /* Call read, write or authenticate */
+  Result = phFriNfc_MfStd_H_WrRdAuth(NdefSmtCrdFmt);
+  return Result;
+}
+
+/*******************************************************************************
+**
+** Function         phFriNfc_MfStd_H_ErrWrSectTr
+**
+** Description      This function shall process the error status of the writing
+*sector trailer.
+**
+** Returns          NFCSTATUS_PENDING if successful
+**                  Other values if an error has occurred
+**
+*******************************************************************************/
+static NFCSTATUS phFriNfc_MfStd_H_ErrWrSectTr(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt) {
+  NFCSTATUS Result = NdefSmtCrdFmt->FmtProcStatus;
+  /* If default key A is used for authentication and if write fails, then try to
+   * authenticate using key B
+   */
+  if (NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState ==
+      PH_FRINFC_MFSTD_FMT_AUTH_DEF_KEY) {
+    /* Change the state to authentication */
+    NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_AUTH_SECT;
+    /* internal authenticate state = key B */
+    NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState = PH_FRINFC_MFSTD_FMT_AUTH_KEYB;
+    /* Now call authenticate */
+    Result = phFriNfc_MfStd_H_WrRdAuth(NdefSmtCrdFmt);
+  } else {
+    Result = phFriNfc_MfStd_H_ProWrSectTr(NdefSmtCrdFmt);
+  }
+  return Result;
+}
+
+/*******************************************************************************
+**
+** Function         phFriNfc_MfStd_H_ProRdSectTr
+**
+** Description      This function shall process the read access bit call.
+**
+** Returns          NFCSTATUS_PENDING if successful
+**                  Other values if an error has occurred
+**
+*******************************************************************************/
+static NFCSTATUS phFriNfc_MfStd_H_ProRdSectTr(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+  uint8_t Buffer[1] = {PH_FRINFC_MFSTD_FMT_NDEF_COMPL},
+          index = PH_FRINFC_MFSTD_FMT_VAL_1,
+          SectIndex = PH_FRINFC_MFSTD_FMT_VAL_0;
+  uint32_t memcompare = PH_FRINFC_MFSTD_FMT_VAL_1;
+
+  /* Calculate sector index */
+  SectIndex = (uint8_t)PH_FRINFC_MFSTD_FMT_SECT_INDEX_CALC;
+
+  /* Depending on the sector trailer, check the access bit */
+  memcompare = phFriNfc_MfStd_H_ChkAcsBit(
+      NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock, NdefSmtCrdFmt->SendRecvBuf,
+      NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSect_AccessBits,
+      NdefSmtCrdFmt->AddInfo.MfStdInfo.NFCForumSect_AccessBits);
+
+  /* Check the sector for ndef compliance */
+  NdefSmtCrdFmt->AddInfo.MfStdInfo.SectCompl[SectIndex] =
+      (uint8_t)((memcompare != PH_FRINFC_MFSTD_FMT_VAL_0)
+                    ? PH_FRINFC_MFSTD_FMT_NON_NDEF_COMPL
+                    : PH_FRINFC_MFSTD_FMT_NDEF_COMPL);
+
+  /* Increment the current block */
+  PH_FRINFC_MFSTD_FMT_CUR_BLK_INC();
+  SectIndex++;
+  if (PH_FRINFC_MFSTD_FMT_CUR_BLK_CHK) {
+    PH_FRINFC_MFSTD_FMT_CHK_END_OF_CARD();
+  } else {
+    /* Set the state */
+    NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_AUTH_SECT;
+    /* Set the authenticate state */
+    NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState =
+        PH_FRINFC_MFSTD_FMT_AUTH_DEF_KEY;
+    /* Start authentication */
+    Result = phFriNfc_MfStd_H_WrRdAuth(NdefSmtCrdFmt);
+  }
+  return Result;
+}
+
+/*******************************************************************************
+**
+** Function         phFriNfc_MfStd_H_ProWrSectTr
+**
+** Description      This function shall process the write access bit call.
+**
+** Returns          NFCSTATUS_PENDING if successful
+**                  Other values if an error has occurred
+**
+*******************************************************************************/
+static NFCSTATUS phFriNfc_MfStd_H_ProWrSectTr(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+  uint8_t Buffer[1] = {PH_FRINFC_MFSTD_FMT_NDEF_COMPL},
+          index = PH_FRINFC_MFSTD_FMT_VAL_1,
+          SectIndex = PH_FRINFC_MFSTD_FMT_VAL_0;
+  uint32_t memcompare = PH_FRINFC_MFSTD_FMT_VAL_1;
+
+  /* Calculate sector index */
+  SectIndex = (uint8_t)PH_FRINFC_MFSTD_FMT_SECT_INDEX_CALC;
+
+  /* Sector is ndef compliance */
+  NdefSmtCrdFmt->AddInfo.MfStdInfo.SectCompl[SectIndex] =
+      (uint8_t)((NdefSmtCrdFmt->FmtProcStatus != NFCSTATUS_SUCCESS)
+                    ? PH_FRINFC_MFSTD_FMT_NON_NDEF_COMPL
+                    : PH_FRINFC_MFSTD_FMT_NDEF_COMPL);
+
+  /* Increment the current block */
+  PH_FRINFC_MFSTD_FMT_CUR_BLK_INC();
+  SectIndex++;
+  if (PH_FRINFC_MFSTD_FMT_CUR_BLK_CHK) {
+    PH_FRINFC_MFSTD_FMT_CHK_END_OF_CARD();
+  } else {
+    /* Set the state */
+    NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_AUTH_SECT;
+    /* Set the authenticate state */
+    NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState =
+        PH_FRINFC_MFSTD_FMT_AUTH_DEF_KEY;
+    /* Start authentication */
+    Result = phFriNfc_MfStd_H_WrRdAuth(NdefSmtCrdFmt);
+  }
+  return Result;
+}
+
+/*******************************************************************************
+**
+** Function         phFriNfc_MfStd_H_ChkAcsBit
+**
+** Description      This function checks access bits of each sector trailer.
+**
+** Returns          compare value
+**
+*******************************************************************************/
+static uint32_t phFriNfc_MfStd_H_ChkAcsBit(uint16_t BlockNo,
+                                           const uint8_t* RecvBuf,
+                                           const uint8_t AcsBits1[],
+                                           const uint8_t AcsBits2[]) {
+  uint32_t mem = PH_FRINFC_MFSTD_FMT_VAL_0;
+
+  /* Compare the access bits read from the sector trailer */
+  mem = (uint32_t)(((BlockNo == PH_FRINFC_MFSTD_FMT_VAL_3) || (BlockNo == 67))
+                       ? phFriNfc_MfStd_MemCompare(
+                             (void*)&RecvBuf[PH_FRINFC_MFSTD_FMT_VAL_6],
+                             (void*)AcsBits1, PH_FRINFC_MFSTD_FMT_VAL_3)
+                       : phFriNfc_MfStd_MemCompare(
+                             (void*)&RecvBuf[PH_FRINFC_MFSTD_FMT_VAL_6],
+                             (void*)AcsBits2, PH_FRINFC_MFSTD_FMT_VAL_3));
+
+  return mem;
+}
+
+/*******************************************************************************
+**
+** Function         phFriNfc_MfStd_H_WrRdAuth
+**
+** Description      This function writes sector trailer using the block number.
+**
+** Returns          NFCSTATUS_PENDING if successful
+**                  Other values if an error has occurred
+**
+*******************************************************************************/
+static NFCSTATUS phFriNfc_MfStd_H_WrRdAuth(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+  /* Fill send buffer and send length */
+  phFriNfc_MfStd_H_FillSendBuf(NdefSmtCrdFmt,
+                               NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock);
+  /* Call ovrhal transceive */
+  Result = phFriNfc_MfStd_H_Transceive(NdefSmtCrdFmt);
+
+  return Result;
+}
+
+/*******************************************************************************
+**
+** Function         phFriNfc_MfStd_H_ChangeAuthSt
+**
+** Description      This function changes authentication state and change the
+*block number if required.
+**
+** Returns          none
+**
+*******************************************************************************/
+static void phFriNfc_MfStd_H_ChangeAuthSt(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt) {
+  uint8_t SectIndex = PH_FRINFC_MFSTD_FMT_VAL_0;
+
+  if (NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState ==
+      PH_FRINFC_MFSTD_FMT_AUTH_SCRT_KEYB) {
+    /* Calculate sector index */
+    SectIndex = (uint8_t)PH_FRINFC_MFSTD_FMT_SECT_INDEX_CALC;
+
+    /* Check the sector for ndef compliance */
+    NdefSmtCrdFmt->AddInfo.MfStdInfo.SectCompl[SectIndex] =
+        PH_FRINFC_MFSTD_FMT_NON_NDEF_COMPL;
+
+    PH_FRINFC_MFSTD_FMT_CUR_BLK_INC();
+  }
+  PH_FRINFC_MFSTD_FMT_NXT_AUTH_STATE();
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phFriNfc_MfStd_H_NdefComplSect
+**
+** Description      This function finds contiguous ndef compliant blocks.
+**
+** Returns          none
+**
+*******************************************************************************/
+static void phFriNfc_MfStd_H_NdefComplSect(uint8_t CardTypes,
+                                           uint8_t Sector[]) {
+  uint8_t count = PH_FRINFC_MFSTD_FMT_VAL_0,
+          NdefComplSectMax = PH_FRINFC_MFSTD_FMT_VAL_0,
+          NdefComplSectTemp = PH_FRINFC_MFSTD_FMT_VAL_1,
+          SectIndex = PH_FRINFC_MFSTD_FMT_VAL_0,
+          MaxCont = PH_FRINFC_MFSTD_FMT_VAL_0,
+          MaxSect = PH_FRINFC_MFSTD_FMT_VAL_0;
+
+  /* Get the maximum sector depending on the sector */
+  MaxSect = ((CardTypes == PH_FRINFC_SMTCRDFMT_MFSTD_1K_CRD)
+                 ? PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_1K
+                 : ((CardTypes == PH_FRINFC_SMTCRDFMT_MFSTD_2K_CRD)
+                        ? PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_2K
+                        : PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_4K));
+  /* Sector index */
+  NdefComplSectTemp = SectIndex = PH_FRINFC_MFSTD_FMT_VAL_1;
+  /* Check the sector index depending on the card type */
+  while (((SectIndex < PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_4K) &&
+          (CardTypes == PH_FRINFC_SMTCRDFMT_MFSTD_4K_CRD)) ||
+         ((SectIndex < PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_1K) &&
+          (CardTypes == PH_FRINFC_SMTCRDFMT_MFSTD_1K_CRD)) ||
+         ((SectIndex < PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_2K) &&
+          (CardTypes == PH_FRINFC_SMTCRDFMT_MFSTD_2K_CRD))) {
+    if (Sector[SectIndex] == PH_FRINFC_MFSTD_FMT_NON_NDEF_COMPL) {
+      if (MaxCont > count) {
+        /* Store the maximum contiguous */
+        NdefComplSectMax = NdefComplSectTemp;
+        count = MaxCont;
+      }
+      MaxCont = PH_FRINFC_MFSTD_FMT_VAL_0;
+      /* Increment the sector index */
+      PH_FRINFC_MFSTD_FMT_INCR_SECT;
+      /* Get the next compliant sector */
+      NdefComplSectTemp = SectIndex;
+    } else {
+      /* Increment the sector index */
+      PH_FRINFC_MFSTD_FMT_INCR_SECT;
+    }
+    MaxCont++;
+  }
+  if (MaxCont > count) {
+    /* Store the maximum contiguous */
+    NdefComplSectMax = NdefComplSectTemp;
+    count = MaxCont;
+  }
+  /* Set the sector value has non ndef compliant which are not present with
+   * contiguous ndef compliant sectors
+   */
+  if ((((count < (MaxSect - PH_FRINFC_MFSTD_FMT_VAL_1)) &&
+        (CardTypes == PH_FRINFC_SMTCRDFMT_MFSTD_1K_CRD)) ||
+       ((count < (MaxSect - PH_FRINFC_MFSTD_FMT_VAL_2)) &&
+        (CardTypes == PH_FRINFC_SMTCRDFMT_MFSTD_4K_CRD)) ||
+       ((count < (MaxSect - PH_FRINFC_MFSTD_FMT_VAL_2)) &&
+        (CardTypes == PH_FRINFC_SMTCRDFMT_MFSTD_2K_CRD))) &&
+      ((NdefComplSectMax > PH_FRINFC_MFSTD_FMT_VAL_0) &&
+       (NdefComplSectMax < (MaxSect - PH_FRINFC_MFSTD_FMT_VAL_2)))) {
+    memset(&Sector[PH_FRINFC_MFSTD_FMT_VAL_1],
+           PH_FRINFC_MFSTD_FMT_NON_NDEF_COMPL,
+           (NdefComplSectMax - PH_FRINFC_MFSTD_FMT_VAL_1));
+
+    memset(&Sector[(NdefComplSectMax + count)],
+           PH_FRINFC_MFSTD_FMT_NON_NDEF_COMPL,
+           (MaxSect - (NdefComplSectMax + count)));
+  }
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phFriNfc_MfStd_H_ProWrMADBlk
+**
+** Description      This function writes the finds MAD block values.
+**
+** Returns          NFCSTATUS_PENDING if successful
+**                  Other values if an error has occurred
+**
+*******************************************************************************/
+static NFCSTATUS phFriNfc_MfStd_H_ProWrMADBlk(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+
+  switch (NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock) {
+    case PH_FRINFC_MFSTD_FMT_VAL_1:
+      /* MAD blocks, still not completed */
+      NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_WR_MAD_BLK;
+      /* MAD block number 2 */
+      NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock = PH_FRINFC_MFSTD_FMT_VAL_2;
+      break;
+
+    case PH_FRINFC_MFSTD_FMT_VAL_2:
+      /* Now write to MAD block is completed */
+      NdefSmtCrdFmt->AddInfo.MfStdInfo.WrMADBlkFlag = PH_FRINFC_MFSTD_FMT_VAL_1;
+      /* Now write the sector trailer, so change the state */
+      NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_WR_SECT_TR;
+      /* MAD block number 3 = Sector trailer */
+      NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock = PH_FRINFC_MFSTD_FMT_VAL_3;
+      break;
+
+    case 64:
+      /* MAD blocks, still not completed */
+      NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_WR_MAD_BLK;
+      NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock = 65;
+      break;
+
+    case 65:
+      /* MAD blocks, still not completed */
+      NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_WR_MAD_BLK;
+      NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock = 66;
+      break;
+
+    case 66:
+    default:
+      /* Now write to MAD block is completed */
+      NdefSmtCrdFmt->AddInfo.MfStdInfo.WrMADBlkFlag = PH_FRINFC_MFSTD_FMT_VAL_1;
+      /* Now write the sector trailer, so change the state */
+      NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_WR_SECT_TR;
+      NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock = 67;
+      break;
+  }
+  /* Write the block */
+  Result = phFriNfc_MfStd_H_WrRdAuth(NdefSmtCrdFmt);
+
+  return Result;
+}
+
+/*******************************************************************************
+**
+** Function         phFriNfc_MfStd_H_ProErrAuth
+**
+** Description      This function shall process the error status of the
+*authentication.
+**
+** Returns          NFCSTATUS_PENDING if successful
+**                  Other values if an error has occurred
+**
+*******************************************************************************/
+static NFCSTATUS phFriNfc_MfStd_H_ProErrAuth(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt) {
+  NFCSTATUS Result = NdefSmtCrdFmt->FmtProcStatus;
+  uint8_t Buffer[1] = {PH_FRINFC_MFSTD_FMT_NDEF_COMPL},
+          index = PH_FRINFC_MFSTD_FMT_VAL_1;
+  uint32_t memcompare = PH_FRINFC_MFSTD_FMT_VAL_1;
+
+  if ((NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock == 67) &&
+      (NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState ==
+       PH_FRINFC_MFSTD_FMT_AUTH_SCRT_KEYB)) {
+    /* Error in the MAD sector 16, so the remaining sector
+     * information can't be updated
+     */
+    memset(&NdefSmtCrdFmt->AddInfo.MfStdInfo.SectCompl[16],
+           PH_FRINFC_MFSTD_FMT_NON_NDEF_COMPL,
+           (PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_4K - 16));
+    PH_FRINFC_MFSTD_FMT_CHK_END_OF_CARD();
+  } else if (((NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock >
+               PH_FRINFC_MFSTD_FMT_VAL_3) &&
+              (NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState !=
+               PH_FRINFC_MFSTD_FMT_AUTH_SCRT_KEYB)) ||
+             ((NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock ==
+               PH_FRINFC_MFSTD_FMT_VAL_3) &&
+              (NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState <
+               PH_FRINFC_MFSTD_FMT_AUTH_SCRT_KEYB))) {
+    /* Authenticate failed, so disconnect, poll and connect */
+    Result = phFriNfc_MfStd_H_CallDisCon(NdefSmtCrdFmt, Result);
+  } else {
+    if (NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock ==
+        PH_FRINFC_MFSTD_FMT_VAL_3) {
+      memset(NdefSmtCrdFmt->AddInfo.MfStdInfo.SectCompl,
+             PH_FRINFC_MFSTD_FMT_NON_NDEF_COMPL,
+             PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_4K);
+    }
+  }
+
+  return Result;
+}
+
+/*******************************************************************************
+**
+** Function         phFriNfc_MfStd_H_ProUpdMADBlk
+**
+** Description      This function shall process the error status of the writing
+*sector trailer.
+**
+** Returns          NFCSTATUS_PENDING if successful
+**                  Other values if an error has occurred
+**
+*******************************************************************************/
+static NFCSTATUS phFriNfc_MfStd_H_ProUpdMADBlk(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+  switch (NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk) {
+    case PH_FRINFC_MFSTD_FMT_MAD_BLK_1:
+      /* Write the next MAD Block */
+      NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk =
+          (uint8_t)PH_FRINFC_MFSTD_FMT_MAD_BLK_2;
+      NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock =
+          PH_FRINFC_MFSTD_FMT_MAD_BLK_2;
+      break;
+
+    case PH_FRINFC_MFSTD_FMT_MAD_BLK_2:
+    case PH_FRINFC_MFSTD_FMT_MAD_BLK_66:
+      if ((NdefSmtCrdFmt->CardType == PH_FRINFC_SMTCRDFMT_MFSTD_1K_CRD) ||
+          (NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock ==
+           PH_FRINFC_MFSTD_FMT_MAD_BLK_66)) {
+        /* Get the block from where the TLV has to be written */
+        phFriNfc_MfStd_H_BlkNoToWrTLV(NdefSmtCrdFmt);
+
+        NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_AUTH_SECT;
+        NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState =
+            PH_FRINFC_MFSTD_FMT_AUTH_NFC_KEY;
+      } else {
+        /* Write the next MAD Block */
+        NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk =
+            (uint8_t)PH_FRINFC_MFSTD_FMT_MAD_BLK_64;
+        NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock =
+            PH_FRINFC_MFSTD_FMT_MAD_BLK_64;
+        NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_AUTH_SECT;
+        NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState =
+            PH_FRINFC_MFSTD_FMT_AUTH_SCRT_KEYB;
+      }
+      break;
+
+    case PH_FRINFC_MFSTD_FMT_MAD_BLK_64:
+      /* Write the next MAD Block */
+      NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk =
+          (uint8_t)PH_FRINFC_MFSTD_FMT_MAD_BLK_65;
+      NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock =
+          PH_FRINFC_MFSTD_FMT_MAD_BLK_65;
+      break;
+
+    case PH_FRINFC_MFSTD_FMT_MAD_BLK_65:
+    default:
+      /* Write the next MAD Block */
+      NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk =
+          (uint8_t)PH_FRINFC_MFSTD_FMT_MAD_BLK_66;
+      NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock =
+          PH_FRINFC_MFSTD_FMT_MAD_BLK_66;
+      break;
+  }
+  Result = phFriNfc_MfStd_H_WrRdAuth(NdefSmtCrdFmt);
+  return Result;
+}
+
+/*******************************************************************************
+**
+** Function         phFriNfc_MfStd_H_StrNdefData
+**
+** Description      This function shall store ndef compliant in the MAD array
+**                  which will be later used for updating the MAD sector.
+**
+** Returns          none
+**
+*******************************************************************************/
+static void phFriNfc_MfStd_H_StrNdefData(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt) {
+  uint8_t SectIndex = PH_FRINFC_MFSTD_FMT_VAL_1,
+          index = PH_FRINFC_MFSTD_FMT_VAL_0;
+
+  memset(NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSectBlk, 0x00,
+         PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_4K);
+
+  /* Zeroth sector of the Mifare card is MAD sector, CRC is 0x14 */
+  NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSectBlk[PH_FRINFC_MFSTD_FMT_VAL_0] = 0x14;
+  /* Info byte is 0x01, because the NDEF application is written and as per the
+   * MAD spec,
+   * the value for miscellaneous application is 0x01
+   */
+  NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSectBlk[PH_FRINFC_MFSTD_FMT_VAL_1] = 0x01;
+
+  if ((NdefSmtCrdFmt->CardType == PH_FRINFC_SMTCRDFMT_MFSTD_4K_CRD) ||
+      (NdefSmtCrdFmt->CardType == PH_FRINFC_SMTCRDFMT_MFSTD_2K_CRD)) {
+    /* If 4k card then sector number 16 is MAD sector, CRC is 0xE8 */
+    NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSectBlk[32] = 0xE8;
+    /* Info byte is 0x01, because the NDEF application is written and
+     * as per the MAD spec,
+     * the value for miscellaneous application is 0x01
+     */
+    NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSectBlk[33] = 0x01;
+  }
+  /* NDEF information has to be updated from */
+  index = PH_FRINFC_MFSTD_FMT_VAL_2;
+  /* Depending on the card type, check the sector index */
+  while (((SectIndex < PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_4K) &&
+          (NdefSmtCrdFmt->CardType == PH_FRINFC_SMTCRDFMT_MFSTD_4K_CRD)) ||
+         ((SectIndex < PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_1K) &&
+          (NdefSmtCrdFmt->CardType == PH_FRINFC_SMTCRDFMT_MFSTD_1K_CRD)) ||
+         ((SectIndex < PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_2K) &&
+          (NdefSmtCrdFmt->CardType == PH_FRINFC_SMTCRDFMT_MFSTD_2K_CRD))) {
+    /* Is the sector ndef compliant? */
+    if (NdefSmtCrdFmt->AddInfo.MfStdInfo.SectCompl[SectIndex] ==
+        PH_FRINFC_MFSTD_FMT_NDEF_COMPL) {
+      /* Ndef compliant sector, update the MAD sector array
+       * in the context with values 0x03 and 0xE1
+       * 0x03 and 0xE1 is NDEF information in MAD sector
+       */
+      NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSectBlk[index] =
+          PH_FRINFC_MFSTD_FMT_NDEF_INFO1;
+      index++;
+      NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSectBlk[index] =
+          PH_FRINFC_MFSTD_FMT_NDEF_INFO2;
+      index++;
+    } else {
+      /* Not a Ndef compliant sector, update the MAD sector array
+       * in the context with values 0x00 and 0x00
+       * 0x00 and 0x00 is NDEF information in MAD sector
+       */
+      NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSectBlk[index] = 0x00;
+      index++;
+      NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSectBlk[index] = 0x00;
+      index++;
+    }
+    /* Go to next sector */
+    SectIndex++;
+    /* is the sector, a MAD sector 16? */
+    if (SectIndex == PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_1K) {
+      /* MAD sector number 16, so skip this sector */
+      SectIndex = SectIndex + PH_FRINFC_MFSTD_FMT_VAL_1;
+      index = index + PH_FRINFC_MFSTD_FMT_VAL_2;
+    }
+  }
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phFriNfc_MfStd_H_BlkNoToWrTLV
+**
+** Description      This function shall find the ndef compliant
+**                  and calculate the block number to write the NDEF TLV.
+**
+** Returns          none
+**
+*******************************************************************************/
+static void phFriNfc_MfStd_H_BlkNoToWrTLV(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt) {
+  uint8_t SectIndex = (uint8_t)PH_FRINFC_MFSTD_FMT_VAL_1;
+  while (((SectIndex < (uint8_t)PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_4K) &&
+          (NdefSmtCrdFmt->CardType ==
+           (uint8_t)PH_FRINFC_SMTCRDFMT_MFSTD_4K_CRD)) ||
+         ((SectIndex < (uint8_t)PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_1K) &&
+          (NdefSmtCrdFmt->CardType ==
+           (uint8_t)PH_FRINFC_SMTCRDFMT_MFSTD_1K_CRD)) ||
+         ((SectIndex < (uint8_t)PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_2K) &&
+          (NdefSmtCrdFmt->CardType ==
+           (uint8_t)PH_FRINFC_SMTCRDFMT_MFSTD_2K_CRD))) {
+    if (NdefSmtCrdFmt->AddInfo.MfStdInfo.SectCompl[SectIndex] ==
+        (uint8_t)PH_FRINFC_MFSTD_FMT_NDEF_COMPL) {
+      /* Get the first NFC forum sector's block */
+      NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock =
+          (uint16_t)(((SectIndex & 0xE0) >= 32)
+                         ? (128 + ((SectIndex % 32) * 16))
+                         : (SectIndex * (uint8_t)PH_FRINFC_MFSTD_FMT_VAL_4));
+      /* Break out of the loop */
+      SectIndex += (uint8_t)PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_4K;
+    }
+    SectIndex++;
+  }
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phFriNfc_MfStd_H_ErrRdSectTr
+**
+** Description      This function shall process the error status of the reading
+*sector trailer.
+**
+** Returns          NFCSTATUS_PENDING if successful
+**                  Other values if an error has occurred
+**
+*******************************************************************************/
+static NFCSTATUS phFriNfc_MfStd_H_ErrRdSectTr(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt) {
+  NFCSTATUS Result = NdefSmtCrdFmt->FmtProcStatus;
+  uint8_t Buffer[1] = {PH_FRINFC_MFSTD_FMT_NDEF_COMPL},
+          index = PH_FRINFC_MFSTD_FMT_VAL_1,
+          SectIndex = PH_FRINFC_MFSTD_FMT_VAL_0;
+  uint32_t memcompare = PH_FRINFC_MFSTD_FMT_VAL_1;
+  /* If default key A is used for authentication and if write fails, then try to
+   * authenticate using key B
+   */
+  if (NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState ==
+      PH_FRINFC_MFSTD_FMT_AUTH_DEF_KEY) {
+    /* Change the state to authentication */
+    NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_AUTH_SECT;
+    /* internal authenticate state = key B */
+    NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState = PH_FRINFC_MFSTD_FMT_AUTH_KEYB;
+    /* Now call authenticate */
+    Result = phFriNfc_MfStd_H_WrRdAuth(NdefSmtCrdFmt);
+  } else {
+    /* Calculate sector index */
+    SectIndex = (uint8_t)PH_FRINFC_MFSTD_FMT_SECT_INDEX_CALC;
+
+    /* Sector is ndef compliance */
+    NdefSmtCrdFmt->AddInfo.MfStdInfo.SectCompl[SectIndex] =
+        (uint8_t)((NdefSmtCrdFmt->FmtProcStatus != NFCSTATUS_SUCCESS)
+                      ? PH_FRINFC_MFSTD_FMT_NON_NDEF_COMPL
+                      : PH_FRINFC_MFSTD_FMT_NDEF_COMPL);
+
+    /* Increment the current block */
+    PH_FRINFC_MFSTD_FMT_CUR_BLK_INC();
+    SectIndex++;
+    if (PH_FRINFC_MFSTD_FMT_CUR_BLK_CHK) {
+      PH_FRINFC_MFSTD_FMT_CHK_END_OF_CARD();
+    } else {
+      /* Set the state */
+      NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_AUTH_SECT;
+      /* Set the authenticate state */
+      NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState =
+          PH_FRINFC_MFSTD_FMT_AUTH_DEF_KEY;
+      /* Start authentication */
+      Result = phFriNfc_MfStd_H_WrRdAuth(NdefSmtCrdFmt);
+    }
+  }
+  return Result;
+}
+
+/*******************************************************************************
+**
+** Function         phFriNfc_MfStd_MemCompare
+**
+** Description      This function shall process memory comparison.
+**
+** Returns          0 if memory is same
+**                  Not 0 if different
+**
+*******************************************************************************/
+static int phFriNfc_MfStd_MemCompare(void* s1, void* s2, unsigned int n) {
+  int8_t diff = 0;
+  int8_t* char_1 = (int8_t*)s1;
+  int8_t* char_2 = (int8_t*)s2;
+  if (NULL == s1 || NULL == s2) {
+    LOG(ERROR) << StringPrintf("NULL pointer passed to memcompare");
+  } else {
+    for (; ((n > 0) && (diff == 0)); n--, char_1++, char_2++) {
+      diff = *char_1 - *char_2;
+    }
+  }
+  return (int)diff;
+}
diff --git a/nci/jni/extns/pn54x/src/mifare/phFriNfc_MifStdFormat.h b/nci/jni/extns/pn54x/src/mifare/phFriNfc_MifStdFormat.h
index ac58453d..eabcf045 100644
--- a/nci/jni/extns/pn54x/src/mifare/phFriNfc_MifStdFormat.h
+++ b/nci/jni/extns/pn54x/src/mifare/phFriNfc_MifStdFormat.h
@@ -22,319 +22,327 @@
 #define PHFRINFC_MIFSTDFORMAT_H
 
 #include <phFriNfc.h>
+#include <phFriNfc_SmtCrdFmt.h>
 #include <phNfcStatus.h>
 #include <phNfcTypes.h>
-#include <phFriNfc_SmtCrdFmt.h>
 
 /********************* Definitions and structures *****************************/
 
 /*
  * Mifare standard -progress states
  */
-#define PH_FRINFC_MFSTD_FMT_RESET_INIT          0   /* Reset state */
-#define PH_FRINFC_MFSTD_FMT_AUTH_SECT           1   /* Sector authentication is in progress */
-#define PH_FRINFC_MFSTD_FMT_DIS_CON             2   /* Disconnect is in progress */
-#define PH_FRINFC_MFSTD_FMT_CON                 3   /* Connect is in progress */
-#define PH_FRINFC_MFSTD_FMT_POLL                4   /* Poll is in progress */
-#define PH_FRINFC_MFSTD_FMT_RD_SECT_TR          5   /* Read sector trailer is in progress */
-#define PH_FRINFC_MFSTD_FMT_WR_SECT_TR          6   /* Write sector trailer is in progress */
-#define PH_FRINFC_MFSTD_FMT_WR_TLV              7   /* Write sector trailer is in progress */
-#define PH_FRINFC_MFSTD_FMT_WR_MAD_BLK          8   /* Write MAD is in progress */
-#define PH_FRINFC_MFSTD_FMT_UPD_MAD_BLK         9   /* Write MAD is in progress */
+#define PH_FRINFC_MFSTD_FMT_RESET_INIT 0 /* Reset state */
+#define PH_FRINFC_MFSTD_FMT_AUTH_SECT \
+  1                                   /* Sector authentication is in progress */
+#define PH_FRINFC_MFSTD_FMT_DIS_CON 2 /* Disconnect is in progress */
+#define PH_FRINFC_MFSTD_FMT_CON 3     /* Connect is in progress */
+#define PH_FRINFC_MFSTD_FMT_POLL 4    /* Poll is in progress */
+#define PH_FRINFC_MFSTD_FMT_RD_SECT_TR \
+  5 /* Read sector trailer is in progress */
+#define PH_FRINFC_MFSTD_FMT_WR_SECT_TR \
+  6                                  /* Write sector trailer is in progress */
+#define PH_FRINFC_MFSTD_FMT_WR_TLV 7 /* Write sector trailer is in progress */
+#define PH_FRINFC_MFSTD_FMT_WR_MAD_BLK 8  /* Write MAD is in progress */
+#define PH_FRINFC_MFSTD_FMT_UPD_MAD_BLK 9 /* Write MAD is in progress */
 
 /*
  * Mifare standard -Authenticate states
  */
-#define PH_FRINFC_MFSTD_FMT_AUTH_DEF_KEY        0   /* Trying to authenticate with the default key */
-#define PH_FRINFC_MFSTD_FMT_AUTH_NFC_KEY        1   /* Trying to authenticate with the MAD key */
-#define PH_FRINFC_MFSTD_FMT_AUTH_MAD_KEY        2   /* Trying to authenticate with the NFC forum key */
-#define PH_FRINFC_MFSTD_FMT_AUTH_KEYB           3   /* Trying to authenticate with key B */
-#define PH_FRINFC_MFSTD_FMT_AUTH_SCRT_KEYB      4   /* Trying to authenticate with secret key B */
+#define PH_FRINFC_MFSTD_FMT_AUTH_DEF_KEY \
+  0 /* Trying to authenticate with the default key */
+#define PH_FRINFC_MFSTD_FMT_AUTH_NFC_KEY \
+  1 /* Trying to authenticate with the MAD key */
+#define PH_FRINFC_MFSTD_FMT_AUTH_MAD_KEY \
+  2 /* Trying to authenticate with the NFC forum key */
+#define PH_FRINFC_MFSTD_FMT_AUTH_KEYB    \
+  3 /* Trying to authenticate with key B \
+     */
+#define PH_FRINFC_MFSTD_FMT_AUTH_SCRT_KEYB \
+  4 /* Trying to authenticate with secret key B */
 
 /*
  * Mifare standard - Update MAD block flag
  */
-#define PH_FRINFC_MFSTD_FMT_NOT_A_MAD_BLK       0   /* Not a MAD block */
-#define PH_FRINFC_MFSTD_FMT_MAD_BLK_1           1   /* MAD block number 1 */
-#define PH_FRINFC_MFSTD_FMT_MAD_BLK_2           2   /* MAD block number 2 */
-#define PH_FRINFC_MFSTD_FMT_MAD_BLK_64          64  /* MAD block number 64 (only used for Mifare 4k card) */
-#define PH_FRINFC_MFSTD_FMT_MAD_BLK_65          65  /* MAD block number 65 (only used for Mifare 4k card) */
-#define PH_FRINFC_MFSTD_FMT_MAD_BLK_66          66  /* MAD block number 66 (only used for Mifare 4k card) */
+#define PH_FRINFC_MFSTD_FMT_NOT_A_MAD_BLK 0 /* Not a MAD block */
+#define PH_FRINFC_MFSTD_FMT_MAD_BLK_1 1     /* MAD block number 1 */
+#define PH_FRINFC_MFSTD_FMT_MAD_BLK_2 2     /* MAD block number 2 */
+#define PH_FRINFC_MFSTD_FMT_MAD_BLK_64 \
+  64 /* MAD block number 64 (only used for Mifare 4k card) */
+#define PH_FRINFC_MFSTD_FMT_MAD_BLK_65 \
+  65 /* MAD block number 65 (only used for Mifare 4k card) */
+#define PH_FRINFC_MFSTD_FMT_MAD_BLK_66 \
+  66 /* MAD block number 66 (only used for Mifare 4k card) */
 
 /*
  * Mifare standard - Update MAD block flag
-*/
-#define  PH_FRINFC_SMTCRDFMT_MSTD_MADSECT_KEYA_ACS_BIT_1K        {0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0x78,0x77,0x88,0xC1}
-#define  PH_FRINFC_SMTCRDFMT_MSTD_MADSECT_KEYA_ACS_BIT_2K        {0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0x78,0x77,0x88,0xC1}
-#define  PH_FRINFC_SMTCRDFMT_MSTD_MADSECT_KEYA_ACS_BIT_4K        {0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0x78,0x77,0x88,0xC2}
-#define  PH_FRINFC_SMTCRDFMT_NFCFORUMSECT_KEYA_ACS_BIT           {0xD3,0xF7,0xD3,0xF7,0xD3,0xF7,0x7F,0x07,0x88,0x40}
+ */
+#define PH_FRINFC_SMTCRDFMT_MSTD_MADSECT_KEYA_ACS_BIT_1K \
+  { 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0x78, 0x77, 0x88, 0xC1 }
+#define PH_FRINFC_SMTCRDFMT_MSTD_MADSECT_KEYA_ACS_BIT_2K \
+  { 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0x78, 0x77, 0x88, 0xC1 }
+#define PH_FRINFC_SMTCRDFMT_MSTD_MADSECT_KEYA_ACS_BIT_4K \
+  { 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0x78, 0x77, 0x88, 0xC2 }
+#define PH_FRINFC_SMTCRDFMT_NFCFORUMSECT_KEYA_ACS_BIT \
+  { 0xD3, 0xF7, 0xD3, 0xF7, 0xD3, 0xF7, 0x7F, 0x07, 0x88, 0x40 }
 
 /*
  * Mifare standard - Key and access bit constants
  */
-#define PH_FRINFC_MFSTD_FMT_NFC_SECT_KEYA0      0xD3    /* NFC forum sector key A */
-#define PH_FRINFC_MFSTD_FMT_NFC_SECT_KEYA1      0xF7    /* NFC forum sector key A */
-
-#define PH_FRINFC_MFSTD_FMT_MAD_SECT_KEYA0      0xA0    /* MAD sector key A */
-#define PH_FRINFC_MFSTD_FMT_MAD_SECT_KEYA1      0xA1    /* MAD sector key A */
-#define PH_FRINFC_MFSTD_FMT_MAD_SECT_KEYA2      0xA2    /* MAD sector key A */
-#define PH_FRINFC_MFSTD_FMT_MAD_SECT_KEYA3      0xA3    /* MAD sector key A */
-#define PH_FRINFC_MFSTD_FMT_MAD_SECT_KEYA4      0xA4    /* MAD sector key A */
-#define PH_FRINFC_MFSTD_FMT_MAD_SECT_KEYA5      0xA5    /* MAD sector key A */
-
-#define PH_FRINFC_MFSTD_FMT_DEFAULT_KEY         0xFF    /* Default key A or B */
-
-#define PH_FRINFC_MFSTD_FMT_MAD_SECT_ACS6       0x78    /* MAD sector access bits 6 */
-#define PH_FRINFC_MFSTD_FMT_MAD_SECT_ACS7       0x77    /* MAD sector access bits 7 */
-#define PH_FRINFC_MFSTD_FMT_MAD_SECT_ACS8       0x88    /* MAD sector access bits 8 */
-#define PH_FRINFC_MFSTD_FMT_MAD_SECT_GPB        0xC1    /* MAD sector GPB */
-
-#define PH_FRINFC_MFSTD_FMT_NFC_SECT_ACS_RW6    0x7F    /* NFC forum sector access bits 6 for read write */
-#define PH_FRINFC_MFSTD_FMT_NFC_SECT_ACS_RW7    0x07    /* NFC forum sector access bits 7 for read write */
-#define PH_FRINFC_MFSTD_FMT_NFC_SECT_ACS_RW8    0x88    /* NFC forum sector access bits 8 for read write */
-#define PH_FRINFC_MFSTD_FMT_NFC_SECT_GPB_RW     0x40    /* NFC forum sector GPB for read write */
-
-#define PH_FRINFC_MFSTD_FMT_NFC_SECT_ACS_RO6    0x07    /* NFC forum sector access bits 6 for read only */
-#define PH_FRINFC_MFSTD_FMT_NFC_SECT_ACS_RO7    0x8F    /* NFC forum sector access bits 7 for read only */
-#define PH_FRINFC_MFSTD_FMT_NFC_SECT_ACS_RO8    0x0F    /* NFC forum sector access bits 8 for read only */
-#define PH_FRINFC_MFSTD_FMT_NFC_SECT_GPB_R0     0x43    /* NFC forum sector GPB for read only */
+#define PH_FRINFC_MFSTD_FMT_NFC_SECT_KEYA0 0xD3 /* NFC forum sector key A */
+#define PH_FRINFC_MFSTD_FMT_NFC_SECT_KEYA1 0xF7 /* NFC forum sector key A */
+
+#define PH_FRINFC_MFSTD_FMT_MAD_SECT_KEYA0 0xA0 /* MAD sector key A */
+#define PH_FRINFC_MFSTD_FMT_MAD_SECT_KEYA1 0xA1 /* MAD sector key A */
+#define PH_FRINFC_MFSTD_FMT_MAD_SECT_KEYA2 0xA2 /* MAD sector key A */
+#define PH_FRINFC_MFSTD_FMT_MAD_SECT_KEYA3 0xA3 /* MAD sector key A */
+#define PH_FRINFC_MFSTD_FMT_MAD_SECT_KEYA4 0xA4 /* MAD sector key A */
+#define PH_FRINFC_MFSTD_FMT_MAD_SECT_KEYA5 0xA5 /* MAD sector key A */
+
+#define PH_FRINFC_MFSTD_FMT_DEFAULT_KEY 0xFF /* Default key A or B */
+
+#define PH_FRINFC_MFSTD_FMT_MAD_SECT_ACS6 0x78 /* MAD sector access bits 6 */
+#define PH_FRINFC_MFSTD_FMT_MAD_SECT_ACS7 0x77 /* MAD sector access bits 7 */
+#define PH_FRINFC_MFSTD_FMT_MAD_SECT_ACS8 0x88 /* MAD sector access bits 8 */
+#define PH_FRINFC_MFSTD_FMT_MAD_SECT_GPB 0xC1  /* MAD sector GPB */
+
+#define PH_FRINFC_MFSTD_FMT_NFC_SECT_ACS_RW6 \
+  0x7F /* NFC forum sector access bits 6 for read write */
+#define PH_FRINFC_MFSTD_FMT_NFC_SECT_ACS_RW7 \
+  0x07 /* NFC forum sector access bits 7 for read write */
+#define PH_FRINFC_MFSTD_FMT_NFC_SECT_ACS_RW8 \
+  0x88 /* NFC forum sector access bits 8 for read write */
+#define PH_FRINFC_MFSTD_FMT_NFC_SECT_GPB_RW \
+  0x40 /* NFC forum sector GPB for read write */
+
+#define PH_FRINFC_MFSTD_FMT_NFC_SECT_ACS_RO6 \
+  0x07 /* NFC forum sector access bits 6 for read only */
+#define PH_FRINFC_MFSTD_FMT_NFC_SECT_ACS_RO7 \
+  0x8F /* NFC forum sector access bits 7 for read only */
+#define PH_FRINFC_MFSTD_FMT_NFC_SECT_ACS_RO8 \
+  0x0F /* NFC forum sector access bits 8 for read only */
+#define PH_FRINFC_MFSTD_FMT_NFC_SECT_GPB_R0 \
+  0x43 /* NFC forum sector GPB for read only */
 
 /*
  * Enum definition contains Mifare standard values
  */
-typedef enum{
-PH_FRINFC_MFSTD_FMT_VAL_0,
-PH_FRINFC_MFSTD_FMT_VAL_1,
-PH_FRINFC_MFSTD_FMT_VAL_2,
-PH_FRINFC_MFSTD_FMT_VAL_3,
-PH_FRINFC_MFSTD_FMT_VAL_4,
-PH_FRINFC_MFSTD_FMT_VAL_5,
-PH_FRINFC_MFSTD_FMT_VAL_6,
-PH_FRINFC_MFSTD_FMT_VAL_7,
-PH_FRINFC_MFSTD_FMT_VAL_8,
-PH_FRINFC_MFSTD_FMT_VAL_9,
-PH_FRINFC_MFSTD_FMT_VAL_10,
-PH_FRINFC_MFSTD_FMT_VAL_11
-}phFriNfc_MfStdVal;
+typedef enum {
+  PH_FRINFC_MFSTD_FMT_VAL_0,
+  PH_FRINFC_MFSTD_FMT_VAL_1,
+  PH_FRINFC_MFSTD_FMT_VAL_2,
+  PH_FRINFC_MFSTD_FMT_VAL_3,
+  PH_FRINFC_MFSTD_FMT_VAL_4,
+  PH_FRINFC_MFSTD_FMT_VAL_5,
+  PH_FRINFC_MFSTD_FMT_VAL_6,
+  PH_FRINFC_MFSTD_FMT_VAL_7,
+  PH_FRINFC_MFSTD_FMT_VAL_8,
+  PH_FRINFC_MFSTD_FMT_VAL_9,
+  PH_FRINFC_MFSTD_FMT_VAL_10,
+  PH_FRINFC_MFSTD_FMT_VAL_11
+} phFriNfc_MfStdVal;
 
 /*
  * Mifare standard - NDEF information constants
  */
-#define PH_FRINFC_MFSTD_FMT_NON_NDEF_COMPL    0       /* Sector is not ndef compliant */
-#define PH_FRINFC_MFSTD_FMT_NDEF_COMPL        1       /* Sector is ndef compliant */
-#define PH_FRINFC_MFSTD_FMT_NDEF_INFO1        0x03    /* If sector is ndef compliant, then one of the MAD
-                                                        sector byte is 0x03 */
-#define PH_FRINFC_MFSTD_FMT_NDEF_INFO2        0xE1    /* If sector is ndef compliant, then one of the MAD
-                                                        sector byte is 0xE1 */
+#define PH_FRINFC_MFSTD_FMT_NON_NDEF_COMPL                               \
+  0                                      /* Sector is not ndef compliant \
+                                          */
+#define PH_FRINFC_MFSTD_FMT_NDEF_COMPL 1 /* Sector is ndef compliant */
+#define PH_FRINFC_MFSTD_FMT_NDEF_INFO1                     \
+  0x03 /* If sector is ndef compliant, then one of the MAD \
+         sector byte is 0x03 */
+#define PH_FRINFC_MFSTD_FMT_NDEF_INFO2                     \
+  0xE1 /* If sector is ndef compliant, then one of the MAD \
+         sector byte is 0xE1 */
 
 /*
  * Mifare standard - constants
  */
-#define PH_FRINFC_MFSTD_FMT_MAX_RECV_LENGTH     252 /* Maximum receive length */
-#define PH_FRINFC_MFSTD_FMT_WR_SEND_LENGTH      17  /* Send length for write */
-#define PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_1K     16  /* Maximum sector index for Mifare 1k = 16 */
-#define PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_2K     32  /* Maximum sector index for Mifare 2k = 32 */
-#define PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_4K     40  /* Maximum sector index for Mifare 4k = 40 */
-#define PH_FRINFC_MFSTD_FMT_MAX_BLOCKS_1K       64  /* Maximum Number of Blocks for Mifare 1k = 64 */
-#define PH_FRINFC_MFSTD_FMT_MAX_BLOCKS_2K       128 /* Maximum Number of Blocks for Mifare 2k = 128 */
-#define PH_FRINFC_MFSTD_FMT_MAX_BLOCKS_4K       256 /* Maximum Number of Blocks for Mifare 4k = 256*/
+#define PH_FRINFC_MFSTD_FMT_MAX_RECV_LENGTH 252 /* Maximum receive length */
+#define PH_FRINFC_MFSTD_FMT_WR_SEND_LENGTH 17   /* Send length for write */
+#define PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_1K \
+  16 /* Maximum sector index for Mifare 1k = 16 */
+#define PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_2K \
+  32 /* Maximum sector index for Mifare 2k = 32 */
+#define PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_4K \
+  40 /* Maximum sector index for Mifare 4k = 40 */
+#define PH_FRINFC_MFSTD_FMT_MAX_BLOCKS_1K \
+  64 /* Maximum Number of Blocks for Mifare 1k = 64 */
+#define PH_FRINFC_MFSTD_FMT_MAX_BLOCKS_2K \
+  128 /* Maximum Number of Blocks for Mifare 2k = 128 */
+#define PH_FRINFC_MFSTD_FMT_MAX_BLOCKS_4K \
+  256 /* Maximum Number of Blocks for Mifare 4k = 256*/
 
 /*
  * Copy default keyA to send buffer
  */
-#define PH_FRINFC_MFSTD_FMT_AUTH_SEND_BUF_DEF(mem)\
-do\
-{\
-    memset(&NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1],\
-                PH_FRINFC_MFSTD_FMT_DEFAULT_KEY,\
-                PH_FRINFC_MFSTD_FMT_VAL_6);\
+#define PH_FRINFC_MFSTD_FMT_AUTH_SEND_BUF_DEF(mem)                             \
+  do {                                                                         \
+    memset(&NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1],             \
+           PH_FRINFC_MFSTD_FMT_DEFAULT_KEY, PH_FRINFC_MFSTD_FMT_VAL_6);        \
     NdefSmtCrdFmt->Cmd.MfCmd = ((NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState == \
-            PH_FRINFC_MFSTD_FMT_AUTH_DEF_KEY)? \
-            phHal_eMifareAuthentA: \
-            phHal_eMifareAuthentB); \
-    NdefSmtCrdFmt->SendLength = PH_FRINFC_MFSTD_FMT_VAL_7; \
-}while(0)
+                                 PH_FRINFC_MFSTD_FMT_AUTH_DEF_KEY)             \
+                                    ? phHal_eMifareAuthentA                    \
+                                    : phHal_eMifareAuthentB);                  \
+    NdefSmtCrdFmt->SendLength = PH_FRINFC_MFSTD_FMT_VAL_7;                     \
+  } while (0)
 
 /*
  * NFC forum sector keyA to send buffer
  */
-#define PH_FRINFC_MFSTD_FMT_AUTH_SEND_BUF_NFCSECT_KEYA(mem)\
-do \
-{\
-    memcpy(&NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1],\
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.NFCForumSect_KeyA,\
-        PH_FRINFC_MFSTD_FMT_VAL_6);\
-        NdefSmtCrdFmt->Cmd.MfCmd = phHal_eMifareAuthentA;\
-        NdefSmtCrdFmt->SendLength = PH_FRINFC_MFSTD_FMT_VAL_7;\
-} while(0)
+#define PH_FRINFC_MFSTD_FMT_AUTH_SEND_BUF_NFCSECT_KEYA(mem)        \
+  do {                                                             \
+    memcpy(&NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1], \
+           NdefSmtCrdFmt->AddInfo.MfStdInfo.NFCForumSect_KeyA,     \
+           PH_FRINFC_MFSTD_FMT_VAL_6);                             \
+    NdefSmtCrdFmt->Cmd.MfCmd = phHal_eMifareAuthentA;              \
+    NdefSmtCrdFmt->SendLength = PH_FRINFC_MFSTD_FMT_VAL_7;         \
+  } while (0)
 
 /*
  * Copy MAD sector keyA to send buffer
  */
-#define PH_FRINFC_MFSTD_FMT_AUTH_SEND_BUF_MADSECT_KEYA(mem)\
-do \
-{\
-    memcpy(&NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1],\
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSect_KeyA,\
-        PH_FRINFC_MFSTD_FMT_VAL_6);\
-        NdefSmtCrdFmt->Cmd.MfCmd = phHal_eMifareAuthentA;\
-        NdefSmtCrdFmt->SendLength = PH_FRINFC_MFSTD_FMT_VAL_7;\
-} while(0)
+#define PH_FRINFC_MFSTD_FMT_AUTH_SEND_BUF_MADSECT_KEYA(mem)        \
+  do {                                                             \
+    memcpy(&NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1], \
+           NdefSmtCrdFmt->AddInfo.MfStdInfo.MADSect_KeyA,          \
+           PH_FRINFC_MFSTD_FMT_VAL_6);                             \
+    NdefSmtCrdFmt->Cmd.MfCmd = phHal_eMifareAuthentA;              \
+    NdefSmtCrdFmt->SendLength = PH_FRINFC_MFSTD_FMT_VAL_7;         \
+  } while (0)
 
 /*
  * Copy MAD sector keyB to send buffer
  */
-#define PH_FRINFC_MFSTD_FMT_AUTH_SEND_BUF_SCRT_KEY(mem) \
-do \
-{\
-    (void)memcpy(&NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1],\
-               NdefSmtCrdFmt->AddInfo.MfStdInfo.ScrtKeyB,\
-               PH_FRINFC_MFSTD_FMT_VAL_6);\
-               NdefSmtCrdFmt->Cmd.MfCmd = phHal_eMifareAuthentB;\
-               NdefSmtCrdFmt->SendLength = PH_FRINFC_MFSTD_FMT_VAL_7;\
-} while(0)
+#define PH_FRINFC_MFSTD_FMT_AUTH_SEND_BUF_SCRT_KEY(mem)                  \
+  do {                                                                   \
+    (void)memcpy(&NdefSmtCrdFmt->SendRecvBuf[PH_FRINFC_MFSTD_FMT_VAL_1], \
+                 NdefSmtCrdFmt->AddInfo.MfStdInfo.ScrtKeyB,              \
+                 PH_FRINFC_MFSTD_FMT_VAL_6);                             \
+    NdefSmtCrdFmt->Cmd.MfCmd = phHal_eMifareAuthentB;                    \
+    NdefSmtCrdFmt->SendLength = PH_FRINFC_MFSTD_FMT_VAL_7;               \
+  } while (0)
 
 /*
  * Get the next block
  */
-#define PH_FRINFC_MFSTD_FMT_CUR_BLK_INC() \
-                    NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock += \
-                        ((NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock >= 127)?\
-                        16:4)
+#define PH_FRINFC_MFSTD_FMT_CUR_BLK_INC()          \
+  NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock += \
+      ((NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock >= 127) ? 16 : 4)
 
 /*
  * Get the sector index
  */
-#define PH_FRINFC_MFSTD_FMT_SECT_INDEX_CALC \
-                    ((NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock >= 128)?\
-                    (32 + ((NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock - 128)/16)):\
-                    (NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock/4))
+#define PH_FRINFC_MFSTD_FMT_SECT_INDEX_CALC                                  \
+  ((NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock >= 128)                    \
+       ? (32 + ((NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock - 128) / 16)) \
+       : (NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock / 4))
 
 /*
  * Check the sector block
  */
-#define PH_FRINFC_MFSTD_FMT_CUR_BLK_CHK\
-                    (((NdefSmtCrdFmt->CardType == PH_FRINFC_SMTCRDFMT_MFSTD_1K_CRD) && \
-                    (NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock >= \
-                    PH_FRINFC_MFSTD_FMT_MAX_BLOCKS_1K)) || \
-                    ((NdefSmtCrdFmt->CardType == PH_FRINFC_SMTCRDFMT_MFSTD_4K_CRD) && \
-                    (NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock >= \
-                    PH_FRINFC_MFSTD_FMT_MAX_BLOCKS_4K)) || \
-                    ((NdefSmtCrdFmt->CardType == PH_FRINFC_SMTCRDFMT_MFSTD_2K_CRD) && \
-                    (NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock >= \
-                    PH_FRINFC_MFSTD_FMT_MAX_BLOCKS_2K)))
+#define PH_FRINFC_MFSTD_FMT_CUR_BLK_CHK                              \
+  (((NdefSmtCrdFmt->CardType == PH_FRINFC_SMTCRDFMT_MFSTD_1K_CRD) && \
+    (NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock >=                \
+     PH_FRINFC_MFSTD_FMT_MAX_BLOCKS_1K)) ||                          \
+   ((NdefSmtCrdFmt->CardType == PH_FRINFC_SMTCRDFMT_MFSTD_4K_CRD) && \
+    (NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock >=                \
+     PH_FRINFC_MFSTD_FMT_MAX_BLOCKS_4K)) ||                          \
+   ((NdefSmtCrdFmt->CardType == PH_FRINFC_SMTCRDFMT_MFSTD_2K_CRD) && \
+    (NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock >=                \
+     PH_FRINFC_MFSTD_FMT_MAX_BLOCKS_2K)))
 
 /*
  * Get the next authenticate state
  */
-#define PH_FRINFC_MFSTD_FMT_NXT_AUTH_STATE() \
-do \
-{\
-    switch(NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState)\
-    {\
-        case PH_FRINFC_MFSTD_FMT_AUTH_DEF_KEY:\
-        {\
-            NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState = (uint8_t) \
-                ((((NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock <= 3) || \
-                ((NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock > 63) && \
-                (NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock < 67))))? \
-                PH_FRINFC_MFSTD_FMT_AUTH_MAD_KEY: \
-                PH_FRINFC_MFSTD_FMT_AUTH_NFC_KEY);\
-        }\
-        break;\
-        case PH_FRINFC_MFSTD_FMT_AUTH_NFC_KEY:\
-        {\
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState = \
-                            PH_FRINFC_MFSTD_FMT_AUTH_KEYB;\
-        }\
-        break;\
-        case PH_FRINFC_MFSTD_FMT_AUTH_MAD_KEY:\
-        {\
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState = \
-                        PH_FRINFC_MFSTD_FMT_AUTH_NFC_KEY;\
-        }\
-        break;\
-        case PH_FRINFC_MFSTD_FMT_AUTH_KEYB:\
-        { \
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState = \
-                        PH_FRINFC_MFSTD_FMT_AUTH_SCRT_KEYB;\
-        } \
-        break;\
-        case PH_FRINFC_MFSTD_FMT_AUTH_SCRT_KEYB:\
-        default:\
-        { \
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState = \
-                        PH_FRINFC_MFSTD_FMT_AUTH_DEF_KEY;\
-        }\
-        break;\
-    }\
-} while(0)
-
+#define PH_FRINFC_MFSTD_FMT_NXT_AUTH_STATE()                           \
+  do {                                                                 \
+    switch (NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState) {              \
+      case PH_FRINFC_MFSTD_FMT_AUTH_DEF_KEY: {                         \
+        NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState = (uint8_t)(        \
+            (((NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock <= 3) ||  \
+              ((NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock > 63) && \
+               (NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock < 67)))) \
+                ? PH_FRINFC_MFSTD_FMT_AUTH_MAD_KEY                     \
+                : PH_FRINFC_MFSTD_FMT_AUTH_NFC_KEY);                   \
+      } break;                                                         \
+      case PH_FRINFC_MFSTD_FMT_AUTH_NFC_KEY: {                         \
+        NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState =                   \
+            PH_FRINFC_MFSTD_FMT_AUTH_KEYB;                             \
+      } break;                                                         \
+      case PH_FRINFC_MFSTD_FMT_AUTH_MAD_KEY: {                         \
+        NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState =                   \
+            PH_FRINFC_MFSTD_FMT_AUTH_NFC_KEY;                          \
+      } break;                                                         \
+      case PH_FRINFC_MFSTD_FMT_AUTH_KEYB: {                            \
+        NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState =                   \
+            PH_FRINFC_MFSTD_FMT_AUTH_SCRT_KEYB;                        \
+      } break;                                                         \
+      case PH_FRINFC_MFSTD_FMT_AUTH_SCRT_KEYB:                         \
+      default: {                                                       \
+        NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState =                   \
+            PH_FRINFC_MFSTD_FMT_AUTH_DEF_KEY;                          \
+      } break;                                                         \
+    }                                                                  \
+  } while (0)
 
 /*
  * Increment the sector index
  */
-#define PH_FRINFC_MFSTD_FMT_INCR_SECT \
-do \
-{\
-    SectIndex++;\
-    SectIndex = (uint8_t)((SectIndex == 16)?\
-                        (SectIndex + PH_FRINFC_MFSTD_FMT_VAL_1):\
-                        SectIndex);\
-} while(0)
-
+#define PH_FRINFC_MFSTD_FMT_INCR_SECT                                         \
+  do {                                                                        \
+    SectIndex++;                                                              \
+    SectIndex =                                                               \
+        (uint8_t)((SectIndex == 16) ? (SectIndex + PH_FRINFC_MFSTD_FMT_VAL_1) \
+                                    : SectIndex);                             \
+  } while (0)
 
 /*
  * Increment the sector index
  */
-#define PH_FRINFC_MFSTD_FMT_CHK_SECT_ARRAY \
-do \
-{\
-    while ((index < PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_4K) && \
-            (memcompare != PH_FRINFC_MFSTD_FMT_VAL_0))\
-    {\
-        /* Compare any one among the sectors is NDEF COMPLIANT */\
-        memcompare = (uint32_t)phFriNfc_MfStd_MemCompare(&Buffer[PH_FRINFC_MFSTD_FMT_VAL_0], \
-        &NdefSmtCrdFmt->AddInfo.MfStdInfo.SectCompl[index],\
-        PH_FRINFC_MFSTD_FMT_VAL_1);\
-        /* increment the index */\
-        index += (uint8_t)((index == (PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_1K - \
-                            PH_FRINFC_MFSTD_FMT_VAL_1))?\
-                            PH_FRINFC_MFSTD_FMT_VAL_2:\
-                            PH_FRINFC_MFSTD_FMT_VAL_1);\
-    }\
-} while(0)
+#define PH_FRINFC_MFSTD_FMT_CHK_SECT_ARRAY                                \
+  do {                                                                    \
+    while ((index < PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_4K) &&               \
+           (memcompare != PH_FRINFC_MFSTD_FMT_VAL_0)) {                   \
+      /* Compare any one among the sectors is NDEF COMPLIANT */           \
+      memcompare = (uint32_t)phFriNfc_MfStd_MemCompare(                   \
+          &Buffer[PH_FRINFC_MFSTD_FMT_VAL_0],                             \
+          &NdefSmtCrdFmt->AddInfo.MfStdInfo.SectCompl[index],             \
+          PH_FRINFC_MFSTD_FMT_VAL_1);                                     \
+      /* increment the index */                                           \
+      index += (uint8_t)((index == (PH_FRINFC_MFSTD_FMT_MAX_SECT_IND_1K - \
+                                    PH_FRINFC_MFSTD_FMT_VAL_1))           \
+                             ? PH_FRINFC_MFSTD_FMT_VAL_2                  \
+                             : PH_FRINFC_MFSTD_FMT_VAL_1);                \
+    }                                                                     \
+  } while (0)
 
 /*
  * Complete the sector
  */
-#define PH_FRINFC_MFSTD_FMT_CHK_END_OF_CARD() \
-do \
-{ \
-    phFriNfc_MfStd_H_NdefComplSect(NdefSmtCrdFmt->CardType, \
-                                NdefSmtCrdFmt->AddInfo.MfStdInfo.SectCompl); \
-    PH_FRINFC_MFSTD_FMT_CHK_SECT_ARRAY; \
-    if(memcompare == PH_FRINFC_MFSTD_FMT_VAL_0) \
-    { \
-        phFriNfc_MfStd_H_StrNdefData(NdefSmtCrdFmt); \
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock = \
-                                PH_FRINFC_MFSTD_FMT_VAL_1; \
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk = \
-            PH_FRINFC_MFSTD_FMT_MAD_BLK_1; \
-        NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState = \
-            PH_FRINFC_MFSTD_FMT_AUTH_SCRT_KEYB; \
-        NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_AUTH_SECT; \
-        Result = phFriNfc_MfStd_H_WrRdAuth(NdefSmtCrdFmt); \
-    } \
-    else \
-    { \
-        Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_SMTCRDFMT, \
-                            NFCSTATUS_FORMAT_ERROR); \
-    } \
-} while(0)
-
-void phFriNfc_MfStd_Reset(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt);
-NFCSTATUS phFriNfc_MfStd_Format(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt, const uint8_t *ScrtKeyB);
-void phFriNfc_MfStd_Process(void *Context, NFCSTATUS Status);
+#define PH_FRINFC_MFSTD_FMT_CHK_END_OF_CARD()                                  \
+  do {                                                                         \
+    phFriNfc_MfStd_H_NdefComplSect(                                            \
+        NdefSmtCrdFmt->CardType, NdefSmtCrdFmt->AddInfo.MfStdInfo.SectCompl);  \
+    PH_FRINFC_MFSTD_FMT_CHK_SECT_ARRAY;                                        \
+    if (memcompare == PH_FRINFC_MFSTD_FMT_VAL_0) {                             \
+      phFriNfc_MfStd_H_StrNdefData(NdefSmtCrdFmt);                             \
+      NdefSmtCrdFmt->AddInfo.MfStdInfo.CurrentBlock =                          \
+          PH_FRINFC_MFSTD_FMT_VAL_1;                                           \
+      NdefSmtCrdFmt->AddInfo.MfStdInfo.UpdMADBlk =                             \
+          PH_FRINFC_MFSTD_FMT_MAD_BLK_1;                                       \
+      NdefSmtCrdFmt->AddInfo.MfStdInfo.AuthState =                             \
+          PH_FRINFC_MFSTD_FMT_AUTH_SCRT_KEYB;                                  \
+      NdefSmtCrdFmt->State = PH_FRINFC_MFSTD_FMT_AUTH_SECT;                    \
+      Result = phFriNfc_MfStd_H_WrRdAuth(NdefSmtCrdFmt);                       \
+    } else {                                                                   \
+      Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_SMTCRDFMT, NFCSTATUS_FORMAT_ERROR); \
+    }                                                                          \
+  } while (0)
+
+void phFriNfc_MfStd_Reset(phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt);
+NFCSTATUS phFriNfc_MfStd_Format(phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt,
+                                const uint8_t* ScrtKeyB);
+void phFriNfc_MfStd_Process(void* Context, NFCSTATUS Status);
 
 #endif /* PHFRINFC_MIFSTDFMT_H */
diff --git a/nci/jni/extns/pn54x/src/mifare/phFriNfc_MifareStdMap.c b/nci/jni/extns/pn54x/src/mifare/phFriNfc_MifareStdMap.c
deleted file mode 100644
index f42526d6..00000000
--- a/nci/jni/extns/pn54x/src/mifare/phFriNfc_MifareStdMap.c
+++ /dev/null
@@ -1,5867 +0,0 @@
-/*
- * Copyright (c) 2016, The Linux Foundation. All rights reserved.
- * Not a Contribution.
- *
- * Copyright (C) 2015 NXP Semiconductors
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * NFC Ndef Mapping For Remote Devices.
- *
- */
-
-#include <phFriNfc_MifStdFormat.h>
-#include <phNfcCompId.h>
-#include <phNxpExtns_MifareStd.h>
-#include <phFriNfc_MifareStdMap.h>
-
-/**************** local methods used in this file only ************************/
-static NFCSTATUS phFriNfc_MifStd_H_RdABlock (phFriNfc_NdefMap_t *NdefMap);
-static NFCSTATUS phFriNfc_MifStd_H_WrABlock (phFriNfc_NdefMap_t *NdefMap);
-static NFCSTATUS phFriNfc_MifStd_H_AuthSector (phFriNfc_NdefMap_t *NdefMap);
-static NFCSTATUS phFriNfc_MifStd4k_H_CheckNdef (phFriNfc_NdefMap_t *NdefMap);
-static void phFriNfc_MifStd_H_fillAIDarray (phFriNfc_NdefMap_t *NdefMap);
-static uint8_t phFriNfc_MifStd_H_GetSect (uint8_t BlockNumber);
-static NFCSTATUS phFriNfc_MifStd_H_BlkChk (phFriNfc_NdefMap_t *NdefMap);
-static NFCSTATUS phFriNfc_MifStd_H_RdAcsBit (phFriNfc_NdefMap_t *NdefMap);
-static NFCSTATUS phFriNfc_MifStd_H_ChkAcsBit (phFriNfc_NdefMap_t *NdefMap);
-static NFCSTATUS phFriNfc_MifStd_H_ChkRdWr (phFriNfc_NdefMap_t *NdefMap);
-static void phFriNfc_MifStd_H_ChkNdefCmpltSects (phFriNfc_NdefMap_t *NdefMap);
-static NFCSTATUS phFriNfc_MifStd_H_RemainTLV (phFriNfc_NdefMap_t *NdefMap,
-                                         uint8_t            *Flag,
-                                         uint8_t            *Temp16Bytes);
-static NFCSTATUS phFriNfc_MifStd_H_ChkIntLen (phFriNfc_NdefMap_t *NdefMap);
-static NFCSTATUS phFriNfc_MifStd_H_IntLenWioutNdef (phFriNfc_NdefMap_t *NdefMap,
-                                            uint8_t             *Flag,
-                                            uint8_t             *TempintBytes);
-static uint8_t phFriNfc_MifStd_H_UpdateTLV (phFriNfc_NdefMap_t *NdefMap);
-static NFCSTATUS phFriNfc_MifStd_H_WriteNdefLen (phFriNfc_NdefMap_t *NdefMap);
-static void phFriNfc_MifStd_H_SetNdefBlkAuth (phFriNfc_NdefMap_t *NdefMap);
-static void phFriNfc_MifStd_H_RdWrReset (phFriNfc_NdefMap_t *NdefMap);
-static NFCSTATUS phFriNfc_MifStd_H_RdtoWrNdefLen (phFriNfc_NdefMap_t *NdefMap);
-static NFCSTATUS phFriNfc_MifStd_H_GetActCardLen (phFriNfc_NdefMap_t *NdefMap);
-static NFCSTATUS phFriNfc_MifStd_H_ChkTLVs (phFriNfc_NdefMap_t *NdefMap,
-                                           uint8_t            *CRFlag);
-static NFCSTATUS phFriNfc_MifStd_H_GetNxtTLV (phFriNfc_NdefMap_t *NdefMap,
-                                       uint16_t             *TempLength,
-                                       uint8_t              *TL4bytesFlag);
-static NFCSTATUS phFriNfc_MifStd_H_Chk16Bytes (phFriNfc_NdefMap_t *NdefMap,
-                                       uint16_t             TempLength);
-static NFCSTATUS phFriNfc_MifStd_H_ChkRemainTLVs (phFriNfc_NdefMap_t *NdefMap,
-                                          uint8_t            *CRFlag,
-                                          uint8_t            *NDEFFlag);
-static void phFriNfc_MifStd_H_Complete (phFriNfc_NdefMap_t *NdefMap,
-                                 NFCSTATUS            Result);
-static void phFriNfc_MifStd_H_Get1kStTrail (phFriNfc_NdefMap_t *NdefMap);
-static void phFriNfc_MifStd_H_Get4kStTrail (phFriNfc_NdefMap_t *NdefMap);
-static NFCSTATUS phFriNfc_MifStd_H_ProChkNdef (phFriNfc_NdefMap_t *NdefMap);
-static NFCSTATUS phFriNfc_MifStd_H_ProAuth (phFriNfc_NdefMap_t *NdefMap);
-static NFCSTATUS phFriNfc_MifStd_H_Rd16Bytes (phFriNfc_NdefMap_t *NdefMap,
-                                              uint8_t               BlockNo);
-static NFCSTATUS phFriNfc_MifStd_H_ProAcsBits (phFriNfc_NdefMap_t *NdefMap);
-static NFCSTATUS phFriNfc_MifStd_H_GPBChk (phFriNfc_NdefMap_t *NdefMap);
-static NFCSTATUS phFriNfc_MifStd_H_ProStatNotValid (phFriNfc_NdefMap_t *NdefMap,
-                                                   NFCSTATUS             status);
-static NFCSTATUS phFriNfc_MifStd_H_RdBeforeWr (phFriNfc_NdefMap_t *NdefMap);
-static NFCSTATUS phFriNfc_MifStd_H_ProBytesToWr (phFriNfc_NdefMap_t *NdefMap);
-static NFCSTATUS phFriNfc_MifStd_H_fillSendBuf (phFriNfc_NdefMap_t *NdefMap,
-                                               uint8_t                   Length);
-static NFCSTATUS phFriNfc_MifStd_H_WrTLV (phFriNfc_NdefMap_t *NdefMap);
-static NFCSTATUS phFriNfc_MifStd_H_ProWrTLV (phFriNfc_NdefMap_t *NdefMap);
-static uint8_t phFriNfc_MifStd_H_UpdRemTLV (phFriNfc_NdefMap_t *NdefMap);
-static void phFriNfc_MifStd_H_fillTLV1 (phFriNfc_NdefMap_t *NdefMap);
-static void phFriNfc_MifStd_H_fillTLV2 (phFriNfc_NdefMap_t *NdefMap);
-static NFCSTATUS phFriNfc_MifStd_H_CallWrNdefLen (phFriNfc_NdefMap_t *NdefMap);
-static NFCSTATUS phFriNfc_MifStd_H_BlkChk_1 (phFriNfc_NdefMap_t *NdefMap);
-static void phFriNfc_MifStd_H_fillTLV1_1 (phFriNfc_NdefMap_t *NdefMap);
-static void phFriNfc_MifStd_H_fillTLV2_1 (phFriNfc_NdefMap_t *NdefMap);
-static NFCSTATUS phFriNfc_MifStd_H_RdTLV (phFriNfc_NdefMap_t *NdefMap);
-static NFCSTATUS phFriNfc_MifStd_H_ProRdTLV (phFriNfc_NdefMap_t *NdefMap);
-static NFCSTATUS phFriNfc_MifStd_H_WrTermTLV (phFriNfc_NdefMap_t *NdefMap);
-static NFCSTATUS phFriNfc_MifStd_H_ProWrABlock (phFriNfc_NdefMap_t *NdefMap);
-static NFCSTATUS phFriNfc_MifStd_H_CallConnect (phFriNfc_NdefMap_t *NdefMap);
-static NFCSTATUS phFriNfc_MifStd_H_CallDisCon (phFriNfc_NdefMap_t *NdefMap);
-static void phFriNfc_MifStd1k_H_BlkChk (phFriNfc_NdefMap_t *NdefMap,
-                                    uint8_t              SectorID,
-                                    uint8_t              *callbreak);
-static uint8_t phFriNfc_MifStd_H_GetSectorTrailerBlkNo (uint8_t SectorID);
-static NFCSTATUS phFriNfc_MifStd_H_ProSectorTrailorAcsBits (phFriNfc_NdefMap_t *NdefMap);
-static NFCSTATUS phFriNfc_MifStd_H_WrSectorTrailorBlock (phFriNfc_NdefMap_t *NdefMap);
-static NFCSTATUS phFriNfc_MifStd_H_ProWrSectorTrailor (phFriNfc_NdefMap_t *NdefMap);
-static NFCSTATUS   phFriNfc_MapTool_ChkSpcVer (const phFriNfc_NdefMap_t *NdefMap,
-                                        uint8_t             VersionIndex) __attribute__((unused));
-
-/* Mifare Standard Mapping - Constants */
-#define PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_MADSECT1        0xA0 /* internal Authenticate Command for MAD Sector */
-#define PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_MADSECT2        0xA1 /* internal Authenticate Command for MAD Sector */
-#define PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_MADSECT3        0xA2 /* internal Authenticate Command for MAD Sector */
-#define PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_MADSECT4        0xA3 /* internal Authenticate Command for MAD Sector */
-#define PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_MADSECT5        0xA4 /* internal Authenticate Command for MAD Sector */
-#define PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_MADSECT6        0xA5 /* internal Authenticate Command for MAD Sector */
-#define PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_NDEFSECT1       0xD3 /* internal Authenticate Command for NDEF Sectors 1 */
-#define PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_NDEFSECT2       0xF7 /* internal Authenticate Command for NDEF Sectors 2 */
-#define PH_FRINFC_NDEFMAP_MIFARESTD_NDEF_COMPVAL2        0x03 /* internal Ndef Compliant command 1 */
-#define PH_FRINFC_NDEFMAP_MIFARESTD_NDEF_COMPVAL1        0xE1 /* internal Ndef Compliant command 2 */
-
-/* Enable access bits check for the MAD sector
-#define ENABLE_ACS_BIT_CHK_FOR_MAD */
-
-#define PH_FRINFC_NDEFMAP_MFUL_VAL0 0
-
-/******************************************************************************
- * Function         phFriNfc_MapTool_SetCardState
- *
- * Description      This function sets the appropriate card state.
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-NFCSTATUS phFriNfc_MapTool_SetCardState (phFriNfc_NdefMap_t *NdefMap,
-                                         uint32_t           Length)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-
-    if (Length == PH_FRINFC_NDEFMAP_MFUL_VAL0)
-    {
-        /* As the NDEF LEN / TLV Len is Zero, irrespective of any state the card
-           shall be set to INITIALIZED STATE*/
-        NdefMap->CardState =(uint8_t) (((NdefMap->CardState ==
-                                PH_NDEFMAP_CARD_STATE_READ_ONLY) ||
-                                (NdefMap->CardState ==
-                                PH_NDEFMAP_CARD_STATE_INVALID))?
-                                PH_NDEFMAP_CARD_STATE_INVALID:
-                                PH_NDEFMAP_CARD_STATE_INITIALIZED);
-    }
-    else
-    {
-        switch (NdefMap->CardState)
-        {
-            case PH_NDEFMAP_CARD_STATE_INITIALIZED:
-                NdefMap->CardState =(uint8_t) ((NdefMap->CardState ==
-                    PH_NDEFMAP_CARD_STATE_INVALID)?
-                    NdefMap->CardState:
-                    PH_NDEFMAP_CARD_STATE_READ_WRITE);
-            break;
-
-            case PH_NDEFMAP_CARD_STATE_READ_ONLY:
-                NdefMap->CardState = (uint8_t) ((NdefMap->CardState ==
-                    PH_NDEFMAP_CARD_STATE_INVALID)?
-                    NdefMap->CardState:
-                    PH_NDEFMAP_CARD_STATE_READ_ONLY);
-            break;
-
-            case PH_NDEFMAP_CARD_STATE_READ_WRITE:
-                NdefMap->CardState = (uint8_t) ((NdefMap->CardState ==
-                    PH_NDEFMAP_CARD_STATE_INVALID)?
-                    NdefMap->CardState:
-                    PH_NDEFMAP_CARD_STATE_READ_WRITE);
-                    if (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_1K_CARD ||
-                        NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD ||
-                        NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD)
-                    {
-                        if(NdefMap->StdMifareContainer.ReadOnlySectorIndex &&
-                           NdefMap->StdMifareContainer.SectorTrailerBlockNo == NdefMap->StdMifareContainer.currentBlock )
-                        {
-                            NdefMap->CardState = (uint8_t) ((NdefMap->CardState ==
-                                                            PH_NDEFMAP_CARD_STATE_INVALID)?
-                                                            NdefMap->CardState:
-                                                            PH_NDEFMAP_CARD_STATE_READ_ONLY);
-                        }
-                    }
-            break;
-
-            default:
-                NdefMap->CardState = PH_NDEFMAP_CARD_STATE_INVALID;
-                Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP,
-                            NFCSTATUS_NO_NDEF_SUPPORT);
-            break;
-        }
-    }
-    Result = ((NdefMap->CardState ==
-                PH_NDEFMAP_CARD_STATE_INVALID)?
-                PHNFCSTVAL (CID_FRI_NFC_NDEF_MAP,
-                NFCSTATUS_NO_NDEF_SUPPORT):
-                Result);
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifareStdMap_H_Reset
- *
- * Description      This function resets the component instance to the initial
- *                  state and lets the component forget about the list of
- *                  registered items. Moreover, the lower device is set.
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-NFCSTATUS phFriNfc_MifareStdMap_H_Reset (phFriNfc_NdefMap_t *NdefMap)
-{
-    NFCSTATUS   status = NFCSTATUS_SUCCESS;
-    uint8_t     index = PH_FRINFC_MIFARESTD_VAL0;
-
-    if (NdefMap == NULL)
-    {
-        status = PHNFCSTVAL (CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_PARAMETER);
-    }
-    else
-    {
-        /* Current Block stores the present block accessed in the card */
-        NdefMap->StdMifareContainer.currentBlock = PH_FRINFC_MIFARESTD_VAL0;
-
-        for (index = PH_FRINFC_MIFARESTD_VAL0; index < PH_FRINFC_NDEFMAP_MIFARESTD_ST15_BYTES; index++)
-        {
-            /* internal buffer to store the odd bytes of length < 15 */
-            NdefMap->StdMifareContainer.internalBuf[index] = PH_FRINFC_MIFARESTD_VAL0;
-        }
-
-        for (index = 0; index < PH_FRINFC_NDEFMAP_MIFARESTD_TOTALNO_BLK; index++)
-        {
-            /* aid buffer reset to non ndef compliant */
-            NdefMap->StdMifareContainer.aid[index] = PH_FRINFC_MIFARESTD_NON_NDEF_COMP;
-        }
-
-        /* odd bytes length stored in the internal buffer */
-        NdefMap->StdMifareContainer.internalLength = PH_FRINFC_MIFARESTD_VAL0;
-
-        NdefMap->CardState = PH_NDEFMAP_CARD_STATE_INITIALIZED;
-
-        /* Flag to get that last few bytes are taken from the user buffer */
-        NdefMap->StdMifareContainer.RemainingBufFlag = PH_FRINFC_MIFARESTD_FLAG0;
-
-        /* Flag to find that the read/write operation has reached the end of the card.
-            Further reading/writing is not possible */
-        NdefMap->StdMifareContainer.ReadWriteCompleteFlag = PH_FRINFC_MIFARESTD_FLAG0;
-
-        /* Flag to get that last few bytes are taken from the internal buffer */
-        NdefMap->StdMifareContainer.internalBufFlag = PH_FRINFC_MIFARESTD_FLAG0;
-
-        /* Authentication Flag for every sector */
-        NdefMap->StdMifareContainer.AuthDone = PH_FRINFC_MIFARESTD_FLAG0;
-
-        /* Used in Check Ndef for storing the sector ID */
-        NdefMap->StdMifareContainer.SectorIndex = PH_FRINFC_MIFARESTD_VAL0;
-
-        NdefMap->StdMifareContainer.NdefBlocks = PH_FRINFC_MIFARESTD_VAL0;
-
-        NdefMap->StdMifareContainer.NoOfNdefCompBlocks = PH_FRINFC_MIFARESTD_VAL0;
-
-        NdefMap->StdMifareContainer.ReadAcsBitFlag = PH_FRINFC_MIFARESTD_FLAG0;
-
-        NdefMap->StdMifareContainer.remSizeUpdFlag = PH_FRINFC_MIFARESTD_FLAG0;
-
-        NdefMap->TLVStruct.NoLbytesinTLV = PH_FRINFC_MIFARESTD_VAL0;
-
-        NdefMap->TLVStruct.prevLenByteValue = PH_FRINFC_MIFARESTD_VAL0;
-
-        NdefMap->TLVStruct.BytesRemainLinTLV = PH_FRINFC_MIFARESTD_VAL0;
-
-        NdefMap->TLVStruct.NdefTLVBlock = PH_FRINFC_MIFARESTD_VAL0;
-
-        NdefMap->TLVStruct.NdefTLVByte = PH_FRINFC_MIFARESTD_VAL0;
-
-        NdefMap->TLVStruct.NULLTLVCount = PH_FRINFC_MIFARESTD_VAL0;
-
-        NdefMap->StdMifareContainer.remainingSize = PH_FRINFC_MIFARESTD_VAL0;
-
-        NdefMap->StdMifareContainer.ReadNdefFlag = PH_FRINFC_MIFARESTD_FLAG0;
-
-        NdefMap->StdMifareContainer.WrNdefFlag = PH_FRINFC_MIFARESTD_FLAG0;
-
-        NdefMap->StdMifareContainer.ChkNdefFlag = PH_FRINFC_MIFARESTD_FLAG0;
-
-        NdefMap->StdMifareContainer.aidCompleteFlag = PH_FRINFC_MIFARESTD_FLAG0;
-
-        NdefMap->StdMifareContainer.NFCforumSectFlag = PH_FRINFC_MIFARESTD_FLAG0;
-
-        NdefMap->StdMifareContainer.ProprforumSectFlag = PH_FRINFC_MIFARESTD_PROP_1ST_CONFIG;
-
-        NdefMap->StdMifareContainer.ReadCompleteFlag = PH_FRINFC_MIFARESTD_FLAG0;
-
-        NdefMap->StdMifareContainer.FirstReadFlag = PH_FRINFC_MIFARESTD_FLAG0;
-
-        NdefMap->StdMifareContainer.WrLength = PH_FRINFC_MIFARESTD_VAL1;
-
-        NdefMap->StdMifareContainer.ChkNdefCompleteFlag = PH_FRINFC_MIFARESTD_FLAG0;
-
-        NdefMap->StdMifareContainer.ReadOnlySectorIndex = PH_FRINFC_MIFARESTD_FLAG0;
-
-        NdefMap->StdMifareContainer.TotalNoSectors = PH_FRINFC_MIFARESTD_FLAG0;
-
-        NdefMap->StdMifareContainer.SectorTrailerBlockNo = PH_FRINFC_MIFARESTD_FLAG0;
-    }
-
-    return status;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifareStdMap_ChkNdef
- *
- * Description      The function checks whether the peer device is NDEF compliant.
- *
- * Returns          This function return NFCSTATUS_PENDING in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-NFCSTATUS phFriNfc_MifareStdMap_ChkNdef ( phFriNfc_NdefMap_t *NdefMap)
-{
-    NFCSTATUS status = NFCSTATUS_PENDING;
-    uint8_t atq, sak;
-
-    if (NdefMap == NULL)
-    {
-        status = PHNFCSTVAL (CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_PARAMETER);
-    }
-    else
-    {
-        NdefMap->PrevOperation = PH_FRINFC_NDEFMAP_CHECK_OPE;
-        NdefMap->StdMifareContainer.CRIndex = PH_FRINFC_NDEFMAP_CR_CHK_NDEF;
-
-        /* Get the Select Response and Sense Response to get
-            the exact Card Type either Mifare 1k or 4k */
-        sak = NdefMap->psRemoteDevInfo->RemoteDevInfo.Iso14443A_Info.Sak;
-        atq = NdefMap->psRemoteDevInfo->RemoteDevInfo.Iso14443A_Info.AtqA[0];
-
-        if (0x08 == (sak & 0x18))
-        {
-            /* Total Number of Blocks in Mifare 1k Card */
-            NdefMap->StdMifareContainer.NoOfNdefCompBlocks =
-                                        PH_FRINFC_NDEFMAP_MIFARESTD_1KNDEF_COMPBLOCK;
-            NdefMap->StdMifareContainer.remainingSize =
-                                                ((NdefMap->CardType == PH_FRINFC_MIFARESTD_VAL0) ?
-                                                (PH_FRINFC_NDEFMAP_MIFARESTD_1KNDEF_COMPBLOCK *
-                                                PH_FRINFC_MIFARESTD_BLOCK_BYTES) :
-                                                NdefMap->StdMifareContainer.remainingSize);
-            NdefMap->CardType = PH_FRINFC_NDEFMAP_MIFARE_STD_1K_CARD;
-        }
-        else if (0x19 == (sak & 0x19))
-        {
-            /* Total Number of Blocks in Mifare 2k Card */
-            NdefMap->StdMifareContainer.NoOfNdefCompBlocks =
-                                        PH_FRINFC_NDEFMAP_MIFARESTD_2KNDEF_COMPBLOCK;
-            NdefMap->StdMifareContainer.remainingSize =
-                                            ((NdefMap->CardType == PH_FRINFC_MIFARESTD_VAL0) ?
-                                            (PH_FRINFC_NDEFMAP_MIFARESTD_2KNDEF_COMPBLOCK *
-                                            PH_FRINFC_MIFARESTD_BLOCK_BYTES) :
-                                            NdefMap->StdMifareContainer.remainingSize);
-            NdefMap->CardType = PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD;
-        }
-        else
-        {
-             /* Total Number of Blocks in Mifare 4k Card */
-            NdefMap->StdMifareContainer.NoOfNdefCompBlocks =
-                                        PH_FRINFC_NDEFMAP_MIFARESTD_4KNDEF_COMPBLOCK;
-            NdefMap->StdMifareContainer.remainingSize =
-                                            ((NdefMap->CardType == PH_FRINFC_MIFARESTD_VAL0) ?
-                                            (PH_FRINFC_NDEFMAP_MIFARESTD_4KNDEF_COMPBLOCK *
-                                            PH_FRINFC_MIFARESTD_BLOCK_BYTES) :
-                                            NdefMap->StdMifareContainer.remainingSize);
-            NdefMap->CardType = PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD;
-        }
-
-
-        /*  phFriNfc_MifareStdMap_ChkNdef should be called only
-            when currentBlock is 0 OR 64,65 and 66 (for Mifare 4k).
-            Otherwise return error */
-        /* and also Check the Authentication Flag */
-        if ((NdefMap->StdMifareContainer.currentBlock != 0) &&
-            (NdefMap->StdMifareContainer.currentBlock != 1) &&
-            (NdefMap->StdMifareContainer.currentBlock != 2) &&
-            (NdefMap->StdMifareContainer.currentBlock != 64) &&
-            (NdefMap->StdMifareContainer.currentBlock != 65) &&
-            (NdefMap->StdMifareContainer.currentBlock != 66))
-        {
-            status = PHNFCSTVAL (CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_PARAMETER);
-        }
-        else if ( NdefMap->StdMifareContainer.AuthDone == 0)
-        {
-            /*  Block 0 contains Manufacturer information and
-                also other informaton. So go for block 1 which
-                contains AIDs. Authenticating any of the block
-                in a sector, Authenticates the whole sector */
-            if (NdefMap->StdMifareContainer.currentBlock == 0)
-            {
-                NdefMap->StdMifareContainer.currentBlock = 1;
-            }
-            status = phFriNfc_MifStd_H_AuthSector (NdefMap);
-        }
-        else
-        {
-            /**
-             * Mifare 1k, sak = 0x08 atq = 0x04
-             * Mifare 2k, sak = 0x19 atq = 0x02
-             * Mifare 4k, sak = 0x18 atq = 0x02
-             */
-            if ((NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD) ||
-                (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_1K_CARD) ||
-                (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD))
-            {
-                /* Change the state to Check Ndef Compliant */
-                NdefMap->State = PH_FRINFC_NDEFMAP_STATE_CHK_NDEF_COMP;
-                NdefMap->PrevOperation = PH_FRINFC_NDEFMAP_CHECK_OPE;
-                NdefMap->StdMifareContainer.ChkNdefFlag = PH_FRINFC_MIFARESTD_FLAG1;
-
-                NdefMap->MapCompletionInfo.CompletionRoutine = phFriNfc_MifareStdMap_Process;
-                NdefMap->MapCompletionInfo.Context = NdefMap;
-
-                NdefMap->Cmd.MfCmd = phHal_eMifareRead;
-                *NdefMap->SendRecvLength = NdefMap->TempReceiveLength;
-                NdefMap->SendRecvBuf [0] = NdefMap->StdMifareContainer.currentBlock;
-                NdefMap->SendLength = MIFARE_MAX_SEND_BUF_TO_READ;
-
-                /* Call the Overlapped HAL Transceive function */
-                status = phFriNfc_ExtnsTransceive (NdefMap->pTransceiveInfo,
-                                      NdefMap->Cmd,
-                                      NdefMap->SendRecvBuf,
-                                      NdefMap->SendLength,
-                                      NdefMap->SendRecvLength);
-            }
-            else
-            {
-                /* Since we have decided temporarily not to go
-                    for any new error codes we are using
-                    NFCSTATUS_INVALID_PARAMETER even though it is not
-                    the relevant error code here TBD */
-                status = PHNFCSTVAL (CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_PARAMETER);
-            }
-        }
-    }
-
-    return status;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifareStdMap_RdNdef
- *
- * Description      The function initiates the reading of NDEF information from
- *                  a Remote Device. It performs a reset of the state and starts
- *                  the action (state machine). A periodic call of the
- *                  phFriNfcNdefMap_Process has to be done once the action
- *                  has been triggered.
- *
- * Returns          This function return NFCSTATUS_PENDING in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-NFCSTATUS phFriNfc_MifareStdMap_RdNdef (phFriNfc_NdefMap_t *NdefMap,
-                                        uint8_t            *PacketData,
-                                        uint32_t           *PacketDataLength,
-                                        uint8_t            Offset)
-{
-    NFCSTATUS status = NFCSTATUS_PENDING;
-
-    NdefMap->ApduBufferSize = *PacketDataLength;
-    NdefMap->NumOfBytesRead = PacketDataLength;
-    *NdefMap->NumOfBytesRead = 0;
-    NdefMap->ApduBuffIndex = 0;
-    NdefMap->PrevOperation = PH_FRINFC_NDEFMAP_READ_OPE;
-    NdefMap->StdMifareContainer.CRIndex = PH_FRINFC_NDEFMAP_CR_RD_NDEF;
-
-    if ((NdefMap->CardState == PH_NDEFMAP_CARD_STATE_INVALID)
-        || (NdefMap->CardState == PH_NDEFMAP_CARD_STATE_INITIALIZED))
-    {
-        /* Card state  is not correct */
-        status = PHNFCSTVAL (CID_FRI_NFC_NDEF_MAP,
-                            NFCSTATUS_INVALID_PARAMETER);
-    }
-    else
-    {
-        if ((Offset == PH_FRINFC_NDEFMAP_SEEK_BEGIN) || ( NdefMap->PrevOperation ==
-            PH_FRINFC_NDEFMAP_WRITE_OPE))
-        {
-            phFriNfc_MifStd_H_RdWrReset (NdefMap);
-            NdefMap->StdMifareContainer.ReadNdefFlag = PH_FRINFC_MIFARESTD_FLAG1;
-            NdefMap->TLVStruct.NdefTLVFoundFlag = PH_FRINFC_MIFARESTD_FLAG0;
-        }
-        /* Offset = Current, but the read has reached the End of Card */
-        if ((Offset == PH_FRINFC_NDEFMAP_SEEK_CUR) &&
-            (NdefMap->StdMifareContainer.ReadWriteCompleteFlag ==
-            PH_FRINFC_MIFARESTD_FLAG1))
-        {
-            status = PHNFCSTVAL (CID_FRI_NFC_NDEF_MAP, NFCSTATUS_EOF_NDEF_CONTAINER_REACHED);
-        }
-        else
-        {
-            NdefMap->Offset = (((Offset != PH_FRINFC_NDEFMAP_SEEK_BEGIN) &&
-                                (NdefMap->PrevOperation ==
-                                PH_FRINFC_NDEFMAP_WRITE_OPE)) ?
-                                PH_FRINFC_NDEFMAP_SEEK_BEGIN :
-                                Offset);
-            status = phFriNfc_MifStd_H_BlkChk (NdefMap);
-            if (status == NFCSTATUS_SUCCESS)
-            {
-                NdefMap->ApduBuffer = PacketData;
-
-                /* Read Operation in Progress */
-                NdefMap->StdMifareContainer.ReadWriteCompleteFlag = PH_FRINFC_MIFARESTD_FLAG0;
-
-                /* Check Authentication Flag */
-                status =
-                    ((NdefMap->StdMifareContainer.AuthDone == PH_FRINFC_MIFARESTD_FLAG1) ?
-                    phFriNfc_MifStd_H_RdABlock(NdefMap) :
-                    phFriNfc_MifStd_H_AuthSector(NdefMap));
-            }
-        }
-    }
-
-    return status;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifareStdMap_WrNdef
- *
- * Description      The function initiates the writing of NDEF information to
- *                  a Remote Device. It performs a reset of the state and starts
- *                  the action (state machine). A periodic call of the
- *                  phFriNfcNdefMap_Process has to be done once the action
- *                  has been triggered.
- *
- * Returns          This function return NFCSTATUS_PENDING in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-NFCSTATUS phFriNfc_MifareStdMap_WrNdef (phFriNfc_NdefMap_t    *NdefMap,
-                                        uint8_t               *PacketData,
-                                        uint32_t              *PacketDataLength,
-                                        uint8_t               Offset)
-{
-    NFCSTATUS status = NFCSTATUS_PENDING;
-
-    NdefMap->ApduBuffer = PacketData;
-    NdefMap->ApduBufferSize = *PacketDataLength;
-    NdefMap->ApduBuffIndex = PH_FRINFC_MIFARESTD_VAL0;
-    NdefMap->WrNdefPacketLength = PacketDataLength;
-    *NdefMap->WrNdefPacketLength = PH_FRINFC_MIFARESTD_VAL0;
-    NdefMap->PrevOperation = PH_FRINFC_NDEFMAP_WRITE_OPE;
-    NdefMap->StdMifareContainer.CRIndex = PH_FRINFC_NDEFMAP_CR_WR_NDEF;
-
-    if ((NdefMap->CardState == PH_NDEFMAP_CARD_STATE_INVALID)
-        || (NdefMap->CardState == PH_NDEFMAP_CARD_STATE_READ_ONLY))
-    {
-        /* Card state  is not correct */
-        status = PHNFCSTVAL (CID_FRI_NFC_NDEF_MAP,
-                            NFCSTATUS_INVALID_PARAMETER);
-    }
-    else
-    {
-        if ((Offset == PH_FRINFC_NDEFMAP_SEEK_BEGIN) ||
-            (NdefMap->PrevOperation == PH_FRINFC_NDEFMAP_READ_OPE))
-        {
-            NdefMap->TLVStruct.NdefTLVFoundFlag = PH_FRINFC_MIFARESTD_FLAG0;
-            NdefMap->StdMifareContainer.RdBeforeWrFlag = PH_FRINFC_MIFARESTD_FLAG1;
-            NdefMap->StdMifareContainer.WrNdefFlag = PH_FRINFC_MIFARESTD_FLAG1;
-            NdefMap->StdMifareContainer.internalLength = PH_FRINFC_MIFARESTD_VAL0;
-            NdefMap->StdMifareContainer.RdAfterWrFlag = PH_FRINFC_MIFARESTD_FLAG0;
-            NdefMap->StdMifareContainer.AuthDone = PH_FRINFC_MIFARESTD_FLAG0;
-            NdefMap->TLVStruct.NULLTLVCount = PH_FRINFC_MIFARESTD_VAL0;
-            NdefMap->TLVStruct.NdefTLVByte = PH_FRINFC_MIFARESTD_VAL0;
-            NdefMap->TLVStruct.NdefTLVAuthFlag = PH_FRINFC_MIFARESTD_FLAG0;
-            NdefMap->StdMifareContainer.FirstReadFlag = PH_FRINFC_MIFARESTD_FLAG0;
-            NdefMap->StdMifareContainer.remainingSize =
-                        (NdefMap->StdMifareContainer.NoOfNdefCompBlocks *
-                        PH_FRINFC_MIFARESTD_BLOCK_BYTES);
-            NdefMap->StdMifareContainer.currentBlock =
-                                            PH_FRINFC_MIFARESTD_BLK4;
-            NdefMap->StdMifareContainer.NdefBlocks = PH_FRINFC_MIFARESTD_VAL1;
-            NdefMap->StdMifareContainer.NFCforumSectFlag = PH_FRINFC_MIFARESTD_FLAG0;
-            /* This macro is added, to be compliant with the previous HAL 2.0
-                For HAL 2.0, polling is done before writing data to the mifare
-                std (if the offset is BEGIN), because if an error is reported
-                during read or write and again write is called, the PN531 state is
-                unchanged (so write will fail), to bring the PN531 to the correct
-                state, polling is done.
-                Changed on 13th Jan 2009
-            */
-            NdefMap->StdMifareContainer.PollFlag = PH_FRINFC_MIFARESTD_FLAG0;
-            NdefMap->StdMifareContainer.WrLength = PH_FRINFC_MIFARESTD_VAL0;
-            NdefMap->StdMifareContainer.FirstWriteFlag = PH_FRINFC_MIFARESTD_FLAG1;
-        }
-
-        if (((Offset == PH_FRINFC_NDEFMAP_SEEK_CUR) &&
-            (NdefMap->StdMifareContainer.ReadWriteCompleteFlag ==
-            PH_FRINFC_MIFARESTD_FLAG1)) || ((NdefMap->StdMifareContainer.PollFlag ==
-            PH_FRINFC_MIFARESTD_FLAG1) && (Offset == PH_FRINFC_NDEFMAP_SEEK_CUR)))
-        {
-            /* Offset = Current, but the read has reached the End of Card */
-            status = PHNFCSTVAL (CID_FRI_NFC_NDEF_MAP,
-                                NFCSTATUS_EOF_NDEF_CONTAINER_REACHED);
-        }
-        else
-        {
-            NdefMap->Offset = (((Offset != PH_FRINFC_NDEFMAP_SEEK_BEGIN) &&
-                            (NdefMap->PrevOperation ==
-                            PH_FRINFC_NDEFMAP_READ_OPE)) ?
-                            PH_FRINFC_NDEFMAP_SEEK_BEGIN :
-                            Offset);
-            NdefMap->StdMifareContainer.AuthDone = PH_FRINFC_MIFARESTD_FLAG0;
-            status = phFriNfc_MifStd_H_BlkChk (NdefMap);
-            NdefMap->StdMifareContainer.ReadWriteCompleteFlag = PH_FRINFC_MIFARESTD_FLAG0;
-            if (status == NFCSTATUS_SUCCESS)
-            {
-                if (NdefMap->StdMifareContainer.PollFlag ==
-                    PH_FRINFC_MIFARESTD_FLAG1)
-                {
-                    /* if poll flag is set then call disconnect because the authentication
-                        has failed so reactivation of card is required */
-                    status = phFriNfc_MifStd_H_CallDisCon (NdefMap);
-                }
-                /* Check Authentication Flag */
-                else if (NdefMap->StdMifareContainer.AuthDone == PH_FRINFC_MIFARESTD_FLAG1)
-                {
-                    status =  ((NdefMap->Offset ==
-                                PH_FRINFC_NDEFMAP_SEEK_BEGIN) ?
-                                phFriNfc_MifStd_H_RdBeforeWr (NdefMap) :
-                                phFriNfc_MifStd_H_WrABlock (NdefMap));
-                }
-                else
-                {
-                    status = phFriNfc_MifStd_H_AuthSector (NdefMap);
-                }
-            }
-        }
-    }
-
-    return status;
-}
-
-
-/******************************************************************************
- * Function         phFriNfc_MifareStdMap_Process
- *
- * Description      This function is a Completion Routine, Processing function,
- *                  needed to avoid long blocking.
- *                  This function as a Completion Routine in order to be able
- *                  to notify the component that an I/O has finished and data
- *                  are ready to be processed.
-
- * Returns          void
- *
- ******************************************************************************/
-void phFriNfc_MifareStdMap_Process (void       *Context,
-                                    NFCSTATUS   Status)
-{
-    phFriNfc_NdefMap_t      *NdefMap;
-    uint8_t                 NDEFFlag = 0,
-                            CRFlag = 0,
-                            Temp16Bytes = 0,
-                            i = 0;
-
-    NdefMap = (phFriNfc_NdefMap_t *)Context;
-
-    if ((Status & PHNFCSTBLOWER) == (NFCSTATUS_SUCCESS & PHNFCSTBLOWER))
-    {
-        switch (NdefMap->State)
-        {
-            case PH_FRINFC_NDEFMAP_STATE_CHK_NDEF_COMP:
-                Status = phFriNfc_MifStd_H_ProChkNdef (NdefMap);
-                CRFlag = (uint8_t)((Status != NFCSTATUS_PENDING) ?
-                            PH_FRINFC_MIFARESTD_FLAG1 :
-                            PH_FRINFC_MIFARESTD_FLAG0);
-                break;
-
-            case PH_FRINFC_NDEFMAP_STATE_READ:
-                /* Receive Length for read shall always be equal to 16 */
-                if ((*NdefMap->SendRecvLength == PH_FRINFC_MIFARESTD_BYTES_READ) &&
-                    (NdefMap->ApduBuffIndex < (uint16_t) NdefMap->ApduBufferSize))
-                {
-                    Temp16Bytes = PH_FRINFC_MIFARESTD_VAL0;
-                    NDEFFlag = (uint8_t) PH_FRINFC_MIFARESTD_FLAG1;
-                    if (NdefMap->TLVStruct.BytesRemainLinTLV != 0)
-                    {
-                        NDEFFlag = PH_FRINFC_MIFARESTD_FLAG0;
-                        CRFlag = PH_FRINFC_MIFARESTD_FLAG0;
-                        /* To read the remaining length (L) in TLV */
-                        Status = phFriNfc_MifStd_H_RemainTLV (NdefMap, &NDEFFlag, &Temp16Bytes);
-                        CRFlag = (uint8_t) ((Status != NFCSTATUS_PENDING) ?
-                                             PH_FRINFC_MIFARESTD_FLAG1 :
-                                             PH_FRINFC_MIFARESTD_FLAG0);
-                    }
-
-                    /* check the NDEFFlag is set. if this is not set, then
-                        in the above RemainTLV function all the 16 bytes has been
-                        read */
-                }
-                else
-                {
-                    Status = PHNFCSTVAL (CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_RECEIVE_LENGTH);
-                    CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
-                }
-                break;
-
-            case PH_FRINFC_NDEFMAP_STATE_WRITE:
-                Status = phFriNfc_MifStd_H_ProWrABlock (NdefMap);
-                CRFlag = (uint8_t) ((Status != NFCSTATUS_PENDING) ?
-                                     PH_FRINFC_MIFARESTD_FLAG1 :
-                                     PH_FRINFC_MIFARESTD_FLAG0);
-
-                /* Call Completion Routine if CR Flag is Set to 1 */
-                if (CRFlag == PH_FRINFC_MIFARESTD_FLAG1)
-                {
-                    *NdefMap->WrNdefPacketLength = NdefMap->ApduBuffIndex;
-                }
-                break;
-
-            case PH_FRINFC_NDEFMAP_STATE_AUTH:
-                NdefMap->StdMifareContainer.FirstReadFlag = PH_FRINFC_MIFARESTD_FLAG0;
-                Status = phFriNfc_MifStd_H_ProAuth (NdefMap);
-                CRFlag = (uint8_t) ((Status != NFCSTATUS_PENDING) ?
-                                     PH_FRINFC_MIFARESTD_FLAG1 :
-                                     PH_FRINFC_MIFARESTD_FLAG0);
-                break;
-
-            case PH_FRINFC_NDEFMAP_STATE_RD_ACS_BIT:
-                Status = phFriNfc_MifStd_H_ProAcsBits (NdefMap);
-                CRFlag = (uint8_t) ((Status != NFCSTATUS_PENDING) ?
-                                     PH_FRINFC_MIFARESTD_FLAG1 :
-                                     PH_FRINFC_MIFARESTD_FLAG0);
-                break;
-
-            case PH_FRINFC_NDEFMAP_STATE_WR_NDEF_LEN:
-                if (NdefMap->StdMifareContainer.RdAfterWrFlag ==
-                    PH_FRINFC_MIFARESTD_FLAG1)
-                {
-                    Status = phFriNfc_MifStd_H_CallWrNdefLen (NdefMap);
-                    CRFlag = (uint8_t) ((Status != NFCSTATUS_PENDING) ?
-                                PH_FRINFC_MIFARESTD_FLAG1 :
-                                PH_FRINFC_MIFARESTD_FLAG0);
-                }
-                else
-                {
-                    /* Check this */
-                    if (NdefMap->StdMifareContainer.TempBlockNo ==
-                        NdefMap->StdMifareContainer.currentBlock)
-                    {
-                        memcpy (NdefMap->StdMifareContainer.internalBuf,
-                                NdefMap->StdMifareContainer.Buffer,
-                                NdefMap->StdMifareContainer.internalLength);
-
-                    }
-                    *NdefMap->WrNdefPacketLength = NdefMap->ApduBuffIndex;
-                    NdefMap->StdMifareContainer.currentBlock =
-                                    NdefMap->StdMifareContainer.TempBlockNo;
-                    NdefMap->CardState = (uint8_t) ((NdefMap->CardState ==
-                                        PH_NDEFMAP_CARD_STATE_INITIALIZED) ?
-                                        PH_NDEFMAP_CARD_STATE_READ_WRITE :
-                                        NdefMap->CardState);
-                    CRFlag = (uint8_t) PH_FRINFC_MIFARESTD_FLAG1;
-                }
-                /*NdefMap->StdMifareContainer.remainingSize -=
-                (((NdefMap->ApduBufferSize) > (PH_FRINFC_MIFARESTD_NDEFTLV_L -
-                                            PH_FRINFC_MIFARESTD_VAL1))?
-                                            ((uint16_t)(*NdefMap->WrNdefPacketLength +
-                                            PH_FRINFC_MIFARESTD_VAL4)):
-                                            ((uint16_t)(*NdefMap->WrNdefPacketLength +
-                                            PH_FRINFC_MIFARESTD_VAL2)));*/
-                break;
-
-            case PH_FRINFC_NDEFMAP_STATE_RD_TO_WR_NDEF_LEN:
-                CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
-                Status = PHNFCSTVAL (CID_FRI_NFC_NDEF_MAP,
-                                    NFCSTATUS_INVALID_DEVICE_REQUEST);
-                if (*NdefMap->SendRecvLength == PH_FRINFC_MIFARESTD_BYTES_READ)
-                {
-                    /* Size of NdefMap->SendRecvBuf is set by phLibNfc_Gen_NdefMapReset to PH_LIBNFC_GEN_MAX_BUFFER */
-                    /* We don't have to check memory here */
-                    for (i = PH_FRINFC_MIFARESTD_BYTES_READ; i > 0; i--)
-                    {
-                        NdefMap->SendRecvBuf [i] = NdefMap->SendRecvBuf [i-1];
-                    }
-                    NdefMap->SendRecvBuf [PH_FRINFC_MIFARESTD_VAL0] =
-                                NdefMap->StdMifareContainer.currentBlock;
-                    Status = phFriNfc_MifStd_H_WriteNdefLen (NdefMap);
-                    CRFlag = (uint8_t) ((Status != NFCSTATUS_PENDING) ?
-                                PH_FRINFC_MIFARESTD_FLAG1 :
-                                PH_FRINFC_MIFARESTD_FLAG0);
-                }
-                break;
-
-            case PH_FRINFC_NDEFMAP_STATE_GET_ACT_CARDSIZE:
-                NDEFFlag = PH_FRINFC_MIFARESTD_FLAG1;
-                if (NdefMap->TLVStruct.NoLbytesinTLV > PH_FRINFC_MIFARESTD_VAL0)
-                {
-                    NDEFFlag = PH_FRINFC_MIFARESTD_FLAG0;
-                    Status = phFriNfc_MifStd_H_ChkRemainTLVs (NdefMap, &CRFlag, &NDEFFlag);
-                    NdefMap->TLVStruct.NoLbytesinTLV =
-                                    PH_FRINFC_MIFARESTD_VAL0;
-                }
-                if ((NDEFFlag == PH_FRINFC_MIFARESTD_FLAG1) &&
-                    (CRFlag != PH_FRINFC_MIFARESTD_FLAG1))
-                {
-                    Status = phFriNfc_MifStd_H_ChkTLVs (NdefMap, &CRFlag);
-                }
-                if (((NdefMap->StdMifareContainer.ReadNdefFlag ==
-                    PH_FRINFC_MIFARESTD_FLAG1) ||
-                    (NdefMap->StdMifareContainer.WrNdefFlag ==
-                    PH_FRINFC_MIFARESTD_FLAG1)) &&
-                    (Status != NFCSTATUS_PENDING))
-                {
-                    NdefMap->StdMifareContainer.NFCforumSectFlag =
-                                            PH_FRINFC_MIFARESTD_FLAG1;
-                    CRFlag = PH_FRINFC_MIFARESTD_FLAG0;
-                    /* if the card state has changed to initialised and
-                     read ndef is called then error is returned */
-                    if (((NdefMap->StdMifareContainer.WrNdefFlag ==
-                        PH_FRINFC_MIFARESTD_FLAG1) &&
-                        (NdefMap->CardState == PH_NDEFMAP_CARD_STATE_READ_ONLY)) ||
-                        ((NdefMap->StdMifareContainer.ReadNdefFlag ==
-                            PH_FRINFC_MIFARESTD_FLAG1) &&
-                        (NdefMap->CardState == PH_NDEFMAP_CARD_STATE_INITIALIZED)))
-                    {
-                        Status = PHNFCSTVAL (CID_FRI_NFC_NDEF_MAP,
-                                            NFCSTATUS_NO_NDEF_SUPPORT);
-                    }
-                    if (NdefMap->StdMifareContainer.AuthDone ==
-                        PH_FRINFC_MIFARESTD_FLAG0)
-                    {
-                        Status = phFriNfc_MifStd_H_AuthSector (NdefMap);
-                    }
-                    else
-                    {
-                        Status = ((NdefMap->StdMifareContainer.ReadNdefFlag ==
-                                    PH_FRINFC_MIFARESTD_FLAG1) ?
-                                    phFriNfc_MifStd_H_RdTLV (NdefMap) :
-                                    phFriNfc_MifStd_H_RdBeforeWr (NdefMap));
-                    }
-                    NdefMap->StdMifareContainer.ReadNdefFlag =
-                                            PH_FRINFC_MIFARESTD_FLAG0;
-                    NdefMap->StdMifareContainer.WrNdefFlag =
-                                            PH_FRINFC_MIFARESTD_FLAG0;
-                }
-
-                if (NdefMap->StdMifareContainer.ChkNdefFlag ==
-                    PH_FRINFC_MIFARESTD_FLAG1)
-                {
-                    CRFlag = (uint8_t) ((Status != NFCSTATUS_PENDING) ?
-                            PH_FRINFC_MIFARESTD_FLAG1 :
-                            PH_FRINFC_MIFARESTD_FLAG0);
-                }
-                break;
-
-            case PH_FRINFC_NDEFMAP_STATE_RD_BEF_WR:
-                /* Read flag says that already part of TLV has been written */
-                Status = phFriNfc_MifStd_H_ProBytesToWr (NdefMap);
-                 CRFlag = (uint8_t) ((Status != NFCSTATUS_PENDING) ?
-                                    PH_FRINFC_MIFARESTD_FLAG1 :
-                                    PH_FRINFC_MIFARESTD_FLAG0);
-                break;
-
-            case PH_FRINFC_NDEFMAP_STATE_WR_TLV:
-                Status = phFriNfc_MifStd_H_ProWrTLV (NdefMap);
-                CRFlag = (uint8_t) ((Status != NFCSTATUS_PENDING) ?
-                                    PH_FRINFC_MIFARESTD_FLAG1 :
-                                    PH_FRINFC_MIFARESTD_FLAG0);
-                break;
-
-            case PH_FRINFC_NDEFMAP_STATE_RD_TLV:
-                Status = phFriNfc_MifStd_H_ProRdTLV (NdefMap);
-                CRFlag = (uint8_t) ((Status != NFCSTATUS_PENDING) ?
-                                    PH_FRINFC_MIFARESTD_FLAG1 :
-                                    PH_FRINFC_MIFARESTD_FLAG0);
-                break;
-
-            case PH_FRINFC_NDEFMAP_STATE_TERM_TLV:
-                phFriNfc_MifStd_H_SetNdefBlkAuth(NdefMap);
-                NdefMap->StdMifareContainer.currentBlock =
-                                NdefMap->TLVStruct.NdefTLVBlock;
-                Status = phFriNfc_MifStd_H_RdtoWrNdefLen (NdefMap);
-                CRFlag = (uint8_t) ((Status != NFCSTATUS_PENDING) ?
-                                    PH_FRINFC_MIFARESTD_FLAG1 :
-                                    PH_FRINFC_MIFARESTD_FLAG0);
-                break;
-
-            case PH_FRINFC_NDEFMAP_STATE_DISCONNECT:
-                NdefMap->StdMifareContainer.PollFlag = PH_FRINFC_MIFARESTD_FLAG0;
-
-                Status = phFriNfc_MifStd_H_CallConnect (NdefMap);
-                CRFlag = (uint8_t) ((Status != NFCSTATUS_PENDING) ?
-                                    PH_FRINFC_MIFARESTD_FLAG1 :
-                                    PH_FRINFC_MIFARESTD_FLAG0);
-                break;
-
-            case PH_FRINFC_NDEFMAP_STATE_CONNECT:
-                if (NdefMap->StdMifareContainer.FirstReadFlag == PH_FRINFC_MIFARESTD_FLAG1)
-                {
-                    NdefMap->StdMifareContainer.FirstReadFlag = PH_FRINFC_MIFARESTD_FLAG0;
-                    Status = phFriNfc_MifStd_H_AuthSector (NdefMap);
-                }
-                else if ((NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_1K_CARD ||
-                          NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD ||
-                          NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD) &&
-                         (NdefMap->StdMifareContainer.ReadOnlySectorIndex &&
-                          NdefMap->StdMifareContainer.SectorTrailerBlockNo ==  NdefMap->StdMifareContainer.currentBlock))
-                {
-                    NdefMap->StdMifareContainer.ReadOnlySectorIndex =
-                        PH_FRINFC_MIFARESTD_FLAG0;
-                    NdefMap->StdMifareContainer.SectorTrailerBlockNo =
-                        PH_FRINFC_MIFARESTD_FLAG0;
-                    NdefMap->StdMifareContainer.currentBlock = PH_FRINFC_MIFARESTD_FLAG0;
-                    Status = NFCSTATUS_FAILED;
-                }
-                else
-                {
-                    Status = ((((NdefMap->Offset == PH_FRINFC_NDEFMAP_SEEK_CUR) &&
-                        (NdefMap->PrevOperation == PH_FRINFC_NDEFMAP_WRITE_OPE)) ||
-                        (NdefMap->StdMifareContainer.WrLength >
-                        PH_FRINFC_MIFARESTD_VAL0)) ?
-                        phFriNfc_MifStd_H_ProStatNotValid (NdefMap, Status) :
-                        phFriNfc_MifStd_H_AuthSector (NdefMap));
-                }
-                CRFlag = (uint8_t) ((Status != NFCSTATUS_PENDING) ?
-                                    PH_FRINFC_MIFARESTD_FLAG1 :
-                                    PH_FRINFC_MIFARESTD_FLAG0);
-                break;
-
-            case PH_FRINFC_NDEFMAP_STATE_RD_SEC_ACS_BIT:
-                Status = phFriNfc_MifStd_H_ProSectorTrailorAcsBits (NdefMap);
-                CRFlag = (uint8_t) ((Status != NFCSTATUS_PENDING)?
-                                    PH_FRINFC_MIFARESTD_FLAG1 :
-                                    PH_FRINFC_MIFARESTD_FLAG0);
-                if ((CRFlag == PH_FRINFC_MIFARESTD_FLAG1) &&
-                    (NdefMap->StdMifareContainer.WriteAcsBitFlag == PH_FRINFC_MIFARESTD_FLAG0))
-                {
-                    Status = PHNFCSTVAL (CID_FRI_NFC_NDEF_MAP,
-                                    NFCSTATUS_INVALID_DEVICE_REQUEST);
-                }
-                break;
-
-            case PH_FRINFC_NDEFMAP_STATE_WRITE_SEC:
-                /* Set flag for writing of Acs bit */
-                NdefMap->StdMifareContainer.WriteAcsBitFlag = PH_FRINFC_MIFARESTD_FLAG1;
-
-                /* The first NDEF sector is already made read only,
-                   set card state to read only and proceed*/
-                if (NdefMap->CardState != PH_NDEFMAP_CARD_STATE_READ_ONLY)
-                {
-                    Status = phFriNfc_MapTool_SetCardState (NdefMap, NdefMap->TLVStruct.BytesRemainLinTLV);
-                    if (Status != NFCSTATUS_SUCCESS)
-                    {
-                        CRFlag = (uint8_t) PH_FRINFC_MIFARESTD_FLAG1;
-                    }
-                }
-
-                if (CRFlag != PH_FRINFC_MIFARESTD_FLAG1)
-                {
-                    Status = phFriNfc_MifStd_H_ProWrSectorTrailor (NdefMap);
-                    CRFlag = (uint8_t) ((Status != NFCSTATUS_PENDING) ?
-                                       PH_FRINFC_MIFARESTD_FLAG1 :
-                                       PH_FRINFC_MIFARESTD_FLAG0);
-                }
-                break;
-
-            default:
-                Status = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP,
-                                    NFCSTATUS_INVALID_DEVICE_REQUEST);
-                CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
-                break;
-        }
-    }
-    else if (NdefMap->State == PH_FRINFC_NDEFMAP_STATE_AUTH)
-    {
-        NdefMap->StdMifareContainer.PollFlag = PH_FRINFC_MIFARESTD_FLAG1;
-        if(NdefMap->StdMifareContainer.FirstWriteFlag ==
-            PH_FRINFC_MIFARESTD_FLAG1)
-        {
-            NdefMap->StdMifareContainer.FirstWriteFlag =
-                                            PH_FRINFC_MIFARESTD_FLAG0;
-            NdefMap->StdMifareContainer.WrLength =
-                ((NdefMap->StdMifareContainer.NFCforumSectFlag ==
-                PH_FRINFC_MIFARESTD_FLAG0) ?
-                PH_FRINFC_MIFARESTD_VAL1 :
-                NdefMap->StdMifareContainer.WrLength);
-        }
-        if (NdefMap->StdMifareContainer.WrLength == PH_FRINFC_MIFARESTD_VAL0)
-        {
-            Status = PHNFCSTVAL (CID_FRI_NFC_NDEF_MAP,
-                                NFCSTATUS_EOF_NDEF_CONTAINER_REACHED);
-            CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
-        }
-        else
-        {
-            /* Authentication has failed */
-            /* Status = phFriNfc_MifStd_H_CallDisCon(NdefMap);
-            CRFlag = (uint8_t)((Status != NFCSTATUS_PENDING)?
-                        PH_FRINFC_MIFARESTD_FLAG1:
-                        PH_FRINFC_MIFARESTD_FLAG0); */
-            CRFlag = PH_FRINFC_MIFARESTD_FLAG1; /* Call Completion Routine */
-            Status = NFCSTATUS_FAILED;/* Update Status Flag */
-        }
-    }
-    else
-    {
-        Status = PHNFCSTVAL (CID_FRI_NFC_NDEF_MAP,
-                            NFCSTATUS_INVALID_DEVICE_REQUEST);
-        CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
-    }
-     /* Call Completion Routine if CR Flag is Set to 1 */
-    if (CRFlag == PH_FRINFC_MIFARESTD_FLAG1)
-    {
-        phFriNfc_MifStd_H_Complete (NdefMap, Status);
-    }
-
-    return;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_RdABlock
- *
- * Description      This function is a Helper function for Mifare Std. It Reads
- *                  a block from the card.
- *
- * Returns          This function return NFCSTATUS_PENDING in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_RdABlock (phFriNfc_NdefMap_t *NdefMap)
-{
-    NFCSTATUS status = NFCSTATUS_PENDING;
-
-    NdefMap->State = PH_FRINFC_NDEFMAP_STATE_READ;
-    NdefMap->PrevOperation = PH_FRINFC_NDEFMAP_READ_OPE;
-    NdefMap->MapCompletionInfo.CompletionRoutine = phFriNfc_MifareStdMap_Process;
-    NdefMap->MapCompletionInfo.Context = NdefMap;
-
-    if (NdefMap->ApduBuffIndex < (uint16_t) NdefMap->ApduBufferSize)
-    {
-
-        if (NdefMap->StdMifareContainer.internalLength > PH_FRINFC_MIFARESTD_VAL0)
-        {
-            status = phFriNfc_MifStd_H_ChkIntLen (NdefMap);
-        } /* internal Length Check */
-        else
-        {
-            NdefMap->SendRecvBuf [PH_FRINFC_MIFARESTD_VAL0] =
-                        NdefMap->StdMifareContainer.currentBlock;
-            NdefMap->SendLength = MIFARE_MAX_SEND_BUF_TO_READ;
-            *NdefMap->SendRecvLength = NdefMap->TempReceiveLength;
-
-            NdefMap->Cmd.MfCmd = phHal_eMifareRead;
-
-            /* Call the Overlapped HAL Transceive function */
-            status = phFriNfc_ExtnsTransceive (NdefMap->pTransceiveInfo,
-                                          NdefMap->Cmd,
-                                          NdefMap->SendRecvBuf,
-                                          NdefMap->SendLength,
-                                          NdefMap->SendRecvLength);
-        }
-    }
-    else
-    {
-        /* Check for the Card Size */
-        if((((NdefMap->StdMifareContainer.NoOfNdefCompBlocks -
-            NdefMap->StdMifareContainer.NdefBlocks) *
-            PH_FRINFC_MIFARESTD_BYTES_READ) == 0) ||
-            (NdefMap->ApduBufferSize == NdefMap->ApduBuffIndex))
-        {
-            NdefMap->StdMifareContainer.ReadWriteCompleteFlag =
-                (uint8_t) ((((NdefMap->StdMifareContainer.NoOfNdefCompBlocks -
-                NdefMap->StdMifareContainer.NdefBlocks) *
-                PH_FRINFC_MIFARESTD_BYTES_READ) == 0) ?
-                PH_FRINFC_MIFARESTD_FLAG1 :
-                PH_FRINFC_MIFARESTD_FLAG0);
-            *NdefMap->NumOfBytesRead = NdefMap->ApduBuffIndex;
-            status = PHNFCSTVAL (CID_NFC_NONE, NFCSTATUS_SUCCESS);
-        }
-        else
-        {
-            /* Error: The control should not ideally come here. Return Error. */
-            status = PHNFCSTVAL (CID_FRI_NFC_NDEF_MAP, NFCSTATUS_FAILED);
-        }
-    }
-
-    return status;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_WrABlock
- *
- * Description      This function writes into a block of the card.
- *
- * Returns          This function return NFCSTATUS_PENDING in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_WrABlock (phFriNfc_NdefMap_t *NdefMap)
-{
-    NFCSTATUS                   status =  NFCSTATUS_PENDING;
-
-    uint16_t                    RemainingBytes = 0,
-                                BytesRemained = 0,
-                                index = 0;
-    uint8_t                     Temp16Bytes = 0;
-
-    NdefMap->MapCompletionInfo.CompletionRoutine = phFriNfc_MifareStdMap_Process;
-    NdefMap->MapCompletionInfo.Context = NdefMap;
-    NdefMap->PrevOperation = PH_FRINFC_NDEFMAP_WRITE_OPE;
-
-    NdefMap->State = PH_FRINFC_NDEFMAP_STATE_WRITE;
-
-    /* User Buffer Check */
-    if( NdefMap->ApduBuffIndex < (uint16_t) NdefMap->ApduBufferSize)
-    {
-        RemainingBytes = (((uint16_t) (NdefMap->ApduBufferSize -
-                         NdefMap->ApduBuffIndex) <
-                        NdefMap->StdMifareContainer.remainingSize) ?
-                        (uint16_t)(NdefMap->ApduBufferSize -
-                        NdefMap->ApduBuffIndex) :
-                        NdefMap->StdMifareContainer.remainingSize);
-
-        NdefMap->SendRecvBuf[0] = NdefMap->StdMifareContainer.currentBlock;
-        Temp16Bytes += PH_FRINFC_MIFARESTD_INC_1;
-
-        /* Check for internal bytes */
-        if (NdefMap->StdMifareContainer.internalLength > 0)
-        {
-            /* copy the bytes previously written in the internal Buffer */
-            memcpy (&(NdefMap->SendRecvBuf [Temp16Bytes]),
-                    NdefMap->StdMifareContainer.internalBuf,
-                    NdefMap->StdMifareContainer.internalLength);
-
-            Temp16Bytes += (uint8_t) (NdefMap->StdMifareContainer.internalLength);
-            if (RemainingBytes >= (MIFARE_MAX_SEND_BUF_TO_WRITE - Temp16Bytes))
-            {
-                /* Copy the Remaining bytes from the user buffer to make the send
-                    data and length = 16 */
-                memcpy (&(NdefMap->SendRecvBuf [Temp16Bytes]),
-                        NdefMap->ApduBuffer,
-                        (MIFARE_MAX_SEND_BUF_TO_WRITE - Temp16Bytes));
-
-                NdefMap->NumOfBytesWritten =
-                    (MIFARE_MAX_SEND_BUF_TO_WRITE - Temp16Bytes);
-                Temp16Bytes += (MIFARE_MAX_SEND_BUF_TO_WRITE - Temp16Bytes);
-                *NdefMap->DataCount = (Temp16Bytes - PH_FRINFC_MIFARESTD_VAL1);
-            }
-            else
-            {
-                memcpy (&(NdefMap->SendRecvBuf [Temp16Bytes]),
-                        NdefMap->ApduBuffer,
-                        RemainingBytes);
-
-                NdefMap->StdMifareContainer.internalBufFlag = PH_FRINFC_MIFARESTD_FLAG1;
-                NdefMap->NumOfBytesWritten = RemainingBytes;
-                Temp16Bytes += (uint8_t) (RemainingBytes);
-                *NdefMap->DataCount = (Temp16Bytes - PH_FRINFC_MIFARESTD_VAL1);
-
-                BytesRemained = (MIFARE_MAX_SEND_BUF_TO_WRITE - Temp16Bytes);
-                /* Pad empty bytes with Zeroes to complete 16 bytes*/
-                for (index = 0; index < BytesRemained; index++)
-                {
-                    NdefMap->SendRecvBuf [(Temp16Bytes + index)] =
-                                (uint8_t) ((index == PH_FRINFC_MIFARESTD_VAL0) ?
-                                    PH_FRINFC_MIFARESTD_TERMTLV_T :
-                                    PH_FRINFC_MIFARESTD_NULLTLV_T);
-                    NdefMap->TLVStruct.SetTermTLVFlag = PH_FRINFC_MIFARESTD_FLAG1;
-                }
-                Temp16Bytes += (uint8_t) (BytesRemained);
-            }
-        }
-        else
-        {
-            if (RemainingBytes >= (MIFARE_MAX_SEND_BUF_TO_WRITE - Temp16Bytes))
-            {
-                /* Bytes left to write < 16, copy remaining bytes */
-                memcpy (&(NdefMap->SendRecvBuf [
-                        Temp16Bytes]),
-                        &(NdefMap->ApduBuffer [
-                        NdefMap->ApduBuffIndex]),
-                        (MIFARE_MAX_SEND_BUF_TO_WRITE - Temp16Bytes));
-
-                NdefMap->NumOfBytesWritten = (MIFARE_MAX_SEND_BUF_TO_WRITE - Temp16Bytes);
-                Temp16Bytes += (MIFARE_MAX_SEND_BUF_TO_WRITE - Temp16Bytes);
-                *NdefMap->DataCount = (Temp16Bytes - PH_FRINFC_MIFARESTD_VAL1);
-            }
-            else
-            {
-                /* Bytes left to write < 16, copy remaining bytes */
-                memcpy (&(NdefMap->SendRecvBuf [
-                        Temp16Bytes]),
-                        &(NdefMap->ApduBuffer [
-                        NdefMap->ApduBuffIndex]),
-                        RemainingBytes);
-
-                NdefMap->StdMifareContainer.RemainingBufFlag = PH_FRINFC_MIFARESTD_FLAG1;
-                NdefMap->NumOfBytesWritten = RemainingBytes;
-                Temp16Bytes += (uint8_t) (RemainingBytes);
-                *NdefMap->DataCount = (Temp16Bytes - PH_FRINFC_MIFARESTD_VAL1);
-
-
-                /* Pad empty bytes with Zeroes to complete 16 bytes */
-                for (index = Temp16Bytes; index < MIFARE_MAX_SEND_BUF_TO_WRITE; index++)
-                {
-                    NdefMap->SendRecvBuf [index] = (uint8_t) ((index ==
-                                    Temp16Bytes) ?
-                                    PH_FRINFC_MIFARESTD_TERMTLV_T :
-                                    PH_FRINFC_MIFARESTD_NULLTLV_T);
-
-                    NdefMap->TLVStruct.SetTermTLVFlag = PH_FRINFC_MIFARESTD_FLAG1;
-                }
-            }
-        }
-        /* Buffer to store 16 bytes which is writing to the present block */
-        memcpy (NdefMap->StdMifareContainer.Buffer,
-                &(NdefMap->SendRecvBuf [PH_FRINFC_MIFARESTD_INC_1]),
-                PH_FRINFC_MIFARESTD_BLOCK_BYTES);
-
-        /* Write from here */
-        NdefMap->SendLength = MIFARE_MAX_SEND_BUF_TO_WRITE;
-        NdefMap->Cmd.MfCmd = phHal_eMifareWrite16;
-        *NdefMap->SendRecvLength = NdefMap->TempReceiveLength;
-        /* Call the Overlapped HAL Transceive function */
-        status = phFriNfc_ExtnsTransceive (NdefMap->pTransceiveInfo,
-                                      NdefMap->Cmd,
-                                      NdefMap->SendRecvBuf,
-                                      NdefMap->SendLength,
-                                      NdefMap->SendRecvLength);
-    }
-    else /* Check User Buffer */
-    {
-        if (NdefMap->StdMifareContainer.NdefBlocks >
-             NdefMap->StdMifareContainer.NoOfNdefCompBlocks)
-        {
-            NdefMap->StdMifareContainer.ReadWriteCompleteFlag =
-                PH_FRINFC_MIFARESTD_FLAG1;
-            status = PHNFCSTVAL (CID_NFC_NONE,
-                                NFCSTATUS_SUCCESS);
-        }
-        else if (NdefMap->ApduBuffIndex == (uint16_t) NdefMap->ApduBufferSize)
-        {
-            status = PHNFCSTVAL (CID_NFC_NONE, NFCSTATUS_SUCCESS);
-        }
-        else
-        {
-            /* Error: The control should not ideally come here. Return Error. */
-            status = PHNFCSTVAL (CID_FRI_NFC_NDEF_MAP, NFCSTATUS_FAILED);
-        }
-    }
-
-    return status;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_AuthSector
- *
- * Description      This function authenticates one sector at a time.
- *
- * Returns          This function return NFCSTATUS_PENDING in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_AuthSector (phFriNfc_NdefMap_t *NdefMap)
-{
-    NFCSTATUS status = NFCSTATUS_PENDING;
-
-    NdefMap->MapCompletionInfo.CompletionRoutine = phFriNfc_MifareStdMap_Process;
-    NdefMap->MapCompletionInfo.Context = NdefMap;
-
-    *NdefMap->SendRecvLength = NdefMap->TempReceiveLength;
-    NdefMap->State = PH_FRINFC_NDEFMAP_STATE_AUTH;
-
-    /* Authenticate */
-    NdefMap->Cmd.MfCmd = phHal_eMifareAuthentA;
-
-    NdefMap->SendRecvBuf [PH_FRINFC_MIFARESTD_VAL0] =
-                            ((NdefMap->TLVStruct.NdefTLVAuthFlag ==
-                                PH_FRINFC_MIFARESTD_FLAG1) ?
-                                NdefMap->TLVStruct.NdefTLVBlock :
-                                NdefMap->StdMifareContainer.currentBlock);
-
-    /* if MAD blocks then authentication key is
-        0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5 else
-        0xD3, 0xF7, 0xD3, 0xF7, 0xD3, 0xF7 */
-    if (((NdefMap->StdMifareContainer.currentBlock != PH_FRINFC_MIFARESTD_MAD_BLK0) &&
-        (NdefMap->StdMifareContainer.currentBlock != PH_FRINFC_MIFARESTD_MAD_BLK1) &&
-        (NdefMap->StdMifareContainer.currentBlock != PH_FRINFC_MIFARESTD_MAD_BLK2) &&
-        (NdefMap->StdMifareContainer.currentBlock != PH_FRINFC_MIFARESTD_MAD_BLK64) &&
-        (NdefMap->StdMifareContainer.currentBlock != PH_FRINFC_MIFARESTD_MAD_BLK65) &&
-        (NdefMap->StdMifareContainer.currentBlock != PH_FRINFC_MIFARESTD_MAD_BLK66)) ||
-        (NdefMap->TLVStruct.NdefTLVAuthFlag ==
-                                (uint8_t) PH_FRINFC_MIFARESTD_FLAG1))
-    {
-        NdefMap->SendRecvBuf [1] = PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_NDEFSECT1; /* 0xD3 */
-        NdefMap->SendRecvBuf [2] = PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_NDEFSECT2; /* 0xF7 */
-        NdefMap->SendRecvBuf [3] = PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_NDEFSECT1; /* 0xD3 */
-        NdefMap->SendRecvBuf [4] = PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_NDEFSECT2; /* 0xF7 */
-        NdefMap->SendRecvBuf [5] = PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_NDEFSECT1; /* 0xD3 */
-        NdefMap->SendRecvBuf [6] = PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_NDEFSECT2; /* 0xF7 */
-    }
-    else
-    {
-        NdefMap->SendRecvBuf [1] = PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_MADSECT1; /* 0xA0 */
-        NdefMap->SendRecvBuf [2] = PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_MADSECT2; /* 0xA1 */
-        NdefMap->SendRecvBuf [3] = PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_MADSECT3; /* 0xA2 */
-        NdefMap->SendRecvBuf [4] = PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_MADSECT4; /* 0xA3 */
-        NdefMap->SendRecvBuf [5] = PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_MADSECT5; /* 0xA4 */
-        NdefMap->SendRecvBuf [6] = PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_MADSECT6; /* 0xA5 */
-    }
-
-    if (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_1K_CARD ||
-        NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD ||
-        NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD)
-    {
-        if (NdefMap->StdMifareContainer.ReadOnlySectorIndex &&
-            NdefMap->StdMifareContainer.SectorTrailerBlockNo == NdefMap->StdMifareContainer.currentBlock)
-        {
-            memcpy (&NdefMap->SendRecvBuf [1], &NdefMap->StdMifareContainer.UserScrtKeyB [0], PH_FRINFC_MIFARESTD_KEY_LEN);
-
-            /* Authenticate with KeyB */
-            NdefMap->Cmd.MfCmd = phHal_eMifareAuthentB;
-        }
-    }
-
-    NdefMap->SendLength = MIFARE_AUTHENTICATE_CMD_LENGTH;
-    *NdefMap->SendRecvLength = NdefMap->TempReceiveLength;
-    /* Call the Overlapped HAL Transceive function */
-    status = phFriNfc_ExtnsTransceive (NdefMap->pTransceiveInfo,
-                                      NdefMap->Cmd,
-                                      NdefMap->SendRecvBuf,
-                                      NdefMap->SendLength,
-                                      NdefMap->SendRecvLength);
-
-    return status;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_Complete
- *
- * Description      It is used to call the Completion Routine
- *
- * Returns          void
- *
- ******************************************************************************/
-static void phFriNfc_MifStd_H_Complete (phFriNfc_NdefMap_t *NdefMap,
-                                        NFCSTATUS          Result)
-{
-    /* set the state back to the Reset_Init state */
-    NdefMap->State = PH_FRINFC_NDEFMAP_STATE_RESET_INIT;
-
-    /* set the completion routine */
-    NdefMap->CompletionRoutine [NdefMap->StdMifareContainer.CRIndex].
-            CompletionRoutine (NdefMap->CompletionRoutine->Context, Result);
-
-    return;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd4k_H_CheckNdef
- *
- * Description      This function is used for Mifare 4k Check Ndef to
- *                  get the next AID blocks.
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd4k_H_CheckNdef (phFriNfc_NdefMap_t *NdefMap)
-{
-    NFCSTATUS Result = NFCSTATUS_SUCCESS;
-
-    /* Get the AID Block */
-    if (NdefMap->StdMifareContainer.currentBlock == PH_FRINFC_MIFARESTD_MAD_BLK2)
-    {
-        NdefMap->StdMifareContainer.currentBlock = PH_FRINFC_MIFARESTD_MAD_BLK64;
-        NdefMap->StdMifareContainer.AuthDone = PH_FRINFC_MIFARESTD_FLAG0;
-    }
-    else if (NdefMap->StdMifareContainer.currentBlock == PH_FRINFC_MIFARESTD_MAD_BLK64)
-    {
-        NdefMap->StdMifareContainer.currentBlock = PH_FRINFC_MIFARESTD_MAD_BLK65;
-    }
-    else
-    {
-        NdefMap->StdMifareContainer.currentBlock = PH_FRINFC_MIFARESTD_MAD_BLK66;
-    }
-
-    Result = phFriNfc_MifareStdMap_ChkNdef (NdefMap);
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_fillAIDarray
- *
- * Description      This function storew the AIDs for check ndef.
- *
- * Returns          void
- *
- ******************************************************************************/
-static void phFriNfc_MifStd_H_fillAIDarray (phFriNfc_NdefMap_t *NdefMap)
-{
-    uint8_t byteindex = 0;
-
-    if ((NdefMap->StdMifareContainer.currentBlock == PH_FRINFC_MIFARESTD_MAD_BLK1) ||
-        (NdefMap->StdMifareContainer.currentBlock == PH_FRINFC_MIFARESTD_MAD_BLK64))
-    {
-        /* The First Two Bytes in Receive Buffer
-            are CRC bytes so it is not copied
-            instead, 0 is copied in AID[0] & AID[1] */
-        NdefMap->StdMifareContainer.aid [NdefMap->StdMifareContainer.SectorIndex] =
-                                    PH_FRINFC_MIFARESTD_NON_NDEF_COMP;
-        NdefMap->StdMifareContainer.SectorIndex++;
-        byteindex = 2;
-    }
-
-    while (byteindex < PH_FRINFC_MIFARESTD_BYTES_READ)
-    {
-        if ((NdefMap->SendRecvBuf [byteindex] == PH_FRINFC_NDEFMAP_MIFARESTD_NDEF_COMPVAL2) &&
-            (NdefMap->SendRecvBuf [(byteindex + 1)] == PH_FRINFC_NDEFMAP_MIFARESTD_NDEF_COMPVAL1))
-        {
-            /* This flag is set when a NFC forum sector is found in a
-                MAD block for the first time */
-            NdefMap->StdMifareContainer.NFCforumSectFlag = PH_FRINFC_MIFARESTD_FLAG1;
-            NdefMap->StdMifareContainer.aid[NdefMap->StdMifareContainer.SectorIndex] =
-                                        PH_FRINFC_MIFARESTD_NDEF_COMP;
-            NdefMap->StdMifareContainer.SectorIndex++;
-        }
-        else
-        {
-            NdefMap->StdMifareContainer.aid [NdefMap->StdMifareContainer.SectorIndex] =
-                                    PH_FRINFC_MIFARESTD_NON_NDEF_COMP;
-            NdefMap->StdMifareContainer.SectorIndex++;
-            /* AID complete flag is set when a non NFC forum sector is found in a
-               MAD block after the NFC forum sector. After setting this, all other
-               values are ignored and are NOT NDEF compliant */
-            NdefMap->StdMifareContainer.aidCompleteFlag =
-                ((NdefMap->StdMifareContainer.NFCforumSectFlag ==
-                    PH_FRINFC_MIFARESTD_FLAG1) ?
-                    PH_FRINFC_MIFARESTD_FLAG1 :
-                    PH_FRINFC_MIFARESTD_FLAG0);
-
-            NdefMap->StdMifareContainer.NFCforumSectFlag = PH_FRINFC_MIFARESTD_FLAG0;
-            if (NdefMap->StdMifareContainer.aidCompleteFlag == PH_FRINFC_MIFARESTD_FLAG1)
-            {
-                break;
-            }
-        }
-        byteindex += 2;
-    }
-
-    /* If "aidCompleteFlag" is set then the remaining sectors are made NOT
-       NDEF compliant */
-    if ((NdefMap->StdMifareContainer.aidCompleteFlag == PH_FRINFC_MIFARESTD_FLAG1) &&
-        (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_1K_CARD))
-    {
-        /* for Mifare 1k there are 16 sectors, till this number all sectors
-           are made NOT NDEF compliant */
-        for (byteindex = NdefMap->StdMifareContainer.SectorIndex;
-             byteindex < PH_FRINFC_MIFARESTD1K_TOTAL_SECTOR;
-             byteindex++)
-        {
-             NdefMap->StdMifareContainer.aid [byteindex] =
-                                    PH_FRINFC_MIFARESTD_NON_NDEF_COMP;
-        }
-    }
-    else if ((NdefMap->StdMifareContainer.aidCompleteFlag == PH_FRINFC_MIFARESTD_FLAG1) &&
-             (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD))
-    {
-        /* for Mifare 2k there are 32 sectors, till this number all sectors
-           are made NOT NDEF compliant */
-        for (byteindex = NdefMap->StdMifareContainer.SectorIndex;
-             byteindex < PH_FRINFC_MIFARESTD2K_TOTAL_SECTOR;
-             byteindex++)
-        {
-            NdefMap->StdMifareContainer.aid[byteindex] =
-                                   PH_FRINFC_MIFARESTD_NON_NDEF_COMP;
-        }
-    }
-    else
-    {
-        /* for Mifare 4k there are 40 sectors, till this number all sectors
-           are made NOT NDEF compliant */
-        if ((NdefMap->StdMifareContainer.aidCompleteFlag == PH_FRINFC_MIFARESTD_FLAG1) &&
-            (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD))
-        {
-            for(byteindex = NdefMap->StdMifareContainer.SectorIndex;
-                byteindex < PH_FRINFC_MIFARESTD4K_TOTAL_SECTOR;
-                byteindex++)
-            {
-                NdefMap->StdMifareContainer.aid [byteindex] =
-                                        PH_FRINFC_MIFARESTD_NON_NDEF_COMP;
-            }
-        }
-    }
-
-    return;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_BlkChk
- *
- * Description      This function is to check the Ndef compliance of the
- *                  current block, if the block is not Ndef Compliant,
- *                  increment the block till the next Ndef compliant block
- *                  using the Get Sector Helper function
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_BlkChk (phFriNfc_NdefMap_t *NdefMap)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-    uint8_t     SectorID = 0, callbreak = 0;
-
-    for (;;)
-    {
-        /* Get a Sector ID for the Current Block */
-        SectorID = phFriNfc_MifStd_H_GetSect (NdefMap->StdMifareContainer.currentBlock);
-        /* Check the card Type 1k or 4k */
-        /* enter if Mifare 1k card. For Mifare 4k go to else */
-        if (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_1K_CARD)
-        {
-            /* if Sector Id > 15 No Sectors to write */
-            if (SectorID > 15)
-            {
-                SectorID = phFriNfc_MifStd_H_GetSect (NdefMap->StdMifareContainer.currentBlock);
-                /*Error: No Ndef Compliant Sectors present */
-                Result = PHNFCSTVAL (CID_FRI_NFC_NDEF_MAP,
-                                    NFCSTATUS_INVALID_PARAMETER);
-                callbreak = 1;
-            }
-            else
-            {
-                phFriNfc_MifStd1k_H_BlkChk (NdefMap, SectorID, &callbreak);
-            }
-        } /* End of if */ /* End of Mifare 1k check */
-        else if (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD) /* Mifare 2k check starts here */
-        {
-             /* Sector > 39 no ndef compliant sectors found*/
-            if (SectorID > PH_FRINFC_MIFARESTD_SECTOR_NO31)
-            {
-                 /*Error: No Ndef Compliant Sectors present */
-                Result = PHNFCSTVAL (CID_FRI_NFC_NDEF_MAP,
-                                    NFCSTATUS_INVALID_PARAMETER);
-                callbreak = 1;
-            }
-            else if (NdefMap->StdMifareContainer.currentBlock == PH_FRINFC_MIFARESTD_MAD_BLK64)
-            {
-                NdefMap->StdMifareContainer.currentBlock += PH_FRINFC_MIFARESTD_BLK4;
-            }
-            else if (SectorID < PH_FRINFC_MIFARESTD_SECTOR_NO32) /* sector < 32 contains 4 blocks in each sector */
-            {
-                 /* If the block checked is 63, the 3 blocks after this
-                     are AID(MAD) blocks so its need to be skipped */
-                if (NdefMap->StdMifareContainer.currentBlock == PH_FRINFC_MIFARESTD_MAD_BLK63)
-                {
-                    NdefMap->StdMifareContainer.currentBlock += PH_FRINFC_MIFARESTD_BLK4;
-                }
-                else
-                {
-                    phFriNfc_MifStd1k_H_BlkChk (NdefMap, SectorID, &callbreak);
-                }
-            }
-            else
-            {
-                phFriNfc_MifStd1k_H_BlkChk (NdefMap, SectorID, &callbreak);
-            }
-        }/* End of if*/ /* End of Mifare 2k check*/
-        else /* Mifare 4k check starts here */
-        {
-            /* Sector > 39 no ndef compliant sectors found*/
-            if (SectorID > PH_FRINFC_MIFARESTD_SECTOR_NO39)
-            {
-                /*Error: No Ndef Compliant Sectors present */
-                Result = PHNFCSTVAL (CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_PARAMETER);
-                callbreak = 1;
-            }
-            else if (NdefMap->StdMifareContainer.currentBlock == PH_FRINFC_MIFARESTD_MAD_BLK64)
-            {
-                NdefMap->StdMifareContainer.currentBlock += PH_FRINFC_MIFARESTD_BLK4;
-            }
-            else if (SectorID < PH_FRINFC_MIFARESTD_SECTOR_NO32) /* sector < 32 contains 4 blocks in each sector */
-            {
-                /* If the block checked is 63, the 3 blocks after this
-                   are AID(MAD) blocks so its need to be skipped */
-                if (NdefMap->StdMifareContainer.currentBlock == PH_FRINFC_MIFARESTD_MAD_BLK63)
-                {
-                    NdefMap->StdMifareContainer.currentBlock += PH_FRINFC_MIFARESTD_BLK4;
-                }
-                else
-                {
-                    phFriNfc_MifStd1k_H_BlkChk (NdefMap, SectorID, &callbreak);
-                }
-            }
-            else
-            {
-                /* every last block of a sector needs to be skipped */
-                if (((NdefMap->StdMifareContainer.currentBlock + 1) %
-                    PH_FRINFC_MIFARESTD_BLOCK_BYTES) == 0)
-                {
-                    NdefMap->StdMifareContainer.currentBlock++;
-                }
-                else
-                {
-                    if (NdefMap->StdMifareContainer.aid [SectorID] ==
-                            PH_FRINFC_MIFARESTD_NDEF_COMP)
-                    {
-                        /* Check whether the block is first block of a (next)new sector and
-                            also check if it is first block then internal length is zero
-                            or not. Because once Authentication is done for the sector again
-                            we should not authenticate it again */
-                        /* In this case 32 sectors contains 4 blocks and next remaining 8 sectors
-                            contains 16 blocks that is why (32 * 4) + (sectorID - 32) *16*/
-                        if ((NdefMap->StdMifareContainer.currentBlock ==
-                            ((PH_FRINFC_MIFARESTD_SECTOR_NO32 * PH_FRINFC_MIFARESTD_BLK4) +
-                            ((SectorID - PH_FRINFC_MIFARESTD_SECTOR_NO32) * PH_FRINFC_MIFARESTD_BLOCK_BYTES))) &&
-                            (NdefMap->StdMifareContainer.internalLength == 0))
-                        {
-                            NdefMap->StdMifareContainer.AuthDone = 0;
-                        }
-                        callbreak = 1;
-                    }
-                    else
-                    {
-                        NdefMap->StdMifareContainer.currentBlock += 16;
-                    }
-                }
-            }
-        }
-        if (callbreak == 1)
-        {
-            break;
-        }
-    }
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_GetSect
- *
- * Description      This function  to get the Sector from the current block
- *
- * Returns          uint8_t SectorID
- *
- ******************************************************************************/
-static uint8_t phFriNfc_MifStd_H_GetSect (uint8_t BlockNumber)
-{
-    uint8_t SectorID = 0;
-
-    if (BlockNumber >= PH_FRINFC_MIFARESTD4K_BLK128)
-    {
-        SectorID = (uint8_t) (PH_FRINFC_MIFARESTD_SECTOR_NO32 +
-                    ((BlockNumber - PH_FRINFC_MIFARESTD4K_BLK128)/
-                    PH_FRINFC_MIFARESTD_BLOCK_BYTES));
-    }
-    else
-    {
-        SectorID = (BlockNumber/PH_FRINFC_MIFARESTD_BLK4);
-    }
-
-    return SectorID;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_RdAcsBit
- *
- * Description      It read the access bits of each sector.
- *                  NCI messages.
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_RdAcsBit (phFriNfc_NdefMap_t *NdefMap)
-{
-    NFCSTATUS Result = NFCSTATUS_SUCCESS;
-
-    NdefMap->State = PH_FRINFC_NDEFMAP_STATE_RD_ACS_BIT;
-
-    if (NdefMap->StdMifareContainer.ReadOnlySectorIndex &&
-        NdefMap->StdMifareContainer.currentBlock == NdefMap->StdMifareContainer.SectorTrailerBlockNo)
-    {
-        NdefMap->State = PH_FRINFC_NDEFMAP_STATE_RD_SEC_ACS_BIT;
-    }
-
-    if (NdefMap->StdMifareContainer.ReadAcsBitFlag == PH_FRINFC_MIFARESTD_FLAG1)
-    {
-        /* Get the sector trailer */
-        ((NdefMap->StdMifareContainer.currentBlock > 127) ?
-            phFriNfc_MifStd_H_Get4kStTrail(NdefMap) :
-            phFriNfc_MifStd_H_Get1kStTrail(NdefMap));
-    }
-    else
-    {
-        /* Give the current block to read */
-        NdefMap->SendRecvBuf [PH_FRINFC_MIFARESTD_VAL0] =
-                        NdefMap->StdMifareContainer.currentBlock;
-    }
-
-    Result = phFriNfc_MifStd_H_Rd16Bytes(NdefMap,
-                        NdefMap->SendRecvBuf [PH_FRINFC_MIFARESTD_VAL0]);
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_ChkAcsBit
- *
- * Description      This function check the access bits of each sector.
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_ChkAcsBit (phFriNfc_NdefMap_t *NdefMap)
-{
-    NFCSTATUS Result = NFCSTATUS_SUCCESS;
-
-    /* Blocks from 0 to 3 and from 64 to 67(MAD blocks) */
-    if ((NdefMap->StdMifareContainer.currentBlock == PH_FRINFC_MIFARESTD_MAD_BLK0) ||
-        (NdefMap->StdMifareContainer.currentBlock == PH_FRINFC_MIFARESTD_MAD_BLK1) ||
-        (NdefMap->StdMifareContainer.currentBlock == PH_FRINFC_MIFARESTD_MAD_BLK2) ||
-        (NdefMap->StdMifareContainer.currentBlock == PH_FRINFC_MIFARESTD_MAD_BLK3) ||
-        (NdefMap->StdMifareContainer.currentBlock == PH_FRINFC_MIFARESTD_MAD_BLK64) ||
-        (NdefMap->StdMifareContainer.currentBlock == PH_FRINFC_MIFARESTD_MAD_BLK65) ||
-        (NdefMap->StdMifareContainer.currentBlock == PH_FRINFC_MIFARESTD_MAD_BLK66) )
-    {
-        /* Access bits check removed for the MAD blocks */
-#ifdef ENABLE_ACS_BIT_CHK_FOR_MAD
-
-        if (((NdefMap->SendRecvBuf [
-            PH_FRINFC_MIFARESTD_VAL6] &
-            PH_FRINFC_MIFARESTD_MASK_FF) ==
-            PH_FRINFC_MIFARESTD_MADSECT_ACS_BYTE6) &&
-            ((NdefMap->SendRecvBuf [
-            PH_FRINFC_MIFARESTD_VAL7] &
-            PH_FRINFC_MIFARESTD_MASK_FF) ==
-            PH_FRINFC_MIFARESTD_MADSECT_ACS_BYTE7) &&
-            ((NdefMap->SendRecvBuf [
-            PH_FRINFC_MIFARESTD_VAL8] &
-            PH_FRINFC_MIFARESTD_MASK_FF) ==
-            PH_FRINFC_MIFARESTD_ACS_BYTE8))
-        {
-            NdefMap->StdMifareContainer.WriteFlag =
-                PH_FRINFC_MIFARESTD_FLAG0;
-            NdefMap->StdMifareContainer.ReadFlag =
-                PH_FRINFC_MIFARESTD_FLAG1;
-        }
-        else
-        {
-            NdefMap->StdMifareContainer.WriteFlag =
-                PH_FRINFC_MIFARESTD_FLAG0;
-            NdefMap->StdMifareContainer.ReadFlag =
-                PH_FRINFC_MIFARESTD_FLAG0;
-        }
-
-#else /* #ifdef ENABLE_ACS_BIT_CHK_FOR_MAD */
-
-        NdefMap->CardState = PH_NDEFMAP_CARD_STATE_INITIALIZED;
-
-#endif /* #ifdef ENABLE_ACS_BIT_CHK_FOR_MAD */
-    }
-    else
-    {
-        /* Check for Access bytes 6, 7 and 8 value =
-            0x7F, 0x07, 0x88 NFC forum sectors*/
-        if (((NdefMap->SendRecvBuf [
-            PH_FRINFC_MIFARESTD_VAL6] &
-            PH_FRINFC_MIFARESTD_MASK_FF) ==
-            PH_FRINFC_MIFARESTD_NFCSECT_ACS_BYTE6) &&
-            ((NdefMap->SendRecvBuf [
-            PH_FRINFC_MIFARESTD_VAL7] &
-            PH_FRINFC_MIFARESTD_MASK_FF) ==
-            PH_FRINFC_MIFARESTD_NFCSECT_ACS_BYTE7) &&
-            ((NdefMap->SendRecvBuf [
-            PH_FRINFC_MIFARESTD_VAL8] &
-            PH_FRINFC_MIFARESTD_MASK_FF) ==
-            PH_FRINFC_MIFARESTD_ACS_BYTE8))
-        {
-            NdefMap->StdMifareContainer.WriteFlag =
-                PH_FRINFC_MIFARESTD_FLAG1;
-            NdefMap->StdMifareContainer.ReadFlag =
-                PH_FRINFC_MIFARESTD_FLAG1;
-        }
-        else if (((NdefMap->SendRecvBuf [
-            PH_FRINFC_MIFARESTD_VAL6] &
-            PH_FRINFC_MIFARESTD_MASK_FF) ==
-            PH_FRINFC_MIFARESTD_NFCSECT_RDACS_BYTE6) &&
-            ((NdefMap->SendRecvBuf [
-            PH_FRINFC_MIFARESTD_VAL7] &
-            PH_FRINFC_MIFARESTD_MASK_FF) ==
-            PH_FRINFC_MIFARESTD_NFCSECT_RDACS_BYTE7) &&
-            ((NdefMap->SendRecvBuf [
-            PH_FRINFC_MIFARESTD_VAL8] &
-            PH_FRINFC_MIFARESTD_MASK_FF) ==
-            PH_FRINFC_MIFARESTD_NFCSECT_RDACS_BYTE8))
-        {
-            /* Read Only state */
-            /* Check for Access bytes 6, 7 and 8 value =
-                0x55, 0xAD, 0x2A NFC forum Sectors */
-            NdefMap->StdMifareContainer.WriteFlag =
-                PH_FRINFC_MIFARESTD_FLAG0;
-            NdefMap->StdMifareContainer.ReadFlag =
-                PH_FRINFC_MIFARESTD_FLAG1;
-        }
-        else
-        {
-            NdefMap->StdMifareContainer.WriteFlag =
-                PH_FRINFC_MIFARESTD_FLAG0;
-            NdefMap->StdMifareContainer.ReadFlag =
-                PH_FRINFC_MIFARESTD_FLAG0;
-        }
-
-#ifdef ENABLE_ACS_BIT_CHK_FOR_MAD
-        /* Do nothing */
-#else /* #ifdef ENABLE_ACS_BIT_CHK_FOR_MAD */
-        Result = phFriNfc_MifStd_H_GPBChk (NdefMap);
-#endif /* #ifdef ENABLE_ACS_BIT_CHK_FOR_MAD */
-    }
-
-#ifdef ENABLE_ACS_BIT_CHK_FOR_MAD
-    Result = phFriNfc_MifStd_H_GPBChk (NdefMap);
-#endif /* #ifdef ENABLE_ACS_BIT_CHK_FOR_MAD */
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_ChkRdWr
- *
- * Description      This function is for read access bits, depending
- *                  on the read/write/check ndef function called.
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_ChkRdWr (phFriNfc_NdefMap_t *NdefMap)
-{
-    NFCSTATUS Result = NFCSTATUS_SUCCESS;
-
-    switch (NdefMap->PrevOperation)
-    {
-        case PH_FRINFC_NDEFMAP_CHECK_OPE:
-            if (NdefMap->CardState == PH_NDEFMAP_CARD_STATE_INVALID)
-            {
-                /* No permission to read */
-                Result = PHNFCSTVAL (CID_FRI_NFC_NDEF_MAP,
-                                    NFCSTATUS_READ_FAILED);
-            }
-            else if ((NdefMap->StdMifareContainer.currentBlock > 3) &&
-                (NdefMap->StdMifareContainer.ChkNdefCompleteFlag ==
-                                    PH_FRINFC_MIFARESTD_FLAG1) &&
-                (NdefMap->StdMifareContainer.currentBlock !=
-                            PH_FRINFC_MIFARESTD_MAD_BLK65) &&
-                (NdefMap->StdMifareContainer.currentBlock !=
-                            PH_FRINFC_MIFARESTD_MAD_BLK66))
-            {
-               /* NdefMap->StdMifareContainer.currentBlock =
-                    ((NdefMap->StdMifareContainer.ReadCompleteFlag ==
-                        PH_FRINFC_MIFARESTD_FLAG1)?
-                        NdefMap->StdMifareContainer.currentBlock:
-                        (NdefMap->StdMifareContainer.currentBlock +
-                        PH_FRINFC_MIFARESTD_VAL4));
-                NdefMap->StdMifareContainer.currentBlock =
-                    ((NdefMap->StdMifareContainer.currentBlock ==
-                        PH_FRINFC_MIFARESTD_MAD_BLK64)?
-                    (NdefMap->StdMifareContainer.currentBlock +
-                    PH_FRINFC_MIFARESTD_VAL4):
-                    NdefMap->StdMifareContainer.currentBlock);*/
-
-                Result = ((NdefMap->StdMifareContainer.ReadAcsBitFlag ==
-                                PH_FRINFC_MIFARESTD_FLAG0)?
-                                phFriNfc_MifStd_H_RdAcsBit(NdefMap):
-                                phFriNfc_MifStd_H_AuthSector(NdefMap));
-            }
-            else
-            {
-                Result = phFriNfc_MifareStdMap_ChkNdef (NdefMap);
-            }
-            break;
-
-        case PH_FRINFC_NDEFMAP_READ_OPE:
-            if (NdefMap->CardState == PH_NDEFMAP_CARD_STATE_INVALID)
-            {
-                /* No permission to Read */
-                Result = PHNFCSTVAL (CID_FRI_NFC_NDEF_MAP, NFCSTATUS_READ_FAILED);
-            }
-            else if (NdefMap->StdMifareContainer.ReadNdefFlag == PH_FRINFC_MIFARESTD_FLAG1)
-            {
-                Result = phFriNfc_MifStd_H_GetActCardLen (NdefMap);
-            }
-            else
-            {
-                Result = phFriNfc_MifStd_H_RdABlock (NdefMap);
-            }
-            break;
-
-        case PH_FRINFC_NDEFMAP_WRITE_OPE:
-            if ((NdefMap->CardState ==
-                PH_NDEFMAP_CARD_STATE_INVALID) ||
-                (NdefMap->CardState ==
-                PH_NDEFMAP_CARD_STATE_READ_ONLY))
-            {
-                /* No permission to Read */
-                Result = PHNFCSTVAL (CID_FRI_NFC_NDEF_MAP,
-                                    NFCSTATUS_WRITE_FAILED);
-            }
-            else if (NdefMap->StdMifareContainer.WrNdefFlag ==
-                    PH_FRINFC_MIFARESTD_FLAG1)
-            {
-                Result = phFriNfc_MifStd_H_GetActCardLen (NdefMap);
-            }
-            else if (NdefMap->StdMifareContainer.RdBeforeWrFlag ==
-                    PH_FRINFC_MIFARESTD_FLAG1)
-            {
-                /*NdefMap->StdMifareContainer.ReadFlag =
-                                PH_FRINFC_MIFARESTD_FLAG0;*/
-                Result = phFriNfc_MifStd_H_RdBeforeWr (NdefMap);
-            }
-            else if (NdefMap->StdMifareContainer.RdAfterWrFlag ==
-                    PH_FRINFC_MIFARESTD_FLAG1)
-            {
-                Result = phFriNfc_MifStd_H_RdtoWrNdefLen (NdefMap);
-            }
-            else
-            {
-                Result = (((NdefMap->TLVStruct.NdefTLVBlock ==
-                            NdefMap->StdMifareContainer.currentBlock) &&
-                            (NdefMap->Offset ==
-                            PH_FRINFC_NDEFMAP_SEEK_BEGIN)) ?
-                            phFriNfc_MifStd_H_RdBeforeWr (NdefMap) :
-                            phFriNfc_MifStd_H_WrABlock (NdefMap));
-            }
-            break;
-
-        case PH_FRINFC_NDEFMAP_GET_ACTSIZE_OPE:
-            Result = ((NdefMap->StdMifareContainer.ReadFlag ==
-                        PH_FRINFC_MIFARESTD_FLAG0) ?
-                        (PHNFCSTVAL (CID_FRI_NFC_NDEF_MAP,
-                        NFCSTATUS_READ_FAILED)) :
-                        phFriNfc_MifStd_H_GetActCardLen (NdefMap));
-            break;
-
-        default:
-            /* Operation is not correct */
-            Result = PHNFCSTVAL (CID_FRI_NFC_NDEF_MAP,
-                                NFCSTATUS_INVALID_PARAMETER);
-
-            break;
-    }
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_ChkNdefCmpltSects
- *
- * Description      This function is used to check ndef to check the
- *                  ndef compliant sectors.
- *
- * Returns          void
- *
- ******************************************************************************/
-static void phFriNfc_MifStd_H_ChkNdefCmpltSects (phFriNfc_NdefMap_t *NdefMap)
-{
-    uint8_t index = 0;
-    uint8_t index_max_4k_2k= 0;
-    if (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD)
-    {
-        index_max_4k_2k = PH_FRINFC_MIFARESTD4K_TOTAL_SECTOR;
-    }
-    else
-    {
-        index_max_4k_2k = PH_FRINFC_MIFARESTD2K_TOTAL_SECTOR;
-    }
-
-    if (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD || NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD)
-    {
-        for (index = PH_FRINFC_MIFARESTD_SECTOR_NO1; index < index_max_4k_2k; index++)/*Block 0 is MAD block, so it should start with 1*/
-        {
-            /* For Mifare 4k, Block 0 to 31 contains 4 blocks */
-            /* sector 0 and 15 are aid blocks */
-            if (index != PH_FRINFC_MIFARESTD_SECTOR_NO16)
-            {
-                if (((index < 32) && (index != PH_FRINFC_MIFARESTD_SECTOR_NO0))
-                    && (NdefMap->StdMifareContainer.aid [index] ==
-                            PH_FRINFC_MIFARESTD_NON_NDEF_COMP))
-                {
-                    /* Only 3 blocks can be read/written till sector 31 */
-                    NdefMap->StdMifareContainer.NoOfNdefCompBlocks -=
-                                                PH_FRINFC_MIFARESTD_MAD_BLK3;
-
-                }
-                else
-                {
-                    /* For Mifare 4k, Block 32 to 39 contains 16 blocks */
-                    if(NdefMap->StdMifareContainer.aid [index] ==
-                        PH_FRINFC_MIFARESTD_NON_NDEF_COMP)
-                    {
-                        /* Only 15 blocks can be read/written from sector 31 */
-                        NdefMap->StdMifareContainer.NoOfNdefCompBlocks -=
-                                                PH_FRINFC_MIFARESTD_BLK15;
-                    }
-                }
-            }
-        } /* For index > 40 */
-    }
-    else
-    {
-        for (index = PH_FRINFC_MIFARESTD_SECTOR_NO1;
-            index < PH_FRINFC_MIFARESTD_SECTOR_NO16; index++)
-        {
-            if (NdefMap->StdMifareContainer.aid [index] ==
-                PH_FRINFC_MIFARESTD_NON_NDEF_COMP)
-            {
-                /*  Only three blocks can be read/written in
-                    a sector. So if a sector is non-ndef
-                    compliant, decrement 3 */
-                NdefMap->StdMifareContainer.NoOfNdefCompBlocks -=
-                                        PH_FRINFC_MIFARESTD_MAD_BLK3;
-            }
-        }
-    }
-
-    return;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_RemainTLV
- *
- * Description      This function is used for read ndef to process the
- *                  remaining bytes of length (L) in the TLV.
- *
- * Returns          This function return NFCSTATUS_PENDING in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_RemainTLV (phFriNfc_NdefMap_t *NdefMap,
-                                              uint8_t            *Flag,
-                                              uint8_t            *Temp16Bytes)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-    uint8_t     CRFlag = 0;
-    uint16_t    RemainingBytes = 0;
-
-    RemainingBytes = ((uint16_t) NdefMap->ApduBufferSize - NdefMap->ApduBuffIndex);
-
-    if (NdefMap->StdMifareContainer.remainingSize < RemainingBytes)
-    {
-        /* If the user Buffer is greater than the Card Size
-           set LastBlockFlag = 1. This Flag is used to read bytes
-           till the end of the card only */
-        RemainingBytes = NdefMap->StdMifareContainer.remainingSize;
-    }
-
-    /* Remaining Bytes of length (L) in TLV <=  16 */
-    if ((NdefMap->TLVStruct.BytesRemainLinTLV <=
-        (PH_FRINFC_MIFARESTD_BYTES_READ - (*Temp16Bytes))) &&
-        (RemainingBytes <= NdefMap->TLVStruct.BytesRemainLinTLV))
-    {
-        /* Copy data to user buffer */
-        memcpy (&(NdefMap->ApduBuffer [NdefMap->ApduBuffIndex]),
-                &(NdefMap->SendRecvBuf [(*Temp16Bytes)]),
-                RemainingBytes);
-
-        NdefMap->ApduBuffIndex += RemainingBytes;
-        NdefMap->StdMifareContainer.remainingSize -= RemainingBytes;
-
-        /* copy the bytes to internal buffer, that are read,
-           but not used for the user buffer */
-        if (RemainingBytes != NdefMap->TLVStruct.BytesRemainLinTLV)
-        {
-            memcpy (NdefMap->StdMifareContainer.internalBuf,
-                    &(NdefMap->SendRecvBuf [((*Temp16Bytes) + RemainingBytes)]),
-                    ((PH_FRINFC_MIFARESTD_BYTES_READ - (*Temp16Bytes)) - RemainingBytes));
-
-            /* internal buffer length */
-            NdefMap->StdMifareContainer.internalLength =
-                    ((PH_FRINFC_MIFARESTD_BYTES_READ -
-                    (*Temp16Bytes)) - RemainingBytes);
-        }
-        *Temp16Bytes += ((uint8_t)RemainingBytes);
-        /* Remaining Bytes of length value in TLV */
-        NdefMap->TLVStruct.BytesRemainLinTLV -= RemainingBytes;
-
-        if (NdefMap->StdMifareContainer.internalLength == PH_FRINFC_MIFARESTD_VAL0)
-        {
-            NdefMap->StdMifareContainer.ReadWriteCompleteFlag = (uint8_t)
-            (((NdefMap->StdMifareContainer.remainingSize == PH_FRINFC_MIFARESTD_VAL0) ||
-            (NdefMap->TLVStruct.BytesRemainLinTLV == PH_FRINFC_MIFARESTD_VAL0)) ?
-            PH_FRINFC_MIFARESTD_FLAG1 :
-            PH_FRINFC_MIFARESTD_FLAG0);
-
-            /* internal length bytes completed */
-            NdefMap->StdMifareContainer.currentBlock++;
-            NdefMap->StdMifareContainer.NdefBlocks++;
-        }
-
-        if (NdefMap->TLVStruct.BytesRemainLinTLV == PH_FRINFC_MIFARESTD_VAL0)
-        {
-            /* Remaining Bytes of length (L) in TLV is Zero means that the next
-               coming bytes are containing type (T), length (L) in TLV */
-            NdefMap->TLVStruct.NdefTLVFoundFlag = PH_FRINFC_MIFARESTD_FLAG1;
-            NdefMap->TLVStruct.LcheckedinTLVFlag = PH_FRINFC_MIFARESTD_FLAG0;
-            NdefMap->TLVStruct.TcheckedinTLVFlag = PH_FRINFC_MIFARESTD_FLAG0;
-        }
-        /* call completion routine */
-        CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
-        *Flag = PH_FRINFC_MIFARESTD_FLAG0;
-    }
-    else if ((NdefMap->TLVStruct.BytesRemainLinTLV <=
-            (PH_FRINFC_MIFARESTD_BYTES_READ - (*Temp16Bytes))) &&
-            (RemainingBytes > NdefMap->TLVStruct.BytesRemainLinTLV))
-    {
-        /* Copy data to user buffer */
-        memcpy (&(NdefMap->ApduBuffer [NdefMap->ApduBuffIndex]),
-                &(NdefMap->SendRecvBuf [(*Temp16Bytes)]),
-                NdefMap->TLVStruct.BytesRemainLinTLV);
-
-        NdefMap->ApduBuffIndex += NdefMap->TLVStruct.BytesRemainLinTLV;
-        NdefMap->StdMifareContainer.remainingSize -= NdefMap->TLVStruct.BytesRemainLinTLV;
-        NdefMap->TLVStruct.NdefTLVFoundFlag = PH_FRINFC_MIFARESTD_FLAG1;
-        *Temp16Bytes += ((uint8_t) NdefMap->TLVStruct.BytesRemainLinTLV);
-        NdefMap->TLVStruct.BytesRemainLinTLV = PH_FRINFC_MIFARESTD_VAL0;
-
-        *Flag = PH_FRINFC_MIFARESTD_FLAG1;
-
-        NdefMap->TLVStruct.LcheckedinTLVFlag = PH_FRINFC_MIFARESTD_FLAG0;
-        NdefMap->TLVStruct.TcheckedinTLVFlag = PH_FRINFC_MIFARESTD_FLAG0;
-        /* 16 bytes completed */
-        if (NdefMap->TLVStruct.BytesRemainLinTLV == PH_FRINFC_MIFARESTD_BYTES_READ)
-        {
-            *Flag = PH_FRINFC_MIFARESTD_FLAG0;
-            NdefMap->TLVStruct.BytesRemainLinTLV = PH_FRINFC_MIFARESTD_NDEFTLV_LBYTES0;
-            NdefMap->StdMifareContainer.currentBlock++;
-            NdefMap->StdMifareContainer.NdefBlocks++;
-            Result = phFriNfc_MifStd_H_BlkChk (NdefMap);
-            if (Result == NFCSTATUS_SUCCESS)
-            {
-                if (NdefMap->StdMifareContainer.AuthDone == PH_FRINFC_MIFARESTD_FLAG1)
-                {
-                    Result = phFriNfc_MifStd_H_RdABlock (NdefMap);
-                }
-                else
-                {
-                    Result = phFriNfc_MifStd_H_AuthSector (NdefMap);
-                }
-            }
-        }
-        else
-        {
-            NdefMap->TLVStruct.BytesRemainLinTLV =
-                            PH_FRINFC_MIFARESTD_NDEFTLV_LBYTES0;
-            /* The read operation has finished. so, completion routine
-               can be called. set the Completion routine(CR) flag */
-            CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
-        }
-    }
-    else if ((NdefMap->TLVStruct.BytesRemainLinTLV >
-            (PH_FRINFC_MIFARESTD_BYTES_READ - (*Temp16Bytes))) &&
-            (RemainingBytes <= (PH_FRINFC_MIFARESTD_BYTES_READ - (*Temp16Bytes))))
-    {
-        /* Copy data to user buffer */
-        memcpy (&(NdefMap->ApduBuffer [NdefMap->ApduBuffIndex]),
-                &(NdefMap->SendRecvBuf [(*Temp16Bytes)]),
-                RemainingBytes);
-        NdefMap->ApduBuffIndex += RemainingBytes;
-        NdefMap->StdMifareContainer.remainingSize -= RemainingBytes;
-
-        /* Remaining Bytes of length (L) in TLV */
-        NdefMap->TLVStruct.BytesRemainLinTLV -= RemainingBytes;
-        /* copy the bytes to internal buffer, that are read,
-                        but not used for the user buffer */
-        memcpy (NdefMap->StdMifareContainer.internalBuf,
-                &(NdefMap->SendRecvBuf[(RemainingBytes + (*Temp16Bytes))]),
-                ((PH_FRINFC_MIFARESTD_BYTES_READ - (*Temp16Bytes))
-                - RemainingBytes));
-
-        /* internal buffer length */
-        NdefMap->StdMifareContainer.internalLength =
-                ((PH_FRINFC_MIFARESTD_BYTES_READ - (*Temp16Bytes)) - RemainingBytes);
-
-        if (RemainingBytes == (PH_FRINFC_MIFARESTD_BYTES_READ - (*Temp16Bytes)))
-        {
-            NdefMap->StdMifareContainer.ReadWriteCompleteFlag = (uint8_t)
-                (((NdefMap->StdMifareContainer.remainingSize == PH_FRINFC_MIFARESTD_VAL0) ||
-                (NdefMap->TLVStruct.BytesRemainLinTLV == PH_FRINFC_MIFARESTD_VAL0)) ?
-                PH_FRINFC_MIFARESTD_FLAG1 :
-                PH_FRINFC_MIFARESTD_FLAG0);
-
-            /* internal length bytes completed */
-            NdefMap->StdMifareContainer.currentBlock++;
-            NdefMap->StdMifareContainer.NdefBlocks++;
-        }
-        *Temp16Bytes += ((uint8_t) RemainingBytes);
-        NdefMap->TLVStruct.NdefTLVFoundFlag = PH_FRINFC_MIFARESTD_FLAG0;
-        CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
-        *Flag = PH_FRINFC_MIFARESTD_FLAG0;
-    }
-    else
-    {
-        if ((NdefMap->TLVStruct.BytesRemainLinTLV >
-            (PH_FRINFC_MIFARESTD_BYTES_READ - (*Temp16Bytes))) &&
-            (RemainingBytes > (PH_FRINFC_MIFARESTD_BYTES_READ - (*Temp16Bytes))))
-        {
-            *Flag = PH_FRINFC_MIFARESTD_FLAG0;
-            /* Copy data to user buffer */
-            memcpy (&(NdefMap->ApduBuffer [NdefMap->ApduBuffIndex]),
-                    &(NdefMap->SendRecvBuf [(*Temp16Bytes)]),
-                    (PH_FRINFC_MIFARESTD_BYTES_READ - (*Temp16Bytes)));
-            NdefMap->ApduBuffIndex += (PH_FRINFC_MIFARESTD_BYTES_READ - (*Temp16Bytes));
-            NdefMap->StdMifareContainer.remainingSize -=
-                                    (PH_FRINFC_MIFARESTD_BYTES_READ - (*Temp16Bytes));
-            NdefMap->TLVStruct.BytesRemainLinTLV -= (PH_FRINFC_MIFARESTD_BYTES_READ - (*Temp16Bytes));
-            *Temp16Bytes += (PH_FRINFC_MIFARESTD_BYTES_READ - (*Temp16Bytes));
-            if (NdefMap->TLVStruct.BytesRemainLinTLV != PH_FRINFC_MIFARESTD_NDEFTLV_LBYTES0)
-            {
-                NdefMap->TLVStruct.NdefTLVFoundFlag = PH_FRINFC_MIFARESTD_FLAG0;
-            }
-            /* 16 bytes completed */
-            NdefMap->StdMifareContainer.currentBlock++;
-            NdefMap->StdMifareContainer.NdefBlocks++;
-            Result = phFriNfc_MifStd_H_BlkChk (NdefMap);
-            if (Result == NFCSTATUS_SUCCESS)
-            {
-                Result = ((NdefMap->StdMifareContainer.AuthDone ==
-                        PH_FRINFC_MIFARESTD_FLAG1) ?
-                        phFriNfc_MifStd_H_RdABlock(NdefMap) :
-                        phFriNfc_MifStd_H_AuthSector(NdefMap));
-            }
-        }
-    }
-
-    if (CRFlag == PH_FRINFC_MIFARESTD_FLAG1)
-    {
-        *NdefMap->NumOfBytesRead = NdefMap->ApduBuffIndex;
-        NdefMap->StdMifareContainer.ReadWriteCompleteFlag = (uint8_t)
-            (((NdefMap->StdMifareContainer.remainingSize == PH_FRINFC_MIFARESTD_VAL0) ||
-            (NdefMap->TLVStruct.BytesRemainLinTLV == PH_FRINFC_MIFARESTD_VAL0)) ?
-            PH_FRINFC_MIFARESTD_FLAG1 :
-            PH_FRINFC_MIFARESTD_FLAG0);
-    }
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_ChkIntLen
- *
- * Description      This function reads ndef to process the internal bytes.
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success,
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_ChkIntLen(phFriNfc_NdefMap_t *NdefMap)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-    uint8_t     NDEFFlag = PH_FRINFC_MIFARESTD_FLAG1;
-    uint8_t     TempintBytes = 0;
-
-    if(NdefMap->TLVStruct.BytesRemainLinTLV != 0)
-    {
-        NDEFFlag = PH_FRINFC_MIFARESTD_FLAG0;
-        /* To read the remaining length (L) in TLV */
-        Result = phFriNfc_MifStd_H_IntLenWioutNdef(NdefMap, &NDEFFlag, &TempintBytes);
-    }
-    NDEFFlag = PH_FRINFC_MIFARESTD_FLAG0;
-    /* check the NDEFFlag is set. if this is not set, then
-       in the above RemainTLV function all the 16 bytes has been
-       read */
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_IntLenWioutNdef
- *
- * Description      This function reads ndef to check the internal bytes
- *                  without ndef tlv flag.
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success,
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_IntLenWioutNdef (phFriNfc_NdefMap_t *NdefMap,
-                                                    uint8_t            *Flag,
-                                                    uint8_t            *TempintBytes)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-    uint8_t     CRFlag = 0;
-    uint16_t    RemainingBytes = 0;
-
-    RemainingBytes = ((uint16_t)NdefMap->ApduBufferSize - NdefMap->ApduBuffIndex);
-
-    if (NdefMap->StdMifareContainer.remainingSize < RemainingBytes)
-    {
-        /* If the user Buffer is greater than the Card Size
-           set LastBlockFlag = 1. This Flag is used to read bytes
-           till the end of the card only */
-        RemainingBytes = NdefMap->StdMifareContainer.remainingSize;
-    }
-
-    /* Remaining Bytes of length (L) in TLV <=  internal length */
-    if ((NdefMap->TLVStruct.BytesRemainLinTLV <=
-        NdefMap->StdMifareContainer.internalLength) &&
-        (RemainingBytes <= NdefMap->TLVStruct.BytesRemainLinTLV))
-    {
-        memcpy (&(NdefMap->ApduBuffer [NdefMap->ApduBuffIndex]),
-                &(NdefMap->StdMifareContainer.internalBuf [(*TempintBytes)]),
-                RemainingBytes);
-        NdefMap->ApduBuffIndex += RemainingBytes;
-        NdefMap->StdMifareContainer.remainingSize -= RemainingBytes;
-        *TempintBytes += ((uint8_t) RemainingBytes);
-
-        /* copy the bytes to internal buffer, that are read,
-           but not used for the user buffer */
-        memcpy (NdefMap->StdMifareContainer.internalBuf,
-                &(NdefMap->StdMifareContainer.internalBuf [RemainingBytes]),
-                (NdefMap->StdMifareContainer.internalLength - RemainingBytes));
-
-        /* internal buffer length */
-        NdefMap->StdMifareContainer.internalLength -= RemainingBytes;
-
-        NdefMap->TLVStruct.BytesRemainLinTLV -= RemainingBytes;
-        if (NdefMap->StdMifareContainer.internalLength == PH_FRINFC_MIFARESTD_VAL0)
-        {
-           NdefMap->StdMifareContainer.ReadWriteCompleteFlag = (uint8_t)
-            (((NdefMap->StdMifareContainer.remainingSize == PH_FRINFC_MIFARESTD_VAL0) ||
-            (NdefMap->TLVStruct.BytesRemainLinTLV == PH_FRINFC_MIFARESTD_VAL0)) ?
-            PH_FRINFC_MIFARESTD_FLAG1 :
-            PH_FRINFC_MIFARESTD_FLAG0);
-
-            /* internal length bytes completed */
-            NdefMap->StdMifareContainer.currentBlock++;
-            NdefMap->StdMifareContainer.NdefBlocks++;
-        }
-
-        /* Remaining Bytes of length value in TLV */
-        if (NdefMap->TLVStruct.BytesRemainLinTLV == 0)
-        {
-            /* Remaining Bytes of length (L) in TLV is Zero means that the next
-             coming bytes are containing type (T), length (L) in TLV */
-            NdefMap->TLVStruct.NdefTLVFoundFlag = PH_FRINFC_MIFARESTD_FLAG1;
-            NdefMap->TLVStruct.LcheckedinTLVFlag = PH_FRINFC_MIFARESTD_FLAG0;
-            NdefMap->TLVStruct.TcheckedinTLVFlag = PH_FRINFC_MIFARESTD_FLAG0;
-        }
-        /* call completion routine */
-        CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
-        *Flag = PH_FRINFC_MIFARESTD_FLAG0;
-    }
-    else if ((NdefMap->TLVStruct.BytesRemainLinTLV <=
-            NdefMap->StdMifareContainer.internalLength) &&
-            (RemainingBytes > NdefMap->TLVStruct.BytesRemainLinTLV))
-    {
-        memcpy (&(NdefMap->ApduBuffer [NdefMap->ApduBuffIndex]),
-                &(NdefMap->StdMifareContainer.internalBuf [(*TempintBytes)]),
-                NdefMap->TLVStruct.BytesRemainLinTLV);
-
-        NdefMap->ApduBuffIndex += NdefMap->TLVStruct.BytesRemainLinTLV;
-        NdefMap->StdMifareContainer.remainingSize -= NdefMap->TLVStruct.BytesRemainLinTLV;
-        NdefMap->TLVStruct.NdefTLVFoundFlag = PH_FRINFC_MIFARESTD_FLAG1;
-
-        *TempintBytes += ((uint8_t) NdefMap->TLVStruct.BytesRemainLinTLV);
-        *Flag = PH_FRINFC_MIFARESTD_FLAG1;
-
-        NdefMap->TLVStruct.LcheckedinTLVFlag = PH_FRINFC_MIFARESTD_FLAG0;
-        NdefMap->TLVStruct.TcheckedinTLVFlag = PH_FRINFC_MIFARESTD_FLAG0;
-
-        NdefMap->TLVStruct.BytesRemainLinTLV = PH_FRINFC_MIFARESTD_VAL0;
-        NdefMap->StdMifareContainer.ReadWriteCompleteFlag = (uint8_t)
-        (((NdefMap->StdMifareContainer.remainingSize == PH_FRINFC_MIFARESTD_VAL0) ||
-            (NdefMap->TLVStruct.BytesRemainLinTLV == PH_FRINFC_MIFARESTD_VAL0)) ?
-            PH_FRINFC_MIFARESTD_FLAG1 :
-            PH_FRINFC_MIFARESTD_FLAG0);
-
-        if (PH_FRINFC_MIFARESTD_FLAG1 == NdefMap->StdMifareContainer.ReadWriteCompleteFlag)
-        {
-            CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
-        }
-
-        if (NdefMap->TLVStruct.BytesRemainLinTLV == NdefMap->StdMifareContainer.internalLength)
-        {
-            /* Remaining Bytes in Length (L) field of TLV is 0 */
-            NdefMap->TLVStruct.BytesRemainLinTLV = PH_FRINFC_MIFARESTD_NDEFTLV_LBYTES0;
-            NdefMap->StdMifareContainer.internalLength = PH_FRINFC_MIFARESTD_VAL0;
-            *Flag = PH_FRINFC_MIFARESTD_FLAG0;
-            /* internal length bytes completed */
-            NdefMap->StdMifareContainer.currentBlock++;
-            NdefMap->StdMifareContainer.NdefBlocks++;
-            Result = phFriNfc_MifStd_H_BlkChk (NdefMap);
-            if (Result == NFCSTATUS_SUCCESS)
-            {
-                Result =
-                ((NdefMap->StdMifareContainer.AuthDone == PH_FRINFC_MIFARESTD_FLAG1) ?
-                phFriNfc_MifStd_H_RdABlock (NdefMap) :
-                phFriNfc_MifStd_H_AuthSector (NdefMap));
-            }
-        }
-        else
-        {
-            /* Remaining Bytes in Length (L) field of TLV is 0 */
-            NdefMap->TLVStruct.BytesRemainLinTLV = PH_FRINFC_MIFARESTD_NDEFTLV_LBYTES0;
-            *Flag = PH_FRINFC_MIFARESTD_FLAG1;
-        }
-    }
-    else if ((NdefMap->TLVStruct.BytesRemainLinTLV >
-            NdefMap->StdMifareContainer.internalLength) &&
-            (RemainingBytes <= NdefMap->StdMifareContainer.internalLength))
-    {
-        memcpy(&(NdefMap->ApduBuffer [NdefMap->ApduBuffIndex]),
-                &(NdefMap->StdMifareContainer.internalBuf [(*TempintBytes)]),
-                RemainingBytes);
-
-        NdefMap->ApduBuffIndex += RemainingBytes;
-        NdefMap->StdMifareContainer.remainingSize -= RemainingBytes;
-        *TempintBytes += ((uint8_t) RemainingBytes);
-        /* Remaining Bytes of length (L) in TLV */
-        NdefMap->TLVStruct.BytesRemainLinTLV -= RemainingBytes;
-
-        /* copy the bytes to internal buffer, that are read,
-                        but not used for the user buffer */
-        memcpy (NdefMap->StdMifareContainer.internalBuf,
-                &(NdefMap->StdMifareContainer.internalBuf [RemainingBytes]),
-                (NdefMap->StdMifareContainer.internalLength - RemainingBytes));
-
-        /* internal buffer length */
-        NdefMap->StdMifareContainer.internalLength -= RemainingBytes;
-        if (NdefMap->StdMifareContainer.internalLength == PH_FRINFC_MIFARESTD_VAL0)
-        {
-            NdefMap->StdMifareContainer.ReadWriteCompleteFlag = (uint8_t)
-            (((NdefMap->StdMifareContainer.remainingSize == PH_FRINFC_MIFARESTD_VAL0) ||
-            (NdefMap->TLVStruct.BytesRemainLinTLV == PH_FRINFC_MIFARESTD_VAL0)) ?
-            PH_FRINFC_MIFARESTD_FLAG1 :
-            PH_FRINFC_MIFARESTD_FLAG0);
-
-            /* internal length bytes completed */
-            NdefMap->StdMifareContainer.currentBlock++;
-            NdefMap->StdMifareContainer.NdefBlocks++;
-        }
-
-        NdefMap->TLVStruct.NdefTLVFoundFlag = PH_FRINFC_MIFARESTD_FLAG0;
-        CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
-        *Flag = PH_FRINFC_MIFARESTD_FLAG0;
-    }
-    else
-    {
-        if ((NdefMap->TLVStruct.BytesRemainLinTLV >
-            NdefMap->StdMifareContainer.internalLength) &&
-            (RemainingBytes > NdefMap->StdMifareContainer.internalLength))
-        {
-            memcpy (&(NdefMap->ApduBuffer [NdefMap->ApduBuffIndex]),
-                    &(NdefMap->StdMifareContainer.internalBuf [(*TempintBytes)]),
-                    NdefMap->StdMifareContainer.internalLength);
-            *Flag = PH_FRINFC_MIFARESTD_FLAG0;
-            NdefMap->ApduBuffIndex += NdefMap->StdMifareContainer.internalLength;
-            NdefMap->StdMifareContainer.remainingSize -=
-                                NdefMap->StdMifareContainer.internalLength;
-            NdefMap->TLVStruct.BytesRemainLinTLV -= NdefMap->StdMifareContainer.internalLength;
-
-            if(NdefMap->TLVStruct.BytesRemainLinTLV != PH_FRINFC_MIFARESTD_NDEFTLV_LBYTES0)
-            {
-                NdefMap->TLVStruct.NdefTLVFoundFlag = PH_FRINFC_MIFARESTD_FLAG0;
-            }
-
-            NdefMap->StdMifareContainer.internalLength = PH_FRINFC_MIFARESTD_VAL0;
-            /* internal length bytes completed */
-            NdefMap->StdMifareContainer.currentBlock++;
-            NdefMap->StdMifareContainer.NdefBlocks++;
-            Result = phFriNfc_MifStd_H_BlkChk(NdefMap);
-            if(Result == NFCSTATUS_SUCCESS)
-            {
-                Result = ((NdefMap->StdMifareContainer.AuthDone ==
-                            PH_FRINFC_MIFARESTD_FLAG1)?
-                            phFriNfc_MifStd_H_RdABlock(NdefMap):
-                            phFriNfc_MifStd_H_AuthSector(NdefMap));
-            }
-        }
-    }
-
-    if(CRFlag == PH_FRINFC_MIFARESTD_FLAG1)
-    {
-        NdefMap->StdMifareContainer.ReadWriteCompleteFlag = (uint8_t)
-        (((NdefMap->StdMifareContainer.remainingSize == PH_FRINFC_MIFARESTD_VAL0) ||
-            (NdefMap->TLVStruct.BytesRemainLinTLV == PH_FRINFC_MIFARESTD_VAL0))?
-            PH_FRINFC_MIFARESTD_FLAG1:
-            PH_FRINFC_MIFARESTD_FLAG0);
-        *NdefMap->NumOfBytesRead = NdefMap->ApduBuffIndex;
-    }
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_WriteNdefLen
- *
- * Description      This function is Helper function for write ndef
- *                  to write the Length TLV.
- *
- * Returns          This function return NFCSTATUS_PENDING in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_WriteNdefLen(phFriNfc_NdefMap_t *NdefMap)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-    NdefMap->State = PH_FRINFC_NDEFMAP_STATE_WR_NDEF_LEN;
-
-    /* If Current block = Ndef TLV block then the starting point
-       is writing from type of TLV
-       Else */
-
-    if(NdefMap->StdMifareContainer.currentBlock ==
-                                NdefMap->TLVStruct.NdefTLVBlock)
-    {
-
-        if(NdefMap->TLVStruct.NULLTLVCount >=
-            PH_FRINFC_MIFARESTD_VAL2)
-        {
-            phFriNfc_MifStd_H_fillTLV1(NdefMap);
-        }
-        else
-        {
-            phFriNfc_MifStd_H_fillTLV2(NdefMap);
-        }
-    }
-    else
-    {
-        if(NdefMap->TLVStruct.NULLTLVCount >=
-            PH_FRINFC_MIFARESTD_VAL2)
-        {
-            phFriNfc_MifStd_H_fillTLV1_1(NdefMap);
-        }
-        else
-        {
-            phFriNfc_MifStd_H_fillTLV2_1(NdefMap);
-        }
-    }
-
-    memcpy( NdefMap->StdMifareContainer.Buffer,
-            &(NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL1]),
-            PH_FRINFC_MIFARESTD_BYTES_READ);
-
-
-    /* Write from here */
-    NdefMap->SendLength = MIFARE_MAX_SEND_BUF_TO_WRITE;
-
-    NdefMap->Cmd.MfCmd = phHal_eMifareWrite16;
-
-    *NdefMap->SendRecvLength = NdefMap->TempReceiveLength;
-    /* Call the Overlapped HAL Transceive function */
-    Result = phFriNfc_ExtnsTransceive(NdefMap->pTransceiveInfo,
-                                   NdefMap->Cmd,
-                                   NdefMap->SendRecvBuf,
-                                   NdefMap->SendLength,
-                                   NdefMap->SendRecvLength);
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_RdWrReset
- *
- * Description      It resets ndef TLV values. This is used when the offset
- *                  is BEGIN.
- *
- * Returns          void
- *
- ******************************************************************************/
-static void phFriNfc_MifStd_H_RdWrReset(phFriNfc_NdefMap_t   *NdefMap)
-{
-    NdefMap->StdMifareContainer.currentBlock = PH_FRINFC_MIFARESTD_BLK4;
-    NdefMap->StdMifareContainer.NdefBlocks = PH_FRINFC_MIFARESTD_VAL1;
-    NdefMap->TLVStruct.BytesRemainLinTLV = PH_FRINFC_MIFARESTD_VAL0;
-    NdefMap->TLVStruct.LcheckedinTLVFlag = PH_FRINFC_MIFARESTD_FLAG0;
-    NdefMap->TLVStruct.TcheckedinTLVFlag = PH_FRINFC_MIFARESTD_FLAG0;
-    NdefMap->TLVStruct.NdefTLVAuthFlag = PH_FRINFC_MIFARESTD_FLAG0;
-    NdefMap->TLVStruct.NdefTLVBlock = PH_FRINFC_MIFARESTD_MAD_BLK0;
-    NdefMap->TLVStruct.NdefTLVByte = PH_FRINFC_MIFARESTD_VAL0;
-    NdefMap->TLVStruct.NoLbytesinTLV = PH_FRINFC_MIFARESTD_VAL0;
-    NdefMap->TLVStruct.NULLTLVCount = PH_FRINFC_MIFARESTD_VAL0;
-    NdefMap->StdMifareContainer.internalLength = PH_FRINFC_MIFARESTD_VAL0;
-    NdefMap->StdMifareContainer.AuthDone = PH_FRINFC_MIFARESTD_FLAG0;
-    NdefMap->StdMifareContainer.NFCforumSectFlag = PH_FRINFC_MIFARESTD_FLAG0;
-    NdefMap->StdMifareContainer.FirstReadFlag = PH_FRINFC_MIFARESTD_FLAG1;
-    NdefMap->StdMifareContainer.ReadWriteCompleteFlag = PH_FRINFC_MIFARESTD_FLAG0;
-    NdefMap->StdMifareContainer.remainingSize = (uint16_t)
-                        (NdefMap->StdMifareContainer.NoOfNdefCompBlocks *
-                            PH_FRINFC_MIFARESTD_BLOCK_BYTES);
-    NdefMap->StdMifareContainer.WrLength = PH_FRINFC_MIFARESTD_VAL1;
-
-    return;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_RdtoWrNdefLen
- *
- * Description      This function is used to read the first ndef compliant
- *                  block to change the length.
- *
- * Returns          This function return NFCSTATUS_PENDING in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_RdtoWrNdefLen(phFriNfc_NdefMap_t *NdefMap)
-{
-    NFCSTATUS Result = NFCSTATUS_SUCCESS;
-
-    NdefMap->State = PH_FRINFC_NDEFMAP_STATE_RD_TO_WR_NDEF_LEN;
-
-    if(NdefMap->TLVStruct.NdefTLVAuthFlag == PH_FRINFC_MIFARESTD_FLAG1)
-    {
-        NdefMap->StdMifareContainer.AuthDone = PH_FRINFC_MIFARESTD_FLAG0;
-        Result = phFriNfc_MifStd_H_AuthSector(NdefMap);
-    }
-    else
-    {
-        NdefMap->SendRecvBuf[0] = NdefMap->StdMifareContainer.currentBlock;
-        NdefMap->SendLength = MIFARE_MAX_SEND_BUF_TO_READ;
-        *NdefMap->SendRecvLength = NdefMap->TempReceiveLength;
-
-        NdefMap->Cmd.MfCmd = phHal_eMifareRead;
-
-        /* Call the Overlapped HAL Transceive function */
-        Result = phFriNfc_ExtnsTransceive(NdefMap->pTransceiveInfo,
-                                      NdefMap->Cmd,
-                                      NdefMap->SendRecvBuf,
-                                      NdefMap->SendLength,
-                                      NdefMap->SendRecvLength);
-    }
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_SetNdefBlkAuth
- *
- * Description      This function is used to set the authentication flag
- *                  for the ndef TLV block.
- *
- * Returns          void
- *
- ******************************************************************************/
-static void phFriNfc_MifStd_H_SetNdefBlkAuth(phFriNfc_NdefMap_t   *NdefMap)
-{
-    NdefMap->TLVStruct.NdefTLVAuthFlag =
-            ((phFriNfc_MifStd_H_GetSect(NdefMap->TLVStruct.NdefTLVBlock)
-            == phFriNfc_MifStd_H_GetSect(NdefMap->StdMifareContainer.currentBlock))?
-            PH_FRINFC_MIFARESTD_FLAG0:
-            PH_FRINFC_MIFARESTD_FLAG1);
-
-    return;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_GetActCardLen
- *
- * Description      Helper function to get the actual length of card.
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_GetActCardLen(phFriNfc_NdefMap_t *NdefMap)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-
-    NdefMap->State = PH_FRINFC_NDEFMAP_STATE_GET_ACT_CARDSIZE;
-    NdefMap->PrevOperation = PH_FRINFC_NDEFMAP_GET_ACTSIZE_OPE;
-
-    Result = ((NdefMap->StdMifareContainer.AuthDone ==
-            PH_FRINFC_MIFARESTD_FLAG0)?
-            phFriNfc_MifStd_H_AuthSector(NdefMap):
-            phFriNfc_MifStd_H_Rd16Bytes(NdefMap,
-                NdefMap->StdMifareContainer.currentBlock));
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_ChkTLVs
- *
- * Description      Helper function to check all the TLVs.
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_ChkTLVs(phFriNfc_NdefMap_t *NdefMap,
-                                           uint8_t            *CRFlag)
-{
-    NFCSTATUS       Result = NFCSTATUS_SUCCESS;
-    uint16_t        TempLength = PH_FRINFC_MIFARESTD_VAL0,
-                    ShiftLength = PH_FRINFC_MIFARESTD_VAL0;
-    uint8_t         TL4bytesFlag = PH_FRINFC_MIFARESTD_FLAG0;
-
-    NdefMap->PrevOperation = PH_FRINFC_NDEFMAP_GET_ACTSIZE_OPE;
-    TempLength = NdefMap->TLVStruct.NdefTLVByte;
-
-    for(;;)
-    {
-        if((NdefMap->SendRecvBuf[TempLength] != PH_FRINFC_MIFARESTD_TERMTLV_T) &&
-            (NdefMap->SendRecvBuf[TempLength] != PH_FRINFC_MIFARESTD_NULLTLV_T) &&
-            (NdefMap->SendRecvBuf[TempLength] != PH_FRINFC_MIFARESTD_NDEFTLV_T) &&
-            (false == NdefMap->TLVStruct.NdefTLVFoundFlag))
-        {
-            Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP,
-                                NFCSTATUS_NO_NDEF_SUPPORT);
-            NdefMap->TLVStruct.BytesRemainLinTLV = 0;
-            NdefMap->CardState = PH_NDEFMAP_CARD_STATE_INVALID;
-            *CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
-            break;
-
-        }
-        else
-        if((NdefMap->SendRecvBuf[TempLength] != PH_FRINFC_MIFARESTD_TERMTLV_T) &&
-            (NdefMap->SendRecvBuf[TempLength] != PH_FRINFC_MIFARESTD_NULLTLV_T))
-        {
-            if(NdefMap->SendRecvBuf[TempLength] == PH_FRINFC_MIFARESTD_NDEFTLV_T)
-            {
-                NdefMap->TLVStruct.NdefTLVBlock =
-                            NdefMap->StdMifareContainer.currentBlock;
-                NdefMap->TLVStruct.NdefTLVByte = (uint8_t)TempLength;
-                NdefMap->TLVStruct.NdefTLVFoundFlag =
-                            ((NdefMap->SendRecvBuf[TempLength] ==
-                                PH_FRINFC_MIFARESTD_NDEFTLV_T)?
-                                PH_FRINFC_MIFARESTD_FLAG1:
-                                PH_FRINFC_MIFARESTD_FLAG0);
-
-                NdefMap->TLVStruct.NULLTLVCount = ((NdefMap->TLVStruct.NULLTLVCount
-                                            == PH_FRINFC_MIFARESTD_VAL1)?
-                                            PH_FRINFC_MIFARESTD_VAL0:
-                                            NdefMap->TLVStruct.NULLTLVCount);
-            }
-            else
-            {
-                NdefMap->TLVStruct.NULLTLVCount = PH_FRINFC_MIFARESTD_VAL0;
-            }
-
-            TempLength++;
-            if(TempLength == PH_FRINFC_MIFARESTD_BYTES_READ)
-            {
-                NdefMap->TLVStruct.TcheckedinTLVFlag =
-                                        PH_FRINFC_MIFARESTD_FLAG1;
-                NdefMap->TLVStruct.NoLbytesinTLV =
-                                    PH_FRINFC_MIFARESTD_VAL3;
-            }
-            Result = phFriNfc_MifStd_H_Chk16Bytes(  NdefMap,
-                                                    TempLength);
-            if(Result != NFCSTATUS_SUCCESS)
-            {
-                *CRFlag = (uint8_t)((Result == NFCSTATUS_PENDING)?
-                            PH_FRINFC_MIFARESTD_FLAG0:
-                            PH_FRINFC_MIFARESTD_FLAG1);
-                break;
-            }
-
-            if(((((  NdefMap->StdMifareContainer.NoOfNdefCompBlocks -
-                        NdefMap->StdMifareContainer.NdefBlocks) *
-                        PH_FRINFC_MIFARESTD_BLOCK_BYTES) +
-                        (PH_FRINFC_MIFARESTD_BLOCK_BYTES -
-                        TempLength)) <
-                        NdefMap->SendRecvBuf[TempLength]) &&
-                        ((NdefMap->SendRecvBuf[TempLength] <
-                        PH_FRINFC_MIFARESTD_NDEFTLV_L) &&
-                        (NdefMap->TLVStruct.NdefTLVFoundFlag !=
-                        PH_FRINFC_MIFARESTD_VAL1)))
-            {
-                /* Result = Error */
-                Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP,
-                                NFCSTATUS_INVALID_PARAMETER);
-                *CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
-                break;
-            }
-
-            if(((((  NdefMap->StdMifareContainer.NoOfNdefCompBlocks -
-                        NdefMap->StdMifareContainer.NdefBlocks) *
-                        PH_FRINFC_MIFARESTD_BLOCK_BYTES) +
-                        (PH_FRINFC_MIFARESTD_BLOCK_BYTES -
-                        TempLength)) <
-                        NdefMap->SendRecvBuf[TempLength]) &&
-                        ((NdefMap->SendRecvBuf[TempLength] ==
-                        PH_FRINFC_MIFARESTD_VAL0) &&
-                        (NdefMap->TLVStruct.NdefTLVFoundFlag ==
-                        PH_FRINFC_MIFARESTD_VAL1)))
-            {
-                /* Result = Error */
-                Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP,
-                                NFCSTATUS_INVALID_PARAMETER);
-                *CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
-                break;
-            }
-
-            if((NdefMap->TLVStruct.NdefTLVFoundFlag ==
-                PH_FRINFC_MIFARESTD_FLAG1) &&
-                (NdefMap->SendRecvBuf[TempLength] <
-                 PH_FRINFC_MIFARESTD_NDEFTLV_L))
-            {
-                Result = phFriNfc_MapTool_SetCardState(NdefMap,
-                                    NdefMap->SendRecvBuf[TempLength]);
-                NdefMap->TLVStruct.BytesRemainLinTLV =
-                                    NdefMap->SendRecvBuf[TempLength];
-                NdefMap->StdMifareContainer.remainingSize -=
-                                            PH_FRINFC_MIFARESTD_VAL2;
-                /* This flag is set */
-                NdefMap->StdMifareContainer.remSizeUpdFlag =
-                    (uint8_t)((NdefMap->TLVStruct.NULLTLVCount >=
-                    PH_FRINFC_MIFARESTD_VAL2)?
-                    PH_FRINFC_MIFARESTD_FLAG0:
-                    PH_FRINFC_MIFARESTD_FLAG1);
-
-                *CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
-                break;
-            }
-
-            NdefMap->StdMifareContainer.remainingSize -=
-                    ((  NdefMap->SendRecvBuf[TempLength] <
-                            PH_FRINFC_MIFARESTD_NDEFTLV_L)?
-                            (NdefMap->SendRecvBuf[TempLength]
-                            + PH_FRINFC_MIFARESTD_VAL2):
-                            PH_FRINFC_MIFARESTD_VAL0);
-
-            if(NdefMap->SendRecvBuf[TempLength] ==
-                        PH_FRINFC_MIFARESTD_VAL0)
-            {
-                Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP,
-                            NFCSTATUS_INVALID_PARAMETER);
-                *CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
-                break;
-            }
-
-            TL4bytesFlag = PH_FRINFC_MIFARESTD_FLAG0;
-            /* get the next TLV after the proprietary TLV */
-            Result =
-                ((NdefMap->SendRecvBuf[TempLength] <
-                    PH_FRINFC_MIFARESTD_NDEFTLV_L)?
-                    phFriNfc_MifStd_H_GetNxtTLV(NdefMap, &TempLength, &TL4bytesFlag):
-                    NFCSTATUS_PENDING);
-
-            if((TempLength >= PH_FRINFC_MIFARESTD_BYTES_READ) &&
-                (Result == NFCSTATUS_SUCCESS))
-            {
-                NdefMap->TLVStruct.TcheckedinTLVFlag =
-                                        PH_FRINFC_MIFARESTD_FLAG0;
-                NdefMap->TLVStruct.NoLbytesinTLV =
-                                    PH_FRINFC_MIFARESTD_VAL0;
-
-                Result = phFriNfc_MifStd_H_GetActCardLen(NdefMap);
-                *CRFlag = (uint8_t)((Result != NFCSTATUS_PENDING)?
-                            PH_FRINFC_MIFARESTD_FLAG1:
-                            PH_FRINFC_MIFARESTD_FLAG0);
-                break;
-            }
-            else
-            {
-                if(Result == NFCSTATUS_PENDING)
-                {
-                    TL4bytesFlag = PH_FRINFC_MIFARESTD_FLAG1;
-                    Result = ((NdefMap->SendRecvBuf[TempLength] ==
-                            PH_FRINFC_MIFARESTD_NDEFTLV_L) ?
-                            NFCSTATUS_SUCCESS:
-                            (PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP,
-                                NFCSTATUS_INVALID_PARAMETER)));
-
-                    if(Result != NFCSTATUS_SUCCESS)
-                    {
-                        *CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
-                        break;
-                    }
-                    NdefMap->TLVStruct.NULLTLVCount = PH_FRINFC_MIFARESTD_VAL0;
-                    TempLength++;
-                    /* Check 0xFF */
-                    if(TempLength == PH_FRINFC_MIFARESTD_BYTES_READ)
-                    {
-                        NdefMap->TLVStruct.TcheckedinTLVFlag =
-                                                PH_FRINFC_MIFARESTD_FLAG1;
-                        NdefMap->TLVStruct.NoLbytesinTLV =
-                                            PH_FRINFC_MIFARESTD_VAL2;
-                    }
-                    Result = phFriNfc_MifStd_H_Chk16Bytes(  NdefMap,
-                                                            TempLength);
-                    if(Result != NFCSTATUS_SUCCESS)
-                    {
-                        break;
-                    }
-
-                    ShiftLength = NdefMap->SendRecvBuf[TempLength];
-                    TempLength++;
-                    if(TempLength == PH_FRINFC_MIFARESTD_BYTES_READ)
-                    {
-                        NdefMap->TLVStruct.TcheckedinTLVFlag =
-                                                PH_FRINFC_MIFARESTD_FLAG1;
-                        NdefMap->TLVStruct.NoLbytesinTLV =
-                                            PH_FRINFC_MIFARESTD_VAL1;
-                        NdefMap->TLVStruct.prevLenByteValue =
-                                    NdefMap->SendRecvBuf[(TempLength -
-                                                PH_FRINFC_MIFARESTD_VAL1)];
-                    }
-                    Result = phFriNfc_MifStd_H_Chk16Bytes(  NdefMap,
-                                                            TempLength);
-                    if(Result != NFCSTATUS_SUCCESS)
-                    {
-                        break;
-                    }
-
-
-                    if((((  NdefMap->StdMifareContainer.NoOfNdefCompBlocks -
-                        NdefMap->StdMifareContainer.NdefBlocks) *
-                        PH_FRINFC_MIFARESTD_BLOCK_BYTES) +
-                        (PH_FRINFC_MIFARESTD_BLOCK_BYTES -
-                        TempLength)) <
-                        (( ShiftLength
-                        << 8) + NdefMap->SendRecvBuf[TempLength]))
-                    {
-                        Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP,
-                                NFCSTATUS_INVALID_REMOTE_DEVICE);
-
-                        break;
-                    }
-
-                    if(NdefMap->TLVStruct.NdefTLVFoundFlag ==
-                        PH_FRINFC_MIFARESTD_FLAG1)
-                    {
-                        ShiftLength = (( ShiftLength<< 8) +
-                                    NdefMap->SendRecvBuf[TempLength]);
-                        NdefMap->TLVStruct.BytesRemainLinTLV = ShiftLength;
-                        Result = phFriNfc_MapTool_SetCardState(NdefMap,
-                                                                ShiftLength);
-                        NdefMap->StdMifareContainer.remainingSize -=
-                                            PH_FRINFC_MIFARESTD_VAL4;
-                        *CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
-                        break;
-                    }
-
-                    NdefMap->StdMifareContainer.remainingSize -=
-                                ((ShiftLength<< 8) +
-                                NdefMap->SendRecvBuf[(TempLength + PH_FRINFC_MIFARESTD_VAL1)]);
-                    TempLength++;
-
-                    /* get the next TLV after the proprietary TLV */
-                    Result = phFriNfc_MifStd_H_GetNxtTLV(NdefMap, &TempLength, &TL4bytesFlag);
-
-                    if((TempLength >= PH_FRINFC_MIFARESTD_BYTES_READ) &&
-                        (Result == NFCSTATUS_SUCCESS))
-                    {
-                        NdefMap->TLVStruct.TcheckedinTLVFlag =
-                                                PH_FRINFC_MIFARESTD_FLAG0;
-                        NdefMap->TLVStruct.NoLbytesinTLV =
-                                            PH_FRINFC_MIFARESTD_VAL0;
-                        Result = phFriNfc_MifStd_H_GetActCardLen(NdefMap);
-
-                        break;
-                    }
-                    break;
-                }
-            }
-        }
-        else if((NdefMap->SendRecvBuf[TempLength] == PH_FRINFC_MIFARESTD_TERMTLV_T) &&
-                (NdefMap->TLVStruct.NdefTLVFoundFlag == PH_FRINFC_MIFARESTD_FLAG0))
-        {
-            Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP,
-                                NFCSTATUS_INVALID_PARAMETER);
-            NdefMap->StdMifareContainer.ReadWriteCompleteFlag =
-                                        PH_FRINFC_MIFARESTD_FLAG1;
-            break;
-
-        }
-        else if(NdefMap->SendRecvBuf[TempLength] == PH_FRINFC_MIFARESTD_NULLTLV_T)
-        {
-            TempLength++;
-            NdefMap->TLVStruct.NULLTLVCount += PH_FRINFC_MIFARESTD_VAL1;
-            ShiftLength = NdefMap->SendRecvBuf[(TempLength - PH_FRINFC_MIFARESTD_VAL1)];
-            NdefMap->StdMifareContainer.remainingSize -= PH_FRINFC_MIFARESTD_VAL1;
-            if(NdefMap->StdMifareContainer.remainingSize <
-                    (( ShiftLength << 8) + NdefMap->SendRecvBuf[TempLength]))
-            {
-                Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP,
-                                NFCSTATUS_INVALID_REMOTE_DEVICE);
-                break;
-            }
-            Result = phFriNfc_MifStd_H_Chk16Bytes(  NdefMap,
-                                                    TempLength);
-            if(Result != NFCSTATUS_SUCCESS)
-            {
-                NdefMap->TLVStruct.NdefTLVByte = PH_FRINFC_MIFARESTD_VAL0;
-                break;
-            }
-        }
-        else
-        {
-            if((NdefMap->SendRecvBuf[TempLength] == PH_FRINFC_MIFARESTD_TERMTLV_T) &&
-                (NdefMap->TLVStruct.NdefTLVFoundFlag == PH_FRINFC_MIFARESTD_FLAG1))
-            {
-                TempLength++;
-                Result = NFCSTATUS_SUCCESS;
-                NdefMap->StdMifareContainer.remainingSize -=
-                                                PH_FRINFC_MIFARESTD_VAL1;
-            }
-        }
-    }
-
-    if(NdefMap->TLVStruct.BytesRemainLinTLV >
-        NdefMap->StdMifareContainer.remainingSize)
-    {
-        Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP,
-                                NFCSTATUS_INVALID_FORMAT);
-    }
-    else
-    {
-        if(NdefMap->StdMifareContainer.remainingSize ==
-                PH_FRINFC_MIFARESTD_VAL0)
-        {
-            Result = ((NdefMap->TLVStruct.NdefTLVFoundFlag ==
-                        PH_FRINFC_MIFARESTD_FLAG1)?
-                        NFCSTATUS_SUCCESS:
-                        (PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP,
-                                    NFCSTATUS_INVALID_PARAMETER)));
-        }
-    }
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_GetNxtTLV
- *
- * Description      This is a Helper function to get the next TLV.
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_GetNxtTLV(phFriNfc_NdefMap_t    *NdefMap,
-                                      uint16_t              *TempLength,
-                                       uint8_t              *TL4bytesFlag)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-    uint16_t    LengthRemaining = PH_FRINFC_MIFARESTD_VAL0,
-                TempLen = PH_FRINFC_MIFARESTD_VAL0,
-                ShiftLength = PH_FRINFC_MIFARESTD_VAL0;
-
-    TempLen = (*TempLength);
-    LengthRemaining = (PH_FRINFC_MIFARESTD_BYTES_READ -
-                        (TempLen + PH_FRINFC_MIFARESTD_VAL1));
-
-    if(*TL4bytesFlag == PH_FRINFC_MIFARESTD_FLAG0)
-    {
-        (*TempLength) += (NdefMap->SendRecvBuf[TempLen] +
-                            PH_FRINFC_MIFARESTD_VAL1);
-
-        if(NdefMap->TLVStruct.NdefTLVFoundFlag == PH_FRINFC_MIFARESTD_FLAG0)
-        {
-            LengthRemaining =
-                (((*TempLength) < PH_FRINFC_MIFARESTD_BYTES_READ)?
-                PH_FRINFC_MIFARESTD_VAL0:
-                (NdefMap->SendRecvBuf[TempLen] -
-                LengthRemaining));
-        }
-        else
-        {
-            LengthRemaining =
-                (((*TempLength) < PH_FRINFC_MIFARESTD_BYTES_READ)?
-                PH_FRINFC_MIFARESTD_VAL0:
-                (NdefMap->SendRecvBuf[TempLen] -
-                LengthRemaining));
-        }
-    }
-    else
-    {
-        *TL4bytesFlag = PH_FRINFC_MIFARESTD_FLAG0;
-        if(NdefMap->TLVStruct.NoLbytesinTLV ==
-            PH_FRINFC_MIFARESTD_VAL1)
-        {
-            ShiftLength = NdefMap->TLVStruct.prevLenByteValue;
-            (*TempLength) += ((ShiftLength
-                                << 8) + NdefMap->SendRecvBuf[TempLen] +
-                            PH_FRINFC_MIFARESTD_VAL1);
-
-            LengthRemaining =
-                (((ShiftLength
-                << 8) + NdefMap->SendRecvBuf[TempLen]) -
-                LengthRemaining);
-        }
-        else
-        {
-            ShiftLength = NdefMap->SendRecvBuf[(TempLen - PH_FRINFC_MIFARESTD_VAL1)];
-            (*TempLength) += ((ShiftLength
-                                << 8) + NdefMap->SendRecvBuf[TempLen] +
-                            PH_FRINFC_MIFARESTD_VAL1);
-
-            LengthRemaining =
-                (((ShiftLength
-                    << 8) + NdefMap->SendRecvBuf[TempLen]) -
-                    LengthRemaining);
-        }
-    }
-
-    NdefMap->TLVStruct.NdefTLVByte =
-        (uint8_t)(((*TempLength) < PH_FRINFC_MIFARESTD_BYTES_READ)?
-        (*TempLength):
-        (LengthRemaining % PH_FRINFC_MIFARESTD_BYTES_READ));
-
-    while(LengthRemaining != PH_FRINFC_MIFARESTD_VAL0)
-    {
-        NdefMap->StdMifareContainer.currentBlock++;
-        NdefMap->StdMifareContainer.NdefBlocks++;
-        Result = phFriNfc_MifStd_H_BlkChk(NdefMap);
-        LengthRemaining -=
-            ((LengthRemaining <= PH_FRINFC_MIFARESTD_BYTES_READ)?
-            LengthRemaining:
-            PH_FRINFC_MIFARESTD_BYTES_READ);
-    }
-
-    if(NdefMap->TLVStruct.NdefTLVByte == PH_FRINFC_MIFARESTD_VAL0)
-    {
-        NdefMap->StdMifareContainer.currentBlock++;
-        NdefMap->StdMifareContainer.NdefBlocks++;
-        Result = phFriNfc_MifStd_H_BlkChk(NdefMap);
-    }
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_Chk16Bytes
- *
- * Description      This Helper function is used to know whether the read
- *                  16 bytes are parsed completely.
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_Chk16Bytes(phFriNfc_NdefMap_t   *NdefMap,
-                                       uint16_t             TempLength)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-
-    if(TempLength == PH_FRINFC_MIFARESTD_BYTES_READ)
-    {
-        NdefMap->StdMifareContainer.currentBlock++;
-        NdefMap->StdMifareContainer.NdefBlocks++;
-        Result = phFriNfc_MifStd_H_BlkChk(NdefMap);
-
-        Result =
-            ((NdefMap->StdMifareContainer.AuthDone == PH_FRINFC_MIFARESTD_FLAG1)?
-            phFriNfc_MifStd_H_GetActCardLen(NdefMap):
-            phFriNfc_MifStd_H_AuthSector(NdefMap));
-    }
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_ChkRemainTLVs
- *
- * Description      This function is used to know whether the read
- *                  16 bytes are parsed completely.
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_ChkRemainTLVs(phFriNfc_NdefMap_t *NdefMap,
-                                          uint8_t            *CRFlag,
-                                          uint8_t            *NDEFFlag)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-    uint16_t    TempLength = PH_FRINFC_MIFARESTD_VAL0,
-                ShiftLength = PH_FRINFC_MIFARESTD_VAL0;
-    uint8_t     TL4bytesFlag = PH_FRINFC_MIFARESTD_FLAG0;
-
-    switch(NdefMap->TLVStruct.NoLbytesinTLV)
-    {
-        case PH_FRINFC_MIFARESTD_VAL3:
-            /* if TLV is found then set card state */
-            Result = ((NdefMap->TLVStruct.NdefTLVFoundFlag ==
-                        PH_FRINFC_MIFARESTD_FLAG1)?
-                        phFriNfc_MapTool_SetCardState(NdefMap,
-                        NdefMap->SendRecvBuf[TempLength]):
-                        Result);
-
-            Result = ((NdefMap->TLVStruct.NdefTLVFoundFlag ==
-                        PH_FRINFC_MIFARESTD_FLAG1)? 1 : Result);
-
-
-            /* Check the length field is less than or
-               equal to 0xFF if yes enter below statement
-               else enter else if*/
-            if((NdefMap->SendRecvBuf[TempLength] <
-                PH_FRINFC_MIFARESTD_NDEFTLV_L) &&
-                (Result == NFCSTATUS_SUCCESS))
-            {
-                NdefMap->StdMifareContainer.remainingSize -=
-                                PH_FRINFC_MIFARESTD_VAL2;
-
-                Result = ((NdefMap->SendRecvBuf[TempLength] >
-                            NdefMap->StdMifareContainer.remainingSize)?
-                            (PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP,
-                            NFCSTATUS_INVALID_FORMAT)):
-                            Result);
-                TL4bytesFlag = PH_FRINFC_MIFARESTD_FLAG0;
-                if((NdefMap->TLVStruct.NdefTLVFoundFlag ==
-                    PH_FRINFC_MIFARESTD_FLAG1) &&
-                    (Result == NFCSTATUS_SUCCESS))
-                {
-                    NdefMap->TLVStruct.BytesRemainLinTLV =
-                    NdefMap->SendRecvBuf[TempLength];
-                    *CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
-
-                }
-                else if(Result == NFCSTATUS_SUCCESS)
-                {
-                    TempLength++;
-                    Result = phFriNfc_MifStd_H_GetNxtTLV(NdefMap,
-                                    &TempLength, &TL4bytesFlag);
-
-                    NdefMap->StdMifareContainer.remainingSize -=
-                                    NdefMap->SendRecvBuf[TempLength];
-                    if((TempLength >= PH_FRINFC_MIFARESTD_BYTES_READ) &&
-                        (*CRFlag == PH_FRINFC_MIFARESTD_FLAG0))
-                    {
-                        *NDEFFlag = PH_FRINFC_MIFARESTD_FLAG0;
-                        Result = phFriNfc_MifStd_H_GetActCardLen(NdefMap);
-                    }
-                }
-
-                else
-                {
-                    /* do nothing */
-                }
-            }
-            else if((NdefMap->SendRecvBuf[TempLength] ==
-                    PH_FRINFC_MIFARESTD_NDEFTLV_L) &&
-                    (Result == NFCSTATUS_SUCCESS))
-            {
-                TempLength++;
-                NdefMap->StdMifareContainer.remainingSize -=
-                                PH_FRINFC_MIFARESTD_VAL4;
-                TL4bytesFlag = PH_FRINFC_MIFARESTD_FLAG0;
-                Result = (((((uint16_t)NdefMap->SendRecvBuf[TempLength] << 8) +
-                                NdefMap->SendRecvBuf[(TempLength +
-                                PH_FRINFC_MIFARESTD_VAL1)]) >
-                                NdefMap->StdMifareContainer.remainingSize)?
-                                (PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP,
-                                NFCSTATUS_INVALID_FORMAT)):
-                                Result);
-                if((NdefMap->TLVStruct.NdefTLVFoundFlag ==
-                    PH_FRINFC_MIFARESTD_FLAG1) &&
-                    (Result == NFCSTATUS_SUCCESS))
-                {
-                    NdefMap->TLVStruct.NULLTLVCount = PH_FRINFC_MIFARESTD_VAL0;
-                    NdefMap->TLVStruct.BytesRemainLinTLV =
-                                (((uint16_t)NdefMap->SendRecvBuf[TempLength] << 8) +
-                                NdefMap->SendRecvBuf[(TempLength +
-                                PH_FRINFC_MIFARESTD_VAL1)]);
-                    *CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
-                }
-                else if(Result == NFCSTATUS_SUCCESS)
-                {
-                    TempLength++;
-
-                    Result = phFriNfc_MifStd_H_GetNxtTLV(NdefMap,
-                                &TempLength, &TL4bytesFlag);
-                    NdefMap->StdMifareContainer.remainingSize -=
-                                (((uint16_t)NdefMap->SendRecvBuf[TempLength] << 8) +
-                                NdefMap->SendRecvBuf[(TempLength +
-                                PH_FRINFC_MIFARESTD_VAL1)]);
-
-                    *NDEFFlag = PH_FRINFC_MIFARESTD_FLAG0;
-                    Result = phFriNfc_MifStd_H_GetActCardLen(NdefMap);
-                }
-                else
-                {
-                    /* do nothing */
-                    *CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
-                }
-            }
-            else
-            {
-                /* Result = Error */
-                Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP,
-                                NFCSTATUS_INVALID_FORMAT);
-                *CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
-            }
-            break;
-
-        case PH_FRINFC_MIFARESTD_VAL2:
-        case PH_FRINFC_MIFARESTD_VAL1:
-            ShiftLength = ((NdefMap->TLVStruct.NoLbytesinTLV ==
-                            PH_FRINFC_MIFARESTD_VAL1)?
-                            ((NdefMap->TLVStruct.prevLenByteValue << 8) +
-                            NdefMap->SendRecvBuf[TempLength]):
-                            (((uint16_t)NdefMap->SendRecvBuf[TempLength] << 8) +
-                            NdefMap->SendRecvBuf[(TempLength +
-                            PH_FRINFC_MIFARESTD_VAL1)]));
-            if((((  NdefMap->StdMifareContainer.NoOfNdefCompBlocks -
-                    NdefMap->StdMifareContainer.NdefBlocks) *
-                    PH_FRINFC_MIFARESTD_BLOCK_BYTES) +
-                    (PH_FRINFC_MIFARESTD_BLOCK_BYTES -
-                    TempLength)) <
-                    ShiftLength)
-            {
-                /* Result = Error */
-                Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP,
-                                NFCSTATUS_INVALID_PARAMETER);
-                *CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
-            }
-            else
-            {
-                NdefMap->StdMifareContainer.remainingSize -=
-                                    PH_FRINFC_MIFARESTD_VAL2;
-                if(NdefMap->TLVStruct.NdefTLVFoundFlag ==
-                        PH_FRINFC_MIFARESTD_FLAG1)
-                {
-                    NdefMap->TLVStruct.BytesRemainLinTLV = ShiftLength;
-                    if(NdefMap->TLVStruct.BytesRemainLinTLV >
-                        NdefMap->StdMifareContainer.remainingSize)
-                    {
-                        Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP,
-                                                NFCSTATUS_INVALID_FORMAT);
-                    }
-                    *CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
-                    *NDEFFlag = PH_FRINFC_MIFARESTD_FLAG0;
-                }
-                else
-                {
-                    NdefMap->StdMifareContainer.remainingSize -=
-                                        ShiftLength;
-                    *CRFlag = PH_FRINFC_MIFARESTD_FLAG0;
-                    TempLength += PH_FRINFC_MIFARESTD_VAL2;
-                    TL4bytesFlag = PH_FRINFC_MIFARESTD_FLAG1;
-                    Result = ((NdefMap->TLVStruct.NdefTLVFoundFlag == PH_FRINFC_MIFARESTD_FLAG1)?
-                                NFCSTATUS_SUCCESS:
-                                phFriNfc_MifStd_H_GetNxtTLV(NdefMap, &TempLength, &TL4bytesFlag));
-
-                    *NDEFFlag = PH_FRINFC_MIFARESTD_FLAG0;
-                    Result = phFriNfc_MifStd_H_GetActCardLen(NdefMap);
-                }
-            }
-            break;
-
-        default:
-            break;
-    }
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_Get1kStTrail
- *
- * Description      This function is used to get the Mifare 1k Sector Trailer.
- *
- * Returns          void
- *
- ******************************************************************************/
-static void phFriNfc_MifStd_H_Get1kStTrail(phFriNfc_NdefMap_t  *NdefMap)
-{
-    switch((NdefMap->StdMifareContainer.currentBlock % 4))
-    {
-        case PH_FRINFC_MIFARESTD_VAL0:
-            NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
-                            (NdefMap->StdMifareContainer.currentBlock +
-                                        PH_FRINFC_MIFARESTD_MAD_BLK3);
-            break;
-
-        case PH_FRINFC_MIFARESTD_VAL1:
-            NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
-                        (NdefMap->StdMifareContainer.currentBlock +
-                                        PH_FRINFC_MIFARESTD_MAD_BLK2);
-            break;
-
-        case PH_FRINFC_MIFARESTD_VAL2:
-            NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
-                        (NdefMap->StdMifareContainer.currentBlock +
-                                        PH_FRINFC_MIFARESTD_MAD_BLK1);
-            break;
-
-        default:
-            NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
-                        NdefMap->StdMifareContainer.currentBlock;
-            break;
-    }
-
-    return;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_Get4kStTrail
- *
- * Description      This function gets the Mifare 4k Sector Trailer.
- *
- * Returns          void
- *
- ******************************************************************************/
-static void phFriNfc_MifStd_H_Get4kStTrail(phFriNfc_NdefMap_t  *NdefMap)
-{
-    switch((NdefMap->StdMifareContainer.currentBlock % 16))
-    {
-        case PH_FRINFC_MIFARESTD_MAD_BLK0:
-            NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
-                            (NdefMap->StdMifareContainer.currentBlock +
-                                        PH_FRINFC_MIFARESTD_BLK15);
-            break;
-
-        case PH_FRINFC_MIFARESTD_MAD_BLK1:
-            NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
-                        (NdefMap->StdMifareContainer.currentBlock +
-                                        PH_FRINFC_MIFARESTD_BLK14);
-            break;
-
-        case PH_FRINFC_MIFARESTD_MAD_BLK2:
-            NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
-                        (NdefMap->StdMifareContainer.currentBlock +
-                                        PH_FRINFC_MIFARESTD_BLK13);
-            break;
-
-        case PH_FRINFC_MIFARESTD_MAD_BLK3:
-            NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
-                        (NdefMap->StdMifareContainer.currentBlock +
-                                        PH_FRINFC_MIFARESTD_BLK12);
-            break;
-
-        case PH_FRINFC_MIFARESTD_BLK4:
-            NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
-                        (NdefMap->StdMifareContainer.currentBlock +
-                                        PH_FRINFC_MIFARESTD_BLK11);
-            break;
-
-        case PH_FRINFC_MIFARESTD_BLK5:
-            NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
-                        (NdefMap->StdMifareContainer.currentBlock +
-                                        PH_FRINFC_MIFARESTD_BLK10);
-            break;
-
-        case PH_FRINFC_MIFARESTD_BLK6:
-            NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
-                        (NdefMap->StdMifareContainer.currentBlock +
-                                        PH_FRINFC_MIFARESTD_BLK9);
-            break;
-
-        case PH_FRINFC_MIFARESTD_BLK7:
-            NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
-                        (NdefMap->StdMifareContainer.currentBlock +
-                                        PH_FRINFC_MIFARESTD_BLK8);
-            break;
-
-        case PH_FRINFC_MIFARESTD_BLK8:
-            NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
-                        (NdefMap->StdMifareContainer.currentBlock +
-                                        PH_FRINFC_MIFARESTD_BLK7);
-            break;
-
-        case PH_FRINFC_MIFARESTD_BLK9:
-            NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
-                        (NdefMap->StdMifareContainer.currentBlock +
-                                        PH_FRINFC_MIFARESTD_BLK6);
-            break;
-
-        case PH_FRINFC_MIFARESTD_BLK10:
-            NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
-                        (NdefMap->StdMifareContainer.currentBlock +
-                                        PH_FRINFC_MIFARESTD_BLK5);
-            break;
-
-        case PH_FRINFC_MIFARESTD_BLK11:
-            NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
-                        (NdefMap->StdMifareContainer.currentBlock +
-                                        PH_FRINFC_MIFARESTD_BLK4);
-            break;
-
-        case PH_FRINFC_MIFARESTD_BLK12:
-            NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
-                        (NdefMap->StdMifareContainer.currentBlock +
-                                        PH_FRINFC_MIFARESTD_MAD_BLK3);
-            break;
-
-        case PH_FRINFC_MIFARESTD_BLK13:
-            NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
-                        (NdefMap->StdMifareContainer.currentBlock +
-                                        PH_FRINFC_MIFARESTD_MAD_BLK2);
-            break;
-
-        case PH_FRINFC_MIFARESTD_BLK14:
-            NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
-                        (NdefMap->StdMifareContainer.currentBlock +
-                                        PH_FRINFC_MIFARESTD_MAD_BLK1);
-            break;
-
-        default:
-            NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
-                        NdefMap->StdMifareContainer.currentBlock;
-            break;
-    }
-
-    return;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_ProChkNdef
- *
- * Description      This function processes the check ndef call.
- *
- * Returns          This function return NFCSTATUS_PENDING in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_ProChkNdef(phFriNfc_NdefMap_t        *NdefMap)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-
-    /* Copy remaining bytes into the AID array
-       from Receive Buffer till array number 7 in aid */
-    if(NdefMap->StdMifareContainer.currentBlock ==
-        PH_FRINFC_MIFARESTD_VAL1)
-    {
-        /* Helper Function to Store AID Information */
-        phFriNfc_MifStd_H_fillAIDarray(NdefMap);
-
-        NdefMap->StdMifareContainer.currentBlock = PH_FRINFC_MIFARESTD_VAL2;
-        /* read remaining AIDs from block number 2 */
-        Result = ((NdefMap->StdMifareContainer.aidCompleteFlag ==
-                PH_FRINFC_MIFARESTD_FLAG1)?
-                Result:
-                phFriNfc_MifareStdMap_ChkNdef( NdefMap));
-    }
-    else if(((NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_1K_CARD) &&
-            (NdefMap->StdMifareContainer.currentBlock ==
-            PH_FRINFC_MIFARESTD_MAD_BLK2)) || (
-            (NdefMap->StdMifareContainer.currentBlock ==
-            PH_FRINFC_MIFARESTD_MAD_BLK66) &&
-            (NdefMap->CardType ==
-            PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD ||
-            NdefMap->CardType ==
-            PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD)))
-    {
-        /* Helper Function to Store AID Information */
-        phFriNfc_MifStd_H_fillAIDarray(NdefMap);
-
-        NdefMap->StdMifareContainer.aidCompleteFlag =
-                        PH_FRINFC_MIFARESTD_FLAG1;
-    } /* Mifare 1k and Mifare 4k end Check */
-    else if((NdefMap->StdMifareContainer.currentBlock >
-            PH_FRINFC_MIFARESTD_VAL1) &&
-            (NdefMap->CardType ==
-            PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD ||
-            NdefMap->CardType ==
-            PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD))
-    {
-        phFriNfc_MifStd_H_fillAIDarray(NdefMap);
-        /* read remaining AIDs from block number 2 */
-        /* Mifare 4k Helper Function */
-        Result = ((NdefMap->StdMifareContainer.aidCompleteFlag ==
-                    PH_FRINFC_MIFARESTD_FLAG1)?
-                    Result:
-                    phFriNfc_MifStd4k_H_CheckNdef(NdefMap));
-    } /* Card Type 4k Check */
-    else
-    {
-        /* Since we have decided temporarily not to go
-           for any new error codes we are using
-           NFCSTATUS_INVALID_PARAMETER even though it is not
-           the relevant error code here TBD */
-        Result = PHNFCSTVAL(    CID_FRI_NFC_NDEF_MAP,
-                                NFCSTATUS_INVALID_PARAMETER);
-    }
-
-    if(NdefMap->StdMifareContainer.aidCompleteFlag ==
-                        PH_FRINFC_MIFARESTD_FLAG1)
-    {
-        NdefMap->StdMifareContainer.ChkNdefCompleteFlag =
-                        PH_FRINFC_MIFARESTD_FLAG1;
-        /*  The check for NDEF compliant information is now over for
-            the Mifare 1K card.
-            Update(decrement) the NoOfNdefCompBlocks as much required,
-            depending on the NDEF compliant information found */
-        /* Check the Sectors are Ndef Compliant */
-        phFriNfc_MifStd_H_ChkNdefCmpltSects(NdefMap);
-        if((NdefMap->StdMifareContainer.NoOfNdefCompBlocks == 0) ||
-            (NdefMap->StdMifareContainer.NoOfNdefCompBlocks > 255))
-        {
-            Result = PHNFCSTVAL( CID_FRI_NFC_NDEF_MAP,
-                                NFCSTATUS_NO_NDEF_SUPPORT);
-        }
-        else
-        {
-            NdefMap->StdMifareContainer.aidCompleteFlag =
-                            PH_FRINFC_MIFARESTD_FLAG0;
-            NdefMap->StdMifareContainer.NFCforumSectFlag =
-                                    PH_FRINFC_MIFARESTD_FLAG0;
-            NdefMap->StdMifareContainer.currentBlock = PH_FRINFC_MIFARESTD_BLK4;
-            Result = phFriNfc_MifStd_H_BlkChk(NdefMap);
-            Result = ((Result != NFCSTATUS_SUCCESS)?
-                        Result:phFriNfc_MifStd_H_AuthSector(NdefMap));
-        }
-
-    }
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_ProAuth
- *
- * Description      This function process the authentication of a sector.
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_ProAuth(phFriNfc_NdefMap_t       *NdefMap)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-
-    if(NdefMap->TLVStruct.NdefTLVAuthFlag ==
-       PH_FRINFC_MIFARESTD_FLAG1)
-    {
-        NdefMap->TLVStruct.NdefTLVAuthFlag =
-                                    PH_FRINFC_MIFARESTD_FLAG0;
-        NdefMap->StdMifareContainer.AuthDone = PH_FRINFC_MIFARESTD_FLAG1;
-        Result = phFriNfc_MifStd_H_RdtoWrNdefLen(NdefMap);
-    }
-    else
-    {
-        NdefMap->StdMifareContainer.AuthDone = 1;
-        NdefMap->StdMifareContainer.ReadAcsBitFlag = 1;
-        Result = phFriNfc_MifStd_H_RdAcsBit(NdefMap);
-    }
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_Rd16Bytes
- *
- * Description      This function reads 16 bytes from a specifed block no.
- *
- * Returns          This function return NFCSTATUS_PENDING in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_Rd16Bytes(phFriNfc_NdefMap_t     *NdefMap,
-                                              uint8_t               BlockNo)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-
-    NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] = BlockNo;
-    NdefMap->SendLength = MIFARE_MAX_SEND_BUF_TO_READ;
-    *NdefMap->SendRecvLength = NdefMap->TempReceiveLength;
-    NdefMap->Cmd.MfCmd = phHal_eMifareRead;
-    NdefMap->MapCompletionInfo.CompletionRoutine = phFriNfc_MifareStdMap_Process;
-    NdefMap->MapCompletionInfo.Context = NdefMap;
-
-    /* Call the Overlapped HAL Transceive function */
-    Result = phFriNfc_ExtnsTransceive(NdefMap->pTransceiveInfo,
-                                      NdefMap->Cmd,
-                                      NdefMap->SendRecvBuf,
-                                      NdefMap->SendLength,
-                                      NdefMap->SendRecvLength);
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_ProAcsBits
- *
- * Description      It processes access bits of the sector trailer.
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_ProAcsBits(phFriNfc_NdefMap_t        *NdefMap)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-    uint8_t     CRFlag = PH_FRINFC_MIFARESTD_FLAG0;
-
-    if(*NdefMap->SendRecvLength == PH_FRINFC_MIFARESTD_BYTES_READ)
-    {
-        if(NdefMap->StdMifareContainer.ReadAcsBitFlag ==
-            PH_FRINFC_MIFARESTD_FLAG1)
-        {
-            /* check for the correct access bits */
-            Result = phFriNfc_MifStd_H_ChkAcsBit(NdefMap);
-
-            if((NdefMap->StdMifareContainer.ChkNdefFlag ==
-                PH_FRINFC_MIFARESTD_FLAG1) &&
-                (Result == NFCSTATUS_SUCCESS))
-            {
-                if(NdefMap->CardState ==
-                    PH_NDEFMAP_CARD_STATE_INVALID)
-                {
-                    NdefMap->StdMifareContainer.NoOfNdefCompBlocks =
-                    ((NdefMap->StdMifareContainer.currentBlock >=
-                    PH_FRINFC_MIFARESTD4K_BLK128)?
-                    (NdefMap->StdMifareContainer.NoOfNdefCompBlocks -
-                                    PH_FRINFC_MIFARESTD_BLK15):
-                    (NdefMap->StdMifareContainer.NoOfNdefCompBlocks -
-                                    PH_FRINFC_MIFARESTD_MAD_BLK3));
-
-                    NdefMap->StdMifareContainer.ProprforumSectFlag =
-                        ((NdefMap->StdMifareContainer.NFCforumSectFlag ==
-                        PH_FRINFC_MIFARESTD_FLAG1)?
-                        PH_FRINFC_MIFARESTD_PROP_2ND_CONFIG:
-                        PH_FRINFC_MIFARESTD_PROP_3RD_CONFIG);
-
-                    Result = phFriNfc_MifStd_H_ProStatNotValid(NdefMap, Result);
-                }
-                else
-                {
-                    NdefMap->StdMifareContainer.NFCforumSectFlag =
-                        (((NdefMap->StdMifareContainer.currentBlock == 64) &&
-                        ((NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD)||
-                        (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD)))?
-                        NdefMap->StdMifareContainer.NFCforumSectFlag:
-                                            PH_FRINFC_MIFARESTD_FLAG1);
-                }
-
-                if(NdefMap->StdMifareContainer.ProprforumSectFlag !=
-                    PH_FRINFC_MIFARESTD_PROP_2ND_CONFIG)
-                {
-                    NdefMap->StdMifareContainer.ReadAcsBitFlag = PH_FRINFC_MIFARESTD_FLAG0;
-                                /* ((NdefMap->StdMifareContainer.ReadCompleteFlag ==
-                                        PH_FRINFC_MIFARESTD_FLAG1)?
-                                        PH_FRINFC_MIFARESTD_FLAG0:
-                                        PH_FRINFC_MIFARESTD_FLAG1);*/
-
-                    NdefMap->StdMifareContainer.ReadCompleteFlag =
-                    (uint8_t)((((((NdefMap->StdMifareContainer.currentBlock +
-                        PH_FRINFC_MIFARESTD_VAL4) >=
-                        PH_FRINFC_MIFARESTD1K_MAX_BLK) &&
-                        (NdefMap->CardType ==
-                        PH_FRINFC_NDEFMAP_MIFARE_STD_1K_CARD)) &&
-                        (NdefMap->StdMifareContainer.ReadCompleteFlag ==
-                        PH_FRINFC_MIFARESTD_FLAG0)) ||
-                        (NdefMap->StdMifareContainer.ReadCompleteFlag ==
-                        PH_FRINFC_MIFARESTD_FLAG1))?
-                        PH_FRINFC_MIFARESTD_FLAG1:
-                        PH_FRINFC_MIFARESTD_FLAG0);
-
-                    NdefMap->StdMifareContainer.ReadCompleteFlag =
-                    (uint8_t)((((((uint16_t)(NdefMap->StdMifareContainer.currentBlock +
-                        PH_FRINFC_MIFARESTD_VAL4) >=
-                        PH_FRINFC_MIFARESTD4K_MAX_BLK) &&
-                        (NdefMap->CardType ==
-                        PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD)) &&
-                        (NdefMap->StdMifareContainer.ReadCompleteFlag ==
-                        PH_FRINFC_MIFARESTD_FLAG0)) ||
-                        (NdefMap->StdMifareContainer.ReadCompleteFlag ==
-                        PH_FRINFC_MIFARESTD_FLAG1))?
-                        PH_FRINFC_MIFARESTD_FLAG1:
-                        PH_FRINFC_MIFARESTD_FLAG0);
-
-                    NdefMap->StdMifareContainer.ReadCompleteFlag =
-                    (uint8_t)((((((uint16_t)(NdefMap->StdMifareContainer.currentBlock +
-                        PH_FRINFC_MIFARESTD_VAL4) >=
-                        PH_FRINFC_MIFARESTD4K_MAX_BLK) &&
-                        (NdefMap->CardType ==
-                        PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD)) &&
-                        (NdefMap->StdMifareContainer.ReadCompleteFlag ==
-                        PH_FRINFC_MIFARESTD_FLAG0)) ||
-                        (NdefMap->StdMifareContainer.ReadCompleteFlag ==
-                        PH_FRINFC_MIFARESTD_FLAG1))?
-                        PH_FRINFC_MIFARESTD_FLAG1:
-                        PH_FRINFC_MIFARESTD_FLAG0);
-
-                    NdefMap->StdMifareContainer.currentBlock =
-                        ((NdefMap->StdMifareContainer.ReadCompleteFlag ==
-                            PH_FRINFC_MIFARESTD_FLAG1)?
-                            PH_FRINFC_MIFARESTD_BLK4:
-                            NdefMap->StdMifareContainer.currentBlock);
-
-                    Result =
-                    ((NdefMap->StdMifareContainer.ReadCompleteFlag ==
-                            PH_FRINFC_MIFARESTD_FLAG1)?
-                            phFriNfc_MifStd_H_BlkChk(NdefMap):
-                            Result);
-                }
-            }
-
-            Result = ((Result != NFCSTATUS_SUCCESS)?
-                        Result:
-                        phFriNfc_MifStd_H_ChkRdWr(NdefMap));
-        }
-        else
-        {
-            NdefMap->StdMifareContainer.ChkNdefFlag =
-                PH_FRINFC_MIFARESTD_FLAG0;
-            /* Here its required to read the entire card to know the */
-            /* Get exact ndef size of the card */
-            Result = phFriNfc_MifStd_H_ChkTLVs(NdefMap, &CRFlag);
-        }
-    }
-    else
-    {
-        /* Since we have decided temporarily not to go
-           for any new error codes we are using
-           NFCSTATUS_INVALID_PARAMETER even though it is not
-           the relevant error code here TBD */
-        Result = PHNFCSTVAL(    CID_FRI_NFC_NDEF_MAP,
-                                NFCSTATUS_INVALID_PARAMETER);
-    }
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_GPBChk
- *
- * Description      This function is checks the GPB bytes.
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_GPBChk(phFriNfc_NdefMap_t        *NdefMap)
-{
-    NFCSTATUS Result = NFCSTATUS_SUCCESS;
-
-    /* Spec version needs to be checked every time (Version check is not enabled) */
-    /* Result = phFriNfc_MapTool_ChkSpcVer(NdefMap, PH_FRINFC_MIFARESTD_VAL9); */
-
-    /* Check rhe read and write access field
-        in GPB is 00b
-        bit 0 and 1 for write access check
-        bit 2 and 3 for read access check */
-    if(Result == NFCSTATUS_SUCCESS)
-    {
-        if(((NdefMap->SendRecvBuf[
-            PH_FRINFC_MIFARESTD_VAL9] &
-            PH_FRINFC_MIFARESTD_MASK_GPB_WR) ==
-            PH_FRINFC_MIFARESTD_GPB_RD_WR_VAL) &&
-            ((NdefMap->SendRecvBuf[
-            PH_FRINFC_MIFARESTD_VAL9] &
-            PH_FRINFC_MIFARESTD_MASK_GPB_RD) ==
-            PH_FRINFC_MIFARESTD_GPB_RD_WR_VAL))
-        {
-            NdefMap->CardState = (((NdefMap->StdMifareContainer.ChkNdefFlag ==
-                                    PH_FRINFC_MIFARESTD_FLAG1) ||
-                                    (NdefMap->StdMifareContainer.ReadNdefFlag ==
-                                    PH_FRINFC_MIFARESTD_FLAG1) ||
-                                    (NdefMap->StdMifareContainer.WrNdefFlag ==
-                                    PH_FRINFC_MIFARESTD_FLAG1))?
-                                    PH_NDEFMAP_CARD_STATE_INITIALIZED:
-                                    PH_NDEFMAP_CARD_STATE_READ_WRITE);
-        }
-        else if(((NdefMap->SendRecvBuf[
-            PH_FRINFC_MIFARESTD_VAL9] &
-            PH_FRINFC_MIFARESTD_MASK_GPB_WR) !=
-            PH_FRINFC_MIFARESTD_GPB_RD_WR_VAL) &&
-            ((NdefMap->SendRecvBuf[
-            PH_FRINFC_MIFARESTD_VAL9] &
-            PH_FRINFC_MIFARESTD_MASK_GPB_RD) ==
-            PH_FRINFC_MIFARESTD_GPB_RD_WR_VAL))
-        {
-            /* write access not given
-            only read access check */
-            NdefMap->CardState = PH_NDEFMAP_CARD_STATE_READ_ONLY;
-        }
-        else
-        {
-            NdefMap->CardState = PH_NDEFMAP_CARD_STATE_INVALID;
-        }
-    }
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_ProStatNotValid
- *
- * Description      This function checks for the different status value in the
- *                  process because of proprietary forum sector.
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_ProStatNotValid(phFriNfc_NdefMap_t        *NdefMap,
-                                                   NFCSTATUS                 status)
-{
-    NFCSTATUS Result = status;
-
-    /* if NFC forum sector is not found before the proprietary one then
-       authenticate the next sector
-       Else it is a error*/
-    if(NdefMap->StdMifareContainer.NFCforumSectFlag ==
-        PH_FRINFC_MIFARESTD_FLAG0)
-    {
-        NdefMap->StdMifareContainer.ProprforumSectFlag =
-                        PH_FRINFC_MIFARESTD_PROP_3RD_CONFIG;
-        if(NdefMap->StdMifareContainer.currentBlock <
-            PH_FRINFC_MIFARESTD4K_BLK128)
-        {
-             /* Fix for the disovery problem,
-                if 1st sector is invalid then ignore the remaining sectors and
-                send an error if the card is mifare 1k,
-                if the card is mifare 4k, then update the block number to 67 and
-                continue.
-                Even if the authentication of that block fails then send error */
-            if(((NdefMap->StdMifareContainer.currentBlock <
-                PH_FRINFC_MIFARESTD_BLK4) &&
-                (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_1K_CARD)) ||
-                ((NdefMap->StdMifareContainer.currentBlock <=
-                PH_FRINFC_MIFARESTD_MAD_BLK67) &&
-                (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD ||
-                 NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD)))
-            {
-                Result = PHNFCSTVAL( CID_FRI_NFC_NDEF_MAP,
-                                    NFCSTATUS_NO_NDEF_SUPPORT);
-            }
-            else if((NdefMap->StdMifareContainer.currentBlock <
-                PH_FRINFC_MIFARESTD_BLK4) &&
-                (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD ||
-                 NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD))
-            {
-                Result = NFCSTATUS_SUCCESS;
-                NdefMap->StdMifareContainer.currentBlock =
-                            PH_FRINFC_MIFARESTD_MAD_BLK67;
-            }
-            else if(((NdefMap->StdMifareContainer.currentBlock +
-                PH_FRINFC_MIFARESTD_BLK4) >
-                PH_FRINFC_MIFARESTD1K_MAX_BLK) &&
-                (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_1K_CARD))
-            {
-                Result = PHNFCSTVAL( CID_FRI_NFC_NDEF_MAP,
-                            NFCSTATUS_NO_NDEF_SUPPORT);
-            }
-            else
-            {
-                NdefMap->StdMifareContainer.remainingSize -=
-                        (PH_FRINFC_MIFARESTD_MAD_BLK3 * PH_FRINFC_MIFARESTD_BLOCK_BYTES);
-                NdefMap->StdMifareContainer.currentBlock +=
-                                PH_FRINFC_MIFARESTD_BLK4;
-                Result = phFriNfc_MifStd_H_BlkChk(NdefMap);
-            }
-        }
-        else if((NdefMap->StdMifareContainer.currentBlock +
-                PH_FRINFC_MIFARESTD_BLK15) >
-                PH_FRINFC_MIFARESTD4K_MAX_BLK)
-        {
-            Result = PHNFCSTVAL( CID_FRI_NFC_NDEF_MAP,
-                        NFCSTATUS_NO_NDEF_SUPPORT);
-        }
-        else
-        {
-            NdefMap->StdMifareContainer.remainingSize -=
-                        (PH_FRINFC_MIFARESTD_BLK15 * PH_FRINFC_MIFARESTD_BLOCK_BYTES);
-            NdefMap->StdMifareContainer.currentBlock +=
-                                    PH_FRINFC_MIFARESTD_BLOCK_BYTES;
-            Result = phFriNfc_MifStd_H_BlkChk(NdefMap);
-        }
-        Result = ((Result != NFCSTATUS_SUCCESS)?
-                (PHNFCSTVAL( CID_FRI_NFC_NDEF_MAP,
-                        NFCSTATUS_NO_NDEF_SUPPORT)):
-                phFriNfc_MifStd_H_AuthSector(NdefMap));
-    }
-    else if((NdefMap->StdMifareContainer.ProprforumSectFlag ==
-            PH_FRINFC_MIFARESTD_PROP_3RD_CONFIG) &&
-            (NdefMap->StdMifareContainer.NFCforumSectFlag ==
-            PH_FRINFC_MIFARESTD_FLAG1))
-    {
-        /*  if the proprietary forum sector are found before
-            NFC forum sector then again a proprietary
-            forum sector are found after the NFC forum
-            sector */
-        Result = PHNFCSTVAL( CID_FRI_NFC_NDEF_MAP,
-                            NFCSTATUS_NO_NDEF_SUPPORT);
-    }
-    else
-    {
-        NdefMap->StdMifareContainer.ProprforumSectFlag =
-                        PH_FRINFC_MIFARESTD_PROP_2ND_CONFIG;
-        switch(NdefMap->PrevOperation)
-        {
-        case PH_FRINFC_NDEFMAP_CHECK_OPE:
-        case PH_FRINFC_NDEFMAP_GET_ACTSIZE_OPE:
-            Result = PHNFCSTVAL( CID_FRI_NFC_NDEF_MAP,
-                        NFCSTATUS_NO_NDEF_SUPPORT);
-            break;
-
-        case PH_FRINFC_NDEFMAP_READ_OPE:
-            if((NdefMap->TLVStruct.NdefTLVFoundFlag ==
-                PH_FRINFC_MIFARESTD_FLAG1) &&
-                (NdefMap->TLVStruct.NoLbytesinTLV ==
-                PH_FRINFC_MIFARESTD_VAL0))
-            {
-                *NdefMap->NumOfBytesRead = NdefMap->ApduBuffIndex;
-                Result = NFCSTATUS_SUCCESS;
-            }
-            else
-            {
-                Result = PHNFCSTVAL( CID_FRI_NFC_NDEF_MAP,
-                        NFCSTATUS_NO_NDEF_SUPPORT);
-            }
-            break;
-
-        case PH_FRINFC_NDEFMAP_WRITE_OPE:
-        default:
-            /* This means the further write is not possible,
-               EOF_NDEF_CONTAINER_REACHED */
-            NdefMap->StdMifareContainer.ReadWriteCompleteFlag =
-                                PH_FRINFC_MIFARESTD_FLAG1;
-            /* Write the length to the L field in the TLV */
-            NdefMap->StdMifareContainer.TempBlockNo =
-                        NdefMap->StdMifareContainer.currentBlock;
-            phFriNfc_MifStd_H_SetNdefBlkAuth(NdefMap);
-            NdefMap->StdMifareContainer.currentBlock =
-                            NdefMap->TLVStruct.NdefTLVBlock;
-            Result = phFriNfc_MifStd_H_RdtoWrNdefLen(NdefMap);
-            break;
-        }
-    }
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_RdBeforeWr
- *
- * Description      This function is used to read the NDEF TLV block.
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_RdBeforeWr(phFriNfc_NdefMap_t        *NdefMap)
-{
-    NFCSTATUS Result = NFCSTATUS_SUCCESS;
-
-    NdefMap->State = PH_FRINFC_NDEFMAP_STATE_RD_BEF_WR;
-    NdefMap->PrevOperation = PH_FRINFC_NDEFMAP_WRITE_OPE;
-
-    Result = phFriNfc_MifStd_H_Rd16Bytes(NdefMap,
-                    NdefMap->StdMifareContainer.currentBlock);
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_ProBytesToWr
- *
- * Description      This function processes the NDEF TLV block read bytes to
- *                  start write from the NDEF TLV.
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_ProBytesToWr(phFriNfc_NdefMap_t        *NdefMap)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-    uint8_t     TempLength = PH_FRINFC_MIFARESTD_VAL0;
-
-    if(*NdefMap->SendRecvLength == PH_FRINFC_MIFARESTD_BYTES_READ)
-    {
-        memmove(&NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL1],
-                    NdefMap->SendRecvBuf,
-                    PH_FRINFC_MIFARESTD_BLOCK_BYTES);
-
-        /* Write to Ndef TLV Block */
-        NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
-                            NdefMap->StdMifareContainer.currentBlock;
-
-        TempLength = ((NdefMap->StdMifareContainer.currentBlock ==
-                        NdefMap->TLVStruct.NdefTLVBlock)?
-                        phFriNfc_MifStd_H_UpdateTLV(NdefMap):
-                        phFriNfc_MifStd_H_UpdRemTLV(NdefMap));
-
-        NdefMap->StdMifareContainer.remainingSize -=
-            ((NdefMap->StdMifareContainer.remSizeUpdFlag ==
-            PH_FRINFC_MIFARESTD_FLAG1)?
-            PH_FRINFC_MIFARESTD_VAL2:
-            PH_FRINFC_MIFARESTD_VAL0);
-
-        NdefMap->StdMifareContainer.remSizeUpdFlag = PH_FRINFC_MIFARESTD_FLAG0;
-        NdefMap->State = PH_FRINFC_NDEFMAP_STATE_WR_TLV;
-        Result = ((TempLength == PH_FRINFC_MIFARESTD_BLOCK_BYTES)?
-                    phFriNfc_MifStd_H_WrTLV(NdefMap):
-                    phFriNfc_MifStd_H_fillSendBuf(NdefMap, TempLength));
-    }
-    else
-    {
-        Result = PHNFCSTVAL( CID_FRI_NFC_NDEF_MAP,
-                                NFCSTATUS_READ_FAILED);
-    }
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_UpdateTLV
- *
- * Description      This function writes ndef to add the TLV structure.
- *
- * Returns          uint8_t     TempLength
- *
- ******************************************************************************/
-static uint8_t phFriNfc_MifStd_H_UpdateTLV(phFriNfc_NdefMap_t *NdefMap)
-{
-    uint8_t     TempLength = PH_FRINFC_MIFARESTD_VAL0;
-
-    TempLength = (uint8_t)(NdefMap->TLVStruct.NdefTLVByte + PH_FRINFC_MIFARESTD_VAL1);
-    /* Creating TLV */
-    if(NdefMap->TLVStruct.NULLTLVCount >= 2)
-    {
-        if((PH_FRINFC_MIFARESTD_BYTES_READ - TempLength) ==
-            PH_FRINFC_MIFARESTD_VAL0)
-        {
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
-        }
-        else
-        {
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
-            TempLength++;
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_L0;
-        }
-    }
-    else
-    {
-        switch((PH_FRINFC_MIFARESTD_BYTES_READ -
-                TempLength))
-        {
-        case PH_FRINFC_MIFARESTD_VAL0:
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NULLTLV_T;
-        break;
-
-        case PH_FRINFC_MIFARESTD_VAL1:
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NULLTLV_T;
-            TempLength++;
-            NdefMap->TLVStruct.prevLenByteValue =
-                                    (uint16_t)((NdefMap->SendRecvBuf[TempLength] >=
-                                    PH_FRINFC_MIFARESTD_NDEFTLV_L)?
-                                    PH_FRINFC_MIFARESTD_VAL0:
-                                    NdefMap->SendRecvBuf[TempLength]);
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NULLTLV_T;
-        break;
-
-        case PH_FRINFC_MIFARESTD_VAL2:
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NULLTLV_T;
-            TempLength++;
-            NdefMap->TLVStruct.prevLenByteValue =
-                                    (uint16_t)((NdefMap->SendRecvBuf[TempLength] >=
-                                    PH_FRINFC_MIFARESTD_NDEFTLV_L)?
-                                    NdefMap->SendRecvBuf[(TempLength +
-                                                PH_FRINFC_MIFARESTD_VAL1)]:
-                                    NdefMap->SendRecvBuf[TempLength]);
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NULLTLV_T;
-            TempLength++;
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
-        break;
-
-        default:
-            NdefMap->TLVStruct.prevLenByteValue =
-                            NdefMap->SendRecvBuf[TempLength];
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NULLTLV_T;
-            TempLength++;
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NULLTLV_T;
-            TempLength++;
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
-            TempLength++;
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_L0;
-        break;
-        }
-    }
-
-    return TempLength;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_fillSendBuf
- *
- * Description      It fill the send buffer to write.
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_fillSendBuf(phFriNfc_NdefMap_t        *NdefMap,
-                                               uint8_t                   Length)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-    uint16_t    RemainingBytes = PH_FRINFC_MIFARESTD_VAL0,
-                BytesToWrite = PH_FRINFC_MIFARESTD_VAL0;
-    uint8_t     index = PH_FRINFC_MIFARESTD_VAL0;
-
-    Length = (Length + PH_FRINFC_MIFARESTD_VAL1);
-
-    RemainingBytes = (uint16_t)((NdefMap->StdMifareContainer.remainingSize
-                        < (uint16_t)(NdefMap->ApduBufferSize -
-                        NdefMap->ApduBuffIndex))?
-                        NdefMap->StdMifareContainer.remainingSize:
-                        (NdefMap->ApduBufferSize -
-                        NdefMap->ApduBuffIndex));
-
-    NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
-                            NdefMap->StdMifareContainer.currentBlock;
-    /* Get the number of bytes that can be written after copying
-       the internal buffer */
-    BytesToWrite = ((RemainingBytes <
-                    ((PH_FRINFC_MIFARESTD_WR_A_BLK - Length) -
-                    NdefMap->StdMifareContainer.internalLength))?
-                    RemainingBytes:
-                    ((PH_FRINFC_MIFARESTD_WR_A_BLK - Length) -
-                    NdefMap->StdMifareContainer.internalLength));
-
-    if(NdefMap->StdMifareContainer.internalLength >
-        PH_FRINFC_MIFARESTD_VAL0)
-    {
-        /* copy the internal buffer to the send buffer */
-        memcpy(&(NdefMap->SendRecvBuf[
-                    Length]),
-                    NdefMap->StdMifareContainer.internalBuf,
-                    NdefMap->StdMifareContainer.internalLength);
-    }
-
-    /* Copy Bytes to write in the send buffer */
-    memcpy(&(NdefMap->SendRecvBuf[
-                (Length +
-                NdefMap->StdMifareContainer.internalLength)]),
-                &(NdefMap->ApduBuffer[NdefMap->ApduBuffIndex]),
-                BytesToWrite);
-
-    /* update number of bytes written from the user buffer */
-    NdefMap->NumOfBytesWritten = BytesToWrite;
-
-    /* check the exact number of bytes written to a block including the
-        internal length */
-    *NdefMap->DataCount =
-            ((BytesToWrite + NdefMap->StdMifareContainer.internalLength
-            + Length) - PH_FRINFC_MIFARESTD_VAL1);
-
-    /* if total bytes to write in the card is less than 4 bytes then
-    pad zeroes till 4 bytes */
-    if((BytesToWrite + NdefMap->StdMifareContainer.internalLength +
-        Length) < PH_FRINFC_MIFARESTD_WR_A_BLK)
-    {
-        for(index = (uint8_t)(BytesToWrite +
-                    NdefMap->StdMifareContainer.internalLength +
-                    Length);
-            index < PH_FRINFC_MIFARESTD_WR_A_BLK;
-            index++)
-            {
-                NdefMap->SendRecvBuf[index] = (uint8_t)((index ==
-                                    (BytesToWrite + Length +
-                                    NdefMap->StdMifareContainer.internalLength))?
-                                    PH_FRINFC_MIFARESTD_TERMTLV_T:
-                                    PH_FRINFC_MIFARESTD_NULLTLV_T);
-
-                NdefMap->TLVStruct.SetTermTLVFlag = PH_FRINFC_MIFARESTD_FLAG1;
-            }
-    }
-
-    NdefMap->TLVStruct.SetTermTLVFlag = PH_FRINFC_MIFARESTD_FLAG1;
-
-    /* A temporary buffer to hold four bytes of data that is
-       written to the card */
-    memcpy(NdefMap->StdMifareContainer.Buffer,
-                &(NdefMap->SendRecvBuf[
-                PH_FRINFC_MIFARESTD_VAL1]),
-                PH_FRINFC_MIFARESTD_BLOCK_BYTES);
-
-    NdefMap->State = PH_FRINFC_NDEFMAP_STATE_WR_TLV;
-    Result = phFriNfc_MifStd_H_WrTLV(NdefMap);
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_WrTLV
- *
- * Description      This function writes 16 bytes in a block.
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_WrTLV(phFriNfc_NdefMap_t        *NdefMap)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-
-    NdefMap->MapCompletionInfo.CompletionRoutine = phFriNfc_MifareStdMap_Process;
-    NdefMap->MapCompletionInfo.Context = NdefMap;
-    /* Write from here */
-    NdefMap->SendLength = MIFARE_MAX_SEND_BUF_TO_WRITE;
-
-    NdefMap->Cmd.MfCmd = phHal_eMifareWrite16;
-
-    *NdefMap->SendRecvLength = NdefMap->TempReceiveLength;
-
-    /* Call the Overlapped HAL Transceive function */
-    Result = phFriNfc_ExtnsTransceive(NdefMap->pTransceiveInfo,
-                                      NdefMap->Cmd,
-                                      NdefMap->SendRecvBuf,
-                                      NdefMap->SendLength,
-                                      NdefMap->SendRecvLength);
-
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_ProWrTLV
- *
- * Description      This function processes the write TLV bytes in a block.
- *
- * Returns          This function return NFCSTATUS_SUCESS in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_ProWrTLV(phFriNfc_NdefMap_t        *NdefMap)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-
-    /* Check that if complete TLV has been written in the
-       card if yes enter the below check or go to else*/
-    if(((((PH_FRINFC_MIFARESTD_BLOCK_BYTES -
-            NdefMap->TLVStruct.NdefTLVByte) ==
-            PH_FRINFC_MIFARESTD_VAL1) &&
-            (NdefMap->TLVStruct.NULLTLVCount >=
-            PH_FRINFC_MIFARESTD_VAL2)) ||
-            (((PH_FRINFC_MIFARESTD_BLOCK_BYTES -
-            NdefMap->TLVStruct.NdefTLVByte) <=
-            PH_FRINFC_MIFARESTD_VAL3) &&
-            (NdefMap->TLVStruct.NULLTLVCount ==
-            PH_FRINFC_MIFARESTD_VAL0))) &&
-            (NdefMap->StdMifareContainer.currentBlock ==
-            NdefMap->TLVStruct.NdefTLVBlock))
-    {
-        /* increment the block and chekc the block is in the same sector
-           using the block check function */
-        NdefMap->StdMifareContainer.RdBeforeWrFlag = PH_FRINFC_MIFARESTD_FLAG1;
-        NdefMap->StdMifareContainer.currentBlock++;
-        NdefMap->StdMifareContainer.NdefBlocks++;
-        Result = phFriNfc_MifStd_H_BlkChk(NdefMap);
-        if(Result == NFCSTATUS_SUCCESS)
-        {
-            Result = ((NdefMap->StdMifareContainer.AuthDone ==
-                        PH_FRINFC_MIFARESTD_FLAG0)?
-                        phFriNfc_MifStd_H_AuthSector(NdefMap):
-                        phFriNfc_MifStd_H_RdBeforeWr(NdefMap));
-        }
-    }
-    else
-    {
-        NdefMap->StdMifareContainer.RdBeforeWrFlag = PH_FRINFC_MIFARESTD_FLAG0;
-        if(NdefMap->ApduBuffIndex <
-                    (uint16_t)NdefMap->ApduBufferSize)
-        {
-            if(*NdefMap->DataCount < PH_FRINFC_MIFARESTD_BLOCK_BYTES)
-            {
-                /* Write complete, so next byte shall be */
-                NdefMap->StdMifareContainer.internalLength =
-                    *NdefMap->DataCount;
-
-                /* Copy bytes less than 16 to internal buffer
-                   for the next write this can be used */
-                memcpy( NdefMap->StdMifareContainer.internalBuf,
-                        NdefMap->StdMifareContainer.Buffer,
-                        NdefMap->StdMifareContainer.internalLength);
-            }
-
-            /* Increment the Send Buffer index */
-             NdefMap->ApduBuffIndex += NdefMap->NumOfBytesWritten;
-
-             NdefMap->StdMifareContainer.remainingSize -=
-                                        NdefMap->NumOfBytesWritten;
-
-             /* Check for the End of Card */
-            if((NdefMap->StdMifareContainer.remainingSize  ==
-                PH_FRINFC_MIFARESTD_VAL0) ||
-                (NdefMap->ApduBuffIndex == NdefMap->ApduBufferSize))
-            {
-                NdefMap->StdMifareContainer.ReadWriteCompleteFlag =
-                (uint8_t)((NdefMap->StdMifareContainer.remainingSize  == 0)?
-                    PH_FRINFC_MIFARESTD_FLAG1:PH_FRINFC_MIFARESTD_FLAG0);
-
-                if(NdefMap->StdMifareContainer.internalLength ==
-                    PH_FRINFC_MIFARESTD_VAL0)
-                {
-                    NdefMap->StdMifareContainer.currentBlock++;
-                    /* Mifare 4k Card, After 128th Block
-                    each sector = 16 blocks in Mifare 4k */
-                    Result = phFriNfc_MifStd_H_BlkChk(NdefMap);
-                    NdefMap->StdMifareContainer.NdefBlocks++;
-                }
-
-                NdefMap->TLVStruct.SetTermTLVFlag =
-                    (uint8_t)(((NdefMap->StdMifareContainer.remainingSize ==
-                            PH_FRINFC_MIFARESTD_VAL0) ||
-                            (NdefMap->TLVStruct.SetTermTLVFlag ==
-                            PH_FRINFC_MIFARESTD_FLAG1))?
-                            PH_FRINFC_MIFARESTD_FLAG1:
-                            PH_FRINFC_MIFARESTD_FLAG0);
-
-            }
-            else
-            {
-                NdefMap->StdMifareContainer.currentBlock++;
-                /* Mifare 4k Card, After 128th Block
-                each sector = 16 blocks in Mifare 4k */
-                Result = phFriNfc_MifStd_H_BlkChk(NdefMap);
-                if(Result == NFCSTATUS_SUCCESS)
-                {
-                    NdefMap->StdMifareContainer.NdefBlocks++;
-                    Result = ((NdefMap->StdMifareContainer.AuthDone ==
-                                PH_FRINFC_MIFARESTD_FLAG1)?
-                                phFriNfc_MifStd_H_WrABlock(NdefMap):
-                                phFriNfc_MifStd_H_AuthSector(NdefMap));
-                }
-            }
-        }
-    }
-
-    if((Result == NFCSTATUS_SUCCESS) &&
-        (NdefMap->TLVStruct.SetTermTLVFlag !=
-        PH_FRINFC_MIFARESTD_FLAG1) &&
-        (NdefMap->StdMifareContainer.remainingSize >
-        PH_FRINFC_MIFARESTD_VAL0))
-    {
-        Result = phFriNfc_MifStd_H_WrTermTLV(NdefMap);
-    }
-    else
-    {
-        if((Result == NFCSTATUS_SUCCESS) &&
-            (NdefMap->TLVStruct.SetTermTLVFlag ==
-            PH_FRINFC_MIFARESTD_FLAG1))
-        {
-            /* Write the length to the L field in the TLV */
-            NdefMap->StdMifareContainer.TempBlockNo =
-                        NdefMap->StdMifareContainer.currentBlock;
-            phFriNfc_MifStd_H_SetNdefBlkAuth(NdefMap);
-            NdefMap->StdMifareContainer.currentBlock =
-                            NdefMap->TLVStruct.NdefTLVBlock;
-            Result = phFriNfc_MifStd_H_RdtoWrNdefLen(NdefMap);
-        }
-    }
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_UpdRemTLV
- *
- * Description      This function updates the remaining TLV.
- *
- * Returns          uint8_t     TempLength : length value
- *
- ******************************************************************************/
-static uint8_t phFriNfc_MifStd_H_UpdRemTLV(phFriNfc_NdefMap_t        *NdefMap)
-{
-    uint8_t     TempLength = PH_FRINFC_MIFARESTD_VAL1;
-
-    if(NdefMap->TLVStruct.NULLTLVCount >=
-        PH_FRINFC_MIFARESTD_VAL2)
-    {
-        NdefMap->TLVStruct.prevLenByteValue = NdefMap->SendRecvBuf[TempLength];
-        NdefMap->SendRecvBuf[TempLength] =
-                        PH_FRINFC_MIFARESTD_NDEFTLV_L0;
-    }
-    else
-    {
-        switch((PH_FRINFC_MIFARESTD_BLOCK_BYTES -
-            NdefMap->TLVStruct.NdefTLVByte))
-        {
-        case PH_FRINFC_MIFARESTD_VAL1:
-            NdefMap->TLVStruct.prevLenByteValue =
-                    (((NdefMap->SendRecvBuf[TempLength] ==
-                    PH_FRINFC_MIFARESTD_NDEFTLV_L))?
-                    (((uint16_t)NdefMap->SendRecvBuf[(TempLength + PH_FRINFC_MIFARESTD_VAL1)]
-                    << PH_FRINFC_MIFARESTD_LEFTSHIFT8) +
-                    NdefMap->SendRecvBuf[(TempLength + PH_FRINFC_MIFARESTD_VAL2)]):
-                    NdefMap->SendRecvBuf[TempLength]);
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NULLTLV_T;
-            TempLength++;
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
-            TempLength++;
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_L0;
-            break;
-
-        case PH_FRINFC_MIFARESTD_VAL2:
-            NdefMap->TLVStruct.prevLenByteValue =
-                    (((NdefMap->SendRecvBuf[TempLength] ==
-                        PH_FRINFC_MIFARESTD_NDEFTLV_L))?
-                    (((uint16_t)NdefMap->SendRecvBuf[TempLength] <<
-                    PH_FRINFC_MIFARESTD_LEFTSHIFT8) +
-                    NdefMap->SendRecvBuf[(TempLength + PH_FRINFC_MIFARESTD_VAL1)]):
-                    NdefMap->SendRecvBuf[TempLength]);
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
-            TempLength++;
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_L0;
-            break;
-
-        case PH_FRINFC_MIFARESTD_VAL3:
-        default:
-            NdefMap->TLVStruct.prevLenByteValue =
-                                            ((NdefMap->TLVStruct.prevLenByteValue <<
-                                            PH_FRINFC_MIFARESTD_LEFTSHIFT8)
-                                            + NdefMap->SendRecvBuf[TempLength]);
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_L0;
-            break;
-        }
-    }
-
-    return TempLength;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_fillTLV1
- *
- * Description      This function updates the length field if more than one
- *                  NULL TLVs exists before of the NDEF TLV.
- *
- * Returns          void
- *
- ******************************************************************************/
-static void phFriNfc_MifStd_H_fillTLV1(phFriNfc_NdefMap_t        *NdefMap)
-{
-    uint8_t     TempLength = (uint8_t)(NdefMap->TLVStruct.NdefTLVByte +
-                            PH_FRINFC_MIFARESTD_VAL1);
-
-    NdefMap->TLVStruct.prevLenByteValue =
-                    ((NdefMap->Offset == PH_FRINFC_NDEFMAP_SEEK_CUR)?
-                    (NdefMap->TLVStruct.prevLenByteValue +
-                    NdefMap->ApduBuffIndex):
-                    NdefMap->ApduBuffIndex);
-
-    NdefMap->StdMifareContainer.RdAfterWrFlag = PH_FRINFC_MIFARESTD_FLAG1;
-    switch(NdefMap->TLVStruct.NdefTLVByte)
-    {
-    case PH_FRINFC_MIFARESTD_VAL0:
-        if(NdefMap->TLVStruct.prevLenByteValue >=
-            PH_FRINFC_MIFARESTD_NDEFTLV_L)
-        {
-            NdefMap->SendRecvBuf[TempLength] =
-                            (uint8_t)(NdefMap->TLVStruct.prevLenByteValue >>
-                            PH_FRINFC_MIFARESTD_RIGHTSHIFT8);
-            NdefMap->SendRecvBuf[(TempLength +
-                                PH_FRINFC_MIFARESTD_VAL1)] =
-                            (uint8_t)NdefMap->TLVStruct.prevLenByteValue;
-        }
-        else
-        {
-            NdefMap->SendRecvBuf[TempLength] =
-                            PH_FRINFC_MIFARESTD_NDEFTLV_T;
-            NdefMap->SendRecvBuf[(TempLength +
-                                PH_FRINFC_MIFARESTD_VAL1)] =
-                            (uint8_t)NdefMap->TLVStruct.prevLenByteValue;
-
-            NdefMap->StdMifareContainer.RdAfterWrFlag =
-                                PH_FRINFC_MIFARESTD_FLAG0;
-        }
-        break;
-
-    case PH_FRINFC_MIFARESTD_VAL1:
-        if(NdefMap->TLVStruct.prevLenByteValue >=
-            PH_FRINFC_MIFARESTD_NDEFTLV_L)
-        {
-            NdefMap->SendRecvBuf[TempLength - PH_FRINFC_MIFARESTD_VAL1] =
-                            PH_FRINFC_MIFARESTD_NDEFTLV_L;
-            NdefMap->SendRecvBuf[TempLength] =
-                            (uint8_t)(NdefMap->TLVStruct.prevLenByteValue >>
-                            PH_FRINFC_MIFARESTD_RIGHTSHIFT8);
-            NdefMap->SendRecvBuf[(TempLength +
-                                PH_FRINFC_MIFARESTD_VAL1)] =
-                            (uint8_t)NdefMap->TLVStruct.prevLenByteValue;
-        }
-        else
-        {
-            NdefMap->SendRecvBuf[TempLength] =
-                            PH_FRINFC_MIFARESTD_NDEFTLV_T;
-            NdefMap->SendRecvBuf[(TempLength +
-                                PH_FRINFC_MIFARESTD_VAL1)] =
-                            (uint8_t)NdefMap->TLVStruct.prevLenByteValue;
-            NdefMap->StdMifareContainer.RdAfterWrFlag =
-                                PH_FRINFC_MIFARESTD_FLAG0;
-        }
-        break;
-
-    case PH_FRINFC_MIFARESTD_VAL15:
-        /* if "Type" of TLV present at byte 15 */
-        if(NdefMap->TLVStruct.prevLenByteValue >=
-            PH_FRINFC_MIFARESTD_NDEFTLV_L)
-        {
-            /* Update the null TLV, ndef TLV block and ndef TLV byte */
-            NdefMap->TLVStruct.NULLTLVCount = PH_FRINFC_MIFARESTD_VAL0;
-            NdefMap->TLVStruct.NdefTLVBlock =
-                                NdefMap->StdMifareContainer.currentBlock;
-            NdefMap->TLVStruct.NdefTLVByte =
-                                (TempLength - PH_FRINFC_MIFARESTD_VAL3);
-
-            NdefMap->SendRecvBuf[(TempLength - PH_FRINFC_MIFARESTD_VAL2)] =
-                            PH_FRINFC_MIFARESTD_NDEFTLV_T;
-            NdefMap->SendRecvBuf[(TempLength - PH_FRINFC_MIFARESTD_VAL1)] =
-                            PH_FRINFC_MIFARESTD_NDEFTLV_L;
-            NdefMap->SendRecvBuf[TempLength] =
-                            (uint8_t)(NdefMap->TLVStruct.prevLenByteValue >>
-                            PH_FRINFC_MIFARESTD_RIGHTSHIFT8);
-        }
-        else
-        {
-            NdefMap->SendRecvBuf[TempLength] =
-                            PH_FRINFC_MIFARESTD_NDEFTLV_T;
-        }
-        break;
-
-    default:
-        /* Already the TLV is present so just append the length field */
-        if(NdefMap->TLVStruct.prevLenByteValue >=
-            PH_FRINFC_MIFARESTD_NDEFTLV_L)
-        {
-            /* Update the null TLV, ndef TLV block and ndef TLV byte */
-            NdefMap->TLVStruct.NULLTLVCount = PH_FRINFC_MIFARESTD_VAL0;
-            NdefMap->TLVStruct.NdefTLVBlock =
-                                NdefMap->StdMifareContainer.currentBlock;
-            NdefMap->TLVStruct.NdefTLVByte =
-                                (TempLength - PH_FRINFC_MIFARESTD_VAL3);
-
-            NdefMap->SendRecvBuf[(TempLength - PH_FRINFC_MIFARESTD_VAL2)] =
-                                (uint8_t)PH_FRINFC_MIFARESTD_NDEFTLV_T;
-            NdefMap->SendRecvBuf[(TempLength - PH_FRINFC_MIFARESTD_VAL1)] =
-                                (uint8_t)PH_FRINFC_MIFARESTD_NDEFTLV_L;
-            NdefMap->SendRecvBuf[TempLength] =
-                                (uint8_t)(NdefMap->TLVStruct.prevLenByteValue >>
-                                PH_FRINFC_MIFARESTD_RIGHTSHIFT8);
-            NdefMap->SendRecvBuf[(TempLength + PH_FRINFC_MIFARESTD_VAL1)] =
-                                (uint8_t)NdefMap->TLVStruct.prevLenByteValue;
-        }
-        else
-        {
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
-            NdefMap->SendRecvBuf[(TempLength + PH_FRINFC_MIFARESTD_VAL1)] =
-                                (uint8_t)NdefMap->TLVStruct.prevLenByteValue;
-        }
-        NdefMap->StdMifareContainer.RdAfterWrFlag =
-                                PH_FRINFC_MIFARESTD_FLAG0;
-        break;
-    }
-
-    return;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_fillTLV2
- *
- * Description      This function is updates the length field if more than one
- *                  NULL TLVs does not exists before the TLV.
- *
- * Returns          void
- *
- ******************************************************************************/
-static void phFriNfc_MifStd_H_fillTLV2(phFriNfc_NdefMap_t        *NdefMap)
-{
-    uint8_t     TempLength = (uint8_t)(NdefMap->TLVStruct.NdefTLVByte +
-                                PH_FRINFC_MIFARESTD_VAL1);
-
-    NdefMap->TLVStruct.prevLenByteValue = ((NdefMap->Offset ==
-                                    PH_FRINFC_NDEFMAP_SEEK_CUR)?
-                                    (NdefMap->TLVStruct.prevLenByteValue +
-                                    NdefMap->ApduBuffIndex):
-                                    NdefMap->ApduBuffIndex);
-    NdefMap->StdMifareContainer.RdAfterWrFlag = PH_FRINFC_MIFARESTD_FLAG1;
-    switch(NdefMap->TLVStruct.NdefTLVByte)
-    {
-    case PH_FRINFC_MIFARESTD_VAL13:
-        if(NdefMap->TLVStruct.prevLenByteValue >=
-            PH_FRINFC_MIFARESTD_NDEFTLV_L)
-        {
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
-            TempLength++;
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_L;
-            TempLength++;
-            NdefMap->SendRecvBuf[TempLength] = (uint8_t)(NdefMap->TLVStruct.prevLenByteValue >>
-                                                PH_FRINFC_MIFARESTD_RIGHTSHIFT8);
-        }
-        else
-        {
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NULLTLV_T;
-            TempLength++;
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NULLTLV_T;
-            TempLength++;
-
-            /* Update the null TLV, ndef TLV block and ndef TLV byte */
-            NdefMap->TLVStruct.NULLTLVCount = PH_FRINFC_MIFARESTD_VAL2;
-            NdefMap->TLVStruct.NdefTLVBlock =
-                                NdefMap->StdMifareContainer.currentBlock;
-            NdefMap->TLVStruct.NdefTLVByte =
-                                (TempLength - PH_FRINFC_MIFARESTD_VAL1);
-
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
-        }
-        break;
-
-    case PH_FRINFC_MIFARESTD_VAL14:
-        if(NdefMap->TLVStruct.prevLenByteValue >=
-            PH_FRINFC_MIFARESTD_NDEFTLV_L)
-        {
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
-            TempLength++;
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_L;
-        }
-        else
-        {
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NULLTLV_T;
-            TempLength++;
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NULLTLV_T;
-        }
-        break;
-
-    case PH_FRINFC_MIFARESTD_VAL15:
-        if(NdefMap->TLVStruct.prevLenByteValue >=
-            PH_FRINFC_MIFARESTD_NDEFTLV_L)
-        {
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
-        }
-        else
-        {
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NULLTLV_T;
-        }
-        break;
-
-    default:
-        if(NdefMap->TLVStruct.prevLenByteValue >=
-            PH_FRINFC_MIFARESTD_NDEFTLV_L)
-        {
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
-            TempLength++;
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_L;
-            TempLength++;
-            NdefMap->SendRecvBuf[TempLength] = (uint8_t)(NdefMap->TLVStruct.prevLenByteValue >>
-                                                PH_FRINFC_MIFARESTD_RIGHTSHIFT8);
-            TempLength++;
-            NdefMap->SendRecvBuf[TempLength] =
-                                (uint8_t)NdefMap->TLVStruct.prevLenByteValue;
-        }
-        else
-        {
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NULLTLV_T;
-            TempLength++;
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NULLTLV_T;
-            TempLength++;
-
-            /* Update the null TLV, ndef TLV block and ndef TLV byte */
-            NdefMap->TLVStruct.NULLTLVCount = PH_FRINFC_MIFARESTD_VAL2;
-            NdefMap->TLVStruct.NdefTLVBlock =
-                                NdefMap->StdMifareContainer.currentBlock;
-            NdefMap->TLVStruct.NdefTLVByte =
-                                (TempLength - PH_FRINFC_MIFARESTD_VAL1);
-
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
-            TempLength++;
-            NdefMap->SendRecvBuf[TempLength] =
-                                (uint8_t)NdefMap->TLVStruct.prevLenByteValue;
-        }
-        NdefMap->StdMifareContainer.RdAfterWrFlag = PH_FRINFC_MIFARESTD_FLAG0;
-        break;
-    }
-
-    return;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_CallWrNdefLen
- *
- * Description      This function is used to increment/decrement the ndef tlv block
- *                  and read the block.
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_CallWrNdefLen(phFriNfc_NdefMap_t        *NdefMap)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-
-    if(NdefMap->TLVStruct.NULLTLVCount >= PH_FRINFC_MIFARESTD_VAL2)
-    {
-        if((NdefMap->TLVStruct.NdefTLVByte == PH_FRINFC_MIFARESTD_VAL0) ||
-            (NdefMap->TLVStruct.NdefTLVByte == PH_FRINFC_MIFARESTD_VAL1) )
-        {
-            /* In this case, current block is decremented because the
-               NULL TLVs are in the previous block */
-            NdefMap->StdMifareContainer.currentBlock--;
-            Result = phFriNfc_MifStd_H_BlkChk_1(NdefMap);
-        }
-        else
-        {
-            /* case NdefMap->TLVStruct.NdefTLVByte = PH_FRINFC_MIFARESTD_VAL15:
-               Current block is incremented to update the remaining TLV
-               structure */
-            NdefMap->StdMifareContainer.currentBlock++;
-            Result = phFriNfc_MifStd_H_BlkChk(NdefMap);
-        }
-    }
-    else
-    {
-        if((NdefMap->TLVStruct.NdefTLVByte == PH_FRINFC_MIFARESTD_VAL13) ||
-            (NdefMap->TLVStruct.NdefTLVByte == PH_FRINFC_MIFARESTD_VAL14) ||
-            (NdefMap->TLVStruct.NdefTLVByte == PH_FRINFC_MIFARESTD_VAL15))
-        {
-            /* Current block is incremented to update the remaining TLV
-                structure */
-            NdefMap->StdMifareContainer.currentBlock++;
-            Result = phFriNfc_MifStd_H_BlkChk(NdefMap);
-        }
-    }
-
-    Result = ((Result == NFCSTATUS_SUCCESS)?
-            phFriNfc_MifStd_H_RdtoWrNdefLen(NdefMap):
-            Result);
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_BlkChk_1
- *
- * Description      This function check the current block is valid or not
- *                  if not valid decrement the current block till the valid block.
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_BlkChk_1(phFriNfc_NdefMap_t        *NdefMap)
-{
-    NFCSTATUS   Result  = NFCSTATUS_SUCCESS;
-    uint8_t     SectorID = PH_FRINFC_MIFARESTD_VAL0;
-
-    /* Get a Sector ID for the Current Block */
-    SectorID = phFriNfc_MifStd_H_GetSect(NdefMap->StdMifareContainer.currentBlock);
-
-    /* Check the sector id is valid or not and if valid then check the
-        current block is greater than 128 */
-    if((NdefMap->StdMifareContainer.aid[SectorID] ==
-        PH_FRINFC_MIFARESTD_NDEF_COMP) &&
-        (((SectorID <= PH_FRINFC_MIFARESTD_VAL15) &&
-        (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_1K_CARD)) ||
-        ((SectorID <= PH_FRINFC_MIFARESTD_SECTOR_NO31) &&
-        (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD)) ||
-        ((SectorID <= PH_FRINFC_MIFARESTD_SECTOR_NO39) &&
-        (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD))))
-    {
-        if(NdefMap->StdMifareContainer.currentBlock > 128)
-        {
-            NdefMap->TLVStruct.NdefTLVAuthFlag =
-            ((((NdefMap->StdMifareContainer.currentBlock +
-                PH_FRINFC_MIFARESTD_VAL1) %
-                PH_FRINFC_MIFARESTD_MAD_BLK16) ==
-                PH_FRINFC_MIFARESTD_VAL0)?
-                PH_FRINFC_MIFARESTD_FLAG1:
-                PH_FRINFC_MIFARESTD_FLAG0);
-
-                NdefMap->StdMifareContainer.currentBlock -=
-            ((((NdefMap->StdMifareContainer.currentBlock +
-                PH_FRINFC_MIFARESTD_VAL1) %
-                PH_FRINFC_MIFARESTD_MAD_BLK16) ==
-                PH_FRINFC_MIFARESTD_VAL0)?
-                PH_FRINFC_MIFARESTD_VAL1:
-                PH_FRINFC_MIFARESTD_VAL0);
-
-        }
-        else
-        {
-            NdefMap->TLVStruct.NdefTLVAuthFlag =
-            ((((NdefMap->StdMifareContainer.currentBlock +
-                PH_FRINFC_MIFARESTD_VAL1) %
-                PH_FRINFC_MIFARESTD_BLK4) ==
-                PH_FRINFC_MIFARESTD_VAL0)?
-                PH_FRINFC_MIFARESTD_FLAG1:
-                PH_FRINFC_MIFARESTD_FLAG0);
-
-            NdefMap->StdMifareContainer.currentBlock -=
-            ((((NdefMap->StdMifareContainer.currentBlock +
-                PH_FRINFC_MIFARESTD_VAL1) %
-                PH_FRINFC_MIFARESTD_BLK4) ==
-                PH_FRINFC_MIFARESTD_VAL1)?
-                PH_FRINFC_MIFARESTD_VAL1:
-                PH_FRINFC_MIFARESTD_VAL0);
-
-        }
-    }
-    else
-    {
-        /*Error: No Ndef Compliant Sectors present.*/
-        Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP,
-                            NFCSTATUS_INVALID_PARAMETER);
-    }
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_fillTLV1_1
- *
- * Description      This function updates the length of the TLV if NULL TLVs
- *                  greater than or equal to 2.
- *
- * Returns          void
- *
- ******************************************************************************/
-static void phFriNfc_MifStd_H_fillTLV1_1(phFriNfc_NdefMap_t        *NdefMap)
-{
-    switch(NdefMap->TLVStruct.NdefTLVByte)
-    {
-    case PH_FRINFC_MIFARESTD_VAL0:
-        /* In the first write ndef length procedure, the
-           length is updated, in this case T and L = 0xFF of TLV are
-           updated */
-        NdefMap->TLVStruct.NULLTLVCount = PH_FRINFC_MIFARESTD_VAL0;
-        NdefMap->TLVStruct.NdefTLVBlock =
-                            NdefMap->StdMifareContainer.currentBlock;
-        NdefMap->TLVStruct.NdefTLVByte = PH_FRINFC_MIFARESTD_VAL14;
-
-        NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL15] =
-                                PH_FRINFC_MIFARESTD_NDEFTLV_T;
-        NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL16] =
-                                PH_FRINFC_MIFARESTD_NDEFTLV_L;
-        break;
-
-    case PH_FRINFC_MIFARESTD_VAL1:
-        /* In the first write ndef length procedure, the
-           length is updated, in this case T of TLV is
-           updated */
-        NdefMap->TLVStruct.NULLTLVCount = PH_FRINFC_MIFARESTD_VAL0;
-        NdefMap->TLVStruct.NdefTLVBlock =
-                            NdefMap->StdMifareContainer.currentBlock;
-        NdefMap->TLVStruct.NdefTLVByte =
-                            PH_FRINFC_MIFARESTD_VAL15;
-        NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL16] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
-        break;
-
-    case PH_FRINFC_MIFARESTD_VAL15:
-    default:
-        /* In the first ndef write length, part of the L field or only T
-           (if update length is less than 255) is updated */
-        NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL1] =
-                                    (uint8_t)NdefMap->TLVStruct.prevLenByteValue;
-        break;
-    }
-    NdefMap->StdMifareContainer.RdAfterWrFlag = PH_FRINFC_MIFARESTD_FLAG0;
-
-    return;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_fillTLV2_1
- *
- * Description      This function updates the length of the TLV if NULL TLVs
- *                  less than 2.
- *
- * Returns          void
- *
- ******************************************************************************/
-static void phFriNfc_MifStd_H_fillTLV2_1(phFriNfc_NdefMap_t        *NdefMap)
-{
-    uint8_t     TempLength = PH_FRINFC_MIFARESTD_VAL1;
-    switch(NdefMap->TLVStruct.NdefTLVByte)
-    {
-    case PH_FRINFC_MIFARESTD_VAL13:
-        /* In last write ndef length, part of length (L) field of TLV
-           is updated now */
-        NdefMap->SendRecvBuf[TempLength] =
-                    (uint8_t)NdefMap->TLVStruct.prevLenByteValue;
-        break;
-
-    case PH_FRINFC_MIFARESTD_VAL14:
-        /* In last write ndef length, part of length (L) field of TLV
-           is updated now */
-        if(NdefMap->TLVStruct.prevLenByteValue >=
-                    PH_FRINFC_MIFARESTD_NDEFTLV_L)
-        {
-            NdefMap->SendRecvBuf[TempLength] =
-                            (uint8_t)(NdefMap->TLVStruct.prevLenByteValue >>
-                            PH_FRINFC_MIFARESTD_RIGHTSHIFT8);
-            TempLength++;
-            NdefMap->SendRecvBuf[TempLength] =
-                            (uint8_t)NdefMap->TLVStruct.prevLenByteValue;
-        }
-        else
-        {
-            NdefMap->TLVStruct.NULLTLVCount = PH_FRINFC_MIFARESTD_VAL2;
-            NdefMap->TLVStruct.NdefTLVBlock =
-                                NdefMap->StdMifareContainer.currentBlock;
-            NdefMap->TLVStruct.NdefTLVByte =
-                                (TempLength - PH_FRINFC_MIFARESTD_VAL1);
-            NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
-            TempLength++;
-            NdefMap->SendRecvBuf[TempLength] =
-                                        (uint8_t)NdefMap->TLVStruct.prevLenByteValue;
-        }
-        break;
-
-    case PH_FRINFC_MIFARESTD_VAL15:
-    default:
-        if(NdefMap->TLVStruct.prevLenByteValue >=
-            PH_FRINFC_MIFARESTD_NDEFTLV_L)
-        {
-            /* In last write ndef length, only T of TLV is updated and
-               length (L) field of TLV is updated now */
-            NdefMap->SendRecvBuf[TempLength] =
-                            PH_FRINFC_MIFARESTD_NDEFTLV_L;
-            TempLength++;
-            NdefMap->SendRecvBuf[TempLength] =
-                            (uint8_t)(NdefMap->TLVStruct.prevLenByteValue >>
-                            PH_FRINFC_MIFARESTD_RIGHTSHIFT8);
-            TempLength++;
-            NdefMap->SendRecvBuf[TempLength] =
-                            (uint8_t)NdefMap->TLVStruct.prevLenByteValue;
-        }
-        else
-        {
-            NdefMap->SendRecvBuf[TempLength] =
-                            PH_FRINFC_MIFARESTD_NULLTLV_T;
-            TempLength++;
-            NdefMap->TLVStruct.NULLTLVCount = PH_FRINFC_MIFARESTD_VAL2;
-            NdefMap->TLVStruct.NdefTLVBlock =
-                                NdefMap->StdMifareContainer.currentBlock;
-            NdefMap->TLVStruct.NdefTLVByte =
-                                (TempLength - PH_FRINFC_MIFARESTD_VAL1);
-            NdefMap->SendRecvBuf[TempLength] =
-                            PH_FRINFC_MIFARESTD_NDEFTLV_T;
-            TempLength++;
-            NdefMap->SendRecvBuf[TempLength] =
-                        (uint8_t)NdefMap->TLVStruct.prevLenByteValue;
-        }
-        break;
-    }
-    NdefMap->StdMifareContainer.RdAfterWrFlag = PH_FRINFC_MIFARESTD_FLAG0;
-
-    return;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_RdTLV
- *
- * Description      This function reads the TLV block.
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_RdTLV(phFriNfc_NdefMap_t        *NdefMap)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-
-    NdefMap->State = PH_FRINFC_NDEFMAP_STATE_RD_TLV;
-    NdefMap->PrevOperation = PH_FRINFC_NDEFMAP_READ_OPE;
-
-    Result = phFriNfc_MifStd_H_Rd16Bytes(NdefMap,
-                NdefMap->StdMifareContainer.currentBlock);
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_ProRdTLV
- *
- * Description      This function processes the read TLV block.
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_ProRdTLV(phFriNfc_NdefMap_t        *NdefMap)
-{
-    NFCSTATUS   Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP,
-                                    NFCSTATUS_INVALID_DEVICE_REQUEST);
-    uint8_t     TempLength = PH_FRINFC_MIFARESTD_VAL0,
-                NDEFFlag = PH_FRINFC_MIFARESTD_FLAG1;
-
-    /*TempLength = (uint8_t)(((NdefMap->TLVStruct.NULLTLVCount >=
-                PH_FRINFC_MIFARESTD_VAL2) &&
-                (NdefMap->TLVStruct.BytesRemainLinTLV > 0xFE))?
-                ((NdefMap->TLVStruct.NdefTLVByte +
-                PH_FRINFC_MIFARESTD_VAL2)%
-                PH_FRINFC_MIFARESTD_VAL16):
-                ((NdefMap->TLVStruct.NdefTLVByte +
-                PH_FRINFC_MIFARESTD_VAL4)%
-                PH_FRINFC_MIFARESTD_VAL16));*/
-
-    TempLength = (uint8_t)((NdefMap->TLVStruct.BytesRemainLinTLV <= 0xFE)?
-                        ((NdefMap->TLVStruct.NdefTLVByte +
-                        PH_FRINFC_MIFARESTD_VAL2)%
-                        PH_FRINFC_MIFARESTD_VAL16):
-                        ((NdefMap->TLVStruct.NdefTLVByte +
-                        PH_FRINFC_MIFARESTD_VAL4)%
-                        PH_FRINFC_MIFARESTD_VAL16));
-
-    if((*NdefMap->SendRecvLength == PH_FRINFC_MIFARESTD_BYTES_READ) &&
-        (NdefMap->ApduBuffIndex < NdefMap->ApduBufferSize))
-    {
-        if(NdefMap->TLVStruct.BytesRemainLinTLV != 0)
-        {
-            NDEFFlag = PH_FRINFC_MIFARESTD_FLAG0;
-            /* To read the remaining length (L) in TLV */
-            Result = phFriNfc_MifStd_H_RemainTLV(NdefMap, &NDEFFlag, &TempLength);
-        }
-    }
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_WrTermTLV
- *
- * Description      This function is used to write the terminator TLV.
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_WrTermTLV(phFriNfc_NdefMap_t   *NdefMap)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-    uint8_t     index = PH_FRINFC_MIFARESTD_VAL0;
-
-    /* Change the state to check ndef compliancy */
-    NdefMap->State = PH_FRINFC_NDEFMAP_STATE_TERM_TLV;
-
-    NdefMap->SendRecvBuf[index] =
-                        NdefMap->StdMifareContainer.currentBlock;
-    index++;
-    NdefMap->SendRecvBuf[index] = PH_FRINFC_MIFARESTD_TERMTLV_T;
-    index++;
-
-    while(index < PH_FRINFC_MIFARESTD_WR_A_BLK)
-    {
-        NdefMap->SendRecvBuf[index] = PH_FRINFC_MIFARESTD_NULLTLV_T;
-        index++;
-    }
-
-    NdefMap->TLVStruct.SetTermTLVFlag = PH_FRINFC_MIFARESTD_FLAG0;
-
-    Result = phFriNfc_MifStd_H_WrTLV(NdefMap);
-
-    return Result;
-}
-
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_ProWrABlock
- *
- * Description      This function processes the write a block.
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_ProWrABlock(phFriNfc_NdefMap_t   *NdefMap)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-
-    NdefMap->StdMifareContainer.WrLength = PH_FRINFC_MIFARESTD_VAL0;
-    if(NdefMap->ApduBuffIndex <
-        (uint16_t)NdefMap->ApduBufferSize)
-    {
-        /* Remaining bytes to write < 16 */
-        if(NdefMap->StdMifareContainer.RemainingBufFlag ==
-            PH_FRINFC_MIFARESTD_FLAG1)
-        {
-            /* Write complete, so next byte shall be */
-            NdefMap->StdMifareContainer.internalLength =
-                *NdefMap->DataCount;
-
-            /* Copy bytes less than 16 to internal buffer
-               for the next write this can be used */
-            memcpy( NdefMap->StdMifareContainer.internalBuf,
-                    NdefMap->StdMifareContainer.Buffer,
-                    NdefMap->StdMifareContainer.internalLength);
-
-            /* Increment the Send Buffer index */
-            NdefMap->ApduBuffIndex += NdefMap->NumOfBytesWritten;
-
-            NdefMap->StdMifareContainer.remainingSize -=
-                    NdefMap->NumOfBytesWritten;
-
-            NdefMap->StdMifareContainer.RemainingBufFlag = PH_FRINFC_MIFARESTD_VAL0;
-            /* Check for the End of Card */
-                NdefMap->StdMifareContainer.ReadWriteCompleteFlag =
-                    (uint8_t)((NdefMap->StdMifareContainer.remainingSize ==
-                    PH_FRINFC_MIFARESTD_VAL0)?
-                    PH_FRINFC_MIFARESTD_FLAG1:
-                    PH_FRINFC_MIFARESTD_FLAG0);
-
-            NdefMap->TLVStruct.SetTermTLVFlag =
-                    (uint8_t)(((NdefMap->StdMifareContainer.remainingSize ==
-                            PH_FRINFC_MIFARESTD_VAL0) ||
-                            (NdefMap->TLVStruct.SetTermTLVFlag ==
-                            PH_FRINFC_MIFARESTD_FLAG1))?
-                            PH_FRINFC_MIFARESTD_FLAG1:
-                            PH_FRINFC_MIFARESTD_FLAG0);
-
-        } /* internal Buffer > Send Buffer */
-        else if(NdefMap->StdMifareContainer.internalBufFlag ==
-                PH_FRINFC_MIFARESTD_FLAG1)
-        {
-            memcpy(NdefMap->StdMifareContainer.internalBuf,
-                    NdefMap->StdMifareContainer.Buffer,
-                    *NdefMap->DataCount);
-
-            NdefMap->StdMifareContainer.internalLength =
-                                    *NdefMap->DataCount;
-
-            /* Increment the Send Buffer index */
-            NdefMap->ApduBuffIndex +=
-                    NdefMap->NumOfBytesWritten;
-
-            NdefMap->StdMifareContainer.remainingSize -=
-                    NdefMap->NumOfBytesWritten;
-
-            NdefMap->StdMifareContainer.internalBufFlag =
-                                PH_FRINFC_MIFARESTD_FLAG0;
-            /* Check for the End of Card */
-            NdefMap->StdMifareContainer.ReadWriteCompleteFlag =
-                (uint8_t)(((NdefMap->StdMifareContainer.remainingSize ==
-                    PH_FRINFC_MIFARESTD_VAL0) &&
-                    (NdefMap->StdMifareContainer.internalLength ==
-                    PH_FRINFC_MIFARESTD_VAL0))?
-                    PH_FRINFC_MIFARESTD_FLAG1:
-                    PH_FRINFC_MIFARESTD_FLAG0);
-
-            NdefMap->TLVStruct.SetTermTLVFlag =
-                    (uint8_t)(((NdefMap->StdMifareContainer.remainingSize ==
-                            PH_FRINFC_MIFARESTD_VAL0) ||
-                            (NdefMap->TLVStruct.SetTermTLVFlag ==
-                            PH_FRINFC_MIFARESTD_FLAG1))?
-                            PH_FRINFC_MIFARESTD_FLAG1:
-                            PH_FRINFC_MIFARESTD_FLAG0);
-        }
-        else
-        {
-            NdefMap->StdMifareContainer.internalLength = 0;
-            /* Increment the Send Buffer index */
-            NdefMap->ApduBuffIndex +=
-                    NdefMap->NumOfBytesWritten;
-            NdefMap->StdMifareContainer.remainingSize -=
-                    NdefMap->NumOfBytesWritten;
-
-            /* Check for the End of Card */
-            if((NdefMap->StdMifareContainer.remainingSize ==
-                    PH_FRINFC_MIFARESTD_VAL0) ||
-                    (NdefMap->ApduBuffIndex == NdefMap->ApduBufferSize))
-            {
-                NdefMap->StdMifareContainer.ReadWriteCompleteFlag =
-                (uint8_t)((NdefMap->StdMifareContainer.remainingSize == 0)?
-                    PH_FRINFC_MIFARESTD_FLAG1:PH_FRINFC_MIFARESTD_FLAG0);
-
-                if(NdefMap->StdMifareContainer.internalLength ==
-                    PH_FRINFC_MIFARESTD_VAL0)
-                {
-                    NdefMap->StdMifareContainer.currentBlock++;
-                    /* Mifare 4k Card, After 128th Block
-                    each sector = 16 blocks in Mifare 4k */
-                    Result = ((NdefMap->StdMifareContainer.remainingSize == 0)?
-                                Result:
-                                phFriNfc_MifStd_H_BlkChk(NdefMap));
-                    NdefMap->StdMifareContainer.NdefBlocks++;
-                }
-                NdefMap->TLVStruct.SetTermTLVFlag =
-                    (uint8_t)(((NdefMap->StdMifareContainer.remainingSize ==
-                            PH_FRINFC_MIFARESTD_VAL0) ||
-                            (NdefMap->TLVStruct.SetTermTLVFlag ==
-                            PH_FRINFC_MIFARESTD_FLAG1))?
-                            PH_FRINFC_MIFARESTD_FLAG1:
-                            PH_FRINFC_MIFARESTD_FLAG0);
-            }
-            else
-            {
-                NdefMap->StdMifareContainer.currentBlock++;
-                NdefMap->StdMifareContainer.WrLength =
-                    (uint16_t)(NdefMap->ApduBufferSize - NdefMap->ApduBuffIndex);
-                /* Mifare 4k Card, After 128th Block
-                each sector = 16 blocks in Mifare 4k */
-                Result = phFriNfc_MifStd_H_BlkChk(NdefMap);
-                if(Result == NFCSTATUS_SUCCESS)
-                {
-                    NdefMap->StdMifareContainer.NdefBlocks++;
-                    Result = ((NdefMap->StdMifareContainer.AuthDone ==
-                                PH_FRINFC_MIFARESTD_FLAG1)?
-                                phFriNfc_MifStd_H_WrABlock(NdefMap):
-                                phFriNfc_MifStd_H_AuthSector(NdefMap));
-                }
-            }
-        }
-    }
-    else
-    {
-        Result = PHNFCSTVAL(    CID_FRI_NFC_NDEF_MAP,
-                                NFCSTATUS_INVALID_DEVICE_REQUEST);
-    }
-
-    if((Result == NFCSTATUS_SUCCESS) &&
-        (NdefMap->TLVStruct.SetTermTLVFlag !=
-        PH_FRINFC_MIFARESTD_FLAG1) &&
-        (NdefMap->StdMifareContainer.remainingSize >
-        PH_FRINFC_MIFARESTD_VAL0))
-    {
-        Result = phFriNfc_MifStd_H_WrTermTLV(NdefMap);
-    }
-    else
-    {
-        if((Result == NFCSTATUS_SUCCESS) &&
-            (NdefMap->TLVStruct.SetTermTLVFlag ==
-            PH_FRINFC_MIFARESTD_FLAG1))
-        {
-            /* Write the length to the L field in the TLV */
-            NdefMap->StdMifareContainer.TempBlockNo =
-                        NdefMap->StdMifareContainer.currentBlock;
-            phFriNfc_MifStd_H_SetNdefBlkAuth(NdefMap);
-            NdefMap->StdMifareContainer.currentBlock =
-                            NdefMap->TLVStruct.NdefTLVBlock;
-            Result = phFriNfc_MifStd_H_RdtoWrNdefLen(NdefMap);
-        }
-    }
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_CallDisCon
- *
- * Description      This function trigger disconnect after the authentication
- *                  has failed.
- *
- * Returns          This function return NFCSTATUS_PENDING in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_CallDisCon(phFriNfc_NdefMap_t   *NdefMap)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-
-    /* Set Ndef State */
-    NdefMap->State = PH_FRINFC_NDEFMAP_STATE_DISCONNECT;
-    NdefMap->MapCompletionInfo.CompletionRoutine = phFriNfc_MifareStdMap_Process;
-    NdefMap->MapCompletionInfo.Context = NdefMap;
-
-    Result = phNxNciExtns_MifareStd_Reconnect();
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_CallConnect
- *
- * Description      This function sets card state to connect after the
- *                  authentication has failed.
- *
- * Returns          NFCSTATUS_SUCCESS
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_CallConnect(phFriNfc_NdefMap_t   *NdefMap)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-
-    /* Set Ndef State */
-    NdefMap->State = PH_FRINFC_NDEFMAP_STATE_CONNECT;
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd1k_H_BlkChk
- *
- * Description      This function used to update the current block.
- *
- * Returns          void
- *
- ******************************************************************************/
-static void phFriNfc_MifStd1k_H_BlkChk(phFriNfc_NdefMap_t   *NdefMap,
-                                    uint8_t              SectorID,
-                                    uint8_t              *callbreak)
-{
-    /* every last block of a sector needs to be skipped */
-    if(((NdefMap->StdMifareContainer.currentBlock + PH_FRINFC_MIFARESTD_INC_1) %
-        PH_FRINFC_MIFARESTD_BLK4) == 0)
-    {
-        NdefMap->StdMifareContainer.currentBlock++;
-    }
-    else
-    {
-        if(NdefMap->StdMifareContainer.aid[SectorID] ==
-            PH_FRINFC_MIFARESTD_NDEF_COMP)
-        {
-            /* Check whether the block is first block of a (next)new sector and
-            also check if it is first block then internal length is zero
-            or not. Because once Authentication is done for the sector again
-            we should not authenticate it again */
-            if((NdefMap->StdMifareContainer.currentBlock ==
-                (SectorID * PH_FRINFC_MIFARESTD_BLK4)) &&
-                (NdefMap->StdMifareContainer.internalLength == 0))
-            {
-                NdefMap->StdMifareContainer.AuthDone = 0;
-            }
-            *callbreak = 1;
-        }
-        else
-        {
-            NdefMap->StdMifareContainer.currentBlock += PH_FRINFC_MIFARESTD_BLK4;
-        }
-    }
-
-    return;
-}
-
-/******************************************************************************
- * Function         phFrinfc_MifareClassic_GetContainerSize
- *
- * Description      This function calculate the card size.
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-NFCSTATUS phFrinfc_MifareClassic_GetContainerSize(const phFriNfc_NdefMap_t *NdefMap,
-                                   uint32_t *maxSize, uint32_t *actualSize)
-{
-    NFCSTATUS   result = NFCSTATUS_SUCCESS;
-    uint16_t    valid_no_of_bytes = 0;
-    uint8_t     sect_aid_index = 0;
-    /*  Mifare std card */
-
-    /*  Max size is the number of NDEF compliant blocks in the card
-        multiplied by 16 bytes */
-
-    /* Skip all the non ndef sectors */
-    while ((sect_aid_index < PH_FRINFC_NDEFMAP_MIFARESTD_TOTALNO_BLK) &&
-          (PH_FRINFC_MIFARESTD_NON_NDEF_COMP == NdefMap->StdMifareContainer.aid[sect_aid_index]))
-    {
-        sect_aid_index++;
-    }
-
-    /* Parse only the contiguous NDEF sectors for the max size calculation */
-     while ((sect_aid_index <PH_FRINFC_NDEFMAP_MIFARESTD_TOTALNO_BLK)&&
-           (PH_FRINFC_MIFARESTD_NDEF_COMP ==NdefMap->StdMifareContainer.aid[sect_aid_index]))
-    {
-        if (((PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD == NdefMap->CardType)||
-             (PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD == NdefMap->CardType)) && (sect_aid_index >= 32))
-        {
-            /* Mifare classic card of 4k size, sector >= 32 has
-               16 blocks per sector and in that 15 blocks are valid data blocks
-               16 is the block number in a sector
-               15 is the number of valid data blocks in a sector
-             */
-            valid_no_of_bytes += (uint16_t)(16 * 15);
-        }
-        else
-        {
-            valid_no_of_bytes += (uint16_t)(16 * 3);
-        }
-
-        sect_aid_index++;
-        if (16 == sect_aid_index)
-        {
-            /* Because sector index is 16, that is "MAD 2" block
-               For calculating size MAD block shall be ignored
-             */
-            sect_aid_index++;
-        }
-    }
-    /* The below check is for the 3 byte length format of the NDEF TLV
-       If the length field > 255, Max size will less by 4
-       else Max size will less by 2 (Type and Length of the NDEF TLV
-       has to be skipped to provide the maximum size in the card */
-    *maxSize = (valid_no_of_bytes > 0xFF) ? (valid_no_of_bytes - 4) : (valid_no_of_bytes - 2);
-
-    *actualSize = NdefMap->TLVStruct.BytesRemainLinTLV;
-
-    return result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifareStdMap_ConvertToReadOnly
- *
- * Description      This function converts the Mifare card to read-only.
- *                  It check preconditions before converting to read only.
- *
- * Returns          This function return NFCSTATUS_PENDING in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-NFCSTATUS
-phFriNfc_MifareStdMap_ConvertToReadOnly (
-               phFriNfc_NdefMap_t *NdefMap,
-               const uint8_t *ScrtKeyB)
-{
-    NFCSTATUS result = NFCSTATUS_SUCCESS;
-    uint8_t totalNoSectors = 0 , sectorTrailerBlockNo = 0;
-
-    if ( NdefMap == NULL)
-    {
-        result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_PARAMETER);
-    }
-    else if ( PH_NDEFMAP_CARD_STATE_INVALID == NdefMap->CardState )
-    {
-        result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_STATE);
-    }
-    else
-    {
-        /* card state is PH_NDEFMAP_CARD_STATE_READ_WRITE now */
-        /* get AID  array and parse */
-        if( PH_FRINFC_NDEFMAP_MIFARE_STD_1K_CARD == NdefMap->CardType )
-        {
-            totalNoSectors  = PH_FRINFC_MIFARESTD1K_TOTAL_SECTOR;
-        }
-        else if ( PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD == NdefMap->CardType )
-        {
-            totalNoSectors  = PH_FRINFC_MIFARESTD2K_TOTAL_SECTOR;
-        }
-        else if ( PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD == NdefMap->CardType )
-        {
-             totalNoSectors  = PH_FRINFC_MIFARESTD4K_TOTAL_SECTOR;
-        }
-
-        /* Store Key B in the context */
-        if(ScrtKeyB ==NULL)
-        {
-            memset (NdefMap->StdMifareContainer.UserScrtKeyB, PH_FRINFC_MIFARESTD_DEFAULT_KEY,
-                    PH_FRINFC_MIFARESTD_KEY_LEN);
-        }
-        else
-        {
-            memcpy (NdefMap->StdMifareContainer.UserScrtKeyB, ScrtKeyB, PH_FRINFC_MIFARESTD_KEY_LEN);
-        }
-
-        NdefMap->StdMifareContainer.TotalNoSectors = totalNoSectors;
-        if(totalNoSectors == 0)
-        {
-            result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_PARAMETER);
-        }
-        else
-        {
-            NdefMap->TLVStruct.NdefTLVFoundFlag = PH_FRINFC_MIFARESTD_FLAG0;
-            NdefMap->StdMifareContainer.RdBeforeWrFlag = PH_FRINFC_MIFARESTD_FLAG0;
-            NdefMap->StdMifareContainer.WrNdefFlag = PH_FRINFC_MIFARESTD_FLAG0;
-            NdefMap->StdMifareContainer.internalLength = PH_FRINFC_MIFARESTD_VAL0;
-            NdefMap->StdMifareContainer.RdAfterWrFlag = PH_FRINFC_MIFARESTD_FLAG0;
-            NdefMap->StdMifareContainer.AuthDone = PH_FRINFC_MIFARESTD_FLAG0;
-            NdefMap->StdMifareContainer.NFCforumSectFlag = PH_FRINFC_MIFARESTD_FLAG0;
-            NdefMap->StdMifareContainer.WriteAcsBitFlag = PH_FRINFC_MIFARESTD_FLAG0;
-
-            /* Sector 0 is MAD sector .Start from Sector 1 */
-            for(NdefMap->StdMifareContainer.ReadOnlySectorIndex = PH_FRINFC_MIFARESTD_FLAG1;
-                NdefMap->StdMifareContainer.ReadOnlySectorIndex < totalNoSectors;
-                NdefMap->StdMifareContainer.ReadOnlySectorIndex++)
-            {
-                /* skip MAD sectors */
-                if( PH_FRINFC_MIFARESTD_SECTOR_NO16 == NdefMap->StdMifareContainer.ReadOnlySectorIndex  )
-                {
-                    continue;
-                }
-
-                /* if not NDEF compliant skip  */
-                if( PH_FRINFC_MIFARESTD_NON_NDEF_COMP ==
-                    NdefMap->StdMifareContainer.aid[NdefMap->StdMifareContainer.ReadOnlySectorIndex])
-                {
-                    continue;
-                }
-
-                if (PH_FRINFC_MIFARESTD_NDEF_COMP ==
-                     NdefMap->StdMifareContainer.aid[NdefMap->StdMifareContainer.ReadOnlySectorIndex])
-                {
-                    /*get the sector trailer block number */
-                    sectorTrailerBlockNo =
-                        phFriNfc_MifStd_H_GetSectorTrailerBlkNo(NdefMap->StdMifareContainer.ReadOnlySectorIndex);
-                    NdefMap->StdMifareContainer.currentBlock = sectorTrailerBlockNo;
-                    NdefMap->StdMifareContainer.SectorTrailerBlockNo = sectorTrailerBlockNo;
-
-                    /* Proceed to authenticate the sector with Key B
-                       and  modify the sector trailor bits to make it read only*/
-                    result = phFriNfc_MifStd_H_AuthSector(NdefMap);
-
-                    if (result == NFCSTATUS_PENDING )
-                    {
-                        break;
-                    }
-                }
-            } /* end for */
-
-            /* There are no NDEF sectors in this card , return */
-            if(NdefMap->StdMifareContainer.ReadOnlySectorIndex == totalNoSectors &&
-               NFCSTATUS_PENDING!= result )
-            {
-                result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_NO_NDEF_SUPPORT);
-            }
-        } /* end else */
-    }
-
-    return result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_GetSectorTrailerBlkNo
- *
- * Description      This function returns the block number of the sector
- *                  trailor for the given sector trailer Id.
- *
- * Returns          uint8_t sectorTrailerblockNumber : sector trailor
- *
- ******************************************************************************/
-static uint8_t phFriNfc_MifStd_H_GetSectorTrailerBlkNo (uint8_t SectorID)
-{
-    uint8_t sectorTrailerblockNumber = 0;
-
-    /* every last block of a sector needs to be skipped */
-    if (SectorID < PH_FRINFC_MIFARESTD_SECTOR_NO32)
-    {
-        sectorTrailerblockNumber = (SectorID * PH_FRINFC_MIFARESTD_BLK4 ) + 3;
-    }
-    else
-    {
-        sectorTrailerblockNumber = ((PH_FRINFC_MIFARESTD_SECTOR_NO32 * PH_FRINFC_MIFARESTD_BLK4) +
-            ((SectorID - PH_FRINFC_MIFARESTD_SECTOR_NO32) * PH_FRINFC_MIFARESTD_SECTOR_BLOCKS)) + 15;
-    }
-
-    return sectorTrailerblockNumber;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_ProSectorTrailorAcsBits
- *
- * Description      This function is called during ConvertToReadonly process to
- *                  Authenticate NDEF compliant Sector.
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_ProSectorTrailorAcsBits(phFriNfc_NdefMap_t *NdefMap)
-{
-    NFCSTATUS   Result = NFCSTATUS_SUCCESS;
-
-    if(*NdefMap->SendRecvLength == PH_FRINFC_MIFARESTD_BYTES_READ)
-    {
-        if(NdefMap->StdMifareContainer.ReadAcsBitFlag ==
-            PH_FRINFC_MIFARESTD_FLAG1)
-        {
-            /* check for the correct access bits */
-            Result = phFriNfc_MifStd_H_ChkAcsBit(NdefMap);
-            if(Result  == NFCSTATUS_SUCCESS)
-            {
-
-                if(NdefMap->CardState == PH_NDEFMAP_CARD_STATE_READ_ONLY)
-                {
-                    /* Go to next sector */
-                    Result = phFriNfc_MifStd_H_ProWrSectorTrailor(NdefMap);
-                }
-                else
-                {
-                    /* tranceive to write the data into SendRecvBuff */
-                    Result = phFriNfc_MifStd_H_WrSectorTrailorBlock(NdefMap);
-                }
-            }
-        }
-    }
-    else
-    {
-        Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP,
-                     NFCSTATUS_INVALID_PARAMETER);
-    }
-
-    return Result;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_WrSectorTrailorBlock
- *
- * Description      This function makes current NDEF compliant Sector ReadOnly
- *                  modify the sector trailor bits and write it to the card.
- *
- * Returns          This function return NFCSTATUS_PENDING in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_WrSectorTrailorBlock(phFriNfc_NdefMap_t *NdefMap)
-{
-    NFCSTATUS status = NFCSTATUS_PENDING;
-
-    NdefMap->MapCompletionInfo.CompletionRoutine = phFriNfc_MifareStdMap_Process;
-    NdefMap->MapCompletionInfo.Context = NdefMap;
-    NdefMap->PrevOperation = PH_FRINFC_NDEFMAP_WRITE_OPE;
-
-    /* next state (update sector index) */
-    NdefMap->State = PH_FRINFC_NDEFMAP_STATE_WRITE_SEC;
-
-    /* Buffer Check */
-    if(NdefMap->SendRecvBuf != NULL)
-    {
-        NdefMap->SendRecvBuf[10] = 0x00;
-        NdefMap->SendRecvBuf[10] = NdefMap->SendRecvBuf[9] | PH_FRINFC_MIFARESTD_MASK_GPB_WR; /* WR bits 11*/
-
-        /*The NdefMap->SendRecvBuf already has the sector trailor.
-        modify the bits to make Read Only */
-        NdefMap->SendRecvBuf[1] = PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_NDEFSECT1; /* 0xD3 */
-        NdefMap->SendRecvBuf[2] = PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_NDEFSECT2; /* 0xF7 */
-        NdefMap->SendRecvBuf[3] = PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_NDEFSECT1; /* 0xD3 */
-        NdefMap->SendRecvBuf[4] = PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_NDEFSECT2; /* 0xF7 */
-        NdefMap->SendRecvBuf[5] = PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_NDEFSECT1; /* 0xD3 */
-        NdefMap->SendRecvBuf[6] = PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_NDEFSECT2; /* 0xF7 */
-
-        NdefMap->SendRecvBuf[7] = PH_FRINFC_MIFARESTD_NFCSECT_RDACS_BYTE6;/* 0x0F */
-        NdefMap->SendRecvBuf[8] = PH_FRINFC_MIFARESTD_NFCSECT_RDACS_BYTE7;/* 0x07 */
-        NdefMap->SendRecvBuf[9] = PH_FRINFC_MIFARESTD_NFCSECT_RDACS_BYTE8;/* 0x8F */
-
-        NdefMap->SendRecvBuf[11] = NdefMap->StdMifareContainer.UserScrtKeyB[0];
-        NdefMap->SendRecvBuf[12] = NdefMap->StdMifareContainer.UserScrtKeyB[1];
-        NdefMap->SendRecvBuf[13] = NdefMap->StdMifareContainer.UserScrtKeyB[2];
-        NdefMap->SendRecvBuf[14] = NdefMap->StdMifareContainer.UserScrtKeyB[3];
-        NdefMap->SendRecvBuf[15] = NdefMap->StdMifareContainer.UserScrtKeyB[4];
-        NdefMap->SendRecvBuf[16] = NdefMap->StdMifareContainer.UserScrtKeyB[5];
-
-        /* Write to Ndef Sector Block */
-        NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] = NdefMap->StdMifareContainer.currentBlock;
-
-        /* Copy Ndef Sector Block into buffer */
-        memcpy(NdefMap->StdMifareContainer.Buffer,
-                    &(NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL1]),
-                    PH_FRINFC_MIFARESTD_BLOCK_BYTES);
-
-        /* Write from here */
-        NdefMap->SendLength = MIFARE_MAX_SEND_BUF_TO_WRITE;
-        NdefMap->Cmd.MfCmd = phHal_eMifareWrite16;
-        *NdefMap->SendRecvLength = NdefMap->TempReceiveLength;
-
-        /* Call the Overlapped HAL Transceive function */
-        status = phFriNfc_ExtnsTransceive(NdefMap->pTransceiveInfo,
-                                      NdefMap->Cmd,
-                                      NdefMap->SendRecvBuf,
-                                      NdefMap->SendLength,
-                                      NdefMap->SendRecvLength);
-    }
-    else
-    {
-        /* Error: The control should not ideally come here.
-           Return Error.*/
-        status = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_FAILED);
-    }
-
-    return status;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_ProWrSectorTrailor
- *
- * Description      This function makes next NDEF compliant Sector ReadOnly.
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS phFriNfc_MifStd_H_ProWrSectorTrailor(phFriNfc_NdefMap_t *NdefMap)
-{
-    NFCSTATUS status =  NFCSTATUS_FAILED;
-    uint8_t sectorTrailerBlockNo = 0;
-
-    /*Increment Sector Index */
-    NdefMap->StdMifareContainer.ReadOnlySectorIndex++;
-
-    /* skip if MAD2 */
-    if(PH_FRINFC_MIFARESTD_SECTOR_NO16 == NdefMap->StdMifareContainer.ReadOnlySectorIndex )
-    {
-        NdefMap->StdMifareContainer.ReadOnlySectorIndex++;
-    }
-
-    /* if current sector index exceeds total sector index then
-       all ndef sectors are made readonly then return success
-       If a NON def sector is encountered return success*/
-    if (NdefMap->StdMifareContainer.ReadOnlySectorIndex >= NdefMap->StdMifareContainer.TotalNoSectors ||
-        PH_FRINFC_MIFARESTD_NON_NDEF_COMP  ==
-        NdefMap->StdMifareContainer.aid[NdefMap->StdMifareContainer.ReadOnlySectorIndex])
-    {
-        status = NFCSTATUS_SUCCESS;
-    }
-    else if(PH_FRINFC_MIFARESTD_NDEF_COMP  == NdefMap->StdMifareContainer.aid[NdefMap->StdMifareContainer.ReadOnlySectorIndex])
-    {
-        /* Convert next NDEF sector to read only */
-        sectorTrailerBlockNo = phFriNfc_MifStd_H_GetSectorTrailerBlkNo(NdefMap->StdMifareContainer.ReadOnlySectorIndex);
-        NdefMap->StdMifareContainer.currentBlock = sectorTrailerBlockNo;
-        NdefMap->StdMifareContainer.SectorTrailerBlockNo = sectorTrailerBlockNo;
-
-        status = phFriNfc_MifStd_H_AuthSector(NdefMap);
-    }
-
-    return status;
-}
-
-/******************************************************************************
- * Function         phFriNfc_MifStd_H_ProWrSectorTrailor
- *
- * Description      This function checks mapping spec version.
- *
- * Returns          This function return NFCSTATUS_SUCCESS in case of success
- *                  In case of failure returns other failure value.
- *
- ******************************************************************************/
-static NFCSTATUS   phFriNfc_MapTool_ChkSpcVer( const phFriNfc_NdefMap_t  *NdefMap,
-        uint8_t             VersionIndex)
-{
-    NFCSTATUS status = NFCSTATUS_SUCCESS;
-
-    uint8_t TagVerNo = NdefMap->SendRecvBuf[VersionIndex];
-
-    if ( TagVerNo == 0 )
-    {
-        /* Return Status Error invalid format */
-        status = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP,NFCSTATUS_INVALID_FORMAT);
-    }
-    else
-    {
-        switch (NdefMap->CardType)
-        {
-            case PH_FRINFC_NDEFMAP_MIFARE_STD_1K_CARD:
-            case PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD:
-            case PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD:
-                {
-                    /* calculate the major and minor version number of Mifare std version number */
-                    status = (( (( PH_NFCFRI_MFSTDMAP_NFCDEV_MAJOR_VER_NUM ==
-                                        PH_NFCFRI_MFSTDMAP_GET_MAJOR_TAG_VERNO(TagVerNo ) )&&
-                                    ( PH_NFCFRI_MFSTDMAP_NFCDEV_MINOR_VER_NUM ==
-                                      PH_NFCFRI_MFSTDMAP_GET_MINOR_TAG_VERNO(TagVerNo))) ||
-                                (( PH_NFCFRI_MFSTDMAP_NFCDEV_MAJOR_VER_NUM ==
-                                   PH_NFCFRI_MFSTDMAP_GET_MAJOR_TAG_VERNO(TagVerNo ) )&&
-                                 ( PH_NFCFRI_MFSTDMAP_NFCDEV_MINOR_VER_NUM <
-                                   PH_NFCFRI_MFSTDMAP_GET_MINOR_TAG_VERNO(TagVerNo) )))?
-                            NFCSTATUS_SUCCESS:
-                            PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP,
-                                NFCSTATUS_INVALID_FORMAT));
-                    break;
-                }
-
-            default:
-                {
-                    /* calculate the major and minor version number of T3VerNo */
-                    if( (( PH_NFCFRI_NDEFMAP_NFCDEV_MAJOR_VER_NUM ==
-                                    PH_NFCFRI_NDEFMAP_GET_MAJOR_TAG_VERNO(TagVerNo ) )&&
-                                ( PH_NFCFRI_NDEFMAP_NFCDEV_MINOR_VER_NUM ==
-                                  PH_NFCFRI_NDEFMAP_GET_MINOR_TAG_VERNO(TagVerNo))) ||
-                            (( PH_NFCFRI_NDEFMAP_NFCDEV_MAJOR_VER_NUM ==
-                               PH_NFCFRI_NDEFMAP_GET_MAJOR_TAG_VERNO(TagVerNo ) )&&
-                             ( PH_NFCFRI_NDEFMAP_NFCDEV_MINOR_VER_NUM <
-                               PH_NFCFRI_NDEFMAP_GET_MINOR_TAG_VERNO(TagVerNo) )))
-                    {
-                        status = PHNFCSTVAL(CID_NFC_NONE,NFCSTATUS_SUCCESS);
-                    }
-                    else
-                    {
-                        if ((PH_NFCFRI_NDEFMAP_NFCDEV_MAJOR_VER_NUM <
-                             PH_NFCFRI_NDEFMAP_GET_MAJOR_TAG_VERNO(TagVerNo)) ||
-                             (PH_NFCFRI_NDEFMAP_NFCDEV_MAJOR_VER_NUM >
-                             PH_NFCFRI_NDEFMAP_GET_MAJOR_TAG_VERNO(TagVerNo)))
-                        {
-                            status = PHNFCSTVAL (CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_FORMAT);
-                        }
-                    }
-                    break;
-                }
-        }
-    }
-
-    return (status);
-}
diff --git a/nci/jni/extns/pn54x/src/mifare/phFriNfc_MifareStdMap.cpp b/nci/jni/extns/pn54x/src/mifare/phFriNfc_MifareStdMap.cpp
new file mode 100644
index 00000000..25818b86
--- /dev/null
+++ b/nci/jni/extns/pn54x/src/mifare/phFriNfc_MifareStdMap.cpp
@@ -0,0 +1,5140 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * NFC Ndef Mapping For Remote Devices.
+ *
+ */
+
+#include <phFriNfc_MifStdFormat.h>
+#include <phFriNfc_MifareStdMap.h>
+#include <phNfcCompId.h>
+#include <phNxpExtns_MifareStd.h>
+
+/**************** local methods used in this file only ************************/
+static NFCSTATUS phFriNfc_MifStd_H_RdABlock(phFriNfc_NdefMap_t* NdefMap);
+static NFCSTATUS phFriNfc_MifStd_H_WrABlock(phFriNfc_NdefMap_t* NdefMap);
+static NFCSTATUS phFriNfc_MifStd_H_AuthSector(phFriNfc_NdefMap_t* NdefMap);
+static NFCSTATUS phFriNfc_MifStd4k_H_CheckNdef(phFriNfc_NdefMap_t* NdefMap);
+static void phFriNfc_MifStd_H_fillAIDarray(phFriNfc_NdefMap_t* NdefMap);
+static uint8_t phFriNfc_MifStd_H_GetSect(uint8_t BlockNumber);
+static NFCSTATUS phFriNfc_MifStd_H_BlkChk(phFriNfc_NdefMap_t* NdefMap);
+static NFCSTATUS phFriNfc_MifStd_H_RdAcsBit(phFriNfc_NdefMap_t* NdefMap);
+static NFCSTATUS phFriNfc_MifStd_H_ChkAcsBit(phFriNfc_NdefMap_t* NdefMap);
+static NFCSTATUS phFriNfc_MifStd_H_ChkRdWr(phFriNfc_NdefMap_t* NdefMap);
+static void phFriNfc_MifStd_H_ChkNdefCmpltSects(phFriNfc_NdefMap_t* NdefMap);
+static NFCSTATUS phFriNfc_MifStd_H_RemainTLV(phFriNfc_NdefMap_t* NdefMap,
+                                             uint8_t* Flag,
+                                             uint8_t* Temp16Bytes);
+static NFCSTATUS phFriNfc_MifStd_H_ChkIntLen(phFriNfc_NdefMap_t* NdefMap);
+static NFCSTATUS phFriNfc_MifStd_H_IntLenWioutNdef(phFriNfc_NdefMap_t* NdefMap,
+                                                   uint8_t* Flag,
+                                                   uint8_t* TempintBytes);
+static uint8_t phFriNfc_MifStd_H_UpdateTLV(phFriNfc_NdefMap_t* NdefMap);
+static NFCSTATUS phFriNfc_MifStd_H_WriteNdefLen(phFriNfc_NdefMap_t* NdefMap);
+static void phFriNfc_MifStd_H_SetNdefBlkAuth(phFriNfc_NdefMap_t* NdefMap);
+static void phFriNfc_MifStd_H_RdWrReset(phFriNfc_NdefMap_t* NdefMap);
+static NFCSTATUS phFriNfc_MifStd_H_RdtoWrNdefLen(phFriNfc_NdefMap_t* NdefMap);
+static NFCSTATUS phFriNfc_MifStd_H_GetActCardLen(phFriNfc_NdefMap_t* NdefMap);
+static NFCSTATUS phFriNfc_MifStd_H_ChkTLVs(phFriNfc_NdefMap_t* NdefMap,
+                                           uint8_t* CRFlag);
+static NFCSTATUS phFriNfc_MifStd_H_GetNxtTLV(phFriNfc_NdefMap_t* NdefMap,
+                                             uint16_t* TempLength,
+                                             uint8_t* TL4bytesFlag);
+static NFCSTATUS phFriNfc_MifStd_H_Chk16Bytes(phFriNfc_NdefMap_t* NdefMap,
+                                              uint16_t TempLength);
+static NFCSTATUS phFriNfc_MifStd_H_ChkRemainTLVs(phFriNfc_NdefMap_t* NdefMap,
+                                                 uint8_t* CRFlag,
+                                                 uint8_t* NDEFFlag);
+static void phFriNfc_MifStd_H_Complete(phFriNfc_NdefMap_t* NdefMap,
+                                       NFCSTATUS Result);
+static void phFriNfc_MifStd_H_Get1kStTrail(phFriNfc_NdefMap_t* NdefMap);
+static void phFriNfc_MifStd_H_Get4kStTrail(phFriNfc_NdefMap_t* NdefMap);
+static NFCSTATUS phFriNfc_MifStd_H_ProChkNdef(phFriNfc_NdefMap_t* NdefMap);
+static NFCSTATUS phFriNfc_MifStd_H_ProAuth(phFriNfc_NdefMap_t* NdefMap);
+static NFCSTATUS phFriNfc_MifStd_H_Rd16Bytes(phFriNfc_NdefMap_t* NdefMap,
+                                             uint8_t BlockNo);
+static NFCSTATUS phFriNfc_MifStd_H_ProAcsBits(phFriNfc_NdefMap_t* NdefMap);
+static NFCSTATUS phFriNfc_MifStd_H_GPBChk(phFriNfc_NdefMap_t* NdefMap);
+static NFCSTATUS phFriNfc_MifStd_H_ProStatNotValid(phFriNfc_NdefMap_t* NdefMap,
+                                                   NFCSTATUS status);
+static NFCSTATUS phFriNfc_MifStd_H_RdBeforeWr(phFriNfc_NdefMap_t* NdefMap);
+static NFCSTATUS phFriNfc_MifStd_H_ProBytesToWr(phFriNfc_NdefMap_t* NdefMap);
+static NFCSTATUS phFriNfc_MifStd_H_fillSendBuf(phFriNfc_NdefMap_t* NdefMap,
+                                               uint8_t Length);
+static NFCSTATUS phFriNfc_MifStd_H_WrTLV(phFriNfc_NdefMap_t* NdefMap);
+static NFCSTATUS phFriNfc_MifStd_H_ProWrTLV(phFriNfc_NdefMap_t* NdefMap);
+static uint8_t phFriNfc_MifStd_H_UpdRemTLV(phFriNfc_NdefMap_t* NdefMap);
+static void phFriNfc_MifStd_H_fillTLV1(phFriNfc_NdefMap_t* NdefMap);
+static void phFriNfc_MifStd_H_fillTLV2(phFriNfc_NdefMap_t* NdefMap);
+static NFCSTATUS phFriNfc_MifStd_H_CallWrNdefLen(phFriNfc_NdefMap_t* NdefMap);
+static NFCSTATUS phFriNfc_MifStd_H_BlkChk_1(phFriNfc_NdefMap_t* NdefMap);
+static void phFriNfc_MifStd_H_fillTLV1_1(phFriNfc_NdefMap_t* NdefMap);
+static void phFriNfc_MifStd_H_fillTLV2_1(phFriNfc_NdefMap_t* NdefMap);
+static NFCSTATUS phFriNfc_MifStd_H_RdTLV(phFriNfc_NdefMap_t* NdefMap);
+static NFCSTATUS phFriNfc_MifStd_H_ProRdTLV(phFriNfc_NdefMap_t* NdefMap);
+static NFCSTATUS phFriNfc_MifStd_H_WrTermTLV(phFriNfc_NdefMap_t* NdefMap);
+static NFCSTATUS phFriNfc_MifStd_H_ProWrABlock(phFriNfc_NdefMap_t* NdefMap);
+static NFCSTATUS phFriNfc_MifStd_H_CallConnect(phFriNfc_NdefMap_t* NdefMap);
+static NFCSTATUS phFriNfc_MifStd_H_CallDisCon(phFriNfc_NdefMap_t* NdefMap);
+static void phFriNfc_MifStd1k_H_BlkChk(phFriNfc_NdefMap_t* NdefMap,
+                                       uint8_t SectorID, uint8_t* callbreak);
+static uint8_t phFriNfc_MifStd_H_GetSectorTrailerBlkNo(uint8_t SectorID);
+static NFCSTATUS phFriNfc_MifStd_H_ProSectorTrailorAcsBits(
+    phFriNfc_NdefMap_t* NdefMap);
+static NFCSTATUS phFriNfc_MifStd_H_WrSectorTrailorBlock(
+    phFriNfc_NdefMap_t* NdefMap);
+static NFCSTATUS phFriNfc_MifStd_H_ProWrSectorTrailor(
+    phFriNfc_NdefMap_t* NdefMap);
+static NFCSTATUS phFriNfc_MapTool_ChkSpcVer(const phFriNfc_NdefMap_t* NdefMap,
+                                            uint8_t VersionIndex)
+    __attribute__((unused));
+
+/* Mifare Standard Mapping - Constants */
+#define PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_MADSECT1 \
+  0xA0 /* internal Authenticate Command for MAD Sector */
+#define PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_MADSECT2 \
+  0xA1 /* internal Authenticate Command for MAD Sector */
+#define PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_MADSECT3 \
+  0xA2 /* internal Authenticate Command for MAD Sector */
+#define PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_MADSECT4 \
+  0xA3 /* internal Authenticate Command for MAD Sector */
+#define PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_MADSECT5 \
+  0xA4 /* internal Authenticate Command for MAD Sector */
+#define PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_MADSECT6 \
+  0xA5 /* internal Authenticate Command for MAD Sector */
+#define PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_NDEFSECT1 \
+  0xD3 /* internal Authenticate Command for NDEF Sectors 1 */
+#define PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_NDEFSECT2 \
+  0xF7 /* internal Authenticate Command for NDEF Sectors 2 */
+#define PH_FRINFC_NDEFMAP_MIFARESTD_NDEF_COMPVAL2 \
+  0x03 /* internal Ndef Compliant command 1 */
+#define PH_FRINFC_NDEFMAP_MIFARESTD_NDEF_COMPVAL1 \
+  0xE1 /* internal Ndef Compliant command 2 */
+
+/* Enable access bits check for the MAD sector
+#define ENABLE_ACS_BIT_CHK_FOR_MAD */
+
+#define PH_FRINFC_NDEFMAP_MFUL_VAL0 0
+
+/******************************************************************************
+ * Function         phFriNfc_MapTool_SetCardState
+ *
+ * Description      This function sets the appropriate card state.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+NFCSTATUS phFriNfc_MapTool_SetCardState(phFriNfc_NdefMap_t* NdefMap,
+                                        uint32_t Length) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+
+  if (Length == PH_FRINFC_NDEFMAP_MFUL_VAL0) {
+    /* As the NDEF LEN / TLV Len is Zero, irrespective of any state the card
+       shall be set to INITIALIZED STATE*/
+    NdefMap->CardState =
+        (uint8_t)(((NdefMap->CardState == PH_NDEFMAP_CARD_STATE_READ_ONLY) ||
+                   (NdefMap->CardState == PH_NDEFMAP_CARD_STATE_INVALID))
+                      ? PH_NDEFMAP_CARD_STATE_INVALID
+                      : PH_NDEFMAP_CARD_STATE_INITIALIZED);
+  } else {
+    switch (NdefMap->CardState) {
+      case PH_NDEFMAP_CARD_STATE_INITIALIZED:
+        NdefMap->CardState =
+            (uint8_t)((NdefMap->CardState == PH_NDEFMAP_CARD_STATE_INVALID)
+                          ? NdefMap->CardState
+                          : PH_NDEFMAP_CARD_STATE_READ_WRITE);
+        break;
+
+      case PH_NDEFMAP_CARD_STATE_READ_ONLY:
+        NdefMap->CardState =
+            (uint8_t)((NdefMap->CardState == PH_NDEFMAP_CARD_STATE_INVALID)
+                          ? NdefMap->CardState
+                          : PH_NDEFMAP_CARD_STATE_READ_ONLY);
+        break;
+
+      case PH_NDEFMAP_CARD_STATE_READ_WRITE:
+        NdefMap->CardState =
+            (uint8_t)((NdefMap->CardState == PH_NDEFMAP_CARD_STATE_INVALID)
+                          ? NdefMap->CardState
+                          : PH_NDEFMAP_CARD_STATE_READ_WRITE);
+        if (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_1K_CARD ||
+            NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD ||
+            NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD) {
+          if (NdefMap->StdMifareContainer.ReadOnlySectorIndex &&
+              NdefMap->StdMifareContainer.SectorTrailerBlockNo ==
+                  NdefMap->StdMifareContainer.currentBlock) {
+            NdefMap->CardState =
+                (uint8_t)((NdefMap->CardState == PH_NDEFMAP_CARD_STATE_INVALID)
+                              ? NdefMap->CardState
+                              : PH_NDEFMAP_CARD_STATE_READ_ONLY);
+          }
+        }
+        break;
+
+      default:
+        NdefMap->CardState = PH_NDEFMAP_CARD_STATE_INVALID;
+        Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_NO_NDEF_SUPPORT);
+        break;
+    }
+  }
+  Result = ((NdefMap->CardState == PH_NDEFMAP_CARD_STATE_INVALID)
+                ? PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_NO_NDEF_SUPPORT)
+                : Result);
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifareStdMap_H_Reset
+ *
+ * Description      This function resets the component instance to the initial
+ *                  state and lets the component forget about the list of
+ *                  registered items. Moreover, the lower device is set.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+NFCSTATUS phFriNfc_MifareStdMap_H_Reset(phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  uint8_t index = PH_FRINFC_MIFARESTD_VAL0;
+
+  if (NdefMap == NULL) {
+    status = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_PARAMETER);
+  } else {
+    /* Current Block stores the present block accessed in the card */
+    NdefMap->StdMifareContainer.currentBlock = PH_FRINFC_MIFARESTD_VAL0;
+
+    for (index = PH_FRINFC_MIFARESTD_VAL0;
+         index < PH_FRINFC_NDEFMAP_MIFARESTD_ST15_BYTES; index++) {
+      /* internal buffer to store the odd bytes of length < 15 */
+      NdefMap->StdMifareContainer.internalBuf[index] = PH_FRINFC_MIFARESTD_VAL0;
+    }
+
+    for (index = 0; index < PH_FRINFC_NDEFMAP_MIFARESTD_TOTALNO_BLK; index++) {
+      /* aid buffer reset to non ndef compliant */
+      NdefMap->StdMifareContainer.aid[index] =
+          PH_FRINFC_MIFARESTD_NON_NDEF_COMP;
+    }
+
+    /* odd bytes length stored in the internal buffer */
+    NdefMap->StdMifareContainer.internalLength = PH_FRINFC_MIFARESTD_VAL0;
+
+    NdefMap->CardState = PH_NDEFMAP_CARD_STATE_INITIALIZED;
+
+    /* Flag to get that last few bytes are taken from the user buffer */
+    NdefMap->StdMifareContainer.RemainingBufFlag = PH_FRINFC_MIFARESTD_FLAG0;
+
+    /* Flag to find that the read/write operation has reached the end of the
+       card.
+        Further reading/writing is not possible */
+    NdefMap->StdMifareContainer.ReadWriteCompleteFlag =
+        PH_FRINFC_MIFARESTD_FLAG0;
+
+    /* Flag to get that last few bytes are taken from the internal buffer */
+    NdefMap->StdMifareContainer.internalBufFlag = PH_FRINFC_MIFARESTD_FLAG0;
+
+    /* Authentication Flag for every sector */
+    NdefMap->StdMifareContainer.AuthDone = PH_FRINFC_MIFARESTD_FLAG0;
+
+    /* Used in Check Ndef for storing the sector ID */
+    NdefMap->StdMifareContainer.SectorIndex = PH_FRINFC_MIFARESTD_VAL0;
+
+    NdefMap->StdMifareContainer.NdefBlocks = PH_FRINFC_MIFARESTD_VAL0;
+
+    NdefMap->StdMifareContainer.NoOfNdefCompBlocks = PH_FRINFC_MIFARESTD_VAL0;
+
+    NdefMap->StdMifareContainer.ReadAcsBitFlag = PH_FRINFC_MIFARESTD_FLAG0;
+
+    NdefMap->StdMifareContainer.remSizeUpdFlag = PH_FRINFC_MIFARESTD_FLAG0;
+
+    NdefMap->TLVStruct.NoLbytesinTLV = PH_FRINFC_MIFARESTD_VAL0;
+
+    NdefMap->TLVStruct.prevLenByteValue = PH_FRINFC_MIFARESTD_VAL0;
+
+    NdefMap->TLVStruct.BytesRemainLinTLV = PH_FRINFC_MIFARESTD_VAL0;
+
+    NdefMap->TLVStruct.NdefTLVBlock = PH_FRINFC_MIFARESTD_VAL0;
+
+    NdefMap->TLVStruct.NdefTLVByte = PH_FRINFC_MIFARESTD_VAL0;
+
+    NdefMap->TLVStruct.NULLTLVCount = PH_FRINFC_MIFARESTD_VAL0;
+
+    NdefMap->StdMifareContainer.remainingSize = PH_FRINFC_MIFARESTD_VAL0;
+
+    NdefMap->StdMifareContainer.ReadNdefFlag = PH_FRINFC_MIFARESTD_FLAG0;
+
+    NdefMap->StdMifareContainer.WrNdefFlag = PH_FRINFC_MIFARESTD_FLAG0;
+
+    NdefMap->StdMifareContainer.ChkNdefFlag = PH_FRINFC_MIFARESTD_FLAG0;
+
+    NdefMap->StdMifareContainer.aidCompleteFlag = PH_FRINFC_MIFARESTD_FLAG0;
+
+    NdefMap->StdMifareContainer.NFCforumSectFlag = PH_FRINFC_MIFARESTD_FLAG0;
+
+    NdefMap->StdMifareContainer.ProprforumSectFlag =
+        PH_FRINFC_MIFARESTD_PROP_1ST_CONFIG;
+
+    NdefMap->StdMifareContainer.ReadCompleteFlag = PH_FRINFC_MIFARESTD_FLAG0;
+
+    NdefMap->StdMifareContainer.FirstReadFlag = PH_FRINFC_MIFARESTD_FLAG0;
+
+    NdefMap->StdMifareContainer.WrLength = PH_FRINFC_MIFARESTD_VAL1;
+
+    NdefMap->StdMifareContainer.ChkNdefCompleteFlag = PH_FRINFC_MIFARESTD_FLAG0;
+
+    NdefMap->StdMifareContainer.ReadOnlySectorIndex = PH_FRINFC_MIFARESTD_FLAG0;
+
+    NdefMap->StdMifareContainer.TotalNoSectors = PH_FRINFC_MIFARESTD_FLAG0;
+
+    NdefMap->StdMifareContainer.SectorTrailerBlockNo =
+        PH_FRINFC_MIFARESTD_FLAG0;
+  }
+
+  return status;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifareStdMap_ChkNdef
+ *
+ * Description      The function checks whether the peer device is NDEF
+ *compliant.
+ *
+ * Returns          This function return NFCSTATUS_PENDING in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+NFCSTATUS phFriNfc_MifareStdMap_ChkNdef(phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS status = NFCSTATUS_PENDING;
+  uint8_t atq, sak;
+
+  if (NdefMap == NULL) {
+    status = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_PARAMETER);
+  } else {
+    NdefMap->PrevOperation = PH_FRINFC_NDEFMAP_CHECK_OPE;
+    NdefMap->StdMifareContainer.CRIndex = PH_FRINFC_NDEFMAP_CR_CHK_NDEF;
+
+    /* Get the Select Response and Sense Response to get
+        the exact Card Type either Mifare 1k or 4k */
+    sak = NdefMap->psRemoteDevInfo->RemoteDevInfo.Iso14443A_Info.Sak;
+    atq = NdefMap->psRemoteDevInfo->RemoteDevInfo.Iso14443A_Info.AtqA[0];
+
+    if (0x08 == (sak & 0x18)) {
+      /* Total Number of Blocks in Mifare 1k Card */
+      NdefMap->StdMifareContainer.NoOfNdefCompBlocks =
+          PH_FRINFC_NDEFMAP_MIFARESTD_1KNDEF_COMPBLOCK;
+      NdefMap->StdMifareContainer.remainingSize =
+          ((NdefMap->CardType == PH_FRINFC_MIFARESTD_VAL0)
+               ? (PH_FRINFC_NDEFMAP_MIFARESTD_1KNDEF_COMPBLOCK *
+                  PH_FRINFC_MIFARESTD_BLOCK_BYTES)
+               : NdefMap->StdMifareContainer.remainingSize);
+      NdefMap->CardType = PH_FRINFC_NDEFMAP_MIFARE_STD_1K_CARD;
+    } else if (0x19 == (sak & 0x19)) {
+      /* Total Number of Blocks in Mifare 2k Card */
+      NdefMap->StdMifareContainer.NoOfNdefCompBlocks =
+          PH_FRINFC_NDEFMAP_MIFARESTD_2KNDEF_COMPBLOCK;
+      NdefMap->StdMifareContainer.remainingSize =
+          ((NdefMap->CardType == PH_FRINFC_MIFARESTD_VAL0)
+               ? (PH_FRINFC_NDEFMAP_MIFARESTD_2KNDEF_COMPBLOCK *
+                  PH_FRINFC_MIFARESTD_BLOCK_BYTES)
+               : NdefMap->StdMifareContainer.remainingSize);
+      NdefMap->CardType = PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD;
+    } else {
+      /* Total Number of Blocks in Mifare 4k Card */
+      NdefMap->StdMifareContainer.NoOfNdefCompBlocks =
+          PH_FRINFC_NDEFMAP_MIFARESTD_4KNDEF_COMPBLOCK;
+      NdefMap->StdMifareContainer.remainingSize =
+          ((NdefMap->CardType == PH_FRINFC_MIFARESTD_VAL0)
+               ? (PH_FRINFC_NDEFMAP_MIFARESTD_4KNDEF_COMPBLOCK *
+                  PH_FRINFC_MIFARESTD_BLOCK_BYTES)
+               : NdefMap->StdMifareContainer.remainingSize);
+      NdefMap->CardType = PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD;
+    }
+
+    /*  phFriNfc_MifareStdMap_ChkNdef should be called only
+        when currentBlock is 0 OR 64,65 and 66 (for Mifare 4k).
+        Otherwise return error */
+    /* and also Check the Authentication Flag */
+    if ((NdefMap->StdMifareContainer.currentBlock != 0) &&
+        (NdefMap->StdMifareContainer.currentBlock != 1) &&
+        (NdefMap->StdMifareContainer.currentBlock != 2) &&
+        (NdefMap->StdMifareContainer.currentBlock != 64) &&
+        (NdefMap->StdMifareContainer.currentBlock != 65) &&
+        (NdefMap->StdMifareContainer.currentBlock != 66)) {
+      status = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_PARAMETER);
+    } else if (NdefMap->StdMifareContainer.AuthDone == 0) {
+      /*  Block 0 contains Manufacturer information and
+          also other informaton. So go for block 1 which
+          contains AIDs. Authenticating any of the block
+          in a sector, Authenticates the whole sector */
+      if (NdefMap->StdMifareContainer.currentBlock == 0) {
+        NdefMap->StdMifareContainer.currentBlock = 1;
+      }
+      status = phFriNfc_MifStd_H_AuthSector(NdefMap);
+    } else {
+      /**
+       * Mifare 1k, sak = 0x08 atq = 0x04
+       * Mifare 2k, sak = 0x19 atq = 0x02
+       * Mifare 4k, sak = 0x18 atq = 0x02
+       */
+      if ((NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD) ||
+          (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_1K_CARD) ||
+          (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD)) {
+        /* Change the state to Check Ndef Compliant */
+        NdefMap->State = PH_FRINFC_NDEFMAP_STATE_CHK_NDEF_COMP;
+        NdefMap->PrevOperation = PH_FRINFC_NDEFMAP_CHECK_OPE;
+        NdefMap->StdMifareContainer.ChkNdefFlag = PH_FRINFC_MIFARESTD_FLAG1;
+
+        NdefMap->MapCompletionInfo.CompletionRoutine =
+            phFriNfc_MifareStdMap_Process;
+        NdefMap->MapCompletionInfo.Context = NdefMap;
+
+        NdefMap->Cmd.MfCmd = phHal_eMifareRead;
+        *NdefMap->SendRecvLength = NdefMap->TempReceiveLength;
+        NdefMap->SendRecvBuf[0] = NdefMap->StdMifareContainer.currentBlock;
+        NdefMap->SendLength = MIFARE_MAX_SEND_BUF_TO_READ;
+
+        /* Call the Overlapped HAL Transceive function */
+        status = phFriNfc_ExtnsTransceive(
+            NdefMap->pTransceiveInfo, NdefMap->Cmd, NdefMap->SendRecvBuf,
+            NdefMap->SendLength, NdefMap->SendRecvLength);
+      } else {
+        /* Since we have decided temporarily not to go
+            for any new error codes we are using
+            NFCSTATUS_INVALID_PARAMETER even though it is not
+            the relevant error code here TBD */
+        status = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_PARAMETER);
+      }
+    }
+  }
+
+  return status;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifareStdMap_RdNdef
+ *
+ * Description      The function initiates the reading of NDEF information from
+ *                  a Remote Device. It performs a reset of the state and starts
+ *                  the action (state machine). A periodic call of the
+ *                  phFriNfcNdefMap_Process has to be done once the action
+ *                  has been triggered.
+ *
+ * Returns          This function return NFCSTATUS_PENDING in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+NFCSTATUS phFriNfc_MifareStdMap_RdNdef(phFriNfc_NdefMap_t* NdefMap,
+                                       uint8_t* PacketData,
+                                       uint32_t* PacketDataLength,
+                                       uint8_t Offset) {
+  NFCSTATUS status = NFCSTATUS_PENDING;
+
+  NdefMap->ApduBufferSize = *PacketDataLength;
+  NdefMap->NumOfBytesRead = PacketDataLength;
+  *NdefMap->NumOfBytesRead = 0;
+  NdefMap->ApduBuffIndex = 0;
+  NdefMap->PrevOperation = PH_FRINFC_NDEFMAP_READ_OPE;
+  NdefMap->StdMifareContainer.CRIndex = PH_FRINFC_NDEFMAP_CR_RD_NDEF;
+
+  if ((NdefMap->CardState == PH_NDEFMAP_CARD_STATE_INVALID) ||
+      (NdefMap->CardState == PH_NDEFMAP_CARD_STATE_INITIALIZED)) {
+    /* Card state  is not correct */
+    status = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_PARAMETER);
+  } else {
+    if ((Offset == PH_FRINFC_NDEFMAP_SEEK_BEGIN) ||
+        (NdefMap->PrevOperation == PH_FRINFC_NDEFMAP_WRITE_OPE)) {
+      phFriNfc_MifStd_H_RdWrReset(NdefMap);
+      NdefMap->StdMifareContainer.ReadNdefFlag = PH_FRINFC_MIFARESTD_FLAG1;
+      NdefMap->TLVStruct.NdefTLVFoundFlag = PH_FRINFC_MIFARESTD_FLAG0;
+    }
+    /* Offset = Current, but the read has reached the End of Card */
+    if ((Offset == PH_FRINFC_NDEFMAP_SEEK_CUR) &&
+        (NdefMap->StdMifareContainer.ReadWriteCompleteFlag ==
+         PH_FRINFC_MIFARESTD_FLAG1)) {
+      status = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP,
+                          NFCSTATUS_EOF_NDEF_CONTAINER_REACHED);
+    } else {
+      NdefMap->Offset =
+          (((Offset != PH_FRINFC_NDEFMAP_SEEK_BEGIN) &&
+            (NdefMap->PrevOperation == PH_FRINFC_NDEFMAP_WRITE_OPE))
+               ? PH_FRINFC_NDEFMAP_SEEK_BEGIN
+               : Offset);
+      status = phFriNfc_MifStd_H_BlkChk(NdefMap);
+      if (status == NFCSTATUS_SUCCESS) {
+        NdefMap->ApduBuffer = PacketData;
+
+        /* Read Operation in Progress */
+        NdefMap->StdMifareContainer.ReadWriteCompleteFlag =
+            PH_FRINFC_MIFARESTD_FLAG0;
+
+        /* Check Authentication Flag */
+        status =
+            ((NdefMap->StdMifareContainer.AuthDone == PH_FRINFC_MIFARESTD_FLAG1)
+                 ? phFriNfc_MifStd_H_RdABlock(NdefMap)
+                 : phFriNfc_MifStd_H_AuthSector(NdefMap));
+      }
+    }
+  }
+
+  return status;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifareStdMap_WrNdef
+ *
+ * Description      The function initiates the writing of NDEF information to
+ *                  a Remote Device. It performs a reset of the state and starts
+ *                  the action (state machine). A periodic call of the
+ *                  phFriNfcNdefMap_Process has to be done once the action
+ *                  has been triggered.
+ *
+ * Returns          This function return NFCSTATUS_PENDING in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+NFCSTATUS phFriNfc_MifareStdMap_WrNdef(phFriNfc_NdefMap_t* NdefMap,
+                                       uint8_t* PacketData,
+                                       uint32_t* PacketDataLength,
+                                       uint8_t Offset) {
+  NFCSTATUS status = NFCSTATUS_PENDING;
+
+  NdefMap->ApduBuffer = PacketData;
+  NdefMap->ApduBufferSize = *PacketDataLength;
+  NdefMap->ApduBuffIndex = PH_FRINFC_MIFARESTD_VAL0;
+  NdefMap->WrNdefPacketLength = PacketDataLength;
+  *NdefMap->WrNdefPacketLength = PH_FRINFC_MIFARESTD_VAL0;
+  NdefMap->PrevOperation = PH_FRINFC_NDEFMAP_WRITE_OPE;
+  NdefMap->StdMifareContainer.CRIndex = PH_FRINFC_NDEFMAP_CR_WR_NDEF;
+
+  if ((NdefMap->CardState == PH_NDEFMAP_CARD_STATE_INVALID) ||
+      (NdefMap->CardState == PH_NDEFMAP_CARD_STATE_READ_ONLY)) {
+    /* Card state  is not correct */
+    status = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_PARAMETER);
+  } else {
+    if ((Offset == PH_FRINFC_NDEFMAP_SEEK_BEGIN) ||
+        (NdefMap->PrevOperation == PH_FRINFC_NDEFMAP_READ_OPE)) {
+      NdefMap->TLVStruct.NdefTLVFoundFlag = PH_FRINFC_MIFARESTD_FLAG0;
+      NdefMap->StdMifareContainer.RdBeforeWrFlag = PH_FRINFC_MIFARESTD_FLAG1;
+      NdefMap->StdMifareContainer.WrNdefFlag = PH_FRINFC_MIFARESTD_FLAG1;
+      NdefMap->StdMifareContainer.internalLength = PH_FRINFC_MIFARESTD_VAL0;
+      NdefMap->StdMifareContainer.RdAfterWrFlag = PH_FRINFC_MIFARESTD_FLAG0;
+      NdefMap->StdMifareContainer.AuthDone = PH_FRINFC_MIFARESTD_FLAG0;
+      NdefMap->TLVStruct.NULLTLVCount = PH_FRINFC_MIFARESTD_VAL0;
+      NdefMap->TLVStruct.NdefTLVByte = PH_FRINFC_MIFARESTD_VAL0;
+      NdefMap->TLVStruct.NdefTLVAuthFlag = PH_FRINFC_MIFARESTD_FLAG0;
+      NdefMap->StdMifareContainer.FirstReadFlag = PH_FRINFC_MIFARESTD_FLAG0;
+      NdefMap->StdMifareContainer.remainingSize =
+          (NdefMap->StdMifareContainer.NoOfNdefCompBlocks *
+           PH_FRINFC_MIFARESTD_BLOCK_BYTES);
+      NdefMap->StdMifareContainer.currentBlock = PH_FRINFC_MIFARESTD_BLK4;
+      NdefMap->StdMifareContainer.NdefBlocks = PH_FRINFC_MIFARESTD_VAL1;
+      NdefMap->StdMifareContainer.NFCforumSectFlag = PH_FRINFC_MIFARESTD_FLAG0;
+      /* This macro is added, to be compliant with the previous HAL 2.0
+          For HAL 2.0, polling is done before writing data to the mifare
+          std (if the offset is BEGIN), because if an error is reported
+          during read or write and again write is called, the PN531 state is
+          unchanged (so write will fail), to bring the PN531 to the correct
+          state, polling is done.
+          Changed on 13th Jan 2009
+      */
+      NdefMap->StdMifareContainer.PollFlag = PH_FRINFC_MIFARESTD_FLAG0;
+      NdefMap->StdMifareContainer.WrLength = PH_FRINFC_MIFARESTD_VAL0;
+      NdefMap->StdMifareContainer.FirstWriteFlag = PH_FRINFC_MIFARESTD_FLAG1;
+    }
+
+    if (((Offset == PH_FRINFC_NDEFMAP_SEEK_CUR) &&
+         (NdefMap->StdMifareContainer.ReadWriteCompleteFlag ==
+          PH_FRINFC_MIFARESTD_FLAG1)) ||
+        ((NdefMap->StdMifareContainer.PollFlag == PH_FRINFC_MIFARESTD_FLAG1) &&
+         (Offset == PH_FRINFC_NDEFMAP_SEEK_CUR))) {
+      /* Offset = Current, but the read has reached the End of Card */
+      status = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP,
+                          NFCSTATUS_EOF_NDEF_CONTAINER_REACHED);
+    } else {
+      NdefMap->Offset =
+          (((Offset != PH_FRINFC_NDEFMAP_SEEK_BEGIN) &&
+            (NdefMap->PrevOperation == PH_FRINFC_NDEFMAP_READ_OPE))
+               ? PH_FRINFC_NDEFMAP_SEEK_BEGIN
+               : Offset);
+      NdefMap->StdMifareContainer.AuthDone = PH_FRINFC_MIFARESTD_FLAG0;
+      status = phFriNfc_MifStd_H_BlkChk(NdefMap);
+      NdefMap->StdMifareContainer.ReadWriteCompleteFlag =
+          PH_FRINFC_MIFARESTD_FLAG0;
+      if (status == NFCSTATUS_SUCCESS) {
+        if (NdefMap->StdMifareContainer.PollFlag == PH_FRINFC_MIFARESTD_FLAG1) {
+          /* if poll flag is set then call disconnect because the authentication
+              has failed so reactivation of card is required */
+          status = phFriNfc_MifStd_H_CallDisCon(NdefMap);
+        }
+        /* Check Authentication Flag */
+        else if (NdefMap->StdMifareContainer.AuthDone ==
+                 PH_FRINFC_MIFARESTD_FLAG1) {
+          status = ((NdefMap->Offset == PH_FRINFC_NDEFMAP_SEEK_BEGIN)
+                        ? phFriNfc_MifStd_H_RdBeforeWr(NdefMap)
+                        : phFriNfc_MifStd_H_WrABlock(NdefMap));
+        } else {
+          status = phFriNfc_MifStd_H_AuthSector(NdefMap);
+        }
+      }
+    }
+  }
+
+  return status;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifareStdMap_Process
+ *
+ * Description      This function is a Completion Routine, Processing function,
+ *                  needed to avoid long blocking.
+ *                  This function as a Completion Routine in order to be able
+ *                  to notify the component that an I/O has finished and data
+ *                  are ready to be processed.
+
+ * Returns          void
+ *
+ ******************************************************************************/
+void phFriNfc_MifareStdMap_Process(void* Context, NFCSTATUS Status) {
+  phFriNfc_NdefMap_t* NdefMap;
+  uint8_t NDEFFlag = 0, CRFlag = 0, Temp16Bytes = 0, i = 0;
+
+  NdefMap = (phFriNfc_NdefMap_t*)Context;
+
+  if ((Status & PHNFCSTBLOWER) == (NFCSTATUS_SUCCESS & PHNFCSTBLOWER)) {
+    switch (NdefMap->State) {
+      case PH_FRINFC_NDEFMAP_STATE_CHK_NDEF_COMP:
+        Status = phFriNfc_MifStd_H_ProChkNdef(NdefMap);
+        CRFlag = (uint8_t)((Status != NFCSTATUS_PENDING)
+                               ? PH_FRINFC_MIFARESTD_FLAG1
+                               : PH_FRINFC_MIFARESTD_FLAG0);
+        break;
+
+      case PH_FRINFC_NDEFMAP_STATE_READ:
+        /* Receive Length for read shall always be equal to 16 */
+        if ((*NdefMap->SendRecvLength == PH_FRINFC_MIFARESTD_BYTES_READ) &&
+            (NdefMap->ApduBuffIndex < (uint16_t)NdefMap->ApduBufferSize)) {
+          Temp16Bytes = PH_FRINFC_MIFARESTD_VAL0;
+          NDEFFlag = (uint8_t)PH_FRINFC_MIFARESTD_FLAG1;
+          if (NdefMap->TLVStruct.BytesRemainLinTLV != 0) {
+            NDEFFlag = PH_FRINFC_MIFARESTD_FLAG0;
+            CRFlag = PH_FRINFC_MIFARESTD_FLAG0;
+            /* To read the remaining length (L) in TLV */
+            Status =
+                phFriNfc_MifStd_H_RemainTLV(NdefMap, &NDEFFlag, &Temp16Bytes);
+            CRFlag = (uint8_t)((Status != NFCSTATUS_PENDING)
+                                   ? PH_FRINFC_MIFARESTD_FLAG1
+                                   : PH_FRINFC_MIFARESTD_FLAG0);
+          }
+
+          /* check the NDEFFlag is set. if this is not set, then
+              in the above RemainTLV function all the 16 bytes has been
+              read */
+        } else {
+          Status = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP,
+                              NFCSTATUS_INVALID_RECEIVE_LENGTH);
+          CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
+        }
+        break;
+
+      case PH_FRINFC_NDEFMAP_STATE_WRITE:
+        Status = phFriNfc_MifStd_H_ProWrABlock(NdefMap);
+        CRFlag = (uint8_t)((Status != NFCSTATUS_PENDING)
+                               ? PH_FRINFC_MIFARESTD_FLAG1
+                               : PH_FRINFC_MIFARESTD_FLAG0);
+
+        /* Call Completion Routine if CR Flag is Set to 1 */
+        if (CRFlag == PH_FRINFC_MIFARESTD_FLAG1) {
+          *NdefMap->WrNdefPacketLength = NdefMap->ApduBuffIndex;
+        }
+        break;
+
+      case PH_FRINFC_NDEFMAP_STATE_AUTH:
+        NdefMap->StdMifareContainer.FirstReadFlag = PH_FRINFC_MIFARESTD_FLAG0;
+        Status = phFriNfc_MifStd_H_ProAuth(NdefMap);
+        CRFlag = (uint8_t)((Status != NFCSTATUS_PENDING)
+                               ? PH_FRINFC_MIFARESTD_FLAG1
+                               : PH_FRINFC_MIFARESTD_FLAG0);
+        break;
+
+      case PH_FRINFC_NDEFMAP_STATE_RD_ACS_BIT:
+        Status = phFriNfc_MifStd_H_ProAcsBits(NdefMap);
+        CRFlag = (uint8_t)((Status != NFCSTATUS_PENDING)
+                               ? PH_FRINFC_MIFARESTD_FLAG1
+                               : PH_FRINFC_MIFARESTD_FLAG0);
+        break;
+
+      case PH_FRINFC_NDEFMAP_STATE_WR_NDEF_LEN:
+        if (NdefMap->StdMifareContainer.RdAfterWrFlag ==
+            PH_FRINFC_MIFARESTD_FLAG1) {
+          Status = phFriNfc_MifStd_H_CallWrNdefLen(NdefMap);
+          CRFlag = (uint8_t)((Status != NFCSTATUS_PENDING)
+                                 ? PH_FRINFC_MIFARESTD_FLAG1
+                                 : PH_FRINFC_MIFARESTD_FLAG0);
+        } else {
+          /* Check this */
+          if (NdefMap->StdMifareContainer.TempBlockNo ==
+              NdefMap->StdMifareContainer.currentBlock) {
+            memcpy(NdefMap->StdMifareContainer.internalBuf,
+                   NdefMap->StdMifareContainer.Buffer,
+                   NdefMap->StdMifareContainer.internalLength);
+          }
+          *NdefMap->WrNdefPacketLength = NdefMap->ApduBuffIndex;
+          NdefMap->StdMifareContainer.currentBlock =
+              NdefMap->StdMifareContainer.TempBlockNo;
+          NdefMap->CardState = (uint8_t)(
+              (NdefMap->CardState == PH_NDEFMAP_CARD_STATE_INITIALIZED)
+                  ? PH_NDEFMAP_CARD_STATE_READ_WRITE
+                  : NdefMap->CardState);
+          CRFlag = (uint8_t)PH_FRINFC_MIFARESTD_FLAG1;
+        }
+        /*NdefMap->StdMifareContainer.remainingSize -=
+        (((NdefMap->ApduBufferSize) > (PH_FRINFC_MIFARESTD_NDEFTLV_L -
+                                    PH_FRINFC_MIFARESTD_VAL1))?
+                                    ((uint16_t)(*NdefMap->WrNdefPacketLength +
+                                    PH_FRINFC_MIFARESTD_VAL4)):
+                                    ((uint16_t)(*NdefMap->WrNdefPacketLength +
+                                    PH_FRINFC_MIFARESTD_VAL2)));*/
+        break;
+
+      case PH_FRINFC_NDEFMAP_STATE_RD_TO_WR_NDEF_LEN:
+        CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
+        Status =
+            PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_DEVICE_REQUEST);
+        if (*NdefMap->SendRecvLength == PH_FRINFC_MIFARESTD_BYTES_READ) {
+          /* Size of NdefMap->SendRecvBuf is set by phLibNfc_Gen_NdefMapReset to
+           * PH_LIBNFC_GEN_MAX_BUFFER */
+          /* We don't have to check memory here */
+          for (i = PH_FRINFC_MIFARESTD_BYTES_READ; i > 0; i--) {
+            NdefMap->SendRecvBuf[i] = NdefMap->SendRecvBuf[i - 1];
+          }
+          NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
+              NdefMap->StdMifareContainer.currentBlock;
+          Status = phFriNfc_MifStd_H_WriteNdefLen(NdefMap);
+          CRFlag = (uint8_t)((Status != NFCSTATUS_PENDING)
+                                 ? PH_FRINFC_MIFARESTD_FLAG1
+                                 : PH_FRINFC_MIFARESTD_FLAG0);
+        }
+        break;
+
+      case PH_FRINFC_NDEFMAP_STATE_GET_ACT_CARDSIZE:
+        NDEFFlag = PH_FRINFC_MIFARESTD_FLAG1;
+        if (NdefMap->TLVStruct.NoLbytesinTLV > PH_FRINFC_MIFARESTD_VAL0) {
+          NDEFFlag = PH_FRINFC_MIFARESTD_FLAG0;
+          Status = phFriNfc_MifStd_H_ChkRemainTLVs(NdefMap, &CRFlag, &NDEFFlag);
+          NdefMap->TLVStruct.NoLbytesinTLV = PH_FRINFC_MIFARESTD_VAL0;
+        }
+        if ((NDEFFlag == PH_FRINFC_MIFARESTD_FLAG1) &&
+            (CRFlag != PH_FRINFC_MIFARESTD_FLAG1)) {
+          Status = phFriNfc_MifStd_H_ChkTLVs(NdefMap, &CRFlag);
+        }
+        if (((NdefMap->StdMifareContainer.ReadNdefFlag ==
+              PH_FRINFC_MIFARESTD_FLAG1) ||
+             (NdefMap->StdMifareContainer.WrNdefFlag ==
+              PH_FRINFC_MIFARESTD_FLAG1)) &&
+            (Status != NFCSTATUS_PENDING)) {
+          NdefMap->StdMifareContainer.NFCforumSectFlag =
+              PH_FRINFC_MIFARESTD_FLAG1;
+          CRFlag = PH_FRINFC_MIFARESTD_FLAG0;
+          /* if the card state has changed to initialised and
+           read ndef is called then error is returned */
+          if (((NdefMap->StdMifareContainer.WrNdefFlag ==
+                PH_FRINFC_MIFARESTD_FLAG1) &&
+               (NdefMap->CardState == PH_NDEFMAP_CARD_STATE_READ_ONLY)) ||
+              ((NdefMap->StdMifareContainer.ReadNdefFlag ==
+                PH_FRINFC_MIFARESTD_FLAG1) &&
+               (NdefMap->CardState == PH_NDEFMAP_CARD_STATE_INITIALIZED))) {
+            Status =
+                PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_NO_NDEF_SUPPORT);
+          }
+          if (NdefMap->StdMifareContainer.AuthDone ==
+              PH_FRINFC_MIFARESTD_FLAG0) {
+            Status = phFriNfc_MifStd_H_AuthSector(NdefMap);
+          } else {
+            Status = ((NdefMap->StdMifareContainer.ReadNdefFlag ==
+                       PH_FRINFC_MIFARESTD_FLAG1)
+                          ? phFriNfc_MifStd_H_RdTLV(NdefMap)
+                          : phFriNfc_MifStd_H_RdBeforeWr(NdefMap));
+          }
+          NdefMap->StdMifareContainer.ReadNdefFlag = PH_FRINFC_MIFARESTD_FLAG0;
+          NdefMap->StdMifareContainer.WrNdefFlag = PH_FRINFC_MIFARESTD_FLAG0;
+        }
+
+        if (NdefMap->StdMifareContainer.ChkNdefFlag ==
+            PH_FRINFC_MIFARESTD_FLAG1) {
+          CRFlag = (uint8_t)((Status != NFCSTATUS_PENDING)
+                                 ? PH_FRINFC_MIFARESTD_FLAG1
+                                 : PH_FRINFC_MIFARESTD_FLAG0);
+        }
+        break;
+
+      case PH_FRINFC_NDEFMAP_STATE_RD_BEF_WR:
+        /* Read flag says that already part of TLV has been written */
+        Status = phFriNfc_MifStd_H_ProBytesToWr(NdefMap);
+        CRFlag = (uint8_t)((Status != NFCSTATUS_PENDING)
+                               ? PH_FRINFC_MIFARESTD_FLAG1
+                               : PH_FRINFC_MIFARESTD_FLAG0);
+        break;
+
+      case PH_FRINFC_NDEFMAP_STATE_WR_TLV:
+        Status = phFriNfc_MifStd_H_ProWrTLV(NdefMap);
+        CRFlag = (uint8_t)((Status != NFCSTATUS_PENDING)
+                               ? PH_FRINFC_MIFARESTD_FLAG1
+                               : PH_FRINFC_MIFARESTD_FLAG0);
+        break;
+
+      case PH_FRINFC_NDEFMAP_STATE_RD_TLV:
+        Status = phFriNfc_MifStd_H_ProRdTLV(NdefMap);
+        CRFlag = (uint8_t)((Status != NFCSTATUS_PENDING)
+                               ? PH_FRINFC_MIFARESTD_FLAG1
+                               : PH_FRINFC_MIFARESTD_FLAG0);
+        break;
+
+      case PH_FRINFC_NDEFMAP_STATE_TERM_TLV:
+        phFriNfc_MifStd_H_SetNdefBlkAuth(NdefMap);
+        NdefMap->StdMifareContainer.currentBlock =
+            NdefMap->TLVStruct.NdefTLVBlock;
+        Status = phFriNfc_MifStd_H_RdtoWrNdefLen(NdefMap);
+        CRFlag = (uint8_t)((Status != NFCSTATUS_PENDING)
+                               ? PH_FRINFC_MIFARESTD_FLAG1
+                               : PH_FRINFC_MIFARESTD_FLAG0);
+        break;
+
+      case PH_FRINFC_NDEFMAP_STATE_DISCONNECT:
+        NdefMap->StdMifareContainer.PollFlag = PH_FRINFC_MIFARESTD_FLAG0;
+
+        Status = phFriNfc_MifStd_H_CallConnect(NdefMap);
+        CRFlag = (uint8_t)((Status != NFCSTATUS_PENDING)
+                               ? PH_FRINFC_MIFARESTD_FLAG1
+                               : PH_FRINFC_MIFARESTD_FLAG0);
+        break;
+
+      case PH_FRINFC_NDEFMAP_STATE_CONNECT:
+        if (NdefMap->StdMifareContainer.FirstReadFlag ==
+            PH_FRINFC_MIFARESTD_FLAG1) {
+          NdefMap->StdMifareContainer.FirstReadFlag = PH_FRINFC_MIFARESTD_FLAG0;
+          Status = phFriNfc_MifStd_H_AuthSector(NdefMap);
+        } else if ((NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_1K_CARD ||
+                    NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD ||
+                    NdefMap->CardType ==
+                        PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD) &&
+                   (NdefMap->StdMifareContainer.ReadOnlySectorIndex &&
+                    NdefMap->StdMifareContainer.SectorTrailerBlockNo ==
+                        NdefMap->StdMifareContainer.currentBlock)) {
+          NdefMap->StdMifareContainer.ReadOnlySectorIndex =
+              PH_FRINFC_MIFARESTD_FLAG0;
+          NdefMap->StdMifareContainer.SectorTrailerBlockNo =
+              PH_FRINFC_MIFARESTD_FLAG0;
+          NdefMap->StdMifareContainer.currentBlock = PH_FRINFC_MIFARESTD_FLAG0;
+          Status = NFCSTATUS_FAILED;
+        } else {
+          Status =
+              ((((NdefMap->Offset == PH_FRINFC_NDEFMAP_SEEK_CUR) &&
+                 (NdefMap->PrevOperation == PH_FRINFC_NDEFMAP_WRITE_OPE)) ||
+                (NdefMap->StdMifareContainer.WrLength >
+                 PH_FRINFC_MIFARESTD_VAL0))
+                   ? phFriNfc_MifStd_H_ProStatNotValid(NdefMap, Status)
+                   : phFriNfc_MifStd_H_AuthSector(NdefMap));
+        }
+        CRFlag = (uint8_t)((Status != NFCSTATUS_PENDING)
+                               ? PH_FRINFC_MIFARESTD_FLAG1
+                               : PH_FRINFC_MIFARESTD_FLAG0);
+        break;
+
+      case PH_FRINFC_NDEFMAP_STATE_RD_SEC_ACS_BIT:
+        Status = phFriNfc_MifStd_H_ProSectorTrailorAcsBits(NdefMap);
+        CRFlag = (uint8_t)((Status != NFCSTATUS_PENDING)
+                               ? PH_FRINFC_MIFARESTD_FLAG1
+                               : PH_FRINFC_MIFARESTD_FLAG0);
+        if ((CRFlag == PH_FRINFC_MIFARESTD_FLAG1) &&
+            (NdefMap->StdMifareContainer.WriteAcsBitFlag ==
+             PH_FRINFC_MIFARESTD_FLAG0)) {
+          Status = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP,
+                              NFCSTATUS_INVALID_DEVICE_REQUEST);
+        }
+        break;
+
+      case PH_FRINFC_NDEFMAP_STATE_WRITE_SEC:
+        /* Set flag for writing of Acs bit */
+        NdefMap->StdMifareContainer.WriteAcsBitFlag = PH_FRINFC_MIFARESTD_FLAG1;
+
+        /* The first NDEF sector is already made read only,
+           set card state to read only and proceed*/
+        if (NdefMap->CardState != PH_NDEFMAP_CARD_STATE_READ_ONLY) {
+          Status = phFriNfc_MapTool_SetCardState(
+              NdefMap, NdefMap->TLVStruct.BytesRemainLinTLV);
+          if (Status != NFCSTATUS_SUCCESS) {
+            CRFlag = (uint8_t)PH_FRINFC_MIFARESTD_FLAG1;
+          }
+        }
+
+        if (CRFlag != PH_FRINFC_MIFARESTD_FLAG1) {
+          Status = phFriNfc_MifStd_H_ProWrSectorTrailor(NdefMap);
+          CRFlag = (uint8_t)((Status != NFCSTATUS_PENDING)
+                                 ? PH_FRINFC_MIFARESTD_FLAG1
+                                 : PH_FRINFC_MIFARESTD_FLAG0);
+        }
+        break;
+
+      default:
+        Status =
+            PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_DEVICE_REQUEST);
+        CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
+        break;
+    }
+  } else if (NdefMap->State == PH_FRINFC_NDEFMAP_STATE_AUTH) {
+    NdefMap->StdMifareContainer.PollFlag = PH_FRINFC_MIFARESTD_FLAG1;
+    if (NdefMap->StdMifareContainer.FirstWriteFlag ==
+        PH_FRINFC_MIFARESTD_FLAG1) {
+      NdefMap->StdMifareContainer.FirstWriteFlag = PH_FRINFC_MIFARESTD_FLAG0;
+      NdefMap->StdMifareContainer.WrLength =
+          ((NdefMap->StdMifareContainer.NFCforumSectFlag ==
+            PH_FRINFC_MIFARESTD_FLAG0)
+               ? PH_FRINFC_MIFARESTD_VAL1
+               : NdefMap->StdMifareContainer.WrLength);
+    }
+    if (NdefMap->StdMifareContainer.WrLength == PH_FRINFC_MIFARESTD_VAL0) {
+      Status = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP,
+                          NFCSTATUS_EOF_NDEF_CONTAINER_REACHED);
+      CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
+    } else {
+      /* Authentication has failed */
+      /* Status = phFriNfc_MifStd_H_CallDisCon(NdefMap);
+      CRFlag = (uint8_t)((Status != NFCSTATUS_PENDING)?
+                  PH_FRINFC_MIFARESTD_FLAG1:
+                  PH_FRINFC_MIFARESTD_FLAG0); */
+      CRFlag = PH_FRINFC_MIFARESTD_FLAG1; /* Call Completion Routine */
+      Status = NFCSTATUS_FAILED;          /* Update Status Flag */
+    }
+  } else {
+    Status = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_DEVICE_REQUEST);
+    CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
+  }
+  /* Call Completion Routine if CR Flag is Set to 1 */
+  if (CRFlag == PH_FRINFC_MIFARESTD_FLAG1) {
+    phFriNfc_MifStd_H_Complete(NdefMap, Status);
+  }
+
+  return;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_RdABlock
+ *
+ * Description      This function is a Helper function for Mifare Std. It Reads
+ *                  a block from the card.
+ *
+ * Returns          This function return NFCSTATUS_PENDING in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_RdABlock(phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS status = NFCSTATUS_PENDING;
+
+  NdefMap->State = PH_FRINFC_NDEFMAP_STATE_READ;
+  NdefMap->PrevOperation = PH_FRINFC_NDEFMAP_READ_OPE;
+  NdefMap->MapCompletionInfo.CompletionRoutine = phFriNfc_MifareStdMap_Process;
+  NdefMap->MapCompletionInfo.Context = NdefMap;
+
+  if (NdefMap->ApduBuffIndex < (uint16_t)NdefMap->ApduBufferSize) {
+    if (NdefMap->StdMifareContainer.internalLength > PH_FRINFC_MIFARESTD_VAL0) {
+      status = phFriNfc_MifStd_H_ChkIntLen(NdefMap);
+    } /* internal Length Check */
+    else {
+      NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
+          NdefMap->StdMifareContainer.currentBlock;
+      NdefMap->SendLength = MIFARE_MAX_SEND_BUF_TO_READ;
+      *NdefMap->SendRecvLength = NdefMap->TempReceiveLength;
+
+      NdefMap->Cmd.MfCmd = phHal_eMifareRead;
+
+      /* Call the Overlapped HAL Transceive function */
+      status = phFriNfc_ExtnsTransceive(
+          NdefMap->pTransceiveInfo, NdefMap->Cmd, NdefMap->SendRecvBuf,
+          NdefMap->SendLength, NdefMap->SendRecvLength);
+    }
+  } else {
+    /* Check for the Card Size */
+    if ((((NdefMap->StdMifareContainer.NoOfNdefCompBlocks -
+           NdefMap->StdMifareContainer.NdefBlocks) *
+          PH_FRINFC_MIFARESTD_BYTES_READ) == 0) ||
+        (NdefMap->ApduBufferSize == NdefMap->ApduBuffIndex)) {
+      NdefMap->StdMifareContainer.ReadWriteCompleteFlag =
+          (uint8_t)((((NdefMap->StdMifareContainer.NoOfNdefCompBlocks -
+                       NdefMap->StdMifareContainer.NdefBlocks) *
+                      PH_FRINFC_MIFARESTD_BYTES_READ) == 0)
+                        ? PH_FRINFC_MIFARESTD_FLAG1
+                        : PH_FRINFC_MIFARESTD_FLAG0);
+      *NdefMap->NumOfBytesRead = NdefMap->ApduBuffIndex;
+      status = PHNFCSTVAL(CID_NFC_NONE, NFCSTATUS_SUCCESS);
+    } else {
+      /* Error: The control should not ideally come here. Return Error. */
+      status = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_FAILED);
+    }
+  }
+
+  return status;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_WrABlock
+ *
+ * Description      This function writes into a block of the card.
+ *
+ * Returns          This function return NFCSTATUS_PENDING in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_WrABlock(phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS status = NFCSTATUS_PENDING;
+
+  uint16_t RemainingBytes = 0, BytesRemained = 0, index = 0;
+  uint8_t Temp16Bytes = 0;
+
+  NdefMap->MapCompletionInfo.CompletionRoutine = phFriNfc_MifareStdMap_Process;
+  NdefMap->MapCompletionInfo.Context = NdefMap;
+  NdefMap->PrevOperation = PH_FRINFC_NDEFMAP_WRITE_OPE;
+
+  NdefMap->State = PH_FRINFC_NDEFMAP_STATE_WRITE;
+
+  /* User Buffer Check */
+  if (NdefMap->ApduBuffIndex < (uint16_t)NdefMap->ApduBufferSize) {
+    RemainingBytes =
+        (((uint16_t)(NdefMap->ApduBufferSize - NdefMap->ApduBuffIndex) <
+          NdefMap->StdMifareContainer.remainingSize)
+             ? (uint16_t)(NdefMap->ApduBufferSize - NdefMap->ApduBuffIndex)
+             : NdefMap->StdMifareContainer.remainingSize);
+
+    NdefMap->SendRecvBuf[0] = NdefMap->StdMifareContainer.currentBlock;
+    Temp16Bytes += PH_FRINFC_MIFARESTD_INC_1;
+
+    /* Check for internal bytes */
+    if (NdefMap->StdMifareContainer.internalLength > 0) {
+      /* copy the bytes previously written in the internal Buffer */
+      memcpy(&(NdefMap->SendRecvBuf[Temp16Bytes]),
+             NdefMap->StdMifareContainer.internalBuf,
+             NdefMap->StdMifareContainer.internalLength);
+
+      Temp16Bytes += (uint8_t)(NdefMap->StdMifareContainer.internalLength);
+      if (RemainingBytes >= (MIFARE_MAX_SEND_BUF_TO_WRITE - Temp16Bytes)) {
+        /* Copy the Remaining bytes from the user buffer to make the send
+            data and length = 16 */
+        memcpy(&(NdefMap->SendRecvBuf[Temp16Bytes]), NdefMap->ApduBuffer,
+               (MIFARE_MAX_SEND_BUF_TO_WRITE - Temp16Bytes));
+
+        NdefMap->NumOfBytesWritten =
+            (MIFARE_MAX_SEND_BUF_TO_WRITE - Temp16Bytes);
+        Temp16Bytes += (MIFARE_MAX_SEND_BUF_TO_WRITE - Temp16Bytes);
+        *NdefMap->DataCount = (Temp16Bytes - PH_FRINFC_MIFARESTD_VAL1);
+      } else {
+        memcpy(&(NdefMap->SendRecvBuf[Temp16Bytes]), NdefMap->ApduBuffer,
+               RemainingBytes);
+
+        NdefMap->StdMifareContainer.internalBufFlag = PH_FRINFC_MIFARESTD_FLAG1;
+        NdefMap->NumOfBytesWritten = RemainingBytes;
+        Temp16Bytes += (uint8_t)(RemainingBytes);
+        *NdefMap->DataCount = (Temp16Bytes - PH_FRINFC_MIFARESTD_VAL1);
+
+        BytesRemained = (MIFARE_MAX_SEND_BUF_TO_WRITE - Temp16Bytes);
+        /* Pad empty bytes with Zeroes to complete 16 bytes*/
+        for (index = 0; index < BytesRemained; index++) {
+          NdefMap->SendRecvBuf[(Temp16Bytes + index)] =
+              (uint8_t)((index == PH_FRINFC_MIFARESTD_VAL0)
+                            ? PH_FRINFC_MIFARESTD_TERMTLV_T
+                            : PH_FRINFC_MIFARESTD_NULLTLV_T);
+          NdefMap->TLVStruct.SetTermTLVFlag = PH_FRINFC_MIFARESTD_FLAG1;
+        }
+        Temp16Bytes += (uint8_t)(BytesRemained);
+      }
+    } else {
+      if (RemainingBytes >= (MIFARE_MAX_SEND_BUF_TO_WRITE - Temp16Bytes)) {
+        /* Bytes left to write < 16, copy remaining bytes */
+        memcpy(&(NdefMap->SendRecvBuf[Temp16Bytes]),
+               &(NdefMap->ApduBuffer[NdefMap->ApduBuffIndex]),
+               (MIFARE_MAX_SEND_BUF_TO_WRITE - Temp16Bytes));
+
+        NdefMap->NumOfBytesWritten =
+            (MIFARE_MAX_SEND_BUF_TO_WRITE - Temp16Bytes);
+        Temp16Bytes += (MIFARE_MAX_SEND_BUF_TO_WRITE - Temp16Bytes);
+        *NdefMap->DataCount = (Temp16Bytes - PH_FRINFC_MIFARESTD_VAL1);
+      } else {
+        /* Bytes left to write < 16, copy remaining bytes */
+        memcpy(&(NdefMap->SendRecvBuf[Temp16Bytes]),
+               &(NdefMap->ApduBuffer[NdefMap->ApduBuffIndex]), RemainingBytes);
+
+        NdefMap->StdMifareContainer.RemainingBufFlag =
+            PH_FRINFC_MIFARESTD_FLAG1;
+        NdefMap->NumOfBytesWritten = RemainingBytes;
+        Temp16Bytes += (uint8_t)(RemainingBytes);
+        *NdefMap->DataCount = (Temp16Bytes - PH_FRINFC_MIFARESTD_VAL1);
+
+        /* Pad empty bytes with Zeroes to complete 16 bytes */
+        for (index = Temp16Bytes; index < MIFARE_MAX_SEND_BUF_TO_WRITE;
+             index++) {
+          NdefMap->SendRecvBuf[index] =
+              (uint8_t)((index == Temp16Bytes) ? PH_FRINFC_MIFARESTD_TERMTLV_T
+                                               : PH_FRINFC_MIFARESTD_NULLTLV_T);
+
+          NdefMap->TLVStruct.SetTermTLVFlag = PH_FRINFC_MIFARESTD_FLAG1;
+        }
+      }
+    }
+    /* Buffer to store 16 bytes which is writing to the present block */
+    memcpy(NdefMap->StdMifareContainer.Buffer,
+           &(NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_INC_1]),
+           PH_FRINFC_MIFARESTD_BLOCK_BYTES);
+
+    /* Write from here */
+    NdefMap->SendLength = MIFARE_MAX_SEND_BUF_TO_WRITE;
+    NdefMap->Cmd.MfCmd = phHal_eMifareWrite16;
+    *NdefMap->SendRecvLength = NdefMap->TempReceiveLength;
+    /* Call the Overlapped HAL Transceive function */
+    status = phFriNfc_ExtnsTransceive(NdefMap->pTransceiveInfo, NdefMap->Cmd,
+                                      NdefMap->SendRecvBuf, NdefMap->SendLength,
+                                      NdefMap->SendRecvLength);
+  } else /* Check User Buffer */
+  {
+    if (NdefMap->StdMifareContainer.NdefBlocks >
+        NdefMap->StdMifareContainer.NoOfNdefCompBlocks) {
+      NdefMap->StdMifareContainer.ReadWriteCompleteFlag =
+          PH_FRINFC_MIFARESTD_FLAG1;
+      status = PHNFCSTVAL(CID_NFC_NONE, NFCSTATUS_SUCCESS);
+    } else if (NdefMap->ApduBuffIndex == (uint16_t)NdefMap->ApduBufferSize) {
+      status = PHNFCSTVAL(CID_NFC_NONE, NFCSTATUS_SUCCESS);
+    } else {
+      /* Error: The control should not ideally come here. Return Error. */
+      status = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_FAILED);
+    }
+  }
+
+  return status;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_AuthSector
+ *
+ * Description      This function authenticates one sector at a time.
+ *
+ * Returns          This function return NFCSTATUS_PENDING in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_AuthSector(phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS status = NFCSTATUS_PENDING;
+
+  NdefMap->MapCompletionInfo.CompletionRoutine = phFriNfc_MifareStdMap_Process;
+  NdefMap->MapCompletionInfo.Context = NdefMap;
+
+  *NdefMap->SendRecvLength = NdefMap->TempReceiveLength;
+  NdefMap->State = PH_FRINFC_NDEFMAP_STATE_AUTH;
+
+  /* Authenticate */
+  NdefMap->Cmd.MfCmd = phHal_eMifareAuthentA;
+
+  NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
+      ((NdefMap->TLVStruct.NdefTLVAuthFlag == PH_FRINFC_MIFARESTD_FLAG1)
+           ? NdefMap->TLVStruct.NdefTLVBlock
+           : NdefMap->StdMifareContainer.currentBlock);
+
+  /* if MAD blocks then authentication key is
+      0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5 else
+      0xD3, 0xF7, 0xD3, 0xF7, 0xD3, 0xF7 */
+  if (((NdefMap->StdMifareContainer.currentBlock !=
+        PH_FRINFC_MIFARESTD_MAD_BLK0) &&
+       (NdefMap->StdMifareContainer.currentBlock !=
+        PH_FRINFC_MIFARESTD_MAD_BLK1) &&
+       (NdefMap->StdMifareContainer.currentBlock !=
+        PH_FRINFC_MIFARESTD_MAD_BLK2) &&
+       (NdefMap->StdMifareContainer.currentBlock !=
+        PH_FRINFC_MIFARESTD_MAD_BLK64) &&
+       (NdefMap->StdMifareContainer.currentBlock !=
+        PH_FRINFC_MIFARESTD_MAD_BLK65) &&
+       (NdefMap->StdMifareContainer.currentBlock !=
+        PH_FRINFC_MIFARESTD_MAD_BLK66)) ||
+      (NdefMap->TLVStruct.NdefTLVAuthFlag ==
+       (uint8_t)PH_FRINFC_MIFARESTD_FLAG1)) {
+    NdefMap->SendRecvBuf[1] =
+        PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_NDEFSECT1; /* 0xD3 */
+    NdefMap->SendRecvBuf[2] =
+        PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_NDEFSECT2; /* 0xF7 */
+    NdefMap->SendRecvBuf[3] =
+        PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_NDEFSECT1; /* 0xD3 */
+    NdefMap->SendRecvBuf[4] =
+        PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_NDEFSECT2; /* 0xF7 */
+    NdefMap->SendRecvBuf[5] =
+        PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_NDEFSECT1; /* 0xD3 */
+    NdefMap->SendRecvBuf[6] =
+        PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_NDEFSECT2; /* 0xF7 */
+  } else {
+    NdefMap->SendRecvBuf[1] =
+        PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_MADSECT1; /* 0xA0 */
+    NdefMap->SendRecvBuf[2] =
+        PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_MADSECT2; /* 0xA1 */
+    NdefMap->SendRecvBuf[3] =
+        PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_MADSECT3; /* 0xA2 */
+    NdefMap->SendRecvBuf[4] =
+        PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_MADSECT4; /* 0xA3 */
+    NdefMap->SendRecvBuf[5] =
+        PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_MADSECT5; /* 0xA4 */
+    NdefMap->SendRecvBuf[6] =
+        PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_MADSECT6; /* 0xA5 */
+  }
+
+  if (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_1K_CARD ||
+      NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD ||
+      NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD) {
+    if (NdefMap->StdMifareContainer.ReadOnlySectorIndex &&
+        NdefMap->StdMifareContainer.SectorTrailerBlockNo ==
+            NdefMap->StdMifareContainer.currentBlock) {
+      memcpy(&NdefMap->SendRecvBuf[1],
+             &NdefMap->StdMifareContainer.UserScrtKeyB[0],
+             PH_FRINFC_MIFARESTD_KEY_LEN);
+
+      /* Authenticate with KeyB */
+      NdefMap->Cmd.MfCmd = phHal_eMifareAuthentB;
+    }
+  }
+
+  NdefMap->SendLength = MIFARE_AUTHENTICATE_CMD_LENGTH;
+  *NdefMap->SendRecvLength = NdefMap->TempReceiveLength;
+  /* Call the Overlapped HAL Transceive function */
+  status = phFriNfc_ExtnsTransceive(NdefMap->pTransceiveInfo, NdefMap->Cmd,
+                                    NdefMap->SendRecvBuf, NdefMap->SendLength,
+                                    NdefMap->SendRecvLength);
+
+  return status;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_Complete
+ *
+ * Description      It is used to call the Completion Routine
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void phFriNfc_MifStd_H_Complete(phFriNfc_NdefMap_t* NdefMap,
+                                       NFCSTATUS Result) {
+  /* set the state back to the Reset_Init state */
+  NdefMap->State = PH_FRINFC_NDEFMAP_STATE_RESET_INIT;
+
+  /* set the completion routine */
+  NdefMap->CompletionRoutine[NdefMap->StdMifareContainer.CRIndex]
+      .CompletionRoutine(NdefMap->CompletionRoutine->Context, Result);
+
+  return;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd4k_H_CheckNdef
+ *
+ * Description      This function is used for Mifare 4k Check Ndef to
+ *                  get the next AID blocks.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd4k_H_CheckNdef(phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+
+  /* Get the AID Block */
+  if (NdefMap->StdMifareContainer.currentBlock ==
+      PH_FRINFC_MIFARESTD_MAD_BLK2) {
+    NdefMap->StdMifareContainer.currentBlock = PH_FRINFC_MIFARESTD_MAD_BLK64;
+    NdefMap->StdMifareContainer.AuthDone = PH_FRINFC_MIFARESTD_FLAG0;
+  } else if (NdefMap->StdMifareContainer.currentBlock ==
+             PH_FRINFC_MIFARESTD_MAD_BLK64) {
+    NdefMap->StdMifareContainer.currentBlock = PH_FRINFC_MIFARESTD_MAD_BLK65;
+  } else {
+    NdefMap->StdMifareContainer.currentBlock = PH_FRINFC_MIFARESTD_MAD_BLK66;
+  }
+
+  Result = phFriNfc_MifareStdMap_ChkNdef(NdefMap);
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_fillAIDarray
+ *
+ * Description      This function storew the AIDs for check ndef.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void phFriNfc_MifStd_H_fillAIDarray(phFriNfc_NdefMap_t* NdefMap) {
+  uint8_t byteindex = 0;
+
+  if ((NdefMap->StdMifareContainer.currentBlock ==
+       PH_FRINFC_MIFARESTD_MAD_BLK1) ||
+      (NdefMap->StdMifareContainer.currentBlock ==
+       PH_FRINFC_MIFARESTD_MAD_BLK64)) {
+    /* The First Two Bytes in Receive Buffer
+        are CRC bytes so it is not copied
+        instead, 0 is copied in AID[0] & AID[1] */
+    NdefMap->StdMifareContainer.aid[NdefMap->StdMifareContainer.SectorIndex] =
+        PH_FRINFC_MIFARESTD_NON_NDEF_COMP;
+    NdefMap->StdMifareContainer.SectorIndex++;
+    byteindex = 2;
+  }
+
+  while (byteindex < PH_FRINFC_MIFARESTD_BYTES_READ) {
+    if ((NdefMap->SendRecvBuf[byteindex] ==
+         PH_FRINFC_NDEFMAP_MIFARESTD_NDEF_COMPVAL2) &&
+        (NdefMap->SendRecvBuf[(byteindex + 1)] ==
+         PH_FRINFC_NDEFMAP_MIFARESTD_NDEF_COMPVAL1)) {
+      /* This flag is set when a NFC forum sector is found in a
+          MAD block for the first time */
+      NdefMap->StdMifareContainer.NFCforumSectFlag = PH_FRINFC_MIFARESTD_FLAG1;
+      NdefMap->StdMifareContainer.aid[NdefMap->StdMifareContainer.SectorIndex] =
+          PH_FRINFC_MIFARESTD_NDEF_COMP;
+      NdefMap->StdMifareContainer.SectorIndex++;
+    } else {
+      NdefMap->StdMifareContainer.aid[NdefMap->StdMifareContainer.SectorIndex] =
+          PH_FRINFC_MIFARESTD_NON_NDEF_COMP;
+      NdefMap->StdMifareContainer.SectorIndex++;
+      /* AID complete flag is set when a non NFC forum sector is found in a
+         MAD block after the NFC forum sector. After setting this, all other
+         values are ignored and are NOT NDEF compliant */
+      NdefMap->StdMifareContainer.aidCompleteFlag =
+          ((NdefMap->StdMifareContainer.NFCforumSectFlag ==
+            PH_FRINFC_MIFARESTD_FLAG1)
+               ? PH_FRINFC_MIFARESTD_FLAG1
+               : PH_FRINFC_MIFARESTD_FLAG0);
+
+      NdefMap->StdMifareContainer.NFCforumSectFlag = PH_FRINFC_MIFARESTD_FLAG0;
+      if (NdefMap->StdMifareContainer.aidCompleteFlag ==
+          PH_FRINFC_MIFARESTD_FLAG1) {
+        break;
+      }
+    }
+    byteindex += 2;
+  }
+
+  /* If "aidCompleteFlag" is set then the remaining sectors are made NOT
+     NDEF compliant */
+  if ((NdefMap->StdMifareContainer.aidCompleteFlag ==
+       PH_FRINFC_MIFARESTD_FLAG1) &&
+      (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_1K_CARD)) {
+    /* for Mifare 1k there are 16 sectors, till this number all sectors
+       are made NOT NDEF compliant */
+    for (byteindex = NdefMap->StdMifareContainer.SectorIndex;
+         byteindex < PH_FRINFC_MIFARESTD1K_TOTAL_SECTOR; byteindex++) {
+      NdefMap->StdMifareContainer.aid[byteindex] =
+          PH_FRINFC_MIFARESTD_NON_NDEF_COMP;
+    }
+  } else if ((NdefMap->StdMifareContainer.aidCompleteFlag ==
+              PH_FRINFC_MIFARESTD_FLAG1) &&
+             (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD)) {
+    /* for Mifare 2k there are 32 sectors, till this number all sectors
+       are made NOT NDEF compliant */
+    for (byteindex = NdefMap->StdMifareContainer.SectorIndex;
+         byteindex < PH_FRINFC_MIFARESTD2K_TOTAL_SECTOR; byteindex++) {
+      NdefMap->StdMifareContainer.aid[byteindex] =
+          PH_FRINFC_MIFARESTD_NON_NDEF_COMP;
+    }
+  } else {
+    /* for Mifare 4k there are 40 sectors, till this number all sectors
+       are made NOT NDEF compliant */
+    if ((NdefMap->StdMifareContainer.aidCompleteFlag ==
+         PH_FRINFC_MIFARESTD_FLAG1) &&
+        (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD)) {
+      for (byteindex = NdefMap->StdMifareContainer.SectorIndex;
+           byteindex < PH_FRINFC_MIFARESTD4K_TOTAL_SECTOR; byteindex++) {
+        NdefMap->StdMifareContainer.aid[byteindex] =
+            PH_FRINFC_MIFARESTD_NON_NDEF_COMP;
+      }
+    }
+  }
+
+  return;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_BlkChk
+ *
+ * Description      This function is to check the Ndef compliance of the
+ *                  current block, if the block is not Ndef Compliant,
+ *                  increment the block till the next Ndef compliant block
+ *                  using the Get Sector Helper function
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_BlkChk(phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+  uint8_t SectorID = 0, callbreak = 0;
+
+  for (;;) {
+    /* Get a Sector ID for the Current Block */
+    SectorID =
+        phFriNfc_MifStd_H_GetSect(NdefMap->StdMifareContainer.currentBlock);
+    /* Check the card Type 1k or 4k */
+    /* enter if Mifare 1k card. For Mifare 4k go to else */
+    if (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_1K_CARD) {
+      /* if Sector Id > 15 No Sectors to write */
+      if (SectorID > 15) {
+        SectorID =
+            phFriNfc_MifStd_H_GetSect(NdefMap->StdMifareContainer.currentBlock);
+        /*Error: No Ndef Compliant Sectors present */
+        Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_PARAMETER);
+        callbreak = 1;
+      } else {
+        phFriNfc_MifStd1k_H_BlkChk(NdefMap, SectorID, &callbreak);
+      }
+    } /* End of if */ /* End of Mifare 1k check */
+    else if (NdefMap->CardType ==
+             PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD) /* Mifare 2k check starts
+                                                      here */
+    {
+      /* Sector > 39 no ndef compliant sectors found*/
+      if (SectorID > PH_FRINFC_MIFARESTD_SECTOR_NO31) {
+        /*Error: No Ndef Compliant Sectors present */
+        Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_PARAMETER);
+        callbreak = 1;
+      } else if (NdefMap->StdMifareContainer.currentBlock ==
+                 PH_FRINFC_MIFARESTD_MAD_BLK64) {
+        NdefMap->StdMifareContainer.currentBlock += PH_FRINFC_MIFARESTD_BLK4;
+      } else if (SectorID < PH_FRINFC_MIFARESTD_SECTOR_NO32) /* sector < 32
+                                                                contains 4
+                                                                blocks in each
+                                                                sector */
+      {
+        /* If the block checked is 63, the 3 blocks after this
+            are AID(MAD) blocks so its need to be skipped */
+        if (NdefMap->StdMifareContainer.currentBlock ==
+            PH_FRINFC_MIFARESTD_MAD_BLK63) {
+          NdefMap->StdMifareContainer.currentBlock += PH_FRINFC_MIFARESTD_BLK4;
+        } else {
+          phFriNfc_MifStd1k_H_BlkChk(NdefMap, SectorID, &callbreak);
+        }
+      } else {
+        phFriNfc_MifStd1k_H_BlkChk(NdefMap, SectorID, &callbreak);
+      }
+    } /* End of if*/ /* End of Mifare 2k check*/
+    else             /* Mifare 4k check starts here */
+    {
+      /* Sector > 39 no ndef compliant sectors found*/
+      if (SectorID > PH_FRINFC_MIFARESTD_SECTOR_NO39) {
+        /*Error: No Ndef Compliant Sectors present */
+        Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_PARAMETER);
+        callbreak = 1;
+      } else if (NdefMap->StdMifareContainer.currentBlock ==
+                 PH_FRINFC_MIFARESTD_MAD_BLK64) {
+        NdefMap->StdMifareContainer.currentBlock += PH_FRINFC_MIFARESTD_BLK4;
+      } else if (SectorID < PH_FRINFC_MIFARESTD_SECTOR_NO32) /* sector < 32
+                                                                contains 4
+                                                                blocks in each
+                                                                sector */
+      {
+        /* If the block checked is 63, the 3 blocks after this
+           are AID(MAD) blocks so its need to be skipped */
+        if (NdefMap->StdMifareContainer.currentBlock ==
+            PH_FRINFC_MIFARESTD_MAD_BLK63) {
+          NdefMap->StdMifareContainer.currentBlock += PH_FRINFC_MIFARESTD_BLK4;
+        } else {
+          phFriNfc_MifStd1k_H_BlkChk(NdefMap, SectorID, &callbreak);
+        }
+      } else {
+        /* every last block of a sector needs to be skipped */
+        if (((NdefMap->StdMifareContainer.currentBlock + 1) %
+             PH_FRINFC_MIFARESTD_BLOCK_BYTES) == 0) {
+          NdefMap->StdMifareContainer.currentBlock++;
+        } else {
+          if (NdefMap->StdMifareContainer.aid[SectorID] ==
+              PH_FRINFC_MIFARESTD_NDEF_COMP) {
+            /* Check whether the block is first block of a (next)new sector and
+                also check if it is first block then internal length is zero
+                or not. Because once Authentication is done for the sector again
+                we should not authenticate it again */
+            /* In this case 32 sectors contains 4 blocks and next remaining 8
+               sectors
+                contains 16 blocks that is why (32 * 4) + (sectorID - 32) *16*/
+            if ((NdefMap->StdMifareContainer.currentBlock ==
+                 ((PH_FRINFC_MIFARESTD_SECTOR_NO32 * PH_FRINFC_MIFARESTD_BLK4) +
+                  ((SectorID - PH_FRINFC_MIFARESTD_SECTOR_NO32) *
+                   PH_FRINFC_MIFARESTD_BLOCK_BYTES))) &&
+                (NdefMap->StdMifareContainer.internalLength == 0)) {
+              NdefMap->StdMifareContainer.AuthDone = 0;
+            }
+            callbreak = 1;
+          } else {
+            NdefMap->StdMifareContainer.currentBlock += 16;
+          }
+        }
+      }
+    }
+    if (callbreak == 1) {
+      break;
+    }
+  }
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_GetSect
+ *
+ * Description      This function  to get the Sector from the current block
+ *
+ * Returns          uint8_t SectorID
+ *
+ ******************************************************************************/
+static uint8_t phFriNfc_MifStd_H_GetSect(uint8_t BlockNumber) {
+  uint8_t SectorID = 0;
+
+  if (BlockNumber >= PH_FRINFC_MIFARESTD4K_BLK128) {
+    SectorID = (uint8_t)(PH_FRINFC_MIFARESTD_SECTOR_NO32 +
+                         ((BlockNumber - PH_FRINFC_MIFARESTD4K_BLK128) /
+                          PH_FRINFC_MIFARESTD_BLOCK_BYTES));
+  } else {
+    SectorID = (BlockNumber / PH_FRINFC_MIFARESTD_BLK4);
+  }
+
+  return SectorID;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_RdAcsBit
+ *
+ * Description      It read the access bits of each sector.
+ *                  NCI messages.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_RdAcsBit(phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+
+  NdefMap->State = PH_FRINFC_NDEFMAP_STATE_RD_ACS_BIT;
+
+  if (NdefMap->StdMifareContainer.ReadOnlySectorIndex &&
+      NdefMap->StdMifareContainer.currentBlock ==
+          NdefMap->StdMifareContainer.SectorTrailerBlockNo) {
+    NdefMap->State = PH_FRINFC_NDEFMAP_STATE_RD_SEC_ACS_BIT;
+  }
+
+  if (NdefMap->StdMifareContainer.ReadAcsBitFlag == PH_FRINFC_MIFARESTD_FLAG1) {
+    /* Get the sector trailer */
+    ((NdefMap->StdMifareContainer.currentBlock > 127)
+         ? phFriNfc_MifStd_H_Get4kStTrail(NdefMap)
+         : phFriNfc_MifStd_H_Get1kStTrail(NdefMap));
+  } else {
+    /* Give the current block to read */
+    NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
+        NdefMap->StdMifareContainer.currentBlock;
+  }
+
+  Result = phFriNfc_MifStd_H_Rd16Bytes(
+      NdefMap, NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0]);
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_ChkAcsBit
+ *
+ * Description      This function check the access bits of each sector.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_ChkAcsBit(phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+
+  /* Blocks from 0 to 3 and from 64 to 67(MAD blocks) */
+  if ((NdefMap->StdMifareContainer.currentBlock ==
+       PH_FRINFC_MIFARESTD_MAD_BLK0) ||
+      (NdefMap->StdMifareContainer.currentBlock ==
+       PH_FRINFC_MIFARESTD_MAD_BLK1) ||
+      (NdefMap->StdMifareContainer.currentBlock ==
+       PH_FRINFC_MIFARESTD_MAD_BLK2) ||
+      (NdefMap->StdMifareContainer.currentBlock ==
+       PH_FRINFC_MIFARESTD_MAD_BLK3) ||
+      (NdefMap->StdMifareContainer.currentBlock ==
+       PH_FRINFC_MIFARESTD_MAD_BLK64) ||
+      (NdefMap->StdMifareContainer.currentBlock ==
+       PH_FRINFC_MIFARESTD_MAD_BLK65) ||
+      (NdefMap->StdMifareContainer.currentBlock ==
+       PH_FRINFC_MIFARESTD_MAD_BLK66)) {
+/* Access bits check removed for the MAD blocks */
+#ifdef ENABLE_ACS_BIT_CHK_FOR_MAD
+
+    if (((NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL6] &
+          PH_FRINFC_MIFARESTD_MASK_FF) ==
+         PH_FRINFC_MIFARESTD_MADSECT_ACS_BYTE6) &&
+        ((NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL7] &
+          PH_FRINFC_MIFARESTD_MASK_FF) ==
+         PH_FRINFC_MIFARESTD_MADSECT_ACS_BYTE7) &&
+        ((NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL8] &
+          PH_FRINFC_MIFARESTD_MASK_FF) == PH_FRINFC_MIFARESTD_ACS_BYTE8)) {
+      NdefMap->StdMifareContainer.WriteFlag = PH_FRINFC_MIFARESTD_FLAG0;
+      NdefMap->StdMifareContainer.ReadFlag = PH_FRINFC_MIFARESTD_FLAG1;
+    } else {
+      NdefMap->StdMifareContainer.WriteFlag = PH_FRINFC_MIFARESTD_FLAG0;
+      NdefMap->StdMifareContainer.ReadFlag = PH_FRINFC_MIFARESTD_FLAG0;
+    }
+
+#else /* #ifdef ENABLE_ACS_BIT_CHK_FOR_MAD */
+
+    NdefMap->CardState = PH_NDEFMAP_CARD_STATE_INITIALIZED;
+
+#endif /* #ifdef ENABLE_ACS_BIT_CHK_FOR_MAD */
+  } else {
+    /* Check for Access bytes 6, 7 and 8 value =
+        0x7F, 0x07, 0x88 NFC forum sectors*/
+    if (((NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL6] &
+          PH_FRINFC_MIFARESTD_MASK_FF) ==
+         PH_FRINFC_MIFARESTD_NFCSECT_ACS_BYTE6) &&
+        ((NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL7] &
+          PH_FRINFC_MIFARESTD_MASK_FF) ==
+         PH_FRINFC_MIFARESTD_NFCSECT_ACS_BYTE7) &&
+        ((NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL8] &
+          PH_FRINFC_MIFARESTD_MASK_FF) == PH_FRINFC_MIFARESTD_ACS_BYTE8)) {
+      NdefMap->StdMifareContainer.WriteFlag = PH_FRINFC_MIFARESTD_FLAG1;
+      NdefMap->StdMifareContainer.ReadFlag = PH_FRINFC_MIFARESTD_FLAG1;
+    } else if (((NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL6] &
+                 PH_FRINFC_MIFARESTD_MASK_FF) ==
+                PH_FRINFC_MIFARESTD_NFCSECT_RDACS_BYTE6) &&
+               ((NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL7] &
+                 PH_FRINFC_MIFARESTD_MASK_FF) ==
+                PH_FRINFC_MIFARESTD_NFCSECT_RDACS_BYTE7) &&
+               ((NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL8] &
+                 PH_FRINFC_MIFARESTD_MASK_FF) ==
+                PH_FRINFC_MIFARESTD_NFCSECT_RDACS_BYTE8)) {
+      /* Read Only state */
+      /* Check for Access bytes 6, 7 and 8 value =
+          0x55, 0xAD, 0x2A NFC forum Sectors */
+      NdefMap->StdMifareContainer.WriteFlag = PH_FRINFC_MIFARESTD_FLAG0;
+      NdefMap->StdMifareContainer.ReadFlag = PH_FRINFC_MIFARESTD_FLAG1;
+    } else {
+      NdefMap->StdMifareContainer.WriteFlag = PH_FRINFC_MIFARESTD_FLAG0;
+      NdefMap->StdMifareContainer.ReadFlag = PH_FRINFC_MIFARESTD_FLAG0;
+    }
+
+#ifdef ENABLE_ACS_BIT_CHK_FOR_MAD
+/* Do nothing */
+#else  /* #ifdef ENABLE_ACS_BIT_CHK_FOR_MAD */
+    Result = phFriNfc_MifStd_H_GPBChk(NdefMap);
+#endif /* #ifdef ENABLE_ACS_BIT_CHK_FOR_MAD */
+  }
+
+#ifdef ENABLE_ACS_BIT_CHK_FOR_MAD
+  Result = phFriNfc_MifStd_H_GPBChk(NdefMap);
+#endif /* #ifdef ENABLE_ACS_BIT_CHK_FOR_MAD */
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_ChkRdWr
+ *
+ * Description      This function is for read access bits, depending
+ *                  on the read/write/check ndef function called.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_ChkRdWr(phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+
+  switch (NdefMap->PrevOperation) {
+    case PH_FRINFC_NDEFMAP_CHECK_OPE:
+      if (NdefMap->CardState == PH_NDEFMAP_CARD_STATE_INVALID) {
+        /* No permission to read */
+        Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_READ_FAILED);
+      } else if ((NdefMap->StdMifareContainer.currentBlock > 3) &&
+                 (NdefMap->StdMifareContainer.ChkNdefCompleteFlag ==
+                  PH_FRINFC_MIFARESTD_FLAG1) &&
+                 (NdefMap->StdMifareContainer.currentBlock !=
+                  PH_FRINFC_MIFARESTD_MAD_BLK65) &&
+                 (NdefMap->StdMifareContainer.currentBlock !=
+                  PH_FRINFC_MIFARESTD_MAD_BLK66)) {
+        /* NdefMap->StdMifareContainer.currentBlock =
+             ((NdefMap->StdMifareContainer.ReadCompleteFlag ==
+                 PH_FRINFC_MIFARESTD_FLAG1)?
+                 NdefMap->StdMifareContainer.currentBlock:
+                 (NdefMap->StdMifareContainer.currentBlock +
+                 PH_FRINFC_MIFARESTD_VAL4));
+         NdefMap->StdMifareContainer.currentBlock =
+             ((NdefMap->StdMifareContainer.currentBlock ==
+                 PH_FRINFC_MIFARESTD_MAD_BLK64)?
+             (NdefMap->StdMifareContainer.currentBlock +
+             PH_FRINFC_MIFARESTD_VAL4):
+             NdefMap->StdMifareContainer.currentBlock);*/
+
+        Result = ((NdefMap->StdMifareContainer.ReadAcsBitFlag ==
+                   PH_FRINFC_MIFARESTD_FLAG0)
+                      ? phFriNfc_MifStd_H_RdAcsBit(NdefMap)
+                      : phFriNfc_MifStd_H_AuthSector(NdefMap));
+      } else {
+        Result = phFriNfc_MifareStdMap_ChkNdef(NdefMap);
+      }
+      break;
+
+    case PH_FRINFC_NDEFMAP_READ_OPE:
+      if (NdefMap->CardState == PH_NDEFMAP_CARD_STATE_INVALID) {
+        /* No permission to Read */
+        Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_READ_FAILED);
+      } else if (NdefMap->StdMifareContainer.ReadNdefFlag ==
+                 PH_FRINFC_MIFARESTD_FLAG1) {
+        Result = phFriNfc_MifStd_H_GetActCardLen(NdefMap);
+      } else {
+        Result = phFriNfc_MifStd_H_RdABlock(NdefMap);
+      }
+      break;
+
+    case PH_FRINFC_NDEFMAP_WRITE_OPE:
+      if ((NdefMap->CardState == PH_NDEFMAP_CARD_STATE_INVALID) ||
+          (NdefMap->CardState == PH_NDEFMAP_CARD_STATE_READ_ONLY)) {
+        /* No permission to Read */
+        Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_WRITE_FAILED);
+      } else if (NdefMap->StdMifareContainer.WrNdefFlag ==
+                 PH_FRINFC_MIFARESTD_FLAG1) {
+        Result = phFriNfc_MifStd_H_GetActCardLen(NdefMap);
+      } else if (NdefMap->StdMifareContainer.RdBeforeWrFlag ==
+                 PH_FRINFC_MIFARESTD_FLAG1) {
+        /*NdefMap->StdMifareContainer.ReadFlag =
+                        PH_FRINFC_MIFARESTD_FLAG0;*/
+        Result = phFriNfc_MifStd_H_RdBeforeWr(NdefMap);
+      } else if (NdefMap->StdMifareContainer.RdAfterWrFlag ==
+                 PH_FRINFC_MIFARESTD_FLAG1) {
+        Result = phFriNfc_MifStd_H_RdtoWrNdefLen(NdefMap);
+      } else {
+        Result = (((NdefMap->TLVStruct.NdefTLVBlock ==
+                    NdefMap->StdMifareContainer.currentBlock) &&
+                   (NdefMap->Offset == PH_FRINFC_NDEFMAP_SEEK_BEGIN))
+                      ? phFriNfc_MifStd_H_RdBeforeWr(NdefMap)
+                      : phFriNfc_MifStd_H_WrABlock(NdefMap));
+      }
+      break;
+
+    case PH_FRINFC_NDEFMAP_GET_ACTSIZE_OPE:
+      Result =
+          ((NdefMap->StdMifareContainer.ReadFlag == PH_FRINFC_MIFARESTD_FLAG0)
+               ? (PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_READ_FAILED))
+               : phFriNfc_MifStd_H_GetActCardLen(NdefMap));
+      break;
+
+    default:
+      /* Operation is not correct */
+      Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_PARAMETER);
+
+      break;
+  }
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_ChkNdefCmpltSects
+ *
+ * Description      This function is used to check ndef to check the
+ *                  ndef compliant sectors.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void phFriNfc_MifStd_H_ChkNdefCmpltSects(phFriNfc_NdefMap_t* NdefMap) {
+  uint8_t index = 0;
+  uint8_t index_max_4k_2k = 0;
+  if (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD) {
+    index_max_4k_2k = PH_FRINFC_MIFARESTD4K_TOTAL_SECTOR;
+  } else {
+    index_max_4k_2k = PH_FRINFC_MIFARESTD2K_TOTAL_SECTOR;
+  }
+
+  if (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD ||
+      NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD) {
+    for (index = PH_FRINFC_MIFARESTD_SECTOR_NO1; index < index_max_4k_2k;
+         index++) /*Block 0 is MAD block, so it should start with 1*/
+    {
+      /* For Mifare 4k, Block 0 to 31 contains 4 blocks */
+      /* sector 0 and 15 are aid blocks */
+      if (index != PH_FRINFC_MIFARESTD_SECTOR_NO16) {
+        if (((index < 32) && (index != PH_FRINFC_MIFARESTD_SECTOR_NO0)) &&
+            (NdefMap->StdMifareContainer.aid[index] ==
+             PH_FRINFC_MIFARESTD_NON_NDEF_COMP)) {
+          /* Only 3 blocks can be read/written till sector 31 */
+          NdefMap->StdMifareContainer.NoOfNdefCompBlocks -=
+              PH_FRINFC_MIFARESTD_MAD_BLK3;
+
+        } else {
+          /* For Mifare 4k, Block 32 to 39 contains 16 blocks */
+          if (NdefMap->StdMifareContainer.aid[index] ==
+              PH_FRINFC_MIFARESTD_NON_NDEF_COMP) {
+            /* Only 15 blocks can be read/written from sector 31 */
+            NdefMap->StdMifareContainer.NoOfNdefCompBlocks -=
+                PH_FRINFC_MIFARESTD_BLK15;
+          }
+        }
+      }
+    } /* For index > 40 */
+  } else {
+    for (index = PH_FRINFC_MIFARESTD_SECTOR_NO1;
+         index < PH_FRINFC_MIFARESTD_SECTOR_NO16; index++) {
+      if (NdefMap->StdMifareContainer.aid[index] ==
+          PH_FRINFC_MIFARESTD_NON_NDEF_COMP) {
+        /*  Only three blocks can be read/written in
+            a sector. So if a sector is non-ndef
+            compliant, decrement 3 */
+        NdefMap->StdMifareContainer.NoOfNdefCompBlocks -=
+            PH_FRINFC_MIFARESTD_MAD_BLK3;
+      }
+    }
+  }
+
+  return;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_RemainTLV
+ *
+ * Description      This function is used for read ndef to process the
+ *                  remaining bytes of length (L) in the TLV.
+ *
+ * Returns          This function return NFCSTATUS_PENDING in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_RemainTLV(phFriNfc_NdefMap_t* NdefMap,
+                                             uint8_t* Flag,
+                                             uint8_t* Temp16Bytes) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+  uint8_t CRFlag = 0;
+  uint16_t RemainingBytes = 0;
+
+  RemainingBytes = ((uint16_t)NdefMap->ApduBufferSize - NdefMap->ApduBuffIndex);
+
+  if (NdefMap->StdMifareContainer.remainingSize < RemainingBytes) {
+    /* If the user Buffer is greater than the Card Size
+       set LastBlockFlag = 1. This Flag is used to read bytes
+       till the end of the card only */
+    RemainingBytes = NdefMap->StdMifareContainer.remainingSize;
+  }
+
+  /* Remaining Bytes of length (L) in TLV <=  16 */
+  if ((NdefMap->TLVStruct.BytesRemainLinTLV <=
+       (PH_FRINFC_MIFARESTD_BYTES_READ - (*Temp16Bytes))) &&
+      (RemainingBytes <= NdefMap->TLVStruct.BytesRemainLinTLV)) {
+    /* Copy data to user buffer */
+    memcpy(&(NdefMap->ApduBuffer[NdefMap->ApduBuffIndex]),
+           &(NdefMap->SendRecvBuf[(*Temp16Bytes)]), RemainingBytes);
+
+    NdefMap->ApduBuffIndex += RemainingBytes;
+    NdefMap->StdMifareContainer.remainingSize -= RemainingBytes;
+
+    /* copy the bytes to internal buffer, that are read,
+       but not used for the user buffer */
+    if (RemainingBytes != NdefMap->TLVStruct.BytesRemainLinTLV) {
+      memcpy(
+          NdefMap->StdMifareContainer.internalBuf,
+          &(NdefMap->SendRecvBuf[((*Temp16Bytes) + RemainingBytes)]),
+          ((PH_FRINFC_MIFARESTD_BYTES_READ - (*Temp16Bytes)) - RemainingBytes));
+
+      /* internal buffer length */
+      NdefMap->StdMifareContainer.internalLength =
+          ((PH_FRINFC_MIFARESTD_BYTES_READ - (*Temp16Bytes)) - RemainingBytes);
+    }
+    *Temp16Bytes += ((uint8_t)RemainingBytes);
+    /* Remaining Bytes of length value in TLV */
+    NdefMap->TLVStruct.BytesRemainLinTLV -= RemainingBytes;
+
+    if (NdefMap->StdMifareContainer.internalLength ==
+        PH_FRINFC_MIFARESTD_VAL0) {
+      NdefMap->StdMifareContainer.ReadWriteCompleteFlag = (uint8_t)(
+          ((NdefMap->StdMifareContainer.remainingSize ==
+            PH_FRINFC_MIFARESTD_VAL0) ||
+           (NdefMap->TLVStruct.BytesRemainLinTLV == PH_FRINFC_MIFARESTD_VAL0))
+              ? PH_FRINFC_MIFARESTD_FLAG1
+              : PH_FRINFC_MIFARESTD_FLAG0);
+
+      /* internal length bytes completed */
+      NdefMap->StdMifareContainer.currentBlock++;
+      NdefMap->StdMifareContainer.NdefBlocks++;
+    }
+
+    if (NdefMap->TLVStruct.BytesRemainLinTLV == PH_FRINFC_MIFARESTD_VAL0) {
+      /* Remaining Bytes of length (L) in TLV is Zero means that the next
+         coming bytes are containing type (T), length (L) in TLV */
+      NdefMap->TLVStruct.NdefTLVFoundFlag = PH_FRINFC_MIFARESTD_FLAG1;
+      NdefMap->TLVStruct.LcheckedinTLVFlag = PH_FRINFC_MIFARESTD_FLAG0;
+      NdefMap->TLVStruct.TcheckedinTLVFlag = PH_FRINFC_MIFARESTD_FLAG0;
+    }
+    /* call completion routine */
+    CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
+    *Flag = PH_FRINFC_MIFARESTD_FLAG0;
+  } else if ((NdefMap->TLVStruct.BytesRemainLinTLV <=
+              (PH_FRINFC_MIFARESTD_BYTES_READ - (*Temp16Bytes))) &&
+             (RemainingBytes > NdefMap->TLVStruct.BytesRemainLinTLV)) {
+    /* Copy data to user buffer */
+    memcpy(&(NdefMap->ApduBuffer[NdefMap->ApduBuffIndex]),
+           &(NdefMap->SendRecvBuf[(*Temp16Bytes)]),
+           NdefMap->TLVStruct.BytesRemainLinTLV);
+
+    NdefMap->ApduBuffIndex += NdefMap->TLVStruct.BytesRemainLinTLV;
+    NdefMap->StdMifareContainer.remainingSize -=
+        NdefMap->TLVStruct.BytesRemainLinTLV;
+    NdefMap->TLVStruct.NdefTLVFoundFlag = PH_FRINFC_MIFARESTD_FLAG1;
+    *Temp16Bytes += ((uint8_t)NdefMap->TLVStruct.BytesRemainLinTLV);
+    NdefMap->TLVStruct.BytesRemainLinTLV = PH_FRINFC_MIFARESTD_VAL0;
+
+    *Flag = PH_FRINFC_MIFARESTD_FLAG1;
+
+    NdefMap->TLVStruct.LcheckedinTLVFlag = PH_FRINFC_MIFARESTD_FLAG0;
+    NdefMap->TLVStruct.TcheckedinTLVFlag = PH_FRINFC_MIFARESTD_FLAG0;
+    /* 16 bytes completed */
+    if (NdefMap->TLVStruct.BytesRemainLinTLV ==
+        PH_FRINFC_MIFARESTD_BYTES_READ) {
+      *Flag = PH_FRINFC_MIFARESTD_FLAG0;
+      NdefMap->TLVStruct.BytesRemainLinTLV =
+          PH_FRINFC_MIFARESTD_NDEFTLV_LBYTES0;
+      NdefMap->StdMifareContainer.currentBlock++;
+      NdefMap->StdMifareContainer.NdefBlocks++;
+      Result = phFriNfc_MifStd_H_BlkChk(NdefMap);
+      if (Result == NFCSTATUS_SUCCESS) {
+        if (NdefMap->StdMifareContainer.AuthDone == PH_FRINFC_MIFARESTD_FLAG1) {
+          Result = phFriNfc_MifStd_H_RdABlock(NdefMap);
+        } else {
+          Result = phFriNfc_MifStd_H_AuthSector(NdefMap);
+        }
+      }
+    } else {
+      NdefMap->TLVStruct.BytesRemainLinTLV =
+          PH_FRINFC_MIFARESTD_NDEFTLV_LBYTES0;
+      /* The read operation has finished. so, completion routine
+         can be called. set the Completion routine(CR) flag */
+      CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
+    }
+  } else if ((NdefMap->TLVStruct.BytesRemainLinTLV >
+              (PH_FRINFC_MIFARESTD_BYTES_READ - (*Temp16Bytes))) &&
+             (RemainingBytes <=
+              (PH_FRINFC_MIFARESTD_BYTES_READ - (*Temp16Bytes)))) {
+    /* Copy data to user buffer */
+    memcpy(&(NdefMap->ApduBuffer[NdefMap->ApduBuffIndex]),
+           &(NdefMap->SendRecvBuf[(*Temp16Bytes)]), RemainingBytes);
+    NdefMap->ApduBuffIndex += RemainingBytes;
+    NdefMap->StdMifareContainer.remainingSize -= RemainingBytes;
+
+    /* Remaining Bytes of length (L) in TLV */
+    NdefMap->TLVStruct.BytesRemainLinTLV -= RemainingBytes;
+    /* copy the bytes to internal buffer, that are read,
+                    but not used for the user buffer */
+    memcpy(
+        NdefMap->StdMifareContainer.internalBuf,
+        &(NdefMap->SendRecvBuf[(RemainingBytes + (*Temp16Bytes))]),
+        ((PH_FRINFC_MIFARESTD_BYTES_READ - (*Temp16Bytes)) - RemainingBytes));
+
+    /* internal buffer length */
+    NdefMap->StdMifareContainer.internalLength =
+        ((PH_FRINFC_MIFARESTD_BYTES_READ - (*Temp16Bytes)) - RemainingBytes);
+
+    if (RemainingBytes == (PH_FRINFC_MIFARESTD_BYTES_READ - (*Temp16Bytes))) {
+      NdefMap->StdMifareContainer.ReadWriteCompleteFlag = (uint8_t)(
+          ((NdefMap->StdMifareContainer.remainingSize ==
+            PH_FRINFC_MIFARESTD_VAL0) ||
+           (NdefMap->TLVStruct.BytesRemainLinTLV == PH_FRINFC_MIFARESTD_VAL0))
+              ? PH_FRINFC_MIFARESTD_FLAG1
+              : PH_FRINFC_MIFARESTD_FLAG0);
+
+      /* internal length bytes completed */
+      NdefMap->StdMifareContainer.currentBlock++;
+      NdefMap->StdMifareContainer.NdefBlocks++;
+    }
+    *Temp16Bytes += ((uint8_t)RemainingBytes);
+    NdefMap->TLVStruct.NdefTLVFoundFlag = PH_FRINFC_MIFARESTD_FLAG0;
+    CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
+    *Flag = PH_FRINFC_MIFARESTD_FLAG0;
+  } else {
+    if ((NdefMap->TLVStruct.BytesRemainLinTLV >
+         (PH_FRINFC_MIFARESTD_BYTES_READ - (*Temp16Bytes))) &&
+        (RemainingBytes > (PH_FRINFC_MIFARESTD_BYTES_READ - (*Temp16Bytes)))) {
+      *Flag = PH_FRINFC_MIFARESTD_FLAG0;
+      /* Copy data to user buffer */
+      memcpy(&(NdefMap->ApduBuffer[NdefMap->ApduBuffIndex]),
+             &(NdefMap->SendRecvBuf[(*Temp16Bytes)]),
+             (PH_FRINFC_MIFARESTD_BYTES_READ - (*Temp16Bytes)));
+      NdefMap->ApduBuffIndex +=
+          (PH_FRINFC_MIFARESTD_BYTES_READ - (*Temp16Bytes));
+      NdefMap->StdMifareContainer.remainingSize -=
+          (PH_FRINFC_MIFARESTD_BYTES_READ - (*Temp16Bytes));
+      NdefMap->TLVStruct.BytesRemainLinTLV -=
+          (PH_FRINFC_MIFARESTD_BYTES_READ - (*Temp16Bytes));
+      *Temp16Bytes += (PH_FRINFC_MIFARESTD_BYTES_READ - (*Temp16Bytes));
+      if (NdefMap->TLVStruct.BytesRemainLinTLV !=
+          PH_FRINFC_MIFARESTD_NDEFTLV_LBYTES0) {
+        NdefMap->TLVStruct.NdefTLVFoundFlag = PH_FRINFC_MIFARESTD_FLAG0;
+      }
+      /* 16 bytes completed */
+      NdefMap->StdMifareContainer.currentBlock++;
+      NdefMap->StdMifareContainer.NdefBlocks++;
+      Result = phFriNfc_MifStd_H_BlkChk(NdefMap);
+      if (Result == NFCSTATUS_SUCCESS) {
+        Result =
+            ((NdefMap->StdMifareContainer.AuthDone == PH_FRINFC_MIFARESTD_FLAG1)
+                 ? phFriNfc_MifStd_H_RdABlock(NdefMap)
+                 : phFriNfc_MifStd_H_AuthSector(NdefMap));
+      }
+    }
+  }
+
+  if (CRFlag == PH_FRINFC_MIFARESTD_FLAG1) {
+    *NdefMap->NumOfBytesRead = NdefMap->ApduBuffIndex;
+    NdefMap->StdMifareContainer.ReadWriteCompleteFlag = (uint8_t)(
+        ((NdefMap->StdMifareContainer.remainingSize ==
+          PH_FRINFC_MIFARESTD_VAL0) ||
+         (NdefMap->TLVStruct.BytesRemainLinTLV == PH_FRINFC_MIFARESTD_VAL0))
+            ? PH_FRINFC_MIFARESTD_FLAG1
+            : PH_FRINFC_MIFARESTD_FLAG0);
+  }
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_ChkIntLen
+ *
+ * Description      This function reads ndef to process the internal bytes.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success,
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_ChkIntLen(phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+  uint8_t NDEFFlag = PH_FRINFC_MIFARESTD_FLAG1;
+  uint8_t TempintBytes = 0;
+
+  if (NdefMap->TLVStruct.BytesRemainLinTLV != 0) {
+    NDEFFlag = PH_FRINFC_MIFARESTD_FLAG0;
+    /* To read the remaining length (L) in TLV */
+    Result =
+        phFriNfc_MifStd_H_IntLenWioutNdef(NdefMap, &NDEFFlag, &TempintBytes);
+  }
+  NDEFFlag = PH_FRINFC_MIFARESTD_FLAG0;
+  /* check the NDEFFlag is set. if this is not set, then
+     in the above RemainTLV function all the 16 bytes has been
+     read */
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_IntLenWioutNdef
+ *
+ * Description      This function reads ndef to check the internal bytes
+ *                  without ndef tlv flag.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success,
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_IntLenWioutNdef(phFriNfc_NdefMap_t* NdefMap,
+                                                   uint8_t* Flag,
+                                                   uint8_t* TempintBytes) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+  uint8_t CRFlag = 0;
+  uint16_t RemainingBytes = 0;
+
+  RemainingBytes = ((uint16_t)NdefMap->ApduBufferSize - NdefMap->ApduBuffIndex);
+
+  if (NdefMap->StdMifareContainer.remainingSize < RemainingBytes) {
+    /* If the user Buffer is greater than the Card Size
+       set LastBlockFlag = 1. This Flag is used to read bytes
+       till the end of the card only */
+    RemainingBytes = NdefMap->StdMifareContainer.remainingSize;
+  }
+
+  /* Remaining Bytes of length (L) in TLV <=  internal length */
+  if ((NdefMap->TLVStruct.BytesRemainLinTLV <=
+       NdefMap->StdMifareContainer.internalLength) &&
+      (RemainingBytes <= NdefMap->TLVStruct.BytesRemainLinTLV)) {
+    memcpy(&(NdefMap->ApduBuffer[NdefMap->ApduBuffIndex]),
+           &(NdefMap->StdMifareContainer.internalBuf[(*TempintBytes)]),
+           RemainingBytes);
+    NdefMap->ApduBuffIndex += RemainingBytes;
+    NdefMap->StdMifareContainer.remainingSize -= RemainingBytes;
+    *TempintBytes += ((uint8_t)RemainingBytes);
+
+    /* copy the bytes to internal buffer, that are read,
+       but not used for the user buffer */
+    memcpy(NdefMap->StdMifareContainer.internalBuf,
+           &(NdefMap->StdMifareContainer.internalBuf[RemainingBytes]),
+           (NdefMap->StdMifareContainer.internalLength - RemainingBytes));
+
+    /* internal buffer length */
+    NdefMap->StdMifareContainer.internalLength -= RemainingBytes;
+
+    NdefMap->TLVStruct.BytesRemainLinTLV -= RemainingBytes;
+    if (NdefMap->StdMifareContainer.internalLength ==
+        PH_FRINFC_MIFARESTD_VAL0) {
+      NdefMap->StdMifareContainer.ReadWriteCompleteFlag = (uint8_t)(
+          ((NdefMap->StdMifareContainer.remainingSize ==
+            PH_FRINFC_MIFARESTD_VAL0) ||
+           (NdefMap->TLVStruct.BytesRemainLinTLV == PH_FRINFC_MIFARESTD_VAL0))
+              ? PH_FRINFC_MIFARESTD_FLAG1
+              : PH_FRINFC_MIFARESTD_FLAG0);
+
+      /* internal length bytes completed */
+      NdefMap->StdMifareContainer.currentBlock++;
+      NdefMap->StdMifareContainer.NdefBlocks++;
+    }
+
+    /* Remaining Bytes of length value in TLV */
+    if (NdefMap->TLVStruct.BytesRemainLinTLV == 0) {
+      /* Remaining Bytes of length (L) in TLV is Zero means that the next
+       coming bytes are containing type (T), length (L) in TLV */
+      NdefMap->TLVStruct.NdefTLVFoundFlag = PH_FRINFC_MIFARESTD_FLAG1;
+      NdefMap->TLVStruct.LcheckedinTLVFlag = PH_FRINFC_MIFARESTD_FLAG0;
+      NdefMap->TLVStruct.TcheckedinTLVFlag = PH_FRINFC_MIFARESTD_FLAG0;
+    }
+    /* call completion routine */
+    CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
+    *Flag = PH_FRINFC_MIFARESTD_FLAG0;
+  } else if ((NdefMap->TLVStruct.BytesRemainLinTLV <=
+              NdefMap->StdMifareContainer.internalLength) &&
+             (RemainingBytes > NdefMap->TLVStruct.BytesRemainLinTLV)) {
+    memcpy(&(NdefMap->ApduBuffer[NdefMap->ApduBuffIndex]),
+           &(NdefMap->StdMifareContainer.internalBuf[(*TempintBytes)]),
+           NdefMap->TLVStruct.BytesRemainLinTLV);
+
+    NdefMap->ApduBuffIndex += NdefMap->TLVStruct.BytesRemainLinTLV;
+    NdefMap->StdMifareContainer.remainingSize -=
+        NdefMap->TLVStruct.BytesRemainLinTLV;
+    NdefMap->TLVStruct.NdefTLVFoundFlag = PH_FRINFC_MIFARESTD_FLAG1;
+
+    *TempintBytes += ((uint8_t)NdefMap->TLVStruct.BytesRemainLinTLV);
+    *Flag = PH_FRINFC_MIFARESTD_FLAG1;
+
+    NdefMap->TLVStruct.LcheckedinTLVFlag = PH_FRINFC_MIFARESTD_FLAG0;
+    NdefMap->TLVStruct.TcheckedinTLVFlag = PH_FRINFC_MIFARESTD_FLAG0;
+
+    NdefMap->TLVStruct.BytesRemainLinTLV = PH_FRINFC_MIFARESTD_VAL0;
+    NdefMap->StdMifareContainer.ReadWriteCompleteFlag = (uint8_t)(
+        ((NdefMap->StdMifareContainer.remainingSize ==
+          PH_FRINFC_MIFARESTD_VAL0) ||
+         (NdefMap->TLVStruct.BytesRemainLinTLV == PH_FRINFC_MIFARESTD_VAL0))
+            ? PH_FRINFC_MIFARESTD_FLAG1
+            : PH_FRINFC_MIFARESTD_FLAG0);
+
+    if (PH_FRINFC_MIFARESTD_FLAG1 ==
+        NdefMap->StdMifareContainer.ReadWriteCompleteFlag) {
+      CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
+    }
+
+    if (NdefMap->TLVStruct.BytesRemainLinTLV ==
+        NdefMap->StdMifareContainer.internalLength) {
+      /* Remaining Bytes in Length (L) field of TLV is 0 */
+      NdefMap->TLVStruct.BytesRemainLinTLV =
+          PH_FRINFC_MIFARESTD_NDEFTLV_LBYTES0;
+      NdefMap->StdMifareContainer.internalLength = PH_FRINFC_MIFARESTD_VAL0;
+      *Flag = PH_FRINFC_MIFARESTD_FLAG0;
+      /* internal length bytes completed */
+      NdefMap->StdMifareContainer.currentBlock++;
+      NdefMap->StdMifareContainer.NdefBlocks++;
+      Result = phFriNfc_MifStd_H_BlkChk(NdefMap);
+      if (Result == NFCSTATUS_SUCCESS) {
+        Result =
+            ((NdefMap->StdMifareContainer.AuthDone == PH_FRINFC_MIFARESTD_FLAG1)
+                 ? phFriNfc_MifStd_H_RdABlock(NdefMap)
+                 : phFriNfc_MifStd_H_AuthSector(NdefMap));
+      }
+    } else {
+      /* Remaining Bytes in Length (L) field of TLV is 0 */
+      NdefMap->TLVStruct.BytesRemainLinTLV =
+          PH_FRINFC_MIFARESTD_NDEFTLV_LBYTES0;
+      *Flag = PH_FRINFC_MIFARESTD_FLAG1;
+    }
+  } else if ((NdefMap->TLVStruct.BytesRemainLinTLV >
+              NdefMap->StdMifareContainer.internalLength) &&
+             (RemainingBytes <= NdefMap->StdMifareContainer.internalLength)) {
+    memcpy(&(NdefMap->ApduBuffer[NdefMap->ApduBuffIndex]),
+           &(NdefMap->StdMifareContainer.internalBuf[(*TempintBytes)]),
+           RemainingBytes);
+
+    NdefMap->ApduBuffIndex += RemainingBytes;
+    NdefMap->StdMifareContainer.remainingSize -= RemainingBytes;
+    *TempintBytes += ((uint8_t)RemainingBytes);
+    /* Remaining Bytes of length (L) in TLV */
+    NdefMap->TLVStruct.BytesRemainLinTLV -= RemainingBytes;
+
+    /* copy the bytes to internal buffer, that are read,
+                    but not used for the user buffer */
+    memcpy(NdefMap->StdMifareContainer.internalBuf,
+           &(NdefMap->StdMifareContainer.internalBuf[RemainingBytes]),
+           (NdefMap->StdMifareContainer.internalLength - RemainingBytes));
+
+    /* internal buffer length */
+    NdefMap->StdMifareContainer.internalLength -= RemainingBytes;
+    if (NdefMap->StdMifareContainer.internalLength ==
+        PH_FRINFC_MIFARESTD_VAL0) {
+      NdefMap->StdMifareContainer.ReadWriteCompleteFlag = (uint8_t)(
+          ((NdefMap->StdMifareContainer.remainingSize ==
+            PH_FRINFC_MIFARESTD_VAL0) ||
+           (NdefMap->TLVStruct.BytesRemainLinTLV == PH_FRINFC_MIFARESTD_VAL0))
+              ? PH_FRINFC_MIFARESTD_FLAG1
+              : PH_FRINFC_MIFARESTD_FLAG0);
+
+      /* internal length bytes completed */
+      NdefMap->StdMifareContainer.currentBlock++;
+      NdefMap->StdMifareContainer.NdefBlocks++;
+    }
+
+    NdefMap->TLVStruct.NdefTLVFoundFlag = PH_FRINFC_MIFARESTD_FLAG0;
+    CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
+    *Flag = PH_FRINFC_MIFARESTD_FLAG0;
+  } else {
+    if ((NdefMap->TLVStruct.BytesRemainLinTLV >
+         NdefMap->StdMifareContainer.internalLength) &&
+        (RemainingBytes > NdefMap->StdMifareContainer.internalLength)) {
+      memcpy(&(NdefMap->ApduBuffer[NdefMap->ApduBuffIndex]),
+             &(NdefMap->StdMifareContainer.internalBuf[(*TempintBytes)]),
+             NdefMap->StdMifareContainer.internalLength);
+      *Flag = PH_FRINFC_MIFARESTD_FLAG0;
+      NdefMap->ApduBuffIndex += NdefMap->StdMifareContainer.internalLength;
+      NdefMap->StdMifareContainer.remainingSize -=
+          NdefMap->StdMifareContainer.internalLength;
+      NdefMap->TLVStruct.BytesRemainLinTLV -=
+          NdefMap->StdMifareContainer.internalLength;
+
+      if (NdefMap->TLVStruct.BytesRemainLinTLV !=
+          PH_FRINFC_MIFARESTD_NDEFTLV_LBYTES0) {
+        NdefMap->TLVStruct.NdefTLVFoundFlag = PH_FRINFC_MIFARESTD_FLAG0;
+      }
+
+      NdefMap->StdMifareContainer.internalLength = PH_FRINFC_MIFARESTD_VAL0;
+      /* internal length bytes completed */
+      NdefMap->StdMifareContainer.currentBlock++;
+      NdefMap->StdMifareContainer.NdefBlocks++;
+      Result = phFriNfc_MifStd_H_BlkChk(NdefMap);
+      if (Result == NFCSTATUS_SUCCESS) {
+        Result =
+            ((NdefMap->StdMifareContainer.AuthDone == PH_FRINFC_MIFARESTD_FLAG1)
+                 ? phFriNfc_MifStd_H_RdABlock(NdefMap)
+                 : phFriNfc_MifStd_H_AuthSector(NdefMap));
+      }
+    }
+  }
+
+  if (CRFlag == PH_FRINFC_MIFARESTD_FLAG1) {
+    NdefMap->StdMifareContainer.ReadWriteCompleteFlag = (uint8_t)(
+        ((NdefMap->StdMifareContainer.remainingSize ==
+          PH_FRINFC_MIFARESTD_VAL0) ||
+         (NdefMap->TLVStruct.BytesRemainLinTLV == PH_FRINFC_MIFARESTD_VAL0))
+            ? PH_FRINFC_MIFARESTD_FLAG1
+            : PH_FRINFC_MIFARESTD_FLAG0);
+    *NdefMap->NumOfBytesRead = NdefMap->ApduBuffIndex;
+  }
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_WriteNdefLen
+ *
+ * Description      This function is Helper function for write ndef
+ *                  to write the Length TLV.
+ *
+ * Returns          This function return NFCSTATUS_PENDING in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_WriteNdefLen(phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+  NdefMap->State = PH_FRINFC_NDEFMAP_STATE_WR_NDEF_LEN;
+
+  /* If Current block = Ndef TLV block then the starting point
+     is writing from type of TLV
+     Else */
+
+  if (NdefMap->StdMifareContainer.currentBlock ==
+      NdefMap->TLVStruct.NdefTLVBlock) {
+    if (NdefMap->TLVStruct.NULLTLVCount >= PH_FRINFC_MIFARESTD_VAL2) {
+      phFriNfc_MifStd_H_fillTLV1(NdefMap);
+    } else {
+      phFriNfc_MifStd_H_fillTLV2(NdefMap);
+    }
+  } else {
+    if (NdefMap->TLVStruct.NULLTLVCount >= PH_FRINFC_MIFARESTD_VAL2) {
+      phFriNfc_MifStd_H_fillTLV1_1(NdefMap);
+    } else {
+      phFriNfc_MifStd_H_fillTLV2_1(NdefMap);
+    }
+  }
+
+  memcpy(NdefMap->StdMifareContainer.Buffer,
+         &(NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL1]),
+         PH_FRINFC_MIFARESTD_BYTES_READ);
+
+  /* Write from here */
+  NdefMap->SendLength = MIFARE_MAX_SEND_BUF_TO_WRITE;
+
+  NdefMap->Cmd.MfCmd = phHal_eMifareWrite16;
+
+  *NdefMap->SendRecvLength = NdefMap->TempReceiveLength;
+  /* Call the Overlapped HAL Transceive function */
+  Result = phFriNfc_ExtnsTransceive(NdefMap->pTransceiveInfo, NdefMap->Cmd,
+                                    NdefMap->SendRecvBuf, NdefMap->SendLength,
+                                    NdefMap->SendRecvLength);
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_RdWrReset
+ *
+ * Description      It resets ndef TLV values. This is used when the offset
+ *                  is BEGIN.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void phFriNfc_MifStd_H_RdWrReset(phFriNfc_NdefMap_t* NdefMap) {
+  NdefMap->StdMifareContainer.currentBlock = PH_FRINFC_MIFARESTD_BLK4;
+  NdefMap->StdMifareContainer.NdefBlocks = PH_FRINFC_MIFARESTD_VAL1;
+  NdefMap->TLVStruct.BytesRemainLinTLV = PH_FRINFC_MIFARESTD_VAL0;
+  NdefMap->TLVStruct.LcheckedinTLVFlag = PH_FRINFC_MIFARESTD_FLAG0;
+  NdefMap->TLVStruct.TcheckedinTLVFlag = PH_FRINFC_MIFARESTD_FLAG0;
+  NdefMap->TLVStruct.NdefTLVAuthFlag = PH_FRINFC_MIFARESTD_FLAG0;
+  NdefMap->TLVStruct.NdefTLVBlock = PH_FRINFC_MIFARESTD_MAD_BLK0;
+  NdefMap->TLVStruct.NdefTLVByte = PH_FRINFC_MIFARESTD_VAL0;
+  NdefMap->TLVStruct.NoLbytesinTLV = PH_FRINFC_MIFARESTD_VAL0;
+  NdefMap->TLVStruct.NULLTLVCount = PH_FRINFC_MIFARESTD_VAL0;
+  NdefMap->StdMifareContainer.internalLength = PH_FRINFC_MIFARESTD_VAL0;
+  NdefMap->StdMifareContainer.AuthDone = PH_FRINFC_MIFARESTD_FLAG0;
+  NdefMap->StdMifareContainer.NFCforumSectFlag = PH_FRINFC_MIFARESTD_FLAG0;
+  NdefMap->StdMifareContainer.FirstReadFlag = PH_FRINFC_MIFARESTD_FLAG1;
+  NdefMap->StdMifareContainer.ReadWriteCompleteFlag = PH_FRINFC_MIFARESTD_FLAG0;
+  NdefMap->StdMifareContainer.remainingSize =
+      (uint16_t)(NdefMap->StdMifareContainer.NoOfNdefCompBlocks *
+                 PH_FRINFC_MIFARESTD_BLOCK_BYTES);
+  NdefMap->StdMifareContainer.WrLength = PH_FRINFC_MIFARESTD_VAL1;
+
+  return;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_RdtoWrNdefLen
+ *
+ * Description      This function is used to read the first ndef compliant
+ *                  block to change the length.
+ *
+ * Returns          This function return NFCSTATUS_PENDING in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_RdtoWrNdefLen(phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+
+  NdefMap->State = PH_FRINFC_NDEFMAP_STATE_RD_TO_WR_NDEF_LEN;
+
+  if (NdefMap->TLVStruct.NdefTLVAuthFlag == PH_FRINFC_MIFARESTD_FLAG1) {
+    NdefMap->StdMifareContainer.AuthDone = PH_FRINFC_MIFARESTD_FLAG0;
+    Result = phFriNfc_MifStd_H_AuthSector(NdefMap);
+  } else {
+    NdefMap->SendRecvBuf[0] = NdefMap->StdMifareContainer.currentBlock;
+    NdefMap->SendLength = MIFARE_MAX_SEND_BUF_TO_READ;
+    *NdefMap->SendRecvLength = NdefMap->TempReceiveLength;
+
+    NdefMap->Cmd.MfCmd = phHal_eMifareRead;
+
+    /* Call the Overlapped HAL Transceive function */
+    Result = phFriNfc_ExtnsTransceive(NdefMap->pTransceiveInfo, NdefMap->Cmd,
+                                      NdefMap->SendRecvBuf, NdefMap->SendLength,
+                                      NdefMap->SendRecvLength);
+  }
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_SetNdefBlkAuth
+ *
+ * Description      This function is used to set the authentication flag
+ *                  for the ndef TLV block.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void phFriNfc_MifStd_H_SetNdefBlkAuth(phFriNfc_NdefMap_t* NdefMap) {
+  NdefMap->TLVStruct.NdefTLVAuthFlag =
+      ((phFriNfc_MifStd_H_GetSect(NdefMap->TLVStruct.NdefTLVBlock) ==
+        phFriNfc_MifStd_H_GetSect(NdefMap->StdMifareContainer.currentBlock))
+           ? PH_FRINFC_MIFARESTD_FLAG0
+           : PH_FRINFC_MIFARESTD_FLAG1);
+
+  return;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_GetActCardLen
+ *
+ * Description      Helper function to get the actual length of card.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_GetActCardLen(phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+
+  NdefMap->State = PH_FRINFC_NDEFMAP_STATE_GET_ACT_CARDSIZE;
+  NdefMap->PrevOperation = PH_FRINFC_NDEFMAP_GET_ACTSIZE_OPE;
+
+  Result = ((NdefMap->StdMifareContainer.AuthDone == PH_FRINFC_MIFARESTD_FLAG0)
+                ? phFriNfc_MifStd_H_AuthSector(NdefMap)
+                : phFriNfc_MifStd_H_Rd16Bytes(
+                      NdefMap, NdefMap->StdMifareContainer.currentBlock));
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_ChkTLVs
+ *
+ * Description      Helper function to check all the TLVs.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_ChkTLVs(phFriNfc_NdefMap_t* NdefMap,
+                                           uint8_t* CRFlag) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+  uint16_t TempLength = PH_FRINFC_MIFARESTD_VAL0,
+           ShiftLength = PH_FRINFC_MIFARESTD_VAL0;
+  uint8_t TL4bytesFlag = PH_FRINFC_MIFARESTD_FLAG0;
+
+  NdefMap->PrevOperation = PH_FRINFC_NDEFMAP_GET_ACTSIZE_OPE;
+  TempLength = NdefMap->TLVStruct.NdefTLVByte;
+
+  for (;;) {
+    if ((NdefMap->SendRecvBuf[TempLength] != PH_FRINFC_MIFARESTD_TERMTLV_T) &&
+        (NdefMap->SendRecvBuf[TempLength] != PH_FRINFC_MIFARESTD_NULLTLV_T) &&
+        (NdefMap->SendRecvBuf[TempLength] != PH_FRINFC_MIFARESTD_NDEFTLV_T) &&
+        (false == NdefMap->TLVStruct.NdefTLVFoundFlag)) {
+      Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_NO_NDEF_SUPPORT);
+      NdefMap->TLVStruct.BytesRemainLinTLV = 0;
+      NdefMap->CardState = PH_NDEFMAP_CARD_STATE_INVALID;
+      *CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
+      break;
+
+    } else if ((NdefMap->SendRecvBuf[TempLength] !=
+                PH_FRINFC_MIFARESTD_TERMTLV_T) &&
+               (NdefMap->SendRecvBuf[TempLength] !=
+                PH_FRINFC_MIFARESTD_NULLTLV_T)) {
+      if (NdefMap->SendRecvBuf[TempLength] == PH_FRINFC_MIFARESTD_NDEFTLV_T) {
+        NdefMap->TLVStruct.NdefTLVBlock =
+            NdefMap->StdMifareContainer.currentBlock;
+        NdefMap->TLVStruct.NdefTLVByte = (uint8_t)TempLength;
+        NdefMap->TLVStruct.NdefTLVFoundFlag =
+            ((NdefMap->SendRecvBuf[TempLength] == PH_FRINFC_MIFARESTD_NDEFTLV_T)
+                 ? PH_FRINFC_MIFARESTD_FLAG1
+                 : PH_FRINFC_MIFARESTD_FLAG0);
+
+        NdefMap->TLVStruct.NULLTLVCount =
+            ((NdefMap->TLVStruct.NULLTLVCount == PH_FRINFC_MIFARESTD_VAL1)
+                 ? PH_FRINFC_MIFARESTD_VAL0
+                 : NdefMap->TLVStruct.NULLTLVCount);
+      } else {
+        NdefMap->TLVStruct.NULLTLVCount = PH_FRINFC_MIFARESTD_VAL0;
+      }
+
+      TempLength++;
+      if (TempLength == PH_FRINFC_MIFARESTD_BYTES_READ) {
+        NdefMap->TLVStruct.TcheckedinTLVFlag = PH_FRINFC_MIFARESTD_FLAG1;
+        NdefMap->TLVStruct.NoLbytesinTLV = PH_FRINFC_MIFARESTD_VAL3;
+      }
+      Result = phFriNfc_MifStd_H_Chk16Bytes(NdefMap, TempLength);
+      if (Result != NFCSTATUS_SUCCESS) {
+        *CRFlag = (uint8_t)((Result == NFCSTATUS_PENDING)
+                                ? PH_FRINFC_MIFARESTD_FLAG0
+                                : PH_FRINFC_MIFARESTD_FLAG1);
+        break;
+      }
+
+      if (((((NdefMap->StdMifareContainer.NoOfNdefCompBlocks -
+              NdefMap->StdMifareContainer.NdefBlocks) *
+             PH_FRINFC_MIFARESTD_BLOCK_BYTES) +
+            (PH_FRINFC_MIFARESTD_BLOCK_BYTES - TempLength)) <
+           NdefMap->SendRecvBuf[TempLength]) &&
+          ((NdefMap->SendRecvBuf[TempLength] < PH_FRINFC_MIFARESTD_NDEFTLV_L) &&
+           (NdefMap->TLVStruct.NdefTLVFoundFlag != PH_FRINFC_MIFARESTD_VAL1))) {
+        /* Result = Error */
+        Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_PARAMETER);
+        *CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
+        break;
+      }
+
+      if (((((NdefMap->StdMifareContainer.NoOfNdefCompBlocks -
+              NdefMap->StdMifareContainer.NdefBlocks) *
+             PH_FRINFC_MIFARESTD_BLOCK_BYTES) +
+            (PH_FRINFC_MIFARESTD_BLOCK_BYTES - TempLength)) <
+           NdefMap->SendRecvBuf[TempLength]) &&
+          ((NdefMap->SendRecvBuf[TempLength] == PH_FRINFC_MIFARESTD_VAL0) &&
+           (NdefMap->TLVStruct.NdefTLVFoundFlag == PH_FRINFC_MIFARESTD_VAL1))) {
+        /* Result = Error */
+        Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_PARAMETER);
+        *CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
+        break;
+      }
+
+      if ((NdefMap->TLVStruct.NdefTLVFoundFlag == PH_FRINFC_MIFARESTD_FLAG1) &&
+          (NdefMap->SendRecvBuf[TempLength] < PH_FRINFC_MIFARESTD_NDEFTLV_L)) {
+        Result = phFriNfc_MapTool_SetCardState(
+            NdefMap, NdefMap->SendRecvBuf[TempLength]);
+        NdefMap->TLVStruct.BytesRemainLinTLV = NdefMap->SendRecvBuf[TempLength];
+        NdefMap->StdMifareContainer.remainingSize -= PH_FRINFC_MIFARESTD_VAL2;
+        /* This flag is set */
+        NdefMap->StdMifareContainer.remSizeUpdFlag = (uint8_t)(
+            (NdefMap->TLVStruct.NULLTLVCount >= PH_FRINFC_MIFARESTD_VAL2)
+                ? PH_FRINFC_MIFARESTD_FLAG0
+                : PH_FRINFC_MIFARESTD_FLAG1);
+
+        *CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
+        break;
+      }
+
+      NdefMap->StdMifareContainer.remainingSize -=
+          ((NdefMap->SendRecvBuf[TempLength] < PH_FRINFC_MIFARESTD_NDEFTLV_L)
+               ? (NdefMap->SendRecvBuf[TempLength] + PH_FRINFC_MIFARESTD_VAL2)
+               : PH_FRINFC_MIFARESTD_VAL0);
+
+      if (NdefMap->SendRecvBuf[TempLength] == PH_FRINFC_MIFARESTD_VAL0) {
+        Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_PARAMETER);
+        *CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
+        break;
+      }
+
+      TL4bytesFlag = PH_FRINFC_MIFARESTD_FLAG0;
+      /* get the next TLV after the proprietary TLV */
+      Result =
+          ((NdefMap->SendRecvBuf[TempLength] < PH_FRINFC_MIFARESTD_NDEFTLV_L)
+               ? phFriNfc_MifStd_H_GetNxtTLV(NdefMap, &TempLength,
+                                             &TL4bytesFlag)
+               : NFCSTATUS_PENDING);
+
+      if ((TempLength >= PH_FRINFC_MIFARESTD_BYTES_READ) &&
+          (Result == NFCSTATUS_SUCCESS)) {
+        NdefMap->TLVStruct.TcheckedinTLVFlag = PH_FRINFC_MIFARESTD_FLAG0;
+        NdefMap->TLVStruct.NoLbytesinTLV = PH_FRINFC_MIFARESTD_VAL0;
+
+        Result = phFriNfc_MifStd_H_GetActCardLen(NdefMap);
+        *CRFlag = (uint8_t)((Result != NFCSTATUS_PENDING)
+                                ? PH_FRINFC_MIFARESTD_FLAG1
+                                : PH_FRINFC_MIFARESTD_FLAG0);
+        break;
+      } else {
+        if (Result == NFCSTATUS_PENDING) {
+          TL4bytesFlag = PH_FRINFC_MIFARESTD_FLAG1;
+          Result = ((NdefMap->SendRecvBuf[TempLength] ==
+                     PH_FRINFC_MIFARESTD_NDEFTLV_L)
+                        ? NFCSTATUS_SUCCESS
+                        : (PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP,
+                                      NFCSTATUS_INVALID_PARAMETER)));
+
+          if (Result != NFCSTATUS_SUCCESS) {
+            *CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
+            break;
+          }
+          NdefMap->TLVStruct.NULLTLVCount = PH_FRINFC_MIFARESTD_VAL0;
+          TempLength++;
+          /* Check 0xFF */
+          if (TempLength == PH_FRINFC_MIFARESTD_BYTES_READ) {
+            NdefMap->TLVStruct.TcheckedinTLVFlag = PH_FRINFC_MIFARESTD_FLAG1;
+            NdefMap->TLVStruct.NoLbytesinTLV = PH_FRINFC_MIFARESTD_VAL2;
+          }
+          Result = phFriNfc_MifStd_H_Chk16Bytes(NdefMap, TempLength);
+          if (Result != NFCSTATUS_SUCCESS) {
+            break;
+          }
+
+          ShiftLength = NdefMap->SendRecvBuf[TempLength];
+          TempLength++;
+          if (TempLength == PH_FRINFC_MIFARESTD_BYTES_READ) {
+            NdefMap->TLVStruct.TcheckedinTLVFlag = PH_FRINFC_MIFARESTD_FLAG1;
+            NdefMap->TLVStruct.NoLbytesinTLV = PH_FRINFC_MIFARESTD_VAL1;
+            NdefMap->TLVStruct.prevLenByteValue =
+                NdefMap->SendRecvBuf[(TempLength - PH_FRINFC_MIFARESTD_VAL1)];
+          }
+          Result = phFriNfc_MifStd_H_Chk16Bytes(NdefMap, TempLength);
+          if (Result != NFCSTATUS_SUCCESS) {
+            break;
+          }
+
+          if ((((NdefMap->StdMifareContainer.NoOfNdefCompBlocks -
+                 NdefMap->StdMifareContainer.NdefBlocks) *
+                PH_FRINFC_MIFARESTD_BLOCK_BYTES) +
+               (PH_FRINFC_MIFARESTD_BLOCK_BYTES - TempLength)) <
+              ((ShiftLength << 8) + NdefMap->SendRecvBuf[TempLength])) {
+            Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP,
+                                NFCSTATUS_INVALID_REMOTE_DEVICE);
+
+            break;
+          }
+
+          if (NdefMap->TLVStruct.NdefTLVFoundFlag ==
+              PH_FRINFC_MIFARESTD_FLAG1) {
+            ShiftLength =
+                ((ShiftLength << 8) + NdefMap->SendRecvBuf[TempLength]);
+            NdefMap->TLVStruct.BytesRemainLinTLV = ShiftLength;
+            Result = phFriNfc_MapTool_SetCardState(NdefMap, ShiftLength);
+            NdefMap->StdMifareContainer.remainingSize -=
+                PH_FRINFC_MIFARESTD_VAL4;
+            *CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
+            break;
+          }
+
+          NdefMap->StdMifareContainer.remainingSize -=
+              ((ShiftLength << 8) +
+               NdefMap->SendRecvBuf[(TempLength + PH_FRINFC_MIFARESTD_VAL1)]);
+          TempLength++;
+
+          /* get the next TLV after the proprietary TLV */
+          Result =
+              phFriNfc_MifStd_H_GetNxtTLV(NdefMap, &TempLength, &TL4bytesFlag);
+
+          if ((TempLength >= PH_FRINFC_MIFARESTD_BYTES_READ) &&
+              (Result == NFCSTATUS_SUCCESS)) {
+            NdefMap->TLVStruct.TcheckedinTLVFlag = PH_FRINFC_MIFARESTD_FLAG0;
+            NdefMap->TLVStruct.NoLbytesinTLV = PH_FRINFC_MIFARESTD_VAL0;
+            Result = phFriNfc_MifStd_H_GetActCardLen(NdefMap);
+
+            break;
+          }
+          break;
+        }
+      }
+    } else if ((NdefMap->SendRecvBuf[TempLength] ==
+                PH_FRINFC_MIFARESTD_TERMTLV_T) &&
+               (NdefMap->TLVStruct.NdefTLVFoundFlag ==
+                PH_FRINFC_MIFARESTD_FLAG0)) {
+      Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_PARAMETER);
+      NdefMap->StdMifareContainer.ReadWriteCompleteFlag =
+          PH_FRINFC_MIFARESTD_FLAG1;
+      break;
+
+    } else if (NdefMap->SendRecvBuf[TempLength] ==
+               PH_FRINFC_MIFARESTD_NULLTLV_T) {
+      TempLength++;
+      NdefMap->TLVStruct.NULLTLVCount += PH_FRINFC_MIFARESTD_VAL1;
+      ShiftLength =
+          NdefMap->SendRecvBuf[(TempLength - PH_FRINFC_MIFARESTD_VAL1)];
+      NdefMap->StdMifareContainer.remainingSize -= PH_FRINFC_MIFARESTD_VAL1;
+      if (NdefMap->StdMifareContainer.remainingSize <
+          ((ShiftLength << 8) + NdefMap->SendRecvBuf[TempLength])) {
+        Result =
+            PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_REMOTE_DEVICE);
+        break;
+      }
+      Result = phFriNfc_MifStd_H_Chk16Bytes(NdefMap, TempLength);
+      if (Result != NFCSTATUS_SUCCESS) {
+        NdefMap->TLVStruct.NdefTLVByte = PH_FRINFC_MIFARESTD_VAL0;
+        break;
+      }
+    } else {
+      if ((NdefMap->SendRecvBuf[TempLength] == PH_FRINFC_MIFARESTD_TERMTLV_T) &&
+          (NdefMap->TLVStruct.NdefTLVFoundFlag == PH_FRINFC_MIFARESTD_FLAG1)) {
+        TempLength++;
+        Result = NFCSTATUS_SUCCESS;
+        NdefMap->StdMifareContainer.remainingSize -= PH_FRINFC_MIFARESTD_VAL1;
+      }
+    }
+  }
+
+  if (NdefMap->TLVStruct.BytesRemainLinTLV >
+      NdefMap->StdMifareContainer.remainingSize) {
+    Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_FORMAT);
+  } else {
+    if (NdefMap->StdMifareContainer.remainingSize == PH_FRINFC_MIFARESTD_VAL0) {
+      Result =
+          ((NdefMap->TLVStruct.NdefTLVFoundFlag == PH_FRINFC_MIFARESTD_FLAG1)
+               ? NFCSTATUS_SUCCESS
+               : (PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP,
+                             NFCSTATUS_INVALID_PARAMETER)));
+    }
+  }
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_GetNxtTLV
+ *
+ * Description      This is a Helper function to get the next TLV.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_GetNxtTLV(phFriNfc_NdefMap_t* NdefMap,
+                                             uint16_t* TempLength,
+                                             uint8_t* TL4bytesFlag) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+  uint16_t LengthRemaining = PH_FRINFC_MIFARESTD_VAL0,
+           TempLen = PH_FRINFC_MIFARESTD_VAL0,
+           ShiftLength = PH_FRINFC_MIFARESTD_VAL0;
+
+  TempLen = (*TempLength);
+  LengthRemaining =
+      (PH_FRINFC_MIFARESTD_BYTES_READ - (TempLen + PH_FRINFC_MIFARESTD_VAL1));
+
+  if (*TL4bytesFlag == PH_FRINFC_MIFARESTD_FLAG0) {
+    (*TempLength) += (NdefMap->SendRecvBuf[TempLen] + PH_FRINFC_MIFARESTD_VAL1);
+
+    if (NdefMap->TLVStruct.NdefTLVFoundFlag == PH_FRINFC_MIFARESTD_FLAG0) {
+      LengthRemaining =
+          (((*TempLength) < PH_FRINFC_MIFARESTD_BYTES_READ)
+               ? PH_FRINFC_MIFARESTD_VAL0
+               : (NdefMap->SendRecvBuf[TempLen] - LengthRemaining));
+    } else {
+      LengthRemaining =
+          (((*TempLength) < PH_FRINFC_MIFARESTD_BYTES_READ)
+               ? PH_FRINFC_MIFARESTD_VAL0
+               : (NdefMap->SendRecvBuf[TempLen] - LengthRemaining));
+    }
+  } else {
+    *TL4bytesFlag = PH_FRINFC_MIFARESTD_FLAG0;
+    if (NdefMap->TLVStruct.NoLbytesinTLV == PH_FRINFC_MIFARESTD_VAL1) {
+      ShiftLength = NdefMap->TLVStruct.prevLenByteValue;
+      (*TempLength) += ((ShiftLength << 8) + NdefMap->SendRecvBuf[TempLen] +
+                        PH_FRINFC_MIFARESTD_VAL1);
+
+      LengthRemaining = (((ShiftLength << 8) + NdefMap->SendRecvBuf[TempLen]) -
+                         LengthRemaining);
+    } else {
+      ShiftLength = NdefMap->SendRecvBuf[(TempLen - PH_FRINFC_MIFARESTD_VAL1)];
+      (*TempLength) += ((ShiftLength << 8) + NdefMap->SendRecvBuf[TempLen] +
+                        PH_FRINFC_MIFARESTD_VAL1);
+
+      LengthRemaining = (((ShiftLength << 8) + NdefMap->SendRecvBuf[TempLen]) -
+                         LengthRemaining);
+    }
+  }
+
+  NdefMap->TLVStruct.NdefTLVByte =
+      (uint8_t)(((*TempLength) < PH_FRINFC_MIFARESTD_BYTES_READ)
+                    ? (*TempLength)
+                    : (LengthRemaining % PH_FRINFC_MIFARESTD_BYTES_READ));
+
+  while (LengthRemaining != PH_FRINFC_MIFARESTD_VAL0) {
+    NdefMap->StdMifareContainer.currentBlock++;
+    NdefMap->StdMifareContainer.NdefBlocks++;
+    Result = phFriNfc_MifStd_H_BlkChk(NdefMap);
+    LengthRemaining -= ((LengthRemaining <= PH_FRINFC_MIFARESTD_BYTES_READ)
+                            ? LengthRemaining
+                            : PH_FRINFC_MIFARESTD_BYTES_READ);
+  }
+
+  if (NdefMap->TLVStruct.NdefTLVByte == PH_FRINFC_MIFARESTD_VAL0) {
+    NdefMap->StdMifareContainer.currentBlock++;
+    NdefMap->StdMifareContainer.NdefBlocks++;
+    Result = phFriNfc_MifStd_H_BlkChk(NdefMap);
+  }
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_Chk16Bytes
+ *
+ * Description      This Helper function is used to know whether the read
+ *                  16 bytes are parsed completely.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_Chk16Bytes(phFriNfc_NdefMap_t* NdefMap,
+                                              uint16_t TempLength) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+
+  if (TempLength == PH_FRINFC_MIFARESTD_BYTES_READ) {
+    NdefMap->StdMifareContainer.currentBlock++;
+    NdefMap->StdMifareContainer.NdefBlocks++;
+    Result = phFriNfc_MifStd_H_BlkChk(NdefMap);
+
+    Result =
+        ((NdefMap->StdMifareContainer.AuthDone == PH_FRINFC_MIFARESTD_FLAG1)
+             ? phFriNfc_MifStd_H_GetActCardLen(NdefMap)
+             : phFriNfc_MifStd_H_AuthSector(NdefMap));
+  }
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_ChkRemainTLVs
+ *
+ * Description      This function is used to know whether the read
+ *                  16 bytes are parsed completely.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_ChkRemainTLVs(phFriNfc_NdefMap_t* NdefMap,
+                                                 uint8_t* CRFlag,
+                                                 uint8_t* NDEFFlag) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+  uint16_t TempLength = PH_FRINFC_MIFARESTD_VAL0,
+           ShiftLength = PH_FRINFC_MIFARESTD_VAL0;
+  uint8_t TL4bytesFlag = PH_FRINFC_MIFARESTD_FLAG0;
+
+  switch (NdefMap->TLVStruct.NoLbytesinTLV) {
+    case PH_FRINFC_MIFARESTD_VAL3:
+      /* if TLV is found then set card state */
+      Result =
+          ((NdefMap->TLVStruct.NdefTLVFoundFlag == PH_FRINFC_MIFARESTD_FLAG1)
+               ? phFriNfc_MapTool_SetCardState(NdefMap,
+                                               NdefMap->SendRecvBuf[TempLength])
+               : Result);
+
+      Result =
+          ((NdefMap->TLVStruct.NdefTLVFoundFlag == PH_FRINFC_MIFARESTD_FLAG1)
+               ? 1
+               : Result);
+
+      /* Check the length field is less than or
+         equal to 0xFF if yes enter below statement
+         else enter else if*/
+      if ((NdefMap->SendRecvBuf[TempLength] < PH_FRINFC_MIFARESTD_NDEFTLV_L) &&
+          (Result == NFCSTATUS_SUCCESS)) {
+        NdefMap->StdMifareContainer.remainingSize -= PH_FRINFC_MIFARESTD_VAL2;
+
+        Result =
+            ((NdefMap->SendRecvBuf[TempLength] >
+              NdefMap->StdMifareContainer.remainingSize)
+                 ? (PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_FORMAT))
+                 : Result);
+        TL4bytesFlag = PH_FRINFC_MIFARESTD_FLAG0;
+        if ((NdefMap->TLVStruct.NdefTLVFoundFlag ==
+             PH_FRINFC_MIFARESTD_FLAG1) &&
+            (Result == NFCSTATUS_SUCCESS)) {
+          NdefMap->TLVStruct.BytesRemainLinTLV =
+              NdefMap->SendRecvBuf[TempLength];
+          *CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
+
+        } else if (Result == NFCSTATUS_SUCCESS) {
+          TempLength++;
+          Result =
+              phFriNfc_MifStd_H_GetNxtTLV(NdefMap, &TempLength, &TL4bytesFlag);
+
+          NdefMap->StdMifareContainer.remainingSize -=
+              NdefMap->SendRecvBuf[TempLength];
+          if ((TempLength >= PH_FRINFC_MIFARESTD_BYTES_READ) &&
+              (*CRFlag == PH_FRINFC_MIFARESTD_FLAG0)) {
+            *NDEFFlag = PH_FRINFC_MIFARESTD_FLAG0;
+            Result = phFriNfc_MifStd_H_GetActCardLen(NdefMap);
+          }
+        }
+
+        else {
+          /* do nothing */
+        }
+      } else if ((NdefMap->SendRecvBuf[TempLength] ==
+                  PH_FRINFC_MIFARESTD_NDEFTLV_L) &&
+                 (Result == NFCSTATUS_SUCCESS)) {
+        TempLength++;
+        NdefMap->StdMifareContainer.remainingSize -= PH_FRINFC_MIFARESTD_VAL4;
+        TL4bytesFlag = PH_FRINFC_MIFARESTD_FLAG0;
+        Result =
+            (((((uint16_t)NdefMap->SendRecvBuf[TempLength] << 8) +
+               NdefMap->SendRecvBuf[(TempLength + PH_FRINFC_MIFARESTD_VAL1)]) >
+              NdefMap->StdMifareContainer.remainingSize)
+                 ? (PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_FORMAT))
+                 : Result);
+        if ((NdefMap->TLVStruct.NdefTLVFoundFlag ==
+             PH_FRINFC_MIFARESTD_FLAG1) &&
+            (Result == NFCSTATUS_SUCCESS)) {
+          NdefMap->TLVStruct.NULLTLVCount = PH_FRINFC_MIFARESTD_VAL0;
+          NdefMap->TLVStruct.BytesRemainLinTLV =
+              (((uint16_t)NdefMap->SendRecvBuf[TempLength] << 8) +
+               NdefMap->SendRecvBuf[(TempLength + PH_FRINFC_MIFARESTD_VAL1)]);
+          *CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
+        } else if (Result == NFCSTATUS_SUCCESS) {
+          TempLength++;
+
+          Result =
+              phFriNfc_MifStd_H_GetNxtTLV(NdefMap, &TempLength, &TL4bytesFlag);
+          NdefMap->StdMifareContainer.remainingSize -=
+              (((uint16_t)NdefMap->SendRecvBuf[TempLength] << 8) +
+               NdefMap->SendRecvBuf[(TempLength + PH_FRINFC_MIFARESTD_VAL1)]);
+
+          *NDEFFlag = PH_FRINFC_MIFARESTD_FLAG0;
+          Result = phFriNfc_MifStd_H_GetActCardLen(NdefMap);
+        } else {
+          /* do nothing */
+          *CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
+        }
+      } else {
+        /* Result = Error */
+        Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_FORMAT);
+        *CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
+      }
+      break;
+
+    case PH_FRINFC_MIFARESTD_VAL2:
+    case PH_FRINFC_MIFARESTD_VAL1:
+      ShiftLength =
+          ((NdefMap->TLVStruct.NoLbytesinTLV == PH_FRINFC_MIFARESTD_VAL1)
+               ? ((NdefMap->TLVStruct.prevLenByteValue << 8) +
+                  NdefMap->SendRecvBuf[TempLength])
+               : (((uint16_t)NdefMap->SendRecvBuf[TempLength] << 8) +
+                  NdefMap
+                      ->SendRecvBuf[(TempLength + PH_FRINFC_MIFARESTD_VAL1)]));
+      if ((((NdefMap->StdMifareContainer.NoOfNdefCompBlocks -
+             NdefMap->StdMifareContainer.NdefBlocks) *
+            PH_FRINFC_MIFARESTD_BLOCK_BYTES) +
+           (PH_FRINFC_MIFARESTD_BLOCK_BYTES - TempLength)) < ShiftLength) {
+        /* Result = Error */
+        Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_PARAMETER);
+        *CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
+      } else {
+        NdefMap->StdMifareContainer.remainingSize -= PH_FRINFC_MIFARESTD_VAL2;
+        if (NdefMap->TLVStruct.NdefTLVFoundFlag == PH_FRINFC_MIFARESTD_FLAG1) {
+          NdefMap->TLVStruct.BytesRemainLinTLV = ShiftLength;
+          if (NdefMap->TLVStruct.BytesRemainLinTLV >
+              NdefMap->StdMifareContainer.remainingSize) {
+            Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_FORMAT);
+          }
+          *CRFlag = PH_FRINFC_MIFARESTD_FLAG1;
+          *NDEFFlag = PH_FRINFC_MIFARESTD_FLAG0;
+        } else {
+          NdefMap->StdMifareContainer.remainingSize -= ShiftLength;
+          *CRFlag = PH_FRINFC_MIFARESTD_FLAG0;
+          TempLength += PH_FRINFC_MIFARESTD_VAL2;
+          TL4bytesFlag = PH_FRINFC_MIFARESTD_FLAG1;
+          Result = ((NdefMap->TLVStruct.NdefTLVFoundFlag ==
+                     PH_FRINFC_MIFARESTD_FLAG1)
+                        ? NFCSTATUS_SUCCESS
+                        : phFriNfc_MifStd_H_GetNxtTLV(NdefMap, &TempLength,
+                                                      &TL4bytesFlag));
+
+          *NDEFFlag = PH_FRINFC_MIFARESTD_FLAG0;
+          Result = phFriNfc_MifStd_H_GetActCardLen(NdefMap);
+        }
+      }
+      break;
+
+    default:
+      break;
+  }
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_Get1kStTrail
+ *
+ * Description      This function is used to get the Mifare 1k Sector Trailer.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void phFriNfc_MifStd_H_Get1kStTrail(phFriNfc_NdefMap_t* NdefMap) {
+  switch ((NdefMap->StdMifareContainer.currentBlock % 4)) {
+    case PH_FRINFC_MIFARESTD_VAL0:
+      NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
+          (NdefMap->StdMifareContainer.currentBlock +
+           PH_FRINFC_MIFARESTD_MAD_BLK3);
+      break;
+
+    case PH_FRINFC_MIFARESTD_VAL1:
+      NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
+          (NdefMap->StdMifareContainer.currentBlock +
+           PH_FRINFC_MIFARESTD_MAD_BLK2);
+      break;
+
+    case PH_FRINFC_MIFARESTD_VAL2:
+      NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
+          (NdefMap->StdMifareContainer.currentBlock +
+           PH_FRINFC_MIFARESTD_MAD_BLK1);
+      break;
+
+    default:
+      NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
+          NdefMap->StdMifareContainer.currentBlock;
+      break;
+  }
+
+  return;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_Get4kStTrail
+ *
+ * Description      This function gets the Mifare 4k Sector Trailer.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void phFriNfc_MifStd_H_Get4kStTrail(phFriNfc_NdefMap_t* NdefMap) {
+  switch ((NdefMap->StdMifareContainer.currentBlock % 16)) {
+    case PH_FRINFC_MIFARESTD_MAD_BLK0:
+      NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
+          (NdefMap->StdMifareContainer.currentBlock +
+           PH_FRINFC_MIFARESTD_BLK15);
+      break;
+
+    case PH_FRINFC_MIFARESTD_MAD_BLK1:
+      NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
+          (NdefMap->StdMifareContainer.currentBlock +
+           PH_FRINFC_MIFARESTD_BLK14);
+      break;
+
+    case PH_FRINFC_MIFARESTD_MAD_BLK2:
+      NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
+          (NdefMap->StdMifareContainer.currentBlock +
+           PH_FRINFC_MIFARESTD_BLK13);
+      break;
+
+    case PH_FRINFC_MIFARESTD_MAD_BLK3:
+      NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
+          (NdefMap->StdMifareContainer.currentBlock +
+           PH_FRINFC_MIFARESTD_BLK12);
+      break;
+
+    case PH_FRINFC_MIFARESTD_BLK4:
+      NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
+          (NdefMap->StdMifareContainer.currentBlock +
+           PH_FRINFC_MIFARESTD_BLK11);
+      break;
+
+    case PH_FRINFC_MIFARESTD_BLK5:
+      NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
+          (NdefMap->StdMifareContainer.currentBlock +
+           PH_FRINFC_MIFARESTD_BLK10);
+      break;
+
+    case PH_FRINFC_MIFARESTD_BLK6:
+      NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
+          (NdefMap->StdMifareContainer.currentBlock + PH_FRINFC_MIFARESTD_BLK9);
+      break;
+
+    case PH_FRINFC_MIFARESTD_BLK7:
+      NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
+          (NdefMap->StdMifareContainer.currentBlock + PH_FRINFC_MIFARESTD_BLK8);
+      break;
+
+    case PH_FRINFC_MIFARESTD_BLK8:
+      NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
+          (NdefMap->StdMifareContainer.currentBlock + PH_FRINFC_MIFARESTD_BLK7);
+      break;
+
+    case PH_FRINFC_MIFARESTD_BLK9:
+      NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
+          (NdefMap->StdMifareContainer.currentBlock + PH_FRINFC_MIFARESTD_BLK6);
+      break;
+
+    case PH_FRINFC_MIFARESTD_BLK10:
+      NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
+          (NdefMap->StdMifareContainer.currentBlock + PH_FRINFC_MIFARESTD_BLK5);
+      break;
+
+    case PH_FRINFC_MIFARESTD_BLK11:
+      NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
+          (NdefMap->StdMifareContainer.currentBlock + PH_FRINFC_MIFARESTD_BLK4);
+      break;
+
+    case PH_FRINFC_MIFARESTD_BLK12:
+      NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
+          (NdefMap->StdMifareContainer.currentBlock +
+           PH_FRINFC_MIFARESTD_MAD_BLK3);
+      break;
+
+    case PH_FRINFC_MIFARESTD_BLK13:
+      NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
+          (NdefMap->StdMifareContainer.currentBlock +
+           PH_FRINFC_MIFARESTD_MAD_BLK2);
+      break;
+
+    case PH_FRINFC_MIFARESTD_BLK14:
+      NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
+          (NdefMap->StdMifareContainer.currentBlock +
+           PH_FRINFC_MIFARESTD_MAD_BLK1);
+      break;
+
+    default:
+      NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
+          NdefMap->StdMifareContainer.currentBlock;
+      break;
+  }
+
+  return;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_ProChkNdef
+ *
+ * Description      This function processes the check ndef call.
+ *
+ * Returns          This function return NFCSTATUS_PENDING in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_ProChkNdef(phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+
+  /* Copy remaining bytes into the AID array
+     from Receive Buffer till array number 7 in aid */
+  if (NdefMap->StdMifareContainer.currentBlock == PH_FRINFC_MIFARESTD_VAL1) {
+    /* Helper Function to Store AID Information */
+    phFriNfc_MifStd_H_fillAIDarray(NdefMap);
+
+    NdefMap->StdMifareContainer.currentBlock = PH_FRINFC_MIFARESTD_VAL2;
+    /* read remaining AIDs from block number 2 */
+    Result = ((NdefMap->StdMifareContainer.aidCompleteFlag ==
+               PH_FRINFC_MIFARESTD_FLAG1)
+                  ? Result
+                  : phFriNfc_MifareStdMap_ChkNdef(NdefMap));
+  } else if (((NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_1K_CARD) &&
+              (NdefMap->StdMifareContainer.currentBlock ==
+               PH_FRINFC_MIFARESTD_MAD_BLK2)) ||
+             ((NdefMap->StdMifareContainer.currentBlock ==
+               PH_FRINFC_MIFARESTD_MAD_BLK66) &&
+              (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD ||
+               NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD))) {
+    /* Helper Function to Store AID Information */
+    phFriNfc_MifStd_H_fillAIDarray(NdefMap);
+
+    NdefMap->StdMifareContainer.aidCompleteFlag = PH_FRINFC_MIFARESTD_FLAG1;
+  } /* Mifare 1k and Mifare 4k end Check */
+  else if ((NdefMap->StdMifareContainer.currentBlock >
+            PH_FRINFC_MIFARESTD_VAL1) &&
+           (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD ||
+            NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD)) {
+    phFriNfc_MifStd_H_fillAIDarray(NdefMap);
+    /* read remaining AIDs from block number 2 */
+    /* Mifare 4k Helper Function */
+    Result = ((NdefMap->StdMifareContainer.aidCompleteFlag ==
+               PH_FRINFC_MIFARESTD_FLAG1)
+                  ? Result
+                  : phFriNfc_MifStd4k_H_CheckNdef(NdefMap));
+  } /* Card Type 4k Check */
+  else {
+    /* Since we have decided temporarily not to go
+       for any new error codes we are using
+       NFCSTATUS_INVALID_PARAMETER even though it is not
+       the relevant error code here TBD */
+    Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_PARAMETER);
+  }
+
+  if (NdefMap->StdMifareContainer.aidCompleteFlag ==
+      PH_FRINFC_MIFARESTD_FLAG1) {
+    NdefMap->StdMifareContainer.ChkNdefCompleteFlag = PH_FRINFC_MIFARESTD_FLAG1;
+    /*  The check for NDEF compliant information is now over for
+        the Mifare 1K card.
+        Update(decrement) the NoOfNdefCompBlocks as much required,
+        depending on the NDEF compliant information found */
+    /* Check the Sectors are Ndef Compliant */
+    phFriNfc_MifStd_H_ChkNdefCmpltSects(NdefMap);
+    if ((NdefMap->StdMifareContainer.NoOfNdefCompBlocks == 0) ||
+        (NdefMap->StdMifareContainer.NoOfNdefCompBlocks > 255)) {
+      Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_NO_NDEF_SUPPORT);
+    } else {
+      NdefMap->StdMifareContainer.aidCompleteFlag = PH_FRINFC_MIFARESTD_FLAG0;
+      NdefMap->StdMifareContainer.NFCforumSectFlag = PH_FRINFC_MIFARESTD_FLAG0;
+      NdefMap->StdMifareContainer.currentBlock = PH_FRINFC_MIFARESTD_BLK4;
+      Result = phFriNfc_MifStd_H_BlkChk(NdefMap);
+      Result = ((Result != NFCSTATUS_SUCCESS)
+                    ? Result
+                    : phFriNfc_MifStd_H_AuthSector(NdefMap));
+    }
+  }
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_ProAuth
+ *
+ * Description      This function process the authentication of a sector.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_ProAuth(phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+
+  if (NdefMap->TLVStruct.NdefTLVAuthFlag == PH_FRINFC_MIFARESTD_FLAG1) {
+    NdefMap->TLVStruct.NdefTLVAuthFlag = PH_FRINFC_MIFARESTD_FLAG0;
+    NdefMap->StdMifareContainer.AuthDone = PH_FRINFC_MIFARESTD_FLAG1;
+    Result = phFriNfc_MifStd_H_RdtoWrNdefLen(NdefMap);
+  } else {
+    NdefMap->StdMifareContainer.AuthDone = 1;
+    NdefMap->StdMifareContainer.ReadAcsBitFlag = 1;
+    Result = phFriNfc_MifStd_H_RdAcsBit(NdefMap);
+  }
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_Rd16Bytes
+ *
+ * Description      This function reads 16 bytes from a specifed block no.
+ *
+ * Returns          This function return NFCSTATUS_PENDING in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_Rd16Bytes(phFriNfc_NdefMap_t* NdefMap,
+                                             uint8_t BlockNo) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+
+  NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] = BlockNo;
+  NdefMap->SendLength = MIFARE_MAX_SEND_BUF_TO_READ;
+  *NdefMap->SendRecvLength = NdefMap->TempReceiveLength;
+  NdefMap->Cmd.MfCmd = phHal_eMifareRead;
+  NdefMap->MapCompletionInfo.CompletionRoutine = phFriNfc_MifareStdMap_Process;
+  NdefMap->MapCompletionInfo.Context = NdefMap;
+
+  /* Call the Overlapped HAL Transceive function */
+  Result = phFriNfc_ExtnsTransceive(NdefMap->pTransceiveInfo, NdefMap->Cmd,
+                                    NdefMap->SendRecvBuf, NdefMap->SendLength,
+                                    NdefMap->SendRecvLength);
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_ProAcsBits
+ *
+ * Description      It processes access bits of the sector trailer.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_ProAcsBits(phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+  uint8_t CRFlag = PH_FRINFC_MIFARESTD_FLAG0;
+
+  if (*NdefMap->SendRecvLength == PH_FRINFC_MIFARESTD_BYTES_READ) {
+    if (NdefMap->StdMifareContainer.ReadAcsBitFlag ==
+        PH_FRINFC_MIFARESTD_FLAG1) {
+      /* check for the correct access bits */
+      Result = phFriNfc_MifStd_H_ChkAcsBit(NdefMap);
+
+      if ((NdefMap->StdMifareContainer.ChkNdefFlag ==
+           PH_FRINFC_MIFARESTD_FLAG1) &&
+          (Result == NFCSTATUS_SUCCESS)) {
+        if (NdefMap->CardState == PH_NDEFMAP_CARD_STATE_INVALID) {
+          NdefMap->StdMifareContainer.NoOfNdefCompBlocks =
+              ((NdefMap->StdMifareContainer.currentBlock >=
+                PH_FRINFC_MIFARESTD4K_BLK128)
+                   ? (NdefMap->StdMifareContainer.NoOfNdefCompBlocks -
+                      PH_FRINFC_MIFARESTD_BLK15)
+                   : (NdefMap->StdMifareContainer.NoOfNdefCompBlocks -
+                      PH_FRINFC_MIFARESTD_MAD_BLK3));
+
+          NdefMap->StdMifareContainer.ProprforumSectFlag =
+              ((NdefMap->StdMifareContainer.NFCforumSectFlag ==
+                PH_FRINFC_MIFARESTD_FLAG1)
+                   ? PH_FRINFC_MIFARESTD_PROP_2ND_CONFIG
+                   : PH_FRINFC_MIFARESTD_PROP_3RD_CONFIG);
+
+          Result = phFriNfc_MifStd_H_ProStatNotValid(NdefMap, Result);
+        } else {
+          NdefMap->StdMifareContainer.NFCforumSectFlag =
+              (((NdefMap->StdMifareContainer.currentBlock == 64) &&
+                ((NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD) ||
+                 (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD)))
+                   ? NdefMap->StdMifareContainer.NFCforumSectFlag
+                   : PH_FRINFC_MIFARESTD_FLAG1);
+        }
+
+        if (NdefMap->StdMifareContainer.ProprforumSectFlag !=
+            PH_FRINFC_MIFARESTD_PROP_2ND_CONFIG) {
+          NdefMap->StdMifareContainer.ReadAcsBitFlag =
+              PH_FRINFC_MIFARESTD_FLAG0;
+          /* ((NdefMap->StdMifareContainer.ReadCompleteFlag ==
+                  PH_FRINFC_MIFARESTD_FLAG1)?
+                  PH_FRINFC_MIFARESTD_FLAG0:
+                  PH_FRINFC_MIFARESTD_FLAG1);*/
+
+          NdefMap->StdMifareContainer.ReadCompleteFlag = (uint8_t)(
+              (((((NdefMap->StdMifareContainer.currentBlock +
+                   PH_FRINFC_MIFARESTD_VAL4) >=
+                  PH_FRINFC_MIFARESTD1K_MAX_BLK) &&
+                 (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_1K_CARD)) &&
+                (NdefMap->StdMifareContainer.ReadCompleteFlag ==
+                 PH_FRINFC_MIFARESTD_FLAG0)) ||
+               (NdefMap->StdMifareContainer.ReadCompleteFlag ==
+                PH_FRINFC_MIFARESTD_FLAG1))
+                  ? PH_FRINFC_MIFARESTD_FLAG1
+                  : PH_FRINFC_MIFARESTD_FLAG0);
+
+          NdefMap->StdMifareContainer.ReadCompleteFlag = (uint8_t)(
+              (((((uint16_t)(NdefMap->StdMifareContainer.currentBlock +
+                             PH_FRINFC_MIFARESTD_VAL4) >=
+                  PH_FRINFC_MIFARESTD4K_MAX_BLK) &&
+                 (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD)) &&
+                (NdefMap->StdMifareContainer.ReadCompleteFlag ==
+                 PH_FRINFC_MIFARESTD_FLAG0)) ||
+               (NdefMap->StdMifareContainer.ReadCompleteFlag ==
+                PH_FRINFC_MIFARESTD_FLAG1))
+                  ? PH_FRINFC_MIFARESTD_FLAG1
+                  : PH_FRINFC_MIFARESTD_FLAG0);
+
+          NdefMap->StdMifareContainer.ReadCompleteFlag = (uint8_t)(
+              (((((uint16_t)(NdefMap->StdMifareContainer.currentBlock +
+                             PH_FRINFC_MIFARESTD_VAL4) >=
+                  PH_FRINFC_MIFARESTD4K_MAX_BLK) &&
+                 (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD)) &&
+                (NdefMap->StdMifareContainer.ReadCompleteFlag ==
+                 PH_FRINFC_MIFARESTD_FLAG0)) ||
+               (NdefMap->StdMifareContainer.ReadCompleteFlag ==
+                PH_FRINFC_MIFARESTD_FLAG1))
+                  ? PH_FRINFC_MIFARESTD_FLAG1
+                  : PH_FRINFC_MIFARESTD_FLAG0);
+
+          NdefMap->StdMifareContainer.currentBlock =
+              ((NdefMap->StdMifareContainer.ReadCompleteFlag ==
+                PH_FRINFC_MIFARESTD_FLAG1)
+                   ? PH_FRINFC_MIFARESTD_BLK4
+                   : NdefMap->StdMifareContainer.currentBlock);
+
+          Result = ((NdefMap->StdMifareContainer.ReadCompleteFlag ==
+                     PH_FRINFC_MIFARESTD_FLAG1)
+                        ? phFriNfc_MifStd_H_BlkChk(NdefMap)
+                        : Result);
+        }
+      }
+
+      Result =
+          ((Result != NFCSTATUS_SUCCESS) ? Result
+                                         : phFriNfc_MifStd_H_ChkRdWr(NdefMap));
+    } else {
+      NdefMap->StdMifareContainer.ChkNdefFlag = PH_FRINFC_MIFARESTD_FLAG0;
+      /* Here its required to read the entire card to know the */
+      /* Get exact ndef size of the card */
+      Result = phFriNfc_MifStd_H_ChkTLVs(NdefMap, &CRFlag);
+    }
+  } else {
+    /* Since we have decided temporarily not to go
+       for any new error codes we are using
+       NFCSTATUS_INVALID_PARAMETER even though it is not
+       the relevant error code here TBD */
+    Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_PARAMETER);
+  }
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_GPBChk
+ *
+ * Description      This function is checks the GPB bytes.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_GPBChk(phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+
+  /* Spec version needs to be checked every time (Version check is not enabled)
+   */
+  /* Result = phFriNfc_MapTool_ChkSpcVer(NdefMap, PH_FRINFC_MIFARESTD_VAL9); */
+
+  /* Check rhe read and write access field
+      in GPB is 00b
+      bit 0 and 1 for write access check
+      bit 2 and 3 for read access check */
+  if (Result == NFCSTATUS_SUCCESS) {
+    if (((NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL9] &
+          PH_FRINFC_MIFARESTD_MASK_GPB_WR) ==
+         PH_FRINFC_MIFARESTD_GPB_RD_WR_VAL) &&
+        ((NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL9] &
+          PH_FRINFC_MIFARESTD_MASK_GPB_RD) ==
+         PH_FRINFC_MIFARESTD_GPB_RD_WR_VAL)) {
+      NdefMap->CardState = (((NdefMap->StdMifareContainer.ChkNdefFlag ==
+                              PH_FRINFC_MIFARESTD_FLAG1) ||
+                             (NdefMap->StdMifareContainer.ReadNdefFlag ==
+                              PH_FRINFC_MIFARESTD_FLAG1) ||
+                             (NdefMap->StdMifareContainer.WrNdefFlag ==
+                              PH_FRINFC_MIFARESTD_FLAG1))
+                                ? PH_NDEFMAP_CARD_STATE_INITIALIZED
+                                : PH_NDEFMAP_CARD_STATE_READ_WRITE);
+    } else if (((NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL9] &
+                 PH_FRINFC_MIFARESTD_MASK_GPB_WR) !=
+                PH_FRINFC_MIFARESTD_GPB_RD_WR_VAL) &&
+               ((NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL9] &
+                 PH_FRINFC_MIFARESTD_MASK_GPB_RD) ==
+                PH_FRINFC_MIFARESTD_GPB_RD_WR_VAL)) {
+      /* write access not given
+      only read access check */
+      NdefMap->CardState = PH_NDEFMAP_CARD_STATE_READ_ONLY;
+    } else {
+      NdefMap->CardState = PH_NDEFMAP_CARD_STATE_INVALID;
+    }
+  }
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_ProStatNotValid
+ *
+ * Description      This function checks for the different status value in the
+ *                  process because of proprietary forum sector.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_ProStatNotValid(phFriNfc_NdefMap_t* NdefMap,
+                                                   NFCSTATUS status) {
+  NFCSTATUS Result = status;
+
+  /* if NFC forum sector is not found before the proprietary one then
+     authenticate the next sector
+     Else it is a error*/
+  if (NdefMap->StdMifareContainer.NFCforumSectFlag ==
+      PH_FRINFC_MIFARESTD_FLAG0) {
+    NdefMap->StdMifareContainer.ProprforumSectFlag =
+        PH_FRINFC_MIFARESTD_PROP_3RD_CONFIG;
+    if (NdefMap->StdMifareContainer.currentBlock <
+        PH_FRINFC_MIFARESTD4K_BLK128) {
+      /* Fix for the disovery problem,
+         if 1st sector is invalid then ignore the remaining sectors and
+         send an error if the card is mifare 1k,
+         if the card is mifare 4k, then update the block number to 67 and
+         continue.
+         Even if the authentication of that block fails then send error */
+      if (((NdefMap->StdMifareContainer.currentBlock <
+            PH_FRINFC_MIFARESTD_BLK4) &&
+           (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_1K_CARD)) ||
+          ((NdefMap->StdMifareContainer.currentBlock <=
+            PH_FRINFC_MIFARESTD_MAD_BLK67) &&
+           (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD ||
+            NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD))) {
+        Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_NO_NDEF_SUPPORT);
+      } else if ((NdefMap->StdMifareContainer.currentBlock <
+                  PH_FRINFC_MIFARESTD_BLK4) &&
+                 (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD ||
+                  NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD)) {
+        Result = NFCSTATUS_SUCCESS;
+        NdefMap->StdMifareContainer.currentBlock =
+            PH_FRINFC_MIFARESTD_MAD_BLK67;
+      } else if (((NdefMap->StdMifareContainer.currentBlock +
+                   PH_FRINFC_MIFARESTD_BLK4) > PH_FRINFC_MIFARESTD1K_MAX_BLK) &&
+                 (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_1K_CARD)) {
+        Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_NO_NDEF_SUPPORT);
+      } else {
+        NdefMap->StdMifareContainer.remainingSize -=
+            (PH_FRINFC_MIFARESTD_MAD_BLK3 * PH_FRINFC_MIFARESTD_BLOCK_BYTES);
+        NdefMap->StdMifareContainer.currentBlock += PH_FRINFC_MIFARESTD_BLK4;
+        Result = phFriNfc_MifStd_H_BlkChk(NdefMap);
+      }
+    } else if ((NdefMap->StdMifareContainer.currentBlock +
+                PH_FRINFC_MIFARESTD_BLK15) > PH_FRINFC_MIFARESTD4K_MAX_BLK) {
+      Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_NO_NDEF_SUPPORT);
+    } else {
+      NdefMap->StdMifareContainer.remainingSize -=
+          (PH_FRINFC_MIFARESTD_BLK15 * PH_FRINFC_MIFARESTD_BLOCK_BYTES);
+      NdefMap->StdMifareContainer.currentBlock +=
+          PH_FRINFC_MIFARESTD_BLOCK_BYTES;
+      Result = phFriNfc_MifStd_H_BlkChk(NdefMap);
+    }
+    Result =
+        ((Result != NFCSTATUS_SUCCESS)
+             ? (PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_NO_NDEF_SUPPORT))
+             : phFriNfc_MifStd_H_AuthSector(NdefMap));
+  } else if ((NdefMap->StdMifareContainer.ProprforumSectFlag ==
+              PH_FRINFC_MIFARESTD_PROP_3RD_CONFIG) &&
+             (NdefMap->StdMifareContainer.NFCforumSectFlag ==
+              PH_FRINFC_MIFARESTD_FLAG1)) {
+    /*  if the proprietary forum sector are found before
+        NFC forum sector then again a proprietary
+        forum sector are found after the NFC forum
+        sector */
+    Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_NO_NDEF_SUPPORT);
+  } else {
+    NdefMap->StdMifareContainer.ProprforumSectFlag =
+        PH_FRINFC_MIFARESTD_PROP_2ND_CONFIG;
+    switch (NdefMap->PrevOperation) {
+      case PH_FRINFC_NDEFMAP_CHECK_OPE:
+      case PH_FRINFC_NDEFMAP_GET_ACTSIZE_OPE:
+        Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_NO_NDEF_SUPPORT);
+        break;
+
+      case PH_FRINFC_NDEFMAP_READ_OPE:
+        if ((NdefMap->TLVStruct.NdefTLVFoundFlag ==
+             PH_FRINFC_MIFARESTD_FLAG1) &&
+            (NdefMap->TLVStruct.NoLbytesinTLV == PH_FRINFC_MIFARESTD_VAL0)) {
+          *NdefMap->NumOfBytesRead = NdefMap->ApduBuffIndex;
+          Result = NFCSTATUS_SUCCESS;
+        } else {
+          Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_NO_NDEF_SUPPORT);
+        }
+        break;
+
+      case PH_FRINFC_NDEFMAP_WRITE_OPE:
+      default:
+        /* This means the further write is not possible,
+           EOF_NDEF_CONTAINER_REACHED */
+        NdefMap->StdMifareContainer.ReadWriteCompleteFlag =
+            PH_FRINFC_MIFARESTD_FLAG1;
+        /* Write the length to the L field in the TLV */
+        NdefMap->StdMifareContainer.TempBlockNo =
+            NdefMap->StdMifareContainer.currentBlock;
+        phFriNfc_MifStd_H_SetNdefBlkAuth(NdefMap);
+        NdefMap->StdMifareContainer.currentBlock =
+            NdefMap->TLVStruct.NdefTLVBlock;
+        Result = phFriNfc_MifStd_H_RdtoWrNdefLen(NdefMap);
+        break;
+    }
+  }
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_RdBeforeWr
+ *
+ * Description      This function is used to read the NDEF TLV block.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_RdBeforeWr(phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+
+  NdefMap->State = PH_FRINFC_NDEFMAP_STATE_RD_BEF_WR;
+  NdefMap->PrevOperation = PH_FRINFC_NDEFMAP_WRITE_OPE;
+
+  Result = phFriNfc_MifStd_H_Rd16Bytes(
+      NdefMap, NdefMap->StdMifareContainer.currentBlock);
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_ProBytesToWr
+ *
+ * Description      This function processes the NDEF TLV block read bytes to
+ *                  start write from the NDEF TLV.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_ProBytesToWr(phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+  uint8_t TempLength = PH_FRINFC_MIFARESTD_VAL0;
+
+  if (*NdefMap->SendRecvLength == PH_FRINFC_MIFARESTD_BYTES_READ) {
+    memmove(&NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL1],
+            NdefMap->SendRecvBuf, PH_FRINFC_MIFARESTD_BLOCK_BYTES);
+
+    /* Write to Ndef TLV Block */
+    NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
+        NdefMap->StdMifareContainer.currentBlock;
+
+    TempLength = ((NdefMap->StdMifareContainer.currentBlock ==
+                   NdefMap->TLVStruct.NdefTLVBlock)
+                      ? phFriNfc_MifStd_H_UpdateTLV(NdefMap)
+                      : phFriNfc_MifStd_H_UpdRemTLV(NdefMap));
+
+    NdefMap->StdMifareContainer.remainingSize -=
+        ((NdefMap->StdMifareContainer.remSizeUpdFlag ==
+          PH_FRINFC_MIFARESTD_FLAG1)
+             ? PH_FRINFC_MIFARESTD_VAL2
+             : PH_FRINFC_MIFARESTD_VAL0);
+
+    NdefMap->StdMifareContainer.remSizeUpdFlag = PH_FRINFC_MIFARESTD_FLAG0;
+    NdefMap->State = PH_FRINFC_NDEFMAP_STATE_WR_TLV;
+    Result = ((TempLength == PH_FRINFC_MIFARESTD_BLOCK_BYTES)
+                  ? phFriNfc_MifStd_H_WrTLV(NdefMap)
+                  : phFriNfc_MifStd_H_fillSendBuf(NdefMap, TempLength));
+  } else {
+    Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_READ_FAILED);
+  }
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_UpdateTLV
+ *
+ * Description      This function writes ndef to add the TLV structure.
+ *
+ * Returns          uint8_t     TempLength
+ *
+ ******************************************************************************/
+static uint8_t phFriNfc_MifStd_H_UpdateTLV(phFriNfc_NdefMap_t* NdefMap) {
+  uint8_t TempLength = PH_FRINFC_MIFARESTD_VAL0;
+
+  TempLength =
+      (uint8_t)(NdefMap->TLVStruct.NdefTLVByte + PH_FRINFC_MIFARESTD_VAL1);
+  /* Creating TLV */
+  if (NdefMap->TLVStruct.NULLTLVCount >= 2) {
+    if ((PH_FRINFC_MIFARESTD_BYTES_READ - TempLength) ==
+        PH_FRINFC_MIFARESTD_VAL0) {
+      NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
+    } else {
+      NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
+      TempLength++;
+      NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_L0;
+    }
+  } else {
+    switch ((PH_FRINFC_MIFARESTD_BYTES_READ - TempLength)) {
+      case PH_FRINFC_MIFARESTD_VAL0:
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NULLTLV_T;
+        break;
+
+      case PH_FRINFC_MIFARESTD_VAL1:
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NULLTLV_T;
+        TempLength++;
+        NdefMap->TLVStruct.prevLenByteValue = (uint16_t)(
+            (NdefMap->SendRecvBuf[TempLength] >= PH_FRINFC_MIFARESTD_NDEFTLV_L)
+                ? PH_FRINFC_MIFARESTD_VAL0
+                : NdefMap->SendRecvBuf[TempLength]);
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NULLTLV_T;
+        break;
+
+      case PH_FRINFC_MIFARESTD_VAL2:
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NULLTLV_T;
+        TempLength++;
+        NdefMap->TLVStruct.prevLenByteValue = (uint16_t)(
+            (NdefMap->SendRecvBuf[TempLength] >= PH_FRINFC_MIFARESTD_NDEFTLV_L)
+                ? NdefMap->SendRecvBuf[(TempLength + PH_FRINFC_MIFARESTD_VAL1)]
+                : NdefMap->SendRecvBuf[TempLength]);
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NULLTLV_T;
+        TempLength++;
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
+        break;
+
+      default:
+        NdefMap->TLVStruct.prevLenByteValue = NdefMap->SendRecvBuf[TempLength];
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NULLTLV_T;
+        TempLength++;
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NULLTLV_T;
+        TempLength++;
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
+        TempLength++;
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_L0;
+        break;
+    }
+  }
+
+  return TempLength;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_fillSendBuf
+ *
+ * Description      It fill the send buffer to write.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_fillSendBuf(phFriNfc_NdefMap_t* NdefMap,
+                                               uint8_t Length) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+  uint16_t RemainingBytes = PH_FRINFC_MIFARESTD_VAL0,
+           BytesToWrite = PH_FRINFC_MIFARESTD_VAL0;
+  uint8_t index = PH_FRINFC_MIFARESTD_VAL0;
+
+  Length = (Length + PH_FRINFC_MIFARESTD_VAL1);
+
+  RemainingBytes =
+      (uint16_t)((NdefMap->StdMifareContainer.remainingSize <
+                  (uint16_t)(NdefMap->ApduBufferSize - NdefMap->ApduBuffIndex))
+                     ? NdefMap->StdMifareContainer.remainingSize
+                     : (NdefMap->ApduBufferSize - NdefMap->ApduBuffIndex));
+
+  NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
+      NdefMap->StdMifareContainer.currentBlock;
+  /* Get the number of bytes that can be written after copying
+     the internal buffer */
+  BytesToWrite =
+      ((RemainingBytes < ((PH_FRINFC_MIFARESTD_WR_A_BLK - Length) -
+                          NdefMap->StdMifareContainer.internalLength))
+           ? RemainingBytes
+           : ((PH_FRINFC_MIFARESTD_WR_A_BLK - Length) -
+              NdefMap->StdMifareContainer.internalLength));
+
+  if (NdefMap->StdMifareContainer.internalLength > PH_FRINFC_MIFARESTD_VAL0) {
+    /* copy the internal buffer to the send buffer */
+    memcpy(&(NdefMap->SendRecvBuf[Length]),
+           NdefMap->StdMifareContainer.internalBuf,
+           NdefMap->StdMifareContainer.internalLength);
+  }
+
+  /* Copy Bytes to write in the send buffer */
+  memcpy(&(NdefMap->SendRecvBuf[(Length +
+                                 NdefMap->StdMifareContainer.internalLength)]),
+         &(NdefMap->ApduBuffer[NdefMap->ApduBuffIndex]), BytesToWrite);
+
+  /* update number of bytes written from the user buffer */
+  NdefMap->NumOfBytesWritten = BytesToWrite;
+
+  /* check the exact number of bytes written to a block including the
+      internal length */
+  *NdefMap->DataCount =
+      ((BytesToWrite + NdefMap->StdMifareContainer.internalLength + Length) -
+       PH_FRINFC_MIFARESTD_VAL1);
+
+  /* if total bytes to write in the card is less than 4 bytes then
+  pad zeroes till 4 bytes */
+  if ((BytesToWrite + NdefMap->StdMifareContainer.internalLength + Length) <
+      PH_FRINFC_MIFARESTD_WR_A_BLK) {
+    for (index = (uint8_t)(BytesToWrite +
+                           NdefMap->StdMifareContainer.internalLength + Length);
+         index < PH_FRINFC_MIFARESTD_WR_A_BLK; index++) {
+      NdefMap->SendRecvBuf[index] =
+          (uint8_t)((index == (BytesToWrite + Length +
+                               NdefMap->StdMifareContainer.internalLength))
+                        ? PH_FRINFC_MIFARESTD_TERMTLV_T
+                        : PH_FRINFC_MIFARESTD_NULLTLV_T);
+
+      NdefMap->TLVStruct.SetTermTLVFlag = PH_FRINFC_MIFARESTD_FLAG1;
+    }
+  }
+
+  NdefMap->TLVStruct.SetTermTLVFlag = PH_FRINFC_MIFARESTD_FLAG1;
+
+  /* A temporary buffer to hold four bytes of data that is
+     written to the card */
+  memcpy(NdefMap->StdMifareContainer.Buffer,
+         &(NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL1]),
+         PH_FRINFC_MIFARESTD_BLOCK_BYTES);
+
+  NdefMap->State = PH_FRINFC_NDEFMAP_STATE_WR_TLV;
+  Result = phFriNfc_MifStd_H_WrTLV(NdefMap);
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_WrTLV
+ *
+ * Description      This function writes 16 bytes in a block.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_WrTLV(phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+
+  NdefMap->MapCompletionInfo.CompletionRoutine = phFriNfc_MifareStdMap_Process;
+  NdefMap->MapCompletionInfo.Context = NdefMap;
+  /* Write from here */
+  NdefMap->SendLength = MIFARE_MAX_SEND_BUF_TO_WRITE;
+
+  NdefMap->Cmd.MfCmd = phHal_eMifareWrite16;
+
+  *NdefMap->SendRecvLength = NdefMap->TempReceiveLength;
+
+  /* Call the Overlapped HAL Transceive function */
+  Result = phFriNfc_ExtnsTransceive(NdefMap->pTransceiveInfo, NdefMap->Cmd,
+                                    NdefMap->SendRecvBuf, NdefMap->SendLength,
+                                    NdefMap->SendRecvLength);
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_ProWrTLV
+ *
+ * Description      This function processes the write TLV bytes in a block.
+ *
+ * Returns          This function return NFCSTATUS_SUCESS in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_ProWrTLV(phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+
+  /* Check that if complete TLV has been written in the
+     card if yes enter the below check or go to else*/
+  if (((((PH_FRINFC_MIFARESTD_BLOCK_BYTES - NdefMap->TLVStruct.NdefTLVByte) ==
+         PH_FRINFC_MIFARESTD_VAL1) &&
+        (NdefMap->TLVStruct.NULLTLVCount >= PH_FRINFC_MIFARESTD_VAL2)) ||
+       (((PH_FRINFC_MIFARESTD_BLOCK_BYTES - NdefMap->TLVStruct.NdefTLVByte) <=
+         PH_FRINFC_MIFARESTD_VAL3) &&
+        (NdefMap->TLVStruct.NULLTLVCount == PH_FRINFC_MIFARESTD_VAL0))) &&
+      (NdefMap->StdMifareContainer.currentBlock ==
+       NdefMap->TLVStruct.NdefTLVBlock)) {
+    /* increment the block and chekc the block is in the same sector
+       using the block check function */
+    NdefMap->StdMifareContainer.RdBeforeWrFlag = PH_FRINFC_MIFARESTD_FLAG1;
+    NdefMap->StdMifareContainer.currentBlock++;
+    NdefMap->StdMifareContainer.NdefBlocks++;
+    Result = phFriNfc_MifStd_H_BlkChk(NdefMap);
+    if (Result == NFCSTATUS_SUCCESS) {
+      Result =
+          ((NdefMap->StdMifareContainer.AuthDone == PH_FRINFC_MIFARESTD_FLAG0)
+               ? phFriNfc_MifStd_H_AuthSector(NdefMap)
+               : phFriNfc_MifStd_H_RdBeforeWr(NdefMap));
+    }
+  } else {
+    NdefMap->StdMifareContainer.RdBeforeWrFlag = PH_FRINFC_MIFARESTD_FLAG0;
+    if (NdefMap->ApduBuffIndex < (uint16_t)NdefMap->ApduBufferSize) {
+      if (*NdefMap->DataCount < PH_FRINFC_MIFARESTD_BLOCK_BYTES) {
+        /* Write complete, so next byte shall be */
+        NdefMap->StdMifareContainer.internalLength = *NdefMap->DataCount;
+
+        /* Copy bytes less than 16 to internal buffer
+           for the next write this can be used */
+        memcpy(NdefMap->StdMifareContainer.internalBuf,
+               NdefMap->StdMifareContainer.Buffer,
+               NdefMap->StdMifareContainer.internalLength);
+      }
+
+      /* Increment the Send Buffer index */
+      NdefMap->ApduBuffIndex += NdefMap->NumOfBytesWritten;
+
+      NdefMap->StdMifareContainer.remainingSize -= NdefMap->NumOfBytesWritten;
+
+      /* Check for the End of Card */
+      if ((NdefMap->StdMifareContainer.remainingSize ==
+           PH_FRINFC_MIFARESTD_VAL0) ||
+          (NdefMap->ApduBuffIndex == NdefMap->ApduBufferSize)) {
+        NdefMap->StdMifareContainer.ReadWriteCompleteFlag =
+            (uint8_t)((NdefMap->StdMifareContainer.remainingSize == 0)
+                          ? PH_FRINFC_MIFARESTD_FLAG1
+                          : PH_FRINFC_MIFARESTD_FLAG0);
+
+        if (NdefMap->StdMifareContainer.internalLength ==
+            PH_FRINFC_MIFARESTD_VAL0) {
+          NdefMap->StdMifareContainer.currentBlock++;
+          /* Mifare 4k Card, After 128th Block
+          each sector = 16 blocks in Mifare 4k */
+          Result = phFriNfc_MifStd_H_BlkChk(NdefMap);
+          NdefMap->StdMifareContainer.NdefBlocks++;
+        }
+
+        NdefMap->TLVStruct.SetTermTLVFlag = (uint8_t)(
+            ((NdefMap->StdMifareContainer.remainingSize ==
+              PH_FRINFC_MIFARESTD_VAL0) ||
+             (NdefMap->TLVStruct.SetTermTLVFlag == PH_FRINFC_MIFARESTD_FLAG1))
+                ? PH_FRINFC_MIFARESTD_FLAG1
+                : PH_FRINFC_MIFARESTD_FLAG0);
+
+      } else {
+        NdefMap->StdMifareContainer.currentBlock++;
+        /* Mifare 4k Card, After 128th Block
+        each sector = 16 blocks in Mifare 4k */
+        Result = phFriNfc_MifStd_H_BlkChk(NdefMap);
+        if (Result == NFCSTATUS_SUCCESS) {
+          NdefMap->StdMifareContainer.NdefBlocks++;
+          Result = ((NdefMap->StdMifareContainer.AuthDone ==
+                     PH_FRINFC_MIFARESTD_FLAG1)
+                        ? phFriNfc_MifStd_H_WrABlock(NdefMap)
+                        : phFriNfc_MifStd_H_AuthSector(NdefMap));
+        }
+      }
+    }
+  }
+
+  if ((Result == NFCSTATUS_SUCCESS) &&
+      (NdefMap->TLVStruct.SetTermTLVFlag != PH_FRINFC_MIFARESTD_FLAG1) &&
+      (NdefMap->StdMifareContainer.remainingSize > PH_FRINFC_MIFARESTD_VAL0)) {
+    Result = phFriNfc_MifStd_H_WrTermTLV(NdefMap);
+  } else {
+    if ((Result == NFCSTATUS_SUCCESS) &&
+        (NdefMap->TLVStruct.SetTermTLVFlag == PH_FRINFC_MIFARESTD_FLAG1)) {
+      /* Write the length to the L field in the TLV */
+      NdefMap->StdMifareContainer.TempBlockNo =
+          NdefMap->StdMifareContainer.currentBlock;
+      phFriNfc_MifStd_H_SetNdefBlkAuth(NdefMap);
+      NdefMap->StdMifareContainer.currentBlock =
+          NdefMap->TLVStruct.NdefTLVBlock;
+      Result = phFriNfc_MifStd_H_RdtoWrNdefLen(NdefMap);
+    }
+  }
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_UpdRemTLV
+ *
+ * Description      This function updates the remaining TLV.
+ *
+ * Returns          uint8_t     TempLength : length value
+ *
+ ******************************************************************************/
+static uint8_t phFriNfc_MifStd_H_UpdRemTLV(phFriNfc_NdefMap_t* NdefMap) {
+  uint8_t TempLength = PH_FRINFC_MIFARESTD_VAL1;
+
+  if (NdefMap->TLVStruct.NULLTLVCount >= PH_FRINFC_MIFARESTD_VAL2) {
+    NdefMap->TLVStruct.prevLenByteValue = NdefMap->SendRecvBuf[TempLength];
+    NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_L0;
+  } else {
+    switch (
+        (PH_FRINFC_MIFARESTD_BLOCK_BYTES - NdefMap->TLVStruct.NdefTLVByte)) {
+      case PH_FRINFC_MIFARESTD_VAL1:
+        NdefMap->TLVStruct.prevLenByteValue =
+            (((NdefMap->SendRecvBuf[TempLength] ==
+               PH_FRINFC_MIFARESTD_NDEFTLV_L))
+                 ? (((uint16_t)NdefMap
+                         ->SendRecvBuf[(TempLength + PH_FRINFC_MIFARESTD_VAL1)]
+                     << PH_FRINFC_MIFARESTD_LEFTSHIFT8) +
+                    NdefMap
+                        ->SendRecvBuf[(TempLength + PH_FRINFC_MIFARESTD_VAL2)])
+                 : NdefMap->SendRecvBuf[TempLength]);
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NULLTLV_T;
+        TempLength++;
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
+        TempLength++;
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_L0;
+        break;
+
+      case PH_FRINFC_MIFARESTD_VAL2:
+        NdefMap->TLVStruct.prevLenByteValue =
+            (((NdefMap->SendRecvBuf[TempLength] ==
+               PH_FRINFC_MIFARESTD_NDEFTLV_L))
+                 ? (((uint16_t)NdefMap->SendRecvBuf[TempLength]
+                     << PH_FRINFC_MIFARESTD_LEFTSHIFT8) +
+                    NdefMap
+                        ->SendRecvBuf[(TempLength + PH_FRINFC_MIFARESTD_VAL1)])
+                 : NdefMap->SendRecvBuf[TempLength]);
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
+        TempLength++;
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_L0;
+        break;
+
+      case PH_FRINFC_MIFARESTD_VAL3:
+      default:
+        NdefMap->TLVStruct.prevLenByteValue =
+            ((NdefMap->TLVStruct.prevLenByteValue
+              << PH_FRINFC_MIFARESTD_LEFTSHIFT8) +
+             NdefMap->SendRecvBuf[TempLength]);
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_L0;
+        break;
+    }
+  }
+
+  return TempLength;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_fillTLV1
+ *
+ * Description      This function updates the length field if more than one
+ *                  NULL TLVs exists before of the NDEF TLV.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void phFriNfc_MifStd_H_fillTLV1(phFriNfc_NdefMap_t* NdefMap) {
+  uint8_t TempLength =
+      (uint8_t)(NdefMap->TLVStruct.NdefTLVByte + PH_FRINFC_MIFARESTD_VAL1);
+
+  NdefMap->TLVStruct.prevLenByteValue =
+      ((NdefMap->Offset == PH_FRINFC_NDEFMAP_SEEK_CUR)
+           ? (NdefMap->TLVStruct.prevLenByteValue + NdefMap->ApduBuffIndex)
+           : NdefMap->ApduBuffIndex);
+
+  NdefMap->StdMifareContainer.RdAfterWrFlag = PH_FRINFC_MIFARESTD_FLAG1;
+  switch (NdefMap->TLVStruct.NdefTLVByte) {
+    case PH_FRINFC_MIFARESTD_VAL0:
+      if (NdefMap->TLVStruct.prevLenByteValue >=
+          PH_FRINFC_MIFARESTD_NDEFTLV_L) {
+        NdefMap->SendRecvBuf[TempLength] =
+            (uint8_t)(NdefMap->TLVStruct.prevLenByteValue >>
+                      PH_FRINFC_MIFARESTD_RIGHTSHIFT8);
+        NdefMap->SendRecvBuf[(TempLength + PH_FRINFC_MIFARESTD_VAL1)] =
+            (uint8_t)NdefMap->TLVStruct.prevLenByteValue;
+      } else {
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
+        NdefMap->SendRecvBuf[(TempLength + PH_FRINFC_MIFARESTD_VAL1)] =
+            (uint8_t)NdefMap->TLVStruct.prevLenByteValue;
+
+        NdefMap->StdMifareContainer.RdAfterWrFlag = PH_FRINFC_MIFARESTD_FLAG0;
+      }
+      break;
+
+    case PH_FRINFC_MIFARESTD_VAL1:
+      if (NdefMap->TLVStruct.prevLenByteValue >=
+          PH_FRINFC_MIFARESTD_NDEFTLV_L) {
+        NdefMap->SendRecvBuf[TempLength - PH_FRINFC_MIFARESTD_VAL1] =
+            PH_FRINFC_MIFARESTD_NDEFTLV_L;
+        NdefMap->SendRecvBuf[TempLength] =
+            (uint8_t)(NdefMap->TLVStruct.prevLenByteValue >>
+                      PH_FRINFC_MIFARESTD_RIGHTSHIFT8);
+        NdefMap->SendRecvBuf[(TempLength + PH_FRINFC_MIFARESTD_VAL1)] =
+            (uint8_t)NdefMap->TLVStruct.prevLenByteValue;
+      } else {
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
+        NdefMap->SendRecvBuf[(TempLength + PH_FRINFC_MIFARESTD_VAL1)] =
+            (uint8_t)NdefMap->TLVStruct.prevLenByteValue;
+        NdefMap->StdMifareContainer.RdAfterWrFlag = PH_FRINFC_MIFARESTD_FLAG0;
+      }
+      break;
+
+    case PH_FRINFC_MIFARESTD_VAL15:
+      /* if "Type" of TLV present at byte 15 */
+      if (NdefMap->TLVStruct.prevLenByteValue >=
+          PH_FRINFC_MIFARESTD_NDEFTLV_L) {
+        /* Update the null TLV, ndef TLV block and ndef TLV byte */
+        NdefMap->TLVStruct.NULLTLVCount = PH_FRINFC_MIFARESTD_VAL0;
+        NdefMap->TLVStruct.NdefTLVBlock =
+            NdefMap->StdMifareContainer.currentBlock;
+        NdefMap->TLVStruct.NdefTLVByte =
+            (TempLength - PH_FRINFC_MIFARESTD_VAL3);
+
+        NdefMap->SendRecvBuf[(TempLength - PH_FRINFC_MIFARESTD_VAL2)] =
+            PH_FRINFC_MIFARESTD_NDEFTLV_T;
+        NdefMap->SendRecvBuf[(TempLength - PH_FRINFC_MIFARESTD_VAL1)] =
+            PH_FRINFC_MIFARESTD_NDEFTLV_L;
+        NdefMap->SendRecvBuf[TempLength] =
+            (uint8_t)(NdefMap->TLVStruct.prevLenByteValue >>
+                      PH_FRINFC_MIFARESTD_RIGHTSHIFT8);
+      } else {
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
+      }
+      break;
+
+    default:
+      /* Already the TLV is present so just append the length field */
+      if (NdefMap->TLVStruct.prevLenByteValue >=
+          PH_FRINFC_MIFARESTD_NDEFTLV_L) {
+        /* Update the null TLV, ndef TLV block and ndef TLV byte */
+        NdefMap->TLVStruct.NULLTLVCount = PH_FRINFC_MIFARESTD_VAL0;
+        NdefMap->TLVStruct.NdefTLVBlock =
+            NdefMap->StdMifareContainer.currentBlock;
+        NdefMap->TLVStruct.NdefTLVByte =
+            (TempLength - PH_FRINFC_MIFARESTD_VAL3);
+
+        NdefMap->SendRecvBuf[(TempLength - PH_FRINFC_MIFARESTD_VAL2)] =
+            (uint8_t)PH_FRINFC_MIFARESTD_NDEFTLV_T;
+        NdefMap->SendRecvBuf[(TempLength - PH_FRINFC_MIFARESTD_VAL1)] =
+            (uint8_t)PH_FRINFC_MIFARESTD_NDEFTLV_L;
+        NdefMap->SendRecvBuf[TempLength] =
+            (uint8_t)(NdefMap->TLVStruct.prevLenByteValue >>
+                      PH_FRINFC_MIFARESTD_RIGHTSHIFT8);
+        NdefMap->SendRecvBuf[(TempLength + PH_FRINFC_MIFARESTD_VAL1)] =
+            (uint8_t)NdefMap->TLVStruct.prevLenByteValue;
+      } else {
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
+        NdefMap->SendRecvBuf[(TempLength + PH_FRINFC_MIFARESTD_VAL1)] =
+            (uint8_t)NdefMap->TLVStruct.prevLenByteValue;
+      }
+      NdefMap->StdMifareContainer.RdAfterWrFlag = PH_FRINFC_MIFARESTD_FLAG0;
+      break;
+  }
+
+  return;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_fillTLV2
+ *
+ * Description      This function is updates the length field if more than one
+ *                  NULL TLVs does not exists before the TLV.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void phFriNfc_MifStd_H_fillTLV2(phFriNfc_NdefMap_t* NdefMap) {
+  uint8_t TempLength =
+      (uint8_t)(NdefMap->TLVStruct.NdefTLVByte + PH_FRINFC_MIFARESTD_VAL1);
+
+  NdefMap->TLVStruct.prevLenByteValue =
+      ((NdefMap->Offset == PH_FRINFC_NDEFMAP_SEEK_CUR)
+           ? (NdefMap->TLVStruct.prevLenByteValue + NdefMap->ApduBuffIndex)
+           : NdefMap->ApduBuffIndex);
+  NdefMap->StdMifareContainer.RdAfterWrFlag = PH_FRINFC_MIFARESTD_FLAG1;
+  switch (NdefMap->TLVStruct.NdefTLVByte) {
+    case PH_FRINFC_MIFARESTD_VAL13:
+      if (NdefMap->TLVStruct.prevLenByteValue >=
+          PH_FRINFC_MIFARESTD_NDEFTLV_L) {
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
+        TempLength++;
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_L;
+        TempLength++;
+        NdefMap->SendRecvBuf[TempLength] =
+            (uint8_t)(NdefMap->TLVStruct.prevLenByteValue >>
+                      PH_FRINFC_MIFARESTD_RIGHTSHIFT8);
+      } else {
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NULLTLV_T;
+        TempLength++;
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NULLTLV_T;
+        TempLength++;
+
+        /* Update the null TLV, ndef TLV block and ndef TLV byte */
+        NdefMap->TLVStruct.NULLTLVCount = PH_FRINFC_MIFARESTD_VAL2;
+        NdefMap->TLVStruct.NdefTLVBlock =
+            NdefMap->StdMifareContainer.currentBlock;
+        NdefMap->TLVStruct.NdefTLVByte =
+            (TempLength - PH_FRINFC_MIFARESTD_VAL1);
+
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
+      }
+      break;
+
+    case PH_FRINFC_MIFARESTD_VAL14:
+      if (NdefMap->TLVStruct.prevLenByteValue >=
+          PH_FRINFC_MIFARESTD_NDEFTLV_L) {
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
+        TempLength++;
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_L;
+      } else {
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NULLTLV_T;
+        TempLength++;
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NULLTLV_T;
+      }
+      break;
+
+    case PH_FRINFC_MIFARESTD_VAL15:
+      if (NdefMap->TLVStruct.prevLenByteValue >=
+          PH_FRINFC_MIFARESTD_NDEFTLV_L) {
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
+      } else {
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NULLTLV_T;
+      }
+      break;
+
+    default:
+      if (NdefMap->TLVStruct.prevLenByteValue >=
+          PH_FRINFC_MIFARESTD_NDEFTLV_L) {
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
+        TempLength++;
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_L;
+        TempLength++;
+        NdefMap->SendRecvBuf[TempLength] =
+            (uint8_t)(NdefMap->TLVStruct.prevLenByteValue >>
+                      PH_FRINFC_MIFARESTD_RIGHTSHIFT8);
+        TempLength++;
+        NdefMap->SendRecvBuf[TempLength] =
+            (uint8_t)NdefMap->TLVStruct.prevLenByteValue;
+      } else {
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NULLTLV_T;
+        TempLength++;
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NULLTLV_T;
+        TempLength++;
+
+        /* Update the null TLV, ndef TLV block and ndef TLV byte */
+        NdefMap->TLVStruct.NULLTLVCount = PH_FRINFC_MIFARESTD_VAL2;
+        NdefMap->TLVStruct.NdefTLVBlock =
+            NdefMap->StdMifareContainer.currentBlock;
+        NdefMap->TLVStruct.NdefTLVByte =
+            (TempLength - PH_FRINFC_MIFARESTD_VAL1);
+
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
+        TempLength++;
+        NdefMap->SendRecvBuf[TempLength] =
+            (uint8_t)NdefMap->TLVStruct.prevLenByteValue;
+      }
+      NdefMap->StdMifareContainer.RdAfterWrFlag = PH_FRINFC_MIFARESTD_FLAG0;
+      break;
+  }
+
+  return;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_CallWrNdefLen
+ *
+ * Description      This function is used to increment/decrement the ndef tlv
+ *block
+ *                  and read the block.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_CallWrNdefLen(phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+
+  if (NdefMap->TLVStruct.NULLTLVCount >= PH_FRINFC_MIFARESTD_VAL2) {
+    if ((NdefMap->TLVStruct.NdefTLVByte == PH_FRINFC_MIFARESTD_VAL0) ||
+        (NdefMap->TLVStruct.NdefTLVByte == PH_FRINFC_MIFARESTD_VAL1)) {
+      /* In this case, current block is decremented because the
+         NULL TLVs are in the previous block */
+      NdefMap->StdMifareContainer.currentBlock--;
+      Result = phFriNfc_MifStd_H_BlkChk_1(NdefMap);
+    } else {
+      /* case NdefMap->TLVStruct.NdefTLVByte = PH_FRINFC_MIFARESTD_VAL15:
+         Current block is incremented to update the remaining TLV
+         structure */
+      NdefMap->StdMifareContainer.currentBlock++;
+      Result = phFriNfc_MifStd_H_BlkChk(NdefMap);
+    }
+  } else {
+    if ((NdefMap->TLVStruct.NdefTLVByte == PH_FRINFC_MIFARESTD_VAL13) ||
+        (NdefMap->TLVStruct.NdefTLVByte == PH_FRINFC_MIFARESTD_VAL14) ||
+        (NdefMap->TLVStruct.NdefTLVByte == PH_FRINFC_MIFARESTD_VAL15)) {
+      /* Current block is incremented to update the remaining TLV
+          structure */
+      NdefMap->StdMifareContainer.currentBlock++;
+      Result = phFriNfc_MifStd_H_BlkChk(NdefMap);
+    }
+  }
+
+  Result =
+      ((Result == NFCSTATUS_SUCCESS) ? phFriNfc_MifStd_H_RdtoWrNdefLen(NdefMap)
+                                     : Result);
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_BlkChk_1
+ *
+ * Description      This function check the current block is valid or not
+ *                  if not valid decrement the current block till the valid
+ *block.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_BlkChk_1(phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+  uint8_t SectorID = PH_FRINFC_MIFARESTD_VAL0;
+
+  /* Get a Sector ID for the Current Block */
+  SectorID =
+      phFriNfc_MifStd_H_GetSect(NdefMap->StdMifareContainer.currentBlock);
+
+  /* Check the sector id is valid or not and if valid then check the
+      current block is greater than 128 */
+  if ((NdefMap->StdMifareContainer.aid[SectorID] ==
+       PH_FRINFC_MIFARESTD_NDEF_COMP) &&
+      (((SectorID <= PH_FRINFC_MIFARESTD_VAL15) &&
+        (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_1K_CARD)) ||
+       ((SectorID <= PH_FRINFC_MIFARESTD_SECTOR_NO31) &&
+        (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD)) ||
+       ((SectorID <= PH_FRINFC_MIFARESTD_SECTOR_NO39) &&
+        (NdefMap->CardType == PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD)))) {
+    if (NdefMap->StdMifareContainer.currentBlock > 128) {
+      NdefMap->TLVStruct.NdefTLVAuthFlag =
+          ((((NdefMap->StdMifareContainer.currentBlock +
+              PH_FRINFC_MIFARESTD_VAL1) %
+             PH_FRINFC_MIFARESTD_MAD_BLK16) == PH_FRINFC_MIFARESTD_VAL0)
+               ? PH_FRINFC_MIFARESTD_FLAG1
+               : PH_FRINFC_MIFARESTD_FLAG0);
+
+      NdefMap->StdMifareContainer.currentBlock -=
+          ((((NdefMap->StdMifareContainer.currentBlock +
+              PH_FRINFC_MIFARESTD_VAL1) %
+             PH_FRINFC_MIFARESTD_MAD_BLK16) == PH_FRINFC_MIFARESTD_VAL0)
+               ? PH_FRINFC_MIFARESTD_VAL1
+               : PH_FRINFC_MIFARESTD_VAL0);
+
+    } else {
+      NdefMap->TLVStruct.NdefTLVAuthFlag =
+          ((((NdefMap->StdMifareContainer.currentBlock +
+              PH_FRINFC_MIFARESTD_VAL1) %
+             PH_FRINFC_MIFARESTD_BLK4) == PH_FRINFC_MIFARESTD_VAL0)
+               ? PH_FRINFC_MIFARESTD_FLAG1
+               : PH_FRINFC_MIFARESTD_FLAG0);
+
+      NdefMap->StdMifareContainer.currentBlock -=
+          ((((NdefMap->StdMifareContainer.currentBlock +
+              PH_FRINFC_MIFARESTD_VAL1) %
+             PH_FRINFC_MIFARESTD_BLK4) == PH_FRINFC_MIFARESTD_VAL1)
+               ? PH_FRINFC_MIFARESTD_VAL1
+               : PH_FRINFC_MIFARESTD_VAL0);
+    }
+  } else {
+    /*Error: No Ndef Compliant Sectors present.*/
+    Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_PARAMETER);
+  }
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_fillTLV1_1
+ *
+ * Description      This function updates the length of the TLV if NULL TLVs
+ *                  greater than or equal to 2.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void phFriNfc_MifStd_H_fillTLV1_1(phFriNfc_NdefMap_t* NdefMap) {
+  switch (NdefMap->TLVStruct.NdefTLVByte) {
+    case PH_FRINFC_MIFARESTD_VAL0:
+      /* In the first write ndef length procedure, the
+         length is updated, in this case T and L = 0xFF of TLV are
+         updated */
+      NdefMap->TLVStruct.NULLTLVCount = PH_FRINFC_MIFARESTD_VAL0;
+      NdefMap->TLVStruct.NdefTLVBlock =
+          NdefMap->StdMifareContainer.currentBlock;
+      NdefMap->TLVStruct.NdefTLVByte = PH_FRINFC_MIFARESTD_VAL14;
+
+      NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL15] =
+          PH_FRINFC_MIFARESTD_NDEFTLV_T;
+      NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL16] =
+          PH_FRINFC_MIFARESTD_NDEFTLV_L;
+      break;
+
+    case PH_FRINFC_MIFARESTD_VAL1:
+      /* In the first write ndef length procedure, the
+         length is updated, in this case T of TLV is
+         updated */
+      NdefMap->TLVStruct.NULLTLVCount = PH_FRINFC_MIFARESTD_VAL0;
+      NdefMap->TLVStruct.NdefTLVBlock =
+          NdefMap->StdMifareContainer.currentBlock;
+      NdefMap->TLVStruct.NdefTLVByte = PH_FRINFC_MIFARESTD_VAL15;
+      NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL16] =
+          PH_FRINFC_MIFARESTD_NDEFTLV_T;
+      break;
+
+    case PH_FRINFC_MIFARESTD_VAL15:
+    default:
+      /* In the first ndef write length, part of the L field or only T
+         (if update length is less than 255) is updated */
+      NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL1] =
+          (uint8_t)NdefMap->TLVStruct.prevLenByteValue;
+      break;
+  }
+  NdefMap->StdMifareContainer.RdAfterWrFlag = PH_FRINFC_MIFARESTD_FLAG0;
+
+  return;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_fillTLV2_1
+ *
+ * Description      This function updates the length of the TLV if NULL TLVs
+ *                  less than 2.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void phFriNfc_MifStd_H_fillTLV2_1(phFriNfc_NdefMap_t* NdefMap) {
+  uint8_t TempLength = PH_FRINFC_MIFARESTD_VAL1;
+  switch (NdefMap->TLVStruct.NdefTLVByte) {
+    case PH_FRINFC_MIFARESTD_VAL13:
+      /* In last write ndef length, part of length (L) field of TLV
+         is updated now */
+      NdefMap->SendRecvBuf[TempLength] =
+          (uint8_t)NdefMap->TLVStruct.prevLenByteValue;
+      break;
+
+    case PH_FRINFC_MIFARESTD_VAL14:
+      /* In last write ndef length, part of length (L) field of TLV
+         is updated now */
+      if (NdefMap->TLVStruct.prevLenByteValue >=
+          PH_FRINFC_MIFARESTD_NDEFTLV_L) {
+        NdefMap->SendRecvBuf[TempLength] =
+            (uint8_t)(NdefMap->TLVStruct.prevLenByteValue >>
+                      PH_FRINFC_MIFARESTD_RIGHTSHIFT8);
+        TempLength++;
+        NdefMap->SendRecvBuf[TempLength] =
+            (uint8_t)NdefMap->TLVStruct.prevLenByteValue;
+      } else {
+        NdefMap->TLVStruct.NULLTLVCount = PH_FRINFC_MIFARESTD_VAL2;
+        NdefMap->TLVStruct.NdefTLVBlock =
+            NdefMap->StdMifareContainer.currentBlock;
+        NdefMap->TLVStruct.NdefTLVByte =
+            (TempLength - PH_FRINFC_MIFARESTD_VAL1);
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
+        TempLength++;
+        NdefMap->SendRecvBuf[TempLength] =
+            (uint8_t)NdefMap->TLVStruct.prevLenByteValue;
+      }
+      break;
+
+    case PH_FRINFC_MIFARESTD_VAL15:
+    default:
+      if (NdefMap->TLVStruct.prevLenByteValue >=
+          PH_FRINFC_MIFARESTD_NDEFTLV_L) {
+        /* In last write ndef length, only T of TLV is updated and
+           length (L) field of TLV is updated now */
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_L;
+        TempLength++;
+        NdefMap->SendRecvBuf[TempLength] =
+            (uint8_t)(NdefMap->TLVStruct.prevLenByteValue >>
+                      PH_FRINFC_MIFARESTD_RIGHTSHIFT8);
+        TempLength++;
+        NdefMap->SendRecvBuf[TempLength] =
+            (uint8_t)NdefMap->TLVStruct.prevLenByteValue;
+      } else {
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NULLTLV_T;
+        TempLength++;
+        NdefMap->TLVStruct.NULLTLVCount = PH_FRINFC_MIFARESTD_VAL2;
+        NdefMap->TLVStruct.NdefTLVBlock =
+            NdefMap->StdMifareContainer.currentBlock;
+        NdefMap->TLVStruct.NdefTLVByte =
+            (TempLength - PH_FRINFC_MIFARESTD_VAL1);
+        NdefMap->SendRecvBuf[TempLength] = PH_FRINFC_MIFARESTD_NDEFTLV_T;
+        TempLength++;
+        NdefMap->SendRecvBuf[TempLength] =
+            (uint8_t)NdefMap->TLVStruct.prevLenByteValue;
+      }
+      break;
+  }
+  NdefMap->StdMifareContainer.RdAfterWrFlag = PH_FRINFC_MIFARESTD_FLAG0;
+
+  return;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_RdTLV
+ *
+ * Description      This function reads the TLV block.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_RdTLV(phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+
+  NdefMap->State = PH_FRINFC_NDEFMAP_STATE_RD_TLV;
+  NdefMap->PrevOperation = PH_FRINFC_NDEFMAP_READ_OPE;
+
+  Result = phFriNfc_MifStd_H_Rd16Bytes(
+      NdefMap, NdefMap->StdMifareContainer.currentBlock);
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_ProRdTLV
+ *
+ * Description      This function processes the read TLV block.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_ProRdTLV(phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS Result =
+      PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_DEVICE_REQUEST);
+  uint8_t TempLength = PH_FRINFC_MIFARESTD_VAL0,
+          NDEFFlag = PH_FRINFC_MIFARESTD_FLAG1;
+
+  /*TempLength = (uint8_t)(((NdefMap->TLVStruct.NULLTLVCount >=
+              PH_FRINFC_MIFARESTD_VAL2) &&
+              (NdefMap->TLVStruct.BytesRemainLinTLV > 0xFE))?
+              ((NdefMap->TLVStruct.NdefTLVByte +
+              PH_FRINFC_MIFARESTD_VAL2)%
+              PH_FRINFC_MIFARESTD_VAL16):
+              ((NdefMap->TLVStruct.NdefTLVByte +
+              PH_FRINFC_MIFARESTD_VAL4)%
+              PH_FRINFC_MIFARESTD_VAL16));*/
+
+  TempLength = (uint8_t)(
+      (NdefMap->TLVStruct.BytesRemainLinTLV <= 0xFE)
+          ? ((NdefMap->TLVStruct.NdefTLVByte + PH_FRINFC_MIFARESTD_VAL2) %
+             PH_FRINFC_MIFARESTD_VAL16)
+          : ((NdefMap->TLVStruct.NdefTLVByte + PH_FRINFC_MIFARESTD_VAL4) %
+             PH_FRINFC_MIFARESTD_VAL16));
+
+  if ((*NdefMap->SendRecvLength == PH_FRINFC_MIFARESTD_BYTES_READ) &&
+      (NdefMap->ApduBuffIndex < NdefMap->ApduBufferSize)) {
+    if (NdefMap->TLVStruct.BytesRemainLinTLV != 0) {
+      NDEFFlag = PH_FRINFC_MIFARESTD_FLAG0;
+      /* To read the remaining length (L) in TLV */
+      Result = phFriNfc_MifStd_H_RemainTLV(NdefMap, &NDEFFlag, &TempLength);
+    }
+  }
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_WrTermTLV
+ *
+ * Description      This function is used to write the terminator TLV.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_WrTermTLV(phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+  uint8_t index = PH_FRINFC_MIFARESTD_VAL0;
+
+  /* Change the state to check ndef compliancy */
+  NdefMap->State = PH_FRINFC_NDEFMAP_STATE_TERM_TLV;
+
+  NdefMap->SendRecvBuf[index] = NdefMap->StdMifareContainer.currentBlock;
+  index++;
+  NdefMap->SendRecvBuf[index] = PH_FRINFC_MIFARESTD_TERMTLV_T;
+  index++;
+
+  while (index < PH_FRINFC_MIFARESTD_WR_A_BLK) {
+    NdefMap->SendRecvBuf[index] = PH_FRINFC_MIFARESTD_NULLTLV_T;
+    index++;
+  }
+
+  NdefMap->TLVStruct.SetTermTLVFlag = PH_FRINFC_MIFARESTD_FLAG0;
+
+  Result = phFriNfc_MifStd_H_WrTLV(NdefMap);
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_ProWrABlock
+ *
+ * Description      This function processes the write a block.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_ProWrABlock(phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+
+  NdefMap->StdMifareContainer.WrLength = PH_FRINFC_MIFARESTD_VAL0;
+  if (NdefMap->ApduBuffIndex < (uint16_t)NdefMap->ApduBufferSize) {
+    /* Remaining bytes to write < 16 */
+    if (NdefMap->StdMifareContainer.RemainingBufFlag ==
+        PH_FRINFC_MIFARESTD_FLAG1) {
+      /* Write complete, so next byte shall be */
+      NdefMap->StdMifareContainer.internalLength = *NdefMap->DataCount;
+
+      /* Copy bytes less than 16 to internal buffer
+         for the next write this can be used */
+      memcpy(NdefMap->StdMifareContainer.internalBuf,
+             NdefMap->StdMifareContainer.Buffer,
+             NdefMap->StdMifareContainer.internalLength);
+
+      /* Increment the Send Buffer index */
+      NdefMap->ApduBuffIndex += NdefMap->NumOfBytesWritten;
+
+      NdefMap->StdMifareContainer.remainingSize -= NdefMap->NumOfBytesWritten;
+
+      NdefMap->StdMifareContainer.RemainingBufFlag = PH_FRINFC_MIFARESTD_VAL0;
+      /* Check for the End of Card */
+      NdefMap->StdMifareContainer.ReadWriteCompleteFlag =
+          (uint8_t)((NdefMap->StdMifareContainer.remainingSize ==
+                     PH_FRINFC_MIFARESTD_VAL0)
+                        ? PH_FRINFC_MIFARESTD_FLAG1
+                        : PH_FRINFC_MIFARESTD_FLAG0);
+
+      NdefMap->TLVStruct.SetTermTLVFlag = (uint8_t)(
+          ((NdefMap->StdMifareContainer.remainingSize ==
+            PH_FRINFC_MIFARESTD_VAL0) ||
+           (NdefMap->TLVStruct.SetTermTLVFlag == PH_FRINFC_MIFARESTD_FLAG1))
+              ? PH_FRINFC_MIFARESTD_FLAG1
+              : PH_FRINFC_MIFARESTD_FLAG0);
+
+    } /* internal Buffer > Send Buffer */
+    else if (NdefMap->StdMifareContainer.internalBufFlag ==
+             PH_FRINFC_MIFARESTD_FLAG1) {
+      memcpy(NdefMap->StdMifareContainer.internalBuf,
+             NdefMap->StdMifareContainer.Buffer, *NdefMap->DataCount);
+
+      NdefMap->StdMifareContainer.internalLength = *NdefMap->DataCount;
+
+      /* Increment the Send Buffer index */
+      NdefMap->ApduBuffIndex += NdefMap->NumOfBytesWritten;
+
+      NdefMap->StdMifareContainer.remainingSize -= NdefMap->NumOfBytesWritten;
+
+      NdefMap->StdMifareContainer.internalBufFlag = PH_FRINFC_MIFARESTD_FLAG0;
+      /* Check for the End of Card */
+      NdefMap->StdMifareContainer.ReadWriteCompleteFlag =
+          (uint8_t)(((NdefMap->StdMifareContainer.remainingSize ==
+                      PH_FRINFC_MIFARESTD_VAL0) &&
+                     (NdefMap->StdMifareContainer.internalLength ==
+                      PH_FRINFC_MIFARESTD_VAL0))
+                        ? PH_FRINFC_MIFARESTD_FLAG1
+                        : PH_FRINFC_MIFARESTD_FLAG0);
+
+      NdefMap->TLVStruct.SetTermTLVFlag = (uint8_t)(
+          ((NdefMap->StdMifareContainer.remainingSize ==
+            PH_FRINFC_MIFARESTD_VAL0) ||
+           (NdefMap->TLVStruct.SetTermTLVFlag == PH_FRINFC_MIFARESTD_FLAG1))
+              ? PH_FRINFC_MIFARESTD_FLAG1
+              : PH_FRINFC_MIFARESTD_FLAG0);
+    } else {
+      NdefMap->StdMifareContainer.internalLength = 0;
+      /* Increment the Send Buffer index */
+      NdefMap->ApduBuffIndex += NdefMap->NumOfBytesWritten;
+      NdefMap->StdMifareContainer.remainingSize -= NdefMap->NumOfBytesWritten;
+
+      /* Check for the End of Card */
+      if ((NdefMap->StdMifareContainer.remainingSize ==
+           PH_FRINFC_MIFARESTD_VAL0) ||
+          (NdefMap->ApduBuffIndex == NdefMap->ApduBufferSize)) {
+        NdefMap->StdMifareContainer.ReadWriteCompleteFlag =
+            (uint8_t)((NdefMap->StdMifareContainer.remainingSize == 0)
+                          ? PH_FRINFC_MIFARESTD_FLAG1
+                          : PH_FRINFC_MIFARESTD_FLAG0);
+
+        if (NdefMap->StdMifareContainer.internalLength ==
+            PH_FRINFC_MIFARESTD_VAL0) {
+          NdefMap->StdMifareContainer.currentBlock++;
+          /* Mifare 4k Card, After 128th Block
+          each sector = 16 blocks in Mifare 4k */
+          Result = ((NdefMap->StdMifareContainer.remainingSize == 0)
+                        ? Result
+                        : phFriNfc_MifStd_H_BlkChk(NdefMap));
+          NdefMap->StdMifareContainer.NdefBlocks++;
+        }
+        NdefMap->TLVStruct.SetTermTLVFlag = (uint8_t)(
+            ((NdefMap->StdMifareContainer.remainingSize ==
+              PH_FRINFC_MIFARESTD_VAL0) ||
+             (NdefMap->TLVStruct.SetTermTLVFlag == PH_FRINFC_MIFARESTD_FLAG1))
+                ? PH_FRINFC_MIFARESTD_FLAG1
+                : PH_FRINFC_MIFARESTD_FLAG0);
+      } else {
+        NdefMap->StdMifareContainer.currentBlock++;
+        NdefMap->StdMifareContainer.WrLength =
+            (uint16_t)(NdefMap->ApduBufferSize - NdefMap->ApduBuffIndex);
+        /* Mifare 4k Card, After 128th Block
+        each sector = 16 blocks in Mifare 4k */
+        Result = phFriNfc_MifStd_H_BlkChk(NdefMap);
+        if (Result == NFCSTATUS_SUCCESS) {
+          NdefMap->StdMifareContainer.NdefBlocks++;
+          Result = ((NdefMap->StdMifareContainer.AuthDone ==
+                     PH_FRINFC_MIFARESTD_FLAG1)
+                        ? phFriNfc_MifStd_H_WrABlock(NdefMap)
+                        : phFriNfc_MifStd_H_AuthSector(NdefMap));
+        }
+      }
+    }
+  } else {
+    Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_DEVICE_REQUEST);
+  }
+
+  if ((Result == NFCSTATUS_SUCCESS) &&
+      (NdefMap->TLVStruct.SetTermTLVFlag != PH_FRINFC_MIFARESTD_FLAG1) &&
+      (NdefMap->StdMifareContainer.remainingSize > PH_FRINFC_MIFARESTD_VAL0)) {
+    Result = phFriNfc_MifStd_H_WrTermTLV(NdefMap);
+  } else {
+    if ((Result == NFCSTATUS_SUCCESS) &&
+        (NdefMap->TLVStruct.SetTermTLVFlag == PH_FRINFC_MIFARESTD_FLAG1)) {
+      /* Write the length to the L field in the TLV */
+      NdefMap->StdMifareContainer.TempBlockNo =
+          NdefMap->StdMifareContainer.currentBlock;
+      phFriNfc_MifStd_H_SetNdefBlkAuth(NdefMap);
+      NdefMap->StdMifareContainer.currentBlock =
+          NdefMap->TLVStruct.NdefTLVBlock;
+      Result = phFriNfc_MifStd_H_RdtoWrNdefLen(NdefMap);
+    }
+  }
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_CallDisCon
+ *
+ * Description      This function trigger disconnect after the authentication
+ *                  has failed.
+ *
+ * Returns          This function return NFCSTATUS_PENDING in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_CallDisCon(phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+
+  /* Set Ndef State */
+  NdefMap->State = PH_FRINFC_NDEFMAP_STATE_DISCONNECT;
+  NdefMap->MapCompletionInfo.CompletionRoutine = phFriNfc_MifareStdMap_Process;
+  NdefMap->MapCompletionInfo.Context = NdefMap;
+
+  Result = phNxNciExtns_MifareStd_Reconnect();
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_CallConnect
+ *
+ * Description      This function sets card state to connect after the
+ *                  authentication has failed.
+ *
+ * Returns          NFCSTATUS_SUCCESS
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_CallConnect(phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+
+  /* Set Ndef State */
+  NdefMap->State = PH_FRINFC_NDEFMAP_STATE_CONNECT;
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd1k_H_BlkChk
+ *
+ * Description      This function used to update the current block.
+ *
+ * Returns          void
+ *
+ ******************************************************************************/
+static void phFriNfc_MifStd1k_H_BlkChk(phFriNfc_NdefMap_t* NdefMap,
+                                       uint8_t SectorID, uint8_t* callbreak) {
+  /* every last block of a sector needs to be skipped */
+  if (((NdefMap->StdMifareContainer.currentBlock + PH_FRINFC_MIFARESTD_INC_1) %
+       PH_FRINFC_MIFARESTD_BLK4) == 0) {
+    NdefMap->StdMifareContainer.currentBlock++;
+  } else {
+    if (NdefMap->StdMifareContainer.aid[SectorID] ==
+        PH_FRINFC_MIFARESTD_NDEF_COMP) {
+      /* Check whether the block is first block of a (next)new sector and
+      also check if it is first block then internal length is zero
+      or not. Because once Authentication is done for the sector again
+      we should not authenticate it again */
+      if ((NdefMap->StdMifareContainer.currentBlock ==
+           (SectorID * PH_FRINFC_MIFARESTD_BLK4)) &&
+          (NdefMap->StdMifareContainer.internalLength == 0)) {
+        NdefMap->StdMifareContainer.AuthDone = 0;
+      }
+      *callbreak = 1;
+    } else {
+      NdefMap->StdMifareContainer.currentBlock += PH_FRINFC_MIFARESTD_BLK4;
+    }
+  }
+
+  return;
+}
+
+/******************************************************************************
+ * Function         phFrinfc_MifareClassic_GetContainerSize
+ *
+ * Description      This function calculate the card size.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+NFCSTATUS phFrinfc_MifareClassic_GetContainerSize(
+    const phFriNfc_NdefMap_t* NdefMap, uint32_t* maxSize,
+    uint32_t* actualSize) {
+  NFCSTATUS result = NFCSTATUS_SUCCESS;
+  uint16_t valid_no_of_bytes = 0;
+  uint8_t sect_aid_index = 0;
+  /*  Mifare std card */
+
+  /*  Max size is the number of NDEF compliant blocks in the card
+      multiplied by 16 bytes */
+
+  /* Skip all the non ndef sectors */
+  while ((sect_aid_index < PH_FRINFC_NDEFMAP_MIFARESTD_TOTALNO_BLK) &&
+         (PH_FRINFC_MIFARESTD_NON_NDEF_COMP ==
+          NdefMap->StdMifareContainer.aid[sect_aid_index])) {
+    sect_aid_index++;
+  }
+
+  /* Parse only the contiguous NDEF sectors for the max size calculation */
+  while ((sect_aid_index < PH_FRINFC_NDEFMAP_MIFARESTD_TOTALNO_BLK) &&
+         (PH_FRINFC_MIFARESTD_NDEF_COMP ==
+          NdefMap->StdMifareContainer.aid[sect_aid_index])) {
+    if (((PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD == NdefMap->CardType) ||
+         (PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD == NdefMap->CardType)) &&
+        (sect_aid_index >= 32)) {
+      /* Mifare classic card of 4k size, sector >= 32 has
+         16 blocks per sector and in that 15 blocks are valid data blocks
+         16 is the block number in a sector
+         15 is the number of valid data blocks in a sector
+       */
+      valid_no_of_bytes += (uint16_t)(16 * 15);
+    } else {
+      valid_no_of_bytes += (uint16_t)(16 * 3);
+    }
+
+    sect_aid_index++;
+    if (16 == sect_aid_index) {
+      /* Because sector index is 16, that is "MAD 2" block
+         For calculating size MAD block shall be ignored
+       */
+      sect_aid_index++;
+    }
+  }
+  /* The below check is for the 3 byte length format of the NDEF TLV
+     If the length field > 255, Max size will less by 4
+     else Max size will less by 2 (Type and Length of the NDEF TLV
+     has to be skipped to provide the maximum size in the card */
+  *maxSize = (valid_no_of_bytes > 0xFF) ? (valid_no_of_bytes - 4)
+                                        : (valid_no_of_bytes - 2);
+
+  *actualSize = NdefMap->TLVStruct.BytesRemainLinTLV;
+
+  return result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifareStdMap_ConvertToReadOnly
+ *
+ * Description      This function converts the Mifare card to read-only.
+ *                  It check preconditions before converting to read only.
+ *
+ * Returns          This function return NFCSTATUS_PENDING in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+NFCSTATUS
+phFriNfc_MifareStdMap_ConvertToReadOnly(phFriNfc_NdefMap_t* NdefMap,
+                                        const uint8_t* ScrtKeyB) {
+  NFCSTATUS result = NFCSTATUS_SUCCESS;
+  uint8_t totalNoSectors = 0, sectorTrailerBlockNo = 0;
+
+  if (NdefMap == NULL) {
+    result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_PARAMETER);
+  } else if (PH_NDEFMAP_CARD_STATE_INVALID == NdefMap->CardState) {
+    result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_STATE);
+  } else {
+    /* card state is PH_NDEFMAP_CARD_STATE_READ_WRITE now */
+    /* get AID  array and parse */
+    if (PH_FRINFC_NDEFMAP_MIFARE_STD_1K_CARD == NdefMap->CardType) {
+      totalNoSectors = PH_FRINFC_MIFARESTD1K_TOTAL_SECTOR;
+    } else if (PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD == NdefMap->CardType) {
+      totalNoSectors = PH_FRINFC_MIFARESTD2K_TOTAL_SECTOR;
+    } else if (PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD == NdefMap->CardType) {
+      totalNoSectors = PH_FRINFC_MIFARESTD4K_TOTAL_SECTOR;
+    }
+
+    /* Store Key B in the context */
+    if (ScrtKeyB == NULL) {
+      memset(NdefMap->StdMifareContainer.UserScrtKeyB,
+             PH_FRINFC_MIFARESTD_DEFAULT_KEY, PH_FRINFC_MIFARESTD_KEY_LEN);
+    } else {
+      memcpy(NdefMap->StdMifareContainer.UserScrtKeyB, ScrtKeyB,
+             PH_FRINFC_MIFARESTD_KEY_LEN);
+    }
+
+    NdefMap->StdMifareContainer.TotalNoSectors = totalNoSectors;
+    if (totalNoSectors == 0) {
+      result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_PARAMETER);
+    } else {
+      NdefMap->TLVStruct.NdefTLVFoundFlag = PH_FRINFC_MIFARESTD_FLAG0;
+      NdefMap->StdMifareContainer.RdBeforeWrFlag = PH_FRINFC_MIFARESTD_FLAG0;
+      NdefMap->StdMifareContainer.WrNdefFlag = PH_FRINFC_MIFARESTD_FLAG0;
+      NdefMap->StdMifareContainer.internalLength = PH_FRINFC_MIFARESTD_VAL0;
+      NdefMap->StdMifareContainer.RdAfterWrFlag = PH_FRINFC_MIFARESTD_FLAG0;
+      NdefMap->StdMifareContainer.AuthDone = PH_FRINFC_MIFARESTD_FLAG0;
+      NdefMap->StdMifareContainer.NFCforumSectFlag = PH_FRINFC_MIFARESTD_FLAG0;
+      NdefMap->StdMifareContainer.WriteAcsBitFlag = PH_FRINFC_MIFARESTD_FLAG0;
+
+      /* Sector 0 is MAD sector .Start from Sector 1 */
+      for (NdefMap->StdMifareContainer.ReadOnlySectorIndex =
+               PH_FRINFC_MIFARESTD_FLAG1;
+           NdefMap->StdMifareContainer.ReadOnlySectorIndex < totalNoSectors;
+           NdefMap->StdMifareContainer.ReadOnlySectorIndex++) {
+        /* skip MAD sectors */
+        if (PH_FRINFC_MIFARESTD_SECTOR_NO16 ==
+            NdefMap->StdMifareContainer.ReadOnlySectorIndex) {
+          continue;
+        }
+
+        /* if not NDEF compliant skip  */
+        if (PH_FRINFC_MIFARESTD_NON_NDEF_COMP ==
+            NdefMap->StdMifareContainer
+                .aid[NdefMap->StdMifareContainer.ReadOnlySectorIndex]) {
+          continue;
+        }
+
+        if (PH_FRINFC_MIFARESTD_NDEF_COMP ==
+            NdefMap->StdMifareContainer
+                .aid[NdefMap->StdMifareContainer.ReadOnlySectorIndex]) {
+          /*get the sector trailer block number */
+          sectorTrailerBlockNo = phFriNfc_MifStd_H_GetSectorTrailerBlkNo(
+              NdefMap->StdMifareContainer.ReadOnlySectorIndex);
+          NdefMap->StdMifareContainer.currentBlock = sectorTrailerBlockNo;
+          NdefMap->StdMifareContainer.SectorTrailerBlockNo =
+              sectorTrailerBlockNo;
+
+          /* Proceed to authenticate the sector with Key B
+             and  modify the sector trailor bits to make it read only*/
+          result = phFriNfc_MifStd_H_AuthSector(NdefMap);
+
+          if (result == NFCSTATUS_PENDING) {
+            break;
+          }
+        }
+      } /* end for */
+
+      /* There are no NDEF sectors in this card , return */
+      if (NdefMap->StdMifareContainer.ReadOnlySectorIndex == totalNoSectors &&
+          NFCSTATUS_PENDING != result) {
+        result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_NO_NDEF_SUPPORT);
+      }
+    } /* end else */
+  }
+
+  return result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_GetSectorTrailerBlkNo
+ *
+ * Description      This function returns the block number of the sector
+ *                  trailor for the given sector trailer Id.
+ *
+ * Returns          uint8_t sectorTrailerblockNumber : sector trailor
+ *
+ ******************************************************************************/
+static uint8_t phFriNfc_MifStd_H_GetSectorTrailerBlkNo(uint8_t SectorID) {
+  uint8_t sectorTrailerblockNumber = 0;
+
+  /* every last block of a sector needs to be skipped */
+  if (SectorID < PH_FRINFC_MIFARESTD_SECTOR_NO32) {
+    sectorTrailerblockNumber = (SectorID * PH_FRINFC_MIFARESTD_BLK4) + 3;
+  } else {
+    sectorTrailerblockNumber =
+        ((PH_FRINFC_MIFARESTD_SECTOR_NO32 * PH_FRINFC_MIFARESTD_BLK4) +
+         ((SectorID - PH_FRINFC_MIFARESTD_SECTOR_NO32) *
+          PH_FRINFC_MIFARESTD_SECTOR_BLOCKS)) +
+        15;
+  }
+
+  return sectorTrailerblockNumber;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_ProSectorTrailorAcsBits
+ *
+ * Description      This function is called during ConvertToReadonly process to
+ *                  Authenticate NDEF compliant Sector.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_ProSectorTrailorAcsBits(
+    phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS Result = NFCSTATUS_SUCCESS;
+
+  if (*NdefMap->SendRecvLength == PH_FRINFC_MIFARESTD_BYTES_READ) {
+    if (NdefMap->StdMifareContainer.ReadAcsBitFlag ==
+        PH_FRINFC_MIFARESTD_FLAG1) {
+      /* check for the correct access bits */
+      Result = phFriNfc_MifStd_H_ChkAcsBit(NdefMap);
+      if (Result == NFCSTATUS_SUCCESS) {
+        if (NdefMap->CardState == PH_NDEFMAP_CARD_STATE_READ_ONLY) {
+          /* Go to next sector */
+          Result = phFriNfc_MifStd_H_ProWrSectorTrailor(NdefMap);
+        } else {
+          /* tranceive to write the data into SendRecvBuff */
+          Result = phFriNfc_MifStd_H_WrSectorTrailorBlock(NdefMap);
+        }
+      }
+    }
+  } else {
+    Result = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_PARAMETER);
+  }
+
+  return Result;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_WrSectorTrailorBlock
+ *
+ * Description      This function makes current NDEF compliant Sector ReadOnly
+ *                  modify the sector trailor bits and write it to the card.
+ *
+ * Returns          This function return NFCSTATUS_PENDING in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_WrSectorTrailorBlock(
+    phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS status = NFCSTATUS_PENDING;
+
+  NdefMap->MapCompletionInfo.CompletionRoutine = phFriNfc_MifareStdMap_Process;
+  NdefMap->MapCompletionInfo.Context = NdefMap;
+  NdefMap->PrevOperation = PH_FRINFC_NDEFMAP_WRITE_OPE;
+
+  /* next state (update sector index) */
+  NdefMap->State = PH_FRINFC_NDEFMAP_STATE_WRITE_SEC;
+
+  /* Buffer Check */
+  if (NdefMap->SendRecvBuf != NULL) {
+    NdefMap->SendRecvBuf[10] = 0x00;
+    NdefMap->SendRecvBuf[10] = NdefMap->SendRecvBuf[9] |
+                               PH_FRINFC_MIFARESTD_MASK_GPB_WR; /* WR bits 11*/
+
+    /*The NdefMap->SendRecvBuf already has the sector trailor.
+    modify the bits to make Read Only */
+    NdefMap->SendRecvBuf[1] =
+        PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_NDEFSECT1; /* 0xD3 */
+    NdefMap->SendRecvBuf[2] =
+        PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_NDEFSECT2; /* 0xF7 */
+    NdefMap->SendRecvBuf[3] =
+        PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_NDEFSECT1; /* 0xD3 */
+    NdefMap->SendRecvBuf[4] =
+        PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_NDEFSECT2; /* 0xF7 */
+    NdefMap->SendRecvBuf[5] =
+        PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_NDEFSECT1; /* 0xD3 */
+    NdefMap->SendRecvBuf[6] =
+        PH_FRINFC_NDEFMAP_MIFARESTD_AUTH_NDEFSECT2; /* 0xF7 */
+
+    NdefMap->SendRecvBuf[7] =
+        PH_FRINFC_MIFARESTD_NFCSECT_RDACS_BYTE6; /* 0x0F */
+    NdefMap->SendRecvBuf[8] =
+        PH_FRINFC_MIFARESTD_NFCSECT_RDACS_BYTE7; /* 0x07 */
+    NdefMap->SendRecvBuf[9] =
+        PH_FRINFC_MIFARESTD_NFCSECT_RDACS_BYTE8; /* 0x8F */
+
+    NdefMap->SendRecvBuf[11] = NdefMap->StdMifareContainer.UserScrtKeyB[0];
+    NdefMap->SendRecvBuf[12] = NdefMap->StdMifareContainer.UserScrtKeyB[1];
+    NdefMap->SendRecvBuf[13] = NdefMap->StdMifareContainer.UserScrtKeyB[2];
+    NdefMap->SendRecvBuf[14] = NdefMap->StdMifareContainer.UserScrtKeyB[3];
+    NdefMap->SendRecvBuf[15] = NdefMap->StdMifareContainer.UserScrtKeyB[4];
+    NdefMap->SendRecvBuf[16] = NdefMap->StdMifareContainer.UserScrtKeyB[5];
+
+    /* Write to Ndef Sector Block */
+    NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL0] =
+        NdefMap->StdMifareContainer.currentBlock;
+
+    /* Copy Ndef Sector Block into buffer */
+    memcpy(NdefMap->StdMifareContainer.Buffer,
+           &(NdefMap->SendRecvBuf[PH_FRINFC_MIFARESTD_VAL1]),
+           PH_FRINFC_MIFARESTD_BLOCK_BYTES);
+
+    /* Write from here */
+    NdefMap->SendLength = MIFARE_MAX_SEND_BUF_TO_WRITE;
+    NdefMap->Cmd.MfCmd = phHal_eMifareWrite16;
+    *NdefMap->SendRecvLength = NdefMap->TempReceiveLength;
+
+    /* Call the Overlapped HAL Transceive function */
+    status = phFriNfc_ExtnsTransceive(NdefMap->pTransceiveInfo, NdefMap->Cmd,
+                                      NdefMap->SendRecvBuf, NdefMap->SendLength,
+                                      NdefMap->SendRecvLength);
+  } else {
+    /* Error: The control should not ideally come here.
+       Return Error.*/
+    status = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_FAILED);
+  }
+
+  return status;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_ProWrSectorTrailor
+ *
+ * Description      This function makes next NDEF compliant Sector ReadOnly.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MifStd_H_ProWrSectorTrailor(
+    phFriNfc_NdefMap_t* NdefMap) {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  uint8_t sectorTrailerBlockNo = 0;
+
+  /*Increment Sector Index */
+  NdefMap->StdMifareContainer.ReadOnlySectorIndex++;
+
+  /* skip if MAD2 */
+  if (PH_FRINFC_MIFARESTD_SECTOR_NO16 ==
+      NdefMap->StdMifareContainer.ReadOnlySectorIndex) {
+    NdefMap->StdMifareContainer.ReadOnlySectorIndex++;
+  }
+
+  /* if current sector index exceeds total sector index then
+     all ndef sectors are made readonly then return success
+     If a NON def sector is encountered return success*/
+  if (NdefMap->StdMifareContainer.ReadOnlySectorIndex >=
+          NdefMap->StdMifareContainer.TotalNoSectors ||
+      PH_FRINFC_MIFARESTD_NON_NDEF_COMP ==
+          NdefMap->StdMifareContainer
+              .aid[NdefMap->StdMifareContainer.ReadOnlySectorIndex]) {
+    status = NFCSTATUS_SUCCESS;
+  } else if (PH_FRINFC_MIFARESTD_NDEF_COMP ==
+             NdefMap->StdMifareContainer
+                 .aid[NdefMap->StdMifareContainer.ReadOnlySectorIndex]) {
+    /* Convert next NDEF sector to read only */
+    sectorTrailerBlockNo = phFriNfc_MifStd_H_GetSectorTrailerBlkNo(
+        NdefMap->StdMifareContainer.ReadOnlySectorIndex);
+    NdefMap->StdMifareContainer.currentBlock = sectorTrailerBlockNo;
+    NdefMap->StdMifareContainer.SectorTrailerBlockNo = sectorTrailerBlockNo;
+
+    status = phFriNfc_MifStd_H_AuthSector(NdefMap);
+  }
+
+  return status;
+}
+
+/******************************************************************************
+ * Function         phFriNfc_MifStd_H_ProWrSectorTrailor
+ *
+ * Description      This function checks mapping spec version.
+ *
+ * Returns          This function return NFCSTATUS_SUCCESS in case of success
+ *                  In case of failure returns other failure value.
+ *
+ ******************************************************************************/
+static NFCSTATUS phFriNfc_MapTool_ChkSpcVer(const phFriNfc_NdefMap_t* NdefMap,
+                                            uint8_t VersionIndex) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+
+  uint8_t TagVerNo = NdefMap->SendRecvBuf[VersionIndex];
+
+  if (TagVerNo == 0) {
+    /* Return Status Error invalid format */
+    status = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_FORMAT);
+  } else {
+    switch (NdefMap->CardType) {
+      case PH_FRINFC_NDEFMAP_MIFARE_STD_1K_CARD:
+      case PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD:
+      case PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD: {
+        /* calculate the major and minor version number of Mifare std version
+         * number */
+        status =
+            ((((PH_NFCFRI_MFSTDMAP_NFCDEV_MAJOR_VER_NUM ==
+                PH_NFCFRI_MFSTDMAP_GET_MAJOR_TAG_VERNO(TagVerNo)) &&
+               (PH_NFCFRI_MFSTDMAP_NFCDEV_MINOR_VER_NUM ==
+                PH_NFCFRI_MFSTDMAP_GET_MINOR_TAG_VERNO(TagVerNo))) ||
+              ((PH_NFCFRI_MFSTDMAP_NFCDEV_MAJOR_VER_NUM ==
+                PH_NFCFRI_MFSTDMAP_GET_MAJOR_TAG_VERNO(TagVerNo)) &&
+               (PH_NFCFRI_MFSTDMAP_NFCDEV_MINOR_VER_NUM <
+                PH_NFCFRI_MFSTDMAP_GET_MINOR_TAG_VERNO(TagVerNo))))
+                 ? NFCSTATUS_SUCCESS
+                 : PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_FORMAT));
+        break;
+      }
+
+      default: {
+        /* calculate the major and minor version number of T3VerNo */
+        if (((PH_NFCFRI_NDEFMAP_NFCDEV_MAJOR_VER_NUM ==
+              PH_NFCFRI_NDEFMAP_GET_MAJOR_TAG_VERNO(TagVerNo)) &&
+             (PH_NFCFRI_NDEFMAP_NFCDEV_MINOR_VER_NUM ==
+              PH_NFCFRI_NDEFMAP_GET_MINOR_TAG_VERNO(TagVerNo))) ||
+            ((PH_NFCFRI_NDEFMAP_NFCDEV_MAJOR_VER_NUM ==
+              PH_NFCFRI_NDEFMAP_GET_MAJOR_TAG_VERNO(TagVerNo)) &&
+             (PH_NFCFRI_NDEFMAP_NFCDEV_MINOR_VER_NUM <
+              PH_NFCFRI_NDEFMAP_GET_MINOR_TAG_VERNO(TagVerNo)))) {
+          status = PHNFCSTVAL(CID_NFC_NONE, NFCSTATUS_SUCCESS);
+        } else {
+          if ((PH_NFCFRI_NDEFMAP_NFCDEV_MAJOR_VER_NUM <
+               PH_NFCFRI_NDEFMAP_GET_MAJOR_TAG_VERNO(TagVerNo)) ||
+              (PH_NFCFRI_NDEFMAP_NFCDEV_MAJOR_VER_NUM >
+               PH_NFCFRI_NDEFMAP_GET_MAJOR_TAG_VERNO(TagVerNo))) {
+            status = PHNFCSTVAL(CID_FRI_NFC_NDEF_MAP, NFCSTATUS_INVALID_FORMAT);
+          }
+        }
+        break;
+      }
+    }
+  }
+
+  return (status);
+}
diff --git a/nci/jni/extns/pn54x/src/mifare/phFriNfc_MifareStdMap.h b/nci/jni/extns/pn54x/src/mifare/phFriNfc_MifareStdMap.h
index e717dd74..f679a657 100644
--- a/nci/jni/extns/pn54x/src/mifare/phFriNfc_MifareStdMap.h
+++ b/nci/jni/extns/pn54x/src/mifare/phFriNfc_MifareStdMap.h
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
- /*
+/*
  * NFC Ndef Mapping For Remote Devices.
  */
 
@@ -22,197 +22,226 @@
 #define PHFRINFC_MIFARESTDMAP_H
 
 #include <phFriNfc.h>
+#include <phFriNfc_NdefMap.h>
 #include <phNfcStatus.h>
 #include <phNfcTypes.h>
-#include <phFriNfc_NdefMap.h>
 
 /* NFC Device Major and Minor Version numbers */
-/* !!CAUTION!! these needs to be updated periodically.Major and Minor version numbers
-   should be compatible to the version number of currently implemented mapping document.
+/* !!CAUTION!! these needs to be updated periodically.Major and Minor version
+   numbers
+   should be compatible to the version number of currently implemented mapping
+   document.
    Example : NFC Device version Number : 1.0 , specifies
               Major VNo is 1,
               Minor VNo is 0 */
-#define PH_NFCFRI_NDEFMAP_NFCDEV_MAJOR_VER_NUM             0x01
-#define PH_NFCFRI_NDEFMAP_NFCDEV_MINOR_VER_NUM             0x00
-#define PH_NFCFRI_MFSTDMAP_NFCDEV_MAJOR_VER_NUM            0x40
-#define PH_NFCFRI_MFSTDMAP_NFCDEV_MINOR_VER_NUM            0x00
-
-/* Macros to find major and minor TAG : Ex:Type1/Type2/Type3/Type4 version numbers */
-#define PH_NFCFRI_MFSTDMAP_GET_MAJOR_TAG_VERNO(a)          ((a) & (0x40)) /* must be 0xC0 */
-#define PH_NFCFRI_MFSTDMAP_GET_MINOR_TAG_VERNO(a)          ((a) & (0x30))
-
-/* Macros to find major and minor TAG : Ex:Type1/Type2/Type3/Type4 version numbers */
-#define PH_NFCFRI_NDEFMAP_GET_MAJOR_TAG_VERNO(a)           (((a) & (0xf0))>>(4))
-#define PH_NFCFRI_NDEFMAP_GET_MINOR_TAG_VERNO(a)           ((a) & (0x0f))
+#define PH_NFCFRI_NDEFMAP_NFCDEV_MAJOR_VER_NUM 0x01
+#define PH_NFCFRI_NDEFMAP_NFCDEV_MINOR_VER_NUM 0x00
+#define PH_NFCFRI_MFSTDMAP_NFCDEV_MAJOR_VER_NUM 0x40
+#define PH_NFCFRI_MFSTDMAP_NFCDEV_MINOR_VER_NUM 0x00
+
+/* Macros to find major and minor TAG : Ex:Type1/Type2/Type3/Type4 version
+ * numbers */
+#define PH_NFCFRI_MFSTDMAP_GET_MAJOR_TAG_VERNO(a) \
+  ((a) & (0x40)) /* must be 0xC0 */
+#define PH_NFCFRI_MFSTDMAP_GET_MINOR_TAG_VERNO(a) ((a) & (0x30))
+
+/* Macros to find major and minor TAG : Ex:Type1/Type2/Type3/Type4 version
+ * numbers */
+#define PH_NFCFRI_NDEFMAP_GET_MAJOR_TAG_VERNO(a) (((a) & (0xf0)) >> (4))
+#define PH_NFCFRI_NDEFMAP_GET_MINOR_TAG_VERNO(a) ((a) & (0x0f))
 
 /* NDEF Mapping - states of the Finite State machine */
-#define PH_FRINFC_NDEFMAP_STATE_INIT                        0   /* Init state. The start-up state */
-#define PH_FRINFC_NDEFMAP_STATE_READ                        1   /* Read State */
-#define PH_FRINFC_NDEFMAP_STATE_WRITE                       2   /* Write is going on*/
-#define PH_FRINFC_NDEFMAP_STATE_AUTH                        3   /* Authenticate is going on*/
-#define PH_FRINFC_NDEFMAP_STATE_CHK_NDEF_COMP               4   /* Check Ndef is going on */
-#define PH_FRINFC_NDEFMAP_STATE_RD_ACS_BIT                  5   /* Read access bit is in progress */
-#define PH_FRINFC_NDEFMAP_STATE_WR_NDEF_LEN                 6   /* Write NDEF TLV LEngth*/
-#define PH_FRINFC_NDEFMAP_STATE_RD_TO_WR_NDEF_LEN           7   /* read to write the Ndef TLV*/
-#define PH_FRINFC_NDEFMAP_STATE_GET_ACT_CARDSIZE            8   /* Get the card size */
-#define PH_FRINFC_NDEFMAP_STATE_RD_BEF_WR                   9   /* Read the NDEF TLV block before starting write */
-#define PH_FRINFC_NDEFMAP_STATE_WR_TLV                      10  /* Read the NDEF TLV block before starting write */
-#define PH_FRINFC_NDEFMAP_STATE_RD_TLV                      11  /* Read the NDEF TLV block */
-#define PH_FRINFC_NDEFMAP_STATE_TERM_TLV                    12  /* Write terminator TLV block */
-#define PH_FRINFC_NDEFMAP_STATE_POLL                        13  /* Poll in progress */
-#define PH_FRINFC_NDEFMAP_STATE_DISCONNECT                  14  /* Disconnect in progress */
-#define PH_FRINFC_NDEFMAP_STATE_CONNECT                     15  /* Connect in progress */
-
-#define PH_FRINFC_NDEFMAP_STATE_RD_SEC_ACS_BIT              16  /* Convert to ReadOnly in progress */
-#define PH_FRINFC_NDEFMAP_STATE_WRITE_SEC                   17  /* Convert to ReadOnly in progress */
-
+#define PH_FRINFC_NDEFMAP_STATE_INIT 0  /* Init state. The start-up state */
+#define PH_FRINFC_NDEFMAP_STATE_READ 1  /* Read State */
+#define PH_FRINFC_NDEFMAP_STATE_WRITE 2 /* Write is going on*/
+#define PH_FRINFC_NDEFMAP_STATE_AUTH 3  /* Authenticate is going on*/
+#define PH_FRINFC_NDEFMAP_STATE_CHK_NDEF_COMP 4 /* Check Ndef is going on */
+#define PH_FRINFC_NDEFMAP_STATE_RD_ACS_BIT \
+  5 /* Read access bit is in progress */
+#define PH_FRINFC_NDEFMAP_STATE_WR_NDEF_LEN 6 /* Write NDEF TLV LEngth*/
+#define PH_FRINFC_NDEFMAP_STATE_RD_TO_WR_NDEF_LEN \
+  7 /* read to write the Ndef TLV*/
+#define PH_FRINFC_NDEFMAP_STATE_GET_ACT_CARDSIZE 8 /* Get the card size */
+#define PH_FRINFC_NDEFMAP_STATE_RD_BEF_WR \
+  9 /* Read the NDEF TLV block before starting write */
+#define PH_FRINFC_NDEFMAP_STATE_WR_TLV \
+  10 /* Read the NDEF TLV block before starting write */
+#define PH_FRINFC_NDEFMAP_STATE_RD_TLV 11     /* Read the NDEF TLV block */
+#define PH_FRINFC_NDEFMAP_STATE_TERM_TLV 12   /* Write terminator TLV block */
+#define PH_FRINFC_NDEFMAP_STATE_POLL 13       /* Poll in progress */
+#define PH_FRINFC_NDEFMAP_STATE_DISCONNECT 14 /* Disconnect in progress */
+#define PH_FRINFC_NDEFMAP_STATE_CONNECT 15    /* Connect in progress */
+
+#define PH_FRINFC_NDEFMAP_STATE_RD_SEC_ACS_BIT \
+  16 /* Convert to ReadOnly in progress */
+#define PH_FRINFC_NDEFMAP_STATE_WRITE_SEC \
+  17 /* Convert to ReadOnly in progress */
 
 /* Mifare Standard - NDEF Compliant Flags */
-#define PH_FRINFC_MIFARESTD_NDEF_COMP                       0   /* Sector is NDEF Compliant */
-#define PH_FRINFC_MIFARESTD_NON_NDEF_COMP                   1   /* Sector is not NDEF Compliant */
+#define PH_FRINFC_MIFARESTD_NDEF_COMP 0     /* Sector is NDEF Compliant */
+#define PH_FRINFC_MIFARESTD_NON_NDEF_COMP 1 /* Sector is not NDEF Compliant */
 
 /*  Mifare Standard - NDEF Compliant Flag */
-#define PH_FRINFC_MIFARESTD_PROP_1ST_CONFIG                 0   /* No proprietary forum sector found */
-#define PH_FRINFC_MIFARESTD_PROP_2ND_CONFIG                 1   /* Here the proprietary
-                                                                   forum sector exists after NFC forum
-                                                                   sector */
-#define PH_FRINFC_MIFARESTD_PROP_3RD_CONFIG                 2   /* Here the proprietary forum sector exists before
-                                                                   NFC forum sector */
+#define PH_FRINFC_MIFARESTD_PROP_1ST_CONFIG \
+  0 /* No proprietary forum sector found */
+#define PH_FRINFC_MIFARESTD_PROP_2ND_CONFIG \
+  1 /* Here the proprietary                 \
+       forum sector exists after NFC forum  \
+       sector */
+#define PH_FRINFC_MIFARESTD_PROP_3RD_CONFIG            \
+  2 /* Here the proprietary forum sector exists before \
+       NFC forum sector */
 
 /* Mifare Standard - NDEF Compliant Flags */
-#define PH_FRINFC_MIFARESTD_MADSECT_ACS_BYTE6               0x78 /* Access Bit for Byte 6 in
-                                                                    MAD sector trailer */
-#define PH_FRINFC_MIFARESTD_MADSECT_ACS_BYTE7               0x77 /* Access Bit for Byte 7 in
-                                                                    MAD sector trailer */
-#define PH_FRINFC_MIFARESTD_NFCSECT_ACS_BYTE6               0x7F /* Access Bit for Byte 6 in
-                                                                    NFC forum sector trailer */
-#define PH_FRINFC_MIFARESTD_NFCSECT_ACS_BYTE7               0x07 /* Access Bit for Byte 7 in
-                                                                    NFC forum sector trailer */
-#define PH_FRINFC_MIFARESTD_ACS_BYTE8                       0x88 /* Access Bit for Byte 8 in
-                                                                    all sector trailer */
-#define PH_FRINFC_MIFARESTD_NFCSECT_RDACS_BYTE6             0x0F /* Access Bit for Byte 6 in
-                                                                    NFC forum sector trailer for
-                                                                    Read Only State */
-#define PH_FRINFC_MIFARESTD_NFCSECT_RDACS_BYTE7             0x07 /* Access Bit for Byte 7 in
-                                                                    NFC forum sector trailer
-                                                                    Read Only State */
-#define PH_FRINFC_MIFARESTD_NFCSECT_RDACS_BYTE8             0x8F /* Access Bit for Byte 8 in
-                                                                    NFC forum sector trailer
-                                                                    Read Only State */
- /* Mifare Standard constants */
-#define MIFARE_MAX_SEND_BUF_TO_READ                         1   /* Send Length for Reading a Block */
-#define MIFARE_MAX_SEND_BUF_TO_WRITE                        17  /* Send Length for writing a Block */
-#define MIFARE_AUTHENTICATE_CMD_LENGTH                      7   /* Send Length for authenticating a Block */
+#define PH_FRINFC_MIFARESTD_MADSECT_ACS_BYTE6 \
+  0x78 /* Access Bit for Byte 6 in            \
+          MAD sector trailer */
+#define PH_FRINFC_MIFARESTD_MADSECT_ACS_BYTE7 \
+  0x77 /* Access Bit for Byte 7 in            \
+          MAD sector trailer */
+#define PH_FRINFC_MIFARESTD_NFCSECT_ACS_BYTE6 \
+  0x7F /* Access Bit for Byte 6 in            \
+          NFC forum sector trailer */
+#define PH_FRINFC_MIFARESTD_NFCSECT_ACS_BYTE7 \
+  0x07 /* Access Bit for Byte 7 in            \
+          NFC forum sector trailer */
+#define PH_FRINFC_MIFARESTD_ACS_BYTE8 \
+  0x88 /* Access Bit for Byte 8 in    \
+          all sector trailer */
+#define PH_FRINFC_MIFARESTD_NFCSECT_RDACS_BYTE6 \
+  0x0F /* Access Bit for Byte 6 in              \
+          NFC forum sector trailer for          \
+          Read Only State */
+#define PH_FRINFC_MIFARESTD_NFCSECT_RDACS_BYTE7 \
+  0x07 /* Access Bit for Byte 7 in              \
+          NFC forum sector trailer              \
+          Read Only State */
+#define PH_FRINFC_MIFARESTD_NFCSECT_RDACS_BYTE8 \
+  0x8F /* Access Bit for Byte 8 in              \
+          NFC forum sector trailer              \
+          Read Only State */
+/* Mifare Standard constants */
+#define MIFARE_MAX_SEND_BUF_TO_READ 1   /* Send Length for Reading a Block */
+#define MIFARE_MAX_SEND_BUF_TO_WRITE 17 /* Send Length for writing a Block */
+#define MIFARE_AUTHENTICATE_CMD_LENGTH \
+  7 /* Send Length for authenticating a Block */
 
 /* Mifare standard - Constants */
-#define PH_FRINFC_MIFARESTD_MAD_BLK0                      0  /* Block number 0 */
-#define PH_FRINFC_MIFARESTD_MAD_BLK1                      1  /* Block number 1 */
-#define PH_FRINFC_MIFARESTD_MAD_BLK2                      2  /* Block number 2 */
-#define PH_FRINFC_MIFARESTD_MAD_BLK3                      3  /* Block number 3 */
-#define PH_FRINFC_MIFARESTD_BLK4                          4  /* Block number 4 */
-#define PH_FRINFC_MIFARESTD_BLK5                          5  /* Block number 5 */
-#define PH_FRINFC_MIFARESTD_BLK6                          6  /* Block number 6 */
-#define PH_FRINFC_MIFARESTD_BLK7                          7  /* Block number 7 */
-#define PH_FRINFC_MIFARESTD_BLK8                          8  /* Block number 8 */
-#define PH_FRINFC_MIFARESTD_BLK9                          9  /* Block number 9 */
-#define PH_FRINFC_MIFARESTD_BLK10                         10 /* Block number 10 */
-#define PH_FRINFC_MIFARESTD_BLK11                         11 /* Block number 11 */
-#define PH_FRINFC_MIFARESTD_BLK12                         12 /* Block number 12 */
-#define PH_FRINFC_MIFARESTD_BLK13                         13 /* Block number 13 */
-#define PH_FRINFC_MIFARESTD_BLK14                         14 /* Block number 14 */
-#define PH_FRINFC_MIFARESTD_BLK15                         15 /* Block number 15 */
-#define PH_FRINFC_MIFARESTD_MAD_BLK16                     16 /* Block number 16 */
-#define PH_FRINFC_MIFARESTD_MAD_BLK63                     63 /* Block number 63 */
-#define PH_FRINFC_MIFARESTD_MAD_BLK64                     64 /* Block number 64 */
-#define PH_FRINFC_MIFARESTD_MAD_BLK65                     65 /* Block number 65 */
-#define PH_FRINFC_MIFARESTD_MAD_BLK66                     66 /* Block number 66 */
-#define PH_FRINFC_MIFARESTD_MAD_BLK67                     67 /* Block number 67 */
-#define PH_FRINFC_MIFARESTD4K_BLK128                      128 /* Block number 128 for Mifare 4k */
-#define PH_FRINFC_MIFARESTD_SECTOR_NO0                    0  /* Sector 0 */
-#define PH_FRINFC_MIFARESTD_SECTOR_NO1                    1  /* Sector 1 */
-#define PH_FRINFC_MIFARESTD_SECTOR_NO16                   16 /* Sector 16 */
-#define PH_FRINFC_MIFARESTD_SECTOR_NO31                   31 /* Sector 31 */
-#define PH_FRINFC_MIFARESTD_SECTOR_NO39                   39 /* Sector 39 */
-#define PH_FRINFC_MIFARESTD_SECTOR_NO32                   32 /* Sector 32 */
-#define PH_FRINFC_MIFARESTD4K_TOTAL_SECTOR                40 /* Sector 40 */
-#define PH_FRINFC_MIFARESTD1K_TOTAL_SECTOR                16 /* Sector 16 */
-#define PH_FRINFC_MIFARESTD2K_TOTAL_SECTOR                32 /* Sector 32 */
-#define PH_FRINFC_MIFARESTD_BYTES_READ                    16 /* Bytes read */
-#define PH_FRINFC_MIFARESTD_BLOCK_BYTES                   16 /* Bytes per block */
-#define PH_FRINFC_MIFARESTD_SECTOR_BLOCKS                 16 /* Blocks per sector */
-#define PH_FRINFC_MIFARESTD_WR_A_BLK                      17 /* 17 bytes (including current block)
-                                                                are given to transfer */
-#define PH_FRINFC_MIFARESTD4K_MAX_BLOCKS                  210 /* Maximum number of Mifare 4k Blocks
-                                                                excluding sector trailer */
-#define PH_FRINFC_MIFARESTD1K_MAX_BLK                     63 /* Maximum number of Mifare 1k blocks
-                                                                including the sector trailer*/
-#define PH_FRINFC_MIFARESTD2K_MAX_BLK                     127 /* Maximum number of Mifare 2k blocks
-                                                                including the sector trailer*/
-#define PH_FRINFC_MIFARESTD4K_MAX_BLK                     254 /* Maximum number of Mifare 4k blocks
-                                                                including the sector trailer*/
-#define PH_FRINFC_MIFARESTD_FLAG1                         1 /* Flag to set 1 */
-#define PH_FRINFC_MIFARESTD_FLAG0                         0 /* Flag to set 0 */
-#define PH_FRINFC_MIFARESTD_INC_1                         1 /* increment by 1 */
-#define PH_FRINFC_MIFARESTD_INC_2                         2 /* increment by 2 */
-#define PH_FRINFC_MIFARESTD_INC_3                         3 /* increment by 3 */
-#define PH_FRINFC_MIFARESTD_INC_4                         4 /* increment by 4 */
-#define PH_FRINFC_MIFARESTD_VAL0                          0 /* Value initialised to 0 */
-#define PH_FRINFC_MIFARESTD_VAL1                          1 /* Value initialised to 1 */
-#define PH_FRINFC_MIFARESTD_VAL2                          2 /* Value initialised to 2 */
-#define PH_FRINFC_MIFARESTD_VAL3                          3 /* Value initialised to 3 */
-#define PH_FRINFC_MIFARESTD_VAL4                          4 /* Value initialised to 4 */
-#define PH_FRINFC_MIFARESTD_VAL5                          5 /* Value initialised to 5 */
-#define PH_FRINFC_MIFARESTD_VAL6                          6 /* Value initialised to 6 */
-#define PH_FRINFC_MIFARESTD_VAL7                          7 /* Value initialised to 7 */
-#define PH_FRINFC_MIFARESTD_VAL8                          8 /* Value initialised to 8 */
-#define PH_FRINFC_MIFARESTD_VAL9                          9 /* Value initialised to 9 */
-#define PH_FRINFC_MIFARESTD_VAL10                         10 /* Value initialised to 10 */
-#define PH_FRINFC_MIFARESTD_VAL11                         11 /* Value initialised to 11 */
-#define PH_FRINFC_MIFARESTD_VAL12                         12 /* Value initialised to 12 */
-#define PH_FRINFC_MIFARESTD_VAL13                         13 /* Value initialised to 13 */
-#define PH_FRINFC_MIFARESTD_VAL14                         14 /* Value initialised to 14 */
-#define PH_FRINFC_MIFARESTD_VAL15                         15 /* Value initialised to 15 */
-#define PH_FRINFC_MIFARESTD_VAL16                         16 /* Value initialised to 16 */
-#define PH_FRINFC_MIFARESTD_VAL31                         31 /* Value initialised to 31 */
-#define PH_FRINFC_MIFARESTD_VAL32                         32 /* Value initialised to 32 */
-#define PH_FRINFC_MIFARESTD_NDEFTLV_L                     0xFF /* Length of the TLV */
-#define PH_FRINFC_MIFARESTD_NDEFTLV_T                     0x03 /* Length of the TLV */
-#define PH_FRINFC_MIFARESTD_NDEFTLV_L0                    0x00 /* Length of the TLV */
-#define PH_FRINFC_MIFARESTD_NDEFTLV_LBYTES0               0 /* Number of bytes taken by length (L) of the TLV */
-#define PH_FRINFC_MIFARESTD_NDEFTLV_LBYTES1               1 /* Number of bytes taken by length (L) of the TLV */
-#define PH_FRINFC_MIFARESTD_NDEFTLV_LBYTES2               2 /* Number of bytes taken by length (L) of the TLV */
-#define PH_FRINFC_MIFARESTD_NDEFTLV_LBYTES3               3 /* Number of bytes taken by length (L) of the TLV */
-#define PH_FRINFC_MIFARESTD_PROPTLV_T                     0xFD /* Type of Proprietary TLV */
-#define PH_FRINFC_MIFARESTD_TERMTLV_T                     0xFE /* Type of Terminator TLV */
-#define PH_FRINFC_MIFARESTD_NULLTLV_T                     0x00 /* Type of NULL TLV */
-#define PH_FRINFC_MIFARESTD_LEFTSHIFT8                    8 /* Left shift by 8 */
-#define PH_FRINFC_MIFARESTD_RIGHTSHIFT8                   8 /* Right shift by 8 */
-#define PH_FRINFC_MIFARESTD_MASK_FF                       0xFF /* Mask 0xFF */
-#define PH_FRINFC_MIFARESTD_MASK_GPB_WR                   0x03 /* Mask 0x03 for GPB byte */
-#define PH_FRINFC_MIFARESTD_MASK_GPB_RD                   0x0C /* Mask 0xOC for GPB byte */
-#define PH_FRINFC_MIFARESTD_GPB_RD_WR_VAL                 0x00 /* GPB Read Write value */
-#define PH_FRINFC_MIFARESTD_KEY_LEN                       0x06 /* MIFARE Std key length */
-#define PH_FRINFC_MIFARESTD_DEFAULT_KEY                   0xFF /* MIFARE Std Default Key */
-
-
-NFCSTATUS phFriNfc_MifareStdMap_H_Reset(  phFriNfc_NdefMap_t        *NdefMap);
-NFCSTATUS phFriNfc_MifareStdMap_RdNdef( phFriNfc_NdefMap_t  *NdefMap,
-                                        uint8_t             *PacketData,
-                                        uint32_t            *PacketDataLength,
-                                        uint8_t             Offset);
-NFCSTATUS phFriNfc_MifareStdMap_WrNdef( phFriNfc_NdefMap_t  *NdefMap,
-                                    uint8_t             *PacketData,
-                                    uint32_t            *PacketDataLength,
-                                    uint8_t             Offset);
-NFCSTATUS phFriNfc_MifareStdMap_ChkNdef(phFriNfc_NdefMap_t      *NdefMap);
-
-void phFriNfc_MifareStdMap_Process( void       *Context,
-                                    NFCSTATUS   Status);
-extern
-NFCSTATUS phFrinfc_MifareClassic_GetContainerSize(const phFriNfc_NdefMap_t *NdefMap,
-                                   uint32_t *maxSize, uint32_t *actualSize);
+#define PH_FRINFC_MIFARESTD_MAD_BLK0 0     /* Block number 0 */
+#define PH_FRINFC_MIFARESTD_MAD_BLK1 1     /* Block number 1 */
+#define PH_FRINFC_MIFARESTD_MAD_BLK2 2     /* Block number 2 */
+#define PH_FRINFC_MIFARESTD_MAD_BLK3 3     /* Block number 3 */
+#define PH_FRINFC_MIFARESTD_BLK4 4         /* Block number 4 */
+#define PH_FRINFC_MIFARESTD_BLK5 5         /* Block number 5 */
+#define PH_FRINFC_MIFARESTD_BLK6 6         /* Block number 6 */
+#define PH_FRINFC_MIFARESTD_BLK7 7         /* Block number 7 */
+#define PH_FRINFC_MIFARESTD_BLK8 8         /* Block number 8 */
+#define PH_FRINFC_MIFARESTD_BLK9 9         /* Block number 9 */
+#define PH_FRINFC_MIFARESTD_BLK10 10       /* Block number 10 */
+#define PH_FRINFC_MIFARESTD_BLK11 11       /* Block number 11 */
+#define PH_FRINFC_MIFARESTD_BLK12 12       /* Block number 12 */
+#define PH_FRINFC_MIFARESTD_BLK13 13       /* Block number 13 */
+#define PH_FRINFC_MIFARESTD_BLK14 14       /* Block number 14 */
+#define PH_FRINFC_MIFARESTD_BLK15 15       /* Block number 15 */
+#define PH_FRINFC_MIFARESTD_MAD_BLK16 16   /* Block number 16 */
+#define PH_FRINFC_MIFARESTD_MAD_BLK63 63   /* Block number 63 */
+#define PH_FRINFC_MIFARESTD_MAD_BLK64 64   /* Block number 64 */
+#define PH_FRINFC_MIFARESTD_MAD_BLK65 65   /* Block number 65 */
+#define PH_FRINFC_MIFARESTD_MAD_BLK66 66   /* Block number 66 */
+#define PH_FRINFC_MIFARESTD_MAD_BLK67 67   /* Block number 67 */
+#define PH_FRINFC_MIFARESTD4K_BLK128 128   /* Block number 128 for Mifare 4k */
+#define PH_FRINFC_MIFARESTD_SECTOR_NO0 0   /* Sector 0 */
+#define PH_FRINFC_MIFARESTD_SECTOR_NO1 1   /* Sector 1 */
+#define PH_FRINFC_MIFARESTD_SECTOR_NO16 16 /* Sector 16 */
+#define PH_FRINFC_MIFARESTD_SECTOR_NO31 31 /* Sector 31 */
+#define PH_FRINFC_MIFARESTD_SECTOR_NO39 39 /* Sector 39 */
+#define PH_FRINFC_MIFARESTD_SECTOR_NO32 32 /* Sector 32 */
+#define PH_FRINFC_MIFARESTD4K_TOTAL_SECTOR 40 /* Sector 40 */
+#define PH_FRINFC_MIFARESTD1K_TOTAL_SECTOR 16 /* Sector 16 */
+#define PH_FRINFC_MIFARESTD2K_TOTAL_SECTOR 32 /* Sector 32 */
+#define PH_FRINFC_MIFARESTD_BYTES_READ 16     /* Bytes read */
+#define PH_FRINFC_MIFARESTD_BLOCK_BYTES 16    /* Bytes per block */
+#define PH_FRINFC_MIFARESTD_SECTOR_BLOCKS 16  /* Blocks per sector */
+#define PH_FRINFC_MIFARESTD_WR_A_BLK       \
+  17 /* 17 bytes (including current block) \
+        are given to transfer */
+#define PH_FRINFC_MIFARESTD4K_MAX_BLOCKS    \
+  210 /* Maximum number of Mifare 4k Blocks \
+        excluding sector trailer */
+#define PH_FRINFC_MIFARESTD1K_MAX_BLK      \
+  63 /* Maximum number of Mifare 1k blocks \
+        including the sector trailer*/
+#define PH_FRINFC_MIFARESTD2K_MAX_BLK       \
+  127 /* Maximum number of Mifare 2k blocks \
+        including the sector trailer*/
+#define PH_FRINFC_MIFARESTD4K_MAX_BLK                                      \
+  254                                /* Maximum number of Mifare 4k blocks \
+                                       including the sector trailer*/
+#define PH_FRINFC_MIFARESTD_FLAG1 1  /* Flag to set 1 */
+#define PH_FRINFC_MIFARESTD_FLAG0 0  /* Flag to set 0 */
+#define PH_FRINFC_MIFARESTD_INC_1 1  /* increment by 1 */
+#define PH_FRINFC_MIFARESTD_INC_2 2  /* increment by 2 */
+#define PH_FRINFC_MIFARESTD_INC_3 3  /* increment by 3 */
+#define PH_FRINFC_MIFARESTD_INC_4 4  /* increment by 4 */
+#define PH_FRINFC_MIFARESTD_VAL0 0   /* Value initialised to 0 */
+#define PH_FRINFC_MIFARESTD_VAL1 1   /* Value initialised to 1 */
+#define PH_FRINFC_MIFARESTD_VAL2 2   /* Value initialised to 2 */
+#define PH_FRINFC_MIFARESTD_VAL3 3   /* Value initialised to 3 */
+#define PH_FRINFC_MIFARESTD_VAL4 4   /* Value initialised to 4 */
+#define PH_FRINFC_MIFARESTD_VAL5 5   /* Value initialised to 5 */
+#define PH_FRINFC_MIFARESTD_VAL6 6   /* Value initialised to 6 */
+#define PH_FRINFC_MIFARESTD_VAL7 7   /* Value initialised to 7 */
+#define PH_FRINFC_MIFARESTD_VAL8 8   /* Value initialised to 8 */
+#define PH_FRINFC_MIFARESTD_VAL9 9   /* Value initialised to 9 */
+#define PH_FRINFC_MIFARESTD_VAL10 10 /* Value initialised to 10 */
+#define PH_FRINFC_MIFARESTD_VAL11 11 /* Value initialised to 11 */
+#define PH_FRINFC_MIFARESTD_VAL12 12 /* Value initialised to 12 */
+#define PH_FRINFC_MIFARESTD_VAL13 13 /* Value initialised to 13 */
+#define PH_FRINFC_MIFARESTD_VAL14 14 /* Value initialised to 14 */
+#define PH_FRINFC_MIFARESTD_VAL15 15 /* Value initialised to 15 */
+#define PH_FRINFC_MIFARESTD_VAL16 16 /* Value initialised to 16 */
+#define PH_FRINFC_MIFARESTD_VAL31 31 /* Value initialised to 31 */
+#define PH_FRINFC_MIFARESTD_VAL32 32 /* Value initialised to 32 */
+#define PH_FRINFC_MIFARESTD_NDEFTLV_L 0xFF  /* Length of the TLV */
+#define PH_FRINFC_MIFARESTD_NDEFTLV_T 0x03  /* Length of the TLV */
+#define PH_FRINFC_MIFARESTD_NDEFTLV_L0 0x00 /* Length of the TLV */
+#define PH_FRINFC_MIFARESTD_NDEFTLV_LBYTES0 \
+  0 /* Number of bytes taken by length (L) of the TLV */
+#define PH_FRINFC_MIFARESTD_NDEFTLV_LBYTES1 \
+  1 /* Number of bytes taken by length (L) of the TLV */
+#define PH_FRINFC_MIFARESTD_NDEFTLV_LBYTES2 \
+  2 /* Number of bytes taken by length (L) of the TLV */
+#define PH_FRINFC_MIFARESTD_NDEFTLV_LBYTES3 \
+  3 /* Number of bytes taken by length (L) of the TLV */
+#define PH_FRINFC_MIFARESTD_PROPTLV_T 0xFD     /* Type of Proprietary TLV */
+#define PH_FRINFC_MIFARESTD_TERMTLV_T 0xFE     /* Type of Terminator TLV */
+#define PH_FRINFC_MIFARESTD_NULLTLV_T 0x00     /* Type of NULL TLV */
+#define PH_FRINFC_MIFARESTD_LEFTSHIFT8 8       /* Left shift by 8 */
+#define PH_FRINFC_MIFARESTD_RIGHTSHIFT8 8      /* Right shift by 8 */
+#define PH_FRINFC_MIFARESTD_MASK_FF 0xFF       /* Mask 0xFF */
+#define PH_FRINFC_MIFARESTD_MASK_GPB_WR 0x03   /* Mask 0x03 for GPB byte */
+#define PH_FRINFC_MIFARESTD_MASK_GPB_RD 0x0C   /* Mask 0xOC for GPB byte */
+#define PH_FRINFC_MIFARESTD_GPB_RD_WR_VAL 0x00 /* GPB Read Write value */
+#define PH_FRINFC_MIFARESTD_KEY_LEN 0x06       /* MIFARE Std key length */
+#define PH_FRINFC_MIFARESTD_DEFAULT_KEY 0xFF   /* MIFARE Std Default Key */
+
+NFCSTATUS phFriNfc_MifareStdMap_H_Reset(phFriNfc_NdefMap_t* NdefMap);
+NFCSTATUS phFriNfc_MifareStdMap_RdNdef(phFriNfc_NdefMap_t* NdefMap,
+                                       uint8_t* PacketData,
+                                       uint32_t* PacketDataLength,
+                                       uint8_t Offset);
+NFCSTATUS phFriNfc_MifareStdMap_WrNdef(phFriNfc_NdefMap_t* NdefMap,
+                                       uint8_t* PacketData,
+                                       uint32_t* PacketDataLength,
+                                       uint8_t Offset);
+NFCSTATUS phFriNfc_MifareStdMap_ChkNdef(phFriNfc_NdefMap_t* NdefMap);
+
+void phFriNfc_MifareStdMap_Process(void* Context, NFCSTATUS Status);
+extern NFCSTATUS phFrinfc_MifareClassic_GetContainerSize(
+    const phFriNfc_NdefMap_t* NdefMap, uint32_t* maxSize, uint32_t* actualSize);
 
 NFCSTATUS
-phFriNfc_MifareStdMap_ConvertToReadOnly (phFriNfc_NdefMap_t *NdefMap, const uint8_t *ScrtKeyB);
+phFriNfc_MifareStdMap_ConvertToReadOnly(phFriNfc_NdefMap_t* NdefMap,
+                                        const uint8_t* ScrtKeyB);
 
 #endif /* PHFRINFC_MIFARESTDMAP_H */
diff --git a/nci/jni/extns/pn54x/src/mifare/phFriNfc_MifareStdTimer.c b/nci/jni/extns/pn54x/src/mifare/phFriNfc_MifareStdTimer.cpp
similarity index 50%
rename from nci/jni/extns/pn54x/src/mifare/phFriNfc_MifareStdTimer.c
rename to nci/jni/extns/pn54x/src/mifare/phFriNfc_MifareStdTimer.cpp
index 8c171eda..aeebd073 100644
--- a/nci/jni/extns/pn54x/src/mifare/phFriNfc_MifareStdTimer.c
+++ b/nci/jni/extns/pn54x/src/mifare/phFriNfc_MifareStdTimer.cpp
@@ -1,8 +1,4 @@
 /*
- * Copyright (c) 2016, The Linux Foundation. All rights reserved.
- * Not a Contribution.
- *
- * Copyright (C) 2010-2014 NXP Semiconductors
  * Copyright (C) 2015 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -18,12 +14,19 @@
  * limitations under the License.
  */
 
- /*include files*/
-#include <phNfcTypes.h>
-#include <phNfcStatus.h>
-#include <phNciNfcTypes.h>
+/*include files*/
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
 #include <phFriNfc_MifareStdTimer.h>
+#include <phNciNfcTypes.h>
+#include <phNfcStatus.h>
+#include <phNfcTypes.h>
 #include <phNxpLog.h>
+
+using android::base::StringPrintf;
+
+STATIC NFCSTATUS
+phFriNfc_MifareStd_CreateTimer(phFriNfc_MifareStdTimer_t* TimerInfo);
 /*******************************************************************************
 **
 ** Function        phFriNfc_MifareStd_StartTimer
@@ -36,42 +39,35 @@
 ** Returns:        NFCSTATUS_SUCCESS  -  timer started successfully
 **                 NFCSTATUS_FAILED   -  otherwise
 *******************************************************************************/
-NFCSTATUS  phFriNfc_MifareStd_StartTimer( phFriNfc_MifareStdTimer_t *TimerInfo )
-{
-    NFCSTATUS status = NFCSTATUS_SUCCESS;
-    int stat = 0;
-    struct itimerspec ts;
-    if ( TimerInfo->mTimerId == 0)
-    {
-        if (TimerInfo->mCb == 0)
-        {
-            return NFCSTATUS_FAILED;
-        }
-
-        if (phFriNfc_MifareStd_CreateTimer(TimerInfo) != NFCSTATUS_SUCCESS)
-            return NFCSTATUS_FAILED;
+NFCSTATUS phFriNfc_MifareStd_StartTimer(phFriNfc_MifareStdTimer_t* TimerInfo) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  int stat = 0;
+  struct itimerspec ts;
+  if (TimerInfo->mTimerId == 0) {
+    if (TimerInfo->mCb == 0) {
+      return NFCSTATUS_FAILED;
     }
 
-    ts.it_value.tv_sec = (TimerInfo->mtimeout) / 1000;
-    ts.it_value.tv_nsec = (TimerInfo->mtimeout % 1000) * 1000000;
+    if (phFriNfc_MifareStd_CreateTimer(TimerInfo) != NFCSTATUS_SUCCESS)
+      return NFCSTATUS_FAILED;
+  }
 
-    ts.it_interval.tv_sec = 0;
-    ts.it_interval.tv_nsec = 0;
+  ts.it_value.tv_sec = (TimerInfo->mtimeout) / 1000;
+  ts.it_value.tv_nsec = (TimerInfo->mtimeout % 1000) * 1000000;
 
-    stat = timer_settime(TimerInfo->mTimerId, 0, &ts, 0);
-    if (stat == 0)
-    {
+  ts.it_interval.tv_sec = 0;
+  ts.it_interval.tv_nsec = 0;
 
-        status = NFCSTATUS_SUCCESS;
-        return status;
-    }else
-    {
-        status= NFCSTATUS_FAILED;
-        return status;
-    }
+  stat = timer_settime(TimerInfo->mTimerId, 0, &ts, 0);
+  if (stat == 0) {
+    status = NFCSTATUS_SUCCESS;
+    return status;
+  } else {
+    status = NFCSTATUS_FAILED;
+    return status;
+  }
 }
 
-
 /*******************************************************************************
 **
 ** Function         phFriNfc_MifareStd_StopTimer
@@ -82,22 +78,20 @@ NFCSTATUS  phFriNfc_MifareStd_StartTimer( phFriNfc_MifareStdTimer_t *TimerInfo )
 ** Returns:         NFCSTATUS_SUCCESS  -  timer stopped successfully
 **                  NFCSTATUS_FAILED   -  otherwise
 *******************************************************************************/
-NFCSTATUS  phFriNfc_MifareStd_StopTimer( phFriNfc_MifareStdTimer_t *TimerInfo )
-{
-    NFCSTATUS status = NFCSTATUS_SUCCESS;
-    if (TimerInfo->mTimerId == 0)
-    {
-        NXPLOG_EXTNS_E(" phFriNfc_MifareStd_CreateTimer() failed to stop timer  ");
-        status = NFCSTATUS_FAILED;
-        return status;
-    }
-
-    timer_delete(TimerInfo->mTimerId);
-    TimerInfo->mTimerId = 0;
-    TimerInfo->mCb = NULL;
+NFCSTATUS phFriNfc_MifareStd_StopTimer(phFriNfc_MifareStdTimer_t* TimerInfo) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  if (TimerInfo->mTimerId == 0) {
+    LOG(ERROR) << StringPrintf(
+        " phFriNfc_MifareStd_CreateTimer() failed to stop timer  ");
+    status = NFCSTATUS_FAILED;
     return status;
-}
+  }
 
+  timer_delete(TimerInfo->mTimerId);
+  TimerInfo->mTimerId = 0;
+  TimerInfo->mCb = NULL;
+  return status;
+}
 
 /*******************************************************************************
 **
@@ -109,28 +103,27 @@ NFCSTATUS  phFriNfc_MifareStd_StopTimer( phFriNfc_MifareStdTimer_t *TimerInfo )
 ** Returns:         NFCSTATUS_SUCCESS  -  timer created successfully
 **                  NFCSTATUS_FAILED   -  otherwise
 *******************************************************************************/
-NFCSTATUS  phFriNfc_MifareStd_CreateTimer( phFriNfc_MifareStdTimer_t *TimerInfo )
-{
-    NFCSTATUS status = NFCSTATUS_SUCCESS;
-    struct sigevent se;
-    memset(&se,0,sizeof(struct sigevent));
-    int stat = 0;
-    /*
-     * Set the sigevent structure to cause the signal to be
-     * delivered by creating a new thread.
-     */
-    se.sigev_notify = SIGEV_THREAD;
-    se.sigev_value.sival_ptr = &(TimerInfo)->mTimerId;
-    se.sigev_notify_function = TimerInfo->mCb;
-    se.sigev_notify_attributes = NULL;
-    stat = timer_create(CLOCK_MONOTONIC, &se, &(TimerInfo)->mTimerId);
-    if (stat == 0)
-    {
-        NXPLOG_EXTNS_E(" phFriNfc_MifareStd_CreateTimer() Timer created successfully ");
-        return status;
-    }else
-    {
-        status= NFCSTATUS_FAILED;
-        return status;
-    }
+STATIC NFCSTATUS
+phFriNfc_MifareStd_CreateTimer(phFriNfc_MifareStdTimer_t* TimerInfo) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  struct sigevent se;
+  memset(&se, 0, sizeof(struct sigevent));
+  int stat = 0;
+  /*
+   * Set the sigevent structure to cause the signal to be
+   * delivered by creating a new thread.
+   */
+  se.sigev_notify = SIGEV_THREAD;
+  se.sigev_value.sival_ptr = &(TimerInfo)->mTimerId;
+  se.sigev_notify_function = TimerInfo->mCb;
+  se.sigev_notify_attributes = NULL;
+  stat = timer_create(CLOCK_MONOTONIC, &se, &(TimerInfo)->mTimerId);
+  if (stat == 0) {
+    LOG(ERROR) << StringPrintf(
+        " phFriNfc_MifareStd_CreateTimer() Timer created successfully ");
+    return status;
+  } else {
+    status = NFCSTATUS_FAILED;
+    return status;
+  }
 }
diff --git a/nci/jni/extns/pn54x/src/mifare/phFriNfc_MifareStdTimer.h b/nci/jni/extns/pn54x/src/mifare/phFriNfc_MifareStdTimer.h
index 0319bfb5..32f41a00 100644
--- a/nci/jni/extns/pn54x/src/mifare/phFriNfc_MifareStdTimer.h
+++ b/nci/jni/extns/pn54x/src/mifare/phFriNfc_MifareStdTimer.h
@@ -18,25 +18,20 @@
  * limitations under the License.
  */
 
-
-
- /*include files*/
-#include <phNfcTypes.h>
-#include <phNfcStatus.h>
+/*include files*/
 #include <phNciNfcTypes.h>
+#include <phNfcStatus.h>
+#include <phNfcTypes.h>
 #include <time.h>
 
-typedef void (*TIMER_FUNC) (union sigval);
-
-typedef struct phFriNfc_MifareStdTimer
-{
-    timer_t mTimerId; // timer id which will be assigned by create timer
-    TIMER_FUNC mCb;   //callback function for timeout
-    uint32_t mtimeout; // timeout value in ms.
-}phFriNfc_MifareStdTimer_t;
+typedef void (*TIMER_FUNC)(union sigval);
 
-NFCSTATUS  phFriNfc_MifareStd_StartTimer( phFriNfc_MifareStdTimer_t *timer );
+typedef struct phFriNfc_MifareStdTimer {
+  timer_t mTimerId;   // timer id which will be assigned by create timer
+  TIMER_FUNC mCb;     // callback function for timeout
+  uint32_t mtimeout;  // timeout value in ms.
+} phFriNfc_MifareStdTimer_t;
 
-NFCSTATUS  phFriNfc_MifareStd_StopTimer( phFriNfc_MifareStdTimer_t *timer );
+NFCSTATUS phFriNfc_MifareStd_StartTimer(phFriNfc_MifareStdTimer_t* timer);
 
-NFCSTATUS  phFriNfc_MifareStd_CreateTimer( phFriNfc_MifareStdTimer_t *TimerInfo );
+NFCSTATUS phFriNfc_MifareStd_StopTimer(phFriNfc_MifareStdTimer_t* timer);
diff --git a/nci/jni/extns/pn54x/src/mifare/phFriNfc_NdefMap.h b/nci/jni/extns/pn54x/src/mifare/phFriNfc_NdefMap.h
index 9f81a9bb..5fc0d45a 100644
--- a/nci/jni/extns/pn54x/src/mifare/phFriNfc_NdefMap.h
+++ b/nci/jni/extns/pn54x/src/mifare/phFriNfc_NdefMap.h
@@ -22,17 +22,18 @@
 #ifndef PHFRINFC_NDEFMAP_H
 #define PHFRINFC_NDEFMAP_H
 
-
 /*include files*/
-#include <phNfcTypes.h>
-#include <phNfcStatus.h>
 #include <phFriNfc.h>
+#include <phNfcStatus.h>
+#include <phNfcTypes.h>
 #include <phNfcTypes_Mapping.h>
 
 /*  NDEF Mapping Component
  *
- *  This component implements the read/write/check NDEF functions for remote devices.
- *  NDEF data, as defined by the NFC Forum NDEF specification are written to or read from
+ *  This component implements the read/write/check NDEF functions for remote
+ *devices.
+ *  NDEF data, as defined by the NFC Forum NDEF specification are written to or
+ *read from
  *  a remote device that can be a smart- or memory card.
  *  Please notice that the NDEF mapping command sequence must
  *  be contiguous (after correct initialization)
@@ -45,426 +46,433 @@
  *
  */
 
-#define PH_FRINFC_NDEFMAP_MIFARE_STD_1K_CARD              7 /* Mifare Standard */
-#define PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD              8 /* Mifare Standard */
-#define PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD              11 /*internal Mifare Standard */
-#define PH_FRINFC_NDEFMAP_EMPTY_NDEF_MSG                  {0xD0, 0x00, 0x00}  /* Empty ndef message */
-#define PH_FRINFC_NDEFMAP_MFUL_4BYTES_BUF                 4 /* To store 4 bytes after write */
-
+#define PH_FRINFC_NDEFMAP_MIFARE_STD_1K_CARD 7  /* Mifare Standard */
+#define PH_FRINFC_NDEFMAP_MIFARE_STD_4K_CARD 8  /* Mifare Standard */
+#define PH_FRINFC_NDEFMAP_MIFARE_STD_2K_CARD 11 /*internal Mifare Standard */
+#define PH_FRINFC_NDEFMAP_EMPTY_NDEF_MSG \
+  { 0xD0, 0x00, 0x00 }                      /* Empty ndef message */
+#define PH_FRINFC_NDEFMAP_MFUL_4BYTES_BUF 4 /* To store 4 bytes after write */
 
 /* Enum represents the different card state*/
-typedef enum
-{
-    PH_NDEFMAP_CARD_STATE_INITIALIZED,
-    PH_NDEFMAP_CARD_STATE_READ_ONLY,
-    PH_NDEFMAP_CARD_STATE_READ_WRITE,
-    PH_NDEFMAP_CARD_STATE_INVALID
-}phNDEF_CARD_STATE;
-
+typedef enum {
+  PH_NDEFMAP_CARD_STATE_INITIALIZED,
+  PH_NDEFMAP_CARD_STATE_READ_ONLY,
+  PH_NDEFMAP_CARD_STATE_READ_WRITE,
+  PH_NDEFMAP_CARD_STATE_INVALID
+} phNDEF_CARD_STATE;
 
 /*
- * NDEF Mapping - specifies the Compliant Blocks in the Mifare 1k and 4k card types
+ * NDEF Mapping - specifies the Compliant Blocks in the Mifare 1k and 4k card
+ *types
  *
  */
-#define PH_FRINFC_NDEFMAP_MIFARESTD_1KNDEF_COMPBLOCK      45 /* Total Ndef Compliant blocks Mifare 1k */
-#define PH_FRINFC_NDEFMAP_MIFARESTD_2KNDEF_COMPBLOCK      90 /* Total Ndef Compliant blocks Mifare 2k */
-#define PH_FRINFC_NDEFMAP_MIFARESTD_4KNDEF_COMPBLOCK      210 /* Total Ndef Compliant blocks Mifare 4k */
-#define PH_FRINFC_NDEFMAP_MIFARESTD_RDWR_SIZE             16 /* Bytes read/write for one read/write operation*/
-#define PH_FRINFC_NDEFMAP_MIFARESTD_TOTALNO_BLK           40 /* Total number of sectors in Mifare 4k */
-#define PH_FRINFC_NDEFMAP_MIFARESTD_ST15_BYTES            15 /* To store 15 bytes after reading a block */
+#define PH_FRINFC_NDEFMAP_MIFARESTD_1KNDEF_COMPBLOCK \
+  45 /* Total Ndef Compliant blocks Mifare 1k */
+#define PH_FRINFC_NDEFMAP_MIFARESTD_2KNDEF_COMPBLOCK \
+  90 /* Total Ndef Compliant blocks Mifare 2k */
+#define PH_FRINFC_NDEFMAP_MIFARESTD_4KNDEF_COMPBLOCK \
+  210 /* Total Ndef Compliant blocks Mifare 4k */
+#define PH_FRINFC_NDEFMAP_MIFARESTD_RDWR_SIZE \
+  16 /* Bytes read/write for one read/write operation*/
+#define PH_FRINFC_NDEFMAP_MIFARESTD_TOTALNO_BLK \
+  40 /* Total number of sectors in Mifare 4k */
+#define PH_FRINFC_NDEFMAP_MIFARESTD_ST15_BYTES \
+  15 /* To store 15 bytes after reading a block */
 
 /*
  * Completion Routine Indices
  *
- * These are the indices of the completion routine pointers within the component context.
+ * These are the indices of the completion routine pointers within the component
+ *context.
  * Completion routines belong to upper components.
  *
  */
-#define PH_FRINFC_NDEFMAP_CR_CHK_NDEF       0  /* */
-#define PH_FRINFC_NDEFMAP_CR_RD_NDEF        1  /* */
-#define PH_FRINFC_NDEFMAP_CR_WR_NDEF        2  /* */
-#define PH_FRINFC_NDEFMAP_CR_ERASE_NDEF     3  /* */
-#define PH_FRINFC_NDEFMAP_CR_INVALID_OPE    4  /* */
-#define PH_FRINFC_NDEFMAP_CR                5  /* */
+#define PH_FRINFC_NDEFMAP_CR_CHK_NDEF 0    /* */
+#define PH_FRINFC_NDEFMAP_CR_RD_NDEF 1     /* */
+#define PH_FRINFC_NDEFMAP_CR_WR_NDEF 2     /* */
+#define PH_FRINFC_NDEFMAP_CR_ERASE_NDEF 3  /* */
+#define PH_FRINFC_NDEFMAP_CR_INVALID_OPE 4 /* */
+#define PH_FRINFC_NDEFMAP_CR 5             /* */
 
 /*
  * File Offset Attributes
  *
- * Following values are used to determine the offset value for Read/Write. This specifies whether
- * the Read/Write operation needs to be restarted/continued from the last offset set.
+ * Following values are used to determine the offset value for Read/Write. This
+ *specifies whether
+ * the Read/Write operation needs to be restarted/continued from the last offset
+ *set.
  *
  */
 /* Read/Write operation shall start from the last offset set */
-#define PH_FRINFC_NDEFMAP_SEEK_CUR                          0 /* */
+#define PH_FRINFC_NDEFMAP_SEEK_CUR 0 /* */
 /* Read/Write operation shall start from the beginning of the file/card */
-#define PH_FRINFC_NDEFMAP_SEEK_BEGIN                        1 /* */
+#define PH_FRINFC_NDEFMAP_SEEK_BEGIN 1 /* */
 
 /* Read operation invalid */
-#define PH_FRINFC_NDEFMAP_SEEK_INVALID                      0xFF /* */
+#define PH_FRINFC_NDEFMAP_SEEK_INVALID 0xFF /* */
 
 /*
  * Buffer Size Definitions
  *
  */
 /* Minimum size of the TRX buffer required */
-#define PH_FRINFC_NDEFMAP_MAX_SEND_RECV_BUF_SIZE            252 /* */
+#define PH_FRINFC_NDEFMAP_MAX_SEND_RECV_BUF_SIZE 252 /* */
 /* The size of s MIFARE block */
-#define PH_FRINFC_NDEFMAP_MF_READ_BLOCK_SIZE                16  /* */
-
-typedef struct phFriNfc_MifareStdCont
-{
-    /* to store bytes that will be used in the next write/read operation, if any */
-    uint8_t             internalBuf[PH_FRINFC_NDEFMAP_MIFARESTD_ST15_BYTES];
-    /* to Store the length of the internalBuf */
-    uint16_t            internalLength;
-    /* holds the block number which is presently been used */
-    uint8_t             currentBlock;
-    /* the number of Ndef compliant blocks written/read */
-    uint8_t             NdefBlocks;
-    /* Total Number of Ndef compliant Blocks */
-    uint16_t            NoOfNdefCompBlocks;
-    /* used in write ndef, to know that internal byte are accessed */
-    uint8_t             internalBufFlag;
-    /* used in write ndef, to know that last 16 bytes are used to write*/
-    uint8_t             RemainingBufFlag;
-    /* indicates that Read has reached the end of the card */
-    uint8_t             ReadWriteCompleteFlag;
-    /* indicates that Read has reached the end of the card */
-    uint8_t             ReadCompleteFlag;
-    /* indicates that Write is possible or not */
-    uint8_t             WriteFlag;
-    /* indicates that Write is possible or not */
-    uint8_t             ReadFlag;
-    /* indicates that Write is possible or not */
-    uint8_t             RdBeforeWrFlag;
-    /* Authentication Flag indicating that a particular sector is authenticated or not */
-    uint8_t             AuthDone;
-    /* to store the last Sector ID in Check Ndef */
-    uint8_t             SectorIndex;
-    /* to read the access bits of each sector */
-    uint8_t             ReadAcsBitFlag;
-    /* Flag to check if Acs bit was written in this call */
-    uint8_t             WriteAcsBitFlag;
-    /* Buffer to store 16 bytes */
-    uint8_t             Buffer[PH_FRINFC_NDEFMAP_MIFARESTD_RDWR_SIZE];
-    /* to store the AIDs of Mifare 1k or 4k */
-    uint8_t             aid[PH_FRINFC_NDEFMAP_MIFARESTD_TOTALNO_BLK];
-    /* flag to write with offset begin */
-    uint8_t             WrNdefFlag;
-    /* flag to read with offset begin */
-    uint8_t             ReadNdefFlag;
-    /* flag to check with offset begin */
-    uint8_t             ChkNdefFlag;
-    /* To store the remaining size of the Mifare 1k or 4k card */
-    uint16_t            remainingSize;
-    /* To update the remaining size when writing to the Mifare 1k or 4k card */
-    uint8_t             remSizeUpdFlag;
-    /* The flag is to know that there is a different AID apart from NFC forum sector AID */
-    uint16_t            aidCompleteFlag;
-    /* The flag is to know that there is a a NFC forum sector exists in the card */
-    uint16_t            NFCforumSectFlag;
-    /* The flag is to know that the particular sector is a proprietary NFC forum sector */
-    uint16_t            ProprforumSectFlag;
-    /* The flag is set after reading the MAD sectors */
-    uint16_t            ChkNdefCompleteFlag;
-    /* Flag to store the current block */
-    uint8_t             TempBlockNo;
-    /* Completion routine index */
-    uint8_t             CRIndex;
-    /* Bytes remaining to write for one write procedure */
-    uint16_t            WrLength;
-    /* Flag to read after write */
-    uint8_t             RdAfterWrFlag;
-    /* Flag to say that poll is required before write ndef (authentication) */
-    uint8_t             PollFlag;
-    /* Flag is to know that this is first time the read has been called. This
-    is required when read is called after write (especially for the card formatted
-    with the 2nd configuration) */
-    uint8_t             FirstReadFlag;
-    /* Flag is to know that this is first time the write has been called. This
-    is required when the card formatted with the 3rd configuration */
-    uint8_t             FirstWriteFlag;
-    /* Indicates the sector trailor id  for which the convert
-        to read only is currently in progress*/
-    uint8_t             ReadOnlySectorIndex;
-    /* Indicates the total number of sectors on the card  */
-    uint8_t             TotalNoSectors;
-    /* Indicates the block number of the sector trailor on the card  */
-    uint8_t             SectorTrailerBlockNo;
-    /* Secret key B to given by the application */
-    uint8_t             UserScrtKeyB[6];
-}phFriNfc_MifareStdCont_t;
+#define PH_FRINFC_NDEFMAP_MF_READ_BLOCK_SIZE 16 /* */
+
+typedef struct phFriNfc_MifareStdCont {
+  /* to store bytes that will be used in the next write/read operation, if any
+   */
+  uint8_t internalBuf[PH_FRINFC_NDEFMAP_MIFARESTD_ST15_BYTES];
+  /* to Store the length of the internalBuf */
+  uint16_t internalLength;
+  /* holds the block number which is presently been used */
+  uint8_t currentBlock;
+  /* the number of Ndef compliant blocks written/read */
+  uint8_t NdefBlocks;
+  /* Total Number of Ndef compliant Blocks */
+  uint16_t NoOfNdefCompBlocks;
+  /* used in write ndef, to know that internal byte are accessed */
+  uint8_t internalBufFlag;
+  /* used in write ndef, to know that last 16 bytes are used to write*/
+  uint8_t RemainingBufFlag;
+  /* indicates that Read has reached the end of the card */
+  uint8_t ReadWriteCompleteFlag;
+  /* indicates that Read has reached the end of the card */
+  uint8_t ReadCompleteFlag;
+  /* indicates that Write is possible or not */
+  uint8_t WriteFlag;
+  /* indicates that Write is possible or not */
+  uint8_t ReadFlag;
+  /* indicates that Write is possible or not */
+  uint8_t RdBeforeWrFlag;
+  /* Authentication Flag indicating that a particular sector is authenticated or
+   * not */
+  uint8_t AuthDone;
+  /* to store the last Sector ID in Check Ndef */
+  uint8_t SectorIndex;
+  /* to read the access bits of each sector */
+  uint8_t ReadAcsBitFlag;
+  /* Flag to check if Acs bit was written in this call */
+  uint8_t WriteAcsBitFlag;
+  /* Buffer to store 16 bytes */
+  uint8_t Buffer[PH_FRINFC_NDEFMAP_MIFARESTD_RDWR_SIZE];
+  /* to store the AIDs of Mifare 1k or 4k */
+  uint8_t aid[PH_FRINFC_NDEFMAP_MIFARESTD_TOTALNO_BLK];
+  /* flag to write with offset begin */
+  uint8_t WrNdefFlag;
+  /* flag to read with offset begin */
+  uint8_t ReadNdefFlag;
+  /* flag to check with offset begin */
+  uint8_t ChkNdefFlag;
+  /* To store the remaining size of the Mifare 1k or 4k card */
+  uint16_t remainingSize;
+  /* To update the remaining size when writing to the Mifare 1k or 4k card */
+  uint8_t remSizeUpdFlag;
+  /* The flag is to know that there is a different AID apart from NFC forum
+   * sector AID */
+  uint16_t aidCompleteFlag;
+  /* The flag is to know that there is a a NFC forum sector exists in the card
+   */
+  uint16_t NFCforumSectFlag;
+  /* The flag is to know that the particular sector is a proprietary NFC forum
+   * sector */
+  uint16_t ProprforumSectFlag;
+  /* The flag is set after reading the MAD sectors */
+  uint16_t ChkNdefCompleteFlag;
+  /* Flag to store the current block */
+  uint8_t TempBlockNo;
+  /* Completion routine index */
+  uint8_t CRIndex;
+  /* Bytes remaining to write for one write procedure */
+  uint16_t WrLength;
+  /* Flag to read after write */
+  uint8_t RdAfterWrFlag;
+  /* Flag to say that poll is required before write ndef (authentication) */
+  uint8_t PollFlag;
+  /* Flag is to know that this is first time the read has been called. This
+  is required when read is called after write (especially for the card formatted
+  with the 2nd configuration) */
+  uint8_t FirstReadFlag;
+  /* Flag is to know that this is first time the write has been called. This
+  is required when the card formatted with the 3rd configuration */
+  uint8_t FirstWriteFlag;
+  /* Indicates the sector trailor id  for which the convert
+      to read only is currently in progress*/
+  uint8_t ReadOnlySectorIndex;
+  /* Indicates the total number of sectors on the card  */
+  uint8_t TotalNoSectors;
+  /* Indicates the block number of the sector trailor on the card  */
+  uint8_t SectorTrailerBlockNo;
+  /* Secret key B to given by the application */
+  uint8_t UserScrtKeyB[6];
+} phFriNfc_MifareStdCont_t;
 
 /*
  *  NDEF TLV structure which details the different variables used for TLV.
  *
  */
-typedef struct phFriNfc_NDEFTLVCont
-{
-    /* Flag is to know that the TLV Type Found */
-    uint8_t             NdefTLVFoundFlag;
-    /* Sector number of the next/present available TLV */
-    uint8_t             NdefTLVSector;
-    /* Following two variables are used to store the
-        T byte and the Block number in which the T is
-        found in Tag */
-    /* Byte number of the next/present available TLV */
-    uint16_t            NdefTLVByte;
-    /* Block number of the next/present available TLV */
-    uint8_t             NdefTLVBlock;
-    /* Authentication flag for NDEF TLV Block */
-    uint8_t             NdefTLVAuthFlag;
-    /* if the 16th byte of the last read is type (T) of TLV
-        and next read contains length (L) bytes of TLV. This flag
-        is set when the type (T) of TLV is found in the last read */
-    uint8_t             TcheckedinTLVFlag;
-    /* if the 16th byte of the last read is Length (L) of TLV
-        and next read contains length (L) bytes of TLV. This flag
-        is set when the Length (L) of TLV is found in the last read */
-    uint8_t             LcheckedinTLVFlag;
-    /* This flag is set, if Terminator TLV is already written
-        and next read contains value (V) bytes of TLV. This flag
-        is set when the value (V) of TLV is found in the last read */
-    uint8_t             SetTermTLVFlag;
-    /* To know the number of Length (L) field is present in the
-        next block */
-    uint8_t             NoLbytesinTLV;
-    /* The value of 3 bytes length(L) field in TLV. In 3 bytes
-        length field, 2 bytes are in one block and other 1 byte
-        is in the next block. To store the former block length
-        field value, this variable is used */
-    uint16_t            prevLenByteValue;
-    /* The value of length(L) field in TLV. */
-    uint16_t            BytesRemainLinTLV;
-    /* Actual size to read and write. This will be always equal to the
-        length (L) of TLV as there is only one NDEF TLV . */
-    uint16_t            ActualSize;
-    /* Flag is to write the length (L) field of the TLV */
-    uint8_t             WrLenFlag;
-    /* Flag is to write the length (L) field of the TLV */
-    uint16_t            NULLTLVCount;
-    /* Buffer to store 4 bytes of data which is written to a block */
-    uint8_t             NdefTLVBuffer[PH_FRINFC_NDEFMAP_MFUL_4BYTES_BUF];
-    /* Buffer to store 4 bytes of data which is written to a next block */
-    uint8_t             NdefTLVBuffer1[PH_FRINFC_NDEFMAP_MFUL_4BYTES_BUF];
-}phFriNfc_NDEFTLVCont_t;
+typedef struct phFriNfc_NDEFTLVCont {
+  /* Flag is to know that the TLV Type Found */
+  uint8_t NdefTLVFoundFlag;
+  /* Sector number of the next/present available TLV */
+  uint8_t NdefTLVSector;
+  /* Following two variables are used to store the
+      T byte and the Block number in which the T is
+      found in Tag */
+  /* Byte number of the next/present available TLV */
+  uint16_t NdefTLVByte;
+  /* Block number of the next/present available TLV */
+  uint8_t NdefTLVBlock;
+  /* Authentication flag for NDEF TLV Block */
+  uint8_t NdefTLVAuthFlag;
+  /* if the 16th byte of the last read is type (T) of TLV
+      and next read contains length (L) bytes of TLV. This flag
+      is set when the type (T) of TLV is found in the last read */
+  uint8_t TcheckedinTLVFlag;
+  /* if the 16th byte of the last read is Length (L) of TLV
+      and next read contains length (L) bytes of TLV. This flag
+      is set when the Length (L) of TLV is found in the last read */
+  uint8_t LcheckedinTLVFlag;
+  /* This flag is set, if Terminator TLV is already written
+      and next read contains value (V) bytes of TLV. This flag
+      is set when the value (V) of TLV is found in the last read */
+  uint8_t SetTermTLVFlag;
+  /* To know the number of Length (L) field is present in the
+      next block */
+  uint8_t NoLbytesinTLV;
+  /* The value of 3 bytes length(L) field in TLV. In 3 bytes
+      length field, 2 bytes are in one block and other 1 byte
+      is in the next block. To store the former block length
+      field value, this variable is used */
+  uint16_t prevLenByteValue;
+  /* The value of length(L) field in TLV. */
+  uint16_t BytesRemainLinTLV;
+  /* Actual size to read and write. This will be always equal to the
+      length (L) of TLV as there is only one NDEF TLV . */
+  uint16_t ActualSize;
+  /* Flag is to write the length (L) field of the TLV */
+  uint8_t WrLenFlag;
+  /* Flag is to write the length (L) field of the TLV */
+  uint16_t NULLTLVCount;
+  /* Buffer to store 4 bytes of data which is written to a block */
+  uint8_t NdefTLVBuffer[PH_FRINFC_NDEFMAP_MFUL_4BYTES_BUF];
+  /* Buffer to store 4 bytes of data which is written to a next block */
+  uint8_t NdefTLVBuffer1[PH_FRINFC_NDEFMAP_MFUL_4BYTES_BUF];
+} phFriNfc_NDEFTLVCont_t;
 
 /*
- *  Lock Control TLV structure which stores the Position, Size and PageCntrl details.
+ *  Lock Control TLV structure which stores the Position, Size and PageCntrl
+ * details.
  */
 
-typedef struct phFriNfc_LockCntrlTLVCont
-{
-    /* Specifies the Byte Position of the lock cntrl tlv
-        in the card memory*/
-    uint16_t             ByteAddr;
+typedef struct phFriNfc_LockCntrlTLVCont {
+  /* Specifies the Byte Position of the lock cntrl tlv
+      in the card memory*/
+  uint16_t ByteAddr;
 
-    /* Specifies the Size of the lock area in terms of
-        bits/bytes*/
-    uint16_t             Size;
+  /* Specifies the Size of the lock area in terms of
+      bits/bytes*/
+  uint16_t Size;
 
-    /* Specifies the Bytes per Page*/
-    uint8_t             BytesPerPage;
+  /* Specifies the Bytes per Page*/
+  uint8_t BytesPerPage;
 
-    /* Specifies the BytesLockedPerLockBit */
-    uint8_t             BytesLockedPerLockBit;
+  /* Specifies the BytesLockedPerLockBit */
+  uint8_t BytesLockedPerLockBit;
 
-    /* Specifies the index of Lock cntrl TLV*/
-    uint8_t             LockTlvBuffIdx;
+  /* Specifies the index of Lock cntrl TLV*/
+  uint8_t LockTlvBuffIdx;
 
-    /* Store the content of Lock cntrl TLV*/
-    uint8_t             LockTlvBuff[8];
+  /* Store the content of Lock cntrl TLV*/
+  uint8_t LockTlvBuff[8];
 
-    /* Specifies the Block number Lock cntrl TLV*/
-    uint16_t             BlkNum;
+  /* Specifies the Block number Lock cntrl TLV*/
+  uint16_t BlkNum;
 
-    /* Specifies the Byte Number position of Lock cntrl TLV*/
-    uint16_t             ByteNum;
-
-
-}phFriNfc_LockCntrlTLVCont_t;
+  /* Specifies the Byte Number position of Lock cntrl TLV*/
+  uint16_t ByteNum;
 
+} phFriNfc_LockCntrlTLVCont_t;
 
 /*
- *  Memory Control TLV structure which stores the Position, Size and PageCntrl details of the reserved byte area.
+ *  Memory Control TLV structure which stores the Position, Size and PageCntrl
+ * details of the reserved byte area.
  */
 
-typedef struct phFriNfc_ResMemCntrlTLVCont
-{
-    /* Specifies the Byte Position of the lock cntrl tlv
-        in the card memory */
-    uint16_t             ByteAddr;
-
-    /* Specifies the Size of the lock area in terms of
-        bits/bytes*/
-    uint16_t             Size;
+typedef struct phFriNfc_ResMemCntrlTLVCont {
+  /* Specifies the Byte Position of the lock cntrl tlv
+      in the card memory */
+  uint16_t ByteAddr;
 
-    /* Store the content of Memory cntrl TLV*/
-    uint8_t             MemCntrlTlvBuff[8];
+  /* Specifies the Size of the lock area in terms of
+      bits/bytes*/
+  uint16_t Size;
 
-    /* Specifies the Bytes per Page*/
-    uint8_t             BytesPerPage;
+  /* Store the content of Memory cntrl TLV*/
+  uint8_t MemCntrlTlvBuff[8];
 
-    /* Specifies the index of Mem cntrl TLV*/
-    uint8_t             MemTlvBuffIdx;
+  /* Specifies the Bytes per Page*/
+  uint8_t BytesPerPage;
 
-    /* Specifies the Block number Lock cntrl TLV*/
-    uint16_t             BlkNum;
+  /* Specifies the index of Mem cntrl TLV*/
+  uint8_t MemTlvBuffIdx;
 
-    /* Specifies the Byte Number position of Lock cntrl TLV*/
-    uint16_t             ByteNum;
+  /* Specifies the Block number Lock cntrl TLV*/
+  uint16_t BlkNum;
 
+  /* Specifies the Byte Number position of Lock cntrl TLV*/
+  uint16_t ByteNum;
 
-
-}phFriNfc_ResMemCntrlTLVCont_t;
+} phFriNfc_ResMemCntrlTLVCont_t;
 
 /*
  *  NFC NDEF Mapping Component Context Structure
  *
- *  This structure is used to store the current context information of the instance.
+ *  This structure is used to store the current context information of the
+ *instance.
  *
  */
-typedef struct phFriNfc_NdefMap
-{
-    /* The state of the operation. */
-    uint8_t                         State;
-
-    /* Completion Routine Context. */
-    phFriNfc_CplRt_t                CompletionRoutine[PH_FRINFC_NDEFMAP_CR];
+typedef struct phFriNfc_NdefMap {
+  /* The state of the operation. */
+  uint8_t State;
 
-    phNfc_sTransceiveInfo_t            *pTransceiveInfo;
+  /* Completion Routine Context. */
+  phFriNfc_CplRt_t CompletionRoutine[PH_FRINFC_NDEFMAP_CR];
 
-    /*Holds the completion routine informations of the Map Layer*/
-    phFriNfc_CplRt_t                MapCompletionInfo;
+  phNfc_sTransceiveInfo_t* pTransceiveInfo;
 
-    /* Pointer to the Remote Device Information */
-    phLibNfc_sRemoteDevInformation_t   *psRemoteDevInfo;
+  /*Holds the completion routine informations of the Map Layer*/
+  phFriNfc_CplRt_t MapCompletionInfo;
 
-    /*Holds the Command Type(read/write)*/
-    phNfc_uCmdList_t               Cmd;
+  /* Pointer to the Remote Device Information */
+  phLibNfc_sRemoteDevInformation_t* psRemoteDevInfo;
 
-    /* Pointer to a temporary buffer. Could be
-          used for read/write purposes */
-    uint8_t                         *ApduBuffer;
+  /*Holds the Command Type(read/write)*/
+  phNfc_uCmdList_t Cmd;
 
-    /* Size allocated to the ApduBuffer. */
-    uint32_t                        ApduBufferSize;
+  /* Pointer to a temporary buffer. Could be
+        used for read/write purposes */
+  uint8_t* ApduBuffer;
 
-    /* Index to the APDU Buffer. Used for internal calculations */
-    uint16_t                        ApduBuffIndex;
+  /* Size allocated to the ApduBuffer. */
+  uint32_t ApduBufferSize;
 
-    /* Pointer to the user-provided Data Size to be written trough WrNdef function. */
-    uint32_t                        *WrNdefPacketLength;
+  /* Index to the APDU Buffer. Used for internal calculations */
+  uint16_t ApduBuffIndex;
 
+  /* Pointer to the user-provided Data Size to be written trough WrNdef
+   * function. */
+  uint32_t* WrNdefPacketLength;
 
-    /* Holds the length of the received data. */
-    uint16_t                        *SendRecvLength;
+  /* Holds the length of the received data. */
+  uint16_t* SendRecvLength;
 
-    /*Holds the ack of some initial commands*/
-    uint8_t                         *SendRecvBuf;
+  /*Holds the ack of some initial commands*/
+  uint8_t* SendRecvBuf;
 
-    /* Holds the length of the data to be sent. */
-    uint16_t                        SendLength;
+  /* Holds the length of the data to be sent. */
+  uint16_t SendLength;
 
-    /* Data Byte Count, which gives the offset to the integration.*/
-    uint16_t                        *DataCount;
+  /* Data Byte Count, which gives the offset to the integration.*/
+  uint16_t* DataCount;
 
-    /* Holds the previous operation on the card*/
-    uint8_t                         PrevOperation;
+  /* Holds the previous operation on the card*/
+  uint8_t PrevOperation;
 
-    /* Holds the previous read mode*/
-    uint8_t                         bPrevReadMode;
+  /* Holds the previous read mode*/
+  uint8_t bPrevReadMode;
 
-    /* Holds the current read mode*/
-    uint8_t                         bCurrReadMode;
+  /* Holds the current read mode*/
+  uint8_t bCurrReadMode;
 
-    /* Holds the previous state on the card*/
-    uint8_t                         PrevState;
+  /* Holds the previous state on the card*/
+  uint8_t PrevState;
 
-    /* Stores the type of the smart card. */
-    uint8_t                         CardType;
+  /* Stores the type of the smart card. */
+  uint8_t CardType;
 
-     /* Stores the card state. */
-    uint8_t                         CardState;
+  /* Stores the card state. */
+  uint8_t CardState;
 
-    /* Stores the memory size of the card */
-    uint16_t                        CardMemSize;
+  /* Stores the memory size of the card */
+  uint16_t CardMemSize;
 
-    /*to Store the page offset on the mifare ul card*/
-    uint8_t                         Offset;
+  /*to Store the page offset on the mifare ul card*/
+  uint8_t Offset;
 
-    /* specifies the desired operation to be performed*/
-    uint8_t                         DespOpFlag;
+  /* specifies the desired operation to be performed*/
+  uint8_t DespOpFlag;
 
-    /*  Used to remember how many bytes were written, to update
-                   the dataCount and the BufferIndex */
-    uint16_t                        NumOfBytesWritten;
+  /*  Used to remember how many bytes were written, to update
+                 the dataCount and the BufferIndex */
+  uint16_t NumOfBytesWritten;
 
-    /*used to remember number of L byte Remaining to be written */
-    uint16_t                        NumOfLReminWrite;
+  /*used to remember number of L byte Remaining to be written */
+  uint16_t NumOfLReminWrite;
 
-    /*  Pointer Used to remember and return how many bytes were read,
-                   to update the PacketDataLength in case of Read operation */
-    /*  Fix for 0000238: [gk] MAP: Number of bytes actually read out is
-        not returned. */
-    uint32_t                        *NumOfBytesRead;
+  /*  Pointer Used to remember and return how many bytes were read,
+                 to update the PacketDataLength in case of Read operation */
+  /*  Fix for 0000238: [gk] MAP: Number of bytes actually read out is
+      not returned. */
+  uint32_t* NumOfBytesRead;
 
-    /*  Flag used to tell the process function that WRITE has
-                   requested for an internal READ.*/
-    uint8_t                         ReadingForWriteOperation;
+  /*  Flag used to tell the process function that WRITE has
+                 requested for an internal READ.*/
+  uint8_t ReadingForWriteOperation;
 
-    /*  Buffer of 5 bytes used for the write operation for the
-                   Mifare UL card.*/
-    uint8_t                         BufferForWriteOp[5];
+  /*  Buffer of 5 bytes used for the write operation for the
+                 Mifare UL card.*/
+  uint8_t BufferForWriteOp[5];
 
-    /* Temporary Receive Length to update the Receive Length
-                  when every time the Overlapped HAL is called. */
-    uint16_t                        TempReceiveLength;
+  /* Temporary Receive Length to update the Receive Length
+                when every time the Overlapped HAL is called. */
+  uint16_t TempReceiveLength;
 
-    uint8_t                         NoOfDevices ;
+  uint8_t NoOfDevices;
 
-    /* stores operating mode type of the felica smart tag */
-    /* phHal_eOpModes_t                OpModeType[2]; */
+  /* stores operating mode type of the felica smart tag */
+  /* phHal_eOpModes_t                OpModeType[2]; */
 
-    /* stores the type of the TLV found */
-    uint8_t                         TLVFoundFlag;
+  /* stores the type of the TLV found */
+  uint8_t TLVFoundFlag;
 
-    /* stores the TLV structure related informations  */
-    phFriNfc_NDEFTLVCont_t          TLVStruct;
+  /* stores the TLV structure related informations  */
+  phFriNfc_NDEFTLVCont_t TLVStruct;
 
-    /* stores the Lock Contrl Tlv related informations  */
-    phFriNfc_LockCntrlTLVCont_t     LockTlv;
+  /* stores the Lock Contrl Tlv related informations  */
+  phFriNfc_LockCntrlTLVCont_t LockTlv;
 
-    /* stores the Mem Contrl Tlv related informations  */
-    phFriNfc_ResMemCntrlTLVCont_t   MemTlv;
+  /* stores the Mem Contrl Tlv related informations  */
+  phFriNfc_ResMemCntrlTLVCont_t MemTlv;
 
-    /* Pointer to the Mifare Standard capability Container Structure. */
-    phFriNfc_MifareStdCont_t        StdMifareContainer;
+  /* Pointer to the Mifare Standard capability Container Structure. */
+  phFriNfc_MifareStdCont_t StdMifareContainer;
 
 } phFriNfc_NdefMap_t;
 
 /*
  * States of the FSM.
  */
-#define PH_FRINFC_NDEFMAP_STATE_RESET_INIT                  0   /* Initial state */
-#define PH_FRINFC_NDEFMAP_STATE_CR_REGISTERED               1   /* CR has been registered */
-#define PH_FRINFC_NDEFMAP_STATE_EOF_CARD                    2   /* EOF card reached */
+#define PH_FRINFC_NDEFMAP_STATE_RESET_INIT 0    /* Initial state */
+#define PH_FRINFC_NDEFMAP_STATE_CR_REGISTERED 1 /* CR has been registered */
+#define PH_FRINFC_NDEFMAP_STATE_EOF_CARD 2      /* EOF card reached */
 
-/* Following values specify the previous operation on the card. This value is assigned to
+/* Following values specify the previous operation on the card. This value is
+   assigned to
    the context structure variable: PrevOperation. */
 
 /* Previous operation is check */
-#define PH_FRINFC_NDEFMAP_CHECK_OPE                         1
+#define PH_FRINFC_NDEFMAP_CHECK_OPE 1
 /* Previous operation is read */
-#define PH_FRINFC_NDEFMAP_READ_OPE                          2
+#define PH_FRINFC_NDEFMAP_READ_OPE 2
 /* Previous operation is write */
-#define PH_FRINFC_NDEFMAP_WRITE_OPE                         3
+#define PH_FRINFC_NDEFMAP_WRITE_OPE 3
 /* Previous operation is Actual size */
-#define PH_FRINFC_NDEFMAP_GET_ACTSIZE_OPE                   4
+#define PH_FRINFC_NDEFMAP_GET_ACTSIZE_OPE 4
 
 /* This flag is set when there is a need of write operation on the odd positions
    ex: 35,5 etc. This is used with MfUlOp Flag */
-#define PH_FRINFC_MFUL_INTERNAL_READ                        3  /* Read/Write control*/
-
+#define PH_FRINFC_MFUL_INTERNAL_READ 3 /* Read/Write control*/
 
 #endif /* PHFRINFC_NDEFMAP_H */
diff --git a/nci/jni/extns/pn54x/src/mifare/phFriNfc_SmtCrdFmt.c b/nci/jni/extns/pn54x/src/mifare/phFriNfc_SmtCrdFmt.c
deleted file mode 100644
index 46f2ccc2..00000000
--- a/nci/jni/extns/pn54x/src/mifare/phFriNfc_SmtCrdFmt.c
+++ /dev/null
@@ -1,219 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Smart Card Completion Routing component
- */
-
-#include <phNfcTypes.h>
-#include<phFriNfc.h>
-#include <phFriNfc_SmtCrdFmt.h>
-#include <phNfcCompId.h>
-#include <phFriNfc_MifStdFormat.h>
-
-
-/*******************************************************************************
-**
-** Function         phFriNfc_SmtCrdFmt_HCrHandler
-**
-** Description      This function is called to complete Completion Routine when gets error.
-**
-** Returns          none.
-**
-*******************************************************************************/
-void phFriNfc_SmtCrdFmt_HCrHandler(phFriNfc_sNdefSmtCrdFmt_t  *NdefSmtCrdFmt, NFCSTATUS Status)
-{
-    /* set the state back to the Reset_Init state*/
-    NdefSmtCrdFmt->State =  PH_FRINFC_SMTCRDFMT_STATE_RESET_INIT;
-
-    /* set the completion routine*/
-    NdefSmtCrdFmt->CompletionRoutine[PH_FRINFC_SMTCRDFMT_CR_FORMAT].
-        CompletionRoutine(NdefSmtCrdFmt->CompletionRoutine->Context, Status);
-
-    return;
-}
-
-/*******************************************************************************
-**
-** Function         phFriNfc_NdefSmtCrd_Reset
-**
-** Description      Resets the component instance to the initial state and initializes the
-**                  internal variables.
-**                  This function has to be called at the beginning, after creating an instance of
-**                  phFriNfc_sNdefSmtCrdFmt_t.  Use this function to reset the instance and/or to switch
-**                  to a different underlying card types.
-**
-** Returns          NFCSTATUS_SUCCESS if operation successful.
-**                  NFCSTATUS_INVALID_PARAMETER if at least one parameter of the function is invalid.
-**
-*******************************************************************************/
-NFCSTATUS phFriNfc_NdefSmtCrd_Reset(phFriNfc_sNdefSmtCrdFmt_t       *NdefSmtCrdFmt,
-                                    void                            *LowerDevice,
-                                    phHal_sRemoteDevInformation_t   *psRemoteDevInfo,
-                                    uint8_t                         *SendRecvBuffer,
-                                    uint16_t                        *SendRecvBuffLen)
-{
-    NFCSTATUS   result = NFCSTATUS_SUCCESS;
-    uint8_t     index;
-    if (    (SendRecvBuffLen == NULL) || (NdefSmtCrdFmt == NULL) || (psRemoteDevInfo == NULL) ||
-            (SendRecvBuffer == NULL) ||  (LowerDevice == NULL) ||
-            (*SendRecvBuffLen == 0) ||
-            (*SendRecvBuffLen < PH_FRINFC_SMTCRDFMT_MAX_SEND_RECV_BUF_SIZE) )
-    {
-        result = PHNFCSTVAL(CID_FRI_NFC_NDEF_SMTCRDFMT, NFCSTATUS_INVALID_PARAMETER);
-    }
-    else
-    {
-        /* Initialize the state to Init */
-        NdefSmtCrdFmt->State = PH_FRINFC_SMTCRDFMT_STATE_RESET_INIT;
-
-        for(index = 0;index<PH_FRINFC_SMTCRDFMT_CR;index++)
-        {
-            /* Initialize the NdefMap Completion Routine to Null */
-            NdefSmtCrdFmt->CompletionRoutine[index].CompletionRoutine = NULL;
-            /* Initialize the NdefMap Completion Routine context to Null  */
-            NdefSmtCrdFmt->CompletionRoutine[index].Context = NULL;
-        }
-
-        /* Lower Device(Always Overlapped HAL Struct initialized in application
-         * is registered in NdefMap Lower Device)
-         */
-        NdefSmtCrdFmt->pTransceiveInfo = LowerDevice;
-
-        /* Remote Device info received from Manual Device Discovery is registered here */
-        NdefSmtCrdFmt->psRemoteDevInfo = psRemoteDevInfo;
-
-        /* Trx Buffer registered */
-        NdefSmtCrdFmt->SendRecvBuf = SendRecvBuffer;
-
-        /* Trx Buffer Size */
-        NdefSmtCrdFmt->SendRecvLength = SendRecvBuffLen;
-
-        /* Register Transfer Buffer Length */
-        NdefSmtCrdFmt->SendLength = 0;
-
-        /* Initialize the Format status flag*/
-        NdefSmtCrdFmt->FmtProcStatus = 0;
-
-        /* Reset the Card Type */
-        NdefSmtCrdFmt->CardType = 0;
-
-        /* Reset MapCompletion Info*/
-        NdefSmtCrdFmt->SmtCrdFmtCompletionInfo.CompletionRoutine = NULL;
-        NdefSmtCrdFmt->SmtCrdFmtCompletionInfo.Context = NULL;
-
-        /* Reset Mifare Standard Container elements*/
-        phFriNfc_MfStd_Reset(NdefSmtCrdFmt);
-    }
-
-    return (result);
-}
-
-/*******************************************************************************
-**
-** Function         phFriNfc_NdefSmtCrd_SetCR
-**
-** Description      This function allows the caller to set a Completion Routine (notifier).
-**
-** Returns          NFCSTATUS_SUCCESS if operation successful.
-**                  NFCSTATUS_INVALID_PARAMETER if at least one parameter of the function is invalid.
-**
-*******************************************************************************/
-NFCSTATUS phFriNfc_NdefSmtCrd_SetCR(phFriNfc_sNdefSmtCrdFmt_t     *NdefSmtCrdFmt,
-                                    uint8_t                       FunctionID,
-                                    pphFriNfc_Cr_t                CompletionRoutine,
-                                    void                          *CompletionRoutineContext)
-{
-    NFCSTATUS   status = NFCSTATUS_SUCCESS;
-    if ((NdefSmtCrdFmt == NULL) || (FunctionID >= PH_FRINFC_SMTCRDFMT_CR) ||
-        (CompletionRoutine == NULL) || (CompletionRoutineContext == NULL))
-    {
-        status = PHNFCSTVAL(CID_FRI_NFC_NDEF_SMTCRDFMT, NFCSTATUS_INVALID_PARAMETER);
-    }
-    else
-    {
-        /* Register the application callback with the NdefMap Completion Routine */
-        NdefSmtCrdFmt->CompletionRoutine[FunctionID].CompletionRoutine = CompletionRoutine;
-
-        /* Register the application context with the NdefMap Completion Routine context */
-        NdefSmtCrdFmt->CompletionRoutine[FunctionID].Context = CompletionRoutineContext;
-    }
-    return status;
-}
-
-/*******************************************************************************
-**
-** Function         phFriNfc_NdefSmtCrd_Process
-**
-** Description      This function is called by the lower layer (OVR HAL)
-**                  when an I/O operation has finished. The internal state machine decides
-**                  whether to call into the lower device again or to complete the process
-**                  by calling into the upper layer's completion routine, stored within this
-**                  component's context (phFriNfc_sNdefSmtCrdFmt_t).
-**
-** Returns          none.
-**
-*******************************************************************************/
-void phFriNfc_NdefSmtCrd_Process(void *Context, NFCSTATUS Status)
-{
-    if ( Context != NULL )
-    {
-        phFriNfc_sNdefSmtCrdFmt_t  *NdefSmtCrdFmt = (phFriNfc_sNdefSmtCrdFmt_t *)Context;
-
-        switch ( NdefSmtCrdFmt->psRemoteDevInfo->RemDevType )
-        {
-            case phNfc_eMifare_PICC :
-            case phNfc_eISO14443_3A_PICC:
-                if((NdefSmtCrdFmt->CardType == PH_FRINFC_SMTCRDFMT_MFSTD_1K_CRD) ||
-                    (NdefSmtCrdFmt->CardType == PH_FRINFC_SMTCRDFMT_MFSTD_4K_CRD) ||
-                    (NdefSmtCrdFmt->CardType == PH_FRINFC_SMTCRDFMT_MFSTD_2K_CRD))
-                {
-                    /* Remote device is Mifare Standard card */
-                    phFriNfc_MfStd_Process(NdefSmtCrdFmt,Status);
-
-                }
-                else
-                {
-                    Status = PHNFCSTVAL(CID_FRI_NFC_NDEF_SMTCRDFMT,
-                                         NFCSTATUS_INVALID_REMOTE_DEVICE);
-                }
-            break;
-            default :
-                /* Remote device opmode not recognized.
-                 * Probably not NDEF compliant
-                 */
-                Status = PHNFCSTVAL(CID_FRI_NFC_NDEF_SMTCRDFMT,
-                                    NFCSTATUS_INVALID_REMOTE_DEVICE);
-                /* set the state back to the Reset_Init state*/
-                NdefSmtCrdFmt->State =  PH_FRINFC_SMTCRDFMT_STATE_RESET_INIT;
-
-                /* set the completion routine*/
-                NdefSmtCrdFmt->CompletionRoutine[PH_FRINFC_SMTCRDFMT_CR_INVALID_OPE].
-                CompletionRoutine(NdefSmtCrdFmt->CompletionRoutine->Context, Status);
-            break;
-        }
-    }
-    else
-    {
-        Status = PHNFCSTVAL(CID_FRI_NFC_NDEF_SMTCRDFMT,\
-                            NFCSTATUS_INVALID_PARAMETER);
-        /* The control should not come here. As Context itself is NULL ,
-         * Can't call the CR
-         */
-    }
-
-    return;
-}
diff --git a/nci/jni/extns/pn54x/src/mifare/phFriNfc_SmtCrdFmt.cpp b/nci/jni/extns/pn54x/src/mifare/phFriNfc_SmtCrdFmt.cpp
new file mode 100644
index 00000000..11e3f27b
--- /dev/null
+++ b/nci/jni/extns/pn54x/src/mifare/phFriNfc_SmtCrdFmt.cpp
@@ -0,0 +1,218 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Smart Card Completion Routing component
+ */
+
+#include <phFriNfc.h>
+#include <phFriNfc_MifStdFormat.h>
+#include <phFriNfc_SmtCrdFmt.h>
+#include <phNfcCompId.h>
+#include <phNfcTypes.h>
+
+/*******************************************************************************
+**
+** Function         phFriNfc_SmtCrdFmt_HCrHandler
+**
+** Description      This function is called to complete Completion Routine when
+*gets error.
+**
+** Returns          none.
+**
+*******************************************************************************/
+void phFriNfc_SmtCrdFmt_HCrHandler(phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt,
+                                   NFCSTATUS Status) {
+  /* set the state back to the Reset_Init state*/
+  NdefSmtCrdFmt->State = PH_FRINFC_SMTCRDFMT_STATE_RESET_INIT;
+
+  /* set the completion routine*/
+  NdefSmtCrdFmt->CompletionRoutine[PH_FRINFC_SMTCRDFMT_CR_FORMAT]
+      .CompletionRoutine(NdefSmtCrdFmt->CompletionRoutine->Context, Status);
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phFriNfc_NdefSmtCrd_Reset
+**
+** Description      Resets the component instance to the initial state and
+*initializes the
+**                  internal variables.
+**                  This function has to be called at the beginning, after
+*creating an instance of
+**                  phFriNfc_sNdefSmtCrdFmt_t.  Use this function to reset the
+*instance and/or to switch
+**                  to a different underlying card types.
+**
+** Returns          NFCSTATUS_SUCCESS if operation successful.
+**                  NFCSTATUS_INVALID_PARAMETER if at least one parameter of the
+*function is invalid.
+**
+*******************************************************************************/
+NFCSTATUS phFriNfc_NdefSmtCrd_Reset(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt, void* LowerDevice,
+    phHal_sRemoteDevInformation_t* psRemoteDevInfo, uint8_t* SendRecvBuffer,
+    uint16_t* SendRecvBuffLen) {
+  NFCSTATUS result = NFCSTATUS_SUCCESS;
+  uint8_t index;
+  if ((SendRecvBuffLen == NULL) || (NdefSmtCrdFmt == NULL) ||
+      (psRemoteDevInfo == NULL) || (SendRecvBuffer == NULL) ||
+      (LowerDevice == NULL) || (*SendRecvBuffLen == 0) ||
+      (*SendRecvBuffLen < PH_FRINFC_SMTCRDFMT_MAX_SEND_RECV_BUF_SIZE)) {
+    result =
+        PHNFCSTVAL(CID_FRI_NFC_NDEF_SMTCRDFMT, NFCSTATUS_INVALID_PARAMETER);
+  } else {
+    /* Initialize the state to Init */
+    NdefSmtCrdFmt->State = PH_FRINFC_SMTCRDFMT_STATE_RESET_INIT;
+
+    for (index = 0; index < PH_FRINFC_SMTCRDFMT_CR; index++) {
+      /* Initialize the NdefMap Completion Routine to Null */
+      NdefSmtCrdFmt->CompletionRoutine[index].CompletionRoutine = NULL;
+      /* Initialize the NdefMap Completion Routine context to Null  */
+      NdefSmtCrdFmt->CompletionRoutine[index].Context = NULL;
+    }
+
+    /* Lower Device(Always Overlapped HAL Struct initialized in application
+     * is registered in NdefMap Lower Device)
+     */
+    NdefSmtCrdFmt->pTransceiveInfo = (phNfc_sTransceiveInfo_t *)LowerDevice;
+
+    /* Remote Device info received from Manual Device Discovery is registered
+     * here */
+    NdefSmtCrdFmt->psRemoteDevInfo = psRemoteDevInfo;
+
+    /* Trx Buffer registered */
+    NdefSmtCrdFmt->SendRecvBuf = SendRecvBuffer;
+
+    /* Trx Buffer Size */
+    NdefSmtCrdFmt->SendRecvLength = SendRecvBuffLen;
+
+    /* Register Transfer Buffer Length */
+    NdefSmtCrdFmt->SendLength = 0;
+
+    /* Initialize the Format status flag*/
+    NdefSmtCrdFmt->FmtProcStatus = 0;
+
+    /* Reset the Card Type */
+    NdefSmtCrdFmt->CardType = 0;
+
+    /* Reset MapCompletion Info*/
+    NdefSmtCrdFmt->SmtCrdFmtCompletionInfo.CompletionRoutine = NULL;
+    NdefSmtCrdFmt->SmtCrdFmtCompletionInfo.Context = NULL;
+
+    /* Reset Mifare Standard Container elements*/
+    phFriNfc_MfStd_Reset(NdefSmtCrdFmt);
+  }
+
+  return (result);
+}
+
+/*******************************************************************************
+**
+** Function         phFriNfc_NdefSmtCrd_SetCR
+**
+** Description      This function allows the caller to set a Completion Routine
+*(notifier).
+**
+** Returns          NFCSTATUS_SUCCESS if operation successful.
+**                  NFCSTATUS_INVALID_PARAMETER if at least one parameter of the
+*function is invalid.
+**
+*******************************************************************************/
+NFCSTATUS phFriNfc_NdefSmtCrd_SetCR(phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt,
+                                    uint8_t FunctionID,
+                                    pphFriNfc_Cr_t CompletionRoutine,
+                                    void* CompletionRoutineContext) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  if ((NdefSmtCrdFmt == NULL) || (FunctionID >= PH_FRINFC_SMTCRDFMT_CR) ||
+      (CompletionRoutine == NULL) || (CompletionRoutineContext == NULL)) {
+    status =
+        PHNFCSTVAL(CID_FRI_NFC_NDEF_SMTCRDFMT, NFCSTATUS_INVALID_PARAMETER);
+  } else {
+    /* Register the application callback with the NdefMap Completion Routine */
+    NdefSmtCrdFmt->CompletionRoutine[FunctionID].CompletionRoutine =
+        CompletionRoutine;
+
+    /* Register the application context with the NdefMap Completion Routine
+     * context */
+    NdefSmtCrdFmt->CompletionRoutine[FunctionID].Context =
+        CompletionRoutineContext;
+  }
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         phFriNfc_NdefSmtCrd_Process
+**
+** Description      This function is called by the lower layer (OVR HAL)
+**                  when an I/O operation has finished. The internal state
+*machine decides
+**                  whether to call into the lower device again or to complete
+*the process
+**                  by calling into the upper layer's completion routine, stored
+*within this
+**                  component's context (phFriNfc_sNdefSmtCrdFmt_t).
+**
+** Returns          none.
+**
+*******************************************************************************/
+void phFriNfc_NdefSmtCrd_Process(void* Context, NFCSTATUS Status) {
+  if (Context != NULL) {
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt =
+        (phFriNfc_sNdefSmtCrdFmt_t*)Context;
+
+    switch (NdefSmtCrdFmt->psRemoteDevInfo->RemDevType) {
+      case phNfc_eMifare_PICC:
+      case phNfc_eISO14443_3A_PICC:
+        if ((NdefSmtCrdFmt->CardType == PH_FRINFC_SMTCRDFMT_MFSTD_1K_CRD) ||
+            (NdefSmtCrdFmt->CardType == PH_FRINFC_SMTCRDFMT_MFSTD_4K_CRD) ||
+            (NdefSmtCrdFmt->CardType == PH_FRINFC_SMTCRDFMT_MFSTD_2K_CRD)) {
+          /* Remote device is Mifare Standard card */
+          phFriNfc_MfStd_Process(NdefSmtCrdFmt, Status);
+
+        } else {
+          Status = PHNFCSTVAL(CID_FRI_NFC_NDEF_SMTCRDFMT,
+                              NFCSTATUS_INVALID_REMOTE_DEVICE);
+        }
+        break;
+      default:
+        /* Remote device opmode not recognized.
+         * Probably not NDEF compliant
+         */
+        Status = PHNFCSTVAL(CID_FRI_NFC_NDEF_SMTCRDFMT,
+                            NFCSTATUS_INVALID_REMOTE_DEVICE);
+        /* set the state back to the Reset_Init state*/
+        NdefSmtCrdFmt->State = PH_FRINFC_SMTCRDFMT_STATE_RESET_INIT;
+
+        /* set the completion routine*/
+        NdefSmtCrdFmt->CompletionRoutine[PH_FRINFC_SMTCRDFMT_CR_INVALID_OPE]
+            .CompletionRoutine(NdefSmtCrdFmt->CompletionRoutine->Context,
+                               Status);
+        break;
+    }
+  } else {
+    Status =
+        PHNFCSTVAL(CID_FRI_NFC_NDEF_SMTCRDFMT, NFCSTATUS_INVALID_PARAMETER);
+    /* The control should not come here. As Context itself is NULL ,
+     * Can't call the CR
+     */
+  }
+
+  return;
+}
diff --git a/nci/jni/extns/pn54x/src/mifare/phFriNfc_SmtCrdFmt.h b/nci/jni/extns/pn54x/src/mifare/phFriNfc_SmtCrdFmt.h
index ac10dee7..0212ac29 100644
--- a/nci/jni/extns/pn54x/src/mifare/phFriNfc_SmtCrdFmt.h
+++ b/nci/jni/extns/pn54x/src/mifare/phFriNfc_SmtCrdFmt.h
@@ -27,96 +27,108 @@
 
 #define DESFIRE_FMT_EV1
 
-#define  PH_FRI_NFC_SMTCRDFMT_NFCSTATUS_FORMAT_ERROR             9                /* Format error */
-#define  PH_FRINFC_SMTCRDFMT_MSTD_DEFAULT_KEYA_OR_KEYB           {0xFF, 0xFF,0xFF,0xFF,0xFF,0xFF} /* Default Key */
-#define  PH_FRINFC_SMTCRDFMT_MSTD_MADSECT_KEYA                   {0xA0, 0xA1,0xA2,0xA3,0xA4,0xA5} /* Key A */
-#define  PH_FRINFC_SMTCRDFMT_NFCFORUMSECT_KEYA                   {0xD3, 0xF7,0xD3,0xF7,0xD3,0xF7} /* NFC Forum Key */
-#define  PH_FRINFC_SMTCRDFMT_MSTD_MADSECT_ACCESSBITS             {0x78,0x77,0x88} /* Access bits */
-#define  PH_FRINFC_SMTCRDFMT_MSTD_NFCFORUM_ACCESSBITS            {0x7F,0x07,0x88} /* NFC Forum access bits */
-#define  PH_FRINFC_SMTCRDFMT_MAX_TLV_TYPE_SUPPORTED              1                /* TLV support */
-#define  PH_FRINFC_SMTCRDFMT_MAX_SEND_RECV_BUF_SIZE              252              /* Buffer size */
-#define  PH_FRINFC_SMTCRDFMT_STATE_RESET_INIT                    1                /* Format state */
+#define PH_FRI_NFC_SMTCRDFMT_NFCSTATUS_FORMAT_ERROR 9 /* Format error */
+#define PH_FRINFC_SMTCRDFMT_MSTD_DEFAULT_KEYA_OR_KEYB \
+  { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF } /* Default Key */
+#define PH_FRINFC_SMTCRDFMT_MSTD_MADSECT_KEYA \
+  { 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5 } /* Key A */
+#define PH_FRINFC_SMTCRDFMT_NFCFORUMSECT_KEYA \
+  { 0xD3, 0xF7, 0xD3, 0xF7, 0xD3, 0xF7 } /* NFC Forum Key */
+#define PH_FRINFC_SMTCRDFMT_MSTD_MADSECT_ACCESSBITS \
+  { 0x78, 0x77, 0x88 } /* Access bits */
+#define PH_FRINFC_SMTCRDFMT_MSTD_NFCFORUM_ACCESSBITS \
+  { 0x7F, 0x07, 0x88 }                               /* NFC Forum access bits */
+#define PH_FRINFC_SMTCRDFMT_MAX_TLV_TYPE_SUPPORTED 1 /* TLV support */
+#define PH_FRINFC_SMTCRDFMT_MAX_SEND_RECV_BUF_SIZE 252 /* Buffer size */
+#define PH_FRINFC_SMTCRDFMT_STATE_RESET_INIT 1         /* Format state */
 
 /*
  * Enum definition contains Tag Types
  */
-enum
-{
-    PH_FRINFC_SMTCRDFMT_MIFARE_UL_CARD,
-    PH_FRINFC_SMTCRDFMT_ISO14443_4A_CARD,
-    PH_FRINFC_SMTCRDFMT_MFSTD_1K_CRD,
-    PH_FRINFC_SMTCRDFMT_MFSTD_2K_CRD,
-    PH_FRINFC_SMTCRDFMT_MFSTD_4K_CRD,
-    PH_FRINFC_SMTCRDFMT_TOPAZ_CARD
+enum {
+  PH_FRINFC_SMTCRDFMT_MIFARE_UL_CARD,
+  PH_FRINFC_SMTCRDFMT_ISO14443_4A_CARD,
+  PH_FRINFC_SMTCRDFMT_MFSTD_1K_CRD,
+  PH_FRINFC_SMTCRDFMT_MFSTD_2K_CRD,
+  PH_FRINFC_SMTCRDFMT_MFSTD_4K_CRD,
+  PH_FRINFC_SMTCRDFMT_TOPAZ_CARD
 };
 
-#define PH_FRINFC_SMTCRDFMT_CR_FORMAT         0  /* Index for phFriNfc_SmtCrd_Format */
-#define PH_FRINFC_SMTCRDFMT_CR_INVALID_OPE    1  /* Index for Unknown States/Operations */
-#define  PH_FRINFC_SMTCRDFMT_CR               2  /* Number of completion routines */
-
- /*
-  * Mifare Std Additional Information Structure
-  */
- typedef struct phFriNfc_MfStd_AddInfo
-{
-    uint8_t     Default_KeyA_OR_B[6];          /* Stores the Default KeyA and KeyB values */
-    uint8_t     MADSect_KeyA[6];               /* Key A of MAD sector */
-    uint8_t     NFCForumSect_KeyA[6];          /* Key A of NFC Forum Sector sector */
-    uint8_t     MADSect_AccessBits[3];         /* Access Bits of MAD sector */
-    uint8_t     NFCForumSect_AccessBits[3];    /* Access Bits of NFC Forum sector */
-    uint8_t     ScrtKeyB[6];                   /* Secret key B to given by the application */
-    uint8_t     AuthState;                     /* Status of the different authentication */
-    uint16_t    CurrentBlock;                  /* Stores the current block */
-    uint8_t     NoOfDevices;                   /* Stores the current block */
-    uint8_t     SectCompl[40];                 /* Store the compliant sectors */
-    uint8_t     WrMADBlkFlag;                  /* Flag to know that MAD sector */
-    uint8_t     MADSectBlk[80];                /* Fill the MAD sector blocks */
-    uint8_t     UpdMADBlk;                     /* Fill the MAD sector blocks */
+#define PH_FRINFC_SMTCRDFMT_CR_FORMAT 0 /* Index for phFriNfc_SmtCrd_Format */
+#define PH_FRINFC_SMTCRDFMT_CR_INVALID_OPE \
+  1                              /* Index for Unknown States/Operations */
+#define PH_FRINFC_SMTCRDFMT_CR 2 /* Number of completion routines */
+
+/*
+ * Mifare Std Additional Information Structure
+ */
+typedef struct phFriNfc_MfStd_AddInfo {
+  uint8_t Default_KeyA_OR_B[6];  /* Stores the Default KeyA and KeyB values */
+  uint8_t MADSect_KeyA[6];       /* Key A of MAD sector */
+  uint8_t NFCForumSect_KeyA[6];  /* Key A of NFC Forum Sector sector */
+  uint8_t MADSect_AccessBits[3]; /* Access Bits of MAD sector */
+  uint8_t NFCForumSect_AccessBits[3]; /* Access Bits of NFC Forum sector */
+  uint8_t ScrtKeyB[6];    /* Secret key B to given by the application */
+  uint8_t AuthState;      /* Status of the different authentication */
+  uint16_t CurrentBlock;  /* Stores the current block */
+  uint8_t NoOfDevices;    /* Stores the current block */
+  uint8_t SectCompl[40];  /* Store the compliant sectors */
+  uint8_t WrMADBlkFlag;   /* Flag to know that MAD sector */
+  uint8_t MADSectBlk[80]; /* Fill the MAD sector blocks */
+  uint8_t UpdMADBlk;      /* Fill the MAD sector blocks */
 } phFriNfc_MfStd_AddInfo_t;
 
 /*
  *  Ndef Mifare Std Additional Information Structure
  */
-typedef struct phFriNfc_sNdefSmtCrdFmt_AddInfo
-{
-   phFriNfc_MfStd_AddInfo_t         MfStdInfo;  /* Mifare Std Additional Information Structure */
+typedef struct phFriNfc_sNdefSmtCrdFmt_AddInfo {
+  phFriNfc_MfStd_AddInfo_t
+      MfStdInfo; /* Mifare Std Additional Information Structure */
 
-}phFriNfc_sNdefSmtCrdFmt_AddInfo_t;
+} phFriNfc_sNdefSmtCrdFmt_AddInfo_t;
 
 /*
  *  Context information Structure
  */
-typedef struct phFriNfc_sNdefSmtCrdFmt
-{
-    phNfc_sTransceiveInfo_t             *pTransceiveInfo;     /* Pointer to the Transceive information */
-    phHal_sRemoteDevInformation_t       *psRemoteDevInfo;     /* Pointer to the Remote Device Information */
-    uint8_t                             CardType;             /* Stores the type of the smart card */
-    uint8_t                             State;                /* The state of the operation */
-    uint8_t                             CardState;            /* Stores the card state */
-    phFriNfc_CplRt_t                    CompletionRoutine[PH_FRINFC_SMTCRDFMT_CR];     /* Completion Routine Context */
-    phFriNfc_CplRt_t                    SmtCrdFmtCompletionInfo;     /* Holds the completion routine informations of the Smart Card Formatting Layer */
-    phHal_uCmdList_t                    Cmd;                  /* Holds the Command Type(read/write) */
-    uint16_t                            *SendRecvLength;      /* Holds the length of the received data */
-    uint8_t                             *SendRecvBuf;         /* Holds the ack of some intial commands */
-    uint16_t                            SendLength;           /* Holds the length of the data to be sent */
-    NFCSTATUS                           FmtProcStatus;        /* Stores the output/result of the format procedure */
-    phFriNfc_sNdefSmtCrdFmt_AddInfo_t   AddInfo;              /* Stores Additional Information needed to format the different types of tags*/
-    uint8_t         TLVMsg[PH_FRINFC_SMTCRDFMT_MAX_TLV_TYPE_SUPPORTED][8];    /* Stores NDEF message TLV */
+typedef struct phFriNfc_sNdefSmtCrdFmt {
+  phNfc_sTransceiveInfo_t*
+      pTransceiveInfo; /* Pointer to the Transceive information */
+  phHal_sRemoteDevInformation_t*
+      psRemoteDevInfo; /* Pointer to the Remote Device Information */
+  uint8_t CardType;    /* Stores the type of the smart card */
+  uint8_t State;       /* The state of the operation */
+  uint8_t CardState;   /* Stores the card state */
+  phFriNfc_CplRt_t CompletionRoutine
+      [PH_FRINFC_SMTCRDFMT_CR];             /* Completion Routine Context */
+  phFriNfc_CplRt_t SmtCrdFmtCompletionInfo; /* Holds the completion routine
+                                               informations of the Smart Card
+                                               Formatting Layer */
+  phHal_uCmdList_t Cmd;     /* Holds the Command Type(read/write) */
+  uint16_t* SendRecvLength; /* Holds the length of the received data */
+  uint8_t* SendRecvBuf;     /* Holds the ack of some intial commands */
+  uint16_t SendLength;      /* Holds the length of the data to be sent */
+  NFCSTATUS
+  FmtProcStatus; /* Stores the output/result of the format procedure */
+  phFriNfc_sNdefSmtCrdFmt_AddInfo_t AddInfo; /* Stores Additional Information
+                                                needed to format the different
+                                                types of tags*/
+  uint8_t TLVMsg[PH_FRINFC_SMTCRDFMT_MAX_TLV_TYPE_SUPPORTED]
+                [8]; /* Stores NDEF message TLV */
 } phFriNfc_sNdefSmtCrdFmt_t;
 
-NFCSTATUS phFriNfc_NdefSmtCrd_Reset(phFriNfc_sNdefSmtCrdFmt_t       *NdefSmtCrdFmt,
-                                    void                            *LowerDevice,
-                                    phHal_sRemoteDevInformation_t   *psRemoteDevInfo,
-                                    uint8_t                         *SendRecvBuffer,
-                                    uint16_t                        *SendRecvBuffLen);
+NFCSTATUS phFriNfc_NdefSmtCrd_Reset(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt, void* LowerDevice,
+    phHal_sRemoteDevInformation_t* psRemoteDevInfo, uint8_t* SendRecvBuffer,
+    uint16_t* SendRecvBuffLen);
 
-NFCSTATUS phFriNfc_NdefSmtCrd_SetCR(phFriNfc_sNdefSmtCrdFmt_t     *NdefSmtCrdFmt,
-                                    uint8_t                       FunctionID,
-                                    pphFriNfc_Cr_t                CompletionRoutine,
-                                    void                          *CompletionRoutineContext);
+NFCSTATUS phFriNfc_NdefSmtCrd_SetCR(phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt,
+                                    uint8_t FunctionID,
+                                    pphFriNfc_Cr_t CompletionRoutine,
+                                    void* CompletionRoutineContext);
 
-void phFriNfc_NdefSmtCrd_Process(void *Context, NFCSTATUS Status);
+void phFriNfc_NdefSmtCrd_Process(void* Context, NFCSTATUS Status);
 
-void phFriNfc_SmtCrdFmt_HCrHandler(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt, NFCSTATUS Status);
+void phFriNfc_SmtCrdFmt_HCrHandler(phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt,
+                                   NFCSTATUS Status);
 
 #endif /* PHFRINFC_SMTCRDFMT_H */
diff --git a/nci/jni/extns/pn54x/src/mifare/phNxpExtns_MifareStd.c b/nci/jni/extns/pn54x/src/mifare/phNxpExtns_MifareStd.c
deleted file mode 100644
index 34caef21..00000000
--- a/nci/jni/extns/pn54x/src/mifare/phNxpExtns_MifareStd.c
+++ /dev/null
@@ -1,2221 +0,0 @@
-/*
- * Copyright (c) 2016, The Linux Foundation. All rights reserved.
- * Not a Contribution.
- *
- * Copyright (C) 2015 NXP Semiconductors
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#define LOG_TAG "pn54x"
-
-#include <log/log.h>
-
-#include <nfc_api.h>
-#include <rw_api.h>
-#include <signal.h>
-#include <phNfcCompId.h>
-#include <phNxpLog.h>
-#include <phNxpExtns_MifareStd.h>
-#include <phFriNfc_MifareStdTimer.h>
-
-phNxpExtns_Context_t       gphNxpExtns_Context;
-phNciNfc_TransceiveInfo_t  tNciTranscvInfo;
-phFriNfc_sNdefSmtCrdFmt_t  *NdefSmtCrdFmt = NULL;
-phFriNfc_NdefMap_t         *NdefMap = NULL;
-phLibNfc_NdefInfo_t        NdefInfo;
-#if(NXP_EXTNS == TRUE)
-pthread_mutex_t SharedDataMutex = PTHREAD_MUTEX_INITIALIZER;
-#endif
-uint8_t current_key[6]={0};
-phNci_mfc_auth_cmd_t       gAuthCmdBuf;
-phFriNfc_MifareStdTimer_t  mTimerInfo;
-
-STATIC NFCSTATUS phNciNfc_SendMfReq(phNciNfc_TransceiveInfo_t tTranscvInfo,
-                                    uint8_t *buff, uint16_t *buffSz);
-STATIC NFCSTATUS phLibNfc_SendRawCmd(phNfc_sTransceiveInfo_t*    pTransceiveInfo,
-                                    pphNciNfc_TransceiveInfo_t   pMappedTranscvIf);
-STATIC NFCSTATUS phLibNfc_SendWrt16Cmd(phNfc_sTransceiveInfo_t*    pTransceiveInfo,
-                                    pphNciNfc_TransceiveInfo_t   pMappedTranscvIf);
-STATIC NFCSTATUS phLibNfc_SendAuthCmd(phNfc_sTransceiveInfo_t *pTransceiveInfo,
-                                      phNciNfc_TransceiveInfo_t  *tNciTranscvInfo) __attribute__((unused));
-STATIC NFCSTATUS phLibNfc_MapCmds(phNciNfc_RFDevType_t         RemDevType,
-                                    phNfc_sTransceiveInfo_t*  pTransceiveInfo,
-                                    pphNciNfc_TransceiveInfo_t   pMappedTranscvIf);
-STATIC NFCSTATUS phLibNfc_MifareMap(phNfc_sTransceiveInfo_t*    pTransceiveInfo,
-                                    pphNciNfc_TransceiveInfo_t   pMappedTranscvIf);
-STATIC NFCSTATUS phLibNfc_ChkAuthCmdMFC(phNfc_sTransceiveInfo_t* pTransceiveInfo,
-                                    uint8_t *bKey);
-STATIC NFCSTATUS phLibNfc_GetKeyNumberMFC(uint8_t *buffer,uint8_t *bKey);
-STATIC void phLibNfc_CalSectorAddress(uint8_t *Sector_Address);
-STATIC NFCSTATUS  phNciNfc_MfCreateAuthCmdHdr(phNciNfc_TransceiveInfo_t tTranscvInfo,
-                                    uint8_t    bBlockAddr,
-                                    uint8_t    *buff,
-                                    uint16_t    *buffSz);
-STATIC NFCSTATUS phNciNfc_MfCreateXchgDataHdr(phNciNfc_TransceiveInfo_t tTranscvInfo,
-                                    uint8_t *buff, uint16_t *buffSz);
-STATIC NFCSTATUS phLibNfc_SendWrt16CmdPayload(phNfc_sTransceiveInfo_t*    pTransceiveInfo,
-                                    pphNciNfc_TransceiveInfo_t   pMappedTranscvIf);
-STATIC NFCSTATUS phNciNfc_RecvMfResp(phNciNfc_Buff_t* RspBuffInfo, NFCSTATUS wStatus);
-STATIC NFCSTATUS nativeNfcExtns_doTransceive(uint8_t *buff, uint16_t buffSz);
-STATIC NFCSTATUS phFriNfc_NdefSmtCrd_Reset__(phFriNfc_sNdefSmtCrdFmt_t    *NdefSmtCrdFmt,
-                                    uint8_t    *SendRecvBuffer,
-                                    uint16_t   *SendRecvBuffLen);
-STATIC NFCSTATUS phFriNfc_ValidateParams(uint8_t  *PacketData,
-                                    uint32_t   *PacketDataLength,
-                                    uint8_t     Offset,
-                                    phFriNfc_NdefMap_t  *pNdefMap,
-                                    uint8_t     bNdefReq);
-STATIC void Mfc_FormatNdef_Completion_Routine(void *NdefCtxt, NFCSTATUS status);
-STATIC void Mfc_WriteNdef_Completion_Routine(void *NdefCtxt, NFCSTATUS status);
-STATIC void Mfc_ReadNdef_Completion_Routine(void *NdefCtxt, NFCSTATUS status);
-STATIC void Mfc_CheckNdef_Completion_Routine(void *NdefCtxt, NFCSTATUS status);
-STATIC void Mfc_CheckNdef_timeoutcb_Routine(union sigval);
-
-/*******************************************************************************
-**
-** Function         phNxpExtns_MfcModuleDeInit
-**
-** Description      It Deinitializes the Mifare module.
-**
-**                  Frees all the memory occupied by Mifare module
-**
-** Returns:
-**                  NFCSTATUS_SUCCESS - if successfully deinitialize
-**                  NFCSTATUS_FAILED  - otherwise
-**
-*******************************************************************************/
-NFCSTATUS phNxpExtns_MfcModuleDeInit(void)
-{
-    NFCSTATUS status = NFCSTATUS_FAILED;
-
-    if(NdefMap != NULL)
-    {
-        if( NdefMap->psRemoteDevInfo != NULL )
-        {
-            free(NdefMap->psRemoteDevInfo);
-            NdefMap->psRemoteDevInfo = NULL;
-        }
-        if( NdefMap->SendRecvBuf != NULL )
-        {
-            free(NdefMap->SendRecvBuf);
-            NdefMap->SendRecvBuf = NULL;
-        }
-        if( NdefMap->SendRecvLength != NULL )
-        {
-            free(NdefMap->SendRecvLength);
-            NdefMap->SendRecvLength = NULL;
-        }
-        if( NdefMap->DataCount != NULL )
-        {
-            free(NdefMap->DataCount);
-            NdefMap->DataCount = NULL;
-        }
-        if( NdefMap->pTransceiveInfo != NULL )
-        {
-            if( NdefMap->pTransceiveInfo->sSendData.buffer != NULL )
-            {
-                free(NdefMap->pTransceiveInfo->sSendData.buffer);
-                NdefMap->pTransceiveInfo->sSendData.buffer = NULL;
-            }
-            if( NdefMap->pTransceiveInfo->sRecvData.buffer != NULL )
-            {
-                free(NdefMap->pTransceiveInfo->sRecvData.buffer);
-                NdefMap->pTransceiveInfo->sRecvData.buffer = NULL;
-            }
-            free(NdefMap->pTransceiveInfo);
-            NdefMap->pTransceiveInfo = NULL;
-        }
-
-        free(NdefMap);
-        NdefMap = NULL;
-    }
-
-    if( tNciTranscvInfo.tSendData.pBuff != NULL )
-    {
-        free(tNciTranscvInfo.tSendData.pBuff);
-        tNciTranscvInfo.tSendData.pBuff = NULL;
-    }
-
-    if( NdefSmtCrdFmt != NULL )
-    {
-        free(NdefSmtCrdFmt);
-        NdefSmtCrdFmt = NULL;
-    }
-#if(NXP_EXTNS == TRUE)
-    pthread_mutex_lock(&SharedDataMutex);
-#endif
-    if ( NULL != NdefInfo.psUpperNdefMsg )
-    {
-        if ( NdefInfo.psUpperNdefMsg->buffer != NULL )
-        {
-            free(NdefInfo.psUpperNdefMsg->buffer);
-            NdefInfo.psUpperNdefMsg->buffer = NULL;
-        }
-        free(NdefInfo.psUpperNdefMsg);
-        NdefInfo.psUpperNdefMsg = NULL;
-    }
-#if(NXP_EXTNS == TRUE)
-    pthread_mutex_unlock(&SharedDataMutex);
-#endif
-    if (NULL != gAuthCmdBuf.pauth_cmd)
-    {
-        if (NULL != gAuthCmdBuf.pauth_cmd->buffer)
-        {
-            free(gAuthCmdBuf.pauth_cmd->buffer);
-            gAuthCmdBuf.pauth_cmd->buffer = NULL;
-        }
-        free(gAuthCmdBuf.pauth_cmd);
-        gAuthCmdBuf.pauth_cmd = NULL;
-    }
-    status = NFCSTATUS_SUCCESS;
-    return status;
-}
-
-/*******************************************************************************
-**
-** Function         phNxpExtns_MfcModuleInit
-**
-** Description      It Initializes the memroy and global variables related
-**                  to Mifare module.
-**
-**                  Reset all the global variables and allocate memory for Mifare module
-**
-** Returns:
-**                  NFCSTATUS_SUCCESS - if successfully deinitialize
-**                  NFCSTATUS_FAILED  - otherwise
-**
-*******************************************************************************/
-NFCSTATUS phNxpExtns_MfcModuleInit(void)
-{
-    NFCSTATUS status = NFCSTATUS_FAILED;
-    gphNxpExtns_Context.writecmdFlag = false;
-    gphNxpExtns_Context.RawWriteCallBack = false;
-    gphNxpExtns_Context.CallBackCtxt   = NULL;
-    gphNxpExtns_Context.CallBackMifare = NULL;
-    gphNxpExtns_Context.ExtnsConnect = false;
-    gphNxpExtns_Context.ExtnsDeactivate = false;
-    gphNxpExtns_Context.ExtnsCallBack = false;
-
-    NdefMap = malloc(sizeof(phFriNfc_NdefMap_t));
-    if( NULL == NdefMap )
-    {
-        goto clean_and_return;
-    }
-    memset(NdefMap,0,sizeof(phFriNfc_NdefMap_t));
-
-    NdefMap->psRemoteDevInfo = malloc(sizeof(phLibNfc_sRemoteDevInformation_t));
-    if( NULL == NdefMap->psRemoteDevInfo )
-    {
-        goto clean_and_return;
-    }
-    memset(NdefMap->psRemoteDevInfo, 0, sizeof(phLibNfc_sRemoteDevInformation_t));
-
-    NdefMap->SendRecvBuf = malloc((uint32_t)(MAX_BUFF_SIZE * 2));
-    if( NULL == NdefMap->SendRecvBuf )
-    {
-        goto clean_and_return;
-    }
-    memset(NdefMap->SendRecvBuf, 0, (MAX_BUFF_SIZE * 2));
-
-    NdefMap->SendRecvLength  = malloc(sizeof(uint16_t));
-    if( NULL ==  NdefMap->SendRecvLength )
-    {
-        goto clean_and_return;
-    }
-    memset(NdefMap->SendRecvLength, 0, sizeof(uint16_t));
-
-    NdefMap->DataCount = malloc(sizeof(uint16_t));
-    if( NULL == NdefMap->DataCount )
-    {
-        goto clean_and_return;
-    }
-    memset(NdefMap->DataCount, 0, sizeof(uint16_t));
-
-    NdefMap->pTransceiveInfo = malloc(sizeof(phNfc_sTransceiveInfo_t));
-    if(NULL == NdefMap->pTransceiveInfo)
-    {
-        goto clean_and_return;
-    }
-    memset(NdefMap->pTransceiveInfo, 0, sizeof(phNfc_sTransceiveInfo_t));
-
-    tNciTranscvInfo.tSendData.pBuff = (uint8_t *)malloc((uint32_t)MAX_BUFF_SIZE);
-    if(NULL == tNciTranscvInfo.tSendData.pBuff)
-    {
-        goto clean_and_return;
-    }
-    memset(tNciTranscvInfo.tSendData.pBuff, 0, MAX_BUFF_SIZE);
-
-    NdefMap->pTransceiveInfo->sSendData.buffer = (uint8_t *)malloc((uint32_t)MAX_BUFF_SIZE);
-    if( NdefMap->pTransceiveInfo->sSendData.buffer == NULL )
-    {
-        goto clean_and_return;
-    }
-    memset( NdefMap->pTransceiveInfo->sSendData.buffer, 0, MAX_BUFF_SIZE );
-    NdefMap->pTransceiveInfo->sSendData.length = MAX_BUFF_SIZE;
-
-    NdefMap->pTransceiveInfo->sRecvData.buffer = (uint8_t *)malloc((uint32_t)MAX_BUFF_SIZE); /* size should be same as sRecvData */
-    if( NdefMap->pTransceiveInfo->sRecvData.buffer == NULL )
-    {
-        goto clean_and_return;
-    }
-    memset( NdefMap->pTransceiveInfo->sRecvData.buffer, 0, MAX_BUFF_SIZE );
-    NdefMap->pTransceiveInfo->sRecvData.length = MAX_BUFF_SIZE;
-
-    NdefSmtCrdFmt = malloc( sizeof(phFriNfc_sNdefSmtCrdFmt_t) );
-    if( NdefSmtCrdFmt == NULL )
-    {
-        goto clean_and_return;
-    }
-    memset( NdefSmtCrdFmt , 0, sizeof(phFriNfc_sNdefSmtCrdFmt_t) );
-#if(NXP_EXTNS == TRUE)
-    pthread_mutex_lock(&SharedDataMutex);
-#endif
-    NdefInfo.psUpperNdefMsg = malloc(sizeof(phNfc_sData_t));
-    if ( NULL == NdefInfo.psUpperNdefMsg )
-    {
-        goto clean_and_return;
-    }
-    memset( NdefInfo.psUpperNdefMsg, 0, sizeof(phNfc_sData_t) );
-    memset (&gAuthCmdBuf, 0, sizeof(phNci_mfc_auth_cmd_t));
-    gAuthCmdBuf.pauth_cmd = malloc(sizeof(phNfc_sData_t));
-    if (NULL == gAuthCmdBuf.pauth_cmd)
-    {
-        goto clean_and_return;
-    }
-    gAuthCmdBuf.pauth_cmd->buffer = malloc((uint32_t)NCI_MAX_DATA_LEN);
-    if (NULL == gAuthCmdBuf.pauth_cmd->buffer)
-    {
-        goto clean_and_return;
-    }
-    status = NFCSTATUS_SUCCESS;
-
-clean_and_return:
-#if(NXP_EXTNS == TRUE)
-    pthread_mutex_unlock(&SharedDataMutex);
-#endif
-    if(status != NFCSTATUS_SUCCESS)
-    {
-        NXPLOG_EXTNS_E("CRIT: Memory Allocation failed for MFC!");
-        phNxpExtns_MfcModuleDeInit();
-    }
-    return status;
-}
-
-/*******************************************************************************
-**
-** Function         Mfc_CheckNdef
-**
-** Description      It triggers NDEF detection for Mifare Classic Tag.
-**
-**
-** Returns          NFCSTATUS_SUCCESS - if successfully initiated
-**                  NFCSTATUS_FAILED  - otherwise
-**
-*******************************************************************************/
-NFCSTATUS Mfc_CheckNdef(void)
-{
-    NFCSTATUS status = NFCSTATUS_FAILED;
-
-    EXTNS_SetCallBackFlag(false);
-    /* Set Completion Routine for CheckNdef */
-    NdefMap->CompletionRoutine[0].CompletionRoutine = Mfc_CheckNdef_Completion_Routine;
-
-    gphNxpExtns_Context.CallBackMifare = phFriNfc_MifareStdMap_Process;
-    gphNxpExtns_Context.CallBackCtxt   = NdefMap;
-    status = phFriNfc_MifareStdMap_H_Reset(NdefMap);
-    if ( NFCSTATUS_SUCCESS == status)
-    {
-        status = phFriNfc_MifareStdMap_ChkNdef(NdefMap);
-        if ( status == NFCSTATUS_PENDING )
-        {
-            status = NFCSTATUS_SUCCESS;
-        }
-    }
-    /*Start a timer for MIFARE Check Ndef response callback handler*/
-    if(NFCSTATUS_SUCCESS == status)
-    {
-        memset(&mTimerInfo,0,sizeof(mTimerInfo));
-        mTimerInfo.mCb = Mfc_CheckNdef_timeoutcb_Routine;
-        mTimerInfo.mtimeout = (uint32_t)PH_FRINFC_CHECK_NDEF_TIMEOUT;
-        status = phFriNfc_MifareStd_StartTimer(&mTimerInfo );
-    }
-    if( status != NFCSTATUS_SUCCESS )
-    {
-        status = NFCSTATUS_FAILED;
-    }
-
-    return status;
-}
-
-/*******************************************************************************
-**
-** Function         Mfc_CheckNdef_Completion_Routine
-**
-** Description      Notify NDEF detection for Mifare Classic Tag to JNI
-**
-**                  Upon completion of NDEF detection, a
-**                  NFA_NDEF_DETECT_EVT will be sent, to notify the application
-**                  of the NDEF attributes (NDEF total memory size, current
-**                  size, etc.).
-**
-** Returns:         void
-**
-*******************************************************************************/
-STATIC void Mfc_CheckNdef_Completion_Routine(void *NdefCtxt, NFCSTATUS status)
-{
-    (void)NdefCtxt;
-    tNFA_CONN_EVT_DATA conn_evt_data;
-    NFCSTATUS timer_status = NFCSTATUS_FAILED;
-    conn_evt_data.ndef_detect.status = status;
-    //stopping checkndef timer if running
-    timer_status = phFriNfc_MifareStd_StopTimer(&mTimerInfo);
-    if(timer_status != NFCSTATUS_SUCCESS)
-    {
-        NXPLOG_EXTNS_E("Failed to stop timer");
-    }
-
-    if(NFCSTATUS_SUCCESS == status)
-    {
-        /* NDef Tag Detected */
-        conn_evt_data.ndef_detect.protocol   = NFA_PROTOCOL_MIFARE;
-        phFrinfc_MifareClassic_GetContainerSize(NdefMap,
-                                                (uint32_t *)&(conn_evt_data.ndef_detect.max_size),
-                                                (uint32_t *)&(conn_evt_data.ndef_detect.cur_size));
-        NdefInfo.NdefLength  = conn_evt_data.ndef_detect.max_size;
-        /* update local flags */
-        NdefInfo.is_ndef = 1;
-        NdefInfo.NdefActualSize = conn_evt_data.ndef_detect.cur_size;
-        if ( PH_NDEFMAP_CARD_STATE_READ_ONLY == NdefMap->CardState )
-        {
-            NXPLOG_EXTNS_D("Mfc_CheckNdef_Completion_Routine : READ_ONLY_CARD");
-            conn_evt_data.ndef_detect.flags = RW_NDEF_FL_READ_ONLY;
-        }
-        else
-        {
-            conn_evt_data.ndef_detect.flags = RW_NDEF_FL_SUPPORTED | RW_NDEF_FL_FORMATED;
-        }
-    }
-    else
-    {
-        /* NDEF Detection failed for other reasons */
-        conn_evt_data.ndef_detect.cur_size = 0;
-        conn_evt_data.ndef_detect.max_size = 0;
-        conn_evt_data.ndef_detect.flags    = RW_NDEF_FL_UNKNOWN;
-
-        /* update local flags */
-        NdefInfo.is_ndef = 0;
-        NdefInfo.NdefActualSize = conn_evt_data.ndef_detect.cur_size;
-    }
-    (*gphNxpExtns_Context.p_conn_cback) (NFA_NDEF_DETECT_EVT, &conn_evt_data);
-
-    return;
-}
-/*******************************************************************************
-**
-** Function         Mfc_ReadNdef_Completion_Routine
-**
-** Description      Notify NDEF read completion for Mifare Classic Tag to JNI
-**
-**                  Upon completion of NDEF read, a
-**                  NFA_READ_CPLT_EVT will be sent, to notify the application
-**                  with the NDEF data and status
-**
-** Returns:         void
-**
-*******************************************************************************/
-STATIC void Mfc_ReadNdef_Completion_Routine(void *NdefCtxt, NFCSTATUS status)
-{
-    (void)NdefCtxt;
-    tNFA_CONN_EVT_DATA conn_evt_data;
-    tNFA_NDEF_EVT_DATA p_data;
-
-    conn_evt_data.status = status;
-#if(NXP_EXTNS == TRUE)
-    pthread_mutex_lock(&SharedDataMutex);
-#endif
-    if(NFCSTATUS_SUCCESS == status)
-    {
-        p_data.ndef_data.len    = NdefInfo.psUpperNdefMsg->length;
-        p_data.ndef_data.p_data = NdefInfo.psUpperNdefMsg->buffer;
-        (*gphNxpExtns_Context.p_ndef_cback) (NFA_NDEF_DATA_EVT, &p_data);
-    }
-    else
-    {
-    }
-
-    (*gphNxpExtns_Context.p_conn_cback) (NFA_READ_CPLT_EVT, &conn_evt_data);
-
-    if( NdefInfo.psUpperNdefMsg->buffer != NULL)
-    {
-        free (NdefInfo.psUpperNdefMsg->buffer);
-        NdefInfo.psUpperNdefMsg->buffer = NULL;
-    }
-#if(NXP_EXTNS == TRUE)
-    pthread_mutex_unlock(&SharedDataMutex);
-#endif
-    return;
-}
-
-/*******************************************************************************
-**
-** Function         Mfc_WriteNdef_Completion_Routine
-**
-** Description      Notify NDEF write completion for Mifare Classic Tag to JNI
-**
-**                  Upon completion of NDEF write, a
-**                  NFA_WRITE_CPLT_EVT will be sent along with status
-**
-** Returns:         void
-**
-*******************************************************************************/
-STATIC void Mfc_WriteNdef_Completion_Routine(void *NdefCtxt, NFCSTATUS status)
-{
-    (void)NdefCtxt;
-    tNFA_CONN_EVT_DATA conn_evt_data;
-
-    conn_evt_data.status = status;
-    (*gphNxpExtns_Context.p_conn_cback) (NFA_WRITE_CPLT_EVT, &conn_evt_data);
-
-    return;
-}
-
-/*******************************************************************************
-**
-** Function         Mfc_FormatNdef_Completion_Routine
-**
-** Description      Notify NDEF format completion for Mifare Classic Tag to JNI
-**
-**                  Upon completion of NDEF format, a
-**                  NFA_FORMAT_CPLT_EVT will be sent along with status
-**
-** Returns:         void
-**
-*******************************************************************************/
-STATIC void Mfc_FormatNdef_Completion_Routine(void *NdefCtxt, NFCSTATUS status)
-{
-    (void)NdefCtxt;
-    tNFA_CONN_EVT_DATA conn_evt_data;
-
-    conn_evt_data.status = status;
-    (*gphNxpExtns_Context.p_conn_cback) (NFA_FORMAT_CPLT_EVT, &conn_evt_data);
-
-    return;
-}
-
-/*******************************************************************************
-**
-** Function          phFriNfc_ValidateParams
-**
-** Description      This function is a common function which validates NdefRd
-**                  and NdefWr parameters.
-**
-** Returns          NFCSTATUS_SUCCESS  - All the params are valid
-**                  NFCSTATUS_FAILED   - otherwise
-**
-*******************************************************************************/
-STATIC NFCSTATUS phFriNfc_ValidateParams(uint8_t             *PacketData,
-                                    uint32_t            *PacketDataLength,
-                                    uint8_t             Offset,
-                                    phFriNfc_NdefMap_t  *pNdefMap,
-                                    uint8_t             bNdefReq)
-{
-
-    if( (pNdefMap == NULL) || (PacketData == NULL)
-        || (PacketDataLength == NULL) )
-    {
-        return NFCSTATUS_FAILED;
-    }
-
-    if( pNdefMap->CardState == PH_NDEFMAP_CARD_STATE_INVALID )
-    {
-        return NFCSTATUS_FAILED;
-    }
-
-    if( bNdefReq == PH_FRINFC_NDEF_READ_REQ )
-    {
-        if( (Offset != PH_FRINFC_NDEFMAP_SEEK_CUR) && (Offset != PH_FRINFC_NDEFMAP_SEEK_BEGIN) )
-        {
-            return NFCSTATUS_FAILED;
-        }
-        if( pNdefMap->CardState == PH_NDEFMAP_CARD_STATE_INITIALIZED )
-        {
-            pNdefMap->NumOfBytesRead  = PacketDataLength;
-            *pNdefMap->NumOfBytesRead = 0;
-            return NFCSTATUS_EOF_NDEF_CONTAINER_REACHED;
-        }
-        if( (pNdefMap->PrevOperation == PH_FRINFC_NDEFMAP_WRITE_OPE) &&
-            (Offset != PH_FRINFC_NDEFMAP_SEEK_BEGIN) )
-        {
-            return NFCSTATUS_FAILED; /* return INVALID_DEVICE_REQUEST */
-        }
-        if( Offset == PH_FRINFC_NDEFMAP_SEEK_BEGIN )
-        {
-            pNdefMap->ApduBuffIndex = 0;
-            *pNdefMap->DataCount    = 0;
-        }
-        else if ( (pNdefMap->bPrevReadMode == PH_FRINFC_NDEFMAP_SEEK_BEGIN) ||
-                  (pNdefMap->bPrevReadMode == PH_FRINFC_NDEFMAP_SEEK_CUR) )
-        {
-
-        }
-        else
-        {
-            return NFCSTATUS_FAILED;
-        }
-    }
-    else if( bNdefReq == PH_FRINFC_NDEF_WRITE_REQ )
-    {
-        if( pNdefMap->CardState == PH_NDEFMAP_CARD_STATE_READ_ONLY )
-        {
-            pNdefMap->WrNdefPacketLength  = PacketDataLength;
-            *pNdefMap->WrNdefPacketLength = 0x00;
-            return NFCSTATUS_NOT_ALLOWED;
-        }
-    }
-
-    return NFCSTATUS_SUCCESS;
-}
-
-/*******************************************************************************
-**
-** Function         Mfc_SetRdOnly_Completion_Routine
-**
-** Description      Notify NDEF read only completion for Mifare Classic Tag to JNI
-**
-**                  Upon completion of NDEF format, a
-**                  NFA_SET_TAG_RO_EVT will be sent along with status
-**
-** Returns:         void
-**
-*******************************************************************************/
-STATIC void Mfc_SetRdOnly_Completion_Routine(void *NdefCtxt, NFCSTATUS status)
-{
-    (void)NdefCtxt;
-    tNFA_CONN_EVT_DATA conn_evt_data;
-    ALOGE("%s status = 0x%x", __func__, status);
-    conn_evt_data.status = status;
-    (*gphNxpExtns_Context.p_conn_cback) (NFA_SET_TAG_RO_EVT, &conn_evt_data);
-
-    return;
-}
-
-/*******************************************************************************
-**
-** Function        Mfc_SetReadOnly
-**
-**
-** Description:    It triggers ConvertToReadOnly  for Mifare Classic Tag.
-**
-** Returns:
-**                  NFCSTATUS_SUCCESS if successfully initiated
-**                  NFCSTATUS_FAILED otherwise
-**
-*******************************************************************************/
-NFCSTATUS Mfc_SetReadOnly(uint8_t *secrtkey, uint8_t len)
-{
-    NXPLOG_EXTNS_D("%s Entering ", __func__);
-    NFCSTATUS status = NFCSTATUS_FAILED;
-    uint8_t mif_secrete_key[6] = {0};
-    uint8_t id = 0;
-    EXTNS_SetCallBackFlag(false);
-    memcpy(mif_secrete_key,secrtkey,len);
-    gphNxpExtns_Context.CallBackMifare = phFriNfc_MifareStdMap_Process;
-    gphNxpExtns_Context.CallBackCtxt   = NdefMap;
-    for (id = 0; id < len; id++)
-    {
-        ALOGV("secrtkey[%d] = 0x%x", id, secrtkey[id]);
-        ALOGV("mif_secrete_key[%d] = 0x%x", id, mif_secrete_key[id]);
-    }
-    /* Set Completion Routine for ReadNdef */
-    NdefMap->CompletionRoutine[0].CompletionRoutine = Mfc_SetRdOnly_Completion_Routine;
-    if(NdefInfo.is_ndef == 0)
-    {
-        status = NFCSTATUS_NON_NDEF_COMPLIANT;
-        goto Mfc_SetRdOnly;
-    }
-    else if( (NdefInfo.is_ndef == 1) && (NdefInfo.NdefActualSize == 0) )
-    {
-#if(NXP_EXTNS == TRUE)
-        pthread_mutex_lock(&SharedDataMutex);
-#endif
-        NdefInfo.psUpperNdefMsg->length = NdefInfo.NdefActualSize;
-#if(NXP_EXTNS == TRUE)
-        pthread_mutex_unlock(&SharedDataMutex);
-#endif
-        status = NFCSTATUS_SUCCESS;
-        goto Mfc_SetRdOnly;
-    }
-    else
-    {
-        status = phFriNfc_MifareStdMap_ConvertToReadOnly(NdefMap, mif_secrete_key);
-    }
-    if ( NFCSTATUS_PENDING == status )
-    {
-        status = NFCSTATUS_SUCCESS;
-    }
-
-Mfc_SetRdOnly:
-    return status;
-}
-
-/*******************************************************************************
-**
-** Function         Mfc_ReadNdef
-**
-** Description      It triggers receiving of the NDEF message from Mifare Classic Tag.
-**
-**
-** Returns:
-**                  NFCSTATUS_SUCCESS - if successfully initiated
-**                  NFCSTATUS_FAILED  - otherwise
-**
-*******************************************************************************/
-NFCSTATUS Mfc_ReadNdef(void)
-{
-    NFCSTATUS status = NFCSTATUS_FAILED;
-    uint8_t            *PacketData = NULL;
-    uint32_t           *PacketDataLength = NULL;
-    phLibNfc_Ndef_EOffset_t Offset;
-
-    EXTNS_SetCallBackFlag(false);
-
-    Offset = phLibNfc_Ndef_EBegin;
-
-    gphNxpExtns_Context.CallBackMifare = phFriNfc_MifareStdMap_Process;
-    gphNxpExtns_Context.CallBackCtxt   = NdefMap;
-#if(NXP_EXTNS == TRUE)
-    pthread_mutex_lock(&SharedDataMutex);
-#endif
-    if(NdefInfo.is_ndef == 0)
-    {
-        status = NFCSTATUS_NON_NDEF_COMPLIANT;
-        goto Mfc_RdNdefEnd;
-    }
-    else if( (NdefInfo.is_ndef == 1) && (NdefInfo.NdefActualSize == 0) )
-    {
-        NdefInfo.psUpperNdefMsg->length = NdefInfo.NdefActualSize;
-        status = NFCSTATUS_SUCCESS;
-        goto Mfc_RdNdefEnd;
-    }
-    else
-    {
-        NdefInfo.psUpperNdefMsg->buffer = malloc(NdefInfo.NdefActualSize);
-        if ( NULL == NdefInfo.psUpperNdefMsg->buffer)
-        {
-           goto Mfc_RdNdefEnd;
-        }
-        NdefInfo.psUpperNdefMsg->length = NdefInfo.NdefActualSize;
-
-        /* Set Completion Routine for ReadNdef */
-        NdefMap->CompletionRoutine[1].CompletionRoutine = Mfc_ReadNdef_Completion_Routine;
-        NdefInfo.NdefContinueRead = (uint8_t) ((phLibNfc_Ndef_EBegin==Offset) ?
-                                                        PH_FRINFC_NDEFMAP_SEEK_BEGIN :
-                                                        PH_FRINFC_NDEFMAP_SEEK_CUR);
-    }
-
-    PacketData             = NdefInfo.psUpperNdefMsg->buffer;
-    PacketDataLength       = (uint32_t*)&(NdefInfo.psUpperNdefMsg->length);
-    NdefMap->bCurrReadMode = Offset;
-    status = phFriNfc_ValidateParams (PacketData, PacketDataLength, Offset, NdefMap, PH_FRINFC_NDEF_READ_REQ);
-    if( status != NFCSTATUS_SUCCESS )
-    {
-        goto Mfc_RdNdefEnd;
-    }
-
-    status = phFriNfc_MifareStdMap_RdNdef(NdefMap, PacketData, PacketDataLength, Offset);
-
-    if(NFCSTATUS_INSUFFICIENT_STORAGE == status)
-    {
-        NdefInfo.psUpperNdefMsg->length = 0x00;
-        status = NFCSTATUS_SUCCESS;
-    }
-
-    if ( NFCSTATUS_PENDING == status )
-    {
-        status = NFCSTATUS_SUCCESS;
-    }
-
-Mfc_RdNdefEnd:
-    if( status != NFCSTATUS_SUCCESS )
-    {
-        if ( NULL != NdefInfo.psUpperNdefMsg->buffer )
-        {
-            free(NdefInfo.psUpperNdefMsg->buffer);
-            NdefInfo.psUpperNdefMsg->buffer = NULL;
-        }
-        status = NFCSTATUS_FAILED;
-    }
-#if(NXP_EXTNS == TRUE)
-    pthread_mutex_unlock(&SharedDataMutex);
-#endif
-    return status;
-
-}
-/*******************************************************************************
-**
-** Function         Mfc_PresenceCheck
-**
-** Description      It triggers receiving of the NDEF message from Mifare Classic Tag.
-**
-**
-** Returns:
-**                  NFCSTATUS_SUCCESS - if successfully initiated
-**                  NFCSTATUS_FAILED  - otherwise
-**
-*******************************************************************************/
-NFCSTATUS Mfc_PresenceCheck(void)
-{
-    NFCSTATUS status = NFCSTATUS_SUCCESS;
-
-    if (gAuthCmdBuf.auth_status == true)
-    {
-        EXTNS_SetCallBackFlag(false);
-        status = nativeNfcExtns_doTransceive(gAuthCmdBuf.pauth_cmd->buffer,
-             gAuthCmdBuf.pauth_cmd->length);
-        if (status != NFCSTATUS_PENDING)
-        {
-            gAuthCmdBuf.auth_sent = false;
-            status = NFCSTATUS_FAILED;
-        }
-        else
-        {
-            gAuthCmdBuf.auth_sent = true;
-            status = NFCSTATUS_SUCCESS;
-        }
-    }
-    else
-    {
-        status = NFCSTATUS_NOT_ALLOWED;
-    }
-    NXPLOG_EXTNS_D("%s status = 0x%x", __func__, status);
-    return status;
-}
-/*******************************************************************************
-**
-** Function         Mfc_WriteNdef
-**
-** Description      It triggers the NDEF data write to Mifare Classic Tag.
-**
-**
-** Returns:
-**                  NFCSTATUS_SUCCESS - if successfully initiated
-**                  NFCSTATUS_FAILED  - otherwise
-**
-*******************************************************************************/
-NFCSTATUS Mfc_WriteNdef(uint8_t *p_data, uint32_t len)
-{
-    NFCSTATUS status = NFCSTATUS_SUCCESS;
-    uint8_t            *PacketData = NULL;
-    uint32_t           *PacketDataLength = NULL;
-
-    if( p_data == NULL || len == 0 )
-    {
-        NXPLOG_EXTNS_E("MFC Error: Invalid Parameters to Ndef Write");
-        status = NFCSTATUS_FAILED;
-        goto Mfc_WrNdefEnd;
-    }
-
-    EXTNS_SetCallBackFlag(false);
-    gphNxpExtns_Context.CallBackMifare = phFriNfc_MifareStdMap_Process;
-    gphNxpExtns_Context.CallBackCtxt   = NdefMap;
-#if(NXP_EXTNS == TRUE)
-    pthread_mutex_lock(&SharedDataMutex);
-#endif
-    if( NdefInfo.is_ndef == PH_LIBNFC_INTERNAL_CHK_NDEF_NOT_DONE )
-    {
-        status = NFCSTATUS_REJECTED;
-        goto Mfc_WrNdefEnd;
-    }
-    else if( NdefInfo.is_ndef == 0 )
-    {
-        status = NFCSTATUS_NON_NDEF_COMPLIANT;
-        goto Mfc_WrNdefEnd;
-    }
-    else if( len > NdefInfo.NdefLength )
-    {
-        status = NFCSTATUS_NOT_ENOUGH_MEMORY;
-        goto Mfc_WrNdefEnd;
-    }
-    else
-    {
-        NdefInfo.psUpperNdefMsg->buffer = p_data;
-        NdefInfo.psUpperNdefMsg->length = len;
-
-        NdefInfo.AppWrLength    = len;
-        NdefMap->CompletionRoutine[2].CompletionRoutine = Mfc_WriteNdef_Completion_Routine;
-        if( 0 == len )
-        {
-            /* TODO: Erase the Tag */
-        }
-        else
-        {
-            NdefMap->ApduBuffIndex = 0x00;
-            *NdefMap->DataCount    = 0x00;
-            PacketData             = NdefInfo.psUpperNdefMsg->buffer;
-            PacketDataLength       = &(NdefInfo.dwWrLength);
-            NdefMap->WrNdefPacketLength = PacketDataLength;
-            NdefInfo.dwWrLength = len;
-
-            status = phFriNfc_ValidateParams (PacketData, PacketDataLength, 0, NdefMap, PH_FRINFC_NDEF_WRITE_REQ);
-            if( status != NFCSTATUS_SUCCESS )
-            {
-                goto Mfc_WrNdefEnd;
-            }
-
-            status = phFriNfc_MifareStdMap_WrNdef(NdefMap, PacketData, PacketDataLength, PH_FRINFC_NDEFMAP_SEEK_BEGIN);
-
-            if ( status == NFCSTATUS_PENDING )
-            {
-                status = NFCSTATUS_SUCCESS;
-            }
-        }
-    }
-
-Mfc_WrNdefEnd:
-#if(NXP_EXTNS == TRUE)
-    pthread_mutex_unlock(&SharedDataMutex);
-#endif
-    if( status != NFCSTATUS_SUCCESS )
-    {
-        status = NFCSTATUS_FAILED;
-    }
-    return status;
-}
-/*******************************************************************************
-**
-** Function          phFriNfc_NdefSmtCrd_Reset__
-**
-** Description      This function Resets the component instance to the initial
-**                  state and initializes the internal variables.
-**
-** Returns          NFCSTATUS_SUCCESS
-**
-*******************************************************************************/
-STATIC NFCSTATUS phFriNfc_NdefSmtCrd_Reset__(phFriNfc_sNdefSmtCrdFmt_t *NdefSmtCrdFmt,
-                                      uint8_t *SendRecvBuffer,
-                                      uint16_t *SendRecvBuffLen)
-{
-//    NFCSTATUS status = NFCSTATUS_FAILED;                      /*commented to eliminate unused variable warning*/
-    uint8_t     index;
-
-    /* Initialize the state to Init */
-    NdefSmtCrdFmt->State = PH_FRINFC_SMTCRDFMT_STATE_RESET_INIT;
-
-    for(index = 0;index<PH_FRINFC_SMTCRDFMT_CR;index++)
-    {
-        /* Initialize the NdefMap Completion Routine to Null */
-        NdefSmtCrdFmt->CompletionRoutine[index].CompletionRoutine = NULL;
-        /* Initialize the NdefMap Completion Routine context to Null  */
-        NdefSmtCrdFmt->CompletionRoutine[index].Context = NULL;
-    }
-
-    /* Trx Buffer registered */
-    NdefSmtCrdFmt->SendRecvBuf = SendRecvBuffer;
-
-    /* Trx Buffer Size */
-    NdefSmtCrdFmt->SendRecvLength = SendRecvBuffLen;
-
-    /* Register Transfer Buffer Length */
-    NdefSmtCrdFmt->SendLength = 0;
-
-    /* Initialize the Format status flag*/
-    NdefSmtCrdFmt->FmtProcStatus = 0;
-
-    /* Reset the Card Type */
-    NdefSmtCrdFmt->CardType = 0;
-
-    /* Reset MapCompletion Info*/
-    NdefSmtCrdFmt->SmtCrdFmtCompletionInfo.CompletionRoutine = NULL;
-    NdefSmtCrdFmt->SmtCrdFmtCompletionInfo.Context = NULL;
-
-    phFriNfc_MfStd_Reset(NdefSmtCrdFmt);
-
-    return NFCSTATUS_SUCCESS;
-}
-
-/*******************************************************************************
-**
-** Function         Mfc_FormatNdef
-**
-** Description      It triggers the NDEF format of Mifare Classic Tag.
-**
-**
-** Returns:
-**                  NFCSTATUS_SUCCESS - if successfully initiated
-**                  NFCSTATUS_FAILED  - otherwise
-**
-*******************************************************************************/
-NFCSTATUS Mfc_FormatNdef(uint8_t *secretkey, uint8_t len)
-{
-    NFCSTATUS status = NFCSTATUS_FAILED;
-    uint8_t   mif_std_key[6] = {0};
-//    static uint8_t   Index;                                               /*commented to eliminate unused variable warning*/
-    uint8_t     sak = 0;
-
-    EXTNS_SetCallBackFlag(false);
-
-    memcpy(mif_std_key,secretkey,len);
-    memcpy(current_key,secretkey,len);
-
-    if( NULL == NdefSmtCrdFmt ||
-        NULL == NdefMap || NULL == NdefMap->SendRecvBuf )
-    {
-        goto Mfc_FormatEnd;
-    }
-    NdefSmtCrdFmt->pTransceiveInfo = NdefMap->pTransceiveInfo;
-
-    gphNxpExtns_Context.CallBackMifare = phFriNfc_MfStd_Process;
-    gphNxpExtns_Context.CallBackCtxt   = NdefSmtCrdFmt;
-
-    NdefInfo.NdefSendRecvLen = NDEF_SENDRCV_BUF_LEN;
-    phFriNfc_NdefSmtCrd_Reset__(NdefSmtCrdFmt, NdefMap->SendRecvBuf, &(NdefInfo.NdefSendRecvLen));
-
-    /* Register Callbacks */
-    NdefSmtCrdFmt->CompletionRoutine[0].CompletionRoutine = Mfc_FormatNdef_Completion_Routine;
-    NdefSmtCrdFmt->CompletionRoutine[1].CompletionRoutine = Mfc_FormatNdef_Completion_Routine;
-    NdefSmtCrdFmt->psRemoteDevInfo = NdefMap->psRemoteDevInfo;
-    sak = NdefSmtCrdFmt->psRemoteDevInfo->RemoteDevInfo.Iso14443A_Info.Sak;
-
-    if((0x08 == (sak & 0x18)) || (0x18 == (sak & 0x18)) ||
-       (0x01 == sak))
-    {
-        NdefSmtCrdFmt->CardType = (uint8_t) (((sak & 0x18) == 0x08)?
-                        PH_FRINFC_SMTCRDFMT_MFSTD_1K_CRD:(((sak & 0x19) == 0x19)?
-                        PH_FRINFC_SMTCRDFMT_MFSTD_2K_CRD:
-                        PH_FRINFC_SMTCRDFMT_MFSTD_4K_CRD));
-        status = phFriNfc_MfStd_Format( NdefSmtCrdFmt, mif_std_key);
-    }
-
-    if( NFCSTATUS_PENDING == status )
-    {
-        status = NFCSTATUS_SUCCESS;
-    }
-
-Mfc_FormatEnd:
-    if( status != NFCSTATUS_SUCCESS )
-    {
-        status = NFCSTATUS_FAILED;
-    }
-
-    return status;
-}
-
-/*******************************************************************************
-**
-** Function         phNxNciExtns_MifareStd_Reconnect
-**
-** Description      This function sends the deactivate command to NFCC for Mifare
-**
-**
-** Returns:
-**                  NFCSTATUS_PENDING - if successfully initiated
-**                  NFCSTATUS_FAILED  - otherwise
-**
-*******************************************************************************/
-NFCSTATUS phNxNciExtns_MifareStd_Reconnect(void)
-{
-    tNFA_STATUS status;
-
-    EXTNS_SetDeactivateFlag(true);
-    if (NFA_STATUS_OK != (status = NFA_Deactivate (true))) /* deactivate to sleep state */
-    {
-        NXPLOG_EXTNS_E ("%s: deactivate failed, status = %d", __func__, status);
-        return NFCSTATUS_FAILED;
-    }
-
-    return NFCSTATUS_PENDING;
-
-}
-
-/*******************************************************************************
-**
-** Function         Mfc_DeactivateCbackSelect
-**
-** Description      This function select the Mifare tag
-**
-**
-** Returns:         void
-**
-*******************************************************************************/
-void Mfc_DeactivateCbackSelect(void)
-{
-    tNFA_STATUS status;
-
-    EXTNS_SetConnectFlag(true);
-    if (NFA_STATUS_OK != (status = NFA_Select (0x01, phNciNfc_e_RfProtocolsMifCProtocol,
-                                                     phNciNfc_e_RfInterfacesTagCmd_RF)))
-    {
-        NXPLOG_EXTNS_E ("%s: NFA_Select failed, status = %d", __func__, status);
-    }
-
-    return;
-}
-
-/*******************************************************************************
-**
-** Function         Mfc_ActivateCback
-**
-** Description      This function invoke the callback when receive the response
-**
-**
-** Returns:         void
-**
-**
-*******************************************************************************/
-void Mfc_ActivateCback(void)
-{
-    gphNxpExtns_Context.CallBackMifare(gphNxpExtns_Context.CallBackCtxt, NFCSTATUS_SUCCESS);
-    return;
-}
-
-/*******************************************************************************
-**
-** Function         Mfc_Transceive
-**
-** Description      Sends raw frame to Mifare Classic Tag.
-**
-** Returns          NFCSTATUS_SUCCESS - if successfully initiated
-**                  NFCSTATUS_FAILED  - otherwise
-**
-*******************************************************************************/
-NFCSTATUS Mfc_Transceive(uint8_t *p_data, uint32_t len)
-{
-    NFCSTATUS status = NFCSTATUS_FAILED;
-    uint8_t i = 0x00;
-
-    gphNxpExtns_Context.RawWriteCallBack = false;
-    gphNxpExtns_Context.CallBackMifare = NULL;
-    gphNxpExtns_Context.CallBackCtxt   = NdefMap;
-
-    EXTNS_SetCallBackFlag(true);
-    if( p_data[0] == 0x60 || p_data[0] == 0x61 )
-    {
-
-        NdefMap->Cmd.MfCmd = p_data[0];
-
-        NdefMap->SendRecvBuf[i++] = p_data[1];
-
-        NdefMap->SendRecvBuf[i++] = p_data[6]; /* TODO, handle 7 byte UID */
-        NdefMap->SendRecvBuf[i++] = p_data[7];
-        NdefMap->SendRecvBuf[i++] = p_data[8];
-        NdefMap->SendRecvBuf[i++] = p_data[9];
-        NdefMap->SendRecvBuf[i++] = p_data[10];
-        NdefMap->SendRecvBuf[i++] = p_data[11];
-
-        status = phFriNfc_ExtnsTransceive(NdefMap->pTransceiveInfo,
-                              NdefMap->Cmd,
-                              NdefMap->SendRecvBuf,
-                              NdefMap->SendLength,
-                              NdefMap->SendRecvLength);
-    }
-    else if( p_data[0] == 0xA0 )
-    {
-        EXTNS_SetCallBackFlag(false);
-        NdefMap->Cmd.MfCmd = phNfc_eMifareWrite16;
-        gphNxpExtns_Context.RawWriteCallBack = true;
-
-        memcpy(NdefMap->SendRecvBuf, &p_data[1], len-1);
-        NdefMap->SendLength = len-1;
-        status = phFriNfc_ExtnsTransceive(NdefMap->pTransceiveInfo,
-                              NdefMap->Cmd,
-                              NdefMap->SendRecvBuf,
-                              NdefMap->SendLength,
-                              NdefMap->SendRecvLength);
-    }
-    else if( (p_data[0] == phNfc_eMifareInc) || (p_data[0] == phNfc_eMifareDec) )
-    {
-
-        EXTNS_SetCallBackFlag(false);
-        NdefMap->Cmd.MfCmd = p_data[0];
-        gphNxpExtns_Context.RawWriteCallBack = true;
-
-        memcpy(NdefMap->SendRecvBuf, &p_data[1], len-1);
-        NdefMap->SendLength = len - 1;
-        status = phFriNfc_ExtnsTransceive(NdefMap->pTransceiveInfo,
-                              NdefMap->Cmd,
-                              NdefMap->SendRecvBuf,
-                              NdefMap->SendLength,
-                              NdefMap->SendRecvLength);
-    }
-    else if( ((p_data[0] == phNfc_eMifareTransfer) || (p_data[0] == phNfc_eMifareRestore)) && (len == 2) )
-    {
-        NdefMap->Cmd.MfCmd = p_data[0];
-        if (p_data[0] == phNfc_eMifareRestore)
-        {
-            EXTNS_SetCallBackFlag(false);
-            gphNxpExtns_Context.RawWriteCallBack = true;
-            memcpy(NdefMap->SendRecvBuf, &p_data[1], len -1);
-            NdefMap->SendLength = len - 1;
-        }
-        else
-        {
-            memcpy(NdefMap->SendRecvBuf, p_data, len);
-            NdefMap->SendLength = len;
-        }
-        status = phFriNfc_ExtnsTransceive(NdefMap->pTransceiveInfo,
-                              NdefMap->Cmd,
-                              NdefMap->SendRecvBuf,
-                              NdefMap->SendLength,
-                              NdefMap->SendRecvLength);
-
-    }
-    else
-    {
-        NdefMap->Cmd.MfCmd = phNfc_eMifareRaw;
-
-        memcpy(NdefMap->SendRecvBuf, p_data, len);
-        NdefMap->SendLength = len;
-        status = phFriNfc_ExtnsTransceive(NdefMap->pTransceiveInfo,
-                              NdefMap->Cmd,
-                              NdefMap->SendRecvBuf,
-                              NdefMap->SendLength,
-                              NdefMap->SendRecvLength);
-    }
-    if (NFCSTATUS_PENDING == status)
-    {
-        status = NFCSTATUS_SUCCESS;
-    }
-    else
-    {
-        NXPLOG_EXTNS_E("ERROR: Mfc_Transceive = 0x%x", status);
-    }
-
-    return status;
-}
-
-/*******************************************************************************
-**
-** Function         nativeNfcExtns_doTransceive
-**
-** Description      Sends raw frame to BCM stack.
-**
-** Returns          NFCSTATUS_PENDING - if successfully initiated
-**                  NFCSTATUS_FAILED  - otherwise
-**
-*******************************************************************************/
-STATIC NFCSTATUS nativeNfcExtns_doTransceive(uint8_t *buff, uint16_t buffSz)
-{
-    NFCSTATUS wStatus = NFCSTATUS_PENDING;
-    tNFA_STATUS status = NFA_SendRawFrame (buff, buffSz, NFA_DM_DEFAULT_PRESENCE_CHECK_START_DELAY);
-
-    if (status != NFA_STATUS_OK)
-    {
-        NXPLOG_EXTNS_E ("%s: fail send; error=%d", __func__, status);
-        wStatus = NFCSTATUS_FAILED;
-    }
-
-    return wStatus;
-}
-
-/*******************************************************************************
-**
-** Function          phNciNfc_RecvMfResp
-**
-** Description      This function shall be invoked as part of ReaderMgmt data
-**                  exchange sequence handler on receiving response/data from NFCC
-**
-** Returns          NFCSTATUS_SUCCESS - Data Reception is successful
-**                  NFCSTATUS_FAILED  - Data Reception failed
-**
-*******************************************************************************/
-STATIC NFCSTATUS
-phNciNfc_RecvMfResp(phNciNfc_Buff_t* RspBuffInfo,
-                        NFCSTATUS          wStatus
-                       )
-{
-    NFCSTATUS               status = NFCSTATUS_SUCCESS;
-    uint16_t                wPldDataSize = 0;
-    phNciNfc_ExtnRespId_t   RecvdExtnRspId = phNciNfc_e_InvalidRsp;
-    uint16_t                wRecvDataSz = 0;
-    NFCSTATUS               writeResponse = NFCSTATUS_SUCCESS;
-    if(NULL == RspBuffInfo)
-    {
-      status = NFCSTATUS_FAILED;
-    }
-    else
-    {
-        if((0 == (RspBuffInfo->wLen))
-                || (PH_NCINFC_STATUS_OK != wStatus)
-                || (NULL == (RspBuffInfo->pBuff))
-                )
-        {
-            status = NFCSTATUS_FAILED;
-        }
-        else
-        {
-            RecvdExtnRspId = (phNciNfc_ExtnRespId_t)RspBuffInfo->pBuff[0];
-
-            switch(RecvdExtnRspId)
-            {
-                case phNciNfc_e_MfXchgDataRsp:
-                {
-                    writeResponse = RspBuffInfo->pBuff[RspBuffInfo->wLen-1];
-                    /* check the status byte */
-                    if((NFC_GetNCIVersion() == NCI_VERSION_2_0) && (((NdefMap->State) == PH_FRINFC_NDEFMAP_STATE_WR_TLV) ||
-                            ((NdefMap->State) == PH_FRINFC_NDEFMAP_STATE_WRITE) ||
-                            ((NdefMap->State) == PH_FRINFC_NDEFMAP_STATE_WR_NDEF_LEN) ||
-                            ((NdefMap->State) == PH_FRINFC_NDEFMAP_STATE_INIT))
-                    ) {
-                        if((writeResponse != NFC_STATUS_OK) &&
-                            ((writeResponse >= T2T_STATUS_OK_1_BIT)&&(writeResponse <= T2T_STATUS_OK_7_BIT)))
-                        {
-                            writeResponse = PH_NCINFC_STATUS_OK;
-                        }
-                      }
-                    if( (writeResponse == PH_NCINFC_STATUS_OK))
-                    {
-                        status = NFCSTATUS_SUCCESS;
-
-                        /* DataLen = TotalRecvdLen - (sizeof(RspId) + sizeof(Status)) */
-                        wPldDataSize = ((RspBuffInfo->wLen) -
-                            (PHNCINFC_EXTNID_SIZE + PHNCINFC_EXTNSTATUS_SIZE));
-                        wRecvDataSz = NCI_MAX_DATA_LEN;
-
-                        /* wPldDataSize = wPldDataSize-1; ==> ignoring the last status byte appended with data */
-                        if((wPldDataSize) <= wRecvDataSz)
-                        {
-                            /* Extract the data part from pBuff[2] & fill it to be sent to upper layer */
-                            memcpy(NdefMap->SendRecvBuf, &(RspBuffInfo->pBuff[1]),(wPldDataSize));
-                            /* update the number of bytes received from lower layer,excluding the status byte */
-                            *(NdefMap->SendRecvLength) = wPldDataSize;
-                        }
-                        else
-                        {
-                            //TODO:- Map some status for remaining extra data received to be sent back to caller??
-                            status = NFCSTATUS_FAILED;
-                        }
-                    }
-                    else
-                    {
-                        status = NFCSTATUS_FAILED;
-                    }
-                }
-                break;
-
-                case phNciNfc_e_MfcAuthRsp:
-                {
-                    /* check the status byte */
-                    if(PH_NCINFC_STATUS_OK == RspBuffInfo->pBuff[1])
-                    {
-                        if (gAuthCmdBuf.auth_sent ==  true)
-                        {
-                            MfcPresenceCheckResult(NFCSTATUS_SUCCESS);
-                            return NFCSTATUS_SUCCESS;
-                        }
-                        gAuthCmdBuf.auth_status = true;
-                        status = NFCSTATUS_SUCCESS;
-
-                        /* DataLen = TotalRecvdLen - (sizeof(RspId) + sizeof(Status)) */
-                        wPldDataSize = ((RspBuffInfo->wLen) -
-                            (PHNCINFC_EXTNID_SIZE + PHNCINFC_EXTNSTATUS_SIZE));
-
-                        /* Extract the data part from pBuff[2] & fill it to be sent to upper layer */
-                        memcpy(NdefMap->SendRecvBuf, &(RspBuffInfo->pBuff[2]),wPldDataSize);
-                        /* update the number of bytes received from lower layer,excluding the status byte */
-                        *(NdefMap->SendRecvLength) = wPldDataSize;
-                    }
-                    else
-                    {
-                        if (gAuthCmdBuf.auth_sent ==  true)
-                        {
-                            gAuthCmdBuf.auth_status = false;
-                            MfcPresenceCheckResult(NFCSTATUS_FAILED);
-                            return NFCSTATUS_SUCCESS;
-                        }
-                        else
-                        {
-                            /* Reset the stored auth command buffer */
-                            memset(gAuthCmdBuf.pauth_cmd->buffer, 0 , NCI_MAX_DATA_LEN);
-                            gAuthCmdBuf.pauth_cmd->length = 0;
-                            gAuthCmdBuf.auth_status = false;
-                        }
-                        status = NFCSTATUS_FAILED;
-                    }
-                }
-                break;
-
-                default:
-                {
-                    status = NFCSTATUS_FAILED;
-                }
-                break;
-            }
-        }
-    }
-
-    return status;
-}
-
-/*******************************************************************************
-**
-** Function         phLibNfc_SendWrt16CmdPayload
-**
-** Description      This function map the raw write cmd
-**
-** Returns          NFCSTATUS_SUCCESS            - Command framing done
-**                  NFCSTATUS_INVALID_PARAMETER  - Otherwise
-**
-*******************************************************************************/
-STATIC NFCSTATUS phLibNfc_SendWrt16CmdPayload(phNfc_sTransceiveInfo_t*    pTransceiveInfo,
-                                    pphNciNfc_TransceiveInfo_t   pMappedTranscvIf)
-{
-    NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
-
-    if( (NULL != pTransceiveInfo->sSendData.buffer) &&
-        (0 != (pTransceiveInfo->sSendData.length)))
-    {
-        memcpy(pMappedTranscvIf->tSendData.pBuff, pTransceiveInfo->sSendData.buffer,
-                              (pTransceiveInfo->sSendData.length));
-        pMappedTranscvIf->tSendData.wLen              = pTransceiveInfo->sSendData.length;
-        pMappedTranscvIf->uCmd.T2TCmd                 = phNciNfc_eT2TRaw;
-    }
-    else
-    {
-        wStatus = NFCSTATUS_INVALID_PARAMETER;
-    }
-
-    if ( gphNxpExtns_Context.RawWriteCallBack == true )
-    {
-        EXTNS_SetCallBackFlag(true);
-        gphNxpExtns_Context.RawWriteCallBack = false;
-    }
-
-    return wStatus;
-}
-
-/*******************************************************************************
-**
-** Function         phLibNfc_SendIncDecCmdPayload
-**
-** Description      This function prepares the Increment/Decrement Value to be
-**                  sent. This is called after sending the Increment/Decrement
-**                  command is already sent and successfull
-**
-** Returns          NFCSTATUS_SUCCESS            - Payload framing done
-**                  NFCSTATUS_INVALID_PARAMETER  - Otherwise
-**
-*******************************************************************************/
-STATIC NFCSTATUS phLibNfc_SendIncDecCmdPayload(phNfc_sTransceiveInfo_t*    pTransceiveInfo,
-                                    pphNciNfc_TransceiveInfo_t   pMappedTranscvIf)
-{
-    NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
-
-    if( (NULL != pTransceiveInfo->sSendData.buffer) &&
-        (0 != (pTransceiveInfo->sSendData.length)))
-    {
-        memcpy(pMappedTranscvIf->tSendData.pBuff, pTransceiveInfo->sSendData.buffer,
-                              (pTransceiveInfo->sSendData.length));
-        pMappedTranscvIf->tSendData.wLen              = pTransceiveInfo->sSendData.length;
-        pMappedTranscvIf->uCmd.T2TCmd                 = phNciNfc_eT2TRaw;
-    }
-    else
-    {
-        wStatus = NFCSTATUS_INVALID_PARAMETER;
-    }
-
-    if ( gphNxpExtns_Context.RawWriteCallBack == true )
-    {
-        EXTNS_SetCallBackFlag(true);
-        gphNxpExtns_Context.RawWriteCallBack = false;
-    }
-
-    return wStatus;
-}
-
-/*******************************************************************************
-**
-** Function         Mfc_RecvPacket
-**
-** Description      Decodes Mifare Classic Tag Response
-**                  This is called from NFA_SendRaw Callback
-**
-** Returns:
-**                  NFCSTATUS_SUCCESS - if successfully initiated
-**                  NFCSTATUS_FAILED  - otherwise
-**
-*******************************************************************************/
-NFCSTATUS Mfc_RecvPacket(uint8_t *buff, uint8_t buffSz)
-{
-    NFCSTATUS    status = NFCSTATUS_SUCCESS;
-    phNciNfc_Buff_t         RspBuff;
-    uint8_t *pcmd_buff;
-    uint16_t buffSize;
-
-    RspBuff.pBuff = buff;
-    RspBuff.wLen  = buffSz;
-    status = phNciNfc_RecvMfResp(&RspBuff, status);
-    if (true == gAuthCmdBuf.auth_sent)
-    {
-        ALOGV("%s Mfc Check Presence in progress", __func__);
-        gAuthCmdBuf.auth_sent = false;
-        return status;
-    }
-    if( true == gphNxpExtns_Context.writecmdFlag && (NFCSTATUS_SUCCESS == status ))
-    {
-        pcmd_buff = (uint8_t *)malloc((uint32_t)MAX_BUFF_SIZE);
-        if( NULL == pcmd_buff )
-        {
-            return NFCSTATUS_FAILED;
-        }
-        buffSize = MAX_BUFF_SIZE;
-        gphNxpExtns_Context.writecmdFlag = false;
-        phLibNfc_SendWrt16CmdPayload(NdefMap->pTransceiveInfo, &tNciTranscvInfo);
-        status = phNciNfc_SendMfReq(tNciTranscvInfo, pcmd_buff, &buffSize);
-        if ( NFCSTATUS_PENDING != status )
-        {
-            NXPLOG_EXTNS_E("ERROR : Mfc_RecvPacket: 0x%x", status);
-        }
-        else
-        {
-            status = NFCSTATUS_SUCCESS;
-        }
-        if( pcmd_buff != NULL )
-        {
-            free(pcmd_buff);
-            pcmd_buff = NULL;
-        }
-    }
-    else if( true == gphNxpExtns_Context.incrdecflag && (NFCSTATUS_SUCCESS == status ))
-    {
-        pcmd_buff = (uint8_t *)malloc((uint32_t)MAX_BUFF_SIZE);
-        if( NULL == pcmd_buff )
-        {
-            return NFCSTATUS_FAILED;
-        }
-        buffSize = MAX_BUFF_SIZE;
-        gphNxpExtns_Context.incrdecflag = false;
-        phLibNfc_SendIncDecCmdPayload(NdefMap->pTransceiveInfo, &tNciTranscvInfo);
-        status = phNciNfc_SendMfReq(tNciTranscvInfo, pcmd_buff, &buffSize);
-        if ( NFCSTATUS_PENDING != status )
-        {
-            NXPLOG_EXTNS_E("ERROR : Mfc_RecvPacket: 0x%x", status);
-        }
-        else
-        {
-            status = NFCSTATUS_SUCCESS;
-        }
-        gphNxpExtns_Context.incrdecstatusflag = true;
-        if( pcmd_buff != NULL )
-        {
-            free(pcmd_buff);
-            pcmd_buff = NULL;
-        }
-
-    }
-    else
-    {
-        if( gphNxpExtns_Context.CallBackMifare != NULL )
-        {
-            if( (gphNxpExtns_Context.incrdecstatusflag == true) && status == 0xB2 )
-            {
-                gphNxpExtns_Context.incrdecstatusflag = false;
-                status = NFCSTATUS_SUCCESS;
-            }
-            gphNxpExtns_Context.CallBackMifare(gphNxpExtns_Context.CallBackCtxt, status);
-        }
-    }
-
-    return status;
-}
-
-/*******************************************************************************
-**
-** Function         phNciNfc_MfCreateXchgDataHdr
-**
-** Description      This function builds the payload header for mifare XchgData
-**                  request to be sent to NFCC.
-**
-** Returns          NFCSTATUS_PENDING            - Command framing done
-**                  NFCSTATUS_FAILED             - Otherwise
-**
-*******************************************************************************/
-STATIC
-NFCSTATUS
-phNciNfc_MfCreateXchgDataHdr(phNciNfc_TransceiveInfo_t tTranscvInfo,
-                             uint8_t *buff, uint16_t *buffSz)
-
-{
-    NFCSTATUS   status = NFCSTATUS_SUCCESS;
-    uint8_t     i = 0;
-
-    buff[i++] = phNciNfc_e_MfRawDataXchgHdr;
-    memcpy(&buff[i],tTranscvInfo.tSendData.pBuff,tTranscvInfo.tSendData.wLen);
-    *buffSz = i + tTranscvInfo.tSendData.wLen;
-
-    status = nativeNfcExtns_doTransceive(buff, (uint16_t) *buffSz);
-
-    return status;
-}
-
-/*******************************************************************************
-**
-** Function         phNciNfc_MfCreateAuthCmdHdr
-**
-** Description      This function builds the payload header for mifare
-**                  classic Authenticate command to be sent to NFCC.
-**
-** Returns          NFCSTATUS_PENDING            - Command framing done
-**                  NFCSTATUS_FAILED             - Otherwise
-**
-*******************************************************************************/
-STATIC
-NFCSTATUS
-phNciNfc_MfCreateAuthCmdHdr(phNciNfc_TransceiveInfo_t tTranscvInfo,
-                            uint8_t    bBlockAddr,
-                            uint8_t    *buff,
-                            uint16_t    *buffSz)
-{
-    NFCSTATUS               status = NFCSTATUS_SUCCESS;
-//    pphNciNfc_RemoteDevInformation_t  pActivDev = NULL;           /*commented to eliminate unused variable warning*/
-    uint8_t bKey = 0x00;
-
-    /*No need to check range of block address*/
-    /*To check for Authenticate A or Authenticate B type command*/
-    if(PHNCINFC_AUTHENTICATION_KEYB ==
-       tTranscvInfo.tSendData.pBuff[0] )
-    {
-        bKey = bKey | PHNCINFC_ENABLE_KEY_B;
-    }
-
-    /*TO Do last 4 bits of Key to be set based of firmware implementation*/
-    /*this value is hardcoded but based on firmware implementation change this value*/
-    bKey = (bKey | PHNCINFC_AUTHENTICATION_KEY);
-
-    bKey |= tTranscvInfo.tSendData.pBuff[2];
-
-    /*For authentication extension no need to copy tSendData buffer of tTranscvInfo */
-    tTranscvInfo.tSendData.wLen = 0x00;
-
-    buff[0] = phNciNfc_e_MfcAuthReq;
-    buff[1] = bBlockAddr;
-    buff[2] = bKey;
-
-    *buffSz = 0x03;
-    if (bKey & PH_NCINFC_MIFARECLASSIC_EMBEDDED_KEY)
-    {
-        memcpy(&buff[3],&tTranscvInfo.tSendData.pBuff[3], PHLIBNFC_MFC_AUTHKEYLEN);
-        *buffSz += PHLIBNFC_MFC_AUTHKEYLEN;
-    }
-    /* Store the auth command buffer to use further for presence check */
-    if (gAuthCmdBuf.pauth_cmd != NULL)
-    {
-        memset(gAuthCmdBuf.pauth_cmd->buffer, 0, NCI_MAX_DATA_LEN);
-        gAuthCmdBuf.pauth_cmd->length = *buffSz;
-        memcpy(gAuthCmdBuf.pauth_cmd->buffer, buff, *buffSz);
-    }
-    status = nativeNfcExtns_doTransceive(buff,(uint16_t) *buffSz);
-
-    return status;
-}
-
-/*******************************************************************************
-**
-** Function         phNciNfc_SendMfReq
-**
-** Description      This function shall be invoked as part of ReaderMgmt data
-**                  exchange sequence handler.
-**                  It shall send the request packet to NFCC.
-**
-** Returns          NFCSTATUS_PENDING  - Send request is Pending
-**                  NFCSTATUS_FAILED   - otherwise
-**
-*******************************************************************************/
-STATIC NFCSTATUS
-phNciNfc_SendMfReq(phNciNfc_TransceiveInfo_t tTranscvInfo, uint8_t *buff, uint16_t *buffSz)
-{
-    NFCSTATUS status = NFCSTATUS_SUCCESS;
-
-    switch(tTranscvInfo.uCmd.T2TCmd)
-    {
-        case phNciNfc_eT2TRaw:
-        {
-            status = phNciNfc_MfCreateXchgDataHdr(tTranscvInfo, buff, buffSz);
-        }
-        break;
-        case phNciNfc_eT2TAuth:
-        {
-            status = phNciNfc_MfCreateAuthCmdHdr(tTranscvInfo,
-                (tTranscvInfo.bAddr), buff, buffSz);
-        }
-        break;
-        default:
-        {
-            status = NFCSTATUS_FAILED;
-            break;
-        }
-    }
-
-    return status;
-}
-
-/*******************************************************************************
-**
-** Function         phLibNfc_CalSectorAddress
-**
-** Description      This function update the sector address for Mifare classic
-**
-** Returns          none
-**
-*******************************************************************************/
-STATIC void phLibNfc_CalSectorAddress(uint8_t *Sector_Address)
-{
-    uint8_t BlockNumber = 0x00;
-
-    if(NULL != Sector_Address)
-    {
-        BlockNumber = *Sector_Address;
-        if(BlockNumber >= PHLIBNFC_MIFARESTD4K_BLK128)
-        {
-            *Sector_Address = (uint8_t)(PHLIBNFC_MIFARESTD_SECTOR_NO32 +
-                              ((BlockNumber - PHLIBNFC_MIFARESTD4K_BLK128)/
-                               PHLIBNFC_MIFARESTD_BLOCK_BYTES));
-        }
-        else
-        {
-            *Sector_Address = BlockNumber/PHLIBNFC_NO_OF_BLKPERSECTOR;
-        }
-     }
-    else
-    {
-    }
-
-    return;
-}
-
-/*******************************************************************************
-**
-** Function         phLibNfc_GetKeyNumberMFC
-**
-** Description      This function find key number based on authentication command
-**
-** Returns          NFCSTATUS_SUCCESS  - If found the key number
-**                  NFCSTATUS_FAILED   - otherwise
-**
-*******************************************************************************/
-STATIC NFCSTATUS phLibNfc_GetKeyNumberMFC(uint8_t *buffer,uint8_t *bKey)
-{
-    int32_t sdwStat   = 0X00;
-    NFCSTATUS wStatus = NFCSTATUS_INVALID_PARAMETER;
-
-    /*Key Configuration
-    uint8_t NdefKey[PHLIBNFC_MFC_AUTHKEYLEN] = {0xD3,0XF7,0xD3,0XF7,0xD3,0XF7};
-    uint8_t RawKey[PHLIBNFC_MFC_AUTHKEYLEN] = {0xFF,0XFF,0xFF,0XFF,0xFF,0XFF};
-    uint8_t MadKey[PHLIBNFC_MFC_AUTHKEYLEN] = {0xA0,0XA1,0xA2,0XA3,0xA4,0XA5};
-    uint8_t Key[PHLIBNFC_MFC_AUTHKEYLEN] = {0x00,0x00,0x00,0x00,0x00,0x00}; */ /*Key used during ndef format*/
-
-    uint8_t bIndex = 0x00;
-    uint8_t bNoOfKeys = 0x00;
-
-#if PHLIBNFC_NXPETENSION_CONFIGURE_MFKEYS
-    uint8_t aMfc_keys[NXP_NUMBER_OF_MFC_KEYS][NXP_MFC_KEY_SIZE] = NXP_MFC_KEYS;
-#else
-    uint8_t aMfc_keys[1][1] = {{0x00}};
-#endif
-
-    if(NULL != bKey &&
-       NULL != buffer )
-    {
-       bNoOfKeys = sizeof(aMfc_keys)/NXP_MFC_KEY_SIZE;
-        /* Traverse through the keys stored to determine whether keys is preloaded key */
-       for(bIndex = 0; bIndex < bNoOfKeys; bIndex++)
-       {
-           /* Check passed key is NDEF key */
-           sdwStat = memcmp(&buffer[PHLIBNFC_MFCUIDLEN_INAUTHCMD],
-                                  aMfc_keys[bIndex], PHLIBNFC_MFC_AUTHKEYLEN);
-           if(!sdwStat)
-           {
-               NXPLOG_EXTNS_E("Mifare : phLibNfc_GetKeyNumberMFC Key found");
-               *bKey = bIndex;
-               wStatus = NFCSTATUS_SUCCESS;
-               break;
-           }
-        }
-       NXPLOG_EXTNS_E("Mifare : phLibNfc_GetKeyNumberMFC returning = 0x%x Key = 0x%x", wStatus, *bKey);
-    }
-    else
-    {
-        wStatus = NFCSTATUS_FAILED;
-        NXPLOG_EXTNS_E("Mifare : phLibNfc_GetKeyNumberMFC returning = 0x%x", wStatus);
-    }
-
-    return wStatus;
-}
-
-/*******************************************************************************
-**
-** Function         phLibNfc_ChkAuthCmdMFC
-**
-** Description      This function Check Authentication command send is proper or not
-**
-** Returns          NFCSTATUS_SUCCESS  - Authenticate command is proper
-**                  NFCSTATUS_FAILED   - otherwise
-**
-*******************************************************************************/
-STATIC NFCSTATUS phLibNfc_ChkAuthCmdMFC(phNfc_sTransceiveInfo_t* pTransceiveInfo,
-                                 uint8_t *bKey)
-{
-    NFCSTATUS wStatus  = NFCSTATUS_SUCCESS;
-
-    if(NULL != pTransceiveInfo &&
-       NULL != pTransceiveInfo->sSendData.buffer &&
-       0 != pTransceiveInfo->sSendData.length &&
-       NULL != bKey)
-    {
-        if((pTransceiveInfo->cmd.MfCmd == phNfc_eMifareAuthentA ||
-           pTransceiveInfo->cmd.MfCmd == phNfc_eMifareAuthentB ))
-        {
-            wStatus = phLibNfc_GetKeyNumberMFC(pTransceiveInfo->sSendData.buffer,bKey);
-        }
-        else
-        {
-            wStatus = NFCSTATUS_FAILED;
-        }
-    }else
-    {
-        wStatus = NFCSTATUS_FAILED;
-    }
-    return wStatus;
-}
-
-/*******************************************************************************
-**
-** Function         phLibNfc_MifareMap
-**
-** Description      Mifare Mapping Utility function
-**
-** Returns          NFCSTATUS_SUCCESS             - Mapping is proper
-**                  NFCSTATUS_INVALID_PARAMETER   - otherwise
-**
-*******************************************************************************/
-STATIC NFCSTATUS phLibNfc_MifareMap(phNfc_sTransceiveInfo_t*    pTransceiveInfo,
-                                    pphNciNfc_TransceiveInfo_t   pMappedTranscvIf)
-{
-    NFCSTATUS status = NFCSTATUS_SUCCESS;
-    uint8_t bBuffIdx = 0;
-    uint8_t bSectorNumber;
-    uint8_t bKey = 0;
-
-    switch(pTransceiveInfo->cmd.MfCmd)
-    {
-        case phNfc_eMifareRead16:
-        {
-            if( (NULL != pTransceiveInfo->sRecvData.buffer) &&
-                (0 != (pTransceiveInfo->sRecvData.length)))
-            {
-                pMappedTranscvIf->tSendData.pBuff[bBuffIdx++] = phNfc_eMifareRead16;
-                pMappedTranscvIf->tSendData.pBuff[bBuffIdx++] = pTransceiveInfo->addr;
-                pMappedTranscvIf->tSendData.wLen              = bBuffIdx;
-                pMappedTranscvIf->uCmd.T2TCmd                 = phNciNfc_eT2TRaw;
-            }
-            else
-            {
-                status = NFCSTATUS_INVALID_PARAMETER;
-            }
-        }
-        break;
-
-        case phNfc_eMifareWrite16:
-        {
-            if( (NULL != pTransceiveInfo->sSendData.buffer) &&
-                (0 != (pTransceiveInfo->sSendData.length)))
-            {
-                pMappedTranscvIf->tSendData.pBuff[bBuffIdx++] = phNfc_eMifareWrite16;
-                pMappedTranscvIf->tSendData.pBuff[bBuffIdx++] = pTransceiveInfo->addr;
-                memcpy(&(pMappedTranscvIf->tSendData.pBuff[bBuffIdx]),pTransceiveInfo->sSendData.buffer,
-                                      (pTransceiveInfo->sSendData.length));
-                pMappedTranscvIf->tSendData.wLen              = bBuffIdx + pTransceiveInfo->sSendData.length;
-                pMappedTranscvIf->uCmd.T2TCmd                 = phNciNfc_eT2TRaw;
-            }
-            else
-            {
-                status = NFCSTATUS_INVALID_PARAMETER;
-            }
-        }
-        break;
-
-        case phNfc_eMifareAuthentA:
-        case phNfc_eMifareAuthentB:
-        {
-            if( (NULL != pTransceiveInfo->sSendData.buffer) &&
-                (0 != (pTransceiveInfo->sSendData.length)) &&
-                (NULL != pTransceiveInfo->sRecvData.buffer) &&
-                (0 != (pTransceiveInfo->sRecvData.length))
-                )
-            {
-                status = phLibNfc_ChkAuthCmdMFC(pTransceiveInfo, &bKey);
-                if(NFCSTATUS_FAILED != status )
-                {
-                    bSectorNumber = pTransceiveInfo->addr;
-                    phLibNfc_CalSectorAddress(&bSectorNumber);
-                    /*For creating extension command header pTransceiveInfo's MfCmd get used*/
-                    pMappedTranscvIf->tSendData.pBuff[bBuffIdx++] = pTransceiveInfo->cmd.MfCmd;
-                    pMappedTranscvIf->tSendData.pBuff[bBuffIdx++] = bSectorNumber;
-                    pMappedTranscvIf->uCmd.T2TCmd = phNciNfc_eT2TAuth;
-                    pMappedTranscvIf->bAddr = bSectorNumber;
-                    pMappedTranscvIf->bNumBlock = pTransceiveInfo->NumBlock;
-                    if(NFCSTATUS_SUCCESS == status)
-                    {
-                        pMappedTranscvIf->tSendData.pBuff[bBuffIdx++] = bKey;
-                        (pMappedTranscvIf->tSendData.wLen) = (uint16_t)(bBuffIdx);
-
-                    }
-                    else if(NFCSTATUS_INVALID_PARAMETER == status)
-                    {
-                        bKey = bKey | PH_NCINFC_MIFARECLASSIC_EMBEDDED_KEY;
-                        pMappedTranscvIf->tSendData.pBuff[bBuffIdx++] = bKey;
-                        memcpy(&pMappedTranscvIf->tSendData.pBuff[bBuffIdx],
-                                &pTransceiveInfo->sSendData.buffer[PHLIBNFC_MFCUIDLEN_INAUTHCMD], PHLIBNFC_MFC_AUTHKEYLEN);
-
-                        (pMappedTranscvIf->tSendData.wLen) = (uint16_t)(bBuffIdx + PHLIBNFC_MFC_AUTHKEYLEN);
-                        status = NFCSTATUS_SUCCESS;
-                    }
-                    else
-                    {
-                        /* do nothing */
-                    }
-                }
-            }
-            else
-            {
-                status = NFCSTATUS_INVALID_PARAMETER;
-            }
-        }
-        break;
-
-        case phNfc_eMifareRaw:
-        {
-
-        }
-        break;
-
-        default:
-        {
-            status = NFCSTATUS_INVALID_PARAMETER;
-            break;
-        }
-    }
-
-    return status;
-}
-
-/*******************************************************************************
-**
-** Function         phLibNfc_MapCmds
-**
-** Description      This function maps the command request from libnfc level to nci level
-**
-** Returns          NFCSTATUS_SUCCESS           - Mapping of command is successful
-**                  NFCSTATUS_INVALID_PARAMETER - One or more of the supplied
-**                  parameters could not be interpreted properly
-**
-*******************************************************************************/
-STATIC NFCSTATUS phLibNfc_MapCmds(phNciNfc_RFDevType_t         RemDevType,
-                           phNfc_sTransceiveInfo_t*  pTransceiveInfo,
-                           pphNciNfc_TransceiveInfo_t   pMappedTranscvIf)
-{
-
-    NFCSTATUS status = NFCSTATUS_SUCCESS;
-
-    if((NULL == pTransceiveInfo) || (NULL == pMappedTranscvIf))
-    {
-        return NFCSTATUS_FAILED;
-    }
-    switch(RemDevType)
-    {
-        case phNciNfc_eMifare1k_PICC:
-        case phNciNfc_eMifare4k_PICC:
-        {
-            status = phLibNfc_MifareMap(pTransceiveInfo,pMappedTranscvIf);
-            break;
-        }
-        default:
-        {
-            break;
-        }
-    }
-
-    return status;
-}
-
-/*******************************************************************************
-**
-** Function         phLibNfc_SendAuthCmd
-**
-** Description      This function Send authentication command to NFCC
-**
-** Returns          NFCSTATUS_SUCCESS           - Parameters are proper
-**                  NFCSTATUS_INVALID_PARAMETER - Otherwise
-**
-*******************************************************************************/
-STATIC NFCSTATUS phLibNfc_SendAuthCmd(phNfc_sTransceiveInfo_t *pTransceiveInfo,
-                                      phNciNfc_TransceiveInfo_t  *tNciTranscvInfo)
-{
-    NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
-
-    wStatus = phLibNfc_MapCmds(phNciNfc_eMifare1k_PICC, pTransceiveInfo, tNciTranscvInfo);
-
-    return wStatus;
-}
-
-/*******************************************************************************
-**
-** Function         phLibNfc_SendWrt16Cmd
-**
-** Description      This function maps Mifarewirte16 commands
-**
-** Returns          NFCSTATUS_SUCCESS           - Parameters are mapped
-**                  NFCSTATUS_INVALID_PARAMETER - Otherwise
-**
-*******************************************************************************/
-STATIC NFCSTATUS phLibNfc_SendWrt16Cmd(phNfc_sTransceiveInfo_t*    pTransceiveInfo,
-                                    pphNciNfc_TransceiveInfo_t   pMappedTranscvIf)
-{
-    NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
-    uint8_t bBuffIdx = 0x00;
-
-    if( (NULL != pTransceiveInfo->sSendData.buffer) &&
-        (0 != (pTransceiveInfo->sSendData.length)))
-    {
-        pMappedTranscvIf->tSendData.pBuff[bBuffIdx++] = phNfc_eMifareWrite16;
-        pMappedTranscvIf->tSendData.pBuff[bBuffIdx++] = pTransceiveInfo->addr;
-        pMappedTranscvIf->tSendData.wLen              = bBuffIdx;
-        pMappedTranscvIf->uCmd.T2TCmd                 = phNciNfc_eT2TRaw;
-    }
-    else
-    {
-        wStatus = NFCSTATUS_INVALID_PARAMETER;
-    }
-
-    return wStatus;
-}
-
-/*******************************************************************************
-**
-** Function         phLibNfc_SendIncDecCmd
-**
-** Description      This function prepares the Increment/Decrement command
-**                  to be sent, increment/decrement value is sent separately
-**
-** Returns          NFCSTATUS_SUCCESS           - Params are mapped
-**                  NFCSTATUS_INVALID_PARAMETER - Otherwise
-**
-*******************************************************************************/
-STATIC NFCSTATUS phLibNfc_SendIncDecCmd(phNfc_sTransceiveInfo_t*    pTransceiveInfo,
-                                    pphNciNfc_TransceiveInfo_t   pMappedTranscvIf,
-                                    uint8_t IncDecCmd)
-{
-    NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
-    uint8_t bBuffIdx = 0x00;
-
-    if( (NULL != pTransceiveInfo->sSendData.buffer) &&
-        (0 != (pTransceiveInfo->sSendData.length)))
-    {
-        pMappedTranscvIf->tSendData.pBuff[bBuffIdx++] = IncDecCmd;
-        pMappedTranscvIf->tSendData.pBuff[bBuffIdx++] = pTransceiveInfo->addr;
-        pMappedTranscvIf->tSendData.wLen              = bBuffIdx;
-        pMappedTranscvIf->uCmd.T2TCmd                 = phNciNfc_eT2TRaw;
-    }
-    else
-    {
-        wStatus = NFCSTATUS_INVALID_PARAMETER;
-    }
-
-    return wStatus;
-}
-
-/*******************************************************************************
-**
-** Function         phLibNfc_SendRawCmd
-**
-** Description      This function maps Mifare raw command
-**
-** Returns          NFCSTATUS_SUCCESS           - Parameters are mapped
-**                  NFCSTATUS_INVALID_PARAMETER - Otherwise
-**
-*******************************************************************************/
-STATIC NFCSTATUS phLibNfc_SendRawCmd(phNfc_sTransceiveInfo_t*    pTransceiveInfo,
-                                    pphNciNfc_TransceiveInfo_t   pMappedTranscvIf)
-{
-    NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
-//    uint8_t bBuffIdx = 0x00;                                  /*commented to eliminate unused variable warning*/
-
-    if( (NULL != pTransceiveInfo->sSendData.buffer) &&
-        (0 != (pTransceiveInfo->sSendData.length)))
-    {
-        memcpy(pMappedTranscvIf->tSendData.pBuff, pTransceiveInfo->sSendData.buffer,
-                              (pTransceiveInfo->sSendData.length));
-        pMappedTranscvIf->tSendData.wLen              = pTransceiveInfo->sSendData.length;
-        pMappedTranscvIf->uCmd.T2TCmd                 = phNciNfc_eT2TRaw;
-    }
-    else
-    {
-        wStatus = NFCSTATUS_INVALID_PARAMETER;
-    }
-
-    return wStatus;
-}
-
-/*******************************************************************************
-**
-** Function         phFriNfc_ExtnsTransceive
-**
-** Description      This function maps Mifare raw command and send it to NFCC
-**
-** Returns          NFCSTATUS_PENDING           - Operation successful
-**                  NFCSTATUS_INVALID_PARAMETER - Otherwise
-**
-*******************************************************************************/
-NFCSTATUS phFriNfc_ExtnsTransceive(phNfc_sTransceiveInfo_t *pTransceiveInfo,
-                                   phNfc_uCmdList_t Cmd,
-                                   uint8_t *SendRecvBuf,
-                                   uint16_t SendLength,
-                                   uint16_t *SendRecvLength)
-{
-    (void)SendRecvLength;
-    NFCSTATUS status = NFCSTATUS_FAILED;
-    uint8_t *buff=NULL;
-    uint16_t buffSz=0;
-    uint8_t i = 0;
-    uint32_t length = SendLength;
-    uint8_t restore_payload[]={0x00, 0x00, 0x00, 0x00,};
-
-    buff = (uint8_t *)malloc((uint32_t)MAX_BUFF_SIZE);
-    if( NULL == buff )
-    {
-        return status;
-    }
-
-    pTransceiveInfo->cmd = Cmd;
-
-    if( (Cmd.MfCmd == phNfc_eMifareAuthentA) ||
-        (Cmd.MfCmd == phNfc_eMifareAuthentB) )
-    {
-        pTransceiveInfo->addr = SendRecvBuf[i++];
-        pTransceiveInfo->sSendData.buffer[4] = SendRecvBuf[i++];
-        pTransceiveInfo->sSendData.buffer[5] = SendRecvBuf[i++];
-        pTransceiveInfo->sSendData.buffer[6] = SendRecvBuf[i++];
-        pTransceiveInfo->sSendData.buffer[7] = SendRecvBuf[i++];
-        pTransceiveInfo->sSendData.buffer[8] = SendRecvBuf[i++];
-        pTransceiveInfo->sSendData.buffer[9] = SendRecvBuf[i++];
-
-        pTransceiveInfo->cmd.MfCmd = Cmd.MfCmd;
-
-        pTransceiveInfo->sSendData.length = length;
-        pTransceiveInfo->sRecvData.length = MAX_BUFF_SIZE;
-        status = phLibNfc_MifareMap(pTransceiveInfo, &tNciTranscvInfo);
-    }
-    else if( Cmd.MfCmd == phNfc_eMifareWrite16 )
-    {
-        pTransceiveInfo->addr = SendRecvBuf[i++];
-        length = SendLength - i;
-        memcpy(pTransceiveInfo->sSendData.buffer, &SendRecvBuf[i], length);
-        pTransceiveInfo->sSendData.length = length;
-        pTransceiveInfo->sRecvData.length = MAX_BUFF_SIZE;
-
-        gphNxpExtns_Context.writecmdFlag = true;
-
-        status = phLibNfc_SendWrt16Cmd(pTransceiveInfo, &tNciTranscvInfo);
-    }
-    else if( (Cmd.MfCmd == phNfc_eMifareInc) || (Cmd.MfCmd == phNfc_eMifareDec) )
-    {
-        pTransceiveInfo->addr = SendRecvBuf[i++];
-        length = SendLength - i;
-        memcpy(pTransceiveInfo->sSendData.buffer, &SendRecvBuf[i], length);
-        pTransceiveInfo->sSendData.length = length;
-        pTransceiveInfo->sRecvData.length = MAX_BUFF_SIZE;
-
-        gphNxpExtns_Context.incrdecflag = true;
-
-        status = phLibNfc_SendIncDecCmd(pTransceiveInfo, &tNciTranscvInfo, Cmd.MfCmd);
-
-    }
-    else if(Cmd.MfCmd == phNfc_eMifareRestore)
-    {
-        pTransceiveInfo->addr = SendRecvBuf[i++];
-        length = SendLength - i;
-        memcpy(pTransceiveInfo->sSendData.buffer, &restore_payload[0], sizeof(restore_payload));
-        pTransceiveInfo->sSendData.length = length + sizeof(restore_payload);
-        pTransceiveInfo->sRecvData.length = MAX_BUFF_SIZE;
-
-        gphNxpExtns_Context.incrdecflag = true;
-
-        status = phLibNfc_SendIncDecCmd(pTransceiveInfo, &tNciTranscvInfo, Cmd.MfCmd);
-
-    }
-    else if ((Cmd.MfCmd == phNfc_eMifareRaw) || (Cmd.MfCmd == phNfc_eMifareTransfer ))
-    {
-        pTransceiveInfo->cmd.MfCmd = (phNfc_eMifareCmdList_t) phNciNfc_eT2TRaw;
-        memcpy(pTransceiveInfo->sSendData.buffer, SendRecvBuf, length);
-        pTransceiveInfo->sSendData.length = length;
-        pTransceiveInfo->sRecvData.length = MAX_BUFF_SIZE;
-        status = phLibNfc_SendRawCmd(pTransceiveInfo, &tNciTranscvInfo);
-    }
-    else
-    {
-        pTransceiveInfo->addr = SendRecvBuf[i++];
-        length = SendLength - i;
-        memcpy(pTransceiveInfo->sSendData.buffer, &SendRecvBuf[i], length);
-        pTransceiveInfo->sSendData.length = length;
-        pTransceiveInfo->sRecvData.length = MAX_BUFF_SIZE;
-        status = phLibNfc_MifareMap(pTransceiveInfo, &tNciTranscvInfo);
-    }
-
-    if (NFCSTATUS_SUCCESS == status )
-    {
-        status = phNciNfc_SendMfReq(tNciTranscvInfo, buff, &buffSz);
-        if (NFCSTATUS_PENDING != status)
-        {
-            NXPLOG_EXTNS_E("ERROR : phNciNfc_SendMfReq()");
-        }
-    }
-    else
-    {
-        NXPLOG_EXTNS_E (" ERROR : Sending phNciNfc_SendMfReq");
-    }
-    if( buff != NULL )
-    {
-        free(buff);
-        buff = NULL;
-    }
-
-    return status;
-}
-/*******************************************************************************
-**
-** Function         Mfc_CheckNdef_timeoutcb_Routine
-**
-** Description      Callback for  Mifare check ndef
-**
-** Returns          None
-**
-**
-*******************************************************************************/
-STATIC void Mfc_CheckNdef_timeoutcb_Routine(union sigval value)
-{
-    (void)value;
-    NXPLOG_EXTNS_E(" Inside Mfc_CheckNdef_timeoutcb_Routine() ");
-    tNFA_CONN_EVT_DATA conn_evt_data;
-    /* NDEF Detection failed for other reasons */
-    conn_evt_data.ndef_detect.status = NFCSTATUS_FAILED;
-    conn_evt_data.ndef_detect.cur_size = 0;
-    conn_evt_data.ndef_detect.max_size = 0;
-    conn_evt_data.ndef_detect.flags    = RW_NDEF_FL_UNKNOWN;
-
-    /* update local flags */
-    NdefInfo.is_ndef = 0;
-    NdefInfo.NdefActualSize = conn_evt_data.ndef_detect.cur_size;
-
-    (*gphNxpExtns_Context.p_conn_cback) (NFA_NDEF_DETECT_EVT, &conn_evt_data);
-
-}
diff --git a/nci/jni/extns/pn54x/src/mifare/phNxpExtns_MifareStd.cpp b/nci/jni/extns/pn54x/src/mifare/phNxpExtns_MifareStd.cpp
new file mode 100644
index 00000000..209d4c91
--- /dev/null
+++ b/nci/jni/extns/pn54x/src/mifare/phNxpExtns_MifareStd.cpp
@@ -0,0 +1,1993 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
+#include <nfc_api.h>
+#include <nfc_int.h>
+#include <phFriNfc_MifareStdTimer.h>
+#include <phNfcCompId.h>
+#include <phNxpExtns_MifareStd.h>
+#include <phNxpLog.h>
+#include <rw_api.h>
+#include <signal.h>
+
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+
+phNxpExtns_Context_t gphNxpExtns_Context;
+phNciNfc_TransceiveInfo_t tNciTranscvInfo;
+phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt = NULL;
+phFriNfc_NdefMap_t* NdefMap = NULL;
+phLibNfc_NdefInfo_t NdefInfo;
+#if (NXP_EXTNS == TRUE)
+pthread_mutex_t SharedDataMutex = PTHREAD_MUTEX_INITIALIZER;
+#endif
+uint8_t current_key[6] = {0};
+phNci_mfc_auth_cmd_t gAuthCmdBuf;
+phFriNfc_MifareStdTimer_t mTimerInfo;
+
+STATIC NFCSTATUS phNciNfc_SendMfReq(phNciNfc_TransceiveInfo_t tTranscvInfo,
+                                    uint8_t* buff, uint16_t* buffSz);
+STATIC NFCSTATUS
+phLibNfc_SendRawCmd(phNfc_sTransceiveInfo_t* pTransceiveInfo,
+                    pphNciNfc_TransceiveInfo_t pMappedTranscvIf);
+STATIC NFCSTATUS
+phLibNfc_SendWrt16Cmd(phNfc_sTransceiveInfo_t* pTransceiveInfo,
+                      pphNciNfc_TransceiveInfo_t pMappedTranscvIf);
+STATIC NFCSTATUS phLibNfc_SendAuthCmd(
+    phNfc_sTransceiveInfo_t* pTransceiveInfo,
+    phNciNfc_TransceiveInfo_t* tNciTranscvInfo) __attribute__((unused));
+STATIC NFCSTATUS phLibNfc_MapCmds(phNciNfc_RFDevType_t RemDevType,
+                                  phNfc_sTransceiveInfo_t* pTransceiveInfo,
+                                  pphNciNfc_TransceiveInfo_t pMappedTranscvIf);
+STATIC NFCSTATUS
+phLibNfc_MifareMap(phNfc_sTransceiveInfo_t* pTransceiveInfo,
+                   pphNciNfc_TransceiveInfo_t pMappedTranscvIf);
+STATIC NFCSTATUS
+phLibNfc_ChkAuthCmdMFC(phNfc_sTransceiveInfo_t* pTransceiveInfo, uint8_t* bKey);
+STATIC NFCSTATUS phLibNfc_GetKeyNumberMFC(uint8_t* buffer, uint8_t* bKey);
+STATIC void phLibNfc_CalSectorAddress(uint8_t* Sector_Address);
+STATIC NFCSTATUS phNciNfc_MfCreateAuthCmdHdr(
+    phNciNfc_TransceiveInfo_t tTranscvInfo, uint8_t bBlockAddr, uint8_t* buff,
+    uint16_t* buffSz);
+STATIC NFCSTATUS phNciNfc_MfCreateXchgDataHdr(
+    phNciNfc_TransceiveInfo_t tTranscvInfo, uint8_t* buff, uint16_t* buffSz);
+STATIC NFCSTATUS
+phLibNfc_SendWrt16CmdPayload(phNfc_sTransceiveInfo_t* pTransceiveInfo,
+                             pphNciNfc_TransceiveInfo_t pMappedTranscvIf);
+STATIC NFCSTATUS phNciNfc_RecvMfResp(phNciNfc_Buff_t* RspBuffInfo,
+                                     NFCSTATUS wStatus);
+STATIC NFCSTATUS nativeNfcExtns_doTransceive(uint8_t* buff, uint16_t buffSz);
+STATIC NFCSTATUS
+phFriNfc_NdefSmtCrd_Reset__(phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt,
+                            uint8_t* SendRecvBuffer, uint16_t* SendRecvBuffLen);
+STATIC NFCSTATUS phFriNfc_ValidateParams(uint8_t* PacketData,
+                                         uint32_t* PacketDataLength,
+                                         uint8_t Offset,
+                                         phFriNfc_NdefMap_t* pNdefMap,
+                                         uint8_t bNdefReq);
+STATIC void Mfc_FormatNdef_Completion_Routine(void* NdefCtxt, NFCSTATUS status);
+STATIC void Mfc_WriteNdef_Completion_Routine(void* NdefCtxt, NFCSTATUS status);
+STATIC void Mfc_ReadNdef_Completion_Routine(void* NdefCtxt, NFCSTATUS status);
+STATIC void Mfc_CheckNdef_Completion_Routine(void* NdefCtxt, NFCSTATUS status);
+STATIC void Mfc_CheckNdef_timeoutcb_Routine(union sigval);
+
+/*******************************************************************************
+**
+** Function         phNxpExtns_MfcModuleDeInit
+**
+** Description      It Deinitializes the Mifare module.
+**
+**                  Frees all the memory occupied by Mifare module
+**
+** Returns:
+**                  NFCSTATUS_SUCCESS - if successfully deinitialize
+**                  NFCSTATUS_FAILED  - otherwise
+**
+*******************************************************************************/
+NFCSTATUS phNxpExtns_MfcModuleDeInit(void) {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+
+  if (NdefMap != NULL) {
+    if (NdefMap->psRemoteDevInfo != NULL) {
+      free(NdefMap->psRemoteDevInfo);
+      NdefMap->psRemoteDevInfo = NULL;
+    }
+    if (NdefMap->SendRecvBuf != NULL) {
+      free(NdefMap->SendRecvBuf);
+      NdefMap->SendRecvBuf = NULL;
+    }
+    if (NdefMap->SendRecvLength != NULL) {
+      free(NdefMap->SendRecvLength);
+      NdefMap->SendRecvLength = NULL;
+    }
+    if (NdefMap->DataCount != NULL) {
+      free(NdefMap->DataCount);
+      NdefMap->DataCount = NULL;
+    }
+    if (NdefMap->pTransceiveInfo != NULL) {
+      if (NdefMap->pTransceiveInfo->sSendData.buffer != NULL) {
+        free(NdefMap->pTransceiveInfo->sSendData.buffer);
+        NdefMap->pTransceiveInfo->sSendData.buffer = NULL;
+      }
+      if (NdefMap->pTransceiveInfo->sRecvData.buffer != NULL) {
+        free(NdefMap->pTransceiveInfo->sRecvData.buffer);
+        NdefMap->pTransceiveInfo->sRecvData.buffer = NULL;
+      }
+      free(NdefMap->pTransceiveInfo);
+      NdefMap->pTransceiveInfo = NULL;
+    }
+
+    free(NdefMap);
+    NdefMap = NULL;
+  }
+
+  if (tNciTranscvInfo.tSendData.pBuff != NULL) {
+    free(tNciTranscvInfo.tSendData.pBuff);
+    tNciTranscvInfo.tSendData.pBuff = NULL;
+  }
+
+  if (NdefSmtCrdFmt != NULL) {
+    free(NdefSmtCrdFmt);
+    NdefSmtCrdFmt = NULL;
+  }
+#if (NXP_EXTNS == TRUE)
+  pthread_mutex_lock(&SharedDataMutex);
+#endif
+  if (NULL != NdefInfo.psUpperNdefMsg) {
+    if (NdefInfo.psUpperNdefMsg->buffer != NULL) {
+      free(NdefInfo.psUpperNdefMsg->buffer);
+      NdefInfo.psUpperNdefMsg->buffer = NULL;
+    }
+    free(NdefInfo.psUpperNdefMsg);
+    NdefInfo.psUpperNdefMsg = NULL;
+  }
+#if (NXP_EXTNS == TRUE)
+  pthread_mutex_unlock(&SharedDataMutex);
+#endif
+  if (NULL != gAuthCmdBuf.pauth_cmd) {
+    if (NULL != gAuthCmdBuf.pauth_cmd->buffer) {
+      free(gAuthCmdBuf.pauth_cmd->buffer);
+      gAuthCmdBuf.pauth_cmd->buffer = NULL;
+    }
+    free(gAuthCmdBuf.pauth_cmd);
+    gAuthCmdBuf.pauth_cmd = NULL;
+  }
+  status = NFCSTATUS_SUCCESS;
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpExtns_MfcModuleInit
+**
+** Description      It Initializes the memroy and global variables related
+**                  to Mifare module.
+**
+**                  Reset all the global variables and allocate memory for
+*Mifare module
+**
+** Returns:
+**                  NFCSTATUS_SUCCESS - if successfully deinitialize
+**                  NFCSTATUS_FAILED  - otherwise
+**
+*******************************************************************************/
+NFCSTATUS phNxpExtns_MfcModuleInit(void) {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  gphNxpExtns_Context.writecmdFlag = false;
+  gphNxpExtns_Context.RawWriteCallBack = false;
+  gphNxpExtns_Context.CallBackCtxt = NULL;
+  gphNxpExtns_Context.CallBackMifare = NULL;
+  gphNxpExtns_Context.ExtnsConnect = false;
+  gphNxpExtns_Context.ExtnsDeactivate = false;
+  gphNxpExtns_Context.ExtnsCallBack = false;
+
+  NdefMap = (phFriNfc_NdefMap_t *)malloc(sizeof(phFriNfc_NdefMap_t));
+  if (NULL == NdefMap) {
+    goto clean_and_return;
+  }
+  memset(NdefMap, 0, sizeof(phFriNfc_NdefMap_t));
+
+  NdefMap->psRemoteDevInfo = (phLibNfc_sRemoteDevInformation_t *)malloc(sizeof(phLibNfc_sRemoteDevInformation_t));
+  if (NULL == NdefMap->psRemoteDevInfo) {
+    goto clean_and_return;
+  }
+  memset(NdefMap->psRemoteDevInfo, 0, sizeof(phLibNfc_sRemoteDevInformation_t));
+
+  NdefMap->SendRecvBuf = (uint8_t *)malloc((uint32_t)(MAX_BUFF_SIZE * 2));
+  if (NULL == NdefMap->SendRecvBuf) {
+    goto clean_and_return;
+  }
+  memset(NdefMap->SendRecvBuf, 0, (MAX_BUFF_SIZE * 2));
+
+  NdefMap->SendRecvLength = (uint16_t *)malloc(sizeof(uint16_t));
+  if (NULL == NdefMap->SendRecvLength) {
+    goto clean_and_return;
+  }
+  memset(NdefMap->SendRecvLength, 0, sizeof(uint16_t));
+
+  NdefMap->DataCount = (uint16_t *)malloc(sizeof(uint16_t));
+  if (NULL == NdefMap->DataCount) {
+    goto clean_and_return;
+  }
+  memset(NdefMap->DataCount, 0, sizeof(uint16_t));
+
+  NdefMap->pTransceiveInfo = (phNfc_sTransceiveInfo_t *)malloc(sizeof(phNfc_sTransceiveInfo_t));
+  if (NULL == NdefMap->pTransceiveInfo) {
+    goto clean_and_return;
+  }
+  memset(NdefMap->pTransceiveInfo, 0, sizeof(phNfc_sTransceiveInfo_t));
+
+  tNciTranscvInfo.tSendData.pBuff = (uint8_t*)malloc((uint32_t)MAX_BUFF_SIZE);
+  if (NULL == tNciTranscvInfo.tSendData.pBuff) {
+    goto clean_and_return;
+  }
+  memset(tNciTranscvInfo.tSendData.pBuff, 0, MAX_BUFF_SIZE);
+
+  NdefMap->pTransceiveInfo->sSendData.buffer =
+      (uint8_t*)malloc((uint32_t)MAX_BUFF_SIZE);
+  if (NdefMap->pTransceiveInfo->sSendData.buffer == NULL) {
+    goto clean_and_return;
+  }
+  memset(NdefMap->pTransceiveInfo->sSendData.buffer, 0, MAX_BUFF_SIZE);
+  NdefMap->pTransceiveInfo->sSendData.length = MAX_BUFF_SIZE;
+
+  NdefMap->pTransceiveInfo->sRecvData.buffer = (uint8_t*)malloc(
+      (uint32_t)MAX_BUFF_SIZE); /* size should be same as sRecvData */
+  if (NdefMap->pTransceiveInfo->sRecvData.buffer == NULL) {
+    goto clean_and_return;
+  }
+  memset(NdefMap->pTransceiveInfo->sRecvData.buffer, 0, MAX_BUFF_SIZE);
+  NdefMap->pTransceiveInfo->sRecvData.length = MAX_BUFF_SIZE;
+
+  NdefSmtCrdFmt = (phFriNfc_sNdefSmtCrdFmt_t *)malloc(sizeof(phFriNfc_sNdefSmtCrdFmt_t));
+  if (NdefSmtCrdFmt == NULL) {
+    goto clean_and_return;
+  }
+  memset(NdefSmtCrdFmt, 0, sizeof(phFriNfc_sNdefSmtCrdFmt_t));
+#if (NXP_EXTNS == TRUE)
+  pthread_mutex_lock(&SharedDataMutex);
+#endif
+  NdefInfo.psUpperNdefMsg = (phNfc_sData_t *) malloc(sizeof(phNfc_sData_t));
+  if (NULL == NdefInfo.psUpperNdefMsg) {
+    goto clean_and_return;
+  }
+  memset(NdefInfo.psUpperNdefMsg, 0, sizeof(phNfc_sData_t));
+  memset(&gAuthCmdBuf, 0, sizeof(phNci_mfc_auth_cmd_t));
+  gAuthCmdBuf.pauth_cmd = (phNfc_sData_t *)malloc(sizeof(phNfc_sData_t));
+  if (NULL == gAuthCmdBuf.pauth_cmd) {
+    goto clean_and_return;
+  }
+  gAuthCmdBuf.pauth_cmd->buffer = (uint8_t *)malloc((uint32_t)NCI_MAX_DATA_LEN);
+  if (NULL == gAuthCmdBuf.pauth_cmd->buffer) {
+    goto clean_and_return;
+  }
+  status = NFCSTATUS_SUCCESS;
+
+clean_and_return:
+#if (NXP_EXTNS == TRUE)
+  pthread_mutex_unlock(&SharedDataMutex);
+#endif
+  if (status != NFCSTATUS_SUCCESS) {
+    LOG(ERROR) << StringPrintf("CRIT: Memory Allocation failed for MFC!");
+    phNxpExtns_MfcModuleDeInit();
+  }
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         Mfc_CheckNdef
+**
+** Description      It triggers NDEF detection for Mifare Classic Tag.
+**
+**
+** Returns          NFCSTATUS_SUCCESS - if successfully initiated
+**                  NFCSTATUS_FAILED  - otherwise
+**
+*******************************************************************************/
+NFCSTATUS Mfc_CheckNdef(void) {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+
+  EXTNS_SetCallBackFlag(false);
+  /* Set Completion Routine for CheckNdef */
+  NdefMap->CompletionRoutine[0].CompletionRoutine =
+      Mfc_CheckNdef_Completion_Routine;
+
+  gphNxpExtns_Context.CallBackMifare = phFriNfc_MifareStdMap_Process;
+  gphNxpExtns_Context.CallBackCtxt = NdefMap;
+  status = phFriNfc_MifareStdMap_H_Reset(NdefMap);
+  if (NFCSTATUS_SUCCESS == status) {
+    status = phFriNfc_MifareStdMap_ChkNdef(NdefMap);
+    if (status == NFCSTATUS_PENDING) {
+      status = NFCSTATUS_SUCCESS;
+    }
+  }
+  /*Start a timer for MIFARE Check Ndef response callback handler*/
+  if (NFCSTATUS_SUCCESS == status) {
+    memset(&mTimerInfo, 0, sizeof(mTimerInfo));
+    mTimerInfo.mCb = Mfc_CheckNdef_timeoutcb_Routine;
+    mTimerInfo.mtimeout = (uint32_t)PH_FRINFC_CHECK_NDEF_TIMEOUT;
+    status = phFriNfc_MifareStd_StartTimer(&mTimerInfo);
+  }
+  if (status != NFCSTATUS_SUCCESS) {
+    status = NFCSTATUS_FAILED;
+  }
+
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         Mfc_CheckNdef_Completion_Routine
+**
+** Description      Notify NDEF detection for Mifare Classic Tag to JNI
+**
+**                  Upon completion of NDEF detection, a
+**                  NFA_NDEF_DETECT_EVT will be sent, to notify the application
+**                  of the NDEF attributes (NDEF total memory size, current
+**                  size, etc.).
+**
+** Returns:         void
+**
+*******************************************************************************/
+STATIC void Mfc_CheckNdef_Completion_Routine(void* NdefCtxt, NFCSTATUS status) {
+  (void)NdefCtxt;
+  tNFA_CONN_EVT_DATA conn_evt_data;
+  NFCSTATUS timer_status = NFCSTATUS_FAILED;
+  conn_evt_data.ndef_detect.status = status;
+  // stopping checkndef timer if running
+  timer_status = phFriNfc_MifareStd_StopTimer(&mTimerInfo);
+  if (timer_status != NFCSTATUS_SUCCESS) {
+    LOG(ERROR) << StringPrintf("Failed to stop timer");
+  }
+
+  if (NFCSTATUS_SUCCESS == status) {
+    /* NDef Tag Detected */
+    conn_evt_data.ndef_detect.protocol = NFC_PROTOCOL_MIFARE;
+    phFrinfc_MifareClassic_GetContainerSize(
+        NdefMap, (uint32_t*)&(conn_evt_data.ndef_detect.max_size),
+        (uint32_t*)&(conn_evt_data.ndef_detect.cur_size));
+    NdefInfo.NdefLength = conn_evt_data.ndef_detect.max_size;
+    /* update local flags */
+    NdefInfo.is_ndef = 1;
+    NdefInfo.NdefActualSize = conn_evt_data.ndef_detect.cur_size;
+    if (PH_NDEFMAP_CARD_STATE_READ_ONLY == NdefMap->CardState) {
+      DLOG_IF(INFO, gLog_level.extns_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL)
+          << StringPrintf("Mfc_CheckNdef_Completion_Routine : READ_ONLY_CARD");
+      conn_evt_data.ndef_detect.flags = RW_NDEF_FL_READ_ONLY;
+    } else {
+      conn_evt_data.ndef_detect.flags =
+          RW_NDEF_FL_SUPPORTED | RW_NDEF_FL_FORMATED;
+    }
+  } else {
+    /* NDEF Detection failed for other reasons */
+    conn_evt_data.ndef_detect.cur_size = 0;
+    conn_evt_data.ndef_detect.max_size = 0;
+    conn_evt_data.ndef_detect.flags = RW_NDEF_FL_UNKNOWN;
+
+    /* update local flags */
+    NdefInfo.is_ndef = 0;
+    NdefInfo.NdefActualSize = conn_evt_data.ndef_detect.cur_size;
+  }
+  (*gphNxpExtns_Context.p_conn_cback)(NFA_NDEF_DETECT_EVT, &conn_evt_data);
+
+  return;
+}
+/*******************************************************************************
+**
+** Function         Mfc_ReadNdef_Completion_Routine
+**
+** Description      Notify NDEF read completion for Mifare Classic Tag to JNI
+**
+**                  Upon completion of NDEF read, a
+**                  NFA_READ_CPLT_EVT will be sent, to notify the application
+**                  with the NDEF data and status
+**
+** Returns:         void
+**
+*******************************************************************************/
+STATIC void Mfc_ReadNdef_Completion_Routine(void* NdefCtxt, NFCSTATUS status) {
+  (void)NdefCtxt;
+  tNFA_CONN_EVT_DATA conn_evt_data;
+  tNFA_NDEF_EVT_DATA p_data;
+
+  conn_evt_data.status = status;
+#if (NXP_EXTNS == TRUE)
+  pthread_mutex_lock(&SharedDataMutex);
+#endif
+  if (NFCSTATUS_SUCCESS == status) {
+    p_data.ndef_data.len = NdefInfo.psUpperNdefMsg->length;
+    p_data.ndef_data.p_data = NdefInfo.psUpperNdefMsg->buffer;
+    (*gphNxpExtns_Context.p_ndef_cback)(NFA_NDEF_DATA_EVT, &p_data);
+  } else {
+  }
+
+  (*gphNxpExtns_Context.p_conn_cback)(NFA_READ_CPLT_EVT, &conn_evt_data);
+
+  if (NdefInfo.psUpperNdefMsg->buffer != NULL) {
+    free(NdefInfo.psUpperNdefMsg->buffer);
+    NdefInfo.psUpperNdefMsg->buffer = NULL;
+  }
+#if (NXP_EXTNS == TRUE)
+  pthread_mutex_unlock(&SharedDataMutex);
+#endif
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         Mfc_WriteNdef_Completion_Routine
+**
+** Description      Notify NDEF write completion for Mifare Classic Tag to JNI
+**
+**                  Upon completion of NDEF write, a
+**                  NFA_WRITE_CPLT_EVT will be sent along with status
+**
+** Returns:         void
+**
+*******************************************************************************/
+STATIC void Mfc_WriteNdef_Completion_Routine(void* NdefCtxt, NFCSTATUS status) {
+  (void)NdefCtxt;
+  tNFA_CONN_EVT_DATA conn_evt_data;
+
+  conn_evt_data.status = status;
+  (*gphNxpExtns_Context.p_conn_cback)(NFA_WRITE_CPLT_EVT, &conn_evt_data);
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         Mfc_FormatNdef_Completion_Routine
+**
+** Description      Notify NDEF format completion for Mifare Classic Tag to JNI
+**
+**                  Upon completion of NDEF format, a
+**                  NFA_FORMAT_CPLT_EVT will be sent along with status
+**
+** Returns:         void
+**
+*******************************************************************************/
+STATIC void Mfc_FormatNdef_Completion_Routine(void* NdefCtxt,
+                                              NFCSTATUS status) {
+  (void)NdefCtxt;
+  tNFA_CONN_EVT_DATA conn_evt_data;
+
+  conn_evt_data.status = status;
+  (*gphNxpExtns_Context.p_conn_cback)(NFA_FORMAT_CPLT_EVT, &conn_evt_data);
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function          phFriNfc_ValidateParams
+**
+** Description      This function is a common function which validates NdefRd
+**                  and NdefWr parameters.
+**
+** Returns          NFCSTATUS_SUCCESS  - All the params are valid
+**                  NFCSTATUS_FAILED   - otherwise
+**
+*******************************************************************************/
+STATIC NFCSTATUS phFriNfc_ValidateParams(uint8_t* PacketData,
+                                         uint32_t* PacketDataLength,
+                                         uint8_t Offset,
+                                         phFriNfc_NdefMap_t* pNdefMap,
+                                         uint8_t bNdefReq) {
+  if ((pNdefMap == NULL) || (PacketData == NULL) ||
+      (PacketDataLength == NULL)) {
+    return NFCSTATUS_FAILED;
+  }
+
+  if (pNdefMap->CardState == PH_NDEFMAP_CARD_STATE_INVALID) {
+    return NFCSTATUS_FAILED;
+  }
+
+  if (bNdefReq == PH_FRINFC_NDEF_READ_REQ) {
+    if ((Offset != PH_FRINFC_NDEFMAP_SEEK_CUR) &&
+        (Offset != PH_FRINFC_NDEFMAP_SEEK_BEGIN)) {
+      return NFCSTATUS_FAILED;
+    }
+    if (pNdefMap->CardState == PH_NDEFMAP_CARD_STATE_INITIALIZED) {
+      pNdefMap->NumOfBytesRead = PacketDataLength;
+      *pNdefMap->NumOfBytesRead = 0;
+      return NFCSTATUS_EOF_NDEF_CONTAINER_REACHED;
+    }
+    if ((pNdefMap->PrevOperation == PH_FRINFC_NDEFMAP_WRITE_OPE) &&
+        (Offset != PH_FRINFC_NDEFMAP_SEEK_BEGIN)) {
+      return NFCSTATUS_FAILED; /* return INVALID_DEVICE_REQUEST */
+    }
+    if (Offset == PH_FRINFC_NDEFMAP_SEEK_BEGIN) {
+      pNdefMap->ApduBuffIndex = 0;
+      *pNdefMap->DataCount = 0;
+    } else if ((pNdefMap->bPrevReadMode == PH_FRINFC_NDEFMAP_SEEK_BEGIN) ||
+               (pNdefMap->bPrevReadMode == PH_FRINFC_NDEFMAP_SEEK_CUR)) {
+    } else {
+      return NFCSTATUS_FAILED;
+    }
+  } else if (bNdefReq == PH_FRINFC_NDEF_WRITE_REQ) {
+    if (pNdefMap->CardState == PH_NDEFMAP_CARD_STATE_READ_ONLY) {
+      pNdefMap->WrNdefPacketLength = PacketDataLength;
+      *pNdefMap->WrNdefPacketLength = 0x00;
+      return NFCSTATUS_NOT_ALLOWED;
+    }
+  }
+
+  return NFCSTATUS_SUCCESS;
+}
+
+/*******************************************************************************
+**
+** Function         Mfc_SetRdOnly_Completion_Routine
+**
+** Description      Notify NDEF read only completion for Mifare Classic Tag to
+*JNI
+**
+**                  Upon completion of NDEF format, a
+**                  NFA_SET_TAG_RO_EVT will be sent along with status
+**
+** Returns:         void
+**
+*******************************************************************************/
+STATIC void Mfc_SetRdOnly_Completion_Routine(void* NdefCtxt, NFCSTATUS status) {
+  (void)NdefCtxt;
+  tNFA_CONN_EVT_DATA conn_evt_data;
+  LOG(ERROR) << StringPrintf("%s status = 0x%x", __func__, status);
+  conn_evt_data.status = status;
+  (*gphNxpExtns_Context.p_conn_cback)(NFA_SET_TAG_RO_EVT, &conn_evt_data);
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function        Mfc_SetReadOnly
+**
+**
+** Description:    It triggers ConvertToReadOnly  for Mifare Classic Tag.
+**
+** Returns:
+**                  NFCSTATUS_SUCCESS if successfully initiated
+**                  NFCSTATUS_FAILED otherwise
+**
+*******************************************************************************/
+NFCSTATUS Mfc_SetReadOnly(uint8_t* secrtkey, uint8_t len) {
+  DLOG_IF(INFO, gLog_level.extns_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL)
+      << StringPrintf("%s Entering ", __func__);
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  uint8_t mif_secrete_key[6] = {0};
+  uint8_t id = 0;
+  EXTNS_SetCallBackFlag(false);
+  memcpy(mif_secrete_key, secrtkey, len);
+  gphNxpExtns_Context.CallBackMifare = phFriNfc_MifareStdMap_Process;
+  gphNxpExtns_Context.CallBackCtxt = NdefMap;
+  for (id = 0; id < len; id++) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("secrtkey[%d] = 0x%x", id, secrtkey[id]);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("mif_secrete_key[%d] = 0x%x", id, mif_secrete_key[id]);
+  }
+  /* Set Completion Routine for ReadNdef */
+  NdefMap->CompletionRoutine[0].CompletionRoutine =
+      Mfc_SetRdOnly_Completion_Routine;
+  if (NdefInfo.is_ndef == 0) {
+    status = NFCSTATUS_NON_NDEF_COMPLIANT;
+    goto Mfc_SetRdOnly;
+  } else if ((NdefInfo.is_ndef == 1) && (NdefInfo.NdefActualSize == 0)) {
+#if (NXP_EXTNS == TRUE)
+    pthread_mutex_lock(&SharedDataMutex);
+#endif
+    NdefInfo.psUpperNdefMsg->length = NdefInfo.NdefActualSize;
+#if (NXP_EXTNS == TRUE)
+    pthread_mutex_unlock(&SharedDataMutex);
+#endif
+    status = NFCSTATUS_SUCCESS;
+    goto Mfc_SetRdOnly;
+  } else {
+    status = phFriNfc_MifareStdMap_ConvertToReadOnly(NdefMap, mif_secrete_key);
+  }
+  if (NFCSTATUS_PENDING == status) {
+    status = NFCSTATUS_SUCCESS;
+  }
+
+Mfc_SetRdOnly:
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         Mfc_ReadNdef
+**
+** Description      It triggers receiving of the NDEF message from Mifare
+*Classic Tag.
+**
+**
+** Returns:
+**                  NFCSTATUS_SUCCESS - if successfully initiated
+**                  NFCSTATUS_FAILED  - otherwise
+**
+*******************************************************************************/
+NFCSTATUS Mfc_ReadNdef(void) {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  uint8_t* PacketData = NULL;
+  uint32_t* PacketDataLength = NULL;
+  phLibNfc_Ndef_EOffset_t Offset;
+
+  EXTNS_SetCallBackFlag(false);
+
+  Offset = phLibNfc_Ndef_EBegin;
+
+  gphNxpExtns_Context.CallBackMifare = phFriNfc_MifareStdMap_Process;
+  gphNxpExtns_Context.CallBackCtxt = NdefMap;
+#if (NXP_EXTNS == TRUE)
+  pthread_mutex_lock(&SharedDataMutex);
+#endif
+  if (NdefInfo.is_ndef == 0) {
+    status = NFCSTATUS_NON_NDEF_COMPLIANT;
+    goto Mfc_RdNdefEnd;
+  } else if ((NdefInfo.is_ndef == 1) && (NdefInfo.NdefActualSize == 0)) {
+    NdefInfo.psUpperNdefMsg->length = NdefInfo.NdefActualSize;
+    status = NFCSTATUS_SUCCESS;
+    goto Mfc_RdNdefEnd;
+  } else {
+    NdefInfo.psUpperNdefMsg->buffer = (uint8_t *)malloc(NdefInfo.NdefActualSize);
+    if (NULL == NdefInfo.psUpperNdefMsg->buffer) {
+      goto Mfc_RdNdefEnd;
+    }
+    NdefInfo.psUpperNdefMsg->length = NdefInfo.NdefActualSize;
+
+    /* Set Completion Routine for ReadNdef */
+    NdefMap->CompletionRoutine[1].CompletionRoutine =
+        Mfc_ReadNdef_Completion_Routine;
+    NdefInfo.NdefContinueRead = (uint8_t)((phLibNfc_Ndef_EBegin == Offset)
+                                              ? PH_FRINFC_NDEFMAP_SEEK_BEGIN
+                                              : PH_FRINFC_NDEFMAP_SEEK_CUR);
+  }
+
+  PacketData = NdefInfo.psUpperNdefMsg->buffer;
+  PacketDataLength = (uint32_t*)&(NdefInfo.psUpperNdefMsg->length);
+  NdefMap->bCurrReadMode = Offset;
+  status = phFriNfc_ValidateParams(PacketData, PacketDataLength, Offset,
+                                   NdefMap, PH_FRINFC_NDEF_READ_REQ);
+  if (status != NFCSTATUS_SUCCESS) {
+    goto Mfc_RdNdefEnd;
+  }
+
+  status = phFriNfc_MifareStdMap_RdNdef(NdefMap, PacketData, PacketDataLength,
+                                        Offset);
+
+  if (NFCSTATUS_INSUFFICIENT_STORAGE == status) {
+    NdefInfo.psUpperNdefMsg->length = 0x00;
+    status = NFCSTATUS_SUCCESS;
+  }
+
+  if (NFCSTATUS_PENDING == status) {
+    status = NFCSTATUS_SUCCESS;
+  }
+
+Mfc_RdNdefEnd:
+  if (status != NFCSTATUS_SUCCESS) {
+    if (NULL != NdefInfo.psUpperNdefMsg->buffer) {
+      free(NdefInfo.psUpperNdefMsg->buffer);
+      NdefInfo.psUpperNdefMsg->buffer = NULL;
+    }
+    status = NFCSTATUS_FAILED;
+  }
+#if (NXP_EXTNS == TRUE)
+  pthread_mutex_unlock(&SharedDataMutex);
+#endif
+  return status;
+}
+/*******************************************************************************
+**
+** Function         Mfc_PresenceCheck
+**
+** Description      It triggers receiving of the NDEF message from Mifare
+*Classic Tag.
+**
+**
+** Returns:
+**                  NFCSTATUS_SUCCESS - if successfully initiated
+**                  NFCSTATUS_FAILED  - otherwise
+**
+*******************************************************************************/
+NFCSTATUS Mfc_PresenceCheck(void) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+
+  if (gAuthCmdBuf.auth_status == true) {
+    EXTNS_SetCallBackFlag(false);
+    status = nativeNfcExtns_doTransceive(gAuthCmdBuf.pauth_cmd->buffer,
+                                         gAuthCmdBuf.pauth_cmd->length);
+    if (status != NFCSTATUS_PENDING) {
+      gAuthCmdBuf.auth_sent = false;
+      status = NFCSTATUS_FAILED;
+    } else {
+      gAuthCmdBuf.auth_sent = true;
+      status = NFCSTATUS_SUCCESS;
+    }
+  } else {
+    status = NFCSTATUS_NOT_ALLOWED;
+  }
+  DLOG_IF(INFO, gLog_level.extns_log_level >= NXPLOG_LOG_DEBUG_LOGLEVEL)
+      << StringPrintf("%s status = 0x%x", __func__, status);
+  return status;
+}
+/*******************************************************************************
+**
+** Function         Mfc_WriteNdef
+**
+** Description      It triggers the NDEF data write to Mifare Classic Tag.
+**
+**
+** Returns:
+**                  NFCSTATUS_SUCCESS - if successfully initiated
+**                  NFCSTATUS_FAILED  - otherwise
+**
+*******************************************************************************/
+NFCSTATUS Mfc_WriteNdef(uint8_t* p_data, uint32_t len) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  uint8_t* PacketData = NULL;
+  uint32_t* PacketDataLength = NULL;
+
+  if (p_data == NULL || len == 0) {
+    LOG(ERROR) << StringPrintf("MFC Error: Invalid Parameters to Ndef Write");
+    status = NFCSTATUS_FAILED;
+    goto Mfc_WrNdefEnd;
+  }
+
+  EXTNS_SetCallBackFlag(false);
+  gphNxpExtns_Context.CallBackMifare = phFriNfc_MifareStdMap_Process;
+  gphNxpExtns_Context.CallBackCtxt = NdefMap;
+#if (NXP_EXTNS == TRUE)
+  pthread_mutex_lock(&SharedDataMutex);
+#endif
+  if (NdefInfo.is_ndef == PH_LIBNFC_INTERNAL_CHK_NDEF_NOT_DONE) {
+    status = NFCSTATUS_REJECTED;
+    goto Mfc_WrNdefEnd;
+  } else if (NdefInfo.is_ndef == 0) {
+    status = NFCSTATUS_NON_NDEF_COMPLIANT;
+    goto Mfc_WrNdefEnd;
+  } else if (len > NdefInfo.NdefLength) {
+    status = NFCSTATUS_NOT_ENOUGH_MEMORY;
+    goto Mfc_WrNdefEnd;
+  } else {
+    NdefInfo.psUpperNdefMsg->buffer = p_data;
+    NdefInfo.psUpperNdefMsg->length = len;
+
+    NdefInfo.AppWrLength = len;
+    NdefMap->CompletionRoutine[2].CompletionRoutine =
+        Mfc_WriteNdef_Completion_Routine;
+    if (0 == len) {
+      /* TODO: Erase the Tag */
+    } else {
+      NdefMap->ApduBuffIndex = 0x00;
+      *NdefMap->DataCount = 0x00;
+      PacketData = NdefInfo.psUpperNdefMsg->buffer;
+      PacketDataLength = &(NdefInfo.dwWrLength);
+      NdefMap->WrNdefPacketLength = PacketDataLength;
+      NdefInfo.dwWrLength = len;
+
+      status = phFriNfc_ValidateParams(PacketData, PacketDataLength, 0, NdefMap,
+                                       PH_FRINFC_NDEF_WRITE_REQ);
+      if (status != NFCSTATUS_SUCCESS) {
+        goto Mfc_WrNdefEnd;
+      }
+
+      status = phFriNfc_MifareStdMap_WrNdef(
+          NdefMap, PacketData, PacketDataLength, PH_FRINFC_NDEFMAP_SEEK_BEGIN);
+
+      if (status == NFCSTATUS_PENDING) {
+        status = NFCSTATUS_SUCCESS;
+      }
+    }
+  }
+
+Mfc_WrNdefEnd:
+#if (NXP_EXTNS == TRUE)
+  pthread_mutex_unlock(&SharedDataMutex);
+#endif
+  if (status != NFCSTATUS_SUCCESS) {
+    status = NFCSTATUS_FAILED;
+  }
+  return status;
+}
+/*******************************************************************************
+**
+** Function          phFriNfc_NdefSmtCrd_Reset__
+**
+** Description      This function Resets the component instance to the initial
+**                  state and initializes the internal variables.
+**
+** Returns          NFCSTATUS_SUCCESS
+**
+*******************************************************************************/
+STATIC NFCSTATUS phFriNfc_NdefSmtCrd_Reset__(
+    phFriNfc_sNdefSmtCrdFmt_t* NdefSmtCrdFmt, uint8_t* SendRecvBuffer,
+    uint16_t* SendRecvBuffLen) {
+  //    NFCSTATUS status = NFCSTATUS_FAILED;                      /*commented to
+  //    eliminate unused variable warning*/
+  uint8_t index;
+
+  /* Initialize the state to Init */
+  NdefSmtCrdFmt->State = PH_FRINFC_SMTCRDFMT_STATE_RESET_INIT;
+
+  for (index = 0; index < PH_FRINFC_SMTCRDFMT_CR; index++) {
+    /* Initialize the NdefMap Completion Routine to Null */
+    NdefSmtCrdFmt->CompletionRoutine[index].CompletionRoutine = NULL;
+    /* Initialize the NdefMap Completion Routine context to Null  */
+    NdefSmtCrdFmt->CompletionRoutine[index].Context = NULL;
+  }
+
+  /* Trx Buffer registered */
+  NdefSmtCrdFmt->SendRecvBuf = SendRecvBuffer;
+
+  /* Trx Buffer Size */
+  NdefSmtCrdFmt->SendRecvLength = SendRecvBuffLen;
+
+  /* Register Transfer Buffer Length */
+  NdefSmtCrdFmt->SendLength = 0;
+
+  /* Initialize the Format status flag*/
+  NdefSmtCrdFmt->FmtProcStatus = 0;
+
+  /* Reset the Card Type */
+  NdefSmtCrdFmt->CardType = 0;
+
+  /* Reset MapCompletion Info*/
+  NdefSmtCrdFmt->SmtCrdFmtCompletionInfo.CompletionRoutine = NULL;
+  NdefSmtCrdFmt->SmtCrdFmtCompletionInfo.Context = NULL;
+
+  phFriNfc_MfStd_Reset(NdefSmtCrdFmt);
+
+  return NFCSTATUS_SUCCESS;
+}
+
+/*******************************************************************************
+**
+** Function         Mfc_FormatNdef
+**
+** Description      It triggers the NDEF format of Mifare Classic Tag.
+**
+**
+** Returns:
+**                  NFCSTATUS_SUCCESS - if successfully initiated
+**                  NFCSTATUS_FAILED  - otherwise
+**
+*******************************************************************************/
+NFCSTATUS Mfc_FormatNdef(uint8_t* secretkey, uint8_t len) {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  uint8_t mif_std_key[6] = {0};
+  //    static uint8_t   Index;
+  //    /*commented to eliminate unused variable warning*/
+  uint8_t sak = 0;
+
+  EXTNS_SetCallBackFlag(false);
+
+  memcpy(mif_std_key, secretkey, len);
+  memcpy(current_key, secretkey, len);
+
+  if (NULL == NdefSmtCrdFmt || NULL == NdefMap ||
+      NULL == NdefMap->SendRecvBuf) {
+    goto Mfc_FormatEnd;
+  }
+  NdefSmtCrdFmt->pTransceiveInfo = NdefMap->pTransceiveInfo;
+
+  gphNxpExtns_Context.CallBackMifare = phFriNfc_MfStd_Process;
+  gphNxpExtns_Context.CallBackCtxt = NdefSmtCrdFmt;
+
+  NdefInfo.NdefSendRecvLen = NDEF_SENDRCV_BUF_LEN;
+  phFriNfc_NdefSmtCrd_Reset__(NdefSmtCrdFmt, NdefMap->SendRecvBuf,
+                              &(NdefInfo.NdefSendRecvLen));
+
+  /* Register Callbacks */
+  NdefSmtCrdFmt->CompletionRoutine[0].CompletionRoutine =
+      Mfc_FormatNdef_Completion_Routine;
+  NdefSmtCrdFmt->CompletionRoutine[1].CompletionRoutine =
+      Mfc_FormatNdef_Completion_Routine;
+  NdefSmtCrdFmt->psRemoteDevInfo = NdefMap->psRemoteDevInfo;
+  sak = NdefSmtCrdFmt->psRemoteDevInfo->RemoteDevInfo.Iso14443A_Info.Sak;
+
+  if ((0x08 == (sak & 0x18)) || (0x18 == (sak & 0x18)) || (0x01 == sak)) {
+    NdefSmtCrdFmt->CardType = (uint8_t)(
+        ((sak & 0x18) == 0x08)
+            ? PH_FRINFC_SMTCRDFMT_MFSTD_1K_CRD
+            : (((sak & 0x19) == 0x19) ? PH_FRINFC_SMTCRDFMT_MFSTD_2K_CRD
+                                      : PH_FRINFC_SMTCRDFMT_MFSTD_4K_CRD));
+    status = phFriNfc_MfStd_Format(NdefSmtCrdFmt, mif_std_key);
+  }
+
+  if (NFCSTATUS_PENDING == status) {
+    status = NFCSTATUS_SUCCESS;
+  }
+
+Mfc_FormatEnd:
+  if (status != NFCSTATUS_SUCCESS) {
+    status = NFCSTATUS_FAILED;
+  }
+
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         phNxNciExtns_MifareStd_Reconnect
+**
+** Description      This function sends the deactivate command to NFCC for
+*Mifare
+**
+**
+** Returns:
+**                  NFCSTATUS_PENDING - if successfully initiated
+**                  NFCSTATUS_FAILED  - otherwise
+**
+*******************************************************************************/
+NFCSTATUS phNxNciExtns_MifareStd_Reconnect(void) {
+  tNFA_STATUS status;
+
+  EXTNS_SetDeactivateFlag(true);
+  if (NFA_STATUS_OK !=
+      (status = NFA_Deactivate(true))) /* deactivate to sleep state */
+  {
+    LOG(ERROR) << StringPrintf("%s: deactivate failed, status = %d", __func__,
+                               status);
+    return NFCSTATUS_FAILED;
+  }
+
+  return NFCSTATUS_PENDING;
+}
+
+/*******************************************************************************
+**
+** Function         Mfc_DeactivateCbackSelect
+**
+** Description      This function select the Mifare tag
+**
+**
+** Returns:         void
+**
+*******************************************************************************/
+void Mfc_DeactivateCbackSelect(void) {
+  tNFA_STATUS status;
+
+  EXTNS_SetConnectFlag(true);
+  if (NFA_STATUS_OK !=
+      (status = NFA_Select(0x01, phNciNfc_e_RfProtocolsMifCProtocol,
+                           phNciNfc_e_RfInterfacesTagCmd_RF))) {
+    LOG(ERROR) << StringPrintf("%s: NFA_Select failed, status = %d", __func__,
+                               status);
+  }
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         Mfc_ActivateCback
+**
+** Description      This function invoke the callback when receive the response
+**
+**
+** Returns:         void
+**
+**
+*******************************************************************************/
+void Mfc_ActivateCback(void) {
+  gphNxpExtns_Context.CallBackMifare(gphNxpExtns_Context.CallBackCtxt,
+                                     NFCSTATUS_SUCCESS);
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         Mfc_Transceive
+**
+** Description      Sends raw frame to Mifare Classic Tag.
+**
+** Returns          NFCSTATUS_SUCCESS - if successfully initiated
+**                  NFCSTATUS_FAILED  - otherwise
+**
+*******************************************************************************/
+NFCSTATUS Mfc_Transceive(uint8_t* p_data, uint32_t len) {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  uint8_t i = 0x00;
+
+  gphNxpExtns_Context.RawWriteCallBack = false;
+  gphNxpExtns_Context.CallBackMifare = NULL;
+  gphNxpExtns_Context.CallBackCtxt = NdefMap;
+
+  EXTNS_SetCallBackFlag(true);
+  if (p_data[0] == 0x60 || p_data[0] == 0x61) {
+    NdefMap->Cmd.MfCmd = (phNfc_eMifareCmdList_t) p_data[0];
+
+    NdefMap->SendRecvBuf[i++] = p_data[1];
+
+    NdefMap->SendRecvBuf[i++] = p_data[6]; /* TODO, handle 7 byte UID */
+    NdefMap->SendRecvBuf[i++] = p_data[7];
+    NdefMap->SendRecvBuf[i++] = p_data[8];
+    NdefMap->SendRecvBuf[i++] = p_data[9];
+    NdefMap->SendRecvBuf[i++] = p_data[10];
+    NdefMap->SendRecvBuf[i++] = p_data[11];
+
+    status = phFriNfc_ExtnsTransceive(NdefMap->pTransceiveInfo, NdefMap->Cmd,
+                                      NdefMap->SendRecvBuf, NdefMap->SendLength,
+                                      NdefMap->SendRecvLength);
+  } else if (p_data[0] == 0xA0) {
+    EXTNS_SetCallBackFlag(false);
+    NdefMap->Cmd.MfCmd = phNfc_eMifareWrite16;
+    gphNxpExtns_Context.RawWriteCallBack = true;
+
+    memcpy(NdefMap->SendRecvBuf, &p_data[1], len - 1);
+    NdefMap->SendLength = len - 1;
+    status = phFriNfc_ExtnsTransceive(NdefMap->pTransceiveInfo, NdefMap->Cmd,
+                                      NdefMap->SendRecvBuf, NdefMap->SendLength,
+                                      NdefMap->SendRecvLength);
+  } else if ((p_data[0] == phNfc_eMifareInc) ||
+             (p_data[0] == phNfc_eMifareDec)) {
+    EXTNS_SetCallBackFlag(false);
+    NdefMap->Cmd.MfCmd = (phNfc_eMifareCmdList_t) p_data[0];
+    gphNxpExtns_Context.RawWriteCallBack = true;
+
+    memcpy(NdefMap->SendRecvBuf, &p_data[1], len - 1);
+    NdefMap->SendLength = len - 1;
+    status = phFriNfc_ExtnsTransceive(NdefMap->pTransceiveInfo, NdefMap->Cmd,
+                                      NdefMap->SendRecvBuf, NdefMap->SendLength,
+                                      NdefMap->SendRecvLength);
+  } else if (((p_data[0] == phNfc_eMifareTransfer) ||
+              (p_data[0] == phNfc_eMifareRestore)) &&
+             (len == 2)) {
+    NdefMap->Cmd.MfCmd = (phNfc_eMifareCmdList_t) p_data[0];
+    if (p_data[0] == phNfc_eMifareRestore) {
+      EXTNS_SetCallBackFlag(false);
+      gphNxpExtns_Context.RawWriteCallBack = true;
+      memcpy(NdefMap->SendRecvBuf, &p_data[1], len - 1);
+      NdefMap->SendLength = len - 1;
+    } else {
+      memcpy(NdefMap->SendRecvBuf, p_data, len);
+      NdefMap->SendLength = len;
+    }
+    status = phFriNfc_ExtnsTransceive(NdefMap->pTransceiveInfo, NdefMap->Cmd,
+                                      NdefMap->SendRecvBuf, NdefMap->SendLength,
+                                      NdefMap->SendRecvLength);
+
+  } else {
+    NdefMap->Cmd.MfCmd = phNfc_eMifareRaw;
+
+    memcpy(NdefMap->SendRecvBuf, p_data, len);
+    NdefMap->SendLength = len;
+    status = phFriNfc_ExtnsTransceive(NdefMap->pTransceiveInfo, NdefMap->Cmd,
+                                      NdefMap->SendRecvBuf, NdefMap->SendLength,
+                                      NdefMap->SendRecvLength);
+  }
+  if (NFCSTATUS_PENDING == status) {
+    status = NFCSTATUS_SUCCESS;
+  } else {
+    LOG(ERROR) << StringPrintf("ERROR: Mfc_Transceive = 0x%x", status);
+  }
+
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         nativeNfcExtns_doTransceive
+**
+** Description      Sends raw frame to BCM stack.
+**
+** Returns          NFCSTATUS_PENDING - if successfully initiated
+**                  NFCSTATUS_FAILED  - otherwise
+**
+*******************************************************************************/
+STATIC NFCSTATUS nativeNfcExtns_doTransceive(uint8_t* buff, uint16_t buffSz) {
+  NFCSTATUS wStatus = NFCSTATUS_PENDING;
+  tNFA_STATUS status =
+      NFA_SendRawFrame(buff, buffSz, NFA_DM_DEFAULT_PRESENCE_CHECK_START_DELAY);
+
+  if (status != NFA_STATUS_OK) {
+    LOG(ERROR) << StringPrintf("%s: fail send; error=%d", __func__, status);
+    wStatus = NFCSTATUS_FAILED;
+  }
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function          phNciNfc_RecvMfResp
+**
+** Description      This function shall be invoked as part of ReaderMgmt data
+**                  exchange sequence handler on receiving response/data from
+*NFCC
+**
+** Returns          NFCSTATUS_SUCCESS - Data Reception is successful
+**                  NFCSTATUS_FAILED  - Data Reception failed
+**
+*******************************************************************************/
+STATIC NFCSTATUS phNciNfc_RecvMfResp(phNciNfc_Buff_t* RspBuffInfo,
+                                     NFCSTATUS wStatus) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  uint16_t wPldDataSize = 0;
+  phNciNfc_ExtnRespId_t RecvdExtnRspId = phNciNfc_e_InvalidRsp;
+  if (NULL == RspBuffInfo) {
+    status = NFCSTATUS_FAILED;
+  } else {
+    if ((0 == (RspBuffInfo->wLen)) || (PH_NCINFC_STATUS_OK != wStatus) ||
+        (NULL == (RspBuffInfo->pBuff))) {
+      status = NFCSTATUS_FAILED;
+    } else {
+      RecvdExtnRspId = (phNciNfc_ExtnRespId_t)RspBuffInfo->pBuff[0];
+
+      switch (RecvdExtnRspId) {
+        case phNciNfc_e_MfXchgDataRsp: {
+          NFCSTATUS writeResponse = NFCSTATUS_SUCCESS;
+          /* check the status byte */
+          if ((NFC_GetNCIVersion() == NCI_VERSION_2_0) &&
+              (((NdefMap->State) == PH_FRINFC_NDEFMAP_STATE_WR_TLV) ||
+               ((NdefMap->State) == PH_FRINFC_NDEFMAP_STATE_WRITE) ||
+               ((NdefMap->State) == PH_FRINFC_NDEFMAP_STATE_WR_NDEF_LEN) ||
+               ((NdefMap->State) == PH_FRINFC_NDEFMAP_STATE_INIT))) {
+            uint8_t rspAck = RspBuffInfo->pBuff[RspBuffInfo->wLen - 2];
+            uint8_t rspAckMask = ((RspBuffInfo->pBuff[RspBuffInfo->wLen - 1]) &
+                                  MAX_NUM_VALID_BITS_FOR_ACK);
+            NCI_CALCULATE_ACK(rspAck, rspAckMask);
+            writeResponse =
+                (rspAck == T2T_RSP_ACK) ? NFCSTATUS_SUCCESS : NFC_STATUS_FAILED;
+          } else {
+            writeResponse = RspBuffInfo->pBuff[RspBuffInfo->wLen - 1];
+          }
+
+          if (writeResponse == PH_NCINFC_STATUS_OK) {
+            status = NFCSTATUS_SUCCESS;
+            uint16_t wRecvDataSz = 0;
+
+            /* DataLen = TotalRecvdLen - (sizeof(RspId) + sizeof(Status)) */
+            wPldDataSize = ((RspBuffInfo->wLen) -
+                            (PHNCINFC_EXTNID_SIZE + PHNCINFC_EXTNSTATUS_SIZE));
+            wRecvDataSz = NCI_MAX_DATA_LEN;
+
+            /* wPldDataSize = wPldDataSize-1; ==> ignoring the last status byte
+             * appended with data */
+            if ((wPldDataSize) <= wRecvDataSz) {
+              /* Extract the data part from pBuff[2] & fill it to be sent to
+               * upper layer */
+              memcpy(NdefMap->SendRecvBuf, &(RspBuffInfo->pBuff[1]),
+                     (wPldDataSize));
+              /* update the number of bytes received from lower layer,excluding
+               * the status byte */
+              *(NdefMap->SendRecvLength) = wPldDataSize;
+            } else {
+              // TODO:- Map some status for remaining extra data received to be
+              // sent back to caller??
+              status = NFCSTATUS_FAILED;
+            }
+          } else {
+            status = NFCSTATUS_FAILED;
+          }
+        } break;
+
+        case phNciNfc_e_MfcAuthRsp: {
+          /* check the status byte */
+          if (PH_NCINFC_STATUS_OK == RspBuffInfo->pBuff[1]) {
+            if (gAuthCmdBuf.auth_sent == true) {
+              MfcPresenceCheckResult(NFCSTATUS_SUCCESS);
+              return NFCSTATUS_SUCCESS;
+            }
+            gAuthCmdBuf.auth_status = true;
+            status = NFCSTATUS_SUCCESS;
+
+            /* DataLen = TotalRecvdLen - (sizeof(RspId) + sizeof(Status)) */
+            wPldDataSize = ((RspBuffInfo->wLen) -
+                            (PHNCINFC_EXTNID_SIZE + PHNCINFC_EXTNSTATUS_SIZE));
+
+            /* Extract the data part from pBuff[2] & fill it to be sent to upper
+             * layer */
+            memcpy(NdefMap->SendRecvBuf, &(RspBuffInfo->pBuff[2]),
+                   wPldDataSize);
+            /* update the number of bytes received from lower layer,excluding
+             * the status byte */
+            *(NdefMap->SendRecvLength) = wPldDataSize;
+          } else {
+            if (gAuthCmdBuf.auth_sent == true) {
+              gAuthCmdBuf.auth_status = false;
+              MfcPresenceCheckResult(NFCSTATUS_FAILED);
+              return NFCSTATUS_SUCCESS;
+            } else {
+              /* Reset the stored auth command buffer */
+              memset(gAuthCmdBuf.pauth_cmd->buffer, 0, NCI_MAX_DATA_LEN);
+              gAuthCmdBuf.pauth_cmd->length = 0;
+              gAuthCmdBuf.auth_status = false;
+            }
+            status = NFCSTATUS_FAILED;
+          }
+        } break;
+
+        default: { status = NFCSTATUS_FAILED; } break;
+      }
+    }
+  }
+
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         phLibNfc_SendWrt16CmdPayload
+**
+** Description      This function map the raw write cmd
+**
+** Returns          NFCSTATUS_SUCCESS            - Command framing done
+**                  NFCSTATUS_INVALID_PARAMETER  - Otherwise
+**
+*******************************************************************************/
+STATIC NFCSTATUS
+phLibNfc_SendWrt16CmdPayload(phNfc_sTransceiveInfo_t* pTransceiveInfo,
+                             pphNciNfc_TransceiveInfo_t pMappedTranscvIf) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+
+  if ((NULL != pTransceiveInfo->sSendData.buffer) &&
+      (0 != (pTransceiveInfo->sSendData.length))) {
+    memcpy(pMappedTranscvIf->tSendData.pBuff, pTransceiveInfo->sSendData.buffer,
+           (pTransceiveInfo->sSendData.length));
+    pMappedTranscvIf->tSendData.wLen = pTransceiveInfo->sSendData.length;
+    pMappedTranscvIf->uCmd.T2TCmd = phNciNfc_eT2TRaw;
+  } else {
+    wStatus = NFCSTATUS_INVALID_PARAMETER;
+  }
+
+  if (gphNxpExtns_Context.RawWriteCallBack == true) {
+    EXTNS_SetCallBackFlag(true);
+    gphNxpExtns_Context.RawWriteCallBack = false;
+  }
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phLibNfc_SendIncDecCmdPayload
+**
+** Description      This function prepares the Increment/Decrement Value to be
+**                  sent. This is called after sending the Increment/Decrement
+**                  command is already sent and successfull
+**
+** Returns          NFCSTATUS_SUCCESS            - Payload framing done
+**                  NFCSTATUS_INVALID_PARAMETER  - Otherwise
+**
+*******************************************************************************/
+STATIC NFCSTATUS
+phLibNfc_SendIncDecCmdPayload(phNfc_sTransceiveInfo_t* pTransceiveInfo,
+                              pphNciNfc_TransceiveInfo_t pMappedTranscvIf) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+
+  if ((NULL != pTransceiveInfo->sSendData.buffer) &&
+      (0 != (pTransceiveInfo->sSendData.length))) {
+    memcpy(pMappedTranscvIf->tSendData.pBuff, pTransceiveInfo->sSendData.buffer,
+           (pTransceiveInfo->sSendData.length));
+    pMappedTranscvIf->tSendData.wLen = pTransceiveInfo->sSendData.length;
+    pMappedTranscvIf->uCmd.T2TCmd = phNciNfc_eT2TRaw;
+  } else {
+    wStatus = NFCSTATUS_INVALID_PARAMETER;
+  }
+
+  if (gphNxpExtns_Context.RawWriteCallBack == true) {
+    EXTNS_SetCallBackFlag(true);
+    gphNxpExtns_Context.RawWriteCallBack = false;
+  }
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         Mfc_RecvPacket
+**
+** Description      Decodes Mifare Classic Tag Response
+**                  This is called from NFA_SendRaw Callback
+**
+** Returns:
+**                  NFCSTATUS_SUCCESS - if successfully initiated
+**                  NFCSTATUS_FAILED  - otherwise
+**
+*******************************************************************************/
+NFCSTATUS Mfc_RecvPacket(uint8_t* buff, uint8_t buffSz) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  phNciNfc_Buff_t RspBuff;
+  uint8_t* pcmd_buff;
+  uint16_t buffSize;
+
+  RspBuff.pBuff = buff;
+  RspBuff.wLen = buffSz;
+  status = phNciNfc_RecvMfResp(&RspBuff, status);
+  if (true == gAuthCmdBuf.auth_sent) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s Mfc Check Presence in progress", __func__);
+    gAuthCmdBuf.auth_sent = false;
+    return status;
+  }
+  if (true == gphNxpExtns_Context.writecmdFlag &&
+      (NFCSTATUS_SUCCESS == status)) {
+    pcmd_buff = (uint8_t*)malloc((uint32_t)MAX_BUFF_SIZE);
+    if (NULL == pcmd_buff) {
+      return NFCSTATUS_FAILED;
+    }
+    buffSize = MAX_BUFF_SIZE;
+    gphNxpExtns_Context.writecmdFlag = false;
+    phLibNfc_SendWrt16CmdPayload(NdefMap->pTransceiveInfo, &tNciTranscvInfo);
+    status = phNciNfc_SendMfReq(tNciTranscvInfo, pcmd_buff, &buffSize);
+    if (NFCSTATUS_PENDING != status) {
+      LOG(ERROR) << StringPrintf("ERROR : Mfc_RecvPacket: 0x%x", status);
+    } else {
+      status = NFCSTATUS_SUCCESS;
+    }
+    if (pcmd_buff != NULL) {
+      free(pcmd_buff);
+      pcmd_buff = NULL;
+    }
+  } else if (true == gphNxpExtns_Context.incrdecflag &&
+             (NFCSTATUS_SUCCESS == status)) {
+    pcmd_buff = (uint8_t*)malloc((uint32_t)MAX_BUFF_SIZE);
+    if (NULL == pcmd_buff) {
+      return NFCSTATUS_FAILED;
+    }
+    buffSize = MAX_BUFF_SIZE;
+    gphNxpExtns_Context.incrdecflag = false;
+    phLibNfc_SendIncDecCmdPayload(NdefMap->pTransceiveInfo, &tNciTranscvInfo);
+    status = phNciNfc_SendMfReq(tNciTranscvInfo, pcmd_buff, &buffSize);
+    if (NFCSTATUS_PENDING != status) {
+      LOG(ERROR) << StringPrintf("ERROR : Mfc_RecvPacket: 0x%x", status);
+    } else {
+      status = NFCSTATUS_SUCCESS;
+    }
+    gphNxpExtns_Context.incrdecstatusflag = true;
+    if (pcmd_buff != NULL) {
+      free(pcmd_buff);
+      pcmd_buff = NULL;
+    }
+
+  } else {
+    if (gphNxpExtns_Context.CallBackMifare != NULL) {
+      if ((gphNxpExtns_Context.incrdecstatusflag == true) && status == 0xB2) {
+        gphNxpExtns_Context.incrdecstatusflag = false;
+        status = NFCSTATUS_SUCCESS;
+      }
+      gphNxpExtns_Context.CallBackMifare(gphNxpExtns_Context.CallBackCtxt,
+                                         status);
+    }
+  }
+
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         phNciNfc_MfCreateXchgDataHdr
+**
+** Description      This function builds the payload header for mifare XchgData
+**                  request to be sent to NFCC.
+**
+** Returns          NFCSTATUS_PENDING            - Command framing done
+**                  NFCSTATUS_FAILED             - Otherwise
+**
+*******************************************************************************/
+STATIC
+NFCSTATUS
+phNciNfc_MfCreateXchgDataHdr(phNciNfc_TransceiveInfo_t tTranscvInfo,
+                             uint8_t* buff, uint16_t* buffSz)
+
+{
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  uint8_t i = 0;
+
+  buff[i++] = phNciNfc_e_MfRawDataXchgHdr;
+  memcpy(&buff[i], tTranscvInfo.tSendData.pBuff, tTranscvInfo.tSendData.wLen);
+  *buffSz = i + tTranscvInfo.tSendData.wLen;
+
+  status = nativeNfcExtns_doTransceive(buff, (uint16_t)*buffSz);
+
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         phNciNfc_MfCreateAuthCmdHdr
+**
+** Description      This function builds the payload header for mifare
+**                  classic Authenticate command to be sent to NFCC.
+**
+** Returns          NFCSTATUS_PENDING            - Command framing done
+**                  NFCSTATUS_FAILED             - Otherwise
+**
+*******************************************************************************/
+STATIC
+NFCSTATUS
+phNciNfc_MfCreateAuthCmdHdr(phNciNfc_TransceiveInfo_t tTranscvInfo,
+                            uint8_t bBlockAddr, uint8_t* buff,
+                            uint16_t* buffSz) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  //    pphNciNfc_RemoteDevInformation_t  pActivDev = NULL;
+  //    /*commented to eliminate unused variable warning*/
+  uint8_t bKey = 0x00;
+
+  /*No need to check range of block address*/
+  /*To check for Authenticate A or Authenticate B type command*/
+  if (PHNCINFC_AUTHENTICATION_KEYB == tTranscvInfo.tSendData.pBuff[0]) {
+    bKey = bKey | PHNCINFC_ENABLE_KEY_B;
+  }
+
+  /*TO Do last 4 bits of Key to be set based of firmware implementation*/
+  /*this value is hardcoded but based on firmware implementation change this
+   * value*/
+  bKey = (bKey | PHNCINFC_AUTHENTICATION_KEY);
+
+  bKey |= tTranscvInfo.tSendData.pBuff[2];
+
+  /*For authentication extension no need to copy tSendData buffer of
+   * tTranscvInfo */
+  tTranscvInfo.tSendData.wLen = 0x00;
+
+  buff[0] = phNciNfc_e_MfcAuthReq;
+  buff[1] = bBlockAddr;
+  buff[2] = bKey;
+
+  *buffSz = 0x03;
+  if (bKey & PH_NCINFC_MIFARECLASSIC_EMBEDDED_KEY) {
+    memcpy(&buff[3], &tTranscvInfo.tSendData.pBuff[3], PHLIBNFC_MFC_AUTHKEYLEN);
+    *buffSz += PHLIBNFC_MFC_AUTHKEYLEN;
+  }
+  /* Store the auth command buffer to use further for presence check */
+  if (gAuthCmdBuf.pauth_cmd != NULL) {
+    memset(gAuthCmdBuf.pauth_cmd->buffer, 0, NCI_MAX_DATA_LEN);
+    gAuthCmdBuf.pauth_cmd->length = *buffSz;
+    memcpy(gAuthCmdBuf.pauth_cmd->buffer, buff, *buffSz);
+  }
+  status = nativeNfcExtns_doTransceive(buff, (uint16_t)*buffSz);
+
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         phNciNfc_SendMfReq
+**
+** Description      This function shall be invoked as part of ReaderMgmt data
+**                  exchange sequence handler.
+**                  It shall send the request packet to NFCC.
+**
+** Returns          NFCSTATUS_PENDING  - Send request is Pending
+**                  NFCSTATUS_FAILED   - otherwise
+**
+*******************************************************************************/
+STATIC NFCSTATUS phNciNfc_SendMfReq(phNciNfc_TransceiveInfo_t tTranscvInfo,
+                                    uint8_t* buff, uint16_t* buffSz) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+
+  switch (tTranscvInfo.uCmd.T2TCmd) {
+    case phNciNfc_eT2TRaw: {
+      status = phNciNfc_MfCreateXchgDataHdr(tTranscvInfo, buff, buffSz);
+    } break;
+    case phNciNfc_eT2TAuth: {
+      status = phNciNfc_MfCreateAuthCmdHdr(tTranscvInfo, (tTranscvInfo.bAddr),
+                                           buff, buffSz);
+    } break;
+    default: {
+      status = NFCSTATUS_FAILED;
+      break;
+    }
+  }
+
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         phLibNfc_CalSectorAddress
+**
+** Description      This function update the sector address for Mifare classic
+**
+** Returns          none
+**
+*******************************************************************************/
+STATIC void phLibNfc_CalSectorAddress(uint8_t* Sector_Address) {
+  uint8_t BlockNumber = 0x00;
+
+  if (NULL != Sector_Address) {
+    BlockNumber = *Sector_Address;
+    if (BlockNumber >= PHLIBNFC_MIFARESTD4K_BLK128) {
+      *Sector_Address = (uint8_t)(PHLIBNFC_MIFARESTD_SECTOR_NO32 +
+                                  ((BlockNumber - PHLIBNFC_MIFARESTD4K_BLK128) /
+                                   PHLIBNFC_MIFARESTD_BLOCK_BYTES));
+    } else {
+      *Sector_Address = BlockNumber / PHLIBNFC_NO_OF_BLKPERSECTOR;
+    }
+  } else {
+  }
+
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         phLibNfc_GetKeyNumberMFC
+**
+** Description      This function find key number based on authentication
+*command
+**
+** Returns          NFCSTATUS_SUCCESS  - If found the key number
+**                  NFCSTATUS_FAILED   - otherwise
+**
+*******************************************************************************/
+STATIC NFCSTATUS phLibNfc_GetKeyNumberMFC(uint8_t* buffer, uint8_t* bKey) {
+  int32_t sdwStat = 0X00;
+  NFCSTATUS wStatus = NFCSTATUS_INVALID_PARAMETER;
+
+  /*Key Configuration
+    uint8_t NdefKey[PHLIBNFC_MFC_AUTHKEYLEN] = {0xD3,0XF7,0xD3,0XF7,0xD3,0XF7};
+    uint8_t RawKey[PHLIBNFC_MFC_AUTHKEYLEN] = {0xFF,0XFF,0xFF,0XFF,0xFF,0XFF};
+    uint8_t MadKey[PHLIBNFC_MFC_AUTHKEYLEN] = {0xA0,0XA1,0xA2,0XA3,0xA4,0XA5};
+    uint8_t Key[PHLIBNFC_MFC_AUTHKEYLEN] = {0x00,0x00,0x00,0x00,0x00,0x00}; */ /*Key used during ndef format*/
+
+  uint8_t bIndex = 0x00;
+  uint8_t bNoOfKeys = 0x00;
+
+#if PHLIBNFC_NXPETENSION_CONFIGURE_MFKEYS
+  uint8_t aMfc_keys[NXP_NUMBER_OF_MFC_KEYS][NXP_MFC_KEY_SIZE] = NXP_MFC_KEYS;
+#else
+  uint8_t aMfc_keys[1][1] = {{0x00}};
+#endif
+
+  if (NULL != bKey && NULL != buffer) {
+    bNoOfKeys = sizeof(aMfc_keys) / NXP_MFC_KEY_SIZE;
+    /* Traverse through the keys stored to determine whether keys is preloaded
+     * key */
+    for (bIndex = 0; bIndex < bNoOfKeys; bIndex++) {
+      /* Check passed key is NDEF key */
+      sdwStat = memcmp(&buffer[PHLIBNFC_MFCUIDLEN_INAUTHCMD], aMfc_keys[bIndex],
+                       PHLIBNFC_MFC_AUTHKEYLEN);
+      if (!sdwStat) {
+        LOG(ERROR) << StringPrintf(
+            "Mifare : phLibNfc_GetKeyNumberMFC Key found");
+        *bKey = bIndex;
+        wStatus = NFCSTATUS_SUCCESS;
+        break;
+      }
+    }
+    LOG(ERROR) << StringPrintf(
+        "Mifare : phLibNfc_GetKeyNumberMFC returning = 0x%x Key = 0x%x",
+        wStatus, *bKey);
+  } else {
+    wStatus = NFCSTATUS_FAILED;
+    LOG(ERROR) << StringPrintf(
+        "Mifare : phLibNfc_GetKeyNumberMFC returning = 0x%x", wStatus);
+  }
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phLibNfc_ChkAuthCmdMFC
+**
+** Description      This function Check Authentication command send is proper or
+*not
+**
+** Returns          NFCSTATUS_SUCCESS  - Authenticate command is proper
+**                  NFCSTATUS_FAILED   - otherwise
+**
+*******************************************************************************/
+STATIC NFCSTATUS phLibNfc_ChkAuthCmdMFC(
+    phNfc_sTransceiveInfo_t* pTransceiveInfo, uint8_t* bKey) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+
+  if (NULL != pTransceiveInfo && NULL != pTransceiveInfo->sSendData.buffer &&
+      0 != pTransceiveInfo->sSendData.length && NULL != bKey) {
+    if ((pTransceiveInfo->cmd.MfCmd == phNfc_eMifareAuthentA ||
+         pTransceiveInfo->cmd.MfCmd == phNfc_eMifareAuthentB)) {
+      wStatus =
+          phLibNfc_GetKeyNumberMFC(pTransceiveInfo->sSendData.buffer, bKey);
+    } else {
+      wStatus = NFCSTATUS_FAILED;
+    }
+  } else {
+    wStatus = NFCSTATUS_FAILED;
+  }
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phLibNfc_MifareMap
+**
+** Description      Mifare Mapping Utility function
+**
+** Returns          NFCSTATUS_SUCCESS             - Mapping is proper
+**                  NFCSTATUS_INVALID_PARAMETER   - otherwise
+**
+*******************************************************************************/
+STATIC NFCSTATUS
+phLibNfc_MifareMap(phNfc_sTransceiveInfo_t* pTransceiveInfo,
+                   pphNciNfc_TransceiveInfo_t pMappedTranscvIf) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  uint8_t bBuffIdx = 0;
+  uint8_t bSectorNumber;
+  uint8_t bKey = 0;
+
+  switch (pTransceiveInfo->cmd.MfCmd) {
+    case phNfc_eMifareRead16: {
+      if ((NULL != pTransceiveInfo->sRecvData.buffer) &&
+          (0 != (pTransceiveInfo->sRecvData.length))) {
+        pMappedTranscvIf->tSendData.pBuff[bBuffIdx++] = phNfc_eMifareRead16;
+        pMappedTranscvIf->tSendData.pBuff[bBuffIdx++] = pTransceiveInfo->addr;
+        pMappedTranscvIf->tSendData.wLen = bBuffIdx;
+        pMappedTranscvIf->uCmd.T2TCmd = phNciNfc_eT2TRaw;
+      } else {
+        status = NFCSTATUS_INVALID_PARAMETER;
+      }
+    } break;
+
+    case phNfc_eMifareWrite16: {
+      if ((NULL != pTransceiveInfo->sSendData.buffer) &&
+          (0 != (pTransceiveInfo->sSendData.length))) {
+        pMappedTranscvIf->tSendData.pBuff[bBuffIdx++] = phNfc_eMifareWrite16;
+        pMappedTranscvIf->tSendData.pBuff[bBuffIdx++] = pTransceiveInfo->addr;
+        memcpy(&(pMappedTranscvIf->tSendData.pBuff[bBuffIdx]),
+               pTransceiveInfo->sSendData.buffer,
+               (pTransceiveInfo->sSendData.length));
+        pMappedTranscvIf->tSendData.wLen =
+            bBuffIdx + pTransceiveInfo->sSendData.length;
+        pMappedTranscvIf->uCmd.T2TCmd = phNciNfc_eT2TRaw;
+      } else {
+        status = NFCSTATUS_INVALID_PARAMETER;
+      }
+    } break;
+
+    case phNfc_eMifareAuthentA:
+    case phNfc_eMifareAuthentB: {
+      if ((NULL != pTransceiveInfo->sSendData.buffer) &&
+          (0 != (pTransceiveInfo->sSendData.length)) &&
+          (NULL != pTransceiveInfo->sRecvData.buffer) &&
+          (0 != (pTransceiveInfo->sRecvData.length))) {
+        status = phLibNfc_ChkAuthCmdMFC(pTransceiveInfo, &bKey);
+        if (NFCSTATUS_FAILED != status) {
+          bSectorNumber = pTransceiveInfo->addr;
+          phLibNfc_CalSectorAddress(&bSectorNumber);
+          /*For creating extension command header pTransceiveInfo's MfCmd get
+           * used*/
+          pMappedTranscvIf->tSendData.pBuff[bBuffIdx++] =
+              pTransceiveInfo->cmd.MfCmd;
+          pMappedTranscvIf->tSendData.pBuff[bBuffIdx++] = bSectorNumber;
+          pMappedTranscvIf->uCmd.T2TCmd = phNciNfc_eT2TAuth;
+          pMappedTranscvIf->bAddr = bSectorNumber;
+          pMappedTranscvIf->bNumBlock = pTransceiveInfo->NumBlock;
+          if (NFCSTATUS_SUCCESS == status) {
+            pMappedTranscvIf->tSendData.pBuff[bBuffIdx++] = bKey;
+            (pMappedTranscvIf->tSendData.wLen) = (uint16_t)(bBuffIdx);
+
+          } else if (NFCSTATUS_INVALID_PARAMETER == status) {
+            bKey = bKey | PH_NCINFC_MIFARECLASSIC_EMBEDDED_KEY;
+            pMappedTranscvIf->tSendData.pBuff[bBuffIdx++] = bKey;
+            memcpy(&pMappedTranscvIf->tSendData.pBuff[bBuffIdx],
+                   &pTransceiveInfo->sSendData
+                        .buffer[PHLIBNFC_MFCUIDLEN_INAUTHCMD],
+                   PHLIBNFC_MFC_AUTHKEYLEN);
+
+            (pMappedTranscvIf->tSendData.wLen) =
+                (uint16_t)(bBuffIdx + PHLIBNFC_MFC_AUTHKEYLEN);
+            status = NFCSTATUS_SUCCESS;
+          } else {
+            /* do nothing */
+          }
+        }
+      } else {
+        status = NFCSTATUS_INVALID_PARAMETER;
+      }
+    } break;
+
+    case phNfc_eMifareRaw: {
+    } break;
+
+    default: {
+      status = NFCSTATUS_INVALID_PARAMETER;
+      break;
+    }
+  }
+
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         phLibNfc_MapCmds
+**
+** Description      This function maps the command request from libnfc level to
+*nci level
+**
+** Returns          NFCSTATUS_SUCCESS           - Mapping of command is
+*successful
+**                  NFCSTATUS_INVALID_PARAMETER - One or more of the supplied
+**                  parameters could not be interpreted properly
+**
+*******************************************************************************/
+STATIC NFCSTATUS phLibNfc_MapCmds(phNciNfc_RFDevType_t RemDevType,
+                                  phNfc_sTransceiveInfo_t* pTransceiveInfo,
+                                  pphNciNfc_TransceiveInfo_t pMappedTranscvIf) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+
+  if ((NULL == pTransceiveInfo) || (NULL == pMappedTranscvIf)) {
+    return NFCSTATUS_FAILED;
+  }
+  switch (RemDevType) {
+    case phNciNfc_eMifare1k_PICC:
+    case phNciNfc_eMifare4k_PICC: {
+      status = phLibNfc_MifareMap(pTransceiveInfo, pMappedTranscvIf);
+      break;
+    }
+    default: { break; }
+  }
+
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         phLibNfc_SendAuthCmd
+**
+** Description      This function Send authentication command to NFCC
+**
+** Returns          NFCSTATUS_SUCCESS           - Parameters are proper
+**                  NFCSTATUS_INVALID_PARAMETER - Otherwise
+**
+*******************************************************************************/
+STATIC NFCSTATUS
+phLibNfc_SendAuthCmd(phNfc_sTransceiveInfo_t* pTransceiveInfo,
+                     phNciNfc_TransceiveInfo_t* tNciTranscvInfo) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+
+  wStatus = phLibNfc_MapCmds(phNciNfc_eMifare1k_PICC, pTransceiveInfo,
+                             tNciTranscvInfo);
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phLibNfc_SendWrt16Cmd
+**
+** Description      This function maps Mifarewirte16 commands
+**
+** Returns          NFCSTATUS_SUCCESS           - Parameters are mapped
+**                  NFCSTATUS_INVALID_PARAMETER - Otherwise
+**
+*******************************************************************************/
+STATIC NFCSTATUS
+phLibNfc_SendWrt16Cmd(phNfc_sTransceiveInfo_t* pTransceiveInfo,
+                      pphNciNfc_TransceiveInfo_t pMappedTranscvIf) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+  uint8_t bBuffIdx = 0x00;
+
+  if ((NULL != pTransceiveInfo->sSendData.buffer) &&
+      (0 != (pTransceiveInfo->sSendData.length))) {
+    pMappedTranscvIf->tSendData.pBuff[bBuffIdx++] = phNfc_eMifareWrite16;
+    pMappedTranscvIf->tSendData.pBuff[bBuffIdx++] = pTransceiveInfo->addr;
+    pMappedTranscvIf->tSendData.wLen = bBuffIdx;
+    pMappedTranscvIf->uCmd.T2TCmd = phNciNfc_eT2TRaw;
+  } else {
+    wStatus = NFCSTATUS_INVALID_PARAMETER;
+  }
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phLibNfc_SendIncDecCmd
+**
+** Description      This function prepares the Increment/Decrement command
+**                  to be sent, increment/decrement value is sent separately
+**
+** Returns          NFCSTATUS_SUCCESS           - Params are mapped
+**                  NFCSTATUS_INVALID_PARAMETER - Otherwise
+**
+*******************************************************************************/
+STATIC NFCSTATUS phLibNfc_SendIncDecCmd(
+    phNfc_sTransceiveInfo_t* pTransceiveInfo,
+    pphNciNfc_TransceiveInfo_t pMappedTranscvIf, uint8_t IncDecCmd) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+  uint8_t bBuffIdx = 0x00;
+
+  if ((NULL != pTransceiveInfo->sSendData.buffer) &&
+      (0 != (pTransceiveInfo->sSendData.length))) {
+    pMappedTranscvIf->tSendData.pBuff[bBuffIdx++] = IncDecCmd;
+    pMappedTranscvIf->tSendData.pBuff[bBuffIdx++] = pTransceiveInfo->addr;
+    pMappedTranscvIf->tSendData.wLen = bBuffIdx;
+    pMappedTranscvIf->uCmd.T2TCmd = phNciNfc_eT2TRaw;
+  } else {
+    wStatus = NFCSTATUS_INVALID_PARAMETER;
+  }
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phLibNfc_SendRawCmd
+**
+** Description      This function maps Mifare raw command
+**
+** Returns          NFCSTATUS_SUCCESS           - Parameters are mapped
+**                  NFCSTATUS_INVALID_PARAMETER - Otherwise
+**
+*******************************************************************************/
+STATIC NFCSTATUS
+phLibNfc_SendRawCmd(phNfc_sTransceiveInfo_t* pTransceiveInfo,
+                    pphNciNfc_TransceiveInfo_t pMappedTranscvIf) {
+  NFCSTATUS wStatus = NFCSTATUS_SUCCESS;
+  //    uint8_t bBuffIdx = 0x00;                                  /*commented to
+  //    eliminate unused variable warning*/
+
+  if ((NULL != pTransceiveInfo->sSendData.buffer) &&
+      (0 != (pTransceiveInfo->sSendData.length))) {
+    memcpy(pMappedTranscvIf->tSendData.pBuff, pTransceiveInfo->sSendData.buffer,
+           (pTransceiveInfo->sSendData.length));
+    pMappedTranscvIf->tSendData.wLen = pTransceiveInfo->sSendData.length;
+    pMappedTranscvIf->uCmd.T2TCmd = phNciNfc_eT2TRaw;
+  } else {
+    wStatus = NFCSTATUS_INVALID_PARAMETER;
+  }
+
+  return wStatus;
+}
+
+/*******************************************************************************
+**
+** Function         phFriNfc_ExtnsTransceive
+**
+** Description      This function maps Mifare raw command and send it to NFCC
+**
+** Returns          NFCSTATUS_PENDING           - Operation successful
+**                  NFCSTATUS_INVALID_PARAMETER - Otherwise
+**
+*******************************************************************************/
+NFCSTATUS phFriNfc_ExtnsTransceive(phNfc_sTransceiveInfo_t* pTransceiveInfo,
+                                   phNfc_uCmdList_t Cmd, uint8_t* SendRecvBuf,
+                                   uint16_t SendLength,
+                                   uint16_t* SendRecvLength) {
+  (void)SendRecvLength;
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  uint8_t* buff = NULL;
+  uint16_t buffSz = 0;
+  uint8_t i = 0;
+  uint32_t length = SendLength;
+  uint8_t restore_payload[] = {
+      0x00, 0x00, 0x00, 0x00,
+  };
+
+  buff = (uint8_t*)malloc((uint32_t)MAX_BUFF_SIZE);
+  if (NULL == buff) {
+    return status;
+  }
+
+  pTransceiveInfo->cmd = Cmd;
+
+  if ((Cmd.MfCmd == phNfc_eMifareAuthentA) ||
+      (Cmd.MfCmd == phNfc_eMifareAuthentB)) {
+    pTransceiveInfo->addr = SendRecvBuf[i++];
+    pTransceiveInfo->sSendData.buffer[4] = SendRecvBuf[i++];
+    pTransceiveInfo->sSendData.buffer[5] = SendRecvBuf[i++];
+    pTransceiveInfo->sSendData.buffer[6] = SendRecvBuf[i++];
+    pTransceiveInfo->sSendData.buffer[7] = SendRecvBuf[i++];
+    pTransceiveInfo->sSendData.buffer[8] = SendRecvBuf[i++];
+    pTransceiveInfo->sSendData.buffer[9] = SendRecvBuf[i++];
+
+    pTransceiveInfo->cmd.MfCmd = Cmd.MfCmd;
+
+    pTransceiveInfo->sSendData.length = length;
+    pTransceiveInfo->sRecvData.length = MAX_BUFF_SIZE;
+    status = phLibNfc_MifareMap(pTransceiveInfo, &tNciTranscvInfo);
+  } else if (Cmd.MfCmd == phNfc_eMifareWrite16) {
+    pTransceiveInfo->addr = SendRecvBuf[i++];
+    length = SendLength - i;
+    memcpy(pTransceiveInfo->sSendData.buffer, &SendRecvBuf[i], length);
+    pTransceiveInfo->sSendData.length = length;
+    pTransceiveInfo->sRecvData.length = MAX_BUFF_SIZE;
+
+    gphNxpExtns_Context.writecmdFlag = true;
+
+    status = phLibNfc_SendWrt16Cmd(pTransceiveInfo, &tNciTranscvInfo);
+  } else if ((Cmd.MfCmd == phNfc_eMifareInc) ||
+             (Cmd.MfCmd == phNfc_eMifareDec)) {
+    pTransceiveInfo->addr = SendRecvBuf[i++];
+    length = SendLength - i;
+    memcpy(pTransceiveInfo->sSendData.buffer, &SendRecvBuf[i], length);
+    pTransceiveInfo->sSendData.length = length;
+    pTransceiveInfo->sRecvData.length = MAX_BUFF_SIZE;
+
+    gphNxpExtns_Context.incrdecflag = true;
+
+    status =
+        phLibNfc_SendIncDecCmd(pTransceiveInfo, &tNciTranscvInfo, Cmd.MfCmd);
+
+  } else if (Cmd.MfCmd == phNfc_eMifareRestore) {
+    pTransceiveInfo->addr = SendRecvBuf[i++];
+    length = SendLength - i;
+    memcpy(pTransceiveInfo->sSendData.buffer, &restore_payload[0],
+           sizeof(restore_payload));
+    pTransceiveInfo->sSendData.length = length + sizeof(restore_payload);
+    pTransceiveInfo->sRecvData.length = MAX_BUFF_SIZE;
+
+    gphNxpExtns_Context.incrdecflag = true;
+
+    status =
+        phLibNfc_SendIncDecCmd(pTransceiveInfo, &tNciTranscvInfo, Cmd.MfCmd);
+
+  } else if ((Cmd.MfCmd == phNfc_eMifareRaw) ||
+             (Cmd.MfCmd == phNfc_eMifareTransfer)) {
+    pTransceiveInfo->cmd.MfCmd = (phNfc_eMifareCmdList_t)phNciNfc_eT2TRaw;
+    memcpy(pTransceiveInfo->sSendData.buffer, SendRecvBuf, length);
+    pTransceiveInfo->sSendData.length = length;
+    pTransceiveInfo->sRecvData.length = MAX_BUFF_SIZE;
+    status = phLibNfc_SendRawCmd(pTransceiveInfo, &tNciTranscvInfo);
+  } else {
+    pTransceiveInfo->addr = SendRecvBuf[i++];
+    length = SendLength - i;
+    memcpy(pTransceiveInfo->sSendData.buffer, &SendRecvBuf[i], length);
+    pTransceiveInfo->sSendData.length = length;
+    pTransceiveInfo->sRecvData.length = MAX_BUFF_SIZE;
+    status = phLibNfc_MifareMap(pTransceiveInfo, &tNciTranscvInfo);
+  }
+
+  if (NFCSTATUS_SUCCESS == status) {
+    status = phNciNfc_SendMfReq(tNciTranscvInfo, buff, &buffSz);
+    if (NFCSTATUS_PENDING != status) {
+      LOG(ERROR) << StringPrintf("ERROR : phNciNfc_SendMfReq()");
+    }
+  } else {
+    LOG(ERROR) << StringPrintf(" ERROR : Sending phNciNfc_SendMfReq");
+  }
+  if (buff != NULL) {
+    free(buff);
+    buff = NULL;
+  }
+
+  return status;
+}
+/*******************************************************************************
+**
+** Function         Mfc_CheckNdef_timeoutcb_Routine
+**
+** Description      Callback for  Mifare check ndef
+**
+** Returns          None
+**
+**
+*******************************************************************************/
+STATIC void Mfc_CheckNdef_timeoutcb_Routine(union sigval value) {
+  LOG(ERROR) << StringPrintf(" Inside Mfc_CheckNdef_timeoutcb_Routine() ");
+  tNFA_CONN_EVT_DATA conn_evt_data;
+  /* NDEF Detection failed for other reasons */
+  conn_evt_data.ndef_detect.status = NFCSTATUS_FAILED;
+  conn_evt_data.ndef_detect.cur_size = 0;
+  conn_evt_data.ndef_detect.max_size = 0;
+  conn_evt_data.ndef_detect.flags = RW_NDEF_FL_UNKNOWN;
+
+  /* update local flags */
+  NdefInfo.is_ndef = 0;
+  NdefInfo.NdefActualSize = conn_evt_data.ndef_detect.cur_size;
+
+  (*gphNxpExtns_Context.p_conn_cback)(NFA_NDEF_DETECT_EVT, &conn_evt_data);
+}
diff --git a/nci/jni/extns/pn54x/src/mifare/phNxpExtns_MifareStd.h b/nci/jni/extns/pn54x/src/mifare/phNxpExtns_MifareStd.h
index 7b942d62..bfa0adc5 100644
--- a/nci/jni/extns/pn54x/src/mifare/phNxpExtns_MifareStd.h
+++ b/nci/jni/extns/pn54x/src/mifare/phNxpExtns_MifareStd.h
@@ -17,13 +17,13 @@
 #ifndef _PHNXPEXTNS_MFCRF_H_
 #define _PHNXPEXTNS_MFCRF_H_
 
-#include <phNfcTypes.h>
-#include <phNciNfcTypes.h>
-#include <phFriNfc_MifareStdMap.h>
 #include <phFriNfc_MifStdFormat.h>
+#include <phFriNfc_MifareStdMap.h>
+#include <phNciNfcTypes.h>
+#include <phNfcTypes.h>
 #include <phNxpExtns.h>
-#include <semaphore.h>
 #include <pthread.h>
+#include <semaphore.h>
 
 extern uint8_t current_key[];
 /* Enable this macro to set key configuration for mifare classic Tag */
@@ -31,45 +31,57 @@ extern uint8_t current_key[];
 
 #define MAX_BUFF_SIZE (512)
 
-#define PHLIBNFC_MIFARESTD4K_BLK128         128  /*Block number 128 for Mifare 4k */
-#define PHLIBNFC_MIFARESTD_SECTOR_NO32      32   /* Sector 32 for Mifare 4K*/
-#define PHLIBNFC_MIFARESTD_BLOCK_BYTES      16   /* Bytes per block after block 32 for Mifare 4K*/
+#define PHLIBNFC_MIFARESTD4K_BLK128 128   /*Block number 128 for Mifare 4k */
+#define PHLIBNFC_MIFARESTD_SECTOR_NO32 32 /* Sector 32 for Mifare 4K*/
+#define PHLIBNFC_MIFARESTD_BLOCK_BYTES \
+  16 /* Bytes per block after block 32 for Mifare 4K*/
 
-#define PHLIBNFC_NO_OF_BLKPERSECTOR  (0x04)      /* Number of blocks per sector for \
-                                                  * Mifare Clsssic Tag*/
+#define PHLIBNFC_NO_OF_BLKPERSECTOR         \
+  (0x04) /* Number of blocks per sector for \
+          * Mifare Clsssic Tag*/
 
-#define PHLIBNFC_MFCUIDLEN_INAUTHCMD        0x04     /* UID length in Authentication command */
-#define PHLIBNFC_MFC_AUTHKEYLEN             0x06     /* Authentication key length */
+#define PHLIBNFC_MFCUIDLEN_INAUTHCMD \
+  0x04                               /* UID length in Authentication command */
+#define PHLIBNFC_MFC_AUTHKEYLEN 0x06 /* Authentication key length */
 
-#define PHNCINFC_AUTHENTICATION_KEY   (0x00U)     /* Authentication key passed in extension \
-                                                     command header of authentication command */
-#define PHNCINFC_AUTHENTICATION_KEYB  (0x61U)     /* Authentication Key B */
-#define PHNCINFC_ENABLE_KEY_B         (0x80U)     /* Enable Key B */
-#define PH_NCINFC_MIFARECLASSIC_EMBEDDED_KEY  (0x10)    /* MIFARE Classic use Embedded Key*/
+#define PHNCINFC_AUTHENTICATION_KEY                 \
+  (0x00U) /* Authentication key passed in extension \
+             command header of authentication command */
+#define PHNCINFC_AUTHENTICATION_KEYB (0x61U) /* Authentication Key B */
+#define PHNCINFC_ENABLE_KEY_B (0x80U)        /* Enable Key B */
+#define PH_NCINFC_MIFARECLASSIC_EMBEDDED_KEY \
+  (0x10) /* MIFARE Classic use Embedded Key*/
 
-#define PH_NCINFC_STATUS_OK           (0x0000)    /* Status OK */
-#define PHNCINFC_EXTNID_SIZE          (0x01U)     /* Size of Mifare Extension Req/Rsp Id */
-#define PHNCINFC_EXTNSTATUS_SIZE      (0x01U)     /* Size of Mifare Extension Resp Status Byte */
+#define PH_NCINFC_STATUS_OK (0x0000) /* Status OK */
+#define PHNCINFC_EXTNID_SIZE (0x01U) /* Size of Mifare Extension Req/Rsp Id */
+#define PHNCINFC_EXTNSTATUS_SIZE \
+  (0x01U) /* Size of Mifare Extension Resp Status Byte */
 
-#define PH_NCINFC_EXTN_INVALID_PARAM_VAL (0xFFU)  /* Initial value of Req/Resp Param/Status */
+#define PH_NCINFC_EXTN_INVALID_PARAM_VAL \
+  (0xFFU) /* Initial value of Req/Resp Param/Status */
 
-#define PH_FRINFC_NDEF_READ_REQ       (0x00U)     /* NDEF Read Request */
-#define PH_FRINFC_NDEF_WRITE_REQ      (0x01U)     /* NDEF Write Request */
+#define PH_FRINFC_NDEF_READ_REQ (0x00U)  /* NDEF Read Request */
+#define PH_FRINFC_NDEF_WRITE_REQ (0x01U) /* NDEF Write Request */
 
-#define PH_LIBNFC_INTERNAL_CHK_NDEF_NOT_DONE (0x02U)  /* Status for check NDEF not done */
+#define PH_LIBNFC_INTERNAL_CHK_NDEF_NOT_DONE \
+  (0x02U) /* Status for check NDEF not done */
 
-#define NDEF_SENDRCV_BUF_LEN            252U      /* Send receive buffer length */
+#define NDEF_SENDRCV_BUF_LEN 252U /* Send receive buffer length */
 
-#define NXP_NUMBER_OF_MFC_KEYS    (0x04U)
-#define NXP_MFC_KEY_SIZE          (0x06U)
+#define NXP_NUMBER_OF_MFC_KEYS (0x04U)
+#define NXP_MFC_KEY_SIZE (0x06U)
 
-#define NXP_MFC_KEYS    {\
-                          {0xA0,0XA1,0xA2,0XA3,0xA4,0XA5},\
-                          {0xD3,0XF7,0xD3,0XF7,0xD3,0XF7},\
-                          {0xFF,0XFF,0xFF,0XFF,0xFF,0XFF},\
-                          {0x00,0x00,0x00,0x00,0x00,0x00}} /* Key used during NDEF format */
+#define NXP_MFC_KEYS                            \
+  {                                             \
+    {0xA0, 0XA1, 0xA2, 0XA3, 0xA4, 0XA5},       \
+        {0xD3, 0XF7, 0xD3, 0XF7, 0xD3, 0XF7},   \
+        {0xFF, 0XFF, 0xFF, 0XFF, 0xFF, 0XFF}, { \
+      0x00, 0x00, 0x00, 0x00, 0x00, 0x00        \
+    }                                           \
+  } /* Key used during NDEF format */
 
-#define PH_FRINFC_CHECK_NDEF_TIMEOUT  (2000U) /* Mifare Check Ndef timeout value in milliseconds.*/
+#define PH_FRINFC_CHECK_NDEF_TIMEOUT \
+  (2000U) /* Mifare Check Ndef timeout value in milliseconds.*/
 
 #ifndef NCI_MAX_DATA_LEN
 #define NCI_MAX_DATA_LEN 300
@@ -78,99 +90,94 @@ extern uint8_t current_key[];
 /*
  * Request Id for different commands
  */
-typedef enum phNciNfc_ExtnReqId
-{
-    phNciNfc_e_T1TXchgDataReq = 0x10,                   /* T1T Raw Data Request from DH */
-    phNciNfc_e_T1TWriteNReq = 0x20,                     /* T1T N bytes write request from DH */
-    phNciNfc_e_MfRawDataXchgHdr = 0x10,                 /* MF Raw Data Request from DH */
-    phNciNfc_e_MfWriteNReq = 0x31,                      /* MF N bytes write request from DH */
-    phNciNfc_e_MfReadNReq = 0x32,                       /* MF N bytes read request from DH */
-    phNciNfc_e_MfSectorSelReq = 0x33,                   /* MF Block select request from DH */
-    phNciNfc_e_MfPlusProxCheckReq = 0x28,               /* MF + Prox check request for NFCC from DH */
-    phNciNfc_e_MfcAuthReq = 0x40,                       /* MFC Authentication request for NFCC from DH */
-    phNciNfc_e_InvalidReq                               /* Invalid ReqId */
-} phNciNfc_ExtnReqId_t ;
+typedef enum phNciNfc_ExtnReqId {
+  phNciNfc_e_T1TXchgDataReq = 0x10,   /* T1T Raw Data Request from DH */
+  phNciNfc_e_T1TWriteNReq = 0x20,     /* T1T N bytes write request from DH */
+  phNciNfc_e_MfRawDataXchgHdr = 0x10, /* MF Raw Data Request from DH */
+  phNciNfc_e_MfWriteNReq = 0x31,      /* MF N bytes write request from DH */
+  phNciNfc_e_MfReadNReq = 0x32,       /* MF N bytes read request from DH */
+  phNciNfc_e_MfSectorSelReq = 0x33,   /* MF Block select request from DH */
+  phNciNfc_e_MfPlusProxCheckReq =
+      0x28, /* MF + Prox check request for NFCC from DH */
+  phNciNfc_e_MfcAuthReq =
+      0x40,             /* MFC Authentication request for NFCC from DH */
+  phNciNfc_e_InvalidReq /* Invalid ReqId */
+} phNciNfc_ExtnReqId_t;
 
 /*
  * Response Ids for different command response
  */
-typedef enum phNciNfc_ExtnRespId
-{
-    phNciNfc_e_T1TXchgDataRsp = 0x10,           /* DH gets Raw data from T1T on successful req */
-    phNciNfc_e_T1TWriteNRsp = 0x20,             /* DH gets write status */
-    phNciNfc_e_MfXchgDataRsp = 0x10,            /* DH gets Raw data from MF on successful req */
-    phNciNfc_e_MfWriteNRsp = 0x31,              /* DH gets write status */
-    phNciNfc_e_MfReadNRsp = 0x32,               /* DH gets N Bytes read from MF, if successful */
-    phNciNfc_e_MfSectorSelRsp = 0x33,           /* DH gets the Sector Select cmd status */
-    phNciNfc_e_MfPlusProxCheckRsp = 0x29,       /* DH gets the MF+ Prox Check cmd status */
-    phNciNfc_e_MfcAuthRsp = 0x40,               /* DH gets the authenticate cmd status */
-    phNciNfc_e_InvalidRsp                       /* Invalid RspId */
-}phNciNfc_ExtnRespId_t ;
+typedef enum phNciNfc_ExtnRespId {
+  phNciNfc_e_T1TXchgDataRsp =
+      0x10, /* DH gets Raw data from T1T on successful req */
+  phNciNfc_e_T1TWriteNRsp = 0x20, /* DH gets write status */
+  phNciNfc_e_MfXchgDataRsp =
+      0x10, /* DH gets Raw data from MF on successful req */
+  phNciNfc_e_MfWriteNRsp = 0x31, /* DH gets write status */
+  phNciNfc_e_MfReadNRsp =
+      0x32, /* DH gets N Bytes read from MF, if successful */
+  phNciNfc_e_MfSectorSelRsp = 0x33, /* DH gets the Sector Select cmd status */
+  phNciNfc_e_MfPlusProxCheckRsp =
+      0x29,                     /* DH gets the MF+ Prox Check cmd status */
+  phNciNfc_e_MfcAuthRsp = 0x40, /* DH gets the authenticate cmd status */
+  phNciNfc_e_InvalidRsp         /* Invalid RspId */
+} phNciNfc_ExtnRespId_t;
 
 /* Data buffer */
-typedef struct phNciNfc_Buff
-{
-    uint8_t *pBuff;    /* pointer to the buffer where received payload shall be stored*/
-    uint16_t wLen;     /* Buffer length*/
-}phNciNfc_Buff_t, *pphNciNfc_Buff_t;
+typedef struct phNciNfc_Buff {
+  uint8_t*
+      pBuff; /* pointer to the buffer where received payload shall be stored*/
+  uint16_t wLen; /* Buffer length*/
+} phNciNfc_Buff_t, *pphNciNfc_Buff_t;
 
 /*
  * Structure for NCI Extension information
  */
-typedef struct phNciNfc_ExtnInfo
-{
-    union
-    {
-        phNciNfc_ExtnReqId_t      ExtnReqId;      /* NCI extension reqid sent */
-        phNciNfc_ExtnRespId_t     ExtnRspId;      /* NCI extension respid received */
-    }ActivExtnId;                                 /* Active Req/Rsp Id */
-    uint8_t              bParamsNumsPresent;      /* Holds number of params available for this Req/Rsp Id */
-    uint8_t              bParam[2];               /* Req/Res: Param[0] = Param1, Param[1] = Param2 */
-}phNciNfc_ExtnInfo_t;
+typedef struct phNciNfc_ExtnInfo {
+  union {
+    phNciNfc_ExtnReqId_t ExtnReqId;  /* NCI extension reqid sent */
+    phNciNfc_ExtnRespId_t ExtnRspId; /* NCI extension respid received */
+  } ActivExtnId;                     /* Active Req/Rsp Id */
+  uint8_t bParamsNumsPresent; /* Holds number of params available for this
+                                 Req/Rsp Id */
+  uint8_t bParam[2]; /* Req/Res: Param[0] = Param1, Param[1] = Param2 */
+} phNciNfc_ExtnInfo_t;
 
 /*
  * NDEF related data structures
  */
-typedef struct phLibNfc_NdefInfo
-{
-
-    uint8_t             NdefContinueRead;
-    uint32_t            NdefActualSize;
-    uint32_t            AppWrLength;
-    phFriNfc_NdefMap_t  *psNdefMap;
-    uint16_t            NdefSendRecvLen;
-    phNfc_sData_t       *psUpperNdefMsg;
-    uint32_t            dwWrLength;
-    uint32_t            NdefLength;
-    uint8_t             is_ndef;
-    phFriNfc_sNdefSmtCrdFmt_t    *ndef_fmt;
-}phLibNfc_NdefInfo_t;
+typedef struct phLibNfc_NdefInfo {
+  uint8_t NdefContinueRead;
+  uint32_t NdefActualSize;
+  uint32_t AppWrLength;
+  phFriNfc_NdefMap_t* psNdefMap;
+  uint16_t NdefSendRecvLen;
+  phNfc_sData_t* psUpperNdefMsg;
+  uint32_t dwWrLength;
+  uint32_t NdefLength;
+  uint8_t is_ndef;
+  phFriNfc_sNdefSmtCrdFmt_t* ndef_fmt;
+} phLibNfc_NdefInfo_t;
 
 /*
  * NDEF offsets
  */
-typedef enum
-{
-    phLibNfc_Ndef_EBegin         = 0x01, /**<  Start from the beginning position */
-    phLibNfc_Ndef_ECurrent               /**<  Start from the current position */
+typedef enum {
+  phLibNfc_Ndef_EBegin = 0x01, /**<  Start from the beginning position */
+  phLibNfc_Ndef_ECurrent       /**<  Start from the current position */
 } phLibNfc_Ndef_EOffset_t;
 
 /*
  * Extns module status
  */
-typedef enum
-{
-   EXTNS_STATUS_OPEN = 0,
-   EXTNS_STATUS_CLOSE
-} phNxpExtns_Status;
+typedef enum { EXTNS_STATUS_OPEN = 0, EXTNS_STATUS_CLOSE } phNxpExtns_Status;
 
 /*
  * NCI Data
  */
-typedef struct nci_data_package
-{
-    uint16_t len;
-    uint8_t p_data[NCI_MAX_DATA_LEN];
+typedef struct nci_data_package {
+  uint16_t len;
+  uint8_t p_data[NCI_MAX_DATA_LEN];
 } nci_rsp_data_t;
 
 /*
@@ -179,55 +186,52 @@ typedef struct nci_data_package
 typedef void (*CallBackMifare_t)(void*, uint16_t);
 
 /*
-  * Auth Cmd Data
+ * Auth Cmd Data
  */
-typedef struct nci_mfc_package
-{
-    bool_t   auth_status;
-    bool_t   auth_sent;
-    sem_t    semPresenceCheck;
-    pthread_mutex_t syncmutex;
-    NFCSTATUS status;
-    phNfc_sData_t *pauth_cmd;
+typedef struct nci_mfc_package {
+  bool_t auth_status;
+  bool_t auth_sent;
+  sem_t semPresenceCheck;
+  pthread_mutex_t syncmutex;
+  NFCSTATUS status;
+  phNfc_sData_t* pauth_cmd;
 } phNci_mfc_auth_cmd_t;
 /*
  * Structure of callback functions from different module.
  * It includes the status also.
  */
-typedef struct phNxpExtns_Context
-{
-    phNxpExtns_Status           Extns_status;
-    tNFA_DM_CBACK               *p_dm_cback;
-    tNFA_CONN_CBACK             *p_conn_cback;
-    tNFA_NDEF_CBACK             *p_ndef_cback;
-    uint8_t                     writecmdFlag;
-    uint8_t                     RawWriteCallBack;
-    void                        *CallBackCtxt;
-    CallBackMifare_t            CallBackMifare;
-    bool_t                     ExtnsConnect;
-    bool_t                     ExtnsDeactivate;
-    bool_t                     ExtnsCallBack;
-    uint8_t                    incrdecflag;
-    uint8_t                    incrdecstatusflag;
+typedef struct phNxpExtns_Context {
+  phNxpExtns_Status Extns_status;
+  tNFA_DM_CBACK* p_dm_cback;
+  tNFA_CONN_CBACK* p_conn_cback;
+  tNFA_NDEF_CBACK* p_ndef_cback;
+  uint8_t writecmdFlag;
+  uint8_t RawWriteCallBack;
+  void* CallBackCtxt;
+  CallBackMifare_t CallBackMifare;
+  bool_t ExtnsConnect;
+  bool_t ExtnsDeactivate;
+  bool_t ExtnsCallBack;
+  uint8_t incrdecflag;
+  uint8_t incrdecstatusflag;
 } phNxpExtns_Context_t;
 
-NFCSTATUS phFriNfc_ExtnsTransceive(phNfc_sTransceiveInfo_t *pTransceiveInfo,
-                                   phNfc_uCmdList_t Cmd,
-                                   uint8_t *SendRecvBuf,
+NFCSTATUS phFriNfc_ExtnsTransceive(phNfc_sTransceiveInfo_t* pTransceiveInfo,
+                                   phNfc_uCmdList_t Cmd, uint8_t* SendRecvBuf,
                                    uint16_t SendLength,
                                    uint16_t* SendRecvLength);
 NFCSTATUS phNxpExtns_MfcModuleInit(void);
 NFCSTATUS phNxpExtns_MfcModuleDeInit(void);
-NFCSTATUS Mfc_WriteNdef(uint8_t *p_data, uint32_t len);
+NFCSTATUS Mfc_WriteNdef(uint8_t* p_data, uint32_t len);
 NFCSTATUS Mfc_CheckNdef(void);
 NFCSTATUS Mfc_ReadNdef(void);
-NFCSTATUS Mfc_FormatNdef(uint8_t *secretkey, uint8_t len);
-NFCSTATUS Mfc_Transceive(uint8_t *p_data, uint32_t len);
-NFCSTATUS Mfc_SetReadOnly(uint8_t *secrtkey, uint8_t len);
+NFCSTATUS Mfc_FormatNdef(uint8_t* secretkey, uint8_t len);
+NFCSTATUS Mfc_Transceive(uint8_t* p_data, uint32_t len);
+NFCSTATUS Mfc_SetReadOnly(uint8_t* secrtkey, uint8_t len);
 void Mfc_DeactivateCbackSelect(void);
 void Mfc_ActivateCback(void);
-NFCSTATUS Mfc_RecvPacket(uint8_t *buff, uint8_t buffSz);
+NFCSTATUS Mfc_RecvPacket(uint8_t* buff, uint8_t buffSz);
 NFCSTATUS phNxNciExtns_MifareStd_Reconnect(void);
-NFCSTATUS Mfc_PresenceCheck (void);
+NFCSTATUS Mfc_PresenceCheck(void);
 
 #endif /* _PHNXPEXTNS_MFCRF_H_ */
diff --git a/nci/jni/extns/pn54x/src/phNxpExtns.c b/nci/jni/extns/pn54x/src/phNxpExtns.c
deleted file mode 100644
index 56668a9a..00000000
--- a/nci/jni/extns/pn54x/src/phNxpExtns.c
+++ /dev/null
@@ -1,684 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#define LOG_TAG "pn54x"
-
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/time.h>
-
-#include <log/log.h>
-
-#include <phNxpExtns_MifareStd.h>
-#include <phNxpLog.h>
-#include <phNxpConfig.h>
-
-phNxpExtns_Context_t         gphNxpExtns_Context;
-extern phFriNfc_NdefMap_t    *NdefMap;
-extern phNci_mfc_auth_cmd_t  gAuthCmdBuf;
-
-static NFCSTATUS phNxpExtns_ProcessSysMessage (phLibNfc_Message_t *msg);
-static NFCSTATUS phNxpExtns_SendMsg (phLibNfc_Message_t *sysmsg);
-
-/*******************************************************************************
-**
-** Function         EXTNS_Init
-**
-** Description      This function Initializes Mifare Classic Extns. Allocates
-**                  required memory and initializes the Mifare Classic Vars
-**
-** Returns          NFCSTATUS_SUCCESS if successfully initialized
-**                  NFCSTATUS_FAILED otherwise
-**
-*******************************************************************************/
-NFCSTATUS EXTNS_Init (tNFA_DM_CBACK        *p_nfa_dm_cback,
-                      tNFA_CONN_CBACK      *p_nfa_conn_cback)
-{
-    NFCSTATUS status = NFCSTATUS_FAILED;
-
-    /* reset config cache */
-    resetNxpConfig ();
-
-    /* Initialize Log level */
-    phNxpLog_InitializeLogLevel ();
-
-    /* Validate parameters */
-    if ((!p_nfa_dm_cback) || (!p_nfa_conn_cback))
-    {
-        NXPLOG_EXTNS_E ("EXTNS_Init(): error null callback");
-        goto clean_and_return;
-    }
-
-    gphNxpExtns_Context.p_dm_cback = p_nfa_dm_cback;
-    gphNxpExtns_Context.p_conn_cback = p_nfa_conn_cback;
-
-    if (NFCSTATUS_SUCCESS != phNxpExtns_MfcModuleInit ())
-    {
-       NXPLOG_EXTNS_E ("ERROR: MFC Module Init Failed");
-       goto clean_and_return;
-    }
-    gphNxpExtns_Context.Extns_status = EXTNS_STATUS_OPEN;
-
-    status = NFCSTATUS_SUCCESS;
-    return status;
-
-clean_and_return:
-    gphNxpExtns_Context.Extns_status = EXTNS_STATUS_CLOSE;
-    return status;
-}
-
-/*******************************************************************************
-**
-** Function         EXTNS_Close
-**
-** Description      This function de-initializes Mifare Classic Extns.
-**                  De-allocates memory
-**
-** Returns          None
-**
-*******************************************************************************/
-void EXTNS_Close (void)
-{
-    gphNxpExtns_Context.Extns_status = EXTNS_STATUS_CLOSE;
-    phNxpExtns_MfcModuleDeInit ();
-    return;
-}
-
-/*******************************************************************************
-**
-** Function         EXTNS_MfcCallBack
-**
-** Description      Decodes Mifare Classic Tag Response
-**                  This is called from NFA_SendRaw Callback
-**
-** Returns:
-**                  NFCSTATUS_SUCCESS if successfully initiated
-**                  NFCSTATUS_FAILED otherwise
-**
-*******************************************************************************/
-NFCSTATUS EXTNS_MfcCallBack (uint8_t *buf, uint32_t buflen)
-{
-    NFCSTATUS status = NFCSTATUS_SUCCESS;
-
-    phLibNfc_Message_t msg;
-
-    msg.eMsgType = PH_NXPEXTNS_RX_DATA;
-    msg.pMsgData = buf;
-    msg.Size = buflen;
-
-    status = phNxpExtns_SendMsg (&msg);
-    if (NFCSTATUS_SUCCESS != status)
-    {
-        NXPLOG_EXTNS_E ("Error Sending msg to Extension Thread");
-    }
-    return status;
-}
-
-/*******************************************************************************
-**
-** Function         EXTNS_MfcCheckNDef
-**
-** Description      Performs NDEF detection for Mifare Classic Tag
-**
-**                  Upon successful completion of NDEF detection, a
-**                  NFA_NDEF_DETECT_EVT will be sent, to notify the application
-**                  of the NDEF attributes (NDEF total memory size, current
-**                  size, etc.).
-**
-** Returns:
-**                  NFCSTATUS_SUCCESS if successfully initiated
-**                  NFCSTATUS_FAILED otherwise
-**
-*******************************************************************************/
-NFCSTATUS EXTNS_MfcCheckNDef (void)
-{
-    NFCSTATUS status = NFCSTATUS_SUCCESS;
-    phLibNfc_Message_t msg;
-
-    msg.eMsgType = PH_NXPEXTNS_MIFARE_CHECK_NDEF;
-    msg.pMsgData = NULL;
-    msg.Size = 0;
-
-    status = phNxpExtns_SendMsg (&msg);
-    if (NFCSTATUS_SUCCESS != status)
-    {
-        NXPLOG_EXTNS_E ("Error Sending msg to Extension Thread");
-    }
-
-    return status;
-}
-
-/*******************************************************************************
-**
-** Function         EXTNS_MfcReadNDef
-**
-** Description      Reads NDEF message from Mifare Classic Tag.
-**
-**                  Upon receiving the NDEF message, the message will be sent to
-**                  the handler registered with EXTNS_MfcRegisterNDefTypeHandler.
-**
-** Returns:
-**                  NFCSTATUS_SUCCESS if successfully initiated
-**                  NFCSTATUS_FAILED otherwise
-**
-*******************************************************************************/
-NFCSTATUS EXTNS_MfcReadNDef (void)
-{
-    NFCSTATUS status = NFCSTATUS_SUCCESS;
-
-    phLibNfc_Message_t msg;
-
-    msg.eMsgType = PH_NXPEXTNS_MIFARE_READ_NDEF;
-    msg.pMsgData = NULL;
-    msg.Size = 0;
-
-    status = phNxpExtns_SendMsg (&msg);
-    if (NFCSTATUS_SUCCESS != status)
-    {
-        NXPLOG_EXTNS_E("Error Sending msg to Extension Thread");
-    }
-
-    return status;
-}
-/*******************************************************************************
-**
-** Function         EXTNS_MfcPresenceCheck
-**
-** Description      Do the check presence for Mifare Classic Tag.
-**
-**
-** Returns:
-**                  NFCSTATUS_SUCCESS if successfully initiated
-**                  NFCSTATUS_FAILED otherwise
-**
-*******************************************************************************/
-NFCSTATUS EXTNS_MfcPresenceCheck (void)
-{
-    NFCSTATUS status = NFCSTATUS_SUCCESS;
-
-    phLibNfc_Message_t msg;
-
-    msg.eMsgType = PH_NXPEXTNS_MIFARE_PRESENCE_CHECK;
-    msg.pMsgData = NULL;
-    msg.Size = 0;
-
-    gAuthCmdBuf.status = NFCSTATUS_FAILED;
-    if (sem_init (&gAuthCmdBuf.semPresenceCheck, 0, 0) == -1)
-    {
-        ALOGE("%s: semaphore creation failed (errno=%d)", __func__, errno);
-        return NFCSTATUS_FAILED;
-    }
-
-    status = phNxpExtns_SendMsg (&msg);
-    if (NFCSTATUS_SUCCESS != status)
-    {
-        NXPLOG_EXTNS_E ("Error Sending msg to Extension Thread");
-        sem_destroy (&gAuthCmdBuf.semPresenceCheck);
-    }
-
-    return status;
-}
-
-/*******************************************************************************
-**
-** Function        EXTNS_MfcSetReadOnly
-**
-**
-** Description:
-**      Sets tag as read only.
-**
-**      When tag is set as read only, or if an error occurs, the app will be
-**      notified with NFA_SET_TAG_RO_EVT.
-**
-** Returns:
-**                  NFCSTATUS_SUCCESS if successfully initiated
-**                  NFCSTATUS_FAILED otherwise
-**
-*******************************************************************************/
-NFCSTATUS EXTNS_MfcSetReadOnly (uint8_t *key, uint8_t len)
-{
-    NFCSTATUS status = NFCSTATUS_SUCCESS;
-
-    phLibNfc_Message_t msg;
-
-    msg.eMsgType = PH_NXPEXTNS_MIFARE_READ_ONLY;
-    msg.pMsgData = key;
-    msg.Size = len;
-
-    status = phNxpExtns_SendMsg (&msg);
-    if (NFCSTATUS_SUCCESS != status)
-    {
-        NXPLOG_EXTNS_E ("Error Sending msg to Extension Thread");
-    }
-
-    return status;
-}
-
-/*******************************************************************************
-**
-** Function         EXTNS_MfcWriteNDef
-**
-** Description      Writes NDEF data to Mifare Classic Tag.
-**
-**                  When the entire message has been written, or if an error
-**                  occurs, the app will be notified with NFA_WRITE_CPLT_EVT.
-**
-**                  p_data needs to be persistent until NFA_WRITE_CPLT_EVT
-**
-** Returns:
-**                  NFCSTATUS_SUCCESS if successfully initiated
-**                  NFCSTATUS_FAILED otherwise
-**
-*******************************************************************************/
-NFCSTATUS EXTNS_MfcWriteNDef (uint8_t *p_data, uint32_t len)
-{
-    NFCSTATUS status = NFCSTATUS_SUCCESS;
-
-    phLibNfc_Message_t msg;
-
-    msg.eMsgType = PH_NXPEXTNS_MIFARE_WRITE_NDEF;
-    msg.pMsgData = p_data;
-    msg.Size = len;
-
-    status = phNxpExtns_SendMsg (&msg);
-    if (NFCSTATUS_SUCCESS != status)
-    {
-        NXPLOG_EXTNS_E ("Error Sending msg to Extension Thread");
-    }
-
-    return status;
-}
-
-/*****************************************************************************
-**
-** Function         EXTNS_MfcFormatTag
-**
-** Description      Formats Mifare Classic Tag.
-**
-**                  The NFA_RW_FORMAT_CPLT_EVT, status is used to
-**                  indicate if tag is successfully formated or not
-**
-** Returns
-**                  NFCSTATUS_SUCCESS if successfully initiated
-**                  NFCSTATUS_FAILED otherwise
-**
-*****************************************************************************/
-NFCSTATUS EXTNS_MfcFormatTag (uint8_t *key, uint8_t len)
-{
-    NFCSTATUS status = NFCSTATUS_SUCCESS;
-
-    phLibNfc_Message_t msg;
-
-    msg.eMsgType = PH_NXPEXTNS_MIFARE_FORMAT_NDEF;
-    msg.pMsgData = key;
-    msg.Size = len;
-
-    status = phNxpExtns_SendMsg (&msg);
-    if (NFCSTATUS_SUCCESS != status)
-    {
-        NXPLOG_EXTNS_E ("Error Sending msg to Extension Thread");
-    }
-
-    return status;
-}
-
-/*****************************************************************************
-**
-** Function         EXTNS_MfcDisconnect
-**
-** Description      Disconnects Mifare Classic Tag.
-**
-** Returns
-**                  NFCSTATUS_SUCCESS if successfully initiated
-**                  NFCSTATUS_FAILED otherwise
-**
-*****************************************************************************/
-NFCSTATUS EXTNS_MfcDisconnect (void)
-{
-    NFCSTATUS status = NFCSTATUS_SUCCESS;
-
-    phLibNfc_Message_t msg;
-
-    msg.eMsgType = PH_NXPEXTNS_DISCONNECT;
-    msg.pMsgData = NULL;
-    msg.Size = 0;
-
-    status = phNxpExtns_SendMsg (&msg);
-    if (NFCSTATUS_SUCCESS != status)
-    {
-        NXPLOG_EXTNS_E ("Error Sending msg to Extension Thread");
-    }
-
-    return status;
-}
-
-/*****************************************************************************
-**
-** Function         EXTNS_MfcActivated
-**
-** Description      Activates Mifare Classic Tag.
-**
-** Returns
-**                  NFCSTATUS_SUCCESS if successfully initiated
-**                  NFCSTATUS_FAILED otherwise
-**
-*****************************************************************************/
-NFCSTATUS EXTNS_MfcActivated (void)
-{
-    NFCSTATUS status = NFCSTATUS_SUCCESS;
-    phLibNfc_Message_t msg;
-
-    msg.eMsgType = PH_NXPEXTNS_ACTIVATED;
-    msg.pMsgData = NULL;
-    msg.Size = 0;
-
-    status = phNxpExtns_SendMsg (&msg);
-    if (NFCSTATUS_SUCCESS != status)
-    {
-        NXPLOG_EXTNS_E ("Error Sending msg to Extension Thread");
-    }
-
-    return status;
-}
-
-/*******************************************************************************
-**
-** Function         EXTNS_MfcTransceive
-**
-** Description      Sends raw frame to Mifare Classic Tag.
-**
-** Returns          NFCSTATUS_SUCCESS if successfully initiated
-**                  NFCSTATUS_FAILED otherwise
-**
-*******************************************************************************/
-NFCSTATUS EXTNS_MfcTransceive (uint8_t *p_data, uint32_t len)
-{
-    NFCSTATUS status = NFCSTATUS_SUCCESS;
-
-    phLibNfc_Message_t msg;
-
-    msg.eMsgType = PH_NXPEXTNS_MIFARE_TRANSCEIVE;
-    msg.pMsgData = p_data;
-    msg.Size = len;
-
-    status = phNxpExtns_SendMsg (&msg);
-    if (NFCSTATUS_SUCCESS != status)
-    {
-        NXPLOG_EXTNS_E ("Error Sending msg to Extension Thread");
-    }
-
-    return status;
-}
-
-/*******************************************************************************
-**
-** Function         EXTNS_MfcInit
-**
-** Description      This function is used to Init Mifare Classic Extns.
-**                  This function should be called when the tag detected is
-**                  Mifare Classic.
-**
-** Returns          NFCSTATUS_SUCCESS
-**
-*******************************************************************************/
-NFCSTATUS EXTNS_MfcInit (tNFA_ACTIVATED activationData)
-{
-    tNFC_ACTIVATE_DEVT rfDetail = activationData.activate_ntf;
-
-    NdefMap->psRemoteDevInfo->RemoteDevInfo.Iso14443A_Info.Sak     = rfDetail.rf_tech_param.param.pa.sel_rsp;
-    NdefMap->psRemoteDevInfo->RemoteDevInfo.Iso14443A_Info.AtqA [0] = rfDetail.rf_tech_param.param.pa.sens_res[0];
-    NdefMap->psRemoteDevInfo->RemoteDevInfo.Iso14443A_Info.AtqA [1] = rfDetail.rf_tech_param.param.pa.sens_res[1];
-
-    return NFCSTATUS_SUCCESS;
-}
-
-/*******************************************************************************
-**
-** Function         phNxpExtns_ProcessSysMessage
-**
-** Description      Internal function to route the request from JNI and Callback
-**                  from NFA_SendRawFrame to right function
-**
-** Returns          NFCSTATUS_SUCCESS if valid request
-**                  NFCSTATUS_FAILED otherwise
-**
-*******************************************************************************/
-static NFCSTATUS phNxpExtns_ProcessSysMessage (phLibNfc_Message_t *msg)
-{
-    NFCSTATUS status = NFCSTATUS_SUCCESS;
-
-    if (gphNxpExtns_Context.Extns_status == EXTNS_STATUS_CLOSE)
-    {
-        return NFCSTATUS_FAILED;
-    }
-
-    switch (msg->eMsgType)
-    {
-        case PH_NXPEXTNS_RX_DATA:
-            status = Mfc_RecvPacket (msg->pMsgData, msg->Size);
-            break;
-
-        case PH_NXPEXTNS_MIFARE_CHECK_NDEF:
-            pthread_mutex_init (&gAuthCmdBuf.syncmutex, NULL);
-            pthread_mutex_lock (&gAuthCmdBuf.syncmutex);
-            status = Mfc_CheckNdef ();
-            pthread_mutex_unlock (&gAuthCmdBuf.syncmutex);
-            pthread_mutex_destroy (&gAuthCmdBuf.syncmutex);
-            break;
-
-        case PH_NXPEXTNS_MIFARE_READ_NDEF:
-            status = Mfc_ReadNdef ();
-            break;
-
-        case PH_NXPEXTNS_MIFARE_WRITE_NDEF:
-            status = Mfc_WriteNdef (msg->pMsgData, msg->Size);
-            break;
-
-        case PH_NXPEXTNS_MIFARE_FORMAT_NDEF:
-            status = Mfc_FormatNdef (msg->pMsgData, msg->Size);
-            break;
-
-        case PH_NXPEXTNS_DISCONNECT:
-            Mfc_DeactivateCbackSelect ();
-            break;
-
-        case PH_NXPEXTNS_ACTIVATED:
-            Mfc_ActivateCback ();
-            break;
-
-        case PH_NXPEXTNS_MIFARE_TRANSCEIVE:
-            status = Mfc_Transceive (msg->pMsgData, msg->Size);
-            break;
-
-        case PH_NXPEXTNS_MIFARE_READ_ONLY:
-            status = Mfc_SetReadOnly (msg->pMsgData, msg->Size);
-            break;
-        case PH_NXPEXTNS_MIFARE_PRESENCE_CHECK:
-            pthread_mutex_init (&gAuthCmdBuf.syncmutex, NULL);
-            pthread_mutex_lock (&gAuthCmdBuf.syncmutex);
-            status = Mfc_PresenceCheck ();
-            pthread_mutex_unlock (&gAuthCmdBuf.syncmutex);
-            pthread_mutex_destroy (&gAuthCmdBuf.syncmutex);
-            break;
-        default:
-            status = NFCSTATUS_FAILED;
-            NXPLOG_EXTNS_E ("Illegal Command for Extension");
-            break;
-        }
-
-    return status;
-}
-
-/*******************************************************************************
-**
-** Function         phNxpExtns_SendMsg
-**
-** Description      unlocks phNxpExtns_ProcessSysMessage with a valid message
-**
-** Returns          NFCSTATUS_SUCCESS if successfully initiated
-**                  NFCSTATUS_FAILED otherwise
-**
-*******************************************************************************/
-static NFCSTATUS phNxpExtns_SendMsg (phLibNfc_Message_t *sysmsg)
-{
-    NFCSTATUS status = NFCSTATUS_SUCCESS;
-
-    status = phNxpExtns_ProcessSysMessage (sysmsg);
-
-    return status;
-}
-
-/*******************************************************************************
-**
-** Function         EXTNS_MfcRegisterNDefTypeHandler
-**
-** Description      This function allows the applications to register for
-**                  specific types of NDEF records.
-**
-**                  For records types which were not registered, the record will
-**                  be sent to the default handler.
-**
-** Returns          NFCSTATUS_SUCCESS
-**
-*******************************************************************************/
-NFCSTATUS EXTNS_MfcRegisterNDefTypeHandler (tNFA_NDEF_CBACK *ndefHandlerCallback)
-{
-
-    NFCSTATUS status = NFCSTATUS_FAILED;
-    if (NULL != ndefHandlerCallback)
-    {
-        gphNxpExtns_Context.p_ndef_cback = ndefHandlerCallback;
-        status = NFCSTATUS_SUCCESS;
-    }
-
-    return status;
-}
-
-/*******************************************************************************
-**                     Synchronizing Functions                                **
-**            Synchronizes Callback in JNI and MFC Extns                      **
-*******************************************************************************/
-
-bool_t EXTNS_GetConnectFlag (void)
-{
-    return (gphNxpExtns_Context.ExtnsConnect);
-
-}
-void EXTNS_SetConnectFlag (bool_t flagval)
-{
-    gphNxpExtns_Context.ExtnsConnect = flagval;
-
-}
-bool_t EXTNS_GetDeactivateFlag(void)
-{
-   return (gphNxpExtns_Context.ExtnsDeactivate);
-
-}
-void EXTNS_SetDeactivateFlag (bool_t flagval)
-{
-    gphNxpExtns_Context.ExtnsDeactivate = flagval;
-
-}
-bool_t EXTNS_GetCallBackFlag(void)
-{
-   return (gphNxpExtns_Context.ExtnsCallBack);
-
-}
-void EXTNS_SetCallBackFlag (bool_t flagval)
-{
-    gphNxpExtns_Context.ExtnsCallBack = flagval;
-
-}
-NFCSTATUS EXTNS_GetPresenceCheckStatus (void)
-{
-    struct timespec ts;
-
-    clock_gettime (CLOCK_REALTIME, &ts);
-    ts.tv_sec += 0;
-    ts.tv_nsec += 100*1000*1000; // 100 milliseconds
-    if (ts.tv_nsec >= 1000 * 1000 * 1000)
-    {
-        ts.tv_sec += 1;
-        ts.tv_nsec = ts.tv_nsec - (1000 * 1000 * 1000);
-    }
-
-    if (sem_timedwait (&gAuthCmdBuf.semPresenceCheck, &ts))
-    {
-        ALOGE("%s: failed to wait (errno=%d)", __func__, errno);
-        sem_destroy (&gAuthCmdBuf.semPresenceCheck);
-        gAuthCmdBuf.auth_sent = false;
-        return NFCSTATUS_FAILED;
-    }
-    if (sem_destroy (&gAuthCmdBuf.semPresenceCheck))
-    {
-        ALOGE("%s: Failed to destroy check Presence semaphore (errno=%d)", __func__, errno);
-    }
-    return gAuthCmdBuf.status;
-}
-
-void MfcPresenceCheckResult (NFCSTATUS status)
-{
-    gAuthCmdBuf.status = status;
-    EXTNS_SetCallBackFlag (true);
-    sem_post (&gAuthCmdBuf.semPresenceCheck);
-}
-void MfcResetPresenceCheckStatus (void)
-{
-    gAuthCmdBuf.auth_sent = false;
-}
-/*******************************************************************************
-**
-** Function         EXTNS_CheckMfcResponse
-**
-** Description      This function is called from JNI Transceive for Mifare
-**                  Classic Tag status interpretation and to send the required
-**                  status to application
-**
-** Returns          NFCSTATUS_SUCCESS
-**                  NFCSTATUS_FAILED
-**
-*******************************************************************************/
-NFCSTATUS EXTNS_CheckMfcResponse (uint8_t** sTransceiveData, uint32_t *sTransceiveDataLen)
-{
-    NFCSTATUS status = NFCSTATUS_SUCCESS;
-
-    if (*sTransceiveDataLen == 3)
-    {
-        if((*sTransceiveData) [0] == 0x10 && (*sTransceiveData) [1] != 0x0A)
-        {
-            NXPLOG_EXTNS_E ("Mifare Error in payload response");
-            *sTransceiveDataLen = 0x1;
-            *sTransceiveData += 1;
-            return NFCSTATUS_FAILED;
-        }
-    }
-    if ((*sTransceiveData) [0] == 0x40)
-    {
-        *sTransceiveData += 1;
-        *sTransceiveDataLen = 0x01;
-        if((*sTransceiveData) [0] == 0x03)
-        {
-            *sTransceiveDataLen = 0x00;
-            status = NFCSTATUS_FAILED;
-        }
-    }
-    else if ((*sTransceiveData) [0] == 0x10)
-    {
-        *sTransceiveData += 1;
-        *sTransceiveDataLen = 0x10;
-    }
-
-    return status;
-}
diff --git a/nci/jni/extns/pn54x/src/phNxpExtns.cpp b/nci/jni/extns/pn54x/src/phNxpExtns.cpp
new file mode 100644
index 00000000..3b569a9c
--- /dev/null
+++ b/nci/jni/extns/pn54x/src/phNxpExtns.cpp
@@ -0,0 +1,631 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/time.h>
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
+//#include <phNxpConfig.h>
+#include <phNxpExtns_MifareStd.h>
+#include <phNxpLog.h>
+
+using android::base::StringPrintf;
+
+extern phNxpExtns_Context_t gphNxpExtns_Context;
+extern phFriNfc_NdefMap_t* NdefMap;
+extern phNci_mfc_auth_cmd_t gAuthCmdBuf;
+
+static NFCSTATUS phNxpExtns_ProcessSysMessage(phLibNfc_Message_t* msg);
+static NFCSTATUS phNxpExtns_SendMsg(phLibNfc_Message_t* sysmsg);
+
+/*******************************************************************************
+**
+** Function         EXTNS_Init
+**
+** Description      This function Initializes Mifare Classic Extns. Allocates
+**                  required memory and initializes the Mifare Classic Vars
+**
+** Returns          NFCSTATUS_SUCCESS if successfully initialized
+**                  NFCSTATUS_FAILED otherwise
+**
+*******************************************************************************/
+NFCSTATUS EXTNS_Init(tNFA_DM_CBACK* p_nfa_dm_cback,
+                     tNFA_CONN_CBACK* p_nfa_conn_cback) {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+
+  /* Initialize Log level */
+  phNxpLog_InitializeLogLevel();
+
+  /* Validate parameters */
+  if ((!p_nfa_dm_cback) || (!p_nfa_conn_cback)) {
+    LOG(ERROR) << StringPrintf("EXTNS_Init(): error null callback");
+    goto clean_and_return;
+  }
+
+  gphNxpExtns_Context.p_dm_cback = p_nfa_dm_cback;
+  gphNxpExtns_Context.p_conn_cback = p_nfa_conn_cback;
+
+  if (NFCSTATUS_SUCCESS != phNxpExtns_MfcModuleInit()) {
+    LOG(ERROR) << StringPrintf("ERROR: MFC Module Init Failed");
+    goto clean_and_return;
+  }
+  gphNxpExtns_Context.Extns_status = EXTNS_STATUS_OPEN;
+
+  status = NFCSTATUS_SUCCESS;
+  return status;
+
+clean_and_return:
+  gphNxpExtns_Context.Extns_status = EXTNS_STATUS_CLOSE;
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         EXTNS_Close
+**
+** Description      This function de-initializes Mifare Classic Extns.
+**                  De-allocates memory
+**
+** Returns          None
+**
+*******************************************************************************/
+void EXTNS_Close(void) {
+  gphNxpExtns_Context.Extns_status = EXTNS_STATUS_CLOSE;
+  phNxpExtns_MfcModuleDeInit();
+  return;
+}
+
+/*******************************************************************************
+**
+** Function         EXTNS_MfcCallBack
+**
+** Description      Decodes Mifare Classic Tag Response
+**                  This is called from NFA_SendRaw Callback
+**
+** Returns:
+**                  NFCSTATUS_SUCCESS if successfully initiated
+**                  NFCSTATUS_FAILED otherwise
+**
+*******************************************************************************/
+NFCSTATUS EXTNS_MfcCallBack(uint8_t* buf, uint32_t buflen) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+
+  phLibNfc_Message_t msg;
+
+  msg.eMsgType = PH_NXPEXTNS_RX_DATA;
+  msg.pMsgData = buf;
+  msg.Size = buflen;
+
+  status = phNxpExtns_SendMsg(&msg);
+  if (NFCSTATUS_SUCCESS != status) {
+    LOG(ERROR) << StringPrintf("Error Sending msg to Extension Thread");
+  }
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         EXTNS_MfcCheckNDef
+**
+** Description      Performs NDEF detection for Mifare Classic Tag
+**
+**                  Upon successful completion of NDEF detection, a
+**                  NFA_NDEF_DETECT_EVT will be sent, to notify the application
+**                  of the NDEF attributes (NDEF total memory size, current
+**                  size, etc.).
+**
+** Returns:
+**                  NFCSTATUS_SUCCESS if successfully initiated
+**                  NFCSTATUS_FAILED otherwise
+**
+*******************************************************************************/
+NFCSTATUS EXTNS_MfcCheckNDef(void) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  phLibNfc_Message_t msg;
+
+  msg.eMsgType = PH_NXPEXTNS_MIFARE_CHECK_NDEF;
+  msg.pMsgData = NULL;
+  msg.Size = 0;
+
+  status = phNxpExtns_SendMsg(&msg);
+  if (NFCSTATUS_SUCCESS != status) {
+    LOG(ERROR) << StringPrintf("Error Sending msg to Extension Thread");
+  }
+
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         EXTNS_MfcReadNDef
+**
+** Description      Reads NDEF message from Mifare Classic Tag.
+**
+**                  Upon receiving the NDEF message, the message will be sent to
+**                  the handler registered with
+*EXTNS_MfcRegisterNDefTypeHandler.
+**
+** Returns:
+**                  NFCSTATUS_SUCCESS if successfully initiated
+**                  NFCSTATUS_FAILED otherwise
+**
+*******************************************************************************/
+NFCSTATUS EXTNS_MfcReadNDef(void) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+
+  phLibNfc_Message_t msg;
+
+  msg.eMsgType = PH_NXPEXTNS_MIFARE_READ_NDEF;
+  msg.pMsgData = NULL;
+  msg.Size = 0;
+
+  status = phNxpExtns_SendMsg(&msg);
+  if (NFCSTATUS_SUCCESS != status) {
+    LOG(ERROR) << StringPrintf("Error Sending msg to Extension Thread");
+  }
+
+  return status;
+}
+/*******************************************************************************
+**
+** Function         EXTNS_MfcPresenceCheck
+**
+** Description      Do the check presence for Mifare Classic Tag.
+**
+**
+** Returns:
+**                  NFCSTATUS_SUCCESS if successfully initiated
+**                  NFCSTATUS_FAILED otherwise
+**
+*******************************************************************************/
+NFCSTATUS EXTNS_MfcPresenceCheck(void) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+
+  phLibNfc_Message_t msg;
+
+  msg.eMsgType = PH_NXPEXTNS_MIFARE_PRESENCE_CHECK;
+  msg.pMsgData = NULL;
+  msg.Size = 0;
+
+  gAuthCmdBuf.status = NFCSTATUS_FAILED;
+  if (sem_init(&gAuthCmdBuf.semPresenceCheck, 0, 0) == -1) {
+    LOG(ERROR) << StringPrintf("%s: semaphore creation failed (errno=%d)",
+                               __func__, errno);
+    return NFCSTATUS_FAILED;
+  }
+
+  status = phNxpExtns_SendMsg(&msg);
+  if (NFCSTATUS_SUCCESS != status) {
+    LOG(ERROR) << StringPrintf("Error Sending msg to Extension Thread");
+    sem_destroy(&gAuthCmdBuf.semPresenceCheck);
+  }
+
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function        EXTNS_MfcSetReadOnly
+**
+**
+** Description:
+**      Sets tag as read only.
+**
+**      When tag is set as read only, or if an error occurs, the app will be
+**      notified with NFA_SET_TAG_RO_EVT.
+**
+** Returns:
+**                  NFCSTATUS_SUCCESS if successfully initiated
+**                  NFCSTATUS_FAILED otherwise
+**
+*******************************************************************************/
+NFCSTATUS EXTNS_MfcSetReadOnly(uint8_t* key, uint8_t len) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+
+  phLibNfc_Message_t msg;
+
+  msg.eMsgType = PH_NXPEXTNS_MIFARE_READ_ONLY;
+  msg.pMsgData = key;
+  msg.Size = len;
+
+  status = phNxpExtns_SendMsg(&msg);
+  if (NFCSTATUS_SUCCESS != status) {
+    LOG(ERROR) << StringPrintf("Error Sending msg to Extension Thread");
+  }
+
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         EXTNS_MfcWriteNDef
+**
+** Description      Writes NDEF data to Mifare Classic Tag.
+**
+**                  When the entire message has been written, or if an error
+**                  occurs, the app will be notified with NFA_WRITE_CPLT_EVT.
+**
+**                  p_data needs to be persistent until NFA_WRITE_CPLT_EVT
+**
+** Returns:
+**                  NFCSTATUS_SUCCESS if successfully initiated
+**                  NFCSTATUS_FAILED otherwise
+**
+*******************************************************************************/
+NFCSTATUS EXTNS_MfcWriteNDef(uint8_t* p_data, uint32_t len) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+
+  phLibNfc_Message_t msg;
+
+  msg.eMsgType = PH_NXPEXTNS_MIFARE_WRITE_NDEF;
+  msg.pMsgData = p_data;
+  msg.Size = len;
+
+  status = phNxpExtns_SendMsg(&msg);
+  if (NFCSTATUS_SUCCESS != status) {
+    LOG(ERROR) << StringPrintf("Error Sending msg to Extension Thread");
+  }
+
+  return status;
+}
+
+/*****************************************************************************
+**
+** Function         EXTNS_MfcFormatTag
+**
+** Description      Formats Mifare Classic Tag.
+**
+**                  The NFA_RW_FORMAT_CPLT_EVT, status is used to
+**                  indicate if tag is successfully formated or not
+**
+** Returns
+**                  NFCSTATUS_SUCCESS if successfully initiated
+**                  NFCSTATUS_FAILED otherwise
+**
+*****************************************************************************/
+NFCSTATUS EXTNS_MfcFormatTag(uint8_t* key, uint8_t len) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+
+  phLibNfc_Message_t msg;
+
+  msg.eMsgType = PH_NXPEXTNS_MIFARE_FORMAT_NDEF;
+  msg.pMsgData = key;
+  msg.Size = len;
+
+  status = phNxpExtns_SendMsg(&msg);
+  if (NFCSTATUS_SUCCESS != status) {
+    LOG(ERROR) << StringPrintf("Error Sending msg to Extension Thread");
+  }
+
+  return status;
+}
+
+/*****************************************************************************
+**
+** Function         EXTNS_MfcDisconnect
+**
+** Description      Disconnects Mifare Classic Tag.
+**
+** Returns
+**                  NFCSTATUS_SUCCESS if successfully initiated
+**                  NFCSTATUS_FAILED otherwise
+**
+*****************************************************************************/
+NFCSTATUS EXTNS_MfcDisconnect(void) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+
+  phLibNfc_Message_t msg;
+
+  msg.eMsgType = PH_NXPEXTNS_DISCONNECT;
+  msg.pMsgData = NULL;
+  msg.Size = 0;
+
+  status = phNxpExtns_SendMsg(&msg);
+  if (NFCSTATUS_SUCCESS != status) {
+    LOG(ERROR) << StringPrintf("Error Sending msg to Extension Thread");
+  }
+
+  return status;
+}
+
+/*****************************************************************************
+**
+** Function         EXTNS_MfcActivated
+**
+** Description      Activates Mifare Classic Tag.
+**
+** Returns
+**                  NFCSTATUS_SUCCESS if successfully initiated
+**                  NFCSTATUS_FAILED otherwise
+**
+*****************************************************************************/
+NFCSTATUS EXTNS_MfcActivated(void) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+  phLibNfc_Message_t msg;
+
+  msg.eMsgType = PH_NXPEXTNS_ACTIVATED;
+  msg.pMsgData = NULL;
+  msg.Size = 0;
+
+  status = phNxpExtns_SendMsg(&msg);
+  if (NFCSTATUS_SUCCESS != status) {
+    LOG(ERROR) << StringPrintf("Error Sending msg to Extension Thread");
+  }
+
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         EXTNS_MfcTransceive
+**
+** Description      Sends raw frame to Mifare Classic Tag.
+**
+** Returns          NFCSTATUS_SUCCESS if successfully initiated
+**                  NFCSTATUS_FAILED otherwise
+**
+*******************************************************************************/
+NFCSTATUS EXTNS_MfcTransceive(uint8_t* p_data, uint32_t len) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+
+  phLibNfc_Message_t msg;
+
+  msg.eMsgType = PH_NXPEXTNS_MIFARE_TRANSCEIVE;
+  msg.pMsgData = p_data;
+  msg.Size = len;
+
+  status = phNxpExtns_SendMsg(&msg);
+  if (NFCSTATUS_SUCCESS != status) {
+    LOG(ERROR) << StringPrintf("Error Sending msg to Extension Thread");
+  }
+
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         EXTNS_MfcInit
+**
+** Description      This function is used to Init Mifare Classic Extns.
+**                  This function should be called when the tag detected is
+**                  Mifare Classic.
+**
+** Returns          NFCSTATUS_SUCCESS
+**
+*******************************************************************************/
+NFCSTATUS EXTNS_MfcInit(tNFA_ACTIVATED activationData) {
+  tNFC_ACTIVATE_DEVT rfDetail = activationData.activate_ntf;
+
+  NdefMap->psRemoteDevInfo->RemoteDevInfo.Iso14443A_Info.Sak =
+      rfDetail.rf_tech_param.param.pa.sel_rsp;
+  NdefMap->psRemoteDevInfo->RemoteDevInfo.Iso14443A_Info.AtqA[0] =
+      rfDetail.rf_tech_param.param.pa.sens_res[0];
+  NdefMap->psRemoteDevInfo->RemoteDevInfo.Iso14443A_Info.AtqA[1] =
+      rfDetail.rf_tech_param.param.pa.sens_res[1];
+
+  return NFCSTATUS_SUCCESS;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpExtns_ProcessSysMessage
+**
+** Description      Internal function to route the request from JNI and Callback
+**                  from NFA_SendRawFrame to right function
+**
+** Returns          NFCSTATUS_SUCCESS if valid request
+**                  NFCSTATUS_FAILED otherwise
+**
+*******************************************************************************/
+static NFCSTATUS phNxpExtns_ProcessSysMessage(phLibNfc_Message_t* msg) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+
+  if (gphNxpExtns_Context.Extns_status == EXTNS_STATUS_CLOSE) {
+    return NFCSTATUS_FAILED;
+  }
+
+  switch (msg->eMsgType) {
+    case PH_NXPEXTNS_RX_DATA:
+      status = Mfc_RecvPacket((uint8_t*)msg->pMsgData, msg->Size);
+      break;
+
+    case PH_NXPEXTNS_MIFARE_CHECK_NDEF:
+      pthread_mutex_init(&gAuthCmdBuf.syncmutex, NULL);
+      pthread_mutex_lock(&gAuthCmdBuf.syncmutex);
+      status = Mfc_CheckNdef();
+      pthread_mutex_unlock(&gAuthCmdBuf.syncmutex);
+      pthread_mutex_destroy(&gAuthCmdBuf.syncmutex);
+      break;
+
+    case PH_NXPEXTNS_MIFARE_READ_NDEF:
+      status = Mfc_ReadNdef();
+      break;
+
+    case PH_NXPEXTNS_MIFARE_WRITE_NDEF:
+      status = Mfc_WriteNdef((uint8_t*)msg->pMsgData, msg->Size);
+      break;
+
+    case PH_NXPEXTNS_MIFARE_FORMAT_NDEF:
+      status = Mfc_FormatNdef((uint8_t*)msg->pMsgData, msg->Size);
+      break;
+
+    case PH_NXPEXTNS_DISCONNECT:
+      Mfc_DeactivateCbackSelect();
+      break;
+
+    case PH_NXPEXTNS_ACTIVATED:
+      Mfc_ActivateCback();
+      break;
+
+    case PH_NXPEXTNS_MIFARE_TRANSCEIVE:
+      status = Mfc_Transceive((uint8_t*)msg->pMsgData, msg->Size);
+      break;
+
+    case PH_NXPEXTNS_MIFARE_READ_ONLY:
+      status = Mfc_SetReadOnly((uint8_t*)msg->pMsgData, msg->Size);
+      break;
+    case PH_NXPEXTNS_MIFARE_PRESENCE_CHECK:
+      pthread_mutex_init(&gAuthCmdBuf.syncmutex, NULL);
+      pthread_mutex_lock(&gAuthCmdBuf.syncmutex);
+      status = Mfc_PresenceCheck();
+      pthread_mutex_unlock(&gAuthCmdBuf.syncmutex);
+      pthread_mutex_destroy(&gAuthCmdBuf.syncmutex);
+      break;
+    default:
+      status = NFCSTATUS_FAILED;
+      LOG(ERROR) << StringPrintf("Illegal Command for Extension");
+      break;
+  }
+
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         phNxpExtns_SendMsg
+**
+** Description      unlocks phNxpExtns_ProcessSysMessage with a valid message
+**
+** Returns          NFCSTATUS_SUCCESS if successfully initiated
+**                  NFCSTATUS_FAILED otherwise
+**
+*******************************************************************************/
+static NFCSTATUS phNxpExtns_SendMsg(phLibNfc_Message_t* sysmsg) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+
+  status = phNxpExtns_ProcessSysMessage(sysmsg);
+
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         EXTNS_MfcRegisterNDefTypeHandler
+**
+** Description      This function allows the applications to register for
+**                  specific types of NDEF records.
+**
+**                  For records types which were not registered, the record will
+**                  be sent to the default handler.
+**
+** Returns          NFCSTATUS_SUCCESS
+**
+*******************************************************************************/
+NFCSTATUS EXTNS_MfcRegisterNDefTypeHandler(
+    tNFA_NDEF_CBACK* ndefHandlerCallback) {
+  NFCSTATUS status = NFCSTATUS_FAILED;
+  if (NULL != ndefHandlerCallback) {
+    gphNxpExtns_Context.p_ndef_cback = ndefHandlerCallback;
+    status = NFCSTATUS_SUCCESS;
+  }
+
+  return status;
+}
+
+/*******************************************************************************
+**                     Synchronizing Functions                                **
+**            Synchronizes Callback in JNI and MFC Extns                      **
+*******************************************************************************/
+
+bool_t EXTNS_GetConnectFlag(void) { return (gphNxpExtns_Context.ExtnsConnect); }
+void EXTNS_SetConnectFlag(bool_t flagval) {
+  gphNxpExtns_Context.ExtnsConnect = flagval;
+}
+bool_t EXTNS_GetDeactivateFlag(void) {
+  return (gphNxpExtns_Context.ExtnsDeactivate);
+}
+void EXTNS_SetDeactivateFlag(bool_t flagval) {
+  gphNxpExtns_Context.ExtnsDeactivate = flagval;
+}
+bool_t EXTNS_GetCallBackFlag(void) {
+  return (gphNxpExtns_Context.ExtnsCallBack);
+}
+void EXTNS_SetCallBackFlag(bool_t flagval) {
+  gphNxpExtns_Context.ExtnsCallBack = flagval;
+}
+NFCSTATUS EXTNS_GetPresenceCheckStatus(void) {
+  struct timespec ts;
+
+  clock_gettime(CLOCK_REALTIME, &ts);
+  ts.tv_sec += 0;
+  ts.tv_nsec += 100 * 1000 * 1000;  // 100 milliseconds
+  if (ts.tv_nsec >= 1000 * 1000 * 1000) {
+    ts.tv_sec += 1;
+    ts.tv_nsec = ts.tv_nsec - (1000 * 1000 * 1000);
+  }
+
+  if (sem_timedwait(&gAuthCmdBuf.semPresenceCheck, &ts)) {
+    LOG(ERROR) << StringPrintf("%s: failed to wait (errno=%d)", __func__,
+                               errno);
+    sem_destroy(&gAuthCmdBuf.semPresenceCheck);
+    gAuthCmdBuf.auth_sent = false;
+    return NFCSTATUS_FAILED;
+  }
+  if (sem_destroy(&gAuthCmdBuf.semPresenceCheck)) {
+    LOG(ERROR) << StringPrintf(
+        "%s: Failed to destroy check Presence semaphore (errno=%d)", __func__,
+        errno);
+  }
+  return gAuthCmdBuf.status;
+}
+
+void MfcPresenceCheckResult(NFCSTATUS status) {
+  gAuthCmdBuf.status = status;
+  EXTNS_SetCallBackFlag(true);
+  sem_post(&gAuthCmdBuf.semPresenceCheck);
+}
+void MfcResetPresenceCheckStatus(void) { gAuthCmdBuf.auth_sent = false; }
+/*******************************************************************************
+**
+** Function         EXTNS_CheckMfcResponse
+**
+** Description      This function is called from JNI Transceive for Mifare
+**                  Classic Tag status interpretation and to send the required
+**                  status to application
+**
+** Returns          NFCSTATUS_SUCCESS
+**                  NFCSTATUS_FAILED
+**
+*******************************************************************************/
+NFCSTATUS EXTNS_CheckMfcResponse(uint8_t** sTransceiveData,
+                                 uint32_t* sTransceiveDataLen) {
+  NFCSTATUS status = NFCSTATUS_SUCCESS;
+
+  if (*sTransceiveDataLen == 3) {
+    if ((*sTransceiveData)[0] == 0x10 && (*sTransceiveData)[1] != 0x0A) {
+      LOG(ERROR) << StringPrintf("Mifare Error in payload response");
+      *sTransceiveDataLen = 0x1;
+      *sTransceiveData += 1;
+      return NFCSTATUS_FAILED;
+    }
+  }
+  if ((*sTransceiveData)[0] == 0x40) {
+    *sTransceiveData += 1;
+    *sTransceiveDataLen = 0x01;
+    if ((*sTransceiveData)[0] == 0x03) {
+      *sTransceiveDataLen = 0x00;
+      status = NFCSTATUS_FAILED;
+    }
+  } else if ((*sTransceiveData)[0] == 0x10) {
+    *sTransceiveData += 1;
+    *sTransceiveDataLen = 0x10;
+  }
+
+  return status;
+}
diff --git a/nci/jni/extns/pn54x/src/utils/phNxpConfig.cpp b/nci/jni/extns/pn54x/src/utils/phNxpConfig.cpp
deleted file mode 100644
index 84e6ad1a..00000000
--- a/nci/jni/extns/pn54x/src/utils/phNxpConfig.cpp
+++ /dev/null
@@ -1,1552 +0,0 @@
-/******************************************************************************
- *  Copyright (c) 2016, The Linux Foundation. All rights reserved.
- *  Not a Contribution.
- *
- *  Copyright (C) 2011-2012 Broadcom Corporation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at:
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-/******************************************************************************
- *
- *  The original Work has been changed by NXP Semiconductors.
- *
- *  Copyright (C) 2015 The Android Open Source Project
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
- /**
-  * @file phNxpConfig.cpp
-  * @date 24 Aug 2016
-  * @brief File containing code for dynamic selection of config files based on target.
-  *
-  * The target device has to be configured with some primary setting while booting.So a
-  * config file will be picked while the target is booted. Here based on the target device
-  * a configuration file will be selected dynamically and the device will be configured.
-  */
-
-#define LOG_TAG "pn54x"
-
-#include <phNxpConfig.h>
-#include <stdio.h>
-#include <string>
-#include <vector>
-#include <list>
-#include <sys/stat.h>
-#include <stdlib.h>
-
-#include <phNxpLog.h>
-#include <cutils/log.h>
-#include <cutils/properties.h>
-#include <errno.h>
-
-#if GENERIC_TARGET
-const char alternative_config_path[] = "/data/nfc/";
-#else
-const char alternative_config_path[] = "";
-#endif
-
-#if 1
-const char* transport_config_paths[] = {"/odm/etc/", "/vendor/etc/", "/etc/"};
-#if(NXP_EXTNS == TRUE)
-const char transit_config_path[] = "/data/nfc/";
-#endif
-#else
-const char* transport_config_paths[] = {"res/"};
-#endif
-const int transport_config_path_size =
-        (sizeof(transport_config_paths) / sizeof(transport_config_paths[0]));
-
-/**
- *  @brief defines the different config files used.
- */
-
-#define config_name             "libnfc-nxp.conf"
-#if(NXP_EXTNS == TRUE)
-#define extra_config_base       "libnfc-"
-#else
-#define extra_config_base       "libnfc-nxp-"
-#endif
-
-#define extra_config_ext        ".conf"
-#define IsStringValue           0x80000000
-
-const char config_timestamp_path[]    = "/data/nfc/libnfc-nxpConfigState.bin";
-const char default_nxp_config_path[]  = "/etc/libnfc-nxp.conf";
-
-/**
- *  @brief target platform ID values.
- */
-
-typedef enum
-{
-  CONFIG_GENERIC                         = 0x00,
-  MTP_TYPE_DEFAULT                       = 0x01, /**< default MTP config. DC DC ON */
-  QRD_TYPE_DEFAULT                       = 0x02, /**< default QRD config DC DC OFF */
-  MTP_TYPE_1                             = 0x03, /**< mtp config type1 : newer chip */
-  MTP_TYPE_2                             = 0x04, /**< mtp config type2 TBD */
-  QRD_TYPE_1                             = 0x05, /**< qrd config type1 DC DC ON*/
-  QRD_TYPE_2                             = 0x06, /**< qrd config type2  Newer chip */
-  MTP_TYPE_NQ3XX                         = 0x07, /**< qrd config : for NQ3XX chip */
-  QRD_TYPE_NQ3XX                         = 0x08, /**< qrd config : for NQ3XX chip */
-  MTP_TYPE_NQ4XX                         = 0x09, /**< mtp config : for NQ4XX chip */
-  QRD_TYPE_NQ4XX                         = 0x10, /**< qrd config : for NQ4XX chip */
-  DEFAULT_CONFIG                         = QRD_TYPE_DEFAULT, /**< default is qrd default config */
-  CONFIG_INVALID                         = 0xFF
-} CONFIGIDVALUE;
-
-/**
- *  @brief Defines the values for different types of targets.
- */
-
-typedef enum
-{
-  TARGET_GENERIC                       = 0x00, /**< new targets */
-  TARGET_MSM8952                       = 264, /**< 8952 target */
-  TARGET_MSM8976                       = 278, /**< 8976 target */
-  TARGET_MSM8937                       = 294, /**< 8937 target */
-  TARGET_MSM8953                       = 293, /**< 8953 target */
-  TARGET_MSM8996                       = 246, /**< 8996 target*/
-  TARGET_MSM8909                       = 245, /**< 8909w target */
-  TARGET_MSM8998                       = 292, /**< 8998 target */
-  TARGET_MSM8997                       = 306, /**< 8997 target */
-  TARGET_MSM8917                       = 303, /**< 8997 target */
-  TARGET_MSM8940                       = 313, /**< 8997 target */
-  TARGET_SDM660                        = 317, /**< SDM660 target */
-  TARGET_SDM670                        = 336, /**< SDM670 target */
-  TARGET_SDM710                        = 360, /**< SDM710 target */
-  TARGET_SDM630                        = 318, /**< SDM630 target */
-  TARGET_SDM632                        = 349, /**< SDM632 target */
-  TARGET_SDM439                        = 353, /**< SDM439 target */
-  TARGET_SDM429                        = 354, /**< SDM429 target */
-  TARGET_SDM450                        = 338, /**< SDM450 target */
-  TARGET_SDM845                        = 321, /**< SDM845 target */
-  TARGET_DEFAULT                       = TARGET_GENERIC, /**< new targets */
-  TARGET_INVALID                       = 0xFF
-} TARGETTYPE;
-
-using namespace::std;
-
-void findConfigFilePathFromTransportConfigPaths(const string& configName, string& filePath);
-
-class CNxpNfcParam : public string
-{
-public:
-    CNxpNfcParam ();
-    CNxpNfcParam (const char* name, const string& value);
-    CNxpNfcParam (const char* name, unsigned long value);
-    virtual ~CNxpNfcParam ();
-    unsigned long numValue () const {return m_numValue;}
-    const char* str_value () const {return m_str_value.c_str();}
-    size_t str_len () const {return m_str_value.length();}
-private:
-    string          m_str_value;
-    unsigned long   m_numValue;
-};
-
-class CNxpNfcConfig : public vector<const CNxpNfcParam*>
-{
-public:
-    virtual ~CNxpNfcConfig ();
-    static CNxpNfcConfig& GetInstance ();
-    friend void readOptionalConfig (const char* optional);
-    int checkTimestamp ();
-    int updateTimestamp ();
-
-    bool    getValue (const char* name, char* pValue, size_t len) const;
-    bool    getValue (const char* name, unsigned long& rValue) const;
-    bool    getValue (const char* name, unsigned short & rValue) const;
-    bool    getValue (const char* name, char* pValue, long len, long* readlen) const;
-    const CNxpNfcParam* find (const char* p_name) const;
-#if(NXP_EXTNS == TRUE)
-    void    readNxpTransitConfig(const char* fileName) const;
-#endif
-    void  clean ();
-private:
-    CNxpNfcConfig ();
-    bool    readConfig (const char* name, bool bResetContent);
-    int     file_exist (const char* filename);
-    int     getconfiguration_id (char * config_file);
-    void    moveFromList ();
-    void    moveToList ();
-    void    add (const CNxpNfcParam* pParam);
-#if(NXP_EXTNS == TRUE)
-    void    dump();
-    bool    isAllowed(const char* name);
-    string  mCurrentFile;
-#endif
-    list<const CNxpNfcParam*> m_list;
-    bool    mValidFile;
-    bool    mDynamConfig;
-    unsigned long m_timeStamp;
-
-    unsigned long state;
-
-    inline bool Is (unsigned long f) {return (state & f) == f;}
-    inline void Set (unsigned long f) {state |= f;}
-    inline void Reset (unsigned long f) {state &= ~f;}
-};
-
-/**
- * @brief This function reads the hardware information from the given path.
- *
- * This function receives the path and then reads the hardware information
- * from the file present in the given path. It reads the details like whether
- * it is QRD or MTP. It reads the data from that file and stores in buffer.
- * It also receives a count which tells the number of characters to be read
- * Finally the length of the buffer is returned.
- *
- * @param path The path where the file containing hardware details to be read.
- * @param buff The hardware details that is read from that path will be stored here.
- * @param count It represents the number of characters to be read from that file.
- * @return It returns the length of the buffer.
- */
-
-static int read_line_from_file(const char *path, char *buf, size_t count)
-{
-    char *fgets_ret = NULL;
-    FILE *fd = NULL;
-    int rv = 0;
-
-    // opens the file to read the HW_PLATFORM detail of the target
-    fd = fopen(path, "r");
-    if (fd == NULL)
-        return -1;
-
-    // stores the data that is read from the given path into buf
-    fgets_ret = fgets(buf, (int)count, fd);
-    if (NULL != fgets_ret)
-        rv = (int)strlen(buf);
-    else
-        rv = ferror(fd);
-
-    fclose(fd);
-    return rv;
-}
-
-/**
- * @brief This function gets the source information from the file.
- *
- * This function receives a buffer variable to store the read information
- * and also receives two different path. The hardware information may be
- * present in any one of the received path. So this function checks in
- * both the paths. This function internally uses read_line_from_file
- * function to read the check and read the hardware details in each path.
- *
- * @param buf hardware details that is read will be stored.
- * @param soc_node_path1 The first path where the file may be present.
- * @param soc_node_path2 The second path where the file may be present.
- * @return Returns the length of buffer.
- */
-
-static int get_soc_info(char *buf, const char *soc_node_path1,
-            const char *soc_node_path2)
-{
-    int ret = 0;
-
-    // checks whether the hw platform detail is present in this path
-    ret = read_line_from_file(soc_node_path1, buf, MAX_SOC_INFO_NAME_LEN);
-    if (ret < 0) {
-        // if the hw platform detail is not present in the former path it checks here
-        ret = read_line_from_file(soc_node_path2, buf, MAX_SOC_INFO_NAME_LEN);
-        if (ret < 0) {
-            ALOGE("getting socinfo(%s, %d) failed.\n", soc_node_path1, ret);
-            return ret;
-        }
-    }
-    if (ret && buf[ret - 1] == '\n')
-        buf[ret - 1] = '\0';
-    return ret;
-}
-
-/**
- * @brief finds the cofiguration id value for the particular target.
- *
- * This function reads the soc id detail and hardware platform detail
- * from the target device and generate a generic config file name.
- * If that config file is present then it will be used for configuring
- * that target.
- * If not then based on the target information a config file will be assigned.
- *
- * @param config_file The generic config file name will be stored.
- * @return it returns the config id for the target.
- */
-
-int CNxpNfcConfig::getconfiguration_id(char *config_file)
-{
-    int config_id = QRD_TYPE_DEFAULT;
-    char target_type[MAX_SOC_INFO_NAME_LEN] = {'\0'};
-    char soc_info[MAX_SOC_INFO_NAME_LEN] = {'\0'};
-    char nq_chipid[PROPERTY_VALUE_MAX] = {0};
-    char nq_fw_ver[PROPERTY_VALUE_MAX] = {0};
-    string strPath;
-    int rc = 0;
-    int idx = 0;
-
-    rc = get_soc_info(soc_info, SYSFS_SOCID_PATH1, SYSFS_SOCID_PATH2);
-    if (rc < 0) {
-        ALOGE("get_soc_info(SOC_ID) fail!\n");
-        return DEFAULT_CONFIG;
-    }
-    idx = atoi(soc_info);
-
-    rc = get_soc_info(target_type, SYSFS_HW_PLATFORM_PATH1, SYSFS_HW_PLATFORM_PATH2);
-    if (rc < 0) {
-        ALOGE("get_soc_info(HW_PLATFORM) fail!\n");
-        return DEFAULT_CONFIG;
-    }
-
-    rc = __system_property_get("vendor.qti.nfc.chipid", nq_chipid);
-    if (rc <= 0)
-        ALOGE("get vendor.qti.nfc.chipid fail, rc = %d\n", rc);
-    else
-        ALOGD("vendor.qti.nfc.chipid = %s\n", nq_chipid);
-
-    rc = __system_property_get("vendor.qti.nfc.fwver", nq_fw_ver);
-    if (rc <= 0)
-        ALOGE("get vendor.qti.nfc.fwver fail, rc = %d\n", rc);
-    else
-        ALOGD("vendor.qti.nfc.fwver = %s\n", nq_fw_ver);
-
-    // Converting the HW_PLATFORM detail that is read from target to lowercase
-    for (int i=0;target_type[i];i++)
-        target_type[i] = tolower(target_type[i]);
-
-    // generating a generic config file name based on the target details
-    snprintf(config_file, MAX_DATA_CONFIG_PATH_LEN, "libnfc-%s_%s.conf",
-        soc_info, target_type);
-
-    findConfigFilePathFromTransportConfigPaths(config_file, strPath);
-    if (file_exist(strPath.c_str()))
-        idx = 0;
-
-    if (DEBUG)
-        ALOGI("id:%d, config_file_name:%s\n", idx, config_file);
-
-    // if target is QRD platform then config id is assigned here
-    if (0 == strncmp(target_type, QRD_HW_PLATFORM, MAX_SOC_INFO_NAME_LEN)) {
-        switch (idx)
-        {
-        case TARGET_GENERIC:
-            config_id = CONFIG_GENERIC;
-            break;
-        case TARGET_MSM8952:
-        case TARGET_MSM8909:
-            config_id = QRD_TYPE_DEFAULT;
-            strlcpy(config_file, config_name_qrd, MAX_DATA_CONFIG_PATH_LEN);
-            break;
-        case TARGET_MSM8953:
-        case TARGET_MSM8937:
-        case TARGET_MSM8940:
-        case TARGET_MSM8917:
-        case TARGET_SDM632:
-        case TARGET_SDM439:
-        case TARGET_SDM429:
-        case TARGET_SDM450:
-            if ((!strncmp(nq_chipid, NQ220, PROPERTY_VALUE_MAX)) || (!strncmp(nq_chipid, NQ210, PROPERTY_VALUE_MAX))) {
-                // NQ210 or NQ220
-                config_id = QRD_TYPE_DEFAULT;
-                strlcpy(config_file, config_name_qrd, MAX_DATA_CONFIG_PATH_LEN);
-            } else if (!strncmp(nq_fw_ver, FW_MAJOR_NUM_NQ4xx, FW_MAJOR_NUM_LENGTH)) {
-                config_id = QRD_TYPE_NQ4XX;
-                strlcpy(config_file, config_name_qrd_NQ4XX, MAX_DATA_CONFIG_PATH_LEN);
-            } else {
-                config_id = QRD_TYPE_NQ3XX;
-                strlcpy(config_file, config_name_qrd_NQ3XX, MAX_DATA_CONFIG_PATH_LEN);
-            }
-            break;
-        case TARGET_MSM8976:
-        case TARGET_MSM8996:
-            config_id = QRD_TYPE_1;
-            strlcpy(config_file, config_name_qrd1, MAX_DATA_CONFIG_PATH_LEN);
-            break;
-        case TARGET_SDM845:
-        case TARGET_SDM670:
-        case TARGET_SDM710:
-            if (!strncmp(nq_fw_ver, FW_MAJOR_NUM_NQ4xx, FW_MAJOR_NUM_LENGTH)) {
-                config_id = QRD_TYPE_NQ4XX;
-                strlcpy(config_file, config_name_qrd_NQ4XX, MAX_DATA_CONFIG_PATH_LEN);
-            }
-            else {
-                config_id = QRD_TYPE_NQ3XX;
-                strlcpy(config_file, config_name_qrd_NQ3XX, MAX_DATA_CONFIG_PATH_LEN);
-            }
-            break;
-        case TARGET_MSM8998:
-        case TARGET_MSM8997:
-        case TARGET_SDM660:
-        case TARGET_SDM630:
-            if ((!strncmp(nq_chipid, NQ220, PROPERTY_VALUE_MAX)) || (!strncmp(nq_chipid, NQ210, PROPERTY_VALUE_MAX))) {
-                // NQ210 or NQ220
-                config_id = QRD_TYPE_2;
-                strlcpy(config_file, config_name_qrd2, MAX_DATA_CONFIG_PATH_LEN);
-	    } else {
-                config_id = QRD_TYPE_NQ3XX;
-                strlcpy(config_file, config_name_qrd_NQ3XX, MAX_DATA_CONFIG_PATH_LEN);
-            }
-            break;
-        default:
-            config_id = QRD_TYPE_DEFAULT;
-            strlcpy(config_file, config_name_qrd, MAX_DATA_CONFIG_PATH_LEN);
-            break;
-        }
-    }
-    // if target is not QRD platform then default config id is assigned here
-    else {
-        switch (idx)
-        {
-        case TARGET_GENERIC:
-            config_id = CONFIG_GENERIC;
-            break;
-        case TARGET_MSM8953:
-        case TARGET_MSM8937:
-        case TARGET_MSM8940:
-        case TARGET_MSM8917:
-        case TARGET_SDM632:
-        case TARGET_SDM439:
-        case TARGET_SDM429:
-        case TARGET_SDM450:
-            if ((!strncmp(nq_chipid, NQ220, PROPERTY_VALUE_MAX)) || (!strncmp(nq_chipid, NQ210, PROPERTY_VALUE_MAX))) {
-                // NQ210 or NQ220
-                config_id = MTP_TYPE_DEFAULT;
-                strlcpy(config_file, config_name_mtp, MAX_DATA_CONFIG_PATH_LEN);
-            } else if (!strncmp(nq_fw_ver, FW_MAJOR_NUM_NQ4xx, FW_MAJOR_NUM_LENGTH)) {
-                config_id = MTP_TYPE_NQ4XX;
-                strlcpy(config_file, config_name_mtp_NQ4XX, MAX_DATA_CONFIG_PATH_LEN);
-            } else {
-                config_id = MTP_TYPE_NQ3XX;
-                strlcpy(config_file, config_name_mtp_NQ3XX, MAX_DATA_CONFIG_PATH_LEN);
-            }
-            break;
-        case TARGET_SDM845:
-        case TARGET_SDM670:
-        case TARGET_SDM710:
-            if (!strncmp(nq_fw_ver, FW_MAJOR_NUM_NQ4xx, FW_MAJOR_NUM_LENGTH)) {
-                config_id = MTP_TYPE_NQ4XX;
-                strlcpy(config_file, config_name_mtp_NQ4XX, MAX_DATA_CONFIG_PATH_LEN);
-            }
-            else {
-                config_id = MTP_TYPE_NQ3XX;
-                strlcpy(config_file, config_name_mtp_NQ3XX, MAX_DATA_CONFIG_PATH_LEN);
-            }
-            break;
-        case TARGET_MSM8998:
-        case TARGET_MSM8997:
-        case TARGET_SDM660:
-        case TARGET_SDM630:
-            if ((!strncmp(nq_chipid, NQ220, PROPERTY_VALUE_MAX)) || (!strncmp(nq_chipid, NQ210, PROPERTY_VALUE_MAX))) {
-                // NQ210 or NQ220
-                config_id = MTP_TYPE_1;
-                strlcpy(config_file, config_name_mtp1, MAX_DATA_CONFIG_PATH_LEN);
-            } else {
-                config_id = MTP_TYPE_NQ3XX;
-                strlcpy(config_file, config_name_mtp_NQ3XX, MAX_DATA_CONFIG_PATH_LEN);
-            }
-            break;
-        default:
-            config_id = MTP_TYPE_DEFAULT;
-            strlcpy(config_file, config_name_mtp, MAX_DATA_CONFIG_PATH_LEN);
-            break;
-        }
-    }
-    if (DEBUG)
-        ALOGI("platform config id:%d, config_file_name:%s\n", config_id, config_file);
-
-    return config_id;
-}
-
-/*******************************************************************************
-**
-** Function:    isPrintable()
-**
-** Description: determine if 'c' is printable
-**
-** Returns:     1, if printable, otherwise 0
-**
-*******************************************************************************/
-inline bool isPrintable (char c)
-{
-    return  (c >= 'A' && c <= 'Z') ||
-            (c >= 'a' && c <= 'z') ||
-            (c >= '0' && c <= '9') ||
-            c == '/' || c == '_' || c == '-' || c == '.';
-}
-
-/*******************************************************************************
-**
-** Function:    isDigit()
-**
-** Description: determine if 'c' is numeral digit
-**
-** Returns:     true, if numerical digit
-**
-*******************************************************************************/
-inline bool isDigit (char c, int base)
-{
-    if ('0' <= c && c <= '9')
-        return true;
-    if (base == 16)
-    {
-        if (('A' <= c && c <= 'F') ||
-            ('a' <= c && c <= 'f'))
-            return true;
-    }
-    return false;
-}
-
-/*******************************************************************************
-**
-** Function:    getDigitValue()
-**
-** Description: return numerical value of a decimal or hex char
-**
-** Returns:     numerical value if decimal or hex char, otherwise 0
-**
-*******************************************************************************/
-inline int getDigitValue (char c, int base)
-{
-    if ('0' <= c && c <= '9')
-        return c - '0';
-    if (base == 16)
-    {
-        if ('A' <= c && c <= 'F')
-            return c - 'A' + 10;
-        else if ('a' <= c && c <= 'f')
-            return c - 'a' + 10;
-    }
-    return 0;
-}
-
-/*******************************************************************************
-**
-** Function:    findConfigFilePathFromTransportConfigPaths()
-**
-** Description: find a config file path with a given config name from transport
-**              config paths
-**
-** Returns:     none
-**
-*******************************************************************************/
-void findConfigFilePathFromTransportConfigPaths(const string& configName,
-                                                string& filePath) {
-    for (int i = 0; i < transport_config_path_size - 1; i++) {
-        filePath.assign(transport_config_paths[i]);
-        filePath += configName;
-        struct stat file_stat;
-        if (stat(filePath.c_str(), &file_stat) == 0 &&
-            S_ISREG(file_stat.st_mode)) {
-            return;
-        }
-    }
-    filePath.assign(transport_config_paths[transport_config_path_size - 1]);
-    filePath += configName;
-}
-
-/*******************************************************************************
-**
-** Function:    CNxpNfcConfig::readConfig()
-**
-** Description: read Config settings and parse them into a linked list
-**              move the element from linked list to a array at the end
-**
-** Returns:     1, if there are any config data, 0 otherwise
-**
-*******************************************************************************/
-bool CNxpNfcConfig::readConfig (const char* name, bool bResetContent)
-{
-    enum {
-        BEGIN_LINE = 1,
-        TOKEN,
-        STR_VALUE,
-        NUM_VALUE,
-        BEGIN_HEX,
-        BEGIN_QUOTE,
-        END_LINE
-    };
-
-    FILE*   fd;
-    struct stat buf;
-    string  token;
-    string  strValue;
-    unsigned long    numValue = 0;
-    CNxpNfcParam* pParam = NULL;
-    int     i = 0;
-    int     base = 0;
-    char    c;
-    int     bflag = 0;
-#if(NXP_EXTNS == TRUE)
-    mCurrentFile = name;
-#endif
-    state = BEGIN_LINE;
-    /* open config file, read it into a buffer */
-    if ((fd = fopen (name, "rb")) == NULL)
-    {
-        ALOGE("%s Cannot open config file %s", __func__, name);
-        if (bResetContent)
-        {
-            ALOGE("%s Using default value for all settings", __func__);
-            mValidFile = false;
-        }
-        return false;
-    }
-    ALOGV("%s Opened %s config %s\n", __func__, (bResetContent ? "base" : "optional"), name);
-
-    stat (name, &buf);
-
-    if(mDynamConfig)
-        m_timeStamp = (unsigned long)buf.st_mtime;
-    else
-    {
-        if(strcmp(default_nxp_config_path, name) == 0)
-            m_timeStamp = (unsigned long)buf.st_mtime;
-    }
-
-    mValidFile = true;
-    if (size() > 0)
-    {
-        if (bResetContent)
-            clean ();
-        else
-            moveToList ();
-    }
-
-    for (;;)
-    {
-        if (feof(fd) || fread(&c, 1, 1, fd) != 1)
-        {
-            if (state == BEGIN_LINE)
-                break;
-            /**
-             * got to the EOF but not in BEGIN_LINE state so the file
-             * probably does not end with a newline, so the parser has
-             * not processed current line, simulate a newline in the file
-             */
-            c = '\n';
-        }
-        switch (state & 0xff)
-        {
-        case BEGIN_LINE:
-            if (c == '#')
-            {
-                state = END_LINE;
-            }
-            else if (isPrintable (c))
-            {
-                i = 0;
-                token.erase ();
-                strValue.erase ();
-                state = TOKEN;
-                token.push_back (c);
-            }
-            break;
-        case TOKEN:
-            if (c == '=')
-            {
-                token.push_back ('\0');
-                state = BEGIN_QUOTE;
-            }
-            else if (isPrintable (c))
-            {
-                token.push_back (c);
-            }
-            else
-            {
-                state = END_LINE;
-            }
-            break;
-        case BEGIN_QUOTE:
-            if (c == '"')
-            {
-                state = STR_VALUE;
-                base = 0;
-            }
-            else if (c == '0')
-            {
-                state = BEGIN_HEX;
-            }
-            else if (isDigit (c, 10))
-            {
-                state = NUM_VALUE;
-                base = 10;
-                numValue = getDigitValue (c, base);
-                i = 0;
-            }
-            else if (c == '{')
-            {
-                state = NUM_VALUE;
-                bflag = 1;
-                base = 16;
-                i = 0;
-                Set (IsStringValue);
-            }
-            else
-            {
-                state = END_LINE;
-            }
-            break;
-        case BEGIN_HEX:
-            if (c == 'x' || c == 'X')
-            {
-                state = NUM_VALUE;
-                base = 16;
-                numValue = 0;
-                i = 0;
-                break;
-            }
-            else if (isDigit (c, 10))
-            {
-                state = NUM_VALUE;
-                base = 10;
-                numValue = getDigitValue (c, base);
-                break;
-            }
-            else if (c != '\n' && c != '\r')
-            {
-                state = END_LINE;
-                break;
-            }
-            // fall through to numValue to handle numValue
-
-        case NUM_VALUE:
-            if (isDigit (c, base))
-            {
-                numValue *= base;
-                numValue += getDigitValue (c, base);
-                ++i;
-            }
-            else if(bflag == 1 && (c == ' ' || c == '\r' || c=='\n' || c=='\t'))
-            {
-                break;
-            }
-            else if (base == 16 && (c== ','|| c == ':' || c == '-' || c == ' ' || c == '}'))
-            {
-
-                if( c=='}' )
-                {
-                    bflag = 0;
-                }
-                if (i > 0)
-                {
-                    int n = (i+1) / 2;
-                    while (n-- > 0)
-                    {
-                        numValue = numValue >> (n * 8);
-                        unsigned char c = (numValue) & 0xFF;
-                        strValue.push_back (c);
-                    }
-                }
-
-                Set (IsStringValue);
-                numValue = 0;
-                i = 0;
-            }
-            else
-            {
-                if (c == '\n' || c == '\r')
-                {
-                    if (bflag == 0)
-                    {
-                        state = BEGIN_LINE;
-                    }
-                }
-                else
-                {
-                    if (bflag == 0)
-                    {
-                        state = END_LINE;
-                    }
-                }
-                if (Is (IsStringValue) && base == 16 && i > 0)
-                {
-                    int n = (i+1) / 2;
-                    while (n-- > 0)
-                        strValue.push_back (((numValue >> (n * 8)) & 0xFF));
-                }
-                if (strValue.length() > 0)
-                    pParam = new CNxpNfcParam (token.c_str (), strValue);
-                else
-                    pParam = new CNxpNfcParam (token.c_str (), numValue);
-
-                add (pParam);
-                strValue.erase ();
-                numValue = 0;
-            }
-            break;
-        case STR_VALUE:
-            if (c == '"')
-            {
-                strValue.push_back('\0');
-                state = END_LINE;
-                pParam = new CNxpNfcParam(token.c_str(), strValue);
-                add(pParam);
-            }
-            else if (isPrintable(c))
-            {
-                strValue.push_back(c);
-            }
-            break;
-        case END_LINE:
-            if (c == '\n' || c == '\r')
-            {
-                state = BEGIN_LINE;
-            }
-            break;
-        default:
-            break;
-        }
-    }
-
-    fclose (fd);
-
-    moveFromList ();
-    return size () > 0;
-}
-
-/*******************************************************************************
-**
-** Function:    CNxpNfcConfig::CNxpNfcConfig()
-**
-** Description: class constructor
-**
-** Returns:     none
-**
-*******************************************************************************/
-CNxpNfcConfig::CNxpNfcConfig () :
-    mValidFile (true),
-    mDynamConfig(true),
-    m_timeStamp (0),
-    state (0)
-{
-}
-
-/*******************************************************************************
-**
-** Function:    CNxpNfcConfig::~CNxpNfcConfig()
-**
-** Description: class destructor
-**
-** Returns:     none
-**
-*******************************************************************************/
-CNxpNfcConfig::~CNxpNfcConfig ()
-{
-}
-
-/**
- * @brief checks whether the given file exist.
- *
- * This function gets the file name and checks whether the given file
- * exist in the particular path.Internaly it uses stat system call to
- * find the existance.
- *
- * @param filename The name of the file whose existance has to be checked.
- * @return it returns true if the given file name exist.
- */
-int CNxpNfcConfig::file_exist (const char* filename)
-{
-    struct stat   buffer;
-    return (stat (filename, &buffer) == 0);
-}
-
-/*******************************************************************************
-**
-** Function:    CNxpNfcConfig::GetInstance()
-**
-** Description: get class singleton object
-**
-** Returns:     none
-**
-*******************************************************************************/
-CNxpNfcConfig& CNxpNfcConfig::GetInstance ()
-{
-    static CNxpNfcConfig theInstance;
-    int gconfigpathid = 0;
-    char config_name_generic[MAX_DATA_CONFIG_PATH_LEN] = {'\0'};
-
-    if (theInstance.size () == 0 && theInstance.mValidFile)
-    {
-        string strPath;
-        if (alternative_config_path [0] != '\0')
-        {
-            strPath.assign (alternative_config_path);
-            strPath += config_name;
-            theInstance.readConfig (strPath.c_str (), true);
-            if (!theInstance.empty ())
-            {
-                return theInstance;
-            }
-        }
-        findConfigFilePathFromTransportConfigPaths(config_name, strPath);
-        //checks whether the default config file is present in th target
-        if (theInstance.file_exist(strPath.c_str()))
-        {
-            ALOGI("default config file exists = %s, dynamic selection disabled", strPath.c_str());
-            theInstance.mDynamConfig = false;
-            theInstance.readConfig(strPath.c_str(), true);
-            /*
-             * if libnfc-nxp.conf exists then dynamic selection will
-             * be turned off by default we will not have this file.
-             */
-            return theInstance;
-        }
-
-        gconfigpathid = theInstance.getconfiguration_id(config_name_generic);
-        findConfigFilePathFromTransportConfigPaths(config_name_generic, strPath);
-        if (!(theInstance.file_exist(strPath.c_str()))) {
-           ALOGI("no matching file found, using default file for stability\n");
-           findConfigFilePathFromTransportConfigPaths(config_name_default, strPath);
-        }
-        ALOGI("config file used = %s\n", strPath.c_str());
-        theInstance.readConfig (strPath.c_str (), true);
-#if(NXP_EXTNS == TRUE)
-        theInstance.readNxpTransitConfig("nxpTransit");
-#endif
-    }
-
-    return theInstance;
-}
-
-/*******************************************************************************
-**
-** Function:    CNxpNfcConfig::getValue()
-**
-** Description: get a string value of a setting
-**
-** Returns:     true if setting exists
-**              false if setting does not exist
-**
-*******************************************************************************/
-bool CNxpNfcConfig::getValue (const char* name, char* pValue, size_t len) const
-{
-    const CNxpNfcParam* pParam = find (name);
-    if (pParam == NULL)
-        return false;
-
-    if (pParam->str_len () > 0)
-    {
-        memset (pValue, 0, len);
-        memcpy (pValue, pParam->str_value (), pParam->str_len ());
-        return true;
-    }
-    return false;
-}
-
-bool CNxpNfcConfig::getValue (const char* name, char* pValue, long len,long* readlen) const
-{
-    const CNxpNfcParam* pParam = find (name);
-    if (pParam == NULL)
-        return false;
-
-    if (pParam->str_len () > 0)
-    {
-        if(pParam->str_len () <= (unsigned long) len)
-        {
-            memset (pValue, 0, len);
-            memcpy (pValue, pParam->str_value (), pParam->str_len ());
-            *readlen = pParam->str_len ();
-        }
-        else
-        {
-            *readlen = -1;
-        }
-
-        return true;
-    }
-    return false;
-}
-
-/*******************************************************************************
-**
-** Function:    CNxpNfcConfig::getValue()
-**
-** Description: get a long numerical value of a setting
-**
-** Returns:     true if setting exists
-**              false if setting does not exist
-**
-*******************************************************************************/
-bool CNxpNfcConfig::getValue (const char* name, unsigned long& rValue) const
-{
-    const CNxpNfcParam* pParam = find (name);
-    if (pParam == NULL)
-        return false;
-
-    if (pParam->str_len () == 0)
-    {
-        rValue = static_cast<unsigned long> (pParam->numValue ());
-        return true;
-    }
-    return false;
-}
-
-/*******************************************************************************
-**
-** Function:    CNxpNfcConfig::getValue()
-**
-** Description: get a short numerical value of a setting
-**
-** Returns:     true if setting exists
-**              false if setting does not exist
-**
-*******************************************************************************/
-bool CNxpNfcConfig::getValue (const char* name, unsigned short& rValue) const
-{
-    const CNxpNfcParam* pParam = find (name);
-    if (pParam == NULL)
-        return false;
-
-    if (pParam->str_len () == 0)
-    {
-        rValue = static_cast<unsigned short> (pParam->numValue ());
-        return true;
-    }
-    return false;
-}
-
-/*******************************************************************************
-**
-** Function:    CNxpNfcConfig::find()
-**
-** Description: search if a setting exist in the setting array
-**
-** Returns:     pointer to the setting object
-**
-*******************************************************************************/
-const CNxpNfcParam* CNxpNfcConfig::find (const char* p_name) const
-{
-    if (size () == 0)
-        return NULL;
-
-    for (const_iterator it = begin (), itEnd = end (); it != itEnd; ++it)
-    {
-        if (**it < p_name)
-        {
-            continue;
-        }
-        else if (**it == p_name)
-        {
-            if ((*it)->str_len () > 0)
-            {
-                NXPLOG_EXTNS_D ("%s found %s=%s\n", __func__, p_name, (*it)->str_value());
-            }
-            else
-            {
-                NXPLOG_EXTNS_D ("%s found %s=(0x%lx)\n", __func__, p_name, (*it)->numValue());
-            }
-            return *it;
-        }
-        else
-            break;
-    }
-    return NULL;
-}
-
-#if(NXP_EXTNS == TRUE)
-/*******************************************************************************
-**
-** Function:    CNxpNfcConfig::readNxpTransitConfig()
-**
-** Description: read Config settings from transit conf file
-**
-** Returns:     none
-**
-*******************************************************************************/
-void CNxpNfcConfig::readNxpTransitConfig(const char* fileName) const
-{
-    string strPath;
-    strPath.assign(transit_config_path);
-    strPath += extra_config_base;
-    strPath += fileName;
-    strPath += extra_config_ext;
-    CNxpNfcConfig::GetInstance().readConfig(strPath.c_str(), false);
-}
-#endif
-
-/*******************************************************************************
-**
-** Function:    CNxpNfcConfig::clean()
-**
-** Description: reset the setting array
-**
-** Returns:     none
-**
-*******************************************************************************/
-void CNxpNfcConfig::clean ()
-{
-    if (size () == 0)
-        return;
-
-    for (iterator it = begin (), itEnd = end (); it != itEnd; ++it)
-        delete *it;
-
-    clear ();
-}
-
-/*******************************************************************************
-**
-** Function:    CNxpNfcConfig::Add()
-**
-** Description: add a setting object to the list
-**
-** Returns:     none
-**
-*******************************************************************************/
-void CNxpNfcConfig::add (const CNxpNfcParam* pParam)
-{
-    if (m_list.size () == 0)
-    {
-        m_list.push_back (pParam);
-        return;
-    }
-#if(NXP_EXTNS == TRUE)
-    if((mCurrentFile.find("nxpTransit") != std::string::npos) && !isAllowed(pParam->c_str()))
-    {
-        ALOGV("%s Token restricted. Returning", __func__);
-        return;
-    }
-#endif
-    for (list<const CNxpNfcParam*>::iterator it = m_list.begin (), itEnd = m_list.end (); it != itEnd; ++it)
-    {
-        if (**it < pParam->c_str ())
-            continue;
-
-#if(NXP_EXTNS == TRUE)
-        if (**it == pParam->c_str())
-            m_list.insert(m_list.erase(it), pParam);
-        else
-            m_list.insert(it, pParam);
-#else
-        m_list.insert (it, pParam);
-#endif
-        return;
-    }
-    m_list.push_back (pParam);
-}
-
-#if(NXP_EXTNS == TRUE)
-/*******************************************************************************
-**
-** Function:    CNxpNfcConfig::dump()
-**
-** Description: prints all elements in the list
-**
-** Returns:     none
-**
-*******************************************************************************/
-void CNxpNfcConfig::dump()
-{
-    ALOGV("%s Enter", __func__);
-
-    for (list<const CNxpNfcParam*>::iterator it = m_list.begin(), itEnd = m_list.end(); it != itEnd; ++it)
-    {
-        if((*it)->str_len()>0)
-            ALOGV("%s %s \t= %s", __func__, (*it)->c_str(),(*it)->str_value());
-        else
-            ALOGV("%s %s \t= (0x%0lX)\n", __func__,(*it)->c_str(),(*it)->numValue());
-    }
-}
-
-/*******************************************************************************
-**
-** Function:    CNfcConfig::isAllowed()
-**
-** Description: checks if token update is allowed
-**
-** Returns:     true if allowed else false
-**
-*******************************************************************************/
-bool CNxpNfcConfig::isAllowed(const char* name)
-{
-    string token(name);
-    bool stat = false;
-    if((token.find("P2P_LISTEN_TECH_MASK") != std::string::npos)        ||
-            (token.find("HOST_LISTEN_TECH_MASK") != std::string::npos)  ||
-            (token.find("UICC_LISTEN_TECH_MASK") != std::string::npos)  ||
-            (token.find("POLLING_TECH_MASK") != std::string::npos)      ||
-            (token.find("NXP_RF_CONF_BLK") != std::string::npos)        ||
-            (token.find("NXP_CN_TRANSIT_BLK_NUM_CHECK_ENABLE") != std::string::npos) ||
-            (token.find("NXP_FWD_FUNCTIONALITY_ENABLE") != std::string::npos))
-
-    {
-        stat = true;
-    }
-    return stat;
-}
-#endif
-/*******************************************************************************
-**
-** Function:    CNxpNfcConfig::moveFromList()
-**
-** Description: move the setting object from list to array
-**
-** Returns:     none
-**
-*******************************************************************************/
-void CNxpNfcConfig::moveFromList ()
-{
-    if (m_list.size () == 0)
-        return;
-
-    for (list<const CNxpNfcParam*>::iterator it = m_list.begin (), itEnd = m_list.end (); it != itEnd; ++it)
-        push_back (*it);
-
-    m_list.clear ();
-}
-
-/*******************************************************************************
-**
-** Function:    CNxpNfcConfig::moveToList()
-**
-** Description: move the setting object from array to list
-**
-** Returns:     none
-**
-*******************************************************************************/
-void CNxpNfcConfig::moveToList ()
-{
-    if (m_list.size () != 0)
-        m_list.clear ();
-
-    for (iterator it = begin (), itEnd = end (); it != itEnd; ++it)
-        m_list.push_back (*it);
-
-    clear();
-}
-
-/*******************************************************************************
-**
-** Function:    CNxpNfcConfig::checkTimestamp()
-**
-** Description: check if config file has modified
-**
-** Returns:     0 if not modified, 1 otherwise.
-**
-*******************************************************************************/
-int CNxpNfcConfig::checkTimestamp ()
-{
-    FILE* fd;
-    struct stat st;
-    unsigned long value = 0;
-    int ret = 0;
-
-    if (stat(config_timestamp_path, &st) != 0)
-    {
-        ALOGV("%s file %s not exist, creat it.", __func__, config_timestamp_path);
-        if ((fd = fopen (config_timestamp_path, "w+")) != NULL)
-        {
-            fwrite (&m_timeStamp, sizeof(unsigned long), 1, fd);
-            fclose (fd);
-        }
-        return 1;
-    }
-    else
-    {
-        fd = fopen (config_timestamp_path, "r+");
-        if (fd == NULL)
-        {
-            ALOGE("%s Cannot open file %s", __func__, config_timestamp_path);
-            return 1;
-        }
-
-        fread (&value, sizeof(unsigned long), 1, fd);
-        ret = (value != m_timeStamp);
-        if (ret)
-        {
-            fseek (fd, 0, SEEK_SET);
-            fwrite (&m_timeStamp, sizeof(unsigned long), 1, fd);
-        }
-        fclose (fd);
-    }
-    return ret;
-}
-
-/*******************************************************************************
-**
-** Function:    CNxpNfcParam::CNxpNfcParam()
-**
-** Description: class constructor
-**
-** Returns:     none
-**
-*******************************************************************************/
-CNxpNfcParam::CNxpNfcParam () :
-    m_numValue (0)
-{
-}
-
-/*******************************************************************************
-**
-** Function:    CNxpNfcParam::~CNxpNfcParam()
-**
-** Description: class destructor
-**
-** Returns:     none
-**
-*******************************************************************************/
-CNxpNfcParam::~CNxpNfcParam ()
-{
-}
-
-/*******************************************************************************
-**
-** Function:    CNxpNfcParam::CNxpNfcParam()
-**
-** Description: class copy constructor
-**
-** Returns:     none
-**
-*******************************************************************************/
-CNxpNfcParam::CNxpNfcParam (const char* name, const string& value) :
-    string (name),
-    m_str_value (value),
-    m_numValue (0)
-{
-}
-
-/*******************************************************************************
-**
-** Function:    CNxpNfcParam::CNxpNfcParam()
-**
-** Description: class copy constructor
-**
-** Returns:     none
-**
-*******************************************************************************/
-CNxpNfcParam::CNxpNfcParam (const char* name, unsigned long value) :
-    string (name),
-    m_numValue (value)
-{
-}
-
-/*******************************************************************************
-**
-** Function:    GetStrValue
-**
-** Description: API function for getting a string value of a setting
-**
-** Returns:     True if found, otherwise False.
-**
-*******************************************************************************/
-extern "C" int GetNxpStrValue (const char* name, char* pValue, unsigned long len)
-{
-    CNxpNfcConfig& rConfig = CNxpNfcConfig::GetInstance ();
-
-    return rConfig.getValue (name, pValue, len);
-}
-
-/*******************************************************************************
-**
-** Function:    GetByteArrayValue()
-**
-** Description: Read byte array value from the config file.
-**
-** Parameters:
-**              name    - name of the config param to read.
-**              pValue  - pointer to input buffer.
-**              bufflen - input buffer length.
-**              len     - out parameter to return the number of bytes read from config file,
-**                        return -1 in case bufflen is not enough.
-**
-** Returns:     true[1] if config param name is found in the config file, else false[0]
-**
-*******************************************************************************/
-extern "C" int GetNxpByteArrayValue (const char* name, char* pValue, long bufflen, long *len)
-{
-    CNxpNfcConfig& rConfig = CNxpNfcConfig::GetInstance ();
-
-    return rConfig.getValue (name, pValue, bufflen,len);
-}
-
-/*******************************************************************************
-**
-** Function:    GetNumValue
-**
-** Description: API function for getting a numerical value of a setting
-**
-** Returns:     true, if successful
-**
-*******************************************************************************/
-extern "C" int GetNxpNumValue (const char* name, void* pValue, unsigned long len)
-{
-    if (!pValue)
-        return false;
-
-    CNxpNfcConfig& rConfig = CNxpNfcConfig::GetInstance ();
-    const CNxpNfcParam* pParam = rConfig.find (name);
-
-    if (pParam == NULL)
-        return false;
-
-    unsigned long v = pParam->numValue ();
-    if (v == 0 && pParam->str_len () > 0 && pParam->str_len () < 4)
-    {
-        const unsigned char* p = (const unsigned char*) pParam->str_value ();
-        for (unsigned int i = 0 ; i < pParam->str_len (); ++i)
-        {
-            v *= 256;
-            v += *p++;
-        }
-    }
-    switch (len)
-    {
-#if(NFC_ARCH_TYPE == 64)
-    case sizeof(unsigned long):
-        *(static_cast<unsigned long*>(pValue)) = (unsigned long) v;
-        break;
-#endif
-    case sizeof(unsigned int):
-        *(static_cast<unsigned int*>(pValue)) = (unsigned int) v;
-        break;
-    case sizeof(unsigned short):
-        *(static_cast<unsigned short*>(pValue)) = (unsigned short) v;
-        break;
-    case sizeof(unsigned char):
-        *(static_cast<unsigned char*> (pValue)) = (unsigned char) v;
-        break;
-    default:
-        return false;
-    }
-    return true;
-}
-
-/*******************************************************************************
-**
-** Function:    resetConfig
-**
-** Description: reset settings array
-**
-** Returns:     none
-**
-*******************************************************************************/
-extern "C" void resetNxpConfig ()
-{
-    CNxpNfcConfig& rConfig = CNxpNfcConfig::GetInstance ();
-
-    rConfig.clean ();
-}
-
-/*******************************************************************************
-**
-** Function:    readOptionalConfig()
-**
-** Description: read Config settings from an optional conf file
-**
-** Returns:     none
-**
-*******************************************************************************/
-void readOptionalConfig (const char* extra)
-{
-    string strPath;
-    string configName(extra_config_base);
-    configName += extra;
-    configName += extra_config_ext;
-
-    if (alternative_config_path [0] != '\0') {
-        strPath.assign (alternative_config_path);
-        strPath += configName;
-    } else {
-        findConfigFilePathFromTransportConfigPaths(configName, strPath);
-    }
-
-    CNxpNfcConfig::GetInstance ().readConfig (strPath.c_str (), false);
-}
-
-/*******************************************************************************
-**
-** Function:    isNxpConfigModified()
-**
-** Description: check if config file has modified
-**
-** Returns:     0 if not modified, 1 otherwise.
-**
-*******************************************************************************/
-extern "C" int isNxpConfigModified ()
-{
-    CNxpNfcConfig& rConfig = CNxpNfcConfig::GetInstance ();
-    return rConfig.checkTimestamp ();
-}
-
-/*******************************************************************************
-**
-** Function:    updateNxpConfigTimestamp()
-**
-** Description: update if config file has modified
-**
-** Returns:     0 if not modified, 1 otherwise.
-**
-*******************************************************************************/
-extern "C" int updateNxpConfigTimestamp()
-{
-    CNxpNfcConfig& rConfig = CNxpNfcConfig::GetInstance();
-    return rConfig.updateTimestamp();
-}
-
-/*******************************************************************************
-**
-** Function:    CNxpNfcConfig::updateTimestamp()
-**
-** Description: update if config file has modified
-**
-** Returns:     0 if not modified, 1 otherwise.
-**
-*******************************************************************************/
-int CNxpNfcConfig::updateTimestamp()
-{
-    FILE*   fd;
-    struct stat st;
-    unsigned long value = 0;
-    int ret = 0;
-
-    if(stat(config_timestamp_path, &st) != 0)
-    {
-        ALOGV("%s file %s not exist, creat it.\n", __func__, config_timestamp_path);
-        if ((fd = fopen(config_timestamp_path, "w+")) != NULL)
-        {
-            fwrite(&m_timeStamp, sizeof(unsigned long), 1, fd);
-            fclose(fd);
-        }
-        return 1;
-    }
-    else
-    {
-        fd = fopen(config_timestamp_path, "r+");
-        if(fd == NULL)
-        {
-            ALOGE("%s Cannot open file %s\n", __func__, config_timestamp_path);
-            return 1;
-        }
-
-        fread(&value, sizeof(unsigned long), 1, fd);
-        ret = (value != m_timeStamp);
-        if(ret)
-        {
-            fseek(fd, 0, SEEK_SET);
-            fwrite(&m_timeStamp, sizeof(unsigned long), 1, fd);
-        }
-        fclose(fd);
-    }
-    return ret;
-}
diff --git a/nci/jni/extns/pn54x/src/utils/phNxpConfig.h b/nci/jni/extns/pn54x/src/utils/phNxpConfig.h
index 99ef7abd..83158e0d 100644
--- a/nci/jni/extns/pn54x/src/utils/phNxpConfig.h
+++ b/nci/jni/extns/pn54x/src/utils/phNxpConfig.h
@@ -20,7 +20,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 The Android Open Source Project
+ *  Copyright (C) 2015-2018 The Android Open Source Project
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -39,63 +39,56 @@
 #ifndef _NXP_CONFIG_H
 #define _NXP_CONFIG_H
 
-#ifdef __cplusplus
-extern "C"
-{
-#endif
-
-int GetNxpStrValue (const char* name, char* p_value, unsigned long len);
-int GetNxpNumValue (const char* name, void* p_value, unsigned long len);
-int GetNxpByteArrayValue (const char* name, char* pValue, long bufflen, long *len);
-void resetNxpConfig (void);
-int isNxpConfigModified ();
-int updateNxpConfigTimestamp ();
-
-#ifdef __cplusplus
-}
-#endif
-
-#define NAME_NXPLOG_EXTNS_LOGLEVEL          "NXPLOG_EXTNS_LOGLEVEL"
-#define NAME_NXPLOG_NCIHAL_LOGLEVEL         "NXPLOG_NCIHAL_LOGLEVEL"
-#define NAME_NXPLOG_NCIX_LOGLEVEL           "NXPLOG_NCIX_LOGLEVEL"
-#define NAME_NXPLOG_NCIR_LOGLEVEL           "NXPLOG_NCIR_LOGLEVEL"
-#define NAME_NXPLOG_FWDNLD_LOGLEVEL         "NXPLOG_FWDNLD_LOGLEVEL"
-#define NAME_NXPLOG_TML_LOGLEVEL            "NXPLOG_TML_LOGLEVEL"
-
-#define NAME_MIFARE_READER_ENABLE           "MIFARE_READER_ENABLE"
-#define NAME_FW_STORAGE                     "FW_STORAGE"
-#define NAME_NXP_FW_NAME                    "NXP_FW_NAME"
-#define NAME_NXP_ACT_PROP_EXTN              "NXP_ACT_PROP_EXTN"
-#define NAME_NXP_RF_CONF_BLK_1              "NXP_RF_CONF_BLK_1"
-#define NAME_NXP_RF_CONF_BLK_2              "NXP_RF_CONF_BLK_2"
-#define NAME_NXP_RF_CONF_BLK_3              "NXP_RF_CONF_BLK_3"
-#define NAME_NXP_RF_CONF_BLK_4              "NXP_RF_CONF_BLK_4"
-#define NAME_NXP_RF_CONF_BLK_5              "NXP_RF_CONF_BLK_5"
-#define NAME_NXP_RF_CONF_BLK_6              "NXP_RF_CONF_BLK_6"
-#define NAME_NXP_CORE_CONF_EXTN             "NXP_CORE_CONF_EXTN"
-#define NAME_NXP_CORE_CONF                  "NXP_CORE_CONF"
-#define NAME_NXP_CORE_MFCKEY_SETTING        "NXP_CORE_MFCKEY_SETTING"
-#define NAME_NXP_CORE_STANDBY               "NXP_CORE_STANDBY"
-#define NAME_NXP_DEFAULT_SE                 "NXP_DEFAULT_SE"
-#define NAME_NXP_NFC_CHIP                   "NXP_NFC_CHIP"
-#define NAME_NXP_SWP_RD_START_TIMEOUT       "NXP_SWP_RD_START_TIMEOUT"
-#define NAME_NXP_SWP_RD_TAG_OP_TIMEOUT      "NXP_SWP_RD_TAG_OP_TIMEOUT"
-#define NAME_NXP_DEFAULT_NFCEE_TIMEOUT      "NXP_DEFAULT_NFCEE_TIMEOUT"
+/*int GetNxpStrValue(const char* name, char* p_value, unsigned long len);
+int GetNxpNumValue(const char* name, void* p_value, unsigned long len);
+int GetNxpByteArrayValue(const char* name, char* pValue, long bufflen,
+                         long* len);
+void resetNxpConfig(void);
+int isNxpRFConfigModified();
+int isNxpConfigModified();
+int updateNxpConfigTimestamp();*/
+
+#define NAME_NXPLOG_EXTNS_LOGLEVEL "NXPLOG_EXTNS_LOGLEVEL"
+#define NAME_NXPLOG_NCIHAL_LOGLEVEL "NXPLOG_NCIHAL_LOGLEVEL"
+#define NAME_NXPLOG_NCIX_LOGLEVEL "NXPLOG_NCIX_LOGLEVEL"
+#define NAME_NXPLOG_NCIR_LOGLEVEL "NXPLOG_NCIR_LOGLEVEL"
+#define NAME_NXPLOG_FWDNLD_LOGLEVEL "NXPLOG_FWDNLD_LOGLEVEL"
+#define NAME_NXPLOG_TML_LOGLEVEL "NXPLOG_TML_LOGLEVEL"
+
+#define NAME_MIFARE_READER_ENABLE "MIFARE_READER_ENABLE"
+#define NAME_FW_STORAGE "FW_STORAGE"
+#define NAME_NXP_ACT_PROP_EXTN "NXP_ACT_PROP_EXTN"
+#define NAME_NXP_RF_CONF_BLK_1 "NXP_RF_CONF_BLK_1"
+#define NAME_NXP_RF_CONF_BLK_2 "NXP_RF_CONF_BLK_2"
+#define NAME_NXP_RF_CONF_BLK_3 "NXP_RF_CONF_BLK_3"
+#define NAME_NXP_RF_CONF_BLK_4 "NXP_RF_CONF_BLK_4"
+#define NAME_NXP_RF_CONF_BLK_5 "NXP_RF_CONF_BLK_5"
+#define NAME_NXP_RF_CONF_BLK_6 "NXP_RF_CONF_BLK_6"
+#define NAME_NXP_CORE_CONF_EXTN "NXP_CORE_CONF_EXTN"
+#define NAME_NXP_CORE_CONF "NXP_CORE_CONF"
+#define NAME_NXP_CORE_MFCKEY_SETTING "NXP_CORE_MFCKEY_SETTING"
+#define NAME_NXP_CORE_STANDBY "NXP_CORE_STANDBY"
+#define NAME_NXP_DEFAULT_SE "NXP_DEFAULT_SE"
+#define NAME_NXP_NFC_CHIP "NXP_NFC_CHIP"
+#define NAME_NXP_SWP_RD_START_TIMEOUT "NXP_SWP_RD_START_TIMEOUT"
+#define NAME_NXP_SWP_RD_TAG_OP_TIMEOUT "NXP_SWP_RD_TAG_OP_TIMEOUT"
+#define NAME_NXP_DEFAULT_NFCEE_TIMEOUT "NXP_DEFAULT_NFCEE_TIMEOUT"
 #define NAME_NXP_DEFAULT_NFCEE_DISC_TIMEOUT "NXP_DEFAULT_NFCEE_DISC_TIMEOUT"
-#define NAME_NXP_CE_ROUTE_STRICT_DISABLE    "NXP_CE_ROUTE_STRICT_DISABLE"
-#define NAME_NXP_P61_LS_DEFAULT_INTERFACE   "NXP_P61_LS_DEFAULT_INTERFACE"
+#define NAME_NXP_CE_ROUTE_STRICT_DISABLE "NXP_CE_ROUTE_STRICT_DISABLE"
+#define NAME_NXP_P61_LS_DEFAULT_INTERFACE "NXP_P61_LS_DEFAULT_INTERFACE"
 #define NAME_NXP_P61_JCOP_DEFAULT_INTERFACE "NXP_P61_JCOP_DEFAULT_INTERFACE"
-#define NAME_NXP_JCOPDL_AT_BOOT_ENABLE      "NXP_JCOPDL_AT_BOOT_ENABLE"
+#define NAME_NXP_JCOPDL_AT_BOOT_ENABLE "NXP_JCOPDL_AT_BOOT_ENABLE"
 #define NAME_NXP_P61_LTSM_DEFAULT_INTERFACE "NXP_P61_LTSM_DEFAULT_INTERFACE"
-#define NAME_NXP_LOADER_SERICE_VERSION      "NXP_LOADER_SERVICE_VERSION"
-#define NAME_NXP_AGC_DEBUG_ENABLE           "NXP_AGC_DEBUG_ENABLE"
+#define NAME_NXP_LOADER_SERICE_VERSION "NXP_LOADER_SERVICE_VERSION"
+#define NAME_NXP_AGC_DEBUG_ENABLE "NXP_AGC_DEBUG_ENABLE"
 #define NAME_NXP_WIRED_MODE_RF_FIELD_ENABLE "NXP_WIRED_MODE_RF_FIELD_ENABLE"
-#define NAME_NXP_UICC_WIRED_PRT_MASK        "NXP_UICC_WIRED_PRT_MASK"
-#define NAME_NXP_ESE_WIRED_PRT_MASK         "NXP_ESE_WIRED_PRT_MASK"
-#define NAME_NXP_ENABLE_ADD_AID             "NXP_ENABLE_ADD_AID"
-#define NAME_NXP_ADDITIONAL_CONFIG_OPTIONS   "NXP_ADDITIONAL_CONFIG_OPTIONS"
-#define NAME_NXP_ESE_POWER_DH_CONTROL       "NXP_ESE_POWER_DH_CONTROL"
-#define NAME_NXP_DWP_INTF_RESET_ENABLE      "NXP_DWP_INTF_RESET_ENABLE"
+#define NAME_NXP_UICC_WIRED_PRT_MASK "NXP_UICC_WIRED_PRT_MASK"
+#define NAME_NXP_ESE_WIRED_PRT_MASK "NXP_ESE_WIRED_PRT_MASK"
+#define NAME_NXP_ENABLE_ADD_AID "NXP_ENABLE_ADD_AID"
+#define NAME_NXP_ESE_POWER_DH_CONTROL "NXP_ESE_POWER_DH_CONTROL"
+#define NAME_NXP_DWP_INTF_RESET_ENABLE "NXP_DWP_INTF_RESET_ENABLE"
+#define NAME_NFA_CONFIG_FORMAT "NFA_CONFIG_FORMAT"
+
 /**
  *  @brief defines the different config files used.
  */
diff --git a/nci/jni/extns/pn54x/src/utils/sparse_crc32.cpp b/nci/jni/extns/pn54x/src/utils/sparse_crc32.cpp
new file mode 100644
index 00000000..126548ce
--- /dev/null
+++ b/nci/jni/extns/pn54x/src/utils/sparse_crc32.cpp
@@ -0,0 +1,107 @@
+/*-
+ *  COPYRIGHT (C) 1986 Gary S. Brown.  You may use this program, or
+ *  code or tables extracted from it, as desired without restriction.
+ */
+
+/*
+ *  First, the polynomial itself and its table of feedback terms.  The
+ *  polynomial is
+ *  X^32+X^26+X^23+X^22+X^16+X^12+X^11+X^10+X^8+X^7+X^5+X^4+X^2+X^1+X^0
+ *
+ *  Note that we take it "backwards" and put the highest-order term in
+ *  the lowest-order bit.  The X^32 term is "implied"; the LSB is the
+ *  X^31 term, etc.  The X^0 term (usually shown as "+1") results in
+ *  the MSB being 1
+ *
+ *  Note that the usual hardware shift register implementation, which
+ *  is what we're using (we're merely optimizing it by doing eight-bit
+ *  chunks at a time) shifts bits into the lowest-order term.  In our
+ *  implementation, that means shifting towards the right.  Why do we
+ *  do it this way?  Because the calculated CRC must be transmitted in
+ *  order from highest-order term to lowest-order term.  UARTs transmit
+ *  characters in order from LSB to MSB.  By storing the CRC this way
+ *  we hand it to the UART in the order low-byte to high-byte; the UART
+ *  sends each low-bit to hight-bit; and the result is transmission bit
+ *  by bit from highest- to lowest-order term without requiring any bit
+ *  shuffling on our part.  Reception works similarly
+ *
+ *  The feedback terms table consists of 256, 32-bit entries.  Notes
+ *
+ *      The table can be generated at runtime if desired; code to do so
+ *      is shown later.  It might not be obvious, but the feedback
+ *      terms simply represent the results of eight shift/xor opera
+ *      tions for all combinations of data and CRC register values
+ *
+ *      The values must be right-shifted by eight bits by the "updcrc
+ *      logic; the shift must be unsigned (bring in zeroes).  On some
+ *      hardware you could probably optimize the shift in assembler by
+ *      using byte-swap instructions
+ *      polynomial $edb88320
+ *
+ *
+ * CRC32 code derived from work by Gary S. Brown.
+ */
+
+/* Code taken from FreeBSD 8 */
+#include <stdint.h>
+
+static uint32_t crc32_tab[] = {
+    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
+    0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
+    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
+    0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
+    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
+    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
+    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
+    0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
+    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
+    0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
+    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
+    0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
+    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
+    0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
+    0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
+    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
+    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
+    0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
+    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
+    0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
+    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
+    0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
+    0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
+    0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
+    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
+    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
+    0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
+    0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
+    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
+    0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
+    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
+    0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
+    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
+    0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
+    0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
+    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
+    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
+    0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
+    0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
+    0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
+    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
+    0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
+    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d};
+
+/*
+ * A function that calculates the CRC-32 based on the table above is
+ * given below for documentation purposes. An equivalent implementation
+ * of this function that's actually used in the kernel can be found
+ * in sys/libkern.h, where it can be inlined.
+ */
+
+uint32_t sparse_crc32(uint32_t crc_in, const void* buf, size_t size) {
+  const uint8_t* p = (uint8_t*) buf;
+  uint32_t crc;
+
+  crc = crc_in ^ ~0U;
+  while (size--) crc = crc32_tab[(crc ^ *p++) & 0xFF] ^ (crc >> 8);
+  return crc ^ ~0U;
+}
diff --git a/nci/jni/extns/pn54x/src/utils/sparse_crc32.h b/nci/jni/extns/pn54x/src/utils/sparse_crc32.h
new file mode 100644
index 00000000..2702c4fa
--- /dev/null
+++ b/nci/jni/extns/pn54x/src/utils/sparse_crc32.h
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _LIBSPARSE_SPARSE_CRC32_H_
+#define _LIBSPARSE_SPARSE_CRC32_H_
+
+#include <stdint.h>
+
+uint32_t sparse_crc32(uint32_t crc, const void* buf, size_t size);
+
+#endif
diff --git a/nci/src/com/android/nfc/dhimpl/NativeNfcManager.java b/nci/src/com/android/nfc/dhimpl/NativeNfcManager.java
index 2b904401..687d7710 100644
--- a/nci/src/com/android/nfc/dhimpl/NativeNfcManager.java
+++ b/nci/src/com/android/nfc/dhimpl/NativeNfcManager.java
@@ -2,7 +2,7 @@
  * Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.
  * Not a Contribution.
  *
- * Copyright (C) 2015 NXP Semiconductors
+ * Copyright (C) 2015-2018 NXP Semiconductors
  * The original Work has been changed by NXP Semiconductors.
  * Copyright (C) 2010 The Android Open Source Project
  *
@@ -30,21 +30,23 @@ import android.nfc.tech.TagTechnology;
 import android.util.Log;
 import java.io.File;
 
+import java.util.HashMap;
+import java.util.Map;
 import com.android.nfc.DeviceHost;
 import com.android.nfc.LlcpException;
 import com.android.nfc.NfcDiscoveryParameters;
 
+import java.io.FileDescriptor;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.HashMap;
-import java.util.Map;
+
 
 /**
  * Native interface to the NFC Manager functions
  */
 public class NativeNfcManager implements DeviceHost {
     private static final String TAG = "NativeNfcManager";
-    private static final String PREF_FIRMWARE_MODTIME = "firmware_modtime";
     private static final long FIRMWARE_MODTIME_DEFAULT = -1;
     static final String PREF = "NciDeviceHost";
 
@@ -73,7 +75,9 @@ public class NativeNfcManager implements DeviceHost {
     /* Native structure */
     private long mNative;
 
+    private int mIsoDepMaxTransceiveLength;
     private final DeviceHostListener mListener;
+    private final NativeNfcMposManager mMposMgr;
     private final Context mContext;
     private Map<String, Integer> mNfcid2ToHandle;
     private final Object mLock = new Object();
@@ -83,6 +87,7 @@ public class NativeNfcManager implements DeviceHost {
         initializeNativeStructure();
         mContext = context;
         mNfcid2ToHandle = new HashMap<String, Integer>();
+        mMposMgr = new NativeNfcMposManager();
     }
 
     public native boolean initializeNativeStructure();
@@ -97,66 +102,8 @@ public class NativeNfcManager implements DeviceHost {
 
     @Override
     public void checkFirmware() {
-        // Check that the NFC controller firmware is up to date.  This
-        // ensures that firmware updates are applied in a timely fashion,
-        // and makes it much less likely that the user will have to wait
-        // for a firmware download when they enable NFC in the settings
-        // app.  Firmware download can take some time, so this should be
-        // run in a separate thread.
-
-        // check the timestamp of the firmware file
-        File firmwareFile;
-        int nbRetry = 0;
-        try {
-        byte[] fwFileName;
-        String filePath="/vendor/lib/";
-
-        //Read firmware file name from config file
-        fwFileName=getFwFileName();
-        if(fwFileName == null)
-        {
-            Log.d(TAG,"FileName not found");
-            int Ver = getChipVer();
-            if( Ver == PN547C2_ID || Ver == PN65T_ID )
-                filePath=filePath.concat("libpn547_fw.so");
-            else if( Ver == PN548C2_ID || Ver == PN66T_ID )
-                filePath=filePath.concat("libpn548c2_fw.so");
-            else if( Ver == PN551_ID || Ver == PN67T_ID )
-                filePath=filePath.concat("libpn551_fw.so");
-            else if( Ver == PN553_ID || Ver == PN80T_ID )
-                filePath=filePath.concat("libpn553_fw.so");
-            else
-                filePath=null;
-        }
-        else
-        {
-            Log.d(TAG,"Firmware fileName found");
-            String fileName = new String(fwFileName);
-            filePath=filePath.concat(fileName);
-        }
-        Log.d(TAG,"Firmware file path=" + filePath);
-        firmwareFile = new File(filePath);
-        } catch(NullPointerException npe) {
-            Log.e(TAG,"path to firmware file was null");
-            return;
-        }
-
-        long modtime = firmwareFile.lastModified();
-
-        SharedPreferences prefs = mContext.getSharedPreferences(PREF, Context.MODE_PRIVATE);
-        long prev_fw_modtime = prefs.getLong(PREF_FIRMWARE_MODTIME, FIRMWARE_MODTIME_DEFAULT);
-        Log.d(TAG,"prev modtime: " + prev_fw_modtime);
-        Log.d(TAG,"new modtime: " + modtime);
-        if (prev_fw_modtime == modtime) {
-            return;
-        }
-
-        // FW download.
-        Log.d(TAG,"Perform FW Download Procedure");
         if(doDownload()) {
             Log.d(TAG,"FW Download Success");
-            // Now that we've finished updating the firmware, save the new modtime.
-            prefs.edit().putLong(PREF_FIRMWARE_MODTIME, modtime).apply();
         }
     else {
             Log.d(TAG,"FW Download Failed");
@@ -165,6 +112,8 @@ public class NativeNfcManager implements DeviceHost {
 
     private native boolean doInitialize();
 
+    private native int getIsoDepMaxTransceiveLength();
+
     @Override
     public boolean initialize() {
         SharedPreferences prefs = mContext.getSharedPreferences(PREF, Context.MODE_PRIVATE);
@@ -178,7 +127,9 @@ public class NativeNfcManager implements DeviceHost {
             } catch (InterruptedException e) { }
         }
 
-        return doInitialize();
+        boolean ret = doInitialize();
+        mIsoDepMaxTransceiveLength = getIsoDepMaxTransceiveLength();
+        return ret;
     }
 
     private native void doEnableDtaMode();
@@ -211,9 +162,6 @@ public class NativeNfcManager implements DeviceHost {
         doShutdown();
     }
 
-    @Override
-    public native byte[] getAdditionalConfigOptions();
-
     private native boolean doDeinitialize();
 
     @Override
@@ -294,6 +242,9 @@ public class NativeNfcManager implements DeviceHost {
     @Override
     public native int   getDefaultAidPowerState();
 
+    @Override
+    public native int   doNfcSelfTest(int type);
+
     @Override
     public native int   getDefaultDesfirePowerState();
 
@@ -351,6 +302,9 @@ public class NativeNfcManager implements DeviceHost {
     @Override
     public native void doSelectSecureElement(int seID);
 
+    @Override
+    public native void doActivateSecureElement(int seID);
+
     @Override
     public native void doDeselectSecureElement(int seID);
 
@@ -367,7 +321,8 @@ public class NativeNfcManager implements DeviceHost {
     public native int getChipVer();
 
     @Override
-    public native byte[] getFwFileName();
+    public native int setTransitConfig(String configs);
+
 
     @Override
     public native int getNfcInitTimeout();
@@ -388,22 +343,56 @@ public class NativeNfcManager implements DeviceHost {
     public native boolean isNfccBusy();
 
     @Override
-    public native void setEtsiReaederState(int newState);
+    public void setEtsiReaederState(int newState) {
+        mMposMgr.doSetEtsiReaederState(newState);
+    }
+
+    @Override
+    public int getEtsiReaederState() {
+        int state;
+        state = mMposMgr.doGetEtsiReaederState();
+        return state;
+    }
+
+    @Override
+    public void etsiReaderConfig(int eeHandle) {
+        mMposMgr.doEtsiReaderConfig(eeHandle);
+    }
+
+    @Override
+    public void notifyEEReaderEvent(int evt) {
+        mMposMgr.doNotifyEEReaderEvent(evt);
+    }
 
     @Override
-    public native int getEtsiReaederState();
+    public void etsiInitConfig() {
+        mMposMgr.doEtsiInitConfig();
+    }
 
     @Override
-    public native void etsiReaderConfig(int eeHandle);
+    public void etsiResetReaderConfig() {
+        mMposMgr.doEtsiResetReaderConfig();
+    }
 
     @Override
-    public native void notifyEEReaderEvent(int evt);
+    public void stopPoll(int mode) {
+        mMposMgr.doStopPoll(mode);
+    }
 
     @Override
-    public native void etsiInitConfig();
+    public void startPoll() {
+        mMposMgr.doStartPoll();
+    }
 
     @Override
-    public native void etsiResetReaderConfig();
+    public int mposSetReaderMode(boolean on) {
+        return mMposMgr.doMposSetReaderMode(on);
+    }
+
+    @Override
+    public boolean mposGetReaderMode() {
+        return mMposMgr.doMposGetReaderMode();
+    }
 
     @Override
     public native void updateScreenState();
@@ -534,14 +523,9 @@ public class NativeNfcManager implements DeviceHost {
             case (TagTechnology.NFC_V):
                 return 253; // PN544 RF buffer = 255 bytes, subtract two for CRC
             case (TagTechnology.ISO_DEP):
-                /* The maximum length of a normal IsoDep frame consists of:
-                 * CLA, INS, P1, P2, LC, LE + 255 payload bytes = 261 bytes
-                 * such a frame is supported. Extended length frames however
-                 * are not supported.
-                 */
-                return 0xFEFF; // Will be automatically split in two frames on the RF layer
+                return mIsoDepMaxTransceiveLength;
             case (TagTechnology.NFC_F):
-                return 252; // PN544 RF buffer = 255 bytes, subtract one for SoD, two for CRC
+                return 255;
             default:
                 return 0;
         }
@@ -565,7 +549,12 @@ public class NativeNfcManager implements DeviceHost {
 
     @Override
     public boolean getExtendedLengthApdusSupported() {
-        return true;
+        /* 261 is the default size if extended length frames aren't supported */
+        if (getMaxTransceiveLength(TagTechnology.ISO_DEP) > 261) {
+            return true;
+        } else {
+            return false;
+        }
     }
 
     @Override
@@ -583,10 +572,10 @@ public class NativeNfcManager implements DeviceHost {
         return DEFAULT_LLCP_RWSIZE;
     }
 
-    private native String doDump();
+    private native void doDump(FileDescriptor fd);
     @Override
-    public String dump() {
-        return doDump();
+    public void dump(FileDescriptor fd) {
+        doDump(fd);
     }
 
     private native void doEnableScreenOffSuspend();
@@ -727,6 +716,11 @@ public class NativeNfcManager implements DeviceHost {
     @Override
     public native int setPreferredSimSlot(int uiccSlot);
 
+    @Override
+    public native byte[] readerPassThruMode(byte status, byte modulationTyp);
+
+    @Override public native byte[] transceiveAppData(byte[] data);
+
     /**
      * Notifies Ndef Message (TODO: rename into notifyTargetDiscovered)
      */
@@ -741,13 +735,6 @@ public class NativeNfcManager implements DeviceHost {
         mListener.onCardEmulationDeselected();
     }
 
-    /**
-     * Notifies transaction
-     */
-    private void notifyTransactionListeners(byte[] aid, byte[] data, int evtSrc) {
-        mListener.onCardEmulationAidSelected(aid,data,evtSrc);
-    }
-
     /**
      * Notifies transaction
      */
@@ -798,17 +785,14 @@ public class NativeNfcManager implements DeviceHost {
     private void notifyFwDwnldRequested() {
         mListener.onFwDwnldReqRestartNfc();
     }
-    /* Reader over SWP listeners*/
-    private void notifySWPReaderRequested(boolean istechA, boolean istechB) {
-        mListener.onSWPReaderRequestedEvent(istechA, istechB);
-    }
 
-    private void notifySWPReaderRequestedFail(int FailureCause) {
-        mListener.onSWPReaderRequestedFail(FailureCause);
+    /* Reader over SWP listeners*/
+    private void notifyETSIReaderRequested(boolean istechA, boolean istechB) {
+        mListener.onETSIReaderRequestedEvent(istechA, istechB);
     }
 
-    private void notifySWPReaderActivated() {
-        mListener.onSWPReaderActivatedEvent();
+    private void notifyETSIReaderRequestedFail(int FailureCause) {
+        mListener.onETSIReaderRequestedFail(FailureCause);
     }
 
     private void notifyonETSIReaderModeStartConfig(int eeHandle) {
@@ -823,6 +807,10 @@ public class NativeNfcManager implements DeviceHost {
         mListener.onETSIReaderModeSwpTimeout(disc_ntf_timeout);
     }
 
+    private void notifyonETSIReaderModeRestart() {
+        mListener.onETSIReaderModeRestart();
+    }
+
     private void notifySeListenActivated() {
         mListener.onSeListenActivated();
     }
@@ -879,6 +867,10 @@ public class NativeNfcManager implements DeviceHost {
        mListener.onUiccStatusEvent(uiccStat);
    }
 
+    private void notifyTransactionListeners(byte[] aid, byte[] data, String evtSrc) {
+        mListener.onNfcTransactionEvent(aid, data, evtSrc);
+    }
+
     static String toHexString(byte[] buffer, int offset, int length) {
         final char[] HEX_CHARS = "0123456789abcdef".toCharArray();
         char[] chars = new char[2 * length];
diff --git a/nci/src/com/android/nfc/dhimpl/NativeNfcMposManager.java b/nci/src/com/android/nfc/dhimpl/NativeNfcMposManager.java
new file mode 100644
index 00000000..80cd6484
--- /dev/null
+++ b/nci/src/com/android/nfc/dhimpl/NativeNfcMposManager.java
@@ -0,0 +1,43 @@
+/******************************************************************************
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  Copyright 2018 NXP
+ *
+ ******************************************************************************/
+
+package com.android.nfc.dhimpl;
+
+public class NativeNfcMposManager {
+    private static final String TAG = "NativeNfcMposManager";
+
+    public native void doSetEtsiReaederState(int newState);
+
+    public native int doGetEtsiReaederState();
+
+    public native void doEtsiReaderConfig(int eeHandle);
+
+    public native void doNotifyEEReaderEvent(int evt);
+
+    public native void doEtsiInitConfig();
+
+    public native void doEtsiResetReaderConfig();
+
+    public native void doStopPoll(int mode);
+
+    public native void doStartPoll();
+
+    public native int doMposSetReaderMode(boolean on);
+
+    public native boolean doMposGetReaderMode();
+}
\ No newline at end of file
diff --git a/nci/src/com/android/nfc/dhimpl/NativeNfcTag.java b/nci/src/com/android/nfc/dhimpl/NativeNfcTag.java
index 610a7394..7c66f33f 100644
--- a/nci/src/com/android/nfc/dhimpl/NativeNfcTag.java
+++ b/nci/src/com/android/nfc/dhimpl/NativeNfcTag.java
@@ -91,7 +91,7 @@ public class NativeNfcTag implements TagEndpoint {
     class PresenceCheckWatchdog extends Thread {
 
         private final int watchdogTimeout;
-        private final DeviceHost.TagDisconnectedCallback tagDisconnectedCallback;
+        private DeviceHost.TagDisconnectedCallback tagDisconnectedCallback;
 
         private boolean isPresent = true;
         private boolean isStopped = false;
@@ -118,9 +118,12 @@ public class NativeNfcTag implements TagEndpoint {
             this.notifyAll();
         }
 
-        public synchronized void end() {
+        public synchronized void end(boolean disableCallback) {
             isStopped = true;
             doCheck = false;
+            if (disableCallback) {
+                tagDisconnectedCallback = null;
+            }
             this.notifyAll();
         }
 
@@ -247,6 +250,14 @@ public class NativeNfcTag implements TagEndpoint {
         return connectWithStatus(technology) == 0;
     }
 
+    @Override
+    public synchronized void stopPresenceChecking() {
+        mIsPresent = false;
+        if (mWatchdog != null) {
+            mWatchdog.end(true);
+        }
+    }
+
     @Override
     public synchronized void startPresenceChecking(int presenceCheckDelay,
                                                    DeviceHost.TagDisconnectedCallback callback) {
@@ -276,7 +287,7 @@ public class NativeNfcTag implements TagEndpoint {
         }
         if (watchdog != null) {
             // Watchdog has already disconnected or will do it
-            watchdog.end();
+            watchdog.end(false);
             try {
                 watchdog.join();
             } catch (InterruptedException e) {
diff --git a/nci/src/com/gsma/nfc/internal/NxpNfcController.java b/nci/src/com/gsma/nfc/internal/NxpNfcController.java
index 5740f246..7d605117 100644
--- a/nci/src/com/gsma/nfc/internal/NxpNfcController.java
+++ b/nci/src/com/gsma/nfc/internal/NxpNfcController.java
@@ -25,14 +25,11 @@ import java.util.List;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.Map;
-
 import android.content.BroadcastReceiver;
-import android.content.pm.ActivityInfo;
 import android.content.pm.ResolveInfo;
 import android.content.pm.PackageInfo;
-import android.net.Uri;
-import android.util.Log;
 
+import android.util.Log;
 import com.nxp.nfc.gsma.internal.INxpNfcController;
 import com.android.nfc.cardemulation.CardEmulationManager;
 import com.android.nfc.cardemulation.RegisteredAidCache;
@@ -42,11 +39,10 @@ import android.os.Binder;
 import android.content.ComponentName;
 import android.content.pm.PackageManager;
 import android.content.pm.PackageManager.NameNotFoundException;
-
 import com.android.nfc.NfcPermissions;
 import com.android.nfc.NfcService;
 import com.nxp.nfc.NxpConstants;
-
+import android.nfc.NfcAdapter;
 
 public class NxpNfcController {
 
@@ -61,17 +57,18 @@ public class NxpNfcController {
     private RegisteredAidCache mRegisteredAidCache;
     private CardEmulationManager mCardEmulationManager;
     private boolean mGsmaCommitOffhostService = false;
-    static final String TAG = "NxpNfcControllerService";
+    static final String TAG = "NxpNfcController";
     boolean DBG = true;
 
     public ArrayList<String> mEnabledMultiEvts = new ArrayList<String>();
     public final HashMap<String, Boolean> mMultiReceptionMap = new HashMap<String, Boolean>();
-    private Object mWaitX509CheckCert = null;
-    private boolean mHasX509Cert = false;
+    //private NfcService mService;
+    private Object mWaitCheckCert = null;
+    private boolean mHasCert = false;
+    private Object mWaitOMACheckCert = null;
+    private boolean mHasOMACert = false;
     private ComponentName unicastPkg = null;
 
-    static final int X509_WAIT_TIMEOUT = 10000;
-
     public NxpNfcController(Context context, CardEmulationManager cardEmulationManager) {
         mContext = context;
         mCardEmulationManager = cardEmulationManager;
@@ -82,66 +79,101 @@ public class NxpNfcController {
 
     public INxpNfcController getNxpNfcControllerInterface() {
         if(mNxpNfcControllerInterface != null) {
-            if(DBG) Log.d(TAG, "GSMA: mNxpNfcControllerInterface is not Null");
+            Log.d("NxpNfcController", "GSMA: mNxpNfcControllerInterface is not Null");
             return mNxpNfcControllerInterface;
         }
         return null;
     }
 
     public ArrayList<String> getEnabledMultiEvtsPackageList() {
+        if(mEnabledMultiEvts.size() == 0x00) {
+            Log.d(TAG, " check for unicast mode service resolution");
+            getPackageListUnicastMode();
+        }
         return mEnabledMultiEvts;
     }
 
-    private boolean checkCertificatesFromUICC(String pkg, String seName) {
-        // FIXME: Should this be ACTION_CHECK_CERT ?
-        return checkX509CertificatesFromSim(pkg, seName);
-   }
-
     public void setResultForCertificates(boolean result) {
-        // FIXME: Might expect ACTION_CHECK_CERT
-        setResultForX509Certificates(result);
+        Log.d(TAG, "setResultForCertificates() Start");
+        synchronized (mWaitCheckCert) {
+            if (mWaitCheckCert != null) {
+                if (result) {
+                    mHasCert = true;
+                } else {
+                    mHasCert = false;
+                }
+                mWaitCheckCert.notify();
+            }
+        }
+        Log.d(TAG, "setResultForCertificates() End");
     }
 
-    // "org.simalliance.openmobileapi.service.ACTION_CHECK_X509
+    private boolean checkCertificatesFromUICC(String pkg, String seName) {
+        Log.d(TAG, "checkCertificatesFromUICC() " + pkg + ", " + seName);
+        Intent CertificateIntent = new Intent();
+        CertificateIntent.setAction(NxpConstants.ACTION_CHECK_X509);
+        CertificateIntent.setPackage(NxpConstants.SET_PACKAGE_NAME);
+        CertificateIntent.putExtra(NfcAdapter.EXTRA_SECURE_ELEMENT_NAME, seName);
+        CertificateIntent.putExtra(NxpConstants.EXTRA_PKG, pkg);
+        mContext.sendBroadcast(CertificateIntent);
+
+        mWaitCheckCert = new Object();
+        mHasCert = false;
+        try {
+            synchronized (mWaitCheckCert) {
+                mWaitCheckCert.wait(1000); // timeout ms
+            }
+        } catch (InterruptedException e) {
+            Log.w(TAG, "interruped exception .");
+        }
+        mWaitCheckCert = null;
+
+        if (mHasCert) {
+            return true;
+        } else {
+            return false;
+        }
+   }
+
     private boolean checkX509CertificatesFromSim (String pkg, String seName) {
         if (DBG) Log.d(TAG, "checkX509CertificatesFromSim() " + pkg + ", " + seName);
 
-        Intent checkX509CertificateIntent = new Intent();
-        checkX509CertificateIntent.setAction(NxpConstants.ACTION_CHECK_X509);
-        checkX509CertificateIntent.setPackage(NxpConstants.SET_PACKAGE_NAME);
-        checkX509CertificateIntent.putExtra(NxpConstants.EXTRA_SE_NAME, seName);
-        checkX509CertificateIntent.putExtra(NxpConstants.EXTRA_PKG, pkg);
-        mContext.sendBroadcast(checkX509CertificateIntent);
+        Intent checkCertificateIntent = new Intent();
+        checkCertificateIntent.setAction("org.simalliance.openmobileapi.service.ACTION_CHECK_X509");
+        checkCertificateIntent.setPackage("org.simalliance.openmobileapi.service");
+        checkCertificateIntent.putExtra("org.simalliance.openmobileapi.service.EXTRA_SE_NAME", seName);
+        checkCertificateIntent.putExtra("org.simalliance.openmobileapi.service.EXTRA_PKG", pkg);
+        mContext.sendBroadcast(checkCertificateIntent);
 
-        mWaitX509CheckCert = new Object();
-        mHasX509Cert = false;
+        mWaitOMACheckCert = new Object();
+        mHasOMACert = false;
         try {
-            synchronized (mWaitX509CheckCert) {
-                mWaitX509CheckCert.wait(X509_WAIT_TIMEOUT); //add timeout 10s
+            synchronized (mWaitOMACheckCert) {
+                mWaitOMACheckCert.wait(1000); //add timeout ms
             }
         } catch (InterruptedException e) {
             // Should not happen; fall-through to abort.
-            Log.w(TAG, "checkX509CertificatesFromSim(): interrupted");
+            Log.w(TAG, "interruped.");
         }
-        mWaitX509CheckCert = null;
+        mWaitOMACheckCert = null;
 
-        if (mHasX509Cert) {
+        if (mHasOMACert) {
             return true;
         } else {
             return false;
         }
-    }
+   }
 
     public void setResultForX509Certificates(boolean result) {
-        Log.d(TAG, "setResultForX509Certificates() Start, result: " + result);
-        if (mWaitX509CheckCert != null) {
-            synchronized (mWaitX509CheckCert) {
+        Log.d(TAG, "setResultForX509Certificates() Start");
+        synchronized (mWaitOMACheckCert) {
+            if (mWaitOMACheckCert != null) {
                 if (result) {
-                    mHasX509Cert = true;
+                    mHasOMACert = true;
                 } else {
-                    mHasX509Cert = false;
+                    mHasOMACert = false;
                 }
-                mWaitX509CheckCert.notify();
+                mWaitOMACheckCert.notify();
             }
         }
         Log.d(TAG, "setResultForX509Certificates() End");
@@ -177,30 +209,13 @@ public class NxpNfcController {
         }
     }
 
-    private ComponentName getPackageListUnicastMode (Intent intent) {
+    private void getPackageListUnicastMode () {
         unicastPkg = null;
         List<NQApduServiceInfo> regServices = new ArrayList<NQApduServiceInfo>(mCardEmulationManager.getAllServices());
-        if(DBG) Log.d(TAG, "getPackageListUnicastMode(): regServices.size() " + regServices.size());
-
         PackageManager pm = mContext.getPackageManager();
-        /*
-         * FIXME: we can use queryBroadcastReceivers to get partial matches
-         * FIXME: we cannot use queryIntentActivities for partial match
-        List<ResolveInfo> intentBroadcastReceivers = pm.queryBroadcastReceivers(
-                new Intent(NxpConstants.ACTION_MULTI_EVT_TRANSACTION,
-                        Uri.parse("nfc://secure:0/SIM")),
-                        (PackageManager.MATCH_DEFAULT_ONLY |
-                                PackageManager.GET_INTENT_FILTERS |
-                                PackageManager.GET_RESOLVED_FILTER));
-        if(DBG) Log.d(TAG, "getPackageListUnicastMode() : intentBroadcastReceivers.size() " + intentBroadcastReceivers.size());
-         */
-        List<ResolveInfo> intentReceivers = pm.queryIntentActivities(
-                intent,
-                (PackageManager.MATCH_DEFAULT_ONLY |
-                        PackageManager.GET_INTENT_FILTERS |
-                        PackageManager.GET_RESOLVED_FILTER));
-        if(DBG) Log.d(TAG, "getPackageListUnicastMode() : intentReceivers.size() " + intentReceivers.size());
-
+        List<ResolveInfo> intentServices = pm.queryIntentActivities(
+                new Intent(NxpConstants.ACTION_MULTI_EVT_TRANSACTION),
+                PackageManager.GET_INTENT_FILTERS| PackageManager.GET_RESOLVED_FILTER);
         ArrayList<String> apduResolvedServices = new ArrayList<String>();
         String packageName = null;
         String resolvedApduService = null;
@@ -210,16 +225,16 @@ public class NxpNfcController {
 
         for(NQApduServiceInfo service : regServices) {
             packageName = service.getComponent().getPackageName();
-            for(ResolveInfo resInfo : intentReceivers) {
+            for(ResolveInfo resInfo : intentServices){
                 resolveInfoService = null;
-                Log.d(TAG, "Registered Activity in resolved cache " + resInfo.activityInfo.packageName);
+                Log.e(TAG, " Registered Service in resolved cache"+resInfo.activityInfo.packageName);
                 if(resInfo.activityInfo.packageName.equals(packageName)) {
                     resolveInfoService = resInfo;
                     break;
                 }
             }
             if(resolveInfoService == null) {
-                Log.e(TAG, "Registered Activity is not found in cache");
+                Log.e(TAG, " Registered Service is not found in cache");
                 continue;
             }
             int priority = resolveInfoService.priority;
@@ -241,34 +256,33 @@ public class NxpNfcController {
         }
         if(apduResolvedServices.size() == 0x00) {
             Log.e(TAG, "No services to resolve, not starting the activity");
-            return unicastPkg;
+            return;
         }else if(apduResolvedServices.size() > 0x01) {
-            Log.d(TAG, "apduResolvedServices.size(): " + apduResolvedServices.size());
+            Log.e(TAG, " resolved"+apduResolvedServices.size());
             minInstallTime = getApplicationInstallTime(apduResolvedServices.get(0));
             for(String resolvedService : apduResolvedServices) {
                 if(getApplicationInstallTime(resolvedService) <= minInstallTime ) {
                     minInstallTime = getApplicationInstallTime(resolvedService);
                     resolvedApduService = resolvedService;
                 }
-                Log.d(TAG, "Install time  of application"+ minInstallTime);
+                Log.e(TAG, " Install time  of application"+ minInstallTime);
             }
 
         } else  resolvedApduService = apduResolvedServices.get(0);
 
-        Log.d(TAG, "Final Resolved Service: " + resolvedApduService);
+        Log.e(TAG, " Final Resolved Service"+resolvedApduService);
         if(resolvedApduService != null) {
-            for(ResolveInfo resolve : intentReceivers) {
+            for(ResolveInfo resolve : intentServices) {
                 if(resolve.activityInfo.packageName.equals(resolvedApduService)) {
-                    unicastPkg = new ComponentName(resolvedApduService, resolve.activityInfo.name);
+                    unicastPkg = new ComponentName(resolvedApduService ,resolve.activityInfo.name);
                     break;
                 }
             }
         }
-        return unicastPkg;
     }
 
-    public ComponentName getUnicastPackage(Intent intent) {
-        return getPackageListUnicastMode(intent);
+    public ComponentName getUnicastPackage() {
+        return unicastPkg;
     }
 
     final class NxpNfcControllerInterface extends INxpNfcController.Stub {
@@ -291,7 +305,7 @@ public class NxpNfcController {
             if(preferredPaymentService != null) {
                 if(preferredPaymentService.getPackageName() != null &&
                     !preferredPaymentService.getPackageName().equals(packageName)) {
-                    Log.d(TAG, "getDefaultOffHostService: unregistered package Name");
+                    Log.d(TAG, "getDefaultOffHostService unregistered package Name");
                     return null;
                 }
                 String defaultservice = preferredPaymentService.getClassName();
diff --git a/res/drawable/ic_weblink_nfc.xml b/res/drawable/ic_weblink_nfc.xml
new file mode 100644
index 00000000..437f9f66
--- /dev/null
+++ b/res/drawable/ic_weblink_nfc.xml
@@ -0,0 +1,20 @@
+<vector android:height="180dp" android:viewportHeight="180.0"
+        android:viewportWidth="180.0" android:width="180dp" xmlns:android="http://schemas.android.com/apk/res/android">
+    <path android:fillColor="#F1F3F4" android:pathData="M90,90m-90,0a90,90 0,1 1,180 0a90,90 0,1 1,-180 0"/>
+    <path android:fillColor="#E0E0E0" android:pathData="M64.2,107.5m-28,0a28,28 0,1 1,56 0a28,28 0,1 1,-56 0"/>
+    <path android:fillColor="#2196F3" android:pathData="M64.2,105.5m-28,0a28,28 0,1 1,56 0a28,28 0,1 1,-56 0"/>
+    <path android:fillColor="#FFFFFF" android:pathData="M74.3,92.4h-21.2c-1.5,0 -2.7,1.2 -2.7,2.6v21.2c0,1.5 1.2,2.7 2.6,2.7h21.2c1.5,0 2.7,-1.2 2.7,-2.6l0.1,-21.3C77,93.6 75.8,92.4 74.3,92.4zM74.3,116.2h-21.2L53.1,95h21.2L74.3,116.2zM71.7,97.7h-6.6c-1.5,0 -2.7,1.2 -2.7,2.6v3c-0.8,0.5 -1.3,1.3 -1.3,2.3c0,1.5 1.2,2.7 2.6,2.7s2.7,-1.2 2.7,-2.6c0,-1 -0.5,-1.8 -1.3,-2.3v-3h4L69.1,111h-10.6v-10.6h2.7v-2.7h-5.3v15.9h15.9L71.7,97.7z"/>
+    <path android:fillColor="#FAC88B" android:pathData="M166.7,137.1c-6.6,-5.9 -13.7,-12.7 -18.6,-18.5c-4.5,-5.4 -6.1,-30.2 -6.1,-30.2c0,-1.8 -0.9,-5.5 -1.4,-5.8c-1.6,-0.9 -3,-0.1 -3.1,1.7l-0.1,0.8c0,0 0.1,2.9 -4.9,0.9l0,0c-0.2,-0.1 -6.3,-3.7 -10.5,-7.7l0,0l-10.9,-10.3l-0.4,-0.4l-26.5,-24.1c-1.9,-1.6 -4,-3 -6,-3.3c-1,-0.1 -2,-0.2 -2.9,0.7l0,0c-0.7,0.7 -0.7,1.4 -0.8,2.1c-0.2,2.2 1.5,4.6 3.2,6.9l23.4,26.9l0.5,0.6l3.2,3.4c0.2,0.2 0.3,0.5 0.2,0.8l-15.4,27c-0.4,0.7 -0.6,1.1 -0.1,1.8c0.6,0.8 2.2,2.9 2.3,3c1.5,1.7 13.2,10.3 34.9,22.1c0.1,0.1 2.8,2.8 2.9,2.9c0,0 0.1,0.1 0.1,0.2c0,0 0,0 -0.1,-0.1c1.2,1.3 6,6.5 12.5,13.3c0.2,0.2 0.4,0.4 0.6,0.7c0.1,0.1 0.1,0.1 0.2,0.2c1.8,1.8 3.7,3.8 5.6,5.8C155.6,152.3 161.8,145.1 166.7,137.1z"/>
+    <path android:fillColor="#FF000000" android:pathData="M86.9,122.3c-2.3,0 -6.1,-0.7 -6.8,-4.9l0,0c0,-0.2 -0.1,-0.4 -0.1,-0.7l0,0c0,-0.4 0,-0.7 0,-1.1l0.6,-77.4c0,-2.1 0.6,-3.7 1.8,-4.9c1.2,-1.1 2.9,-1.7 5.1,-1.7l0,0h0.1l0,0l32.3,0.2c2.2,0 4,0.6 5.1,1.8c1.2,1.1 1.8,2.8 1.7,4.9l-0.6,77.4c0,0.3 0,0.7 0,1.1l0,0c0,0.2 0,0.5 -0.1,0.7l0,0l0,0c-0.7,4.2 -4.6,4.8 -6.9,4.8L86.9,122.3z"/>
+    <path android:fillColor="#FFFFFF" android:pathData="M123.6,114.2l-41.8,-0.6c-0.4,0 -0.8,-0.4 -0.8,-0.8l1,-70.5c0,-0.4 0.4,-0.8 0.8,-0.8l41.9,0.5c0.4,0 0.8,0.4 0.8,0.8l-1,70.5C124.4,113.9 124.1,114.2 123.6,114.2z"/>
+    <path android:fillColor="#939393" android:pathData="M87.6,31.9L87.6,31.9h0.8l0,0l30.7,0.2h0.7h0.1c2.1,0 3.8,0.6 4.9,1.7c1.1,1.1 1.7,2.7 1.7,4.7v0.1v0.6l-0.6,76.7c0,0.4 0,0.7 0,1.1l0,0l0,0c0,0.2 0,0.5 -0.1,0.7l0,0c-0.7,4 -4.4,4.6 -6.6,4.6h-0.1h-0.7l-30.7,-0.3h-0.7h-0.1c-2.2,0 -5.9,-0.6 -6.5,-4.7l0,0c0,-0.2 -0.1,-0.4 -0.1,-0.7l0,0l0,0c0,-0.4 0,-0.7 0,-1.1l0.6,-76.7v-0.6v-0.1c0,-2 0.6,-3.6 1.7,-4.7C83.7,32.4 85.4,31.9 87.6,31.9C87.5,31.9 87.5,31.9 87.6,31.9C87.5,31.9 87.6,31.9 87.6,31.9L87.6,31.9M87.7,31.4L87.7,31.4L87.7,31.4h-0.2l0,0c-2.3,0 -4,0.6 -5.3,1.8c-1.2,1.2 -1.9,2.9 -1.9,5.1v0.1v0.6l-0.6,76.7c0,0.4 0,0.7 0,1.1l0,0l0,0c0,0.2 0,0.5 0.1,0.7l0,0l0,0l0,0l0,0c0.3,1.9 1.3,3.4 3,4.2c1.4,0.7 3,0.9 4.1,0.9h0.1h0.7l30.7,0.2h0.7h0.1c1.1,0 2.7,-0.1 4.1,-0.8c1.7,-0.8 2.7,-2.2 3,-4.2l0,0l0,0l0,0l0,0c0,-0.2 0.1,-0.4 0.1,-0.7l0,0l0,0c0,-0.4 0,-0.7 0,-1.1l0.6,-76.7v-0.6v-0.1c0,-2.2 -0.6,-3.9 -1.8,-5.1c-1.2,-1.2 -3,-1.8 -5.3,-1.8h-0.1h-0.7l-30.7,-0.2l0,0L87.7,31.4L87.7,31.4L87.7,31.4z"/>
+    <path android:fillColor="#2196F3" android:pathData="M111.7,63.9l-16.9,-0.1c-1.2,0 -2.1,0.9 -2.1,2.1l-0.1,16.9c0,1.2 0.9,2.1 2.1,2.1l16.9,0.1c1.2,0 2.1,-0.9 2.1,-2.1l0.1,-16.9C113.8,64.9 112.9,63.9 111.7,63.9zM111.6,83l-16.9,-0.1l0.1,-16.9l16.9,0.1L111.6,83zM109.6,68.1h-5.3c-1.2,0 -2.1,0.9 -2.1,2.1v2.4c-0.6,0.4 -1.1,1 -1.1,1.8c0,1.2 0.9,2.1 2.1,2.1s2.1,-0.9 2.1,-2.1c0,-0.8 -0.4,-1.5 -1,-1.8v-2.4h3.2v8.5h-8.5v-8.5h2.1v-2.1h-4.2l-0.1,12.7l12.7,0.1L109.6,68.1z"/>
+    <path android:fillColor="#E0E0E0" android:pathData="M96.4,91.7c0.6,-0.1 2.3,-0.3 2.7,-3.1c0.4,-2.7 -3.1,-6.4 -4.4,-7.6l-10.9,-10.7c-2.3,-2.1 -7.1,5.9 -4.8,8l13.4,12C93.5,91.4 95,91.8 96.4,91.7z"/>
+    <path android:fillColor="#E0E0E0" android:pathData="M95.3,101.7c0.6,-0.1 2.3,-0.3 2.7,-3.1c0.4,-2.7 -3.1,-6.4 -4.4,-7.6l-10.9,-10.7c-2.3,-2.1 -6.7,5.5 -4.4,7.6l13,12.4C92.5,101.4 93.9,101.8 95.3,101.7z"/>
+    <path android:fillColor="#E0E0E0" android:pathData="M76.1,87.2c-0.4,0 2.1,8.2 3.5,12.7c0.4,1.3 1.1,4.4 1.1,4.4c2,2.5 6,5.4 8.3,3.2s1.2,-5.6 -0.8,-8l-7.5,-10.2C79.7,88 77.5,87.3 76.1,87.2z"/>
+    <path android:fillColor="#FAC88B" android:pathData="M136.6,114.6l4.4,-23.2c0,0 3,-6.7 -0.9,-10.3c-3.9,-3.6 -14.4,-18.2 -14.4,-18.2s-6.7,-9.6 -11.5,-4.1c-2.9,3.3 3.1,11.1 3.1,11.1l8.5,14.4c-6.1,14.2 -5.7,26 1.5,36.1C127.4,120.4 132.6,125.3 136.6,114.6z"/>
+    <path android:fillColor="#FFCC80" android:pathData="M96.5,91c0.6,-0.1 2.3,-0.3 2.7,-3.1c0.4,-2.7 -3.1,-6.4 -4.4,-7.6l-10.8,-10.7c-2.3,-2.1 -6.7,-4.3 -8.6,-1.8c-2,2.5 -0.4,5.7 1.9,7.8l15.3,14.1C93.7,90.7 95.1,91.2 96.5,91z"/>
+    <path android:fillColor="#FFCC80" android:pathData="M95.3,100.9c0.6,-0.1 2.3,-0.3 2.7,-3.1c0.4,-2.7 -3.1,-6.4 -4.4,-7.6l-10.8,-10.7c-2.3,-2.1 -6.7,-4.3 -8.6,-1.8c-2,2.5 -0.4,5.7 1.9,7.8l15.3,14.1C92.5,100.6 93.9,101 95.3,100.9z"/>
+    <path android:fillColor="#FFCC80" android:pathData="M76.1,86.4c-0.6,0 -2.3,0 -3.1,2.7c-0.8,2.6 2.1,6.8 3.3,8.3l4.4,6.2c2,2.5 6,5.4 8.3,3.2c2.3,-2.2 1.2,-5.6 -0.8,-8l-7.5,-10.2C79.8,87.3 77.5,86.5 76.1,86.4z"/>
+</vector>
+
diff --git a/res/layout/url_open_confirmation.xml b/res/layout/url_open_confirmation.xml
new file mode 100644
index 00000000..5c2e437a
--- /dev/null
+++ b/res/layout/url_open_confirmation.xml
@@ -0,0 +1,36 @@
+<LinearLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:gravity="start"
+    android:layout_width="wrap_content"
+    android:layout_height="400dp"
+    android:orientation="vertical"
+    android:paddingTop="24dp"
+    android:paddingStart="24dp"
+    android:paddingEnd="24dp">
+    <TextView
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:textAlignment="viewStart"
+        android:paddingBottom="24dp"
+        android:text="@string/summary_confirm_url_open"
+        android:textColor="?android:attr/textColorPrimaryInverse"/>
+    <TextView
+        android:id="@+id/url_open_confirmation_link"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:textAlignment="viewStart"
+        android:textColor="?android:attr/colorAccent"/>
+    <FrameLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:paddingTop="24dp"
+        android:paddingBottom="24dp">
+        <ImageView
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center"
+            android:src="@drawable/ic_weblink_nfc"/>
+    </FrameLayout>
+
+</LinearLayout>
+
diff --git a/res/values-af/live_cases.xml b/res/values-af/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-af/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-af/provisioning.xml b/res/values-af/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-af/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-am/live_cases.xml b/res/values-am/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-am/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-am/provisioning.xml b/res/values-am/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-am/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-ar/live_cases.xml b/res/values-ar/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-ar/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-ar/provisioning.xml b/res/values-ar/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-ar/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-az/live_cases.xml b/res/values-az/live_cases.xml
deleted file mode 100644
index 653ad14e..00000000
--- a/res/values-az/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"NövA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-az/provisioning.xml b/res/values-az/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-az/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-b+sr+Latn/live_cases.xml b/res/values-b+sr+Latn/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-b+sr+Latn/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-b+sr+Latn/provisioning.xml b/res/values-b+sr+Latn/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-b+sr+Latn/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-be/live_cases.xml b/res/values-be/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-be/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-be/provisioning.xml b/res/values-be/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-be/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-bg/live_cases.xml b/res/values-bg/live_cases.xml
deleted file mode 100644
index c0d512bc..00000000
--- a/res/values-bg/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"Тип A"</item>
-  </string-array>
-</resources>
diff --git a/res/values-bg/provisioning.xml b/res/values-bg/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-bg/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-bn/live_cases.xml b/res/values-bn/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-bn/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-bn/provisioning.xml b/res/values-bn/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-bn/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-bs/live_cases.xml b/res/values-bs/live_cases.xml
deleted file mode 100644
index b6cb9ae4..00000000
--- a/res/values-bs/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TipA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-bs/provisioning.xml b/res/values-bs/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-bs/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-ca/live_cases.xml b/res/values-ca/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-ca/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-ca/provisioning.xml b/res/values-ca/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-ca/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-cs/live_cases.xml b/res/values-cs/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-cs/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-cs/provisioning.xml b/res/values-cs/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-cs/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-da/live_cases.xml b/res/values-da/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-da/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-da/provisioning.xml b/res/values-da/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-da/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-de/live_cases.xml b/res/values-de/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-de/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-de/provisioning.xml b/res/values-de/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-de/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-el/live_cases.xml b/res/values-el/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-el/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-el/provisioning.xml b/res/values-el/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-el/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-en-rAU/live_cases.xml b/res/values-en-rAU/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-en-rAU/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-en-rAU/provisioning.xml b/res/values-en-rAU/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-en-rAU/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-en-rGB/live_cases.xml b/res/values-en-rGB/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-en-rGB/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-en-rGB/provisioning.xml b/res/values-en-rGB/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-en-rGB/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-en-rIN/live_cases.xml b/res/values-en-rIN/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-en-rIN/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-en-rIN/provisioning.xml b/res/values-en-rIN/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-en-rIN/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-es-rUS/live_cases.xml b/res/values-es-rUS/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-es-rUS/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-es-rUS/provisioning.xml b/res/values-es-rUS/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-es-rUS/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-es/live_cases.xml b/res/values-es/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-es/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-es/provisioning.xml b/res/values-es/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-es/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-et/live_cases.xml b/res/values-et/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-et/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-et/provisioning.xml b/res/values-et/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-et/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-eu/live_cases.xml b/res/values-eu/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-eu/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-eu/provisioning.xml b/res/values-eu/provisioning.xml
deleted file mode 100644
index bc2afcb9..00000000
--- a/res/values-eu/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"aplikazioa/com.android.kudeatutakohorniketa"</item>
-  </string-array>
-</resources>
diff --git a/res/values-fa/live_cases.xml b/res/values-fa/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-fa/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-fa/provisioning.xml b/res/values-fa/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-fa/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-fi/live_cases.xml b/res/values-fi/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-fi/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-fi/provisioning.xml b/res/values-fi/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-fi/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-fr-rCA/live_cases.xml b/res/values-fr-rCA/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-fr-rCA/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-fr-rCA/provisioning.xml b/res/values-fr-rCA/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-fr-rCA/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-fr/live_cases.xml b/res/values-fr/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-fr/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-fr/provisioning.xml b/res/values-fr/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-fr/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-gl/live_cases.xml b/res/values-gl/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-gl/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-gl/provisioning.xml b/res/values-gl/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-gl/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-gu/live_cases.xml b/res/values-gu/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-gu/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-gu/provisioning.xml b/res/values-gu/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-gu/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-hi/live_cases.xml b/res/values-hi/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-hi/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-hi/provisioning.xml b/res/values-hi/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-hi/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-hr/live_cases.xml b/res/values-hr/live_cases.xml
deleted file mode 100644
index 97733dd8..00000000
--- a/res/values-hr/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"Vrsta A"</item>
-  </string-array>
-</resources>
diff --git a/res/values-hr/provisioning.xml b/res/values-hr/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-hr/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-hu/live_cases.xml b/res/values-hu/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-hu/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-hu/provisioning.xml b/res/values-hu/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-hu/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-hy/live_cases.xml b/res/values-hy/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-hy/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-hy/provisioning.xml b/res/values-hy/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-hy/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-in/live_cases.xml b/res/values-in/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-in/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-in/provisioning.xml b/res/values-in/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-in/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-is/live_cases.xml b/res/values-is/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-is/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-is/provisioning.xml b/res/values-is/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-is/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-it/live_cases.xml b/res/values-it/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-it/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-it/provisioning.xml b/res/values-it/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-it/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-iw/live_cases.xml b/res/values-iw/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-iw/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-iw/provisioning.xml b/res/values-iw/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-iw/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-ja/live_cases.xml b/res/values-ja/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-ja/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-ja/provisioning.xml b/res/values-ja/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-ja/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-ka/live_cases.xml b/res/values-ka/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-ka/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-ka/provisioning.xml b/res/values-ka/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-ka/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-kk/live_cases.xml b/res/values-kk/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-kk/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-kk/provisioning.xml b/res/values-kk/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-kk/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-km/live_cases.xml b/res/values-km/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-km/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-km/provisioning.xml b/res/values-km/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-km/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-kn/live_cases.xml b/res/values-kn/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-kn/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-kn/provisioning.xml b/res/values-kn/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-kn/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-ko/live_cases.xml b/res/values-ko/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-ko/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-ko/provisioning.xml b/res/values-ko/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-ko/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-ky/live_cases.xml b/res/values-ky/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-ky/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-ky/provisioning.xml b/res/values-ky/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-ky/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-lo/live_cases.xml b/res/values-lo/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-lo/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-lo/provisioning.xml b/res/values-lo/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-lo/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-lt/live_cases.xml b/res/values-lt/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-lt/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-lt/provisioning.xml b/res/values-lt/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-lt/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-lv/live_cases.xml b/res/values-lv/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-lv/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-lv/provisioning.xml b/res/values-lv/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-lv/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-mk/live_cases.xml b/res/values-mk/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-mk/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-mk/provisioning.xml b/res/values-mk/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-mk/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-ml/live_cases.xml b/res/values-ml/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-ml/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-ml/provisioning.xml b/res/values-ml/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-ml/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-mn/live_cases.xml b/res/values-mn/live_cases.xml
deleted file mode 100644
index 26234dc7..00000000
--- a/res/values-mn/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"Aтөрөл"</item>
-  </string-array>
-</resources>
diff --git a/res/values-mn/provisioning.xml b/res/values-mn/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-mn/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-mr/live_cases.xml b/res/values-mr/live_cases.xml
deleted file mode 100644
index 4d37b7c5..00000000
--- a/res/values-mr/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"प्रकारA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-mr/provisioning.xml b/res/values-mr/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-mr/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-ms/live_cases.xml b/res/values-ms/live_cases.xml
deleted file mode 100644
index 5660f974..00000000
--- a/res/values-ms/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"JenisA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-ms/provisioning.xml b/res/values-ms/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-ms/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-my/live_cases.xml b/res/values-my/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-my/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-my/provisioning.xml b/res/values-my/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-my/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-nb/live_cases.xml b/res/values-nb/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-nb/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-nb/provisioning.xml b/res/values-nb/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-nb/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-ne/live_cases.xml b/res/values-ne/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-ne/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-ne/provisioning.xml b/res/values-ne/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-ne/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-nl/live_cases.xml b/res/values-nl/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-nl/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-nl/provisioning.xml b/res/values-nl/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-nl/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-pa/live_cases.xml b/res/values-pa/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-pa/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-pa/provisioning.xml b/res/values-pa/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-pa/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-pl/live_cases.xml b/res/values-pl/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-pl/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-pl/provisioning.xml b/res/values-pl/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-pl/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-pt-rPT/live_cases.xml b/res/values-pt-rPT/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-pt-rPT/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-pt-rPT/provisioning.xml b/res/values-pt-rPT/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-pt-rPT/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-pt/live_cases.xml b/res/values-pt/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-pt/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-pt/provisioning.xml b/res/values-pt/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-pt/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-ro/live_cases.xml b/res/values-ro/live_cases.xml
deleted file mode 100644
index b6cb9ae4..00000000
--- a/res/values-ro/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TipA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-ro/provisioning.xml b/res/values-ro/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-ro/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-ru/live_cases.xml b/res/values-ru/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-ru/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-ru/provisioning.xml b/res/values-ru/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-ru/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-si/live_cases.xml b/res/values-si/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-si/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-si/provisioning.xml b/res/values-si/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-si/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-sk/live_cases.xml b/res/values-sk/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-sk/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-sk/provisioning.xml b/res/values-sk/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-sk/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-sl/live_cases.xml b/res/values-sl/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-sl/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-sl/provisioning.xml b/res/values-sl/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-sl/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-sq/live_cases.xml b/res/values-sq/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-sq/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-sq/provisioning.xml b/res/values-sq/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-sq/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-sr/live_cases.xml b/res/values-sr/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-sr/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-sr/provisioning.xml b/res/values-sr/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-sr/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-sv/live_cases.xml b/res/values-sv/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-sv/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-sv/provisioning.xml b/res/values-sv/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-sv/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-sw/live_cases.xml b/res/values-sw/live_cases.xml
deleted file mode 100644
index 99adcd70..00000000
--- a/res/values-sw/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"Aina ya A"</item>
-  </string-array>
-</resources>
diff --git a/res/values-sw/provisioning.xml b/res/values-sw/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-sw/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-ta/live_cases.xml b/res/values-ta/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-ta/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-ta/provisioning.xml b/res/values-ta/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-ta/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-te/live_cases.xml b/res/values-te/live_cases.xml
deleted file mode 100644
index 66f8114f..00000000
--- a/res/values-te/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"రకంA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-te/provisioning.xml b/res/values-te/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-te/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-th/live_cases.xml b/res/values-th/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-th/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-th/provisioning.xml b/res/values-th/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-th/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-tl/live_cases.xml b/res/values-tl/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-tl/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-tl/provisioning.xml b/res/values-tl/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-tl/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-tr/live_cases.xml b/res/values-tr/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-tr/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-tr/provisioning.xml b/res/values-tr/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-tr/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-uk/live_cases.xml b/res/values-uk/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-uk/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-uk/provisioning.xml b/res/values-uk/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-uk/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-ur/live_cases.xml b/res/values-ur/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-ur/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-ur/provisioning.xml b/res/values-ur/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-ur/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-uz/live_cases.xml b/res/values-uz/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-uz/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-uz/provisioning.xml b/res/values-uz/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-uz/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-vi/live_cases.xml b/res/values-vi/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-vi/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-vi/provisioning.xml b/res/values-vi/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-vi/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-watch/drawables.xml b/res/values-watch/drawables.xml
new file mode 100644
index 00000000..3cb941fa
--- /dev/null
+++ b/res/values-watch/drawables.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <item name="icon" type="drawable">@*android:drawable/sym_def_app_icon</item>
+</resources>
diff --git a/res/values-zh-rCN/live_cases.xml b/res/values-zh-rCN/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-zh-rCN/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-zh-rCN/provisioning.xml b/res/values-zh-rCN/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-zh-rCN/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-zh-rHK/live_cases.xml b/res/values-zh-rHK/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-zh-rHK/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-zh-rHK/provisioning.xml b/res/values-zh-rHK/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-zh-rHK/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-zh-rTW/live_cases.xml b/res/values-zh-rTW/live_cases.xml
deleted file mode 100644
index 0705e983..00000000
--- a/res/values-zh-rTW/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"TypeA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-zh-rTW/provisioning.xml b/res/values-zh-rTW/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-zh-rTW/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values-zu/live_cases.xml b/res/values-zu/live_cases.xml
deleted file mode 100644
index c3981c57..00000000
--- a/res/values-zu/live_cases.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="live_case_mime_types">
-    <item msgid="7603834493079256643">"application/vnd.google.android.apps.workshop"</item>
-    <item msgid="2377974536673049053">"application/vnd.google.android.apps.live_case"</item>
-  </string-array>
-  <string-array name="live_case_tag_types">
-    <item msgid="3541804405299652565">"UhloboA"</item>
-  </string-array>
-</resources>
diff --git a/res/values-zu/provisioning.xml b/res/values-zu/provisioning.xml
deleted file mode 100644
index efcee844..00000000
--- a/res/values-zu/provisioning.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--  Copyright (C) 2013 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
- -->
-
-<!--  NFC resources that may need to be customized
-     for different hardware or product builds.  -->
-
-<resources xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-  <string-array name="provisioning_mime_types">
-    <item msgid="3675637130021393293">"application/com.android.managedprovisioning"</item>
-  </string-array>
-</resources>
diff --git a/res/values/config.xml b/res/values/config.xml
new file mode 100644
index 00000000..be3a5a2d
--- /dev/null
+++ b/res/values/config.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="bluetooth_package" translatable="false">com.android.bluetooth</string>
+    <bool name="enable_nfc_url_open_dialog">false</bool>
+</resources>
+
diff --git a/res/values/live_cases.xml b/res/values/live_cases.xml
index fc22b21f..d5c9d48f 100644
--- a/res/values/live_cases.xml
+++ b/res/values/live_cases.xml
@@ -22,7 +22,7 @@
 
     <!-- The accepted mime-types when NFC is enabled at locked screen.
          Mime-types must be lower case, wildcards are *not* accepted. -->
-    <string-array name="live_case_mime_types">
+    <string-array name="live_case_mime_types" translatable="false">
         <item>application/vnd.google.android.apps.workshop</item>
         <item>application/vnd.google.android.apps.live_case</item>
     </string-array>
@@ -30,7 +30,7 @@
     <!-- The accepted tag technology types which will be detected for live case
          NFC at lock screen. Mime-types must be lower case, wildcards are *not*
          accepted. -->
-    <string-array name="live_case_tag_types">
+    <string-array name="live_case_tag_types" translatable="false">
         <item>TypeA</item>
     </string-array>
 </resources>
diff --git a/res/values/provisioning.xml b/res/values/provisioning.xml
index 8253b09b..e14deab5 100644
--- a/res/values/provisioning.xml
+++ b/res/values/provisioning.xml
@@ -22,7 +22,7 @@
 
     <!-- The accepted mime-types when NFC is enabled in setup wizard.
          Mime-types must be lower case, wildcards are *not* accepted. -->
-    <string-array name="provisioning_mime_types">
+    <string-array name="provisioning_mime_types" translatable="false">
         <item>application/com.android.managedprovisioning</item>
     </string-array>
 </resources>
diff --git a/res/values/strings.xml b/res/values/strings.xml
index 153510ff..13092f0c 100644
--- a/res/values/strings.xml
+++ b/res/values/strings.xml
@@ -92,4 +92,17 @@
 
     <!-- Used to refer to in the Share Menu Android Beam . This phrase is a trademark. [CHAR LIMIT=32] -->
     <string name="android_beam">Android Beam</string>
+
+    <!-- Message shown in a toast when user wants to Beam a file, but application doesn't have required permission -->
+    <string name="beam_requires_external_storage_permission">Application does not have External Storage Permission. This is required to Beam this file</string>
+
+    <!-- Strings for a dialog informing the user a URL was read from an NFC tag, and allowing confirmation that they want to open it -->
+    <!-- Title of the dialog -->
+    <string name="title_confirm_url_open">Open link?</string>
+    <!-- Summary text appearing before the URL -->
+    <string name="summary_confirm_url_open" product="tablet">Your tablet received a link through NFC:</string>
+    <string name="summary_confirm_url_open" product="default">Your phone received a link through NFC:</string>
+    <!-- Label for the button which causes the URL to be opened -->
+    <string name="action_confirm_url_open">Open link</string>
+
 </resources>
diff --git a/src/com/android/nfc/BeamShareActivity.java b/src/com/android/nfc/BeamShareActivity.java
index 4cc29b00..446e499a 100644
--- a/src/com/android/nfc/BeamShareActivity.java
+++ b/src/com/android/nfc/BeamShareActivity.java
@@ -41,6 +41,7 @@ import android.util.Log;
 import android.util.EventLog;
 import android.webkit.URLUtil;
 import android.Manifest.permission;
+import android.widget.Toast;
 
 import com.android.internal.R;
 
@@ -222,6 +223,9 @@ public class BeamShareActivity extends Activity {
                     if (uri.getScheme().equalsIgnoreCase("file") &&
                             getApplicationContext().checkPermission(permission.READ_EXTERNAL_STORAGE, -1, uid) !=
                             PackageManager.PERMISSION_GRANTED) {
+                        Toast.makeText(getApplicationContext(),
+                                        com.android.nfc.R.string.beam_requires_external_storage_permission,
+                                        Toast.LENGTH_SHORT).show();
                         Log.e(TAG, "File based Uri doesn't have External Storage Permission.");
                         EventLog.writeEvent(0x534e4554, "37287958", uid, uri.getPath());
                         break;
diff --git a/src/com/android/nfc/ConfirmConnectToWifiNetworkActivity.java b/src/com/android/nfc/ConfirmConnectToWifiNetworkActivity.java
index dc539e77..4734f04c 100644
--- a/src/com/android/nfc/ConfirmConnectToWifiNetworkActivity.java
+++ b/src/com/android/nfc/ConfirmConnectToWifiNetworkActivity.java
@@ -122,6 +122,7 @@ public class ConfirmConnectToWifiNetworkActivity extends Activity
 
     @Override
     protected void onDestroy() {
+        mAlertDialog.dismiss();
         ConfirmConnectToWifiNetworkActivity.this.unregisterReceiver(mBroadcastReceiver);
         super.onDestroy();
     }
diff --git a/src/com/android/nfc/DeviceHost.java b/src/com/android/nfc/DeviceHost.java
old mode 100644
new mode 100755
index adb4cedb..7a4d0840
--- a/src/com/android/nfc/DeviceHost.java
+++ b/src/com/android/nfc/DeviceHost.java
@@ -17,7 +17,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -38,6 +38,7 @@ import android.annotation.Nullable;
 import android.nfc.NdefMessage;
 import android.os.Bundle;
 
+import java.io.FileDescriptor;
 import java.io.IOException;
 
 public interface DeviceHost {
@@ -49,11 +50,6 @@ public interface DeviceHost {
          */
         public void onCardEmulationDeselected();
 
-        /**
-         * Notifies transaction
-         */
-        public void onCardEmulationAidSelected(byte[] aid,byte[] data, int evtSrc);
-
         /**
          * Notifies connectivity event from the SE
          */
@@ -111,11 +107,9 @@ public interface DeviceHost {
         /**
          * Notifies SWP Reader Events.
          */
-        public void onSWPReaderRequestedEvent(boolean istechA, boolean istechB);
+        public void onETSIReaderRequestedEvent(boolean istechA, boolean istechB);
 
-        public void onSWPReaderRequestedFail(int FailCause);
-
-        public void onSWPReaderActivatedEvent();
+        public void onETSIReaderRequestedFail(int FailCause);
 
         public void onETSIReaderModeStartConfig(int eeHandle);
 
@@ -123,7 +117,11 @@ public interface DeviceHost {
 
         public void onETSIReaderModeSwpTimeout(int disc_ntf_timeout);
 
+        public void onETSIReaderModeRestart();
+
         public void onUiccStatusEvent(int uiccStat);
+
+        public void onNfcTransactionEvent(byte[] aid, byte[] data, String seName);
     }
 
     public interface TagEndpoint {
@@ -135,6 +133,7 @@ public interface DeviceHost {
         boolean isPresent();
         void startPresenceChecking(int presenceCheckDelay,
                                    @Nullable TagDisconnectedCallback callback);
+        void stopPresenceChecking();
 
         int[] getTechList();
         void removeTechnology(int tech); // TODO remove this one
@@ -272,6 +271,8 @@ public interface DeviceHost {
 
     public void doSelectSecureElement(int seID);
 
+    public void doActivateSecureElement(int seID);
+
     public void doSetSecureElementListenTechMask(int tech_mask);
     public int doGetSecureElementTechList();
 
@@ -334,6 +335,8 @@ public interface DeviceHost {
 
     public boolean unrouteApduPattern(byte[] apduData);
 
+    public int doNfcSelfTest(int type);
+
     public boolean doCheckLlcp();
 
     public boolean doCheckJcopDlAtBoot();
@@ -368,7 +371,7 @@ public interface DeviceHost {
 
     int getChipVer();
 
-    byte[] getFwFileName();
+    int setTransitConfig(String configs);
 
     int getNfcInitTimeout();
 
@@ -376,7 +379,7 @@ public interface DeviceHost {
 
     void doSetNfcMode(int nfcMode);
 
-    String dump();
+    void dump(FileDescriptor fd);
 
     boolean enableScreenOffSuspend();
 
@@ -398,6 +401,14 @@ public interface DeviceHost {
 
     void etsiInitConfig();
 
+    void stopPoll(int mode);
+
+    void startPoll();
+
+    int mposSetReaderMode(boolean on);
+
+    boolean mposGetReaderMode();
+
     void updateScreenState();
     //boolean enableReaderMode(int technologies);
 
@@ -437,11 +448,13 @@ public interface DeviceHost {
 
     public void shutdown();
 
-    public byte[] getAdditionalConfigOptions();
-
     public int doselectUicc(int uiccSlot);
 
     public int doGetSelectedUicc();
 
     public int setPreferredSimSlot(int uiccSlot);
+
+    public byte[] readerPassThruMode(byte status, byte modulationTyp);
+
+    public byte[] transceiveAppData(byte[] data);
 }
diff --git a/src/com/android/nfc/DtaServiceConnector.java b/src/com/android/nfc/DtaServiceConnector.java
old mode 100644
new mode 100755
index b8eb927b..c3a6fc0b
--- a/src/com/android/nfc/DtaServiceConnector.java
+++ b/src/com/android/nfc/DtaServiceConnector.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 NXP Semiconductors
+ * Copyright (C) 2017-2018 NXP Semiconductors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -32,18 +32,22 @@ import android.os.RemoteException;
 
 public class DtaServiceConnector {
 
+
+    private static String sMessageService;
     Context mContext;
     Messenger dtaMessenger = null;
     boolean isBound;
 
+
     public DtaServiceConnector(Context mContext) {
         this.mContext = mContext;
     }
 
     public void bindService() {
-        if(!isBound){
-        Intent intent = new Intent("com.phdtaui.messageservice.ACTION_BIND");
-        mContext.bindService(createExplicitFromImplicitIntent(mContext,intent), myConnection,Context.BIND_AUTO_CREATE);
+        if (!isBound) {
+            Intent intent = new Intent(sMessageService);
+            mContext.bindService(createExplicitFromImplicitIntent(mContext,intent),
+                                   myConnection,Context.BIND_AUTO_CREATE);
         }
     }
 
@@ -60,7 +64,7 @@ public class DtaServiceConnector {
     };
 
     public void sendMessage(String ndefMessage) {
-        if(!isBound)return;
+        if (!isBound) return;
         Message msg = Message.obtain();
         Bundle bundle = new Bundle();
         bundle.putString("NDEF_MESSAGE", ndefMessage);
@@ -69,16 +73,16 @@ public class DtaServiceConnector {
             dtaMessenger.send(msg);
         } catch (RemoteException e) {
             e.printStackTrace();
-        }catch (NullPointerException e) {
+        } catch (NullPointerException e) {
             e.printStackTrace();
-    }
+        }
     }
 
-    public static Intent createExplicitFromImplicitIntent(Context context, Intent implicitIntent){
+    public static Intent createExplicitFromImplicitIntent(Context context, Intent implicitIntent) {
         PackageManager pm = context.getPackageManager();
         List<ResolveInfo> resolveInfo = pm.queryIntentServices(implicitIntent, 0);
         if (resolveInfo == null || resolveInfo.size() != 1) {
-        return null;
+            return null;
         }
         ResolveInfo serviceInfo = resolveInfo.get(0);
         String packageName = serviceInfo.serviceInfo.packageName;
@@ -89,4 +93,8 @@ public class DtaServiceConnector {
         return explicitIntent;
     }
 
+    public static void setMessageService(String service) {
+        sMessageService = service;
+    }
+
 }
diff --git a/src/com/android/nfc/NfcApplication.java b/src/com/android/nfc/NfcApplication.java
index f72988d5..6210c2d6 100644
--- a/src/com/android/nfc/NfcApplication.java
+++ b/src/com/android/nfc/NfcApplication.java
@@ -43,8 +43,6 @@ public class NfcApplication extends Application {
         super.onCreate();
         PackageManager pm = getApplicationContext().getPackageManager();
         if (!pm.hasSystemFeature(PackageManager.FEATURE_NFC_ANY)) {
-            pm.setApplicationEnabledSetting(getApplicationContext().getPackageName(),
-                PackageManager.COMPONENT_ENABLED_STATE_DISABLED, 0);
                 return;
         }
 
diff --git a/src/com/android/nfc/NfcBootCompletedReceiver.java b/src/com/android/nfc/NfcBootCompletedReceiver.java
new file mode 100644
index 00000000..6827a91c
--- /dev/null
+++ b/src/com/android/nfc/NfcBootCompletedReceiver.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.nfc;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+
+/**
+ * Boot completed receiver. used to disable the application if the device doesn't
+ * support NFC when device boots.
+ *
+ */
+public class NfcBootCompletedReceiver extends BroadcastReceiver {
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        String action = intent.getAction();
+
+        if (Intent.ACTION_BOOT_COMPLETED.equals(action)) {
+            PackageManager pm = context.getPackageManager();
+            if (!pm.hasSystemFeature(PackageManager.FEATURE_NFC_ANY)) {
+                pm.setApplicationEnabledSetting(context.getPackageName(),
+                    PackageManager.COMPONENT_ENABLED_STATE_DISABLED, 0);
+            }
+        }
+    }
+}
+
diff --git a/src/com/android/nfc/NfcDispatcher.java b/src/com/android/nfc/NfcDispatcher.java
old mode 100644
new mode 100755
index fc42df20..6fb6948d
--- a/src/com/android/nfc/NfcDispatcher.java
+++ b/src/com/android/nfc/NfcDispatcher.java
@@ -16,21 +16,24 @@
 
 package com.android.nfc;
 
+import android.Manifest;
 import android.bluetooth.BluetoothAdapter;
 import android.os.UserManager;
-
 import com.android.nfc.RegisteredComponentCache.ComponentInfo;
 import com.android.nfc.handover.HandoverDataParser;
 import com.android.nfc.handover.PeripheralHandoverService;
 
 import android.app.Activity;
 import android.app.ActivityManager;
+import android.app.AlertDialog;
 import android.app.IActivityManager;
 import android.app.PendingIntent;
 import android.app.PendingIntent.CanceledException;
+import android.content.BroadcastReceiver;
 import android.content.ComponentName;
 import android.content.ContentResolver;
 import android.content.Context;
+import android.content.DialogInterface;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.pm.PackageManager;
@@ -44,17 +47,26 @@ import android.nfc.NfcAdapter;
 import android.nfc.Tag;
 import android.nfc.tech.Ndef;
 import android.nfc.tech.NfcBarcode;
+import android.os.Handler;
+import android.os.Message;
+import android.os.Messenger;
 import android.os.RemoteException;
 import android.os.UserHandle;
 import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.WindowManager;
+import android.widget.TextView;
 
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.Locale;
 
 /**
  * Dispatch of NFC events to start activities
@@ -77,6 +89,9 @@ class NfcDispatcher {
     private final ScreenStateHelper mScreenStateHelper;
     private final NfcUnlockManager mNfcUnlockManager;
     private final boolean mDeviceSupportsBluetooth;
+    private final Handler mMessageHandler = new MessageHandler();
+    private final Messenger mMessenger = new Messenger(mMessageHandler);
+    private AtomicBoolean mBluetoothEnabledByNfc = new AtomicBoolean();
 
     // Locked on this
     private PendingIntent mOverrideIntent;
@@ -124,6 +139,15 @@ class NfcDispatcher {
             }
         }
         mLiveCaseMimes = liveCaseMimes;
+
+        IntentFilter filter = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
+        mContext.registerReceiver(mBluetoothStatusReceiver, filter);
+    }
+
+    @Override
+    protected void finalize() throws Throwable {
+        mContext.unregisterReceiver(mBluetoothStatusReceiver);
+        super.finalize();
     }
 
     public synchronized void setForegroundDispatch(PendingIntent intent,
@@ -197,6 +221,16 @@ class NfcDispatcher {
             return intent;
         }
 
+        public boolean isWebIntent() {
+            if (ndefUri == null) return false;
+            if (ndefUri.normalizeScheme().getScheme() == null) return false;
+            return ndefUri != null && ndefUri.normalizeScheme().getScheme().startsWith("http");
+        }
+
+        public String getUri() {
+            return ndefUri.toString();
+        }
+
         /**
          * Launch the activity via a (single) NFC root task, so that it
          * creates a new task stack instead of interfering with any existing
@@ -393,7 +427,7 @@ class NfcDispatcher {
         // All tags of NfcBarcode technology and Kovio type have lengths of a multiple of 16 bytes
         if (tagId.length >= 4
                 && (tagId[1] == URI_PREFIX_HTTP_WWW || tagId[1] == URI_PREFIX_HTTPS_WWW
-                    || tagId[1] == URI_PREFIX_HTTP || tagId[1] == URI_PREFIX_HTTPS)) {
+                || tagId[1] == URI_PREFIX_HTTP || tagId[1] == URI_PREFIX_HTTPS)) {
             // Look for optional URI terminator (0xfe), used to indicate the end of a URI prior to
             // the end of the full NfcBarcode payload. No terminator means that the URI occupies the
             // entire length of the payload field. Exclude checking the CRC in the final two bytes
@@ -535,6 +569,13 @@ class NfcDispatcher {
 
         // regular launch
         dispatch.intent.setPackage(null);
+
+        if (dispatch.isWebIntent()) {
+            if (DBG) Log.i(TAG, "matched Web link - prompting user");
+            showWebLinkConfirmation(dispatch);
+            return true;
+        }
+
         if (dispatch.tryStartActivity()) {
             if (DBG) Log.i(TAG, "matched NDEF");
             return true;
@@ -635,12 +676,13 @@ class NfcDispatcher {
         if (handover.btClass != null) {
             intent.putExtra(PeripheralHandoverService.EXTRA_PERIPHERAL_CLASS, handover.btClass);
         }
+        intent.putExtra(PeripheralHandoverService.EXTRA_BT_ENABLED, mBluetoothEnabledByNfc.get());
+        intent.putExtra(PeripheralHandoverService.EXTRA_CLIENT, mMessenger);
         mContext.startServiceAsUser(intent, UserHandle.CURRENT);
 
         return true;
     }
 
-
     /**
      * Tells the ActivityManager to resume allowing app switches.
      *
@@ -705,6 +747,33 @@ class NfcDispatcher {
         return enabled;
     }
 
+    void showWebLinkConfirmation(DispatchInfo dispatch) {
+        if (!mContext.getResources().getBoolean(R.bool.enable_nfc_url_open_dialog)) {
+            dispatch.tryStartActivity();
+            return;
+        }
+        AlertDialog.Builder builder = new AlertDialog.Builder(
+                mContext.getApplicationContext(),
+                android.R.style.Theme_DeviceDefault_Light_Dialog_Alert);
+        builder.setTitle(R.string.title_confirm_url_open);
+        LayoutInflater inflater = LayoutInflater.from(mContext);
+        View view = inflater.inflate(R.layout.url_open_confirmation, null);
+        if (view != null) {
+            TextView url = view.findViewById(R.id.url_open_confirmation_link);
+            if (url != null) {
+                url.setText(dispatch.getUri());
+            }
+            builder.setView(view);
+        }
+        builder.setNegativeButton(R.string.cancel, (dialog, which) -> {});
+        builder.setPositiveButton(R.string.action_confirm_url_open, (dialog, which) -> {
+            dispatch.tryStartActivity();
+        });
+        AlertDialog dialog = builder.create();
+        dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
+        dialog.show();
+    }
+
     void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
         synchronized (this) {
             pw.println("mOverrideIntent=" + mOverrideIntent);
@@ -712,4 +781,38 @@ class NfcDispatcher {
             pw.println("mOverrideTechLists=" + mOverrideTechLists);
         }
     }
+
+    private class MessageHandler extends Handler {
+        @Override
+        public void handleMessage(Message msg) {
+            if (DBG) Log.d(TAG, "handleMessage: msg=" + msg);
+
+            switch (msg.what) {
+                case PeripheralHandoverService.MSG_HEADSET_CONNECTED:
+                case PeripheralHandoverService.MSG_HEADSET_NOT_CONNECTED:
+                    mBluetoothEnabledByNfc.set(msg.arg1 != 0);
+                    break;
+                default:
+                    break;
+            }
+        }
+    }
+
+    final BroadcastReceiver mBluetoothStatusReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            if (action.equals(BluetoothAdapter.ACTION_STATE_CHANGED)) {
+                handleBluetoothStateChanged(intent);
+            }
+        }
+
+        private void handleBluetoothStateChanged(Intent intent) {
+            int state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE,
+                    BluetoothAdapter.ERROR);
+            if (state == BluetoothAdapter.STATE_OFF) {
+                mBluetoothEnabledByNfc.set(false);
+            }
+        }
+    };
 }
diff --git a/src/com/android/nfc/NfcService.java b/src/com/android/nfc/NfcService.java
index 39b7e8de..42ef7981 100644
--- a/src/com/android/nfc/NfcService.java
+++ b/src/com/android/nfc/NfcService.java
@@ -2,7 +2,7 @@
  * Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.
  * Not a Contribution.
  *
- * Copyright (C) 2015 NXP Semiconductors
+ * Copyright (C) 2015-2018 NXP Semiconductors
  * The original Work has been changed by NXP Semiconductors.
  * Copyright (C) 2010 The Android Open Source Project
  *
@@ -35,9 +35,9 @@ import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.SharedPreferences;
 
+import android.content.pm.ApplicationInfo;
 import android.content.pm.IPackageManager;
 import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager.NameNotFoundException;
 import android.content.pm.PackageManager;
 import android.content.pm.UserInfo;
 import android.content.res.Resources.NotFoundException;
@@ -62,11 +62,13 @@ import android.nfc.TechListParcel;
 import android.nfc.TransceiveResult;
 import android.nfc.tech.Ndef;
 import android.nfc.tech.TagTechnology;
+import android.nfc.INfcDta;
 import android.os.AsyncTask;
 import android.os.Binder;
 import android.os.Build;
 import android.os.Bundle;
 import android.os.Handler;
+import android.os.HwBinder;
 import android.os.IBinder;
 import android.os.Message;
 import android.os.PowerManager;
@@ -77,7 +79,12 @@ import android.os.SystemClock;
 import android.os.SystemProperties;
 import android.os.UserHandle;
 import android.os.UserManager;
+import android.os.VibrationEffect;
+import android.os.Vibrator;
 import android.provider.Settings;
+import android.se.omapi.ISecureElementService;
+import android.service.vr.IVrManager;
+import android.service.vr.IVrStateCallbacks;
 import android.util.Log;
 
 import com.android.internal.logging.MetricsLogger;
@@ -102,6 +109,7 @@ import com.android.nfc.handover.HandoverDataParser;
 
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
+import java.io.UnsupportedEncodingException;
 import java.nio.ByteBuffer;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.io.InputStream;
@@ -118,24 +126,21 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.NoSuchElementException;
+import java.util.TimerTask;
+import java.util.Timer;
 import java.io.IOException;
 import java.io.FileNotFoundException;
 
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.lang.reflect.InvocationTargetException;
+
 import android.util.Pair;
 import java.util.HashSet;
 import java.util.concurrent.ExecutionException;
 
 import com.nxp.nfc.INxpNfcAdapter;
-import com.nxp.intf.ILoaderService;
-import com.nxp.intf.IJcopService;
-import com.nxp.intf.INxpExtrasService;
-import com.nxp.intf.IeSEClientServicesAdapter;
-import com.nxp.nfc.INxpNfcDta;
-import android.nfc.INfcDta;
 import com.nxp.nfc.INfcVzw;
-import com.nxp.nfc.INxpNfcAdapterExtras;
-import com.nxp.nfc.INxpNfcAccessExtras;
-import com.nxp.nfc.NxpNfcAdapter;
 import com.nxp.nfc.NxpConstants;
 import com.vzw.nfc.RouteEntry;
 import com.gsma.nfc.internal.NxpNfcController;
@@ -170,13 +175,10 @@ public class NfcService implements DeviceHostListener {
     private static final String PREF_MIFARE_DESFIRE_PROTO_ROUTE_ID = "mifare_desfire_proto_route";
     private static final String PREF_SET_DEFAULT_ROUTE_ID ="set_default_route";
     private static final String PREF_MIFARE_CLT_ROUTE_ID= "mifare_clt_route";
-    private static final String LS_BACKUP_PATH = "/data/vendor/nfc/ls_backup.txt";
-    private static final String LS_UPDATE_BACKUP_PATH = "/data/vendor/nfc/loaderservice_updater.txt";
-    private static final String LS_UPDATE_BACKUP_OUT_PATH = "/data/vendor/nfc/loaderservice_updater_out.txt";
 
-    private static final String[] path = {"/data/vendor/nfc/JcopOs_Update1.apdu",
-                                          "/data/vendor/nfc/JcopOs_Update2.apdu",
-                                          "/data/vendor/nfc/JcopOs_Update3.apdu"};
+    private static final String[] path = {"/data/nfc/JcopOs_Update1.apdu",
+                                          "/data/nfc/JcopOs_Update2.apdu",
+                                          "/data/nfc/JcopOs_Update3.apdu"};
 
     private static final String[] PREF_JCOP_MODTIME = {"jcop file1 modtime",
                                                        "jcop file2 modtime",
@@ -213,7 +215,6 @@ public class NfcService implements DeviceHostListener {
     static final String TRON_NFC_TAG = "nfc_tag";
 
     static final int MSG_NDEF_TAG = 0;
-    static final int MSG_CARD_EMULATION = 1;
     static final int MSG_LLCP_LINK_ACTIVATION = 2;
     static final int MSG_LLCP_LINK_DEACTIVATED = 3;
     static final int MSG_TARGET_DESELECTED = 4;
@@ -232,7 +233,6 @@ public class NfcService implements DeviceHostListener {
     static final int MSG_INVOKE_BEAM = 19;
 
     static final int MSG_SWP_READER_REQUESTED = 20;
-    static final int MSG_SWP_READER_ACTIVATED = 21;
     static final int MSG_SWP_READER_DEACTIVATED = 22;
     static final int MSG_CLEAR_ROUTING = 23;
     static final int MSG_SET_SCREEN_STATE = 25;
@@ -256,16 +256,16 @@ public class NfcService implements DeviceHostListener {
     static final int MSG_ETSI_STOP_CONFIG = 49;
     static final int MSG_ETSI_SWP_TIMEOUT = 50;
     static final int MSG_APPLY_SCREEN_STATE = 51;
-    static final int MSG_CHANGE_DEFAULT_ROUTE = 52;
-    static final int MSG_SE_DELIVER_INTENT = 53;
     static final int MSG_REGISTER_T3T_IDENTIFIER = 54;
     static final int MSG_DEREGISTER_T3T_IDENTIFIER = 55;
     static final int MSG_TAG_DEBOUNCE = 56;
     static final int MSG_UPDATE_STATS = 57;
+    static final int MSG_SWP_READER_RESTART = 58;
     /*Restart Nfc disbale watchdog timer*/
     static final int MSG_RESTART_WATCHDOG = 60;
     static final int MSG_ROUTE_APDU = 61;
     static final int MSG_UNROUTE_APDU = 62;
+    static final int MSG_TRANSACTION_EVENT = 63;
     // Update stats every 4 hours
     static final long STATS_UPDATE_INTERVAL_MS = 4 * 60 * 60 * 1000;
     static final long MAX_POLLING_PAUSE_TIMEOUT = 40000;
@@ -274,6 +274,8 @@ public class NfcService implements DeviceHostListener {
     static final int TASK_BOOT = 3;
     static final int TASK_EE_WIPE = 4;
     static final int TASK_RESTART = 0x1F;
+    static final int MSG_CHANGE_DEFAULT_ROUTE = 52;
+    static final int MSG_SE_DELIVER_INTENT = 53;
 
     // Copied from com.android.nfc_extras to avoid library dependency
     // Must keep in sync with com.android.nfc_extras
@@ -293,7 +295,7 @@ public class NfcService implements DeviceHostListener {
     static final int NFC_POLL_A = 0x01;
     static final int NFC_POLL_B = 0x02;
     static final int NFC_POLL_F = 0x04;
-    static final int NFC_POLL_ISO15693 = 0x08;
+    static final int NFC_POLL_V = 0x08;
     static final int NFC_POLL_B_PRIME = 0x10;
     static final int NFC_POLL_KOVIO = 0x20;
 
@@ -326,6 +328,8 @@ public class NfcService implements DeviceHostListener {
     // The amount of time we wait before manually launching
     // the Beam animation when called through the share menu.
     static final int INVOKE_BEAM_DELAY_MS = 1000;
+    // Default delay used for presence checks in ETSI mode
+    static final int ETSI_PRESENCE_CHECK_DELAY = 1000;
     // for use with playSound()
     public static final int SOUND_START = 0;
     public static final int SOUND_END = 1;
@@ -335,9 +339,10 @@ public class NfcService implements DeviceHostListener {
 
     public static final int NCI_VERSION_1_0 = 0x10;
     //ETSI Reader Events
-    public static final int ETSI_READER_REQUESTED   = 0;
-    public static final int ETSI_READER_START       = 1;
-    public static final int ETSI_READER_STOP        = 2;
+    public static final int ETSI_READER_START_SUCCESS   = 0;
+    public static final int ETSI_READER_START_FAIL  = 1;
+    public static final int ETSI_READER_ACTIVATED   = 2;
+    public static final int ETSI_READER_STOP        = 3;
 
     //ETSI Reader Req States
     public static final int STATE_SE_RDR_MODE_INVALID = 0x00;
@@ -359,7 +364,6 @@ public class NfcService implements DeviceHostListener {
         "com.android.nfc_extras.action.RF_FIELD_OFF_DETECTED";
     public static final String ACTION_AID_SELECTED =
         "com.android.nfc_extras.action.AID_SELECTED";
-    public static final String EXTRA_AID = "com.android.nfc_extras.extra.AID";
 
     public static final String ACTION_LLCP_UP =
             "com.android.nfc.action.LLCP_UP";
@@ -439,11 +443,17 @@ public class NfcService implements DeviceHostListener {
     // Timeout to re-apply routing if a tag was present and we postponed it
     private static final int APPLY_ROUTING_RETRY_TIMEOUT_MS = 5000;
 
+    // these states are for making enable and disable nfc atomic
+    private int NXP_NFC_STATE_OFF = 0;
+    private int NXP_NFC_STATE_TURNING_ON = 1;
+    private int NXP_NFC_STATE_ON = 2;
+    private int NXP_NFC_STATE_TURNING_OFF = 3;
+
     private final UserManager mUserManager;
     private static int nci_version = NCI_VERSION_1_0;
     // NFC Execution Environment
     // fields below are protected by this
-    private NativeNfcSecureElement mSecureElement;
+    public NativeNfcSecureElement mSecureElement;
     private OpenSecureElement mOpenEe;  // null when EE closed
     private final ReaderModeDeathRecipient mReaderModeDeathRecipient =
             new ReaderModeDeathRecipient();
@@ -451,19 +461,19 @@ public class NfcService implements DeviceHostListener {
 
     private int mEeRoutingState;  // contactless interface routing
     private int mLockscreenPollMask;
-    List<PackageInfo> mInstalledPackages; // cached version of installed packages
+    // cached version of installed packages requesting Android.permission.NFC_TRANSACTION_EVENTS
+    List<String> mNfcEventInstalledPackages = new ArrayList<String>();
     private NativeNfcAla mNfcAla;
 
     private final BackupManager mBackupManager;
 
-    NfcAccessExtrasService mNfcAccessExtrasService;
-
     // fields below are used in multiple threads and protected by synchronized(this)
     final HashMap<Integer, Object> mObjectMap = new HashMap<Integer, Object>();
     // mSePackages holds packages that accessed the SE, but only for the owner user,
     // as SE access is not granted for non-owner users.
     HashSet<String> mSePackages = new HashSet<String>();
     int mScreenState;
+    int mChipVer;
     boolean mIsTaskBoot = false;
     boolean mInProvisionMode; // whether we're in setup wizard and enabled NFC provisioning
     boolean mIsNdefPushEnabled;
@@ -477,8 +487,11 @@ public class NfcService implements DeviceHostListener {
     private int mUserId;
     boolean mPollingPaused;
 
+    static final int INVALID_NATIVE_HANDLE = -1;
+    static final int SE_ACCESS_DENIED = -2;
     byte[] mDebounceTagUid;
     int mDebounceTagDebounceMs;
+    int mDebounceTagNativeHandle = INVALID_NATIVE_HANDLE;
     ITagRemovedCallback mDebounceTagRemovedCallback;
 
     // Only accessed on one thread so doesn't need locking
@@ -493,6 +506,8 @@ public class NfcService implements DeviceHostListener {
     // and the default AsyncTask thread so it is read unprotected from that
     // thread
     int mState;  // one of NfcAdapter.STATE_ON, STATE_TURNING_ON, etc
+    int mNxpNfcState = NXP_NFC_STATE_OFF;
+
     boolean mPowerShutDown = false;  // State for power shut down state
 
     // fields below are final after onCreate()
@@ -515,23 +530,17 @@ public class NfcService implements DeviceHostListener {
     NfcAdapterExtrasService mExtrasService;
 //    CardEmulationService mCardEmulationService;
     NxpNfcAdapterService mNxpNfcAdapter;
-    NxpNfcAdapterExtrasService mNxpExtrasService;
-    NxpExtrasService mNxpExtras;
-    EseClientServicesAdapter mEseClientServicesAdapter;
     boolean mIsDebugBuild;
     boolean mIsHceCapable;
     boolean mIsHceFCapable;
-    boolean mIsRoutingTableDirty;
+    public boolean mIsRoutingTableDirty;
     boolean mIsFelicaOnHostConfigured;
     boolean mIsFelicaOnHostConfiguring;
 
     public boolean mIsRouteForced;
-    NfceeAccessControl mNfceeAccessControl;
     NfcSccAccessControl mNfcSccAccessControl;
     NfcSeAccessControl mNfcSeAccessControl;
-    NfcAlaService mAlaService;
-    NfcJcopService mJcopService;
-    NfcDtaService mDtaService;
+    NfcDtaService mNfcDtaService;
     NfcVzwService mVzwService;
     private NfcDispatcher mNfcDispatcher;
     private PowerManager mPowerManager;
@@ -541,7 +550,10 @@ public class NfcService implements DeviceHostListener {
     private ContentResolver mContentResolver;
     private RegisteredAidCache mAidCache;
     private CardEmulationManager mCardEmulationManager;
+    private Vibrator mVibrator;
+    private VibrationEffect mVibrationEffect;
     private AidRoutingManager mAidRoutingManager;
+    private ISecureElementService mSEService;
     private ScreenStateHelper mScreenStateHelper;
     private ForegroundUtils mForegroundUtils;
     private boolean mClearNextTapDefault;
@@ -558,8 +570,11 @@ public class NfcService implements DeviceHostListener {
     private static final Boolean multiReceptionMode = Boolean.TRUE;
     private static final Boolean unicastReceptionMode = Boolean.FALSE;
     boolean mIsSentUnicastReception = false;
-    boolean mLegacyTransactionEvent = false;
 
+    //WiredSe
+    Class mWiredSeClass;
+    Method mWiredSeInitMethod, mWiredSeDeInitMwthod;
+    Object mWiredSeObj;
 
     public void enforceNfcSeAdminPerm(String pkg) {
         if (pkg == null) {
@@ -579,10 +594,6 @@ public class NfcService implements DeviceHostListener {
             throw new SecurityException("caller must pass a package name");
         }
         NfcPermissions.enforceUserPermissions(mContext);
-        if (!mNfceeAccessControl.check(Binder.getCallingUid(), pkg)) {
-            throw new SecurityException(NfceeAccessControl.NFCEE_ACCESS_PATH +
-                    " denies NFCEE access to " + pkg);
-        }
         if (UserHandle.getCallingUserId() != UserHandle.USER_OWNER) {
             throw new SecurityException("only the owner is allowed to call SE APIs");
         }
@@ -607,6 +618,9 @@ public class NfcService implements DeviceHostListener {
     boolean mIsLiveCaseEnabled; // whether live cases are enabled
     int mLiveCaseTechnology; // Technology mask of accepted NFC tags
 
+    private IVrManager vrManager;
+    boolean mIsVrModeEnabled;
+
     public static NfcService getInstance() {
         return sService;
     }
@@ -627,6 +641,7 @@ public class NfcService implements DeviceHostListener {
     public int getChipVer() {
         return mDeviceHost.getChipVer();
     }
+
     /**
      * Notifies Card emulation deselect
      */
@@ -637,20 +652,6 @@ public class NfcService implements DeviceHostListener {
         }
     }
 
-    /**
-     * Notifies transaction
-     */
-    @Override
-    public void onCardEmulationAidSelected(byte[] aid, byte[] data, int evtSrc) {
-        if (!mIsHceCapable || SE_BROADCASTS_WITH_HCE) {
-            Pair<byte[], Integer> dataSrc = new Pair<byte[], Integer>(data, evtSrc);
-            Pair<byte[], Pair> transactionInfo = new Pair<byte[], Pair>(aid, dataSrc);
-            Log.d(TAG, "onCardEmulationAidSelected : Source" + evtSrc);
-
-            sendMessage(NfcService.MSG_CARD_EMULATION, transactionInfo);
-        }
-    }
-
     /**
      * Notifies connectivity
      */
@@ -802,7 +803,7 @@ public class NfcService implements DeviceHostListener {
     }
 
     @Override
-    public void onSWPReaderRequestedEvent(boolean istechA, boolean istechB)
+    public void onETSIReaderRequestedEvent(boolean istechA, boolean istechB)
     {
         int size=0;
         ArrayList<Integer> techList = new ArrayList<Integer>();
@@ -815,20 +816,18 @@ public class NfcService implements DeviceHostListener {
     }
 
     @Override
-    public void onSWPReaderRequestedFail(int FailCause)
+    public void onETSIReaderRequestedFail(int FailCause)
     {
         sendMessage(NfcService.MSG_SWP_READER_REQUESTED_FAIL , FailCause);
     }
 
-    @Override
-    public void onSWPReaderActivatedEvent()
-    {
-        sendMessage(NfcService.MSG_SWP_READER_ACTIVATED, null);
-    }
-
     @Override
     public void onETSIReaderModeStartConfig(int eeHandle)
     {
+        // Check if NFC is enabled
+        if (!isNfcEnabled()) {
+            return;
+        }
         ArrayList<Integer> configList = new ArrayList<Integer>();
         configList.add(eeHandle);
         sendMessage(NfcService.MSG_ETSI_START_CONFIG, configList);
@@ -837,7 +836,13 @@ public class NfcService implements DeviceHostListener {
     @Override
     public void onETSIReaderModeStopConfig(int disc_ntf_timeout)
     {
-        sendMessage(NfcService.MSG_ETSI_STOP_CONFIG, disc_ntf_timeout);
+        // Check if NFC is enabled
+        if (!isNfcEnabled()) {
+            return;
+        }
+        EtsiStopConfigTask task = new EtsiStopConfigTask();
+        task.execute(disc_ntf_timeout);
+
     }
 
     @Override
@@ -846,7 +851,12 @@ public class NfcService implements DeviceHostListener {
         sendMessage(NfcService.MSG_ETSI_SWP_TIMEOUT, disc_ntf_timeout);
     }
 
-     @Override
+    @Override
+    public void onETSIReaderModeRestart() {
+        sendMessage(NfcService.MSG_SWP_READER_RESTART, null);
+    }
+
+    @Override
     public void onUiccStatusEvent(int uiccStat)
     {
          Log.i(TAG, "Broadcasting UICC Status : " + uiccStat);
@@ -867,6 +877,12 @@ public class NfcService implements DeviceHostListener {
         new EnableDisableTask().execute(TASK_RESTART);
     }
 
+    @Override
+    public void onNfcTransactionEvent(byte[] aid, byte[] data, String seName) {
+        byte[][] dataObj = {aid, data, seName.getBytes()};
+        sendMessage(NfcService.MSG_TRANSACTION_EVENT, dataObj);
+    }
+
     final class ReaderModeParams {
         public int flags;
         public IAppCallback callback;
@@ -881,9 +897,17 @@ public class NfcService implements DeviceHostListener {
         mNfcAdapter = new NfcAdapterService();
         mNxpNfcAdapter = new NxpNfcAdapterService();
         mExtrasService = new NfcAdapterExtrasService();
-        mNxpExtrasService = new NxpNfcAdapterExtrasService();
       //  mCardEmulationService = new CardEmulationService();
 
+        try {
+            mWiredSeClass = Class.forName("com.android.nfc.WiredSeService");
+            mWiredSeObj = mWiredSeClass.newInstance();
+        } catch (ClassNotFoundException | IllegalAccessException e){
+            Log.e(TAG, "WiredSeService Class not found");
+        } catch (InstantiationException e) {
+            Log.e(TAG, "WiredSeService object Instantiation failed");
+        }
+
         Log.i(TAG, "Starting NFC service");
 
         sService = this;
@@ -920,7 +944,7 @@ public class NfcService implements DeviceHostListener {
                 } else if (liveCaseTechList[i].equals("TypeF")) {
                     mLiveCaseTechnology |= NFC_POLL_F;
                 } else if (liveCaseTechList[i].equals("TypeV")) {
-                    mLiveCaseTechnology |= NFC_POLL_ISO15693;
+                    mLiveCaseTechnology |= NFC_POLL_V;
                 }
             }
         } catch (NotFoundException e) {
@@ -949,7 +973,6 @@ public class NfcService implements DeviceHostListener {
         mEeRoutingState = ROUTE_OFF;
         mToastHandler = new ToastHandler(mContext);
 
-        mNfceeAccessControl = new NfceeAccessControl(mContext);
         mNfcSccAccessControl = new NfcSccAccessControl(mContext);
         mNfcSeAccessControl  = new NfcSeAccessControl(mContext);
         mNfcAla = new NativeNfcAla();
@@ -961,7 +984,7 @@ public class NfcService implements DeviceHostListener {
 
         mState = NfcAdapter.STATE_OFF;
         mIsNdefPushEnabled = mPrefs.getBoolean(PREF_NDEF_PUSH_ON, NDEF_PUSH_ON_DEFAULT);
-        setBeamShareActivityState(mIsNdefPushEnabled);
+        enforceBeamShareActivityPolicy(mContext, new UserHandle(mUserId));
 
         mIsDebugBuild = "userdebug".equals(Build.TYPE) || "eng".equals(Build.TYPE);
 
@@ -974,6 +997,8 @@ public class NfcService implements DeviceHostListener {
 
         mKeyguard = (KeyguardManager) mContext.getSystemService(Context.KEYGUARD_SERVICE);
         mUserManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);
+        mVibrator = (Vibrator) mContext.getSystemService(Context.VIBRATOR_SERVICE);
+        mVibrationEffect = VibrationEffect.createOneShot(200, VibrationEffect.DEFAULT_AMPLITUDE);
 
         mScreenState = mScreenStateHelper.checkScreenState();
 
@@ -1010,13 +1035,16 @@ public class NfcService implements DeviceHostListener {
         mContext.registerReceiverAsUser(x509CertificateReceiver, UserHandle.ALL,
                 x509CertificateFilter, NfcPermissions.ADMIN_PERM, null);
 
+        IntentFilter activateStkFilter = new IntentFilter();
+        activateStkFilter.addAction(NxpConstants.CAT_ACTIVATE_NOTIFY_ACTION);
+        mContext.registerReceiver(mActivateSwpInterface, activateStkFilter);
+
         IntentFilter enableNfc = new IntentFilter();
         enableNfc.addAction(NxpConstants.ACTION_GSMA_ENABLE_NFC);
         mContext.registerReceiverAsUser(mEnableNfc, UserHandle.ALL, enableNfc, null, null);
 
         IntentFilter lsFilter = new IntentFilter(NfcAdapter.ACTION_ADAPTER_STATE_CHANGED);
         //mContext.registerReceiver(mAlaReceiver, lsFilter);
-        mContext.registerReceiverAsUser(mAlaReceiver, UserHandle.ALL, lsFilter, null, null);
 
         IntentFilter policyFilter = new IntentFilter(DevicePolicyManager.ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED);
         mContext.registerReceiverAsUser(mPolicyReceiver, UserHandle.ALL, policyFilter, null, null);
@@ -1044,13 +1072,36 @@ public class NfcService implements DeviceHostListener {
         // Make sure this is only called when object construction is complete.
         ServiceManager.addService(SERVICE_NAME, mNfcAdapter);
 
+        ActivityManager activityManager = (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);
+
         new EnableDisableTask().execute(TASK_BOOT);  // do blocking boot tasks
 
         mHandler.sendEmptyMessageDelayed(MSG_UPDATE_STATS, STATS_UPDATE_INTERVAL_MS);
+
+        IVrManager mVrManager = IVrManager.Stub.asInterface(ServiceManager.getService(
+                mContext.VR_SERVICE));
+        if (mVrManager != null) {
+            try {
+                mVrManager.registerListener(mVrStateCallbacks);
+                mIsVrModeEnabled = mVrManager.getVrModeState();
+            } catch (RemoteException e) {
+                Log.e(TAG, "Failed to register VR mode state listener: " + e);
+            }
+        }
+        mSEService = ISecureElementService.Stub.asInterface(ServiceManager.getService(
+                Context.SECURE_ELEMENT_SERVICE));
         /*SoundPool clean up before NFC state updated*/
         initSoundPool();
     }
 
+    private boolean isSEServiceAvailable() {
+        if (mSEService == null) {
+            mSEService = ISecureElementService.Stub.asInterface(ServiceManager.getService(
+                    Context.SECURE_ELEMENT_SERVICE));
+        }
+        return (mSEService != null);
+    }
+
     void initSoundPool() {
         synchronized(this) {
             if (mSoundPool == null) {
@@ -1073,9 +1124,18 @@ public class NfcService implements DeviceHostListener {
 
     void updatePackageCache() {
         PackageManager pm = mContext.getPackageManager();
-        List<PackageInfo> packages = pm.getInstalledPackagesAsUser(0, UserHandle.USER_SYSTEM);
+        List<PackageInfo> packagesNfcEvents = pm.getPackagesHoldingPermissions(
+                new String[] {android.Manifest.permission.NFC_TRANSACTION_EVENT},
+                PackageManager.GET_ACTIVITIES);
         synchronized (this) {
-            mInstalledPackages = packages;
+            mNfcEventInstalledPackages.clear();
+            for (int i = 0; i < packagesNfcEvents.size(); i++) {
+                int hasPerm = pm.checkPermission(android.Manifest.permission.NFC,
+                                                 packagesNfcEvents.get(i).packageName);
+                if (hasPerm == PackageManager.PERMISSION_GRANTED){
+                      mNfcEventInstalledPackages.add(packagesNfcEvents.get(i).packageName);
+                }
+            }
         }
     }
 
@@ -1145,23 +1205,6 @@ public class NfcService implements DeviceHostListener {
         return null;
     }
 
-    public static String getCallingAppPkg(Context context) {
-        String localTAG = "getCallingAppPkg";
-        ActivityManager am = (ActivityManager) context.getSystemService(context.ACTIVITY_SERVICE);
-
-        // get the info from the currently running task
-        List< ActivityManager.RunningTaskInfo > taskInfo = am.getRunningTasks(1);
-
-        Log.d("topActivity", "CURRENT Activity ::"
-                + taskInfo.get(0).topActivity.getClassName());
-        String s = taskInfo.get(0).topActivity.getClassName();
-
-        ComponentName componentInfo = taskInfo.get(0).topActivity;
-        componentInfo.getPackageName();
-        Log.i(localTAG,"componentInfo.getPackageName()" + componentInfo.getPackageName());
-        return componentInfo.getPackageName();
-    }
-
     /**
      * Manages tasks that involve turning on/off the NFC controller.
      * <p/>
@@ -1218,7 +1261,7 @@ public class NfcService implements DeviceHostListener {
                     disableInternal();
                     break;
                 case TASK_BOOT:
-                    if (mPrefs.getBoolean(PREF_FIRST_BOOT, true)) {
+                if (mPrefs.getBoolean(PREF_FIRST_BOOT, true)) {
                         Log.i(TAG, "First Boot");
                         mPrefsEditor.putBoolean(PREF_FIRST_BOOT, false);
                         mPrefsEditor.apply();
@@ -1235,6 +1278,7 @@ public class NfcService implements DeviceHostListener {
                         Log.d(TAG, "NFC is off.  Checking firmware version");
                         mDeviceHost.checkFirmware();
                     }
+                    SystemProperties.set("nfc.initialized", "true");
                     break;
                 case TASK_RESTART:
                     restartInternal();
@@ -1298,7 +1342,6 @@ public class NfcService implements DeviceHostListener {
                         mNxpPrefs.getInt(PREF_SECURE_ELEMENT_ID, SECURE_ELEMENT_ID_DEFAULT);
 
                 if (seList != null) {
-
                     if (secureElementId != ALL_SE_ID_TYPE/* SECURE_ELEMENT_ALL */) {
                         mDeviceHost.doDeselectSecureElement(UICC_ID_TYPE);
                         mDeviceHost.doDeselectSecureElement(UICC2_ID_TYPE);
@@ -1452,6 +1495,7 @@ public class NfcService implements DeviceHostListener {
                     if (!mDeviceHost.initialize()) {
                         Log.w(TAG, "Error enabling NFC");
                         updateState(NfcAdapter.STATE_OFF);
+                        watchDog.cancel();
                         return false;
                     }
                 } finally {
@@ -1460,9 +1504,9 @@ public class NfcService implements DeviceHostListener {
             } finally {
                 watchDog.cancel();
             }
-            int chipVer = mDeviceHost.getChipVer();
-            if((chipVer == PN80T_ID) || (chipVer == PN553_ID)) {
-                ALL_SE_ID_TYPE |= UICC2_ID_TYPE;
+            mChipVer = mDeviceHost.getChipVer();
+            if(mChipVer < PN553_ID) {
+                ALL_SE_ID_TYPE &= ~UICC2_ID_TYPE;
             }
             checkSecureElementConfuration();
 
@@ -1478,24 +1522,22 @@ public class NfcService implements DeviceHostListener {
             synchronized (NfcService.this) {
                 mObjectMap.clear();
                 mP2pLinkManager.enableDisable(mIsNdefPushEnabled, true);
-                updateState(NfcAdapter.STATE_ON);
             }
 
             synchronized (NfcService.this) {
-                if(mDeviceHost.doCheckJcopDlAtBoot()) {
-                    /* start jcop download */
-                    Log.i(TAG, "Calling Jcop Download");
-                    jcopOsDownload();
-                }
-            }
-
-            byte[] additionalConfigOptions = mDeviceHost.getAdditionalConfigOptions();
-
-            if(additionalConfigOptions.length > 0 && additionalConfigOptions[0] == (byte)0x01) {
-                Log.w(TAG, "Legacy Transaction Event Behavior");
-                mLegacyTransactionEvent = true;
+              updateState(NfcAdapter.STATE_ON);
+              try {
+                mWiredSeInitMethod = mWiredSeClass.getDeclaredMethod("wiredSeInitialize");
+                mWiredSeInitMethod.invoke(mWiredSeObj);
+              } catch (NoSuchElementException | NoSuchMethodException e) {
+                Log.i(TAG, "No such Method WiredSeInitialize");
+              } catch (RuntimeException | IllegalAccessException | InvocationTargetException e) {
+                Log.e(TAG, "Error in invoking wiredSeInitialize invocation");
+              } catch (Exception e) {
+                Log.e(TAG, "caught Exception during wiredSeInitialize");
+                e.printStackTrace();
+              }
             }
-
             /* Start polling loop */
             Log.e(TAG, "applyRouting -3");
             mScreenState = mScreenStateHelper.checkScreenState();
@@ -1517,6 +1559,9 @@ public class NfcService implements DeviceHostListener {
                 mIsTaskBoot = false;
             }
             applyRouting(true);
+            synchronized (NfcService.this) {
+                mNxpNfcState = NXP_NFC_STATE_ON;
+            }
             return true;
         }
 
@@ -1530,6 +1575,19 @@ public class NfcService implements DeviceHostListener {
             }
             Log.i(TAG, "Disabling NFC");
             updateState(NfcAdapter.STATE_TURNING_OFF);
+
+            try{
+                mWiredSeDeInitMwthod = mWiredSeClass.getDeclaredMethod("wiredSeDeInitialize");
+                mWiredSeDeInitMwthod.invoke(mWiredSeObj);
+            } catch (NoSuchElementException | NoSuchMethodException e) {
+                Log.i(TAG, "No such Method WiredSeInitialize");
+            } catch (RuntimeException | IllegalAccessException | InvocationTargetException e) {
+                Log.e(TAG, "Error in invoking wiredSeInitialize invocation");
+            } catch (Exception e) {
+                Log.e(TAG, "caught Exception during wiredSeInitialize");
+                e.printStackTrace();
+            }
+
             /*SoundPool clean up before NFC state updated
             releaseSoundPool();*/
 
@@ -1589,9 +1647,8 @@ public class NfcService implements DeviceHostListener {
             synchronized (NfcService.this) {
                 mCurrentDiscoveryParameters = NfcDiscoveryParameters.getNfcOffParameters();
                 updateState(NfcAdapter.STATE_OFF);
+                mNxpNfcState = NXP_NFC_STATE_OFF;
             }
-
-
             return result;
         }
 
@@ -1630,16 +1687,6 @@ public class NfcService implements DeviceHostListener {
                 if (newState == mState) {
                     return;
                 }
-                int Ver = mDeviceHost.getChipVer();
-                if(Ver == PN80T_ID || Ver == PN67T_ID || Ver == PN66T_ID || Ver == PN65T_ID) {
-                    /*Added for Loader service recover during NFC Off/On*/
-                    if(newState == NfcAdapter.STATE_ON){
-                        NfcAlaService nas = new NfcAlaService();
-                        nas.LSReexecute();
-                        IntentFilter lsFilter = new IntentFilter(NfcAdapter.ACTION_ADAPTER_STATE_CHANGED);
-                        mContext.registerReceiverAsUser(mAlaReceiver, UserHandle.ALL, lsFilter, null, null);
-                    }
-                }
                 mState = newState;
                 Intent intent = new Intent(NfcAdapter.ACTION_ADAPTER_STATE_CHANGED);
                 intent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
@@ -1663,6 +1710,11 @@ public class NfcService implements DeviceHostListener {
                 Log.w(TAG, "Not playing sound when NFC is disabled");
                 return;
             }
+
+            if (mIsVrModeEnabled) {
+                Log.d(TAG, "Not playing NFC sound when Vr Mode is enabled");
+                return;
+            }
             switch (sound) {
                 case SOUND_START:
                     mSoundPool.play(mStartSound, 1.0f, 1.0f, 0, 0, 1.0f);
@@ -1681,26 +1733,25 @@ public class NfcService implements DeviceHostListener {
         return mUserId;
     }
 
-    void setBeamShareActivityState(boolean enabled) {
-        UserManager um = (UserManager) mContext.getSystemService(Context.USER_SERVICE);
-        // Propagate the state change to all user profiles related to the current
-        // user. Note that the list returned by getUserProfiles contains the
-        // current user.
-        List <UserHandle> luh = um.getUserProfiles();
-        for (UserHandle uh : luh){
-            enforceBeamShareActivityPolicy(mContext, uh, enabled);
-        }
-    }
-
-    void enforceBeamShareActivityPolicy(Context context, UserHandle uh,
-            boolean isGlobalEnabled){
+    void enforceBeamShareActivityPolicy(Context context, UserHandle uh) {
         UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);
         IPackageManager mIpm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+        boolean isGlobalEnabled = mIsNdefPushEnabled;
+        if (uh.getIdentifier() != mUserId) {
+            try {
+            int userSetting = mIpm.getComponentEnabledSetting(new ComponentName(
+                    BeamShareActivity.class.getPackageName$(),
+                    BeamShareActivity.class.getName()), uh.getIdentifier());
+            isGlobalEnabled = (userSetting == PackageManager.COMPONENT_ENABLED_STATE_DISABLED) ? false : true;
+            } catch (RemoteException e) {
+                Log.w(TAG, "Unable to get Beam status for user " + uh);
+            }
+        }
         boolean isActiveForUser =
                 (!um.hasUserRestriction(UserManager.DISALLOW_OUTGOING_BEAM, uh)) &&
                 isGlobalEnabled;
-        if (DBG){
-            Log.d(TAG, "Enforcing a policy change on user: " + uh +
+        if (DBG) {
+            Log.d(TAG, "Enforcing a policy change on user: " + uh.toString() +
                     ", isActiveForUser = " + isActiveForUser);
         }
         try {
@@ -1711,7 +1762,7 @@ public class NfcService implements DeviceHostListener {
                             PackageManager.COMPONENT_ENABLED_STATE_ENABLED :
                             PackageManager.COMPONENT_ENABLED_STATE_DISABLED,
                             PackageManager.DONT_KILL_APP,
-                    uh.getIdentifier());
+                        uh.getIdentifier());
         } catch (RemoteException e) {
             Log.w(TAG, "Unable to change Beam status for user " + uh);
         }
@@ -1721,6 +1772,16 @@ public class NfcService implements DeviceHostListener {
         @Override
         public boolean enable() throws RemoteException {
             NfcPermissions.enforceAdminPermissions(mContext);
+            if (mNxpNfcState != NXP_NFC_STATE_OFF) {
+                return true;
+            } else {
+                // do nothing
+            }
+
+            synchronized (NfcService.this) {
+                mNxpNfcState = NXP_NFC_STATE_TURNING_ON;
+            }
+
             int val =  mDeviceHost.GetDefaultSE();
             Log.i(TAG, "getDefaultSE " + val);
 
@@ -1734,6 +1795,16 @@ public class NfcService implements DeviceHostListener {
         @Override
         public boolean disable(boolean saveState) throws RemoteException {
             NfcPermissions.enforceAdminPermissions(mContext);
+            if (mNxpNfcState != NXP_NFC_STATE_ON) {
+                return true;
+            } else {
+               // do nothing
+            }
+
+            synchronized (NfcService.this) {
+                mNxpNfcState = NXP_NFC_STATE_TURNING_OFF;
+            }
+
             Log.d(TAG,"Disabling Nfc.");
 
             //Check if this a device shutdown or Nfc only Nfc disable.
@@ -1813,7 +1884,7 @@ public class NfcService implements DeviceHostListener {
                 mPrefsEditor.putBoolean(PREF_NDEF_PUSH_ON, true);
                 mPrefsEditor.apply();
                 mIsNdefPushEnabled = true;
-                setBeamShareActivityState(true);
+                enforceBeamShareActivityPolicy(mContext, new UserHandle(mUserId));
                 if (isNfcEnabled()) {
                     mDeviceHost.doEnablep2p(mIsNdefPushEnabled);
                     mP2pLinkManager.enableDisable(true, true);
@@ -1834,7 +1905,7 @@ public class NfcService implements DeviceHostListener {
                 mPrefsEditor.putBoolean(PREF_NDEF_PUSH_ON, false);
                 mPrefsEditor.apply();
                 mIsNdefPushEnabled = false;
-                setBeamShareActivityState(false);
+                enforceBeamShareActivityPolicy(mContext, new UserHandle(mUserId));
                 if (isNfcEnabled()) {
                     mP2pLinkManager.enableDisable(false, true);
                 }
@@ -1898,7 +1969,6 @@ public class NfcService implements DeviceHostListener {
 
             if (pkg.equals(PACKAGE_SMART_CARD_SERVICE)){
                 Log.d(TAG, "wildcard for SmartcardService");
-                NfcService.this.enforceNfceeAdminPerm(pkg);
                 return mExtrasService;
             }
 
@@ -1906,17 +1976,35 @@ public class NfcService implements DeviceHostListener {
             return mExtrasService;
         }
 
+        @Override
+        public INfcDta getNfcDtaInterface(String pkg) throws RemoteException {
+            NfcPermissions.enforceAdminPermissions(mContext);
+            if (mNfcDtaService == null) {
+                mNfcDtaService = new NfcDtaService();
+            }
+            return mNfcDtaService;
+        }
+
          @Override
         public boolean ignore(int nativeHandle, int debounceMs, ITagRemovedCallback callback)
                 throws RemoteException {
             NfcPermissions.enforceUserPermissions(mContext);
 
+            if (debounceMs == 0 && mDebounceTagNativeHandle != INVALID_NATIVE_HANDLE
+                && nativeHandle == mDebounceTagNativeHandle) {
+              // Remove any previous messages and immediately debounce.
+              mHandler.removeMessages(MSG_TAG_DEBOUNCE);
+              mHandler.sendEmptyMessage(MSG_TAG_DEBOUNCE);
+              return true;
+            }
+
             TagEndpoint tag = (TagEndpoint) findAndRemoveObject(nativeHandle);
             if (tag != null) {
                 // Store UID and params
                 int uidLength = tag.getUid().length;
                 synchronized (NfcService.this) {
                     mDebounceTagDebounceMs = debounceMs;
+                    mDebounceTagNativeHandle = nativeHandle;
                     mDebounceTagUid = new byte[uidLength];
                     mDebounceTagRemovedCallback = callback;
                     System.arraycopy(tag.getUid(), 0, mDebounceTagUid, 0, uidLength);
@@ -2056,6 +2144,7 @@ public class NfcService implements DeviceHostListener {
                 } else {
                     try {
                         mReaderModeParams = null;
+                        StopPresenceChecking();
                         binder.unlinkToDeath(mReaderModeDeathRecipient, 0);
                     } catch (NoSuchElementException e) {
                         Log.e(TAG, "Reader mode Binder was never registered.");
@@ -2093,7 +2182,7 @@ public class NfcService implements DeviceHostListener {
 
             techCodeToMask.put(TagTechnology.NFC_A, NfcService.NFC_POLL_A);
             techCodeToMask.put(TagTechnology.NFC_B, NfcService.NFC_POLL_B);
-            techCodeToMask.put(TagTechnology.NFC_V, NfcService.NFC_POLL_ISO15693);
+            techCodeToMask.put(TagTechnology.NFC_V, NfcService.NFC_POLL_V);
             techCodeToMask.put(TagTechnology.NFC_F, NfcService.NFC_POLL_F);
             techCodeToMask.put(TagTechnology.NFC_BARCODE, NfcService.NFC_POLL_KOVIO);
             techCodeToMask.put(TagTechnology.MIFARE_CLASSIC, NfcService.NFC_POLL_A);
@@ -2114,12 +2203,6 @@ public class NfcService implements DeviceHostListener {
             return mask;
         }
 
-        @Override
-        public INfcDta getNfcDtaInterface(String pkg) {
-            NfcPermissions.enforceAdminPermissions(mContext);
-            return null;
-        }
-
         /**
          * An interface for nxp extensions
          */
@@ -2134,34 +2217,12 @@ public class NfcService implements DeviceHostListener {
 
     }
     final class NxpNfcAdapterService extends INxpNfcAdapter.Stub {
-        @Override
-        public INxpNfcAdapterExtras getNxpNfcAdapterExtrasInterface() throws RemoteException {
-            return mNxpExtrasService;
-        }
-        @Override
-        public IeSEClientServicesAdapter getNfcEseClientServicesAdapterInterface() {
-            if(mEseClientServicesAdapter == null){
-                mEseClientServicesAdapter = new EseClientServicesAdapter();
-            }
-            return mEseClientServicesAdapter;
-        }
-
         //GSMA Changes
         @Override
         public INxpNfcController getNxpNfcControllerInterface() {
             return mNxpNfcController.getNxpNfcControllerInterface();
         }
 
-        @Override
-        public INxpNfcDta getNfcDtaInterface() {
-            NfcPermissions.enforceAdminPermissions(mContext);
-            //begin
-            if(mDtaService == null){
-                mDtaService = new NfcDtaService();
-            }
-            //end
-            return mDtaService;
-        }
         @Override
         public INfcVzw getNfcVzwInterface() {
             NfcPermissions.enforceAdminPermissions(mContext);
@@ -2178,17 +2239,6 @@ public class NfcService implements DeviceHostListener {
             return mDeviceHost.setEmvCoPollProfile(enable, route);
         }
 
-        @Override
-        public int[] getSecureElementList(String pkg) throws RemoteException {
-            NfcService.this.enforceNfcSeAdminPerm(pkg);
-
-            int[] list = null;
-            if (isNfcEnabled()) {
-                list = mDeviceHost.doGetSecureElementList();
-            }
-            return list;
-        }
-
         @Override
         public int[] getActiveSecureElementList(String pkg) throws RemoteException {
 
@@ -2202,147 +2252,19 @@ public class NfcService implements DeviceHostListener {
             return list;
         }
 
-        public INxpNfcAccessExtras getNxpNfcAccessExtrasInterface(String pkg) {
-            NfcService.this.enforceNfcSccAdminPerm(pkg);
-            Log.d(TAG, "getNxpNfcAccessExtrasInterface1");
-            if(mNfcAccessExtrasService == null){
-                mNfcAccessExtrasService = new NfcAccessExtrasService();
-            }
-            return mNfcAccessExtrasService;
-        }
-
-        @Override
-        public int getSelectedSecureElement(String pkg) throws RemoteException {
-            NfcService.this.enforceNfcSeAdminPerm(pkg);
-            return mSelectedSeId;
-        }
-        @Override
-        public int deselectSecureElement(String pkg) throws RemoteException {
-            NfcService.this.enforceNfcSeAdminPerm(pkg);
-
-            // Check if NFC is enabled
-            if (!isNfcEnabled()) {
-                return ErrorCodes.ERROR_NOT_INITIALIZED;
-            }
-
-            if (mSelectedSeId == 0) {
-                return ErrorCodes.ERROR_NO_SE_CONNECTED;
-            }
-
-            if (mSelectedSeId != ALL_SE_ID_TYPE/* SECURE_ELEMENT_ALL */) {
-                mDeviceHost.doDeselectSecureElement(mSelectedSeId);
-            } else {
-
-                /* Get SE List */
-                int[] seList = mDeviceHost.doGetSecureElementList();
-
-                for (int i = 0; i < seList.length; i++) {
-                    mDeviceHost.doDeselectSecureElement(seList[i]);
-                }
-
-             //   mDeviceHost.doSetMultiSEState(false);
-            }
-            mNfcSecureElementState = false;
-            mSelectedSeId = 0;
-
-            /* store preference */
-            mNxpPrefsEditor.putBoolean(PREF_SECURE_ELEMENT_ON, false);
-            mNxpPrefsEditor.putInt(PREF_SECURE_ELEMENT_ID, 0);
-            mNxpPrefsEditor.apply();
-
-            return ErrorCodes.SUCCESS;
-        }
-
-
-
-
-
-        @Override
-        public void storeSePreference(int seId) {
-            NfcPermissions.enforceAdminPermissions(mContext);
-            /* store */
-            Log.d(TAG, "SE Preference stored");
-            mNxpPrefsEditor.putBoolean(PREF_SECURE_ELEMENT_ON, true);
-            mNxpPrefsEditor.putInt(PREF_SECURE_ELEMENT_ID, seId);
-            mNxpPrefsEditor.apply();
-        }
-
         @Override
-        public int selectSecureElement(String pkg,int seId) throws RemoteException {
-            NfcService.this.enforceNfcSeAdminPerm(pkg);
-
-            // Check if NFC is enabled
-            if (!isNfcEnabled()) {
-                return ErrorCodes.ERROR_NOT_INITIALIZED;
-            }
-
-            if (mSelectedSeId == seId) {
-                return ErrorCodes.ERROR_SE_ALREADY_SELECTED;
-            }
-
-            if (mSelectedSeId != 0) {
-                return ErrorCodes.ERROR_SE_CONNECTED;
-            }
-            /* Get SE List */
-            int[] seList = mDeviceHost.doGetSecureElementList();
-
-            mSelectedSeId = seId;
-            if (seId != ALL_SE_ID_TYPE/* SECURE_ELEMENT_ALL */) {
-                mDeviceHost.doSelectSecureElement(mSelectedSeId);
-            } else {
-                if (seList.length > 1) {
-                    for (int i = 0; i < seList.length; i++) {
-                        mDeviceHost.doSelectSecureElement(seList[i]);
-                        try{
-                            //Delay b/w two SE selection.
-                            Thread.sleep(200);
-                        } catch(Exception e) {
-                            e.printStackTrace();
-                        }
-                    }
-                }
-            }
-            /* store */
-            mNxpPrefsEditor.putBoolean(PREF_SECURE_ELEMENT_ON, true);
-            mNxpPrefsEditor.putInt(PREF_SECURE_ELEMENT_ID, mSelectedSeId);
-            mNxpPrefsEditor.apply();
-
-            mNfcSecureElementState = true;
-
-            return ErrorCodes.SUCCESS;
-        }
-
-        public void MifareDesfireRouteSet(int routeLoc, boolean fullPower, boolean lowPower, boolean noPower)
-        throws RemoteException
-        {
-            int protoRouteEntry = 0;
-            protoRouteEntry=((routeLoc & 0x03)== 0x01) ? (0x01 << ROUTE_LOC_MASK) : (((routeLoc & 0x03) == 0x02) ? (0x02 << ROUTE_LOC_MASK) : 0x00) ;
-            protoRouteEntry |= ((fullPower ? (mDeviceHost.getDefaultDesfirePowerState() & 0x1F) | 0x01 : 0) | (lowPower ? 0x01 << 1 :0 ) | (noPower ? 0x01 << 2 :0));
-
-            if(routeLoc == 0x00)
-            {
-                /*
-                bit pos 1 = Power Off
-                bit pos 2 = Battery Off
-                bit pos 4 = Screen Off
-                Set these bits to 0 because in case routeLoc = HOST it can not work on POWER_OFF, BATTERY_OFF and SCREEN_OFF*/
-                protoRouteEntry &= 0xE9;
-            }
-
-            Log.i(TAG,"MifareDesfireRouteSet : " + protoRouteEntry);
-            mNxpPrefsEditor = mNxpPrefs.edit();
-            mNxpPrefsEditor.putInt("PREF_MIFARE_DESFIRE_PROTO_ROUTE_ID", protoRouteEntry);
-            mNxpPrefsEditor.commit();
-            Log.i(TAG,"MifareDesfireRouteSet function in");
-            commitRouting();
-        }
-
         public void DefaultRouteSet(int routeLoc, boolean fullPower, boolean lowPower, boolean noPower)
                 throws RemoteException
         {
+            if((mChipVer < PN553_ID) && (routeLoc == UICC2_ID_TYPE)) {
+                throw new RemoteException("UICC2 is not supported");
+            }
             if (mIsHceCapable) {
                 int protoRouteEntry = 0;
-                protoRouteEntry=((routeLoc & 0x03)== 0x01) ? (0x01 << ROUTE_LOC_MASK) : (((routeLoc & 0x03) == 0x02) ? (0x02 << ROUTE_LOC_MASK) : 0x00) ;
+                protoRouteEntry=((routeLoc & 0x07) == 0x04) ? (0x03 << ROUTE_LOC_MASK) : /*UICC2*/
+                                ((routeLoc & 0x07) == 0x02) ? (0x02 << ROUTE_LOC_MASK) : /*UICC1*/
+                                ((routeLoc & 0x07) == 0x01) ? (0x01 << ROUTE_LOC_MASK) : /*eSE*/
+                                0x00;
                 protoRouteEntry |= ((fullPower ? (mDeviceHost.getDefaultAidPowerState() & 0x1F) | 0x01 : 0) | (lowPower ? 0x01 << 1 :0 ) | (noPower ? 0x01 << 2 :0));
 
                 if(routeLoc == 0x00)
@@ -2373,20 +2295,6 @@ public class NfcService implements DeviceHostListener {
             }
         }
 
-        public void MifareCLTRouteSet(int routeLoc, boolean fullPower, boolean lowPower, boolean noPower)
-        throws RemoteException
-        {
-            int techRouteEntry=0;
-            techRouteEntry=((routeLoc & 0x03) == 0x01) ? (0x01 << ROUTE_LOC_MASK) : (((routeLoc & 0x03) == 0x02) ? (0x02 << ROUTE_LOC_MASK) : 0x00);
-            techRouteEntry |= ((fullPower ? (mDeviceHost.getDefaultMifareCLTPowerState() & 0x1F) | 0x01 : 0) | (lowPower ? 0x01 << 1 :0 ) | (noPower ? 0x01 << 2 :0));
-            techRouteEntry |= (TECH_TYPE_A << TECH_TYPE_MASK);
-
-            Log.i(TAG,"MifareCLTRouteSet : " + techRouteEntry);
-            mNxpPrefsEditor = mNxpPrefs.edit();
-            mNxpPrefsEditor.putInt("PREF_MIFARE_CLT_ROUTE_ID", techRouteEntry);
-            mNxpPrefsEditor.commit();
-            commitRouting();
-        }
         @Override
         public byte[] getFWVersion()
         {
@@ -2400,6 +2308,22 @@ public class NfcService implements DeviceHostListener {
             return buf;
         }
 
+        @Override
+        public byte[] readerPassThruMode(byte status, byte modulationTyp)
+            throws RemoteException {
+
+          Log.i(TAG, "Reader pass through mode request: 0x" + status +
+                         " with modulation: 0x" + modulationTyp);
+          return mDeviceHost.readerPassThruMode(status, modulationTyp);
+        }
+
+        @Override
+        public byte[] transceiveAppData(byte[] data) throws RemoteException {
+
+          Log.i(TAG, "Transceive requested on reader pass through mode");
+          return mDeviceHost.transceiveAppData(data);
+        }
+
         @Override
         public Map<String,Integer> getServicesAidCacheSize(int userId, String category){
             return mCardEmulationManager.getServicesAidCacheSize(userId, category);
@@ -2410,11 +2334,6 @@ public class NfcService implements DeviceHostListener {
             return mCardEmulationManager.updateServiceState(userId ,serviceState);
         }
 
-        @Override
-        public int getSeInterface(int type) throws RemoteException {
-            return mDeviceHost.doGetSeInterface(type);
-        }
-
         @Override
         public int getMaxAidRoutingTableSize() throws RemoteException {
             NfcPermissions.enforceUserPermissions(mContext);
@@ -2442,7 +2361,7 @@ public class NfcService implements DeviceHostListener {
             /*check if format of configs is fine*/
             /*Save configurations to file*/
             try {
-                File newTextFile = new File("/data/vendor/nfc/libnfc-nxpTransit.conf");
+                File newTextFile = new File("/data/nfc/libnfc-nxpTransit.conf");
                 if(configs == null)
                 {
                     if(newTextFile.delete()){
@@ -2458,6 +2377,7 @@ public class NfcService implements DeviceHostListener {
                     fw.close();
                     Log.e(TAG, "File Written to libnfc-nxpTransit.conf successfully" );
                 }
+                mDeviceHost.setTransitConfig(configs);
             } catch (Exception e) {
                 e.printStackTrace();
                 return TRANSIT_SETCONFIG_STAT_FAILED;
@@ -2466,7 +2386,9 @@ public class NfcService implements DeviceHostListener {
             /*restart NFC service*/
             try {
                 mNfcAdapter.disable(true);
+                WaitForAdapterChange(NfcAdapter.STATE_OFF);
                 mNfcAdapter.enable();
+                WaitForAdapterChange(NfcAdapter.STATE_ON);
             } catch (Exception e) {
                 Log.e(TAG, "Unable to restart NFC Service");
                 e.printStackTrace();
@@ -2474,36 +2396,166 @@ public class NfcService implements DeviceHostListener {
             }
             return TRANSIT_SETCONFIG_STAT_SUCCESS;
         }
-    }
 
-    final class ReaderModeDeathRecipient implements IBinder.DeathRecipient {
-        @Override
-        public void binderDied() {
-            synchronized (NfcService.this) {
-                if (mReaderModeParams != null) {
-                    mReaderModeParams = null;
-                    Log.e(TAG, "applyRouting -5");
-                    applyRouting(false);
+        private void WaitForAdapterChange(int state) {
+            while (true) {
+                if(mState == state) {
+                    break;
+                }
+                try {
+                    Thread.sleep(100);
+                } catch (Exception e) {
+                    e.printStackTrace();
                 }
             }
+            return;
         }
-    }
 
-    final class TagService extends INfcTag.Stub {
         @Override
-        public int connect(int nativeHandle, int technology) throws RemoteException {
-            NfcPermissions.enforceUserPermissions(mContext);
-
-            TagEndpoint tag = null;
-
+        public int mPOSSetReaderMode (String pkg, boolean on) {
+            NfcService.this.enforceNfceeAdminPerm(pkg);
+            // Check if NFC is enabled
             if (!isNfcEnabled()) {
-                return ErrorCodes.ERROR_NOT_INITIALIZED;
+                return NxpConstants.MPOS_STATUS_REJECTED;
             }
 
-            /* find the tag in the hmap */
-            tag = (TagEndpoint) findObject(nativeHandle);
-            if (tag == null) {
-                return ErrorCodes.ERROR_DISCONNECT;
+            synchronized(NfcService.this) {
+                int status = mDeviceHost.mposSetReaderMode(on);
+                if(!on) {
+                    if(nci_version != NCI_VERSION_2_0) {
+                        applyRouting(true);
+                    } else if(mScreenState == ScreenStateHelper.SCREEN_STATE_ON_UNLOCKED
+                            || mNfcUnlockManager.isLockscreenPollingEnabled()) {
+                        applyRouting(false);
+                    }
+                }
+                return status;
+            }
+        }
+
+        @Override
+        public boolean mPOSGetReaderMode (String pkg) {
+            NfcService.this.enforceNfceeAdminPerm(pkg);
+            // Check if NFC is enabled
+            if (!isNfcEnabled()) {
+                return false;
+            }
+
+            boolean status = false;
+            synchronized(NfcService.this) {
+                status = mDeviceHost.mposGetReaderMode();
+            }
+            return status;
+        }
+
+        @Override
+        public void stopPoll(String pkg, int mode) {
+            NfcService.this.enforceNfceeAdminPerm(pkg);
+            // Check if NFC is enabled
+            if (!isNfcEnabled()) {
+                return;
+            }
+
+            synchronized(NfcService.this) {
+                mDeviceHost.stopPoll(mode);
+            }
+        }
+
+        @Override
+        public void startPoll(String pkg) {
+            NfcService.this.enforceNfceeAdminPerm(pkg);
+           // Check if NFC is enabled
+            if (!isNfcEnabled()) {
+                return;
+            }
+
+            synchronized(NfcService.this) {
+                mDeviceHost.startPoll();
+            }
+        }
+
+        @Override
+        public int nfcSelfTest(String pkg, int type) {
+            int status = 0xFF;
+            NfcService.this.enforceNfceeAdminPerm(pkg);
+
+            synchronized(NfcService.this) {
+                status = mDeviceHost.doNfcSelfTest(type);
+            }
+            return status;
+        }
+
+        @Override
+        public int getSelectedUicc() throws RemoteException {
+            if (!isNfcEnabled()) {
+                throw new RemoteException("NFC is not enabled");
+            }
+            return mDeviceHost.doGetSelectedUicc();
+        }
+
+        @Override
+        public int selectUicc(int uiccSlot) throws RemoteException {
+            synchronized(NfcService.this) {
+                if (!isNfcEnabled()) {
+                    throw new RemoteException("NFC is not enabled");
+                }
+                int status =  mDeviceHost.doselectUicc(uiccSlot);
+                Log.i(TAG, "Update routing table");
+                /*In case of UICC connected and Enabled or Removed ,
+                 *Reconfigure the routing table based on current UICC parameters
+                 **/
+                if((status == 0x00)||(status == 0x01))
+                {
+                    mPrefsEditor.putInt(PREF_CUR_SELECTED_UICC_ID, uiccSlot);
+                    mPrefsEditor.apply();
+                    if((mAidRoutingManager != null) && (mCardEmulationManager != null))
+                    {
+                        Log.i(TAG, "Update routing table");
+                        mAidRoutingManager.onNfccRoutingTableCleared();
+                        mIsRoutingTableDirty = true;
+                        mCardEmulationManager.onNfcEnabled();
+                    }
+                    else
+                    {
+                        Log.i(TAG, "Update only Mifare and Desfire route");
+                        mIsRoutingTableDirty = true;
+                        applyRouting(false);
+                    }
+                }
+                return status;
+            }
+        }
+
+    }
+
+    final class ReaderModeDeathRecipient implements IBinder.DeathRecipient {
+        @Override
+        public void binderDied() {
+            synchronized (NfcService.this) {
+                if (mReaderModeParams != null) {
+                    mReaderModeParams = null;
+                    Log.e(TAG, "applyRouting -5");
+                    applyRouting(false);
+                }
+            }
+        }
+    }
+
+    final class TagService extends INfcTag.Stub {
+        @Override
+        public int connect(int nativeHandle, int technology) throws RemoteException {
+            NfcPermissions.enforceUserPermissions(mContext);
+
+            TagEndpoint tag = null;
+
+            if (!isNfcEnabled()) {
+                return ErrorCodes.ERROR_NOT_INITIALIZED;
+            }
+
+            /* find the tag in the hmap */
+            tag = (TagEndpoint) findObject(nativeHandle);
+            if (tag == null) {
+                return ErrorCodes.ERROR_DISCONNECT;
             }
 
             if (!tag.isPresent()) {
@@ -2816,636 +2868,83 @@ public class NfcService implements DeviceHostListener {
         }
     }
 
-    final class NfcJcopService extends IJcopService.Stub{
-
-        public int jcopOsDownload(String pkg) throws RemoteException
-        {
-            NfcService.this.enforceNfceeAdminPerm(pkg);
-            int status = ErrorCodes.SUCCESS;
-            boolean mode;
-            mode = mDeviceHost.doCheckJcopDlAtBoot();
-            if(mode == false) {
-                Log.i(TAG, "Starting getChipName");
-                int Ver = mDeviceHost.getChipVer();
-                if(Ver == PN80T_ID || Ver == PN67T_ID || Ver == PN66T_ID || Ver == PN65T_ID) {
-                    status = mDeviceHost.JCOSDownload();
-            }
-            else {
-                status = ErrorCodes.ERROR_NOT_SUPPORTED;
-                }
-            }
-            else {
-                status = ErrorCodes.ERROR_NOT_SUPPORTED;
-            }
-            return status;
-        }
-    }
-    final class EseClientServicesAdapter extends IeSEClientServicesAdapter.Stub{
-        @Override
-        public IJcopService getJcopService() {
-            if(mJcopService == null){
-                mJcopService = new NfcJcopService();
-            }
-            return mJcopService;
-        }
-        @Override
-        public ILoaderService getLoaderService() {
-            if(mAlaService == null){
-                mAlaService = new NfcAlaService();
-            }
-            return mAlaService;
-        }
-        @Override
-        public INxpExtrasService getNxpExtrasService() {
-            if(mNxpExtras == null){
-                mNxpExtras = new NxpExtrasService();
+    final class NfcDtaService extends INfcDta.Stub {
+        public void enableDta() throws RemoteException {
+            NfcPermissions.enforceAdminPermissions(mContext);
+            if(!sIsDtaMode) {
+                mDeviceHost.enableDtaMode();
+                sIsDtaMode = true;
+                Log.d(TAG, "DTA Mode is Enabled ");
             }
-            return mNxpExtras;
-        }
-    };
-
-    final class NfcAlaService extends ILoaderService.Stub{
-        private boolean isRecovery = false;
-        private String appName = null;
-        private String srcIn = null;
-        private String respOut = null;
-        private String status = "false";
-
-        void NfcAlaService()
-        {
-            appName = null;
-            srcIn = null;
-            respOut = null;
-            status = "false";
-            isRecovery = false;
         }
-        private synchronized void LSReexecute()
-        {
-             byte[] ret = {0x4E,0x02,(byte)0x69,(byte)0x87};
-             byte retry = LS_RETRY_CNT;
-             PrintWriter out= null;
-             BufferedReader br = null;
-             Log.i(TAG, "Enter: NfcAlaService constructor");
-             try{
-             File f = new File(LS_BACKUP_PATH);
-
-             Log.i(TAG, "Enter: NfcAlaService constructor file open");
-             /*If the file does not exists*/
-             if(!(f.isFile()))
-             {
-                 Log.i(TAG, "FileNotFound ls backup");
-                 this.status = null;
-             }
-             /*If the file exists*/
-             else
-             {
-                 Log.i(TAG, "File Found ls backup");
-                 br = new BufferedReader(new FileReader(LS_BACKUP_PATH));
-                 this.appName = br.readLine();
-                 this.srcIn = br.readLine();
-                 this.respOut = br.readLine();
-                 this.status = br.readLine();
-             }
-             }catch(FileNotFoundException f)
-             {
-                 Log.i(TAG, "FileNotFoundException Raised during LS Initialization");
-                 return;
-             }
-             catch(IOException ie)
-             {
-                 Log.i(TAG, "IOException Raised during LS Initialization ");
-                 return;
-             }
-             finally{
-                 try{
-                 if(br != null)
-                     br.close();
-                 /*If the file does not exist or empty file */
-                 if(this.status == null)
-                 {
-                     out = new PrintWriter(LS_BACKUP_PATH);
-                     this.status = "true";
-                     out.println("null");
-                     out.println("null");
-                     out.println("null");
-                     out.println("true");
-                 }
-                 }catch(IOException e)
-                 {
-                     Log.i(TAG, "IOException Raised during LS Initialization ");
-                     return;
-                 }
-                 finally{
-                     if(this.status == null)
-                         this.status = "true";
-                     if(out != null)
-                         out.close();
-                 }
-             }
-             if(this.status.equals("true"))
-             {
-                 Log.i(TAG, "LS Script execution completed");
-             }
-             else
-             {
-                 Log.i(TAG, "LS Script execution aborted or tear down happened");
-                 Log.i(TAG, "Input script path"+ this.srcIn);
-                 Log.i(TAG, "Output response path"+ this.respOut);
-                 Log.i(TAG, "Application name which invoked LS"+ this.appName);
-                 try{
-                 File fSrc = new File(this.srcIn);
-                 File fRsp = new File(this.respOut);
-                 if((fSrc.isFile() && fRsp.isFile()))
-                 {
-                     byte[] lsAppletStatus = {0x6F,0x00};
-                         /*Perform lsExecuteScript on tear down*/
-                         WatchDogThread watchDog =
-                               new WatchDogThread("Loader service ", INIT_WATCHDOG_LS_MS);
-                         watchDog.start();
-                         try {
-                             mRoutingWakeLock.acquire();
-                              try {
-                                  /*Reset retry counter*/
-                                  while((retry-- > 0))
-                                  {
-                                      Thread.sleep(1000);
-                                      lsAppletStatus = mNfcAla.doLsGetAppletStatus();
-                                      if((lsAppletStatus[0]==0x63) && (lsAppletStatus[1]==0x40))
-                                      {
-                                          Log.i(TAG, "Started LS recovery since previous session failed");
-                                          this.isRecovery = true;
-                                          ret = this.lsExecuteScript(this.srcIn, this.respOut);
-                                      }
-                                      else
-                                      {
-                                          break;
-                                      }
-                                  }
-                                  } finally {
-                                      this.isRecovery = false;
-                                      watchDog.cancel();
-                                      mRoutingWakeLock.release();
-                                }
-                              }
-                         catch(RemoteException ie)
-                         {
-                             Log.i(TAG, "LS recovery Exception: ");
-                         }
-                         lsAppletStatus = mNfcAla.doLsGetAppletStatus();
-                         if((lsAppletStatus[0]==(byte)0x90)&&(lsAppletStatus[1]==(byte)0x00))
-                         {
-                            out = new PrintWriter(LS_BACKUP_PATH);
-                            out.println("null");
-                            out.println("null");
-                            out.println("null");
-                            out.println("true");
-                            out.close();
-                            Log.i(TAG, "Commiting Default Values of Loader Service AS RETRY ENDS: ");
-                         }
-             }
-             else
-             {
-                 Log.i(TAG, "LS recovery not required");
-             }
-            }catch(InterruptedException re)
-            {
-                /*Retry failed todo*/
-                Log.i(TAG, "InterruptedException while LS recovery");
-            }catch(FileNotFoundException re)
-            {
-                /*Retry failed todo*/
-                Log.i(TAG, "FileNotFoundException while LS recovery");
-            }
-           }
-         }
-         private void updateLoaderService() {
-             byte[] ret = {0x4E,0x02,(byte)0x69,(byte)0x87};
-            Log.i(TAG, "Enter: NfcAlaService constructor file open");
-             File f = new File(LS_UPDATE_BACKUP_PATH);
-            /*If the file exists*/
-            if((f.isFile()))
-            {
-                Log.i(TAG, "File Found LS update required");
-                WatchDogThread watchDog =
-                       new WatchDogThread("LS Update Loader service ", (INIT_WATCHDOG_LS_MS+INIT_WATCHDOG_LS_MS));
-               watchDog.start();
-               try {
-                       try {
-                               /*Reset retry counter*/
-                               {
-                                       Log.i(TAG, "Started LS update");
-                                       ret = this.lsExecuteScript(LS_UPDATE_BACKUP_PATH, LS_UPDATE_BACKUP_OUT_PATH);
-                                       if(ret[2] == (byte)(0x90) && ret[3] == (byte)(0x00))
-                                       {
-                                               Log.i(TAG, " LS update successfully completed");
-                                               f.delete();
-                                       } else {
-                                               Log.i(TAG, " LS update failed");
-                                       }
-                               }
-                       } finally {
-                               watchDog.cancel();
-                       }
-               }
-               catch(RemoteException ie)
-               {
-                       Log.i(TAG, "LS update recovery Exception: ");
-               }
-            }
-            /*If the file does not exists*/
-            else
-            {
-                Log.i(TAG, "No LS update");
-            }
-       }
-
-        public byte[] lsExecuteScript( String srcIn, String respOut) throws RemoteException {
-            String pkg_name = getCallingAppPkg(mContext);
-            byte[] sha_data = CreateSHA(pkg_name, 2);
-            byte[] respSW = {0x4e,0x02,0x69,(byte)0x87};
-            InputStream is = null;
-            OutputStream os = null;
-            PrintWriter out = null;
-            FileReader fr = null;
-            byte[] buffer = new byte[1024];
-            int length = 0;
-            String srcBackup = srcIn+"mw";
-            String rspBackup = null;
-            File rspFile = null;
-            if(respOut != null)
-            rspBackup = respOut+"mw";
-            File srcFile = new File(srcBackup);
-            if(respOut != null)
-            rspFile = new File(rspBackup);
-
-
-            /*If Previously Tear down happened before completion of LS execution*/
-            if(this.isRecovery != false)
-            {
-                try{
-                fr =  new FileReader(LS_BACKUP_PATH);
-                if(fr != null)
-                {
-                    BufferedReader br = new BufferedReader(fr);
-                    if(br != null)
-                    {
-                        String appName = br.readLine();
-                        if(appName != null)
-                        {
-                            sha_data = CreateSHA(appName, 2);
-                            pkg_name = appName;
-                        }
-                    }
-                   }
-                }catch(IOException ioe)
-                {
-                    Log.i(TAG, "IOException thrown for opening ");
-                }
-                finally{
-                    try{
-                    if(fr != null)
-                        fr.close();
-                    }
-                    catch(IOException e)
-                    {
-                        Log.i(TAG, "IOException thrown for opening ");
-                    }
-                }
-            }
-            /*Store it in File*/
-            try{
-            out = new PrintWriter(LS_BACKUP_PATH);
-            out.println(pkg_name);
-            out.println(srcIn);
-            out.println(respOut);
-            out.println(false);
-            }catch(IOException fe)
-            {
-                Log.i(TAG, "IOException thrown during clearing ");
-            }
-            finally{
-                if(out != null)
-                out.close();
-            }
-            try{
-                /*To avoid rewriting of backup file*/
-                if(!(this.isRecovery)){
-                is = new FileInputStream(srcIn);
-                os = new FileOutputStream(srcBackup);
 
-                while((length = is.read(buffer))>0)
-                {
-                    os.write(buffer,0,length);
-                }
-                if(is != null)is.close();
-                if(os != null)os.close();}
-                Log.i(TAG, "sha_data len : " + sha_data.length);
-                Log.i(TAG, "Calling package APP Name is "+ pkg_name);
-                if(sha_data != null)
-                {
-                    respSW = mNfcAla.doLsExecuteScript(srcBackup, rspBackup, sha_data);
-                }
-                /*resp file is not null*/
-                if(respOut != null){
-                    is = new FileInputStream(rspBackup);
-                    os = new FileOutputStream(respOut);
-                    length = 0;
-                    while((length = is.read(buffer))>0)
-                    {
-                       os.write(buffer,0,length);
-                    }
-                }
-                if(is != null)is.close();
-                if(os != null)os.close();
-            }catch(IOException ioe)
-            {
-                Log.i(TAG, "LS File not found");
-            }catch(SecurityException se)
-            {
-                Log.i(TAG, "LS File access permission deneied");
-            }
-            finally{
-            byte[] status = mNfcAla.doLsGetStatus();
-            Log.i(TAG, "LS getStatus return SW1 : "+status[0]);
-            Log.i(TAG, "LS getStatus return  SW2: "+status[1]);
-            if((status[0]== (byte)0x90) && (status[1] == 0x00))
-            {
-                try{
-                out = new PrintWriter(LS_BACKUP_PATH);
-                out.println("null");
-                out.println("null");
-                out.println("null");
-                out.println("true");
-                }catch(IOException fe)
-                {
-                    Log.i(TAG, "FileNotFoundException thrown during clearing ");
-                }
-                finally
-                {
-                    if(out != null)
-                    out.close();
-                }
-                Log.i(TAG, "COMMITTING THE DEFAULT VALUES OF LS : ");
-                srcFile.delete();
-                rspFile.delete();
-            }
-            else
-            {
-                Log.i(TAG, "NOT COMMITTING THE DEFAULT VALUES OF LS : ");
+        public void disableDta() throws RemoteException {
+            NfcPermissions.enforceAdminPermissions(mContext);
+            if(sIsDtaMode) {
+                mDeviceHost.disableDtaMode();
+                sIsDtaMode = false;
             }
-          }
-            return respSW;
         }
-        public byte[] lsGetVersion()
-        {
-            byte[] respApdu = {0x4e,0x02,0x69,(byte)0x87};
 
-            respApdu = mNfcAla.doLsGetVersion();
-            return respApdu;
-        }
-        public int appletLoadApplet(String pkg, String choice) throws RemoteException {
-            String pkg_name = getCallingAppPkg(mContext);
-            int state = 0;
-            byte[] sha_data = CreateSHA(pkg_name, 1);
-            Log.i(TAG, "sha_data len : " + sha_data.length);
+        public boolean enableServer(String serviceName, int serviceSap, int miu,
+                int rwSize,int testCaseId) throws RemoteException {
+            NfcPermissions.enforceAdminPermissions(mContext);
 
-            if(sha_data != null)
-            {
-                state = mNfcAla.doAppletLoadApplet(choice, sha_data);
-                return state;
-            }
-            else
-                return 0xFF;
-        }
-        public int getListofApplets(String pkg, String[] name) throws RemoteException {
-            int cnt = mNfcAla.GetAppletsList(name);
-            Log.i(TAG, "GetListofApplets count : " + cnt);
-            for(int i=0;i<cnt;i++) {
-                Log.i(TAG, "GetListofApplets " + name[i]);
-            }
+            if(serviceName.equals(null))
+                return false;
 
-            return cnt;
+            mP2pLinkManager.enableExtDtaSnepServer(serviceName, serviceSap, miu, rwSize,testCaseId);
+            return true;
         }
 
-        //Just Stub for compilation.
-        public byte[] getKeyCertificate() throws RemoteException {
-            return null;
+        public void disableServer() throws RemoteException {
+            NfcPermissions.enforceAdminPermissions(mContext);
+            mP2pLinkManager.disableExtDtaSnepServer();
         }
 
-    };
+        public boolean enableClient(String serviceName, int miu, int rwSize,
+                int testCaseId) throws RemoteException {
+            NfcPermissions.enforceAdminPermissions(mContext);
 
-    final class NxpExtrasService extends INxpExtrasService.Stub {
-        private Bundle writeNoException() {
-            Bundle p = new Bundle();
-            p.putInt("e", 0);
-            return p;
-        }
+            if(testCaseId == 0)
+                return false;
 
-        private Bundle writeEeException(int exceptionType, String message) {
-            Bundle p = new Bundle();
-            p.putInt("e", exceptionType);
-            p.putString("m", message);
-            return p;
+            if (testCaseId>20){
+                sIsShortRecordLayout=true;
+                testCaseId=testCaseId-20;
+            } else {
+                sIsShortRecordLayout=false;
+            }
+            Log.d("testCaseId", ""+testCaseId);
+            mP2pLinkManager.enableDtaSnepClient(serviceName, miu, rwSize, testCaseId);
+            return true;
         }
 
-        @Override
-        public Bundle getCallingAppPkg(String pkg, IBinder b) throws RemoteException {
-            NfcService.this.enforceNfceeAdminPerm(pkg);
-            Bundle result;
-            String packageName;
-            try{
-                packageName = NfcService.this.getCallingAppPkg(mContext);
-                result = writeNoException();
-                result.putString("packageName", packageName);
-            } catch(Exception e){
-                result = writeEeException(EE_ERROR_IO, e.getMessage());
-            }
-            return result;
+        public void disableClient() throws RemoteException {
+            NfcPermissions.enforceAdminPermissions(mContext);
+            mP2pLinkManager.disableDtaSnepClient();
         }
 
-        @Override
-        public boolean isEnabled()
-        {
-            try {
-                return (mState == NfcAdapter.STATE_ON);
-            } catch (Exception e) {
-                Log.d(TAG, "Exception " + e.getMessage());
+        public boolean registerMessageService(String msgServiceName)
+                throws RemoteException {
+            NfcPermissions.enforceAdminPermissions(mContext);
+            if(msgServiceName.equals(null))
                 return false;
-            }
-        }
 
+            DtaServiceConnector.setMessageService(msgServiceName);
+            return true;
+         }
+      };
+
+    final class NfcVzwService extends INfcVzw.Stub {
         @Override
-        public byte[] getSecureElementUid(String pkg) throws RemoteException {
-            NfcService.this.enforceNfceeAdminPerm(pkg);
-            return mDeviceHost.getSecureElementUid();
-        }
-
-        @Override
-        public Bundle open(String pkg, IBinder b) throws RemoteException {
-            NfcService.this.enforceNfceeAdminPerm(pkg);
-
-            Bundle result;
-            int handle = _open(b);
-            if (handle < 0) {
-                result = writeEeException(handle, "NFCEE open exception.");
-            } else {
-                result = writeNoException();
-            }
-            return result;
-        }
-
-        /**
-         * Opens a connection to the secure element.
-         *
-         * @return A handle with a value >= 0 in case of success, or a
-         *         negative value in case of failure.
-         */
-        private int _open(IBinder b) {
-            synchronized(NfcService.this) {
-                if (!isNfcEnabled()) {
-                    return EE_ERROR_NFC_DISABLED;
-                }
-                if (mInProvisionMode) {
-                    // Deny access to the NFCEE as long as the device is being setup
-                    return EE_ERROR_IO;
-                }
-
-                if (mOpenEe != null) {
-                    return EE_ERROR_ALREADY_OPEN;
-                }
-
-                boolean restorePolling = false;
-                if (mNfcPollingEnabled) {
-                    // Disable polling for tags/P2P when connecting to the SMX
-                    // on PN544-based devices. Whenever nfceeClose is called,
-                    // the polling configuration will be restored.
-                    mDeviceHost.disableDiscovery();
-                    mNfcPollingEnabled = false;
-                    restorePolling = true;
-                }
-                int handle = doOpenSecureElementConnection(0xF3);
-                if (handle < 0) {
-
-                    if (restorePolling) {
-                        mDeviceHost.enableDiscovery(mCurrentDiscoveryParameters, true);
-                        mNfcPollingEnabled = true;
-                    }
-                    return handle;
-                }
-
-                mOpenEe = new OpenSecureElement(getCallingPid(), handle, b);
-                try {
-                    b.linkToDeath(mOpenEe, 0);
-                } catch (RemoteException e) {
-                    mOpenEe.binderDied();
-                }
-
-                // Add the calling package to the list of packages that have accessed
-                // the secure element.
-                for (String packageName : mContext.getPackageManager().getPackagesForUid(getCallingUid())) {
-                    mSePackages.add(packageName);
-                }
-
-                return handle;
-           }
-        }
-
-        @Override
-        public Bundle close(String pkg, IBinder binder) throws RemoteException {
-            NfcService.this.enforceNfceeAdminPerm(pkg);
-
-            Bundle result;
-            try {
-                _nfcEeClose(getCallingPid(), binder);
-                result = writeNoException();
-            } catch (IOException e) {
-                result = writeEeException(EE_ERROR_IO, e.getMessage());
-            }
-            return result;
-        }
-        @Override
-        public Bundle transceive(String pkg, byte[] in) throws RemoteException {
-            NfcService.this.enforceNfceeAdminPerm(pkg);
-
-            Bundle result;
-            byte[] out;
-            try {
-                out = _transceive(in);
-                result = writeNoException();
-                result.putByteArray("out", out);
-            } catch (IOException e) {
-                result = writeEeException(EE_ERROR_IO, e.getMessage());
-            }
-            return result;
-        }
-
-        private byte[] _transceive(byte[] data) throws IOException {
-            synchronized(NfcService.this) {
-                if (!isNfcEnabled()) {
-                    throw new IOException("NFC is not enabled");
-                }
-                if (mOpenEe == null) {
-                    throw new IOException("NFC EE is not open");
-                }
-                if (getCallingPid() != mOpenEe.pid) {
-                    throw new SecurityException("Wrong PID");
-                }
-            }
-
-            return doTransceive(mOpenEe.handle, data);
-        }
-    };
-    final class NfcDtaService extends INxpNfcDta.Stub {
-
-        public boolean snepDtaCmd(String cmdType, String serviceName, int serviceSap, int miu, int rwSize, int testCaseId) throws RemoteException
-        {
-            NfcPermissions.enforceAdminPermissions(mContext);
-            if(cmdType.equals(null))
-                return false;
-            if(cmdType.equals("enabledta") && (!sIsDtaMode)) {
-                mDeviceHost.enableDtaMode();
-                sIsDtaMode = true;
-                Log.d(TAG, "DTA Mode is Enabled ");
-            }else if(cmdType.equals("disableDta") && (sIsDtaMode)) {
-                mDeviceHost.disableDtaMode();
-                sIsDtaMode = false;
-            } else if(cmdType.equals("enableserver")) {
-                if(serviceName.equals(null))
-                    return false;
-                mP2pLinkManager.enableExtDtaSnepServer(serviceName, serviceSap, miu, rwSize,testCaseId);
-            } else if(cmdType.equals("disableserver")) {
-                mP2pLinkManager.disableExtDtaSnepServer();
-            } else if(cmdType.equals("enableclient")) {
-               if(testCaseId == 0)
-                    return false;
-                if(testCaseId>20){
-                    sIsShortRecordLayout=true;
-                    testCaseId=testCaseId-20;
-                }else{
-                    sIsShortRecordLayout=false;
-                }
-                Log.d("testCaseId", ""+testCaseId);
-                mP2pLinkManager.enableDtaSnepClient(serviceName, miu, rwSize, testCaseId);
-            } else if(cmdType.equals("disableclient")) {
-               mP2pLinkManager.disableDtaSnepClient();
-            } else {
-                Log.d(TAG, "Unkown DTA Command");
-                return false;
-            }
-            return true;
-        }
-
-    };
-
-    final class NfcVzwService extends INfcVzw.Stub {
-        @Override
-        public void setScreenOffCondition(boolean enable) throws RemoteException {
-
-               Message msg = mHandler.obtainMessage();
-               msg.what=MSG_SET_SCREEN_STATE;
-               msg.arg1= (enable)?1:0;
-               mHandler.sendMessage(msg);
-
+        public void setScreenOffCondition(boolean enable) throws RemoteException {
+
+               Message msg = mHandler.obtainMessage();
+               msg.what=MSG_SET_SCREEN_STATE;
+               msg.arg1= (enable)?1:0;
+               mHandler.sendMessage(msg);
+
         }
 
         @Override
@@ -3514,20 +3013,8 @@ public class NfcService implements DeviceHostListener {
        }
     }
 
-    final class NfcAccessExtrasService extends INxpNfcAccessExtras.Stub {
-            public boolean checkChannelAdminAccess(String pkg) throws RemoteException {
-                boolean result = true;
-                try {
-                NfcService.this.enforceNfcSccAdminPerm(pkg);
-                } catch (Exception e) {
-                    e.printStackTrace();
-                    result = false;
-                }
-                return result;
-            }
-        };
-
     final class NfcAdapterExtrasService extends INfcAdapterExtras.Stub {
+        ActivityManager activityManager = (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);
         private Bundle writeNoException() {
             Bundle p = new Bundle();
             p.putInt("e", 0);
@@ -3546,11 +3033,15 @@ public class NfcService implements DeviceHostListener {
             NfcService.this.enforceNfceeAdminPerm(pkg);
 
             Bundle result;
-            int handle = _open(b);
-            if (handle < 0) {
-                result = writeEeException(handle, "NFCEE open exception.");
+            if (activityManager.isLowRamDevice()) {
+                result = writeEeException(SE_ACCESS_DENIED, "SE open access denied.");
             } else {
-                result = writeNoException();
+                int handle = _open(b);
+                if (handle < 0) {
+                    result = writeEeException(handle, "NFCEE open exception.");
+                } else {
+                    result = writeNoException();
+                }
             }
             return result;
         }
@@ -3623,366 +3114,90 @@ public class NfcService implements DeviceHostListener {
             NfcService.this.enforceNfceeAdminPerm(pkg);
 
             Bundle result;
-            try {
-                _nfcEeClose(getCallingPid(), binder);
-                result = writeNoException();
-            } catch (IOException e) {
-                result = writeEeException(EE_ERROR_IO, e.getMessage());
-            }
-            return result;
-        }
-
-        @Override
-        public Bundle transceive(String pkg, byte[] in) throws RemoteException {
-            NfcService.this.enforceNfceeAdminPerm(pkg);
-
-            Bundle result;
-            byte[] out;
-            try {
-                out = _transceive(in);
-                result = writeNoException();
-                result.putByteArray("out", out);
-            } catch (IOException e) {
-                result = writeEeException(EE_ERROR_IO, e.getMessage());
-            }
-            return result;
-        }
-
-        private byte[] _transceive(byte[] data) throws IOException {
-            synchronized(NfcService.this) {
-                if (!isNfcEnabled()) {
-                    throw new IOException("NFC is not enabled");
-                }
-                if (mOpenEe == null) {
-                    throw new IOException("NFC EE is not open");
-                }
-                if (getCallingPid() != mOpenEe.pid) {
-                    throw new SecurityException("Wrong PID");
-                }
-            }
-
-            return doTransceive(mOpenEe.handle, data);
-        }
-
-        @Override
-        public int getCardEmulationRoute(String pkg) throws RemoteException {
-            NfcService.this.enforceNfceeAdminPerm(pkg);
-            return mEeRoutingState;
-        }
-
-        @Override
-        public void setCardEmulationRoute(String pkg, int route) throws RemoteException {
-            NfcService.this.enforceNfceeAdminPerm(pkg);
-            mEeRoutingState = route;
-            ApplyRoutingTask applyRoutingTask = new ApplyRoutingTask();
-            applyRoutingTask.execute();
-            try {
-                // Block until route is set
-                applyRoutingTask.get();
-            } catch (ExecutionException e) {
-                Log.e(TAG, "failed to set card emulation mode");
-            } catch (InterruptedException e) {
-                Log.e(TAG, "failed to set card emulation mode");
-            }
-        }
-
-        @Override
-        public void authenticate(String pkg, byte[] token) throws RemoteException {
-            NfcService.this.enforceNfceeAdminPerm(pkg);
-        }
-
-        @Override
-        public String getDriverName(String pkg) throws RemoteException {
-            NfcService.this.enforceNfceeAdminPerm(pkg);
-            return mDeviceHost.getName();
-        }
-
-    }
-    final class NxpNfcAdapterExtrasService extends INxpNfcAdapterExtras.Stub {
-        private Bundle writeNoException() {
-            Bundle p = new Bundle();
-            p.putInt("e", 0);
-            return p;
-        }
-
-        private Bundle writeEeException(int exceptionType, String message) {
-            Bundle p = new Bundle();
-            p.putInt("e", exceptionType);
-            p.putString("m", message);
-            return p;
-        }
-
-        @Override
-        public boolean eSEChipReset(String pkg) throws RemoteException {
-            NfcService.this.enforceNfceeAdminPerm(pkg);
-            Bundle result;
-            boolean stat = false;
-            try {
-                synchronized (NfcService.this) {
-                    if (!isNfcEnabledOrShuttingDown()) {
-                       throw new IOException("NFC adapter is disabled");
-                    }
-                    if (mOpenEe == null) {
-                       throw new IOException("NFC EE closed");
-                    }
-                    stat =  mSecureElement.doeSEChipReset();
-                }
-                result = writeNoException();
-            } catch (IOException e) {
-                result = writeEeException(EE_ERROR_IO, e.getMessage());
-            }
-            return stat;
-        }
-
-        @Override
-        public boolean reset(String pkg) throws RemoteException {
-            NfcService.this.enforceNfceeAdminPerm(pkg);
-            Bundle result;
-            boolean stat = false;
-            try {
-                stat = _nfcEeReset();
-                result = writeNoException();
-            } catch (IOException e) {
-                result = writeEeException(EE_ERROR_IO, e.getMessage());
-            }
-            Log.d(TAG,"reset" + stat);
-            return stat;
-        }
 
-        boolean _nfcEeReset() throws IOException {
-            synchronized (NfcService.this) {
-                if (!isNfcEnabledOrShuttingDown()) {
-                   throw new IOException("NFC adapter is disabled");
-                }
-                if (mOpenEe == null) {
-                   throw new IOException("NFC EE closed");
+            if (activityManager.isLowRamDevice()) {
+                result = writeEeException(SE_ACCESS_DENIED, "SE close access denied.");
+            } else {
+                try {
+                    _nfcEeClose(getCallingPid(), binder);
+                    result = writeNoException();
+                } catch (IOException e) {
+                    result = writeEeException(EE_ERROR_IO, e.getMessage());
                 }
-                return mSecureElement.doReset(mOpenEe.handle);
             }
-         }
-
-        @Override
-        public int getSecureElementTechList(String pkg) throws RemoteException {
-            NfcService.this.enforceNfceeAdminPerm(pkg);
-            return mDeviceHost.doGetSecureElementTechList();
-        }
-
-        @Override
-        public byte[] getSecureElementUid(String pkg) throws RemoteException {
-            NfcService.this.enforceNfceeAdminPerm(pkg);
-            return mDeviceHost.getSecureElementUid();
-        }
-
-        @Override
-        public void notifyCheckCertResult(String pkg, boolean success)
-                throws RemoteException {
-            if (DBG) Log.d(TAG, "notifyCheckCertResult() " + pkg + ", success=" + success);
-
-            NfcService.this.enforceNfceeAdminPerm(pkg);
-            mNxpNfcController.setResultForX509Certificates(success);
-        }
-
-        @Override
-        public void deliverSeIntent(String pkg, Intent seIntent)
-                throws RemoteException {
-            Log.d(TAG, "deliverSeIntent() " + pkg + " " + seIntent.getAction());
-            NfcService.this.enforceNfceeAdminPerm(pkg);
-            sendMessage(MSG_SE_DELIVER_INTENT, seIntent);
-        }
-
-        @Override
-        public byte[] doGetRouting() throws RemoteException {
-            return mDeviceHost.doGetRouting();
-        }
-
-        @Override
-        public Bundle getAtr(String pkg) throws RemoteException {
-            NfcService.this.enforceNfceeAdminPerm(pkg);
-
-            Bundle result;
-            byte[] out;
-            try {
-                out = _getAtr();
-                result = writeNoException();
-                result.putByteArray("out", out);
-            } catch (IOException e) {
-                result = writeEeException(EE_ERROR_IO, e.getMessage());
-            }
-            Log.d(TAG,"getAtr result " + result);
             return result;
         }
 
-        private byte[] _getAtr() throws IOException {
-            synchronized(NfcService.this) {
-                if (!isNfcEnabled()) {
-                    throw new IOException("NFC is not enabled");
-                }
-                if (mOpenEe == null) {
-                    throw new IOException("NFC EE is not open");
-                }
-                if (getCallingPid() != mOpenEe.pid) {
-                    throw new SecurityException("Wrong PID");
-                }
-            }
-            return mSecureElement.doGetAtr(mOpenEe.handle);
-        }
         @Override
-        public int selectUicc(int uiccSlot) throws RemoteException {
-            synchronized(NfcService.this) {
-                if (!isNfcEnabled()) {
-                    throw new RemoteException("NFC is not enabled");
-                }
-                int status =  mDeviceHost.doselectUicc(uiccSlot);
-                Log.i(TAG, "Update routing table");
-                /*In case of UICC connected and Enabled or Removed ,
-                 *Reconfigure the routing table based on current UICC parameters
-                 **/
-                if((status == 0x00)||(status == 0x01))
-                {
-                    mPrefsEditor.putInt(PREF_CUR_SELECTED_UICC_ID, uiccSlot);
-                    mPrefsEditor.apply();
-                    if((mAidRoutingManager != null) && (mCardEmulationManager != null))
-                    {
-                        Log.i(TAG, "Update routing table");
-                        mAidRoutingManager.onNfccRoutingTableCleared();
-                        mIsRoutingTableDirty = true;
-                        mCardEmulationManager.onNfcEnabled();
-                    }
-                    else
-                    {
-                        Log.i(TAG, "Update only Mifare and Desfire route");
-                        mIsRoutingTableDirty = true;
-                        applyRouting(false);
-                    }
-                }
-                return status;
-            }
-        }
-
-        @Override
-        public int getSelectedUicc() throws RemoteException {
-            if (!isNfcEnabled()) {
-                throw new RemoteException("NFC is not enabled");
-            }
-            return mDeviceHost.doGetSelectedUicc();
-        }
-
-        @Override
-        public Bundle openuicc(String pkg, IBinder b) throws RemoteException {
+        public Bundle transceive(String pkg, byte[] in) throws RemoteException {
             NfcService.this.enforceNfceeAdminPerm(pkg);
 
-        Bundle result;
-        int handle = _openuicc(b);
-        if (handle < 0) {
-            result = writeEeException(handle, "NFCEE UICC open exception.");
-        } else {
-            result = writeNoException();
-        }
-        return result;
-    }
-
-    /**
-     * Opens a connection to the UICC element.
-     *
-     * @return A handle with a value >= 0 in case of success, or a
-     *         negative value in case of failure.
-     */
-    private int _openuicc(IBinder b) {
-        synchronized(NfcService.this) {
-            if (!isNfcEnabled()) {
-                return EE_ERROR_NFC_DISABLED;
-            }
-            if (mInProvisionMode) {
-                // Deny access to the NFCEE as long as the device is being setup
-                return EE_ERROR_IO;
-            }
-            if (mOpenEe != null) {
-                return EE_ERROR_ALREADY_OPEN;
-            }
-
-            boolean restorePolling = false;
-            if (mNfcPollingEnabled) {
-                // Disable polling for tags/P2P when connecting to the SMX
-                // on PN544-based devices. Whenever nfceeClose is called,
-                // the polling configuration will be restored.
-                mDeviceHost.disableDiscovery();
-                mNfcPollingEnabled = false;
-                restorePolling = true;
-            }
-
-            int handle = doOpenSecureElementConnection(0xF4);
-            if (handle < 0) {
-
-                if (restorePolling) {
-                    mDeviceHost.enableDiscovery(mCurrentDiscoveryParameters, true);
-                    mNfcPollingEnabled = true;
-                }
-                return handle;
-            }
-
-            mOpenEe = new OpenSecureElement(getCallingPid(), handle, b);
-            try {
-                b.linkToDeath(mOpenEe, 0);
-            } catch (RemoteException e) {
-                mOpenEe.binderDied();
-            }
+            Bundle result;
 
-            // Add the calling package to the list of packages that have accessed
-            // the secure element.
-            for (String packageName : mContext.getPackageManager().getPackagesForUid(getCallingUid())) {
-                mSePackages.add(packageName);
+            if (activityManager.isLowRamDevice()) {
+                result = writeEeException(SE_ACCESS_DENIED, "SE transceive access denied.");
+            } else {
+                byte[] out;
+                try {
+                    out = _transceive(in);
+                    result = writeNoException();
+                    result.putByteArray("out", out);
+                } catch (IOException e) {
+                    result = writeEeException(EE_ERROR_IO, e.getMessage());
+                }
             }
+            return result;
+        }
 
-            return handle;
-       }
-    }
+        private byte[] _transceive(byte[] data) throws IOException {
+            synchronized(NfcService.this) {
+                if (!isNfcEnabled()) {
+                    throw new IOException("NFC is not enabled");
+                }
+                if (mOpenEe == null) {
+                    throw new IOException("NFC EE is not open");
+                }
+                if (getCallingPid() != mOpenEe.pid) {
+                    throw new SecurityException("Wrong PID");
+                }
+            }
 
-    @Override
-    public Bundle closeuicc(String pkg, IBinder binder) throws RemoteException {
-        NfcService.this.enforceNfceeAdminPerm(pkg);
+            return doTransceive(mOpenEe.handle, data);
+        }
 
-        Bundle result;
-        try {
-            Log.w("Nxp", "Close UICC!");
-            _nfcEeClose(getCallingPid(), binder);
-            result = writeNoException();
-        } catch (IOException e) {
-            result = writeEeException(EE_ERROR_IO, e.getMessage());
+        @Override
+        public int getCardEmulationRoute(String pkg) throws RemoteException {
+            NfcService.this.enforceNfceeAdminPerm(pkg);
+            return mEeRoutingState;
         }
-        return result;
-    }
 
-    @Override
-    public Bundle transceiveuicc(String pkg, byte[] in) throws RemoteException {
-        NfcService.this.enforceNfceeAdminPerm(pkg);
+        @Override
+        public void setCardEmulationRoute(String pkg, int route) throws RemoteException {
+            NfcService.this.enforceNfceeAdminPerm(pkg);
+            mEeRoutingState = route;
+            ApplyRoutingTask applyRoutingTask = new ApplyRoutingTask();
+            applyRoutingTask.execute();
+            try {
+                // Block until route is set
+                applyRoutingTask.get();
+            } catch (ExecutionException e) {
+                Log.e(TAG, "failed to set card emulation mode");
+            } catch (InterruptedException e) {
+                Log.e(TAG, "failed to set card emulation mode");
+            }
+        }
 
-        Bundle result;
-        byte[] out;
-        try {
-            out = _transceiveuicc(in);
-            result = writeNoException();
-            result.putByteArray("out", out);
-        } catch (IOException e) {
-            result = writeEeException(EE_ERROR_IO, e.getMessage());
+        @Override
+        public void authenticate(String pkg, byte[] token) throws RemoteException {
+            NfcService.this.enforceNfceeAdminPerm(pkg);
         }
-        return result;
-    }
 
-    private byte[] _transceiveuicc(byte[] data) throws IOException {
-        synchronized(NfcService.this) {
-            if (!isNfcEnabled()) {
-                throw new IOException("NFC is not enabled");
-            }
-            if (mOpenEe == null) {
-                throw new IOException("NFC EE is not open");
-            }
-            if (getCallingPid() != mOpenEe.pid) {
-                throw new SecurityException("Wrong PID");
-            }
+        @Override
+        public String getDriverName(String pkg) throws RemoteException {
+            NfcService.this.enforceNfceeAdminPerm(pkg);
+            return mDeviceHost.getName();
         }
 
-        return doTransceive(mOpenEe.handle, data);
-    }
     }
 
     /** resources kept while secure element is open */
@@ -4211,7 +3426,7 @@ public class NfcService implements DeviceHostListener {
                 if ((mReaderModeParams.flags & NfcAdapter.FLAG_READER_NFC_F) != 0)
                     techMask |= NFC_POLL_F;
                 if ((mReaderModeParams.flags & NfcAdapter.FLAG_READER_NFC_V) != 0)
-                    techMask |= NFC_POLL_ISO15693;
+                    techMask |= NFC_POLL_V;
                 if ((mReaderModeParams.flags & NfcAdapter.FLAG_READER_NFC_BARCODE) != 0)
                     techMask |= NFC_POLL_KOVIO;
 
@@ -4243,6 +3458,11 @@ public class NfcService implements DeviceHostListener {
             paramsBuilder.setEnableP2p(false);
         }
 
+        if (mIsHceCapable && mReaderModeParams == null) {
+            // Host routing is always enabled at lock screen or later, provided we aren't in reader mode
+             paramsBuilder.setEnableHostRouting(true);
+        }
+
         //To make routing table update.
         if(mIsRoutingTableDirty) {
             mIsRoutingTableDirty = false;
@@ -4264,6 +3484,17 @@ public class NfcService implements DeviceHostListener {
         }
         return false;
     }
+
+    private void StopPresenceChecking() {
+        Object[] objectValues = mObjectMap.values().toArray();
+        for (Object object : objectValues) {
+            if (object instanceof TagEndpoint) {
+                TagEndpoint tag = (TagEndpoint)object;
+                ((TagEndpoint) object).stopPresenceChecking();
+            }
+        }
+    }
+
     /**
      * Disconnect any target if present
      */
@@ -4460,18 +3691,6 @@ public class NfcService implements DeviceHostListener {
         return t3tIdBytes;
     }
 
-    private byte[] getT3tIdentifierBytes(String systemCode, String nfcId2) {
-        ByteBuffer buffer = ByteBuffer.allocate(NCI_SYSTEMCODE_LEN + NCI_NFCID2_LEN);
-        buffer.put(hexStringToBytes(systemCode));
-        buffer.put(hexStringToBytes(nfcId2));
-
-        byte[] t3tIdBytes = new byte[buffer.position()];
-        buffer.position(0);
-        buffer.get(t3tIdBytes);
-
-        return t3tIdBytes;
-    }
-
     public void registerT3tIdentifier(String systemCode, String nfcId2, String t3tPmm) {
         Log.d(TAG, "request to register LF_T3T_IDENTIFIER");
 
@@ -4479,13 +3698,6 @@ public class NfcService implements DeviceHostListener {
         sendMessage(MSG_REGISTER_T3T_IDENTIFIER, t3tIdentifier);
     }
 
-    public void registerT3tIdentifier(String systemCode, String nfcId2) {
-        Log.d(TAG, "request to register LF_T3T_IDENTIFIER");
-
-        byte[] t3tIdentifier = getT3tIdentifierBytes(systemCode, nfcId2);
-        sendMessage(MSG_REGISTER_T3T_IDENTIFIER, t3tIdentifier);
-    }
-
     public void deregisterT3tIdentifier(String systemCode, String nfcId2, String t3tPmm) {
         Log.d(TAG, "request to deregister LF_T3T_IDENTIFIER");
 
@@ -4493,13 +3705,6 @@ public class NfcService implements DeviceHostListener {
         sendMessage(MSG_DEREGISTER_T3T_IDENTIFIER, t3tIdentifier);
     }
 
-    public void deregisterT3tIdentifier(String systemCode, String nfcId2) {
-        Log.d(TAG, "request to deregister LF_T3T_IDENTIFIER");
-
-        byte[] t3tIdentifier = getT3tIdentifierBytes(systemCode, nfcId2);
-        sendMessage(MSG_DEREGISTER_T3T_IDENTIFIER, t3tIdentifier);
-    }
-
     public void clearT3tIdentifiersCache() {
         Log.d(TAG, "clear T3t Identifiers Cache");
         mDeviceHost.clearT3tIdentifiersCache();
@@ -4620,6 +3825,14 @@ public class NfcService implements DeviceHostListener {
         }
     }
 
+    public void updateLastScreenState()
+    {
+        Log.d(TAG, "updateLastScreenState");
+        int screen_state_mask = (mNfcUnlockManager.isLockscreenPollingEnabled()) ?
+                (ScreenStateHelper.SCREEN_POLLING_TAG_MASK | mScreenState) : mScreenState;
+        mDeviceHost.doSetScreenOrPowerState(screen_state_mask);
+    }
+
     public void etsiStartConfig(int eeHandle) {
         Log.d(TAG, "etsiStartConfig Enter");
 
@@ -4633,13 +3846,13 @@ public class NfcService implements DeviceHostListener {
         mDeviceHost.etsiReaderConfig(eeHandle);
 
         Log.d(TAG, "etsiStartConfig : notifyEEReaderEvent");
-        mDeviceHost.notifyEEReaderEvent(ETSI_READER_REQUESTED);
+        mDeviceHost.notifyEEReaderEvent(ETSI_READER_START_SUCCESS);
 
         Log.d(TAG, "etsiStartConfig : setEtsiReaederState");
         mDeviceHost.setEtsiReaederState(STATE_SE_RDR_MODE_STARTED);
         //broadcast SWP_READER_ACTIVATED evt
         Intent swpReaderRequestedIntent = new Intent();
-        swpReaderRequestedIntent.setAction(NxpConstants.ACTION_SWP_READER_REQUESTED);
+        swpReaderRequestedIntent.setAction(NxpConstants.ACTION_NFC_MPOS_READER_MODE_START_SUCCESS);
         if (DBG) {
             Log.d(TAG, "SWP READER - Requested");
         }
@@ -4659,13 +3872,16 @@ public class NfcService implements DeviceHostListener {
             return;
         }
         ETSI_STOP_CONFIG = true;
-        TagRemoveTask tagRemoveTask = new TagRemoveTask();
-        tagRemoveTask.execute(discNtfTimeout);
         Log.d(TAG, "etsiStopConfig : etsiInitConfig");
         mDeviceHost.etsiInitConfig();
 
+        Timer mTimer = new Timer();
+        TagRemoveTaskTimer tagRemoveTask = new TagRemoveTaskTimer();
+        mTimer.schedule(tagRemoveTask, ETSI_PRESENCE_CHECK_DELAY, ETSI_PRESENCE_CHECK_DELAY);
+
         Log.d(TAG, "etsiStopConfig : disableDiscovery");
-        mDeviceHost.disableDiscovery();
+        mDeviceHost.stopPoll(NxpConstants.ULTRA_LOW_POWER);
+        mTimer.cancel();
 
         if(mDeviceHost.getEtsiReaederState() == STATE_SE_RDR_MODE_STOPPED)
         {
@@ -4679,11 +3895,16 @@ public class NfcService implements DeviceHostListener {
         Log.d(TAG, "etsiStopConfig : notifyEEReaderEvent");
         mDeviceHost.notifyEEReaderEvent(ETSI_READER_STOP);
 
+        Log.d(TAG, "etsiStopConfig : enable discovery");
+        NfcDiscoveryParameters params = computeDiscoveryParameters(mScreenState);
+        boolean shouldRestart = mCurrentDiscoveryParameters.shouldEnableDiscovery();
+        mDeviceHost.enableDiscovery(params, shouldRestart);
+
         Intent swpReaderDeActivatedIntent = new Intent();
 
       //broadcast SWP_READER_DEACTIVATED evt
         swpReaderDeActivatedIntent
-                .setAction(NxpConstants.ACTION_SWP_READER_DEACTIVATED);
+                .setAction(NxpConstants.ACTION_NFC_MPOS_READER_MODE_STOP_SUCCESS);
         if (DBG) {
             Log.d(TAG, "SWP READER - DeActivated");
         }
@@ -4692,12 +3913,8 @@ public class NfcService implements DeviceHostListener {
         Log.d(TAG, "etsiStopConfig : setEtsiReaederState");
         mDeviceHost.setEtsiReaederState(STATE_SE_RDR_MODE_STOPPED);
 
-        Log.d(TAG, "etsiStopConfig : enableDiscovery");
-        mDeviceHost.enableDiscovery(mCurrentDiscoveryParameters, true);
         ETSI_STOP_CONFIG = false;
-
-        Log.d(TAG, "etsiStopConfig : updateScreenState");
-        mDeviceHost.updateScreenState();
+        updateLastScreenState();
 
         Log.d(TAG, "etsiStopConfig Exit");
     }
@@ -4845,7 +4062,7 @@ public class NfcService implements DeviceHostListener {
                     if (action.equals("com.gsma.services.nfc.action.TRANSACTION_EVENT")) {
                         byte[] byteAid = seIntent.getByteArrayExtra("com.android.nfc_extras.extra.AID");
                         byte[] data = seIntent.getByteArrayExtra("com.android.nfc_extras.extra.DATA");
-                        String seName = seIntent.getStringExtra("com.android.nfc_extras.extra.SE_NAME");
+                        String seName = seIntent.getStringExtra("com.android.nfc_extras.extra.SECURE_ELEMENT_NAME");
                         StringBuffer strAid = new StringBuffer();
                         for (int i = 0; i < byteAid.length; i++) {
                             String hex = Integer.toHexString(0xFF & byteAid[i]);
@@ -4872,7 +4089,6 @@ public class NfcService implements DeviceHostListener {
 
                         if (receptionMode == multiReceptionMode) {
                             // if multicast reception for GSMA
-                            if(DBG) Log.d(TAG, "multicast in SE DELIVER INTENT: " + gsmaIntent.toString());
                             mContext.sendBroadcast(gsmaIntent);
                         } else {
                             // if unicast reception for GSMA
@@ -4881,7 +4097,6 @@ public class NfcService implements DeviceHostListener {
                                     //start gsma
                                     gsmaIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                                     mContext.startActivity(gsmaIntent);
-                                    if(DBG) Log.d(TAG, "unicast in SE DELIVER INTENT: " + gsmaIntent.toString());
                                     mIsSentUnicastReception = true;
                                 }
                             } catch (Exception e) {
@@ -4896,6 +4111,8 @@ public class NfcService implements DeviceHostListener {
 
                 case MSG_NDEF_TAG:
                     if (DBG) Log.d(TAG, "Tag detected, notifying applications");
+                    mPowerManager.userActivity(SystemClock.uptimeMillis(),
+                            PowerManager.USER_ACTIVITY_EVENT_OTHER, 0);
                     mNumTagsDetected.incrementAndGet();
                     TagEndpoint tag = (TagEndpoint) msg.obj;
                     byte[] debounceTagUid;
@@ -4964,6 +4181,7 @@ public class NfcService implements DeviceHostListener {
                             synchronized (NfcService.this) {
                                 mDebounceTagUid = null;
                                 mDebounceTagRemovedCallback = null;
+                                mDebounceTagNativeHandle = INVALID_NATIVE_HANDLE;
                             }
                             if (debounceTagRemovedCallback != null) {
                                 try {
@@ -4981,70 +4199,6 @@ public class NfcService implements DeviceHostListener {
                     dispatchTagEndpoint(tag, readerParams);
                     break;
 
-                case MSG_CARD_EMULATION:
-                    if (DBG) Log.d(TAG, "Card Emulation message");
-                    {
-                        /* Tell the host-emu manager an AID has been selected on
-                         * a secure element.
-                         */
-                        if (mCardEmulationManager != null) {
-                            mCardEmulationManager.onOffHostAidSelected();
-                        }
-                        Pair<byte[], Pair> transactionInfo = (Pair<byte[], Pair>) msg.obj;
-                        Pair<byte[], Integer> dataSrcInfo = (Pair<byte[], Integer>) transactionInfo.second;
-
-                        String gsmaSrc = "";
-                        String gsmaDataAID = toHexString(transactionInfo.first, 0, transactionInfo.first.length);
-                        Log.d(TAG, "Event source: " + dataSrcInfo.second);
-
-                        String evtSrc = "";
-                        if(dataSrcInfo.second == UICC_ID_TYPE) {
-                            evtSrc = NxpConstants.UICC_ID;
-                            gsmaSrc = "SIM1";
-                        } else if(dataSrcInfo.second == UICC2_ID_TYPE) {
-                            evtSrc = NxpConstants.UICC2_ID;
-                            gsmaSrc = "SIM2";
-                        } else if(dataSrcInfo.second == SMART_MX_ID_TYPE) {
-                            evtSrc = NxpConstants.SMART_MX_ID;
-                            gsmaSrc = "ESE";
-                        }
-                        if (dataSrcInfo.first != null) {
-                        String evt_data = toHexString(dataSrcInfo.first, 0, dataSrcInfo.first.length);
-                        if (DBG) Log.d(TAG, "Data is : "+evt_data);
-                        }
-                        /* Send broadcast */
-                        Intent aidIntent = new Intent();
-                        aidIntent.setAction(ACTION_AID_SELECTED);
-                        aidIntent.putExtra(EXTRA_AID, transactionInfo.first);
-                        aidIntent.putExtra("com.android.nfc_extras.extra.SE_NAME", evtSrc);
-                        aidIntent.putExtra("com.android.nfc_extras.extra.DATA",dataSrcInfo.first);
-                        if (DBG) Log.d(TAG, "Broadcasting " + ACTION_AID_SELECTED);
-                        sendNfcEeAccessProtectedBroadcast(aidIntent);
-                        mIsSentUnicastReception = false;
-
-                        if(mLegacyTransactionEvent) {
-                            /* Send broadcast ordered */
-                            Intent TransactionIntent = new Intent();
-                            TransactionIntent.setAction(NxpConstants.ACTION_TRANSACTION_DETECTED);
-                            TransactionIntent.putExtra(NxpConstants.EXTRA_AID, transactionInfo.first);
-                            TransactionIntent.putExtra(NxpConstants.EXTRA_DATA, dataSrcInfo.first);
-                            TransactionIntent.putExtra(NxpConstants.EXTRA_SOURCE, evtSrc);
-
-                            if (DBG) Log.d(TAG, "Start Activity Card Emulation event");
-                            mContext.sendBroadcast(TransactionIntent, NfcPermissions.NFC_PERMISSION);
-
-                            /* Send "transaction events" to all authorized/registered components" */
-                            Intent evtIntent = new Intent();
-                            evtIntent.setAction(NxpConstants.ACTION_MULTI_EVT_TRANSACTION);
-                            evtIntent.setData(Uri.parse("nfc://secure:0/"+ gsmaSrc+"/"+ gsmaDataAID));
-                            evtIntent.putExtra(NxpConstants.EXTRA_GSMA_AID, transactionInfo.first);
-                            evtIntent.putExtra(NxpConstants.EXTRA_GSMA_DATA, dataSrcInfo.first);
-                            if (DBG) Log.d(TAG, "Broadcasting " + NxpConstants.ACTION_MULTI_EVT_TRANSACTION);
-                            sendMultiEvtBroadcast(evtIntent);
-                        }
-                    }
-                    break;
-
                 case MSG_CONNECTIVITY_EVENT:
                     if (DBG) {
                         Log.d(TAG, "SE EVENT CONNECTIVITY");
@@ -5088,7 +4242,7 @@ public class NfcService implements DeviceHostListener {
                     Intent cardRemovalIntent = new Intent();
                     cardRemovalIntent.setAction(ACTION_EMV_CARD_REMOVAL);
                     if (DBG) Log.d(TAG, "Broadcasting " + ACTION_EMV_CARD_REMOVAL);
-                    sendNfcEeAccessProtectedBroadcast(cardRemovalIntent);
+                    sendSeBroadcast(cardRemovalIntent);
                     break;
 
                 case MSG_SE_APDU_RECEIVED:
@@ -5101,7 +4255,7 @@ public class NfcService implements DeviceHostListener {
                         apduReceivedIntent.putExtra(EXTRA_APDU_BYTES, apduBytes);
                     }
                     if (DBG) Log.d(TAG, "Broadcasting " + ACTION_APDU_RECEIVED);
-                    sendNfcEeAccessProtectedBroadcast(apduReceivedIntent);
+                    sendSeBroadcast(apduReceivedIntent);
                     break;
 
                 case MSG_SE_MIFARE_ACCESS:
@@ -5116,10 +4270,12 @@ public class NfcService implements DeviceHostListener {
                         mifareAccessIntent.putExtra(EXTRA_MIFARE_BLOCK, mifareBlock);
                     }
                     if (DBG) Log.d(TAG, "Broadcasting " + ACTION_MIFARE_ACCESS_DETECTED);
-                    sendNfcEeAccessProtectedBroadcast(mifareAccessIntent);
+                    sendSeBroadcast(mifareAccessIntent);
                     break;
 
                 case MSG_LLCP_LINK_ACTIVATION:
+                    mPowerManager.userActivity(SystemClock.uptimeMillis(),
+                            PowerManager.USER_ACTIVITY_EVENT_OTHER, 0);
                     if (mIsDebugBuild) {
                         Intent actIntent = new Intent(ACTION_LLCP_UP);
                         mContext.sendBroadcast(actIntent);
@@ -5170,7 +4326,7 @@ public class NfcService implements DeviceHostListener {
                     if (DBG) Log.d(TAG, "SE FIELD ACTIVATED");
                     Intent eventFieldOnIntent = new Intent();
                     eventFieldOnIntent.setAction(ACTION_RF_FIELD_ON_DETECTED);
-                    sendNfcEeAccessProtectedBroadcast(eventFieldOnIntent);
+                    sendSeBroadcast(eventFieldOnIntent);
                     break;
                 }
                 case MSG_RESUME_POLLING:
@@ -5181,7 +4337,7 @@ public class NfcService implements DeviceHostListener {
                     if (DBG) Log.d(TAG, "SE FIELD DEACTIVATED");
                     Intent eventFieldOffIntent = new Intent();
                     eventFieldOffIntent.setAction(ACTION_RF_FIELD_OFF_DETECTED);
-                    sendNfcEeAccessProtectedBroadcast(eventFieldOffIntent);
+                    sendSeBroadcast(eventFieldOffIntent);
                     break;
                 }
 
@@ -5189,7 +4345,7 @@ public class NfcService implements DeviceHostListener {
                     if (DBG) Log.d(TAG, "SE LISTEN MODE ACTIVATED");
                     Intent listenModeActivated = new Intent();
                     listenModeActivated.setAction(ACTION_SE_LISTEN_ACTIVATED);
-                    sendNfcEeAccessProtectedBroadcast(listenModeActivated);
+                    sendSeBroadcast(listenModeActivated);
                     break;
                 }
 
@@ -5197,7 +4353,7 @@ public class NfcService implements DeviceHostListener {
                     if (DBG) Log.d(TAG, "SE LISTEN MODE DEACTIVATED");
                     Intent listenModeDeactivated = new Intent();
                     listenModeDeactivated.setAction(ACTION_SE_LISTEN_DEACTIVATED);
-                    sendNfcEeAccessProtectedBroadcast(listenModeDeactivated);
+                    sendSeBroadcast(listenModeDeactivated);
                     break;
                 }
 
@@ -5208,7 +4364,7 @@ public class NfcService implements DeviceHostListener {
                     ArrayList<Integer> techList = (ArrayList<Integer>) msg.obj;
                     Integer[] techs = techList.toArray(new Integer[techList.size()]);
                     swpReaderRequestedIntent
-                            .setAction(NxpConstants.ACTION_SWP_READER_REQUESTED);
+                            .setAction(NxpConstants.ACTION_NFC_MPOS_READER_MODE_START_SUCCESS);
                     if (DBG) {
                         Log.d(TAG, "SWP READER - Requested");
                     }
@@ -5221,26 +4377,13 @@ public class NfcService implements DeviceHostListener {
                     Intent swpReaderRequestedFailIntent = new Intent();
 
                     swpReaderRequestedFailIntent
-                    .setAction(NxpConstants.ACTION_SWP_READER_REQUESTED_FAILED);
+                    .setAction(NxpConstants.ACTION_NFC_MPOS_READER_MODE_START_FAIL);
                     if (DBG) {
                         Log.d(TAG, "SWP READER - Requested Fail");
                     }
                     mContext.sendBroadcast(swpReaderRequestedFailIntent);
                     break;
 
-                case MSG_SWP_READER_ACTIVATED:
-
-                    /* Send broadcast ordered */
-                    Intent swpReaderActivatedIntent = new Intent();
-
-                    swpReaderActivatedIntent
-                            .setAction(NxpConstants.ACTION_SWP_READER_ACTIVATED);
-                    if (DBG) {
-                        Log.d(TAG, "SWP READER - Activated");
-                    }
-                    mContext.sendBroadcast(swpReaderActivatedIntent);
-                    break;
-
                 case MSG_ETSI_START_CONFIG:
                 {
                     Log.d(TAG, "NfcServiceHandler - MSG_ETSI_START_CONFIG");
@@ -5253,7 +4396,9 @@ public class NfcService implements DeviceHostListener {
                     else{
                         eeHandle = 0x4C0;
                     }
-                    etsiStartConfig(eeHandle);
+                    synchronized (NfcService.this) {
+                        etsiStartConfig(eeHandle);
+                    }
                 }
                     break;
 
@@ -5268,32 +4413,52 @@ public class NfcService implements DeviceHostListener {
 
                     Log.d(TAG, "NfcServiceHandler - MSG_ETSI_SWP_TIMEOUT");
 
-                    mDeviceHost.setEtsiReaederState(STATE_SE_RDR_MODE_STOP_CONFIG);
-                    etsiStopConfig((int)msg.obj);
+                    /* Send broadcast ordered */
+                    Intent swpReaderTimeoutIntent = new Intent();
+
+                    swpReaderTimeoutIntent
+                            .setAction(NxpConstants.ACTION_NFC_MPOS_READER_MODE_TIMEOUT);
+                    if (DBG) {
+                        Log.d(TAG, "SWP READER - Timeout");
+                    }
+                    mContext.sendBroadcast(swpReaderTimeoutIntent);
+                    break;
+
+                case MSG_SWP_READER_RESTART:
 
+                    Log.d(TAG, "NfcServiceHandler - MSG_SWP_READER_RESTART");
+
+                    /* Send broadcast ordered */
+                    Intent swpReaderRestartIntent = new Intent();
+
+                    swpReaderRestartIntent
+                            .setAction(NxpConstants.ACTION_NFC_MPOS_READER_MODE_RESTART);
+                    if (DBG) {
+                        Log.d(TAG, "SWP READER - RESTART");
+                    }
+                    mContext.sendBroadcast(swpReaderRestartIntent);
                     break;
+
                 case MSG_APPLY_SCREEN_STATE:
 
                     mScreenState = (int)msg.obj;
 
-                    if(mScreenState == ScreenStateHelper.SCREEN_STATE_ON_UNLOCKED)
-                    {
-                      applyRouting(false);
+                    // If NFC is turning off, we shouldn't need any changes here
+                    synchronized (NfcService.this) {
+                        if (mState == NfcAdapter.STATE_TURNING_OFF)
+                            return;
                     }
+
                     int screen_state_mask = (mNfcUnlockManager.isLockscreenPollingEnabled()) ?
                                 (ScreenStateHelper.SCREEN_POLLING_TAG_MASK | mScreenState) : mScreenState;
+                    mDeviceHost.doSetScreenOrPowerState(screen_state_mask);
 
-                   if(mNfcUnlockManager.isLockscreenPollingEnabled())
+                    if(nci_version != NCI_VERSION_2_0) {
                         applyRouting(false);
-                   mDeviceHost.doSetScreenOrPowerState(screen_state_mask);
-
-/*                    mRoutingWakeLock.acquire();
-                    try {
-                        Log.e(TAG, "applyRouting -20");
+                    } else if(mScreenState == ScreenStateHelper.SCREEN_STATE_ON_UNLOCKED
+                       || mNfcUnlockManager.isLockscreenPollingEnabled()) {
                         applyRouting(false);
-                    } finally {
-                        mRoutingWakeLock.release();
-                    }*/
+                    }
                     break;
                 case MSG_TAG_DEBOUNCE:
                     // Didn't see the tag again, tag is gone
@@ -5302,6 +4467,7 @@ public class NfcService implements DeviceHostListener {
                         mDebounceTagUid = null;
                         tagRemovedCallback = mDebounceTagRemovedCallback;
                         mDebounceTagRemovedCallback = null;
+                        mDebounceTagNativeHandle = INVALID_NATIVE_HANDLE;
                     }
                     if (tagRemovedCallback != null) {
                         try {
@@ -5359,52 +4525,136 @@ public class NfcService implements DeviceHostListener {
                     mDeviceHost.unrouteApduPattern(hexStringToBytes(apdu));
                     break;
                 }
+                case MSG_TRANSACTION_EVENT:
+                    if (mCardEmulationManager != null) {
+                        mCardEmulationManager.onOffHostAidSelected();
+                    }
+                    byte[][] data = (byte[][]) msg.obj;
+                    sendOffHostTransactionEvent(data[0], data[1], data[2]);
+                    break;
                 default:
                     Log.e(TAG, "Unknown message received");
                     break;
             }
         }
 
-        private void sendNfcEeAccessProtectedBroadcast(Intent intent) {
-            intent.addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES);
-            // Resume app switches so the receivers can start activites without delay
-            mNfcDispatcher.resumeAppSwitches();
-            ArrayList<String> matchingPackages = new ArrayList<String>();
-            ArrayList<String> preferredPackages = new ArrayList<String>();
-            Log.d(TAG, "NFCINTENT sendNfcEeAccessProtectedBroadcast");
-            if(mInstalledPackages == null) {
-                Log.d(TAG, "No packages to send broadcast.");
+        private void sendOffHostTransactionEvent(byte[] aid, byte[] data, byte[] readerByteArray) {
+
+            if (!isSEServiceAvailable() || mNfcEventInstalledPackages.isEmpty()) {
                 return;
             }
-            synchronized(this) {
-                for (PackageInfo pkg : mInstalledPackages) {
-                    if (pkg != null && pkg.applicationInfo != null) {
-                         if (pkg.packageName.equals(PACKAGE_SMART_CARD_SERVICE)) {
-                            preferredPackages.add(pkg.packageName);
-                            Log.d(TAG, "NFCINTENT PACKAGE ADDED");
-                        }
-                        if (mNfceeAccessControl.check(pkg.applicationInfo)) {
-                            matchingPackages.add(pkg.packageName);
-                            if (mCardEmulationManager != null &&
-                                    mCardEmulationManager.packageHasPreferredService(pkg.packageName)) {
-                                preferredPackages.add(pkg.packageName);
-                            }
+            try {
+                String reader = new String(readerByteArray, "UTF-8");
+                String[] installedPackages = new String[mNfcEventInstalledPackages.size()];
+                boolean[] nfcAccess = mSEService.isNFCEventAllowed(reader, aid,
+                        mNfcEventInstalledPackages.toArray(installedPackages));
+                if (nfcAccess == null) {
+                    return;
+                }
+                ArrayList<String> packages = new ArrayList<String>();
+                Intent intent = new Intent(NfcAdapter.ACTION_TRANSACTION_DETECTED);
+                intent.addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES);
+                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+                intent.putExtra(NfcAdapter.EXTRA_AID, aid);
+                intent.putExtra(NfcAdapter.EXTRA_DATA, data);
+                intent.putExtra(NfcAdapter.EXTRA_SECURE_ELEMENT_NAME, reader);
+                StringBuilder aidString = new StringBuilder(aid.length);
+                for (byte b : aid) {
+                    aidString.append(String.format("%02X", b));
+                }
+                String url = new String ("nfc://secure:0/" + reader + "/" + aidString.toString());
+                intent.setData(Uri.parse(url));
+                for (int i = 0; i < nfcAccess.length; i++) {
+                    if (nfcAccess[i]) {
+                        intent.setPackage(mNfcEventInstalledPackages.get(i));
+                        mContext.sendBroadcast(intent);
+                    }
+                }
+            } catch (RemoteException e) {
+                Log.e(TAG, "Error in isNFCEventAllowed() " + e);
+            } catch (UnsupportedEncodingException e) {
+                Log.e(TAG, "Incorrect format for Secure Element name" + e);
+            }
+        }
+
+        /* Returns the list of packages that have access to NFC Events on any SE */
+        private ArrayList<String> getSEAccessAllowedPackages() {
+            if (!isSEServiceAvailable() || mNfcEventInstalledPackages.isEmpty()) {
+                return null;
+            }
+            String[] readers = null;
+            try {
+                readers = mSEService.getReaders();
+            } catch (RemoteException e) {
+                Log.e(TAG, "Error in getReaders() " + e);
+                return null;
+            }
+
+            if (readers == null || readers.length == 0) {
+                return null;
+            }
+            boolean[] nfcAccessFinal = null;
+            String[] installedPackages = new String[mNfcEventInstalledPackages.size()];
+            for (String reader : readers) {
+                try {
+                    boolean[] accessList = mSEService.isNFCEventAllowed(reader, null,
+                            mNfcEventInstalledPackages.toArray(installedPackages));
+                    if (accessList == null) {
+                        continue;
+                    }
+                    if (nfcAccessFinal == null) {
+                        nfcAccessFinal = accessList;
+                    }
+                    for (int i = 0; i < accessList.length; i++) {
+                        if (accessList[i]) {
+                            nfcAccessFinal[i] = true;
                         }
                     }
+                } catch (RemoteException e) {
+                    Log.e(TAG, "Error in isNFCEventAllowed() " + e);
+                }
+            }
+            if (nfcAccessFinal == null) {
+                return null;
+            }
+            ArrayList<String> packages = new ArrayList<String>();
+            for (int i = 0; i < nfcAccessFinal.length; i++) {
+                if (nfcAccessFinal[i]) {
+                    packages.add(mNfcEventInstalledPackages.get(i));
                 }
-                if (preferredPackages.size() > 0) {
-                    // If there's any packages in here which are preferred, only
-                    // send field events to those packages, to prevent other apps
-                    // with signatures in nfcee_access.xml from acting upon the events.
-                    for (String packageName : preferredPackages){
+            }
+            return packages;
+        }
+
+        private void sendSeBroadcast(Intent intent) {
+            intent.addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES);
+            // Resume app switches so the receivers can start activites without delay
+            mNfcDispatcher.resumeAppSwitches();
+            Log.d(TAG, "NFCINTENT sendNfcEeAccessProtectedBroadcast");
+            synchronized(this) {
+                ArrayList<String> SEPackages = getSEAccessAllowedPackages();
+                if (SEPackages!= null && !SEPackages.isEmpty()) {
+                    for (String packageName : SEPackages) {
                         intent.setPackage(packageName);
                         Log.d(TAG, "NFCINTENT SENT TO PACKAGE" + packageName);
                         mContext.sendBroadcast(intent);
                     }
-                } else {
-                    for (String packageName : matchingPackages){
-                        intent.setPackage(packageName);
-                        mContext.sendBroadcast(intent);
+                }
+                PackageManager pm = mContext.getPackageManager();
+                for (String packageName : mNfcEventInstalledPackages) {
+                    try {
+                        PackageInfo info = pm.getPackageInfo(packageName, 0);
+                        if (SEPackages != null && SEPackages.contains(packageName)) {
+                            continue;
+                        }
+                        if (info.applicationInfo != null &&
+                                ((info.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0 ||
+                                (info.applicationInfo.privateFlags & ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0)) {
+                            intent.setPackage(packageName);
+                            mContext.sendBroadcast(intent);
+                        }
+                    } catch (Exception e) {
+                        Log.e(TAG, "Exception in getPackageInfo " + e);
                     }
                 }
             }
@@ -5416,20 +4666,20 @@ public class NfcService implements DeviceHostListener {
             ComponentName unicastComponent = null;
             if(packageList.size() == 0) {
                 Log.d(TAG, "No packages to send broadcast.");
-                unicastComponent = mNxpNfcController.getUnicastPackage(intent);
+                unicastComponent = mNxpNfcController.getUnicastPackage();
                 if(unicastComponent != null)
                 {
                     intent.setComponent(unicastComponent);
                     try {
                         //start gsma
-                        Log.d(TAG, "Starting activity unicast pkg: " + unicastComponent.flattenToString());
+                        Log.d(TAG, "Starting activity uincast Pkg"+unicastComponent.flattenToString());
                         intent.addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES);
                         intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                         if(mContext.getPackageManager().resolveActivity(intent, 0) != null)
                         {
                             mContext.startActivityAsUser(intent, UserHandle.CURRENT);
                         } else {
-                            Log.w(TAG, "Intent not resolved: " + intent.toString());
+                            Log.d(TAG, "Intent not resolved");
                         }
                     } catch (Exception e) {
                         if (DBG) Log.d(TAG, "Exception: " + e.getMessage());
@@ -5507,6 +4757,7 @@ public class NfcService implements DeviceHostListener {
             if (readerParams != null) {
                 try {
                     if ((readerParams.flags & NfcAdapter.FLAG_READER_NO_PLATFORM_SOUNDS) == 0) {
+                        mVibrator.vibrate(mVibrationEffect);
                         playSound(SOUND_END);
                     }
                     if (readerParams.callback != null) {
@@ -5529,6 +4780,7 @@ public class NfcService implements DeviceHostListener {
                 unregisterObject(tagEndpoint.getHandle());
                 playSound(SOUND_ERROR);
             } else if (dispatchResult == NfcDispatcher.DISPATCH_SUCCESS) {
+                mVibrator.vibrate(mVibrationEffect);
                 playSound(SOUND_END);
             }
         }
@@ -5559,44 +4811,25 @@ public class NfcService implements DeviceHostListener {
         }
     }
 
-    class TagRemoveTask extends AsyncTask<Integer, Void, Void> {
+    class EtsiStopConfigTask extends AsyncTask<Integer, Void, Void> {
         @Override
         protected Void doInBackground(Integer... params) {
-
-                Intent swpReaderTagRemoveIntent = new Intent();
-
-                swpReaderTagRemoveIntent.setAction(NxpConstants.ACTION_SWP_READER_TAG_REMOVE);
-
-                int counter = 0;
-                int discNtfTimeout = params[0].intValue();
-
-                while(ETSI_STOP_CONFIG == true)
-                { /* Send broadcast ordered */
-
-                    if(discNtfTimeout == 0)
-                    {
-                        /*Do nothing*/
-                    }
-                    else if(counter < discNtfTimeout)
-                    {
-                        counter++;
-                    }
-                    else
-                    {
-                        ETSI_STOP_CONFIG = false;
-                        break;
-                    }
-                    if (DBG) {
-                        Log.d(TAG, "SWP READER - Tag Remove");
-                    }
-                    mContext.sendBroadcast(swpReaderTagRemoveIntent);
-                    try{
-                        Thread.sleep(1000);
-                    } catch(Exception e) {
-                        e.printStackTrace();
-                    }
-                }
+            synchronized (NfcService.this) {
+                etsiStopConfig(params[0].intValue());
                 return null;
+            }
+        }
+    }
+
+    class TagRemoveTaskTimer extends TimerTask {
+        public void run()
+        {
+            Intent swpReaderTagRemoveIntent = new Intent();
+            swpReaderTagRemoveIntent.setAction(NxpConstants.ACTION_NFC_MPOS_READER_MODE_REMOVE_CARD);
+            if (DBG) {
+                Log.d(TAG, "SWP READER - Tag Remove");
+            }
+            mContext.sendBroadcast(swpReaderTagRemoveIntent);
         }
     }
 
@@ -5619,6 +4852,39 @@ public class NfcService implements DeviceHostListener {
         }
     };
 
+    private final BroadcastReceiver mActivateSwpInterface = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+
+            String action = intent.getAction();
+
+            if(NxpConstants.CAT_ACTIVATE_NOTIFY_ACTION.equals(action)){
+
+                Log.i(TAG, "Received ACTIVATE intent:" + action);
+
+                if(mSelectedSeId != ALL_SE_ID_TYPE){
+                    mDeviceHost.doSelectSecureElement(mSelectedSeId);
+                    Log.i(TAG, "Activated:" + mSelectedSeId);
+                }
+                else{
+                    int[] seList = mDeviceHost.doGetSecureElementList();
+                    Log.i(TAG, "Activating all SE:");
+
+                    for(int i = 0; i < seList.length; i++){
+                        mDeviceHost.doActivateSecureElement(seList[i]);
+                        try{
+                            //Delay between two SE selection
+                            Thread.sleep(200);
+                        }catch(Exception e){
+                            e.printStackTrace();
+                        }
+                    }
+                }
+            }
+        }
+    };
+
+
     private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
         @Override
         public void onReceive(Context context, Intent intent) {
@@ -5659,17 +4925,41 @@ public class NfcService implements DeviceHostListener {
                         return;
                     }
                 }
-                if(nci_version != NCI_VERSION_2_0) {
+                /* This piece of code is duplicate as MSG_APPLY_SCREEN_STATE
+                is already calling applyRouting api */
+                /*if(nci_version != NCI_VERSION_2_0) {
                     new ApplyRoutingTask().execute(Integer.valueOf(screenState));
+                }*/
+
+                if( mDeviceHost.getEtsiReaederState() == STATE_SE_RDR_MODE_STOPPED ||
+                    mDeviceHost.getEtsiReaederState() == STATE_SE_RDR_MODE_INVALID) {
+                    sendMessage(NfcService.MSG_APPLY_SCREEN_STATE, screenState);
+                } else {
+                    Log.e(TAG, "mPOS in progress holding screen state "+screenState);
+                    mScreenState = screenState;
                 }
-                sendMessage(NfcService.MSG_APPLY_SCREEN_STATE, screenState);
                 Log.e(TAG, "screen state "+screenState);
                 Log.e(TAG, "screen state mScreenState "+mScreenState);
             } else if (action.equals(Intent.ACTION_USER_SWITCHED)) {
                 int screenState = mScreenStateHelper.checkScreenState();
                 int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, 0);
+                int beamSetting = PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
+                try {
+                    IPackageManager mIpm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+                    beamSetting = mIpm.getComponentEnabledSetting(new ComponentName(
+                            BeamShareActivity.class.getPackageName$(),
+                            BeamShareActivity.class.getName()),
+                            userId);
+                } catch(RemoteException e) {
+                    Log.e(TAG, "Error int getComponentEnabledSetting for BeamShareActivity");
+                }
                 synchronized (this) {
                     mUserId = userId;
+                    if (beamSetting == PackageManager.COMPONENT_ENABLED_STATE_DISABLED) {
+                       mIsNdefPushEnabled = false;
+                    } else {
+                       mIsNdefPushEnabled = true;
+                    }
                 }
                 mP2pLinkManager.onUserSwitched(getUserId());
                 if (mIsHceCapable) {
@@ -5691,13 +4981,9 @@ public class NfcService implements DeviceHostListener {
                     action.equals(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE)) {
                 updatePackageCache();
 
-                if (action.equals(Intent.ACTION_PACKAGE_REMOVED)) {
-                    // Clear the NFCEE access cache in case a UID gets recycled
-                    mNfceeAccessControl.invalidateCache();
-                }
-            } else if (action.equals(Intent.ACTION_SHUTDOWN)) {
+            } else if(action.equals(Intent.ACTION_SHUTDOWN)) {
                 mPowerShutDown = true;
-                if (DBG) Log.d(TAG, "Device is shutting down.");
+                if (DBG) Log.d(TAG,"Device is shutting down.");
                 mDeviceHost.doSetScreenOrPowerState(ScreenStateHelper.POWER_STATE_OFF);
                 if (isNfcEnabled()) {
                     mDeviceHost.shutdown();
@@ -5706,26 +4992,6 @@ public class NfcService implements DeviceHostListener {
         }
     };
 
-    final BroadcastReceiver mAlaReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            String action = intent.getAction();
-            if (NfcAdapter.ACTION_ADAPTER_STATE_CHANGED.equals(intent.getAction())) {
-                int state = intent.getIntExtra(NfcAdapter.EXTRA_ADAPTER_STATE,
-                        NfcAdapter.STATE_OFF);
-                if (state == NfcAdapter.STATE_ON) {
-                    Log.e(TAG, "Loader service update start from NFC_ON Broadcast");
-                    NfcAlaService nas = new NfcAlaService();
-                    int lsVersion = mNfcAla.doGetLSConfigVersion();
-
-                    if(lsVersion >= LOADER_SERVICE_VERSION_LOW_LIMIT &&
-                        lsVersion <= LOADER_SERVICE_VERSION_HIGH_LIMIT)
-                        nas.updateLoaderService();
-            }
-        }
-      }
-    };
-
     private final BroadcastReceiver mPolicyReceiver = new BroadcastReceiver() {
         @Override
         public void onReceive(Context context, Intent intent){
@@ -5733,7 +4999,16 @@ public class NfcService implements DeviceHostListener {
             if (DevicePolicyManager.ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED
                     .equals(action)) {
                 enforceBeamShareActivityPolicy(context,
-                        new UserHandle(getSendingUserId()), mIsNdefPushEnabled);
+                        new UserHandle(getSendingUserId()));
+            }
+        }
+    };
+
+    private final IVrStateCallbacks mVrStateCallbacks = new IVrStateCallbacks.Stub() {
+        @Override
+        public void onVrStateChanged(boolean enabled) {
+            synchronized (this) {
+                mIsVrModeEnabled = enabled;
             }
         }
     };
@@ -5778,9 +5053,9 @@ public class NfcService implements DeviceHostListener {
             if (mIsHceCapable) {
                 mCardEmulationManager.dump(fd, pw, args);
             }
-            mNfceeAccessControl.dump(fd, pw, args);
             mNfcDispatcher.dump(fd, pw, args);
-            pw.println(mDeviceHost.dump());
+            pw.flush();
+            mDeviceHost.dump(fd);
 
         }
     }
diff --git a/src/com/android/nfc/NfcWifiProtectedSetup.java b/src/com/android/nfc/NfcWifiProtectedSetup.java
index babaaabb..7e206bce 100644
--- a/src/com/android/nfc/NfcWifiProtectedSetup.java
+++ b/src/com/android/nfc/NfcWifiProtectedSetup.java
@@ -46,7 +46,7 @@ public final class NfcWifiProtectedSetup {
 
     private static final short AUTH_TYPE_EXPECTED_SIZE = 2;
 
-    private static final short AUTH_TYPE_OPEN = 0;
+    private static final short AUTH_TYPE_OPEN = 0x0001;
     private static final short AUTH_TYPE_WPA_PSK = 0x0002;
     private static final short AUTH_TYPE_WPA_EAP =  0x0008;
     private static final short AUTH_TYPE_WPA2_EAP = 0x0010;
@@ -134,7 +134,9 @@ public final class NfcWifiProtectedSetup {
                     }
                     byte[] networkKey = new byte[fieldSize];
                     payload.get(networkKey);
-                    result.preSharedKey = "\"" + new String(networkKey) + "\"";
+                    if (fieldSize > 0) {
+                        result.preSharedKey = "\"" + new String(networkKey) + "\"";
+                    }
                     break;
                 case AUTH_TYPE_FIELD_ID:
                     if (fieldSize != AUTH_TYPE_EXPECTED_SIZE) {
@@ -152,8 +154,16 @@ public final class NfcWifiProtectedSetup {
             }
         }
 
-        if (result.preSharedKey != null && result.SSID != null) {
-            return result;
+        if (result.SSID != null) {
+            if (result.getAuthType() == WifiConfiguration.KeyMgmt.NONE) {
+                if (result.preSharedKey == null) {
+                    return result;
+                }
+            } else {
+                if (result.preSharedKey != null) {
+                    return result;
+                }
+            }
         }
 
         return null;
diff --git a/src/com/android/nfc/NfceeAccessControl.java b/src/com/android/nfc/NfceeAccessControl.java
deleted file mode 100644
index 40672148..00000000
--- a/src/com/android/nfc/NfceeAccessControl.java
+++ /dev/null
@@ -1,308 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/******************************************************************************
- *
- *  The original Work has been changed by NXP Semiconductors.
- *
- *  Copyright (C) 2015 NXP Semiconductors
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-package com.android.nfc;
-
-import java.io.File;
-import java.io.FileDescriptor;
-import java.io.FileNotFoundException;
-import java.io.FileReader;
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.util.ArrayList;
-import java.util.HashMap;
-
-import org.xmlpull.v1.XmlPullParser;
-import org.xmlpull.v1.XmlPullParserException;
-import org.xmlpull.v1.XmlPullParserFactory;
-
-import android.content.Context;
-import android.content.pm.ApplicationInfo;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-import android.content.pm.Signature;
-import android.content.pm.PackageManager.NameNotFoundException;
-import android.os.Environment;
-import android.util.Log;
-
-public class NfceeAccessControl {
-    static final String TAG = "NfceeAccess";
-    static final boolean DBG = false;
-
-    public static final String NFCEE_ACCESS_PATH = "/etc/nqnfcee_access.xml";
-
-    /**
-     * Map of signatures to valid packages names, as read from nqnfcee_access.xml.
-     * An empty list of package names indicates that any package
-     * with this signature is allowed.
-     */
-    final HashMap<Signature, String[]> mNfceeAccess;  // contents final after onCreate()
-
-    /**
-     * Map from UID to NFCEE access, used as a cache.
-     * Note: if a UID contains multiple packages they must all be
-     * signed with the same certificate so in effect UID == certificate
-     * used to sign the package.
-     */
-    final HashMap<Integer, Boolean> mUidCache;  // contents guarded by this
-
-    final Context mContext;
-    final boolean mDebugPrintSignature;
-
-    NfceeAccessControl(Context context) {
-        mContext = context;
-        mNfceeAccess = new HashMap<Signature, String[]>();
-        mUidCache = new HashMap<Integer, Boolean>();
-        mDebugPrintSignature = parseNfceeAccess();
-    }
-
-    /**
-     * Check if the {uid, pkg} combination may use NFCEE.
-     * Also verify with package manager that this {uid, pkg} combination
-     * is valid if it is not cached.
-     */
-    public boolean check(int uid, String pkg) {
-        synchronized (this) {
-            Boolean cached = mUidCache.get(uid);
-            if (cached != null) {
-                return cached;
-            }
-
-            boolean access = false;
-
-            // Ensure the claimed package is present in the calling UID
-            PackageManager pm = mContext.getPackageManager();
-            String[] pkgs = pm.getPackagesForUid(uid);
-            for (String uidPkg : pkgs) {
-                if (uidPkg.equals(pkg)) {
-                    // Ensure the package has access permissions
-                    if (checkPackageNfceeAccess(pkg)) {
-                        access = true;
-                    }
-                    break;
-                }
-            }
-
-            mUidCache.put(uid, access);
-            return access;
-        }
-    }
-
-    /**
-     * Check if the given ApplicationInfo may use the NFCEE.
-     * Assumes ApplicationInfo came from package manager,
-     * so no need to confirm {uid, pkg} is valid.
-     */
-    public boolean check(ApplicationInfo info) {
-        synchronized (this) {
-            Boolean access = mUidCache.get(info.uid);
-            if (access == null) {
-                access = checkPackageNfceeAccess(info.packageName);
-                mUidCache.put(info.uid, access);
-            }
-            return access;
-        }
-    }
-
-    public void invalidateCache() {
-        synchronized (this) {
-            mUidCache.clear();
-        }
-    }
-
-    /**
-     * Check with package manager if the pkg may use NFCEE.
-     * Does not use cache.
-     */
-    boolean checkPackageNfceeAccess(String pkg) {
-        PackageManager pm = mContext.getPackageManager();
-        try {
-            PackageInfo info = pm.getPackageInfo(pkg, PackageManager.GET_SIGNATURES);
-            if (info.signatures == null) {
-                return false;
-            }
-
-            for (Signature s : info.signatures){
-                if (s == null) {
-                    continue;
-                }
-                String[] packages = mNfceeAccess.get(s);
-                if (packages == null) {
-                    continue;
-                }
-                if (packages.length == 0) {
-                    // wildcard access
-                    if (DBG) Log.d(TAG, "Granted NFCEE access to " + pkg + " (wildcard)");
-                    return true;
-                }
-                for (String p : packages) {
-                    if (pkg.equals(p)) {
-                        // explicit package access
-                        if (DBG) Log.d(TAG, "Granted access to " + pkg + " (explicit)");
-                        return true;
-                    }
-                }
-            }
-
-            if (mDebugPrintSignature) {
-                Log.w(TAG, "denied NFCEE access for " + pkg + " with signature:");
-                for (Signature s : info.signatures) {
-                    if (s != null) {
-                        Log.w(TAG, s.toCharsString());
-                    }
-                }
-            }
-        } catch (NameNotFoundException e) {
-            // ignore
-        }
-        return false;
-    }
-
-    /**
-     * Parse nqnfcee_access.xml, populate mNfceeAccess
-     * Policy is to ignore unexpected XML elements and continue processing,
-     * except for obvious errors within a <signer> group since they might cause
-     * package names to by ignored and therefore wildcard access granted
-     * by mistake. Those errors invalidate the entire <signer> group.
-     */
-    boolean parseNfceeAccess() {
-        File file = new File(Environment.getRootDirectory(), NFCEE_ACCESS_PATH);
-        FileReader reader = null;
-        boolean debug = false;
-        try {
-            reader = new FileReader(file);
-            XmlPullParserFactory factory = XmlPullParserFactory.newInstance();
-            XmlPullParser parser = factory.newPullParser();
-            parser.setInput(reader);
-
-            int event;
-            ArrayList<String> packages = new ArrayList<String>();
-            Signature signature = null;
-            parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, false);
-            while (true) {
-                event = parser.next();
-                String tag = parser.getName();
-                if (event == XmlPullParser.START_TAG && "signer".equals(tag)) {
-                    signature = null;
-                    packages.clear();
-                    for (int i = 0; i < parser.getAttributeCount(); i++) {
-                        if ("android:signature".equals(parser.getAttributeName(i))) {
-                            signature = new Signature(parser.getAttributeValue(i));
-                            break;
-                        }
-                    }
-                    if (signature == null) {
-                        Log.w(TAG, "signer tag is missing android:signature attribute, igorning");
-                        continue;
-                    }
-                    if (mNfceeAccess.containsKey(signature)) {
-                        Log.w(TAG, "duplicate signature, ignoring");
-                        signature = null;
-                        continue;
-                    }
-                } else if (event == XmlPullParser.END_TAG && "signer".equals(tag)) {
-                    if (signature == null) {
-                        Log.w(TAG, "mis-matched signer tag");
-                        continue;
-                    }
-                    mNfceeAccess.put(signature, packages.toArray(new String[0]));
-                    packages.clear();
-                } else if (event == XmlPullParser.START_TAG && "package".equals(tag)) {
-                    if (signature == null) {
-                        Log.w(TAG, "ignoring unnested packge tag");
-                        continue;
-                    }
-                    String name = null;
-                    for (int i = 0; i < parser.getAttributeCount(); i++) {
-                        if ("android:name".equals(parser.getAttributeName(i))) {
-                            name = parser.getAttributeValue(i);
-                            break;
-                        }
-                    }
-                    if (name == null) {
-                        Log.w(TAG, "package missing android:name, ignoring signer group");
-                        signature = null;  // invalidate signer
-                        continue;
-                    }
-                    // check for duplicate package names
-                    if (packages.contains(name)) {
-                        Log.w(TAG, "duplicate package name in signer group, ignoring");
-                        continue;
-                    }
-                    packages.add(name);
-                } else if (event == XmlPullParser.START_TAG && "debug".equals(tag)) {
-                    debug = true;
-                } else if (event == XmlPullParser.END_DOCUMENT) {
-                    break;
-                }
-            }
-        } catch (XmlPullParserException e) {
-            Log.w(TAG, "failed to load NFCEE access list", e);
-            mNfceeAccess.clear();  // invalidate entire access list
-        } catch (FileNotFoundException e) {
-            Log.w(TAG, "could not find " + NFCEE_ACCESS_PATH + ", no NFCEE access allowed");
-        } catch (IOException e) {
-            Log.e(TAG, "Failed to load NFCEE access list", e);
-            mNfceeAccess.clear();  // invalidate entire access list
-        } finally {
-            if (reader != null) {
-                try {
-                    reader.close();
-                } catch (IOException e2)  { }
-            }
-        }
-        Log.i(TAG, "read " + mNfceeAccess.size() + " signature(s) for NFCEE access");
-        return debug;
-    }
-
-    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
-        pw.println("mNfceeAccess=");
-        for (Signature s : mNfceeAccess.keySet()) {
-            pw.printf("\t%s [", s.toCharsString());
-            String[] ps = mNfceeAccess.get(s);
-            for (String p : ps) {
-                pw.printf("%s, ", p);
-            }
-            pw.println("]");
-        }
-        synchronized (this) {
-            pw.println("mNfceeUidCache=");
-            for (Integer uid : mUidCache.keySet()) {
-                Boolean b = mUidCache.get(uid);
-                pw.printf("\t%d %s\n", uid, b);
-            }
-        }
-    }
-}
diff --git a/src/com/android/nfc/P2pLinkManager.java b/src/com/android/nfc/P2pLinkManager.java
index d862e2a8..ba6b29a5 100644
--- a/src/com/android/nfc/P2pLinkManager.java
+++ b/src/com/android/nfc/P2pLinkManager.java
@@ -17,7 +17,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -331,8 +331,7 @@ class P2pLinkManager implements Handler.Callback, P2pEventListener.Callback {
      /**
      * To Enable DTA SNEP Server for NFC Forum testing
      */
-    public void enableExtDtaSnepServer(String serviceName, int serviceSap, int miu, int rwSize,int testCaseId)
-    {
+    public void enableExtDtaSnepServer(String serviceName, int serviceSap, int miu, int rwSize,int testCaseId) {
         if (DBG) Log.d(TAG, "Enabling Extended DTA Server");
         mServiceName = serviceName;
         mServiceSap = serviceSap;
@@ -341,7 +340,8 @@ class P2pLinkManager implements Handler.Callback, P2pEventListener.Callback {
         mTestCaseID = testCaseId;
         synchronized (this) {
             if(mExtDtaSnepServer == null)
-            mExtDtaSnepServer = new ExtDtaSnepServer(mServiceName, mServiceSap, mDtaMiu, mDtaRwSize, mExtDtaSnepServerCallback,mContext, mTestCaseID);
+            mExtDtaSnepServer = new ExtDtaSnepServer(mServiceName, mServiceSap, mDtaMiu, mDtaRwSize,
+                                                     mExtDtaSnepServerCallback,mContext, mTestCaseID);
             mExtDtaSnepServer.start();
             mExtDtaSnepServerRunning = true;
         }
@@ -351,15 +351,11 @@ class P2pLinkManager implements Handler.Callback, P2pEventListener.Callback {
     /**
      * To Disable DTA SNEP Server for NFC Forum testing
      */
-    public void disableExtDtaSnepServer()
-    {
+    public void disableExtDtaSnepServer() {
         if (DBG) Log.d(TAG, "Disabling Extended DTA Server");
         if (!mExtDtaSnepServerRunning)
-        {
             return;
-        }
-        synchronized (this)
-        {
+        synchronized (this) {
             mExtDtaSnepServer.stop();
             mExtDtaSnepServer = null;
             mExtDtaSnepServerRunning = false;
@@ -370,8 +366,7 @@ class P2pLinkManager implements Handler.Callback, P2pEventListener.Callback {
     /**
      * To Enable DTA SNEP Client for NFC Forum testing
      */
-    public void enableDtaSnepClient(String serviceName, int miu, int rwSize, int testCaseId)
-    {
+    public void enableDtaSnepClient(String serviceName, int miu, int rwSize, int testCaseId) {
         if (DBG) Log.d(TAG, "enableDtaSnepClient");
         mClientEnabled = true;
         mServiceName = serviceName;
@@ -384,8 +379,7 @@ class P2pLinkManager implements Handler.Callback, P2pEventListener.Callback {
     /**
      * To Disable DTA SNEP Client for NFC Forum testing
      */
-    public void disableDtaSnepClient()
-    {
+    public void disableDtaSnepClient() {
         if (DBG) Log.d(TAG, "disableDtaSnepClient");
         mDtaSnepClient = null;
         mClientEnabled = false;
@@ -785,33 +779,23 @@ class P2pLinkManager implements Handler.Callback, P2pEventListener.Callback {
                     handoverClient = null;
                 }
             }
-            if (needsNdef || (needsHandover && handoverClient == null))
-            {
-                if(NfcService.sIsDtaMode) {
-                    if(mClientEnabled)
-                    {
-                        if(mDtaSnepClient == null){
+            if (needsNdef || (needsHandover && handoverClient == null)) {
+                if (NfcService.sIsDtaMode) {
+                    if (mClientEnabled) {
+                        if (mDtaSnepClient == null) {
                             if (DBG) Log.d(TAG, "Creating DTA Snep Client");
                             mDtaSnepClient = new DtaSnepClient(mServiceName, mDtaMiu, mDtaRwSize, mTestCaseID);
                         }
                     }
-                }
-                else
-                {
+                } else
                     snepClient = new SnepClient();
-                }
-                try
-                {
-                    if(NfcService.sIsDtaMode) {
-                        if(mDtaSnepClient != null)
-                        {
+                try {
+                    if (NfcService.sIsDtaMode) {
+                        if (mDtaSnepClient != null)
                             mDtaSnepClient.DtaClientOperations(mContext);
-                        }
                     }
                     else
-                    {
                         snepClient.connect();
-                    }
                     success = true;
                     mDtaSnepClient = null;
                 } catch (IOException e) {
@@ -841,7 +825,7 @@ class P2pLinkManager implements Handler.Callback, P2pEventListener.Callback {
                     if (nppClient != null) {
                         nppClient.close();
                     }
-                    if(mDtaSnepClient != null) {
+                    if (mDtaSnepClient != null) {
                         mDtaSnepClient.close();
                     }
                     return false;
@@ -1020,16 +1004,17 @@ class P2pLinkManager implements Handler.Callback, P2pEventListener.Callback {
 
         @Override
         public SnepMessage doGet(int acceptableLength, NdefMessage msg) {
-            NdefMessage response = null;
             // The NFC Forum Default SNEP server is not allowed to respond to
             // SNEP GET requests - see SNEP 1.0 TS section 6.1. However,
             // since Android 4.1 used the NFC Forum default server to
             // implement connection handover, we will support this
             // until we can deprecate it.
-            /*IncomingHandoverData inCmgHandoverData;*/
-            if(msg == null){
-            }else if((mHandoverDataParser.getIncomingHandoverData(msg)) ==  null){
-            }else{
+            NdefMessage response = null;
+            if (NfcService.sIsDtaMode){
+               if(msg != null && mHandoverDataParser.getIncomingHandoverData(msg) !=  null) {
+                   response = mHandoverDataParser.getIncomingHandoverData(msg).handoverSelect;
+               }
+            } else {
                 response = mHandoverDataParser.getIncomingHandoverData(msg).handoverSelect;
             }
             if (response != null) {
@@ -1040,8 +1025,7 @@ class P2pLinkManager implements Handler.Callback, P2pEventListener.Callback {
             }
         }
     };
-    final ExtDtaSnepServer.Callback mExtDtaSnepServerCallback = new ExtDtaSnepServer.Callback()
-    {
+    final ExtDtaSnepServer.Callback mExtDtaSnepServerCallback = new ExtDtaSnepServer.Callback() {
         @Override
         public SnepMessage doPut(NdefMessage msg) {
             mPutBeforeGet = true;
@@ -1050,16 +1034,16 @@ class P2pLinkManager implements Handler.Callback, P2pEventListener.Callback {
 
         @Override
         public SnepMessage doGet(int acceptableLength, NdefMessage msg) {
-            if((!mPutBeforeGet)) {
+            if ((!mPutBeforeGet)) {
                 return SnepMessage.getMessage(SnepMessage.RESPONSE_NOT_FOUND);
-            } else if(acceptableLength == 501) {
+            } else if (acceptableLength == 501) {
                 mPutBeforeGet = false;
                 return SnepMessage.getMessage(SnepMessage.RESPONSE_EXCESS_DATA);
-            } else if(mPutBeforeGet&&(acceptableLength == 1024)) {
+            } else if (mPutBeforeGet&&(acceptableLength == 1024)) {
                 try {
                     mPutBeforeGet = false;
                     return SnepMessage.getSuccessResponse(SnepMessage.getLargeNdef());
-                } catch(UnsupportedEncodingException e) {
+                } catch (UnsupportedEncodingException e) {
                     mPutBeforeGet = false;
                     return null;
                 }
diff --git a/src/com/android/nfc/WiredSeService.cpp b/src/com/android/nfc/WiredSeService.cpp
new file mode 100644
index 00000000..325a6cea
--- /dev/null
+++ b/src/com/android/nfc/WiredSeService.cpp
@@ -0,0 +1,182 @@
+/*
+* Copyright (C) 2018 NXP Semiconductors
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.nfc;
+
+import java.util.ArrayList;
+import android.util.Log;
+import android.os.Handler;
+import android.os.HwBinder;
+import android.os.Looper;
+import android.os.Message;
+import android.os.RemoteException;
+import java.io.IOException;
+import java.util.NoSuchElementException;
+
+import vendor.nxp.nxpwiredse.V1_0.INxpWiredSe;
+import vendor.nxp.nxpwiredse.V1_0.INxpWiredSeHalCallback;
+
+
+
+public class WiredSeService {
+
+    static final String TAG = "WiredSeService";
+
+    private static WiredSeService sService ;
+
+    private static final int EVENT_GET_HAL = 1;
+    private static final int MAX_GET_HAL_RETRY = 5;
+    private static final int GET_SERVICE_DELAY_MILLIS = 200;
+    private static int sNfcWiredSeHandle = 0;
+    private static int sWiredSeGetHalRetry = 0;
+    INxpWiredSe mWiredSEHal = null;
+
+
+    public static WiredSeService getInstance() {
+        if (sService == null) {
+            sService = new WiredSeService();
+        }
+        return sService;
+    }
+
+    private HwBinder.DeathRecipient mWiredSeDeathRecipient = new WiredSeDeathRecipient();
+
+    private
+    INxpWiredSeHalCallback.Stub mWiredSeCallback = new INxpWiredSeHalCallback.Stub() {
+     private
+      ArrayList<Byte> byteArrayToArrayList(byte[] array) {
+        ArrayList<Byte> list = new ArrayList<Byte>();
+        for (Byte b : array) {
+          list.add(b);
+        }
+        return list;
+      }
+
+     private
+      byte[] arrayListToByteArray(ArrayList<Byte> list) {
+        Byte[] byteArray = list.toArray(new Byte[list.size()]);
+        int i = 0;
+        byte[] result = new byte[list.size()];
+        for (Byte b : byteArray) {
+          result[i++] = b.byteValue();
+        }
+        return result;
+      }
+
+      @Override public int openWiredSe() {
+                Log.d(TAG, "WiredSe: openWiredSe");
+        sNfcWiredSeHandle = NfcService.getInstance().doOpenSecureElementConnection(0xF3);
+        if (sNfcWiredSeHandle <= 0) {
+          Log.e(TAG, "WiredSe: open secure element failed.");
+          sNfcWiredSeHandle = 0;
+        } else {
+          Log.d(TAG, "WiredSe: open secure element success.");
+        }
+        return sNfcWiredSeHandle;
+      }
+
+      @Override public ArrayList<Byte> transmit(ArrayList<Byte> data, int wiredSeHandle) {
+        Log.d(TAG, "WiredSe: transmit");
+        if (wiredSeHandle <= 0) {
+          Log.d(TAG, "WiredSe: Secure Element handle NULL");
+          return null;
+        } else {
+          byte[] resp = NfcService.getInstance().doTransceive(wiredSeHandle, arrayListToByteArray(data));
+          if (resp != null) {
+            Log.d(TAG, "WiredSe: response is received");
+          }
+          return byteArrayToArrayList(resp);
+        }
+      }
+
+      @Override public ArrayList<Byte> getAtr(int wiredSeHandle)
+          throws android.os.RemoteException {
+        Log.d(TAG, "WiredSe: getAtr");
+        synchronized(WiredSeService.this) {
+            return byteArrayToArrayList(NfcService.getInstance().mSecureElement.doGetAtr(wiredSeHandle));
+        }
+      }
+
+      @Override public int closeWiredSe(int wiredSeHandle) {
+                Log.d(TAG, "WiredSe: closeWiredSe");
+        NfcService.getInstance().doDisconnect(wiredSeHandle);
+        sNfcWiredSeHandle = 0;
+        return 0;
+      }
+    };
+
+    public void wiredSeInitialize() throws NoSuchElementException, RemoteException {
+        Log.e(TAG, "wiredSeInitialize Enter");
+        if (mWiredSEHal == null) {
+          mWiredSEHal = INxpWiredSe.getService();
+        }
+        if (mWiredSEHal == null) {
+          throw new NoSuchElementException("No HAL is provided for WiredSe");
+        }
+        mWiredSEHal.setWiredSeCallback(mWiredSeCallback);
+        mWiredSEHal.linkToDeath(mWiredSeDeathRecipient, 0);
+    }
+
+    public void wiredSeDeInitialize() throws NoSuchElementException, RemoteException {
+        Log.e(TAG, "wiredSeDeInitialize Enter");
+        mWiredSEHal.setWiredSeCallback(null);
+    }
+
+    class WiredSeDeathRecipient implements HwBinder.DeathRecipient {
+      @Override
+      public void serviceDied(long cookie) {
+        try{
+          Log.d(TAG, "WiredSe: serviceDied !!");
+          if(sNfcWiredSeHandle > 0) {
+            mWiredSeCallback.closeWiredSe(sNfcWiredSeHandle);
+            sNfcWiredSeHandle = 0;
+          }
+           mWiredSEHal.unlinkToDeath(mWiredSeDeathRecipient);
+           mWiredSEHal = null;
+           mWiredSeHandler.sendMessageDelayed(mWiredSeHandler.obtainMessage(EVENT_GET_HAL, 0),
+                                         GET_SERVICE_DELAY_MILLIS);
+        }catch(Exception e) {
+            e.printStackTrace();
+        }
+      }
+    }
+
+    private Handler mWiredSeHandler = new Handler(Looper.getMainLooper()) {
+      @Override
+      public void handleMessage(Message message) {
+        switch (message.what) {
+          case EVENT_GET_HAL:
+            try {
+              if(sWiredSeGetHalRetry > MAX_GET_HAL_RETRY) {
+                Log.e(TAG, "WiredSe GET_HAL retry failed");
+                sWiredSeGetHalRetry = 0;
+                break;
+              }
+              wiredSeInitialize();
+              sWiredSeGetHalRetry = 0;
+            } catch (Exception e) {
+                Log.e(TAG, " could not get the service. trying again");
+                sWiredSeGetHalRetry++;
+                sendMessageDelayed(obtainMessage(EVENT_GET_HAL, 0),
+                                     GET_SERVICE_DELAY_MILLIS);
+            }
+            break;
+          default:
+            break;
+        }
+      }
+    };
+}
diff --git a/src/com/android/nfc/beam/BeamManager.java b/src/com/android/nfc/beam/BeamManager.java
index 5aba0a2f..03346634 100644
--- a/src/com/android/nfc/beam/BeamManager.java
+++ b/src/com/android/nfc/beam/BeamManager.java
@@ -15,6 +15,8 @@
 */
 package com.android.nfc.beam;
 
+import com.android.nfc.NfcService;
+import com.android.nfc.R;
 import com.android.nfc.handover.HandoverDataParser;
 
 import android.bluetooth.BluetoothDevice;
@@ -36,7 +38,6 @@ public class BeamManager implements Handler.Callback {
     private static final String TAG = "BeamManager";
     private static final boolean DBG = false;
 
-    private static final String BLUETOOTH_PACKAGE = "com.android.bluetooth";
     private static final String ACTION_WHITELIST_DEVICE =
             "android.btopp.intent.action.WHITELIST_DEVICE";
     public static final int MSG_BEAM_COMPLETE = 0;
@@ -46,6 +47,8 @@ public class BeamManager implements Handler.Callback {
     private boolean mBeamInProgress;
     private final Handler mCallback;
 
+    private NfcService mNfcService;
+
     private static final class Singleton {
         public static final BeamManager INSTANCE = new BeamManager();
     }
@@ -54,6 +57,7 @@ public class BeamManager implements Handler.Callback {
         mLock = new Object();
         mBeamInProgress = false;
         mCallback = new Handler(Looper.getMainLooper(), this);
+        mNfcService = NfcService.getInstance();
     }
 
     public static BeamManager getInstance() {
@@ -119,6 +123,11 @@ public class BeamManager implements Handler.Callback {
             synchronized (mLock) {
                 mBeamInProgress = false;
             }
+
+            boolean success = msg.arg1 == 1;
+            if (success) {
+                mNfcService.playSound(NfcService.SOUND_END);
+            }
             return true;
         }
         return false;
@@ -127,7 +136,7 @@ public class BeamManager implements Handler.Callback {
     void whitelistOppDevice(Context context, BluetoothDevice device) {
         if (DBG) Log.d(TAG, "Whitelisting " + device + " for BT OPP");
         Intent intent = new Intent(ACTION_WHITELIST_DEVICE);
-        intent.setPackage(BLUETOOTH_PACKAGE);
+        intent.setPackage(context.getString(R.string.bluetooth_package));
         intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
         context.sendBroadcastAsUser(intent, UserHandle.CURRENT);
     }
diff --git a/src/com/android/nfc/beam/BeamReceiveService.java b/src/com/android/nfc/beam/BeamReceiveService.java
index 7deb0148..4ebffc87 100644
--- a/src/com/android/nfc/beam/BeamReceiveService.java
+++ b/src/com/android/nfc/beam/BeamReceiveService.java
@@ -1,6 +1,5 @@
 package com.android.nfc.beam;
 
-import com.android.nfc.R;
 
 import android.app.Service;
 import android.bluetooth.BluetoothAdapter;
@@ -8,8 +7,6 @@ import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
-import android.media.AudioManager;
-import android.media.SoundPool;
 import android.os.Handler;
 import android.os.IBinder;
 import android.os.Message;
@@ -33,8 +30,6 @@ public class BeamReceiveService extends Service implements BeamTransferManager.C
     private BeamStatusReceiver mBeamStatusReceiver;
     private boolean mBluetoothEnabledByNfc;
     private int mStartId;
-    private SoundPool mSoundPool;
-    private int mSuccessSound;
     private BeamTransferManager mTransferManager;
     private Messenger mCompleteCallback;
 
@@ -75,7 +70,7 @@ public class BeamReceiveService extends Service implements BeamTransferManager.C
             if (DBG) Log.i(TAG, "Ready for incoming Beam transfer");
             return START_STICKY;
         } else {
-            invokeCompleteCallback();
+            invokeCompleteCallback(false);
             stopSelf(startId);
             return START_NOT_STICKY;
         }
@@ -86,8 +81,6 @@ public class BeamReceiveService extends Service implements BeamTransferManager.C
     public void onCreate() {
         super.onCreate();
 
-        mSoundPool = new SoundPool(1, AudioManager.STREAM_NOTIFICATION, 0);
-        mSuccessSound = mSoundPool.load(this, R.raw.end, 1);
 
         // register BT state receiver
         IntentFilter filter = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
@@ -97,9 +90,6 @@ public class BeamReceiveService extends Service implements BeamTransferManager.C
     @Override
     public void onDestroy() {
         super.onDestroy();
-        if (mSoundPool != null) {
-            mSoundPool.release();
-        }
 
         if (mBeamStatusReceiver != null) {
             unregisterReceiver(mBeamStatusReceiver);
@@ -139,10 +129,12 @@ public class BeamReceiveService extends Service implements BeamTransferManager.C
         return true;
     }
 
-    private void invokeCompleteCallback() {
+    private void invokeCompleteCallback(boolean success) {
         if (mCompleteCallback != null) {
             try {
-                mCompleteCallback.send(Message.obtain(null, BeamManager.MSG_BEAM_COMPLETE));
+                Message msg = Message.obtain(null, BeamManager.MSG_BEAM_COMPLETE);
+                msg.arg1 = success ? 1 : 0;
+                mCompleteCallback.send(msg);
             } catch (RemoteException e) {
                 Log.e(TAG, "failed to invoke Beam complete callback", e);
             }
@@ -152,9 +144,7 @@ public class BeamReceiveService extends Service implements BeamTransferManager.C
     @Override
     public void onTransferComplete(BeamTransferManager transfer, boolean success) {
         // Play success sound
-        if (success) {
-            mSoundPool.play(mSuccessSound, 1.0f, 1.0f, 0, 0, 1.0f);
-        } else {
+        if (!success) {
             if (DBG) Log.d(TAG, "Transfer failed, final state: " +
                     Integer.toString(transfer.mState));
         }
@@ -164,7 +154,7 @@ public class BeamReceiveService extends Service implements BeamTransferManager.C
             mBluetoothAdapter.disable();
         }
 
-        invokeCompleteCallback();
+        invokeCompleteCallback(success);
         stopSelf(mStartId);
     }
 
diff --git a/src/com/android/nfc/beam/BeamSendService.java b/src/com/android/nfc/beam/BeamSendService.java
index 59019d53..71e2878f 100644
--- a/src/com/android/nfc/beam/BeamSendService.java
+++ b/src/com/android/nfc/beam/BeamSendService.java
@@ -16,7 +16,6 @@
 
 package com.android.nfc.beam;
 
-import com.android.nfc.R;
 
 import android.app.Service;
 import android.bluetooth.BluetoothAdapter;
@@ -24,8 +23,6 @@ import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
-import android.media.AudioManager;
-import android.media.SoundPool;
 import android.os.Handler;
 import android.os.IBinder;
 import android.os.Message;
@@ -47,8 +44,6 @@ public class BeamSendService extends Service implements BeamTransferManager.Call
     private boolean mBluetoothEnabledByNfc;
     private Messenger mCompleteCallback;
     private int mStartId;
-    SoundPool mSoundPool;
-    int mSuccessSound;
 
     private final BluetoothAdapter mBluetoothAdapter;
     private final BroadcastReceiver mBluetoothStateReceiver = new BroadcastReceiver() {
@@ -69,8 +64,6 @@ public class BeamSendService extends Service implements BeamTransferManager.Call
     public void onCreate() {
         super.onCreate();
 
-        mSoundPool = new SoundPool(1, AudioManager.STREAM_NOTIFICATION, 0);
-        mSuccessSound = mSoundPool.load(this, R.raw.end, 1);
 
         // register BT state receiver
         IntentFilter filter = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
@@ -80,9 +73,6 @@ public class BeamSendService extends Service implements BeamTransferManager.Call
     @Override
     public void onDestroy() {
         super.onDestroy();
-        if (mSoundPool != null) {
-            mSoundPool.release();
-        }
 
         if (mBeamStatusReceiver != null) {
             unregisterReceiver(mBeamStatusReceiver);
@@ -108,7 +98,7 @@ public class BeamSendService extends Service implements BeamTransferManager.Call
             if (DBG) Log.i(TAG, "Starting outgoing Beam transfer");
             return START_STICKY;
         } else {
-            invokeCompleteCallback();
+            invokeCompleteCallback(false);
             stopSelf(startId);
             return START_NOT_STICKY;
         }
@@ -170,10 +160,12 @@ public class BeamSendService extends Service implements BeamTransferManager.Call
         }
     }
 
-    private void invokeCompleteCallback() {
+    private void invokeCompleteCallback(boolean success) {
         if (mCompleteCallback != null) {
             try {
-                mCompleteCallback.send(Message.obtain(null, BeamManager.MSG_BEAM_COMPLETE));
+                Message msg = Message.obtain(null, BeamManager.MSG_BEAM_COMPLETE);
+                msg.arg1 = success ? 1 : 0;
+                mCompleteCallback.send(msg);
             } catch (RemoteException e) {
                 Log.e(TAG, "failed to invoke Beam complete callback", e);
             }
@@ -183,9 +175,7 @@ public class BeamSendService extends Service implements BeamTransferManager.Call
     @Override
     public void onTransferComplete(BeamTransferManager transfer, boolean success) {
         // Play success sound
-        if (success) {
-            mSoundPool.play(mSuccessSound, 1.0f, 1.0f, 0, 0, 1.0f);
-        } else {
+        if (!success) {
             if (DBG) Log.d(TAG, "Transfer failed, final state: " +
                     Integer.toString(transfer.mState));
         }
@@ -195,7 +185,7 @@ public class BeamSendService extends Service implements BeamTransferManager.Call
             mBluetoothAdapter.disable();
         }
 
-        invokeCompleteCallback();
+        invokeCompleteCallback(success);
         stopSelf(mStartId);
     }
 
diff --git a/src/com/android/nfc/beam/BeamStatusReceiver.java b/src/com/android/nfc/beam/BeamStatusReceiver.java
index 67b5b82a..23e1ce80 100644
--- a/src/com/android/nfc/beam/BeamStatusReceiver.java
+++ b/src/com/android/nfc/beam/BeamStatusReceiver.java
@@ -1,5 +1,7 @@
 package com.android.nfc.beam;
 
+import com.android.nfc.R;
+
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
@@ -120,6 +122,7 @@ public class BeamStatusReceiver extends BroadcastReceiver {
                     if (DBG) Log.d(TAG, "Didn't find transfer, stopping");
                     Intent cancelIntent = new Intent(ACTION_STOP_BLUETOOTH_TRANSFER);
                     cancelIntent.putExtra(EXTRA_TRANSFER_ID, id);
+                    cancelIntent.setPackage(mContext.getString(R.string.bluetooth_package));
                     mContext.sendBroadcast(cancelIntent);
                 }
             }
diff --git a/src/com/android/nfc/beam/BeamTransferManager.java b/src/com/android/nfc/beam/BeamTransferManager.java
index 7d387f96..f0ce8da1 100644
--- a/src/com/android/nfc/beam/BeamTransferManager.java
+++ b/src/com/android/nfc/beam/BeamTransferManager.java
@@ -108,8 +108,6 @@ public class BeamTransferManager implements Handler.Callback,
 
     static final String BEAM_NOTIFICATION_CHANNEL = "beam_notification_channel";
 
-    static final String BLUETOOTH_PACKAGE = "com.android.bluetooth";
-
     static final String ACTION_WHITELIST_DEVICE =
             "android.btopp.intent.action.WHITELIST_DEVICE";
 
@@ -188,7 +186,7 @@ public class BeamTransferManager implements Handler.Callback,
     void whitelistOppDevice(BluetoothDevice device) {
         if (DBG) Log.d(TAG, "Whitelisting " + device + " for BT OPP");
         Intent intent = new Intent(ACTION_WHITELIST_DEVICE);
-        intent.setPackage(BLUETOOTH_PACKAGE);
+        intent.setPackage(mContext.getString(R.string.bluetooth_package));
         intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
         mContext.sendBroadcastAsUser(intent, UserHandle.CURRENT);
     }
@@ -298,7 +296,7 @@ public class BeamTransferManager implements Handler.Callback,
 
     private void sendBluetoothCancelIntentAndUpdateState() {
         Intent cancelIntent = new Intent(ACTION_STOP_BLUETOOTH_TRANSFER);
-        cancelIntent.setPackage(BLUETOOTH_PACKAGE);
+        cancelIntent.setPackage(mContext.getString(R.string.bluetooth_package));
         cancelIntent.putExtra(BeamStatusReceiver.EXTRA_TRANSFER_ID, mBluetoothTransferId);
         mContext.sendBroadcast(cancelIntent);
         updateStateAndNotification(STATE_CANCELLED);
diff --git a/src/com/android/nfc/beam/BluetoothOppHandover.java b/src/com/android/nfc/beam/BluetoothOppHandover.java
index 8e040931..292d93c0 100644
--- a/src/com/android/nfc/beam/BluetoothOppHandover.java
+++ b/src/com/android/nfc/beam/BluetoothOppHandover.java
@@ -16,6 +16,8 @@
 
 package com.android.nfc.beam;
 
+import com.android.nfc.R;
+
 import android.bluetooth.BluetoothDevice;
 import android.content.Context;
 import android.content.Intent;
@@ -95,7 +97,7 @@ public class BluetoothOppHandover implements Handler.Callback {
 
     void sendIntent() {
         Intent intent = new Intent();
-        intent.setPackage("com.android.bluetooth");
+        intent.setPackage(mContext.getString(R.string.bluetooth_package));
         String mimeType = MimeTypeUtil.getMimeTypeForUri(mContext, mUris.get(0));
         intent.setType(mimeType);
         intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mDevice);
@@ -104,7 +106,7 @@ public class BluetoothOppHandover implements Handler.Callback {
             // to the Bluetooth process. This works, but we don't have
             // a good framework API for revoking permission yet.
             try {
-                mContext.grantUriPermission("com.android.bluetooth", uri,
+                mContext.grantUriPermission(mContext.getString(R.string.bluetooth_package), uri,
                         Intent.FLAG_GRANT_READ_URI_PERMISSION);
             } catch (SecurityException e) {
                 Log.e(TAG, "Failed to transfer permission to Bluetooth process.");
diff --git a/src/com/android/nfc/beam/MimeTypeUtil.java b/src/com/android/nfc/beam/MimeTypeUtil.java
index 73d7fd6e..283a24ce 100644
--- a/src/com/android/nfc/beam/MimeTypeUtil.java
+++ b/src/com/android/nfc/beam/MimeTypeUtil.java
@@ -35,7 +35,12 @@ public final class MimeTypeUtil {
             ContentResolver cr = context.getContentResolver();
             return cr.getType(uri);
         } else if (uri.getScheme().equals(ContentResolver.SCHEME_FILE)) {
-            String extension = MimeTypeMap.getFileExtensionFromUrl(uri.getPath()).toLowerCase();
+            String extension = null;
+            String filePath = uri.getPath().toLowerCase();
+            int index = filePath.lastIndexOf(".");
+            if (index > 0 && index + 1 < filePath.length()) {
+                extension = filePath.substring(index + 1);
+            }
             if (extension != null) {
                 return MimeTypeMap.getSingleton().getMimeTypeFromExtension(extension);
             } else {
diff --git a/src/com/android/nfc/beam/SendUi.java b/src/com/android/nfc/beam/SendUi.java
index 64dab180..e11aef84 100644
--- a/src/com/android/nfc/beam/SendUi.java
+++ b/src/com/android/nfc/beam/SendUi.java
@@ -13,7 +13,26 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
+/******************************************************************************
+*
+*  The original Work has been changed by NXP.
+*
+*  Licensed under the Apache License, Version 2.0 (the "License");
+*  you may not use this file except in compliance with the License.
+*  You may obtain a copy of the License at
+*
+*  http://www.apache.org/licenses/LICENSE-2.0
+*
+*  Unless required by applicable law or agreed to in writing, software
+*  distributed under the License is distributed on an "AS IS" BASIS,
+*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+*  See the License for the specific language governing permissions and
+*  limitations under the License.
+*
+*  Copyright 2018 NXP
+*  NOT A CONTRIBUTION
+*
+******************************************************************************/
 package com.android.nfc.beam;
 
 import com.android.nfc.R;
@@ -467,7 +486,8 @@ public class SendUi implements Animator.AnimatorListener, View.OnTouchListener,
                 // We didn't build up any animation state yet, but
                 // did store the bitmap. Clear out the bitmap, reset
                 // state and bail.
-                mScreenshotBitmap = null;
+                mScreenshotView.setImageBitmap(null);
+                recycleBitmap();
                 mState = STATE_IDLE;
                 return;
             default:
@@ -533,9 +553,9 @@ public class SendUi implements Animator.AnimatorListener, View.OnTouchListener,
         mScaleUpAnimator.cancel();
         mAlphaUpAnimator.cancel();
         mAlphaDownAnimator.cancel();
+        mScreenshotView.setImageBitmap(null);
         mWindowManager.removeView(mDecor);
         mStatusBarManager.disable(StatusBarManager.DISABLE_NONE);
-        mScreenshotBitmap = null;
         mContext.unregisterReceiver(mReceiver);
         if (mToastString != null) {
             Toast toast = Toast.makeText(mContext, mToastString, Toast.LENGTH_LONG);
@@ -543,6 +563,19 @@ public class SendUi implements Animator.AnimatorListener, View.OnTouchListener,
             toast.show();
         }
         mToastString = null;
+        recycleBitmap();
+    }
+    /*
+    * Recycles Bitmap of ScreenShot
+    */
+    private void recycleBitmap(){
+        try{
+            if(mScreenshotBitmap!=null && !mScreenshotBitmap.isRecycled()){
+                mScreenshotBitmap.recycle();
+            }
+        }catch(Exception e){
+            Log.e(TAG, "Error while recycle bitmap", e);
+        }
     }
 
     /**
diff --git a/src/com/android/nfc/cardemulation/AidRoutingManager.java b/src/com/android/nfc/cardemulation/AidRoutingManager.java
index 9f6746ea..d63d644f 100644
--- a/src/com/android/nfc/cardemulation/AidRoutingManager.java
+++ b/src/com/android/nfc/cardemulation/AidRoutingManager.java
@@ -18,7 +18,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -35,6 +35,10 @@
  ******************************************************************************/
 package com.android.nfc.cardemulation;
 
+import android.app.ActivityManager;
+import android.app.ActivityManager.RunningTaskInfo;
+import android.app.ActivityThread;
+import android.content.Context;
 import android.util.Log;
 import android.util.SparseArray;
 
@@ -117,6 +121,8 @@ public class AidRoutingManager {
 
     final VzwRoutingCache mVzwRoutingCache;
 
+    final ActivityManager mActivityManager;
+
     public AidRoutingManager() {
         mDefaultRoute = doGetDefaultRouteDestination();
         mRoutingTableChanged = false;
@@ -129,6 +135,9 @@ public class AidRoutingManager {
         if (DBG) Log.d(TAG, "mAidTableSize=0x" + Integer.toHexString(mAidRoutingTableSize));
         mVzwRoutingCache = new VzwRoutingCache();
         mLastCommitStatus = true;
+
+        Context context = (Context) ActivityThread.currentApplication();
+        mActivityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
     }
 
     public boolean supportsAidPrefixRouting() {
@@ -145,6 +154,40 @@ public class AidRoutingManager {
         return mRoutingTableChanged;
     }
     void clearNfcRoutingTableLocked() {
+        /*
+        for (Map.Entry<String, Integer> aidEntry : mRouteForAid.entrySet())  {
+            String aid = aidEntry.getKey();
+            if (aid.endsWith("*")) {
+                if (mAidMatchingSupport == AID_MATCHING_EXACT_ONLY) {
+                    Log.e(TAG, "Device does not support prefix AIDs but AID [" + aid
+                            + "] is registered");
+                } else if (mAidMatchingSupport == AID_MATCHING_PREFIX_ONLY) {
+                    if (DBG) Log.d(TAG, "Unrouting prefix AID " + aid);
+                    // Cut off '*' since controller anyway treats all AIDs as a prefix
+                    aid = aid.substring(0, aid.length() - 1);
+                } else if (mAidMatchingSupport == AID_MATCHING_EXACT_OR_PREFIX ||
+                    mAidMatchingSupport == AID_MATCHING_EXACT_OR_SUBSET_OR_PREFIX) {
+                    aid = aid.substring(0, aid.length() - 1);
+                    if (DBG) Log.d(TAG, "Unrouting prefix AID " + aid);
+                }
+            }  else if (aid.endsWith("#")) {
+                if (mAidMatchingSupport == AID_MATCHING_EXACT_ONLY) {
+                    Log.e(TAG, "Device does not support subset AIDs but AID [" + aid
+                            + "] is registered");
+                } else if (mAidMatchingSupport == AID_MATCHING_PREFIX_ONLY ||
+                    mAidMatchingSupport == AID_MATCHING_EXACT_OR_PREFIX) {
+                    Log.e(TAG, "Device does not support subset AIDs but AID [" + aid
+                            + "] is registered");
+                } else if (mAidMatchingSupport == AID_MATCHING_EXACT_OR_SUBSET_OR_PREFIX) {
+                    if (DBG) Log.d(TAG, "Unrouting subset AID " + aid);
+                    aid = aid.substring(0, aid.length() - 1);
+                }
+            } else {
+                if (DBG) Log.d(TAG, "Unrouting exact AID " + aid);
+            }
+            NfcService.getInstance().unrouteAids(aid);
+        }
+        */
         NfcService.getInstance().clearRouting();
         mRouteForAid.clear();
         mPowerForAid.clear();
@@ -199,7 +242,7 @@ public class AidRoutingManager {
 
         synchronized (mLock) {
             if (routeForAid.equals(mRouteForAid)) {
-                if (DBG) Log.d(TAG, "Routing table unchanged, but commit the routing");
+                if (DBG) Log.d(TAG, "Routing table unchanged");
                 if(mLastCommitStatus == false){
                     NfcService.getInstance().updateStatusOfServices(false);
                     NfcService.getInstance().notifyRoutingTableFull();
@@ -209,11 +252,15 @@ public class AidRoutingManager {
                 already resolved by previously installed services, service state of newly installed app needs to be updated*/
                     NfcService.getInstance().updateStatusOfServices(true);
                 }
-                NfcService.getInstance().commitRouting();
+                if (isProcessingTapAgain() || NfcService.getInstance().mIsRoutingTableDirty) {
+                    if (DBG) Log.d(TAG, "Routing table unchanged, but commit the routing");
+                    NfcService.getInstance().commitRouting();
+                } else {
+                    if (DBG) Log.d(TAG, "Routing table unchanged, not updating");
+                }
                 return false;
             }
 
-            mRoutingTableChanged = true;
             // Otherwise, update internal structures and commit new routing
             clearNfcRoutingTableLocked();
             mRouteForAid = routeForAid;
@@ -238,7 +285,7 @@ public class AidRoutingManager {
                  * default route at the top of the table, so they will be matched first.
                  */
                 Set<String> defaultRouteAids = mAidRoutingTable.get(mDefaultRoute);
-               if (defaultRouteAids != null) {
+                if (defaultRouteAids != null) {
                     for (String defaultRouteAid : defaultRouteAids) {
                         // Check whether there are any shorted AIDs routed to non-default
                         // TODO this is O(N^2) run-time complexity...
@@ -252,7 +299,7 @@ public class AidRoutingManager {
                                 AidElement elem = aidMap.get(defaultRouteAid);
                                 elem.setRouteLocation(mDefaultRoute);
                                 routeCache.put(defaultRouteAid, elem);
-//                                NfcService.getInstance().routeAids(defaultRouteAid, mDefaultRoute, mPowerForAid.get(defaultRouteAid),infoForAid.get(defaultRouteAid);
+                                //NfcService.getInstance().routeAids(defaultRouteAid, mDefaultRoute, mPowerForAid.get(defaultRouteAid),infoForAid.get(defaultRouteAid));
                             }
                         }
                     }
@@ -275,8 +322,8 @@ public class AidRoutingManager {
                                 AidElement elem = aidMap.get(aid);
                                 elem.setAid(aid.substring(0,aid.length() - 1));
                                 routeCache.put(aid, elem);
-//                                NfcService.getInstance().routeAids(aid.substring(0,
-//                                                aid.length() - 1), route, mPowerForAid.get(aid),infoForAid.get(aid));
+                                //NfcService.getInstance().routeAids(aid.substring(0,
+                                                //aid.length() - 1), route, mPowerForAid.get(aid),infoForAid.get(aid));
                             } else if (mAidMatchingSupport == AID_MATCHING_EXACT_OR_PREFIX
                               || mAidMatchingSupport == AID_MATCHING_EXACT_OR_SUBSET_OR_PREFIX) {
                                 Log.d(TAG, "Routing AID in AID_MATCHING_EXACT_OR_PREFIX");
@@ -284,7 +331,7 @@ public class AidRoutingManager {
                                         + Integer.toString(route));
                                 AidElement elem = aidMap.get(aid);
                                 routeCache.put(aid, elem);
-//                                NfcService.getInstance().routeAids(aid, route, (mPowerForAid.get(aid)),infoForAid.get(aid));
+                                //NfcService.getInstance().routeAids(aid, route, (mPowerForAid.get(aid)),infoForAid.get(aid));
                             }
                         } else if (aid.endsWith("#")) {
                             if (mAidMatchingSupport == AID_MATCHING_EXACT_ONLY) {
@@ -299,14 +346,14 @@ public class AidRoutingManager {
                                         + Integer.toString(route));
                                 AidElement elem = aidMap.get(aid);
                                 routeCache.put(aid, elem);
-//                                NfcService.getInstance().routeAids(aid, route, (mPowerForAid.get(aid)),infoForAid.get(aid));
+                                //NfcService.getInstance().routeAids(aid, route, (mPowerForAid.get(aid)),infoForAid.get(aid));
                             }
                         } else {
                             if (DBG) Log.d(TAG, "Routing exact AID " + aid + " to route "
                                     + Integer.toString(route));
                             AidElement elem = aidMap.get(aid);
                             routeCache.put(aid, elem);
-//                            NfcService.getInstance().routeAids(aid, route, mPowerForAid.get(aid),infoForAid.get(aid));
+                            //NfcService.getInstance().routeAids(aid, route, mPowerForAid.get(aid),infoForAid.get(aid));
                         }
                     }
                 }
@@ -343,6 +390,7 @@ public class AidRoutingManager {
         }
         // And finally commit the routing and update the status of commit for each service
         if(aidRouteResolved == true) {
+            mRoutingTableChanged = true;
             commit(routeCache);
             NfcService.getInstance().updateStatusOfServices(true);
             mLastCommitStatus = true;
@@ -553,4 +601,20 @@ public class AidRoutingManager {
        }
 
     }
+
+    // Returns true if AppChooserActivity is foreground to restart RF discovery so that
+    // TapAgainDialog is dismissed when an external reader detects the device.
+    private boolean isProcessingTapAgain() {
+        String appChooserActivityClassName = AppChooserActivity.class.getName();
+        return appChooserActivityClassName.equals(getTopClass());
+    }
+
+    private String getTopClass() {
+        String topClass = null;
+        List<RunningTaskInfo> tasks = mActivityManager.getRunningTasks(1);
+        if (tasks != null && tasks.size() > 0) {
+            topClass = tasks.get(0).topActivity.getClassName();
+        }
+        return topClass;
+    }
 }
diff --git a/src/com/android/nfc/cardemulation/CardEmulationManager.java b/src/com/android/nfc/cardemulation/CardEmulationManager.java
old mode 100644
new mode 100755
index 699b5937..ce82d5e9
--- a/src/com/android/nfc/cardemulation/CardEmulationManager.java
+++ b/src/com/android/nfc/cardemulation/CardEmulationManager.java
@@ -2,7 +2,7 @@
  * Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.
  * Not a Contribution.
  *
- * Copyright (C) 2015 NXP Semiconductors
+ * Copyright (C) 2015-2018 NXP Semiconductors
  * The original Work has been changed by NXP Semiconductors.
  * Copyright (C) 2014 The Android Open Source Project
  *
@@ -168,10 +168,10 @@ public class CardEmulationManager implements RegisteredServicesCache.Callback,
     }
 
     public void onUserSwitched(int userId) {
-        // for HCE
+        //For HCE
         mServiceCache.invalidateCache(userId);
         mPreferredServices.onUserSwitched(userId);
-        // for HCE-F
+        //For HCE-F
         mHostNfcFEmulationManager.onUserSwitched();
         mT3tIdentifiersCache.onUserSwitched();
         mEnabledNfcFServices.onUserSwitched(userId);
@@ -194,14 +194,12 @@ public class CardEmulationManager implements RegisteredServicesCache.Callback,
     }
 
     public void onNfcEnabled() {
-        // for HCE
         mAidCache.onNfcEnabled();
         // for HCE-F
         mT3tIdentifiersCache.onNfcEnabled();
     }
 
     public void onNfcDisabled() {
-        // for HCE
         mAidCache.onNfcDisabled();
         // for HCE-F
         mHostNfcFEmulationManager.onNfcDisabled();
@@ -243,49 +241,7 @@ public class CardEmulationManager implements RegisteredServicesCache.Callback,
         ComponentName defaultPaymentService =
                 getDefaultServiceForCategory(userId, CardEmulation.CATEGORY_PAYMENT, false);
         if (DBG) Log.d(TAG, "Current default: " + defaultPaymentService);
-        if (defaultPaymentService != null) {
-            // Validate the default is still installed and handling payment
-            NQApduServiceInfo serviceInfo = mServiceCache.getService(userId, defaultPaymentService);
-            if (serviceInfo == null || !serviceInfo.hasCategory(CardEmulation.CATEGORY_PAYMENT)) {
-                if (serviceInfo == null) {
-                    Log.e(TAG, "Default payment service unexpectedly removed.");
-                } else if (!serviceInfo.hasCategory(CardEmulation.CATEGORY_PAYMENT)) {
-                    if (DBG) Log.d(TAG, "Default payment service had payment category removed");
-                }
-                int numPaymentServices = 0;
-                ComponentName lastFoundPaymentService = null;
-                for (NQApduServiceInfo service : services) {
-                    if (service.hasCategory(CardEmulation.CATEGORY_PAYMENT))  {
-                        numPaymentServices++;
-                        lastFoundPaymentService = service.getComponent();
-                    }
-                }
-                if (DBG) Log.d(TAG, "Number of payment services is " +
-                        Integer.toString(numPaymentServices));
-                if (numPaymentServices == 0) {
-                    if (DBG) Log.d(TAG, "Default removed, no services left.");
-                    // No payment services left, unset default and don't ask the user
-                    setDefaultServiceForCategoryChecked(userId, null, CardEmulation.CATEGORY_PAYMENT);
-                } else if (numPaymentServices == 1) {
-                    // Only one left, automatically make it the default
-                    if (DBG) Log.d(TAG, "Default removed, making remaining service default.");
-                    setDefaultServiceForCategoryChecked(userId, lastFoundPaymentService,
-                            CardEmulation.CATEGORY_PAYMENT);
-                } else if (numPaymentServices > 1) {
-                    // More than one left, unset default and ask the user if he wants
-                    // to set a new one
-                    if (DBG) Log.d(TAG, "Default removed, asking user to pick.");
-                    setDefaultServiceForCategoryChecked(userId, null,
-                            CardEmulation.CATEGORY_PAYMENT);
-                    Intent intent = new Intent(mContext, DefaultRemovedActivity.class);
-                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
-                    mContext.startActivityAsUser(intent, UserHandle.CURRENT);
-                }
-            } else {
-                // Default still exists and handles the category, nothing do
-                if (DBG) Log.d(TAG, "Default payment service still ok.");
-            }
-        } else {
+        if (defaultPaymentService == null) {
             // A payment service may have been removed, leaving only one;
             // in that case, automatically set that app as default.
             int numPaymentServices = 0;
@@ -381,7 +337,7 @@ public class CardEmulationManager implements RegisteredServicesCache.Callback,
     }
 
 
-    /**
+   /**
      * Returns whether a service in this package is preferred,
      * either because it's the default payment app or it's running
      * in the foreground.
@@ -392,8 +348,10 @@ public class CardEmulationManager implements RegisteredServicesCache.Callback,
 
 
     /**
-     * This class implements the application-facing APIs and are called
-     * from binder. All calls must be permission-checked.
+     * This class implements the application-facing APIs
+     * and are called from binder. All calls must be
+     * permission-checked.
+     *
      */
     final class CardEmulationInterface extends INfcCardEmulation.Stub {
         @Override
diff --git a/src/com/android/nfc/cardemulation/DefaultRemovedActivity.java b/src/com/android/nfc/cardemulation/DefaultRemovedActivity.java
deleted file mode 100644
index d9fa7e9b..00000000
--- a/src/com/android/nfc/cardemulation/DefaultRemovedActivity.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.nfc.cardemulation;
-
-import android.content.DialogInterface;
-import android.content.Intent;
-import android.os.Bundle;
-import android.provider.Settings;
-import com.android.internal.R;
-
-import com.android.internal.app.AlertActivity;
-import com.android.internal.app.AlertController;
-
-public class DefaultRemovedActivity extends AlertActivity implements
-        DialogInterface.OnClickListener {
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        setTheme(R.style.Theme_DeviceDefault_Light_Dialog_Alert);
-        super.onCreate(savedInstanceState);
-
-        AlertController.AlertParams ap = mAlertParams;
-
-        ap.mMessage = getString(com.android.nfc.R.string.default_pay_app_removed);
-        ap.mNegativeButtonText = getString(R.string.no);
-        ap.mPositiveButtonText = getString(R.string.yes);
-        ap.mPositiveButtonListener = this;
-        setupAlert();
-    }
-
-    @Override
-    public void onClick(DialogInterface dialog, int which) {
-        // Launch into Settings
-        Intent intent = new Intent(Settings.ACTION_NFC_PAYMENT_SETTINGS);
-        startActivity(intent);
-    }
-}
\ No newline at end of file
diff --git a/src/com/android/nfc/cardemulation/EnabledNfcFServices.java b/src/com/android/nfc/cardemulation/EnabledNfcFServices.java
index 1d2acb58..c06ca26b 100644
--- a/src/com/android/nfc/cardemulation/EnabledNfcFServices.java
+++ b/src/com/android/nfc/cardemulation/EnabledNfcFServices.java
@@ -117,7 +117,8 @@ public class EnabledNfcFServices implements com.android.nfc.ForegroundUtils.Call
                 return false;
             } else {
                 if (serviceInfo.getSystemCode().equalsIgnoreCase("NULL") ||
-                        serviceInfo.getNfcid2().equalsIgnoreCase("NULL")) {
+                        serviceInfo.getNfcid2().equalsIgnoreCase("NULL") ||
+                        serviceInfo.getT3tPmm().equalsIgnoreCase("NULL")) {
                     return false;
                 }
             }
diff --git a/src/com/android/nfc/cardemulation/HostEmulationManager.java b/src/com/android/nfc/cardemulation/HostEmulationManager.java
index b5c57520..91001582 100644
--- a/src/com/android/nfc/cardemulation/HostEmulationManager.java
+++ b/src/com/android/nfc/cardemulation/HostEmulationManager.java
@@ -98,15 +98,16 @@ public class HostEmulationManager {
     // Variables below are for a non-payment service,
     // that is typically only bound in the STATE_XFER state.
     Messenger mService;
-    boolean mServiceBound;
-    ComponentName mServiceName;
+    boolean mServiceBound = false;
+    ComponentName mServiceName = null;
 
     // Variables below are for a payment service,
     // which is typically bound persistently to improve on
     // latency.
     Messenger mPaymentService;
-    boolean mPaymentServiceBound;
-    ComponentName mPaymentServiceName;
+    boolean mPaymentServiceBound = false;
+    ComponentName mPaymentServiceName = null;
+    ComponentName mLastBoundPaymentServiceName;
 
     // mActiveService denotes the service interface
     // that is the current active one, until a new SELECT AID
@@ -352,10 +353,10 @@ public class HostEmulationManager {
     }
 
     Messenger bindServiceIfNeededLocked(ComponentName service) {
-        if (mPaymentServiceBound && mPaymentServiceName.equals(service)) {
+        if (mPaymentServiceName != null && mPaymentServiceName.equals(service)) {
             Log.d(TAG, "Service already bound as payment service.");
             return mPaymentService;
-        } else if (mServiceBound && mServiceName.equals(service)) {
+        } else if (mServiceName != null && mServiceName.equals(service)) {
             Log.d(TAG, "Service already bound as regular service.");
             return mService;
         } else {
@@ -365,6 +366,7 @@ public class HostEmulationManager {
             aidIntent.setComponent(service);
             if (mContext.bindServiceAsUser(aidIntent, mConnection,
                     Context.BIND_AUTO_CREATE, UserHandle.CURRENT)) {
+                mServiceBound = true;
             } else {
                 Log.e(TAG, "Could not bind service.");
             }
@@ -419,8 +421,11 @@ public class HostEmulationManager {
 
         Intent intent = new Intent(HostApduService.SERVICE_INTERFACE);
         intent.setComponent(service);
-        if (!mContext.bindServiceAsUser(intent, mPaymentConnection,
+        mLastBoundPaymentServiceName = service;
+        if (mContext.bindServiceAsUser(intent, mPaymentConnection,
                 Context.BIND_AUTO_CREATE, new UserHandle(userId))) {
+          mPaymentServiceBound = true;
+        } else {
             Log.e(TAG, "Could not bind (persistent) payment service.");
         }
     }
@@ -510,9 +515,12 @@ public class HostEmulationManager {
         @Override
         public void onServiceConnected(ComponentName name, IBinder service) {
             synchronized (mLock) {
+                /* Preferred Payment Service has been changed. */
+                if (!mLastBoundPaymentServiceName.equals(name)) {
+                    return;
+                }
                 mPaymentServiceName = name;
                 mPaymentService = new Messenger(service);
-                mPaymentServiceBound = true;
             }
         }
 
@@ -530,8 +538,11 @@ public class HostEmulationManager {
         @Override
         public void onServiceConnected(ComponentName name, IBinder service) {
             synchronized (mLock) {
+                /* Service is already deactivated, don't bind */
+                if (mState == STATE_IDLE) {
+                  return;
+                }
                 mService = new Messenger(service);
-                mServiceBound = true;
                 mServiceName = name;
                 Log.d(TAG, "Service bound");
                 mState = STATE_XFER;
diff --git a/src/com/android/nfc/cardemulation/RegisteredAidCache.java b/src/com/android/nfc/cardemulation/RegisteredAidCache.java
old mode 100644
new mode 100755
index a38c49b5..b28f6831
--- a/src/com/android/nfc/cardemulation/RegisteredAidCache.java
+++ b/src/com/android/nfc/cardemulation/RegisteredAidCache.java
@@ -18,6 +18,25 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+/******************************************************************************
+ *
+ *  The original Work has been changed by NXP Semiconductors.
+ *
+ *  Copyright (C) 2015-2018 NXP Semiconductors
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
 
 package com.android.nfc.cardemulation;
 
@@ -47,7 +66,10 @@ import android.nfc.cardemulation.NQAidGroup;
 public class RegisteredAidCache {
     static final String TAG = "RegisteredAidCache";
 
-    static final boolean DBG = true;
+    static final boolean DBG = false;
+
+    static final int AID_ROUTE_QUAL_SUBSET = 0x20;
+    static final int AID_ROUTE_QUAL_PREFIX = 0x10;
 
     // mAidServices maps AIDs to services that have registered them.
     // It's a TreeMap in order to be able to quickly select subsets
@@ -422,6 +444,8 @@ public class RegisteredAidCache {
         for (NQApduServiceInfo service : services) {
             if (DBG) Log.d(TAG, "generateServiceMap component: " + service.getComponent());
             List<String> prefixAids = service.getPrefixAids();
+            List<String> subSetAids = service.getSubsetAids();
+
             for (String aid : service.getAids()) {
                 if (!CardEmulation.isValidAid(aid)) {
                     Log.e(TAG, "Aid " + aid + " is not valid.");
@@ -445,6 +469,24 @@ public class RegisteredAidCache {
                     if (foundPrefix) {
                         continue;
                     }
+                } else if (aid.endsWith("#") && !supportsAidSubsetRegistration()) {
+                    Log.e(TAG, "Subset AID " + aid + " ignored on device that doesn't support it.");
+                    continue;
+                } else if (supportsAidSubsetRegistration() && subSetAids.size() > 0 && isExact(aid)) {
+                    // Check if we already have an overlapping subset registered for this AID
+                    boolean foundSubset = false;
+                    for (String subsetAid : subSetAids) {
+                        String plainSubset = subsetAid.substring(0, subsetAid.length() - 1);
+                        if (plainSubset.startsWith(aid)) {
+                            Log.e(TAG, "Ignoring exact AID " + aid + " because subset AID " + plainSubset +
+                                    " is already registered");
+                            foundSubset = true;
+                            break;
+                        }
+                    }
+                    if (foundSubset) {
+                        continue;
+                    }
                 }
 
                 ServiceAidInfo serviceAidInfo = new ServiceAidInfo();
@@ -646,6 +688,16 @@ public class RegisteredAidCache {
                     // This prefix is the default; therefore, AIDs of all conflicting children
                     // will no longer be evaluated.
                     resolvedAids.addAll(prefixConflicts.aids);
+                    for(String aid : resolveInfo.defaultService.getSubsetAids()) {
+                        if(prefixConflicts.aids.contains(aid)) {
+                            if((CardEmulation.CATEGORY_PAYMENT.equals(resolveInfo.defaultService.getCategoryForAid(aid))) || (resolveInfo.defaultService.getComponent().equals(mPreferredForegroundService))) {
+                                AidResolveInfo childResolveInfo = resolveAidConflictLocked(mAidServices.get(aid), false);
+                                aidCache.put(aid,childResolveInfo);
+                                Log.d(TAG, "AID " + aid+ " shared with prefix; " +
+                                                "adding subset .");
+                             }
+                        }
+                   }
                 } else if (resolveInfo.services.size() > 0) {
                     // This means we don't have a default for this prefix and all its
                     // conflicting children. So, for all conflicting AIDs, just add
@@ -807,10 +859,10 @@ public class RegisteredAidCache {
                 continue;
             }
             if(aid.endsWith("#")) {
-                aidInfo |= 0x20;
+                aidInfo |= AID_ROUTE_QUAL_SUBSET;
             }
             if(aid.endsWith("*") || (resolveInfo.prefixInfo != null && resolveInfo.prefixInfo.matchingSubset)) {
-                aidInfo |= 0x10;
+                aidInfo |= AID_ROUTE_QUAL_PREFIX;
             }
             if (resolveInfo.services.size() == 0) {
                 // No interested services
diff --git a/src/com/android/nfc/cardemulation/RegisteredT3tIdentifiersCache.java b/src/com/android/nfc/cardemulation/RegisteredT3tIdentifiersCache.java
index 55215e75..e480648c 100644
--- a/src/com/android/nfc/cardemulation/RegisteredT3tIdentifiersCache.java
+++ b/src/com/android/nfc/cardemulation/RegisteredT3tIdentifiersCache.java
@@ -144,7 +144,7 @@ public class RegisteredT3tIdentifiersCache {
             Map.Entry<String, NfcFServiceInfo> entry =
                     (Map.Entry<String, NfcFServiceInfo>) it.next();
             t3tIdentifiers.add(new T3tIdentifier(
-                    entry.getValue().getSystemCode(), entry.getValue().getNfcid2(), null));
+                    entry.getValue().getSystemCode(), entry.getValue().getNfcid2(), entry.getValue().getT3tPmm()));
         }
         mRoutingManager.configureRouting(t3tIdentifiers);
     }
diff --git a/src/com/android/nfc/cardemulation/SystemCodeRoutingManager.java b/src/com/android/nfc/cardemulation/SystemCodeRoutingManager.java
index 643171a5..d4bd62f0 100644
--- a/src/com/android/nfc/cardemulation/SystemCodeRoutingManager.java
+++ b/src/com/android/nfc/cardemulation/SystemCodeRoutingManager.java
@@ -59,25 +59,27 @@ public class SystemCodeRoutingManager {
             for (T3tIdentifier t3tIdentifier : toBeRemoved) {
                 if (DBG) Log.d(TAG, "deregisterNfcFSystemCodeonDh:");
                 NfcService.getInstance().deregisterT3tIdentifier(
-                        t3tIdentifier.systemCode, t3tIdentifier.nfcid2 );
+                        t3tIdentifier.systemCode, t3tIdentifier.nfcid2, t3tIdentifier.t3tPmm);
             }
             for (T3tIdentifier t3tIdentifier : toBeAdded) {
                 if (DBG) Log.d(TAG, "registerNfcFSystemCodeonDh:");
                 NfcService.getInstance().registerT3tIdentifier(
-                        t3tIdentifier.systemCode, t3tIdentifier.nfcid2 );
+                        t3tIdentifier.systemCode, t3tIdentifier.nfcid2, t3tIdentifier.t3tPmm);
             }
             if (DBG) {
                 Log.d(TAG, "(Before) mConfiguredT3tIdentifiers: size=" +
                         mConfiguredT3tIdentifiers.size());
                 for (T3tIdentifier t3tIdentifier : mConfiguredT3tIdentifiers) {
                     Log.d(TAG, "    " + t3tIdentifier.systemCode +
-                            "/" + t3tIdentifier.nfcid2);
+                            "/" + t3tIdentifier.t3tPmm);
                 }
                 Log.d(TAG, "(After) mConfiguredT3tIdentifiers: size=" +
                         t3tIdentifiers.size());
                 for (T3tIdentifier t3tIdentifier : t3tIdentifiers) {
                     Log.d(TAG, "    " + t3tIdentifier.systemCode +
-                            "/" + t3tIdentifier.nfcid2);
+                            "/" + t3tIdentifier.nfcid2 +
+                            "/" + t3tIdentifier.t3tPmm);
+
                     Log.d(TAG, "    " + t3tIdentifier.systemCode + "/");
                 }
             }
diff --git a/src/com/android/nfc/handover/BluetoothPeripheralHandover.java b/src/com/android/nfc/handover/BluetoothPeripheralHandover.java
index 85db4d36..ee718be6 100644
--- a/src/com/android/nfc/handover/BluetoothPeripheralHandover.java
+++ b/src/com/android/nfc/handover/BluetoothPeripheralHandover.java
@@ -360,7 +360,16 @@ public class BluetoothPeripheralHandover implements BluetoothProfile.ServiceList
                 // HFP then A2DP connect
                 mState = STATE_CONNECTING;
                 synchronized (mLock) {
-                    if (mTransport != BluetoothDevice.TRANSPORT_LE) {
+                    if (mTransport == BluetoothDevice.TRANSPORT_LE) {
+                        if (mInput.getConnectionState(mDevice)
+                                != BluetoothProfile.STATE_CONNECTED) {
+                            mHidResult = RESULT_PENDING;
+                            toast(getToastString(R.string.connecting_peripheral));
+                            break;
+                        } else {
+                            mHidResult = RESULT_CONNECTED;
+                        }
+                    } else {
                         if (mHeadset.getConnectionState(mDevice) !=
                                 BluetoothProfile.STATE_CONNECTED) {
                             if (mIsHeadsetAvailable) {
@@ -395,7 +404,18 @@ public class BluetoothPeripheralHandover implements BluetoothProfile.ServiceList
                 }
                 // fall-through
             case STATE_CONNECTING:
-                if (mTransport != BluetoothDevice.TRANSPORT_LE) {
+                if (mTransport == BluetoothDevice.TRANSPORT_LE) {
+                    if (mHidResult == RESULT_PENDING) {
+                        break;
+                    } else if (mHidResult == RESULT_CONNECTED) {
+                        toast(getToastString(R.string.connected_peripheral));
+                        mDevice.setAlias(mName);
+                        complete(true);
+                    } else {
+                        toast (getToastString(R.string.connect_peripheral_failed));
+                        complete(false);
+                    }
+                } else {
                     if (mA2dpResult == RESULT_PENDING || mHfpResult == RESULT_PENDING) {
                         // another connection type still pending
                         break;
@@ -544,6 +564,7 @@ public class BluetoothPeripheralHandover implements BluetoothProfile.ServiceList
         Intent dialogIntent = new Intent(mContext, ConfirmConnectActivity.class);
         dialogIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
         dialogIntent.putExtra(BluetoothDevice.EXTRA_DEVICE, mDevice);
+        dialogIntent.putExtra(BluetoothDevice.EXTRA_NAME, mName);
 
         mContext.startActivity(dialogIntent);
     }
@@ -583,7 +604,24 @@ public class BluetoothPeripheralHandover implements BluetoothProfile.ServiceList
                 case MSG_TIMEOUT:
                     if (mState == STATE_COMPLETE) return;
                     Log.i(TAG, "Timeout completing BT handover");
-                    mContext.sendBroadcast(new Intent(ACTION_TIMEOUT_CONNECT));
+                    if (mState == STATE_WAITING_FOR_BOND_CONFIRMATION) {
+                        mContext.sendBroadcast(new Intent(ACTION_TIMEOUT_CONNECT));
+                    } else if (mState == STATE_BONDING) {
+                        toast(getToastString(R.string.pairing_peripheral_failed));
+                    } else if (mState == STATE_CONNECTING) {
+                        if (mHidResult == RESULT_PENDING) {
+                            mHidResult = RESULT_DISCONNECTED;
+                        }
+                        if (mA2dpResult == RESULT_PENDING) {
+                            mA2dpResult = RESULT_DISCONNECTED;
+                        }
+                        if (mHfpResult == RESULT_PENDING) {
+                            mHfpResult = RESULT_DISCONNECTED;
+                        }
+                        // Check if any one profile is connected, then it takes as success
+                        nextStepConnect();
+                        break;
+                    }
                     complete(false);
                     break;
                 case MSG_NEXT_STEP:
diff --git a/src/com/android/nfc/handover/ConfirmConnectActivity.java b/src/com/android/nfc/handover/ConfirmConnectActivity.java
index e76ab50b..75310e17 100644
--- a/src/com/android/nfc/handover/ConfirmConnectActivity.java
+++ b/src/com/android/nfc/handover/ConfirmConnectActivity.java
@@ -41,8 +41,8 @@ public class ConfirmConnectActivity extends Activity {
         mDevice = launchIntent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
         if (mDevice == null) finish();
         Resources res = getResources();
-        String deviceName = mDevice.getName() != null ? mDevice.getName() : "";
-        String confirmString = String.format(res.getString(R.string.confirm_pairing), deviceName);
+        String confirmString = String.format(res.getString(R.string.confirm_pairing),
+                launchIntent.getStringExtra(BluetoothDevice.EXTRA_NAME));
         builder.setMessage(confirmString)
                .setCancelable(false)
                .setPositiveButton(res.getString(R.string.pair_yes),
diff --git a/src/com/android/nfc/handover/HandoverDataParser.java b/src/com/android/nfc/handover/HandoverDataParser.java
index 13e3da7e..5e90c90a 100644
--- a/src/com/android/nfc/handover/HandoverDataParser.java
+++ b/src/com/android/nfc/handover/HandoverDataParser.java
@@ -145,7 +145,12 @@ public class HandoverDataParser {
             }
 
             byte[] addressBytes = addressToReverseBytes(mLocalBluetoothAddress);
-            System.arraycopy(addressBytes, 0, payload, 2, 6);
+            if (addressBytes != null) {
+                System.arraycopy(addressBytes, 0, payload, 2, 6);
+            } else {
+                // don't cache unknown result
+                mLocalBluetoothAddress = null;
+            }
         }
 
         return new NdefRecord(NdefRecord.TNF_MIME_MEDIA, TYPE_BT_OOB, new byte[]{'b'}, payload);
@@ -559,7 +564,15 @@ public class HandoverDataParser {
     }
 
    static byte[] addressToReverseBytes(String address) {
+        if (address == null) {
+            Log.w(TAG, "BT address is null");
+            return null;
+        }
         String[] split = address.split(":");
+        if (split.length < 6) {
+            Log.w(TAG, "BT address " + address + " is invalid");
+            return null;
+        }
         byte[] result = new byte[split.length];
 
         for (int i = 0; i < split.length; i++) {
diff --git a/src/com/android/nfc/handover/HandoverServer.java b/src/com/android/nfc/handover/HandoverServer.java
index 4d8ddf94..4a731622 100644
--- a/src/com/android/nfc/handover/HandoverServer.java
+++ b/src/com/android/nfc/handover/HandoverServer.java
@@ -129,7 +129,7 @@ public final class HandoverServer {
                 } catch (LlcpException e) {
                     Log.e(TAG, "llcp error", e);
                 } catch (IOException e) {
-                    Log.e(TAG, "IO error", e);
+                    if (DBG) Log.d(TAG, "IO error");
                 } finally {
                     synchronized (HandoverServer.this) {
                         if (mServerSocket != null) {
diff --git a/src/com/android/nfc/handover/PeripheralHandoverService.java b/src/com/android/nfc/handover/PeripheralHandoverService.java
index 37c4daee..48926329 100644
--- a/src/com/android/nfc/handover/PeripheralHandoverService.java
+++ b/src/com/android/nfc/handover/PeripheralHandoverService.java
@@ -36,6 +36,8 @@ import android.os.ParcelUuid;
 import android.os.RemoteException;
 import android.util.Log;
 
+import java.util.Set;
+
 public class PeripheralHandoverService extends Service implements BluetoothPeripheralHandover.Callback {
     static final String TAG = "PeripheralHandoverService";
     static final boolean DBG = true;
@@ -49,6 +51,11 @@ public class PeripheralHandoverService extends Service implements BluetoothPerip
     public static final String EXTRA_PERIPHERAL_OOB_DATA = "oobdata";
     public static final String EXTRA_PERIPHERAL_UUIDS = "uuids";
     public static final String EXTRA_PERIPHERAL_CLASS = "class";
+    public static final String EXTRA_CLIENT = "client";
+    public static final String EXTRA_BT_ENABLED = "bt_enabled";
+
+    public static final int MSG_HEADSET_CONNECTED = 0;
+    public static final int MSG_HEADSET_NOT_CONNECTED = 1;
 
     // Amount of time to pause polling when connecting to peripherals
     private static final int PAUSE_POLLING_TIMEOUT_MS = 35000;
@@ -65,6 +72,8 @@ public class PeripheralHandoverService extends Service implements BluetoothPerip
     NfcAdapter mNfcAdapter;
     Handler mHandler;
     BluetoothPeripheralHandover mBluetoothPeripheralHandover;
+    BluetoothDevice mDevice;
+    Messenger mClient;
     boolean mBluetoothHeadsetConnected;
     boolean mBluetoothEnabledByNfc;
 
@@ -148,7 +157,7 @@ public class PeripheralHandoverService extends Service implements BluetoothPerip
             return false;
         }
 
-        BluetoothDevice device = msgData.getParcelable(EXTRA_PERIPHERAL_DEVICE);
+        mDevice = msgData.getParcelable(EXTRA_PERIPHERAL_DEVICE);
         String name = msgData.getString(EXTRA_PERIPHERAL_NAME);
         int transport = msgData.getInt(EXTRA_PERIPHERAL_TRANSPORT);
         OobData oobData = msgData.getParcelable(EXTRA_PERIPHERAL_OOB_DATA);
@@ -163,8 +172,11 @@ public class PeripheralHandoverService extends Service implements BluetoothPerip
             }
         }
 
+        mClient = msgData.getParcelable(EXTRA_CLIENT);
+        mBluetoothEnabledByNfc = msgData.getBoolean(EXTRA_BT_ENABLED);
+
         mBluetoothPeripheralHandover = new BluetoothPeripheralHandover(
-                this, device, name, transport, oobData, uuids, btClass, this);
+                this, mDevice, name, transport, oobData, uuids, btClass, this);
 
         if (transport == BluetoothDevice.TRANSPORT_LE) {
             mHandler.sendMessageDelayed(
@@ -226,6 +238,7 @@ public class PeripheralHandoverService extends Service implements BluetoothPerip
             mNfcAdapter.resumePolling();
         }
         disableBluetoothIfNeeded();
+        replyToClient(connected);
 
         synchronized (sLock) {
             stopSelf(mStartId);
@@ -244,6 +257,7 @@ public class PeripheralHandoverService extends Service implements BluetoothPerip
 
     void disableBluetoothIfNeeded() {
         if (!mBluetoothEnabledByNfc) return;
+        if (hasConnectedBluetoothDevices()) return;
 
         if (!mBluetoothHeadsetConnected) {
             mBluetoothAdapter.disable();
@@ -256,6 +270,40 @@ public class PeripheralHandoverService extends Service implements BluetoothPerip
         return null;
     }
 
+    boolean hasConnectedBluetoothDevices() {
+        Set<BluetoothDevice> bondedDevices = mBluetoothAdapter.getBondedDevices();
+
+        if (bondedDevices != null) {
+            for (BluetoothDevice device : bondedDevices) {
+                if (device.equals(mDevice)) {
+                    // Not required to check the remote BT "target" device
+                    // connection status, because sometimes the connection
+                    // state is not yet been updated upon disconnection.
+                    // It is enough to check the connection status for
+                    // "other" remote BT device/s.
+                    continue;
+                }
+                if (device.isConnected()) return true;
+            }
+        }
+        return false;
+    }
+
+    void replyToClient(boolean connected) {
+        if (mClient == null) {
+            return;
+        }
+
+        final int msgId = connected ? MSG_HEADSET_CONNECTED : MSG_HEADSET_NOT_CONNECTED;
+        final Message msg = Message.obtain(null, msgId);
+        msg.arg1 = mBluetoothEnabledByNfc ? 1 : 0;
+        try {
+            mClient.send(msg);
+        } catch (RemoteException e) {
+            // Ignore
+        }
+    }
+
     @Override
     public boolean onUnbind(Intent intent) {
         // prevent any future callbacks to the client, no rebind call needed.
diff --git a/src/com/android/nfc/ndefpush/NdefPushServer.java b/src/com/android/nfc/ndefpush/NdefPushServer.java
index bf92c170..82b37dec 100644
--- a/src/com/android/nfc/ndefpush/NdefPushServer.java
+++ b/src/com/android/nfc/ndefpush/NdefPushServer.java
@@ -165,7 +165,7 @@ public class NdefPushServer {
                 } catch (LlcpException e) {
                     Log.e(TAG, "llcp error", e);
                 } catch (IOException e) {
-                    Log.e(TAG, "IO error", e);
+                    if (DBG) Log.d(TAG, "IO error");
                 } finally {
                     synchronized (NdefPushServer.this) {
                         if (mServerSocket != null) {
diff --git a/src/com/android/nfc/snep/SnepMessage.java b/src/com/android/nfc/snep/SnepMessage.java
index 50a76af2..4c3ad995 100644
--- a/src/com/android/nfc/snep/SnepMessage.java
+++ b/src/com/android/nfc/snep/SnepMessage.java
@@ -13,25 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-/******************************************************************************
- *
- *  The original Work has been changed by NXP Semiconductors.
- *
- *  Copyright (C) 2015 NXP Semiconductors
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
+
 package com.android.nfc.snep;
 
 import android.nfc.FormatException;
@@ -66,6 +48,16 @@ public final class SnepMessage {
     public static final byte RESPONSE_UNSUPPORTED_VERSION = (byte) 0xE1;
     public static final byte RESPONSE_REJECT = (byte) 0xFF;
 
+    private static final byte[] NDEF_SHORT_TEST_RECORD = new byte[]{(byte)0xD1,(byte)0x01,(byte)0x1E,(byte)0x54,(byte)0x02,(byte)0x6C,(byte)0x61, // NDEF Header
+            (byte)0x4C,(byte)0x6F,(byte)0x72,(byte)0x65,(byte)0x6D,(byte)0x20,(byte)0x69,(byte)0x70,(byte)0x73,(byte)0x75, // Payload
+            (byte)0x6D,(byte)0x20,(byte)0x64,(byte)0x6F,(byte)0x6C,(byte)0x6F,(byte)0x72,(byte)0x20,(byte)0x73,(byte)0x69,
+            (byte)0x74,(byte)0x20,(byte)0x61,(byte)0x6D,(byte)0x65,(byte)0x74,(byte)0x2E};
+
+    private static final byte[] NDEF_TEST_RECORD = new byte[]{(byte)0xC1,(byte)0x01,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x1E,(byte)0x54,(byte)0x02,(byte)0x6C,(byte)0x61, // NDEF Header
+            (byte)0x4C,(byte)0x6F,(byte)0x72,(byte)0x65,(byte)0x6D,(byte)0x20,(byte)0x69,(byte)0x70,(byte)0x73,(byte)0x75, // Payload
+            (byte)0x6D,(byte)0x20,(byte)0x64,(byte)0x6F,(byte)0x6C,(byte)0x6F,(byte)0x72,(byte)0x20,(byte)0x73,(byte)0x69,
+            (byte)0x74,(byte)0x20,(byte)0x61,(byte)0x6D,(byte)0x65,(byte)0x74,(byte)0x2E};
+
     private static final int HEADER_LENGTH = 6;
     public static final int MAL_IUT = 0x0400;
     public static final int MAL = 0xFFFFFFFF;
@@ -99,8 +91,8 @@ public final class SnepMessage {
     public static SnepMessage fromByteArray(byte[] data) throws FormatException {
         return new SnepMessage(data);
     }
-    public static NdefMessage getLargeNdef() throws UnsupportedEncodingException
-    {
+
+    public static NdefMessage getLargeNdef() throws UnsupportedEncodingException {
         String snepTestData2 = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus at"
                 +" lorem nunc, ut venenatis quam. Etiam id dolor quam, at viverra dolor."
                 +" Phasellus eu lacus ligula, quis euismod erat. Sed feugiat, ligula at"
@@ -125,8 +117,7 @@ public final class SnepMessage {
         return new NdefMessage(new NdefRecord[]{data2});
     }
 
-    public static NdefMessage getSmallNdef() throws UnsupportedEncodingException
-    {
+    public static NdefMessage getSmallNdef() throws UnsupportedEncodingException {
         String snepTestData1 = "Lorem ipsum dolor sit amet.";
         String lang = "la";
         byte[] textBytes = snepTestData1.getBytes();
@@ -183,21 +174,14 @@ public final class SnepMessage {
     public byte[] toByteArray() {
         byte[] bytes;
         if (mNdefMessage != null) {
-            if((NfcService.sIsDtaMode)&&(DtaSnepClient.mTestCaseId != 0)){
-               if(DtaSnepClient.mTestCaseId == 5 || DtaSnepClient.mTestCaseId == 6){
+            if (NfcService.sIsDtaMode && DtaSnepClient.mTestCaseId != 0) {
+               if (DtaSnepClient.mTestCaseId == 5 || DtaSnepClient.mTestCaseId == 6) {
                    bytes = mNdefMessage.toByteArray();
-               }
-               else{
-                   if(NfcService.sIsShortRecordLayout){
-                       bytes = new byte[]{(byte)0xD1,(byte)0x01,(byte)0x1E,(byte)0x54,(byte)0x02,(byte)0x6C,(byte)0x61, // NDEF Header
-                                          (byte)0x4C,(byte)0x6F,(byte)0x72,(byte)0x65,(byte)0x6D,(byte)0x20,(byte)0x69,(byte)0x70,(byte)0x73,(byte)0x75, // Payload
-                                          (byte)0x6D,(byte)0x20,(byte)0x64,(byte)0x6F,(byte)0x6C,(byte)0x6F,(byte)0x72,(byte)0x20,(byte)0x73,(byte)0x69,
-                                          (byte)0x74,(byte)0x20,(byte)0x61,(byte)0x6D,(byte)0x65,(byte)0x74,(byte)0x2E};
-                   }else{
-                       bytes = new byte[]{(byte)0xC1,(byte)0x01,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x1E,(byte)0x54,(byte)0x02,(byte)0x6C,(byte)0x61, // NDEF Header
-                               (byte)0x4C,(byte)0x6F,(byte)0x72,(byte)0x65,(byte)0x6D,(byte)0x20,(byte)0x69,(byte)0x70,(byte)0x73,(byte)0x75, // Payload
-                               (byte)0x6D,(byte)0x20,(byte)0x64,(byte)0x6F,(byte)0x6C,(byte)0x6F,(byte)0x72,(byte)0x20,(byte)0x73,(byte)0x69,
-                               (byte)0x74,(byte)0x20,(byte)0x61,(byte)0x6D,(byte)0x65,(byte)0x74,(byte)0x2E};
+               } else {
+                   if (NfcService.sIsShortRecordLayout) {
+                       bytes = NDEF_SHORT_TEST_RECORD;
+                   } else {
+                       bytes = NDEF_TEST_RECORD;
                    }
                }
             } else {
diff --git a/src/com/android/nfc/snep/SnepMessenger.java b/src/com/android/nfc/snep/SnepMessenger.java
index 871c90ce..0ee507cb 100644
--- a/src/com/android/nfc/snep/SnepMessenger.java
+++ b/src/com/android/nfc/snep/SnepMessenger.java
@@ -13,25 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-/******************************************************************************
- *
- *  The original Work has been changed by NXP Semiconductors.
- *
- *  Copyright (C) 2015 NXP Semiconductors
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
+
 package com.android.nfc.snep;
 
 import com.android.nfc.DeviceHost.LlcpSocket;
@@ -99,8 +81,8 @@ public class SnepMessenger {
                     snepResponse.getField() + ")");
         }
         // Look for wrong/invalid request or response from peer
-       if(NfcService.sIsDtaMode) {
-            if((mIsClient)&&(DtaSnepClient.mTestCaseId == 6)) {
+       if (NfcService.sIsDtaMode) {
+            if (mIsClient && (DtaSnepClient.mTestCaseId == 6)) {
                 length = Math.min(buffer.length - offset, mFragmentLength);
                 tmpBuffer = Arrays.copyOfRange(buffer, offset, offset + length);
                 if (DBG) Log.d(TAG, "about to send a " + length + " byte fragment");
@@ -129,8 +111,8 @@ public class SnepMessenger {
             if (DBG) Log.d(TAG, "about to send a " + length + " byte fragment");
             mSocket.send(tmpBuffer);
 
-            if(NfcService.sIsDtaMode) {
-                if((!mIsClient)&&(ExtDtaSnepServer.mTestCaseId == 0x01)){
+            if (NfcService.sIsDtaMode) {
+                if (!mIsClient && ExtDtaSnepServer.mTestCaseId == 0x01) {
                     mSocket.receive(responseBytes);
                     try {
                         snepResponse = SnepMessage.fromByteArray(responseBytes);
@@ -153,10 +135,10 @@ public class SnepMessenger {
         ByteArrayOutputStream buffer = new ByteArrayOutputStream(mFragmentLength);
         byte[] partial = new byte[mFragmentLength];
         int size;
+        int requestSize = 0;
         int readSize = 0;
         byte requestVersion = 0;
         byte requestField = 0; // for DTA Mode
-        int requestLength = 0;
         boolean doneReading = false;
         byte fieldContinue;
         byte fieldReject;
@@ -179,7 +161,7 @@ public class SnepMessenger {
             throw new IOException("Error reading SNEP message.");
         } else if (size < HEADER_LENGTH) {
             try {
-                if((NfcService.sIsDtaMode)&&(mIsClient)){
+                if (NfcService.sIsDtaMode && mIsClient) {
                     if (DBG) Log.d(TAG, "Invalid header length");
                     close();
                 } else {
@@ -199,16 +181,16 @@ public class SnepMessenger {
         DataInputStream dataIn = new DataInputStream(new ByteArrayInputStream(partial));
         requestVersion = dataIn.readByte();
         requestField = dataIn.readByte();
-        requestLength = dataIn.readInt();
+        requestSize = dataIn.readInt();
 
-        if (DBG) Log.d(TAG, "read " + readSize + " of " + requestLength);
+        if (DBG) Log.d(TAG, "read " + readSize + " of " + requestSize);
 
         if (((requestVersion & 0xF0) >> 4) != SnepMessage.VERSION_MAJOR) {
-            if(NfcService.sIsDtaMode) {
+            if (NfcService.sIsDtaMode) {
                 sendMessage(SnepMessage.getMessage(SnepMessage.RESPONSE_UNSUPPORTED_VERSION));
                 close();
             } else {
-            if(NfcService.sIsDtaMode) {
+            if (NfcService.sIsDtaMode) {
                 sendMessage(SnepMessage.getMessage(SnepMessage.RESPONSE_UNSUPPORTED_VERSION));
                 close();
             } else {
@@ -219,39 +201,37 @@ public class SnepMessenger {
 
         }
 
-        if(NfcService.sIsDtaMode) {
-            if((!mIsClient)&&((requestField == SnepMessage.RESPONSE_CONTINUE)||  // added for TC_S_BIT_B1_01_X
-                              (requestField == SnepMessage.RESPONSE_SUCCESS) ||
-                              (requestField == SnepMessage.RESPONSE_NOT_FOUND)))
-            {
+        if (NfcService.sIsDtaMode) {
+            if (!mIsClient && (requestField == SnepMessage.RESPONSE_CONTINUE ||  // added for TC_S_BIT_B1_01_X
+                              requestField == SnepMessage.RESPONSE_SUCCESS ||
+                              requestField == SnepMessage.RESPONSE_NOT_FOUND)) {
                 if (DBG) Log.d(TAG, "errorneous response received, disconnecting client");
                 close();
             }
-            if((!mIsClient)&&((requestField == SnepMessage.REQUEST_RFU)))
-            {
+            if (!mIsClient && requestField == SnepMessage.REQUEST_RFU) {
                 if (DBG) Log.d(TAG, "unknown request received, disconnecting client");
                 sendMessage(SnepMessage.getMessage(SnepMessage.RESPONSE_BAD_REQUEST));
                 close();
-
             }
-            if((mIsClient)&&((requestField == SnepMessage.REQUEST_PUT))) // added for TC_C_BIT_BI_01_0
-            {
+            // added for TC_C_BIT_BI_01_0
+            if (mIsClient && requestField == SnepMessage.REQUEST_PUT) {
                 if (DBG) Log.d(TAG, "errorneous PUT request received, disconnecting from server");
                     close();
             }
-            if((mIsClient)&&(requestLength > SnepMessage.MAL_IUT)) // added for TC_C_GET_BV_03
-            {
+            // added for TC_C_GET_BV_03
+            if (mIsClient && (requestSize > SnepMessage.MAL_IUT)) {
                 if (DBG) Log.d(TAG, "responding reject");
-                    return new SnepMessage(requestVersion, requestField, requestLength, 0, null);
+                    return new SnepMessage(requestVersion, requestField, requestSize, 0, null);
             }
-            if((!mIsClient)&&((requestLength > SnepMessage.MAL_IUT) || (requestLength == SnepMessage.MAL)))  //added for TC_S_ACC_BV_05_0&1 and TC_S_ACC_BV_06_0&1
-            {
+            //added for TC_S_ACC_BV_05_0&1 and TC_S_ACC_BV_06_0&1
+            if (!mIsClient && ((requestSize > SnepMessage.MAL_IUT) ||
+                                requestSize == SnepMessage.MAL)) {
                 if (DBG) Log.d(TAG, "responding reject");
-                    return new SnepMessage(requestVersion, requestField, requestLength, 0, null);
+                    return new SnepMessage(requestVersion, requestField, requestSize, 0, null);
             }
         }
 
-        if (requestLength > readSize) {
+        if (requestSize > readSize) {
             if (DBG) Log.d(TAG, "requesting continuation");
             mSocket.send(SnepMessage.getMessage(fieldContinue).toByteArray());
         } else {
@@ -273,7 +253,7 @@ public class SnepMessenger {
                 } else {
                     readSize += size;
                     buffer.write(partial, 0, size);
-                    if (readSize == requestLength) {
+                    if (readSize == requestSize) {
                         doneReading = true;
                     }
                 }
diff --git a/src/com/android/nfc/snep/SnepServer.java b/src/com/android/nfc/snep/SnepServer.java
index 94767fad..33b64063 100644
--- a/src/com/android/nfc/snep/SnepServer.java
+++ b/src/com/android/nfc/snep/SnepServer.java
@@ -13,25 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-/******************************************************************************
- *
- *  The original Work has been changed by NXP Semiconductors.
- *
- *  Copyright (C) 2015 NXP Semiconductors
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
+
 package com.android.nfc.snep;
 
 import com.android.nfc.DeviceHost.LlcpServerSocket;
@@ -173,8 +155,8 @@ public final class SnepServer {
         if (((request.getVersion() & 0xF0) >> 4) != SnepMessage.VERSION_MAJOR) {
             messenger.sendMessage(SnepMessage.getMessage(
                     SnepMessage.RESPONSE_UNSUPPORTED_VERSION));
-        } else if((NfcService.sIsDtaMode)&&((request.getLength() > SnepMessage.MAL_IUT) ||
-                (request.getLength() == SnepMessage.MAL))){
+        } else if (NfcService.sIsDtaMode && ((request.getLength() > SnepMessage.MAL_IUT) ||
+                                              request.getLength() == SnepMessage.MAL)) {
             if (DBG) Log.d(TAG, "Bad requested length");
             messenger.sendMessage(SnepMessage.getMessage(SnepMessage.RESPONSE_REJECT));
         } else if (request.getField() == SnepMessage.REQUEST_GET) {
@@ -246,7 +228,7 @@ public final class SnepServer {
                 } catch (LlcpException e) {
                     Log.e(TAG, "llcp error", e);
                 } catch (IOException e) {
-                    Log.e(TAG, "IO error", e);
+                    if (DBG) Log.d(TAG, "IO error");
                 } finally {
                     synchronized (SnepServer.this) {
                         if (mServerSocket != null) {
diff --git a/src/com/android/nfc/sneptest/DtaSnepClient.java b/src/com/android/nfc/sneptest/DtaSnepClient.java
index f1491cad..be6211bd 100644
--- a/src/com/android/nfc/sneptest/DtaSnepClient.java
+++ b/src/com/android/nfc/sneptest/DtaSnepClient.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 NXP Semiconductors
+ * Copyright (C) 2015-2018 NXP Semiconductors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -35,8 +35,7 @@ import com.android.nfc.snep.SnepException;
 import com.android.nfc.snep.SnepMessage;
 import com.android.nfc.snep.SnepMessenger;
 
-public final class DtaSnepClient
-{
+public final class DtaSnepClient {
     private static final String TAG = "DtaSnepClient";
     private static final boolean DBG = true;
     private static final int DEFAULT_ACCEPTABLE_LENGTH = 1024;
@@ -62,8 +61,7 @@ public final class DtaSnepClient
 
     SnepMessenger mMessenger = null;
 
-    public DtaSnepClient()
-    {
+    public DtaSnepClient() {
         mServiceName = DEFAULT_SERVICE_NAME;
         mPort = DEFAULT_PORT;
         mAcceptableLength = DEFAULT_ACCEPTABLE_LENGTH;
@@ -82,157 +80,146 @@ public final class DtaSnepClient
         mTestCaseId = testCaseId;
     }
 
-    public void DtaClientOperations(Context mContext)
-    {
+    public void DtaClientOperations(Context mContext) {
         DtaServiceConnector dtaServiceConnector=new DtaServiceConnector(mContext);
         dtaServiceConnector.bindService();
         if (DBG) Log.d(TAG, "Connecting remote server");
-        try{
+        try {
             connect();
-        }catch(IOException e){
+        } catch(IOException e) {
             Log.e(TAG, "Error connecting remote server");
         }
-        switch(mTestCaseId)
-        {
-           case 1: //TC_C_BIT_BV_01
+        switch(mTestCaseId) {
+           //TC_C_BIT_BV_01
+           case 1:
            {
                try {
                    if (DBG) Log.d(TAG, "PUT Small Ndef Data");
                    put(SnepMessage.getSmallNdef());
                    dtaServiceConnector.sendMessage(SnepMessage.getSmallNdef().toString());
                } catch (UnsupportedEncodingException e) {
-                     // TODO Auto-generated catch block
                      e.printStackTrace();
                } catch (IOException e) {
-                     // TODO Auto-generated catch block
                      e.printStackTrace();
                }
                close();
            }
            break;
-           case 2: //TC_C_BIT_BI_01_0
+           //TC_C_BIT_BI_01_0
+           case 2:
            {
                try {
-                       if (DBG) Log.d(TAG, "PUT Small Ndef Data");
-                       put(SnepMessage.getSmallNdef());
-                       dtaServiceConnector.sendMessage(SnepMessage.getSmallNdef().toString());
+                   if (DBG) Log.d(TAG, "PUT Small Ndef Data");
+                   put(SnepMessage.getSmallNdef());
+                   dtaServiceConnector.sendMessage(SnepMessage.getSmallNdef().toString());
                } catch (UnsupportedEncodingException e) {
-                     // TODO Auto-generated catch block
-                     e.printStackTrace();
+                   e.printStackTrace();
                } catch (IOException e) {
-                   // TODO Auto-generated catch block
                    e.printStackTrace();
                }
                close();
            }
            break;
-           case 3: //TC_C_BIT_BI_01_1
+           //TC_C_BIT_BI_01_1
+           case 3:
            {
                try {
                    if (DBG) Log.d(TAG, "PUT Small Ndef Data");
                    put(SnepMessage.getSmallNdef());
                    dtaServiceConnector.sendMessage(SnepMessage.getSmallNdef().toString());
                } catch (UnsupportedEncodingException e) {
-                   // TODO Auto-generated catch block
                    e.printStackTrace();
                } catch (IOException e) {
-                   // TODO Auto-generated catch block
                    e.printStackTrace();
                }
                close();
            }
            break;
-           case 4: //TC_C_PUT_BV_01
+           //TC_C_PUT_BV_01
+           case 4:
            {
                try {
                    if (DBG) Log.d(TAG, "PUT Small Ndef Data");
                    put(SnepMessage.getSmallNdef());
                    dtaServiceConnector.sendMessage(SnepMessage.getSmallNdef().toString());
                } catch (UnsupportedEncodingException e) {
-                   // TODO Auto-generated catch block
                    e.printStackTrace();
                } catch (IOException e) {
-                   // TODO Auto-generated catch block
                    e.printStackTrace();
                }
                close();
            }
            break;
-           case 5: //TC_C_PUT_BV_02
+           //TC_C_PUT_BV_02
+           case 5:
            {
                try {
-                if (DBG) Log.d(TAG, "PUT Large Ndef Data");
-                put(SnepMessage.getLargeNdef());
-                dtaServiceConnector.sendMessage(SnepMessage.getLargeNdef().toString());
-            } catch (UnsupportedEncodingException e) {
-                // TODO Auto-generated catch block
-                e.printStackTrace();
-            } catch (IOException e) {
-                // TODO Auto-generated catch block
-                e.printStackTrace();
-            }
+                   if (DBG) Log.d(TAG, "PUT Large Ndef Data");
+                   put(SnepMessage.getLargeNdef());
+                   dtaServiceConnector.sendMessage(SnepMessage.getLargeNdef().toString());
+               } catch (UnsupportedEncodingException e) {
+                   e.printStackTrace();
+               } catch (IOException e) {
+                   e.printStackTrace();
+               }
                close();
            }
            break;
-           case 6: //TC_C_PUT_BI_01
+           //TC_C_PUT_BI_01
+           case 6:
            {
                try {
-                if (DBG) Log.d(TAG, "PUT Large Ndef Data");
-                put(SnepMessage.getLargeNdef());
-                dtaServiceConnector.sendMessage(SnepMessage.getLargeNdef().toString());
-            } catch (UnsupportedEncodingException e) {
-                // TODO Auto-generated catch block
-                e.printStackTrace();
-            } catch (IOException e) {
-                // TODO Auto-generated catch block
-                e.printStackTrace();
-            }
+                   if (DBG) Log.d(TAG, "PUT Large Ndef Data");
+                   put(SnepMessage.getLargeNdef());
+                   dtaServiceConnector.sendMessage(SnepMessage.getLargeNdef().toString());
+               } catch (UnsupportedEncodingException e) {
+                   e.printStackTrace();
+               } catch (IOException e) {
+                   e.printStackTrace();
+               }
                close();
            }
            break;
-           case 7: //TC_C_GET_BV_01
+           //TC_C_GET_BV_01
+           case 7:
            {
                try {
                    if (DBG) Log.d(TAG, "GET Ndef Message");
                    get(SnepMessage.getSmallNdef());
                    dtaServiceConnector.sendMessage(SnepMessage.getSmallNdef().toString());
                } catch (UnsupportedEncodingException e) {
-                   // TODO Auto-generated catch block
                    e.printStackTrace();
                } catch (IOException e) {
-                   // TODO Auto-generated catch block
                    e.printStackTrace();
                }
                close();
            }
            break;
-           case 8: //TC_C_GET_BV_02
+           //TC_C_GET_BV_02
+           case 8:
            {
                try {
                    if (DBG) Log.d(TAG, "GET Ndef Message");
                    get(SnepMessage.getSmallNdef());
                    dtaServiceConnector.sendMessage(SnepMessage.getSmallNdef().toString());
                } catch (UnsupportedEncodingException e) {
-                   // TODO Auto-generated catch block
                    e.printStackTrace();
                } catch (IOException e) {
-                   // TODO Auto-generated catch block
                    e.printStackTrace();
                }
                close();
            }
            break;
-           case 9: //TC_C_GET_BV_03
+           //TC_C_GET_BV_03
+           case 9:
            {
                try {
                    if (DBG) Log.d(TAG, "GET Ndef Message");
                    get(SnepMessage.getSmallNdef());
                    dtaServiceConnector.sendMessage(SnepMessage.getSmallNdef().toString());
                } catch (UnsupportedEncodingException e) {
-                   // TODO Auto-generated catch block
                    e.printStackTrace();
                } catch (IOException e) {
-                   // TODO Auto-generated catch block
                    e.printStackTrace();
                }
                close();
@@ -317,8 +304,7 @@ public final class DtaSnepClient
             if (socket != null) {
                 try {
                     socket.close();
-                } catch (IOException e2) {
-                }
+                } catch (IOException e2) {}
             }
             synchronized (this) {
                 mState = DISCONNECTED;
diff --git a/src/com/android/nfc/sneptest/ExtDtaSnepServer.java b/src/com/android/nfc/sneptest/ExtDtaSnepServer.java
index 5e256318..350b8be4 100644
--- a/src/com/android/nfc/sneptest/ExtDtaSnepServer.java
+++ b/src/com/android/nfc/sneptest/ExtDtaSnepServer.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 NXP Semiconductors
+ * Copyright (C) 2017-2018 NXP Semiconductors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -30,8 +30,7 @@ import com.android.nfc.snep.SnepException;
 import com.android.nfc.snep.SnepMessage;
 import com.android.nfc.snep.SnepMessenger;
 
-public final class ExtDtaSnepServer
-{
+public final class ExtDtaSnepServer {
     private static final String TAG = "ExtDtaSnepServer";
     private static final boolean DBG = true;
     public static final int DEFAULT_PORT = 5;
@@ -52,15 +51,14 @@ public final class ExtDtaSnepServer
     boolean mServerRunning = false;
     static DtaServiceConnector dtaServiceConnector;
 
-    public interface Callback
-    {
+    public interface Callback {
         public SnepMessage doPut(NdefMessage msg);
         public SnepMessage doGet(int acceptableLength, NdefMessage msg);
     }
 
     // for NFC Forum SNEP DTA
-    public ExtDtaSnepServer(String serviceName, int serviceSap, int miu, int rwSize, Callback callback,Context mContext,int testCaseId)
-    {
+    public ExtDtaSnepServer(String serviceName, int serviceSap, int miu, int rwSize,
+                            Callback callback,Context mContext,int testCaseId) {
         mExtDtaSnepServerCallback = callback;
         mDtaServiceName = serviceName;
         mDtaServiceSap = serviceSap;
@@ -73,13 +71,11 @@ public final class ExtDtaSnepServer
     }
 
     /** Connection class, used to handle incoming connections */
-    private class ConnectionThread extends Thread
-    {
+    private class ConnectionThread extends Thread {
         private final LlcpSocket mSock;
         private final SnepMessenger mMessager;
 
-        ConnectionThread(LlcpSocket socket, int fragmentLength)
-        {
+        ConnectionThread(LlcpSocket socket, int fragmentLength) {
             super(TAG);
             mSock = socket;
             mMessager = new SnepMessenger(false, socket, fragmentLength);
@@ -95,9 +91,8 @@ public final class ExtDtaSnepServer
                 }
 
                 while (running) {
-                    if (!handleRequest(mMessager, mExtDtaSnepServerCallback)) {
+                    if (!handleRequest(mMessager, mExtDtaSnepServerCallback))
                         break;
-                    }
 
                     synchronized (ExtDtaSnepServer.this) {
                         running = mServerRunning;
@@ -109,17 +104,13 @@ public final class ExtDtaSnepServer
                 try {
                     if (DBG) Log.d(TAG, "about to close");
                     mSock.close();
-                } catch (IOException e) {
-                    // ignore
-                }
+                } catch (IOException e) {}
             }
-
             if (DBG) Log.d(TAG, "finished connection thread");
         }
     }
 
-    static boolean handleRequest(SnepMessenger messenger, Callback callback) throws IOException
-    {
+    static boolean handleRequest(SnepMessenger messenger, Callback callback) throws IOException {
         SnepMessage request;
         try {
             request = messenger.getMessage();
@@ -128,59 +119,42 @@ public final class ExtDtaSnepServer
             try {
                 messenger.sendMessage(SnepMessage.getMessage(
                     SnepMessage.RESPONSE_BAD_REQUEST));
-            } catch (IOException e2) {
-                // Ignore
-            }
+            } catch (IOException e2) {}
             return false;
         }
 
-        if (((request.getVersion() & 0xF0) >> 4) != SnepMessage.VERSION_MAJOR)
-        {
+        if (((request.getVersion() & 0xF0) >> 4) != SnepMessage.VERSION_MAJOR) {
             messenger.sendMessage(SnepMessage.getMessage(
                     SnepMessage.RESPONSE_UNSUPPORTED_VERSION));
-        }
-        else if((request.getLength() > SnepMessage.MAL_IUT) ||  //added for TC_S_ACC_BV_05_0&1 and TC_S_ACC_BV_06_0&1
-                (request.getLength() == SnepMessage.MAL))
-        {
+        } else if ((request.getLength() > SnepMessage.MAL_IUT) || request.getLength() == SnepMessage.MAL) {
             if (DBG) Log.d(TAG, "Bad requested length");
             messenger.sendMessage(SnepMessage.getMessage(SnepMessage.RESPONSE_REJECT));
-        }
-        else if (request.getField() == SnepMessage.REQUEST_GET)
-        {
+        } else if (request.getField() == SnepMessage.REQUEST_GET) {
             if (DBG) Log.d(TAG, "getting message " + request.toString());
-            messenger.sendMessage(callback.doGet(request.getAcceptableLength(),
-                    request.getNdefMessage()));
-            if(request.getNdefMessage()!=null)
-            dtaServiceConnector.sendMessage(request.getNdefMessage().toString());
-        }
-        else if (request.getField() == SnepMessage.REQUEST_PUT)
-        {
+            messenger.sendMessage(callback.doGet(request.getAcceptableLength(), request.getNdefMessage()));
+            if (request.getNdefMessage() != null)
+                dtaServiceConnector.sendMessage(request.getNdefMessage().toString());
+        } else if (request.getField() == SnepMessage.REQUEST_PUT) {
             if (DBG) Log.d(TAG, "putting message " + request.toString());
             messenger.sendMessage(callback.doPut(request.getNdefMessage()));
-            if(request.getNdefMessage()!=null)
-            dtaServiceConnector.sendMessage(request.getNdefMessage().toString());
-        }
-        else
-        {
+            if (request.getNdefMessage() != null)
+                dtaServiceConnector.sendMessage(request.getNdefMessage().toString());
+        } else {
             if (DBG) Log.d(TAG, "Unknown request (" + request.getField() +")");
-            messenger.sendMessage(SnepMessage.getMessage(
-                    SnepMessage.RESPONSE_BAD_REQUEST));
+            messenger.sendMessage(SnepMessage.getMessage(SnepMessage.RESPONSE_BAD_REQUEST));
         }
         return true;
     }
 
     /** Server class, used to listen for incoming connection request */
-    class ServerThread extends Thread
-    {
+    class ServerThread extends Thread {
         private boolean mThreadRunning = true;
         LlcpServerSocket mServerSocket;
 
         @Override
-        public void run()
-        {
+        public void run() {
             boolean threadRunning;
-            synchronized (ExtDtaSnepServer.this)
-            {
+            synchronized (ExtDtaSnepServer.this) {
                 threadRunning = mThreadRunning;
             }
 
@@ -215,8 +189,7 @@ public final class ExtDtaSnepServer
                         if (DBG) Log.d(TAG, "accept returned " + communicationSocket);
                         if (communicationSocket != null) {
                             int miu = communicationSocket.getRemoteMiu();
-                            int fragmentLength = (mDtaFragmentLength == -1) ?
-                                    miu : Math.min(miu, mDtaFragmentLength);
+                            int fragmentLength = (mDtaFragmentLength == -1) ? miu : Math.min(miu, mDtaFragmentLength);
                             new ConnectionThread(communicationSocket, fragmentLength).start();
                         }
 
@@ -235,9 +208,7 @@ public final class ExtDtaSnepServer
                             if (DBG) Log.d(TAG, "about to close");
                             try {
                                 mServerSocket.close();
-                            } catch (IOException e) {
-                                // ignore
-                            }
+                            } catch (IOException e) {}
                             mServerSocket = null;
                         }
                     }
@@ -249,26 +220,21 @@ public final class ExtDtaSnepServer
             }
         }
 
-        public void shutdown()
-        {
+        public void shutdown() {
             synchronized (ExtDtaSnepServer.this) {
                 mThreadRunning = false;
                 if (mServerSocket != null) {
                     try {
                         mServerSocket.close();
-                    } catch (IOException e) {
-                        // ignore
-                    }
+                    } catch (IOException e) {}
                     mServerSocket = null;
                 }
             }
         }
     }
 
-    public void start()
-    {
-        synchronized (ExtDtaSnepServer.this)
-        {
+    public void start() {
+        synchronized (ExtDtaSnepServer.this) {
             if (DBG) Log.d(TAG, "start, thread = " + mServerThread);
             if (mServerThread == null) {
                 if (DBG) Log.d(TAG, "starting new server thread");
@@ -279,10 +245,8 @@ public final class ExtDtaSnepServer
         }
     }
 
-    public void stop()
-    {
-        synchronized (ExtDtaSnepServer.this)
-        {
+    public void stop() {
+        synchronized (ExtDtaSnepServer.this) {
             if (DBG) Log.d(TAG, "stop, thread = " + mServerThread);
             if (mServerThread != null) {
                 if (DBG) Log.d(TAG, "shuting down server thread");
-- 
2.17.1

