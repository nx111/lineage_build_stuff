From bd62718314d3c69d3a60ec4b75e285060724c51f Mon Sep 17 00:00:00 2001
From: Bruno Martins <bgcngm@gmail.com>
Date: Fri, 8 Mar 2019 00:00:48 +0000
Subject: [PATCH] [SQUASH][DNM] Merge tag 'LA.UM.7.3.r1-06900-sdm845.0' into
 HEAD

Change-Id: Id83a9a6af9ad7f000aae212c0aef333881bf7249
---
 Android.bp                                    |    1 +
 Android.mk                                    |  140 --
 OWNERS                                        |    2 +
 README.md                                     |   13 +
 p61-jcop-kit/README.md                        |   22 +
 run_unit_tests.sh                             |  125 ++
 src/Android.bp                                |   75 +
 .../{CrcChecksum.cpp => CrcChecksum.cc}       |   25 +-
 .../{NfcAdaptation.cpp => NfcAdaptation.cc}   |  645 ++++--
 src/adaptation/OverrideLog.cpp                |  145 --
 src/adaptation/android_logmsg.cpp             |  351 ---
 src/adaptation/config.cpp                     |  827 --------
 src/adaptation/debug_nfcsnoop.cc              |  187 ++
 src/adaptation/{libmain.c => libmain.cc}      |  145 +-
 src/adaptation/nfc_config.cc                  |  103 +
 src/gki/common/gki.h                          |   62 +-
 .../common/{gki_buffer.c => gki_buffer.cc}    |  265 +--
 src/gki/common/gki_common.h                   |  134 +-
 src/gki/common/gki_debug.c                    |  308 ---
 src/gki/common/gki_inet.h                     |    6 -
 src/gki/common/{gki_time.c => gki_time.cc}    |   31 +-
 src/gki/ulinux/data_types.h                   |    6 -
 src/gki/ulinux/gki_int.h                      |   13 +-
 .../ulinux/{gki_ulinux.c => gki_ulinux.cc}    |  295 ++-
 src/hal/include/nfc_hal_api.h                 |  420 ----
 src/hal/include/nfc_hal_target.h              |  437 ----
 src/hal/include/nfc_types.h                   |  351 ---
 src/hal/int/nfc_brcm_defs.h                   |  420 ----
 src/hal/int/nfc_hal_int.h                     |  538 -----
 src/hal/int/nfc_hal_int_api.h                 |  307 ---
 src/hal/int/nfc_hal_nv_ci.h                   |   89 -
 src/hal/int/nfc_hal_nv_co.h                   |  118 --
 src/include/CrcChecksum.h                     |    7 -
 src/include/NfcAdaptation.h                   |   26 +-
 src/{hal => }/include/Nxp_Features.h          |    0
 src/include/_OverrideLog.h                    |   95 -
 src/include/android_logmsg.h                  |   88 -
 src/include/bt_trace.h                        | 1876 -----------------
 src/include/bt_types.h                        |   31 -
 src/include/buildcfg.h                        |   63 +-
 src/include/config.h                          |  188 --
 src/include/debug_nfcsnoop.h                  |   50 +
 src/{hal => }/include/gki_hal_target.h        |   96 +-
 src/include/gki_target.h                      |  110 +-
 src/{hal => }/include/nci_defs.h              |  256 +--
 src/include/nfc_brcm_defs.h                   |   86 +
 src/include/nfc_config.h                      |  123 ++
 src/include/nfc_hal_api.h                     |  104 +
 src/include/nfc_hal_int.h                     |  276 +++
 src/include/nfc_hal_int_api.h                 |   76 +
 .../nfc_hal_nv_ci.h}                          |   26 +-
 src/include/nfc_hal_nv_co.h                   |   57 +
 src/{hal/int => include}/nfc_hal_post_reset.h |   10 -
 src/include/nfc_hal_target.h                  |  163 ++
 src/include/nfc_target.h                      |   21 +-
 src/include/nfc_types.h                       |  180 ++
 src/include/trace_api.h                       |   49 -
 src/nfa/ce/{nfa_ce_act.c => nfa_ce_act.cc}    |  203 +-
 src/nfa/ce/{nfa_ce_api.c => nfa_ce_api.cc}    |   42 +-
 src/nfa/ce/{nfa_ce_main.c => nfa_ce_main.cc}  |   36 +-
 src/nfa/dm/{nfa_dm_act.c => nfa_dm_act.cc}    |  457 ++--
 src/nfa/dm/{nfa_dm_api.c => nfa_dm_api.cc}    |  282 +--
 src/nfa/dm/{nfa_dm_cfg.c => nfa_dm_cfg.cc}    |   27 +-
 .../{nfa_dm_discover.c => nfa_dm_discover.cc} |  815 +++----
 src/nfa/dm/{nfa_dm_main.c => nfa_dm_main.cc}  |  111 +-
 src/nfa/dm/{nfa_dm_ndef.c => nfa_dm_ndef.cc}  |  137 +-
 src/nfa/ee/{nfa_ee_act.c => nfa_ee_act.cc}    | 1287 ++++++-----
 src/nfa/ee/{nfa_ee_api.c => nfa_ee_api.cc}    |  275 ++-
 src/nfa/ee/{nfa_ee_main.c => nfa_ee_main.cc}  |  106 +-
 src/nfa/hci/{nfa_hci_act.c => nfa_hci_act.cc} |  254 +--
 src/nfa/hci/{nfa_hci_api.c => nfa_hci_api.cc} |  267 +--
 src/nfa/hci/{nfa_hci_ci.c => nfa_hci_ci.cc}   |    4 +-
 .../hci/{nfa_hci_main.c => nfa_hci_main.cc}   |  204 +-
 .../hci/{nfa_hci_utils.c => nfa_hci_utils.cc} |  134 +-
 src/nfa/include/nfa_api.h                     |  211 +-
 src/nfa/include/nfa_ce_api.h                  |   10 +-
 src/nfa/{int => include}/nfa_ce_int.h         |    8 +-
 src/nfa/{int => include}/nfa_dm_int.h         |   72 +-
 src/nfa/{int => include}/nfa_dta_int.h        |  108 -
 src/nfa/include/nfa_ee_api.h                  |  127 +-
 src/nfa/{int => include}/nfa_ee_int.h         |   91 +-
 src/nfa/include/nfa_hci_api.h                 |   39 +-
 src/nfa/include/nfa_hci_defs.h                |   10 +-
 src/nfa/{int => include}/nfa_hci_int.h        |   42 +-
 src/nfa/include/nfa_mem_co.h                  |    6 -
 src/nfa/include/nfa_nv_ci.h                   |   25 -
 src/nfa/include/nfa_nv_co.h                   |   10 -
 src/nfa/include/nfa_p2p_api.h                 |   33 -
 src/nfa/{int => include}/nfa_p2p_int.h        |   10 +-
 src/nfa/include/nfa_rw_api.h                  |   18 +-
 src/nfa/{int => include}/nfa_rw_int.h         |   10 +-
 src/nfa/include/nfa_snep_api.h                |  315 ---
 src/nfa/{int => include}/nfa_snep_int.h       |   57 +-
 src/nfa/{int => include}/nfa_sys.h            |    9 -
 src/nfa/{int => include}/nfa_sys_int.h        |    4 +-
 src/nfa/{int => include}/nfa_sys_ptim.h       |    6 -
 src/nfa/p2p/{nfa_p2p_act.c => nfa_p2p_act.cc} |   86 +-
 src/nfa/p2p/{nfa_p2p_api.c => nfa_p2p_api.cc} |  168 +-
 .../p2p/{nfa_p2p_main.c => nfa_p2p_main.cc}   |  249 ++-
 src/nfa/rw/{nfa_rw_act.c => nfa_rw_act.cc}    |  355 ++--
 src/nfa/rw/{nfa_rw_api.c => nfa_rw_api.cc}    |  170 +-
 src/nfa/rw/{nfa_rw_main.c => nfa_rw_main.cc}  |   37 +-
 .../sys/{nfa_sys_cback.c => nfa_sys_cback.cc} |   11 +-
 src/nfa/sys/{nfa_sys_cfg.c => nfa_sys_cfg.cc} |    2 -
 .../sys/{nfa_sys_main.c => nfa_sys_main.cc}   |   41 +-
 .../sys/{nfa_sys_ptim.c => nfa_sys_ptim.cc}   |   21 +-
 src/nfc/include/ce_api.h                      |   54 +-
 src/nfc/{int => include}/ce_int.h             |   12 -
 src/nfc/include/llcp_api.h                    |   32 +-
 src/nfc/include/llcp_defs.h                   |   30 -
 src/nfc/{int => include}/llcp_int.h           |   21 +-
 src/nfc/include/nci_hmsgs.h                   |   20 +-
 src/nfc/include/ndef_utils.h                  |   49 -
 src/nfc/include/nfc_api.h                     |  336 ++-
 src/nfc/{int => include}/nfc_int.h            |   44 +-
 src/nfc/include/nfc_vs.h                      |   29 +
 src/nfc/include/rw_api.h                      |   40 +-
 src/nfc/{int => include}/rw_int.h             |   32 +-
 src/nfc/include/tags_defs.h                   |  188 +-
 src/nfc/{int => include}/tags_int.h           |    7 +-
 src/nfc/llcp/{llcp_api.c => llcp_api.cc}      |  216 +-
 src/nfc/llcp/{llcp_dlc.c => llcp_dlc.cc}      |  204 +-
 src/nfc/llcp/{llcp_link.c => llcp_link.cc}    |  197 +-
 src/nfc/llcp/{llcp_main.c => llcp_main.cc}    |   40 +-
 src/nfc/llcp/{llcp_sdp.c => llcp_sdp.cc}      |   99 +-
 src/nfc/llcp/{llcp_util.c => llcp_util.cc}    |   93 +-
 src/nfc/nci/{nci_hmsgs.c => nci_hmsgs.cc}     |  162 +-
 src/nfc/nci/{nci_hrcv.c => nci_hrcv.cc}       |  187 +-
 src/nfc/ndef/{ndef_utils.c => ndef_utils.cc}  |  149 +-
 src/nfc/nfc/{nfc_ee.c => nfc_ee.cc}           |   16 +-
 src/nfc/nfc/{nfc_main.c => nfc_main.cc}       |  378 ++--
 src/nfc/nfc/{nfc_ncif.c => nfc_ncif.cc}       |  910 ++++----
 src/nfc/nfc/{nfc_task.c => nfc_task.cc}       |   51 +-
 src/nfc/nfc/{nfc_test.c => nfc_test.cc}       |    0
 src/nfc/nfc/{nfc_utils.c => nfc_utils.cc}     |   19 +-
 src/nfc/nfc/{nfc_vs.c => nfc_vs.cc}           |   77 +-
 src/nfc/tags/{ce_main.c => ce_main.cc}        |   35 +-
 src/nfc/tags/{ce_t3t.c => ce_t3t.cc}          |  112 +-
 src/nfc/tags/{ce_t4t.c => ce_t4t.cc}          |  261 +--
 src/nfc/tags/{rw_i93.c => rw_i93.cc}          |  647 ++++--
 src/nfc/tags/{rw_main.c => rw_main.cc}        |   49 +-
 src/nfc/tags/{rw_t1t.c => rw_t1t.cc}          |  187 +-
 .../tags/{rw_t1t_ndef.c => rw_t1t_ndef.cc}    |  137 +-
 src/nfc/tags/{rw_t2t.c => rw_t2t.cc}          |  167 +-
 .../tags/{rw_t2t_ndef.c => rw_t2t_ndef.cc}    |   96 +-
 src/nfc/tags/{rw_t3t.c => rw_t3t.cc}          |  296 ++-
 src/nfc/tags/{rw_t4t.c => rw_t4t.cc}          |  299 ++-
 src/nfc/tags/{tags_int.c => tags_int.cc}      |   12 +-
 src/static-lib-adapt/ProtoDispBluetoothHci.c  |  162 --
 src/udrv/include/upio.h                       |  348 ---
 utils/Android.bp                              |   50 +
 utils/config.cc                               |  190 ++
 utils/include/config.h                        |   64 +
 utils/include/ringbuffer.h                    |   62 +
 utils/ringbuffer.cc                           |  116 +
 utils/test/config_test.cc                     |  135 ++
 utils/test/ringbuffer_test.cc                 |  138 ++
 157 files changed, 9215 insertions(+), 15705 deletions(-)
 create mode 100644 Android.bp
 delete mode 100644 Android.mk
 create mode 100644 OWNERS
 create mode 100644 run_unit_tests.sh
 create mode 100755 src/Android.bp
 rename src/adaptation/{CrcChecksum.cpp => CrcChecksum.cc} (91%)
 mode change 100644 => 100755
 rename src/adaptation/{NfcAdaptation.cpp => NfcAdaptation.cc} (58%)
 mode change 100644 => 100755
 delete mode 100644 src/adaptation/OverrideLog.cpp
 delete mode 100644 src/adaptation/android_logmsg.cpp
 delete mode 100644 src/adaptation/config.cpp
 create mode 100755 src/adaptation/debug_nfcsnoop.cc
 rename src/adaptation/{libmain.c => libmain.cc} (60%)
 mode change 100644 => 100755
 create mode 100755 src/adaptation/nfc_config.cc
 rename src/gki/common/{gki_buffer.c => gki_buffer.cc} (82%)
 mode change 100644 => 100755
 mode change 100644 => 100755 src/gki/common/gki_common.h
 delete mode 100644 src/gki/common/gki_debug.c
 mode change 100644 => 100755 src/gki/common/gki_inet.h
 rename src/gki/common/{gki_time.c => gki_time.cc} (97%)
 mode change 100644 => 100755
 mode change 100644 => 100755 src/gki/ulinux/data_types.h
 mode change 100644 => 100755 src/gki/ulinux/gki_int.h
 rename src/gki/ulinux/{gki_ulinux.c => gki_ulinux.cc} (85%)
 delete mode 100644 src/hal/include/nfc_hal_api.h
 delete mode 100644 src/hal/include/nfc_hal_target.h
 delete mode 100644 src/hal/include/nfc_types.h
 delete mode 100644 src/hal/int/nfc_brcm_defs.h
 delete mode 100644 src/hal/int/nfc_hal_int.h
 delete mode 100644 src/hal/int/nfc_hal_int_api.h
 delete mode 100644 src/hal/int/nfc_hal_nv_ci.h
 delete mode 100644 src/hal/int/nfc_hal_nv_co.h
 mode change 100644 => 100755 src/include/NfcAdaptation.h
 rename src/{hal => }/include/Nxp_Features.h (100%)
 delete mode 100644 src/include/_OverrideLog.h
 delete mode 100644 src/include/android_logmsg.h
 delete mode 100644 src/include/bt_trace.h
 mode change 100644 => 100755 src/include/bt_types.h
 mode change 100644 => 100755 src/include/buildcfg.h
 delete mode 100644 src/include/config.h
 create mode 100644 src/include/debug_nfcsnoop.h
 rename src/{hal => }/include/gki_hal_target.h (57%)
 mode change 100644 => 100755 src/include/gki_target.h
 rename src/{hal => }/include/nci_defs.h (77%)
 mode change 100644 => 100755
 create mode 100755 src/include/nfc_brcm_defs.h
 create mode 100755 src/include/nfc_config.h
 create mode 100755 src/include/nfc_hal_api.h
 create mode 100755 src/include/nfc_hal_int.h
 create mode 100755 src/include/nfc_hal_int_api.h
 rename src/{nfca_version.c => include/nfc_hal_nv_ci.h} (59%)
 mode change 100644 => 100755
 create mode 100755 src/include/nfc_hal_nv_co.h
 rename src/{hal/int => include}/nfc_hal_post_reset.h (88%)
 create mode 100755 src/include/nfc_hal_target.h
 mode change 100644 => 100755 src/include/nfc_target.h
 create mode 100755 src/include/nfc_types.h
 delete mode 100644 src/include/trace_api.h
 rename src/nfa/ce/{nfa_ce_act.c => nfa_ce_act.cc} (93%)
 mode change 100644 => 100755
 rename src/nfa/ce/{nfa_ce_api.c => nfa_ce_api.cc} (92%)
 rename src/nfa/ce/{nfa_ce_main.c => nfa_ce_main.cc} (90%)
 rename src/nfa/dm/{nfa_dm_act.c => nfa_dm_act.cc} (85%)
 mode change 100644 => 100755
 rename src/nfa/dm/{nfa_dm_api.c => nfa_dm_api.cc} (87%)
 rename src/nfa/dm/{nfa_dm_cfg.c => nfa_dm_cfg.cc} (81%)
 mode change 100644 => 100755
 rename src/nfa/dm/{nfa_dm_discover.c => nfa_dm_discover.cc} (82%)
 rename src/nfa/dm/{nfa_dm_main.c => nfa_dm_main.cc} (89%)
 mode change 100644 => 100755
 rename src/nfa/dm/{nfa_dm_ndef.c => nfa_dm_ndef.cc} (79%)
 rename src/nfa/ee/{nfa_ee_act.c => nfa_ee_act.cc} (80%)
 rename src/nfa/ee/{nfa_ee_api.c => nfa_ee_api.cc} (79%)
 mode change 100644 => 100755
 rename src/nfa/ee/{nfa_ee_main.c => nfa_ee_main.cc} (89%)
 mode change 100644 => 100755
 rename src/nfa/hci/{nfa_hci_act.c => nfa_hci_act.cc} (93%)
 rename src/nfa/hci/{nfa_hci_api.c => nfa_hci_api.cc} (80%)
 mode change 100644 => 100755
 rename src/nfa/hci/{nfa_hci_ci.c => nfa_hci_ci.cc} (96%)
 rename src/nfa/hci/{nfa_hci_main.c => nfa_hci_main.cc} (92%)
 mode change 100644 => 100755
 rename src/nfa/hci/{nfa_hci_utils.c => nfa_hci_utils.cc} (92%)
 mode change 100644 => 100755 src/nfa/include/nfa_api.h
 rename src/nfa/{int => include}/nfa_ce_int.h (98%)
 rename src/nfa/{int => include}/nfa_dm_int.h (96%)
 mode change 100644 => 100755
 rename src/nfa/{int => include}/nfa_dta_int.h (72%)
 mode change 100644 => 100755 src/nfa/include/nfa_ee_api.h
 rename src/nfa/{int => include}/nfa_ee_int.h (93%)
 mode change 100644 => 100755
 mode change 100644 => 100755 src/nfa/include/nfa_hci_api.h
 mode change 100644 => 100755 src/nfa/include/nfa_hci_defs.h
 rename src/nfa/{int => include}/nfa_hci_int.h (96%)
 mode change 100644 => 100755
 rename src/nfa/{int => include}/nfa_p2p_int.h (97%)
 rename src/nfa/{int => include}/nfa_rw_int.h (98%)
 rename src/nfa/{int => include}/nfa_snep_int.h (77%)
 rename src/nfa/{int => include}/nfa_sys.h (96%)
 rename src/nfa/{int => include}/nfa_sys_int.h (96%)
 rename src/nfa/{int => include}/nfa_sys_ptim.h (98%)
 rename src/nfa/p2p/{nfa_p2p_act.c => nfa_p2p_act.cc} (92%)
 rename src/nfa/p2p/{nfa_p2p_api.c => nfa_p2p_api.cc} (87%)
 rename src/nfa/p2p/{nfa_p2p_main.c => nfa_p2p_main.cc} (78%)
 mode change 100644 => 100755
 rename src/nfa/rw/{nfa_rw_act.c => nfa_rw_act.cc} (92%)
 rename src/nfa/rw/{nfa_rw_api.c => nfa_rw_api.cc} (89%)
 rename src/nfa/rw/{nfa_rw_main.c => nfa_rw_main.cc} (89%)
 rename src/nfa/sys/{nfa_sys_cback.c => nfa_sys_cback.cc} (95%)
 rename src/nfa/sys/{nfa_sys_cfg.c => nfa_sys_cfg.cc} (94%)
 rename src/nfa/sys/{nfa_sys_main.c => nfa_sys_main.cc} (90%)
 mode change 100644 => 100755
 rename src/nfa/sys/{nfa_sys_ptim.c => nfa_sys_ptim.cc} (89%)
 rename src/nfc/{int => include}/ce_int.h (96%)
 mode change 100644 => 100755 src/nfc/include/llcp_api.h
 mode change 100644 => 100755 src/nfc/include/llcp_defs.h
 rename src/nfc/{int => include}/llcp_int.h (96%)
 mode change 100644 => 100755 src/nfc/include/nci_hmsgs.h
 mode change 100644 => 100755 src/nfc/include/nfc_api.h
 rename src/nfc/{int => include}/nfc_int.h (96%)
 create mode 100755 src/nfc/include/nfc_vs.h
 rename src/nfc/{int => include}/rw_int.h (97%)
 rename src/nfc/{int => include}/tags_int.h (94%)
 rename src/nfc/llcp/{llcp_api.c => llcp_api.cc} (87%)
 rename src/nfc/llcp/{llcp_dlc.c => llcp_dlc.cc} (89%)
 rename src/nfc/llcp/{llcp_link.c => llcp_link.cc} (91%)
 rename src/nfc/llcp/{llcp_main.c => llcp_main.cc} (85%)
 rename src/nfc/llcp/{llcp_sdp.c => llcp_sdp.cc} (85%)
 rename src/nfc/llcp/{llcp_util.c => llcp_util.cc} (87%)
 rename src/nfc/nci/{nci_hmsgs.c => nci_hmsgs.cc} (93%)
 mode change 100644 => 100755
 rename src/nfc/nci/{nci_hrcv.c => nci_hrcv.cc} (76%)
 mode change 100644 => 100755
 rename src/nfc/ndef/{ndef_utils.c => ndef_utils.cc} (90%)
 rename src/nfc/nfc/{nfc_ee.c => nfc_ee.cc} (92%)
 mode change 100644 => 100755
 rename src/nfc/nfc/{nfc_main.c => nfc_main.cc} (86%)
 mode change 100644 => 100755
 rename src/nfc/nfc/{nfc_ncif.c => nfc_ncif.cc} (78%)
 mode change 100644 => 100755
 rename src/nfc/nfc/{nfc_task.c => nfc_task.cc} (92%)
 mode change 100644 => 100755
 rename src/nfc/nfc/{nfc_test.c => nfc_test.cc} (100%)
 rename src/nfc/nfc/{nfc_utils.c => nfc_utils.cc} (93%)
 rename src/nfc/nfc/{nfc_vs.c => nfc_vs.cc} (88%)
 rename src/nfc/tags/{ce_main.c => ce_main.cc} (81%)
 rename src/nfc/tags/{ce_t3t.c => ce_t3t.cc} (90%)
 rename src/nfc/tags/{ce_t4t.c => ce_t4t.cc} (80%)
 mode change 100644 => 100755
 rename src/nfc/tags/{rw_i93.c => rw_i93.cc} (85%)
 mode change 100644 => 100755
 rename src/nfc/tags/{rw_main.c => rw_main.cc} (87%)
 rename src/nfc/tags/{rw_t1t.c => rw_t1t.cc} (86%)
 rename src/nfc/tags/{rw_t1t_ndef.c => rw_t1t_ndef.cc} (96%)
 rename src/nfc/tags/{rw_t2t.c => rw_t2t.cc} (89%)
 mode change 100644 => 100755
 rename src/nfc/tags/{rw_t2t_ndef.c => rw_t2t_ndef.cc} (97%)
 mode change 100644 => 100755
 rename src/nfc/tags/{rw_t3t.c => rw_t3t.cc} (92%)
 mode change 100644 => 100755
 rename src/nfc/tags/{rw_t4t.c => rw_t4t.cc} (89%)
 mode change 100644 => 100755
 rename src/nfc/tags/{tags_int.c => tags_int.cc} (97%)
 delete mode 100644 src/static-lib-adapt/ProtoDispBluetoothHci.c
 delete mode 100644 src/udrv/include/upio.h
 create mode 100755 utils/Android.bp
 create mode 100755 utils/config.cc
 create mode 100755 utils/include/config.h
 create mode 100644 utils/include/ringbuffer.h
 create mode 100644 utils/ringbuffer.cc
 create mode 100755 utils/test/config_test.cc
 create mode 100644 utils/test/ringbuffer_test.cc

diff --git a/Android.bp b/Android.bp
new file mode 100644
index 0000000..9679a81
--- /dev/null
+++ b/Android.bp
@@ -0,0 +1 @@
+subdirs = ["src", "utils"]
diff --git a/Android.mk b/Android.mk
deleted file mode 100644
index 3a56340..0000000
--- a/Android.mk
+++ /dev/null
@@ -1,140 +0,0 @@
-ifeq ($(strip $(TARGET_USES_NQ_NFC)),true)
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-NFA := src/nfa
-NFC := src/nfc
-HAL := src/hal
-UDRV := src/udrv
-
-D_CFLAGS := -DANDROID -DBUILDCFG=1 \
-    -Wno-deprecated-register \
-    -Wno-unused-parameter \
-
-#Enable NXP Specific
-D_CFLAGS += -DNXP_EXTNS=TRUE
-D_CFLAGS += -DNFC_NXP_STAT_DUAL_UICC_EXT_SWITCH=FALSE
-D_CFLAGS += -DNFC_NXP_AID_MAX_SIZE_DYN=TRUE
-
-#Enable HCE-F specific
-D_CFLAGS += -DNXP_NFCC_HCE_F=TRUE
-
-#variables for NFC_NXP_CHIP_TYPE
-PN547C2 := 1
-PN548C2 := 2
-PN551   := 3
-PN553   := 4
-PN557   := 5
-
-ifeq ($(PN547C2),1)
-D_CFLAGS += -DPN547C2=1
-endif
-ifeq ($(PN548C2),2)
-D_CFLAGS += -DPN548C2=2
-endif
-ifeq ($(PN551),3)
-D_CFLAGS += -DPN551=3
-endif
-ifeq ($(PN553),4)
-D_CFLAGS += -DPN553=4
-endif
-ifeq ($(PN557),5)
-D_CFLAGS += -DPN557=5
-endif
-
-#### Select the JCOP OS Version ####
-JCOP_VER_3_1 := 1
-JCOP_VER_3_2 := 2
-JCOP_VER_3_3 := 3
-JCOP_VER_4_0 := 4
-
-LOCAL_CFLAGS += -DJCOP_VER_3_1=$(JCOP_VER_3_1)
-LOCAL_CFLAGS += -DJCOP_VER_3_2=$(JCOP_VER_3_2)
-LOCAL_CFLAGS += -DJCOP_VER_3_3=$(JCOP_VER_3_3)
-LOCAL_CFLAGS += -DJCOP_VER_4_0=$(JCOP_VER_4_0)
-
-NFC_NXP_ESE:= TRUE
-ifeq ($(NFC_NXP_ESE),TRUE)
-LOCAL_CFLAGS += -DNFC_NXP_ESE=TRUE
-LOCAL_CFLAGS += -DNFC_NXP_ESE_VER=$(JCOP_VER_4_0)
-else
-LOCAL_CFLAGS += -DNFC_NXP_ESE=FALSE
-endif
-
-ifeq ($(call is-board-platform-in-list,msm8909w msm8916 msm8994 msm8909 msm8996 msm8992 msm8952 msm8937 msm8953 msm8998),true)
-D_CFLAGS += -DNQ_NFC_DUAL_UICC=FALSE
-else
-D_CFLAGS += -DNQ_NFC_DUAL_UICC=TRUE
-endif
-
-#### Select the CHIP ####
-ifeq ($(strip $(NQ3XX_PRESENT)),true)
-NXP_CHIP_TYPE := $(PN557)
-else
-NXP_CHIP_TYPE := $(PN548C2)
-endif
-
-ifeq ($(NXP_CHIP_TYPE),$(PN547C2))
-D_CFLAGS += -DNFC_NXP_CHIP_TYPE=PN547C2
-else ifeq ($(NXP_CHIP_TYPE),$(PN548C2))
-D_CFLAGS += -DNFC_NXP_CHIP_TYPE=PN548C2
-else ifeq ($(NXP_CHIP_TYPE),$(PN551))
-D_CFLAGS += -DNFC_NXP_CHIP_TYPE=PN551
-else ifeq ($(NXP_CHIP_TYPE),$(PN553))
-D_CFLAGS += -DNFC_NXP_CHIP_TYPE=PN553
-else ifeq ($(NXP_CHIP_TYPE),$(PN557))
-D_CFLAGS += -DNFC_NXP_CHIP_TYPE=PN557
-endif
-
-#Gemalto SE support
-D_CFLAGS += -DGEMALTO_SE_SUPPORT
-D_CFLAGS += -DNXP_UICC_ENABLE
-ifeq ($(NXP_CHIP_TYPE),$(PN553))
-D_CFLAGS += -DJCOP_WA_ENABLE=FALSE
-else
-D_CFLAGS += -DJCOP_WA_ENABLE=TRUE
-endif
-
-#Routing Entries optimization
-D_CFLAGS += -DNFC_NXP_LISTEN_ROUTE_TBL_OPTIMIZATION=TRUE
-######################################
-# Build shared library system/lib/libnfc-nci.so for stack code.
-
-LOCAL_ARM_MODE := arm
-ifeq (true,$(TARGET_IS_64_BIT))
-LOCAL_MULTILIB := 64
-else
-LOCAL_MULTILIB := 32
-endif
-LOCAL_MODULE := libnqnfc-nci
-LOCAL_MODULE_TAGS := optional
-LOCAL_MODULE_OWNER := nxp
-LOCAL_SHARED_LIBRARIES := libhardware_legacy libcutils liblog libdl libhardware
-LOCAL_CFLAGS += $(D_CFLAGS)
-LOCAL_C_INCLUDES := $(LOCAL_PATH)/src/include \
-    $(LOCAL_PATH)/src/gki/ulinux \
-    $(LOCAL_PATH)/src/gki/common \
-    $(LOCAL_PATH)/$(NFA)/include \
-    $(LOCAL_PATH)/$(NFA)/int \
-    $(LOCAL_PATH)/$(NFC)/include \
-    $(LOCAL_PATH)/$(NFC)/int \
-    $(LOCAL_PATH)/src/hal/include \
-    $(LOCAL_PATH)/src/hal/int \
-    $(LOCAL_PATH)/$(HALIMPL)/include \
-    system/libhwbinder/include
-
-# Treble configuration
-LOCAL_SHARED_LIBRARIES += libhidlbase libhidltransport libhwbinder libutils android.hardware.nfc@1.0 android.hardware.nfc@1.1 vendor.nxp.hardware.nfc@1.0
-LOCAL_SRC_FILES := \
-    $(call all-c-files-under, $(NFA)/ce $(NFA)/dm $(NFA)/ee) \
-    $(call all-c-files-under, $(NFA)/hci $(NFA)/int $(NFA)/p2p $(NFA)/rw $(NFA)/sys) \
-    $(call all-c-files-under, $(NFC)/int $(NFC)/llcp $(NFC)/nci $(NFC)/ndef $(NFC)/nfc $(NFC)/tags) \
-    $(call all-c-files-under, src/adaptation) \
-    $(call all-cpp-files-under, src/adaptation) \
-    $(call all-c-files-under, src/gki) \
-    src/nfca_version.c
-include $(BUILD_SHARED_LIBRARY)
-
-
-######################################
-include $(call all-makefiles-under,$(LOCAL_PATH))
-endif
diff --git a/OWNERS b/OWNERS
new file mode 100644
index 0000000..984e5f9
--- /dev/null
+++ b/OWNERS
@@ -0,0 +1,2 @@
+eisenbach@google.com
+kandoiruchi@google.com
diff --git a/README.md b/README.md
index 722f299..e7f9e34 100644
--- a/README.md
+++ b/README.md
@@ -43,3 +43,16 @@
 | android-o-preview2                     |  8.0.13_O (PN553/PN557) |  NFC_NCIHALx_AR18C0.8.0.13_O_OpnSrc |
 | android-8.0.0_r4               |  8.1.0_O (PN553) |  NFC_NCIHALx_AR00C0.8.1.0_O_OpnSrc |
 | android-8.0.0_r4               |  8.2.0_O (PN557) |  NFC_NCIHALx_AR18C0.8.2.0_O_OpnSrc |
+| android-8.0.0_r4               |  8.2.3_O (PN557) |  NFC_NCIHALx_AR18C0.8.2.3_O_OpnSrc |
+| android-8.0.0_r4               |  8.3.0_O (PN548C2/PN551/PN553) |  NFC_NCIHALx_AR0054.8.3.0_O_OpnSrc |
+| android-8.0.0_r4               |  8.3.0_O (PN548C2/PN551) | NFC_NCIHALx_AR003C.8.3.0_O_OpnSrc  |
+| android-8.0.0_r4/android-8.1.0_r7              |  8.4.0_O (PN548C2/PN551/PN553/PN557) |  NFC_NCIHALx_AR00C0.8.4.0_OpnSrc |
+
+####Supported Versions on "br_android_ncihalx_row_p" Branch
+
+| Android Version        | NXP Release          | NXP Tag  |
+| :-------------: |:-------------:| :-----:|
+| android-p-preview 2               |  9.0.D (PN553) |  NFC_NCIHALx_AR00C0.9.0.D_OpnSrc |
+| android-9.0.0_r3              |  9.1.0 (PN557) |  NFC_NCIHALx_AR0800.9.1.0_OpnSrc |
+| android-9.0.0_r3              |  9.2.0 (PN81T/PN557) |  NFC_NCIHALx_AR1800.9.2.0_OpnSrc |
+| android-9.0.0_r3              |  9.3.0 (PN553) |  NFC_NCIHALx_AR0040.9.3.0_OpnSrc |
diff --git a/p61-jcop-kit/README.md b/p61-jcop-kit/README.md
index b64196d..e90ce92 100644
--- a/p61-jcop-kit/README.md
+++ b/p61-jcop-kit/README.md
@@ -26,3 +26,25 @@
 | android-o-preview2                     |  8.0.13_O (PN553/PN557) |  SEAccessKit_AR8.0.13_OpnSrc |
 | android-8.0.0_r4               |  8.1.0_O (PN553) |  SEAccessKit_AR8.1.0_OpnSrc |
 | android-8.0.0_r4               |  8.2.0_O (PN557) |  SEAccessKit_AR8.2.0_OpnSrc |
+| android-8.0.0_r4               |  8.2.3_O (PN557) |  SEAccessKit_AR8.2.3_OpnSrc |
+| android-8.0.0_r4               |  8.3.0_O (PN548C2/PN551/PN553) |  SEAccessKit_AR8.3.0_OpnSrc |
+| android-8.0.0_r4/android-8.1.0_r7            |  8.4.0_O (PN548C2/PN551/PN553/PN557) |  SEAccessKit_AR8.4.0_OpnSrc |
+
+####Supported Versions on "br_android_ncihalx_row_p" Branch
+
+| Android Version        | NXP Release          | NXP Tag  |
+| :-------------: |:-------------:| :-----:|
+| android-p-preview 2               |  9.0.D (PN553) |  NFC_NCIHALx_AR00C0.9.0.D_OpnSrc |
+| android-9.0.0_r3              |  9.1.0 (PN557) |  NFC_NCIHALx_AR0800.9.1.0_OpnSrc |
+| android-9.0.0_r3              |  9.2.0 (PN81T/PN557) |  NFC_NCIHALx_AR1800.9.2.0_OpnSrc |
+
+####Supported Android Versions on "br_android_ncihalx_p" Branch
+
+| Android Version        | NXP Release          | NXP Tag  |
+| :-------------: |:-------------:| :-----:|
+| aosp-master               |  9.00.02 (SN100x) |  NFC_NCIHALx_AR2000.09.00.02_OpnSrc |
+| aosp-master               |  9.00.03 (SN100x) |  NFC_NCIHALx_AR2000.09.00.03_OpnSrc |
+| android-p-preview 2               |  9.00.06 (SN100x) |  NFC_NCIHALx_AR2000.09.00.06_OpnSrc |
+| android-p-preview 2               |  9.00.07 (SN100x) |  NFC_NCIHALx_AR2000.09.00.07_OpnSrc |
+| android-p-preview 2               |  9.00.08 (SN100x) |  NFC_NCIHALx_AR2000.09.00.08_OpnSrc |
+| android-p-preview 2               |  9.00.0A (SN100x) |  NFC_NCIHALx_AR2000.09.00.0A_OpnSrc |
diff --git a/run_unit_tests.sh b/run_unit_tests.sh
new file mode 100644
index 0000000..c2c9904
--- /dev/null
+++ b/run_unit_tests.sh
@@ -0,0 +1,125 @@
+#!/bin/sh
+
+known_tests=(
+  nfc_test_utils
+)
+
+known_remote_tests=(
+)
+
+
+usage() {
+  binary="$(basename "$0")"
+  echo "Usage: ${binary} --help"
+  echo "       ${binary} [-i <iterations>] [-s <specific device>] [--all] [<test name>[.<filter>] ...] [--<arg> ...]"
+  echo
+  echo "Unknown long arguments are passed to the test."
+  echo
+  echo "Known test names:"
+
+  for name in "${known_tests[@]}"
+  do
+    echo "    ${name}"
+  done
+
+  echo
+  echo "Known tests that need a remote device:"
+  for name in "${known_remote_tests[@]}"
+  do
+    echo "    ${name}"
+  done
+}
+
+iterations=1
+device=
+tests=()
+test_args=()
+while [ $# -gt 0 ]
+do
+  case "$1" in
+    -h|--help)
+      usage
+      exit 0
+      ;;
+    -i)
+      shift
+      if [ $# -eq 0 ]; then
+        echo "error: number of iterations expected" 1>&2
+        usage
+        exit 2
+      fi
+      iterations=$(( $1 ))
+      shift
+      ;;
+    -s)
+      shift
+      if [ $# -eq 0 ]; then
+        echo "error: no device specified" 1>&2
+        usage
+        exit 2
+      fi
+      device="$1"
+      shift
+      ;;
+    --all)
+      tests+=( "${known_tests[@]}" )
+      shift
+      ;;
+    --*)
+      test_args+=( "$1" )
+      shift
+      ;;
+    *)
+      tests+=( "$1" )
+      shift
+      ;;
+  esac
+done
+
+if [ "${#tests[@]}" -eq 0 ]; then
+  tests+=( "${known_tests[@]}" )
+fi
+
+adb=( "adb" )
+if [ -n "${device}" ]; then
+  adb+=( "-s" "${device}" )
+fi
+
+failed_tests=()
+for spec in "${tests[@]}"
+do
+  name="${spec%%.*}"
+  binary="/data/nativetest/${name}/${name}"
+
+  push_command=( "${adb[@]}" push {"${ANDROID_PRODUCT_OUT}",}"${binary}" )
+  test_command=( "${adb[@]}" shell "${binary}" )
+  if [ "${name}" != "${spec}" ]; then
+    filter="${spec#*.}"
+    test_command+=( "--gtest_filter=${filter}" )
+  fi
+  test_command+=( "${test_args[@]}" )
+
+  echo "--- ${name} ---"
+  echo "pushing..."
+  "${push_command[@]}"
+  echo "running..."
+  failed_count=0
+  for i in $(seq 1 ${iterations})
+  do
+    "${test_command[@]}" || failed_count=$(( $failed_count + 1 ))
+  done
+
+  if [ $failed_count != 0 ]; then
+    failed_tests+=( "${name} ${failed_count}/${iterations}" )
+  fi
+done
+
+if [ "${#failed_tests[@]}" -ne 0 ]; then
+  for failed_test in "${failed_tests[@]}"
+  do
+    echo "!!! FAILED TEST: ${failed_test} !!!"
+  done
+  exit 1
+fi
+
+exit 0
diff --git a/src/Android.bp b/src/Android.bp
new file mode 100755
index 0000000..d402b30
--- /dev/null
+++ b/src/Android.bp
@@ -0,0 +1,75 @@
+cc_library_shared {
+    arch: {
+        arm: {
+            instruction_set: "arm",
+        },
+    },
+    name: "libnqnfc-nci",
+    shared_libs: [
+        "libcutils",
+        "liblog",
+        "libdl",
+        "libhardware",
+        "libmetricslogger",
+        "libpower",
+        "libchrome",
+        "libbase",
+        "libz",
+
+        // Treble configuration
+        "libhidlbase",
+        "libhidltransport",
+        "libhwbinder",
+        "libutils",
+        "android.hardware.nfc@1.0",
+        "android.hardware.nfc@1.1",
+        "vendor.nxp.hardware.nfc@1.0",
+    ],
+    static_libs: [
+        "libnqnfcutils",
+    ],
+    cflags: [
+        "-DBUILDCFG=1",
+        "-Wall",
+        "-Werror",
+        "-DNXP_EXTNS=TRUE",
+        "-DNFC_NXP_AID_MAX_SIZE_DYN=TRUE",
+        "-DNXP_NFCC_HCE_F=TRUE",
+        "-DNFC_NXP_LISTEN_ROUTE_TBL_OPTIMIZATION=TRUE",
+        "-DANDROID"
+    ],
+    local_include_dirs: [
+        "include",
+        "gki/ulinux",
+        "gki/common",
+        "nfa/include",
+        "nfc/include",
+    ],
+    include_dirs: [
+        "vendor/nxp/opensource/halimpl/extns/impl/",
+    ],
+    srcs: [
+        "nfa/ce/*.cc",
+        "nfa/dm/*.cc",
+        "nfa/ee/*.cc",
+        "nfa/hci/*.cc",
+        "nfa/p2p/*.cc",
+        "nfa/rw/*.cc",
+        "nfa/sys/*.cc",
+        "nfc/llcp/*.cc",
+        "nfc/nci/*.cc",
+        "nfc/ndef/*.cc",
+        "nfc/nfc/*.cc",
+        "nfc/tags/*.cc",
+        "adaptation/*.cc",
+        "gki/common/*.cc",
+        "gki/ulinux/*.cc",
+    ],
+    product_variables: {
+        debuggable: {
+            cflags: [
+                "-DDCHECK_ALWAYS_ON"
+            ],
+        },
+    },
+}
diff --git a/src/adaptation/CrcChecksum.cpp b/src/adaptation/CrcChecksum.cc
old mode 100644
new mode 100755
similarity index 91%
rename from src/adaptation/CrcChecksum.cpp
rename to src/adaptation/CrcChecksum.cc
index 774d1d6..eb82b31
--- a/src/adaptation/CrcChecksum.cpp
+++ b/src/adaptation/CrcChecksum.cc
@@ -35,16 +35,15 @@
  *
  ******************************************************************************/
 
-#include "_OverrideLog.h"
 #include "CrcChecksum.h"
-#include <sys/types.h>
-#include <sys/stat.h>
 #include <fcntl.h>
-#include <errno.h>
 #include <string>
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
 
-#undef LOG_TAG
-#define LOG_TAG "NfcNciHal"
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
 
 static const unsigned short crctab[256] = {
     0x0000, 0xc0c1, 0xc181, 0x0140, 0xc301, 0x03c0, 0x0280, 0xc241, 0xc601,
@@ -88,9 +87,9 @@ static const unsigned short crctab[256] = {
 **
 *******************************************************************************/
 unsigned short crcChecksumCompute(const unsigned char* buffer, int bufferLen) {
-  register unsigned short crc = 0;
-  const register unsigned char* cp = buffer;
-  register int cnt = bufferLen;
+  unsigned short crc = 0;
+  const unsigned char* cp = buffer;
+  int cnt = bufferLen;
 
   while (cnt--) {
     crc = ((crc >> 8) & 0xff) ^ crctab[(crc & 0xff) ^ *cp++];
@@ -109,7 +108,7 @@ unsigned short crcChecksumCompute(const unsigned char* buffer, int bufferLen) {
 **
 *******************************************************************************/
 bool crcChecksumVerifyIntegrity(const char* filename) {
-  ALOGD("%s: filename=%s", __func__, filename);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: filename=%s", __func__, filename);
   bool isGood = false;
   int fileStream = open(filename, O_RDONLY);
   if (fileStream >= 0) {
@@ -126,14 +125,14 @@ bool crcChecksumVerifyIntegrity(const char* filename) {
     }
     close(fileStream);
     if ((actualReadCrc == sizeof(checksum)) && (data.size() > 0)) {
-      ALOGD("%s: data size=%zu", __func__, data.size());
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: data size=%zu", __func__, data.size());
       if (checksum ==
           crcChecksumCompute((const unsigned char*)data.data(), data.size()))
         isGood = true;
       else
-        ALOGE("%s: checksum mismatch", __func__);
+        LOG(ERROR) << StringPrintf("%s: checksum mismatch", __func__);
     } else
-      ALOGE("%s: invalid length", __func__);
+      LOG(ERROR) << StringPrintf("%s: invalid length", __func__);
   } else
     isGood = true;  // assume file does not exist
   return isGood;
diff --git a/src/adaptation/NfcAdaptation.cpp b/src/adaptation/NfcAdaptation.cc
old mode 100644
new mode 100755
similarity index 58%
rename from src/adaptation/NfcAdaptation.cpp
rename to src/adaptation/NfcAdaptation.cc
index a76c67c..6a9da65
--- a/src/adaptation/NfcAdaptation.cpp
+++ b/src/adaptation/NfcAdaptation.cc
@@ -3,7 +3,7 @@
  *  Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.
  *  Not a Contribution.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *  The original Work has been changed by NXP Semiconductors.
  *
  *  Copyright (C) 1999-2012 Broadcom Corporation
@@ -21,46 +21,52 @@
  *  limitations under the License.
  *
  ******************************************************************************/
-#include "_OverrideLog.h"
-
+#include "NfcAdaptation.h"
+#include <android-base/stringprintf.h>
+#include <android/hardware/nfc/1.0/types.h>
 #include <android/hardware/nfc/1.1/INfc.h>
 #include <vendor/nxp/hardware/nfc/1.0/INqNfc.h>
-#include <android/hardware/nfc/1.0/INfcClientCallback.h>
-#include <android/hardware/nfc/1.0/types.h>
+#include <base/command_line.h>
+#include <base/logging.h>
+#include <cutils/properties.h>
+#include <hidl/LegacySupport.h>
 #include <hwbinder/ProcessState.h>
-#include <pthread.h>
-#include "NfcAdaptation.h"
-extern "C"
-{
-    #include "gki.h"
-    #include "nfa_api.h"
-    #include "nfc_int.h"
-    #include "nfc_target.h"
-    #include "vendor_cfg.h"
-}
-#include "config.h"
-#include "android_logmsg.h"
-
-#undef LOG_TAG
-#define LOG_TAG "NfcAdaptation"
+#include <vector>
+#include "debug_nfcsnoop.h"
+#ifdef ENABLE_ESE_CLIENT
+#include "hal_nxpese.h"
+#endif
+#include "nfa_api.h"
+#include "nfa_rw_api.h"
+#include "nfc_config.h"
+#include "nfc_int.h"
+#include "nfc_target.h"
 
 using android::OK;
 using android::sp;
 using android::status_t;
 
+using android::base::StringPrintf;
 using android::hardware::ProcessState;
 using android::hardware::Return;
 using android::hardware::Void;
 using android::hardware::nfc::V1_0::INfc;
-using vendor::nxp::hardware::nfc::V1_0::INqNfc;
+using android::hardware::nfc::V1_1::PresenceCheckAlgorithm;
 using INfcV1_1 = android::hardware::nfc::V1_1::INfc;
+using NfcVendorConfig = android::hardware::nfc::V1_1::NfcConfig;
 using android::hardware::nfc::V1_1::INfcClientCallback;
 using android::hardware::hidl_vec;
+using vendor::nxp::hardware::nfc::V1_0::INqNfc;
+using android::hardware::configureRpcThreadpool;
+using ::android::hardware::hidl_death_recipient;
+using ::android::wp;
+using ::android::hidl::base::V1_0::IBase;
+
+extern bool nfc_debug_enabled;
 
-extern "C" void GKI_shutdown();
-extern void resetConfig();
-extern "C" void verify_stack_non_volatile_store();
-extern "C" void delete_stack_non_volatile_store(bool forceDelete);
+extern void GKI_shutdown();
+extern void verify_stack_non_volatile_store();
+extern void delete_stack_non_volatile_store(bool forceDelete);
 
 NfcAdaptation* NfcAdaptation::mpInstance = NULL;
 ThreadMutex NfcAdaptation::sLock;
@@ -84,25 +90,40 @@ static uint8_t isSignaled = SIGNAL_NONE;
 static uint8_t evt_status;
 #endif
 
-uint32_t ScrProtocolTraceFlag = SCR_PROTO_TRACE_ALL;  // 0x017F00;
-uint8_t appl_trace_level = 0xff;
-#if (NXP_EXTNS == TRUE)
+bool nfc_debug_enabled = false;
+std::string nfc_storage_path;
 uint8_t appl_dta_mode_flag = 0x00;
-#endif
-char bcm_nfc_location[120];
 
-static uint8_t nfa_dm_cfg[sizeof(tNFA_DM_CFG)];
-static uint8_t nfa_proprietary_cfg[sizeof(tNFA_PROPRIETARY_CFG)];
-extern tNFA_DM_CFG* p_nfa_dm_cfg;
-extern tNFA_PROPRIETARY_CFG* p_nfa_proprietary_cfg;
+extern tNFA_DM_CFG nfa_dm_cfg;
+extern tNFA_PROPRIETARY_CFG nfa_proprietary_cfg;
+extern tNFA_HCI_CFG nfa_hci_cfg;
 extern uint8_t nfa_ee_max_ee_cfg;
-extern const uint8_t nfca_version_string[];
-extern const uint8_t nfa_version_string[];
-static uint8_t deviceHostWhiteList[NFA_HCI_MAX_HOST_IN_NETWORK];
-static tNFA_HCI_CFG jni_nfa_hci_cfg;
-extern tNFA_HCI_CFG* p_nfa_hci_cfg;
 extern bool nfa_poll_bail_out_mode;
 
+// Whitelist for hosts allowed to create a pipe
+// See ADM_CREATE_PIPE command in the ETSI test specification
+// ETSI TS 102 622, section 6.1.3.1
+static std::vector<uint8_t> host_whitelist;
+
+namespace {
+void initializeGlobalDebugEnabledFlag() {
+  nfc_debug_enabled =
+      (NfcConfig::getUnsigned(NAME_NFC_DEBUG_ENABLED, 0) != 0) ? true : false;
+
+  char valueStr[PROPERTY_VALUE_MAX] = {0};
+  int len = property_get("nfc.debug_enabled", valueStr, "");
+  if (len > 0) {
+    // let Android property override .conf variable
+    unsigned debug_enabled = 0;
+    sscanf(valueStr, "%u", &debug_enabled);
+    nfc_debug_enabled = (debug_enabled == 0) ? false : true;
+  }
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: level=%u", __func__, nfc_debug_enabled);
+}
+}  // namespace
+
 class NfcClientCallback : public INfcClientCallback {
  public:
   NfcClientCallback(tHAL_NFC_CBACK* eventCallback,
@@ -135,6 +156,23 @@ class NfcClientCallback : public INfcClientCallback {
   tHAL_NFC_DATA_CBACK* mDataCallback;
 };
 
+class NfcDeathRecipient : public hidl_death_recipient {
+ public:
+  android::sp<android::hardware::nfc::V1_0::INfc> mNfcDeathHal;
+  NfcDeathRecipient(android::sp<android::hardware::nfc::V1_0::INfc> &mHal) {
+    mNfcDeathHal = mHal;
+  }
+
+  virtual void serviceDied(
+      uint64_t /* cookie */,
+      const wp<::android::hidl::base::V1_0::IBase>& /* who */) {
+    ALOGE("NfcDeathRecipient::serviceDied - Nfc service died");
+    mNfcDeathHal->unlinkToDeath(this);
+    mNfcDeathHal = NULL;
+    abort();
+  }
+};
+
 /*******************************************************************************
 **
 ** Function:    NfcAdaptation::NfcAdaptation()
@@ -145,6 +183,7 @@ class NfcClientCallback : public INfcClientCallback {
 **
 *******************************************************************************/
 NfcAdaptation::NfcAdaptation() {
+  mNfcHalDeathRecipient = new NfcDeathRecipient(mHal);
   memset(&mHalEntryFuncs, 0, sizeof(mHalEntryFuncs));
 }
 
@@ -157,7 +196,7 @@ NfcAdaptation::NfcAdaptation() {
 ** Returns:     none
 **
 *******************************************************************************/
-NfcAdaptation::~NfcAdaptation() { mpInstance = NULL; }
+NfcAdaptation::~NfcAdaptation() {}
 
 /*******************************************************************************
 **
@@ -178,6 +217,181 @@ NfcAdaptation& NfcAdaptation::GetInstance() {
   return *mpInstance;
 }
 
+void NfcAdaptation::GetNxpConfigs(
+    std::map<std::string, ConfigValue>& configMap) {
+  nfc_nci_IoctlInOutData_t inpOutData;
+  int ret = HalIoctl(HAL_NFC_GET_NXP_CONFIG, &inpOutData);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("HAL_NFC_GET_NXP_CONFIG ioctl return value = %d", ret);
+  configMap.emplace(
+      NAME_NAME_NXP_ESE_LISTEN_TECH_MASK,
+      ConfigValue(inpOutData.out.data.nxpConfigs.ese_listen_tech_mask));
+  configMap.emplace(
+      NAME_NXP_DEFAULT_NFCEE_DISC_TIMEOUT,
+      ConfigValue(inpOutData.out.data.nxpConfigs.default_nfcee_disc_timeout));
+  configMap.emplace(
+      NAME_NXP_DEFAULT_NFCEE_TIMEOUT,
+      ConfigValue(inpOutData.out.data.nxpConfigs.default_nfcee_timeout));
+  configMap.emplace(
+      NAME_NXP_ESE_WIRED_PRT_MASK,
+      ConfigValue(inpOutData.out.data.nxpConfigs.ese_wired_prt_mask));
+  configMap.emplace(
+      NAME_NXP_UICC_WIRED_PRT_MASK,
+      ConfigValue(inpOutData.out.data.nxpConfigs.uicc_wired_prt_mask));
+  configMap.emplace(
+      NAME_NXP_WIRED_MODE_RF_FIELD_ENABLE,
+      ConfigValue(inpOutData.out.data.nxpConfigs.wired_mode_rf_field_enable));
+  configMap.emplace(
+      NAME_AID_BLOCK_ROUTE,
+      ConfigValue(inpOutData.out.data.nxpConfigs.aid_block_route));
+
+  configMap.emplace(
+      NAME_NXP_ESE_POWER_DH_CONTROL,
+      ConfigValue(inpOutData.out.data.nxpConfigs.esePowerDhControl));
+  configMap.emplace(NAME_NXP_SWP_RD_TAG_OP_TIMEOUT,
+                    ConfigValue(inpOutData.out.data.nxpConfigs.tagOpTimeout));
+  configMap.emplace(
+      NAME_NXP_LOADER_SERICE_VERSION,
+      ConfigValue(inpOutData.out.data.nxpConfigs.loaderServiceVersion));
+  configMap.emplace(
+      NAME_NXP_DEFAULT_NFCEE_DISC_TIMEOUT,
+      ConfigValue(inpOutData.out.data.nxpConfigs.defaultNfceeDiscTimeout));
+  configMap.emplace(NAME_NXP_DUAL_UICC_ENABLE,
+                    ConfigValue(inpOutData.out.data.nxpConfigs.dualUiccEnable));
+  configMap.emplace(
+      NAME_NXP_CE_ROUTE_STRICT_DISABLE,
+      ConfigValue(inpOutData.out.data.nxpConfigs.ceRouteStrictDisable));
+  configMap.emplace(
+      NAME_OS_DOWNLOAD_TIMEOUT_VALUE,
+      ConfigValue(inpOutData.out.data.nxpConfigs.osDownloadTimeoutValue));
+  configMap.emplace(NAME_NXP_DEFAULT_SE,
+                    ConfigValue(inpOutData.out.data.nxpConfigs.nxpDefaultSe));
+  configMap.emplace(
+      NAME_DEFAULT_AID_ROUTE,
+      ConfigValue(inpOutData.out.data.nxpConfigs.defaultAidRoute));
+  configMap.emplace(
+      NAME_DEFAULT_AID_PWR_STATE,
+      ConfigValue(inpOutData.out.data.nxpConfigs.defaultAidPwrState));
+  configMap.emplace(
+      NAME_DEFAULT_ROUTE_PWR_STATE,
+      ConfigValue(inpOutData.out.data.nxpConfigs.defaultRoutePwrState));
+  configMap.emplace(
+      NAME_DEFAULT_OFFHOST_PWR_STATE,
+      ConfigValue(inpOutData.out.data.nxpConfigs.defaultOffHostPwrState));
+  configMap.emplace(
+      NAME_NXP_JCOPDL_AT_BOOT_ENABLE,
+      ConfigValue(inpOutData.out.data.nxpConfigs.jcopDlAtBootEnable));
+  configMap.emplace(
+      NAME_NXP_DEFAULT_NFCEE_TIMEOUT,
+      ConfigValue(inpOutData.out.data.nxpConfigs.defaultNfceeTimeout));
+  configMap.emplace(NAME_NXP_NFC_CHIP,
+                    ConfigValue(inpOutData.out.data.nxpConfigs.nxpNfcChip));
+  configMap.emplace(
+      NAME_NXP_CORE_SCRN_OFF_AUTONOMOUS_ENABLE,
+      ConfigValue(inpOutData.out.data.nxpConfigs.coreScrnOffAutonomousEnable));
+  configMap.emplace(
+      NAME_NXP_P61_LS_DEFAULT_INTERFACE,
+      ConfigValue(inpOutData.out.data.nxpConfigs.p61LsDefaultInterface));
+  configMap.emplace(
+      NAME_NXP_P61_JCOP_DEFAULT_INTERFACE,
+      ConfigValue(inpOutData.out.data.nxpConfigs.p61JcopDefaultInterface));
+  configMap.emplace(NAME_NXP_AGC_DEBUG_ENABLE,
+                    ConfigValue(inpOutData.out.data.nxpConfigs.agcDebugEnable));
+  configMap.emplace(
+      NAME_DEFAULT_FELICA_CLT_PWR_STATE,
+      ConfigValue(inpOutData.out.data.nxpConfigs.felicaCltPowerState));
+  configMap.emplace(
+      NAME_NXP_HCEF_CMD_RSP_TIMEOUT_VALUE,
+      ConfigValue(inpOutData.out.data.nxpConfigs.cmdRspTimeoutValue));
+  configMap.emplace(
+      NAME_CHECK_DEFAULT_PROTO_SE_ID,
+      ConfigValue(inpOutData.out.data.nxpConfigs.checkDefaultProtoSeId));
+  configMap.emplace(
+      NAME_NXP_NFCC_PASSIVE_LISTEN_TIMEOUT,
+      ConfigValue(inpOutData.out.data.nxpConfigs.nfccPassiveListenTimeout));
+  configMap.emplace(
+      NAME_NXP_NFCC_STANDBY_TIMEOUT,
+      ConfigValue(inpOutData.out.data.nxpConfigs.nfccStandbyTimeout));
+  configMap.emplace(NAME_NXP_WM_MAX_WTX_COUNT,
+                    ConfigValue(inpOutData.out.data.nxpConfigs.wmMaxWtxCount));
+  configMap.emplace(
+      NAME_NXP_NFCC_RF_FIELD_EVENT_TIMEOUT,
+      ConfigValue(inpOutData.out.data.nxpConfigs.nfccRfFieldEventTimeout));
+  configMap.emplace(
+      NAME_NXP_ALLOW_WIRED_IN_MIFARE_DESFIRE_CLT,
+      ConfigValue(inpOutData.out.data.nxpConfigs.allowWiredInMifareDesfireClt));
+  configMap.emplace(
+      NAME_NXP_DWP_INTF_RESET_ENABLE,
+      ConfigValue(inpOutData.out.data.nxpConfigs.dwpIntfResetEnable));
+  configMap.emplace(
+      NAME_NXPLOG_HAL_LOGLEVEL,
+      ConfigValue(inpOutData.out.data.nxpConfigs.nxpLogHalLoglevel));
+  configMap.emplace(
+      NAME_NXPLOG_EXTNS_LOGLEVEL,
+      ConfigValue(inpOutData.out.data.nxpConfigs.nxpLogExtnsLogLevel));
+  configMap.emplace(
+      NAME_NXPLOG_TML_LOGLEVEL,
+      ConfigValue(inpOutData.out.data.nxpConfigs.nxpLogTmlLogLevel));
+  configMap.emplace(
+      NAME_NXPLOG_FWDNLD_LOGLEVEL,
+      ConfigValue(inpOutData.out.data.nxpConfigs.nxpLogFwDnldLogLevel));
+  configMap.emplace(
+      NAME_NXPLOG_NCIX_LOGLEVEL,
+      ConfigValue(inpOutData.out.data.nxpConfigs.nxpLogNcixLogLevel));
+  configMap.emplace(
+      NAME_NXPLOG_NCIR_LOGLEVEL,
+      ConfigValue(inpOutData.out.data.nxpConfigs.nxpLogNcirLogLevel));
+}
+
+void NfcAdaptation::GetVendorConfigs(
+    std::map<std::string, ConfigValue>& configMap) {
+  if (mHal_1_1) {
+    mHal_1_1->getConfig([&configMap](NfcVendorConfig config) {
+      std::vector<uint8_t> nfaPropCfg = {
+          config.nfaProprietaryCfg.protocol18092Active,
+          config.nfaProprietaryCfg.protocolBPrime,
+          config.nfaProprietaryCfg.protocolDual,
+          config.nfaProprietaryCfg.protocol15693,
+          config.nfaProprietaryCfg.protocolKovio,
+          config.nfaProprietaryCfg.protocolMifare,
+          config.nfaProprietaryCfg.discoveryPollKovio,
+          config.nfaProprietaryCfg.discoveryPollBPrime,
+          config.nfaProprietaryCfg.discoveryListenBPrime};
+      configMap.emplace(NAME_NFA_PROPRIETARY_CFG, ConfigValue(nfaPropCfg));
+      configMap.emplace(NAME_NFA_POLL_BAIL_OUT_MODE,
+                        ConfigValue(config.nfaPollBailOutMode ? 1 : 0));
+      configMap.emplace(NAME_DEFAULT_OFFHOST_ROUTE,
+                        ConfigValue(config.defaultOffHostRoute));
+      configMap.emplace(NAME_DEFAULT_ROUTE, ConfigValue(config.defaultRoute));
+      configMap.emplace(NAME_DEFAULT_NFCF_ROUTE,
+                        ConfigValue(config.defaultOffHostRouteFelica));
+      configMap.emplace(NAME_DEFAULT_SYS_CODE_ROUTE,
+                        ConfigValue(config.defaultSystemCodeRoute));
+      configMap.emplace(NAME_DEFAULT_SYS_CODE_PWR_STATE,
+                        ConfigValue(config.defaultSystemCodePowerState));
+      configMap.emplace(NAME_OFF_HOST_SIM_PIPE_ID,
+                        ConfigValue(config.offHostSIMPipeId));
+      configMap.emplace(NAME_OFF_HOST_ESE_PIPE_ID,
+                        ConfigValue(config.offHostESEPipeId));
+      configMap.emplace(NAME_ISO_DEP_MAX_TRANSCEIVE,
+                        ConfigValue(config.maxIsoDepTransceiveLength));
+      if (config.hostWhitelist.size() != 0) {
+        configMap.emplace(NAME_DEVICE_HOST_WHITE_LIST,
+                          ConfigValue(config.hostWhitelist));
+      }
+      /* For Backwards compatibility */
+      if (config.presenceCheckAlgorithm ==
+          PresenceCheckAlgorithm::ISO_DEP_NAK) {
+        configMap.emplace(NAME_PRESENCE_CHECK_ALGORITHM,
+                          ConfigValue((uint32_t)NFA_RW_PRES_CHK_ISO_DEP_NAK));
+      } else {
+        configMap.emplace(NAME_PRESENCE_CHECK_ALGORITHM,
+                          ConfigValue((uint32_t)config.presenceCheckAlgorithm));
+      }
+    });
+  }
+}
+
 /*******************************************************************************
 **
 ** Function:    NfcAdaptation::Initialize()
@@ -189,59 +403,79 @@ NfcAdaptation& NfcAdaptation::GetInstance() {
 *******************************************************************************/
 void NfcAdaptation::Initialize() {
   const char* func = "NfcAdaptation::Initialize";
-  ALOGD("%s: enter", func);
-  ALOGE("%s: ver=%s nfa=%s", func, nfca_version_string, nfa_version_string);
-  unsigned long num;
-
-  if (GetNumValue(NAME_USE_RAW_NCI_TRACE, &num, sizeof(num))) {
-    if (num == 1) {
-      // display protocol traces in raw format
-      ProtoDispAdapterUseRawOutput(true);
-      ALOGD("%s: logging protocol in raw format", func);
-    }
-  }
-  if (!GetStrValue(NAME_NFA_STORAGE, bcm_nfc_location,
-                   sizeof(bcm_nfc_location))) {
-    strlcpy(bcm_nfc_location, "/data/nfc", sizeof(bcm_nfc_location));
+  const char* argv[] = {"libnfc_nci"};
+  // Init log tag
+  base::CommandLine::Init(1, argv);
+
+  // Android already logs thread_id, proc_id, timestamp, so disable those.
+  logging::SetLogItems(false, false, false, false);
+  initializeGlobalDebugEnabledFlag();
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", func);
+
+  nfc_storage_path = NfcConfig::getString(NAME_NFA_STORAGE, "/data/nfc");
+
+  if (NfcConfig::hasKey(NAME_NFA_DM_CFG)) {
+    std::vector<uint8_t> dm_config = NfcConfig::getBytes(NAME_NFA_DM_CFG);
+    if (dm_config.size() > 0) nfa_dm_cfg.auto_detect_ndef = dm_config[0];
+    if (dm_config.size() > 1) nfa_dm_cfg.auto_read_ndef = dm_config[1];
+    if (dm_config.size() > 2) nfa_dm_cfg.auto_presence_check = dm_config[2];
+    if (dm_config.size() > 3) nfa_dm_cfg.presence_check_option = dm_config[3];
+    // NOTE: The timeout value is not configurable here because the endianess
+    // of a byte array is ambiguous and needlessly difficult to configure.
+    // If this value needs to be configgurable, a numeric config option should
+    // be used.
   }
 
-  initializeProtocolLogLevel();
-
-  if (GetStrValue(NAME_NFA_DM_CFG, (char*)nfa_dm_cfg, sizeof(nfa_dm_cfg)))
-    p_nfa_dm_cfg = (tNFA_DM_CFG*)((void*)&nfa_dm_cfg[0]);
+  if (NfcConfig::hasKey(NAME_NFA_MAX_EE_SUPPORTED)) {
+    nfa_ee_max_ee_cfg = NfcConfig::getUnsigned(NAME_NFA_MAX_EE_SUPPORTED);
+    DLOG_IF(INFO, nfc_debug_enabled)
+         << StringPrintf("%s: Overriding NFA_EE_MAX_EE_SUPPORTED to use %d",
+                         func, nfa_ee_max_ee_cfg);
+  }
 
-  if (GetNumValue(NAME_NFA_POLL_BAIL_OUT_MODE, &num, sizeof(num))) {
-    nfa_poll_bail_out_mode = num;
-    ALOGD("%s: Overriding NFA_POLL_BAIL_OUT_MODE to use %d", func,
+  if (NfcConfig::hasKey(NAME_NFA_POLL_BAIL_OUT_MODE)) {
+    nfa_poll_bail_out_mode =
+        NfcConfig::getUnsigned(NAME_NFA_POLL_BAIL_OUT_MODE);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Overriding NFA_POLL_BAIL_OUT_MODE to use %d", func,
           nfa_poll_bail_out_mode);
   }
 
-  if (GetStrValue(NAME_NFA_PROPRIETARY_CFG, (char*)nfa_proprietary_cfg,
-                  sizeof(tNFA_PROPRIETARY_CFG))) {
-    p_nfa_proprietary_cfg =
-        (tNFA_PROPRIETARY_CFG*)(void*)(&nfa_proprietary_cfg[0]);
+  if (NfcConfig::hasKey(NAME_NFA_PROPRIETARY_CFG)) {
+    std::vector<uint8_t> p_config =
+        NfcConfig::getBytes(NAME_NFA_PROPRIETARY_CFG);
+    if (p_config.size() > 0)
+      nfa_proprietary_cfg.pro_protocol_18092_active = p_config[0];
+    if (p_config.size() > 1)
+      nfa_proprietary_cfg.pro_protocol_b_prime = p_config[1];
+    if (p_config.size() > 2)
+      nfa_proprietary_cfg.pro_protocol_dual = p_config[2];
+    if (p_config.size() > 3)
+      nfa_proprietary_cfg.pro_protocol_15693 = p_config[3];
+    if (p_config.size() > 4)
+      nfa_proprietary_cfg.pro_protocol_kovio = p_config[4];
+    if (p_config.size() > 5) nfa_proprietary_cfg.pro_protocol_mfc = p_config[5];
+    if (p_config.size() > 6)
+      nfa_proprietary_cfg.pro_discovery_kovio_poll = p_config[6];
+    if (p_config.size() > 7)
+      nfa_proprietary_cfg.pro_discovery_b_prime_poll = p_config[7];
+    if (p_config.size() > 8)
+      nfa_proprietary_cfg.pro_discovery_b_prime_listen = p_config[8];
   }
-  // configure device host whitelist of HCI host ID's; see specification ETSI TS
-  // 102 622 V11.1.10
-  //(2012-10), section 6.1.3.1
-  num = GetStrValue(NAME_DEVICE_HOST_WHITE_LIST, (char*)deviceHostWhiteList,
-                    sizeof(deviceHostWhiteList));
-  if (num) {
-    memmove(&jni_nfa_hci_cfg, p_nfa_hci_cfg, sizeof(jni_nfa_hci_cfg));
-    jni_nfa_hci_cfg.num_whitelist_host =
-        (uint8_t)num;  // number of HCI host ID's in the whitelist
-    jni_nfa_hci_cfg.p_whitelist = deviceHostWhiteList;  // array of HCI host
-                                                        // ID's
-    p_nfa_hci_cfg = &jni_nfa_hci_cfg;
+  // Configure whitelist of HCI host ID's
+  // See specification: ETSI TS 102 622, section 6.1.3.1
+  if (NfcConfig::hasKey(NAME_DEVICE_HOST_WHITE_LIST)) {
+    host_whitelist = NfcConfig::getBytes(NAME_DEVICE_HOST_WHITE_LIST);
+    nfa_hci_cfg.num_whitelist_host = host_whitelist.size();
+    nfa_hci_cfg.p_whitelist = &host_whitelist[0];
   }
 
-  initializeGlobalAppLogLevel();
 
   verify_stack_non_volatile_store();
-  if (GetNumValue(NAME_PRESERVE_STORAGE, (char*)&num, sizeof(num)) &&
-      (num == 1))
-    ALOGD("%s: preserve stack NV store", __func__);
-  else {
+  if (NfcConfig::hasKey(NAME_PRESERVE_STORAGE) &&
+      NfcConfig::getUnsigned(NAME_PRESERVE_STORAGE) == 1) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: preserve stack NV store", __func__);
+  } else {
     delete_stack_non_volatile_store(false);
   }
 
@@ -256,7 +490,9 @@ void NfcAdaptation::Initialize() {
     mCondVar.wait();
   }
 
-  ALOGD("%s: exit", func);
+  debug_nfcsnoop_init();
+  configureRpcThreadpool(2, false);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", func);
 }
 #if (NXP_EXTNS == TRUE)
 /*******************************************************************************
@@ -270,7 +506,7 @@ void NfcAdaptation::Initialize() {
 *******************************************************************************/
 void NfcAdaptation::MinInitialize() {
   const char* func = "NfcAdaptation::MinInitialize";
-  ALOGD("%s: enter", func);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", func);
   GKI_init();
   GKI_enable();
   GKI_create_task((TASKPTR)NFCA_TASK, BTU_TASK, (int8_t*)"NFCA_TASK", 0, 0,
@@ -281,12 +517,25 @@ void NfcAdaptation::MinInitialize() {
                     (pthread_cond_t*)NULL, NULL);
     mCondVar.wait();
   }
-  mHalCallback = NULL;
-  memset(&mHalEntryFuncs, 0, sizeof(mHalEntryFuncs));
+
   InitializeHalDeviceContext();
-  ALOGD("%s: exit", func);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", func);
 }
 #endif
+
+
+void NfcAdaptation::FactoryReset() {
+  if (mHal_1_1 != nullptr) {
+    mHal_1_1->factoryReset();
+  }
+}
+
+void NfcAdaptation::DeviceShutdown() {
+  if (mHal_1_1 != nullptr) {
+    mHal_1_1->closeForPowerOffCase();
+  }
+}
+
 /*******************************************************************************
 **
 ** Function:    NfcAdaptation::Finalize()
@@ -300,26 +549,28 @@ void NfcAdaptation::Finalize() {
   const char* func = "NfcAdaptation::Finalize";
   AutoThreadMutex a(sLock);
 
-  ALOGD("%s: enter", func);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", func);
   GKI_shutdown();
 
-  resetConfig();
+  NfcConfig::clear();
 
-  ALOGD("%s: exit", func);
-  delete this;
-}
+  mCallback = NULL;
+  memset(&mHalEntryFuncs, 0, sizeof(mHalEntryFuncs));
 
-void NfcAdaptation::FactoryReset() {
-  if (mHal_1_1 != nullptr) {
-    mHal_1_1->factoryReset();
-  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", func);
+  mpInstance = NULL;
 }
 
-void NfcAdaptation::DeviceShutdown() {
-  if (mHal_1_1 != nullptr) {
-    mHal_1_1->closeForPowerOffCase();
-  }
-}
+/*******************************************************************************
+**
+** Function:    NfcAdaptation::Dump
+**
+** Description: Native support for dumpsys function.
+**
+** Returns:     None.
+**
+*******************************************************************************/
+void NfcAdaptation::Dump(int fd) { debug_nfcsnoop_dump(fd); }
 
 /*******************************************************************************
 **
@@ -341,11 +592,11 @@ void NfcAdaptation::signal() { mCondVar.signal(); }
 ** Returns:     none
 **
 *******************************************************************************/
-uint32_t NfcAdaptation::NFCA_TASK(uint32_t arg) {
+uint32_t NfcAdaptation::NFCA_TASK(__attribute__((unused)) uint32_t arg) {
   const char* func = "NfcAdaptation::NFCA_TASK";
-  ALOGD("%s: enter", func);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", func);
   GKI_run(0);
-  ALOGD("%s: exit", func);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", func);
   return 0;
 }
 
@@ -358,9 +609,9 @@ uint32_t NfcAdaptation::NFCA_TASK(uint32_t arg) {
 ** Returns:     none
 **
 *******************************************************************************/
-uint32_t NfcAdaptation::Thread(uint32_t arg) {
+uint32_t NfcAdaptation::Thread(__attribute__((unused)) uint32_t arg) {
   const char* func = "NfcAdaptation::Thread";
-  ALOGD("%s: enter", func);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", func);
 
   {
     ThreadCondVar CondVar;
@@ -373,7 +624,7 @@ uint32_t NfcAdaptation::Thread(uint32_t arg) {
   NfcAdaptation::GetInstance().signal();
 
   GKI_exit_task(GKI_get_taskid());
-  ALOGD("%s: exit", func);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", func);
   return 0;
 }
 
@@ -399,35 +650,43 @@ tHAL_NFC_ENTRY* NfcAdaptation::GetHalEntryFuncs() { return &mHalEntryFuncs; }
 *******************************************************************************/
 void NfcAdaptation::InitializeHalDeviceContext() {
   const char* func = "NfcAdaptation::InitializeHalDeviceContext";
-  ALOGD("%s: enter", func);
-  int ret = 0;  // 0 means success
-
-    mHalEntryFuncs.initialize = HalInitialize;
-    mHalEntryFuncs.terminate = HalTerminate;
-    mHalEntryFuncs.open = HalOpen;
-    mHalEntryFuncs.close = HalClose;
-    mHalEntryFuncs.core_initialized = HalCoreInitialized;
-    mHalEntryFuncs.write = HalWrite;
-#if(NXP_EXTNS == TRUE)
-    mHalEntryFuncs.ioctl = HalIoctl;
+
+  mHalEntryFuncs.initialize = HalInitialize;
+  mHalEntryFuncs.terminate = HalTerminate;
+  mHalEntryFuncs.open = HalOpen;
+  mHalEntryFuncs.close = HalClose;
+  mHalEntryFuncs.core_initialized = HalCoreInitialized;
+  mHalEntryFuncs.write = HalWrite;
+#if (NXP_EXTNS == TRUE)
+  mHalEntryFuncs.ioctl = HalIoctl;
 #endif
-    mHalEntryFuncs.prediscover = HalPrediscover;
-    mHalEntryFuncs.control_granted = HalControlGranted;
-    mHalEntryFuncs.power_cycle = HalPowerCycle;
-    mHalEntryFuncs.get_max_ee = HalGetMaxNfcee;
-    ALOGI("%s: INfc::getService()", func);
-    mHal = mHal_1_1 = INfcV1_1::getService();
-    if (mHal_1_1 == nullptr) {
-      mHal = INfc::getService();
-    }
-    LOG_FATAL_IF(mHal == nullptr, "Failed to retrieve the NFC HAL!");
-    ALOGI("%s: INfc::getService() returned %p (%s)", func,
-          mHal.get(), (mHal->isRemote() ? "remote" : "local"));
-    mNqHal = INqNfc::getService();
-    LOG_FATAL_IF(mNqHal == nullptr, "Failed to retrieve the vendor NFC HAL!");
-    ALOGI("%s: INqNfc::getService() returned %p (%s)", func,
-          mNqHal.get(), (mNqHal->isRemote() ? "remote" : "local"));
-    ALOGD ("%s: exit", func);
+  mHalEntryFuncs.prediscover = HalPrediscover;
+  mHalEntryFuncs.control_granted = HalControlGranted;
+  mHalEntryFuncs.power_cycle = HalPowerCycle;
+  mHalEntryFuncs.get_max_ee = HalGetMaxNfcee;
+  LOG(INFO) << StringPrintf("%s: Try INfcV1_1::getService()", func);
+  mHal = mHal_1_1 = INfcV1_1::tryGetService();
+  if (mHal_1_1 == nullptr) {
+    LOG(INFO) << StringPrintf("%s: Try INfc::getService()", func);
+    mHal = INfc::tryGetService();
+  }
+  //LOG_FATAL_IF(mHal == nullptr, "Failed to retrieve the NFC HAL!");
+  if (mHal == nullptr) {
+    LOG(INFO) << StringPrintf ( "Failed to retrieve the NFC HAL!");
+  }else {
+    LOG(INFO) << StringPrintf("%s: INfc::getService() returned %p (%s)", func, mHal.get(),
+          (mHal->isRemote() ? "remote" : "local"));
+  }
+  mHal->linkToDeath(mNfcHalDeathRecipient,0);
+  LOG(INFO) << StringPrintf("%s: INqNfc::getService()", func);
+  mNqHal = INqNfc::tryGetService();
+  if(mNqHal == nullptr) {
+    LOG(INFO) << StringPrintf ( "Failed to retrieve the NXPNFC HAL!");
+  } else {
+    LOG(INFO) << StringPrintf("%s: INqNfc::getService() returned %p (%s)", func, mNqHal.get(),
+          (mNqHal->isRemote() ? "remote" : "local"));
+  }
+
 }
 
 /*******************************************************************************
@@ -442,7 +701,7 @@ void NfcAdaptation::InitializeHalDeviceContext() {
 *******************************************************************************/
 void NfcAdaptation::HalInitialize() {
   const char* func = "NfcAdaptation::HalInitialize";
-  ALOGD("%s", func);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", func);
 }
 
 /*******************************************************************************
@@ -457,7 +716,7 @@ void NfcAdaptation::HalInitialize() {
 *******************************************************************************/
 void NfcAdaptation::HalTerminate() {
   const char* func = "NfcAdaptation::HalTerminate";
-  ALOGD("%s", func);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", func);
 }
 
 /*******************************************************************************
@@ -472,7 +731,7 @@ void NfcAdaptation::HalTerminate() {
 void NfcAdaptation::HalOpen(tHAL_NFC_CBACK* p_hal_cback,
                             tHAL_NFC_DATA_CBACK* p_data_cback) {
   const char* func = "NfcAdaptation::HalOpen";
-  ALOGD("%s", func);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", func);
   mCallback = new NfcClientCallback(p_hal_cback, p_data_cback);
   if (mHal_1_1 != nullptr) {
     mHal_1_1->open_1_1(mCallback);
@@ -491,7 +750,7 @@ void NfcAdaptation::HalOpen(tHAL_NFC_CBACK* p_hal_cback,
 *******************************************************************************/
 void NfcAdaptation::HalClose() {
   const char* func = "NfcAdaptation::HalClose";
-  ALOGD("%s", func);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", func);
   mHal->close();
 }
 
@@ -508,7 +767,7 @@ void NfcAdaptation::HalClose() {
 void NfcAdaptation::HalDeviceContextCallback(nfc_event_t event,
                                              nfc_status_t event_status) {
   const char* func = "NfcAdaptation::HalDeviceContextCallback";
-  ALOGD("%s: event=%u", func, event);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: event=%u", func, event);
   if (mHalCallback) mHalCallback(event, (tHAL_NFC_STATUS)event_status);
 }
 
@@ -525,7 +784,7 @@ void NfcAdaptation::HalDeviceContextCallback(nfc_event_t event,
 void NfcAdaptation::HalDeviceContextDataCallback(uint16_t data_len,
                                                  uint8_t* p_data) {
   const char* func = "NfcAdaptation::HalDeviceContextDataCallback";
-  ALOGD("%s: len=%u", func, data_len);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: len=%u", func, data_len);
   if (mHalDataCallback) mHalDataCallback(data_len, p_data);
 }
 
@@ -540,21 +799,13 @@ void NfcAdaptation::HalDeviceContextDataCallback(uint16_t data_len,
 *******************************************************************************/
 void NfcAdaptation::HalWrite(uint16_t data_len, uint8_t* p_data) {
   const char* func = "NfcAdaptation::HalWrite";
-  ALOGD("%s", func);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", func);
   ::android::hardware::nfc::V1_0::NfcData data;
   data.setToExternal(p_data, data_len);
   mHal->write(data);
 }
 
 #if (NXP_EXTNS == TRUE)
-typedef struct {
-    struct nfc_nci_device nci_device;
-
-    /* Local definitions */
-    int(*ioctl)(const struct nfc_nci_device *p_dev, long arg, void *p_data);
-    int(*check_fw_dwnld_flag)(const struct nfc_nci_device *p_dev, uint8_t* param1);
-
-} pn547_dev_t;
 /*******************************************************************************
 **
 ** Function:    IoctlCallback
@@ -569,7 +820,7 @@ void IoctlCallback(::android::hardware::nfc::V1_0::NfcData outputData) {
   const char* func = "IoctlCallback";
   nfc_nci_ExtnOutputData_t* pOutData =
       (nfc_nci_ExtnOutputData_t*)&outputData[0];
-  ALOGD("%s Ioctl Type=%llu", func, pOutData->ioctlType);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s Ioctl Type=%llu", func, (unsigned long long)pOutData->ioctlType);
   NfcAdaptation* pAdaptation = (NfcAdaptation*)pOutData->context;
   /*Output Data from stub->Proxy is copied back to output data
    * This data will be sent back to libnfc*/
@@ -597,14 +848,23 @@ int NfcAdaptation::HalIoctl(long arg, void* p_data) {
   ::android::hardware::nfc::V1_0::NfcData data;
   AutoThreadMutex a(sIoctlLock);
   nfc_nci_IoctlInOutData_t* pInpOutData = (nfc_nci_IoctlInOutData_t*)p_data;
-  int status = 0;
-  ALOGD("%s arg=%ld", func, arg);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s arg=%ld", func, arg);
   pInpOutData->inp.context = &NfcAdaptation::GetInstance();
   NfcAdaptation::GetInstance().mCurrentIoctlData = pInpOutData;
   data.setToExternal((uint8_t*)pInpOutData, sizeof(nfc_nci_IoctlInOutData_t));
+  if (arg == HAL_NFC_IOCTL_SET_TRANSIT_CONFIG) {
+    /*Insert Transit config at the end of IOCTL data as transit buffer also
+    needs to be part of NfcData(hidl_vec)*/
+    std::vector<uint8_t> tempStdVec(data);
+    tempStdVec.insert(
+        tempStdVec.end(), pInpOutData->inp.data.transitConfig.val,
+        pInpOutData->inp.data.transitConfig.val +
+            (pInpOutData->inp.data.transitConfig.len));
+    data = tempStdVec;
+  }
   if(mNqHal != nullptr)
       mNqHal->ioctl(arg, data, IoctlCallback);
-  ALOGD("%s Ioctl Completed for Type=%llu", func, pInpOutData->out.ioctlType);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s Ioctl Completed for Type=%llu", func, (unsigned long long)pInpOutData->out.ioctlType);
   return (pInpOutData->out.result);
 }
 
@@ -617,10 +877,10 @@ int NfcAdaptation::HalIoctl(long arg, void* p_data) {
 ** Returns:     SUCESS or FAIL.
 **
 *******************************************************************************/
-int NfcAdaptation::HalGetFwDwnldFlag(uint8_t* fwDnldRequest) {
+int NfcAdaptation::HalGetFwDwnldFlag(__attribute__((unused)) uint8_t* fwDnldRequest) {
   const char* func = "NfcAdaptation::HalGetFwDwnldFlag";
   int status = NFA_STATUS_FAILED;
-  ALOGD("%s : Dummy", func);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s : Dummy", func);
   /*FIXME: Additional IOCTL type can be added for this
    * Instead of extra function pointer
    * This is required for a corner case or delayed FW download after SPI session
@@ -648,7 +908,7 @@ int NfcAdaptation::HalGetFwDwnldFlag(uint8_t* fwDnldRequest) {
 void NfcAdaptation::HalCoreInitialized(uint16_t data_len,
                                        uint8_t* p_core_init_rsp_params) {
   const char* func = "NfcAdaptation::HalCoreInitialized";
-  ALOGD("%s", func);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", func);
   hidl_vec<uint8_t> data;
   data.setToExternal(p_core_init_rsp_params, data_len);
   mHal->coreInitialized(data);
@@ -670,7 +930,7 @@ void NfcAdaptation::HalCoreInitialized(uint16_t data_len,
 *******************************************************************************/
 bool NfcAdaptation::HalPrediscover() {
   const char* func = "NfcAdaptation::HalPrediscover";
-  ALOGD("%s", func);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", func);
   bool retval = false;
   if(mHal != nullptr)
   {
@@ -702,7 +962,7 @@ bool NfcAdaptation::HalPrediscover() {
 *******************************************************************************/
 void NfcAdaptation::HalControlGranted() {
   const char* func = "NfcAdaptation::HalControlGranted";
-  ALOGD("%s", func);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", func);
   mHal->controlGranted();
 }
 
@@ -717,7 +977,7 @@ void NfcAdaptation::HalControlGranted() {
 *******************************************************************************/
 void NfcAdaptation::HalPowerCycle() {
   const char* func = "NfcAdaptation::HalPowerCycle";
-  ALOGD("%s", func);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", func);
   mHal->powerCycle();
 }
 
@@ -732,8 +992,7 @@ void NfcAdaptation::HalPowerCycle() {
 *******************************************************************************/
 uint8_t NfcAdaptation::HalGetMaxNfcee() {
   const char* func = "NfcAdaptation::HalPowerCycle";
-  uint8_t maxNfcee = 0;
-  ALOGD("%s", func);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", func);
   return nfa_ee_max_ee_cfg;
 }
 
@@ -748,7 +1007,7 @@ uint8_t NfcAdaptation::HalGetMaxNfcee() {
 *******************************************************************************/
 void NfcAdaptation::DownloadFirmware() {
   const char* func = "NfcAdaptation::DownloadFirmware";
-  ALOGD("%s: enter", func);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", func);
 #if (NXP_EXTNS == TRUE)
   static uint8_t cmd_reset_nci[] = {0x20, 0x00, 0x01, 0x00};
   static uint8_t cmd_init_nci[] = {0x20, 0x01, 0x00};
@@ -768,7 +1027,7 @@ void NfcAdaptation::DownloadFirmware() {
   HalInitialize();
 
   mHalOpenCompletedEvent.lock();
-  ALOGD("%s: try open HAL", func);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: try open HAL", func);
   HalOpen(HalDownloadFirmwareCallback, HalDownloadFirmwareDataCallback);
   mHalOpenCompletedEvent.wait();
   mHalOpenCompletedEvent.unlock();
@@ -780,7 +1039,7 @@ void NfcAdaptation::DownloadFirmware() {
    * to the NFCC. Hence CORE-RESET and CORE-INIT have to be sent prior to this.
    */
   isSignaled = SIGNAL_NONE;
-  ALOGD("%s: send CORE_RESET", func);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: send CORE_RESET", func);
   HalWrite(cmd_reset_nci_size, cmd_reset_nci);
   mHalCoreResetCompletedEvent.lock();
   if (SIGNAL_NONE == isSignaled) {
@@ -791,8 +1050,8 @@ void NfcAdaptation::DownloadFirmware() {
   if (evt_status == NFC_STATUS_FAILED) {
     goto TheEnd;
   }
-  ALOGD("%s: send CORE_INIT", func);
-  ALOGD("%s: send CORE_INIT NCI Version : %d", func, NFA_GetNCIVersion());
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: send CORE_INIT", func);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: send CORE_INIT NCI Version : %d", func, NFA_GetNCIVersion());
   if(NFA_GetNCIVersion() == NCI_VERSION_2_0)
     HalWrite(cmd_init_nci_size, cmd_init_nci2_0);
   else
@@ -808,15 +1067,15 @@ void NfcAdaptation::DownloadFirmware() {
   }
   mHalEntryFuncs.ioctl(HAL_NFC_IOCTL_CHECK_FLASH_REQ, &inpOutData);
   fw_update_inf = *(tNFC_FWUpdate_Info_t*)&inpOutData.out.data.fwUpdateInf;
-  NFC_TRACE_DEBUG1("fw_update required  -> %d", fw_update_inf.fw_update_reqd);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("fw_update required  -> %d", fw_update_inf.fw_update_reqd);
   if (fw_update_inf.fw_update_reqd == true) {
     mHalEntryFuncs.ioctl(HAL_NFC_IOCTL_FW_DWNLD, &inpOutData);
     fw_dwnld_status = inpOutData.out.data.fwDwnldStatus;
     if (fw_dwnld_status != NFC_STATUS_OK) {
-      ALOGD("%s: FW Download failed", func);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: FW Download failed", func);
     } else {
       isSignaled = SIGNAL_NONE;
-      ALOGD("%s: send CORE_RESET", func);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: send CORE_RESET", func);
       HalWrite(cmd_reset_nci_size, cmd_reset_nci);
       mHalCoreResetCompletedEvent.lock();
       if (SIGNAL_NONE == isSignaled) {
@@ -827,7 +1086,7 @@ void NfcAdaptation::DownloadFirmware() {
       if (evt_status == NFC_STATUS_FAILED) {
         goto TheEnd;
       }
-      ALOGD("%s: send CORE_INIT", func);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: send CORE_INIT", func);
       if(NFA_GetNCIVersion() == NCI_VERSION_2_0)
         HalWrite(cmd_init_nci_size, cmd_init_nci2_0);
       else
@@ -841,10 +1100,14 @@ void NfcAdaptation::DownloadFirmware() {
       if (evt_status == NFC_STATUS_FAILED) {
         goto TheEnd;
       }
-      ALOGD("%s: try init HAL", func);
-      HalCoreInitialized(sizeof(uint8_t), &p_core_init_rsp_params);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: try init HAL", func);
+      isSignaled = SIGNAL_NONE;
       mHalInitCompletedEvent.lock();
-      mHalInitCompletedEvent.wait();
+      HalCoreInitialized(sizeof(uint8_t), &p_core_init_rsp_params);
+      if (SIGNAL_NONE == isSignaled) {
+        mHalInitCompletedEvent.wait();
+      }
+      isSignaled = SIGNAL_NONE;
       mHalInitCompletedEvent.unlock();
     }
   }
@@ -852,7 +1115,7 @@ void NfcAdaptation::DownloadFirmware() {
 TheEnd:
   isSignaled = SIGNAL_NONE;
 #endif
-  ALOGD("%s: try close HAL", func);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: try close HAL", func);
   HalClose();
 #if (NXP_EXTNS == TRUE)
   mHalCloseCompletedEvent.lock();
@@ -863,7 +1126,7 @@ TheEnd:
   mHalCloseCompletedEvent.unlock();
 #endif
   HalTerminate();
-  ALOGD("%s: exit", func);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit", func);
 }
 
 /*******************************************************************************
@@ -876,23 +1139,27 @@ TheEnd:
 **
 *******************************************************************************/
 void NfcAdaptation::HalDownloadFirmwareCallback(nfc_event_t event,
+                                                __attribute__((unused))
                                                 nfc_status_t event_status) {
   const char* func = "NfcAdaptation::HalDownloadFirmwareCallback";
   (void)(event_status);
-  ALOGD("%s: event=0x%X", func, event);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: event=0x%X", func, event);
   switch (event) {
     case HAL_NFC_OPEN_CPLT_EVT: {
-      ALOGD("%s: HAL_NFC_OPEN_CPLT_EVT", func);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: HAL_NFC_OPEN_CPLT_EVT", func);
       mHalOpenCompletedEvent.signal();
       break;
     }
     case HAL_NFC_POST_INIT_CPLT_EVT: {
-      ALOGD("%s: HAL_NFC_POST_INIT_CPLT_EVT", func);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: HAL_NFC_POST_INIT_CPLT_EVT", func);
+#if (NXP_EXTNS == TRUE)
+      isSignaled = SIGNAL_SIGNALED;
+#endif
       mHalInitCompletedEvent.signal();
       break;
     }
     case HAL_NFC_CLOSE_CPLT_EVT: {
-      ALOGD("%s: HAL_NFC_CLOSE_CPLT_EVT", func);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: HAL_NFC_CLOSE_CPLT_EVT", func);
 #if (NXP_EXTNS == TRUE)
       isSignaled = SIGNAL_SIGNALED;
 #endif
@@ -911,7 +1178,9 @@ void NfcAdaptation::HalDownloadFirmwareCallback(nfc_event_t event,
 ** Returns:     None.
 **
 *******************************************************************************/
-void NfcAdaptation::HalDownloadFirmwareDataCallback(uint16_t data_len,
+void NfcAdaptation::HalDownloadFirmwareDataCallback(__attribute__((unused))
+                                                    uint16_t data_len,
+                                                    __attribute__((unused))
                                                     uint8_t* p_data) {
 #if (NXP_EXTNS == TRUE)
   isSignaled = SIGNAL_SIGNALED;
@@ -1058,3 +1327,17 @@ AutoThreadMutex::AutoThreadMutex(ThreadMutex& m) : mm(m) { mm.lock(); }
 **
 *******************************************************************************/
 AutoThreadMutex::~AutoThreadMutex() { mm.unlock(); }
+
+/***************************************************************************
+**
+** Function         initializeGlobalAppDtaMode.
+**
+** Description      initialize Dta App Mode flag.
+**
+** Returns          None.
+**
+***************************************************************************/
+void initializeGlobalAppDtaMode() {
+  appl_dta_mode_flag = 0x01;
+  ALOGD("%s: DTA Enabled", __func__);
+}
diff --git a/src/adaptation/OverrideLog.cpp b/src/adaptation/OverrideLog.cpp
deleted file mode 100644
index 08a477d..0000000
--- a/src/adaptation/OverrideLog.cpp
+++ /dev/null
@@ -1,145 +0,0 @@
-/******************************************************************************
- *
- *  Copyright (C) 2012 Broadcom Corporation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at:
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-/******************************************************************************
- *
- *  The original Work has been changed by NXP Semiconductors.
- *
- *  Copyright (C) 2015 NXP Semiconductors
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-/******************************************************************************
- *
- *  Override the ALOGD(), ALOGE(), and other logging macros from
- *  /system/core/include/cutils/log.h
- *
- ******************************************************************************/
-#include "_OverrideLog.h"
-#include <cutils/properties.h>
-#include <string.h>
-#include "config.h"
-#include "android_logmsg.h"
-
-#undef LOG_TAG
-#define LOG_TAG "BrcmNfcJni"
-
-/*******************************************************************************
-**
-** Function:        initializeGlobalAppLogLevel
-**
-** Description:     Initialize and get global logging level from .conf or
-**                  Android property nfc.app_log_level.  The Android property
-**                  overrides .conf variable.
-**
-** Returns:         Global log level:
-**                  BT_TRACE_LEVEL_NONE    0 * No trace messages to be generated
-**                  BT_TRACE_LEVEL_ERROR   1 * Error condition trace messages
-**                  BT_TRACE_LEVEL_WARNING 2 * Warning condition trace messages
-**                  BT_TRACE_LEVEL_API     3 * API traces
-**                  BT_TRACE_LEVEL_EVENT   4 * Debug messages for events
-**                  BT_TRACE_LEVEL_DEBUG   5 * Debug messages (general)
-**
-*******************************************************************************/
-unsigned char initializeGlobalAppLogLevel() {
-  unsigned long num = 0;
-  char valueStr[PROPERTY_VALUE_MAX] = {0};
-
-  num = 1;
-  if (GetNumValue(NAME_APPL_TRACE_LEVEL, &num, sizeof(num)))
-    appl_trace_level = (unsigned char)num;
-  int len = property_get("nfc.app_log_level", valueStr, "");
-  if (len > 0) {
-    // let Android property override .conf variable
-    sscanf(valueStr, "%lu", &num);
-    appl_trace_level = (unsigned char)num;
-  }
-
-  // 0xFF is a special value used by the stack to query the current
-  // trace level; it does not change any trace level
-  if (appl_trace_level == 0xFF) appl_trace_level = BT_TRACE_LEVEL_DEBUG;
-  ALOGD("%s: level=%u", __func__, appl_trace_level);
-
-  if (appl_trace_level < BT_TRACE_LEVEL_DEBUG) {
-    // display protocol traces in raw format
-    ProtoDispAdapterUseRawOutput(true);
-  }
-  return appl_trace_level;
-}
-
-uint32_t initializeProtocolLogLevel() {
-  uint32_t num = 0;
-  char valueStr[PROPERTY_VALUE_MAX] = {0};
-
-  if (GetNumValue(NAME_PROTOCOL_TRACE_LEVEL, &num, sizeof(num)))
-    ScrProtocolTraceFlag = num;
-
-  int len = property_get("nfc.enable_protocol_log", valueStr, "");
-  if (len > 0) {
-    if (strncmp("0", valueStr, 1) == 0) {
-      ScrProtocolTraceFlag = 0;
-    } else {
-      ScrProtocolTraceFlag = ~0;
-    }
-  }
-
-  return ScrProtocolTraceFlag;
-}
-
-#if (NXP_EXTNS == TRUE)
-/*********************************************************************************
-** Function:        enableDisableAppLevel
-**
-** Description:     Enable/Disable applicaton trace logs
-**
-** Returns:         none:
-**
-*******************************************************************************/
-void enableDisableAppLevel(uint8_t type) {
-  static uint8_t backup_app_trace = appl_trace_level;
-  if (0x01 == type && (backup_app_trace != appl_trace_level)) {
-    appl_trace_level = backup_app_trace;
-  } else if (0x00 == type && (0x00 != appl_trace_level)) {
-    backup_app_trace = appl_trace_level;
-    appl_trace_level = 0x00;
-  }
-}
-/*******************************************************************************
-**
-** Function:        initializeGlobalDtaMode
-**
-** Description:     Initialize and get global DTA mode from .conf
-**
-** Returns:         none:
-**
-*******************************************************************************/
-void initializeGlobalAppDtaMode() {
-  appl_dta_mode_flag = 0x01;
-  ALOGD("%s: DTA Enabled", __func__);
-}
-#endif
diff --git a/src/adaptation/android_logmsg.cpp b/src/adaptation/android_logmsg.cpp
deleted file mode 100644
index 0a82175..0000000
--- a/src/adaptation/android_logmsg.cpp
+++ /dev/null
@@ -1,351 +0,0 @@
-/******************************************************************************
- *
- *  Copyright (C) 1999-2012 Broadcom Corporation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at:
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-/******************************************************************************
- *
- *  The original Work has been changed by NXP Semiconductors.
- *
- *  Copyright (C) 2015 NXP Semiconductors
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-#include "_OverrideLog.h"
-#include "android_logmsg.h"
-#include "nfc_target.h"
-#include "buildcfg.h"
-#include <cutils/log.h>
-
-extern uint32_t ScrProtocolTraceFlag;
-#define MAX_NCI_PACKET_SIZE 259
-#define BTE_LOG_BUF_SIZE 1024
-#define BTE_LOG_MAX_SIZE (BTE_LOG_BUF_SIZE - 12)
-#define MAX_LOGCAT_LINE 4096
-#define PRINT(s) __android_log_write(ANDROID_LOG_DEBUG, "BrcmNci", s)
-#define UNUSED(X) (void) X
-static char log_line[MAX_LOGCAT_LINE];
-static const char* sTable = "0123456789abcdef";
-static bool sIsUseRaw = false;
-static void ToHex(const uint8_t* data, uint16_t len, char* hexString,
-                  uint16_t hexStringSize);
-static void dumpbin(const char* data, int size, uint32_t trace_layer,
-                    uint32_t trace_type);
-static inline void word2hex(const char* data, char** hex);
-static inline void byte2char(const char* data, char** str);
-static inline void byte2hex(const char* data, char** str);
-
-void BTDISP_LOCK_LOG() {}
-
-void BTDISP_UNLOCK_LOG() {}
-
-void BTDISP_INIT_LOCK() {}
-
-void BTDISP_UNINIT_LOCK() {}
-
-void ProtoDispAdapterUseRawOutput(bool isUseRaw) { sIsUseRaw = isUseRaw; }
-
-void ProtoDispAdapterDisplayNciPacket(uint8_t* nciPacket, uint16_t nciPacketLen,
-                                      bool is_recv) {
-  // Protocol decoder is not available, so decode NCI packet into hex numbers.
-  if (!(ScrProtocolTraceFlag & SCR_PROTO_TRACE_NCI)) return;
-  char line_buf[(MAX_NCI_PACKET_SIZE * 2) + 1];
-  ToHex(nciPacket, nciPacketLen, line_buf, sizeof(line_buf));
-  __android_log_write(ANDROID_LOG_DEBUG, (is_recv) ? "BrcmNciR" : "BrcmNciX",
-                      line_buf);
-}
-
-void ToHex(const uint8_t* data, uint16_t len, char* hexString,
-           uint16_t hexStringSize) {
-  int i = 0, j = 0;
-  for (i = 0, j = 0; i < len && j < hexStringSize - 3; i++) {
-    hexString[j++] = sTable[(*data >> 4) & 0xf];
-    hexString[j++] = sTable[*data & 0xf];
-    data++;
-  }
-  hexString[j] = '\0';
-}
-
-// Protodisp code calls ScrLog() to print decoded texts.
-void ScrLog(uint32_t trace_set_mask, const char* fmt_str, ...) {
-  static char buffer[BTE_LOG_BUF_SIZE];
-  va_list ap;
-  UNUSED(trace_set_mask);
-  va_start(ap, fmt_str);
-  vsnprintf(buffer, BTE_LOG_MAX_SIZE, fmt_str, ap);
-  va_end(ap);
-  __android_log_write(ANDROID_LOG_INFO, "BrcmNci", buffer);
-}
-
-uint8_t* scru_dump_hex(uint8_t* p, char* pTitle, uint32_t len, uint32_t layer,
-                       uint32_t type) {
-  if (pTitle && *pTitle) PRINT(pTitle);
-  dumpbin((char*)p, len, layer, type);
-  return p;
-}
-
-void dumpbin(const char* data, int size, uint32_t trace_layer,
-             uint32_t trace_type) {
-  char line_buff[256];
-  char* line;
-  int i, j, addr;
-  const int width = 16;
-  UNUSED(trace_layer);
-  UNUSED(trace_type);
-  if (size <= 0) return;
-  for (i = 0; i < size / width; i++) {
-    line = line_buff;
-    // write address:
-    addr = i * width;
-    word2hex((const char*)&addr, &line);
-    *line++ = ':';
-    *line++ = ' ';
-    // write hex of data
-    for (j = 0; j < width; j++) {
-      byte2hex(&data[j], &line);
-      *line++ = ' ';
-    }
-    // write char of data
-    for (j = 0; j < width; j++) byte2char(data++, &line);
-    // wirte the end of line
-    *line = 0;
-    // output the line
-    PRINT(line_buff);
-  }
-  // last line of left over if any
-  int leftover = size % width;
-  if (leftover > 0) {
-    line = line_buff;
-    // write address:
-    addr = i * width;
-    word2hex((const char*)&addr, &line);
-    *line++ = ':';
-    *line++ = ' ';
-    // write hex of data
-    for (j = 0; j < leftover; j++) {
-      byte2hex(&data[j], &line);
-      *line++ = ' ';
-    }
-    // write hex padding
-    for (; j < width; j++) {
-      *line++ = ' ';
-      *line++ = ' ';
-      *line++ = ' ';
-    }
-    // write char of data
-    for (j = 0; j < leftover; j++) byte2char(data++, &line);
-    // write the end of line
-    *line = 0;
-    // output the line
-    PRINT(line_buff);
-  }
-}
-
-inline void word2hex(const char* data, char** hex) {
-  byte2hex(&data[1], hex);
-  byte2hex(&data[0], hex);
-}
-
-inline void byte2char(const char* data, char** str) {
-  **str = *data < ' ' ? '.' : *data > '~' ? '.' : *data;
-  ++(*str);
-}
-
-inline void byte2hex(const char* data, char** str) {
-  **str = sTable[(*data >> 4) & 0xf];
-  ++*str;
-  **str = sTable[*data & 0xf];
-  ++*str;
-}
-
-// Decode a few Bluetooth HCI packets into hex numbers.
-void DispHciCmd(NFC_HDR* p_buf) {
-  uint32_t nBytes = ((NFC_HDR_SIZE + p_buf->offset + p_buf->len) * 2) + 1;
-  uint8_t* data = (uint8_t*)p_buf;
-  int data_len = NFC_HDR_SIZE + p_buf->offset + p_buf->len;
-
-  if (appl_trace_level < BT_TRACE_LEVEL_DEBUG) return;
-
-  if (nBytes > sizeof(log_line)) return;
-
-  ToHex(data, data_len, log_line, sizeof(log_line));
-  __android_log_write(ANDROID_LOG_DEBUG, "BrcmHciX", log_line);
-}
-
-// Decode a few Bluetooth HCI packets into hex numbers.
-void DispHciEvt(NFC_HDR* p_buf) {
-  uint32_t nBytes = ((NFC_HDR_SIZE + p_buf->offset + p_buf->len) * 2) + 1;
-  uint8_t* data = (uint8_t*)p_buf;
-  int data_len = NFC_HDR_SIZE + p_buf->offset + p_buf->len;
-
-  if (appl_trace_level < BT_TRACE_LEVEL_DEBUG) return;
-
-  if (nBytes > sizeof(log_line)) return;
-
-  ToHex(data, data_len, log_line, sizeof(log_line));
-  __android_log_write(ANDROID_LOG_DEBUG, "BrcmHciR", log_line);
-}
-
-/***************************************************************************
-**
-** Function         DispLLCP
-**
-** Description      Log LLCP packet as hex-ascii bytes.
-**
-** Returns          None.
-**
-***************************************************************************/
-void DispLLCP(NFC_HDR* p_buf, bool is_recv) {
-  uint32_t nBytes = ((NFC_HDR_SIZE + p_buf->offset + p_buf->len) * 2) + 1;
-  uint8_t* data = (uint8_t*)p_buf;
-  int data_len = NFC_HDR_SIZE + p_buf->offset + p_buf->len;
-
-  if (appl_trace_level < BT_TRACE_LEVEL_DEBUG) return;
-
-  if (nBytes > sizeof(log_line)) return;
-
-  ToHex(data, data_len, log_line, sizeof(log_line));
-  __android_log_write(ANDROID_LOG_DEBUG, (is_recv) ? "BrcmLlcpR" : "BrcmLlcpX",
-                      log_line);
-}
-
-/***************************************************************************
-**
-** Function         DispHcp
-**
-** Description      Log raw HCP packet as hex-ascii bytes
-**
-** Returns          None.
-**
-***************************************************************************/
-void DispHcp(uint8_t* data, uint16_t len, bool is_recv) {
-  uint32_t nBytes = (len * 2) + 1;
-
-  if (appl_trace_level < BT_TRACE_LEVEL_DEBUG) return;
-
-  // Only trace HCP if we're tracing HCI as well
-  if (!(ScrProtocolTraceFlag & SCR_PROTO_TRACE_HCI_SUMMARY)) return;
-
-  if (nBytes > sizeof(log_line)) return;
-
-  ToHex(data, len, log_line, sizeof(log_line));
-  __android_log_write(ANDROID_LOG_DEBUG, (is_recv) ? "BrcmHcpR" : "BrcmHcpX",
-                      log_line);
-}
-
-void DispSNEP(uint8_t local_sap, uint8_t remote_sap, NFC_HDR* p_buf,
-              bool is_first, bool is_rx) {
-  UNUSED(local_sap);
-  UNUSED(remote_sap);
-  UNUSED(p_buf);
-  UNUSED(is_first);
-  UNUSED(is_rx);
-}
-void DispCHO(uint8_t* pMsg, uint32_t MsgLen, bool is_rx) {
-  UNUSED(pMsg);
-  UNUSED(MsgLen);
-  UNUSED(is_rx);
-}
-void DispT3TagMessage(NFC_HDR* p_msg, bool is_rx) {
-  UNUSED(p_msg);
-  UNUSED(is_rx);
-}
-void DispRWT4Tags(NFC_HDR* p_buf, bool is_rx) {
-  UNUSED(p_buf);
-  UNUSED(is_rx);
-}
-void DispCET4Tags(NFC_HDR* p_buf, bool is_rx) {
-  UNUSED(p_buf);
-  UNUSED(is_rx);
-}
-void DispRWI93Tag(NFC_HDR* p_buf, bool is_rx, uint8_t command_to_respond) {
-  UNUSED(p_buf);
-  UNUSED(is_rx);
-  UNUSED(command_to_respond);
-}
-void DispNDEFMsg(uint8_t* pMsg, uint32_t MsgLen, bool is_recv) {
-  UNUSED(pMsg);
-  UNUSED(MsgLen);
-  UNUSED(is_recv);
-}
-
-/*******************************************************************************
-**
-** Function:        LogMsg
-**
-** Description:     Print messages from NFC stack.
-**
-** Returns:         None.
-**
-*******************************************************************************/
-void LogMsg(uint32_t trace_set_mask, const char* fmt_str, ...) {
-  static char buffer[BTE_LOG_BUF_SIZE];
-  va_list ap;
-  uint32_t trace_type =
-      trace_set_mask & 0x07;  // lower 3 bits contain trace type
-  int android_log_type = ANDROID_LOG_INFO;
-
-  va_start(ap, fmt_str);
-  vsnprintf(buffer, BTE_LOG_MAX_SIZE, fmt_str, ap);
-  va_end(ap);
-  if (trace_type == TRACE_TYPE_ERROR) android_log_type = ANDROID_LOG_ERROR;
-  __android_log_write(android_log_type, LOGMSG_TAG_NAME, buffer);
-}
-
-void LogMsg_0(uint32_t maskTraceSet, const char* p_str) {
-  LogMsg(maskTraceSet, p_str);
-}
-
-void LogMsg_1(uint32_t maskTraceSet, const char* fmt_str, uintptr_t p1) {
-  LogMsg(maskTraceSet, fmt_str, p1);
-}
-
-void LogMsg_2(uint32_t maskTraceSet, const char* fmt_str, uintptr_t p1,
-              uintptr_t p2) {
-  LogMsg(maskTraceSet, fmt_str, p1, p2);
-}
-
-void LogMsg_3(uint32_t maskTraceSet, const char* fmt_str, uintptr_t p1,
-              uintptr_t p2, uintptr_t p3) {
-  LogMsg(maskTraceSet, fmt_str, p1, p2, p3);
-}
-
-void LogMsg_4(uint32_t maskTraceSet, const char* fmt_str, uintptr_t p1,
-              uintptr_t p2, uintptr_t p3, uintptr_t p4) {
-  LogMsg(maskTraceSet, fmt_str, p1, p2, p3, p4);
-}
-
-void LogMsg_5(uint32_t maskTraceSet, const char* fmt_str, uintptr_t p1,
-              uintptr_t p2, uintptr_t p3, uintptr_t p4, uintptr_t p5) {
-  LogMsg(maskTraceSet, fmt_str, p1, p2, p3, p4, p5);
-}
-
-void LogMsg_6(uint32_t maskTraceSet, const char* fmt_str, uintptr_t p1,
-              uintptr_t p2, uintptr_t p3, uintptr_t p4, uintptr_t p5,
-              uintptr_t p6) {
-  LogMsg(maskTraceSet, fmt_str, p1, p2, p3, p4, p5, p6);
-}
diff --git a/src/adaptation/config.cpp b/src/adaptation/config.cpp
deleted file mode 100644
index 88820f0..0000000
--- a/src/adaptation/config.cpp
+++ /dev/null
@@ -1,827 +0,0 @@
-/******************************************************************************
- *
- *  Copyright (C) 2011-2012 Broadcom Corporation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at:
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-/******************************************************************************
- *
- *  The original Work has been changed by NXP Semiconductors.
- *
- *  Copyright (C) 2013-2014 NXP Semiconductors
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-#include "_OverrideLog.h"
-#include "config.h"
-#include <stdio.h>
-#include <sys/stat.h>
-#include <string>
-#include <vector>
-#include <list>
-#include <cutils/properties.h>
-
-#undef LOG_TAG
-#define LOG_TAG "NfcAdaptation"
-
-const char* transport_config_paths[] = {"/odm/etc/", "/vendor/etc/", "/etc/"};
-const int transport_config_path_size =
-    (sizeof(transport_config_paths) / sizeof(transport_config_paths[0]));
-
-#if (NXP_EXTNS == TRUE)
-const char transit_config_path[] = "/data/vendor/nfc/";
-#endif
-
-#define config_name "libnfc-brcm.conf"
-#define config_name_NCI2 "libnfc-brcm_NCI2_0.conf"
-#if (NXP_EXTNS == TRUE)
-#define extra_config_base "libnfc-"
-#else
-#define extra_config_base "libnfc-brcm-"
-#endif
-#define extra_config_ext ".conf"
-#define IsStringValue 0x80000000
-
-using namespace ::std;
-
-class CNfcParam : public string {
- public:
-  CNfcParam();
-  CNfcParam(const char* name, const string& value);
-  CNfcParam(const char* name, unsigned long value);
-  virtual ~CNfcParam();
-  unsigned long numValue() const { return m_numValue; }
-  const char* str_value() const { return m_str_value.c_str(); }
-  size_t str_len() const { return m_str_value.length(); }
-
- private:
-  string m_str_value;
-  unsigned long m_numValue;
-};
-
-class CNfcConfig : public vector<const CNfcParam*> {
- public:
-  virtual ~CNfcConfig();
-  static CNfcConfig& GetInstance();
-  friend void readOptionalConfigExt(const char* optional);
-  bool getValue(const char* name, char* pValue, size_t& len) const;
-  bool getValue(const char* name, unsigned long& rValue) const;
-  bool getValue(const char* name, unsigned short& rValue) const;
-  const CNfcParam* find(const char* p_name) const;
-#if (NXP_EXTNS == TRUE)
-  void readNxpTransitConfig(const char* fileName) const;
-#endif
-  void clean();
-
- private:
-  CNfcConfig();
-  bool readConfig(const char* name, bool bResetContent);
-  void moveFromList();
-  void moveToList();
-  void add(const CNfcParam* pParam);
-#if (NXP_EXTNS == TRUE)
-  void dump();
-  bool isAllowed(const char* name);
-  string mCurrentFile;
-#endif
-  list<const CNfcParam*> m_list;
-  bool mValidFile;
-
-  unsigned long state;
-
-  inline bool Is(unsigned long f) { return (state & f) == f; }
-  inline void Set(unsigned long f) { state |= f; }
-  inline void Reset(unsigned long f) { state &= ~f; }
-};
-
-/*******************************************************************************
-**
-** Function:    isPrintable()
-**
-** Description: detremine if a char is printable
-**
-** Returns:     none
-**
-*******************************************************************************/
-inline bool isPrintable(char c) {
-  return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') ||
-         (c >= '0' && c <= '9') || c == '/' || c == '_' || c == '-' || c == '.';
-}
-
-/*******************************************************************************
-**
-** Function:    isDigit()
-**
-** Description: detremine if a char is numeral digit
-**
-** Returns:     none
-**
-*******************************************************************************/
-inline bool isDigit(char c, int base) {
-  if ('0' <= c && c <= '9') return true;
-  if (base == 16) {
-    if (('A' <= c && c <= 'F') || ('a' <= c && c <= 'f')) return true;
-  }
-  return false;
-}
-
-/*******************************************************************************
-**
-** Function:    getDigitValue()
-**
-** Description: return numercal value of a char
-**
-** Returns:     none
-**
-*******************************************************************************/
-inline int getDigitValue(char c, int base) {
-  if ('0' <= c && c <= '9') return c - '0';
-  if (base == 16) {
-    if ('A' <= c && c <= 'F')
-      return c - 'A' + 10;
-    else if ('a' <= c && c <= 'f')
-      return c - 'a' + 10;
-  }
-  return 0;
-}
-
-/*******************************************************************************
-**
-** Function:    findConfigFilePathFromTransportConfigPaths()
-**
-** Description: find a config file path with a given config name from transport
-**              config paths
-**
-** Returns:     none
-**
-*******************************************************************************/
-void findConfigFilePathFromTransportConfigPaths(const string& configName,
-                                                string& filePath) {
-  for (int i = 0; i < transport_config_path_size - 1; i++) {
-    filePath.assign(transport_config_paths[i]);
-    filePath += configName;
-    struct stat file_stat;
-    if (stat(filePath.c_str(), &file_stat) == 0 && S_ISREG(file_stat.st_mode)) {
-      return;
-    }
-  }
-  filePath.assign(transport_config_paths[transport_config_path_size - 1]);
-  filePath += configName;
-}
-
-/*******************************************************************************
-**
-** Function:    CNfcConfig::readConfig()
-**
-** Description: read Config settings and parse them into a linked list
-**              move the element from linked list to a array at the end
-**
-** Returns:     none
-**
-*******************************************************************************/
-bool CNfcConfig::readConfig(const char* name, bool bResetContent) {
-  enum {
-    BEGIN_LINE = 1,
-    TOKEN,
-    STR_VALUE,
-    NUM_VALUE,
-    BEGIN_HEX,
-    BEGIN_QUOTE,
-    END_LINE
-  };
-
-  FILE* fd = NULL;
-  string token;
-  string strValue;
-  unsigned long numValue = 0;
-  CNfcParam* pParam = NULL;
-  int i = 0;
-  int base = 0;
-  char c = 0;
-#if (NXP_EXTNS == TRUE)
-  mCurrentFile = name;
-#endif
-
-  state = BEGIN_LINE;
-  /* open config file, read it into a buffer */
-  if ((fd = fopen(name, "rb")) == NULL) {
-    ALOGD("%s Cannot open config file %s\n", __func__, name);
-    if (bResetContent) {
-      ALOGD("%s Using default value for all settings\n", __func__);
-      mValidFile = false;
-    }
-    return false;
-  }
-  ALOGD("%s Opened %s config %s\n", __func__,
-        (bResetContent ? "base" : "optional"), name);
-
-  mValidFile = true;
-  if (size() > 0) {
-    if (bResetContent)
-      clean();
-    else
-      moveToList();
-  }
-
-  for (;;) {
-    if (feof(fd) || fread(&c, 1, 1, fd) != 1) {
-      if (state == BEGIN_LINE) break;
-
-      // got to the EOF but not in BEGIN_LINE state so the file
-      // probably does not end with a newline, so the parser has
-      // not processed current line, simulate a newline in the file
-      c = '\n';
-    }
-
-    switch (state & 0xff) {
-      case BEGIN_LINE:
-        if (c == '#')
-          state = END_LINE;
-        else if (isPrintable(c)) {
-          i = 0;
-          token.erase();
-          strValue.erase();
-          state = TOKEN;
-          token.push_back(c);
-        }
-        break;
-      case TOKEN:
-        if (c == '=') {
-          token.push_back('\0');
-          state = BEGIN_QUOTE;
-        } else if (isPrintable(c))
-          token.push_back(c);
-        else
-          state = END_LINE;
-        break;
-      case BEGIN_QUOTE:
-        if (c == '"') {
-          state = STR_VALUE;
-          base = 0;
-        } else if (c == '0')
-          state = BEGIN_HEX;
-        else if (isDigit(c, 10)) {
-          state = NUM_VALUE;
-          base = 10;
-          numValue = getDigitValue(c, base);
-          i = 0;
-        } else if (c == '{') {
-          state = NUM_VALUE;
-          base = 16;
-          i = 0;
-          Set(IsStringValue);
-        } else
-          state = END_LINE;
-        break;
-      case BEGIN_HEX:
-        if (c == 'x' || c == 'X') {
-          state = NUM_VALUE;
-          base = 16;
-          numValue = 0;
-          i = 0;
-          break;
-        } else if (isDigit(c, 10)) {
-          state = NUM_VALUE;
-          base = 10;
-          numValue = getDigitValue(c, base);
-          break;
-        } else if (c != '\n' && c != '\r') {
-          state = END_LINE;
-          break;
-        }
-      // fal through to numValue to handle numValue
-
-      case NUM_VALUE:
-        if (isDigit(c, base)) {
-          numValue *= base;
-          numValue += getDigitValue(c, base);
-          ++i;
-        } else if (base == 16 &&
-                   (c == ':' || c == '-' || c == ' ' || c == '}')) {
-          if (i > 0) {
-            int n = (i + 1) / 2;
-            while (n-- > 0) {
-              unsigned char c = (numValue >> (n * 8)) & 0xFF;
-              strValue.push_back(c);
-            }
-          }
-          Set(IsStringValue);
-          numValue = 0;
-          i = 0;
-        } else {
-          if (c == '\n' || c == '\r')
-            state = BEGIN_LINE;
-          else
-            state = END_LINE;
-          if (Is(IsStringValue) && base == 16 && i > 0) {
-            int n = (i + 1) / 2;
-            while (n-- > 0) strValue.push_back(((numValue >> (n * 8)) & 0xFF));
-          }
-          if (strValue.length() > 0)
-            pParam = new CNfcParam(token.c_str(), strValue);
-          else
-            pParam = new CNfcParam(token.c_str(), numValue);
-          add(pParam);
-          strValue.erase();
-          numValue = 0;
-        }
-        break;
-      case STR_VALUE:
-        if (c == '"') {
-          strValue.push_back('\0');
-          state = END_LINE;
-          pParam = new CNfcParam(token.c_str(), strValue);
-          add(pParam);
-        } else if (isPrintable(c))
-          strValue.push_back(c);
-        break;
-      case END_LINE:
-        if (c == '\n' || c == '\r') state = BEGIN_LINE;
-        break;
-      default:
-        break;
-    }
-
-    if (feof(fd)) break;
-  }
-
-  fclose(fd);
-
-  moveFromList();
-  return size() > 0;
-}
-
-/*******************************************************************************
-**
-** Function:    CNfcConfig::CNfcConfig()
-**
-** Description: class constructor
-**
-** Returns:     none
-**
-*******************************************************************************/
-CNfcConfig::CNfcConfig() : mValidFile(true), state(0) {}
-
-/*******************************************************************************
-**
-** Function:    CNfcConfig::~CNfcConfig()
-**
-** Description: class destructor
-**
-** Returns:     none
-**
-*******************************************************************************/
-CNfcConfig::~CNfcConfig() {}
-
-/*******************************************************************************
-**
-** Function:    CNfcConfig::GetInstance()
-**
-** Description: get class singleton object
-**
-** Returns:     none
-**
-*******************************************************************************/
-CNfcConfig& CNfcConfig::GetInstance() {
-  static CNfcConfig theInstance;
-
-  if (theInstance.size() == 0 && theInstance.mValidFile) {
-    string strPath;
-    int rc = 0;
-    char nq_fw_ver[PROPERTY_VALUE_MAX] = {0};
-
-    rc = __system_property_get("vendor.qti.nfc.fwver", nq_fw_ver);
-    if (rc <= 0)
-        ALOGE("get vendor.qti.nfc.fwver fail, rc = %d\n", rc);
-    else
-        ALOGD("vendor.qti.nfc.fwver = %s\n", nq_fw_ver);
-
-    if (!strncmp(nq_fw_ver, FW_MAJOR_NUM_NQ4xx, FW_MAJOR_NUM_LENGTH))
-        findConfigFilePathFromTransportConfigPaths(config_name_NCI2, strPath);
-    else
-        findConfigFilePathFromTransportConfigPaths(config_name, strPath);
-
-    theInstance.readConfig(strPath.c_str(), true);
-#if (NXP_EXTNS == TRUE)
-    readOptionalConfigExt("nxp");
-    theInstance.readNxpTransitConfig("nxpTransit");
-#endif
-  }
-
-  return theInstance;
-}
-
-/*******************************************************************************
-**
-** Function:    CNfcConfig::getValue()
-**
-** Description: get a string value of a setting
-**
-** Returns:     true if setting exists
-**              false if setting does not exist
-**
-*******************************************************************************/
-bool CNfcConfig::getValue(const char* name, char* pValue, size_t& len) const {
-  const CNfcParam* pParam = find(name);
-  if (pParam == NULL) return false;
-
-  if (pParam->str_len() > 0) {
-    memset(pValue, 0, len);
-    if (len > pParam->str_len()) len = pParam->str_len();
-    memcpy(pValue, pParam->str_value(), len);
-    return true;
-  }
-  return false;
-}
-
-/*******************************************************************************
-**
-** Function:    CNfcConfig::getValue()
-**
-** Description: get a long numerical value of a setting
-**
-** Returns:     true if setting exists
-**              false if setting does not exist
-**
-*******************************************************************************/
-bool CNfcConfig::getValue(const char* name, unsigned long& rValue) const {
-  const CNfcParam* pParam = find(name);
-  if (pParam == NULL) return false;
-
-  if (pParam->str_len() == 0) {
-    rValue = static_cast<unsigned long>(pParam->numValue());
-    return true;
-  }
-  return false;
-}
-
-/*******************************************************************************
-**
-** Function:    CNfcConfig::getValue()
-**
-** Description: get a short numerical value of a setting
-**
-** Returns:     true if setting exists
-**              false if setting does not exist
-**
-*******************************************************************************/
-bool CNfcConfig::getValue(const char* name, unsigned short& rValue) const {
-  const CNfcParam* pParam = find(name);
-  if (pParam == NULL) return false;
-
-  if (pParam->str_len() == 0) {
-    rValue = static_cast<unsigned short>(pParam->numValue());
-    return true;
-  }
-  return false;
-}
-
-/*******************************************************************************
-**
-** Function:    CNfcConfig::find()
-**
-** Description: search if a setting exist in the setting array
-**
-** Returns:     pointer to the setting object
-**
-*******************************************************************************/
-const CNfcParam* CNfcConfig::find(const char* p_name) const {
-  if (size() == 0) return NULL;
-
-  for (const_iterator it = begin(), itEnd = end(); it != itEnd; ++it) {
-    if (**it < p_name)
-      continue;
-    else if (**it == p_name) {
-      if ((*it)->str_len() > 0)
-        ALOGD("%s found %s=%s\n", __func__, p_name, (*it)->str_value());
-      else
-        ALOGD("%s found %s=(0x%lX)\n", __func__, p_name, (*it)->numValue());
-      return *it;
-    } else
-      break;
-  }
-  return NULL;
-}
-
-#if (NXP_EXTNS == TRUE)
-/*******************************************************************************
-**
-** Function:    CNfcConfig::readNxpTransitConfig()
-**
-** Description: read Config settings from transit conf file
-**
-** Returns:     none
-**
-*******************************************************************************/
-void CNfcConfig::readNxpTransitConfig(const char* fileName) const {
-  string strPath;
-  strPath.assign(transit_config_path);
-  strPath += extra_config_base;
-  strPath += fileName;
-  strPath += extra_config_ext;
-  CNfcConfig::GetInstance().readConfig(strPath.c_str(), false);
-}
-#endif
-
-/*******************************************************************************
-**
-** Function:    CNfcConfig::clean()
-**
-** Description: reset the setting array
-**
-** Returns:     none
-**
-*******************************************************************************/
-void CNfcConfig::clean() {
-  if (size() == 0) return;
-
-  for (iterator it = begin(), itEnd = end(); it != itEnd; ++it) delete *it;
-  clear();
-}
-
-/*******************************************************************************
-**
-** Function:    CNfcConfig::Add()
-**
-** Description: add a setting object to the list
-**
-** Returns:     none
-**
-*******************************************************************************/
-void CNfcConfig::add(const CNfcParam* pParam) {
-  if (m_list.size() == 0) {
-    m_list.push_back(pParam);
-    return;
-  }
-#if (NXP_EXTNS == TRUE)
-  if ((mCurrentFile.find("nxpTransit") != std::string::npos) &&
-      !isAllowed(pParam->c_str())) {
-    ALOGD("%s Token restricted. Returning", __func__);
-    return;
-  }
-#endif
-  for (list<const CNfcParam*>::iterator it = m_list.begin(),
-                                        itEnd = m_list.end();
-       it != itEnd; ++it) {
-    if (**it < pParam->c_str()) continue;
-#if (NXP_EXTNS == TRUE)
-    /*If pParam->c_str() already exist in the list replace it*/
-    if (**it == pParam->c_str())
-      m_list.insert(m_list.erase(it), pParam);
-    else
-      m_list.insert(it, pParam);
-#else
-    m_list.insert(it, pParam);
-#endif
-    return;
-  }
-  m_list.push_back(pParam);
-}
-
-#if (NXP_EXTNS == TRUE)
-/*******************************************************************************
-**
-** Function:    CNfcConfig::dump()
-**
-** Description: prints all elements in the list
-**
-** Returns:     none
-**
-*******************************************************************************/
-void CNfcConfig::dump() {
-  ALOGD("%s Enter", __func__);
-
-  for (list<const CNfcParam*>::iterator it = m_list.begin(),
-                                        itEnd = m_list.end();
-       it != itEnd; ++it) {
-    if ((*it)->str_len() > 0)
-      ALOGD("%s %s \t= %s", __func__, (*it)->c_str(), (*it)->str_value());
-    else
-      ALOGD("%s %s \t= (0x%0lX)\n", __func__, (*it)->c_str(),
-            (*it)->numValue());
-  }
-}
-
-/*******************************************************************************
-**
-** Function:    CNfcConfig::isAllowed()
-**
-** Description: checks if token update is allowed
-**
-** Returns:     true if allowed else false
-**
-*******************************************************************************/
-bool CNfcConfig::isAllowed(const char* name) {
-  string token(name);
-  bool stat = false;
-  if ((token.find("P2P_LISTEN_TECH_MASK") != std::string::npos) ||
-      (token.find("HOST_LISTEN_TECH_MASK") != std::string::npos) ||
-      (token.find("UICC_LISTEN_TECH_MASK") != std::string::npos) ||
-      (token.find("NXP_ESE_LISTEN_TECH_MASK") != std::string::npos) ||
-      (token.find("POLLING_TECH_MASK") != std::string::npos) ||
-      (token.find("NXP_RF_CONF_BLK") != std::string::npos) ||
-      (token.find("NXP_CN_TRANSIT_BLK_NUM_CHECK_ENABLE") !=
-       std::string::npos) ||
-      (token.find("NXP_FWD_FUNCTIONALITY_ENABLE") != std::string::npos))
-
-  {
-    stat = true;
-  }
-  return stat;
-}
-#endif
-
-/*******************************************************************************
-**
-** Function:    CNfcConfig::moveFromList()
-**
-** Description: move the setting object from list to array
-**
-** Returns:     none
-**
-*******************************************************************************/
-void CNfcConfig::moveFromList() {
-  if (m_list.size() == 0) return;
-
-  for (list<const CNfcParam*>::iterator it = m_list.begin(),
-                                        itEnd = m_list.end();
-       it != itEnd; ++it)
-    push_back(*it);
-  m_list.clear();
-}
-
-/*******************************************************************************
-**
-** Function:    CNfcConfig::moveToList()
-**
-** Description: move the setting object from array to list
-**
-** Returns:     none
-**
-*******************************************************************************/
-void CNfcConfig::moveToList() {
-  if (m_list.size() != 0) m_list.clear();
-
-  for (iterator it = begin(), itEnd = end(); it != itEnd; ++it)
-    m_list.push_back(*it);
-  clear();
-}
-
-/*******************************************************************************
-**
-** Function:    CNfcParam::CNfcParam()
-**
-** Description: class constructor
-**
-** Returns:     none
-**
-*******************************************************************************/
-CNfcParam::CNfcParam() : m_numValue(0) {}
-
-/*******************************************************************************
-**
-** Function:    CNfcParam::~CNfcParam()
-**
-** Description: class destructor
-**
-** Returns:     none
-**
-*******************************************************************************/
-CNfcParam::~CNfcParam() {}
-
-/*******************************************************************************
-**
-** Function:    CNfcParam::CNfcParam()
-**
-** Description: class copy constructor
-**
-** Returns:     none
-**
-*******************************************************************************/
-CNfcParam::CNfcParam(const char* name, const string& value)
-    : string(name), m_str_value(value), m_numValue(0) {}
-
-/*******************************************************************************
-**
-** Function:    CNfcParam::CNfcParam()
-**
-** Description: class copy constructor
-**
-** Returns:     none
-**
-*******************************************************************************/
-CNfcParam::CNfcParam(const char* name, unsigned long value)
-    : string(name), m_numValue(value) {}
-
-/*******************************************************************************
-**
-** Function:    GetStrValue
-**
-** Description: API function for getting a string value of a setting
-**
-** Returns:     none
-**
-*******************************************************************************/
-extern "C" int GetStrValue(const char* name, char* pValue, unsigned long l) {
-  size_t len = l;
-  CNfcConfig& rConfig = CNfcConfig::GetInstance();
-
-  bool b = rConfig.getValue(name, pValue, len);
-  return b ? len : 0;
-}
-
-/*******************************************************************************
-**
-** Function:    GetNumValue
-**
-** Description: API function for getting a numerical value of a setting
-**
-** Returns:     none
-**
-*******************************************************************************/
-extern "C" int GetNumValue(const char* name, void* pValue, unsigned long len) {
-  if (!pValue) return false;
-
-  CNfcConfig& rConfig = CNfcConfig::GetInstance();
-  const CNfcParam* pParam = rConfig.find(name);
-
-  if (pParam == NULL) return false;
-  unsigned long v = pParam->numValue();
-  if (v == 0 && pParam->str_len() > 0 && pParam->str_len() < 4) {
-    const unsigned char* p = (const unsigned char*)pParam->str_value();
-    for (size_t i = 0; i < pParam->str_len(); ++i) {
-      v *= 256;
-      v += *p++;
-    }
-  }
-  switch (len) {
-    case sizeof(unsigned long):
-      *(static_cast<unsigned long*>(pValue)) = (unsigned long)v;
-      break;
-    case sizeof(unsigned short):
-      *(static_cast<unsigned short*>(pValue)) = (unsigned short)v;
-      break;
-    case sizeof(unsigned char):
-      *(static_cast<unsigned char*>(pValue)) = (unsigned char)v;
-      break;
-    default:
-      return false;
-  }
-  return true;
-}
-
-/*******************************************************************************
-**
-** Function:    resetConfig
-**
-** Description: reset settings array
-**
-** Returns:     none
-**
-*******************************************************************************/
-extern void resetConfig() {
-  CNfcConfig& rConfig = CNfcConfig::GetInstance();
-
-  rConfig.clean();
-}
-
-/*******************************************************************************
-**
-** Function:    readOptionalConfig()
-**
-** Description: read Config settings from an optional conf file
-**
-** Returns:     none
-**
-*******************************************************************************/
-void readOptionalConfigExt(const char* extra) {
-  string strPath;
-  string configName(extra_config_base);
-  configName += extra;
-  configName += extra_config_ext;
-
-  findConfigFilePathFromTransportConfigPaths(configName, strPath);
-  CNfcConfig::GetInstance().readConfig(strPath.c_str(), false);
-}
diff --git a/src/adaptation/debug_nfcsnoop.cc b/src/adaptation/debug_nfcsnoop.cc
new file mode 100755
index 0000000..9466b9f
--- /dev/null
+++ b/src/adaptation/debug_nfcsnoop.cc
@@ -0,0 +1,187 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2017 Google Inc.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include <android-base/logging.h>
+#include <resolv.h>
+#include <zlib.h>
+#include <mutex>
+
+#include <ringbuffer.h>
+
+#include "bt_types.h"
+#include "include/debug_nfcsnoop.h"
+#include "nfc_int.h"
+
+#define USEC_PER_SEC 1000000ULL
+
+// Total nfcsnoop memory log buffer size
+#ifndef NFCSNOOP_MEM_BUFFER_SIZE
+static const size_t NFCSNOOP_MEM_BUFFER_SIZE = (256 * 1024);
+#endif
+
+// Block size for copying buffers (for compression/encoding etc.)
+static const size_t BLOCK_SIZE = 16384;
+
+// Maximum line length in bugreport (should be multiple of 4 for base64 output)
+static const uint8_t MAX_LINE_LENGTH = 128;
+
+static std::mutex buffer_mutex;
+static ringbuffer_t* buffer = NULL;
+static uint64_t last_timestamp_ms = 0;
+
+static void nfcsnoop_cb(const uint8_t* data, const size_t length,
+                        bool is_received, const uint64_t timestamp_us) {
+  nfcsnooz_header_t header;
+
+  std::lock_guard<std::mutex> lock(buffer_mutex);
+
+  // Make room in the ring buffer
+
+  while (ringbuffer_available(buffer) < (length + sizeof(nfcsnooz_header_t))) {
+    ringbuffer_pop(buffer, (uint8_t*)&header, sizeof(nfcsnooz_header_t));
+    ringbuffer_delete(buffer, header.length - 1);
+  }
+
+  // Insert data
+  header.length = length;
+  header.is_received = is_received ? 1 : 0;
+
+  uint64_t delta_time_ms = 0;
+  if (last_timestamp_ms) {
+    __builtin_sub_overflow(timestamp_us, last_timestamp_ms, &delta_time_ms);
+  }
+  header.delta_time_ms = delta_time_ms;
+
+  last_timestamp_ms = timestamp_us;
+
+  ringbuffer_insert(buffer, (uint8_t*)&header, sizeof(nfcsnooz_header_t));
+  ringbuffer_insert(buffer, data, length);
+}
+
+static bool nfcsnoop_compress(ringbuffer_t* rb_dst, ringbuffer_t* rb_src) {
+  CHECK(rb_dst != NULL);
+  CHECK(rb_src != NULL);
+
+  z_stream zs;
+  zs.zalloc = Z_NULL;
+  zs.zfree = Z_NULL;
+  zs.opaque = Z_NULL;
+
+  if (deflateInit(&zs, Z_DEFAULT_COMPRESSION) != Z_OK) return false;
+
+  bool rc = true;
+  uint8_t block_src[BLOCK_SIZE];
+  uint8_t block_dst[BLOCK_SIZE];
+
+  const size_t num_blocks =
+      (ringbuffer_size(rb_src) + BLOCK_SIZE - 1) / BLOCK_SIZE;
+  for (size_t i = 0; i < num_blocks; ++i) {
+    zs.avail_in =
+        ringbuffer_peek(rb_src, i * BLOCK_SIZE, block_src, BLOCK_SIZE);
+    zs.next_in = block_src;
+
+    do {
+      zs.avail_out = BLOCK_SIZE;
+      zs.next_out = block_dst;
+
+      int err = deflate(&zs, (i == num_blocks - 1) ? Z_FINISH : Z_NO_FLUSH);
+      if (err == Z_STREAM_ERROR) {
+        rc = false;
+        break;
+      }
+
+      const size_t length = BLOCK_SIZE - zs.avail_out;
+      ringbuffer_insert(rb_dst, block_dst, length);
+    } while (zs.avail_out == 0);
+  }
+
+  deflateEnd(&zs);
+  return rc;
+}
+
+void nfcsnoop_capture(const NFC_HDR* packet, bool is_received) {
+  struct timeval tv;
+  gettimeofday(&tv, NULL);
+  uint64_t timestamp = static_cast<uint64_t>(tv.tv_sec) * USEC_PER_SEC +
+                       static_cast<uint64_t>(tv.tv_usec);
+  uint8_t* p = (uint8_t*)(packet + 1) + packet->offset;
+  uint8_t mt = (*(p)&NCI_MT_MASK) >> NCI_MT_SHIFT;
+
+  if (mt == NCI_MT_DATA) {
+    nfcsnoop_cb(p, NCI_DATA_HDR_SIZE, is_received, timestamp);
+  } else if (packet->len > 2) {
+    nfcsnoop_cb(p, p[2] + NCI_MSG_HDR_SIZE, is_received, timestamp);
+  }
+}
+
+void debug_nfcsnoop_init(void) {
+  if (buffer == NULL) buffer = ringbuffer_init(NFCSNOOP_MEM_BUFFER_SIZE);
+}
+
+void debug_nfcsnoop_dump(int fd) {
+  ringbuffer_t* ringbuffer = ringbuffer_init(NFCSNOOP_MEM_BUFFER_SIZE);
+  if (ringbuffer == NULL) {
+    dprintf(fd, "%s Unable to allocate memory for compression", __func__);
+    return;
+  }
+
+  // Prepend preamble
+
+  nfcsnooz_preamble_t preamble;
+  preamble.version = NFCSNOOZ_CURRENT_VERSION;
+  preamble.last_timestamp_ms = last_timestamp_ms;
+  ringbuffer_insert(ringbuffer, (uint8_t*)&preamble,
+                    sizeof(nfcsnooz_preamble_t));
+
+  // Compress data
+
+  uint8_t b64_in[3] = {0};
+  char b64_out[5] = {0};
+
+  size_t line_length = 0;
+
+  bool rc;
+  {
+    std::lock_guard<std::mutex> lock(buffer_mutex);
+    dprintf(fd, "--- BEGIN:NFCSNOOP_LOG_SUMMARY (%zu bytes in) ---\n",
+            ringbuffer_size(buffer));
+    rc = nfcsnoop_compress(ringbuffer, buffer);
+  }
+
+  if (rc == false) {
+    dprintf(fd, "%s Log compression failed", __func__);
+    goto error;
+  }
+
+  // Base64 encode & output
+
+  while (ringbuffer_size(ringbuffer) > 0) {
+    size_t read = ringbuffer_pop(ringbuffer, b64_in, 3);
+    if (line_length >= MAX_LINE_LENGTH) {
+      dprintf(fd, "\n");
+      line_length = 0;
+    }
+    line_length += b64_ntop(b64_in, read, b64_out, 5);
+    dprintf(fd, "%s", b64_out);
+  }
+
+  dprintf(fd, "\n--- END:NFCSNOOP_LOG_SUMMARY ---\n");
+
+error:
+  ringbuffer_free(ringbuffer);
+}
diff --git a/src/adaptation/libmain.c b/src/adaptation/libmain.cc
old mode 100644
new mode 100755
similarity index 60%
rename from src/adaptation/libmain.c
rename to src/adaptation/libmain.cc
index c4ad050..bac493a
--- a/src/adaptation/libmain.c
+++ b/src/adaptation/libmain.cc
@@ -1,4 +1,5 @@
 /******************************************************************************
+ *
  *  Copyright (c) 2016, The Linux Foundation. All rights reserved.
  *  Not a Contribution.
  *
@@ -17,21 +18,26 @@
  *  limitations under the License.
  *
  ******************************************************************************/
-#include "_OverrideLog.h"
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
 #include <stdlib.h>
-#include <sys/types.h>
-#include <sys/stat.h>
 #include <fcntl.h>
-#include <errno.h>
-#include <nfa_nv_ci.h>
-#include "buildcfg.h"
-#include "nfa_nv_co.h"
-#include "config.h"
-#include "nfc_hal_target.h"
+#include "nfa_nv_ci.h"
 #include "nfc_hal_nv_co.h"
 #include "CrcChecksum.h"
-extern char bcm_nfc_location[];
-static const char* sNfaStorageBin = "/nfaStorage.bin";
+#include <vector>
+
+using android::base::StringPrintf;
+
+extern std::string nfc_storage_path;
+extern bool nfc_debug_enabled;
+
+namespace {
+std::string getFilenameForBlock(const unsigned block) {
+  std::string bin = "nfaStorage.bin";
+  return StringPrintf("%s/%s%u", nfc_storage_path.c_str(), bin.c_str(), block);
+}
+}  // namespace
 
 /*******************************************************************************
 **
@@ -79,34 +85,30 @@ extern void nfa_mem_co_free(void* pBuffer) { free(pBuffer); }
 **
 *******************************************************************************/
 extern void nfa_nv_co_read(uint8_t* pBuffer, uint16_t nbytes, uint8_t block) {
-  char filename[256], filename2[256];
-
-  memset(filename, 0, sizeof(filename));
-  memset(filename2, 0, sizeof(filename2));
-  strlcpy(filename2, bcm_nfc_location, sizeof(filename2));
-  strlcat(filename2, sNfaStorageBin, sizeof(filename2)-strlen(filename2)-1);
-  if (strlen(filename2) > 200) {
-    ALOGE("%s: filename too long", __func__);
-    return;
-  }
-  snprintf (filename, 256, "%s%u", filename2, block);
+  std::string filename = getFilenameForBlock(block);
 
-  ALOGD("%s: buffer len=%u; file=%s", __func__, nbytes, filename);
-  int fileStream = open(filename, O_RDONLY);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: buffer len=%u; file=%s", __func__, nbytes, filename.c_str());
+  int fileStream = open(filename.c_str(), O_RDONLY);
   if (fileStream >= 0) {
     unsigned short checksum = 0;
-    size_t actualReadCrc = read(fileStream, &checksum, sizeof(checksum));
+    int status = read(fileStream, &checksum, sizeof(checksum));
+    if (!status) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: fail to read checksum", __func__);
+      close(fileStream);
+      return;
+    }
     size_t actualReadData = read(fileStream, pBuffer, nbytes);
     close(fileStream);
     if (actualReadData > 0) {
-      ALOGD("%s: data size=%zu", __func__, actualReadData);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: data size=%zu", __func__, actualReadData);
       nfa_nv_ci_read(actualReadData, NFA_NV_CO_OK, block);
     } else {
-      ALOGE("%s: fail to read", __func__);
+      LOG(ERROR) << StringPrintf("%s: fail to read", __func__);
       nfa_nv_ci_read(0, NFA_NV_CO_FAIL, block);
     }
   } else {
-    ALOGD("%s: fail to open", __func__);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: fail to open", __func__);
     nfa_nv_ci_read(0, NFA_NV_CO_FAIL, block);
   }
 }
@@ -132,37 +134,25 @@ extern void nfa_nv_co_read(uint8_t* pBuffer, uint16_t nbytes, uint8_t block) {
 *******************************************************************************/
 extern void nfa_nv_co_write(const uint8_t* pBuffer, uint16_t nbytes,
                             uint8_t block) {
-  char filename[256], filename2[256];
-
-  memset(filename, 0, sizeof(filename));
-  memset(filename2, 0, sizeof(filename2));
-  strlcpy(filename2, bcm_nfc_location, sizeof(filename2));
-  strlcat(filename2, sNfaStorageBin, sizeof(filename2)-strlen(filename2)-1);
-  if (strlen(filename2) > 200) {
-    ALOGE("%s: filename too long", __func__);
-    return;
-  }
-  snprintf (filename, 256, "%s%u", filename2, block);
-  ALOGD("%s: bytes=%u; file=%s", __func__, nbytes, filename);
-
-  int fileStream = 0;
+  std::string filename = getFilenameForBlock(block);
 
-  fileStream = open(filename, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
+  int fileStream =
+      open(filename.c_str(), O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
   if (fileStream >= 0) {
     unsigned short checksum = crcChecksumCompute(pBuffer, nbytes);
     size_t actualWrittenCrc = write(fileStream, &checksum, sizeof(checksum));
     size_t actualWrittenData = write(fileStream, pBuffer, nbytes);
-    ALOGD("%s: %zu bytes written", __func__, actualWrittenData);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: %zu bytes written", __func__, actualWrittenData);
     if ((actualWrittenData == nbytes) &&
         (actualWrittenCrc == sizeof(checksum))) {
       nfa_nv_ci_write(NFA_NV_CO_OK);
     } else {
-      ALOGE("%s: fail to write", __func__);
+      LOG(ERROR) << StringPrintf("%s: fail to write", __func__);
       nfa_nv_ci_write(NFA_NV_CO_FAIL);
     }
     close(fileStream);
   } else {
-    ALOGE("%s: fail to open, error = %d", __func__, errno);
+    LOG(ERROR) << StringPrintf("%s: fail to open, error = %d", __func__, errno);
     nfa_nv_ci_write(NFA_NV_CO_FAIL);
   }
 }
@@ -180,31 +170,17 @@ extern void nfa_nv_co_write(const uint8_t* pBuffer, uint16_t nbytes,
 *******************************************************************************/
 void delete_stack_non_volatile_store(bool forceDelete) {
   static bool firstTime = true;
-  char filename[256], filename2[256];
 
   if ((firstTime == false) && (forceDelete == false)) return;
   firstTime = false;
 
-  ALOGD("%s", __func__);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
 
-  memset(filename, 0, sizeof(filename));
-  memset(filename2, 0, sizeof(filename2));
-  strlcpy(filename2, bcm_nfc_location, sizeof(filename2));
-  strlcat(filename2, sNfaStorageBin, sizeof(filename2)-strlen(filename2)-1);
-  if (strlen(filename2) > 200) {
-    ALOGE("%s: filename too long", __func__);
-    return;
-  }
-  snprintf (filename, 256, "%s%u", filename2, DH_NV_BLOCK);
-  remove(filename);
-  snprintf (filename, 256, "%s%u", filename2, HC_F3_NV_BLOCK);
-  remove(filename);
-  snprintf (filename, 256, "%s%u", filename2, HC_F4_NV_BLOCK);
-  remove(filename);
-  snprintf (filename, 256, "%s%u", filename2, HC_F2_NV_BLOCK);
-  remove(filename);
-  snprintf (filename, 256, "%s%u", filename2, HC_F5_NV_BLOCK);
-  remove(filename);
+  remove(getFilenameForBlock(DH_NV_BLOCK).c_str());
+  remove(getFilenameForBlock(HC_F2_NV_BLOCK).c_str());
+  remove(getFilenameForBlock(HC_F3_NV_BLOCK).c_str());
+  remove(getFilenameForBlock(HC_F4_NV_BLOCK).c_str());
+  remove(getFilenameForBlock(HC_F5_NV_BLOCK).c_str());
 }
 
 /*******************************************************************************
@@ -219,33 +195,16 @@ void delete_stack_non_volatile_store(bool forceDelete) {
 **
 *******************************************************************************/
 void verify_stack_non_volatile_store() {
-  ALOGD("%s", __func__);
-  char filename[256], filename2[256];
-  bool isValid = false;
-
-  memset(filename, 0, sizeof(filename));
-  memset(filename2, 0, sizeof(filename2));
-  strlcpy(filename2, bcm_nfc_location, sizeof(filename2));
-  strlcat(filename2, sNfaStorageBin, sizeof(filename2)-strlen(filename2)-1);
-  if (strlen(filename2) > 200) {
-    ALOGE("%s: filename too long", __func__);
-    return;
-  }
-
-  snprintf (filename, 256, "%s%u", filename2, DH_NV_BLOCK);
-  if (crcChecksumVerifyIntegrity(filename)) {
-    snprintf (filename, 256, "%s%u", filename2, HC_F3_NV_BLOCK);
-    if (crcChecksumVerifyIntegrity(filename)) {
-      snprintf (filename, 256, "%s%u", filename2, HC_F4_NV_BLOCK);
-      if (crcChecksumVerifyIntegrity(filename)) {
-        snprintf (filename, 256, "%s%u", filename2, HC_F2_NV_BLOCK);
-        if (crcChecksumVerifyIntegrity(filename)) {
-          snprintf (filename, 256, "%s%u", filename2, HC_F5_NV_BLOCK);
-          if (crcChecksumVerifyIntegrity(filename)) isValid = true;
-        }
-      }
-    }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
+  const std::vector<unsigned> verify_blocks = {DH_NV_BLOCK, HC_F2_NV_BLOCK,
+                                               HC_F3_NV_BLOCK, HC_F4_NV_BLOCK,
+                                               HC_F5_NV_BLOCK};
+
+  size_t verified = 0;
+  for (auto block : verify_blocks) {
+    if (!crcChecksumVerifyIntegrity(getFilenameForBlock(block).c_str())) break;
+    ++verified;
   }
 
-  if (isValid == false) delete_stack_non_volatile_store(true);
+  if (verified != verify_blocks.size()) delete_stack_non_volatile_store(true);
 }
diff --git a/src/adaptation/nfc_config.cc b/src/adaptation/nfc_config.cc
new file mode 100755
index 0000000..bb7e6b4
--- /dev/null
+++ b/src/adaptation/nfc_config.cc
@@ -0,0 +1,103 @@
+/*
+ * Copyright 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include "nfc_config.h"
+#include "NfcAdaptation.h"
+
+#include <android-base/file.h>
+#include <android-base/logging.h>
+#include <android-base/parseint.h>
+#include <android-base/strings.h>
+
+#include <config.h>
+
+using namespace ::std;
+using namespace ::android::base;
+#define PATH_TRANSIT_CONF "/data/nfc/libnfc-nxpTransit.conf"
+namespace {
+
+std::string findConfigPath() {
+  const vector<string> search_path = {"/odm/etc/", "/vendor/etc/",
+                                      "/product/etc/", "/etc/"};
+  const string file_name = "libnfc-nci.conf";
+
+  for (string path : search_path) {
+    path.append(file_name);
+    struct stat file_stat;
+    if (stat(path.c_str(), &file_stat) != 0) continue;
+    if (S_ISREG(file_stat.st_mode)) return path;
+  }
+  return "";
+}
+
+}  // namespace
+
+void NfcConfig::loadConfig() {
+  string config_path = findConfigPath();
+  CHECK(config_path != "");
+  config_.parseFromFile(config_path);
+  struct stat file_stat;
+  /* Read Transit configs if available */
+  if (stat(PATH_TRANSIT_CONF, &file_stat) == 0)
+    config_.parseFromFile(PATH_TRANSIT_CONF);
+  /* Read vendor specific configs */
+  NfcAdaptation& theInstance = NfcAdaptation::GetInstance();
+  std::map<std::string, ConfigValue> configMap;
+  theInstance.GetVendorConfigs(configMap);
+  theInstance.GetNxpConfigs(configMap);
+  for (auto config : configMap) {
+    config_.addConfig(config.first, config.second);
+  }
+}
+
+NfcConfig::NfcConfig() { loadConfig(); }
+
+NfcConfig& NfcConfig::getInstance() {
+  static NfcConfig theInstance;
+  if (theInstance.config_.isEmpty()) {
+    theInstance.loadConfig();
+  }
+  return theInstance;
+}
+
+bool NfcConfig::hasKey(const std::string& key) {
+  return getInstance().config_.hasKey(key);
+}
+
+std::string NfcConfig::getString(const std::string& key) {
+  return getInstance().config_.getString(key);
+}
+
+std::string NfcConfig::getString(const std::string& key,
+                                 std::string default_value) {
+  if (hasKey(key)) return getString(key);
+  return default_value;
+}
+
+unsigned NfcConfig::getUnsigned(const std::string& key) {
+  return getInstance().config_.getUnsigned(key);
+}
+
+unsigned NfcConfig::getUnsigned(const std::string& key,
+                                unsigned default_value) {
+  if (hasKey(key)) return getUnsigned(key);
+  return default_value;
+}
+
+std::vector<uint8_t> NfcConfig::getBytes(const std::string& key) {
+  return getInstance().config_.getBytes(key);
+}
+
+void NfcConfig::clear() { getInstance().config_.clear(); }
\ No newline at end of file
diff --git a/src/gki/common/gki.h b/src/gki/common/gki.h
index bc05315..17521bc 100644
--- a/src/gki/common/gki.h
+++ b/src/gki/common/gki.h
@@ -26,12 +26,10 @@
 #define NFC_STANDALONE false
 #endif
 
+#include <string>
 #include "bt_types.h"
 #include "gki_target.h"
 
-/* Uncomment this line for verbose GKI debugging and buffer tracking */
-#define GKI_BUFFER_DEBUG false
-
 /* Error codes */
 #define GKI_SUCCESS 0x00
 #define GKI_FAILURE 0x01
@@ -43,9 +41,7 @@
 ** send buffers to the task.
 */
 #define TASK_MBOX_0 0
-#define TASK_MBOX_1 1
 #define TASK_MBOX_2 2
-#define TASK_MBOX_3 3
 
 #define NUM_TASK_MBOX 4
 
@@ -56,7 +52,6 @@
 ** There are 4 reserved events used to signal timeout events.
 ** There are 8 general purpose events available for applications.
 */
-#define MAX_EVENTS 16
 
 #define TASK_MBOX_0_EVT_MASK 0x0001
 #define TASK_MBOX_1_EVT_MASK 0x0002
@@ -74,14 +69,8 @@
 #define TIMER_3_EVT_MASK 0x0080
 
 #define APPL_EVT_0 8
-#define APPL_EVT_1 9
-#define APPL_EVT_2 10
-#define APPL_EVT_3 11
-#define APPL_EVT_4 12
-#define APPL_EVT_5 13
 #define APPL_EVT_6 14
 #define APPL_EVT_7 15
-
 #define EVENT_MASK(evt) ((uint16_t)(0x0001 << (evt)))
 
 /************************************************************************
@@ -298,25 +287,29 @@
 
 #endif /* GKI_NUM_FIXED_BUF_POOLS < 16 */
 
+#ifndef GKI_UNKNOWN_TASK_EVT
+#define GKI_UNKNOWN_TASK_EVT APPL_EVT_6
+#endif
 #ifndef GKI_SHUTDOWN_EVT
 #define GKI_SHUTDOWN_EVT APPL_EVT_7
 #endif
 
 /* Timer list entry callback type
 */
-typedef void(TIMER_CBACK)(void* p_tle);
+struct TIMER_LIST_ENT;
+typedef void(TIMER_CBACK)(TIMER_LIST_ENT* p_tle);
 
 /* Define a timer list entry
 */
-typedef struct _tle {
-  struct _tle* p_next;
-  struct _tle* p_prev;
+struct TIMER_LIST_ENT {
+  TIMER_LIST_ENT* p_next;
+  TIMER_LIST_ENT* p_prev;
   TIMER_CBACK* p_cback;
   int32_t ticks;
   uintptr_t param;
   uint16_t event;
   uint8_t in_use;
-} TIMER_LIST_ENT;
+};
 
 /* Define a timer list queue
 */
@@ -335,26 +328,19 @@ typedef struct {
   uint16_t count;
 } BUFFER_Q;
 
-#define GKI_IS_QUEUE_EMPTY(p_q) ((p_q)->count == 0)
-
 /* Task constants
 */
 #ifndef TASKPTR
-typedef void (*TASKPTR)(uint32_t);
+typedef uint32_t (*TASKPTR)(uint32_t);
 #endif
 
 /* General pool accessible to GKI_getbuf() */
-#define GKI_PUBLIC_POOL 0
 #define GKI_RESTRICTED_POOL 1 /* Inaccessible pool to GKI_getbuf() */
 
 /***********************************************************************
 ** Function prototypes
 */
 
-#ifdef __cplusplus
-extern "C" {
-#endif
-
 /* Task management
 */
 extern uint8_t GKI_create_task(TASKPTR, uint8_t, int8_t*, uint16_t*, uint16_t,
@@ -367,7 +353,6 @@ extern uint8_t GKI_resume_task(uint8_t);
 extern void GKI_run(void*);
 extern void GKI_stop(void);
 extern uint8_t GKI_suspend_task(uint8_t);
-extern uint8_t GKI_is_task_running(uint8_t);
 
 /* memory management
 */
@@ -389,19 +374,9 @@ extern uint8_t GKI_create_pool(uint16_t, uint16_t, uint8_t, void*);
 extern void GKI_delete_pool(uint8_t);
 extern void* GKI_find_buf_start(void*);
 extern void GKI_freebuf(void*);
-#if (GKI_BUFFER_DEBUG == true)
-#define GKI_getbuf(size) GKI_getbuf_debug(size, __func__, __LINE__)
-extern void* GKI_getbuf_debug(uint16_t, const char*, int);
-#else
 extern void* GKI_getbuf(uint16_t);
-#endif
 extern uint16_t GKI_get_buf_size(void*);
-#if (GKI_BUFFER_DEBUG == true)
-#define GKI_getpoolbuf(id) GKI_getpoolbuf_debug(id, __func__, __LINE__)
-extern void* GKI_getpoolbuf_debug(uint8_t, const char*, int);
-#else
 extern void* GKI_getpoolbuf(uint8_t);
-#endif
 
 extern uint16_t GKI_poolcount(uint8_t);
 extern uint16_t GKI_poolfreecount(uint8_t);
@@ -467,19 +442,6 @@ extern uint32_t GKI_get_os_tick_count(void);
 
 /* Exception handling
 */
-extern void GKI_exception(uint16_t, char*);
-
-#if (GKI_BUFFER_DEBUG == true)
-extern void GKI_PrintBufferUsage(uint8_t* p_num_pools, uint16_t* p_cur_used);
-extern void GKI_PrintBuffer(void);
-extern void GKI_print_task(void);
-#else
-#undef GKI_PrintBufferUsage
-#define GKI_PrintBuffer() NULL
-#endif
-
-#ifdef __cplusplus
-}
-#endif
+extern void GKI_exception(uint16_t, std::string);
 
 #endif
diff --git a/src/gki/common/gki_buffer.c b/src/gki/common/gki_buffer.cc
old mode 100644
new mode 100755
similarity index 82%
rename from src/gki/common/gki_buffer.c
rename to src/gki/common/gki_buffer.cc
index 09f49e0..5b5ae34
--- a/src/gki/common/gki_buffer.c
+++ b/src/gki/common/gki_buffer.cc
@@ -1,4 +1,5 @@
 /******************************************************************************
+ *
  *  Copyright (c) 2016, The Linux Foundation. All rights reserved.
  *  Not a Contribution.
  *
@@ -17,8 +18,9 @@
  *  limitations under the License.
  *
  ******************************************************************************/
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
 #include "gki_int.h"
-#include <stdio.h>
 
 #if (GKI_NUM_TOTAL_BUF_POOLS > 16)
 #error Number of pools out of range (16 Max)!
@@ -29,15 +31,8 @@ static void gki_add_to_pool_list(uint8_t pool_id);
 static void gki_remove_from_pool_list(uint8_t pool_id);
 #endif /*  BTU_STACK_LITE_ENABLED == false */
 
-#if (GKI_BUFFER_DEBUG == true)
-#define LOG_TAG "GKI_DEBUG"
-#include <android/log.h>
-#include <cutils/log.h>
-#define LOGD(format, ...)                                       \
-  LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_GKI | TRACE_ORG_GKI | \
-             TRACE_TYPE_GENERIC,                                \
-         format, ##__VA_ARGS__)
-#endif
+using android::base::StringPrintf;
+
 /*******************************************************************************
 **
 ** Function         gki_init_free_queue
@@ -75,13 +70,6 @@ static void gki_init_free_queue(uint8_t id, uint16_t size, uint16_t total,
   p_cb->freeq[id].cur_cnt = 0;
   p_cb->freeq[id].max_cnt = 0;
 
-#if (GKI_BUFFER_DEBUG == true)
-  LOGD(
-      "gki_init_free_queue() init pool=%d, size=%d (aligned=%d) total=%d "
-      "start=%p",
-      id, size, tempsize, total, p_mem);
-#endif
-
   /* Initialize  index table */
   if (p_mem) {
     hdr = (BUFFER_HDR_T*)p_mem;
@@ -103,13 +91,9 @@ static void gki_init_free_queue(uint8_t id, uint16_t size, uint16_t total,
   return;
 }
 
-#if (GKI_USE_DEFERED_ALLOC_BUF_POOLS == true)
 static bool gki_alloc_free_queue(uint8_t id) {
   FREE_QUEUE_T* Q;
   tGKI_COM_CB* p_cb = &gki_cb.com;
-#if (GKI_BUFFER_DEBUG == true)
-  ALOGD("\ngki_alloc_free_queue in, id:%d \n", id);
-#endif
 
   Q = &p_cb->freeq[p_cb->pool_list[id]];
 
@@ -117,28 +101,14 @@ static bool gki_alloc_free_queue(uint8_t id) {
     void* p_mem = GKI_os_malloc((Q->size + BUFFER_PADDING_SIZE) * Q->total);
     if (p_mem) {
 // re-initialize the queue with allocated memory
-#if (GKI_BUFFER_DEBUG == true)
-      ALOGD(
-          "\ngki_alloc_free_queue calling  gki_init_free_queue, id:%d  "
-          "size:%d, totol:%d\n",
-          id, Q->size, Q->total);
-#endif
       gki_init_free_queue(id, Q->size, Q->total, p_mem);
-#if (GKI_BUFFER_DEBUG == true)
-      ALOGD("\ngki_alloc_free_queue ret OK, id:%d  size:%d, totol:%d\n", id,
-            Q->size, Q->total);
-#endif
       return true;
     }
     GKI_exception(GKI_ERROR_BUF_SIZE_TOOBIG,
                   "gki_alloc_free_queue: Not enough memory");
   }
-#if (GKI_BUFFER_DEBUG == true)
-  ALOGD("\ngki_alloc_free_queue out failed, id:%d\n", id);
-#endif
   return false;
 }
-#endif
 
 /*******************************************************************************
 **
@@ -178,91 +148,6 @@ void gki_buffer_init(void) {
   /* Use default from target.h */
   p_cb->pool_access_mask = GKI_DEF_BUFPOOL_PERM_MASK;
 
-#if (GKI_USE_DEFERED_ALLOC_BUF_POOLS == false && \
-     GKI_USE_DYNAMIC_BUFFERS == true)
-
-#if (GKI_NUM_FIXED_BUF_POOLS > 0)
-  p_cb->bufpool0 = (uint8_t*)GKI_os_malloc(
-      (GKI_BUF0_SIZE + BUFFER_PADDING_SIZE) * GKI_BUF0_MAX);
-#endif
-
-#if (GKI_NUM_FIXED_BUF_POOLS > 1)
-  p_cb->bufpool1 = (uint8_t*)GKI_os_malloc(
-      (GKI_BUF1_SIZE + BUFFER_PADDING_SIZE) * GKI_BUF1_MAX);
-#endif
-
-#if (GKI_NUM_FIXED_BUF_POOLS > 2)
-  p_cb->bufpool2 = (uint8_t*)GKI_os_malloc(
-      (GKI_BUF2_SIZE + BUFFER_PADDING_SIZE) * GKI_BUF2_MAX);
-#endif
-
-#if (GKI_NUM_FIXED_BUF_POOLS > 3)
-  p_cb->bufpool3 = (uint8_t*)GKI_os_malloc(
-      (GKI_BUF3_SIZE + BUFFER_PADDING_SIZE) * GKI_BUF3_MAX);
-#endif
-
-#if (GKI_NUM_FIXED_BUF_POOLS > 4)
-  p_cb->bufpool4 = (uint8_t*)GKI_os_malloc(
-      (GKI_BUF4_SIZE + BUFFER_PADDING_SIZE) * GKI_BUF4_MAX);
-#endif
-
-#if (GKI_NUM_FIXED_BUF_POOLS > 5)
-  p_cb->bufpool5 = (uint8_t*)GKI_os_malloc(
-      (GKI_BUF5_SIZE + BUFFER_PADDING_SIZE) * GKI_BUF5_MAX);
-#endif
-
-#if (GKI_NUM_FIXED_BUF_POOLS > 6)
-  p_cb->bufpool6 = (uint8_t*)GKI_os_malloc(
-      (GKI_BUF6_SIZE + BUFFER_PADDING_SIZE) * GKI_BUF6_MAX);
-#endif
-
-#if (GKI_NUM_FIXED_BUF_POOLS > 7)
-  p_cb->bufpool7 = (uint8_t*)GKI_os_malloc(
-      (GKI_BUF7_SIZE + BUFFER_PADDING_SIZE) * GKI_BUF7_MAX);
-#endif
-
-#if (GKI_NUM_FIXED_BUF_POOLS > 8)
-  p_cb->bufpool8 = (uint8_t*)GKI_os_malloc(
-      (GKI_BUF8_SIZE + BUFFER_PADDING_SIZE) * GKI_BUF8_MAX);
-#endif
-
-#if (GKI_NUM_FIXED_BUF_POOLS > 9)
-  p_cb->bufpool9 = (uint8_t*)GKI_os_malloc(
-      (GKI_BUF9_SIZE + BUFFER_PADDING_SIZE) * GKI_BUF9_MAX);
-#endif
-
-#if (GKI_NUM_FIXED_BUF_POOLS > 10)
-  p_cb->bufpool10 = (uint8_t*)GKI_os_malloc(
-      (GKI_BUF10_SIZE + BUFFER_PADDING_SIZE) * GKI_BUF10_MAX);
-#endif
-
-#if (GKI_NUM_FIXED_BUF_POOLS > 11)
-  p_cb->bufpool11 = (uint8_t*)GKI_os_malloc(
-      (GKI_BUF11_SIZE + BUFFER_PADDING_SIZE) * GKI_BUF11_MAX);
-#endif
-
-#if (GKI_NUM_FIXED_BUF_POOLS > 12)
-  p_cb->bufpool12 = (uint8_t*)GKI_os_malloc(
-      (GKI_BUF12_SIZE + BUFFER_PADDING_SIZE) * GKI_BUF12_MAX);
-#endif
-
-#if (GKI_NUM_FIXED_BUF_POOLS > 13)
-  p_cb->bufpool13 = (uint8_t*)GKI_os_malloc(
-      (GKI_BUF13_SIZE + BUFFER_PADDING_SIZE) * GKI_BUF13_MAX);
-#endif
-
-#if (GKI_NUM_FIXED_BUF_POOLS > 14)
-  p_cb->bufpool14 = (uint8_t*)GKI_os_malloc(
-      (GKI_BUF14_SIZE + BUFFER_PADDING_SIZE) * GKI_BUF14_MAX);
-#endif
-
-#if (GKI_NUM_FIXED_BUF_POOLS > 15)
-  p_cb->bufpool15 = (uint8_t*)GKI_os_malloc(
-      (GKI_BUF15_SIZE + BUFFER_PADDING_SIZE) * GKI_BUF15_MAX);
-#endif
-
-#endif
-
 #if (GKI_NUM_FIXED_BUF_POOLS > 0)
   gki_init_free_queue(0, GKI_BUF0_SIZE, GKI_BUF0_MAX, p_cb->bufpool0);
 #endif
@@ -369,28 +254,17 @@ void GKI_init_q(BUFFER_Q* p_q) {
 ** Returns          A pointer to the buffer, or NULL if none available
 **
 *******************************************************************************/
-#if (GKI_BUFFER_DEBUG == true)
-void* GKI_getbuf_debug(uint16_t size, const char* _function_, int _line_)
-#else
-void* GKI_getbuf(uint16_t size)
-#endif
-{
+void* GKI_getbuf(uint16_t size) {
   uint8_t i;
   FREE_QUEUE_T* Q;
   BUFFER_HDR_T* p_hdr;
   tGKI_COM_CB* p_cb = &gki_cb.com;
-#if (GKI_BUFFER_DEBUG == true)
-  uint8_t x;
-#endif
 
   if (size == 0) {
     GKI_exception(GKI_ERROR_BUF_SIZE_ZERO, "getbuf: Size is zero");
     return (NULL);
   }
 
-#if (GKI_BUFFER_DEBUG == true)
-  LOGD("GKI_getbuf() requesting %d func:%s(line=%d)", size, _function_, _line_);
-#endif
   /* Find the first buffer pool that is public that can hold the desired size */
   for (i = 0; i < p_cb->curr_total_no_of_pools; i++) {
     if (size <= p_cb->freeq[p_cb->pool_list[i]].size) break;
@@ -412,17 +286,15 @@ void* GKI_getbuf(uint16_t size)
 
     Q = &p_cb->freeq[p_cb->pool_list[i]];
     if (Q->cur_cnt < Q->total) {
-#if (GKI_USE_DEFERED_ALLOC_BUF_POOLS == true)
       if (Q->p_first == 0 && gki_alloc_free_queue(i) != true) {
-        GKI_TRACE_ERROR_0("GKI_getbuf() out of buffer");
+        LOG(ERROR) << StringPrintf("out of buffer");
         GKI_enable();
         return NULL;
       }
-#endif
 
       if (Q->p_first == 0) {
         /* gki_alloc_free_queue() failed to alloc memory */
-        GKI_TRACE_ERROR_0("GKI_getbuf() fail alloc free queue");
+        LOG(ERROR) << StringPrintf("fail alloc free queue");
         GKI_enable();
         return NULL;
       }
@@ -441,48 +313,11 @@ void* GKI_getbuf(uint16_t size)
       p_hdr->status = BUF_STATUS_UNLINKED;
       p_hdr->p_next = NULL;
       p_hdr->Type = 0;
-#if (GKI_BUFFER_DEBUG == true)
-      LOGD("GKI_getbuf() allocated, %x, %x (%d of %d used) %d",
-           (uint8_t*)p_hdr + BUFFER_HDR_SIZE, p_hdr, Q->cur_cnt, Q->total,
-           p_cb->freeq[i].total);
-
-      strlcpy(p_hdr->_function, _function_, _GKI_MAX_FUNCTION_NAME_LEN);
-      p_hdr->_function[_GKI_MAX_FUNCTION_NAME_LEN] = '\0';
-      p_hdr->_line = _line_;
-#endif
       return ((void*)((uint8_t*)p_hdr + BUFFER_HDR_SIZE));
     }
   }
 
-  GKI_TRACE_ERROR_0("GKI_getbuf() unable to allocate buffer!!!!!");
-#if (GKI_BUFFER_DEBUG == true)
-  LOGD("GKI_getbuf() unable to allocate buffer!!!!!");
-  LOGD("******************** GKI Memory Pool Dump ********************");
-
-  p_cb = &gki_cb.com;
-
-  LOGD("Dumping total of %d buffer pools", p_cb->curr_total_no_of_pools);
-
-  for (i = 0; i < p_cb->curr_total_no_of_pools; i++) {
-    p_hdr = (BUFFER_HDR_T*)p_cb->pool_start[i];
-
-    LOGD("pool %d has a total of %d buffers (start=%p)", i,
-         p_cb->freeq[i].total, p_hdr);
-
-    for (x = 0; p_hdr && x < p_cb->freeq[i].total; x++) {
-      if (p_hdr->status != BUF_STATUS_FREE) {
-        LOGD("pool:%d, buf[%d]:%x, hdr:%x status=%d func:%s(line=%d)", i, x,
-             (uint8_t*)p_hdr + BUFFER_HDR_SIZE, p_hdr, p_hdr->status,
-             p_hdr->_function, p_hdr->_line);
-      }
-
-      p_hdr = (BUFFER_HDR_T*)((uint8_t*)p_hdr + p_cb->pool_size[i]);
-    }
-  }
-  LOGD("**************************************************************");
-#endif
-
-  GKI_TRACE_ERROR_0("Failed to allocate GKI buffer");
+  LOG(ERROR) << StringPrintf("unable to allocate buffer!!!!!");
 
   GKI_enable();
 
@@ -505,34 +340,23 @@ void* GKI_getbuf(uint16_t size)
 ** Returns          A pointer to the buffer, or NULL if none available
 **
 *******************************************************************************/
-#if (GKI_BUFFER_DEBUG == true)
-void* GKI_getpoolbuf_debug(uint8_t pool_id, const char* _function_, int _line_)
-#else
-void* GKI_getpoolbuf(uint8_t pool_id)
-#endif
-{
+void* GKI_getpoolbuf(uint8_t pool_id) {
   FREE_QUEUE_T* Q;
   BUFFER_HDR_T* p_hdr;
   tGKI_COM_CB* p_cb = &gki_cb.com;
 
   if (pool_id >= GKI_NUM_TOTAL_BUF_POOLS) return (NULL);
 
-#if (GKI_BUFFER_DEBUG == true)
-  LOGD("GKI_getpoolbuf() requesting from %d func:%s(line=%d)", pool_id,
-       _function_, _line_);
-#endif
   /* Make sure the buffers aren't disturbed til finished with allocation */
   GKI_disable();
 
   Q = &p_cb->freeq[pool_id];
   if (Q->cur_cnt < Q->total) {
-#if (GKI_USE_DEFERED_ALLOC_BUF_POOLS == true)
     if (Q->p_first == 0 && gki_alloc_free_queue(pool_id) != true) return NULL;
-#endif
 
     if (Q->p_first == 0) {
       /* gki_alloc_free_queue() failed to alloc memory */
-      GKI_TRACE_ERROR_0("GKI_getpoolbuf() fail alloc free queue");
+      LOG(ERROR) << StringPrintf("fail alloc free queue");
       return NULL;
     }
 
@@ -551,28 +375,14 @@ void* GKI_getpoolbuf(uint8_t pool_id)
     p_hdr->p_next = NULL;
     p_hdr->Type = 0;
 
-#if (GKI_BUFFER_DEBUG == true)
-    LOGD("GKI_getpoolbuf() allocated, %x, %x (%d of %d used) %d",
-         (uint8_t*)p_hdr + BUFFER_HDR_SIZE, p_hdr, Q->cur_cnt, Q->total,
-         p_cb->freeq[pool_id].total);
-
-    strlcpy(p_hdr->_function, _function_, _GKI_MAX_FUNCTION_NAME_LEN);
-    p_hdr->_function[_GKI_MAX_FUNCTION_NAME_LEN] = '\0';
-    p_hdr->_line = _line_;
-#endif
     return ((void*)((uint8_t*)p_hdr + BUFFER_HDR_SIZE));
   }
 
   /* If here, no buffers in the specified pool */
   GKI_enable();
 
-#if (GKI_BUFFER_DEBUG == true)
-  /* try for free buffers in public pools */
-  return (GKI_getbuf_debug(p_cb->freeq[pool_id].size, _function_, _line_));
-#else
   /* try for free buffers in public pools */
   return (GKI_getbuf(p_cb->freeq[pool_id].size));
-#endif
 }
 
 /*******************************************************************************
@@ -600,11 +410,6 @@ void GKI_freebuf(void* p_buf) {
 
   p_hdr = (BUFFER_HDR_T*)((uint8_t*)p_buf - BUFFER_HDR_SIZE);
 
-#if (GKI_BUFFER_DEBUG == true)
-  LOGD("GKI_freebuf() freeing, %x, %x, func:%s(line=%d)", p_buf, p_hdr,
-       p_hdr->_function, p_hdr->_line);
-#endif
-
   if (p_hdr->status != BUF_STATUS_UNLINKED) {
     GKI_exception(GKI_ERROR_FREEBUF_BUF_LINKED, "Freeing Linked Buf");
     return;
@@ -651,9 +456,12 @@ void GKI_freebuf(void* p_buf) {
 uint16_t GKI_get_buf_size(void* p_buf) {
   BUFFER_HDR_T* p_hdr;
 
+
   p_hdr = (BUFFER_HDR_T*)((uint8_t*)p_buf - BUFFER_HDR_SIZE);
 
-  if ((uint32_t)p_hdr & 1) return (0);
+  if ((uintptr_t)p_hdr & 1){
+    return (0);
+  }
 
   if (p_hdr->q_id < GKI_NUM_TOTAL_BUF_POOLS) {
     return (gki_cb.com.freeq[p_hdr->q_id].size);
@@ -677,7 +485,9 @@ bool gki_chk_buf_damage(void* p_buf) {
   uint32_t* magic;
   magic = (uint32_t*)((uint8_t*)p_buf + GKI_get_buf_size(p_buf));
 
-  if ((uint32_t)magic & 1) return (true);
+  if ((uintptr_t)magic & 1){
+    return (true);
+  }
 
   if (*magic == MAGIC_NO) return (false);
 
@@ -1171,45 +981,6 @@ static void gki_remove_from_pool_list(uint8_t pool_id) {
   return;
 }
 
-/*******************************************************************************
-**
-** Function         GKI_igetpoolbuf
-**
-** Description      Called by an interrupt service routine to get a free buffer
-**                  from a specific buffer pool.
-**
-** Parameters       pool_id - (input) pool ID to get a buffer out of.
-**
-** Returns          A pointer to the buffer, or NULL if none available
-**
-*******************************************************************************/
-void* GKI_igetpoolbuf(uint8_t pool_id) {
-  FREE_QUEUE_T* Q;
-  BUFFER_HDR_T* p_hdr;
-
-  if (pool_id >= GKI_NUM_TOTAL_BUF_POOLS) return (NULL);
-
-  Q = &gki_cb.com.freeq[pool_id];
-  if (Q->cur_cnt < Q->total) {
-    p_hdr = Q->p_first;
-    Q->p_first = p_hdr->p_next;
-
-    if (!Q->p_first) Q->p_last = NULL;
-
-    if (++Q->cur_cnt > Q->max_cnt) Q->max_cnt = Q->cur_cnt;
-
-    p_hdr->task_id = GKI_get_taskid();
-
-    p_hdr->status = BUF_STATUS_UNLINKED;
-    p_hdr->p_next = NULL;
-    p_hdr->Type = 0;
-
-    return ((void*)((uint8_t*)p_hdr + BUFFER_HDR_SIZE));
-  }
-
-  return (NULL);
-}
-
 /*******************************************************************************
 **
 ** Function         GKI_poolcount
diff --git a/src/gki/common/gki_common.h b/src/gki/common/gki_common.h
old mode 100644
new mode 100755
index c4592cb..a1d2b6c
--- a/src/gki/common/gki_common.h
+++ b/src/gki/common/gki_common.h
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -39,16 +39,9 @@
 
 #include "gki.h"
 
-#ifndef GKI_DEBUG
-#define GKI_DEBUG false
-#endif
-
 /* Task States: (For OSRdyTbl) */
 #define TASK_DEAD 0    /* b0000 */
 #define TASK_READY 1   /* b0001 */
-#define TASK_WAIT 2    /* b0010 */
-#define TASK_DELAY 4   /* b0100 */
-#define TASK_SUSPEND 8 /* b1000 */
 
 /********************************************************************
 **  Internal Error codes
@@ -63,14 +56,12 @@
 #define GKI_ERROR_DELETE_POOL_BAD_QID 0xFFF8
 #define GKI_ERROR_BUF_SIZE_TOOBIG 0xFFF7
 #define GKI_ERROR_BUF_SIZE_ZERO 0xFFF6
-#define GKI_ERROR_ADDR_NOT_IN_BUF 0xFFF5
 
 /********************************************************************
 **  Misc constants
 *********************************************************************/
 
 #define GKI_MAX_INT32 (0x7fffffffL)
-#define GKI_MAX_TIMESTAMP (0xffffffffL)
 
 /********************************************************************
 **  Buffer Management Data Structures
@@ -82,14 +73,6 @@ typedef struct _buffer_hdr {
   uint8_t task_id;            /* task which allocated the buffer*/
   uint8_t status;             /* FREE, UNLINKED or QUEUED */
   uint8_t Type;
-
-#if (GKI_BUFFER_DEBUG == true)
-/* for tracking who allocated the buffer */
-#define _GKI_MAX_FUNCTION_NAME_LEN (50)
-  char _function[_GKI_MAX_FUNCTION_NAME_LEN + 1];
-  int _line;
-#endif
-
 } BUFFER_HDR_T;
 
 typedef struct _free_queue {
@@ -122,18 +105,6 @@ typedef struct _free_queue {
 #define BUF_STATUS_UNLINKED 1
 #define BUF_STATUS_QUEUED 2
 
-#define GKI_USE_DEFERED_ALLOC_BUF_POOLS true
-
-/* Exception related structures (Used in debug mode only)
-*/
-#if (GKI_DEBUG == true)
-typedef struct {
-  uint16_t type;
-  uint8_t taskid;
-  uint8_t msg[GKI_MAX_EXCEPTION_MSGLEN];
-} EXCEPTION_T;
-#endif
-
 /* Put all GKI variables into one control block
 */
 typedef struct {
@@ -141,7 +112,6 @@ typedef struct {
 */
 /* The stack and stack size are not used on Windows
 */
-#if (GKI_USE_DYNAMIC_BUFFERS == false)
 
 #if (GKI_NUM_FIXED_BUF_POOLS > 0)
   uint8_t bufpool0[(ALIGN_POOL(GKI_BUF0_SIZE) + BUFFER_PADDING_SIZE) *
@@ -221,74 +191,6 @@ typedef struct {
 #if (GKI_NUM_FIXED_BUF_POOLS > 15)
   uint8_t bufpool15[(ALIGN_POOL(GKI_BUF15_SIZE) + BUFFER_PADDING_SIZE) *
                     GKI_BUF15_MAX];
-#endif
-
-#else
-/* Definitions for dynamic buffer use */
-#if (GKI_NUM_FIXED_BUF_POOLS > 0)
-  uint8_t* bufpool0;
-#endif
-
-#if (GKI_NUM_FIXED_BUF_POOLS > 1)
-  uint8_t* bufpool1;
-#endif
-
-#if (GKI_NUM_FIXED_BUF_POOLS > 2)
-  uint8_t* bufpool2;
-#endif
-
-#if (GKI_NUM_FIXED_BUF_POOLS > 3)
-  uint8_t* bufpool3;
-#endif
-
-#if (GKI_NUM_FIXED_BUF_POOLS > 4)
-  uint8_t* bufpool4;
-#endif
-
-#if (GKI_NUM_FIXED_BUF_POOLS > 5)
-  uint8_t* bufpool5;
-#endif
-
-#if (GKI_NUM_FIXED_BUF_POOLS > 6)
-  uint8_t* bufpool6;
-#endif
-
-#if (GKI_NUM_FIXED_BUF_POOLS > 7)
-  uint8_t* bufpool7;
-#endif
-
-#if (GKI_NUM_FIXED_BUF_POOLS > 8)
-  uint8_t* bufpool8;
-#endif
-
-#if (GKI_NUM_FIXED_BUF_POOLS > 9)
-  uint8_t* bufpool9;
-#endif
-
-#if (GKI_NUM_FIXED_BUF_POOLS > 10)
-  uint8_t* bufpool10;
-#endif
-
-#if (GKI_NUM_FIXED_BUF_POOLS > 11)
-  uint8_t* bufpool11;
-#endif
-
-#if (GKI_NUM_FIXED_BUF_POOLS > 12)
-  uint8_t* bufpool12;
-#endif
-
-#if (GKI_NUM_FIXED_BUF_POOLS > 13)
-  uint8_t* bufpool13;
-#endif
-
-#if (GKI_NUM_FIXED_BUF_POOLS > 14)
-  uint8_t* bufpool14;
-#endif
-
-#if (GKI_NUM_FIXED_BUF_POOLS > 15)
-  uint8_t* bufpool15;
-#endif
-
 #endif
 
   uint8_t* OSStack[GKI_MAX_TASKS];     /* pointer to beginning of stack */
@@ -392,16 +294,8 @@ typedef struct {
   bool system_tick_running; /* true if system tick is running. Valid only if
                                p_tick_cb is not NULL */
 
-#if (GKI_DEBUG == true)
-  uint16_t ExceptionCnt; /* number of GKI exceptions that have happened */
-  EXCEPTION_T Exception[GKI_MAX_EXCEPTION];
-#endif
-
 } tGKI_COM_CB;
 
-#ifdef __cplusplus
-extern "C" {
-#endif
 
 /* Internal GKI function prototypes
 */
@@ -411,35 +305,9 @@ extern void gki_buffer_init(void);
 extern void gki_timers_init(void);
 extern void gki_adjust_timer_count(int32_t);
 
-extern void OSStartRdy(void);
-extern void OSCtxSw(void);
-extern void OSIntCtxSw(void);
-extern void OSSched(void);
-extern void OSIntEnter(void);
-extern void OSIntExit(void);
-
 /* Debug aids
 */
 typedef void (*FP_PRINT)(char*, ...);
 
-#if (GKI_DEBUG == true)
-
-typedef void (*PKT_PRINT)(uint8_t*, uint16_t);
-
-extern void gki_print_task(FP_PRINT);
-extern void gki_print_exception(FP_PRINT);
-extern void gki_print_timer(FP_PRINT);
-extern void gki_print_stack(FP_PRINT);
-extern void gki_print_buffer(FP_PRINT);
-extern void gki_print_buffer_statistics(FP_PRINT, int16_t);
-extern void gki_print_used_bufs(FP_PRINT, uint8_t);
-extern void gki_dump(uint8_t*, uint16_t, FP_PRINT);
-extern void gki_dump2(uint16_t*, uint16_t, FP_PRINT);
-extern void gki_dump4(uint32_t*, uint16_t, FP_PRINT);
-
-#endif
-#ifdef __cplusplus
-}
-#endif
 
 #endif
diff --git a/src/gki/common/gki_debug.c b/src/gki/common/gki_debug.c
deleted file mode 100644
index 204649c..0000000
--- a/src/gki/common/gki_debug.c
+++ /dev/null
@@ -1,308 +0,0 @@
-/******************************************************************************
- *
- *  Copyright (C) 1999-2012 Broadcom Corporation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at:
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-#include "gki_int.h"
-
-#if (GKI_DEBUG == true)
-
-const int8_t* const OSTaskStates[] = {
-    (int8_t*)"DEAD",                                                    /* 0 */
-    (int8_t*) "REDY",                                                   /* 1 */
-    (int8_t*) "WAIT",                                                   /* 2 */
-    (int8_t*) "",     (int8_t*) "DELY",                                 /* 4 */
-    (int8_t*) "",     (int8_t*) "",     (int8_t*) "", (int8_t*) "SUSP", /* 8 */
-};
-
-/*******************************************************************************
-**
-** Function         GKI_PrintBufferUsage
-**
-** Description      Displays Current Buffer Pool summary
-**
-** Returns          void
-**
-*******************************************************************************/
-void GKI_PrintBufferUsage(uint8_t* p_num_pools, uint16_t* p_cur_used) {
-  int i;
-  FREE_QUEUE_T* p;
-  uint8_t num = gki_cb.com.curr_total_no_of_pools;
-  uint16_t cur[GKI_NUM_TOTAL_BUF_POOLS];
-
-  GKI_TRACE_0("");
-  GKI_TRACE_0("--- GKI Buffer Pool Summary (R - restricted, P - public) ---");
-
-  GKI_TRACE_0("POOL     SIZE  USED  MAXU  TOTAL");
-  GKI_TRACE_0("------------------------------");
-  for (i = 0; i < gki_cb.com.curr_total_no_of_pools; i++) {
-    p = &gki_cb.com.freeq[i];
-    if ((1 << i) & gki_cb.com.pool_access_mask) {
-      GKI_TRACE_5("%02d: (R), %4d, %3d, %3d, %3d", i, p->size, p->cur_cnt,
-                  p->max_cnt, p->total);
-    } else {
-      GKI_TRACE_5("%02d: (P), %4d, %3d, %3d, %3d", i, p->size, p->cur_cnt,
-                  p->max_cnt, p->total);
-    }
-    cur[i] = p->cur_cnt;
-  }
-  if (p_num_pools) *p_num_pools = num;
-  if (p_cur_used) memcpy(p_cur_used, cur, num * 2);
-}
-
-/*******************************************************************************
-**
-** Function         GKI_PrintBuffer
-**
-** Description      Called internally by OSS to print the buffer pools
-**
-** Returns          void
-**
-*******************************************************************************/
-void GKI_PrintBuffer(void) {
-  uint16_t i;
-  for (i = 0; i < GKI_NUM_TOTAL_BUF_POOLS; i++) {
-    GKI_TRACE_5("pool:%4u free %4u cur %3u max %3u  total%3u", i,
-                gki_cb.com.freeq[i].size, gki_cb.com.freeq[i].cur_cnt,
-                gki_cb.com.freeq[i].max_cnt, gki_cb.com.freeq[i].total);
-  }
-}
-
-/*******************************************************************************
-**
-** Function         gki_calc_stack
-**
-** Description      This function tries to calculate the amount of
-**                  stack used by looking non magic num. Magic num is consider
-**                  the first byte in the stack.
-**
-** Returns          the number of unused byte on the stack. 4 in case of stack
-**                  overrun
-**
-*******************************************************************************/
-uint16_t gki_calc_stack(uint8_t task) {
-  int j, stacksize;
-  uint32_t MagicNum;
-  uint32_t* p;
-
-  stacksize = (int)gki_cb.com.OSStackSize[task];
-  p = (uint32_t*)gki_cb.com.OSStack[task]; /* assume stack is aligned, */
-  MagicNum = *p;
-
-  for (j = 0; j < stacksize; j++) {
-    if (*p++ != MagicNum) break;
-  }
-
-  return (j * sizeof(uint32_t));
-}
-
-/*******************************************************************************
-**
-** Function         GKI_print_task
-**
-** Description      Print task stack usage.
-**
-** Returns          void
-**
-*******************************************************************************/
-void GKI_print_task(void) {
-#ifdef _BT_WIN32
-  GKI_TRACE_0("Service not available under insight");
-#else
-  uint8_t TaskId;
-
-  GKI_TRACE_0("TID TASKNAME STATE FREE_STACK  STACK");
-  for (TaskId = 0; TaskId < GKI_MAX_TASKS; TaskId++) {
-    if (gki_cb.com.OSRdyTbl[TaskId] != TASK_DEAD) {
-      GKI_TRACE_5("%2u   %-8s %-5s  0x%04X     0x%04X Bytes", (uint16_t)TaskId,
-                  gki_cb.com.OSTName[TaskId],
-                  OSTaskStates[gki_cb.com.OSRdyTbl[TaskId]],
-                  gki_calc_stack(TaskId), gki_cb.com.OSStackSize[TaskId]);
-    }
-  }
-#endif
-}
-
-/*******************************************************************************
-**
-** Function         gki_print_buffer_statistics
-**
-** Description      Called internally by OSS to print the buffer pools
-**                  statistics
-**
-** Returns          void
-**
-*******************************************************************************/
-void gki_print_buffer_statistics(FP_PRINT print, int16_t pool) {
-  uint16_t i;
-  BUFFER_HDR_T* hdr;
-  uint16_t size, act_size, maxbuffs;
-  uint32_t* magic;
-
-  if (pool > GKI_NUM_TOTAL_BUF_POOLS || pool < 0) {
-    print("Not a valid Buffer pool\n");
-    return;
-  }
-
-  size = gki_cb.com.freeq[pool].size;
-  maxbuffs = gki_cb.com.freeq[pool].total;
-  act_size = size + BUFFER_PADDING_SIZE;
-  print("Buffer Pool[%u] size=%u cur_cnt=%u max_cnt=%u  total=%u\n", pool,
-        gki_cb.com.freeq[pool].size, gki_cb.com.freeq[pool].cur_cnt,
-        gki_cb.com.freeq[pool].max_cnt, gki_cb.com.freeq[pool].total);
-
-  print("      Owner  State    Sanity\n");
-  print("----------------------------\n");
-  hdr = (BUFFER_HDR_T*)(gki_cb.com.pool_start[pool]);
-  for (i = 0; i < maxbuffs; i++) {
-    magic = (uint32_t*)((uint8_t*)hdr + BUFFER_HDR_SIZE + size);
-    print("%3d: 0x%02x %4d %10s\n", i, hdr->task_id, hdr->status,
-          (*magic == MAGIC_NO) ? "OK" : "CORRUPTED");
-    hdr = (BUFFER_HDR_T*)((uint8_t*)hdr + act_size);
-  }
-  return;
-}
-
-/*******************************************************************************
-**
-** Function         gki_print_used_bufs
-**
-** Description      Dumps used buffers in the particular pool
-**
-*******************************************************************************/
-void gki_print_used_bufs(FP_PRINT print, uint8_t pool_id) {
-  uint8_t* p_start;
-  uint16_t buf_size;
-  uint16_t num_bufs;
-  BUFFER_HDR_T* p_hdr;
-  uint16_t i;
-  uint32_t* magic;
-  uint16_t* p;
-
-  if (pool_id >= GKI_NUM_TOTAL_BUF_POOLS &&
-      gki_cb.com.pool_start[pool_id] != 0) {
-    print("Not a valid Buffer pool\n");
-    return;
-  }
-
-  p_start = gki_cb.com.pool_start[pool_id];
-  buf_size = gki_cb.com.freeq[pool_id].size + BUFFER_PADDING_SIZE;
-  num_bufs = gki_cb.com.freeq[pool_id].total;
-
-  for (i = 0; i < num_bufs; i++, p_start += buf_size) {
-    p_hdr = (BUFFER_HDR_T*)p_start;
-    magic = (uint32_t*)((uint8_t*)p_hdr + buf_size - sizeof(uint32_t));
-    p = (uint16_t*)p_hdr;
-
-    if (p_hdr->status != BUF_STATUS_FREE) {
-      print(
-          "%d:0x%x (Q:%d,Task:%s,Stat:%d,%s) %04x %04x %04x %04x %04x %04x "
-          "%04x %04x\n",
-          i, p_hdr, p_hdr->q_id, GKI_map_taskname(p_hdr->task_id),
-          p_hdr->status, (*magic == MAGIC_NO) ? "OK" : "CORRUPTED", p[0], p[1],
-          p[2], p[3], p[4], p[5], p[6], p[7]);
-    }
-  }
-}
-
-/*******************************************************************************
-**
-** Function         gki_print_task
-**
-** Description      This function prints the task states.
-**
-** Returns          void
-**
-*******************************************************************************/
-void gki_print_task(FP_PRINT print) {
-  uint8_t i;
-
-  print("TID VID TASKNAME STATE WAIT WAITFOR TIMEOUT STACK\n");
-  print("-------------------------------------------------\n");
-  for (i = 0; i < GKI_MAX_TASKS; i++) {
-    if (gki_cb.com.OSRdyTbl[i] != TASK_DEAD) {
-      print("%2u  %-8s %-5s %04X    %04X %7u %u/%u Bytes\n", (uint16_t)i,
-            gki_cb.com.OSTName[i], OSTaskStates[gki_cb.com.OSRdyTbl[i]],
-            gki_cb.com.OSWaitEvt[i], gki_cb.com.OSWaitForEvt[i],
-            gki_cb.com.OSWaitTmr[i], gki_calc_stack(i),
-            gki_cb.com.OSStackSize[i]);
-    }
-  }
-}
-
-/*******************************************************************************
-**
-** Function         gki_print_exception
-**
-** Description      This function prints the exception information.
-**
-** Returns          void
-**
-*******************************************************************************/
-void gki_print_exception(FP_PRINT print) {
-  uint16_t i;
-  EXCEPTION_T* pExp;
-
-  print("GKI Exceptions:\n");
-  for (i = 0; i < gki_cb.com.ExceptionCnt; i++) {
-    pExp = &gki_cb.com.Exception[i];
-    print("%d: Type=%d, Task=%d: %s\n", i, (int32_t)pExp->type,
-          (int32_t)pExp->taskid, (int8_t*)pExp->msg);
-  }
-}
-
-/*****************************************************************************/
-void gki_dump(uint8_t* s, uint16_t len, FP_PRINT print) {
-  uint16_t i, j;
-
-  for (i = 0, j = 0; i < len; i++) {
-    if (j == 0)
-      print("\n%lX: %02X, ", &s[i], s[i]);
-    else if (j == 7)
-      print("%02X,  ", s[i]);
-    else
-      print("%02X, ", s[i]);
-    if (++j == 16) j = 0;
-  }
-  print("\n");
-}
-
-void gki_dump2(uint16_t* s, uint16_t len, FP_PRINT print) {
-  uint16_t i, j;
-
-  for (i = 0, j = 0; i < len; i++) {
-    if (j == 0)
-      print("\n%lX: %04X, ", &s[i], s[i]);
-    else
-      print("%04X, ", s[i]);
-    if (++j == 8) j = 0;
-  }
-  print("\n");
-}
-
-void gki_dump4(uint32_t* s, uint16_t len, FP_PRINT print) {
-  uint16_t i, j;
-
-  for (i = 0, j = 0; i < len; i++) {
-    if (j == 0)
-      print("\n%lX: %08lX, ", &s[i], s[i]);
-    else
-      print("%08lX, ", s[i]);
-    if (++j == 4) j = 0;
-  }
-  print("\n");
-}
-
-#endif
diff --git a/src/gki/common/gki_inet.h b/src/gki/common/gki_inet.h
old mode 100644
new mode 100755
index 677013b..0b06c34
--- a/src/gki/common/gki_inet.h
+++ b/src/gki/common/gki_inet.h
@@ -20,12 +20,6 @@
 
 #include "data_types.h"
 
-#define htons ntohs
-#define htonl ntohl
-
-#define htonets nettohs
-#define htonetl nettohl
-
 #if (BIG_ENDIAN == true)
 #define ntohs(n) (n)
 #define ntohl(n) (n)
diff --git a/src/gki/common/gki_time.c b/src/gki/common/gki_time.cc
old mode 100644
new mode 100755
similarity index 97%
rename from src/gki/common/gki_time.c
rename to src/gki/common/gki_time.cc
index f941354..933afae
--- a/src/gki/common/gki_time.c
+++ b/src/gki/common/gki_time.cc
@@ -1,4 +1,5 @@
 /******************************************************************************
+ *
  *  Copyright (c) 2016, The Linux Foundation. All rights reserved.
  *  Not a Contribution.
  *
@@ -17,12 +18,10 @@
  *  limitations under the License.
  *
  ******************************************************************************/
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
 #include "gki_int.h"
 
-#ifndef BT_ERROR_TRACE_0
-#define BT_ERROR_TRACE_0(l, m)
-#endif
-
 /* Make sure that this has been defined in target.h */
 #ifndef GKI_NUM_TIMERS
 #error NO TIMERS: Must define at least 1 timer in the system!
@@ -34,6 +33,10 @@
 #define GKI_UNUSED_LIST_ENTRY (0x80000000L)
 #define GKI_MAX_INT32 (0x7fffffffL)
 
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+
 /*******************************************************************************
 **
 ** Function         gki_timers_init
@@ -186,6 +189,11 @@ void GKI_start_timer(uint8_t tnum, int32_t ticks, bool is_continuous) {
   int32_t reload;
   int32_t orig_ticks;
   uint8_t task_id = GKI_get_taskid();
+
+  /*if task_id doesnt found in the array, use default task id 14*/
+  if(task_id == 255) {
+    task_id = 14;
+  }
   bool bad_timer = false;
 
   if (ticks <= 0) ticks = 1;
@@ -285,6 +293,10 @@ void GKI_start_timer(uint8_t tnum, int32_t ticks, bool is_continuous) {
 void GKI_stop_timer(uint8_t tnum) {
   uint8_t task_id = GKI_get_taskid();
 
+    /*if task_id doesnt found in the array, use default task id 14*/
+  if(task_id == 255) {
+    task_id = 14;
+  }
   GKI_disable();
 
   switch (tnum) {
@@ -329,7 +341,7 @@ void GKI_stop_timer(uint8_t tnum) {
       }
 #else
       gki_cb.com.system_tick_running = false;
-      gki_cb.com.p_tick_cb(false); /* stop system tick */
+      (gki_cb.com.p_tick_cb)(false); /* stop system tick */
 #endif
     }
   }
@@ -716,12 +728,12 @@ uint32_t GKI_get_remaining_ticks(TIMER_LIST_Q* p_timer_listq,
     if ((p_tle != NULL) && (p_tle == p_target_tle)) {
       rem_ticks += p_tle->ticks;
     } else {
-      BT_ERROR_TRACE_0(TRACE_LAYER_GKI,
+      LOG(ERROR) << StringPrintf(
                        "GKI_get_remaining_ticks: No timer entry in the list");
       return (0);
     }
   } else {
-    BT_ERROR_TRACE_0(TRACE_LAYER_GKI,
+    LOG(ERROR) << StringPrintf(
                      "GKI_get_remaining_ticks: timer entry is not active");
   }
 
@@ -751,8 +763,9 @@ void GKI_add_to_timer_list(TIMER_LIST_Q* p_timer_listq, TIMER_LIST_ENT* p_tle) {
   uint8_t tt;
   TIMER_LIST_ENT* p_temp;
   if (p_tle == NULL || p_timer_listq == NULL) {
-    GKI_TRACE_3("%s: invalid argument %x, %x****************************<<",
-                __func__, p_timer_listq, p_tle);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: invalid argument %p, %p****************************<<", __func__,
+        p_timer_listq, p_tle);
     return;
   }
 
diff --git a/src/gki/ulinux/data_types.h b/src/gki/ulinux/data_types.h
old mode 100644
new mode 100755
index 5ede586..2e43931
--- a/src/gki/ulinux/data_types.h
+++ b/src/gki/ulinux/data_types.h
@@ -35,8 +35,6 @@
 #define FALSE 0
 #endif
 
-typedef uint32_t TIME_STAMP;
-
 #ifndef true
 #define true (!false)
 #endif
@@ -44,7 +42,6 @@ typedef uint32_t TIME_STAMP;
 #ifndef TRUE
 #define TRUE (!FALSE)
 #endif
-typedef unsigned char UBYTE;
 
 #ifdef __arm
 #define PACKED __packed
@@ -58,9 +55,6 @@ typedef unsigned char UBYTE;
 #define BIG_ENDIAN false
 #endif
 
-#define UINT16_LOW_BYTE(x) ((x)&0xff)
-#define UINT16_HI_BYTE(x) ((x) >> 8)
-
 /* MACRO definitions for safe string functions */
 /* Replace standard string functions with safe functions if available */
 #define BCM_STRCAT_S(x1,x2,x3)      strcat((x1),(x3))
diff --git a/src/gki/ulinux/gki_int.h b/src/gki/ulinux/gki_int.h
old mode 100644
new mode 100755
index 07cc590..b8f8de5
--- a/src/gki/ulinux/gki_int.h
+++ b/src/gki/ulinux/gki_int.h
@@ -40,9 +40,6 @@ typedef struct {
   pthread_mutex_t gki_timer_mutex;
   pthread_cond_t gki_timer_cond;
   int gki_timer_wake_lock_on;
-#if (GKI_DEBUG == true)
-  pthread_mutex_t GKI_trace_mutex;
-#endif
 } tGKI_OS;
 
 /* condition to exit or continue GKI_run() timer loop */
@@ -58,14 +55,6 @@ typedef struct {
   tGKI_COM_CB com;
 } tGKI_CB;
 
-#ifdef __cplusplus
-extern "C" {
-#endif
-
 extern tGKI_CB gki_cb;
 
-#ifdef __cplusplus
-}
-#endif
-
-#endif
+#endif
\ No newline at end of file
diff --git a/src/gki/ulinux/gki_ulinux.c b/src/gki/ulinux/gki_ulinux.cc
similarity index 85%
rename from src/gki/ulinux/gki_ulinux.c
rename to src/gki/ulinux/gki_ulinux.cc
index 52929c3..82b941f 100644
--- a/src/gki/ulinux/gki_ulinux.c
+++ b/src/gki/ulinux/gki_ulinux.cc
@@ -1,4 +1,5 @@
 /******************************************************************************
+ *
  *  Copyright (c) 2016, The Linux Foundation. All rights reserved.
  *  Not a Contribution.
  *
@@ -17,22 +18,24 @@
  *  limitations under the License.
  *
  ******************************************************************************/
-#include <stdio.h>
-#include <stdarg.h>
 #include <errno.h>
+#include <malloc.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <pthread.h> /* must be 1st header defined  */
 
-#define GKI_DEBUG false
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
 
-#include <pthread.h> /* must be 1st header defined  */
-#include <time.h>
 #include "gki_int.h"
-#include "gki_target.h"
-#include "bt_trace.h"
+
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
 
 /* Temp android logging...move to android tgt config file */
 
 #ifndef LINUX_NATIVE
-#include <cutils/log.h>
 #else
 #define LOGV(format, ...) fprintf(stdout, LOG_TAG format, ##__VA_ARGS__)
 #define LOGE(format, ...) fprintf(stderr, LOG_TAG format, ##__VA_ARGS__)
@@ -56,10 +59,6 @@ tGKI_CB gki_cb;
 #define LINUX_SEC (1000 / TICKS_PER_SEC)
 // #define GKI_TICK_TIMER_DEBUG
 
-#define LOCK(m) pthread_mutex_lock(&m)
-#define UNLOCK(m) pthread_mutex_unlock(&m)
-#define INIT(m) pthread_mutex_init(&m, NULL)
-
 /* this kind of mutex go into tGKI_OS control block!!!! */
 /* static pthread_mutex_t GKI_sched_mutex; */
 /*static pthread_mutex_t thread_delay_mutex;
@@ -73,7 +72,6 @@ static pthread_t timer_thread_id = 0;
 #if (NXP_EXTNS == TRUE)
 uint8_t gki_buf_init_done = false;
 #endif
-/* For Android */
 
 typedef struct {
   uint8_t task_id;         /* GKI task id */
@@ -95,39 +93,26 @@ static struct tms buffer;
 ** Returns          void
 **
 *******************************************************************************/
-void gki_task_entry(uintptr_t params) {
+void* gki_task_entry(void* params) {
   pthread_t thread_id = pthread_self();
   gki_pthread_info_t* p_pthread_info = (gki_pthread_info_t*)params;
-  GKI_TRACE_5("gki_task_entry task_id=%i, thread_id=%x/%x, pCond/pMutex=%x/%x",
-              p_pthread_info->task_id,
-              gki_cb.os.thread_id[p_pthread_info->task_id], pthread_self(),
-              p_pthread_info->pCond, p_pthread_info->pMutex);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "gki_task_entry task_id=%i, thread_id=%lx/%lx, pCond/pMutex=%p/%p",
+      p_pthread_info->task_id, gki_cb.os.thread_id[p_pthread_info->task_id],
+      pthread_self(), p_pthread_info->pCond, p_pthread_info->pMutex);
 
   gki_cb.os.thread_id[p_pthread_info->task_id] = thread_id;
   /* Call the actual thread entry point */
   (p_pthread_info->task_entry)(p_pthread_info->params);
 
-  GKI_TRACE_ERROR_1("gki_task task_id=%i terminating", p_pthread_info->task_id);
+  LOG(ERROR) << StringPrintf("gki_task task_id=%i terminating",
+                             p_pthread_info->task_id);
   gki_cb.os.thread_id[p_pthread_info->task_id] = 0;
 
-  return;
+  return NULL;
 }
 /* end android */
 
-#ifndef ANDROID
-void GKI_TRACE(char* fmt, ...) {
-  LOCK(gki_cb.os.GKI_trace_mutex);
-  va_list ap;
-
-  va_start(ap, fmt);
-  vfprintf(stderr, fmt, ap);
-  fprintf(stderr, "\n");
-
-  va_end(ap);
-  UNLOCK(gki_cb.os.GKI_trace_mutex);
-}
-#endif
-
 /*******************************************************************************
 **
 ** Function         GKI_init
@@ -164,10 +149,7 @@ void GKI_init(void) {
 #endif
   p_os = &gki_cb.os;
   pthread_mutex_init(&p_os->GKI_mutex, &attr);
-/* pthread_mutex_init(&GKI_sched_mutex, NULL); */
-#if (GKI_DEBUG == true)
-  pthread_mutex_init(&p_os->GKI_trace_mutex, NULL);
-#endif
+  /* pthread_mutex_init(&GKI_sched_mutex, NULL); */
   /* pthread_mutex_init(&thread_delay_mutex, NULL); */ /* used in GKI_delay */
   /* pthread_cond_init (&thread_delay_cond, NULL); */
 
@@ -223,23 +205,20 @@ uint32_t GKI_get_os_tick_count(void) {
 uint8_t GKI_create_task(TASKPTR task_entry, uint8_t task_id, int8_t* taskname,
                         uint16_t* stack, uint16_t stacksize, void* pCondVar,
                         void* pMutex) {
-  uint16_t i;
-  uint8_t* p;
   struct sched_param param;
   int policy, ret = 0;
   pthread_condattr_t attr;
   pthread_attr_t attr1;
-  (void)stack;
-  (void)stacksize;
 
   pthread_condattr_init(&attr);
   pthread_condattr_setclock(&attr, CLOCK_MONOTONIC);
-  GKI_TRACE_5(
-      "GKI_create_task func=0x%x  id=%d  name=%s  stack=0x%x  stackSize=%d",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "GKI_create_task func=0x%p  id=%d  name=%s  stack=0x%p  stackSize=%d",
       task_entry, task_id, taskname, stack, stacksize);
 
   if (task_id >= GKI_MAX_TASKS) {
-    GKI_TRACE_0("Error! task ID > max task allowed");
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("Error! task ID > max task allowed");
     return (GKI_FAILURE);
   }
 
@@ -259,10 +238,11 @@ uint8_t GKI_create_task(TASKPTR task_entry, uint8_t task_id, int8_t* taskname,
 #if (false == GKI_PTHREAD_JOINABLE)
   pthread_attr_setdetachstate(&attr1, PTHREAD_CREATE_DETACHED);
 
-  GKI_TRACE_3("GKI creating task %i, pCond/pMutex=%x/%x", task_id, pCondVar,
-              pMutex);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "GKI creating task %i, pCond/pMutex=%p/%p", task_id, pCondVar, pMutex);
 #else
-  GKI_TRACE_1("GKI creating JOINABLE task %i", task_id);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("GKI creating JOINABLE task %i", task_id);
 #endif
 
   /* On Android, the new tasks starts running before
@@ -275,14 +255,15 @@ uint8_t GKI_create_task(TASKPTR task_entry, uint8_t task_id, int8_t* taskname,
   gki_pthread_info[task_id].pCond = (pthread_cond_t*)pCondVar;
   gki_pthread_info[task_id].pMutex = (pthread_mutex_t*)pMutex;
 
-  ret = pthread_create(&gki_cb.os.thread_id[task_id], &attr1,
-                       (void*)gki_task_entry, &gki_pthread_info[task_id]);
+  ret = pthread_create(&gki_cb.os.thread_id[task_id], &attr1, gki_task_entry,
+                       &gki_pthread_info[task_id]);
 #if (NXP_EXTNS == TRUE)
   pthread_attr_destroy(&attr1);
   pthread_condattr_destroy(&attr);
 #endif
   if (ret != 0) {
-    GKI_TRACE_2("pthread_create failed(%d), %s!", ret, taskname);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("pthread_create failed(%d), %s!", ret, taskname);
     return GKI_FAILURE;
   }
 
@@ -290,7 +271,8 @@ uint8_t GKI_create_task(TASKPTR task_entry, uint8_t task_id, int8_t* taskname,
       0) {
 #if (PBS_SQL_TASK == true)
     if (task_id == PBS_SQL_TASK) {
-      GKI_TRACE_0("PBS SQL lowest priority task");
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("PBS SQL lowest priority task");
       policy = SCHED_NORMAL;
     } else
 #endif
@@ -301,8 +283,9 @@ uint8_t GKI_create_task(TASKPTR task_entry, uint8_t task_id, int8_t* taskname,
     pthread_setschedparam(gki_cb.os.thread_id[task_id], policy, &param);
   }
 
-  GKI_TRACE_6("Leaving GKI_create_task %x %d %x %s %x %d", task_entry, task_id,
-              gki_cb.os.thread_id[task_id], taskname, stack, stacksize);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "Leaving GKI_create_task %p %d %lx %s %p %d", task_entry, task_id,
+      gki_cb.os.thread_id[task_id], taskname, stack, stacksize);
 
   return (GKI_SUCCESS);
 }
@@ -321,8 +304,8 @@ uint8_t GKI_create_task(TASKPTR task_entry, uint8_t task_id, int8_t* taskname,
 *******************************************************************************/
 #define WAKE_LOCK_ID "brcm_nfca"
 #define PARTIAL_WAKE_LOCK 1
-extern int acquire_wake_lock(int lock, const char* id);
-extern int release_wake_lock(const char* id);
+extern "C" int acquire_wake_lock(int lock, const char* id);
+extern "C" int release_wake_lock(const char* id);
 
 void GKI_shutdown(void) {
   uint8_t task_id;
@@ -339,7 +322,6 @@ void GKI_shutdown(void) {
   for (task_id = GKI_MAX_TASKS; task_id > 0; task_id--) {
     if (gki_cb.com.OSRdyTbl[task_id - 1] != TASK_DEAD) {
       gki_cb.com.OSRdyTbl[task_id - 1] = TASK_DEAD;
-
       /* paranoi settings, make sure that we do not execute any mailbox events
        */
       gki_cb.com.OSWaitEvt[task_id - 1] &=
@@ -347,18 +329,26 @@ void GKI_shutdown(void) {
             TASK_MBOX_3_EVT_MASK);
       GKI_send_event(task_id - 1, EVENT_MASK(GKI_SHUTDOWN_EVT));
 
+      if (((task_id - 1) == BTU_TASK) && gki_cb.com.p_tick_cb &&
+          gki_cb.com.system_tick_running) {
+        gki_cb.com.system_tick_running = false;
+        (gki_cb.com.p_tick_cb)(false); /* stop system tick */
+      }
+
 #if (false == GKI_PTHREAD_JOINABLE)
       i = 0;
-      while ((gki_cb.com.OSWaitEvt[task_id - 1] != 0) && (++i < 5))
+      while ((gki_cb.com.OSWaitEvt[task_id - 1] != 0) && (++i < 15))
         usleep(2 * 1000);
 #else
       /* wait for proper Arnold Schwarzenegger task state */
       result = pthread_join(gki_cb.os.thread_id[task_id - 1], NULL);
       if (result < 0) {
-        GKI_TRACE_1("pthread_join() FAILED: result: %d", result);
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("FAILED: result: %d", result);
       }
 #endif
-      GKI_TRACE_1("GKI_shutdown(): task %s dead", gki_cb.com.OSTName[task_id]);
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("task %s dead", gki_cb.com.OSTName[task_id-1]);
       GKI_exit_task(task_id - 1);
     }
   }
@@ -366,9 +356,6 @@ void GKI_shutdown(void) {
   /* Destroy mutex and condition variable objects */
   pthread_mutex_destroy(&gki_cb.os.GKI_mutex);
 /*    pthread_mutex_destroy(&GKI_sched_mutex); */
-#if (GKI_DEBUG == true)
-  pthread_mutex_destroy(&gki_cb.os.GKI_trace_mutex);
-#endif
 /*    pthread_mutex_destroy(&thread_delay_mutex);
  pthread_cond_destroy (&thread_delay_cond); */
 #if (false == GKI_PTHREAD_JOINABLE)
@@ -379,7 +366,8 @@ void GKI_shutdown(void) {
   shutdown_timer = 1;
 #endif
   if (gki_cb.os.gki_timer_wake_lock_on) {
-    GKI_TRACE_0("GKI_shutdown :  release_wake_lock(brcm_btld)");
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("GKI_shutdown :  release_wake_lock(brcm_btld)");
     release_wake_lock(WAKE_LOCK_ID);
     gki_cb.os.gki_timer_wake_lock_on = 0;
   }
@@ -403,7 +391,9 @@ void GKI_shutdown(void) {
 void gki_system_tick_start_stop_cback(bool start) {
   tGKI_OS* p_os = &gki_cb.os;
   volatile int* p_run_cond = &p_os->no_timer_suspend;
+#ifdef GKI_TICK_TIMER_DEBUG
   static volatile int wake_lock_count;
+#endif
   if (false == start) {
     /* this can lead to a race condition. however as we only read this variable
      * in the timer loop
@@ -413,9 +403,8 @@ void gki_system_tick_start_stop_cback(bool start) {
     *p_run_cond = GKI_TIMER_TICK_STOP_COND;
 /* GKI_enable(); */
 #ifdef GKI_TICK_TIMER_DEBUG
-    BT_TRACE_1(TRACE_LAYER_HCI, TRACE_TYPE_DEBUG,
-               ">>> STOP GKI_timer_update(), wake_lock_count:%d",
-               --wake_lock_count);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf(">>> STOP wake_lock_count:%d", --wake_lock_count);
 #endif
     release_wake_lock(WAKE_LOCK_ID);
     gki_cb.os.gki_timer_wake_lock_on = 0;
@@ -429,9 +418,8 @@ void gki_system_tick_start_stop_cback(bool start) {
     pthread_mutex_unlock(&p_os->gki_timer_mutex);
 
 #ifdef GKI_TICK_TIMER_DEBUG
-    BT_TRACE_1(TRACE_LAYER_HCI, TRACE_TYPE_DEBUG,
-               ">>> START GKI_timer_update(), wake_lock_count:%d",
-               ++wake_lock_count);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf(">>> START wake_lock_count:%d", ++wake_lock_count);
 #endif
   }
 }
@@ -449,7 +437,7 @@ void gki_system_tick_start_stop_cback(bool start) {
 *******************************************************************************/
 #ifdef NO_GKI_RUN_RETURN
 void timer_thread(signed long id) {
-  GKI_TRACE_1("%s enter", __func__);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s enter", __func__);
   struct timespec delay;
   int timeout = 1000; /* 10  ms per system tick  */
   int err;
@@ -466,7 +454,7 @@ void timer_thread(signed long id) {
 
     GKI_timer_update(1);
   }
-  GKI_TRACE_ERROR_1("%s exit", __func__);
+  LOG(ERROR) << StringPrintf("%s exit", __func__);
   return;
 }
 #endif
@@ -486,8 +474,8 @@ void timer_thread(signed long id) {
 **                  one step, If your OS does it in one step, this function
 **                  should be empty.
 *******************************************************************************/
-void GKI_run(void* p_task_id) {
-  GKI_TRACE_1("%s enter", __func__);
+void GKI_run(__attribute__((unused)) void* p_task_id) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s enter", __func__);
   struct timespec delay;
   int err = 0;
 #if (NXP_EXTNS == TRUE)
@@ -495,19 +483,18 @@ void GKI_run(void* p_task_id) {
   (void)p_task_id;
 #endif
   volatile int* p_run_cond = &gki_cb.os.no_timer_suspend;
-#if (NXP_EXTNS == TRUE)
-  int ret = 0;
-#endif
 #ifndef GKI_NO_TICK_STOP
   /* register start stop function which disable timer loop in GKI_run() when no
    * timers are
    * in any GKI/BTA/BTU this should save power when BTLD is idle! */
   GKI_timer_queue_register_callback(gki_system_tick_start_stop_cback);
-  APPL_TRACE_DEBUG0("GKI_run(): Start/Stop GKI_timer_update_registered!");
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("Start/Stop GKI_timer_update_registered!");
 #endif
 
 #ifdef NO_GKI_RUN_RETURN
-  GKI_TRACE_0("GKI_run == NO_GKI_RUN_RETURN");
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("GKI_run == NO_GKI_RUN_RETURN");
   pthread_attr_t timer_attr;
 
   shutdown_timer = 0;
@@ -515,18 +502,21 @@ void GKI_run(void* p_task_id) {
   pthread_attr_init(&timer_attr);
   pthread_attr_setdetachstate(&timer_attr, PTHREAD_CREATE_DETACHED);
 #if (NXP_EXTNS == TRUE)
-  ret = pthread_create(&timer_thread_id, &timer_attr, timer_thread, NULL);
+  int ret = 0;
+  ret = pthread_create(&timer_thread_id, &timer_attr, timer_thread, NULL);sdadsa
   pthread_attr_destroy(&timer_attr);
   if (ret != 0)
 #else
   if (pthread_create(&timer_thread_id, &timer_attr, timer_thread, NULL) != 0)
 #endif
   {
-    GKI_TRACE_0("GKI_run: pthread_create failed to create timer_thread!");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "GKI_run: pthread_create failed to create timer_thread!");
     return GKI_FAILURE;
   }
 #else
-  GKI_TRACE_2("GKI_run, run_cond(%x)=%d ", p_run_cond, *p_run_cond);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("GKI_run, run_cond(%p)=%d ", p_run_cond, *p_run_cond);
 #if (NXP_EXTNS == TRUE)
   rtask = GKI_get_taskid();
 #endif
@@ -550,41 +540,36 @@ void GKI_run(void* p_task_id) {
        * e.g. power saving you may want to provide more ticks
        */
       GKI_timer_update(1);
-      /* BT_TRACE_2( TRACE_LAYER_HCI, TRACE_TYPE_DEBUG, "update: tv_sec: %d,
-       * tv_nsec: %d", delay.tv_sec, delay.tv_nsec ); */
     } while (GKI_TIMER_TICK_RUN_COND == *p_run_cond);
 
 /* currently on reason to exit above loop is no_timer_suspend ==
  * GKI_TIMER_TICK_STOP_COND
  * block timer main thread till re-armed by  */
 #ifdef GKI_TICK_TIMER_DEBUG
-    BT_TRACE_0(TRACE_LAYER_HCI, TRACE_TYPE_DEBUG,
-               ">>> SUSPENDED GKI_timer_update()");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(">>> SUSPENDED");
 #endif
 #if (NXP_EXTNS == TRUE)
     if (gki_cb.com.OSRdyTbl[rtask] == TASK_DEAD) {
       gki_cb.com.OSWaitEvt[rtask] = 0;
-      BT_TRACE_1(TRACE_LAYER_HCI, TRACE_TYPE_DEBUG,
-                 "GKI TASK_DEAD received. exit thread %d...", rtask);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf
+              ("GKI TASK_DEAD received. exit thread %d...", rtask);
       gki_cb.os.thread_id[rtask] = 0;
     }
 #endif
     if (GKI_TIMER_TICK_EXIT_COND != *p_run_cond) {
-      GKI_TRACE_1("%s waiting timer mutex", __func__);
       pthread_mutex_lock(&gki_cb.os.gki_timer_mutex);
       pthread_cond_wait(&gki_cb.os.gki_timer_cond, &gki_cb.os.gki_timer_mutex);
       pthread_mutex_unlock(&gki_cb.os.gki_timer_mutex);
-      GKI_TRACE_1("%s exited timer mutex", __func__);
     }
 /* potentially we need to adjust os gki_cb.com.OSTicks */
 
 #ifdef GKI_TICK_TIMER_DEBUG
-    BT_TRACE_1(TRACE_LAYER_HCI, TRACE_TYPE_DEBUG,
-               ">>> RESTARTED GKI_timer_update(): run_cond: %d", *p_run_cond);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf(">>> RESTARTED run_cond: %d", *p_run_cond);
 #endif
   } /* for */
 #endif
-  GKI_TRACE_1("%s exit", __func__);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s exit", __func__);
 }
 
 /*******************************************************************************
@@ -638,18 +623,18 @@ uint16_t GKI_wait(uint16_t flag, uint32_t timeout) {
   int nano_sec;
 
   rtask = GKI_get_taskid();
-  GKI_TRACE_3("GKI_wait %d %x %d", rtask, flag, timeout);
   if (rtask >= GKI_MAX_TASKS) {
-    GKI_TRACE_ERROR_3("%s() Exiting thread; rtask %d >= %d", __func__, rtask,
-                      GKI_MAX_TASKS);
-    return EVENT_MASK(GKI_SHUTDOWN_EVT);
+    LOG(ERROR) << StringPrintf("%s() Exiting thread; rtask %d >= %d", __func__,
+                               rtask, GKI_MAX_TASKS);
+    return EVENT_MASK(GKI_UNKNOWN_TASK_EVT);
   }
 
   gki_pthread_info_t* p_pthread_info = &gki_pthread_info[rtask];
   if (p_pthread_info->pCond != NULL && p_pthread_info->pMutex != NULL) {
     int ret;
-    GKI_TRACE_3("GKI_wait task=%i, pCond/pMutex = %x/%x", rtask,
-                p_pthread_info->pCond, p_pthread_info->pMutex);
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("GKI_wait task=%i, pCond/pMutex = %p/%p", rtask,
+                        p_pthread_info->pCond, p_pthread_info->pMutex);
     ret = pthread_mutex_lock(p_pthread_info->pMutex);
     ret = pthread_cond_signal(p_pthread_info->pCond);
     ret = pthread_mutex_unlock(p_pthread_info->pMutex);
@@ -686,7 +671,13 @@ uint16_t GKI_wait(uint16_t flag, uint32_t timeout) {
       //            abstime.tv_sec = currSysTime.time;
       //            abstime.tv_nsec = NANOSEC_PER_MILLISEC *
       //            currSysTime.millitm;
-      clock_gettime(CLOCK_MONOTONIC, &abstime);
+
+
+      /* TODO: Need to check for the return status for ret_clk */
+      int ret_clk = clock_gettime(CLOCK_MONOTONIC, &abstime);
+      if (ret_clk == -1) {
+        LOG(ERROR) << StringPrintf("%s: clock_gettime failed\n", __func__);
+      }
 
       /* add timeout */
       sec = timeout / 1000;
@@ -728,7 +719,8 @@ uint16_t GKI_wait(uint16_t flag, uint32_t timeout) {
       /* unlock thread_evt_mutex as pthread_cond_wait() does auto lock when cond
        * is met */
       pthread_mutex_unlock(&gki_cb.os.thread_evt_mutex[rtask]);
-      GKI_TRACE_ERROR_1("GKI TASK_DEAD received. exit thread %d...", rtask);
+      LOG(ERROR) << StringPrintf("GKI TASK_DEAD received. exit thread %d...",
+                                 rtask);
 
       gki_cb.os.thread_id[rtask] = 0;
       return (EVENT_MASK(GKI_SHUTDOWN_EVT));
@@ -747,7 +739,6 @@ uint16_t GKI_wait(uint16_t flag, uint32_t timeout) {
   /* unlock thread_evt_mutex as pthread_cond_wait() does auto lock mutex when
    * cond is met */
   pthread_mutex_unlock(&gki_cb.os.thread_evt_mutex[rtask]);
-  GKI_TRACE_4("GKI_wait %d %x %d %x resumed", rtask, flag, timeout, evt);
 
   return (evt);
 }
@@ -771,7 +762,8 @@ void GKI_delay(uint32_t timeout) {
   struct timespec delay;
   int err;
 
-  GKI_TRACE_2("GKI_delay %d %d", rtask, timeout);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("GKI_delay %d %d", rtask, timeout);
 
   delay.tv_sec = timeout / 1000;
   delay.tv_nsec = 1000 * 1000 * (timeout % 1000);
@@ -790,7 +782,8 @@ void GKI_delay(uint32_t timeout) {
   if (rtask && gki_cb.com.OSRdyTbl[rtask] == TASK_DEAD) {
   }
 
-  GKI_TRACE_2("GKI_delay %d %d done", rtask, timeout);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("GKI_delay %d %d", rtask, timeout);
   return;
 }
 
@@ -810,8 +803,6 @@ void GKI_delay(uint32_t timeout) {
 **
 *******************************************************************************/
 uint8_t GKI_send_event(uint8_t task_id, uint16_t event) {
-  GKI_TRACE_2("GKI_send_event %d %x", task_id, event);
-
   /* use efficient coding to avoid pipeline stalls */
   if (task_id < GKI_MAX_TASKS) {
     /* protect OSWaitEvt[task_id] from manipulation in GKI_wait() */
@@ -824,7 +815,6 @@ uint8_t GKI_send_event(uint8_t task_id, uint16_t event) {
 
     pthread_mutex_unlock(&gki_cb.os.thread_evt_mutex[task_id]);
 
-    GKI_TRACE_2("GKI_send_event %d %x done", task_id, event);
     return (GKI_SUCCESS);
   }
   return (GKI_FAILURE);
@@ -851,8 +841,10 @@ uint8_t GKI_send_event(uint8_t task_id, uint16_t event) {
 **
 *******************************************************************************/
 uint8_t GKI_isend_event(uint8_t task_id, uint16_t event) {
-  GKI_TRACE_2("GKI_isend_event %d %x", task_id, event);
-  GKI_TRACE_2("GKI_isend_event %d %x done", task_id, event);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("GKI_isend_event %d %x", task_id, event);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("GKI_isend_event %d %x done", task_id, event);
   return GKI_send_event(task_id, event);
 }
 
@@ -876,13 +868,10 @@ uint8_t GKI_get_taskid(void) {
   pthread_t thread_id = pthread_self();
   for (i = 0; i < GKI_MAX_TASKS; i++) {
     if (gki_cb.os.thread_id[i] == thread_id) {
-      GKI_TRACE_2("GKI_get_taskid %x %d done", thread_id, i);
       return (i);
     }
   }
 
-  GKI_TRACE_1("GKI_get_taskid: thread id = %x, task id = -1", thread_id);
-
   return (-1);
 }
 
@@ -904,11 +893,12 @@ uint8_t GKI_get_taskid(void) {
 **
 *******************************************************************************/
 int8_t* GKI_map_taskname(uint8_t task_id) {
-  GKI_TRACE_1("GKI_map_taskname %d", task_id);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("GKI_map_taskname %d", task_id);
 
   if (task_id < GKI_MAX_TASKS) {
-    GKI_TRACE_2("GKI_map_taskname %d %s done", task_id,
-                gki_cb.com.OSTName[task_id]);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "GKI_map_taskname %d %s done", task_id, gki_cb.com.OSTName[task_id]);
     return (gki_cb.com.OSTName[task_id]);
   } else if (task_id == GKI_MAX_TASKS) {
     return (gki_cb.com.OSTName[GKI_get_taskid()]);
@@ -927,11 +917,9 @@ int8_t* GKI_map_taskname(uint8_t task_id) {
 **
 *******************************************************************************/
 void GKI_enable(void) {
-  GKI_TRACE_0("GKI_enable");
   pthread_mutex_unlock(&gki_cb.os.GKI_mutex);
   /*  pthread_mutex_xx is nesting save, no need for this: already_disabled = 0;
    */
-  GKI_TRACE_0("Leaving GKI_enable");
   return;
 }
 
@@ -946,14 +934,16 @@ void GKI_enable(void) {
 *******************************************************************************/
 
 void GKI_disable(void) {
-  // GKI_TRACE_0("GKI_disable");
+  // DLOG_IF(INFO, nfc_debug_enabled) <<
+  // StringPrintf("GKI_disable");");
 
   /*  pthread_mutex_xx is nesting save, no need for this: if (!already_disabled)
      {
       already_disabled = 1; */
   pthread_mutex_lock(&gki_cb.os.GKI_mutex);
   /*  } */
-  // GKI_TRACE_0("Leaving GKI_disable");
+  // DLOG_IF(INFO, nfc_debug_enabled) <<
+  // StringPrintf("Leaving GKI_disable");
   return;
 }
 
@@ -971,41 +961,25 @@ void GKI_disable(void) {
 **
 *******************************************************************************/
 
-void GKI_exception(uint16_t code, char* msg) {
+void GKI_exception(uint16_t code, std::string msg) {
   uint8_t task_id;
-  int i = 0;
 
-  GKI_TRACE_ERROR_0("GKI_exception(): Task State Table");
+  LOG(ERROR) << StringPrintf("Task State Table");
 
   for (task_id = 0; task_id < GKI_MAX_TASKS; task_id++) {
-    GKI_TRACE_ERROR_3("TASK ID [%d] task name [%s] state [%d]", task_id,
-                      gki_cb.com.OSTName[task_id],
-                      gki_cb.com.OSRdyTbl[task_id]);
+    LOG(ERROR) << StringPrintf("TASK ID [%d] task name [%s] state [%d]",
+                               task_id, gki_cb.com.OSTName[task_id],
+                               gki_cb.com.OSRdyTbl[task_id]);
   }
 
-  GKI_TRACE_ERROR_2("GKI_exception %d %s", code, msg);
-  GKI_TRACE_ERROR_0(
+  LOG(ERROR) << StringPrintf("%d %s", code, msg.c_str());
+  LOG(ERROR) << StringPrintf(
       "********************************************************************");
-  GKI_TRACE_ERROR_2("* GKI_exception(): %d %s", code, msg);
-  GKI_TRACE_ERROR_0(
+  LOG(ERROR) << StringPrintf("* %d %s", code, msg.c_str());
+  LOG(ERROR) << StringPrintf(
       "********************************************************************");
 
-#if (GKI_DEBUG == true)
-  GKI_disable();
-
-  if (gki_cb.com.ExceptionCnt < GKI_MAX_EXCEPTION) {
-    EXCEPTION_T* pExp;
-
-    pExp = &gki_cb.com.Exception[gki_cb.com.ExceptionCnt++];
-    pExp->type = code;
-    pExp->taskid = GKI_get_taskid();
-    strlcpy((char*)pExp->msg, msg, GKI_MAX_EXCEPTION_MSGLEN - 1);
-  }
-
-  GKI_enable();
-#endif
-
-  GKI_TRACE_ERROR_2("GKI_exception %d %s done", code, msg);
+  LOG(ERROR) << StringPrintf("%d %s done", code, msg.c_str());
 
   return;
 }
@@ -1134,9 +1108,11 @@ void GKI_os_free(void* p_mem) {
 *******************************************************************************/
 uint8_t GKI_suspend_task(uint8_t task_id) {
   (void)task_id;
-  GKI_TRACE_1("GKI_suspend_task %d - NOT implemented", task_id);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("GKI_suspend_task %d - NOT implemented", task_id);
 
-  GKI_TRACE_1("GKI_suspend_task %d done", task_id);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("GKI_suspend_task %d done", task_id);
 
   return (GKI_SUCCESS);
 }
@@ -1159,9 +1135,11 @@ uint8_t GKI_suspend_task(uint8_t task_id) {
 uint8_t GKI_resume_task(uint8_t task_id) {
   (void)task_id;
 
-  GKI_TRACE_1("GKI_resume_task %d - NOT implemented", task_id);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("GKI_resume_task %d - NOT implemented", task_id);
 
-  GKI_TRACE_1("GKI_resume_task %d done", task_id);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("GKI_resume_task %d done", task_id);
 
   return (GKI_SUCCESS);
 }
@@ -1198,7 +1176,8 @@ void GKI_exit_task(uint8_t task_id) {
 
   // GKI_send_event(task_id, EVENT_MASK(GKI_SHUTDOWN_EVT));
 
-  GKI_TRACE_1("GKI_exit_task %d done", task_id);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("GKI_exit_task %d done", task_id);
   return;
 }
 
@@ -1217,7 +1196,7 @@ void GKI_exit_task(uint8_t task_id) {
 **
 *******************************************************************************/
 void GKI_sched_lock(void) {
-  GKI_TRACE_0("GKI_sched_lock");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("GKI_sched_lock");
   GKI_disable();
   return;
 }
@@ -1237,7 +1216,7 @@ void GKI_sched_lock(void) {
 **
 *******************************************************************************/
 void GKI_sched_unlock(void) {
-  GKI_TRACE_0("GKI_sched_unlock");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("GKI_sched_unlock");;
   GKI_enable();
 }
 
@@ -1249,9 +1228,9 @@ void GKI_sched_unlock(void) {
 **
 *******************************************************************************/
 void GKI_shiftdown(uint8_t* p_mem, uint32_t len, uint32_t shift_amount) {
-  register uint8_t* ps = p_mem + len - 1;
-  register uint8_t* pd = ps + shift_amount;
-  register uint32_t xx;
+  uint8_t* ps = p_mem + len - 1;
+  uint8_t* pd = ps + shift_amount;
+  uint32_t xx;
 
   for (xx = 0; xx < len; xx++) *pd-- = *ps--;
 }
@@ -1264,9 +1243,9 @@ void GKI_shiftdown(uint8_t* p_mem, uint32_t len, uint32_t shift_amount) {
 **
 *******************************************************************************/
 void GKI_shiftup(uint8_t* p_dest, uint8_t* p_src, uint32_t len) {
-  register uint8_t* ps = p_src;
-  register uint8_t* pd = p_dest;
-  register uint32_t xx;
+  uint8_t* ps = p_src;
+  uint8_t* pd = p_dest;
+  uint32_t xx;
 
   for (xx = 0; xx < len; xx++) *pd++ = *ps++;
 }
diff --git a/src/hal/include/nfc_hal_api.h b/src/hal/include/nfc_hal_api.h
deleted file mode 100644
index ac873c8..0000000
--- a/src/hal/include/nfc_hal_api.h
+++ /dev/null
@@ -1,420 +0,0 @@
-/******************************************************************************
- *  Copyright (c) 2016, The Linux Foundation. All rights reserved.
- *  Not a Contribution.
- *
- *  Copyright (C) 2015 NXP Semiconductors
- *  The original Work has been changed by NXP Semiconductors.
- *
- *  Copyright (C) 2012-2014 Broadcom Corporation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at:
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-/******************************************************************************
- *
- *  The original Work has been changed by NXP Semiconductors.
- *
- *  Copyright (C) 2015 NXP Semiconductors
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-/******************************************************************************
- *
- *  NFC Hardware Abstraction Layer API
- *
- ******************************************************************************/
-#ifndef NFC_HAL_API_H
-#define NFC_HAL_API_H
-#include <hardware/nfc.h>
-#include "data_types.h"
-#include "nfc_hal_target.h"
-
-/*******************************************************************************
-** tHAL_STATUS Definitions
-*******************************************************************************/
-#define HAL_NFC_STATUS_OK               0
-#define HAL_NFC_STATUS_FAILED           1
-#define HAL_NFC_STATUS_ERR_TRANSPORT    2
-#define HAL_NFC_STATUS_ERR_CMD_TIMEOUT  3
-#define HAL_NFC_STATUS_REFUSED          4
-
-/*******************************************************************************
-** tHAL_HCI_NETWK_CMD Definitions
-*******************************************************************************/
-#define HAL_NFC_HCI_NO_UICC_HOST 0x00
-#define HAL_NFC_HCI_UICC0_HOST 0x01
-#define HAL_NFC_HCI_UICC1_HOST 0x02
-#define HAL_NFC_HCI_UICC2_HOST 0x04
-
-#define MAX_IOCTL_TRANSCEIVE_CMD_LEN  256
-#define MAX_IOCTL_TRANSCEIVE_RESP_LEN 256
-#define MAX_ATR_INFO_LEN              128
-
-/*
- * Data structures provided below are used of Hal Ioctl calls
- */
-/*
- * nfc_nci_ExtnCmd_t shall contain data for commands used for transceive command in ioctl
- */
-typedef struct
-{
-    uint16_t cmd_len;
-    uint8_t  p_cmd[MAX_IOCTL_TRANSCEIVE_CMD_LEN];
-} nfc_nci_ExtnCmd_t;
-
-/*
- * nfc_nci_ExtnRsp_t shall contain response for command sent in transceive command
- */
-typedef struct
-{
-    uint16_t rsp_len;
-    uint8_t  p_rsp[MAX_IOCTL_TRANSCEIVE_RESP_LEN];
-} nfc_nci_ExtnRsp_t;
-/*
- * InputData_t :ioctl has multiple subcommands
- * Each command has corresponding input data which needs to be populated in this
- */
-typedef union {
-    uint16_t          bootMode;
-    uint8_t           halType;
-    nfc_nci_ExtnCmd_t nciCmd;
-    uint32_t          timeoutMilliSec;
-    long              nfcServicePid;
-}InputData_t;
-/*
- * nfc_nci_ExtnInputData_t :Apart from InputData_t, there are context data
- * which is required during callback from stub to proxy.
- * To avoid additional copy of data while propagating from libnfc to Adaptation
- * and Nfcstub to ncihal, common structure is used. As a sideeffect, context data
- * is exposed to libnfc (Not encapsulated).
- */
-typedef struct {
-    /*
-     * context to be used/updated only by users of proxy & stub of Nfc.hal
-     * i.e, NfcAdaptation & Nfc hidl
-     */
-    void*       context;
-    InputData_t data;
-}nfc_nci_ExtnInputData_t;
-
-
-/*
- * outputData_t :ioctl has multiple commands/responses
- * This contains the output types for each ioctl.
- */
-typedef union{
-    uint32_t            status;
-    nfc_nci_ExtnRsp_t   nciRsp;
-    uint8_t             nxpNciAtrInfo[MAX_ATR_INFO_LEN];
-    uint32_t            p61CurrentState;
-    uint16_t            fwUpdateInf;
-    uint16_t            fwDwnldStatus;
-    uint16_t            fwMwVerStatus;
-    uint8_t             chipType;
-}outputData_t;
-
-/*
- * nfc_nci_ExtnOutputData_t :Apart from outputData_t, there are other information
- * which is required during callback from stub to proxy.
- * For ex (context, result of the operation , type of ioctl which was completed).
- * To avoid additional copy of data while propagating from libnfc to Adaptation
- * and Nfcstub to ncihal, common structure is used. As a sideeffect, these data
- * is exposed(Not encapsulated).
- */
-typedef struct {
-    /*
-     * ioctlType, result & context to be used/updated only by users of
-     * proxy & stub of Nfc.hal.
-     * i.e, NfcAdaptation & Nfc hidl
-     * These fields shall not be used by libnfc or halimplementation
-     */
-    uint64_t     ioctlType;
-    uint32_t     result;
-    void*        context;
-    outputData_t data;
-}nfc_nci_ExtnOutputData_t;
-
-/*
- * nfc_nci_IoctlInOutData_t :data structure for input & output
- * to be sent for ioctl command. input is populated by client/proxy side
- * output is provided from server/stub to client/proxy
- */
-typedef struct {
-    nfc_nci_ExtnInputData_t  inp;
-    nfc_nci_ExtnOutputData_t out;
-}nfc_nci_IoctlInOutData_t;
-
-enum {
-    HAL_NFC_ENABLE_I2C_FRAGMENTATION_EVT = 0x07,
-    HAL_NFC_POST_MIN_INIT_CPLT_EVT  = 0x08
-};
-
-enum {
-    HAL_NFC_IOCTL_P61_IDLE_MODE = 0,
-    HAL_NFC_IOCTL_P61_WIRED_MODE,
-    HAL_NFC_IOCTL_P61_PWR_MODE,
-    HAL_NFC_IOCTL_P61_DISABLE_MODE,
-    HAL_NFC_IOCTL_P61_ENABLE_MODE,
-    HAL_NFC_IOCTL_SET_BOOT_MODE,
-    HAL_NFC_IOCTL_GET_CONFIG_INFO,
-    HAL_NFC_IOCTL_CHECK_FLASH_REQ,
-    HAL_NFC_IOCTL_FW_DWNLD,
-    HAL_NFC_IOCTL_FW_MW_VER_CHECK,
-    HAL_NFC_IOCTL_DISABLE_HAL_LOG,
-    HAL_NFC_IOCTL_NCI_TRANSCEIVE,
-    HAL_NFC_IOCTL_P61_GET_ACCESS,
-    HAL_NFC_IOCTL_P61_REL_ACCESS,
-    HAL_NFC_IOCTL_ESE_CHIP_RST,
-    HAL_NFC_IOCTL_REL_SVDD_WAIT,
-    HAL_NFC_IOCTL_SET_JCP_DWNLD_ENABLE,
-    HAL_NFC_IOCTL_SET_JCP_DWNLD_DISABLE,
-    HAL_NFC_IOCTL_SET_NFC_SERVICE_PID,
-    HAL_NFC_IOCTL_GET_FEATURE_LIST
-};
-
-typedef uint8_t tHAL_NFC_STATUS;
-typedef void(tHAL_NFC_STATUS_CBACK)(tHAL_NFC_STATUS status);
-typedef void(tHAL_NFC_CBACK)(uint8_t event, tHAL_NFC_STATUS status);
-typedef void(tHAL_NFC_DATA_CBACK)(uint16_t data_len, uint8_t* p_data);
-
-/*******************************************************************************
-** tHAL_NFC_ENTRY HAL entry-point lookup table
-*******************************************************************************/
-
-typedef void(tHAL_API_INITIALIZE)(void);
-typedef void(tHAL_API_TERMINATE)(void);
-typedef void(tHAL_API_OPEN)(tHAL_NFC_CBACK* p_hal_cback,
-                            tHAL_NFC_DATA_CBACK* p_data_cback);
-typedef void(tHAL_API_CLOSE)(void);
-typedef void(tHAL_API_CORE_INITIALIZED)(uint16_t data_len,
-                                        uint8_t* p_core_init_rsp_params);
-typedef void(tHAL_API_WRITE)(uint16_t data_len, uint8_t* p_data);
-typedef bool(tHAL_API_PREDISCOVER)(void);
-typedef void(tHAL_API_CONTROL_GRANTED)(void);
-typedef void(tHAL_API_POWER_CYCLE)(void);
-typedef uint8_t(tHAL_API_GET_MAX_NFCEE)(void);
-#if (NXP_EXTNS == TRUE)
-typedef int(tHAL_API_IOCTL)(long arg, void* p_data);
-typedef int(tHAL_API_GET_FW_DWNLD_FLAG)(uint8_t* fwDnldRequest);
-#endif
-
-#define NFC_HAL_DM_PRE_SET_MEM_LEN 5
-typedef struct {
-  uint32_t addr;
-  uint32_t data;
-} tNFC_HAL_DM_PRE_SET_MEM;
-
-/* data members for NFC_HAL-HCI */
-typedef struct {
-  bool nfc_hal_prm_nvm_required; /* set nfc_hal_prm_nvm_required to true, if the
-                                    platform wants to abort PRM process without
-                                    NVM */
-  uint16_t nfc_hal_nfcc_enable_timeout; /* max time to wait for RESET NTF after
-                                           setting REG_PU to high */
-  uint16_t nfc_hal_post_xtal_timeout;   /* max time to wait for RESET NTF after
-                                           setting Xtal frequency */
-#if (NFC_HAL_HCI_INCLUDED == true)
-  bool nfc_hal_first_boot; /* set nfc_hal_first_boot to true, if platform
-                              enables NFC for the first time after bootup */
-  uint8_t nfc_hal_hci_uicc_support; /* set nfc_hal_hci_uicc_support to Zero, if
-                                       no UICC is supported otherwise set
-                                       corresponding bit(s) for every supported
-                                       UICC(s) */
-#endif
-} tNFC_HAL_CFG;
-
-typedef struct {
-  tHAL_API_INITIALIZE* initialize;
-  tHAL_API_TERMINATE* terminate;
-  tHAL_API_OPEN* open;
-  tHAL_API_CLOSE* close;
-  tHAL_API_CORE_INITIALIZED* core_initialized;
-  tHAL_API_WRITE* write;
-  tHAL_API_PREDISCOVER* prediscover;
-  tHAL_API_CONTROL_GRANTED* control_granted;
-  tHAL_API_POWER_CYCLE* power_cycle;
-  tHAL_API_GET_MAX_NFCEE* get_max_ee;
-#if (NXP_EXTNS == TRUE)
-  tHAL_API_IOCTL* ioctl;
-  tHAL_API_GET_FW_DWNLD_FLAG* check_fw_dwnld_flag;
-#endif
-} tHAL_NFC_ENTRY;
-
-#if (NXP_EXTNS == TRUE)
-typedef struct {
-  tHAL_NFC_ENTRY* hal_entry_func;
-  uint8_t boot_mode;
-} tHAL_NFC_CONTEXT;
-#endif
-/*******************************************************************************
-** HAL API Function Prototypes
-*******************************************************************************/
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*******************************************************************************
-**
-** Function         HAL_NfcInitialize
-**
-** Description      Called when HAL library is loaded.
-**
-**                  Initialize GKI and start the HCIT task
-**
-** Returns          void
-**
-*******************************************************************************/
-void HAL_NfcInitialize(void);
-
-/*******************************************************************************
-**
-** Function         HAL_NfcTerminate
-**
-** Description      Called to terminate NFC HAL
-**
-** Returns          void
-**
-*******************************************************************************/
-void HAL_NfcTerminate(void);
-
-/*******************************************************************************
-**
-** Function         HAL_NfcOpen
-**
-** Description      Open transport and intialize the NFCC, and
-**                  Register callback for HAL event notifications,
-**
-**                  HAL_OPEN_CPLT_EVT will notify when operation is complete.
-**
-** Returns          void
-**
-*******************************************************************************/
-void HAL_NfcOpen(tHAL_NFC_CBACK* p_hal_cback,
-                 tHAL_NFC_DATA_CBACK* p_data_cback);
-
-/*******************************************************************************
-**
-** Function         HAL_NfcClose
-**
-** Description      Prepare for shutdown. A HAL_CLOSE_CPLT_EVT will be
-**                  reported when complete.
-**
-** Returns          void
-**
-*******************************************************************************/
-void HAL_NfcClose(void);
-
-/*******************************************************************************
-**
-** Function         HAL_NfcCoreInitialized
-**
-** Description      Called after the CORE_INIT_RSP is received from the NFCC.
-**                  At this time, the HAL can do any chip-specific
-**                  configuration, and when finished signal the libnfc-nci with
-**                  event HAL_POST_INIT_CPLT_EVT.
-**
-** Returns          void
-**
-*******************************************************************************/
-void HAL_NfcCoreInitialized(uint8_t* p_core_init_rsp_params);
-
-/*******************************************************************************
-**
-** Function         HAL_NfcWrite
-**
-** Description      Send an NCI control message or data packet to the
-**                  transport. If an NCI command message exceeds the transport
-**                  size, HAL is responsible for fragmenting it, Data packets
-**                  must be of the correct size.
-**
-** Returns          void
-**
-*******************************************************************************/
-void HAL_NfcWrite(uint16_t data_len, uint8_t* p_data);
-
-/*******************************************************************************
-**
-** Function         HAL_NfcPreDiscover
-**
-** Description      Perform any vendor-specific pre-discovery actions (if
-**                  needed).If any actions were performed true will be
-**                  returned, and HAL_PRE_DISCOVER_CPLT_EVT will notify when
-**                  actions are completed.
-**
-** Returns          true if vendor-specific pre-discovery actions initialized
-**                  false if no vendor-specific pre-discovery actions are
-**                  needed.
-**
-*******************************************************************************/
-bool HAL_NfcPreDiscover(void);
-
-/*******************************************************************************
-**
-** Function         HAL_NfcControlGranted
-**
-** Description      Grant control to HAL control for sending NCI commands.
-**
-**                  Call in response to HAL_REQUEST_CONTROL_EVT.
-**
-**                  Must only be called when there are no NCI commands pending.
-**
-**                  HAL_RELEASE_CONTROL_EVT will notify when HAL no longer
-**                  needs control of NCI.
-**
-**
-** Returns          void
-**
-*******************************************************************************/
-void HAL_NfcControlGranted(void);
-
-/*******************************************************************************
-**
-** Function         HAL_NfcPowerCycle
-**
-** Description      Restart NFCC by power cyle
-**
-**                  HAL_OPEN_CPLT_EVT will notify when operation is complete.
-**
-** Returns          void
-**
-*******************************************************************************/
-void HAL_NfcPowerCycle(void);
-
-/*******************************************************************************
-**
-** Function         HAL_NfcGetMaxNfcee
-**
-** Description      Retrieve the maximum number of NFCEEs supported by NFCC
-**
-** Returns          the maximum number of NFCEEs supported by NFCC
-**
-*******************************************************************************/
-uint8_t HAL_NfcGetMaxNfcee(void);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* NFC_HAL_API_H  */
diff --git a/src/hal/include/nfc_hal_target.h b/src/hal/include/nfc_hal_target.h
deleted file mode 100644
index 8b766e3..0000000
--- a/src/hal/include/nfc_hal_target.h
+++ /dev/null
@@ -1,437 +0,0 @@
-/******************************************************************************
- *
- *  Copyright (C) 2012-2014 Broadcom Corporation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at:
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-#ifndef NFC_HAL_TARGET_H
-#define NFC_HAL_TARGET_H
-
-#include "gki.h"
-#include "data_types.h"
-
-/****************************************************************************
-** NCI related configuration
-****************************************************************************/
-
-/* Initial Max Control Packet Payload Size (until receiving payload size in
- * INIT_CORE_RSP) */
-#ifndef NFC_HAL_NCI_INIT_CTRL_PAYLOAD_SIZE
-#define NFC_HAL_NCI_INIT_CTRL_PAYLOAD_SIZE 0xFF
-#endif
-
-/* Number of bytes to reserve in front of NCI messages (e.g. for transport
- * header) */
-#ifndef NFC_HAL_NCI_MSG_OFFSET_SIZE
-#define NFC_HAL_NCI_MSG_OFFSET_SIZE 1
-#endif
-
-/* NFC-WAKE */
-#ifndef NFC_HAL_LP_NFC_WAKE_GPIO
-#define NFC_HAL_LP_NFC_WAKE_GPIO UPIO_GENERAL3
-#endif
-
-/* NFCC snooze mode idle timeout before deassert NFC_WAKE in ms */
-#ifndef NFC_HAL_LP_IDLE_TIMEOUT
-#define NFC_HAL_LP_IDLE_TIMEOUT 100
-#endif
-
-/* NFC snooze mode */
-#ifndef NFC_HAL_LP_SNOOZE_MODE
-#define NFC_HAL_LP_SNOOZE_MODE NFC_HAL_LP_SNOOZE_MODE_UART
-#endif
-
-/* Idle Threshold Host in 100ms unit */
-#ifndef NFC_HAL_LP_IDLE_THRESHOLD_HOST
-#define NFC_HAL_LP_IDLE_THRESHOLD_HOST 0
-#endif
-
-/* Idle Threshold HC in 100ms unit */
-#ifndef NFC_HAL_LP_IDLE_THRESHOLD_HC
-#define NFC_HAL_LP_IDLE_THRESHOLD_HC 0
-#endif
-
-/* Default NFCC power-up baud rate */
-#ifndef NFC_HAL_DEFAULT_BAUD
-#define NFC_HAL_DEFAULT_BAUD USERIAL_BAUD_115200
-#endif
-
-/* time (in ms) between power off and on NFCC */
-#ifndef NFC_HAL_POWER_CYCLE_DELAY
-#define NFC_HAL_POWER_CYCLE_DELAY 100
-#endif
-
-/* time (in ms) between power off and on NFCC */
-#ifndef NFC_HAL_NFCC_ENABLE_TIMEOUT
-#define NFC_HAL_NFCC_ENABLE_TIMEOUT 1000
-#endif
-
-#ifndef NFC_HAL_PRM_DEBUG
-#define NFC_HAL_PRM_DEBUG true
-#endif
-
-/* max patch data length (Can be overridden by platform for ACL HCI command
- * size) */
-#ifndef NFC_HAL_PRM_HCD_CMD_MAXLEN
-#define NFC_HAL_PRM_HCD_CMD_MAXLEN 250
-#endif
-
-/* Require PreI2C patch by default */
-#ifndef NFC_HAL_PRE_I2C_PATCH_INCLUDED
-#define NFC_HAL_PRE_I2C_PATCH_INCLUDED true
-#endif
-
-/* Mininum payload size for SPD NCI commands (used to validate
- * HAL_NfcPrmSetSpdNciCmdPayloadSize) */
-/* Default is 32, as required by the NCI specifications; however this value may
- * be          */
-/* over-riden for platforms that have transport packet limitations */
-#ifndef NFC_HAL_PRM_MIN_NCI_CMD_PAYLOAD_SIZE
-#define NFC_HAL_PRM_MIN_NCI_CMD_PAYLOAD_SIZE (32)
-#endif
-
-/* amount of time to wait for authenticating/committing patch to NVM */
-#ifndef NFC_HAL_PRM_COMMIT_DELAY
-#define NFC_HAL_PRM_COMMIT_DELAY (30000)
-#endif
-
-/* amount of time to wait after downloading preI2C patch before downloading
- * LPM/FPM patch */
-#ifndef NFC_HAL_PRM_POST_I2C_FIX_DELAY
-#define NFC_HAL_PRM_POST_I2C_FIX_DELAY (200)
-#endif
-
-/* NFCC will respond to more than one technology during listen discovery  */
-#ifndef NFC_HAL_DM_MULTI_TECH_RESP
-#define NFC_HAL_DM_MULTI_TECH_RESP true
-#endif
-
-/* Data rate for 15693 command/response, it must be same as
- * RW_I93_FLAG_DATA_RATE in nfc_target.h */
-#define NFC_HAL_I93_FLAG_DATA_RATE_LOW 0x00
-#define NFC_HAL_I93_FLAG_DATA_RATE_HIGH 0x02
-
-#ifndef NFC_HAL_I93_FLAG_DATA_RATE
-#define NFC_HAL_I93_FLAG_DATA_RATE NFC_HAL_I93_FLAG_DATA_RATE_HIGH
-#endif
-
-/* NFC HAL HCI */
-#ifndef NFC_HAL_HCI_INCLUDED
-#define NFC_HAL_HCI_INCLUDED true
-#endif
-
-/* Quick Timer */
-#ifndef QUICK_TIMER_TICKS_PER_SEC
-#define QUICK_TIMER_TICKS_PER_SEC 100 /* 10ms timer */
-#endif
-
-#ifndef NFC_HAL_SHARED_TRANSPORT_ENABLED
-#define NFC_HAL_SHARED_TRANSPORT_ENABLED false
-#endif
-
-/* Enable verbose tracing by default */
-#ifndef NFC_HAL_TRACE_VERBOSE
-#define NFC_HAL_TRACE_VERBOSE true
-#endif
-
-#ifndef NFC_HAL_INITIAL_TRACE_LEVEL
-#define NFC_HAL_INITIAL_TRACE_LEVEL 5
-#endif
-
-/* Map NFC serial port to USERIAL_PORT_6 by default */
-#ifndef USERIAL_NFC_PORT
-#define USERIAL_NFC_PORT (USERIAL_PORT_6)
-#endif
-
-/* Restore NFCC baud rate to default on shutdown if baud rate was updated */
-#ifndef NFC_HAL_RESTORE_BAUD_ON_SHUTDOWN
-#define NFC_HAL_RESTORE_BAUD_ON_SHUTDOWN true
-#endif
-
-/* Enable protocol tracing by default */
-#ifndef NFC_HAL_TRACE_PROTOCOL
-#define NFC_HAL_TRACE_PROTOCOL true
-#endif
-
-/* Legacy protocol-trace-enable macro */
-#ifndef BT_TRACE_PROTOCOL
-#define BT_TRACE_PROTOCOL (NFC_HAL_TRACE_PROTOCOL)
-#endif
-
-/* Enable HAL tracing by default */
-#ifndef NFC_HAL_USE_TRACES
-#define NFC_HAL_USE_TRACES true
-#endif
-
-/* HAL trace macros */
-#if (NFC_HAL_USE_TRACES == true)
-#define NCI_TRACE_0(l, t, m) \
-  LogMsg((TRACE_CTRL_GENERAL | (l) | TRACE_ORG_STACK | (t)), (m))
-#define NCI_TRACE_1(l, t, m, p1) \
-  LogMsg(TRACE_CTRL_GENERAL | (l) | TRACE_ORG_STACK | (t), (m), (uintptr_t)(p1))
-#define NCI_TRACE_2(l, t, m, p1, p2)                            \
-  LogMsg(TRACE_CTRL_GENERAL | (l) | TRACE_ORG_STACK | (t), (m), \
-         (uintptr_t)(p1), (uintptr_t)(p2))
-#define NCI_TRACE_3(l, t, m, p1, p2, p3)                        \
-  LogMsg(TRACE_CTRL_GENERAL | (l) | TRACE_ORG_STACK | (t), (m), \
-         (uintptr_t)(p1), (uintptr_t)(p2), (uintptr_t)(p3))
-#define NCI_TRACE_4(l, t, m, p1, p2, p3, p4)                    \
-  LogMsg(TRACE_CTRL_GENERAL | (l) | TRACE_ORG_STACK | (t), (m), \
-         (uintptr_t)(p1), (uintptr_t)(p2), (uintptr_t)(p3), (uintptr_t)(p4))
-#define NCI_TRACE_5(l, t, m, p1, p2, p3, p4, p5)                             \
-  LogMsg(TRACE_CTRL_GENERAL | (l) | TRACE_ORG_STACK | (t), (m),              \
-         (uintptr_t)(p1), (uintptr_t)(p2), (uintptr_t)(p3), (uintptr_t)(p4), \
-         (uintptr_t)(p5))
-#define NCI_TRACE_6(l, t, m, p1, p2, p3, p4, p5, p6)                         \
-  LogMsg(TRACE_CTRL_GENERAL | (l) | TRACE_ORG_STACK | (t), (m),              \
-         (uintptr_t)(p1), (uintptr_t)(p2), (uintptr_t)(p3), (uintptr_t)(p4), \
-         (uintptr_t)(p5), (uintptr_t)(p6))
-
-#define HAL_TRACE_ERROR0(m)                              \
-  {                                                      \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_ERROR)  \
-      NCI_TRACE_0(TRACE_LAYER_HAL, TRACE_TYPE_ERROR, m); \
-  }
-#define HAL_TRACE_ERROR1(m, p1)                              \
-  {                                                          \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_ERROR)      \
-      NCI_TRACE_1(TRACE_LAYER_HAL, TRACE_TYPE_ERROR, m, p1); \
-  }
-#define HAL_TRACE_ERROR2(m, p1, p2)                              \
-  {                                                              \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_ERROR)          \
-      NCI_TRACE_2(TRACE_LAYER_HAL, TRACE_TYPE_ERROR, m, p1, p2); \
-  }
-#define HAL_TRACE_ERROR3(m, p1, p2, p3)                              \
-  {                                                                  \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_ERROR)              \
-      NCI_TRACE_3(TRACE_LAYER_HAL, TRACE_TYPE_ERROR, m, p1, p2, p3); \
-  }
-#define HAL_TRACE_ERROR4(m, p1, p2, p3, p4)                              \
-  {                                                                      \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                  \
-      NCI_TRACE_4(TRACE_LAYER_HAL, TRACE_TYPE_ERROR, m, p1, p2, p3, p4); \
-  }
-#define HAL_TRACE_ERROR5(m, p1, p2, p3, p4, p5)                              \
-  {                                                                          \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                      \
-      NCI_TRACE_5(TRACE_LAYER_HAL, TRACE_TYPE_ERROR, m, p1, p2, p3, p4, p5); \
-  }
-#define HAL_TRACE_ERROR6(m, p1, p2, p3, p4, p5, p6)                         \
-  {                                                                         \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                     \
-      NCI_TRACE_6(TRACE_LAYER_HAL, TRACE_TYPE_ERROR, m, p1, p2, p3, p4, p5, \
-                  p6);                                                      \
-  }
-
-#define HAL_TRACE_WARNING0(m)                              \
-  {                                                        \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_WARNING)  \
-      NCI_TRACE_0(TRACE_LAYER_HAL, TRACE_TYPE_WARNING, m); \
-  }
-#define HAL_TRACE_WARNING1(m, p1)                              \
-  {                                                            \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_WARNING)      \
-      NCI_TRACE_1(TRACE_LAYER_HAL, TRACE_TYPE_WARNING, m, p1); \
-  }
-#define HAL_TRACE_WARNING2(m, p1, p2)                              \
-  {                                                                \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_WARNING)          \
-      NCI_TRACE_2(TRACE_LAYER_HAL, TRACE_TYPE_WARNING, m, p1, p2); \
-  }
-#define HAL_TRACE_WARNING3(m, p1, p2, p3)                              \
-  {                                                                    \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_WARNING)              \
-      NCI_TRACE_3(TRACE_LAYER_HAL, TRACE_TYPE_WARNING, m, p1, p2, p3); \
-  }
-#define HAL_TRACE_WARNING4(m, p1, p2, p3, p4)                              \
-  {                                                                        \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                  \
-      NCI_TRACE_4(TRACE_LAYER_HAL, TRACE_TYPE_WARNING, m, p1, p2, p3, p4); \
-  }
-#define HAL_TRACE_WARNING5(m, p1, p2, p3, p4, p5)                              \
-  {                                                                            \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                      \
-      NCI_TRACE_5(TRACE_LAYER_HAL, TRACE_TYPE_WARNING, m, p1, p2, p3, p4, p5); \
-  }
-#define HAL_TRACE_WARNING6(m, p1, p2, p3, p4, p5, p6)                         \
-  {                                                                           \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                     \
-      NCI_TRACE_6(TRACE_LAYER_HAL, TRACE_TYPE_WARNING, m, p1, p2, p3, p4, p5, \
-                  p6);                                                        \
-  }
-
-#define HAL_TRACE_API0(m)                              \
-  {                                                    \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_API)  \
-      NCI_TRACE_0(TRACE_LAYER_HAL, TRACE_TYPE_API, m); \
-  }
-#define HAL_TRACE_API1(m, p1)                              \
-  {                                                        \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_API)      \
-      NCI_TRACE_1(TRACE_LAYER_HAL, TRACE_TYPE_API, m, p1); \
-  }
-#define HAL_TRACE_API2(m, p1, p2)                              \
-  {                                                            \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_API)          \
-      NCI_TRACE_2(TRACE_LAYER_HAL, TRACE_TYPE_API, m, p1, p2); \
-  }
-#define HAL_TRACE_API3(m, p1, p2, p3)                              \
-  {                                                                \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_API)              \
-      NCI_TRACE_3(TRACE_LAYER_HAL, TRACE_TYPE_API, m, p1, p2, p3); \
-  }
-#define HAL_TRACE_API4(m, p1, p2, p3, p4)                              \
-  {                                                                    \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_API)                  \
-      NCI_TRACE_4(TRACE_LAYER_HAL, TRACE_TYPE_API, m, p1, p2, p3, p4); \
-  }
-#define HAL_TRACE_API5(m, p1, p2, p3, p4, p5)                              \
-  {                                                                        \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_API)                      \
-      NCI_TRACE_5(TRACE_LAYER_HAL, TRACE_TYPE_API, m, p1, p2, p3, p4, p5); \
-  }
-#define HAL_TRACE_API6(m, p1, p2, p3, p4, p5, p6)                              \
-  {                                                                            \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_API)                          \
-      NCI_TRACE_6(TRACE_LAYER_HAL, TRACE_TYPE_API, m, p1, p2, p3, p4, p5, p6); \
-  }
-
-#define HAL_TRACE_EVENT0(m)                              \
-  {                                                      \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_EVENT)  \
-      NCI_TRACE_0(TRACE_LAYER_HAL, TRACE_TYPE_EVENT, m); \
-  }
-#define HAL_TRACE_EVENT1(m, p1)                              \
-  {                                                          \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_EVENT)      \
-      NCI_TRACE_1(TRACE_LAYER_HAL, TRACE_TYPE_EVENT, m, p1); \
-  }
-#define HAL_TRACE_EVENT2(m, p1, p2)                              \
-  {                                                              \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_EVENT)          \
-      NCI_TRACE_2(TRACE_LAYER_HAL, TRACE_TYPE_EVENT, m, p1, p2); \
-  }
-#define HAL_TRACE_EVENT3(m, p1, p2, p3)                              \
-  {                                                                  \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_EVENT)              \
-      NCI_TRACE_3(TRACE_LAYER_HAL, TRACE_TYPE_EVENT, m, p1, p2, p3); \
-  }
-#define HAL_TRACE_EVENT4(m, p1, p2, p3, p4)                              \
-  {                                                                      \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                  \
-      NCI_TRACE_4(TRACE_LAYER_HAL, TRACE_TYPE_EVENT, m, p1, p2, p3, p4); \
-  }
-#define HAL_TRACE_EVENT5(m, p1, p2, p3, p4, p5)                              \
-  {                                                                          \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                      \
-      NCI_TRACE_5(TRACE_LAYER_HAL, TRACE_TYPE_EVENT, m, p1, p2, p3, p4, p5); \
-  }
-#define HAL_TRACE_EVENT6(m, p1, p2, p3, p4, p5, p6)                         \
-  {                                                                         \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                     \
-      NCI_TRACE_6(TRACE_LAYER_HAL, TRACE_TYPE_EVENT, m, p1, p2, p3, p4, p5, \
-                  p6);                                                      \
-  }
-
-#define HAL_TRACE_DEBUG0(m)                              \
-  {                                                      \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)  \
-      NCI_TRACE_0(TRACE_LAYER_HAL, TRACE_TYPE_DEBUG, m); \
-  }
-#define HAL_TRACE_DEBUG1(m, p1)                              \
-  {                                                          \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)      \
-      NCI_TRACE_1(TRACE_LAYER_HAL, TRACE_TYPE_DEBUG, m, p1); \
-  }
-#define HAL_TRACE_DEBUG2(m, p1, p2)                              \
-  {                                                              \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)          \
-      NCI_TRACE_2(TRACE_LAYER_HAL, TRACE_TYPE_DEBUG, m, p1, p2); \
-  }
-#define HAL_TRACE_DEBUG3(m, p1, p2, p3)                              \
-  {                                                                  \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)              \
-      NCI_TRACE_3(TRACE_LAYER_HAL, TRACE_TYPE_DEBUG, m, p1, p2, p3); \
-  }
-#define HAL_TRACE_DEBUG4(m, p1, p2, p3, p4)                              \
-  {                                                                      \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                  \
-      NCI_TRACE_4(TRACE_LAYER_HAL, TRACE_TYPE_DEBUG, m, p1, p2, p3, p4); \
-  }
-#define HAL_TRACE_DEBUG5(m, p1, p2, p3, p4, p5)                              \
-  {                                                                          \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                      \
-      NCI_TRACE_5(TRACE_LAYER_HAL, TRACE_TYPE_DEBUG, m, p1, p2, p3, p4, p5); \
-  }
-#define HAL_TRACE_DEBUG6(m, p1, p2, p3, p4, p5, p6)                         \
-  {                                                                         \
-    if (nfc_hal_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                     \
-      NCI_TRACE_6(TRACE_LAYER_HAL, TRACE_TYPE_DEBUG, m, p1, p2, p3, p4, p5, \
-                  p6);                                                      \
-  }
-
-#else /* Disable HAL tracing */
-
-#define HAL_TRACE_0(l, t, m)
-#define HAL_TRACE_1(l, t, m, p1)
-#define HAL_TRACE_2(l, t, m, p1, p2)
-#define HAL_TRACE_3(l, t, m, p1, p2, p3)
-#define HAL_TRACE_4(l, t, m, p1, p2, p3, p4)
-#define HAL_TRACE_5(l, t, m, p1, p2, p3, p4, p5)
-#define HAL_TRACE_6(l, t, m, p1, p2, p3, p4, p5, p6)
-
-#define HAL_TRACE_ERROR0(m)
-#define HAL_TRACE_ERROR1(m, p1)
-#define HAL_TRACE_ERROR2(m, p1, p2)
-#define HAL_TRACE_ERROR3(m, p1, p2, p3)
-#define HAL_TRACE_ERROR4(m, p1, p2, p3, p4)
-#define HAL_TRACE_ERROR5(m, p1, p2, p3, p4, p5)
-#define HAL_TRACE_ERROR6(m, p1, p2, p3, p4, p5, p6)
-
-#define HAL_TRACE_WARNING0(m)
-#define HAL_TRACE_WARNING1(m, p1)
-#define HAL_TRACE_WARNING2(m, p1, p2)
-#define HAL_TRACE_WARNING3(m, p1, p2, p3)
-#define HAL_TRACE_WARNING4(m, p1, p2, p3, p4)
-#define HAL_TRACE_WARNING5(m, p1, p2, p3, p4, p5)
-#define HAL_TRACE_WARNING6(m, p1, p2, p3, p4, p5, p6)
-
-#define HAL_TRACE_API0(m)
-#define HAL_TRACE_API1(m, p1)
-#define HAL_TRACE_API2(m, p1, p2)
-#define HAL_TRACE_API3(m, p1, p2, p3)
-#define HAL_TRACE_API4(m, p1, p2, p3, p4)
-#define HAL_TRACE_API5(m, p1, p2, p3, p4, p5)
-#define HAL_TRACE_API6(m, p1, p2, p3, p4, p5, p6)
-
-#define HAL_TRACE_EVENT0(m)
-#define HAL_TRACE_EVENT1(m, p1)
-#define HAL_TRACE_EVENT2(m, p1, p2)
-#define HAL_TRACE_EVENT3(m, p1, p2, p3)
-#define HAL_TRACE_EVENT4(m, p1, p2, p3, p4)
-#define HAL_TRACE_EVENT5(m, p1, p2, p3, p4, p5)
-#define HAL_TRACE_EVENT6(m, p1, p2, p3, p4, p5, p6)
-
-#define HAL_TRACE_DEBUG0(m)
-#define HAL_TRACE_DEBUG1(m, p1)
-#define HAL_TRACE_DEBUG2(m, p1, p2)
-#define HAL_TRACE_DEBUG3(m, p1, p2, p3)
-#define HAL_TRACE_DEBUG4(m, p1, p2, p3, p4)
-#define HAL_TRACE_DEBUG5(m, p1, p2, p3, p4, p5)
-#define HAL_TRACE_DEBUG6(m, p1, p2, p3, p4, p5, p6)
-#endif /* Disable HAL tracing */
-
-#endif /* GKI_TARGET_H */
diff --git a/src/hal/include/nfc_types.h b/src/hal/include/nfc_types.h
deleted file mode 100644
index acd9126..0000000
--- a/src/hal/include/nfc_types.h
+++ /dev/null
@@ -1,351 +0,0 @@
-/******************************************************************************
- *
- *  Copyright (C) 2012-2014 Broadcom Corporation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at:
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-#ifndef NFC_TYPES_H
-#define NFC_TYPES_H
-#include "Nxp_Features.h"
-/****************************************************************************
-** NFC_HDR header definition for NFC messages
-*****************************************************************************/
-typedef struct {
-  uint16_t event;
-  uint16_t len;
-  uint16_t offset;
-  uint16_t layer_specific;
-} NFC_HDR;
-#define NFC_HDR_SIZE (sizeof(NFC_HDR))
-
-/* Mask for NFC_HDR event field */
-#define NFC_EVT_MASK 0xFF00
-#define NFC_SUB_EVT_MASK 0x00FF
-
-/****************************************************************************
-** NFC_HAL_TASK  definitions
-*****************************************************************************/
-
-/* NFC_HAL_TASK event messages */
-/* NCI message for sending to NFCC          */
-#define NFC_HAL_EVT_TO_NFC_NCI 0x0100
-/* Request to start NCIT quick timer        */
-#define NFC_HAL_EVT_POST_CORE_RESET 0x0200
-/* Request to start chip-specific config    */
-#define NFC_HAL_EVT_TO_START_QUICK_TIMER 0x0300
-/* NCI message for hci persistency data     */
-#define NFC_HAL_EVT_HCI 0x0400
-/* NCI message to issue prediscover config  */
-#define NFC_HAL_EVT_PRE_DISCOVER 0x0500
-/* permission to send commands queued in HAL*/
-#define NFC_HAL_EVT_CONTROL_GRANTED 0x0600
-
-/* NFC_HAL_TASK sub event messages */
-#define NFC_HAL_HCI_RSP_NV_READ_EVT (0x01 | NFC_HAL_EVT_HCI)
-#define NFC_HAL_HCI_RSP_NV_WRITE_EVT (0x02 | NFC_HAL_EVT_HCI)
-#define NFC_HAL_HCI_VSC_TIMEOUT_EVT (0x03 | NFC_HAL_EVT_HCI)
-
-/* Event masks for NFC_TASK messages */
-/* NCI message for sending to host stack    */
-#define NFC_EVT_TO_NFC_NCI 0x4000
-/* Error notification to NFC Task           */
-#define NFC_EVT_TO_NFC_ERR 0x4100
-/* Messages between NFC and NCI task        */
-#define NFC_EVT_TO_NFC_MSGS 0x4200
-
-/*****************************************************************************
-** Macros to get and put bytes to and from a stream (Little Endian format).
-*****************************************************************************/
-
-#define UINT32_TO_STREAM(p, u32)     \
-  {                                  \
-    *(p)++ = (uint8_t)(u32);         \
-    *(p)++ = (uint8_t)((u32) >> 8);  \
-    *(p)++ = (uint8_t)((u32) >> 16); \
-    *(p)++ = (uint8_t)((u32) >> 24); \
-  }
-#define UINT24_TO_STREAM(p, u24)     \
-  {                                  \
-    *(p)++ = (uint8_t)(u24);         \
-    *(p)++ = (uint8_t)((u24) >> 8);  \
-    *(p)++ = (uint8_t)((u24) >> 16); \
-  }
-#define UINT16_TO_STREAM(p, u16)    \
-  {                                 \
-    *(p)++ = (uint8_t)(u16);        \
-    *(p)++ = (uint8_t)((u16) >> 8); \
-  }
-#define UINT8_TO_STREAM(p, u8) \
-  { *(p)++ = (uint8_t)(u8); }
-#define INT8_TO_STREAM(p, u8) \
-  { *(p)++ = (int8_t)(u8); }
-#define ARRAY32_TO_STREAM(p, a)                                   \
-  {                                                               \
-    register int ijk;                                             \
-    for (ijk = 0; ijk < 32; ijk++) *(p)++ = (uint8_t)a[31 - ijk]; \
-  }
-#define ARRAY16_TO_STREAM(p, a)                                   \
-  {                                                               \
-    register int ijk;                                             \
-    for (ijk = 0; ijk < 16; ijk++) *(p)++ = (uint8_t)a[15 - ijk]; \
-  }
-#define ARRAY8_TO_STREAM(p, a)                                  \
-  {                                                             \
-    register int ijk;                                           \
-    for (ijk = 0; ijk < 8; ijk++) *(p)++ = (uint8_t)a[7 - ijk]; \
-  }
-#define BDADDR_TO_STREAM(p, a)                    \
-  {                                               \
-    register int ijk;                             \
-    for (ijk = 0; ijk < BD_ADDR_LEN; ijk++)       \
-      *(p)++ = (uint8_t)a[BD_ADDR_LEN - 1 - ijk]; \
-  }
-#define LAP_TO_STREAM(p, a)                   \
-  {                                           \
-    register int ijk;                         \
-    for (ijk = 0; ijk < LAP_LEN; ijk++)       \
-      *(p)++ = (uint8_t)a[LAP_LEN - 1 - ijk]; \
-  }
-#define DEVCLASS_TO_STREAM(p, a)                    \
-  {                                                 \
-    register int ijk;                               \
-    for (ijk = 0; ijk < DEV_CLASS_LEN; ijk++)       \
-      *(p)++ = (uint8_t)a[DEV_CLASS_LEN - 1 - ijk]; \
-  }
-#define ARRAY_TO_STREAM(p, a, len)                            \
-  {                                                           \
-    register int ijk;                                         \
-    for (ijk = 0; ijk < len; ijk++) *(p)++ = (uint8_t)a[ijk]; \
-  }
-#define REVERSE_ARRAY_TO_STREAM(p, a, len)                              \
-  {                                                                     \
-    register int ijk;                                                   \
-    for (ijk = 0; ijk < len; ijk++) *(p)++ = (uint8_t)a[len - 1 - ijk]; \
-  }
-
-#define STREAM_TO_UINT8(u8, p) \
-  {                            \
-    u8 = (uint8_t)(*(p));      \
-    (p) += 1;                  \
-  }
-#define STREAM_TO_UINT16(u16, p)                                \
-  {                                                             \
-    u16 = ((uint16_t)(*(p)) + (((uint16_t)(*((p) + 1))) << 8)); \
-    (p) += 2;                                                   \
-  }
-#define STREAM_TO_UINT24(u32, p)                                    \
-  {                                                                 \
-    u32 = (((uint32_t)(*(p))) + ((((uint32_t)(*((p) + 1)))) << 8) + \
-           ((((uint32_t)(*((p) + 2)))) << 16));                     \
-    (p) += 3;                                                       \
-  }
-#define STREAM_TO_UINT32(u32, p)                                    \
-  {                                                                 \
-    u32 = (((uint32_t)(*(p))) + ((((uint32_t)(*((p) + 1)))) << 8) + \
-           ((((uint32_t)(*((p) + 2)))) << 16) +                     \
-           ((((uint32_t)(*((p) + 3)))) << 24));                     \
-    (p) += 4;                                                       \
-  }
-#define STREAM_TO_BDADDR(a, p)                              \
-  {                                                         \
-    register int ijk;                                       \
-    register uint8_t* pbda = (uint8_t*)a + BD_ADDR_LEN - 1; \
-    for (ijk = 0; ijk < BD_ADDR_LEN; ijk++) *pbda-- = *p++; \
-  }
-#define STREAM_TO_ARRAY32(a, p)                   \
-  {                                               \
-    register int ijk;                             \
-    register uint8_t* _pa = (uint8_t*)a + 31;     \
-    for (ijk = 0; ijk < 32; ijk++) *_pa-- = *p++; \
-  }
-#define STREAM_TO_ARRAY16(a, p)                   \
-  {                                               \
-    register int ijk;                             \
-    register uint8_t* _pa = (uint8_t*)a + 15;     \
-    for (ijk = 0; ijk < 16; ijk++) *_pa-- = *p++; \
-  }
-#define STREAM_TO_ARRAY8(a, p)                   \
-  {                                              \
-    register int ijk;                            \
-    register uint8_t* _pa = (uint8_t*)a + 7;     \
-    for (ijk = 0; ijk < 8; ijk++) *_pa-- = *p++; \
-  }
-#define STREAM_TO_DEVCLASS(a, p)                             \
-  {                                                          \
-    register int ijk;                                        \
-    register uint8_t* _pa = (uint8_t*)a + DEV_CLASS_LEN - 1; \
-    for (ijk = 0; ijk < DEV_CLASS_LEN; ijk++) *_pa-- = *p++; \
-  }
-#define STREAM_TO_LAP(a, p)                             \
-  {                                                     \
-    register int ijk;                                   \
-    register uint8_t* plap = (uint8_t*)a + LAP_LEN - 1; \
-    for (ijk = 0; ijk < LAP_LEN; ijk++) *plap-- = *p++; \
-  }
-#define STREAM_TO_ARRAY(a, p, len)                             \
-  {                                                            \
-    register int ijk;                                          \
-    for (ijk = 0; ijk < len; ijk++) ((uint8_t*)a)[ijk] = *p++; \
-  }
-#define REVERSE_STREAM_TO_ARRAY(a, p, len)         \
-  {                                                \
-    register int ijk;                              \
-    register uint8_t* _pa = (uint8_t*)a + len - 1; \
-    for (ijk = 0; ijk < len; ijk++) *_pa-- = *p++; \
-  }
-
-/*****************************************************************************
-** Macros to get and put bytes to and from a field (Little Endian format).
-** These are the same as to stream, except the pointer is not incremented.
-*****************************************************************************/
-
-#define UINT32_TO_FIELD(p, u32)                    \
-  {                                                \
-    *(uint8_t*)(p) = (uint8_t)(u32);               \
-    *((uint8_t*)(p) + 1) = (uint8_t)((u32) >> 8);  \
-    *((uint8_t*)(p) + 2) = (uint8_t)((u32) >> 16); \
-    *((uint8_t*)(p) + 3) = (uint8_t)((u32) >> 24); \
-  }
-#define UINT24_TO_FIELD(p, u24)                    \
-  {                                                \
-    *(uint8_t*)(p) = (uint8_t)(u24);               \
-    *((uint8_t*)(p) + 1) = (uint8_t)((u24) >> 8);  \
-    *((uint8_t*)(p) + 2) = (uint8_t)((u24) >> 16); \
-  }
-#define UINT16_TO_FIELD(p, u16)                   \
-  {                                               \
-    *(uint8_t*)(p) = (uint8_t)(u16);              \
-    *((uint8_t*)(p) + 1) = (uint8_t)((u16) >> 8); \
-  }
-#define UINT8_TO_FIELD(p, u8) \
-  { *(uint8_t*)(p) = (uint8_t)(u8); }
-
-/*****************************************************************************
-** Macros to get and put bytes to and from a stream (Big Endian format)
-*****************************************************************************/
-
-#define UINT32_TO_BE_STREAM(p, u32)  \
-  {                                  \
-    *(p)++ = (uint8_t)((u32) >> 24); \
-    *(p)++ = (uint8_t)((u32) >> 16); \
-    *(p)++ = (uint8_t)((u32) >> 8);  \
-    *(p)++ = (uint8_t)(u32);         \
-  }
-#define UINT24_TO_BE_STREAM(p, u24)  \
-  {                                  \
-    *(p)++ = (uint8_t)((u24) >> 16); \
-    *(p)++ = (uint8_t)((u24) >> 8);  \
-    *(p)++ = (uint8_t)(u24);         \
-  }
-#define UINT16_TO_BE_STREAM(p, u16) \
-  {                                 \
-    *(p)++ = (uint8_t)((u16) >> 8); \
-    *(p)++ = (uint8_t)(u16);        \
-  }
-#define UINT8_TO_BE_STREAM(p, u8) \
-  { *(p)++ = (uint8_t)(u8); }
-#define ARRAY_TO_BE_STREAM(p, a, len)                         \
-  {                                                           \
-    register int ijk;                                         \
-    for (ijk = 0; ijk < len; ijk++) *(p)++ = (uint8_t)a[ijk]; \
-  }
-
-#define BE_STREAM_TO_UINT8(u8, p) \
-  {                               \
-    u8 = (uint8_t)(*(p));         \
-    (p) += 1;                     \
-  }
-#define BE_STREAM_TO_UINT16(u16, p)                                     \
-  {                                                                     \
-    u16 = (uint16_t)(((uint16_t)(*(p)) << 8) + (uint16_t)(*((p) + 1))); \
-    (p) += 2;                                                           \
-  }
-#define BE_STREAM_TO_UINT24(u32, p)                                   \
-  {                                                                   \
-    u32 = (((uint32_t)(*((p) + 2))) + ((uint32_t)(*((p) + 1)) << 8) + \
-           ((uint32_t)(*(p)) << 16));                                 \
-    (p) += 3;                                                         \
-  }
-#define BE_STREAM_TO_UINT32(u32, p)                                    \
-  {                                                                    \
-    u32 = ((uint32_t)(*((p) + 3)) + ((uint32_t)(*((p) + 2)) << 8) +    \
-           ((uint32_t)(*((p) + 1)) << 16) + ((uint32_t)(*(p)) << 24)); \
-    (p) += 4;                                                          \
-  }
-#define BE_STREAM_TO_ARRAY(p, a, len)                          \
-  {                                                            \
-    register int ijk;                                          \
-    for (ijk = 0; ijk < len; ijk++) ((uint8_t*)a)[ijk] = *p++; \
-  }
-
-/*****************************************************************************
-** Macros to get and put bytes to and from a field (Big Endian format).
-** These are the same as to stream, except the pointer is not incremented.
-*****************************************************************************/
-
-#define UINT32_TO_BE_FIELD(p, u32)                 \
-  {                                                \
-    *(uint8_t*)(p) = (uint8_t)((u32) >> 24);       \
-    *((uint8_t*)(p) + 1) = (uint8_t)((u32) >> 16); \
-    *((uint8_t*)(p) + 2) = (uint8_t)((u32) >> 8);  \
-    *((uint8_t*)(p) + 3) = (uint8_t)(u32);         \
-  }
-#define UINT24_TO_BE_FIELD(p, u24)                \
-  {                                               \
-    *(uint8_t*)(p) = (uint8_t)((u24) >> 16);      \
-    *((uint8_t*)(p) + 1) = (uint8_t)((u24) >> 8); \
-    *((uint8_t*)(p) + 2) = (uint8_t)(u24);        \
-  }
-#define UINT16_TO_BE_FIELD(p, u16)          \
-  {                                         \
-    *(uint8_t*)(p) = (uint8_t)((u16) >> 8); \
-    *((uint8_t*)(p) + 1) = (uint8_t)(u16);  \
-  }
-#define UINT8_TO_BE_FIELD(p, u8) \
-  { *(uint8_t*)(p) = (uint8_t)(u8); }
-
-/*****************************************************************************
-** Define trace levels
-*****************************************************************************/
-
-/* No trace messages to be generated    */
-#define BT_TRACE_LEVEL_NONE 0
-/* Error condition trace messages       */
-#define BT_TRACE_LEVEL_ERROR 1
-/* Warning condition trace messages     */
-#define BT_TRACE_LEVEL_WARNING 2
-/* API traces                           */
-#define BT_TRACE_LEVEL_API 3
-/* Debug messages for events            */
-#define BT_TRACE_LEVEL_EVENT 4
-/* Full debug messages                  */
-#define BT_TRACE_LEVEL_DEBUG 5
-
-#define TRACE_CTRL_GENERAL 0x00000000
-#define TRACE_LAYER_NCI 0x00280000
-#define TRACE_LAYER_HAL 0x00310000
-#define TRACE_LAYER_GKI 0x001a0000
-#define TRACE_ORG_STACK 0x00000000
-#define TRACE_ORG_GKI 0x00000400
-
-#define TRACE_TYPE_ERROR 0x00000000
-#define TRACE_TYPE_WARNING 0x00000001
-#define TRACE_TYPE_API 0x00000002
-#define TRACE_TYPE_EVENT 0x00000003
-#define TRACE_TYPE_DEBUG 0x00000004
-
-#define TRACE_TYPE_GENERIC 0x00000008
-
-#endif /* NFC_TYPES_H */
diff --git a/src/hal/int/nfc_brcm_defs.h b/src/hal/int/nfc_brcm_defs.h
deleted file mode 100644
index 3a7af18..0000000
--- a/src/hal/int/nfc_brcm_defs.h
+++ /dev/null
@@ -1,420 +0,0 @@
-/******************************************************************************
- *
- *  Copyright (C) 2012-2014 Broadcom Corporation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at:
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-/******************************************************************************
- *
- *  This file contains the Broadcom-specific defintions that are shared
- *  between HAL, nfc stack, adaptation layer and applications.
- *
- ******************************************************************************/
-
-#ifndef NFC_BRCM_DEFS_H
-#define NFC_BRCM_DEFS_H
-
-/*****************************************************************************
-** Broadcom HW ID definitions
-*****************************************************************************/
-#define BRCM_20791B3_ID 0x20791b03
-#define BRCM_20791B4_ID 0x20791b04
-#define BRCM_20791B5_ID 0x20791b05
-#define BRCM_43341B0_ID 0x43341b00
-#define BRCM_20795T1_ID 0x20795a01
-#define BRCM_20795A0_ID 0x20795a00
-#define BRCM_20795A1_ID 0x20795a10
-
-#define BRCM_NFC_GEN_MASK 0xFFFFF000 /* HW generation mask */
-#define BRCM_NFC_REV_MASK 0x00000FFF /* HW revision mask   */
-#define BRCM_NFC_20791_GEN 0x20791000
-#define BRCM_NFC_20791_GEN_MAX_EE 3 /* HCI access and 2 UICCs */
-#define BRCM_NFC_43341_GEN 0x43341000
-#define BRCM_NFC_43341_GEN_MAX_EE 3 /* HCI access and 2 UICCs */
-#define BRCM_NFC_20795_GEN 0x20795000
-#define BRCM_NFC_20795_GEN_MAX_EE 4 /* HCI access and 3 UICCs */
-
-/*****************************************************************************
-** Broadcom-specific NCI definitions
-*****************************************************************************/
-
-/**********************************************
- * NCI Message Proprietary  Group       - F
- **********************************************/
-#define NCI_MSG_TAG_SET_MEM 0x00
-#define NCI_MSG_TAG_GET_MEM 0x01
-#define NCI_MSG_T1T_SET_HR 0x02
-#define NCI_MSG_SET_CLF_REGISTERS 0x03
-#define NCI_MSG_GET_BUILD_INFO 0x04
-#define NCI_MSG_HCI_NETWK 0x05
-#define NCI_MSG_SET_FWFSM 0x06
-#define NCI_MSG_SET_UICCRDRF 0x07
-#define NCI_MSG_POWER_LEVEL 0x08
-#define NCI_MSG_FRAME_LOG 0x09
-#define NCI_MSG_UICC_READER_ACTION 0x0A
-#define NCI_MSG_SET_PPSE_RESPONSE 0x0B
-#define NCI_MSG_PRBS_SET 0x0C
-/* reset HCI network/close all pipes (S,D) register */
-#define NCI_MSG_RESET_ALL_UICC_CFG 0x0D
-#define NCI_MSG_GET_NFCEE_INFO 0x0E
-#define NCI_MSG_DISABLE_INIT_CHECK 0x0F
-#define NCI_MSG_ANTENNA_SELF_TEST 0x10
-#define NCI_MSG_SET_MAX_PKT_SIZE 0x11
-#define NCI_MSG_NCIP_CLK_REQ_OR_CAR_DET 0x12
-#define NCI_MSG_NCIP_CONFIG_DBUART 0x13
-#define NCI_MSG_NCIP_ENABLE_DVT_DRIVER 0x14
-#define NCI_MSG_SET_ASWP 0x15
-#define NCI_MSG_ENCAPSULATE_NCI 0x16
-#define NCI_MSG_CONFIGURE_ARM_JTAG 0x17
-#define NCI_MSG_STATISTICS 0x18
-#define NCI_MSG_SET_DSP_TABLE 0x19
-#define NCI_MSG_GET_DSP_TABLE 0x1a
-#define NCI_MSG_READY_RX_CMD 0x1b
-#define NCI_MSG_GET_VBAT 0x1c
-#define NCI_MSG_GET_XTAL_INDEX_FROM_DH 0x1d
-#define NCI_MSG_SWP_LOG 0x1e
-#define NCI_MSG_GET_PWRLEVEL 0x1f
-#define NCI_MSG_SET_VBAT_MONITOR 0x20
-#define NCI_MSG_SET_TINT_MODE 0x21
-#define NCI_MSG_ACCESS_APP 0x22
-#define NCI_MSG_SET_SECURE_MODE 0x23
-#define NCI_MSG_GET_NV_DEVICE 0x24
-#define NCI_MSG_LPTD 0x25
-#define NCI_MSG_SET_CE4_AS_SNOOZE 0x26
-#define NCI_MSG_NFCC_SEND_HCI 0x27
-#define NCI_MSG_CE4_PATCH_DOWNLOAD_DONE 0x28
-#define NCI_MSG_EEPROM_RW 0x29
-#define NCI_MSG_GET_CLF_REGISTERS 0x2A
-#define NCI_MSG_RF_TEST 0x2B
-#define NCI_MSG_DEBUG_PRINT 0x2C
-#define NCI_MSG_GET_PATCH_VERSION 0x2D
-#define NCI_MSG_SECURE_PATCH_DOWNLOAD 0x2E
-#define NCI_MSG_SPD_FORMAT_NVM 0x2F
-#define NCI_MSG_SPD_READ_NVM 0x30
-#define NCI_MSG_SWP_BIST 0x31
-#define NCI_MSG_WLESS_DBG_MODE 0x32
-#define NCI_MSG_I2C_REQ_POLARITY 0x33
-#define NCI_MSG_AID_FILTER 0x39
-
-/**********************************************
- * Proprietary  NCI status codes
- **********************************************/
-#define NCI_STATUS_SPD_ERROR_ORDER 0xE0
-#define NCI_STATUS_SPD_ERROR_DEST 0xE1
-#define NCI_STATUS_SPD_ERROR_PROJECTID 0xE2
-#define NCI_STATUS_SPD_ERROR_CHIPVER 0xE3
-#define NCI_STATUS_SPD_ERROR_MAJORVER 0xE4
-#define NCI_STATUS_SPD_ERROR_INVALID_PARAM 0xE5
-#define NCI_STATUS_SPD_ERROR_INVALID_SIG 0xE6
-#define NCI_STATUS_SPD_ERROR_NVM_CORRUPTED 0xE7
-#define NCI_STATUS_SPD_ERROR_PWR_MODE 0xE8
-#define NCI_STATUS_SPD_ERROR_MSG_LEN 0xE9
-#define NCI_STATUS_SPD_ERROR_PATCHSIZE 0xEA
-
-#define NCI_NV_DEVICE_NONE 0x00
-#define NCI_NV_DEVICE_EEPROM 0x08
-#define NCI_NV_DEVICE_UICC1 0x10
-
-/* The events reported on tNFC_VS_CBACK */
-/* The event is (NCI_NTF_BIT|oid) or (NCI_RSP_BIT|oid) */
-#define NFC_VS_HCI_NETWK_EVT (NCI_NTF_BIT | NCI_MSG_HCI_NETWK)
-#define NFC_VS_HCI_NETWK_RSP (NCI_RSP_BIT | NCI_MSG_HCI_NETWK)
-#define NFC_VS_UICC_READER_ACTION_EVT (NCI_NTF_BIT | NCI_MSG_UICC_READER_ACTION)
-#define NFC_VS_POWER_LEVEL_RSP (NCI_RSP_BIT | NCI_MSG_POWER_LEVEL)
-#define NFC_VS_GET_NV_DEVICE_EVT (NCI_RSP_BIT | NCI_MSG_GET_NV_DEVICE)
-#define NFC_VS_LPTD_EVT (NCI_NTF_BIT | NCI_MSG_LPTD)
-#define NFC_VS_GET_BUILD_INFO_EVT (NCI_RSP_BIT | NCI_MSG_GET_BUILD_INFO)
-#define NFC_VS_GET_PATCH_VERSION_EVT (NCI_RSP_BIT | NCI_MSG_GET_PATCH_VERSION)
-#define NFC_VS_SEC_PATCH_DOWNLOAD_EVT \
-  (NCI_RSP_BIT | NCI_MSG_SECURE_PATCH_DOWNLOAD)
-#define NFC_VS_SEC_PATCH_AUTH_EVT (NCI_NTF_BIT | NCI_MSG_SECURE_PATCH_DOWNLOAD)
-#define NFC_VS_EEPROM_RW_EVT (NCI_RSP_BIT | NCI_MSG_EEPROM_RW)
-
-#define NCI_GET_PATCH_VERSION_NVM_OFFSET 37
-
-/* Static and dynamic pipe id and status for each pipe to uicc0 and uicc1. */
-#define NCI_NFCC_PIPE_INFO_NV_SIZE 24
-#define NCI_PERSONALITY_SLOT_SIZE 19
-#define NCI_DYNAMIC_PIPE_SIZE 8
-
-/* Type of TLV in NCI_MSG_HCI_NETWK */
-#define NCI_SWP_INTERFACE_TYPE 0xFF
-/* Type of TLV in NCI_MSG_HCI_NETWK */
-#define NCI_HCI_GATE_TYPE 0xFE
-
-/* Secure Patch Download definitions (patch type definitions) */
-#define NCI_SPD_TYPE_HEADER 0x00
-#define NCI_SPD_TYPE_SRAM 0x01
-#define NCI_SPD_TYPE_AON 0x02
-#define NCI_SPD_TYPE_PATCH_TABLE 0x03
-#define NCI_SPD_TYPE_SECURE_CONFIG 0x04
-#define NCI_SPD_TYPE_CONTROLLED_CONFIG 0x05
-#define NCI_SPD_TYPE_SIGNATURE 0x06
-#define NCI_SPD_TYPE_SIGCHEK 0x07
-
-/* Secure Patch Download definitions (NCI_SPD_TYPE_HEADER definitions) */
-#define NCI_SPD_HEADER_OFFSET_CHIPVERLEN 0x18
-#define NCI_SPD_HEADER_CHIPVER_LEN 16
-
-/* NVM Type (in GET_PATCH_VERSION RSP) */
-#define NCI_SPD_NVM_TYPE_NONE 0x00
-#define NCI_SPD_NVM_TYPE_EEPROM 0x01
-#define NCI_SPD_NVM_TYPE_UICC 0x02
-
-/**********************************************
- * NCI NFCC proprietary features in octet 3
- **********************************************/
-#define NCI_FEAT_SIGNED_PATCH 0x01000000
-
-/**********************************************
- * NCI Interface Types
- **********************************************/
-#define NCI_INTERFACE_VS_MIFARE 0x80
-#define NCI_INTERFACE_VS_CALYPSO_CE 0x81
-#define NCI_INTERFACE_VS_T2T_CE 0x82 /* for Card Emulation side */
-/* for both Reader/Writer and Card Emulation side */
-#define NCI_INTERFACE_VS_15693 0x83
-#define NCI_INTERFACE_VS_T1T_CE 0x84 /* for Card Emulation side */
-
-/**********************************************
- * NCI Proprietary Parameter IDs
- **********************************************/
-#define NCI_PARAM_ID_LA_FSDI 0xA0
-#define NCI_PARAM_ID_LB_FSDI 0xA1
-#define NCI_PARAM_ID_HOST_LISTEN_MASK 0xA2
-#define NCI_PARAM_ID_CHIP_TYPE 0xA3 /* NFCDEP */
-#define NCI_PARAM_ID_PA_ANTICOLL 0xA4
-#define NCI_PARAM_ID_CONTINUE_MODE 0xA5
-#define NCI_PARAM_ID_LBP 0xA6
-#define NCI_PARAM_ID_T1T_RDR_ONLY 0xA7
-#define NCI_PARAM_ID_LA_SENS_RES 0xA8
-#define NCI_PARAM_ID_PWR_SETTING_BITMAP 0xA9
-#define NCI_PARAM_ID_WI_NTF_ENABLE 0xAA
-#define NCI_PARAM_ID_LN_BITRATE 0xAB /* NFCDEP Listen Bitrate */
-#define NCI_PARAM_ID_LF_BITRATE 0xAC /* FeliCa */
-#define NCI_PARAM_ID_SWP_BITRATE_MASK 0xAD
-#define NCI_PARAM_ID_KOVIO 0xAE
-#define NCI_PARAM_ID_UICC_NTF_TO 0xAF
-#define NCI_PARAM_ID_NFCDEP 0xB0
-#define NCI_PARAM_ID_CLF_REGS_CFG 0xB1
-#define NCI_PARAM_ID_NFCDEP_TRANS_TIME 0xB2
-#define NCI_PARAM_ID_CREDIT_TIMER 0xB3
-#define NCI_PARAM_ID_CORRUPT_RX 0xB4
-#define NCI_PARAM_ID_ISODEP 0xB5
-#define NCI_PARAM_ID_LF_CONFIG 0xB6
-#define NCI_PARAM_ID_I93_DATARATE 0xB7
-#define NCI_PARAM_ID_CREDITS_THRESHOLD 0xB8
-#define NCI_PARAM_ID_TAGSNIFF_CFG 0xB9
-#define NCI_PARAM_ID_PA_FSDI 0xBA /* ISODEP */
-#define NCI_PARAM_ID_PB_FSDI 0xBB /* ISODEP */
-#define NCI_PARAM_ID_FRAME_INTF_RETXN 0xBC
-
-#define NCI_PARAM_ID_UICC_RDR_PRIORITY 0xBD
-#define NCI_PARAM_ID_GUARD_TIME 0xBE
-#define NCI_PARAM_ID_STDCONFIG 0xBF /* dont not use this config item */
-/* dont not use this config item  */
-#define NCI_PARAM_ID_PROPCFG 0xC0
-#define NCI_PARAM_ID_MAXTRY2ACTIVATE 0xC1
-#define NCI_PARAM_ID_SWPCFG 0xC2
-#define NCI_PARAM_ID_CLF_LPM_CFG 0xC3
-#define NCI_PARAM_ID_DCLB 0xC4
-#define NCI_PARAM_ID_ACT_ORDER 0xC5
-#define NCI_PARAM_ID_DEP_DELAY_ACT 0xC6
-#define NCI_PARAM_ID_DH_PARITY_CRC_CTL 0xC7
-#define NCI_PARAM_ID_PREINIT_DSP_CFG 0xC8
-#define NCI_PARAM_ID_FW_WORKAROUND 0xC9
-#define NCI_PARAM_ID_RFU_CONFIG 0xCA
-#define NCI_PARAM_ID_EMVCO_ENABLE 0xCB
-#define NCI_PARAM_ID_ANTDRIVER_PARAM 0xCC
-#define NCI_PARAM_ID_PLL325_CFG_PARAM 0xCD
-#define NCI_PARAM_ID_OPNLP_ADPLL_ENABLE 0xCE
-#define NCI_PARAM_ID_CONFORMANCE_MODE 0xCF
-
-#define NCI_PARAM_ID_LPO_ON_OFF_ENABLE 0xD0
-#define NCI_PARAM_ID_FORCE_VANT 0xD1
-#define NCI_PARAM_ID_COEX_CONFIG 0xD2
-#define NCI_PARAM_ID_INTEL_MODE 0xD3
-
-#define NCI_PARAM_ID_AID 0xFF
-
-/**********************************************
- * NCI Parameter ID Lens
- **********************************************/
-#define NCI_PARAM_LEN_PWR_SETTING_BITMAP 3
-#define NCI_PARAM_LEN_HOST_LISTEN_MASK 2
-#define NCI_PARAM_LEN_PLL325_CFG_PARAM 14
-
-/**********************************************
- * Snooze Mode
- **********************************************/
-#define NFC_SNOOZE_MODE_NONE 0x00    /* Snooze mode disabled    */
-#define NFC_SNOOZE_MODE_UART 0x01    /* Snooze mode for UART    */
-#define NFC_SNOOZE_MODE_SPI_I2C 0x08 /* Snooze mode for SPI/I2C */
-
-#define NFC_SNOOZE_ACTIVE_LOW 0x00  /* high to low voltage is asserting */
-#define NFC_SNOOZE_ACTIVE_HIGH 0x01 /* low to high voltage is asserting */
-
-/**********************************************
- * HCI definitions
- **********************************************/
-#define NFC_HAL_HCI_SESSION_ID_LEN 8
-#define NFC_HAL_HCI_SYNC_ID_LEN 2
-
-/* HCI Network command definitions */
-#define NFC_HAL_HCI_NETWK_INFO_SIZE 250
-#define NFC_HAL_HCI_NO_RW_MODE_NETWK_INFO_SIZE 184
-#define NFC_HAL_HCI_DH_NETWK_INFO_SIZE 111
-#define NFC_HAL_HCI_MIN_NETWK_INFO_SIZE 12
-#define NFC_HAL_HCI_MIN_DH_NETWK_INFO_SIZE 11
-
-/* Card emulation RF Gate A definitions */
-#define NFC_HAL_HCI_CE_RF_A_UID_REG_LEN 10
-#define NFC_HAL_HCI_CE_RF_A_ATQA_RSP_CODE_LEN 2
-#define NFC_HAL_HCI_CE_RF_A_MAX_HIST_DATA_LEN 15
-#define NFC_HAL_HCI_CE_RF_A_MAX_DATA_RATE_LEN 3
-
-/* Card emulation RF Gate B definitions */
-#define NFC_HAL_HCI_CE_RF_B_PUPI_LEN 4
-#define NFC_HAL_HCI_CE_RF_B_ATQB_LEN 4
-#define NFC_HAL_HCI_CE_RF_B_HIGHER_LAYER_RSP_LEN 61
-#define NFC_HAL_HCI_CE_RF_B_MAX_DATA_RATE_LEN 3
-
-/* Card emulation RF Gate BP definitions */
-#define NFC_HAL_HCI_CE_RF_BP_MAX_PAT_IN_LEN 8
-#define NFC_HAL_HCI_CE_RF_BP_DATA_OUT_LEN 40
-
-/* Reader RF Gate A definitions */
-#define NFC_HAL_HCI_RD_RF_B_HIGHER_LAYER_DATA_LEN 61
-
-/* DH HCI Network command definitions */
-#define NFC_HAL_HCI_DH_MAX_DYN_PIPES 20
-
-/* Target handle for different host in the network */
-#define NFC_HAL_HCI_DH_TARGET_HANDLE 0xF2
-#define NFC_HAL_HCI_UICC0_TARGET_HANDLE 0xF3
-#define NFC_HAL_HCI_UICC1_TARGET_HANDLE 0xF4
-#define NFC_HAL_HCI_UICC2_TARGET_HANDLE 0xF5
-
-/* Card emulation RF Gate A registry information */
-typedef struct {
-  uint8_t pipe_id; /* if MSB is set then valid, 7 bits for Pipe ID */
-  uint8_t mode; /* Type A card emulation enabled indicator, 0x02:enabled    */
-  uint8_t sak;
-  uint8_t uid_reg_len;
-  uint8_t uid_reg[NFC_HAL_HCI_CE_RF_A_UID_REG_LEN];
-  uint8_t atqa[NFC_HAL_HCI_CE_RF_A_ATQA_RSP_CODE_LEN]; /* ATQA response code */
-  uint8_t app_data_len;
-  uint8_t
-      app_data[NFC_HAL_HCI_CE_RF_A_MAX_HIST_DATA_LEN]; /* 15 bytes optional
-                                                          storage for historic
-                                                          data, use 2 slots */
-  uint8_t fwi_sfgi; /* FRAME WAITING TIME, START-UP FRAME GUARD TIME */
-  uint8_t cid_support;
-  uint8_t datarate_max[NFC_HAL_HCI_CE_RF_A_MAX_DATA_RATE_LEN];
-  uint8_t clt_support;
-} tNCI_HCI_CE_RF_A;
-
-/* Card emulation RF Gate B registry information */
-typedef struct {
-  uint8_t pipe_id; /* if MSB is set then valid, 7 bits for Pipe ID */
-  uint8_t mode; /* Type B card emulation enabled indicator, 0x02:enabled    */
-  uint8_t pupi_len;
-  uint8_t pupi_reg[NFC_HAL_HCI_CE_RF_B_PUPI_LEN];
-  uint8_t afi;
-  uint8_t
-      atqb[NFC_HAL_HCI_CE_RF_B_ATQB_LEN]; /* 4 bytes ATQB application data */
-  uint8_t higherlayer_resp
-      [NFC_HAL_HCI_CE_RF_B_HIGHER_LAYER_RSP_LEN]; /* 0~ 61 bytes ATRB_INF use
-                                                     1~4 personality slots */
-  uint8_t datarate_max[NFC_HAL_HCI_CE_RF_B_MAX_DATA_RATE_LEN];
-  uint8_t natrb;
-} tNCI_HCI_CE_RF_B;
-
-/* Card emulation RF Gate BP registry information */
-typedef struct {
-  uint8_t pipe_id; /* if MSB is set then valid, 7 bits for Pipe ID */
-  uint8_t
-      mode; /* Type B prime card emulation enabled indicator, 0x02:enabled */
-  uint8_t pat_in_len;
-  uint8_t pat_in[NFC_HAL_HCI_CE_RF_BP_MAX_PAT_IN_LEN];
-  uint8_t dat_out_len;
-  uint8_t
-      dat_out[NFC_HAL_HCI_CE_RF_BP_DATA_OUT_LEN]; /* ISO7816-3 <=64 byte, and
-                                                     other fields are 9 bytes */
-  uint8_t natr;
-} tNCI_HCI_CE_RF_BP;
-
-/* Card emulation RF Gate F registry information */
-typedef struct {
-  uint8_t pipe_id; /* if MSB is set then valid, 7 bits for Pipe ID */
-  uint8_t mode; /* Type F card emulation enabled indicator, 0x02:enabled    */
-  uint8_t speed_cap;
-  uint8_t clt_support;
-} tNCI_HCI_CE_RF_F;
-
-/* Reader RF Gate A registry information */
-typedef struct {
-  uint8_t pipe_id; /* if MSB is set then valid, 7 bits for Pipe ID */
-  uint8_t datarate_max;
-} tNCI_HCI_RD_RF_A;
-
-/* Reader RF Gate B registry information */
-typedef struct {
-  uint8_t pipe_id; /* if MSB is set then valid, 7 bits for Pipe ID */
-  uint8_t afi;
-  uint8_t hldata_len;
-  uint8_t
-      high_layer_data[NFC_HAL_HCI_RD_RF_B_HIGHER_LAYER_DATA_LEN]; /* INF field
-                                                                     in ATTRIB
-                                                                     command */
-} tNCI_HCI_RD_RF_B;
-
-/* Dynamic pipe information */
-typedef struct {
-  uint8_t source_host;
-  uint8_t dest_host;
-  uint8_t source_gate;
-  uint8_t dest_gate;
-  uint8_t pipe_id; /* if MSB is set then valid, 7 bits for Pipe ID */
-} tNCI_HCI_DYN_PIPE_INFO;
-
-/*************************************************************
- * HCI Network CMD/NTF structure for UICC host in the network
- *************************************************************/
-typedef struct {
-  uint8_t target_handle;
-  uint8_t session_id[NFC_HAL_HCI_SESSION_ID_LEN];
-  uint8_t sync_id[NFC_HAL_HCI_SYNC_ID_LEN];
-  uint8_t static_pipe_info;
-  tNCI_HCI_CE_RF_A ce_rf_a;
-  tNCI_HCI_CE_RF_B ce_rf_b;
-  tNCI_HCI_CE_RF_BP ce_rf_bp;
-  tNCI_HCI_CE_RF_F ce_rf_f;
-  tNCI_HCI_RD_RF_A rw_rf_a;
-  tNCI_HCI_RD_RF_B rw_rf_b;
-} tNCI_HCI_NETWK;
-
-/************************************************
- * HCI Network CMD/NTF structure for Device host
- ************************************************/
-typedef struct {
-  uint8_t target_handle;
-  uint8_t session_id[NFC_HAL_HCI_SESSION_ID_LEN];
-  uint8_t static_pipe_info;
-  uint8_t num_dyn_pipes;
-  tNCI_HCI_DYN_PIPE_INFO dyn_pipe_info[NFC_HAL_HCI_DH_MAX_DYN_PIPES];
-} tNCI_HCI_NETWK_DH;
-
-#endif /* NFC_BRCM_DEFS_H */
diff --git a/src/hal/int/nfc_hal_int.h b/src/hal/int/nfc_hal_int.h
deleted file mode 100644
index 8ad1cc6..0000000
--- a/src/hal/int/nfc_hal_int.h
+++ /dev/null
@@ -1,538 +0,0 @@
-/******************************************************************************
- *
- *  Copyright (C) 2009-2014 Broadcom Corporation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at:
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-/******************************************************************************
- *
- *  this file contains the NCI transport internal definitions and functions.
- *
- ******************************************************************************/
-
-#ifndef NFC_HAL_INT_H
-#define NFC_HAL_INT_H
-
-#include "nfc_hal_target.h"
-#include "gki.h"
-#include "nci_defs.h"
-#include "nfc_brcm_defs.h"
-#include "nfc_hal_api.h"
-#include "nfc_hal_int_api.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/****************************************************************************
-** NFC HAL TASK transport definitions
-****************************************************************************/
-/* NFC HAL Task event masks */
-#define NFC_HAL_TASK_EVT_DATA_RDY EVENT_MASK(APPL_EVT_0)
-#define NFC_HAL_TASK_EVT_INITIALIZE EVENT_MASK(APPL_EVT_5)
-#define NFC_HAL_TASK_EVT_TERMINATE EVENT_MASK(APPL_EVT_6)
-#define NFC_HAL_TASK_EVT_POWER_CYCLE EVENT_MASK(APPL_EVT_7)
-
-#define NFC_HAL_TASK_EVT_MBOX (TASK_MBOX_0_EVT_MASK)
-
-/* NFC HAL Task mailbox definitions */
-#define NFC_HAL_TASK_MBOX (TASK_MBOX_0)
-
-/* NFC HAL Task Timer events */
-#ifndef NFC_HAL_QUICK_TIMER_EVT_MASK
-#define NFC_HAL_QUICK_TIMER_EVT_MASK (TIMER_0_EVT_MASK)
-#endif
-
-#ifndef NFC_HAL_QUICK_TIMER_ID
-#define NFC_HAL_QUICK_TIMER_ID (TIMER_0)
-#endif
-
-/* NFC HAL Task Timer types */
-#define NFC_HAL_TTYPE_NCI_WAIT_RSP 0
-#define NFC_HAL_TTYPE_POWER_CYCLE 1
-#define NFC_HAL_TTYPE_NFCC_ENABLE 2
-
-/* NFC HAL Task Wait Response flag */
-/* wait response on an NCI command                  */
-#define NFC_HAL_WAIT_RSP_CMD 0x10
-/* wait response on an NCI vendor specific command  */
-#define NFC_HAL_WAIT_RSP_VSC 0x20
-/* wait response on a proprietary command           */
-#define NFC_HAL_WAIT_RSP_PROP 0x40
-/* not waiting for anything                         */
-#define NFC_HAL_WAIT_RSP_NONE 0x00
-
-typedef uint8_t tNFC_HAL_WAIT_RSP;
-
-#if (NFC_HAL_HCI_INCLUDED == true)
-
-typedef uint16_t tNFC_HAL_HCI_EVT;
-
-#define NFC_HAL_HCI_PIPE_INFO_SIZE 5
-
-#define NFC_HAL_HCI_ANY_SET_PARAMETER 0x01
-#define NFC_HAL_HCI_ANY_GET_PARAMETER 0x02
-#define NFC_HAL_HCI_ADM_NOTIFY_ALL_PIPE_CLEARED 0x15
-
-#define NFC_HAL_HCI_SESSION_IDENTITY_INDEX 0x01
-#define NFC_HAL_HCI_WHITELIST_INDEX 0x03
-
-#define NFC_HAL_HCI_ADMIN_PIPE 0x01
-/* Host ID for UICC 0 */
-#define NFC_HAL_HCI_HOST_ID_UICC0 0x02
-/* Host ID for UICC 1 */
-#define NFC_HAL_HCI_HOST_ID_UICC1 0x03
-/* Host ID for UICC 2 */
-#define NFC_HAL_HCI_HOST_ID_UICC2 0x04
-#define NFC_HAL_HCI_COMMAND_TYPE 0x00
-#define NFC_HAL_HCI_RESPONSE_TYPE 0x02
-
-/* NFC HAL HCI responses */
-#define NFC_HAL_HCI_ANY_OK 0x00
-
-#endif
-
-/* Flag defintions for tNFC_HAL_NVM */
-/* No NVM available                     */
-#define NFC_HAL_NVM_FLAGS_NO_NVM 0x01
-/* FPM patch in NVM failed CRC check    */
-#define NFC_HAL_NVM_FLAGS_LPM_BAD 0x02
-/* LPM patch in NVM failed CRC check    */
-#define NFC_HAL_NVM_FLAGS_FPM_BAD 0x04
-/* Patch is present in NVM              */
-#define NFC_HAL_NVM_FLAGS_PATCH_PRESENT 0x08
-
-/* NFC HAL transport configuration */
-typedef struct {
-  bool shared_transport; /* true if using shared HCI/NCI transport */
-  uint8_t userial_baud;
-  uint8_t userial_fc;
-} tNFC_HAL_TRANS_CFG;
-
-#ifdef TESTER
-/* For Insight, ncit_cfg is runtime-configurable */
-#define NFC_HAL_TRANS_CFG_QUALIFIER
-#else
-/* For all other platforms, ncit_cfg is constant */
-#define NFC_HAL_TRANS_CFG_QUALIFIER const
-#endif
-extern NFC_HAL_TRANS_CFG_QUALIFIER tNFC_HAL_TRANS_CFG nfc_hal_trans_cfg;
-
-/*****************************************************************************
-* BT HCI definitions
-*****************************************************************************/
-
-/* Tranport message type */
-#define HCIT_TYPE_COMMAND 0x01
-#define HCIT_TYPE_EVENT 0x04
-#define HCIT_TYPE_NFC 0x10
-
-/* Vendor-Specific BT HCI definitions */
-#define HCI_SUCCESS 0x00
-#define HCI_GRP_VENDOR_SPECIFIC (0x3F << 10) /* 0xFC00 */
-#define HCI_BRCM_WRITE_SLEEP_MODE (0x0027 | HCI_GRP_VENDOR_SPECIFIC)
-#define HCI_GRP_HOST_CONT_BASEBAND_CMDS (0x03 << 10) /* 0x0C00 */
-#define HCI_RESET (0x0003 | HCI_GRP_HOST_CONT_BASEBAND_CMDS)
-#define HCI_COMMAND_COMPLETE_EVT 0x0E
-#define HCI_BRCM_WRITE_SLEEP_MODE_LENGTH 12
-#define HCI_BRCM_UPDATE_BAUD_RATE_UNENCODED_LENGTH 0x06
-#define HCIE_PREAMBLE_SIZE 2
-#define HCI_BRCM_PRE_SET_MEM (0x000C | HCI_GRP_VENDOR_SPECIFIC)
-#define HCI_BRCM_PRE_SET_MEM_LENGTH 10
-#define HCI_BRCM_PRE_SET_MEM_TYPE 8
-
-/****************************************************************************
-** Internal constants and definitions
-****************************************************************************/
-
-/* NFC HAL receiving states */
-enum {
-  NFC_HAL_RCV_IDLE_ST,        /* waiting for packet type byte             */
-  NFC_HAL_RCV_NCI_MSG_ST,     /* waiting for the first byte of NCI header */
-  NFC_HAL_RCV_NCI_HDR_ST,     /* reading NCI header                       */
-  NFC_HAL_RCV_NCI_PAYLOAD_ST, /* reading NCI payload                      */
-  NFC_HAL_RCV_BT_MSG_ST,      /* waiting for the first byte of BT header  */
-  NFC_HAL_RCV_BT_HDR_ST,      /* reading BT HCI header                    */
-  NFC_HAL_RCV_BT_PAYLOAD_ST   /* reading BT HCI payload                   */
-};
-
-/* errors during NCI packet reassembly process */
-#define NFC_HAL_NCI_RAS_TOO_BIG 0x01
-#define NFC_HAL_NCI_RAS_ERROR 0x02
-typedef uint8_t tNFC_HAL_NCI_RAS;
-
-/* NFC HAL power mode */
-enum {
-  NFC_HAL_POWER_MODE_FULL, /* NFCC is full power mode      */
-  NFC_HAL_POWER_MODE_LAST
-};
-typedef uint8_t tNFC_HAL_POWER_MODE;
-
-/* NFC HAL event for low power mode */
-enum {
-  NFC_HAL_LP_TX_DATA_EVT, /* DH is sending data to NFCC   */
-  NFC_HAL_LP_RX_DATA_EVT, /* DH received data from NFCC   */
-  NFC_HAL_LP_TIMEOUT_EVT, /* Timeout                      */
-  NFC_HAL_LP_LAST_EVT
-};
-typedef uint8_t tNFC_HAL_LP_EVT;
-
-#define NFC_HAL_ASSERT_NFC_WAKE 0x00   /* assert NFC_WAKE      */
-#define NFC_HAL_DEASSERT_NFC_WAKE 0x01 /* deassert NFC_WAKE    */
-
-#define NFC_HAL_BT_HCI_CMD_HDR_SIZE 3 /* opcode (2) +  length (1)    */
-#define NFC_HAL_CMD_TOUT (2000)       /* timeout for NCI CMD (in ms) */
-
-#define NFC_HAL_SAVED_HDR_SIZE (2)
-#define NFC_HAL_SAVED_CMD_SIZE (2)
-
-#ifndef NFC_HAL_DEBUG
-#define NFC_HAL_DEBUG true
-#endif
-
-#if (NFC_HAL_DEBUG == true)
-extern const char* const nfc_hal_init_state_str[];
-#define NFC_HAL_SET_INIT_STATE(state)                           \
-  HAL_TRACE_DEBUG3("init state: %d->%d(%s)",                    \
-                   nfc_hal_cb.dev_cb.initializing_state, state, \
-                   nfc_hal_init_state_str[state]);              \
-  nfc_hal_cb.dev_cb.initializing_state = state;
-#else
-#define NFC_HAL_SET_INIT_STATE(state) \
-  nfc_hal_cb.dev_cb.initializing_state = state;
-#endif
-
-/* NFC HAL - NFCC initializing state */
-enum {
-  NFC_HAL_INIT_STATE_IDLE,           /* Initialization is done                */
-  NFC_HAL_INIT_STATE_W4_XTAL_SET,    /* Waiting for crystal setting rsp       */
-  NFC_HAL_INIT_STATE_POST_XTAL_SET,  /* Waiting for reset ntf after xtal set  */
-  NFC_HAL_INIT_STATE_W4_NFCC_ENABLE, /* Waiting for reset ntf atter REG_PU up */
-  NFC_HAL_INIT_STATE_W4_BUILD_INFO,  /* Waiting for build info rsp            */
-  NFC_HAL_INIT_STATE_W4_PATCH_INFO,  /* Waiting for patch info rsp            */
-  NFC_HAL_INIT_STATE_W4_APP_COMPLETE,   /* Waiting for complete from application
-                                           */
-  NFC_HAL_INIT_STATE_W4_POST_INIT_DONE, /* Waiting for complete of post init */
-  NFC_HAL_INIT_STATE_W4_CONTROL_DONE,   /* Waiting for control release */
-  NFC_HAL_INIT_STATE_W4_PREDISCOVER_DONE, /* Waiting for complete of prediscover
-                                             */
-  NFC_HAL_INIT_STATE_CLOSING /* Shutting down                         */
-};
-typedef uint8_t tNFC_HAL_INIT_STATE;
-
-/* NFC HAL - NFCC config items during post initialization */
-enum {
-  NFC_HAL_DM_CONFIG_LPTD,
-  NFC_HAL_DM_CONFIG_PLL_325,
-  NFC_HAL_DM_CONFIG_START_UP,
-  NFC_HAL_DM_CONFIG_I93_DATA_RATE,
-  NFC_HAL_DM_CONFIG_FW_FSM,
-  NFC_HAL_DM_CONFIG_START_UP_VSC,
-  NFC_HAL_DM_CONFIG_NONE
-};
-typedef uint8_t tNFC_HAL_DM_CONFIG;
-
-/* callback function prototype */
-typedef struct {
-  uint16_t opcode;
-  uint16_t param_len;
-  uint8_t* p_param_buf;
-} tNFC_HAL_BTVSC_CPLT;
-
-typedef void(tNFC_HAL_BTVSC_CPLT_CBACK)(tNFC_HAL_BTVSC_CPLT* p1);
-
-#if (NFC_HAL_HCI_INCLUDED == true)
-
-/* data type for NFC_HAL_HCI_RSP_NV_READ_EVT */
-typedef struct {
-  NFC_HDR hdr;
-  uint8_t block;
-  uint16_t size;
-  tHAL_NFC_STATUS status;
-} tNFC_HAL_HCI_RSP_NV_READ_EVT;
-
-/* data type for NFC_HAL_HCI_RSP_NV_WRITE_EVT */
-typedef struct {
-  NFC_HDR hdr;
-  tHAL_NFC_STATUS status;
-} tNFC_HAL_HCI_RSP_NV_WRITE_EVT;
-
-/* union of all event data types */
-typedef union {
-  NFC_HDR hdr;
-  /* Internal events */
-  tNFC_HAL_HCI_RSP_NV_READ_EVT nv_read;
-  tNFC_HAL_HCI_RSP_NV_WRITE_EVT nv_write;
-} tNFC_HAL_HCI_EVENT_DATA;
-
-#endif
-/*****************************************************************************
-** Control block for NFC HAL
-*****************************************************************************/
-
-/* Patch RAM Download Control block */
-
-/* PRM states */
-enum {
-  NFC_HAL_PRM_ST_IDLE,
-
-  /* Secure patch download stated */
-  NFC_HAL_PRM_ST_SPD_COMPARE_VERSION,
-  NFC_HAL_PRM_ST_SPD_GET_PATCH_HEADER,
-  NFC_HAL_PRM_ST_SPD_DOWNLOADING,
-  NFC_HAL_PRM_ST_SPD_AUTHENTICATING,
-  NFC_HAL_PRM_ST_SPD_AUTH_DONE,
-  NFC_HAL_PRM_ST_W4_GET_VERSION
-};
-typedef uint8_t tNFC_HAL_PRM_STATE;
-
-/* Maximum number of patches (currently 2: LPM and FPM) */
-#define NFC_HAL_PRM_MAX_PATCH_COUNT 2
-#define NFC_HAL_PRM_PATCH_MASK_ALL 0xFFFFFFFF
-#define NFC_HAL_PRM_MAX_CHIP_VER_LEN 8
-
-/* Structures for PRM Control Block */
-typedef struct {
-  uint8_t power_mode;
-  uint16_t len;
-} tNFC_HAL_PRM_PATCHDESC;
-
-typedef struct {
-  tNFC_HAL_PRM_STATE state; /* download state */
-  uint32_t flags;           /* internal flags */
-  uint16_t
-      cur_patch_len_remaining; /* bytes remaining in patchfile to process     */
-  const uint8_t*
-      p_cur_patch_data;      /* pointer to patch currently being downloaded */
-  uint16_t cur_patch_offset; /* offset of next byte to process              */
-  uint32_t dest_ram;
-  TIMER_LIST_ENT timer; /* Timer for patch download                    */
-  void* p_param;        /* general purpose param for PRM               */
-  uint8_t param_idx;    /* information related to general purpose param*/
-
-  /* Secure Patch Download */
-  uint32_t
-      spd_patch_needed_mask; /* Mask of patches that need to be downloaded */
-  uint8_t spd_patch_count;   /* Number of patches left to download */
-  uint8_t spd_cur_patch_idx; /* Current patch being downloaded */
-
-  tNFC_HAL_PRM_PATCHDESC spd_patch_desc[NFC_HAL_PRM_MAX_PATCH_COUNT];
-
-  /* I2C-patch */
-  uint8_t* p_spd_patch;             /* pointer to spd patch             */
-  uint16_t spd_patch_len_remaining; /* patch length                     */
-  uint16_t spd_patch_offset;        /* offset of next byte to process   */
-
-  tNFC_HAL_PRM_FORMAT format;  /* format of patch ram              */
-  tNFC_HAL_PRM_CBACK* p_cback; /* Callback for download status notifications */
-  uint32_t patchram_delay;     /* the dealy after patch */
-} tNFC_HAL_PRM_CB;
-
-/* Information about current patch in NVM */
-typedef struct {
-  uint16_t project_id; /* Current project_id of patch in nvm       */
-  uint16_t ver_major;  /* Current major version of patch in nvm    */
-  uint16_t ver_minor;  /* Current minor version of patch in nvm    */
-  uint16_t fpm_size;   /* Current size of FPM patch in nvm         */
-  uint16_t lpm_size;   /* Current size of LPM patch in nvm         */
-  uint8_t flags;       /* See NFC_HAL_NVM_FLAGS_* flag definitions */
-  uint8_t nvm_type;    /* Current NVM Type - UICC/EEPROM           */
-  uint8_t chip_ver[NFC_HAL_PRM_MAX_CHIP_VER_LEN]; /* patch chip version       */
-} tNFC_HAL_NVM;
-
-/* Patch for I2C fix */
-typedef struct {
-  uint8_t* p_patch;      /* patch for i2c fix                */
-  uint32_t prei2c_delay; /* the dealy after preI2C patch */
-  uint16_t len;          /* i2c patch length                 */
-} tNFC_HAL_PRM_I2C_FIX_CB;
-
-/* Control block for NCI transport */
-typedef struct {
-  uint8_t nci_ctrl_size; /* Max size for NCI messages */
-  uint8_t rcv_state;     /* current rx state */
-  uint16_t rcv_len; /* bytes remaining to be received in current rx state     */
-  NFC_HDR* p_rcv_msg;  /* buffer to receive NCI message */
-  NFC_HDR* p_frag_msg; /* fragmented NCI message; waiting for last fragment */
-  NFC_HDR*
-      p_pend_cmd; /* pending NCI message; waiting for NFCC state to be free */
-  tNFC_HAL_NCI_RAS nci_ras; /* nci reassembly error status */
-  TIMER_LIST_ENT
-  nci_wait_rsp_timer; /* Timer for waiting for nci command response */
-  tNFC_HAL_WAIT_RSP nci_wait_rsp; /* nci wait response flag */
-  uint8_t
-      last_hdr[NFC_HAL_SAVED_HDR_SIZE]; /* part of last NCI command header */
-  uint8_t
-      last_cmd[NFC_HAL_SAVED_CMD_SIZE]; /* part of last NCI command payload */
-  void* p_vsc_cback; /* the callback function for last VSC command */
-} tNFC_HAL_NCIT_CB;
-
-/* Control block for device initialization */
-typedef struct {
-  tNFC_HAL_INIT_STATE initializing_state; /* state of initializing NFCC */
-
-  uint32_t brcm_hw_id; /* BRCM NFCC HW ID                          */
-  tNFC_HAL_DM_CONFIG next_dm_config; /* next config in post initialization */
-  uint8_t next_startup_vsc; /* next start-up VSC offset in post init    */
-
-  tNFC_HAL_POWER_MODE power_mode; /* NFCC power mode                          */
-  uint8_t snooze_mode;            /* current snooze mode                      */
-  uint8_t new_snooze_mode;        /* next snooze mode after receiving cmpl    */
-  uint8_t nfc_wake_active_mode;   /* NFC_HAL_LP_ACTIVE_LOW/HIGH               */
-  TIMER_LIST_ENT lp_timer;        /* timer for low power mode                 */
-
-  tHAL_NFC_STATUS_CBACK*
-      p_prop_cback; /* callback to notify complete of proprietary update */
-} tNFC_HAL_DEV_CB;
-
-#if (NFC_HAL_HCI_INCLUDED == true)
-
-/* data members for NFC_HAL-HCI */
-typedef struct {
-  TIMER_LIST_ENT
-  hci_timer; /* Timer to avoid indefinitely waiting for response */
-  uint8_t*
-      p_hci_netwk_info_buf; /* Buffer for reading HCI Network information */
-  uint8_t* p_hci_netwk_dh_info_buf; /* Buffer for reading HCI Network DH
-                                       information */
-  uint8_t hci_netwk_config_block;  /* Rsp awaiting for hci network configuration
-                                      block */
-  bool b_wait_hcp_conn_create_rsp; /* Waiting for hcp connection create response
-                                      */
-  bool clear_all_pipes_to_uicc1;   /* UICC1 was restarted for patch download */
-  bool update_session_id; /* Next response from NFCC is to Get Session id cmd */
-  bool hci_fw_validate_netwk_cmd; /* Flag to indicate if hci network ntf to
-                                     validate */
-  uint8_t hcp_conn_id;            /* NCI Connection id for HCP */
-  uint8_t dh_session_id[1];       /* Byte 0 of DH Session ID */
-} tNFC_HAL_HCI_CB;
-
-#endif
-
-typedef struct {
-  tHAL_NFC_CBACK* p_stack_cback;     /* Callback for HAL event notification  */
-  tHAL_NFC_DATA_CBACK* p_data_cback; /* Callback for data event notification  */
-
-  TIMER_LIST_Q quick_timer_queue; /* timer list queue                 */
-  TIMER_LIST_ENT timer;           /* timer for NCI transport task     */
-
-  tNFC_HAL_NCIT_CB ncit_cb; /* NCI transport */
-  tNFC_HAL_DEV_CB dev_cb;   /* device initialization */
-  tNFC_HAL_NVM nvm_cb;      /* Information about current patch in NVM */
-
-  /* Patchram control block */
-  tNFC_HAL_PRM_CB prm;
-  tNFC_HAL_PRM_I2C_FIX_CB prm_i2c;
-
-#if (NFC_HAL_HCI_INCLUDED == true)
-  /* data members for NFC_HAL-HCI */
-  tNFC_HAL_HCI_CB hci_cb;
-#endif
-
-  uint8_t pre_discover_done; /* true, when the prediscover config is complete */
-  uint8_t pre_set_mem_idx;
-
-  uint8_t max_rf_credits; /* NFC Max RF data credits */
-  uint8_t max_ee;         /* NFC Max number of NFCEE supported by NFCC */
-  uint8_t trace_level;    /* NFC HAL trace level */
-} tNFC_HAL_CB;
-
-/* Global NCI data */
-extern tNFC_HAL_CB nfc_hal_cb;
-
-extern uint8_t* p_nfc_hal_pre_discover_cfg;
-
-/****************************************************************************
-** Internal nfc functions
-****************************************************************************/
-
-/* From nfc_hal_main.c */
-uint32_t nfc_hal_main_task(uint32_t param);
-void nfc_hal_main_init(void);
-void nfc_hal_main_pre_init_done(tHAL_NFC_STATUS);
-void nfc_hal_main_start_quick_timer(TIMER_LIST_ENT* p_tle, uint16_t type,
-                                    uint32_t timeout);
-void nfc_hal_main_stop_quick_timer(TIMER_LIST_ENT* p_tle);
-void nfc_hal_main_send_error(tHAL_NFC_STATUS status);
-void nfc_hal_send_nci_msg_to_nfc_task(NFC_HDR* p_msg);
-
-/* nfc_hal_nci.c */
-bool nfc_hal_nci_receive_msg(uint8_t byte);
-bool nfc_hal_nci_preproc_rx_nci_msg(NFC_HDR* p_msg);
-NFC_HDR* nfc_hal_nci_postproc_rx_nci_msg(void);
-void nfc_hal_nci_assemble_nci_msg(void);
-void nfc_hal_nci_add_nfc_pkt_type(NFC_HDR* p_msg);
-void nfc_hal_nci_send_cmd(NFC_HDR* p_buf);
-void nfc_hal_nci_cmd_timeout_cback(void* p_tle);
-
-/* nfc_hal_dm.c */
-void nfc_hal_dm_init(void);
-void nfc_hal_dm_set_xtal_freq_index(void);
-void nfc_hal_dm_send_get_build_info_cmd(void);
-void nfc_hal_dm_proc_msg_during_init(NFC_HDR* p_msg);
-void nfc_hal_dm_config_nfcc(void);
-void nfc_hal_dm_send_nci_cmd(const uint8_t* p_data, uint16_t len,
-                             tNFC_HAL_NCI_CBACK* p_cback);
-void nfc_hal_dm_send_bt_cmd(const uint8_t* p_data, uint16_t len,
-                            tNFC_HAL_BTVSC_CPLT_CBACK* p_cback);
-void nfc_hal_dm_set_nfc_wake(uint8_t cmd);
-void nfc_hal_dm_pre_init_nfcc(void);
-void nfc_hal_dm_shutting_down_nfcc(void);
-bool nfc_hal_dm_power_mode_execute(tNFC_HAL_LP_EVT event);
-void nfc_hal_dm_send_pend_cmd(void);
-tHAL_NFC_STATUS nfc_hal_dm_set_config(uint8_t tlv_size, uint8_t* p_param_tlvs,
-                                      tNFC_HAL_NCI_CBACK* p_cback);
-bool nfc_hal_dm_check_pre_set_mem(void);
-
-/* nfc_hal_prm.c */
-void nfc_hal_prm_spd_reset_ntf(uint8_t reset_reason, uint8_t reset_type);
-void nfc_hal_prm_nci_command_complete_cback(tNFC_HAL_NCI_EVT event,
-                                            uint16_t data_len, uint8_t* p_data);
-void nfc_hal_prm_process_timeout(void* p_tle);
-
-#if (NFC_HAL_HCI_INCLUDED == true)
-/* nfc_hal_hci.c */
-void nfc_hal_hci_enable(void);
-void nfc_hal_hci_evt_hdlr(tNFC_HAL_HCI_EVENT_DATA* p_evt_data);
-void nfc_hal_hci_handle_hci_netwk_info(uint8_t* p_data);
-void nfc_hal_hci_handle_hcp_pkt_from_hc(uint8_t* p_data);
-NFC_HDR* nfc_hal_hci_postproc_hcp(void);
-bool nfc_hal_hci_handle_hcp_pkt_to_hc(uint8_t* p_data);
-void nfc_hal_hci_timeout_cback(void* p_tle);
-void nfc_hal_hci_handle_build_info(uint8_t chipverlen, uint8_t* p_chipverstr);
-#else
-#define nfc_hal_hci_enable() NFC_HAL_SET_INIT_STATE(NFC_HAL_INIT_STATE_IDLE);
-#define nfc_hal_hci_handle_build_info(p, a)
-#define nfc_hal_hci_evt_hdlr(p) ;
-#endif
-
-/* Define default NCI protocol trace function (if protocol tracing is enabled)
- */
-#if (NFC_HAL_TRACE_PROTOCOL == true)
-#if !defined(DISP_NCI)
-#define DISP_NCI (DispNci)
-void DispNci(uint8_t* p, uint16_t len, bool is_recv);
-#endif /* DISP_NCI */
-
-/* For displaying vendor-specific HCI commands */
-void DispHciCmd(NFC_HDR* p_buf);
-void DispHciEvt(NFC_HDR* p_buf);
-#endif /* NFC_HAL_TRACE_PROTOCOL */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* NFC_HAL_INT_H */
diff --git a/src/hal/int/nfc_hal_int_api.h b/src/hal/int/nfc_hal_int_api.h
deleted file mode 100644
index 89edb03..0000000
--- a/src/hal/int/nfc_hal_int_api.h
+++ /dev/null
@@ -1,307 +0,0 @@
-/******************************************************************************
- *
- *  Copyright (C) 2009-2014 Broadcom Corporation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at:
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-/******************************************************************************
- *
- *  Internal NFC HAL API functions.
- *
- ******************************************************************************/
-#ifndef NFC_HAL_INT_API_H
-#define NFC_HAL_INT_API_H
-
-/****************************************************************************
-** Device Configuration definitions
-****************************************************************************/
-
-#define NFC_HAL_PLL_325_SETCONFIG_PARAM_LEN (2 + NCI_PARAM_LEN_PLL325_CFG_PARAM)
-
-/* Crystal Frequency Index (in 1 KHz) */
-enum {
-  NFC_HAL_XTAL_INDEX_9600,
-  NFC_HAL_XTAL_INDEX_13000,
-  NFC_HAL_XTAL_INDEX_16200,
-  NFC_HAL_XTAL_INDEX_19200,
-  NFC_HAL_XTAL_INDEX_24000,
-  NFC_HAL_XTAL_INDEX_26000,
-  NFC_HAL_XTAL_INDEX_38400,
-  NFC_HAL_XTAL_INDEX_52000,
-  NFC_HAL_XTAL_INDEX_37400,
-  NFC_HAL_XTAL_INDEX_MAX,
-  NFC_HAL_XTAL_INDEX_SPECIAL = 0xFF
-};
-typedef uint8_t tNFC_HAL_XTAL_INDEX;
-
-/* Broadcom specific device initialization before sending NCI reset */
-
-typedef struct {
-  uint32_t brcm_hw_id;
-  uint16_t xtal_freq;
-  uint8_t xtal_index;
-} tNFC_HAL_DEV_INIT_XTAL_CFG;
-
-#define NFC_HAL_DEV_INIT_MAX_XTAL_CFG 5
-
-typedef struct {
-  uint8_t num_xtal_cfg;
-  tNFC_HAL_DEV_INIT_XTAL_CFG xtal_cfg[NFC_HAL_DEV_INIT_MAX_XTAL_CFG];
-} tNFC_HAL_DEV_INIT_CFG;
-
-/*****************************************************************************
-**  Low Power Mode definitions
-*****************************************************************************/
-
-/* Snooze mode disabled    */
-#define NFC_HAL_LP_SNOOZE_MODE_NONE NFC_SNOOZE_MODE_NONE
-/* Snooze mode for UART    */
-#define NFC_HAL_LP_SNOOZE_MODE_UART NFC_SNOOZE_MODE_UART
-/* Snooze mode for SPI/I2C */
-#define NFC_HAL_LP_SNOOZE_MODE_SPI_I2C NFC_SNOOZE_MODE_SPI_I2C
-
-/* high to low voltage is asserting */
-#define NFC_HAL_LP_ACTIVE_LOW NFC_SNOOZE_ACTIVE_LOW
-/* low to high voltage is asserting */
-#define NFC_HAL_LP_ACTIVE_HIGH NFC_SNOOZE_ACTIVE_HIGH
-
-/*****************************************************************************
-**  Patch RAM Constants
-*****************************************************************************/
-
-/* patch format type */
-#define NFC_HAL_PRM_FORMAT_BIN 0x00
-#define NFC_HAL_PRM_FORMAT_HCD 0x01
-#define NFC_HAL_PRM_FORMAT_NCD 0x02
-typedef uint8_t tNFC_HAL_PRM_FORMAT;
-
-/*****************************************************************************
-**  Patch RAM Callback for event notificaton
-*****************************************************************************/
-/* Events for tNFC_HAL_PRM_CBACK */
-enum {
-  NFC_HAL_PRM_CONTINUE_EVT,
-  NFC_HAL_PRM_COMPLETE_EVT,
-  NFC_HAL_PRM_ABORT_EVT,
-  NFC_HAL_PRM_ABORT_INVALID_PATCH_EVT, /* Patch is invalid (bad version, project
-                                          id, or chip)  */
-  NFC_HAL_PRM_ABORT_BAD_SIGNATURE_EVT, /* Patch has invalid signature */
-  NFC_HAL_PRM_SPD_GET_PATCHFILE_HDR_EVT, /* Secure Patch Download: request for
-                                            patchfile header  */
-  NFC_HAL_PRM_SPD_GET_NEXT_PATCH,        /* Get first command of next patch in
-                                            patchfile         */
-  NFC_HAL_PRM_ABORT_NO_NVM_EVT /* nfc_hal_prm_nvm_required is true and NVM is
-                                  unavail  */
-};
-
-typedef void(tNFC_HAL_PRM_CBACK)(uint8_t event);
-
-typedef uint8_t tNFC_HAL_NCI_EVT; /* MT + Opcode */
-typedef void(tNFC_HAL_NCI_CBACK)(tNFC_HAL_NCI_EVT event, uint16_t data_len,
-                                 uint8_t* p_data);
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*******************************************************************************
-**
-** Function         HAL_NfcPreInitDone
-**
-** Description      Notify that pre-initialization of NFCC is complete
-**
-** Returns          void
-**
-*******************************************************************************/
-void HAL_NfcPreInitDone(tHAL_NFC_STATUS status);
-
-/*******************************************************************************
-**
-** Function         HAL_NfcReInit
-**
-** Description      This function is called to restart initialization after
-**                  REG_PU toggled because of failure to detect NVM type or
-**                  download patchram.
-**
-** Note             This function should be called only during the HAL init
-**                  process
-**
-** Returns          HAL_NFC_STATUS_OK if successfully initiated
-**                  HAL_NFC_STATUS_FAILED otherwise
-**
-*******************************************************************************/
-tHAL_NFC_STATUS HAL_NfcReInit(void);
-
-/*******************************************************************************
-**
-** Function         HAL_NfcSetSnoozeMode
-**
-** Description      Set snooze mode
-**                  snooze_mode
-**                      NFC_HAL_LP_SNOOZE_MODE_NONE - Snooze mode disabled
-**                      NFC_HAL_LP_SNOOZE_MODE_UART - Snooze mode for UART
-**                      NFC_HAL_LP_SNOOZE_MODE_SPI_I2C - Snooze mode for SPI/I2C
-**
-**                  idle_threshold_dh/idle_threshold_nfcc
-**                      Idle Threshold Host in 100ms unit
-**
-**                  nfc_wake_active_mode/dh_wake_active_mode
-**                      NFC_HAL_LP_ACTIVE_LOW - high to low voltage is asserting
-**                      NFC_HAL_LP_ACTIVE_HIGH - low to high voltage is
-**                                               asserting
-**
-**                  p_snooze_cback
-**                      Notify status of operation
-**
-** Returns          tHAL_NFC_STATUS
-**
-*******************************************************************************/
-tHAL_NFC_STATUS HAL_NfcSetSnoozeMode(uint8_t snooze_mode,
-                                     uint8_t idle_threshold_dh,
-                                     uint8_t idle_threshold_nfcc,
-                                     uint8_t nfc_wake_active_mode,
-                                     uint8_t dh_wake_active_mode,
-                                     tHAL_NFC_STATUS_CBACK* p_snooze_cback);
-
-/*******************************************************************************
-**
-** Function         HAL_NfcPrmDownloadStart
-**
-** Description      Initiate patch download
-**
-** Input Params
-**                  format_type     patch format type
-**                                  (NFC_HAL_PRM_FORMAT_BIN,
-**                                   NFC_HAL_PRM_FORMAT_HCD, or
-**                                   NFC_HAL_PRM_FORMAT_NCD)
-**
-**                  dest_address    destination adderess (needed for BIN format
-**                                  only)
-**
-**                  p_patchram_buf  pointer to patchram buffer. If NULL, then
-**                                  app must call HAL_NfcPrmDownloadContinue
-**                                  when NFC_HAL_PRM_CONTINUE_EVT is received,
-**                                  to send the next segment of patchram
-**
-**                  patchram_len    size of p_patchram_buf (if non-NULL)
-**
-**                  patchram_delay  The delay after each patch.
-**                                  If the given value is less than the size of
-**                                  the patchram, the size of patchram is used
-**                                  instead.
-**
-**                  p_cback         callback for download status
-**
-**
-** Returns          true if successful, otherwise false
-**
-**
-*******************************************************************************/
-bool HAL_NfcPrmDownloadStart(tNFC_HAL_PRM_FORMAT format_type,
-                             uint32_t dest_address, uint8_t* p_patchram_buf,
-                             uint32_t patchram_len, uint32_t patchram_delay,
-                             tNFC_HAL_PRM_CBACK* p_cback);
-
-/*******************************************************************************
-**
-** Function         HAL_NfcPrmDownloadContinue
-**
-** Description      Send next segment of patchram to controller. Called when
-**                  NFC_HAL_PRM_CONTINUE_EVT is received.
-**
-**                  Only needed if HAL_NfcPrmDownloadStart was called with
-**                  p_patchram_buf=NULL
-**
-** Input Params     p_patch_data    pointer to patch data
-**                  patch_data_len  patch data len
-**
-** Returns          true if successful, otherwise false
-**
-*******************************************************************************/
-bool HAL_NfcPrmDownloadContinue(uint8_t* p_patch_data, uint16_t patch_data_len);
-
-/*******************************************************************************
-**
-** Function         HAL_NfcPrmSetI2cPatch
-**
-** Description      Specify patchfile for BCM20791B3 I2C fix. This fix
-**                  must be downloaded prior to initial patch download for I2C
-**                  transport
-**
-** Input Params     p_i2c_patchfile_buf: pointer to patch for i2c fix
-**                  i2c_patchfile_len: length of patch
-**                  prei2c_delay: the delay before downloading main patch
-**                                if 0 is given, NFC_HAL_PRM_POST_I2C_FIX_DELAY
-**                                is used instead.
-**
-** Returns          Nothing
-**
-**
-*******************************************************************************/
-void HAL_NfcPrmSetI2cPatch(uint8_t* p_i2c_patchfile_buf,
-                           uint16_t i2c_patchfile_len, uint32_t prei2c_delay);
-
-/*******************************************************************************
-**
-** Function         HAL_NfcPrmSetSpdNciCmdPayloadSize
-**
-** Description      Set Host-to-NFCC NCI message size for secure patch download
-**
-**                  This API must be called before calling
-**                  HAL_NfcPrmDownloadStart. If the API is not called, then PRM
-**                  will use the default message size.
-**
-**                  Typically, this API is only called for platforms that have
-**                  message-size limitations in the transport/driver.
-**
-**                  Valid message size range:
-**                  NFC_HAL_PRM_MIN_NCI_CMD_PAYLOAD_SIZE to 255.
-**
-** Returns          HAL_NFC_STATUS_OK if successful
-**                  HAL_NFC_STATUS_FAILED otherwise
-**
-**
-*******************************************************************************/
-tHAL_NFC_STATUS HAL_NfcPrmSetSpdNciCmdPayloadSize(uint8_t max_payload_size);
-
-/*******************************************************************************
-**
-** Function         HAL_NfcSetMaxRfDataCredits
-**
-** Description      This function sets the maximum RF data credit for HAL.
-**                  If 0, use the value reported from NFCC.
-**
-** Returns          none
-**
-*******************************************************************************/
-void HAL_NfcSetMaxRfDataCredits(uint8_t max_credits);
-
-/*******************************************************************************
-**
-** Function         HAL_NfcSetTraceLevel
-**
-** Description      This function sets the trace level for HAL.  If called with
-**                  a value of 0xFF, it simply returns the current trace level.
-**
-** Returns          The new or current trace level
-**
-*******************************************************************************/
-uint8_t HAL_NfcSetTraceLevel(uint8_t new_level);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* NFC_HAL_INT_API_H */
diff --git a/src/hal/int/nfc_hal_nv_ci.h b/src/hal/int/nfc_hal_nv_ci.h
deleted file mode 100644
index b63a8fb..0000000
--- a/src/hal/int/nfc_hal_nv_ci.h
+++ /dev/null
@@ -1,89 +0,0 @@
-/******************************************************************************
- *
- *  Copyright (C) 2003-2014 Broadcom Corporation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at:
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-/******************************************************************************
- *
- *  This is the interface file for non valtile memory call-in functions.
- *
- ******************************************************************************/
-#ifndef NFC_HAL_NV_CI_H
-#define NFC_HAL_NV_CI_H
-
-#include "nfc_hal_target.h"
-#if (NFC_HAL_HCI_INCLUDED == true)
-
-#include "nfc_hal_nv_co.h"
-
-/*****************************************************************************
-**  Function Declarations
-*****************************************************************************/
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*******************************************************************************
-**
-** Function         nfc_hal_nv_ci_write
-**
-** Description      This function sends an event to NFAA indicating the phone
-**                  has written the number of bytes specified in the call-out
-**                  function, nfa_nv_co_write (), and is ready for more data.
-**                  This function is used to control the TX data flow.
-**                  Note: The data buffer is released by the stack aioer
-**                        calling this function.
-**
-** Parameters       status - NFA_NV_CO_OK, NFA_NV_CO_NOSPACE, or NFA_NV_CO_FAIL
-**                  evt - Used Internally by NFA -> MUST be same value passed
-**                       in call-out function.
-**
-** Returns          void
-**
-*******************************************************************************/
-void nfc_hal_nv_ci_write(tNFC_HAL_NV_CO_STATUS status);
-
-/*******************************************************************************
-**
-** Function         nfc_hal_nv_ci_read
-**
-** Description      This function sends an event to NCIT indicating the phone
-**                  has read in the requested amount of data specified in the
-**                  nfa_nv_co_read () call-out function.  It should only be
-**                  called when the requested number of bytes has been read.
-**
-** Parameters       num_bytes_read - number of bytes read into the buffer
-**                      specified in the read callout-function.
-**                  status - NFC_HAL_NV_CO_OK if full buffer of data,
-**                           NFC_HAL_NV_CO_EOF if the end of file has been
-**                           reached,
-**                           NFC_HAL_NV_CO_FAIL if an error has occurred.
-**                  evt - Used Internally by NFA -> MUST be same value passed
-**                       in call-out function.
-**
-** Returns          void
-**
-*******************************************************************************/
-void nfc_hal_nv_ci_read(uint16_t num_bytes_read, tNFC_HAL_NV_CO_STATUS status,
-                        uint8_t block);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* NFC_HAL_HCI_INCLUDED */
-
-#endif /* NFC_HAL_NV_CI_H */
diff --git a/src/hal/int/nfc_hal_nv_co.h b/src/hal/int/nfc_hal_nv_co.h
deleted file mode 100644
index 870da24..0000000
--- a/src/hal/int/nfc_hal_nv_co.h
+++ /dev/null
@@ -1,118 +0,0 @@
-/******************************************************************************
- *
- *  Copyright (C) 2003-2014 Broadcom Corporation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at:
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-/******************************************************************************
- *
- *  This is the interface file for storing nv data
- *
- ******************************************************************************/
-#ifndef NFC_HAL_NV_CO_H
-#define NFC_HAL_NV_CO_H
-
-#include "nfc_hal_target.h"
-#if (NFC_HAL_HCI_INCLUDED == true)
-
-#include <time.h>
-
-/*****************************************************************************
-**  Constants and Data Types
-*****************************************************************************/
-
-/**************************
-**  Common Definitions
-***************************/
-
-/* Status codes returned by call-out functions, or in call-in functions as
- * status */
-#define NFC_HAL_NV_CO_OK 0x00
-#define NFC_HAL_NV_CO_FAIL 0x01 /* Used to pass all other errors */
-#define NFC_HAL_NV_CO_EACCES 0x02
-#define NFC_HAL_NV_CO_ENOTEMPTY 0x03
-#define NFC_HAL_NV_CO_EOF 0x04
-#define NFC_HAL_NV_CO_EODIR 0x05
-/* Returned in nfa_nv_ci_open if no room */
-#define NFC_HAL_NV_CO_ENOSPACE 0x06
-#define NFC_HAL_NV_CO_EIS_DIR 0x07
-#define NFC_HAL_NV_CO_RESUME 0x08 /* used in nfa_nv_ci_open, on resume */
-/* used in nfa_nv_ci_open, on resume (no file to resume) */
-#define NFC_HAL_NV_CO_NONE 0x09
-
-typedef uint8_t tNFC_HAL_NV_CO_STATUS;
-
-#define DH_NV_BLOCK 0x01
-#define HC_F3_NV_BLOCK 0x02
-#define HC_F4_NV_BLOCK 0x03
-#define HC_F2_NV_BLOCK 0x04
-#define HC_F5_NV_BLOCK 0x05
-
-/*****************************************************************************
-**  Function Declarations
-*****************************************************************************/
-/**************************
-**  Common Functions
-***************************/
-
-/*******************************************************************************
-**
-** Function         nfc_hal_nv_co_read
-**
-** Description      This function is called by NFA to read in data from the
-**                  previously opened file.
-**
-** Parameters       p_buf   - buffer to read the data into.
-**                  nbytes  - number of bytes to read into the buffer.
-**
-** Returns          void
-**
-**                  Note: Upon completion of the request, nfa_nv_ci_read () is
-**                        called with the buffer of data, along with the number
-**                        of bytes read into the buffer, and a status.  The
-**                        call-in function should only be called when ALL
-**                        requested bytes have been read, the end of file has
-**                        been detected, or an error has occurred.
-**
-*******************************************************************************/
-void nfc_hal_nv_co_read(uint8_t* p_buf, uint16_t nbytes, uint8_t block);
-
-/*******************************************************************************
-**
-** Function         nfc_hal_nv_co_write
-**
-** Description      This function is called by io to send file data to the
-**                  phone.
-**
-** Parameters       p_buf   - buffer to read the data from.
-**                  nbytes  - number of bytes to write out to the file.
-**
-** Returns          void
-**
-**                  Note: Upon completion of the request, nfa_nv_ci_write () is
-**                        called with the file descriptor and the status. The
-**                        call-in function should only be called when ALL
-**                        requested bytes have been written, or an error has
-**                        been detected,
-**
-*******************************************************************************/
-void nfc_hal_nv_co_write(const uint8_t* p_buf, uint16_t nbytes, uint8_t block);
-
-extern void nfa_nv_ci_read(uint16_t num_bytes_read, tNFA_NV_CO_STATUS status,
-                           uint8_t block);
-extern void nfa_nv_ci_write(tNFA_NV_CO_STATUS status);
-
-#endif /* NFC_HAL_HCI_INCLUDED */
-#endif /* NFC_HAL_NV_CO_H */
diff --git a/src/include/CrcChecksum.h b/src/include/CrcChecksum.h
index f3154f2..c0e1e1d 100644
--- a/src/include/CrcChecksum.h
+++ b/src/include/CrcChecksum.h
@@ -19,9 +19,6 @@
 
 #include <stdbool.h>
 
-#ifdef __cplusplus
-extern "C" {
-#endif
 
 /*******************************************************************************
 **
@@ -45,7 +42,3 @@ unsigned short crcChecksumCompute(const unsigned char* buffer, int bufferLen);
 **
 *******************************************************************************/
 bool crcChecksumVerifyIntegrity(const char* filename);
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/include/NfcAdaptation.h b/src/include/NfcAdaptation.h
old mode 100644
new mode 100755
index 82ae7f7..320b0ff
--- a/src/include/NfcAdaptation.h
+++ b/src/include/NfcAdaptation.h
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -37,17 +37,23 @@
 #pragma once
 #include <pthread.h>
 
+#include "config.h"
 #include "nfc_target.h"
 #include "nfc_hal_api.h"
 #include <hardware/nfc.h>
 #include <utils/RefBase.h>
+#include <android/hardware/nfc/1.0/INfc.h>
+#include <android/hardware/nfc/1.0/INfcClientCallback.h>
+#include <android/hardware/nfc/1.0/types.h>
+
+using ::android::sp;
 
 namespace android {
 namespace hardware {
 namespace nfc {
 namespace V1_0 {
-    struct INfc;
-    struct INfcClientCallback;
+struct INfc;
+struct INfcClientCallback;
 }
 namespace V1_1 {
 struct INfc;
@@ -65,6 +71,12 @@ namespace V1_0 {
 struct INqNfc;
 } } } } }
 
+/*
+ * Uncomment define ENABLE_ESE_CLIENT to
+ * enable eSE client
+ */
+//#define ENABLE_ESE_CLIENT TRUE
+
 class ThreadMutex {
  public:
   ThreadMutex();
@@ -103,6 +115,8 @@ class AutoThreadMutex {
   ThreadMutex& mm;
 };
 
+class NfcDeathRecipient ;
+
 class NfcAdaptation {
  public:
   virtual ~NfcAdaptation();
@@ -113,6 +127,9 @@ class NfcAdaptation {
   static NfcAdaptation& GetInstance();
   tHAL_NFC_ENTRY* GetHalEntryFuncs();
   void DownloadFirmware();
+  void GetNxpConfigs(std::map<std::string, ConfigValue>& configMap);
+  void GetVendorConfigs(std::map<std::string, ConfigValue>& configMap);
+  void Dump(int fd);
 #if (NXP_EXTNS == TRUE)
   void MinInitialize();
   int HalGetFwDwnldFlag(uint8_t* fwDnldRequest);
@@ -127,7 +144,6 @@ class NfcAdaptation {
   static ThreadMutex sIoctlLock;
   ThreadCondVar mCondVar;
   tHAL_NFC_ENTRY mHalEntryFuncs;  // function pointers for HAL entry points
-  static nfc_nci_device_t* mHalDeviceContext;
   static tHAL_NFC_CBACK* mHalCallback;
   static tHAL_NFC_DATA_CBACK* mHalDataCallback;
   static ThreadCondVar mHalOpenCompletedEvent;
@@ -137,8 +153,8 @@ class NfcAdaptation {
   static android::sp<android::hardware::nfc::V1_1::INfc> mHal_1_1;
   static android::sp<vendor::nxp::hardware::nfc::V1_0::INqNfc> mNqHal;
   static android::hardware::nfc::V1_1::INfcClientCallback* mCallback;
+  sp<NfcDeathRecipient> mNfcHalDeathRecipient;
 #if (NXP_EXTNS == TRUE)
-  pthread_t mThreadId;
   static ThreadCondVar mHalCoreResetCompletedEvent;
   static ThreadCondVar mHalCoreInitCompletedEvent;
   static ThreadCondVar mHalInitCompletedEvent;
diff --git a/src/hal/include/Nxp_Features.h b/src/include/Nxp_Features.h
similarity index 100%
rename from src/hal/include/Nxp_Features.h
rename to src/include/Nxp_Features.h
diff --git a/src/include/_OverrideLog.h b/src/include/_OverrideLog.h
deleted file mode 100644
index addbea7..0000000
--- a/src/include/_OverrideLog.h
+++ /dev/null
@@ -1,95 +0,0 @@
-/******************************************************************************
- *
- *  Copyright (C) 2012 Broadcom Corporation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at:
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-/******************************************************************************
- *
- *  Override the Android logging macro(s) from
- *  /system/core/include/cutils/log.h. This header must be the first header
- *  included by a *.cpp file so the original Android macro can be replaced.
- *  Do not include this header in another header, because that will create
- *  unnecessary dependency.
- *
- ******************************************************************************/
-#pragma once
-
-// Override Android's ALOGD macro by adding a boolean expression.
-#define ALOGD(...) \
-  ((void)ALOGD_IF(appl_trace_level >= BT_TRACE_LEVEL_DEBUG, __VA_ARGS__))
-
-#include <cutils/log.h>  //define Android logging macros
-#include "bt_types.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-extern unsigned char appl_trace_level;
-extern uint32_t ScrProtocolTraceFlag;
-
-#if (NXP_EXTNS == TRUE)
-extern unsigned char
-    appl_dta_mode_flag;  // defined for run time DTA mode selection
-#endif
-/*******************************************************************************
-**
-** Function:        initializeGlobalAppLogLevel
-**
-** Description:     Initialize and get global logging level from .conf or
-**                  Android property nfc.app_log_level.  The Android property
-**                  overrides .conf variable.
-**
-** Returns:         Global log level:
-**                  BT_TRACE_LEVEL_NONE    0 * No trace messages to be generated
-**                  BT_TRACE_LEVEL_ERROR   1 * Error condition trace messages
-**                  BT_TRACE_LEVEL_WARNING 2 * Warning condition trace messages
-**                  BT_TRACE_LEVEL_API     3 * API traces
-**                  BT_TRACE_LEVEL_EVENT   4 * Debug messages for events
-**                  BT_TRACE_LEVEL_DEBUG   5 * Debug messages (general)
-**
-*******************************************************************************/
-unsigned char initializeGlobalAppLogLevel();
-uint32_t initializeProtocolLogLevel();
-
-#if (NXP_EXTNS == TRUE)
-/*******************************************************************************
-**
-** Function:        initializeGlobalDtaMode
-**
-** Description:     Initialize and get global DTA mode from .conf
-**
-** Returns:         none:
-**
-*******************************************************************************/
-void initializeGlobalAppDtaMode();
-
-/*******************************************************************************
-**
-** Function:        enableDisableAppLevel
-**
-** Description:      This function can be used to enable/disable application
-**                   trace  logs
-**
-** Returns:         none:
-**
-*******************************************************************************/
-void enableDisableAppLevel(uint8_t type);
-#endif
-
-#ifdef __cplusplus
-}
-#endif
diff --git a/src/include/android_logmsg.h b/src/include/android_logmsg.h
deleted file mode 100644
index efcaf0a..0000000
--- a/src/include/android_logmsg.h
+++ /dev/null
@@ -1,88 +0,0 @@
-/******************************************************************************
- *
- *  Copyright (C) 2011-2012 Broadcom Corporation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at:
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-/******************************************************************************
- *
- *  The original Work has been changed by NXP Semiconductors.
- *
- *  Copyright (C) 2015 NXP Semiconductors
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-/* Decode NFC packets and print them to ADB log.
-* If protocol decoder is not present, then decode packets into hex numbers.
-******************************************************************************/
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include "data_types.h"
-#include "nfc_types.h"
-
-#define DISP_NCI ProtoDispAdapterDisplayNciPacket
-void ProtoDispAdapterDisplayNciPacket(uint8_t* nciPacket, uint16_t nciPacketLen,
-                                      bool is_recv);
-void ProtoDispAdapterUseRawOutput(bool isUseRaw);
-void ScrLog(uint32_t trace_set_mask, const char* fmt_str, ...);
-void LogMsg(uint32_t trace_set_mask, const char* fmt_str, ...);
-void LogMsg_0(uint32_t trace_set_mask, const char* p_str);
-void LogMsg_1(uint32_t trace_set_mask, const char* fmt_str, uintptr_t p1);
-void LogMsg_2(uint32_t trace_set_mask, const char* fmt_str, uintptr_t p1,
-              uintptr_t p2);
-void LogMsg_3(uint32_t trace_set_mask, const char* fmt_str, uintptr_t p1,
-              uintptr_t p2, uintptr_t p3);
-void LogMsg_4(uint32_t trace_set_mask, const char* fmt_str, uintptr_t p1,
-              uintptr_t p2, uintptr_t p3, uintptr_t p4);
-void LogMsg_5(uint32_t trace_set_mask, const char* fmt_str, uintptr_t p1,
-              uintptr_t p2, uintptr_t p3, uintptr_t p4, uintptr_t p5);
-void LogMsg_6(uint32_t trace_set_mask, const char* fmt_str, uintptr_t p1,
-              uintptr_t p2, uintptr_t p3, uintptr_t p4, uintptr_t p5,
-              uintptr_t p6);
-uint8_t* scru_dump_hex(uint8_t* p, char* pTitle, uint32_t len, uint32_t layer,
-                       uint32_t type);
-void BTDISP_LOCK_LOG();
-void BTDISP_UNLOCK_LOG();
-void BTDISP_INIT_LOCK();
-void BTDISP_UNINIT_LOCK();
-void DispHciCmd(NFC_HDR* p_buf);
-void DispHciEvt(NFC_HDR* p_buf);
-void DispLLCP(NFC_HDR* p_buf, bool is_recv);
-void DispHcp(uint8_t* data, uint16_t len, bool is_recv);
-void DispSNEP(uint8_t local_sap, uint8_t remote_sap, NFC_HDR* p_buf,
-              bool is_first, bool is_rx);
-void DispCHO(uint8_t* pMsg, uint32_t MsgLen, bool is_rx);
-void DispT3TagMessage(NFC_HDR* p_msg, bool is_rx);
-void DispRWT4Tags(NFC_HDR* p_buf, bool is_rx);
-void DispCET4Tags(NFC_HDR* p_buf, bool is_rx);
-void DispRWI93Tag(NFC_HDR* p_buf, bool is_rx, uint8_t command_to_respond);
-void DispNDEFMsg(uint8_t* pMsg, uint32_t MsgLen, bool is_recv);
-
-#ifdef __cplusplus
-};
-#endif
diff --git a/src/include/bt_trace.h b/src/include/bt_trace.h
deleted file mode 100644
index ccb9795..0000000
--- a/src/include/bt_trace.h
+++ /dev/null
@@ -1,1876 +0,0 @@
-/******************************************************************************
- *
- *  Copyright (C) 1999-2012 Broadcom Corporation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at:
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-#ifndef BT_TRACE_H
-#define BT_TRACE_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* External declaration for appl_trace_level here to avoid to add the
- * declaration in all the files using APPL_TRACExxx macros */
-extern uint8_t appl_trace_level;
-
-/* Prototype for message logging function. */
-extern void LogMsg(uint32_t trace_set_mask, const char* fmt_str, ...);
-extern void LogMsg_0(uint32_t trace_set_mask, const char* p_str);
-extern void LogMsg_1(uint32_t trace_set_mask, const char* fmt_str,
-                     uintptr_t p1);
-extern void LogMsg_2(uint32_t trace_set_mask, const char* fmt_str, uintptr_t p1,
-                     uintptr_t p2);
-extern void LogMsg_3(uint32_t trace_set_mask, const char* fmt_str, uintptr_t p1,
-                     uintptr_t p2, uintptr_t p3);
-extern void LogMsg_4(uint32_t trace_set_mask, const char* fmt_str, uintptr_t p1,
-                     uintptr_t p2, uintptr_t p3, uintptr_t p4);
-extern void LogMsg_5(uint32_t trace_set_mask, const char* fmt_str, uintptr_t p1,
-                     uintptr_t p2, uintptr_t p3, uintptr_t p4, uintptr_t p5);
-extern void LogMsg_6(uint32_t trace_set_mask, const char* fmt_str, uintptr_t p1,
-                     uintptr_t p2, uintptr_t p3, uintptr_t p4, uintptr_t p5,
-                     uintptr_t p6);
-
-#ifdef __cplusplus
-}
-#endif
-
-/******************************************************************************
-**
-** Trace configurable parameters
-**
-******************************************************************************/
-
-/* Enables or disables verbose trace information. */
-#ifndef BT_TRACE_VERBOSE
-#define BT_TRACE_VERBOSE false
-#endif
-
-/* Enables or disables protocol trace information. */
-#ifndef BT_TRACE_PROTOCOL
-#define BT_TRACE_PROTOCOL true /* Android requires true */
-#endif
-
-/******************************************************************************
-**
-** Trace Levels
-**
-** The following values may be used for different levels:
-**      BT_TRACE_LEVEL_NONE    0        * No trace messages to be generated
-**      BT_TRACE_LEVEL_ERROR   1        * Error condition trace messages
-**      BT_TRACE_LEVEL_WARNING 2        * Warning condition trace messages
-**      BT_TRACE_LEVEL_API     3        * API traces
-**      BT_TRACE_LEVEL_EVENT   4        * Debug messages for events
-**      BT_TRACE_LEVEL_DEBUG   5        * Debug messages (general)
-******************************************************************************/
-
-/* Core Stack default trace levels */
-#ifndef HCI_INITIAL_TRACE_LEVEL
-#define HCI_INITIAL_TRACE_LEVEL BT_TRACE_LEVEL_DEBUG
-#endif
-
-#ifndef LLCP_INITIAL_TRACE_LEVEL
-#define LLCP_INITIAL_TRACE_LEVEL BT_TRACE_LEVEL_DEBUG
-#endif
-
-#ifndef APPL_INITIAL_TRACE_LEVEL
-#define APPL_INITIAL_TRACE_LEVEL BT_TRACE_LEVEL_DEBUG
-#endif
-
-#ifndef NFC_INITIAL_TRACE_LEVEL
-#define NFC_INITIAL_TRACE_LEVEL BT_TRACE_LEVEL_DEBUG
-#endif
-
-#ifndef SMP_INITIAL_TRACE_LEVEL
-#define SMP_INITIAL_TRACE_LEVEL BT_TRACE_LEVEL_DEBUG
-#endif
-
-#define BT_TRACE_0(l, t, m) \
-  LogMsg_0((TRACE_CTRL_GENERAL | (l) | TRACE_ORG_STACK | (t)), (m))
-#define BT_TRACE_1(l, t, m, p1)                                   \
-  LogMsg_1(TRACE_CTRL_GENERAL | (l) | TRACE_ORG_STACK | (t), (m), \
-           (uintptr_t)(p1))
-#define BT_TRACE_2(l, t, m, p1, p2)                               \
-  LogMsg_2(TRACE_CTRL_GENERAL | (l) | TRACE_ORG_STACK | (t), (m), \
-           (uintptr_t)(p1), (uintptr_t)(p2))
-#define BT_TRACE_3(l, t, m, p1, p2, p3)                           \
-  LogMsg_3(TRACE_CTRL_GENERAL | (l) | TRACE_ORG_STACK | (t), (m), \
-           (uintptr_t)(p1), (uintptr_t)(p2), (uintptr_t)(p3))
-#define BT_TRACE_4(l, t, m, p1, p2, p3, p4)                       \
-  LogMsg_4(TRACE_CTRL_GENERAL | (l) | TRACE_ORG_STACK | (t), (m), \
-           (uintptr_t)(p1), (uintptr_t)(p2), (uintptr_t)(p3), (uintptr_t)(p4))
-#define BT_TRACE_5(l, t, m, p1, p2, p3, p4, p5)                                \
-  LogMsg_5(TRACE_CTRL_GENERAL | (l) | TRACE_ORG_STACK | (t), (m),              \
-           (uintptr_t)(p1), (uintptr_t)(p2), (uintptr_t)(p3), (uintptr_t)(p4), \
-           (uintptr_t)(p5))
-#define BT_TRACE_6(l, t, m, p1, p2, p3, p4, p5, p6)                            \
-  LogMsg_6(TRACE_CTRL_GENERAL | (l) | TRACE_ORG_STACK | (t), (m),              \
-           (uintptr_t)(p1), (uintptr_t)(p2), (uintptr_t)(p3), (uintptr_t)(p4), \
-           (uintptr_t)(p5), (uintptr_t)(p6))
-
-#define BT_ERROR_TRACE_0(l, m) \
-  LogMsg_0(TRACE_CTRL_GENERAL | (l) | TRACE_ORG_STACK | TRACE_TYPE_ERROR, (m))
-#define BT_ERROR_TRACE_1(l, m, p1)                                             \
-  LogMsg_1(TRACE_CTRL_GENERAL | (l) | TRACE_ORG_STACK | TRACE_TYPE_ERROR, (m), \
-           (uintptr_t)(p1))
-#define BT_ERROR_TRACE_2(l, m, p1, p2)                                         \
-  LogMsg_2(TRACE_CTRL_GENERAL | (l) | TRACE_ORG_STACK | TRACE_TYPE_ERROR, (m), \
-           (uintptr_t)(p1), (uintptr_t)(p2))
-#define BT_ERROR_TRACE_3(l, m, p1, p2, p3)                                     \
-  LogMsg_3(TRACE_CTRL_GENERAL | (l) | TRACE_ORG_STACK | TRACE_TYPE_ERROR, (m), \
-           (uintptr_t)(p1), (uintptr_t)(p2), (uintptr_t)(p3))
-
-/* Define tracing for the LLCP unit
-*/
-#define LLCP_TRACE_ERROR0(m)                             \
-  {                                                      \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_ERROR)     \
-      BT_TRACE_0(TRACE_LAYER_LLCP, TRACE_TYPE_ERROR, m); \
-  }
-#define LLCP_TRACE_ERROR1(m, p1)                             \
-  {                                                          \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_ERROR)         \
-      BT_TRACE_1(TRACE_LAYER_LLCP, TRACE_TYPE_ERROR, m, p1); \
-  }
-#define LLCP_TRACE_ERROR2(m, p1, p2)                             \
-  {                                                              \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_ERROR)             \
-      BT_TRACE_2(TRACE_LAYER_LLCP, TRACE_TYPE_ERROR, m, p1, p2); \
-  }
-#define LLCP_TRACE_ERROR3(m, p1, p2, p3)                             \
-  {                                                                  \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                 \
-      BT_TRACE_3(TRACE_LAYER_LLCP, TRACE_TYPE_ERROR, m, p1, p2, p3); \
-  }
-#define LLCP_TRACE_ERROR4(m, p1, p2, p3, p4)                             \
-  {                                                                      \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                     \
-      BT_TRACE_4(TRACE_LAYER_LLCP, TRACE_TYPE_ERROR, m, p1, p2, p3, p4); \
-  }
-#define LLCP_TRACE_ERROR5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                          \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                         \
-      BT_TRACE_5(TRACE_LAYER_LLCP, TRACE_TYPE_ERROR, m, p1, p2, p3, p4, p5); \
-  }
-#define LLCP_TRACE_ERROR6(m, p1, p2, p3, p4, p5, p6)                        \
-  {                                                                         \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                        \
-      BT_TRACE_6(TRACE_LAYER_LLCP, TRACE_TYPE_ERROR, m, p1, p2, p3, p4, p5, \
-                 p6);                                                       \
-  }
-
-#define LLCP_TRACE_WARNING0(m)                             \
-  {                                                        \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_WARNING)     \
-      BT_TRACE_0(TRACE_LAYER_LLCP, TRACE_TYPE_WARNING, m); \
-  }
-#define LLCP_TRACE_WARNING1(m, p1)                             \
-  {                                                            \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_WARNING)         \
-      BT_TRACE_1(TRACE_LAYER_LLCP, TRACE_TYPE_WARNING, m, p1); \
-  }
-#define LLCP_TRACE_WARNING2(m, p1, p2)                             \
-  {                                                                \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_WARNING)             \
-      BT_TRACE_2(TRACE_LAYER_LLCP, TRACE_TYPE_WARNING, m, p1, p2); \
-  }
-#define LLCP_TRACE_WARNING3(m, p1, p2, p3)                             \
-  {                                                                    \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                 \
-      BT_TRACE_3(TRACE_LAYER_LLCP, TRACE_TYPE_WARNING, m, p1, p2, p3); \
-  }
-#define LLCP_TRACE_WARNING4(m, p1, p2, p3, p4)                             \
-  {                                                                        \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                     \
-      BT_TRACE_4(TRACE_LAYER_LLCP, TRACE_TYPE_WARNING, m, p1, p2, p3, p4); \
-  }
-#define LLCP_TRACE_WARNING5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                            \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                         \
-      BT_TRACE_5(TRACE_LAYER_LLCP, TRACE_TYPE_WARNING, m, p1, p2, p3, p4, p5); \
-  }
-#define LLCP_TRACE_WARNING6(m, p1, p2, p3, p4, p5, p6)                        \
-  {                                                                           \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                        \
-      BT_TRACE_6(TRACE_LAYER_LLCP, TRACE_TYPE_WARNING, m, p1, p2, p3, p4, p5, \
-                 p6);                                                         \
-  }
-
-#define LLCP_TRACE_API0(m)                             \
-  {                                                    \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_API)     \
-      BT_TRACE_0(TRACE_LAYER_LLCP, TRACE_TYPE_API, m); \
-  }
-#define LLCP_TRACE_API1(m, p1)                             \
-  {                                                        \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_API)         \
-      BT_TRACE_1(TRACE_LAYER_LLCP, TRACE_TYPE_API, m, p1); \
-  }
-#define LLCP_TRACE_API2(m, p1, p2)                             \
-  {                                                            \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_API)             \
-      BT_TRACE_2(TRACE_LAYER_LLCP, TRACE_TYPE_API, m, p1, p2); \
-  }
-#define LLCP_TRACE_API3(m, p1, p2, p3)                             \
-  {                                                                \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_API)                 \
-      BT_TRACE_3(TRACE_LAYER_LLCP, TRACE_TYPE_API, m, p1, p2, p3); \
-  }
-#define LLCP_TRACE_API4(m, p1, p2, p3, p4)                             \
-  {                                                                    \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_API)                     \
-      BT_TRACE_4(TRACE_LAYER_LLCP, TRACE_TYPE_API, m, p1, p2, p3, p4); \
-  }
-#define LLCP_TRACE_API5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                        \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_API)                         \
-      BT_TRACE_5(TRACE_LAYER_LLCP, TRACE_TYPE_API, m, p1, p2, p3, p4, p5); \
-  }
-#define LLCP_TRACE_API6(m, p1, p2, p3, p4, p5, p6)                             \
-  {                                                                            \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_API)                             \
-      BT_TRACE_6(TRACE_LAYER_LLCP, TRACE_TYPE_API, m, p1, p2, p3, p4, p5, p6); \
-  }
-
-#define LLCP_TRACE_EVENT0(m)                             \
-  {                                                      \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_EVENT)     \
-      BT_TRACE_0(TRACE_LAYER_LLCP, TRACE_TYPE_EVENT, m); \
-  }
-#define LLCP_TRACE_EVENT1(m, p1)                             \
-  {                                                          \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_EVENT)         \
-      BT_TRACE_1(TRACE_LAYER_LLCP, TRACE_TYPE_EVENT, m, p1); \
-  }
-#define LLCP_TRACE_EVENT2(m, p1, p2)                             \
-  {                                                              \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_EVENT)             \
-      BT_TRACE_2(TRACE_LAYER_LLCP, TRACE_TYPE_EVENT, m, p1, p2); \
-  }
-#define LLCP_TRACE_EVENT3(m, p1, p2, p3)                             \
-  {                                                                  \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                 \
-      BT_TRACE_3(TRACE_LAYER_LLCP, TRACE_TYPE_EVENT, m, p1, p2, p3); \
-  }
-#define LLCP_TRACE_EVENT4(m, p1, p2, p3, p4)                             \
-  {                                                                      \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                     \
-      BT_TRACE_4(TRACE_LAYER_LLCP, TRACE_TYPE_EVENT, m, p1, p2, p3, p4); \
-  }
-#define LLCP_TRACE_EVENT5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                          \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                         \
-      BT_TRACE_5(TRACE_LAYER_LLCP, TRACE_TYPE_EVENT, m, p1, p2, p3, p4, p5); \
-  }
-#define LLCP_TRACE_EVENT6(m, p1, p2, p3, p4, p5, p6)                        \
-  {                                                                         \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                        \
-      BT_TRACE_6(TRACE_LAYER_LLCP, TRACE_TYPE_EVENT, m, p1, p2, p3, p4, p5, \
-                 p6);                                                       \
-  }
-
-#define LLCP_TRACE_DEBUG0(m)                             \
-  {                                                      \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)     \
-      BT_TRACE_0(TRACE_LAYER_LLCP, TRACE_TYPE_DEBUG, m); \
-  }
-#define LLCP_TRACE_DEBUG1(m, p1)                             \
-  {                                                          \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)         \
-      BT_TRACE_1(TRACE_LAYER_LLCP, TRACE_TYPE_DEBUG, m, p1); \
-  }
-#define LLCP_TRACE_DEBUG2(m, p1, p2)                             \
-  {                                                              \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)             \
-      BT_TRACE_2(TRACE_LAYER_LLCP, TRACE_TYPE_DEBUG, m, p1, p2); \
-  }
-#define LLCP_TRACE_DEBUG3(m, p1, p2, p3)                             \
-  {                                                                  \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                 \
-      BT_TRACE_3(TRACE_LAYER_LLCP, TRACE_TYPE_DEBUG, m, p1, p2, p3); \
-  }
-#define LLCP_TRACE_DEBUG4(m, p1, p2, p3, p4)                             \
-  {                                                                      \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                     \
-      BT_TRACE_4(TRACE_LAYER_LLCP, TRACE_TYPE_DEBUG, m, p1, p2, p3, p4); \
-  }
-#define LLCP_TRACE_DEBUG5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                          \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                         \
-      BT_TRACE_5(TRACE_LAYER_LLCP, TRACE_TYPE_DEBUG, m, p1, p2, p3, p4, p5); \
-  }
-#define LLCP_TRACE_DEBUG6(m, p1, p2, p3, p4, p5, p6)                        \
-  {                                                                         \
-    if (llcp_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                        \
-      BT_TRACE_6(TRACE_LAYER_LLCP, TRACE_TYPE_DEBUG, m, p1, p2, p3, p4, p5, \
-                 p6);                                                       \
-  }
-
-/* Define tracing for the NFC unit
-*/
-#define NFC_TRACE_ERROR0(m)                             \
-  {                                                     \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_ERROR)     \
-      BT_TRACE_0(TRACE_LAYER_NFC, TRACE_TYPE_ERROR, m); \
-  }
-#define NFC_TRACE_ERROR1(m, p1)                             \
-  {                                                         \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_ERROR)         \
-      BT_TRACE_1(TRACE_LAYER_NFC, TRACE_TYPE_ERROR, m, p1); \
-  }
-#define NFC_TRACE_ERROR2(m, p1, p2)                             \
-  {                                                             \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_ERROR)             \
-      BT_TRACE_2(TRACE_LAYER_NFC, TRACE_TYPE_ERROR, m, p1, p2); \
-  }
-#define NFC_TRACE_ERROR3(m, p1, p2, p3)                             \
-  {                                                                 \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                 \
-      BT_TRACE_3(TRACE_LAYER_NFC, TRACE_TYPE_ERROR, m, p1, p2, p3); \
-  }
-#define NFC_TRACE_ERROR4(m, p1, p2, p3, p4)                             \
-  {                                                                     \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                     \
-      BT_TRACE_4(TRACE_LAYER_NFC, TRACE_TYPE_ERROR, m, p1, p2, p3, p4); \
-  }
-#define NFC_TRACE_ERROR5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                         \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                         \
-      BT_TRACE_5(TRACE_LAYER_NFC, TRACE_TYPE_ERROR, m, p1, p2, p3, p4, p5); \
-  }
-#define NFC_TRACE_ERROR6(m, p1, p2, p3, p4, p5, p6)                        \
-  {                                                                        \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                        \
-      BT_TRACE_6(TRACE_LAYER_NFC, TRACE_TYPE_ERROR, m, p1, p2, p3, p4, p5, \
-                 p6);                                                      \
-  }
-
-#define NFC_TRACE_WARNING0(m)                             \
-  {                                                       \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_WARNING)     \
-      BT_TRACE_0(TRACE_LAYER_NFC, TRACE_TYPE_WARNING, m); \
-  }
-#define NFC_TRACE_WARNING1(m, p1)                             \
-  {                                                           \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_WARNING)         \
-      BT_TRACE_1(TRACE_LAYER_NFC, TRACE_TYPE_WARNING, m, p1); \
-  }
-#define NFC_TRACE_WARNING2(m, p1, p2)                             \
-  {                                                               \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_WARNING)             \
-      BT_TRACE_2(TRACE_LAYER_NFC, TRACE_TYPE_WARNING, m, p1, p2); \
-  }
-#define NFC_TRACE_WARNING3(m, p1, p2, p3)                             \
-  {                                                                   \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                 \
-      BT_TRACE_3(TRACE_LAYER_NFC, TRACE_TYPE_WARNING, m, p1, p2, p3); \
-  }
-#define NFC_TRACE_WARNING4(m, p1, p2, p3, p4)                             \
-  {                                                                       \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                     \
-      BT_TRACE_4(TRACE_LAYER_NFC, TRACE_TYPE_WARNING, m, p1, p2, p3, p4); \
-  }
-#define NFC_TRACE_WARNING5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                           \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                         \
-      BT_TRACE_5(TRACE_LAYER_NFC, TRACE_TYPE_WARNING, m, p1, p2, p3, p4, p5); \
-  }
-#define NFC_TRACE_WARNING6(m, p1, p2, p3, p4, p5, p6)                        \
-  {                                                                          \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                        \
-      BT_TRACE_6(TRACE_LAYER_NFC, TRACE_TYPE_WARNING, m, p1, p2, p3, p4, p5, \
-                 p6);                                                        \
-  }
-
-#define NFC_TRACE_API0(m)                             \
-  {                                                   \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_API)     \
-      BT_TRACE_0(TRACE_LAYER_NFC, TRACE_TYPE_API, m); \
-  }
-#define NFC_TRACE_API1(m, p1)                             \
-  {                                                       \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_API)         \
-      BT_TRACE_1(TRACE_LAYER_NFC, TRACE_TYPE_API, m, p1); \
-  }
-#define NFC_TRACE_API2(m, p1, p2)                             \
-  {                                                           \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_API)             \
-      BT_TRACE_2(TRACE_LAYER_NFC, TRACE_TYPE_API, m, p1, p2); \
-  }
-#define NFC_TRACE_API3(m, p1, p2, p3)                             \
-  {                                                               \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_API)                 \
-      BT_TRACE_3(TRACE_LAYER_NFC, TRACE_TYPE_API, m, p1, p2, p3); \
-  }
-#define NFC_TRACE_API4(m, p1, p2, p3, p4)                             \
-  {                                                                   \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_API)                     \
-      BT_TRACE_4(TRACE_LAYER_NFC, TRACE_TYPE_API, m, p1, p2, p3, p4); \
-  }
-#define NFC_TRACE_API5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                       \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_API)                         \
-      BT_TRACE_5(TRACE_LAYER_NFC, TRACE_TYPE_API, m, p1, p2, p3, p4, p5); \
-  }
-#define NFC_TRACE_API6(m, p1, p2, p3, p4, p5, p6)                             \
-  {                                                                           \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_API)                             \
-      BT_TRACE_6(TRACE_LAYER_NFC, TRACE_TYPE_API, m, p1, p2, p3, p4, p5, p6); \
-  }
-
-#define NFC_TRACE_EVENT0(m)                             \
-  {                                                     \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_EVENT)     \
-      BT_TRACE_0(TRACE_LAYER_NFC, TRACE_TYPE_EVENT, m); \
-  }
-#define NFC_TRACE_EVENT1(m, p1)                             \
-  {                                                         \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_EVENT)         \
-      BT_TRACE_1(TRACE_LAYER_NFC, TRACE_TYPE_EVENT, m, p1); \
-  }
-#define NFC_TRACE_EVENT2(m, p1, p2)                             \
-  {                                                             \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_EVENT)             \
-      BT_TRACE_2(TRACE_LAYER_NFC, TRACE_TYPE_EVENT, m, p1, p2); \
-  }
-#define NFC_TRACE_EVENT3(m, p1, p2, p3)                             \
-  {                                                                 \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                 \
-      BT_TRACE_3(TRACE_LAYER_NFC, TRACE_TYPE_EVENT, m, p1, p2, p3); \
-  }
-#define NFC_TRACE_EVENT4(m, p1, p2, p3, p4)                             \
-  {                                                                     \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                     \
-      BT_TRACE_4(TRACE_LAYER_NFC, TRACE_TYPE_EVENT, m, p1, p2, p3, p4); \
-  }
-#define NFC_TRACE_EVENT5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                         \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                         \
-      BT_TRACE_5(TRACE_LAYER_NFC, TRACE_TYPE_EVENT, m, p1, p2, p3, p4, p5); \
-  }
-#define NFC_TRACE_EVENT6(m, p1, p2, p3, p4, p5, p6)                        \
-  {                                                                        \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                        \
-      BT_TRACE_6(TRACE_LAYER_NFC, TRACE_TYPE_EVENT, m, p1, p2, p3, p4, p5, \
-                 p6);                                                      \
-  }
-
-#define NFC_TRACE_DEBUG0(m)                             \
-  {                                                     \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)     \
-      BT_TRACE_0(TRACE_LAYER_NFC, TRACE_TYPE_DEBUG, m); \
-  }
-#define NFC_TRACE_DEBUG1(m, p1)                             \
-  {                                                         \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)         \
-      BT_TRACE_1(TRACE_LAYER_NFC, TRACE_TYPE_DEBUG, m, p1); \
-  }
-#define NFC_TRACE_DEBUG2(m, p1, p2)                             \
-  {                                                             \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)             \
-      BT_TRACE_2(TRACE_LAYER_NFC, TRACE_TYPE_DEBUG, m, p1, p2); \
-  }
-#define NFC_TRACE_DEBUG3(m, p1, p2, p3)                             \
-  {                                                                 \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                 \
-      BT_TRACE_3(TRACE_LAYER_NFC, TRACE_TYPE_DEBUG, m, p1, p2, p3); \
-  }
-#define NFC_TRACE_DEBUG4(m, p1, p2, p3, p4)                             \
-  {                                                                     \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                     \
-      BT_TRACE_4(TRACE_LAYER_NFC, TRACE_TYPE_DEBUG, m, p1, p2, p3, p4); \
-  }
-#define NFC_TRACE_DEBUG5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                         \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                         \
-      BT_TRACE_5(TRACE_LAYER_NFC, TRACE_TYPE_DEBUG, m, p1, p2, p3, p4, p5); \
-  }
-#define NFC_TRACE_DEBUG6(m, p1, p2, p3, p4, p5, p6)                        \
-  {                                                                        \
-    if (nfc_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                        \
-      BT_TRACE_6(TRACE_LAYER_NFC, TRACE_TYPE_DEBUG, m, p1, p2, p3, p4, p5, \
-                 p6);                                                      \
-  }
-
-#define NCI_TRACE_ERROR0(m)                             \
-  {                                                     \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_ERROR)    \
-      BT_TRACE_0(TRACE_LAYER_NCI, TRACE_TYPE_ERROR, m); \
-  }
-#define NCI_TRACE_ERROR1(m, p1)                             \
-  {                                                         \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_ERROR)        \
-      BT_TRACE_1(TRACE_LAYER_NCI, TRACE_TYPE_ERROR, m, p1); \
-  }
-#define NCI_TRACE_ERROR2(m, p1, p2)                             \
-  {                                                             \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_ERROR)            \
-      BT_TRACE_2(TRACE_LAYER_NCI, TRACE_TYPE_ERROR, m, p1, p2); \
-  }
-#define NCI_TRACE_ERROR3(m, p1, p2, p3)                             \
-  {                                                                 \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                \
-      BT_TRACE_3(TRACE_LAYER_NCI, TRACE_TYPE_ERROR, m, p1, p2, p3); \
-  }
-#define NCI_TRACE_ERROR4(m, p1, p2, p3, p4)                             \
-  {                                                                     \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                    \
-      BT_TRACE_4(TRACE_LAYER_NCI, TRACE_TYPE_ERROR, m, p1, p2, p3, p4); \
-  }
-#define NCI_TRACE_ERROR5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                         \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                        \
-      BT_TRACE_5(TRACE_LAYER_NCI, TRACE_TYPE_ERROR, m, p1, p2, p3, p4, p5); \
-  }
-#define NCI_TRACE_ERROR6(m, p1, p2, p3, p4, p5, p6)                        \
-  {                                                                        \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                       \
-      BT_TRACE_6(TRACE_LAYER_NCI, TRACE_TYPE_ERROR, m, p1, p2, p3, p4, p5, \
-                 p6);                                                      \
-  }
-
-#define NCI_TRACE_WARNING0(m)                             \
-  {                                                       \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_WARNING)    \
-      BT_TRACE_0(TRACE_LAYER_NCI, TRACE_TYPE_WARNING, m); \
-  }
-#define NCI_TRACE_WARNING1(m, p1)                             \
-  {                                                           \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_WARNING)        \
-      BT_TRACE_1(TRACE_LAYER_NCI, TRACE_TYPE_WARNING, m, p1); \
-  }
-#define NCI_TRACE_WARNING2(m, p1, p2)                             \
-  {                                                               \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_WARNING)            \
-      BT_TRACE_2(TRACE_LAYER_NCI, TRACE_TYPE_WARNING, m, p1, p2); \
-  }
-#define NCI_TRACE_WARNING3(m, p1, p2, p3)                             \
-  {                                                                   \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                \
-      BT_TRACE_3(TRACE_LAYER_NCI, TRACE_TYPE_WARNING, m, p1, p2, p3); \
-  }
-#define NCI_TRACE_WARNING4(m, p1, p2, p3, p4)                             \
-  {                                                                       \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                    \
-      BT_TRACE_4(TRACE_LAYER_NCI, TRACE_TYPE_WARNING, m, p1, p2, p3, p4); \
-  }
-#define NCI_TRACE_WARNING5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                           \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                        \
-      BT_TRACE_5(TRACE_LAYER_NCI, TRACE_TYPE_WARNING, m, p1, p2, p3, p4, p5); \
-  }
-#define NCI_TRACE_WARNING6(m, p1, p2, p3, p4, p5, p6)                        \
-  {                                                                          \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                       \
-      BT_TRACE_6(TRACE_LAYER_NCI, TRACE_TYPE_WARNING, m, p1, p2, p3, p4, p5, \
-                 p6);                                                        \
-  }
-
-#define NCI_TRACE_API0(m)                             \
-  {                                                   \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_API)    \
-      BT_TRACE_0(TRACE_LAYER_NCI, TRACE_TYPE_API, m); \
-  }
-#define NCI_TRACE_API1(m, p1)                             \
-  {                                                       \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_API)        \
-      BT_TRACE_1(TRACE_LAYER_NCI, TRACE_TYPE_API, m, p1); \
-  }
-#define NCI_TRACE_API2(m, p1, p2)                             \
-  {                                                           \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_API)            \
-      BT_TRACE_2(TRACE_LAYER_NCI, TRACE_TYPE_API, m, p1, p2); \
-  }
-#define NCI_TRACE_API3(m, p1, p2, p3)                             \
-  {                                                               \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_API)                \
-      BT_TRACE_3(TRACE_LAYER_NCI, TRACE_TYPE_API, m, p1, p2, p3); \
-  }
-#define NCI_TRACE_API4(m, p1, p2, p3, p4)                             \
-  {                                                                   \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_API)                    \
-      BT_TRACE_4(TRACE_LAYER_NCI, TRACE_TYPE_API, m, p1, p2, p3, p4); \
-  }
-#define NCI_TRACE_API5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                       \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_API)                        \
-      BT_TRACE_5(TRACE_LAYER_NCI, TRACE_TYPE_API, m, p1, p2, p3, p4, p5); \
-  }
-#define NCI_TRACE_API6(m, p1, p2, p3, p4, p5, p6)                             \
-  {                                                                           \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_API)                            \
-      BT_TRACE_6(TRACE_LAYER_NCI, TRACE_TYPE_API, m, p1, p2, p3, p4, p5, p6); \
-  }
-
-#define NCI_TRACE_EVENT0(m)                             \
-  {                                                     \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_EVENT)    \
-      BT_TRACE_0(TRACE_LAYER_NCI, TRACE_TYPE_EVENT, m); \
-  }
-#define NCI_TRACE_EVENT1(m, p1)                             \
-  {                                                         \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_EVENT)        \
-      BT_TRACE_1(TRACE_LAYER_NCI, TRACE_TYPE_EVENT, m, p1); \
-  }
-#define NCI_TRACE_EVENT2(m, p1, p2)                             \
-  {                                                             \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_EVENT)            \
-      BT_TRACE_2(TRACE_LAYER_NCI, TRACE_TYPE_EVENT, m, p1, p2); \
-  }
-#define NCI_TRACE_EVENT3(m, p1, p2, p3)                             \
-  {                                                                 \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                \
-      BT_TRACE_3(TRACE_LAYER_NCI, TRACE_TYPE_EVENT, m, p1, p2, p3); \
-  }
-#define NCI_TRACE_EVENT4(m, p1, p2, p3, p4)                             \
-  {                                                                     \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                    \
-      BT_TRACE_4(TRACE_LAYER_NCI, TRACE_TYPE_EVENT, m, p1, p2, p3, p4); \
-  }
-#define NCI_TRACE_EVENT5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                         \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                        \
-      BT_TRACE_5(TRACE_LAYER_NCI, TRACE_TYPE_EVENT, m, p1, p2, p3, p4, p5); \
-  }
-#define NCI_TRACE_EVENT6(m, p1, p2, p3, p4, p5, p6)                        \
-  {                                                                        \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                       \
-      BT_TRACE_6(TRACE_LAYER_NCI, TRACE_TYPE_EVENT, m, p1, p2, p3, p4, p5, \
-                 p6);                                                      \
-  }
-
-#define NCI_TRACE_DEBUG0(m)                             \
-  {                                                     \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)    \
-      BT_TRACE_0(TRACE_LAYER_NCI, TRACE_TYPE_DEBUG, m); \
-  }
-#define NCI_TRACE_DEBUG1(m, p1)                             \
-  {                                                         \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)        \
-      BT_TRACE_1(TRACE_LAYER_NCI, TRACE_TYPE_DEBUG, m, p1); \
-  }
-#define NCI_TRACE_DEBUG2(m, p1, p2)                             \
-  {                                                             \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)            \
-      BT_TRACE_2(TRACE_LAYER_NCI, TRACE_TYPE_DEBUG, m, p1, p2); \
-  }
-#define NCI_TRACE_DEBUG3(m, p1, p2, p3)                             \
-  {                                                                 \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                \
-      BT_TRACE_3(TRACE_LAYER_NCI, TRACE_TYPE_DEBUG, m, p1, p2, p3); \
-  }
-#define NCI_TRACE_DEBUG4(m, p1, p2, p3, p4)                             \
-  {                                                                     \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                    \
-      BT_TRACE_4(TRACE_LAYER_NCI, TRACE_TYPE_DEBUG, m, p1, p2, p3, p4); \
-  }
-#define NCI_TRACE_DEBUG5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                         \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                        \
-      BT_TRACE_5(TRACE_LAYER_NCI, TRACE_TYPE_DEBUG, m, p1, p2, p3, p4, p5); \
-  }
-#define NCI_TRACE_DEBUG6(m, p1, p2, p3, p4, p5, p6)                        \
-  {                                                                        \
-    if (ncit_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                       \
-      BT_TRACE_6(TRACE_LAYER_NCI, TRACE_TYPE_DEBUG, m, p1, p2, p3, p4, p5, \
-                 p6);                                                      \
-  }
-
-#define RW_TRACE_ERROR0(m)                             \
-  {                                                    \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_ERROR)     \
-      BT_TRACE_0(TRACE_LAYER_RW, TRACE_TYPE_ERROR, m); \
-  }
-#define RW_TRACE_ERROR1(m, p1)                             \
-  {                                                        \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_ERROR)         \
-      BT_TRACE_1(TRACE_LAYER_RW, TRACE_TYPE_ERROR, m, p1); \
-  }
-#define RW_TRACE_ERROR2(m, p1, p2)                             \
-  {                                                            \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_ERROR)             \
-      BT_TRACE_2(TRACE_LAYER_RW, TRACE_TYPE_ERROR, m, p1, p2); \
-  }
-#define RW_TRACE_ERROR3(m, p1, p2, p3)                             \
-  {                                                                \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                 \
-      BT_TRACE_3(TRACE_LAYER_RW, TRACE_TYPE_ERROR, m, p1, p2, p3); \
-  }
-#define RW_TRACE_ERROR4(m, p1, p2, p3, p4)                             \
-  {                                                                    \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                     \
-      BT_TRACE_4(TRACE_LAYER_RW, TRACE_TYPE_ERROR, m, p1, p2, p3, p4); \
-  }
-#define RW_TRACE_ERROR5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                        \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                         \
-      BT_TRACE_5(TRACE_LAYER_RW, TRACE_TYPE_ERROR, m, p1, p2, p3, p4, p5); \
-  }
-#define RW_TRACE_ERROR6(m, p1, p2, p3, p4, p5, p6)                             \
-  {                                                                            \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                             \
-      BT_TRACE_6(TRACE_LAYER_RW, TRACE_TYPE_ERROR, m, p1, p2, p3, p4, p5, p6); \
-  }
-
-#define RW_TRACE_WARNING0(m)                             \
-  {                                                      \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_WARNING)     \
-      BT_TRACE_0(TRACE_LAYER_RW, TRACE_TYPE_WARNING, m); \
-  }
-#define RW_TRACE_WARNING1(m, p1)                             \
-  {                                                          \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_WARNING)         \
-      BT_TRACE_1(TRACE_LAYER_RW, TRACE_TYPE_WARNING, m, p1); \
-  }
-#define RW_TRACE_WARNING2(m, p1, p2)                             \
-  {                                                              \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_WARNING)             \
-      BT_TRACE_2(TRACE_LAYER_RW, TRACE_TYPE_WARNING, m, p1, p2); \
-  }
-#define RW_TRACE_WARNING3(m, p1, p2, p3)                             \
-  {                                                                  \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                 \
-      BT_TRACE_3(TRACE_LAYER_RW, TRACE_TYPE_WARNING, m, p1, p2, p3); \
-  }
-#define RW_TRACE_WARNING4(m, p1, p2, p3, p4)                             \
-  {                                                                      \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                     \
-      BT_TRACE_4(TRACE_LAYER_RW, TRACE_TYPE_WARNING, m, p1, p2, p3, p4); \
-  }
-#define RW_TRACE_WARNING5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                          \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                         \
-      BT_TRACE_5(TRACE_LAYER_RW, TRACE_TYPE_WARNING, m, p1, p2, p3, p4, p5); \
-  }
-#define RW_TRACE_WARNING6(m, p1, p2, p3, p4, p5, p6)                        \
-  {                                                                         \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                        \
-      BT_TRACE_6(TRACE_LAYER_RW, TRACE_TYPE_WARNING, m, p1, p2, p3, p4, p5, \
-                 p6);                                                       \
-  }
-
-#define RW_TRACE_API0(m)                             \
-  {                                                  \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_API)     \
-      BT_TRACE_0(TRACE_LAYER_RW, TRACE_TYPE_API, m); \
-  }
-#define RW_TRACE_API1(m, p1)                             \
-  {                                                      \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_API)         \
-      BT_TRACE_1(TRACE_LAYER_RW, TRACE_TYPE_API, m, p1); \
-  }
-#define RW_TRACE_API2(m, p1, p2)                             \
-  {                                                          \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_API)             \
-      BT_TRACE_2(TRACE_LAYER_RW, TRACE_TYPE_API, m, p1, p2); \
-  }
-#define RW_TRACE_API3(m, p1, p2, p3)                             \
-  {                                                              \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_API)                 \
-      BT_TRACE_3(TRACE_LAYER_RW, TRACE_TYPE_API, m, p1, p2, p3); \
-  }
-#define RW_TRACE_API4(m, p1, p2, p3, p4)                             \
-  {                                                                  \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_API)                     \
-      BT_TRACE_4(TRACE_LAYER_RW, TRACE_TYPE_API, m, p1, p2, p3, p4); \
-  }
-#define RW_TRACE_API5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                      \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_API)                         \
-      BT_TRACE_5(TRACE_LAYER_RW, TRACE_TYPE_API, m, p1, p2, p3, p4, p5); \
-  }
-#define RW_TRACE_API6(m, p1, p2, p3, p4, p5, p6)                             \
-  {                                                                          \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_API)                             \
-      BT_TRACE_6(TRACE_LAYER_RW, TRACE_TYPE_API, m, p1, p2, p3, p4, p5, p6); \
-  }
-
-#define RW_TRACE_EVENT0(m)                             \
-  {                                                    \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_EVENT)     \
-      BT_TRACE_0(TRACE_LAYER_RW, TRACE_TYPE_EVENT, m); \
-  }
-#define RW_TRACE_EVENT1(m, p1)                             \
-  {                                                        \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_EVENT)         \
-      BT_TRACE_1(TRACE_LAYER_RW, TRACE_TYPE_EVENT, m, p1); \
-  }
-#define RW_TRACE_EVENT2(m, p1, p2)                             \
-  {                                                            \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_EVENT)             \
-      BT_TRACE_2(TRACE_LAYER_RW, TRACE_TYPE_EVENT, m, p1, p2); \
-  }
-#define RW_TRACE_EVENT3(m, p1, p2, p3)                             \
-  {                                                                \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                 \
-      BT_TRACE_3(TRACE_LAYER_RW, TRACE_TYPE_EVENT, m, p1, p2, p3); \
-  }
-#define RW_TRACE_EVENT4(m, p1, p2, p3, p4)                             \
-  {                                                                    \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                     \
-      BT_TRACE_4(TRACE_LAYER_RW, TRACE_TYPE_EVENT, m, p1, p2, p3, p4); \
-  }
-#define RW_TRACE_EVENT5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                        \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                         \
-      BT_TRACE_5(TRACE_LAYER_RW, TRACE_TYPE_EVENT, m, p1, p2, p3, p4, p5); \
-  }
-#define RW_TRACE_EVENT6(m, p1, p2, p3, p4, p5, p6)                             \
-  {                                                                            \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                             \
-      BT_TRACE_6(TRACE_LAYER_RW, TRACE_TYPE_EVENT, m, p1, p2, p3, p4, p5, p6); \
-  }
-
-#define RW_TRACE_DEBUG0(m)                             \
-  {                                                    \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)     \
-      BT_TRACE_0(TRACE_LAYER_RW, TRACE_TYPE_DEBUG, m); \
-  }
-#define RW_TRACE_DEBUG1(m, p1)                             \
-  {                                                        \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)         \
-      BT_TRACE_1(TRACE_LAYER_RW, TRACE_TYPE_DEBUG, m, p1); \
-  }
-#define RW_TRACE_DEBUG2(m, p1, p2)                             \
-  {                                                            \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)             \
-      BT_TRACE_2(TRACE_LAYER_RW, TRACE_TYPE_DEBUG, m, p1, p2); \
-  }
-#define RW_TRACE_DEBUG3(m, p1, p2, p3)                             \
-  {                                                                \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                 \
-      BT_TRACE_3(TRACE_LAYER_RW, TRACE_TYPE_DEBUG, m, p1, p2, p3); \
-  }
-#define RW_TRACE_DEBUG4(m, p1, p2, p3, p4)                             \
-  {                                                                    \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                     \
-      BT_TRACE_4(TRACE_LAYER_RW, TRACE_TYPE_DEBUG, m, p1, p2, p3, p4); \
-  }
-#define RW_TRACE_DEBUG5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                        \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                         \
-      BT_TRACE_5(TRACE_LAYER_RW, TRACE_TYPE_DEBUG, m, p1, p2, p3, p4, p5); \
-  }
-#define RW_TRACE_DEBUG6(m, p1, p2, p3, p4, p5, p6)                             \
-  {                                                                            \
-    if (rw_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                             \
-      BT_TRACE_6(TRACE_LAYER_RW, TRACE_TYPE_DEBUG, m, p1, p2, p3, p4, p5, p6); \
-  }
-
-#define CE_TRACE_ERROR0(m)                             \
-  {                                                    \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_ERROR)     \
-      BT_TRACE_0(TRACE_LAYER_CE, TRACE_TYPE_ERROR, m); \
-  }
-#define CE_TRACE_ERROR1(m, p1)                             \
-  {                                                        \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_ERROR)         \
-      BT_TRACE_1(TRACE_LAYER_CE, TRACE_TYPE_ERROR, m, p1); \
-  }
-#define CE_TRACE_ERROR2(m, p1, p2)                             \
-  {                                                            \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_ERROR)             \
-      BT_TRACE_2(TRACE_LAYER_CE, TRACE_TYPE_ERROR, m, p1, p2); \
-  }
-#define CE_TRACE_ERROR3(m, p1, p2, p3)                             \
-  {                                                                \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                 \
-      BT_TRACE_3(TRACE_LAYER_CE, TRACE_TYPE_ERROR, m, p1, p2, p3); \
-  }
-#define CE_TRACE_ERROR4(m, p1, p2, p3, p4)                             \
-  {                                                                    \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                     \
-      BT_TRACE_4(TRACE_LAYER_CE, TRACE_TYPE_ERROR, m, p1, p2, p3, p4); \
-  }
-#define CE_TRACE_ERROR5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                        \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                         \
-      BT_TRACE_5(TRACE_LAYER_CE, TRACE_TYPE_ERROR, m, p1, p2, p3, p4, p5); \
-  }
-#define CE_TRACE_ERROR6(m, p1, p2, p3, p4, p5, p6)                             \
-  {                                                                            \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                             \
-      BT_TRACE_6(TRACE_LAYER_CE, TRACE_TYPE_ERROR, m, p1, p2, p3, p4, p5, p6); \
-  }
-
-#define CE_TRACE_WARNING0(m)                             \
-  {                                                      \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_WARNING)     \
-      BT_TRACE_0(TRACE_LAYER_CE, TRACE_TYPE_WARNING, m); \
-  }
-#define CE_TRACE_WARNING1(m, p1)                             \
-  {                                                          \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_WARNING)         \
-      BT_TRACE_1(TRACE_LAYER_CE, TRACE_TYPE_WARNING, m, p1); \
-  }
-#define CE_TRACE_WARNING2(m, p1, p2)                             \
-  {                                                              \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_WARNING)             \
-      BT_TRACE_2(TRACE_LAYER_CE, TRACE_TYPE_WARNING, m, p1, p2); \
-  }
-#define CE_TRACE_WARNING3(m, p1, p2, p3)                             \
-  {                                                                  \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                 \
-      BT_TRACE_3(TRACE_LAYER_CE, TRACE_TYPE_WARNING, m, p1, p2, p3); \
-  }
-#define CE_TRACE_WARNING4(m, p1, p2, p3, p4)                             \
-  {                                                                      \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                     \
-      BT_TRACE_4(TRACE_LAYER_CE, TRACE_TYPE_WARNING, m, p1, p2, p3, p4); \
-  }
-#define CE_TRACE_WARNING5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                          \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                         \
-      BT_TRACE_5(TRACE_LAYER_CE, TRACE_TYPE_WARNING, m, p1, p2, p3, p4, p5); \
-  }
-#define CE_TRACE_WARNING6(m, p1, p2, p3, p4, p5, p6)                        \
-  {                                                                         \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                        \
-      BT_TRACE_6(TRACE_LAYER_CE, TRACE_TYPE_WARNING, m, p1, p2, p3, p4, p5, \
-                 p6);                                                       \
-  }
-
-#define CE_TRACE_API0(m)                             \
-  {                                                  \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_API)     \
-      BT_TRACE_0(TRACE_LAYER_CE, TRACE_TYPE_API, m); \
-  }
-#define CE_TRACE_API1(m, p1)                             \
-  {                                                      \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_API)         \
-      BT_TRACE_1(TRACE_LAYER_CE, TRACE_TYPE_API, m, p1); \
-  }
-#define CE_TRACE_API2(m, p1, p2)                             \
-  {                                                          \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_API)             \
-      BT_TRACE_2(TRACE_LAYER_CE, TRACE_TYPE_API, m, p1, p2); \
-  }
-#define CE_TRACE_API3(m, p1, p2, p3)                             \
-  {                                                              \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_API)                 \
-      BT_TRACE_3(TRACE_LAYER_CE, TRACE_TYPE_API, m, p1, p2, p3); \
-  }
-#define CE_TRACE_API4(m, p1, p2, p3, p4)                             \
-  {                                                                  \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_API)                     \
-      BT_TRACE_4(TRACE_LAYER_CE, TRACE_TYPE_API, m, p1, p2, p3, p4); \
-  }
-#define CE_TRACE_API5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                      \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_API)                         \
-      BT_TRACE_5(TRACE_LAYER_CE, TRACE_TYPE_API, m, p1, p2, p3, p4, p5); \
-  }
-#define CE_TRACE_API6(m, p1, p2, p3, p4, p5, p6)                             \
-  {                                                                          \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_API)                             \
-      BT_TRACE_6(TRACE_LAYER_CE, TRACE_TYPE_API, m, p1, p2, p3, p4, p5, p6); \
-  }
-
-#define CE_TRACE_EVENT0(m)                             \
-  {                                                    \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_EVENT)     \
-      BT_TRACE_0(TRACE_LAYER_CE, TRACE_TYPE_EVENT, m); \
-  }
-#define CE_TRACE_EVENT1(m, p1)                             \
-  {                                                        \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_EVENT)         \
-      BT_TRACE_1(TRACE_LAYER_CE, TRACE_TYPE_EVENT, m, p1); \
-  }
-#define CE_TRACE_EVENT2(m, p1, p2)                             \
-  {                                                            \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_EVENT)             \
-      BT_TRACE_2(TRACE_LAYER_CE, TRACE_TYPE_EVENT, m, p1, p2); \
-  }
-#define CE_TRACE_EVENT3(m, p1, p2, p3)                             \
-  {                                                                \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                 \
-      BT_TRACE_3(TRACE_LAYER_CE, TRACE_TYPE_EVENT, m, p1, p2, p3); \
-  }
-#define CE_TRACE_EVENT4(m, p1, p2, p3, p4)                             \
-  {                                                                    \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                     \
-      BT_TRACE_4(TRACE_LAYER_CE, TRACE_TYPE_EVENT, m, p1, p2, p3, p4); \
-  }
-#define CE_TRACE_EVENT5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                        \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                         \
-      BT_TRACE_5(TRACE_LAYER_CE, TRACE_TYPE_EVENT, m, p1, p2, p3, p4, p5); \
-  }
-#define CE_TRACE_EVENT6(m, p1, p2, p3, p4, p5, p6)                             \
-  {                                                                            \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                             \
-      BT_TRACE_6(TRACE_LAYER_CE, TRACE_TYPE_EVENT, m, p1, p2, p3, p4, p5, p6); \
-  }
-
-#define CE_TRACE_DEBUG0(m)                             \
-  {                                                    \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)     \
-      BT_TRACE_0(TRACE_LAYER_CE, TRACE_TYPE_DEBUG, m); \
-  }
-#define CE_TRACE_DEBUG1(m, p1)                             \
-  {                                                        \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)         \
-      BT_TRACE_1(TRACE_LAYER_CE, TRACE_TYPE_DEBUG, m, p1); \
-  }
-#define CE_TRACE_DEBUG2(m, p1, p2)                             \
-  {                                                            \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)             \
-      BT_TRACE_2(TRACE_LAYER_CE, TRACE_TYPE_DEBUG, m, p1, p2); \
-  }
-#define CE_TRACE_DEBUG3(m, p1, p2, p3)                             \
-  {                                                                \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                 \
-      BT_TRACE_3(TRACE_LAYER_CE, TRACE_TYPE_DEBUG, m, p1, p2, p3); \
-  }
-#define CE_TRACE_DEBUG4(m, p1, p2, p3, p4)                             \
-  {                                                                    \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                     \
-      BT_TRACE_4(TRACE_LAYER_CE, TRACE_TYPE_DEBUG, m, p1, p2, p3, p4); \
-  }
-#define CE_TRACE_DEBUG5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                        \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                         \
-      BT_TRACE_5(TRACE_LAYER_CE, TRACE_TYPE_DEBUG, m, p1, p2, p3, p4, p5); \
-  }
-#define CE_TRACE_DEBUG6(m, p1, p2, p3, p4, p5, p6)                             \
-  {                                                                            \
-    if (ce_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                             \
-      BT_TRACE_6(TRACE_LAYER_CE, TRACE_TYPE_DEBUG, m, p1, p2, p3, p4, p5, p6); \
-  }
-
-#define NDEF_TRACE_ERROR0(m)                             \
-  {                                                      \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_ERROR)     \
-      BT_TRACE_0(TRACE_LAYER_NDEF, TRACE_TYPE_ERROR, m); \
-  }
-#define NDEF_TRACE_ERROR1(m, p1)                             \
-  {                                                          \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_ERROR)         \
-      BT_TRACE_1(TRACE_LAYER_NDEF, TRACE_TYPE_ERROR, m, p1); \
-  }
-#define NDEF_TRACE_ERROR2(m, p1, p2)                             \
-  {                                                              \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_ERROR)             \
-      BT_TRACE_2(TRACE_LAYER_NDEF, TRACE_TYPE_ERROR, m, p1, p2); \
-  }
-#define NDEF_TRACE_ERROR3(m, p1, p2, p3)                             \
-  {                                                                  \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                 \
-      BT_TRACE_3(TRACE_LAYER_NDEF, TRACE_TYPE_ERROR, m, p1, p2, p3); \
-  }
-#define NDEF_TRACE_ERROR4(m, p1, p2, p3, p4)                             \
-  {                                                                      \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                     \
-      BT_TRACE_4(TRACE_LAYER_NDEF, TRACE_TYPE_ERROR, m, p1, p2, p3, p4); \
-  }
-#define NDEF_TRACE_ERROR5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                          \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                         \
-      BT_TRACE_5(TRACE_LAYER_NDEF, TRACE_TYPE_ERROR, m, p1, p2, p3, p4, p5); \
-  }
-#define NDEF_TRACE_ERROR6(m, p1, p2, p3, p4, p5, p6)                        \
-  {                                                                         \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                        \
-      BT_TRACE_6(TRACE_LAYER_NDEF, TRACE_TYPE_ERROR, m, p1, p2, p3, p4, p5, \
-                 p6);                                                       \
-  }
-
-#define NDEF_TRACE_WARNING0(m)                             \
-  {                                                        \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_WARNING)     \
-      BT_TRACE_0(TRACE_LAYER_NDEF, TRACE_TYPE_WARNING, m); \
-  }
-#define NDEF_TRACE_WARNING1(m, p1)                             \
-  {                                                            \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_WARNING)         \
-      BT_TRACE_1(TRACE_LAYER_NDEF, TRACE_TYPE_WARNING, m, p1); \
-  }
-#define NDEF_TRACE_WARNING2(m, p1, p2)                             \
-  {                                                                \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_WARNING)             \
-      BT_TRACE_2(TRACE_LAYER_NDEF, TRACE_TYPE_WARNING, m, p1, p2); \
-  }
-#define NDEF_TRACE_WARNING3(m, p1, p2, p3)                             \
-  {                                                                    \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                 \
-      BT_TRACE_3(TRACE_LAYER_NDEF, TRACE_TYPE_WARNING, m, p1, p2, p3); \
-  }
-#define NDEF_TRACE_WARNING4(m, p1, p2, p3, p4)                             \
-  {                                                                        \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                     \
-      BT_TRACE_4(TRACE_LAYER_NDEF, TRACE_TYPE_WARNING, m, p1, p2, p3, p4); \
-  }
-#define NDEF_TRACE_WARNING5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                            \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                         \
-      BT_TRACE_5(TRACE_LAYER_NDEF, TRACE_TYPE_WARNING, m, p1, p2, p3, p4, p5); \
-  }
-#define NDEF_TRACE_WARNING6(m, p1, p2, p3, p4, p5, p6)                        \
-  {                                                                           \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                        \
-      BT_TRACE_6(TRACE_LAYER_NDEF, TRACE_TYPE_WARNING, m, p1, p2, p3, p4, p5, \
-                 p6);                                                         \
-  }
-
-#define NDEF_TRACE_API0(m)                             \
-  {                                                    \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_API)     \
-      BT_TRACE_0(TRACE_LAYER_NDEF, TRACE_TYPE_API, m); \
-  }
-#define NDEF_TRACE_API1(m, p1)                             \
-  {                                                        \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_API)         \
-      BT_TRACE_1(TRACE_LAYER_NDEF, TRACE_TYPE_API, m, p1); \
-  }
-#define NDEF_TRACE_API2(m, p1, p2)                             \
-  {                                                            \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_API)             \
-      BT_TRACE_2(TRACE_LAYER_NDEF, TRACE_TYPE_API, m, p1, p2); \
-  }
-#define NDEF_TRACE_API3(m, p1, p2, p3)                             \
-  {                                                                \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_API)                 \
-      BT_TRACE_3(TRACE_LAYER_NDEF, TRACE_TYPE_API, m, p1, p2, p3); \
-  }
-#define NDEF_TRACE_API4(m, p1, p2, p3, p4)                             \
-  {                                                                    \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_API)                     \
-      BT_TRACE_4(TRACE_LAYER_NDEF, TRACE_TYPE_API, m, p1, p2, p3, p4); \
-  }
-#define NDEF_TRACE_API5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                        \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_API)                         \
-      BT_TRACE_5(TRACE_LAYER_NDEF, TRACE_TYPE_API, m, p1, p2, p3, p4, p5); \
-  }
-#define NDEF_TRACE_API6(m, p1, p2, p3, p4, p5, p6)                             \
-  {                                                                            \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_API)                             \
-      BT_TRACE_6(TRACE_LAYER_NDEF, TRACE_TYPE_API, m, p1, p2, p3, p4, p5, p6); \
-  }
-
-#define NDEF_TRACE_EVENT0(m)                             \
-  {                                                      \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_EVENT)     \
-      BT_TRACE_0(TRACE_LAYER_NDEF, TRACE_TYPE_EVENT, m); \
-  }
-#define NDEF_TRACE_EVENT1(m, p1)                             \
-  {                                                          \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_EVENT)         \
-      BT_TRACE_1(TRACE_LAYER_NDEF, TRACE_TYPE_EVENT, m, p1); \
-  }
-#define NDEF_TRACE_EVENT2(m, p1, p2)                             \
-  {                                                              \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_EVENT)             \
-      BT_TRACE_2(TRACE_LAYER_NDEF, TRACE_TYPE_EVENT, m, p1, p2); \
-  }
-#define NDEF_TRACE_EVENT3(m, p1, p2, p3)                             \
-  {                                                                  \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                 \
-      BT_TRACE_3(TRACE_LAYER_NDEF, TRACE_TYPE_EVENT, m, p1, p2, p3); \
-  }
-#define NDEF_TRACE_EVENT4(m, p1, p2, p3, p4)                             \
-  {                                                                      \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                     \
-      BT_TRACE_4(TRACE_LAYER_NDEF, TRACE_TYPE_EVENT, m, p1, p2, p3, p4); \
-  }
-#define NDEF_TRACE_EVENT5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                          \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                         \
-      BT_TRACE_5(TRACE_LAYER_NDEF, TRACE_TYPE_EVENT, m, p1, p2, p3, p4, p5); \
-  }
-#define NDEF_TRACE_EVENT6(m, p1, p2, p3, p4, p5, p6)                        \
-  {                                                                         \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                        \
-      BT_TRACE_6(TRACE_LAYER_NDEF, TRACE_TYPE_EVENT, m, p1, p2, p3, p4, p5, \
-                 p6);                                                       \
-  }
-
-#define NDEF_TRACE_DEBUG0(m)                             \
-  {                                                      \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)     \
-      BT_TRACE_0(TRACE_LAYER_NDEF, TRACE_TYPE_DEBUG, m); \
-  }
-#define NDEF_TRACE_DEBUG1(m, p1)                             \
-  {                                                          \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)         \
-      BT_TRACE_1(TRACE_LAYER_NDEF, TRACE_TYPE_DEBUG, m, p1); \
-  }
-#define NDEF_TRACE_DEBUG2(m, p1, p2)                             \
-  {                                                              \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)             \
-      BT_TRACE_2(TRACE_LAYER_NDEF, TRACE_TYPE_DEBUG, m, p1, p2); \
-  }
-#define NDEF_TRACE_DEBUG3(m, p1, p2, p3)                             \
-  {                                                                  \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                 \
-      BT_TRACE_3(TRACE_LAYER_NDEF, TRACE_TYPE_DEBUG, m, p1, p2, p3); \
-  }
-#define NDEF_TRACE_DEBUG4(m, p1, p2, p3, p4)                             \
-  {                                                                      \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                     \
-      BT_TRACE_4(TRACE_LAYER_NDEF, TRACE_TYPE_DEBUG, m, p1, p2, p3, p4); \
-  }
-#define NDEF_TRACE_DEBUG5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                          \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                         \
-      BT_TRACE_5(TRACE_LAYER_NDEF, TRACE_TYPE_DEBUG, m, p1, p2, p3, p4, p5); \
-  }
-#define NDEF_TRACE_DEBUG6(m, p1, p2, p3, p4, p5, p6)                        \
-  {                                                                         \
-    if (ndef_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                        \
-      BT_TRACE_6(TRACE_LAYER_NDEF, TRACE_TYPE_DEBUG, m, p1, p2, p3, p4, p5, \
-                 p6);                                                       \
-  }
-
-/* Define tracing for the NFA unit
-*/
-#define NFA_TRACE_ERROR0(m)                             \
-  {                                                     \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_ERROR) \
-      BT_TRACE_0(TRACE_LAYER_NFA, TRACE_TYPE_ERROR, m); \
-  }
-#define NFA_TRACE_ERROR1(m, p1)                             \
-  {                                                         \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_ERROR)     \
-      BT_TRACE_1(TRACE_LAYER_NFA, TRACE_TYPE_ERROR, m, p1); \
-  }
-#define NFA_TRACE_ERROR2(m, p1, p2)                             \
-  {                                                             \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_ERROR)         \
-      BT_TRACE_2(TRACE_LAYER_NFA, TRACE_TYPE_ERROR, m, p1, p2); \
-  }
-#define NFA_TRACE_ERROR3(m, p1, p2, p3)                             \
-  {                                                                 \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_ERROR)             \
-      BT_TRACE_3(TRACE_LAYER_NFA, TRACE_TYPE_ERROR, m, p1, p2, p3); \
-  }
-#define NFA_TRACE_ERROR4(m, p1, p2, p3, p4)                             \
-  {                                                                     \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                 \
-      BT_TRACE_4(TRACE_LAYER_NFA, TRACE_TYPE_ERROR, m, p1, p2, p3, p4); \
-  }
-#define NFA_TRACE_ERROR5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                         \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                     \
-      BT_TRACE_5(TRACE_LAYER_NFA, TRACE_TYPE_ERROR, m, p1, p2, p3, p4, p5); \
-  }
-#define NFA_TRACE_ERROR6(m, p1, p2, p3, p4, p5, p6)                        \
-  {                                                                        \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                    \
-      BT_TRACE_6(TRACE_LAYER_NFA, TRACE_TYPE_ERROR, m, p1, p2, p3, p4, p5, \
-                 p6);                                                      \
-  }
-
-#define NFA_TRACE_WARNING0(m)                             \
-  {                                                       \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_WARNING) \
-      BT_TRACE_0(TRACE_LAYER_NFA, TRACE_TYPE_WARNING, m); \
-  }
-#define NFA_TRACE_WARNING1(m, p1)                             \
-  {                                                           \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_WARNING)     \
-      BT_TRACE_1(TRACE_LAYER_NFA, TRACE_TYPE_WARNING, m, p1); \
-  }
-#define NFA_TRACE_WARNING2(m, p1, p2)                             \
-  {                                                               \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_WARNING)         \
-      BT_TRACE_2(TRACE_LAYER_NFA, TRACE_TYPE_WARNING, m, p1, p2); \
-  }
-#define NFA_TRACE_WARNING3(m, p1, p2, p3)                             \
-  {                                                                   \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_WARNING)             \
-      BT_TRACE_3(TRACE_LAYER_NFA, TRACE_TYPE_WARNING, m, p1, p2, p3); \
-  }
-#define NFA_TRACE_WARNING4(m, p1, p2, p3, p4)                             \
-  {                                                                       \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                 \
-      BT_TRACE_4(TRACE_LAYER_NFA, TRACE_TYPE_WARNING, m, p1, p2, p3, p4); \
-  }
-#define NFA_TRACE_WARNING5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                           \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                     \
-      BT_TRACE_5(TRACE_LAYER_NFA, TRACE_TYPE_WARNING, m, p1, p2, p3, p4, p5); \
-  }
-#define NFA_TRACE_WARNING6(m, p1, p2, p3, p4, p5, p6)                        \
-  {                                                                          \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                    \
-      BT_TRACE_6(TRACE_LAYER_NFA, TRACE_TYPE_WARNING, m, p1, p2, p3, p4, p5, \
-                 p6);                                                        \
-  }
-
-#define NFA_TRACE_API0(m)                             \
-  {                                                   \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_API) \
-      BT_TRACE_0(TRACE_LAYER_NFA, TRACE_TYPE_API, m); \
-  }
-#define NFA_TRACE_API1(m, p1)                             \
-  {                                                       \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_API)     \
-      BT_TRACE_1(TRACE_LAYER_NFA, TRACE_TYPE_API, m, p1); \
-  }
-#define NFA_TRACE_API2(m, p1, p2)                             \
-  {                                                           \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_API)         \
-      BT_TRACE_2(TRACE_LAYER_NFA, TRACE_TYPE_API, m, p1, p2); \
-  }
-#define NFA_TRACE_API3(m, p1, p2, p3)                             \
-  {                                                               \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_API)             \
-      BT_TRACE_3(TRACE_LAYER_NFA, TRACE_TYPE_API, m, p1, p2, p3); \
-  }
-#define NFA_TRACE_API4(m, p1, p2, p3, p4)                             \
-  {                                                                   \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_API)                 \
-      BT_TRACE_4(TRACE_LAYER_NFA, TRACE_TYPE_API, m, p1, p2, p3, p4); \
-  }
-#define NFA_TRACE_API5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                       \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_API)                     \
-      BT_TRACE_5(TRACE_LAYER_NFA, TRACE_TYPE_API, m, p1, p2, p3, p4, p5); \
-  }
-#define NFA_TRACE_API6(m, p1, p2, p3, p4, p5, p6)                             \
-  {                                                                           \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_API)                         \
-      BT_TRACE_6(TRACE_LAYER_NFA, TRACE_TYPE_API, m, p1, p2, p3, p4, p5, p6); \
-  }
-
-#define NFA_TRACE_EVENT0(m)                             \
-  {                                                     \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_EVENT) \
-      BT_TRACE_0(TRACE_LAYER_NFA, TRACE_TYPE_EVENT, m); \
-  }
-#define NFA_TRACE_EVENT1(m, p1)                             \
-  {                                                         \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_EVENT)     \
-      BT_TRACE_1(TRACE_LAYER_NFA, TRACE_TYPE_EVENT, m, p1); \
-  }
-#define NFA_TRACE_EVENT2(m, p1, p2)                             \
-  {                                                             \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_EVENT)         \
-      BT_TRACE_2(TRACE_LAYER_NFA, TRACE_TYPE_EVENT, m, p1, p2); \
-  }
-#define NFA_TRACE_EVENT3(m, p1, p2, p3)                             \
-  {                                                                 \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_EVENT)             \
-      BT_TRACE_3(TRACE_LAYER_NFA, TRACE_TYPE_EVENT, m, p1, p2, p3); \
-  }
-#define NFA_TRACE_EVENT4(m, p1, p2, p3, p4)                             \
-  {                                                                     \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                 \
-      BT_TRACE_4(TRACE_LAYER_NFA, TRACE_TYPE_EVENT, m, p1, p2, p3, p4); \
-  }
-#define NFA_TRACE_EVENT5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                         \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                     \
-      BT_TRACE_5(TRACE_LAYER_NFA, TRACE_TYPE_EVENT, m, p1, p2, p3, p4, p5); \
-  }
-#define NFA_TRACE_EVENT6(m, p1, p2, p3, p4, p5, p6)                        \
-  {                                                                        \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                    \
-      BT_TRACE_6(TRACE_LAYER_NFA, TRACE_TYPE_EVENT, m, p1, p2, p3, p4, p5, \
-                 p6);                                                      \
-  }
-
-#define NFA_TRACE_DEBUG0(m)                             \
-  {                                                     \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_DEBUG) \
-      BT_TRACE_0(TRACE_LAYER_NFA, TRACE_TYPE_DEBUG, m); \
-  }
-#define NFA_TRACE_DEBUG1(m, p1)                             \
-  {                                                         \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)     \
-      BT_TRACE_1(TRACE_LAYER_NFA, TRACE_TYPE_DEBUG, m, p1); \
-  }
-#define NFA_TRACE_DEBUG2(m, p1, p2)                             \
-  {                                                             \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)         \
-      BT_TRACE_2(TRACE_LAYER_NFA, TRACE_TYPE_DEBUG, m, p1, p2); \
-  }
-#define NFA_TRACE_DEBUG3(m, p1, p2, p3)                             \
-  {                                                                 \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)             \
-      BT_TRACE_3(TRACE_LAYER_NFA, TRACE_TYPE_DEBUG, m, p1, p2, p3); \
-  }
-#define NFA_TRACE_DEBUG4(m, p1, p2, p3, p4)                             \
-  {                                                                     \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                 \
-      BT_TRACE_4(TRACE_LAYER_NFA, TRACE_TYPE_DEBUG, m, p1, p2, p3, p4); \
-  }
-#define NFA_TRACE_DEBUG5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                         \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                     \
-      BT_TRACE_5(TRACE_LAYER_NFA, TRACE_TYPE_DEBUG, m, p1, p2, p3, p4, p5); \
-  }
-#define NFA_TRACE_DEBUG6(m, p1, p2, p3, p4, p5, p6)                        \
-  {                                                                        \
-    if (nfa_sys_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                    \
-      BT_TRACE_6(TRACE_LAYER_NFA, TRACE_TYPE_DEBUG, m, p1, p2, p3, p4, p5, \
-                 p6);                                                      \
-  }
-
-/* Define tracing for the NFA P2P unit
-*/
-#define P2P_TRACE_ERROR0(m)                             \
-  {                                                     \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_ERROR) \
-      BT_TRACE_0(TRACE_LAYER_P2P, TRACE_TYPE_ERROR, m); \
-  }
-#define P2P_TRACE_ERROR1(m, p1)                             \
-  {                                                         \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_ERROR)     \
-      BT_TRACE_1(TRACE_LAYER_P2P, TRACE_TYPE_ERROR, m, p1); \
-  }
-#define P2P_TRACE_ERROR2(m, p1, p2)                             \
-  {                                                             \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_ERROR)         \
-      BT_TRACE_2(TRACE_LAYER_P2P, TRACE_TYPE_ERROR, m, p1, p2); \
-  }
-#define P2P_TRACE_ERROR3(m, p1, p2, p3)                             \
-  {                                                                 \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_ERROR)             \
-      BT_TRACE_3(TRACE_LAYER_P2P, TRACE_TYPE_ERROR, m, p1, p2, p3); \
-  }
-#define P2P_TRACE_ERROR4(m, p1, p2, p3, p4)                             \
-  {                                                                     \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                 \
-      BT_TRACE_4(TRACE_LAYER_P2P, TRACE_TYPE_ERROR, m, p1, p2, p3, p4); \
-  }
-#define P2P_TRACE_ERROR5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                         \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                     \
-      BT_TRACE_5(TRACE_LAYER_P2P, TRACE_TYPE_ERROR, m, p1, p2, p3, p4, p5); \
-  }
-#define P2P_TRACE_ERROR6(m, p1, p2, p3, p4, p5, p6)                        \
-  {                                                                        \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_ERROR)                    \
-      BT_TRACE_6(TRACE_LAYER_P2P, TRACE_TYPE_ERROR, m, p1, p2, p3, p4, p5, \
-                 p6);                                                      \
-  }
-
-#define P2P_TRACE_WARNING0(m)                             \
-  {                                                       \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_WARNING) \
-      BT_TRACE_0(TRACE_LAYER_P2P, TRACE_TYPE_WARNING, m); \
-  }
-#define P2P_TRACE_WARNING1(m, p1)                             \
-  {                                                           \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_WARNING)     \
-      BT_TRACE_1(TRACE_LAYER_P2P, TRACE_TYPE_WARNING, m, p1); \
-  }
-#define P2P_TRACE_WARNING2(m, p1, p2)                             \
-  {                                                               \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_WARNING)         \
-      BT_TRACE_2(TRACE_LAYER_P2P, TRACE_TYPE_WARNING, m, p1, p2); \
-  }
-#define P2P_TRACE_WARNING3(m, p1, p2, p3)                             \
-  {                                                                   \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_WARNING)             \
-      BT_TRACE_3(TRACE_LAYER_P2P, TRACE_TYPE_WARNING, m, p1, p2, p3); \
-  }
-#define P2P_TRACE_WARNING4(m, p1, p2, p3, p4)                             \
-  {                                                                       \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                 \
-      BT_TRACE_4(TRACE_LAYER_P2P, TRACE_TYPE_WARNING, m, p1, p2, p3, p4); \
-  }
-#define P2P_TRACE_WARNING5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                           \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                     \
-      BT_TRACE_5(TRACE_LAYER_P2P, TRACE_TYPE_WARNING, m, p1, p2, p3, p4, p5); \
-  }
-#define P2P_TRACE_WARNING6(m, p1, p2, p3, p4, p5, p6)                        \
-  {                                                                          \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_WARNING)                    \
-      BT_TRACE_6(TRACE_LAYER_P2P, TRACE_TYPE_WARNING, m, p1, p2, p3, p4, p5, \
-                 p6);                                                        \
-  }
-
-#define P2P_TRACE_API0(m)                             \
-  {                                                   \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_API) \
-      BT_TRACE_0(TRACE_LAYER_P2P, TRACE_TYPE_API, m); \
-  }
-#define P2P_TRACE_API1(m, p1)                             \
-  {                                                       \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_API)     \
-      BT_TRACE_1(TRACE_LAYER_P2P, TRACE_TYPE_API, m, p1); \
-  }
-#define P2P_TRACE_API2(m, p1, p2)                             \
-  {                                                           \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_API)         \
-      BT_TRACE_2(TRACE_LAYER_P2P, TRACE_TYPE_API, m, p1, p2); \
-  }
-#define P2P_TRACE_API3(m, p1, p2, p3)                             \
-  {                                                               \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_API)             \
-      BT_TRACE_3(TRACE_LAYER_P2P, TRACE_TYPE_API, m, p1, p2, p3); \
-  }
-#define P2P_TRACE_API4(m, p1, p2, p3, p4)                             \
-  {                                                                   \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_API)                 \
-      BT_TRACE_4(TRACE_LAYER_P2P, TRACE_TYPE_API, m, p1, p2, p3, p4); \
-  }
-#define P2P_TRACE_API5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                       \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_API)                     \
-      BT_TRACE_5(TRACE_LAYER_P2P, TRACE_TYPE_API, m, p1, p2, p3, p4, p5); \
-  }
-#define P2P_TRACE_API6(m, p1, p2, p3, p4, p5, p6)                             \
-  {                                                                           \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_API)                         \
-      BT_TRACE_6(TRACE_LAYER_P2P, TRACE_TYPE_API, m, p1, p2, p3, p4, p5, p6); \
-  }
-
-#define P2P_TRACE_EVENT0(m)                             \
-  {                                                     \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_EVENT) \
-      BT_TRACE_0(TRACE_LAYER_P2P, TRACE_TYPE_EVENT, m); \
-  }
-#define P2P_TRACE_EVENT1(m, p1)                             \
-  {                                                         \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_EVENT)     \
-      BT_TRACE_1(TRACE_LAYER_P2P, TRACE_TYPE_EVENT, m, p1); \
-  }
-#define P2P_TRACE_EVENT2(m, p1, p2)                             \
-  {                                                             \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_EVENT)         \
-      BT_TRACE_2(TRACE_LAYER_P2P, TRACE_TYPE_EVENT, m, p1, p2); \
-  }
-#define P2P_TRACE_EVENT3(m, p1, p2, p3)                             \
-  {                                                                 \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_EVENT)             \
-      BT_TRACE_3(TRACE_LAYER_P2P, TRACE_TYPE_EVENT, m, p1, p2, p3); \
-  }
-#define P2P_TRACE_EVENT4(m, p1, p2, p3, p4)                             \
-  {                                                                     \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                 \
-      BT_TRACE_4(TRACE_LAYER_P2P, TRACE_TYPE_EVENT, m, p1, p2, p3, p4); \
-  }
-#define P2P_TRACE_EVENT5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                         \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                     \
-      BT_TRACE_5(TRACE_LAYER_P2P, TRACE_TYPE_EVENT, m, p1, p2, p3, p4, p5); \
-  }
-#define P2P_TRACE_EVENT6(m, p1, p2, p3, p4, p5, p6)                        \
-  {                                                                        \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_EVENT)                    \
-      BT_TRACE_6(TRACE_LAYER_P2P, TRACE_TYPE_EVENT, m, p1, p2, p3, p4, p5, \
-                 p6);                                                      \
-  }
-
-#define P2P_TRACE_DEBUG0(m)                             \
-  {                                                     \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_DEBUG) \
-      BT_TRACE_0(TRACE_LAYER_P2P, TRACE_TYPE_DEBUG, m); \
-  }
-#define P2P_TRACE_DEBUG1(m, p1)                             \
-  {                                                         \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)     \
-      BT_TRACE_1(TRACE_LAYER_P2P, TRACE_TYPE_DEBUG, m, p1); \
-  }
-#define P2P_TRACE_DEBUG2(m, p1, p2)                             \
-  {                                                             \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)         \
-      BT_TRACE_2(TRACE_LAYER_P2P, TRACE_TYPE_DEBUG, m, p1, p2); \
-  }
-#define P2P_TRACE_DEBUG3(m, p1, p2, p3)                             \
-  {                                                                 \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)             \
-      BT_TRACE_3(TRACE_LAYER_P2P, TRACE_TYPE_DEBUG, m, p1, p2, p3); \
-  }
-#define P2P_TRACE_DEBUG4(m, p1, p2, p3, p4)                             \
-  {                                                                     \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                 \
-      BT_TRACE_4(TRACE_LAYER_P2P, TRACE_TYPE_DEBUG, m, p1, p2, p3, p4); \
-  }
-#define P2P_TRACE_DEBUG5(m, p1, p2, p3, p4, p5)                             \
-  {                                                                         \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                     \
-      BT_TRACE_5(TRACE_LAYER_P2P, TRACE_TYPE_DEBUG, m, p1, p2, p3, p4, p5); \
-  }
-#define P2P_TRACE_DEBUG6(m, p1, p2, p3, p4, p5, p6)                        \
-  {                                                                        \
-    if (nfa_p2p_cb.trace_level >= BT_TRACE_LEVEL_DEBUG)                    \
-      BT_TRACE_6(TRACE_LAYER_P2P, TRACE_TYPE_DEBUG, m, p1, p2, p3, p4, p5, \
-                 p6);                                                      \
-  }
-
-/* define traces for application */
-#define APPL_TRACE_ERROR0(m)                                            \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_ERROR)                       \
-      LogMsg_0(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_ERROR,                                    \
-               (m));                                                    \
-  }
-#define APPL_TRACE_ERROR1(m, p1)                                        \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_ERROR)                       \
-      LogMsg_1(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_ERROR,                                    \
-               (m), (uintptr_t)(p1));                                   \
-  }
-#define APPL_TRACE_ERROR2(m, p1, p2)                                    \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_ERROR)                       \
-      LogMsg_2(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_ERROR,                                    \
-               (m), (uintptr_t)(p1), (uintptr_t)(p2));                  \
-  }
-#define APPL_TRACE_ERROR3(m, p1, p2, p3)                                \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_ERROR)                       \
-      LogMsg_3(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_ERROR,                                    \
-               (m), (uintptr_t)(p1), (uintptr_t)(p2), (uintptr_t)(p3)); \
-  }
-#define APPL_TRACE_ERROR4(m, p1, p2, p3, p4)                            \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_ERROR)                       \
-      LogMsg_4(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_ERROR,                                    \
-               (m), (uintptr_t)(p1), (uintptr_t)(p2), (uintptr_t)(p3),  \
-               (uintptr_t)(p4));                                        \
-  }
-#define APPL_TRACE_ERROR5(m, p1, p2, p3, p4, p5)                        \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_ERROR)                       \
-      LogMsg_5(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_ERROR,                                    \
-               (m), (uintptr_t)(p1), (uintptr_t)(p2), (uintptr_t)(p3),  \
-               (uintptr_t)(p4), (uintptr_t)(p5));                       \
-  }
-#define APPL_TRACE_ERROR6(m, p1, p2, p3, p4, p5, p6)                    \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_ERROR)                       \
-      LogMsg_6(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_ERROR,                                    \
-               (m), (uintptr_t)(p1), (uintptr_t)(p2), (uintptr_t)(p3),  \
-               (uintptr_t)(p4), (uintptr_t)(p5), (uintptr_t)(p6));      \
-  }
-
-#define APPL_TRACE_WARNING0(m)                                          \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_WARNING)                     \
-      LogMsg_0(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_WARNING,                                  \
-               (m));                                                    \
-  }
-#define APPL_TRACE_WARNING1(m, p1)                                      \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_WARNING)                     \
-      LogMsg_1(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_WARNING,                                  \
-               (m), (uintptr_t)(p1));                                   \
-  }
-#define APPL_TRACE_WARNING2(m, p1, p2)                                  \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_WARNING)                     \
-      LogMsg_2(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_WARNING,                                  \
-               (m), (uintptr_t)(p1), (uintptr_t)(p2));                  \
-  }
-
-#define APPL_TRACE_WARNING3(m, p1, p2, p3)                              \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_WARNING)                     \
-      LogMsg_3(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_WARNING,                                  \
-               (m), (uintptr_t)(p1), (uintptr_t)(p2), (uintptr_t)(p3)); \
-  }
-#define APPL_TRACE_WARNING4(m, p1, p2, p3, p4)                          \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_WARNING)                     \
-      LogMsg_4(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_WARNING,                                  \
-               (m), (uintptr_t)(p1), (uintptr_t)(p2), (uintptr_t)(p3),  \
-               (uintptr_t)(p4));                                        \
-  }
-#define APPL_TRACE_WARNING5(m, p1, p2, p3, p4, p5)                      \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_WARNING)                     \
-      LogMsg_5(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_WARNING,                                  \
-               (m), (uintptr_t)(p1), (uintptr_t)(p2), (uintptr_t)(p3),  \
-               (uintptr_t)(p4), (uintptr_t)(p5));                       \
-  }
-#define APPL_TRACE_WARNING6(m, p1, p2, p3, p4, p5, p6)                  \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_WARNING)                     \
-      LogMsg_6(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_WARNING,                                  \
-               (m), (uintptr_t)(p1), (uintptr_t)(p2), (uintptr_t)(p3),  \
-               (uintptr_t)(p4), (uintptr_t)(p5), (uintptr_t)(p6));      \
-  }
-
-#define APPL_TRACE_API0(m)                                              \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_API)                         \
-      LogMsg_0(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_API,                                      \
-               (m));                                                    \
-  }
-#define APPL_TRACE_API1(m, p1)                                          \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_API)                         \
-      LogMsg_1(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_API,                                      \
-               (m), (uintptr_t)(p1));                                   \
-  }
-#define APPL_TRACE_API2(m, p1, p2)                                      \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_API)                         \
-      LogMsg_2(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_API,                                      \
-               (m), (uintptr_t)(p1), (uintptr_t)(p2));                  \
-  }
-#define APPL_TRACE_API3(m, p1, p2, p3)                                  \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_API)                         \
-      LogMsg_3(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_API,                                      \
-               (m), (uintptr_t)(p1), (uintptr_t)(p2), (uintptr_t)(p3)); \
-  }
-#define APPL_TRACE_API4(m, p1, p2, p3, p4)                              \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_API)                         \
-      LogMsg_4(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_API,                                      \
-               (m), (uintptr_t)(p1), (uintptr_t)(p2), (uintptr_t)(p3),  \
-               (uintptr_t)(p4));                                        \
-  }
-#define APPL_TRACE_API5(m, p1, p2, p3, p4, p5)                          \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_API)                         \
-      LogMsg_5(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_API,                                      \
-               (m), (uintptr_t)(p1), (uintptr_t)(p2), (uintptr_t)(p3),  \
-               (uintptr_t)(p4), (uintptr_t)(p5));                       \
-  }
-#define APPL_TRACE_API6(m, p1, p2, p3, p4, p5, p6)                      \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_API)                         \
-      LogMsg_6(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_API,                                      \
-               (m), (uintptr_t)(p1), (uintptr_t)(p2), (uintptr_t)(p3),  \
-               (uintptr_t)(p4), (uintptr_t)(p5), (uintptr_t)(p6));      \
-  }
-
-#define APPL_TRACE_EVENT0(m)                                            \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_EVENT)                       \
-      LogMsg_0(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_EVENT,                                    \
-               (m));                                                    \
-  }
-#define APPL_TRACE_EVENT1(m, p1)                                        \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_EVENT)                       \
-      LogMsg_1(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_EVENT,                                    \
-               (m), (uintptr_t)(p1));                                   \
-  }
-#define APPL_TRACE_EVENT2(m, p1, p2)                                    \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_EVENT)                       \
-      LogMsg_2(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_EVENT,                                    \
-               (m), (uintptr_t)(p1), (uintptr_t)(p2));                  \
-  }
-#define APPL_TRACE_EVENT3(m, p1, p2, p3)                                \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_EVENT)                       \
-      LogMsg_3(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_EVENT,                                    \
-               (m), (uintptr_t)(p1), (uintptr_t)(p2), (uintptr_t)(p3)); \
-  }
-#define APPL_TRACE_EVENT4(m, p1, p2, p3, p4)                            \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_EVENT)                       \
-      LogMsg_4(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_EVENT,                                    \
-               (m), (uintptr_t)(p1), (uintptr_t)(p2), (uintptr_t)(p3),  \
-               (uintptr_t)(p4));                                        \
-  }
-#define APPL_TRACE_EVENT5(m, p1, p2, p3, p4, p5)                        \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_EVENT)                       \
-      LogMsg_5(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_EVENT,                                    \
-               (m), (uintptr_t)(p1), (uintptr_t)(p2), (uintptr_t)(p3),  \
-               (uintptr_t)(p4), (uintptr_t)(p5));                       \
-  }
-#define APPL_TRACE_EVENT6(m, p1, p2, p3, p4, p5, p6)                    \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_EVENT)                       \
-      LogMsg_6(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_EVENT,                                    \
-               (m), (uintptr_t)(p1), (uintptr_t)(p2), (uintptr_t)(p3),  \
-               (uintptr_t)(p4), (uintptr_t)(p5), (uintptr_t)(p6));      \
-  }
-
-#define APPL_TRACE_DEBUG0(m)                                            \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_DEBUG)                       \
-      LogMsg_0(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_DEBUG,                                    \
-               (m));                                                    \
-  }
-#define APPL_TRACE_DEBUG1(m, p1)                                        \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_DEBUG)                       \
-      LogMsg_1(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_DEBUG,                                    \
-               (m), (uintptr_t)(p1));                                   \
-  }
-#define APPL_TRACE_DEBUG2(m, p1, p2)                                    \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_DEBUG)                       \
-      LogMsg_2(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_DEBUG,                                    \
-               (m), (uintptr_t)(p1), (uintptr_t)(p2));                  \
-  }
-#define APPL_TRACE_DEBUG3(m, p1, p2, p3)                                \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_DEBUG)                       \
-      LogMsg_3(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_DEBUG,                                    \
-               (m), (uintptr_t)(p1), (uintptr_t)(p2), (uintptr_t)(p3)); \
-  }
-#define APPL_TRACE_DEBUG4(m, p1, p2, p3, p4)                            \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_DEBUG)                       \
-      LogMsg_4(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_DEBUG,                                    \
-               (m), (uintptr_t)(p1), (uintptr_t)(p2), (uintptr_t)(p3),  \
-               (uintptr_t)(p4));                                        \
-  }
-#define APPL_TRACE_DEBUG5(m, p1, p2, p3, p4, p5)                        \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_DEBUG)                       \
-      LogMsg_5(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_DEBUG,                                    \
-               (m), (uintptr_t)(p1), (uintptr_t)(p2), (uintptr_t)(p3),  \
-               (uintptr_t)(p4), (uintptr_t)(p5));                       \
-  }
-#define APPL_TRACE_DEBUG6(m, p1, p2, p3, p4, p5, p6)                    \
-  {                                                                     \
-    if (appl_trace_level >= BT_TRACE_LEVEL_DEBUG)                       \
-      LogMsg_6(TRACE_CTRL_GENERAL | TRACE_LAYER_NONE | TRACE_ORG_APPL | \
-                   TRACE_TYPE_DEBUG,                                    \
-               (m), (uintptr_t)(p1), (uintptr_t)(p2), (uintptr_t)(p3),  \
-               (uintptr_t)(p4), (uintptr_t)(p5), (uintptr_t)(p6));      \
-  }
-
-#endif /* BT_TRACE_H */
diff --git a/src/include/bt_types.h b/src/include/bt_types.h
old mode 100644
new mode 100755
index 87ab96e..a3edaec
--- a/src/include/bt_types.h
+++ b/src/include/bt_types.h
@@ -22,36 +22,13 @@
 #include "data_types.h"
 #include "nfc_types.h"
 
-#define SCR_PROTO_TRACE_NCI 0x00004000
-#define SCR_PROTO_TRACE_ALL 0x001fffff
-#define SCR_PROTO_TRACE_HCI_SUMMARY 0x00000001
-
-#define TRACE_LAYER_NONE 0x00000000
-#define TRACE_LAYER_HCI 0x00070000
-#define TRACE_LAYER_GKI 0x001a0000
-#define TRACE_LAYER_NFC 0x00270000
-/*it's overwritten in nfc_types.h*/
-#define TRACE_LAYER_NCI 0x00280000
-#define TRACE_LAYER_LLCP 0x00290000
-#define TRACE_LAYER_NDEF 0x002a0000
-#define TRACE_LAYER_RW 0x002b0000
-#define TRACE_LAYER_CE 0x002c0000
-#define TRACE_LAYER_P2P 0x002d0000
-#define TRACE_LAYER_NFA 0x00300000
-/*it's overwritten in nfc_types.h*/
-#define TRACE_LAYER_HAL 0x00310000
-#define TRACE_LAYER_MAX_NUM 0x0032
-
 /* NCI Command, Notification or Data*/
 #define BT_EVT_TO_NFC_NCI 0x4000
-#define BT_EVT_TO_NFC_NCI_VS 0x4200 /* Vendor specific message */
 /* messages between NFC and NCI task */
 #define BT_EVT_TO_NFC_MSGS 0x4300
 
 /* start timer */
 #define BT_EVT_TO_START_TIMER 0x3c00
-/* stop timer */
-#define BT_EVT_TO_STOP_TIMER 0x3d00
 
 #define TRACE_TYPE_MAX_NUM 20
 #define TRACE_TYPE_ALL 0xffff
@@ -59,12 +36,4 @@
 /* start quick timer */
 #define BT_EVT_TO_START_QUICK_TIMER 0x3e00
 
-#define TRACE_ORG_APPL 0x00000500
-
-#define DEV_CLASS_LEN 3
-typedef uint8_t DEV_CLASS[DEV_CLASS_LEN]; /* Device class */
-
-#define BD_ADDR_LEN 6                 /* Device address length */
-typedef uint8_t BD_ADDR[BD_ADDR_LEN]; /* Device address */
-
 #endif
diff --git a/src/include/buildcfg.h b/src/include/buildcfg.h
old mode 100644
new mode 100755
index d1a8cc2..90af69a
--- a/src/include/buildcfg.h
+++ b/src/include/buildcfg.h
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -45,28 +45,19 @@
 #define NFC_CONTORLLER_ID (1)
 #endif
 
-#define BTE_APPL_MAX_USERIAL_DEV_NAME (256)
-
-#ifdef BT_TRACE_VERBOSE
-#undef BT_TRACE_VERBOSE
-#endif
-#define BT_TRACE_VERBOSE true
-
-#define TRACE_TASK_INCLUDED true
-
 #define GKI_BUF1_MAX 0
 // 2 is in use
-#if (NXP_EXTNS == TRUE)
-#define GKI_BUF2_MAX 70
-#define GKI_BUF3_MAX 70
-#define GKI_NUM_FIXED_BUF_POOLS 9
-#else
 #define GKI_BUF2_MAX 50
 #define GKI_BUF3_MAX 30
-#define GKI_NUM_FIXED_BUF_POOLS 4
-#endif
+
+#if (NXP_EXTNS == TRUE)
+#define GKI_BUF4_SIZE 268
+#define GKI_BUF4_MAX 130
+#else
 #define GKI_BUF4_SIZE 2400
 #define GKI_BUF4_MAX 30
+#endif
+
 #define GKI_BUF5_MAX 0
 #define GKI_BUF6_MAX 0
 #define GKI_BUF7_MAX 0
@@ -76,37 +67,11 @@
 #define GKI_BUF0_SIZE 268
 #define GKI_BUF0_MAX 40
 
-#define NCI_BUF_POOL_ID GKI_POOL_ID_0
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-extern uint8_t* scru_dump_hex(uint8_t* p, char* p_title, uint32_t len,
-                              uint32_t trace_layer, uint32_t trace_type);
-extern void ScrLog(uint32_t trace_set_mask, const char* fmt_str, ...);
-extern void DispNci(uint8_t* p, uint16_t len, bool is_recv);
-
-extern void downloadFirmwarePatchFile(uint32_t brcm_hw_id);
-
-void ProtoDispAdapterDisplayNciPacket(uint8_t* nciPacket, uint16_t nciPacketLen,
-                                      bool is_recv);
-#define DISP_NCI ProtoDispAdapterDisplayNciPacket
-#define LOGMSG_TAG_NAME "BrcmNfcNfa"
-
-#ifndef _TIMEB
-#define _TIMEB
-struct _timeb {
-  long time;
-  short millitm;
-  short timezone;
-  short dstflag;
-};
-void _ftime(struct _timeb*);
-
+#if (NXP_EXTNS == TRUE)
+#define GKI_NUM_FIXED_BUF_POOLS 5
+#else
+#define GKI_NUM_FIXED_BUF_POOLS 4
 #endif
 
-#ifdef __cplusplus
-};
-#endif
-#endif
+void initializeGlobalAppDtaMode();
+#endif
\ No newline at end of file
diff --git a/src/include/config.h b/src/include/config.h
deleted file mode 100644
index 3cc98a6..0000000
--- a/src/include/config.h
+++ /dev/null
@@ -1,188 +0,0 @@
-/******************************************************************************
- *
- *  Copyright (C) 1999-2012 Broadcom Corporation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at:
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-/******************************************************************************
- *
- *  The original Work has been changed by NXP Semiconductors.
- *
- *  Copyright (C) 2015 NXP Semiconductors
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-#ifndef __CONFIG_H
-#define __CONFIG_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-int GetStrValue(const char* name, char* p_value, unsigned long len);
-int GetNumValue(const char* name, void* p_value, unsigned long len);
-
-#ifdef __cplusplus
-};
-#endif
-
-#define NAME_POLLING_TECH_MASK "POLLING_TECH_MASK"
-#define NAME_REGISTER_VIRTUAL_SE "REGISTER_VIRTUAL_SE"
-#define NAME_APPL_TRACE_LEVEL "APPL_TRACE_LEVEL"
-#define NAME_USE_RAW_NCI_TRACE "USE_RAW_NCI_TRACE"
-#define NAME_LOGCAT_FILTER "LOGCAT_FILTER"
-#define NAME_LPTD_CFG "LPTD_CFG"
-#define NAME_SCREEN_OFF_POWER_STATE "SCREEN_OFF_POWER_STATE"
-#define NAME_PREINIT_DSP_CFG "PREINIT_DSP_CFG"
-#define NAME_DTA_START_CFG "DTA_START_CFG"
-#define NAME_NXP_NFC_CHIP "NXP_NFC_CHIP"
-#if (NXP_EXTNS != TRUE)
-#define NAME_TRANSPORT_DRIVER "TRANSPORT_DRIVER"
-#define NAME_POWER_CONTROL_DRIVER "POWER_CONTROL_DRIVER"
-#endif
-#define NAME_PROTOCOL_TRACE_LEVEL "PROTOCOL_TRACE_LEVEL"
-#define NAME_UART_PORT "UART_PORT"
-#define NAME_UART_BAUD "UART_BAUD"
-#define NAME_UART_PARITY "UART_PARITY"
-#define NAME_UART_STOPBITS "UART_STOPBITS"
-#define NAME_UART_DATABITS "UART_DATABITS"
-#define NAME_CLIENT_ADDRESS "BCMI2CNFC_ADDRESS"
-#define NAME_NFA_DM_START_UP_CFG "NFA_DM_START_UP_CFG"
-#define NAME_NFA_DM_CFG "NFA_DM_CFG"
-#define NAME_NFA_DM_LP_CFG "NFA_DM_LP_CFG"
-#define NAME_LOW_SPEED_TRANSPORT "LOW_SPEED_TRANSPORT"
-#define NAME_NFC_WAKE_DELAY "NFC_WAKE_DELAY"
-#define NAME_NFC_WRITE_DELAY "NFC_WRITE_DELAY"
-#define NAME_PERF_MEASURE_FREQ "REPORT_PERFORMANCE_MEASURE"
-#define NAME_READ_MULTI_PACKETS "READ_MULTIPLE_PACKETS"
-#define NAME_POWER_ON_DELAY "POWER_ON_DELAY"
-#define NAME_PRE_POWER_OFF_DELAY "PRE_POWER_OFF_DELAY"
-#define NAME_POST_POWER_OFF_DELAY "POST_POWER_OFF_DELAY"
-#define NAME_CE3_PRE_POWER_OFF_DELAY "CE3_PRE_POWER_OFF_DELAY"
-#define NAME_NFA_STORAGE "NFA_STORAGE"
-#define NAME_NFA_DM_START_UP_VSC_CFG "NFA_DM_START_UP_VSC_CFG"
-#define NAME_NFA_DTA_START_UP_VSC_CFG "NFA_DTA_START_UP_VSC_CFG"
-#define NAME_UICC_LISTEN_TECH_MASK "UICC_LISTEN_TECH_MASK"
-#define NAME_P2P_LISTEN_TECH_MASK "P2P_LISTEN_TECH_MASK"
-#define NAME_UICC_LISTEN_TECH_EX_MASK "UICC_LISTEN_TECH_EXCLUDE_MASK"
-#if (NXP_EXTNS == TRUE)
-#define NAME_APPL_DTA_MODE "APPL_DTA_MODE"
-#define NAME_DEFAULT_AID_ROUTE "DEFAULT_AID_ROUTE"
-#define NAME_DEFAULT_DESFIRE_ROUTE "DEFAULT_DESFIRE_ROUTE"
-#define NAME_DEFAULT_MIFARE_CLT_ROUTE "DEFAULT_MIFARE_CLT_ROUTE"
-#define NAME_DEFAULT_AID_PWR_STATE "DEFAULT_AID_PWR_STATE"
-#define NAME_DEFAULT_DESFIRE_PWR_STATE "DEFAULT_DESFIRE_PWR_STATE"
-#define NAME_DEFAULT_MIFARE_CLT_PWR_STATE "DEFAULT_MIFARE_CLT_PWR_STATE"
-#define NAME_CHECK_DEFAULT_PROTO_SE_ID "NXP_CHECK_DEFAULT_PROTO_SE_ID"
-#define NAME_NFA_DM_DISC_NTF_TIMEOUT "NFA_DM_DISC_NTF_TIMEOUT"
-#define NAME_NXP_FWD_FUNCTIONALITY_ENABLE "NXP_FWD_FUNCTIONALITY_ENABLE"
-#define NAME_HOST_LISTEN_TECH_MASK "HOST_LISTEN_TECH_MASK"
-#define NAME_DEFAULT_FELICA_CLT_ROUTE "DEFAULT_FELICA_CLT_ROUTE"
-#define NAME_DEFAULT_FELICA_CLT_PWR_STATE "DEFAULT_FELICA_CLT_PWR_STATE"
-#define NAME_NXP_ESE_LISTEN_TECH_MASK "NXP_ESE_LISTEN_TECH_MASK"
-#endif
-#define NAME_DEFAULT_OFFHOST_ROUTE "DEFAULT_OFFHOST_ROUTE"
-#define NAME_SNOOZE_MODE_CFG "SNOOZE_MODE_CFG"
-#define NAME_NFA_DM_DISC_DURATION_POLL "NFA_DM_DISC_DURATION_POLL"
-#define NAME_SPD_DEBUG "SPD_DEBUG"
-#define NAME_SPD_MAXRETRYCOUNT "SPD_MAX_RETRY_COUNT"
-#define NAME_SPI_NEGOTIATION "SPI_NEGOTIATION"
-#define NAME_AID_FOR_EMPTY_SELECT "AID_FOR_EMPTY_SELECT"
-#define NAME_PRESERVE_STORAGE "PRESERVE_STORAGE"
-#define NAME_NFA_MAX_EE_SUPPORTED "NFA_MAX_EE_SUPPORTED"
-#define NAME_NFCC_ENABLE_TIMEOUT "NFCC_ENABLE_TIMEOUT"
-#define NAME_NFA_DM_PRE_DISCOVERY_CFG "NFA_DM_PRE_DISCOVERY_CFG"
-#define NAME_POLL_FREQUENCY "POLL_FREQUENCY"
-#define NAME_XTAL_HARDWARE_ID "XTAL_HARDWARE_ID"
-#define NAME_XTAL_FREQUENCY "XTAL_FREQUENCY"
-#define NAME_XTAL_FREQ_INDEX "XTAL_FREQ_INDEX"
-#define NAME_XTAL_PARAMS_CFG "XTAL_PARAMS_CFG"
-#define NAME_EXCLUSIVE_SE_ACCESS "EXCLUSIVE_SE_ACCESS"
-#define NAME_DBG_NO_UICC_IDLE_TIMEOUT_TOGGLING \
-  "DBG_NO_UICC_IDLE_TIMEOUT_TOGGLING"
-#define NAME_PRESENCE_CHECK_ALGORITHM "PRESENCE_CHECK_ALGORITHM"
-#define NAME_ALLOW_NO_NVM "ALLOW_NO_NVM"
-#define NAME_DEVICE_HOST_WHITE_LIST "DEVICE_HOST_WHITE_LIST"
-#define NAME_POWER_OFF_MODE "POWER_OFF_MODE"
-#define NAME_GLOBAL_RESET "DO_GLOBAL_RESET"
-#define NAME_NCI_HAL_MODULE "NCI_HAL_MODULE"
-#define NAME_NFA_POLL_BAIL_OUT_MODE "NFA_POLL_BAIL_OUT_MODE"
-#define NAME_NFA_PROPRIETARY_CFG "NFA_PROPRIETARY_CFG"
-#if (NXP_EXTNS == TRUE)
-#define NAME_NXP_ESE_LISTEN_TECH_MASK   "NXP_ESE_LISTEN_TECH_MASK"
-#define NAME_NXP_WM_MAX_WTX_COUNT       "NXP_WM_MAX_WTX_COUNT"
-#define NAME_NXP_NFCC_STANDBY_TIMEOUT "NXP_NFCC_STANDBY_TIMEOUT"
-#define NAME_NXP_CP_TIMEOUT "NXP_CP_TIMEOUT"
-#define NAME_NXP_CORE_SCRN_OFF_AUTONOMOUS_ENABLE \
-  "NXP_CORE_SCRN_OFF_AUTONOMOUS_ENABLE"
-#define NAME_NXP_ALLOW_WIRED_IN_MIFARE_DESFIRE_CLT \
-  "NXP_ALLOW_WIRED_IN_MIFARE_DESFIRE_CLT"
-#define NAME_NXP_NFCC_RF_FIELD_EVENT_TIMEOUT "NXP_NFCC_RF_FIELD_EVENT_TIMEOUT"
-#define NAME_NFA_BLOCK_ROUTE "NFA_BLOCK_ROUTE"
-#define NAME_NXP_MIFARE_DESFIRE_DISABLE "NXP_MIFARE_DESFIRE_DISABLE"
-#define NAME_NXP_DUAL_UICC_ENABLE "NXP_DUAL_UICC_ENABLE"
-#define NAME_NXP_DEFAULT_NFCEE_TIMEOUT "NXP_DEFAULT_NFCEE_TIMEOUT"
-#define NAME_NXP_DEFAULT_NFCEE_DISC_TIMEOUT "NXP_DEFAULT_NFCEE_DISC_TIMEOUT"
-#define NAME_NXP_NFCC_PASSIVE_LISTEN_TIMEOUT "NXP_NFCC_PASSIVE_LISTEN_TIMEOUT"
-#define NAME_OS_DOWNLOAD_TIMEOUT_VALUE "OS_DOWNLOAD_TIMEOUT_VALUE"
-#define NAME_NXP_HCEF_CMD_RSP_TIMEOUT_VALUE "NXP_HCEF_CMD_RSP_TIMEOUT_VALUE"
-#endif
-
-#define LPTD_PARAM_LEN (40)
-
-// default configuration
-#define default_transport "/dev/bcm2079x"
-
-/**
- *  @brief defines the different major number used.
- */
-#define FW_MAJOR_NUM_NQ2xx      "10"
-#define FW_MAJOR_NUM_NQ3xx      "11"
-#define FW_MAJOR_NUM_NQ4xx      "12"
-
-#define FW_MAJOR_NUM_LENGTH     2
-
-struct tUART_CONFIG {
-  int m_iBaudrate;  // 115200
-  int m_iDatabits;  // 8
-  int m_iParity;    // 0 - none, 1 = odd, 2 = even
-  int m_iStopbits;
-};
-
-extern struct tUART_CONFIG uartConfig;
-#define MAX_CHIPID_LEN (16)
-void readOptionalConfigExt(const char* option);
-
-/* Snooze mode configuration structure */
-typedef struct {
-  unsigned char snooze_mode;         /* Snooze Mode */
-  unsigned char idle_threshold_dh;   /* Idle Threshold Host */
-  unsigned char idle_threshold_nfcc; /* Idle Threshold NFCC   */
-  unsigned char
-      nfc_wake_active_mode; /* NFC_LP_ACTIVE_LOW or NFC_LP_ACTIVE_HIGH */
-  unsigned char
-      dh_wake_active_mode; /* NFC_LP_ACTIVE_LOW or NFC_LP_ACTIVE_HIGH */
-} tSNOOZE_MODE_CONFIG;
-#endif
diff --git a/src/include/debug_nfcsnoop.h b/src/include/debug_nfcsnoop.h
new file mode 100644
index 0000000..2dd7b6b
--- /dev/null
+++ b/src/include/debug_nfcsnoop.h
@@ -0,0 +1,50 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2017 Google Inc.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+#ifndef _DEBUG_NFCSNOOP_
+#define _DEBUG_NFCSNOOP_
+
+#include <stdint.h>
+#include "nfc_target.h"
+#include "nfc_types.h"
+
+#define NFCSNOOZ_CURRENT_VERSION 0x01
+
+// The preamble is stored un-encrypted as the first part
+// of the file.
+typedef struct nfcsnooz_preamble_t {
+  uint8_t version;
+  uint64_t last_timestamp_ms;
+} __attribute__((__packed__)) nfcsnooz_preamble_t;
+
+// One header for each NCI packet
+typedef struct nfcsnooz_header_t {
+  uint16_t length;
+  uint32_t delta_time_ms;
+  uint8_t is_received;
+} __attribute__((__packed__)) nfcsnooz_header_t;
+
+// Initializes nfcsnoop memory logging and registers
+void debug_nfcsnoop_init(void);
+
+// Writes nfcsnoop data base64 encoded to fd
+void debug_nfcsnoop_dump(int fd);
+
+// capture the packet
+void nfcsnoop_capture(const NFC_HDR* packet, bool is_received);
+
+#endif /* _DEBUG_NFCSNOOP_ */
diff --git a/src/hal/include/gki_hal_target.h b/src/include/gki_hal_target.h
similarity index 57%
rename from src/hal/include/gki_hal_target.h
rename to src/include/gki_hal_target.h
index 2863944..0b13d5a 100644
--- a/src/hal/include/gki_hal_target.h
+++ b/src/include/gki_hal_target.h
@@ -126,11 +126,6 @@
 **
 ******************************************************************************/
 
-/* true if GKI uses dynamic buffers. */
-#ifndef GKI_USE_DYNAMIC_BUFFERS
-#define GKI_USE_DYNAMIC_BUFFERS false
-#endif
-
 /* The size of the buffers in pool 0. */
 #ifndef GKI_BUF0_SIZE
 #define GKI_BUF0_SIZE 64
@@ -206,11 +201,6 @@
 #define GKI_SEVERE(code)
 #endif
 
-/* true if GKI includes debug functionality. */
-#ifndef GKI_DEBUG
-#define GKI_DEBUG false
-#endif
-
 /* Maximum number of exceptions logged. */
 #ifndef GKI_MAX_EXCEPTION
 #define GKI_MAX_EXCEPTION 8
@@ -225,88 +215,4 @@
 #define GKI_SEND_MSG_FROM_ISR false
 #endif
 
-#if defined(GKI_DEBUG) && (GKI_DEBUG == true)
-#ifdef LOG_TAG
-#undef LOG_TAG
-#endif
-#define LOG_TAG "GKI_LINUX"
-/* GKI Trace Macros */
-#define GKI_TRACE_0(m)                                          \
-  LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_GKI | TRACE_ORG_GKI | \
-             TRACE_TYPE_GENERIC,                                \
-         m)
-#define GKI_TRACE_1(m, p1)                                      \
-  LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_GKI | TRACE_ORG_GKI | \
-             TRACE_TYPE_GENERIC,                                \
-         m, p1)
-#define GKI_TRACE_2(m, p1, p2)                                  \
-  LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_GKI | TRACE_ORG_GKI | \
-             TRACE_TYPE_GENERIC,                                \
-         m, p1, p2)
-#define GKI_TRACE_3(m, p1, p2, p3)                              \
-  LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_GKI | TRACE_ORG_GKI | \
-             TRACE_TYPE_GENERIC,                                \
-         m, p1, p2, p3)
-#define GKI_TRACE_4(m, p1, p2, p3, p4)                          \
-  LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_GKI | TRACE_ORG_GKI | \
-             TRACE_TYPE_GENERIC,                                \
-         m, p1, p2, p3, p4)
-#define GKI_TRACE_5(m, p1, p2, p3, p4, p5)                      \
-  LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_GKI | TRACE_ORG_GKI | \
-             TRACE_TYPE_GENERIC,                                \
-         m, p1, p2, p3, p4, p5)
-#define GKI_TRACE_6(m, p1, p2, p3, p4, p5, p6)                  \
-  LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_GKI | TRACE_ORG_GKI | \
-             TRACE_TYPE_GENERIC,                                \
-         m, p1, p2, p3, p4, p5, p6)
-#else
-#define GKI_TRACE_0(m)
-#define GKI_TRACE_1(m, p1)
-#define GKI_TRACE_2(m, p1, p2)
-#define GKI_TRACE_3(m, p1, p2, p3)
-#define GKI_TRACE_4(m, p1, p2, p3, p4)
-#define GKI_TRACE_5(m, p1, p2, p3, p4, p5)
-#define GKI_TRACE_6(m, p1, p2, p3, p4, p5, p6)
-
-#endif
-
-#define GKI_TRACE_ERROR_0(m)                                                   \
-  LogMsg(                                                                      \
-      TRACE_CTRL_GENERAL | TRACE_LAYER_GKI | TRACE_ORG_GKI | TRACE_TYPE_ERROR, \
-      m)
-#define GKI_TRACE_ERROR_1(m, p1)                                               \
-  LogMsg(                                                                      \
-      TRACE_CTRL_GENERAL | TRACE_LAYER_GKI | TRACE_ORG_GKI | TRACE_TYPE_ERROR, \
-      m, p1)
-#define GKI_TRACE_ERROR_2(m, p1, p2)                                           \
-  LogMsg(                                                                      \
-      TRACE_CTRL_GENERAL | TRACE_LAYER_GKI | TRACE_ORG_GKI | TRACE_TYPE_ERROR, \
-      m, p1, p2)
-#define GKI_TRACE_ERROR_3(m, p1, p2, p3)                                       \
-  LogMsg(                                                                      \
-      TRACE_CTRL_GENERAL | TRACE_LAYER_GKI | TRACE_ORG_GKI | TRACE_TYPE_ERROR, \
-      m, p1, p2, p3)
-#define GKI_TRACE_ERROR_4(m, p1, p2, p3, p4)                                   \
-  LogMsg(                                                                      \
-      TRACE_CTRL_GENERAL | TRACE_LAYER_GKI | TRACE_ORG_GKI | TRACE_TYPE_ERROR, \
-      m, p1, p2, p3, p4)
-#define GKI_TRACE_ERROR_5(m, p1, p2, p3, p4, p5)                               \
-  LogMsg(                                                                      \
-      TRACE_CTRL_GENERAL | TRACE_LAYER_GKI | TRACE_ORG_GKI | TRACE_TYPE_ERROR, \
-      m, p1, p2, p3, p4, p5)
-#define GKI_TRACE_ERROR_6(m, p1, p2, p3, p4, p5, p6)                           \
-  LogMsg(                                                                      \
-      TRACE_CTRL_GENERAL | TRACE_LAYER_GKI | TRACE_ORG_GKI | TRACE_TYPE_ERROR, \
-      m, p1, p2, p3, p4, p5, p6)
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-extern void LogMsg(uint32_t trace_set_mask, const char* fmt_str, ...);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* GKI_TARGET_H */
+#endif /* GKI_TARGET_H */
\ No newline at end of file
diff --git a/src/include/gki_target.h b/src/include/gki_target.h
old mode 100644
new mode 100755
index 1740ebd..4e969ef
--- a/src/include/gki_target.h
+++ b/src/include/gki_target.h
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -43,14 +43,6 @@
 
 #include "data_types.h"
 
-/* Operating System Selection */
-#ifndef BTE_SIM_APP
-#define _GKI_ARM
-#define _GKI_STANDALONE
-#else
-#define _BT_WIN32
-#endif
-
 /******************************************************************************
 **
 ** Task configuration
@@ -118,7 +110,7 @@
 
 /* The number of GKI tasks in the software system. */
 #ifndef GKI_MAX_TASKS
-#define GKI_MAX_TASKS 14
+#define GKI_MAX_TASKS 15
 #endif
 
 /******************************************************************************
@@ -148,11 +140,6 @@
 **
 ******************************************************************************/
 
-/* true if GKI uses dynamic buffers. */
-#ifndef GKI_USE_DYNAMIC_BUFFERS
-#define GKI_USE_DYNAMIC_BUFFERS false
-#endif
-
 /* The size of the buffers in pool 0. */
 #ifndef GKI_BUF0_SIZE
 #define GKI_BUF0_SIZE 64
@@ -200,11 +187,7 @@
 
 /* The size of the buffers in pool 3. */
 #ifndef GKI_BUF3_SIZE
-#if (NXP_EXTNS == TRUE)
 #define GKI_BUF3_SIZE (0xFFB0)
-#else
-#define GKI_BUF3_SIZE 2500
-#endif
 #endif
 
 /* The number of buffers in buffer pool 3. */
@@ -308,11 +291,6 @@ of order */
 #define GKI_SEVERE(code)
 #endif
 
-/* true if GKI includes debug functionality. */
-#ifndef GKI_DEBUG
-#define GKI_DEBUG false
-#endif
-
 /* Maximum number of exceptions logged. */
 #ifndef GKI_MAX_EXCEPTION
 #define GKI_MAX_EXCEPTION 8
@@ -393,88 +371,4 @@ over HCI data and intentionally kept out of order */
 #define GKI_BUF8_MAX 30
 #endif
 
-#if defined(GKI_DEBUG) && (GKI_DEBUG == true)
-#ifdef LOG_TAG
-#undef LOG_TAG
-#endif
-#define LOG_TAG "GKI_LINUX"
-/* GKI Trace Macros */
-#define GKI_TRACE_0(m)                                          \
-  LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_GKI | TRACE_ORG_GKI | \
-             TRACE_TYPE_GENERIC,                                \
-         m)
-#define GKI_TRACE_1(m, p1)                                      \
-  LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_GKI | TRACE_ORG_GKI | \
-             TRACE_TYPE_GENERIC,                                \
-         m, p1)
-#define GKI_TRACE_2(m, p1, p2)                                  \
-  LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_GKI | TRACE_ORG_GKI | \
-             TRACE_TYPE_GENERIC,                                \
-         m, p1, p2)
-#define GKI_TRACE_3(m, p1, p2, p3)                              \
-  LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_GKI | TRACE_ORG_GKI | \
-             TRACE_TYPE_GENERIC,                                \
-         m, p1, p2, p3)
-#define GKI_TRACE_4(m, p1, p2, p3, p4)                          \
-  LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_GKI | TRACE_ORG_GKI | \
-             TRACE_TYPE_GENERIC,                                \
-         m, p1, p2, p3, p4)
-#define GKI_TRACE_5(m, p1, p2, p3, p4, p5)                      \
-  LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_GKI | TRACE_ORG_GKI | \
-             TRACE_TYPE_GENERIC,                                \
-         m, p1, p2, p3, p4, p5)
-#define GKI_TRACE_6(m, p1, p2, p3, p4, p5, p6)                  \
-  LogMsg(TRACE_CTRL_GENERAL | TRACE_LAYER_GKI | TRACE_ORG_GKI | \
-             TRACE_TYPE_GENERIC,                                \
-         m, p1, p2, p3, p4, p5, p6)
-#else
-#define GKI_TRACE_0(m)
-#define GKI_TRACE_1(m, p1)
-#define GKI_TRACE_2(m, p1, p2)
-#define GKI_TRACE_3(m, p1, p2, p3)
-#define GKI_TRACE_4(m, p1, p2, p3, p4)
-#define GKI_TRACE_5(m, p1, p2, p3, p4, p5)
-#define GKI_TRACE_6(m, p1, p2, p3, p4, p5, p6)
-
-#endif
-
-#define GKI_TRACE_ERROR_0(m)                                                   \
-  LogMsg(                                                                      \
-      TRACE_CTRL_GENERAL | TRACE_LAYER_GKI | TRACE_ORG_GKI | TRACE_TYPE_ERROR, \
-      m)
-#define GKI_TRACE_ERROR_1(m, p1)                                               \
-  LogMsg(                                                                      \
-      TRACE_CTRL_GENERAL | TRACE_LAYER_GKI | TRACE_ORG_GKI | TRACE_TYPE_ERROR, \
-      m, p1)
-#define GKI_TRACE_ERROR_2(m, p1, p2)                                           \
-  LogMsg(                                                                      \
-      TRACE_CTRL_GENERAL | TRACE_LAYER_GKI | TRACE_ORG_GKI | TRACE_TYPE_ERROR, \
-      m, p1, p2)
-#define GKI_TRACE_ERROR_3(m, p1, p2, p3)                                       \
-  LogMsg(                                                                      \
-      TRACE_CTRL_GENERAL | TRACE_LAYER_GKI | TRACE_ORG_GKI | TRACE_TYPE_ERROR, \
-      m, p1, p2, p3)
-#define GKI_TRACE_ERROR_4(m, p1, p2, p3, p4)                                   \
-  LogMsg(                                                                      \
-      TRACE_CTRL_GENERAL | TRACE_LAYER_GKI | TRACE_ORG_GKI | TRACE_TYPE_ERROR, \
-      m, p1, p2, p3, p4)
-#define GKI_TRACE_ERROR_5(m, p1, p2, p3, p4, p5)                               \
-  LogMsg(                                                                      \
-      TRACE_CTRL_GENERAL | TRACE_LAYER_GKI | TRACE_ORG_GKI | TRACE_TYPE_ERROR, \
-      m, p1, p2, p3, p4, p5)
-#define GKI_TRACE_ERROR_6(m, p1, p2, p3, p4, p5, p6)                           \
-  LogMsg(                                                                      \
-      TRACE_CTRL_GENERAL | TRACE_LAYER_GKI | TRACE_ORG_GKI | TRACE_TYPE_ERROR, \
-      m, p1, p2, p3, p4, p5, p6)
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-extern void LogMsg(uint32_t trace_set_mask, const char* fmt_str, ...);
-
-#ifdef __cplusplus
-}
-#endif
-
 #endif /* GKI_TARGET_H */
diff --git a/src/hal/include/nci_defs.h b/src/include/nci_defs.h
old mode 100644
new mode 100755
similarity index 77%
rename from src/hal/include/nci_defs.h
rename to src/include/nci_defs.h
index 1b7e99e..74a95be
--- a/src/hal/include/nci_defs.h
+++ b/src/include/nci_defs.h
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -46,27 +46,21 @@
 
 #include <stdint.h>
 
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define NCI_BRCM_CO_ID 0x2E
-
 /* Define the message header size for all NCI Commands and Notifications.
 */
 #define NCI_MSG_HDR_SIZE 3  /* per NCI spec */
 #define NCI_DATA_HDR_SIZE 3 /* per NCI spec */
 #define NCI_MAX_PAYLOAD_SIZE 0xFE
-#define NCI_MAX_CTRL_SIZE 0xFF /* max control message size */
 #define NCI_CTRL_INIT_SIZE 32  /* initial NFCC control payload size */
 #define NCI_MAX_VSC_SIZE 0xFF
+#define APPL_DTA_MODE TRUE
+
 /* NCI header (3) + callback function pointer(8; use 8 to be safe) + HCIT (1
  * byte) */
 #define NCI_VSC_MSG_HDR_SIZE 12
-#define NCI_TL_SIZE 2
 #define NCI_PARAM_ID_LF_CON_ADV_FEAT 0x55
 /*LF_T3T name changed in NCI2.0*/
-#define NCI_PARAM_ID_LF_T3T_RD_ALLOWED  0x55
+
 /* Max frame size (256) - Prologue (1) - Epilogue (2) in ISO-DEP, CID and NAD
  * are not used*/
 #define NCI_ISO_DEP_MAX_INFO 253
@@ -86,12 +80,6 @@ extern "C" {
 #define NCI_MT_CMD 1 /* (NCI_MT_CMD << NCI_MT_SHIFT) = 0x20 */
 #define NCI_MT_RSP 2 /* (NCI_MT_RSP << NCI_MT_SHIFT) = 0x40 */
 #define NCI_MT_NTF 3 /* (NCI_MT_NTF << NCI_MT_SHIFT) = 0x60 */
-#define NCI_MT_CFG 4 /* (NCI_MT_CFG << NCI_MT_SHIFT) = 0x80 */
-
-#define NCI_MTS_CMD 0x20
-#define NCI_MTS_RSP 0x40
-#define NCI_MTS_NTF 0x60
-#define NCI_MTS_CFG 0x80
 
 #define NCI_NTF_BIT 0x80 /* the tNFC_VS_EVT is a notification */
 #define NCI_RSP_BIT 0x40 /* the tNFC_VS_EVT is a response     */
@@ -99,18 +87,13 @@ extern "C" {
 /* for internal use only; not from specification */
 /* the following 2 flags are used in layer_specific for fragmentation/reassembly
  * of data packets */
-#define NCI_LS_DATA 0x00
-#define NCI_LS_DATA_PBF 0x01
 
 /* PBF: Packet Boundary Flag (byte 0) */
 #define NCI_PBF_MASK 0x10
 #define NCI_PBF_SHIFT 4
-#define NCI_PBF_NO_OR_LAST 0x00 /* not fragmented or last fragment */
-#define NCI_PBF_ST_CONT 0x10    /* start or continuing fragment */
 
 /* GID: Group Identifier (byte 0) */
 #define NCI_GID_MASK 0x0F
-#define NCI_GID_SHIFT 0
 #define NCI_GID_CORE 0x00      /* 0000b NCI Core group */
 #define NCI_GID_RF_MANAGE 0x01 /* 0001b RF Management group */
 #define NCI_GID_EE_MANAGE 0x02 /* 0010b NFCEE Management group */
@@ -135,26 +118,18 @@ extern "C" {
 #define NCI_MSG_BLD_HDR0(p, mt, gid) \
   *(p)++ = (uint8_t)(((mt) << NCI_MT_SHIFT) | (gid));
 
-#define NCI_MSG_PBLD_HDR0(p, mt, pbf, gid) \
-  *(p)++ = (uint8_t)(((mt) << NCI_MT_SHIFT) | ((pbf) << NCI_PBF_SHIFT) | (gid));
-
 /* builds byte1 of NCI Command and Notification packet */
 #define NCI_MSG_BLD_HDR1(p, oid) *(p)++ = (uint8_t)(((oid) << NCI_OID_SHIFT));
 
 /* parse byte0 of NCI packet */
-#define NCI_MSG_PRS_HDR0(p, mt, pbf, gid)     \
-  mt = (*(p)&NCI_MT_MASK) >> NCI_MT_SHIFT;    \
-  pbf = (*(p)&NCI_PBF_MASK) >> NCI_PBF_SHIFT; \
-  gid = *(p)++ & NCI_GID_MASK;
-
-/* parse MT and PBF bits of NCI packet */
-#define NCI_MSG_PRS_MT_PBF(p, mt, pbf)     \
-  mt = (*(p)&NCI_MT_MASK) >> NCI_MT_SHIFT; \
-  pbf = (*(p)&NCI_PBF_MASK) >> NCI_PBF_SHIFT;
+#define NCI_MSG_PRS_HDR0(p, mt, pbf, gid)       \
+  mt = (*(p)&NCI_MT_MASK) >> NCI_MT_SHIFT;      \
+  (pbf) = (*(p)&NCI_PBF_MASK) >> NCI_PBF_SHIFT; \
+  (gid) = *(p)++ & NCI_GID_MASK;
 
 /* parse byte1 of NCI Cmd/Ntf */
-#define NCI_MSG_PRS_HDR1(p, oid) \
-  oid = (*(p)&NCI_OID_MASK);     \
+#define NCI_MSG_PRS_HDR1(p, oid)   \
+  (oid) = (*(p)&NCI_OID_MASK);     \
   (p)++;
 
 /* NCI Data Format:
@@ -165,12 +140,6 @@ extern "C" {
  * is predefined  */
 #define NCI_CID_MASK 0x0F
 
-/* builds 3-byte message header of NCI Data packet */
-#define NCI_DATA_BLD_HDR(p, cid, len) \
-  *(p)++ = (uint8_t)(cid);            \
-  *(p)++ = 0;                         \
-  *(p)++ = (uint8_t)(len);
-
 #define NCI_DATA_PBLD_HDR(p, pbf, cid, len)             \
   *(p)++ = (uint8_t)(((pbf) << NCI_PBF_SHIFT) | (cid)); \
   *(p)++ = 0;                                           \
@@ -179,13 +148,12 @@ extern "C" {
 #define NCI_DATA_PRS_HDR(p, pbf, cid, len)      \
   (pbf) = (*(p)&NCI_PBF_MASK) >> NCI_PBF_SHIFT; \
   (cid) = (*(p)&NCI_CID_MASK);                  \
-  p++;                                          \
-  p++;                                          \
+  (p)++;                                          \
+  (p)++;                                          \
   (len) = *(p)++;
 
 /* Logical target ID 0x01-0xFE */
 /* CORE_RESET_NTF reset trigger type*/
-#define NCI2_0_RESET_TRIGGER_TYPE_ERROR                   0x00
 #define NCI2_0_RESET_TRIGGER_TYPE_POWERED_ON              0x01
 #define NCI2_0_RESET_TRIGGER_TYPE_CORE_RESET_CMD_RECEIVED 0x02
 /* Status Codes */
@@ -201,6 +169,7 @@ extern "C" {
 #define NCI_STATUS_UNKNOWN_OID 0x08
 #define NCI_STATUS_INVALID_PARAM 0x09
 #define NCI_STATUS_MSG_SIZE_TOO_BIG 0x0A
+#define NCI_STATUS_NOT_SUPPORTED 0x0B
 /* discovery */
 #define NCI_STATUS_ALREADY_STARTED 0xA0
 #define NCI_STATUS_ACTIVATION_FAILED 0xA1
@@ -219,15 +188,14 @@ extern "C" {
 #define NCI_STATUS_DWP_APDU_DROPPPED \
   0xE5 /* todo: need to place new error code when FW is readey*/
 #define NCI_STATUS_ALREADY_INITIALIZED 0x0C
+#define NCI_STATUS_EPERM -1
 #endif
 
-typedef uint8_t tNCI_STATUS;
-
 /* RF Technologies */
 #define NCI_RF_TECHNOLOGY_A 0x00
 #define NCI_RF_TECHNOLOGY_B 0x01
 #define NCI_RF_TECHNOLOGY_F 0x02
-#define NCI_RF_TECHNOLOGY_15693 0x03
+#define NCI_RF_TECHNOLOGY_V 0x03
 
 /* Bit Rates */
 #define NCI_BIT_RATE_106 0x00  /* 106 kbit/s */
@@ -250,6 +218,7 @@ typedef uint8_t tNCI_STATUS;
 #define NCI_MSG_CORE_CONN_CREDITS 6
 #define NCI_MSG_CORE_GEN_ERR_STATUS 7
 #define NCI_MSG_CORE_INTF_ERR_STATUS 8
+#define NCI_MSG_CORE_SET_POWER_SUB_STATE 9
 
 /**********************************************
  * RF MANAGEMENT Group Opcode    - 1
@@ -267,6 +236,7 @@ typedef uint8_t tNCI_STATUS;
 #define NCI_MSG_RF_EE_DISCOVERY_REQ 10
 #define NCI_MSG_RF_PARAMETER_UPDATE 11
 #define NCI_MSG_RF_ISO_DEP_NAK_PRESENCE 16
+
 /**********************************************
  * NFCEE MANAGEMENT Group Opcode - 2
  **********************************************/
@@ -286,8 +256,6 @@ typedef uint8_t tNCI_STATUS;
  * NCI Core Group Params
  **********************************************/
 #define NCI_CORE_PARAM_SIZE_RESET 0x01
-#define NCI_CORE_PARAM_SIZE_RESET_RSP 0x03
-#define NCI_CORE_PARAM_SIZE_RESET_NTF 0x02
 /**********************************************
  * NCI Feature Bit
  **********************************************/
@@ -295,66 +263,31 @@ typedef uint8_t tNCI_STATUS;
 #define NCI_CORE_PARAM_SIZE_INIT(X) (((X) == NCI_VERSION_2_0) ? (0x02) : (0x00))
 #define NCI2_0_CORE_INIT_CMD_BYTE_0 0x00
 #define NCI2_0_CORE_INIT_CMD_BYTE_1 0x00
-#define NCI_CORE_PARAM_SIZE_INIT_RSP 0x11
-#define NCI_CORE_INIT_RSP_OFFSET_NUM_INTF 0x05
-
 /* Status (1 octet) and number of params */
-#define NCI_CORE_PARAM_SIZE_SET_CONFIG_RSP 0x02
-
-/* octet 0 */
-#define NCI_FEAT_DISCOVERY_FREG 0x00000001
-#define NCI_FEAT_DISCOVERY_CFGM 0x00000006
-/* octet 1 */
-#define NCI_FEAT_TECHNOLOGY_ROUTING 0x00000200
-#define NCI_FEAT_PROTOCOL_ROUTING 0x00000400
-#define NCI_FEAT_AID_ROUTING 0x00000800
-/* octet 2 */
-#define NCI_FEAT_BATTERY_OFF_MD 0x00010000
-#define NCI_FEAT_SWITCH_OFF_MD 0x00020000
-
-/* supported Interfaces */
-#define NCI_SUP_INTF_FRAME 0x0001
-#define NCI_SUP_INTF_ISO_DEP 0x0002
-#define NCI_SUP_INTF_NFC_DEP 0x0004
+#define NCI_CORE_PARAM_SIZE_SET_POWER_SUB_STATE 0x01
 
 #define NCI_CORE_PARAM_SIZE_CON_CREATE 0x02 /* handle, num_tlv, (tlv) */
 /* status, size, credits, conn_id */
-#define NCI_CORE_PARAM_SIZE_CON_CREATE_RSP 0x04
-#define NCI_CON_CREATE_TAG_EE_INTF 0x00 /* old */
 #define NCI_CON_CREATE_TAG_RF_DISC_ID 0x00
 #define NCI_CON_CREATE_TAG_NFCEE_VAL 0x01
 
 #define NCI_CORE_PARAM_SIZE_CON_CLOSE 0x01     /* Conn ID (1 octet) */
-#define NCI_CORE_PARAM_SIZE_CON_CLOSE_RSP 0x01 /* Status (1 octet) */
-
-/* RF Field Status (1 octet) */
-#define NCI_CORE_PARAM_SIZE_RF_FIELD_NTF 0x01
 
 /* Keep the NCI configuration (if possible) and perform NCI initialization. */
 #define NCI_RESET_TYPE_KEEP_CFG 0x00
 /* Reset the NCI configuration, and perform NCI initialization. */
 #define NCI_RESET_TYPE_RESET_CFG 0x01
 
-/* NCI Configuration has been kept  */
-#define NCI_RESET_STATUS_KEPT_CFG 0x00
-/* NCI Configuration has been reset */
-#define NCI_RESET_STATUS_RESET_CFG 0x01
-
 /* No operating field generated by remote device  */
 #define NCI_RF_STS_NO_REMOTE 0x00
 /* Operating field generated by remote device  */
 #define NCI_RF_STS_REMOTE 0x01
 
 #define NCI_PARAM_SIZE_DISCOVER_NFCEE(X) (((X) == NCI_VERSION_2_0) ?0X00 : 0X01) /* Discovery Action (1 octet) */
-/* Status (1 octet)Number of NFCEEs (1 octet) */
-#define NCI_PARAM_SIZE_DISCOVER_NFCEE_RSP 0x02
 
 #define NCI_DISCOVER_ACTION_DISABLE 0
 #define NCI_DISCOVER_ACTION_ENABLE 1
 
-#define NCI_EE_DISCOVER_REQ_TYPE_LISTEN 0x01
-#define NCI_EE_DISCOVER_REQ_TYPE_POLL 0x02
-
 #define NCI_RF_PARAM_ID_TECH_N_MODE 0x00 /* RF Technology and Mode   */
 #define NCI_RF_PARAM_ID_TX_BIT_RATE 0x01 /* Transmit Bit Rate        */
 #define NCI_RF_PARAM_ID_RX_BIT_RATE 0x02 /* Receive Bit Rate         */
@@ -385,14 +318,10 @@ typedef uint8_t tNCI_STATUS;
 #define NCI_NFCEE_STS_CONN_ACTIVE 0x00
 #define NCI_NFCEE_STS_CONN_INACTIVE 0x01
 #define NCI_NFCEE_STS_REMOVED 0x02
-#define NCI_NUM_NFCEE_STS 3
 
 /* Logical Target ID (1 octet)NFCEE Mode (1 octet) */
 #define NCI_CORE_PARAM_SIZE_NFCEE_MODE_SET 0x02
-#define NCI_CORE_PARAM_SIZE_NFCEE_MODE_SET_RSP 0x01 /* Status (1 octet) */
 
-#define NCI_MSG_CORE_SET_POWER_SUB_STATE 9
-#define NCI_CORE_PARAM_SIZE_SET_POWER_SUB_STATE    0x01
 /* Deactivate the connected NFCEE */
 #define NCI_NFCEE_MD_DEACTIVATE 0x00
 /* Activate the connected NFCEE */
@@ -414,19 +343,13 @@ typedef uint8_t tNCI_STATUS;
 #define NCI_DEACTIVATE_REASON_ENDPOINT_REQ 1 /* Endpoint Request */
 #define NCI_DEACTIVATE_REASON_RF_LINK_LOSS 2 /* RF Link Loss     */
 #define NCI_DEACTIVATE_REASON_NFCB_BAD_AFI 3 /* NFC-B Bad AFI    */
-
+/* DH Request Failed due to error */
+#define NCI_DEACTIVATE_REASON_DH_REQ_FAILED 4
 
 /* The NFCEE status in NFCEE Status Notification */
-#define NCI_NFCEE_NTF_STATUS_ERROR          0x00    /* Unrecoverable Error */
-#define NCI_NFCEE_NTF_STATUS_INIT_STARTED   0x01    /* NFCEE initialization sequence started */
-#define NCI_NFCEE_NTF_STATUS_INIT_DONE      0x02    /* NFCEE initialization sequence completed */
 typedef uint8_t tNCI_EE_NTF_STATUS;
 
 /* NFCEE Power and Link Configuration */
-#define NFCEE_PL_CONFIG_NFCC_DECIDES        0x00
-#define NFCEE_PL_CONFIG_P_ALWAYS_ON         0x01
-#define NFCEE_PL_CONFIG_L_ON_WHEN_P_ON      0x02
-#define NFCEE_PL_CONFIG_PL_ALWAYS_ON        0x03
 typedef uint8_t tNCI_NFCEE_PL_CONFIG;
 
 /**********************************************
@@ -456,20 +379,9 @@ typedef uint8_t tNCI_INTF_TYPE;
 /**********************************************
  * NCI RF Management / DISCOVERY Group Params
  **********************************************/
-#define NCI_DISCOVER_PARAM_SIZE_RSP 0x01
-
 #define NCI_DISCOVER_PARAM_SIZE_SELECT 0x03     /* ID, protocol, interface */
-#define NCI_DISCOVER_PARAM_SIZE_SELECT_RSP 0x01 /* Status (1 octet) */
-#define NCI_DISCOVER_PARAM_SIZE_STOP 0x00       /*  */
-#define NCI_DISCOVER_PARAM_SIZE_STOP_RSP 0x01   /* Status (1 octet) */
 #define NCI_DISCOVER_PARAM_SIZE_DEACT 0x01      /* type */
-#define NCI_DISCOVER_PARAM_SIZE_DEACT_RSP 0x01  /* Status (1 octet) */
-#define NCI_DISCOVER_PARAM_SIZE_DEACT_NTF 0x01  /* type */
 
-#define NCI_ROUTE_QUAL_MASK         0x70
-#define NCI_ROUTE_QUAL_LONG_SELECT  0x10 /* AID matching is allowed when the SELECT AID is longer */
-#define NCI_ROUTE_QUAL_SHORT_SELECT 0x20 /* AID matching is allowed when the SELECT AID is shorter */
-#define NCI_ROUTE_QUAL_BLOCK_ROUTE  0x40 /* AID is blocked in unsupported power mode */
 /**********************************************
  * Supported Protocols
  **********************************************/
@@ -477,6 +389,7 @@ typedef uint8_t tNCI_INTF_TYPE;
 #define NCI_PROTOCOL_T1T 0x01
 #define NCI_PROTOCOL_T2T 0x02
 #define NCI_PROTOCOL_T3T 0x03
+#define NCI_PROTOCOL_T5T 0x06
 #define NCI_PROTOCOL_ISO_DEP 0x04
 #define NCI_PROTOCOL_NFC_DEP 0x05
 #if (NXP_EXTNS == TRUE)
@@ -495,16 +408,19 @@ typedef uint8_t tNCI_INTF_TYPE;
 #define NCI_DISCOVERY_TYPE_POLL_A 0x00
 #define NCI_DISCOVERY_TYPE_POLL_B 0x01
 #define NCI_DISCOVERY_TYPE_POLL_F 0x02
+#define NCI_DISCOVERY_TYPE_POLL_V 0x06
 #define NCI_DISCOVERY_TYPE_POLL_A_ACTIVE 0x03
+/* NCI2.0 standardizes P2P poll active*/
+#define NCI_DISCOVERY_TYPE_POLL_ACTIVE 0x03
 #define NCI_DISCOVERY_TYPE_POLL_F_ACTIVE 0x05
 #define NCI_DISCOVERY_TYPE_LISTEN_A 0x80
 #define NCI_DISCOVERY_TYPE_LISTEN_B 0x81
 #define NCI_DISCOVERY_TYPE_LISTEN_F 0x82
 #define NCI_DISCOVERY_TYPE_LISTEN_A_ACTIVE 0x83
+/* NCI2.0 standardizes P2P listen active*/
+#define NCI_DISCOVERY_TYPE_LISTEN_ACTIVE 0x83
 #define NCI_DISCOVERY_TYPE_LISTEN_F_ACTIVE 0x85
-#define NCI_DISCOVERY_TYPE_POLL_ISO15693 0x06
 #define NCI_DISCOVERY_TYPE_LISTEN_ISO15693 0x86
-#define NCI_DISCOVERY_TYPE_MAX NCI_DISCOVERY_TYPE_LISTEN_ISO15693
 
 typedef uint8_t tNCI_DISCOVERY_TYPE;
 
@@ -514,19 +430,16 @@ typedef uint8_t tNCI_DISCOVERY_TYPE;
 #define NCI_EE_TRIG_APP_INIT 0x10
 
 #define NCI_EE_ACT_TAG_AID 0xC0   /* AID                 */
-#define NCI_EE_ACT_TAG_PROTO 0xC1 /* RF protocol         */
-#define NCI_EE_ACT_TAG_TECH 0xC2  /* RF technology       */
 #define NCI_EE_ACT_TAG_DATA 0xC3  /* hex data for app    */
-#define NCI_EE_ACT_TAG_DEBUG 0xC4 /* debug trace         */
 
 #define NCI_CORE_PARAM_SIZE_NFCEE_PL_CTRL       0x02 /* NFCEE ID (1 octet) PL config (1 octet) */
-#define NCI_CORE_PARAM_SIZE_NFCEE_PL_CTRL_RSP   0x01 /* Status (1 octet) */
 
 /* Technology based routing  */
 #define NCI_ROUTE_TAG_TECH 0x00
 /* Protocol based routing  */
 #define NCI_ROUTE_TAG_PROTO 0x01
 #define NCI_ROUTE_TAG_AID 0x02 /* AID routing */
+#define NCI_ROUTE_TAG_SYSCODE 0x03 /* SystemCode routing */
 
 #define NCI_ROUTE_TAG_APDU 0x4 /* APDU routing*/
 #define NCI_ROUTE_PWR_STATE_ON 0x01 /* The device is on */
@@ -534,14 +447,13 @@ typedef uint8_t tNCI_DISCOVERY_TYPE;
 #define NCI_ROUTE_PWR_STATE_SWITCH_OFF 0x02
 /* The device's battery is removed */
 #define NCI_ROUTE_PWR_STATE_BATT_OFF 0x04
-#if (NXP_EXTNS == TRUE)
 /* The device is screen off Unlock mode */
 #define NCI_ROUTE_PWR_STATE_SCREEN_OFF_UNLOCK()   ((NFC_GetNCIVersion() == NCI_VERSION_2_0)?0x08:0x80)
 /* The device is screen on lock mode */
 #define NCI_ROUTE_PWR_STATE_SCREEN_ON_LOCK()    ((NFC_GetNCIVersion() == NCI_VERSION_2_0)?0x10:0x40)
 /* The device is screen off lock mode */
 #define NCI_ROUTE_PWR_STATE_SCREEN_OFF_LOCK()   ((NFC_GetNCIVersion() == NCI_VERSION_2_0)?0x20:0x00)
-#endif
+
 /* Hardware / Registration Identification  */
 #define NCI_NFCEE_TAG_HW_ID 0x00
 #define NCI_NFCEE_TAG_ATR_BYTES 0x01 /* ATR Bytes  */
@@ -612,7 +524,10 @@ typedef uint8_t tNCI_DISCOVERY_TYPE;
 #define NCI_PARAM_ID_LF_T3T_MAX 0x52
 #define NCI_PARAM_ID_LF_T3T_FLAGS2 0x53
 #define NCI_PARAM_ID_LF_CON_BITR_F 0x54
-#define NCI_PARAM_ID_LF_CON_ADV_FEAT 0x55  // FelicaOnHost
+#define NCI_PARAM_ID_LF_CON_ADV_FEAT 0x55
+/*LF_T3T name changed in NCI2.0*/
+#define NCI_PARAM_ID_LF_T3T_RD_ALLOWED 0x55
+
 #define NCI_PARAM_ID_FWI 0x58
 #define NCI_PARAM_ID_LA_HIST_BY 0x59
 #define NCI_PARAM_ID_LB_H_INFO_RSP 0x5A
@@ -623,25 +538,8 @@ typedef uint8_t tNCI_DISCOVERY_TYPE;
 #define NCI_PARAM_ID_ATR_RSP_CONFIG 0x62
 
 #define NCI_PARAM_ID_RF_FIELD_INFO 0x80
-#define NCI_PARAM_ID_RF_NFCEE_ACTION 0x81
 #define NCI_PARAM_ID_NFC_DEP_OP 0x82
 
-/* NCI_PARAM_ID_HOST_LISTEN_MASK (byte1 for DH, byte2 for UICC) */
-/* (0x01 << (NCI_DISCOVERY_TYPE_LISTEN_A_PASSIVE & 0x0F)) */
-#define NCI_LISTEN_MASK_A 0x01
-/* (0x01 << (NCI_DISCOVERY_TYPE_LISTEN_B_PASSIVE & 0x0F)) */
-#define NCI_LISTEN_MASK_B 0x02
-/* (0x01 << (NCI_DISCOVERY_TYPE_LISTEN_F_PASSIVE & 0x0F)) */
-#define NCI_LISTEN_MASK_F 0x04
-/* (0x01 << (NCI_DISCOVERY_TYPE_LISTEN_A_ACTIVE & 0x0F))  */
-#define NCI_LISTEN_MASK_A_ACTIVE 0x08
-/* (0x01 << (NCI_DISCOVERY_TYPE_LISTEN_B_PRIME & 0x0F))   */
-#define NCI_LISTEN_MASK_B_PRIME 0x10
-/* (0x01 << (NCI_DISCOVERY_TYPE_LISTEN_F_ACTIVE & 0x0F))  */
-#define NCI_LISTEN_MASK_F_ACTIVE 0x20
-/* (0x01 << (NCI_DISCOVERY_TYPE_LISTEN_ISO15693 & 0x0F))  */
-#define NCI_LISTEN_MASK_ISO15693 0x40
-
 #define NCI_LISTEN_DH_NFCEE_ENABLE_MASK 0x00 /* The DH-NFCEE listen is considered as a enable NFCEE */
 #define NCI_LISTEN_DH_NFCEE_DISABLE_MASK 0x02 /* The DH-NFCEE listen is considered as a disable NFCEE */
 #define NCI_POLLING_DH_DISABLE_MASK 0x00 /* The DH polling is considered as a disable NFCEE */
@@ -658,8 +556,6 @@ typedef uint8_t tNCI_DISCOVERY_TYPE;
 
 #define NCI_PARAM_LEN_CON_DISCOVERY_PARAM 1
 
-#define NCI_PARAM_LEN_PA_FSDI 1
-
 #define NCI_PARAM_LEN_PF_RC 1
 
 #define NCI_PARAM_LEN_LA_BIT_FRAME_SDD 1
@@ -675,7 +571,9 @@ typedef uint8_t tNCI_DISCOVERY_TYPE;
 #define NCI_PARAM_LEN_LF_T3T_FLAGS2 2
 #define NCI_PARAM_LEN_LF_T3T_PMM 8
 #define NCI_PARAM_LEN_LF_T3T_ID(X) (((X) == NCI_VERSION_2_0) ? (0x12) : (0x0A))
-#define NCI_PARAM_LEN_LF_CON_ADV_FEAT 1  // FelicaOnHost
+#define NCI_PARAM_LEN_LF_CON_ADV_FEAT 1
+
+#define NCI_PARAM_LEN_LF_T3T_RD_ALLOWED 1  // Listen F NCI2.0 Parameter
 
 #define NCI_PARAM_LEN_FWI 1
 #define NCI_PARAM_LEN_WT 1
@@ -686,39 +584,26 @@ typedef uint8_t tNCI_DISCOVERY_TYPE;
 #define NCI_LISTEN_PROTOCOL_ISO_DEP 0x01
 #define NCI_LISTEN_PROTOCOL_NFC_DEP 0x02
 
-#define NCI_DISCOVER_PARAM_SIZE_TEST_RF 0x06
-
 /* LF_T3T_FLAGS2 listen bits all-disabled definition */
 #define NCI_LF_T3T_FLAGS2_ALL_DISABLED 0x0000
-#define NCI_LF_T3T_FLAGS2_ID1_ENABLED 0x0001
-
-#define NCI_PARAM_LEN_LF_CON_ADV_FEAT 1
-
-#define NCI_PARAM_LEN_LF_T3T_RD_ALLOWED 1 //Listen F NCI2.0 Parameter
-#define NCI_PARAM_LEN_LF_T3T_ID_MAX 16 //LF T3T indentifier Max Value 16
-#define NFA_CE_LISTEN_INFO_LF_MAX 16 //LF T3T indentifier Max Value 16
 
-typedef struct {
-  uint16_t addr;
-  uint8_t len;
-  uint8_t* data;
-} NCIP_T1T_SETMEM_CMD_t;
-
-typedef struct { uint8_t status; } NCIP_T1T_SETMEM_RSP_t;
-
-typedef struct { uint16_t addr; } NCIP_T1T_GETMEM_CMD_t;
-
-typedef struct {
-  uint8_t status;
-  uint8_t* data;
-} NCIP_T1T_GETMEM_RSP_t;
-
-typedef struct {
-  uint8_t hr0;
-  uint8_t hr1;
-} NCIP_T1T_SETHR_CMD_t;
-
-typedef struct { uint8_t status; } NCIP_T1T_SETHR_RSP_t;
+/* The DH-NFCEE listen is considered as a enable NFCEE */
+#define NCI_LISTEN_DH_NFCEE_ENABLE_MASK 0x00
+/* The DH-NFCEE listen is considered as a disable NFCEE */
+#define NCI_LISTEN_DH_NFCEE_DISABLE_MASK 0x02
+/* The DH polling is considered as a disable NFCEE */
+#define NCI_POLLING_DH_DISABLE_MASK 0x00
+/* The DH polling is considered as a enable NFCEE */
+#define NCI_POLLING_DH_ENABLE_MASK 0x01
+/* SCBR support check with Core Init resp OCT1 byte */
+#define NCI_SCBR_MASK 0x10
+
+/* AID matching is allowed when the SELECT AID is longer */
+#define NCI_ROUTE_QUAL_LONG_SELECT 0x10
+/* AID matching is allowed when the SELECT AID is shorter */
+#define NCI_ROUTE_QUAL_SHORT_SELECT 0x20
+/* AID is blocked in unsupported power mode */
+#define NCI_ROUTE_QUAL_BLOCK_ROUTE 0x40
 
 #ifndef NCI_GET_CMD_BUF
 #if (HCI_USE_VARIABLE_SIZE_CMD_BUF == false)
@@ -772,8 +657,6 @@ typedef struct {
 #if (NXP_EXTNS == TRUE)
 #define NCI_SENSF_RES_OFFSET_NFCID2 1
 #endif
-#define NCI_SENSF_RES_OFFSET_PAD0 8
-#define NCI_SENSF_RES_OFFSET_RD 16
 #define NCI_NFCID2_LEN 8
 #define NCI_T3T_PMM_LEN 8
 #define NCI_SYSTEMCODE_LEN 2
@@ -793,16 +676,6 @@ typedef struct {
                                      Interface  */
 } tNCI_RF_LF_PARAMS;
 
-typedef struct {
-  tNCI_DISCOVERY_TYPE mode;
-  union {
-    tNCI_RF_PA_PARAMS pa;
-    tNCI_RF_PB_PARAMS pb;
-    tNCI_RF_PF_PARAMS pf;
-    tNCI_RF_LF_PARAMS lf;
-  } param; /* Discovery Type specific parameters */
-} tNCI_RF_TECH_PARAMS;
-
 #ifndef NCI_MAX_ATS_LEN
 #define NCI_MAX_ATS_LEN 60
 #endif
@@ -817,7 +690,6 @@ typedef struct {
 #define NCI_ATS_TC_MASK 0x40
 #define NCI_ATS_TB_MASK 0x20
 #define NCI_ATS_TA_MASK 0x10
-#define NCI_ATS_FSCI_MASK 0x0F
 typedef struct {
   uint8_t ats_res_len;              /* Length of ATS RES */
   uint8_t ats_res[NCI_MAX_ATS_LEN]; /* ATS RES defined in [DIGPROT] */
@@ -859,21 +731,13 @@ typedef struct {
 } tNCI_INTF_LB_ISO_DEP;
 
 typedef struct {
-  tNCI_INTF_TYPE type; /* Interface Type  1 Byte  See Table 67 */
-  union {
-    tNCI_INTF_LA_ISO_DEP la_iso;
-    tNCI_INTF_PA_ISO_DEP pa_iso;
-    tNCI_INTF_LB_ISO_DEP lb_iso;
-    tNCI_INTF_PB_ISO_DEP pb_iso;
-    tNCI_INTF_LA_NFC_DEP la_nfc;
-    tNCI_INTF_PA_NFC_DEP pa_nfc;
-    tNCI_INTF_LF_NFC_DEP lf_nfc;
-    tNCI_INTF_PF_NFC_DEP pf_nfc;
-  } intf_param; /* Activation Parameters   0 - n Bytes */
-} tNCI_INTF_PARAMS;
-
-#ifdef __cplusplus
-}
-#endif
+  uint8_t atr_res_len;                      /* Length of ATR_RES            */
+  uint8_t atr_res[NCI_MAX_ATS_LEN];         /* ATR_RES (Byte 3 - Byte 17+n) */
+  uint8_t max_payload_size;                 /* 64, 128, 192 or 254          */
+  uint8_t gen_bytes_len;                    /* len of general bytes         */
+  uint8_t gen_bytes[NCI_MAX_GEN_BYTES_LEN]; /* general bytes                */
+  uint8_t waiting_time;                     /* WT -> Response Waiting Time
+                                               RWT = (256 x 16/fC) x 2WT    */
+} tNCI_RF_ACM_P_PARAMS;
 
 #endif /* NFC_NCI_DEFS_H */
diff --git a/src/include/nfc_brcm_defs.h b/src/include/nfc_brcm_defs.h
new file mode 100755
index 0000000..91b0f6d
--- /dev/null
+++ b/src/include/nfc_brcm_defs.h
@@ -0,0 +1,86 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2012-2014 Broadcom Corporation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ *  This file contains the Broadcom-specific defintions that are shared
+ *  between HAL, nfc stack, adaptation layer and applications.
+ *
+ ******************************************************************************/
+
+#ifndef NFC_BRCM_DEFS_H
+#define NFC_BRCM_DEFS_H
+
+/**********************************************
+ * NCI Message Proprietary  Group       - F
+ **********************************************/
+#define NCI_MSG_GET_BUILD_INFO 0x04
+#define NCI_MSG_HCI_NETWK 0x05
+#define NCI_MSG_POWER_LEVEL 0x08
+#define NCI_MSG_UICC_READER_ACTION 0x0A
+/* reset HCI network/close all pipes (S,D) register */
+#define NCI_MSG_GET_NV_DEVICE 0x24
+#define NCI_MSG_LPTD 0x25
+#define NCI_MSG_EEPROM_RW 0x29
+#define NCI_MSG_GET_PATCH_VERSION 0x2D
+#define NCI_MSG_SECURE_PATCH_DOWNLOAD 0x2E
+
+/* Secure Patch Download definitions (patch type definitions) */
+#define NCI_SPD_TYPE_HEADER 0x00
+
+/**********************************************
+ * NCI Interface Types
+ **********************************************/
+#define NCI_INTERFACE_VS_MIFARE 0x80
+#define NCI_INTERFACE_VS_T2T_CE 0x82 /* for Card Emulation side */
+
+#define NCI_PARAM_ID_T1T_RDR_ONLY 0xA7
+
+#define NFC_SNOOZE_MODE_UART 0x01    /* Snooze mode for UART    */
+
+#define NFC_SNOOZE_ACTIVE_LOW 0x00  /* high to low voltage is asserting */
+
+/**********************************************
+ * HCI definitions
+ **********************************************/
+#define NFC_HAL_HCI_SESSION_ID_LEN 8
+#define NFC_HAL_HCI_SYNC_ID_LEN 2
+
+/* Card emulation RF Gate A definitions */
+#define NFC_HAL_HCI_CE_RF_A_UID_REG_LEN 10
+#define NFC_HAL_HCI_CE_RF_A_ATQA_RSP_CODE_LEN 2
+#define NFC_HAL_HCI_CE_RF_A_MAX_HIST_DATA_LEN 15
+#define NFC_HAL_HCI_CE_RF_A_MAX_DATA_RATE_LEN 3
+
+/* Card emulation RF Gate B definitions */
+#define NFC_HAL_HCI_CE_RF_B_PUPI_LEN 4
+#define NFC_HAL_HCI_CE_RF_B_ATQB_LEN 4
+#define NFC_HAL_HCI_CE_RF_B_HIGHER_LAYER_RSP_LEN 61
+#define NFC_HAL_HCI_CE_RF_B_MAX_DATA_RATE_LEN 3
+
+/* Card emulation RF Gate BP definitions */
+#define NFC_HAL_HCI_CE_RF_BP_MAX_PAT_IN_LEN 8
+#define NFC_HAL_HCI_CE_RF_BP_DATA_OUT_LEN 40
+
+/* Reader RF Gate A definitions */
+#define NFC_HAL_HCI_RD_RF_B_HIGHER_LAYER_DATA_LEN 61
+
+/* DH HCI Network command definitions */
+#define NFC_HAL_HCI_DH_MAX_DYN_PIPES 20
+
+#endif /* NFC_BRCM_DEFS_H */
diff --git a/src/include/nfc_config.h b/src/include/nfc_config.h
new file mode 100755
index 0000000..3a5d6ba
--- /dev/null
+++ b/src/include/nfc_config.h
@@ -0,0 +1,123 @@
+/*
+ * Copyright 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#include <string>
+#include <vector>
+
+#include <config.h>
+
+/* Configs from libnfc-nci.conf */
+#define NAME_NFC_DEBUG_ENABLED "NFC_DEBUG_ENABLED"
+#define NAME_POLLING_TECH_MASK "POLLING_TECH_MASK"
+#define NAME_NFA_DM_CFG "NFA_DM_CFG"
+#define NAME_SCREEN_OFF_POWER_STATE "SCREEN_OFF_POWER_STATE"
+#define NAME_NFA_STORAGE "NFA_STORAGE"
+#define NAME_UICC_LISTEN_TECH_MASK "UICC_LISTEN_TECH_MASK"
+#define NAME_NFA_DM_DISC_DURATION_POLL "NFA_DM_DISC_DURATION_POLL"
+#define NAME_AID_FOR_EMPTY_SELECT "AID_FOR_EMPTY_SELECT"
+#define NAME_PRESERVE_STORAGE "PRESERVE_STORAGE"
+#define NAME_NFA_MAX_EE_SUPPORTED "NFA_MAX_EE_SUPPORTED"
+#define NAME_POLL_FREQUENCY "POLL_FREQUENCY"
+#define NAME_PRESENCE_CHECK_ALGORITHM "PRESENCE_CHECK_ALGORITHM"
+#define NAME_DEVICE_HOST_WHITE_LIST "DEVICE_HOST_WHITE_LIST"
+#define NAME_DEFAULT_SYS_CODE "DEFAULT_SYS_CODE"
+#define NAME_DEFAULT_SYS_CODE_ROUTE "DEFAULT_SYS_CODE_ROUTE"
+#define NAME_AID_MATCHING_MODE "AID_MATCHING_MODE"
+#define NAME_OFFHOST_AID_ROUTE_PWR_STATE "OFFHOST_AID_ROUTE_PWR_STATE"
+/* Configs from vendor interface */
+#define NAME_NFA_POLL_BAIL_OUT_MODE "NFA_POLL_BAIL_OUT_MODE"
+#define NAME_NFA_PROPRIETARY_CFG "NFA_PROPRIETARY_CFG"
+#define NAME_AID_BLOCK_ROUTE "AID_BLOCK_ROUTE"
+#define NAME_NXP_PROP_BLACKLIST_ROUTING "NXP_PROP_BLACKLIST_ROUTING"
+#define NAME_ISO_DEP_MAX_TRANSCEIVE "ISO_DEP_MAX_TRANSCEIVE"
+#define NAME_DEFAULT_ROUTE "DEFAULT_ROUTE"
+#define NAME_DEFAULT_NFCF_ROUTE "DEFAULT_NFCF_ROUTE"
+#define NAME_OFF_HOST_ESE_PIPE_ID "OFF_HOST_ESE_PIPE_ID"
+#define NAME_OFF_HOST_SIM_PIPE_ID "OFF_HOST_SIM_PIPE_ID"
+#if (NXP_EXTNS == TRUE)
+#define NAME_DEFAULT_AID_ROUTE "DEFAULT_AID_ROUTE"
+#define NAME_DEFAULT_DESFIRE_ROUTE "DEFAULT_DESFIRE_ROUTE"
+#define NAME_DEFAULT_MIFARE_CLT_ROUTE "DEFAULT_MIFARE_CLT_ROUTE"
+#define NAME_DEFAULT_AID_PWR_STATE "DEFAULT_AID_PWR_STATE"
+#define NAME_DEFAULT_ROUTE_PWR_STATE "DEFAULT_ROUTE_PWR_STATE"
+#define NAME_DEFAULT_OFFHOST_PWR_STATE "DEFAULT_OFFHOST_PWR_STATE"
+#define NAME_NXP_CORE_SCRN_OFF_AUTONOMOUS_ENABLE \
+  "NXP_CORE_SCRN_OFF_AUTONOMOUS_ENABLE"
+#define NAME_NFA_DM_DISC_NTF_TIMEOUT "NFA_DM_DISC_NTF_TIMEOUT"
+#define NAME_HOST_LISTEN_TECH_MASK "HOST_LISTEN_TECH_MASK"
+#define NAME_NXP_FWD_FUNCTIONALITY_ENABLE "NXP_FWD_FUNCTIONALITY_ENABLE"
+#define NAME_NXP_ESE_LISTEN_TECH_MASK "NXP_ESE_LISTEN_TECH_MASK"
+#define NAME_P2P_LISTEN_TECH_MASK "P2P_LISTEN_TECH_MASK"
+#define NAME_DEFAULT_OFFHOST_ROUTE "DEFAULT_OFFHOST_ROUTE"
+#define NAME_NXP_DEFAULT_NFCEE_TIMEOUT "NXP_DEFAULT_NFCEE_TIMEOUT"
+#define NAME_NXP_DEFAULT_NFCEE_DISC_TIMEOUT "NXP_DEFAULT_NFCEE_DISC_TIMEOUT"
+#define NAME_NXP_DUAL_UICC_ENABLE "NXP_DUAL_UICC_ENABLE"
+#define NAME_NXP_ESE_PWR_MGMT_PROP "NXP_ESE_PWR_MGMT_PROP"
+#define NAME_OS_DOWNLOAD_TIMEOUT_VALUE "OS_DOWNLOAD_TIMEOUT_VALUE"
+#define NAME_DEFAULT_FELICA_CLT_ROUTE "DEFAULT_FELICA_CLT_ROUTE"
+#define NAME_DEFAULT_SYS_CODE_PWR_STATE "DEFAULT_SYS_CODE_PWR_STATE"
+#define NAME_DEFAULT_FELICA_CLT_PWR_STATE "DEFAULT_FELICA_CLT_PWR_STATE"
+#define NAME_NXP_HCEF_CMD_RSP_TIMEOUT_VALUE "NXP_HCEF_CMD_RSP_TIMEOUT_VALUE"
+#define NAME_NXP_ALLOW_WIRED_IN_MIFARE_DESFIRE_CLT \
+  "NXP_ALLOW_WIRED_IN_MIFARE_DESFIRE_CLT"
+#define NAME_NXP_NFCC_RF_FIELD_EVENT_TIMEOUT "NXP_NFCC_RF_FIELD_EVENT_TIMEOUT"
+#define NAME_NXP_WM_MAX_WTX_COUNT       "NXP_WM_MAX_WTX_COUNT"
+#define NAME_NXP_NFCC_STANDBY_TIMEOUT "NXP_NFCC_STANDBY_TIMEOUT"
+#define NAME_NXP_NFCC_PASSIVE_LISTEN_TIMEOUT "NXP_NFCC_PASSIVE_LISTEN_TIMEOUT"
+#define NAME_CHECK_DEFAULT_PROTO_SE_ID "NXP_CHECK_DEFAULT_PROTO_SE_ID"
+#define NAME_NAME_NXP_ESE_LISTEN_TECH_MASK "NAME_NXP_ESE_LISTEN_TECH_MASK"
+#define NAME_NXP_ESE_WIRED_PRT_MASK "NXP_ESE_WIRED_PRT_MASK"
+#define NAME_NXP_UICC_WIRED_PRT_MASK "NXP_UICC_WIRED_PRT_MASK"
+#define NAME_NXP_WIRED_MODE_RF_FIELD_ENABLE "NXP_WIRED_MODE_RF_FIELD_ENABLE"
+#define NAME_NXP_ESE_POWER_DH_CONTROL "NXP_ESE_POWER_DH_CONTROL"
+#define NAME_NXP_SWP_RD_TAG_OP_TIMEOUT "NXP_SWP_RD_TAG_OP_TIMEOUT"
+#define NAME_NXP_LOADER_SERICE_VERSION "NXP_LOADER_SERVICE_VERSION"
+#define NAME_NXP_CE_ROUTE_STRICT_DISABLE "NXP_CE_ROUTE_STRICT_DISABLE"
+#define NAME_NXP_DEFAULT_SE "NXP_DEFAULT_SE"
+#define NAME_NXP_JCOPDL_AT_BOOT_ENABLE "NXP_JCOPDL_AT_BOOT_ENABLE"
+#define NAME_NXP_NFC_CHIP "NXP_NFC_CHIP"
+#define NAME_NXP_P61_LS_DEFAULT_INTERFACE "NXP_P61_LS_DEFAULT_INTERFACE"
+#define NAME_NXP_P61_JCOP_DEFAULT_INTERFACE "NXP_P61_JCOP_DEFAULT_INTERFACE"
+#define NAME_NXP_AGC_DEBUG_ENABLE "NXP_AGC_DEBUG_ENABLE"
+#define NAME_NXP_DWP_INTF_RESET_ENABLE "NXP_DWP_INTF_RESET_ENABLE"
+#define NAME_NXP_CORE_STANDBY "NXP_CORE_STANDBY"
+#define NAME_NXPLOG_HAL_LOGLEVEL "NXPLOG_NCIHAL_LOGLEVEL"
+#define NAME_NXPLOG_EXTNS_LOGLEVEL "NXPLOG_EXTNS_LOGLEVEL"
+#define NAME_NXPLOG_TML_LOGLEVEL "NXPLOG_TML_LOGLEVEL"
+#define NAME_NXPLOG_FWDNLD_LOGLEVEL "NXPLOG_FWDNLD_LOGLEVEL"
+#define NAME_NXPLOG_NCIX_LOGLEVEL "NXPLOG_NCIX_LOGLEVEL"
+#define NAME_NXPLOG_NCIR_LOGLEVEL "NXPLOG_NCIR_LOGLEVEL"
+#endif
+
+class NfcConfig {
+ public:
+  static bool hasKey(const std::string& key);
+  static std::string getString(const std::string& key);
+  static std::string getString(const std::string& key,
+                               std::string default_value);
+  static unsigned getUnsigned(const std::string& key);
+  static unsigned getUnsigned(const std::string& key, unsigned default_value);
+  static std::vector<uint8_t> getBytes(const std::string& key);
+  static void clear();
+
+ private:
+  void loadConfig();
+  static NfcConfig& getInstance();
+  NfcConfig();
+
+  ConfigFile config_;
+};
diff --git a/src/include/nfc_hal_api.h b/src/include/nfc_hal_api.h
new file mode 100755
index 0000000..984acc1
--- /dev/null
+++ b/src/include/nfc_hal_api.h
@@ -0,0 +1,104 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2012-2014 Broadcom Corporation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+/******************************************************************************
+ *
+ *  The original Work has been changed by NXP Semiconductors.
+ *
+ *  Copyright (C) 2015 - 2018 NXP Semiconductors
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ *  NFC Hardware Abstraction Layer API
+ *
+ ******************************************************************************/
+#ifndef NFC_HAL_API_H
+#define NFC_HAL_API_H
+#include <hardware/nfc.h>
+#include "data_types.h"
+#include "nfc_hal_target.h"
+#include "hal_nxpnfc.h"
+
+typedef uint8_t tHAL_NFC_STATUS;
+typedef void(tHAL_NFC_STATUS_CBACK)(tHAL_NFC_STATUS status);
+typedef void(tHAL_NFC_CBACK)(uint8_t event, tHAL_NFC_STATUS status);
+typedef void(tHAL_NFC_DATA_CBACK)(uint16_t data_len, uint8_t* p_data);
+
+/*******************************************************************************
+** tHAL_NFC_ENTRY HAL entry-point lookup table
+*******************************************************************************/
+
+typedef void(tHAL_API_INITIALIZE)(void);
+typedef void(tHAL_API_TERMINATE)(void);
+typedef void(tHAL_API_OPEN)(tHAL_NFC_CBACK* p_hal_cback,
+                            tHAL_NFC_DATA_CBACK* p_data_cback);
+typedef void(tHAL_API_CLOSE)(void);
+typedef void(tHAL_API_CORE_INITIALIZED)(uint16_t data_len,
+                                        uint8_t* p_core_init_rsp_params);
+typedef void(tHAL_API_WRITE)(uint16_t data_len, uint8_t* p_data);
+typedef bool(tHAL_API_PREDISCOVER)(void);
+typedef void(tHAL_API_CONTROL_GRANTED)(void);
+typedef void(tHAL_API_POWER_CYCLE)(void);
+typedef uint8_t(tHAL_API_GET_MAX_NFCEE)(void);
+#if (NXP_EXTNS == TRUE)
+typedef int(tHAL_API_IOCTL)(long arg, void* p_data);
+typedef int(tHAL_API_GET_FW_DWNLD_FLAG)(uint8_t* fwDnldRequest);
+#endif
+
+typedef struct {
+  tHAL_API_INITIALIZE* initialize;
+  tHAL_API_TERMINATE* terminate;
+  tHAL_API_OPEN* open;
+  tHAL_API_CLOSE* close;
+  tHAL_API_CORE_INITIALIZED* core_initialized;
+  tHAL_API_WRITE* write;
+  tHAL_API_PREDISCOVER* prediscover;
+  tHAL_API_CONTROL_GRANTED* control_granted;
+  tHAL_API_POWER_CYCLE* power_cycle;
+  tHAL_API_GET_MAX_NFCEE* get_max_ee;
+#if (NXP_EXTNS == TRUE)
+  tHAL_API_IOCTL* ioctl;
+  tHAL_API_GET_FW_DWNLD_FLAG* check_fw_dwnld_flag;
+#endif
+} tHAL_NFC_ENTRY;
+
+#if (NXP_EXTNS == TRUE)
+typedef struct {
+  tHAL_NFC_ENTRY* hal_entry_func;
+  uint8_t boot_mode;
+  bool    isLowRam;
+} tHAL_NFC_CONTEXT;
+#endif
+/*******************************************************************************
+** HAL API Function Prototypes
+*******************************************************************************/
+
+#endif /* NFC_HAL_API_H  */
diff --git a/src/include/nfc_hal_int.h b/src/include/nfc_hal_int.h
new file mode 100755
index 0000000..2d65097
--- /dev/null
+++ b/src/include/nfc_hal_int.h
@@ -0,0 +1,276 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2009-2014 Broadcom Corporation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ *  this file contains the NCI transport internal definitions and functions.
+ *
+ ******************************************************************************/
+
+#ifndef NFC_HAL_INT_H
+#define NFC_HAL_INT_H
+
+#include "nfc_hal_target.h"
+#include "gki.h"
+#include "nci_defs.h"
+#include "nfc_brcm_defs.h"
+#include "nfc_hal_api.h"
+#include "nfc_hal_int_api.h"
+
+using android::base::StringPrintf;
+
+/* NFC HAL Task Timer events */
+#ifndef NFC_HAL_QUICK_TIMER_EVT_MASK
+#define NFC_HAL_QUICK_TIMER_EVT_MASK (TIMER_0_EVT_MASK)
+#endif
+
+#ifndef NFC_HAL_QUICK_TIMER_ID
+#define NFC_HAL_QUICK_TIMER_ID (TIMER_0)
+#endif
+
+typedef uint8_t tNFC_HAL_WAIT_RSP;
+
+#if (NFC_HAL_HCI_INCLUDED == true)
+
+#endif
+
+/* NFC HAL transport configuration */
+typedef struct {
+  bool shared_transport; /* true if using shared HCI/NCI transport */
+  uint8_t userial_baud;
+  uint8_t userial_fc;
+} tNFC_HAL_TRANS_CFG;
+
+#ifdef TESTER
+/* For Insight, ncit_cfg is runtime-configurable */
+#define NFC_HAL_TRANS_CFG_QUALIFIER
+#else
+/* For all other platforms, ncit_cfg is constant */
+#define NFC_HAL_TRANS_CFG_QUALIFIER const
+#endif
+extern NFC_HAL_TRANS_CFG_QUALIFIER tNFC_HAL_TRANS_CFG nfc_hal_trans_cfg;
+
+/****************************************************************************
+** Internal constants and definitions
+****************************************************************************/
+
+typedef uint8_t tNFC_HAL_NCI_RAS;
+
+typedef uint8_t tNFC_HAL_POWER_MODE;
+
+#define NFC_HAL_SAVED_HDR_SIZE (2)
+#define NFC_HAL_SAVED_CMD_SIZE (2)
+
+#ifndef NFC_HAL_DEBUG
+#define NFC_HAL_DEBUG true
+#endif
+
+#if (NFC_HAL_DEBUG == true)
+extern bool nfc_debug_enabled;
+extern const char* const nfc_hal_init_state_str[];
+#define NFC_HAL_SET_INIT_STATE(state)                                        \
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(                          \
+      "init state: %d->%d(%s)", nfc_hal_cb.dev_cb.initializing_state, state, \
+      nfc_hal_init_state_str[state]);
+  nfc_hal_cb.dev_cb.initializing_state = state;
+#else
+#define NFC_HAL_SET_INIT_STATE(state) \
+  nfc_hal_cb.dev_cb.initializing_state = state;
+#endif
+
+typedef uint8_t tNFC_HAL_INIT_STATE;
+
+typedef uint8_t tNFC_HAL_DM_CONFIG;
+
+/* callback function prototype */
+typedef struct {
+  uint16_t opcode;
+  uint16_t param_len;
+  uint8_t* p_param_buf;
+} tNFC_HAL_BTVSC_CPLT;
+
+#if (NFC_HAL_HCI_INCLUDED == true)
+
+/* data type for NFC_HAL_HCI_RSP_NV_READ_EVT */
+typedef struct {
+  NFC_HDR hdr;
+  uint8_t block;
+  uint16_t size;
+  tHAL_NFC_STATUS status;
+} tNFC_HAL_HCI_RSP_NV_READ_EVT;
+
+/* data type for NFC_HAL_HCI_RSP_NV_WRITE_EVT */
+typedef struct {
+  NFC_HDR hdr;
+  tHAL_NFC_STATUS status;
+} tNFC_HAL_HCI_RSP_NV_WRITE_EVT;
+
+/* union of all event data types */
+typedef union {
+  NFC_HDR hdr;
+  /* Internal events */
+  tNFC_HAL_HCI_RSP_NV_READ_EVT nv_read;
+  tNFC_HAL_HCI_RSP_NV_WRITE_EVT nv_write;
+} tNFC_HAL_HCI_EVENT_DATA;
+
+#endif
+/*****************************************************************************
+** Control block for NFC HAL
+*****************************************************************************/
+
+/* Information about current patch in NVM */
+typedef struct {
+  uint16_t project_id; /* Current project_id of patch in nvm       */
+  uint16_t ver_major;  /* Current major version of patch in nvm    */
+  uint16_t ver_minor;  /* Current minor version of patch in nvm    */
+  uint16_t fpm_size;   /* Current size of FPM patch in nvm         */
+  uint16_t lpm_size;   /* Current size of LPM patch in nvm         */
+  uint8_t flags;       /* See NFC_HAL_NVM_FLAGS_* flag definitions */
+  uint8_t nvm_type;    /* Current NVM Type - UICC/EEPROM           */
+  uint8_t chip_ver[NFC_HAL_PRM_MAX_CHIP_VER_LEN]; /* patch chip version       */
+} tNFC_HAL_NVM;
+
+/* Patch for I2C fix */
+typedef struct {
+  uint8_t* p_patch;      /* patch for i2c fix                */
+  uint32_t prei2c_delay; /* the dealy after preI2C patch */
+  uint16_t len;          /* i2c patch length                 */
+} tNFC_HAL_PRM_I2C_FIX_CB;
+
+/* Control block for NCI transport */
+typedef struct {
+  uint8_t nci_ctrl_size; /* Max size for NCI messages */
+  uint8_t rcv_state;     /* current rx state */
+  uint16_t rcv_len; /* bytes remaining to be received in current rx state     */
+  NFC_HDR* p_rcv_msg;  /* buffer to receive NCI message */
+  NFC_HDR* p_frag_msg; /* fragmented NCI message; waiting for last fragment */
+  NFC_HDR*
+      p_pend_cmd; /* pending NCI message; waiting for NFCC state to be free */
+  tNFC_HAL_NCI_RAS nci_ras; /* nci reassembly error status */
+  TIMER_LIST_ENT
+  nci_wait_rsp_timer; /* Timer for waiting for nci command response */
+  tNFC_HAL_WAIT_RSP nci_wait_rsp; /* nci wait response flag */
+  uint8_t
+      last_hdr[NFC_HAL_SAVED_HDR_SIZE]; /* part of last NCI command header */
+  uint8_t
+      last_cmd[NFC_HAL_SAVED_CMD_SIZE]; /* part of last NCI command payload */
+  void* p_vsc_cback; /* the callback function for last VSC command */
+} tNFC_HAL_NCIT_CB;
+
+/* Control block for device initialization */
+typedef struct {
+  tNFC_HAL_INIT_STATE initializing_state; /* state of initializing NFCC */
+
+  uint32_t brcm_hw_id; /* BRCM NFCC HW ID                          */
+  tNFC_HAL_DM_CONFIG next_dm_config; /* next config in post initialization */
+  uint8_t next_startup_vsc; /* next start-up VSC offset in post init    */
+
+  tNFC_HAL_POWER_MODE power_mode; /* NFCC power mode                          */
+  uint8_t snooze_mode;            /* current snooze mode                      */
+  uint8_t new_snooze_mode;        /* next snooze mode after receiving cmpl    */
+  uint8_t nfc_wake_active_mode;   /* NFC_HAL_LP_ACTIVE_LOW/HIGH               */
+  TIMER_LIST_ENT lp_timer;        /* timer for low power mode                 */
+
+  tHAL_NFC_STATUS_CBACK*
+      p_prop_cback; /* callback to notify complete of proprietary update */
+} tNFC_HAL_DEV_CB;
+
+#if (NFC_HAL_HCI_INCLUDED == true)
+
+/* data members for NFC_HAL-HCI */
+typedef struct {
+  TIMER_LIST_ENT
+  hci_timer; /* Timer to avoid indefinitely waiting for response */
+  uint8_t*
+      p_hci_netwk_info_buf; /* Buffer for reading HCI Network information */
+  uint8_t* p_hci_netwk_dh_info_buf; /* Buffer for reading HCI Network DH
+                                       information */
+  uint8_t hci_netwk_config_block;  /* Rsp awaiting for hci network configuration
+                                      block */
+  bool b_wait_hcp_conn_create_rsp; /* Waiting for hcp connection create response
+                                      */
+  bool clear_all_pipes_to_uicc1;   /* UICC1 was restarted for patch download */
+  bool update_session_id; /* Next response from NFCC is to Get Session id cmd */
+  bool hci_fw_validate_netwk_cmd; /* Flag to indicate if hci network ntf to
+                                     validate */
+  uint8_t hcp_conn_id;            /* NCI Connection id for HCP */
+  uint8_t dh_session_id[1];       /* Byte 0 of DH Session ID */
+} tNFC_HAL_HCI_CB;
+
+#endif
+
+typedef struct {
+  tHAL_NFC_CBACK* p_stack_cback;     /* Callback for HAL event notification  */
+  tHAL_NFC_DATA_CBACK* p_data_cback; /* Callback for data event notification  */
+
+  TIMER_LIST_Q quick_timer_queue; /* timer list queue                 */
+  TIMER_LIST_ENT timer;           /* timer for NCI transport task     */
+
+  tNFC_HAL_NCIT_CB ncit_cb; /* NCI transport */
+  tNFC_HAL_DEV_CB dev_cb;   /* device initialization */
+  tNFC_HAL_NVM nvm_cb;      /* Information about current patch in NVM */
+
+  /* Patchram control block */
+  tNFC_HAL_PRM_CB prm;
+  tNFC_HAL_PRM_I2C_FIX_CB prm_i2c;
+
+#if (NFC_HAL_HCI_INCLUDED == true)
+  /* data members for NFC_HAL-HCI */
+  tNFC_HAL_HCI_CB hci_cb;
+#endif
+
+  uint8_t pre_discover_done; /* true, when the prediscover config is complete */
+  uint8_t pre_set_mem_idx;
+
+  uint8_t max_rf_credits; /* NFC Max RF data credits */
+  uint8_t max_ee;         /* NFC Max number of NFCEE supported by NFCC */
+} tNFC_HAL_CB;
+
+/* Global NCI data */
+extern tNFC_HAL_CB nfc_hal_cb;
+
+extern uint8_t* p_nfc_hal_pre_discover_cfg;
+
+/****************************************************************************
+** Internal nfc functions
+****************************************************************************/
+
+#if (NFC_HAL_HCI_INCLUDED == true)
+/* nfc_hal_hci.c */
+void nfc_hal_hci_enable(void);
+void nfc_hal_hci_evt_hdlr(tNFC_HAL_HCI_EVENT_DATA* p_evt_data);
+
+void nfc_hal_hci_handle_build_info(uint8_t chipverlen, uint8_t* p_chipverstr);
+#else
+#define nfc_hal_hci_enable() NFC_HAL_SET_INIT_STATE(NFC_HAL_INIT_STATE_IDLE);
+#define nfc_hal_hci_handle_build_info(p, a)
+#define nfc_hal_hci_evt_hdlr(p) ;
+#endif
+
+/* Define default NCI protocol trace function (if protocol tracing is enabled)
+ */
+#if (NFC_HAL_TRACE_PROTOCOL == true)
+#if !defined(DISP_NCI)
+#define DISP_NCI (DispNci)
+void DispNci(uint8_t* p, uint16_t len, bool is_recv);
+#endif /* DISP_NCI */
+
+#endif /* NFC_HAL_TRACE_PROTOCOL */
+
+
+#endif /* NFC_HAL_INT_H */
diff --git a/src/include/nfc_hal_int_api.h b/src/include/nfc_hal_int_api.h
new file mode 100755
index 0000000..d88d639
--- /dev/null
+++ b/src/include/nfc_hal_int_api.h
@@ -0,0 +1,76 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2009-2014 Broadcom Corporation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ *  Internal NFC HAL API functions.
+ *
+ ******************************************************************************/
+#ifndef NFC_HAL_INT_API_H
+#define NFC_HAL_INT_API_H
+
+/****************************************************************************
+** Device Configuration definitions
+****************************************************************************/
+
+/* Broadcom specific device initialization before sending NCI reset */
+
+typedef struct {
+  uint32_t brcm_hw_id;
+  uint16_t xtal_freq;
+  uint8_t xtal_index;
+} tNFC_HAL_DEV_INIT_XTAL_CFG;
+
+#define NFC_HAL_DEV_INIT_MAX_XTAL_CFG 5
+
+/*****************************************************************************
+**  Patch RAM Constants
+*****************************************************************************/
+
+/* patch format type */
+typedef uint8_t tNFC_HAL_PRM_FORMAT;
+
+/*****************************************************************************
+**  Patch RAM Callback for event notificaton
+*****************************************************************************/
+
+typedef uint8_t tNFC_HAL_NCI_EVT; /* MT + Opcode */
+/*******************************************************************************
+**
+** Function         HAL_NfcPrmSetSpdNciCmdPayloadSize
+**
+** Description      Set Host-to-NFCC NCI message size for secure patch download
+**
+**                  This API must be called before calling
+**                  HAL_NfcPrmDownloadStart. If the API is not called, then PRM
+**                  will use the default message size.
+**
+**                  Typically, this API is only called for platforms that have
+**                  message-size limitations in the transport/driver.
+**
+**                  Valid message size range:
+**                  NFC_HAL_PRM_MIN_NCI_CMD_PAYLOAD_SIZE to 255.
+**
+** Returns          HAL_NFC_STATUS_OK if successful
+**                  HAL_NFC_STATUS_FAILED otherwise
+**
+**
+*******************************************************************************/
+tHAL_NFC_STATUS HAL_NfcPrmSetSpdNciCmdPayloadSize(uint8_t max_payload_size);
+
+#endif /* NFC_HAL_INT_API_H */
diff --git a/src/nfca_version.c b/src/include/nfc_hal_nv_ci.h
old mode 100644
new mode 100755
similarity index 59%
rename from src/nfca_version.c
rename to src/include/nfc_hal_nv_ci.h
index 6c83d7d..1740fa0
--- a/src/nfca_version.c
+++ b/src/include/nfc_hal_nv_ci.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- *  Copyright (C) 2012 Broadcom Corporation
+ *  Copyright (C) 2003-2014 Broadcom Corporation
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -15,14 +15,20 @@
  *  limitations under the License.
  *
  ******************************************************************************/
-#include "bt_types.h"
 
-const uint8_t nfca_version_string[] = "NFCDROID-AOSP_M_00.01";
+/******************************************************************************
+ *
+ *  This is the interface file for non valtile memory call-in functions.
+ *
+ ******************************************************************************/
+#ifndef NFC_HAL_NV_CI_H
+#define NFC_HAL_NV_CI_H
+
+#include "nfc_hal_target.h"
+#if (NFC_HAL_HCI_INCLUDED == true)
+
+#include "nfc_hal_nv_co.h"
+
+#endif /* NFC_HAL_HCI_INCLUDED */
 
-/*
-// The following string should be manually updated to contain the
-// label of the NFA version being used (see stack-info.txt).
-//
-// NOTE: IF additional branches are used add a "+" at the end of the string
-*/
-const uint8_t nfa_version_string[] = "NFA_PI_1.03.66+";
+#endif /* NFC_HAL_NV_CI_H */
diff --git a/src/include/nfc_hal_nv_co.h b/src/include/nfc_hal_nv_co.h
new file mode 100755
index 0000000..76a3ccf
--- /dev/null
+++ b/src/include/nfc_hal_nv_co.h
@@ -0,0 +1,57 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2003-2014 Broadcom Corporation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ *  This is the interface file for storing nv data
+ *
+ ******************************************************************************/
+#ifndef NFC_HAL_NV_CO_H
+#define NFC_HAL_NV_CO_H
+
+#include "nfc_hal_target.h"
+#if (NFC_HAL_HCI_INCLUDED == true)
+
+#include <time.h>
+
+/*****************************************************************************
+**  Constants and Data Types
+*****************************************************************************/
+
+/**************************
+**  Common Definitions
+***************************/
+
+typedef uint8_t tNFC_HAL_NV_CO_STATUS;
+
+#define DH_NV_BLOCK 0x01
+#define HC_F3_NV_BLOCK 0x02
+#define HC_F4_NV_BLOCK 0x03
+#define HC_F2_NV_BLOCK 0x04
+#define HC_F5_NV_BLOCK 0x05
+
+/*****************************************************************************
+**  Function Declarations
+*****************************************************************************/
+
+extern void nfa_nv_ci_read(uint16_t num_bytes_read, tNFA_NV_CO_STATUS status,
+                           uint8_t block);
+extern void nfa_nv_ci_write(tNFA_NV_CO_STATUS status);
+
+#endif /* NFC_HAL_HCI_INCLUDED */
+#endif /* NFC_HAL_NV_CO_H */
diff --git a/src/hal/int/nfc_hal_post_reset.h b/src/include/nfc_hal_post_reset.h
similarity index 88%
rename from src/hal/int/nfc_hal_post_reset.h
rename to src/include/nfc_hal_post_reset.h
index 7ce3953..cc703a1 100644
--- a/src/hal/int/nfc_hal_post_reset.h
+++ b/src/include/nfc_hal_post_reset.h
@@ -28,7 +28,6 @@
 ** Application control block definitions
 ******************************************************************************/
 #define NFA_APP_PATCHFILE_MAX_PATH 255
-#define NFA_APP_MAX_NUM_REINIT 5
 
 typedef struct {
   uint8_t prm_file[NFA_APP_PATCHFILE_MAX_PATH + 1]; /* Filename of patchram */
@@ -61,13 +60,4 @@ typedef struct {
 } tNFC_POST_RESET_CB;
 extern tNFC_POST_RESET_CB nfc_post_reset_cb;
 
-/*
-** Post NCI reset handler
-**
-** This function is called to start device pre-initialization after
-** NCI CORE-RESET. When pre-initialization is completed,
-** HAL_NfcPreInitDone() must be called to proceed with stack start up.
-*/
-void nfc_hal_post_reset_init(uint32_t brcm_hw_id, uint8_t nvm_type);
-
 #endif /* NFC_HAL_POST_RESET_H */
diff --git a/src/include/nfc_hal_target.h b/src/include/nfc_hal_target.h
new file mode 100755
index 0000000..9ad8946
--- /dev/null
+++ b/src/include/nfc_hal_target.h
@@ -0,0 +1,163 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2012-2014 Broadcom Corporation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#ifndef NFC_HAL_TARGET_H
+#define NFC_HAL_TARGET_H
+
+#include "data_types.h"
+#include "gki.h"
+
+/****************************************************************************
+** NCI related configuration
+****************************************************************************/
+
+/* Initial Max Control Packet Payload Size (until receiving payload size in
+ * INIT_CORE_RSP) */
+#ifndef NFC_HAL_NCI_INIT_CTRL_PAYLOAD_SIZE
+#define NFC_HAL_NCI_INIT_CTRL_PAYLOAD_SIZE 0xFF
+#endif
+
+/* Number of bytes to reserve in front of NCI messages (e.g. for transport
+ * header) */
+#ifndef NFC_HAL_NCI_MSG_OFFSET_SIZE
+#define NFC_HAL_NCI_MSG_OFFSET_SIZE 1
+#endif
+
+/* NFC-WAKE */
+#ifndef NFC_HAL_LP_NFC_WAKE_GPIO
+#define NFC_HAL_LP_NFC_WAKE_GPIO UPIO_GENERAL3
+#endif
+
+/* NFCC snooze mode idle timeout before deassert NFC_WAKE in ms */
+#ifndef NFC_HAL_LP_IDLE_TIMEOUT
+#define NFC_HAL_LP_IDLE_TIMEOUT 100
+#endif
+
+/* NFC snooze mode */
+#ifndef NFC_HAL_LP_SNOOZE_MODE
+#define NFC_HAL_LP_SNOOZE_MODE NFC_HAL_LP_SNOOZE_MODE_UART
+#endif
+
+/* Idle Threshold Host in 100ms unit */
+#ifndef NFC_HAL_LP_IDLE_THRESHOLD_HOST
+#define NFC_HAL_LP_IDLE_THRESHOLD_HOST 0
+#endif
+
+/* Idle Threshold HC in 100ms unit */
+#ifndef NFC_HAL_LP_IDLE_THRESHOLD_HC
+#define NFC_HAL_LP_IDLE_THRESHOLD_HC 0
+#endif
+
+/* Default NFCC power-up baud rate */
+#ifndef NFC_HAL_DEFAULT_BAUD
+#define NFC_HAL_DEFAULT_BAUD USERIAL_BAUD_115200
+#endif
+
+/* time (in ms) between power off and on NFCC */
+#ifndef NFC_HAL_POWER_CYCLE_DELAY
+#define NFC_HAL_POWER_CYCLE_DELAY 100
+#endif
+
+/* time (in ms) between power off and on NFCC */
+#ifndef NFC_HAL_NFCC_ENABLE_TIMEOUT
+#define NFC_HAL_NFCC_ENABLE_TIMEOUT 1000
+#endif
+
+#ifndef NFC_HAL_PRM_DEBUG
+#define NFC_HAL_PRM_DEBUG TRUE
+#endif
+
+/* max patch data length (Can be overridden by platform for ACL HCI command
+ * size) */
+#ifndef NFC_HAL_PRM_HCD_CMD_MAXLEN
+#define NFC_HAL_PRM_HCD_CMD_MAXLEN 250
+#endif
+
+/* Require PreI2C patch by default */
+#ifndef NFC_HAL_PRE_I2C_PATCH_INCLUDED
+#define NFC_HAL_PRE_I2C_PATCH_INCLUDED TRUE
+#endif
+
+/* over-riden for platforms that have transport packet limitations */
+#ifndef NFC_HAL_PRM_MIN_NCI_CMD_PAYLOAD_SIZE
+#define NFC_HAL_PRM_MIN_NCI_CMD_PAYLOAD_SIZE (32)
+#endif
+
+/* amount of time to wait for authenticating/committing patch to NVM */
+#ifndef NFC_HAL_PRM_COMMIT_DELAY
+#define NFC_HAL_PRM_COMMIT_DELAY (30000)
+#endif
+
+/* amount of time to wait after downloading preI2C patch before downloading
+ * LPM/FPM patch */
+#ifndef NFC_HAL_PRM_POST_I2C_FIX_DELAY
+#define NFC_HAL_PRM_POST_I2C_FIX_DELAY (200)
+#endif
+
+/* NFCC will respond to more than one technology during listen discovery  */
+#ifndef NFC_HAL_DM_MULTI_TECH_RESP
+#define NFC_HAL_DM_MULTI_TECH_RESP TRUE
+#endif
+
+/* Data rate for 15693 command/response, it must be same as
+ * RW_I93_FLAG_DATA_RATE in nfc_target.h */
+#define NFC_HAL_I93_FLAG_DATA_RATE_HIGH 0x02
+
+#ifndef NFC_HAL_I93_FLAG_DATA_RATE
+#define NFC_HAL_I93_FLAG_DATA_RATE NFC_HAL_I93_FLAG_DATA_RATE_HIGH
+#endif
+
+/* NFC HAL HCI */
+#ifndef NFC_HAL_HCI_INCLUDED
+#define NFC_HAL_HCI_INCLUDED TRUE
+#endif
+
+/* Quick Timer */
+#ifndef QUICK_TIMER_TICKS_PER_SEC
+#define QUICK_TIMER_TICKS_PER_SEC 100 /* 10ms timer */
+#endif
+
+#ifndef NFC_HAL_SHARED_TRANSPORT_ENABLED
+#define NFC_HAL_SHARED_TRANSPORT_ENABLED FALSE
+#endif
+
+/* Enable verbose tracing by default */
+#ifndef NFC_HAL_TRACE_VERBOSE
+#define NFC_HAL_TRACE_VERBOSE TRUE
+#endif
+
+#ifndef NFC_HAL_INITIAL_TRACE_LEVEL
+#define NFC_HAL_INITIAL_TRACE_LEVEL 5
+#endif
+
+/* Map NFC serial port to USERIAL_PORT_6 by default */
+#ifndef USERIAL_NFC_PORT
+#define USERIAL_NFC_PORT (USERIAL_PORT_6)
+#endif
+
+/* Restore NFCC baud rate to default on shutdown if baud rate was updated */
+#ifndef NFC_HAL_RESTORE_BAUD_ON_SHUTDOWN
+#define NFC_HAL_RESTORE_BAUD_ON_SHUTDOWN TRUE
+#endif
+
+/* Enable protocol tracing by default */
+#ifndef NFC_HAL_TRACE_PROTOCOL
+#define NFC_HAL_TRACE_PROTOCOL TRUE
+#endif
+
+#endif /* GKI_TARGET_H */
\ No newline at end of file
diff --git a/src/include/nfc_target.h b/src/include/nfc_target.h
old mode 100644
new mode 100755
index c7ca261..d90a303
--- a/src/include/nfc_target.h
+++ b/src/include/nfc_target.h
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -47,9 +47,6 @@
 #include "gki_target.h"
 
 #include "bt_types.h" /* This must be defined AFTER buildcfg.h */
-#ifndef LMP_TEST
-#include "bt_trace.h"
-#endif
 
 #ifndef USERIAL_DEBUG
 #define USERIAL_DEBUG false
@@ -153,6 +150,17 @@
 #define NFC_HAL_NCI_POOL_BUF_SIZE NFC_NCI_POOL_BUF_SIZE
 #endif
 
+#if (NXP_EXTNS == TRUE)
+/* WIRED Mode pool */
+#ifndef NFC_WIRED_POOL_ID
+#define NFC_WIRED_POOL_ID GKI_POOL_ID_4
+#endif
+
+#ifndef NFC_WIRED_POOL_SIZE
+#define NFC_WIRED_POOL_SIZE GKI_BUF4_SIZE
+#endif
+
+#endif
 /******************************************************************************
 **
 ** NCI Transport definitions
@@ -177,15 +185,12 @@
 
 #define NCI_VERSION_UNKNOWN 0x00
 #define NCI_VERSION_1_0     0x10
-#define NCI_VERSION_1_1     0x11
 #define NCI_VERSION_2_0     0x20
 
 #ifndef NCI_VERSION
-//#define NCI_VERSION NCI_VERSION_1_0
 #define NCI_VERSION NCI_VERSION_2_0
 #endif
 #define NCI_CORE_RESET_RSP_LEN(X) (((X) == NCI_VERSION_2_0)?(0x01) : (0x03))
-#define NCI_VERSION_0_F 0x0F
 /* true I2C patch is needed */
 #ifndef NFC_I2C_PATCH_INCLUDED
 #define NFC_I2C_PATCH_INCLUDED true /* NFC-Android uses this!!! */
@@ -699,7 +704,7 @@
 #ifndef HAL_WRITE
 #define HAL_WRITE(p)                                            \
   {                                                             \
-    nfc_cb.p_hal->write(p->len, (uint8_t*)(p + 1) + p->offset); \
+    nfc_cb.p_hal->write((p)->len, (uint8_t*)((p) + 1) + (p)->offset); \
     GKI_freebuf(p);                                             \
   }
 #if (NXP_EXTNS == TRUE)
diff --git a/src/include/nfc_types.h b/src/include/nfc_types.h
new file mode 100755
index 0000000..4d5d6ea
--- /dev/null
+++ b/src/include/nfc_types.h
@@ -0,0 +1,180 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2012-2014 Broadcom Corporation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+/******************************************************************************
+ *
+ *  The original Work has been changed by NXP Semiconductors.
+ *
+ *  Copyright 2018 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#ifndef NFC_TYPES_H
+#define NFC_TYPES_H
+#include "Nxp_Features.h"
+/****************************************************************************
+** NFC_HDR header definition for NFC messages
+*****************************************************************************/
+typedef struct {
+  uint16_t event;
+  uint16_t len;
+  uint16_t offset;
+  uint16_t layer_specific;
+} NFC_HDR;
+#define NFC_HDR_SIZE (sizeof(NFC_HDR))
+
+/* Mask for NFC_HDR event field */
+#define NFC_EVT_MASK 0xFF00
+
+/****************************************************************************
+** NFC_HAL_TASK  definitions
+*****************************************************************************/
+
+/* NCI message for hci persistency data     */
+#define NFC_HAL_EVT_HCI 0x0400
+/* NCI message for sending to host stack    */
+#define NFC_EVT_TO_NFC_NCI 0x4000
+
+/*****************************************************************************
+** Macros to get and put bytes to and from a stream (Little Endian format).
+*****************************************************************************/
+
+#define UINT32_TO_STREAM(p, u32)     \
+  {                                  \
+    *(p)++ = (uint8_t)(u32);         \
+    *(p)++ = (uint8_t)((u32) >> 8);  \
+    *(p)++ = (uint8_t)((u32) >> 16); \
+    *(p)++ = (uint8_t)((u32) >> 24); \
+  }
+#define UINT16_TO_STREAM(p, u16)    \
+  {                                 \
+    *(p)++ = (uint8_t)(u16);        \
+    *(p)++ = (uint8_t)((u16) >> 8); \
+  }
+#define UINT8_TO_STREAM(p, u8) \
+  { *(p)++ = (uint8_t)(u8); }
+#define INT8_TO_STREAM(p, u8) \
+  { *(p)++ = (int8_t)(u8); }
+
+#define ARRAY8_TO_STREAM(p, a)                                  \
+  {                                                             \
+    int ijk;                                                      \
+    for (ijk = 0; ijk < 8; ijk++) *(p)++ = (uint8_t)(a)[7 - ijk]; \
+  }
+#define ARRAY_TO_STREAM(p, a, len)                            \
+  {                                                           \
+    int ijk;                                                      \
+    for (ijk = 0; ijk < len; ijk++) *(p)++ = (uint8_t)(a)[ijk]; \
+  }
+
+#define STREAM_TO_UINT8(u8, p) \
+  {                            \
+    (u8) = (uint8_t)(*(p));      \
+    (p) += 1;                  \
+  }
+#define STREAM_TO_UINT16(u16, p)                                \
+  {                                                             \
+    (u16) = ((uint16_t)(*(p)) + (((uint16_t)(*((p) + 1))) << 8)); \
+    (p) += 2;                                                   \
+  }
+#define STREAM_TO_UINT32(u32, p)                                    \
+  {                                                                 \
+    (u32) = (((uint32_t)(*(p))) + ((((uint32_t)(*((p) + 1)))) << 8) + \
+           ((((uint32_t)(*((p) + 2)))) << 16) +                     \
+           ((((uint32_t)(*((p) + 3)))) << 24));                     \
+    (p) += 4;                                                       \
+  }
+#define STREAM_TO_ARRAY8(a, p)                   \
+  {                                              \
+    int ijk;                                       \
+    uint8_t* _pa = (uint8_t*)(a) + 7;              \
+    for (ijk = 0; ijk < 8; ijk++) *_pa-- = *(p)++; \
+  }
+#define STREAM_TO_ARRAY(a, p, len)                             \
+  {                                                            \
+    int ijk;                                                         \
+    for (ijk = 0; ijk < len; ijk++) ((uint8_t*)(a))[ijk] = *(p)++; \
+  }
+
+/*****************************************************************************
+** Macros to get and put bytes to and from a stream (Big Endian format)
+*****************************************************************************/
+
+#define UINT32_TO_BE_STREAM(p, u32)  \
+  {                                  \
+    *(p)++ = (uint8_t)((u32) >> 24); \
+    *(p)++ = (uint8_t)((u32) >> 16); \
+    *(p)++ = (uint8_t)((u32) >> 8);  \
+    *(p)++ = (uint8_t)(u32);         \
+  }
+#define UINT24_TO_BE_STREAM(p, u24)  \
+  {                                  \
+    *(p)++ = (uint8_t)((u24) >> 16); \
+    *(p)++ = (uint8_t)((u24) >> 8);  \
+    *(p)++ = (uint8_t)(u24);         \
+  }
+#define UINT16_TO_BE_STREAM(p, u16) \
+  {                                 \
+    *(p)++ = (uint8_t)((u16) >> 8); \
+    *(p)++ = (uint8_t)(u16);        \
+  }
+#define UINT8_TO_BE_STREAM(p, u8) \
+  { *(p)++ = (uint8_t)(u8); }
+#define ARRAY_TO_BE_STREAM(p, a, len)                         \
+  {                                                           \
+    int ijk;                                                      \
+    for (ijk = 0; ijk < len; ijk++) *(p)++ = (uint8_t)a[ijk]; \
+  }
+
+#define BE_STREAM_TO_UINT8(u8, p) \
+  {                               \
+    (u8) = (uint8_t)(*(p));         \
+    (p) += 1;                     \
+  }
+#define BE_STREAM_TO_UINT16(u16, p)                                     \
+  {                                                                     \
+    u16 = (uint16_t)(((uint16_t)(*(p)) << 8) + (uint16_t)(*((p) + 1))); \
+    (p) += 2;                                                           \
+  }
+#define BE_STREAM_TO_UINT32(u32, p)                                    \
+  {                                                                    \
+    (u32) = ((uint32_t)(*((p) + 3)) + ((uint32_t)(*((p) + 2)) << 8) +    \
+           ((uint32_t)(*((p) + 1)) << 16) + ((uint32_t)(*(p)) << 24)); \
+    (p) += 4;                                                          \
+  }
+
+/*****************************************************************************
+** Macros to get and put bytes to and from a field (Big Endian format).
+** These are the same as to stream, except the pointer is not incremented.
+*****************************************************************************/
+
+#define UINT8_TO_BE_FIELD(p, u8) \
+  { *(uint8_t*)(p) = (uint8_t)(u8); }
+
+#endif /* NFC_TYPES_H */
diff --git a/src/include/trace_api.h b/src/include/trace_api.h
deleted file mode 100644
index 2a41951..0000000
--- a/src/include/trace_api.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/******************************************************************************
- *
- *  Copyright (C) 1999-2012 Broadcom Corporation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at:
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-/******************************************************************************
- *
- *  Contains API for BTE Test Tool trace related functions.
- *
- ******************************************************************************/
-
-#ifndef TRACE_API_H
-#define TRACE_API_H
-
-#include "nfc_hal_api.h"
-#include "bt_types.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Trace API Function External Declarations */
-extern void DispT3TagMessage(NFC_HDR* p_msg, bool is_rx);
-extern void DispRWT4Tags(NFC_HDR* p_buf, bool is_rx);
-extern void DispCET4Tags(NFC_HDR* p_buf, bool is_rx);
-extern void DispRWI93Tag(NFC_HDR* p_buf, bool is_rx,
-                         uint8_t command_to_respond);
-
-extern void DispLLCP(NFC_HDR* p_buf, bool is_rx);
-extern void DispHcp(uint8_t* p, uint16_t len, bool is_recv, bool is_first_seg);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* TRACE_API_H */
diff --git a/src/nfa/ce/nfa_ce_act.c b/src/nfa/ce/nfa_ce_act.cc
old mode 100644
new mode 100755
similarity index 93%
rename from src/nfa/ce/nfa_ce_act.c
rename to src/nfa/ce/nfa_ce_act.cc
index 7735e33..f176fad
--- a/src/nfa/ce/nfa_ce_act.c
+++ b/src/nfa/ce/nfa_ce_act.cc
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -41,9 +41,9 @@
  *
  ******************************************************************************/
 #include <string.h>
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
 #include "nfa_ce_int.h"
-#include "nfa_dm_int.h"
-#include "nfa_sys_int.h"
 #include "nfa_mem_co.h"
 #include "ndef_utils.h"
 #include "ce_api.h"
@@ -51,6 +51,9 @@
 #include "nfa_ee_int.h"
 #endif
 
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
 /*****************************************************************************
 * Protocol-specific event handlers
 *****************************************************************************/
@@ -68,25 +71,22 @@ void nfa_ce_handle_t3t_evt(tCE_EVENT event, tCE_DATA* p_ce_data) {
   tNFA_CE_CB* p_cb = &nfa_ce_cb;
   tNFA_CONN_EVT_DATA conn_evt;
 
-  NFA_TRACE_DEBUG1("nfa_ce_handle_t3t_evt: event 0x%x", event);
-#if (NXP_EXTNS == TRUE && NXP_NFCC_HCE_F == TRUE)
-  uint8_t listen_info_idx;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ce_handle_t3t_evt: event 0x%x", event);
+
   /* For the felica on host for nfcFcallback */
-  for (listen_info_idx = 0; listen_info_idx < NFA_CE_LISTEN_INFO_IDX_INVALID;
-       listen_info_idx++) {
-    if ((p_cb->listen_info[listen_info_idx].flags &
+  for (uint8_t idx = 0; idx < NFA_CE_LISTEN_INFO_IDX_INVALID; idx++) {
+    if ((p_cb->listen_info[idx].flags &
          NFA_CE_LISTEN_INFO_IN_USE) &&
-        (p_cb->listen_info[listen_info_idx].flags &
+        (p_cb->listen_info[idx].flags &
          NFA_CE_LISTEN_INFO_FELICA) &&
-        (p_cb->listen_info[listen_info_idx].flags &
+        (p_cb->listen_info[idx].flags &
          NFA_CE_LISTEN_INFO_T3T_ACTIVATE_PND)) {
-      p_cb->idx_cur_active = listen_info_idx;
+      p_cb->idx_cur_active = idx;
       p_cb->p_active_conn_cback =
           p_cb->listen_info[p_cb->idx_cur_active].p_conn_cback;
       break;
     }
   }
-#endif
 
   switch (event) {
     case CE_T3T_NDEF_UPDATE_START_EVT:
@@ -95,7 +95,7 @@ void nfa_ce_handle_t3t_evt(tCE_EVENT event, tCE_DATA* p_ce_data) {
         conn_evt.status = NFA_STATUS_OK;
         (*p_cb->p_active_conn_cback)(NFA_CE_NDEF_WRITE_START_EVT, &conn_evt);
       } else {
-        NFA_TRACE_ERROR0(
+        LOG(ERROR) << StringPrintf(
             "nfa_ce_handle_t3t_evt: got CE_T3T_UPDATE_START_EVT, but no active "
             "NDEF");
       }
@@ -109,7 +109,7 @@ void nfa_ce_handle_t3t_evt(tCE_EVENT event, tCE_DATA* p_ce_data) {
         conn_evt.ndef_write_cplt.p_data = p_ce_data->update_info.p_data;
         (*p_cb->p_active_conn_cback)(NFA_CE_NDEF_WRITE_CPLT_EVT, &conn_evt);
       } else {
-        NFA_TRACE_ERROR0(
+        LOG(ERROR) << StringPrintf(
             "nfa_ce_handle_t3t_evt: got CE_T3T_UPDATE_CPLT_EVT, but no active "
             "NDEF");
       }
@@ -123,7 +123,6 @@ void nfa_ce_handle_t3t_evt(tCE_EVENT event, tCE_DATA* p_ce_data) {
         conn_evt.data.len = p_ce_data->raw_frame.p_data->len;
         (*p_cb->p_active_conn_cback)(NFA_DATA_EVT, &conn_evt);
       } else {
-#if (NXP_EXTNS == TRUE && NXP_NFCC_HCE_F == TRUE)
         /* If we have not notified the app of activation, do so now */
         if (p_cb->listen_info[p_cb->idx_cur_active].flags &
             NFA_CE_LISTEN_INFO_T3T_ACTIVATE_PND) {
@@ -138,7 +137,6 @@ void nfa_ce_handle_t3t_evt(tCE_EVENT event, tCE_DATA* p_ce_data) {
 
           (*p_cb->p_active_conn_cback)(NFA_CE_ACTIVATED_EVT, &conn_evt);
         }
-#endif
         /* Notify app of t3t raw data */
         conn_evt.ce_data.status = p_ce_data->raw_frame.status;
         conn_evt.ce_data.handle =
@@ -152,7 +150,7 @@ void nfa_ce_handle_t3t_evt(tCE_EVENT event, tCE_DATA* p_ce_data) {
       break;
 
     default:
-      NFA_TRACE_DEBUG1("nfa_ce_handle_t3t_evt unhandled event=0x%02x", event);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ce_handle_t3t_evt unhandled event=0x%02x", event);
       break;
   }
 }
@@ -170,7 +168,7 @@ void nfa_ce_handle_t4t_evt(tCE_EVENT event, tCE_DATA* p_ce_data) {
   tNFA_CE_CB* p_cb = &nfa_ce_cb;
   tNFA_CONN_EVT_DATA conn_evt;
 
-  NFA_TRACE_DEBUG1("nfa_ce_handle_t4t_evt: event 0x%x", event);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ce_handle_t4t_evt: event 0x%x", event);
 
   /* AID for NDEF selected. we had notified the app of activation. */
   p_cb->idx_cur_active = NFA_CE_LISTEN_INFO_IDX_NDEF;
@@ -208,7 +206,7 @@ void nfa_ce_handle_t4t_evt(tCE_EVENT event, tCE_DATA* p_ce_data) {
 
     default:
       /* CE_T4T_RAW_FRAME_EVT is not used in NFA CE */
-      NFA_TRACE_DEBUG1("nfa_ce_handle_t4t_evt unhandled event=0x%02x", event);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ce_handle_t4t_evt unhandled event=0x%02x", event);
       break;
   }
 }
@@ -228,7 +226,7 @@ void nfa_ce_handle_t4t_aid_evt(tCE_EVENT event, tCE_DATA* p_ce_data) {
   uint8_t listen_info_idx;
   tNFA_CONN_EVT_DATA conn_evt;
 
-  NFA_TRACE_DEBUG1("nfa_ce_handle_t4t_aid_evt: event 0x%x", event);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ce_handle_t4t_aid_evt: event 0x%x", event);
 
   /* Get listen_info for this aid callback */
   for (listen_info_idx = 0; listen_info_idx < NFA_CE_LISTEN_INFO_IDX_INVALID;
@@ -273,10 +271,10 @@ void nfa_ce_handle_t4t_aid_evt(tCE_EVENT event, tCE_DATA* p_ce_data) {
       conn_evt.ce_data.len = p_ce_data->raw_frame.p_data->len;
       (*p_cb->p_active_conn_cback)(NFA_CE_DATA_EVT, &conn_evt);
     } else {
-      NFA_TRACE_ERROR1(
+      LOG(ERROR) << StringPrintf(
           "nfa_ce_handle_t4t_aid_evt: unable to find listen_info for aid hdl "
           "%i",
-          p_ce_data->raw_frame.aid_handle)
+          p_ce_data->raw_frame.aid_handle);
     }
 
     GKI_freebuf(p_ce_data->raw_frame.p_data);
@@ -298,11 +296,11 @@ void nfa_ce_handle_t4t_aid_evt(tCE_EVENT event, tCE_DATA* p_ce_data) {
 *******************************************************************************/
 void nfa_ce_discovery_cback(tNFA_DM_RF_DISC_EVT event, tNFC_DISCOVER* p_data) {
   tNFA_CE_MSG ce_msg;
-  NFA_TRACE_DEBUG1("nfa_ce_discovery_cback(): event:0x%02X", event);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ce_discovery_cback(): event:0x%02X", event);
 
   switch (event) {
     case NFA_DM_RF_DISC_START_EVT:
-      NFA_TRACE_DEBUG1("nfa_ce_handle_disc_start (status=0x%x)", p_data->start);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ce_handle_disc_start (status=0x%x)", p_data->start);
       break;
 
     case NFA_DM_RF_DISC_ACTIVATED_EVT:
@@ -315,7 +313,7 @@ void nfa_ce_discovery_cback(tNFA_DM_RF_DISC_EVT event, tNFC_DISCOVER* p_data) {
 #endif
       ce_msg.activate_ntf.hdr.event = NFA_CE_ACTIVATE_NTF_EVT;
       ce_msg.activate_ntf.p_activation_params = &p_data->activate;
-      nfa_ce_hdl_event((void*)&ce_msg);
+      nfa_ce_hdl_event(&ce_msg.hdr);
       break;
 
     case NFA_DM_RF_DISC_DEACTIVATED_EVT:
@@ -328,12 +326,12 @@ void nfa_ce_discovery_cback(tNFA_DM_RF_DISC_EVT event, tNFC_DISCOVER* p_data) {
         /*clear the p61 ce*/
         nfa_ee_ce_p61_active = 0;
 #endif
-        nfa_ce_hdl_event((void*)&ce_msg);
+        nfa_ce_hdl_event(&ce_msg.hdr);
       }
       break;
 
     default:
-      NFA_TRACE_ERROR0("Unexpected event");
+      LOG(ERROR) << StringPrintf("Unexpected event");
       break;
   }
 }
@@ -354,11 +352,9 @@ void nfc_ce_t3t_set_listen_params(void) {
   uint8_t tlv_size;
   uint16_t t3t_flags2_mask = 0xFFFF; /* Mask of which T3T_IDs are disabled */
   uint8_t t3t_idx = 0;
-
-#if (NXP_EXTNS == TRUE && NXP_NFCC_HCE_F == TRUE)
   uint8_t adv_Feat = 1;
-  uint8_t t3tPMM[NCI_T3T_PMM_LEN] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
-#endif
+  uint8_t t3tPMM[NCI_T3T_PMM_LEN] = {0xFF, 0xFF, 0xFF, 0xFF,
+                                     0xFF, 0xFF, 0xFF, 0xFF};
 
   /* Point to start of tlv buffer */
   p_params = tlv;
@@ -369,14 +365,15 @@ void nfc_ce_t3t_set_listen_params(void) {
         (p_cb->listen_info[i].protocol_mask & NFA_PROTOCOL_MASK_T3T)) {
       /* Set tag's system code and NFCID2 */
       UINT8_TO_STREAM(p_params, NFC_PMID_LF_T3T_ID1 + t3t_idx); /* type */
-      UINT8_TO_STREAM(p_params, NCI_PARAM_LEN_LF_T3T_ID(NFC_GetNCIVersion()));       /* length */
+      /* length */
+      UINT8_TO_STREAM(p_params, NCI_PARAM_LEN_LF_T3T_ID(NFC_GetNCIVersion()));
       /* System Code */
       UINT16_TO_BE_STREAM(p_params, p_cb->listen_info[i].t3t_system_code);
       ARRAY_TO_BE_STREAM(p_params, p_cb->listen_info[i].t3t_nfcid2,
                          NCI_RF_F_UID_LEN);
-      if(NFC_GetNCIVersion() == NCI_VERSION_2_0) {
+      if (NFC_GetNCIVersion() == NCI_VERSION_2_0) {
         ARRAY_TO_BE_STREAM(p_params, p_cb->listen_info[i].t3t_pmm,
-                          NCI_T3T_PMM_LEN);
+                           NCI_T3T_PMM_LEN);
       }
       /* Set mask for this ID */
       t3t_flags2_mask &= ~((uint16_t)(1 << t3t_idx));
@@ -387,35 +384,32 @@ void nfc_ce_t3t_set_listen_params(void) {
   /* For NCI draft 22+, the polarity of NFC_PMID_LF_T3T_FLAGS2 is flipped */
   t3t_flags2_mask = ~t3t_flags2_mask;
 
-
+  UINT8_TO_STREAM(p_params, NFC_PMID_LF_T3T_FLAGS2);      /* type */
+  UINT8_TO_STREAM(p_params, NCI_PARAM_LEN_LF_T3T_FLAGS2); /* length */
+  /* Mask of IDs to disable listening */
   if(nfcFL.chipType != pn547C2) {
-      NFA_TRACE_DEBUG0(" LF_T3T_FLAGS swap for NCI specification compliance");
-      t3t_flags2_mask = ((t3t_flags2_mask >> 8) | (t3t_flags2_mask << 8));
+    UINT16_TO_STREAM(p_params, t3t_flags2_mask);
+  }
+  else
+  {
+    UINT16_TO_BE_STREAM(p_params, t3t_flags2_mask);
   }
 
-  UINT8_TO_STREAM(p_params, NFC_PMID_LF_T3T_FLAGS2);      /* type */
-  UINT8_TO_STREAM(p_params, NCI_PARAM_LEN_LF_T3T_FLAGS2); /* length */
-#if ((NXP_EXTNS == TRUE) && (NXP_NFCC_HCE_F == TRUE))
-  // FelicaOnHost
-  UINT16_TO_BE_STREAM(p_params, t3t_flags2_mask);
-  if(NFC_GetNCIVersion() == NCI_VERSION_2_0) {
+  if (NFC_GetNCIVersion() == NCI_VERSION_2_0) {
     /*Name changed in NCI2.0*/
-     UINT8_TO_STREAM (p_params, NCI_PARAM_ID_LF_T3T_RD_ALLOWED);      /* type */
-     UINT8_TO_STREAM (p_params, NCI_PARAM_LEN_LF_T3T_RD_ALLOWED);     /* length */
+    UINT8_TO_STREAM(p_params, NCI_PARAM_ID_LF_T3T_RD_ALLOWED);  /* type */
+    UINT8_TO_STREAM(p_params, NCI_PARAM_LEN_LF_T3T_RD_ALLOWED); /* length */
   } else {
-    UINT8_TO_STREAM (p_params, NCI_PARAM_ID_LF_CON_ADV_FEAT);      /* type */
-    UINT8_TO_STREAM (p_params, NCI_PARAM_LEN_LF_CON_ADV_FEAT);     /* length */
+    UINT8_TO_STREAM(p_params, NCI_PARAM_ID_LF_CON_ADV_FEAT);  /* type */
+    UINT8_TO_STREAM(p_params, NCI_PARAM_LEN_LF_CON_ADV_FEAT); /* length */
   }
-  UINT8_TO_STREAM (p_params, adv_Feat);
+  UINT8_TO_STREAM(p_params, adv_Feat);
 
-  if(NFC_GetNCIVersion() != NCI_VERSION_2_0) {
-    UINT8_TO_STREAM (p_params, NCI_PARAM_ID_LF_T3T_PMM);      /* type */
-    UINT8_TO_STREAM (p_params, NCI_PARAM_LEN_LF_T3T_PMM);     /* length */
+  if (NFC_GetNCIVersion() != NCI_VERSION_2_0) {
+    UINT8_TO_STREAM(p_params, NCI_PARAM_ID_LF_T3T_PMM);  /* type */
+    UINT8_TO_STREAM(p_params, NCI_PARAM_LEN_LF_T3T_PMM); /* length */
+    ARRAY_TO_BE_STREAM(p_params, t3tPMM, NCI_T3T_PMM_LEN);
   }
-#else
-  /* Mask of IDs to disable listening */
-  UINT16_TO_STREAM(p_params, t3t_flags2_mask);
-#endif
   tlv_size = (uint8_t)(p_params - tlv);
   if (appl_dta_mode_flag == 0x01) {
     nfa_dm_cb.eDtaMode |= NFA_DTA_HCEF_MODE;
@@ -465,7 +459,7 @@ tNFA_STATUS nfa_ce_start_listening(void) {
   tNFA_HANDLE disc_handle;
   uint8_t listen_info_idx;
 
-  NFA_TRACE_DEBUG0("nfa_ce_start_listening(): enter");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ce_start_listening(): enter");
   /*************************************************************************/
   /* Construct protocol preference list to listen for */
 
@@ -586,10 +580,10 @@ tNFA_STATUS nfa_ce_start_listening(void) {
           }
         } else {
 #if (NXP_EXTNS == TRUE)
-          NFA_TRACE_ERROR1("UICC/ESE[0x%x] is not activated",
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("UICC/ESE[0x%x] is not activated",
                            p_cb->listen_info[listen_info_idx].ee_handle);
 #else
-          NFA_TRACE_ERROR1("UICC[0x%x] is not activated",
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("UICC[0x%x] is not activated",
                            p_cb->listen_info[listen_info_idx].ee_handle);
 #endif
         }
@@ -597,7 +591,7 @@ tNFA_STATUS nfa_ce_start_listening(void) {
 #endif
     }
   }
-  NFA_TRACE_DEBUG0("nfa_ce_start_listening(): exit");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ce_start_listening(): exit");
   return NFA_STATUS_OK;
 }
 
@@ -650,7 +644,7 @@ void nfa_ce_remove_listen_info_entry(uint8_t listen_info_idx, bool notify_app) {
   tNFA_CE_CB* p_cb = &nfa_ce_cb;
   tNFA_CONN_EVT_DATA conn_evt;
 
-  NFA_TRACE_DEBUG1("NFA_CE: removing listen_info entry %i", listen_info_idx);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_CE: removing listen_info entry %i", listen_info_idx);
 
   /* Notify app that listening has stopped  if requested (for API deregister) */
   /* For LISTEN_START failures, app has already notified of NFA_LISTEN_START_EVT
@@ -776,7 +770,7 @@ tNFA_STATUS nfa_ce_realloc_scratch_buffer(void) {
       if (nfa_ce_cb.p_scratch_buf != NULL) {
         nfa_ce_cb.scratch_buf_size = nfa_ce_cb.ndef_max_size;
       } else {
-        NFA_TRACE_ERROR1(
+        LOG(ERROR) << StringPrintf(
             "Unable to allocate scratch buffer for writable NDEF message (%i "
             "bytes)",
             nfa_ce_cb.ndef_max_size);
@@ -810,7 +804,7 @@ tNFC_STATUS nfa_ce_set_content(void) {
     return (NFA_STATUS_OK);
   }
 
-  NFA_TRACE_DEBUG0("Setting NDEF contents");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Setting NDEF contents");
 
   readonly = (p_cb->listen_info[NFA_CE_LISTEN_INFO_IDX_NDEF].flags &
               NFC_CE_LISTEN_INFO_READONLY_NDEF)
@@ -844,7 +838,7 @@ tNFC_STATUS nfa_ce_set_content(void) {
     CE_T3tSetLocalNDEFMsg(true, 0, 0, NULL, NULL);
     CE_T4tSetLocalNDEFMsg(true, 0, 0, NULL, NULL);
 
-    NFA_TRACE_ERROR1("Unable to set contents (error %02x)", status);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Unable to set contents (error %02x)", status);
   }
 
   return (status);
@@ -874,14 +868,12 @@ bool nfa_ce_activate_ntf(tNFA_CE_MSG* p_ce_msg) {
   uint8_t* p_nfcid2 = NULL;
   uint8_t i;
   bool t4t_activate_pending = false;
-#if (NXP_EXTNS == TRUE)
   bool t3t_activate_pending = false;
   bool t3t_offhost_entry_found = false;
   uint8_t t3t_activate_idx = 0;
   uint8_t t3t_offhost_idx = 0;
-#endif
 
-  NFA_TRACE_DEBUG1("nfa_ce_activate_ntf () protocol=%d",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ce_activate_ntf () protocol=%d",
                    p_ce_msg->activate_ntf.p_activation_params->protocol);
 
   /* Tag is in listen active state */
@@ -899,7 +891,7 @@ bool nfa_ce_activate_ntf(tNFA_CE_MSG* p_ce_msg) {
     for (i = 0; i < NFA_CE_LISTEN_INFO_IDX_INVALID; i++) {
       if (p_cb->listen_info[i].flags & NFA_CE_LISTEN_INFO_UICC) {
         listen_info_idx = i;
-        NFA_TRACE_DEBUG1(
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
             "listen_info found for this activation. listen_info_idx=%d",
             listen_info_idx);
         /* Get CONN_CBACK for this activation */
@@ -951,18 +943,6 @@ bool nfa_ce_activate_ntf(tNFA_CE_MSG* p_ce_msg) {
     }
 
     p_ce_cback = nfa_ce_handle_t3t_evt;
-    /* If listening for PROTO_T3T on DH and eSE/UICC, then notify CE module now
-     * and wait for reader/writer to SELECT a target */
-    if (t3t_activate_pending && t3t_offhost_entry_found) {
-      CE_SetActivatedTagType(&p_cb->activation_params, t3t_system_code,
-                             p_ce_cback);
-      return true;
-    } else if (t3t_activate_pending) {
-      listen_info_idx = t3t_activate_idx;
-    } else if (t3t_offhost_entry_found) {
-      listen_info_idx = t3t_offhost_idx;
-    }
-  }
 #else
   /* Find the listen_info entry corresponding to this activation */
   if (p_cb->activation_params.protocol == NFA_PROTOCOL_T3T) {
@@ -1000,8 +980,19 @@ bool nfa_ce_activate_ntf(tNFA_CE_MSG* p_ce_msg) {
     }
 
     p_ce_cback = nfa_ce_handle_t3t_evt;
-  }
 #endif
+      /* If listening for PROTO_T3T on DH and eSE/UICC, then notify CE module now
+     * and wait for reader/writer to SELECT a target */
+    if (t3t_activate_pending && t3t_offhost_entry_found) {
+      CE_SetActivatedTagType(&p_cb->activation_params, t3t_system_code,
+                             p_ce_cback);
+      return true;
+    } else if (t3t_activate_pending) {
+      listen_info_idx = t3t_activate_idx;
+    } else if (t3t_offhost_entry_found) {
+      listen_info_idx = t3t_offhost_idx;
+    }
+  }
   else if (p_cb->activation_params.protocol == NFA_PROTOCOL_ISO_DEP) {
     p_ce_cback = nfa_ce_handle_t4t_evt;
 
@@ -1097,7 +1088,7 @@ bool nfa_ce_activate_ntf(tNFA_CE_MSG* p_ce_msg) {
       ((listen_info_idx == NFA_CE_LISTEN_INFO_IDX_NDEF) &&
        !(p_cb->listen_info[NFA_CE_LISTEN_INFO_IDX_NDEF].flags &
          NFA_CE_LISTEN_INFO_IN_USE))) {
-    NFA_TRACE_DEBUG1(
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "No listen_info found for this activation. listen_info_idx=%d",
         listen_info_idx);
     return (true);
@@ -1106,10 +1097,8 @@ bool nfa_ce_activate_ntf(tNFA_CE_MSG* p_ce_msg) {
   p_cb->listen_info[listen_info_idx].flags &=
       ~NFA_CE_LISTEN_INFO_T4T_ACTIVATE_PND;
 
-#if (NXP_EXTNS == TRUE)
   p_cb->listen_info[listen_info_idx].flags &=
       ~NFA_CE_LISTEN_INFO_T3T_ACTIVATE_PND;
-#endif
 
   /* Get CONN_CBACK for this activation */
   p_cb->p_active_conn_cback = p_cb->listen_info[listen_info_idx].p_conn_cback;
@@ -1169,7 +1158,7 @@ bool nfa_ce_deactivate_ntf(tNFA_CE_MSG* p_ce_msg) {
   tNFA_CONN_EVT_DATA conn_evt;
   uint8_t i;
 
-  NFA_TRACE_DEBUG1("nfa_ce_deactivate_ntf () deact_type=%d", deact_type);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ce_deactivate_ntf () deact_type=%d", deact_type);
 
   /* Check if deactivating to SLEEP mode */
   if ((deact_type == NFC_DEACTIVATE_TYPE_SLEEP) ||
@@ -1233,11 +1222,9 @@ bool nfa_ce_deactivate_ntf(tNFA_CE_MSG* p_ce_msg) {
         }
       } else if ((p_cb->activation_params.protocol == NFA_PROTOCOL_T3T) &&
                  (p_cb->listen_info[i].protocol_mask & NFA_PROTOCOL_MASK_T3T)) {
-#if (NXP_EXTNS == TRUE)
         /* Don't send NFA_DEACTIVATED_EVT if NFA_ACTIVATED_EVT wasn't sent */
         if (!(p_cb->listen_info[i].flags &
               NFA_CE_LISTEN_INFO_T3T_ACTIVATE_PND)) {
-#endif
           if (i == NFA_CE_LISTEN_INFO_IDX_NDEF) {
             conn_evt.deactivated.type = deact_type;
             if (p_cb->p_active_conn_cback)
@@ -1249,9 +1236,7 @@ bool nfa_ce_deactivate_ntf(tNFA_CE_MSG* p_ce_msg) {
             if (p_cb->p_active_conn_cback)
                 (*p_cb->p_active_conn_cback)(NFA_CE_DEACTIVATED_EVT, &conn_evt);
           }
-#if (NXP_EXTNS == TRUE)
         }
-#endif
       }
     }
   }
@@ -1287,7 +1272,7 @@ void nfa_ce_disable_local_tag(void) {
   tNFA_CE_CB* p_cb = &nfa_ce_cb;
   tNFA_CONN_EVT_DATA evt_data;
 
-  NFA_TRACE_DEBUG0("Disabling local NDEF tag");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Disabling local NDEF tag");
 
   /* If local NDEF tag is in use, then disable it */
   if (p_cb->listen_info[NFA_CE_LISTEN_INFO_IDX_NDEF].flags &
@@ -1337,9 +1322,9 @@ bool nfa_ce_api_cfg_local_tag(tNFA_CE_MSG* p_ce_msg) {
     return true;
   }
 
-  NFA_TRACE_DEBUG5(
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "Configuring local NDEF tag: protocol_mask=%01x cur_size=%i, "
-      "max_size=%i, readonly=%i",
+      "max_size=%i, readonly=%i, uid_len=%i",
       p_ce_msg->local_tag.protocol_mask, p_ce_msg->local_tag.ndef_cur_size,
       p_ce_msg->local_tag.ndef_max_size, p_ce_msg->local_tag.read_only,
       p_ce_msg->local_tag.uid_len);
@@ -1390,7 +1375,7 @@ bool nfa_ce_api_cfg_local_tag(tNFA_CE_MSG* p_ce_msg) {
       (NFA_PROTOCOL_MASK_T3T | NFA_PROTOCOL_MASK_ISO_DEP)) {
     /* Ok to set contents now */
     if (nfa_ce_set_content() != NFA_STATUS_OK) {
-      NFA_TRACE_ERROR0("nfa_ce_api_cfg_local_tag: could not set contents");
+      LOG(ERROR) << StringPrintf("nfa_ce_api_cfg_local_tag: could not set contents");
       nfa_dm_conn_cback_event_notify(NFA_CE_LOCAL_TAG_CONFIGURED_EVT,
                                      &conn_evt);
       return true;
@@ -1421,12 +1406,12 @@ bool nfa_ce_api_reg_listen(tNFA_CE_MSG* p_ce_msg) {
   uint8_t listen_info_idx = NFA_CE_LISTEN_INFO_IDX_INVALID;
 
 #if (NXP_EXTNS == TRUE)
-  NFA_TRACE_DEBUG1(
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "nfa_ce_api_reg_listen ():Registering UICC/ESE/Felica/Type-4 tag "
       "listener. Type=%i",
       p_ce_msg->reg_listen.listen_type);
 #else
-  NFA_TRACE_DEBUG1(
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "nfa_ce_api_reg_listen ():Registering UICC/Felica/Type-4 tag listener. "
       "Type=%i",
       p_ce_msg->reg_listen.listen_type);
@@ -1441,7 +1426,7 @@ bool nfa_ce_api_reg_listen(tNFA_CE_MSG* p_ce_msg) {
         (p_cb->listen_info[i].flags & NFA_CE_LISTEN_INFO_IN_USE) &&
         (p_cb->listen_info[i].flags & NFA_CE_LISTEN_INFO_UICC) &&
         (p_cb->listen_info[i].ee_handle == p_ce_msg->reg_listen.ee_handle)) {
-      NFA_TRACE_ERROR1("UICC (0x%x) listening already specified",
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("UICC (0x%x) listening already specified",
                        p_ce_msg->reg_listen.ee_handle);
       conn_evt.status = NFA_STATUS_FAILED;
       nfa_dm_conn_cback_event_notify(NFA_CE_UICC_LISTEN_CONFIGURED_EVT,
@@ -1455,7 +1440,7 @@ bool nfa_ce_api_reg_listen(tNFA_CE_MSG* p_ce_msg) {
              (p_cb->listen_info[i].ee_handle ==
               p_ce_msg->reg_listen.ee_handle)) {
 
-      NFA_TRACE_ERROR1("ESE (0x%x) listening already specified",
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("ESE (0x%x) listening already specified",
                        p_ce_msg->reg_listen.ee_handle);
       conn_evt.status = NFA_STATUS_FAILED;
       nfa_dm_conn_cback_event_notify(NFA_CE_ESE_LISTEN_CONFIGURED_EVT,
@@ -1467,7 +1452,7 @@ bool nfa_ce_api_reg_listen(tNFA_CE_MSG* p_ce_msg) {
     else if ((!(p_cb->listen_info[i].flags & NFA_CE_LISTEN_INFO_IN_USE)) &&
              (listen_info_idx == NFA_CE_LISTEN_INFO_IDX_INVALID)) {
       listen_info_idx = i;
-      NFA_TRACE_DEBUG1(
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "nfa_ce_api_reg_listen ():found free entry listen_info_idx = %d",
           listen_info_idx);
     }
@@ -1475,7 +1460,7 @@ bool nfa_ce_api_reg_listen(tNFA_CE_MSG* p_ce_msg) {
 
   /* Add new entry to listen_info table */
   if (listen_info_idx == NFA_CE_LISTEN_INFO_IDX_INVALID) {
-    NFA_TRACE_ERROR1("Maximum listen callbacks exceeded (%i)",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Maximum listen callbacks exceeded (%i)",
                      NFA_CE_LISTEN_INFO_MAX);
 
     if (p_ce_msg->reg_listen.listen_type == NFA_CE_REG_TYPE_UICC) {
@@ -1498,7 +1483,7 @@ bool nfa_ce_api_reg_listen(tNFA_CE_MSG* p_ce_msg) {
     }
     return true;
   } else {
-    NFA_TRACE_DEBUG1("NFA_CE: adding listen_info entry %i", listen_info_idx);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_CE: adding listen_info entry %i", listen_info_idx);
 
     /* Store common parameters */
     /* Mark entry as 'in-use', and NFA_CE_LISTEN_INFO_START_NTF_PND */
@@ -1523,7 +1508,7 @@ bool nfa_ce_api_reg_listen(tNFA_CE_MSG* p_ce_msg) {
             nfa_ce_handle_t4t_aid_evt);
         if (p_cb->listen_info[listen_info_idx].t4t_aid_handle ==
             CE_T4T_AID_HANDLE_INVALID) {
-          NFA_TRACE_ERROR0("Unable to register AID");
+          LOG(ERROR) << StringPrintf("Unable to register AID");
           p_cb->listen_info[listen_info_idx].flags = 0;
 
           /* Notify application */
@@ -1552,7 +1537,7 @@ bool nfa_ce_api_reg_listen(tNFA_CE_MSG* p_ce_msg) {
         memcpy(p_cb->listen_info[listen_info_idx].t3t_nfcid2,
                p_ce_msg->reg_listen.nfcid2, NCI_RF_F_UID_LEN);
         memcpy(p_cb->listen_info[listen_info_idx].t3t_pmm,
-                       p_ce_msg->reg_listen.t3tPmm, NCI_T3T_PMM_LEN);
+               p_ce_msg->reg_listen.t3tPmm, NCI_T3T_PMM_LEN);
         break;
 
 #if (NFC_NFCEE_INCLUDED == true)
@@ -1566,7 +1551,7 @@ bool nfa_ce_api_reg_listen(tNFA_CE_MSG* p_ce_msg) {
           if ((p_cb->listen_info[listen_info_idx].flags &
                NFA_CE_LISTEN_INFO_ESE) &&
               (tech)) {
-            NFA_TRACE_ERROR1(
+            LOG(ERROR) << StringPrintf(
                 "NFA_CE: Technology %0x listening already specified for ESE",
                 tech);
             conn_evt.status = NFA_STATUS_FAILED;
@@ -1596,7 +1581,7 @@ bool nfa_ce_api_reg_listen(tNFA_CE_MSG* p_ce_msg) {
           if ((p_cb->listen_info[listen_info_idx].flags &
                NFA_CE_LISTEN_INFO_UICC) &&
               (tech)) {
-            NFA_TRACE_ERROR1(
+            LOG(ERROR) << StringPrintf(
                 "NFA_CE: Technology %0x listening already specified for UICC",
                 tech);
             conn_evt.status = NFA_STATUS_FAILED;
@@ -1625,7 +1610,7 @@ bool nfa_ce_api_reg_listen(tNFA_CE_MSG* p_ce_msg) {
   /* Start listening */
   conn_evt.status = nfa_ce_start_listening();
   if (conn_evt.status != NFA_STATUS_OK) {
-    NFA_TRACE_ERROR0(
+    LOG(ERROR) << StringPrintf(
         "nfa_ce_api_reg_listen: unable to register new listen params with DM");
     p_cb->listen_info[listen_info_idx].flags = 0;
   }
@@ -1643,7 +1628,7 @@ bool nfa_ce_api_reg_listen(tNFA_CE_MSG* p_ce_msg) {
 #endif
   else {
     conn_evt.ce_registered.handle = NFA_HANDLE_GROUP_CE | listen_info_idx;
-    NFA_TRACE_DEBUG1("nfa_ce_api_reg_listen: registered handle 0x%04X",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ce_api_reg_listen: registered handle 0x%04X",
                      conn_evt.ce_registered.handle);
     (*p_cb->listen_info[listen_info_idx].p_conn_cback)(NFA_CE_REGISTERED_EVT,
                                                        &conn_evt);
@@ -1716,7 +1701,7 @@ bool nfa_ce_api_dereg_listen(tNFA_CE_MSG* p_ce_msg) {
     if (listen_info_idx == NFA_CE_LISTEN_INFO_MAX) {
       conn_evt.status = NFA_STATUS_INVALID_PARAM;
 #if (NXP_EXTNS == TRUE)
-      NFA_TRACE_ERROR0(
+      LOG(ERROR) << StringPrintf(
           "nfa_ce_api_dereg_listen (): cannot find listen_info for UICC/ESE");
       if (p_ce_msg->dereg_listen.listen_info & NFA_CE_LISTEN_INFO_UICC) {
         nfa_dm_conn_cback_event_notify(NFA_CE_UICC_LISTEN_CONFIGURED_EVT,
@@ -1726,7 +1711,7 @@ bool nfa_ce_api_dereg_listen(tNFA_CE_MSG* p_ce_msg) {
                                        &conn_evt);
       }
 #else
-      NFA_TRACE_ERROR0(
+      LOG(ERROR) << StringPrintf(
           "nfa_ce_api_dereg_listen (): cannot find listen_info for UICC");
       nfa_dm_conn_cback_event_notify(NFA_CE_UICC_LISTEN_CONFIGURED_EVT,
                                      &conn_evt);
@@ -1764,7 +1749,7 @@ bool nfa_ce_api_dereg_listen(tNFA_CE_MSG* p_ce_msg) {
         nfa_ce_remove_listen_info_entry(listen_info_idx, true);
       }
     } else {
-      NFA_TRACE_ERROR0(
+      LOG(ERROR) << StringPrintf(
           "nfa_ce_api_dereg_listen (): cannot find listen_info for "
           "Felica/T4tAID");
       conn_evt.status = NFA_STATUS_INVALID_PARAM;
diff --git a/src/nfa/ce/nfa_ce_api.c b/src/nfa/ce/nfa_ce_api.cc
similarity index 92%
rename from src/nfa/ce/nfa_ce_api.c
rename to src/nfa/ce/nfa_ce_api.cc
index e516d81..fb15a62 100644
--- a/src/nfa/ce/nfa_ce_api.c
+++ b/src/nfa/ce/nfa_ce_api.cc
@@ -41,10 +41,14 @@
  *
  ******************************************************************************/
 #include <string.h>
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
 #include "nfa_api.h"
-#include "nfa_sys.h"
 #include "nfa_ce_int.h"
-#include "nfa_sys_int.h"
+
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
 
 /*******************************************************************************
 **
@@ -70,7 +74,7 @@ tNFA_STATUS nfa_ce_api_deregister_listen(tNFA_HANDLE handle,
 #endif
        ) &&
       ((handle & NFA_HANDLE_GROUP_MASK) != NFA_HANDLE_GROUP_CE)) {
-    NFA_TRACE_ERROR0("nfa_ce_api_reregister_listen: Invalid handle");
+    LOG(ERROR) << StringPrintf("nfa_ce_api_reregister_listen: Invalid handle");
     return (NFA_STATUS_BAD_HANDLE);
   }
 
@@ -84,7 +88,7 @@ tNFA_STATUS nfa_ce_api_deregister_listen(tNFA_HANDLE handle,
 
     return (NFA_STATUS_OK);
   } else {
-    NFA_TRACE_ERROR0("nfa_ce_api_reregister_listen: Out of buffers");
+    LOG(ERROR) << StringPrintf("nfa_ce_api_reregister_listen: Out of buffers");
     return (NFA_STATUS_FAILED);
   }
 }
@@ -142,25 +146,25 @@ tNFA_STATUS NFA_CeConfigureLocalTag(tNFA_PROTOCOL_MASK protocol_mask,
 {
   tNFA_CE_MSG* p_msg;
 
-  NFA_TRACE_API0("NFA_CeConfigureLocalTag ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
 
   if (protocol_mask) {
     /* If any protocols are specified, then NDEF buffer pointer must be non-NULL
      */
     if (p_ndef_data == NULL) {
-      NFA_TRACE_ERROR0("NFA_CeConfigureLocalTag: NULL ndef data pointer");
+      LOG(ERROR) << StringPrintf("NFA_CeConfigureLocalTag: NULL ndef data pointer");
       return (NFA_STATUS_INVALID_PARAM);
     }
 
     if ((protocol_mask & NFA_PROTOCOL_MASK_T1T) ||
         (protocol_mask & NFA_PROTOCOL_MASK_T2T)) {
-      NFA_TRACE_ERROR0(
+      LOG(ERROR) << StringPrintf(
           "NFA_CeConfigureLocalTag: Cannot emulate Type 1 / Type 2 tag");
       return (NFA_STATUS_INVALID_PARAM);
     }
 
     if (uid_len) {
-      NFA_TRACE_ERROR1(
+      LOG(ERROR) << StringPrintf(
           "NFA_CeConfigureLocalTag: Cannot Set UID for Protocol_mask: 0x%x",
           protocol_mask);
       return (NFA_STATUS_INVALID_PARAM);
@@ -218,7 +222,7 @@ tNFA_STATUS NFA_CeConfigureUiccListenTech(tNFA_HANDLE ee_handle,
 #if (NFC_NFCEE_INCLUDED == true)
   tNFA_CE_MSG* p_msg;
 
-  NFA_TRACE_API2(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "NFA_CeConfigureUiccListenTech () ee_handle = 0x%x tech_mask = 0x%x",
       ee_handle, tech_mask);
 
@@ -242,7 +246,7 @@ tNFA_STATUS NFA_CeConfigureUiccListenTech(tNFA_HANDLE ee_handle,
     return (NFA_STATUS_OK);
   }
 #else
-  NFA_TRACE_ERROR0(
+  LOG(ERROR) << StringPrintf(
       "NFA_CeConfigureUiccListenTech () NFCEE related functions are not "
       "enabled!");
 #endif
@@ -281,7 +285,7 @@ tNFA_STATUS NFA_CeConfigureEseListenTech(tNFA_HANDLE ee_handle,
 #if (NFC_NFCEE_INCLUDED == true)
   tNFA_CE_MSG* p_msg;
 
-  NFA_TRACE_API1("NFA_CeConfigureEseListenTech () ee_handle = 0x%x", ee_handle);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_CeConfigureEseListenTech () ee_handle = 0x%x", ee_handle);
 
   /* If tech_mask is zero, then app is disabling listening for specified uicc */
   if (tech_mask == 0) {
@@ -303,7 +307,7 @@ tNFA_STATUS NFA_CeConfigureEseListenTech(tNFA_HANDLE ee_handle,
     return (NFA_STATUS_OK);
   }
 #else
-  NFA_TRACE_ERROR0(
+  LOG(ERROR) << StringPrintf(
       "NFA_CeConfigureEseListenTech () NFCEE related functions are not "
       "enabled!");
 #endif
@@ -331,10 +335,11 @@ tNFA_STATUS NFA_CeConfigureEseListenTech(tNFA_HANDLE ee_handle,
 *******************************************************************************/
 tNFA_STATUS NFA_CeRegisterFelicaSystemCodeOnDH(uint16_t system_code,
                                                uint8_t nfcid2[NCI_RF_F_UID_LEN],
+                                               uint8_t t3tPmm[NCI_T3T_PMM_LEN],
                                                tNFA_CONN_CBACK* p_conn_cback) {
   tNFA_CE_MSG* p_msg;
 
-  NFA_TRACE_API0("NFA_CeRegisterFelicaSystemCodeOnDH ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
 
   /* Validate parameters */
   if (p_conn_cback == NULL) return (NFA_STATUS_INVALID_PARAM);
@@ -347,6 +352,7 @@ tNFA_STATUS NFA_CeRegisterFelicaSystemCodeOnDH(uint16_t system_code,
 
     /* Listen info */
     memcpy(p_msg->reg_listen.nfcid2, nfcid2, NCI_RF_F_UID_LEN);
+    memcpy(p_msg->reg_listen.t3tPmm, t3tPmm, NCI_T3T_PMM_LEN);
     p_msg->reg_listen.system_code = system_code;
 
     nfa_sys_sendmsg(p_msg);
@@ -378,7 +384,7 @@ tNFA_STATUS NFA_CeRegisterFelicaSystemCodeOnDH(uint16_t system_code,
 **
 *******************************************************************************/
 tNFA_STATUS NFA_CeDeregisterFelicaSystemCodeOnDH(tNFA_HANDLE handle) {
-  NFA_TRACE_API1("NFA_CeDeregisterFelicaSystemCodeOnDH (): handle:0x%X",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_CeDeregisterFelicaSystemCodeOnDH (): handle:0x%X",
                  handle);
   return (nfa_ce_api_deregister_listen(handle, NFA_CE_LISTEN_INFO_FELICA));
 }
@@ -409,7 +415,7 @@ tNFA_STATUS NFA_CeRegisterAidOnDH(uint8_t aid[NFC_MAX_AID_LEN], uint8_t aid_len,
                                   tNFA_CONN_CBACK* p_conn_cback) {
   tNFA_CE_MSG* p_msg;
 
-  NFA_TRACE_API0("NFA_CeRegisterAidOnDH ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
 
 /* Validate parameters */
 #if (NXP_EXTNS == TRUE)
@@ -457,7 +463,7 @@ tNFA_STATUS NFA_CeRegisterAidOnDH(uint8_t aid[NFC_MAX_AID_LEN], uint8_t aid_len,
 **
 *******************************************************************************/
 tNFA_STATUS NFA_CeDeregisterAidOnDH(tNFA_HANDLE handle) {
-  NFA_TRACE_API1("NFA_CeDeregisterAidOnDH (): handle:0x%X", handle);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_CeDeregisterAidOnDH (): handle:0x%X", handle);
   return (nfa_ce_api_deregister_listen(handle, NFA_CE_LISTEN_INFO_T4T_AID));
 }
 
@@ -492,9 +498,9 @@ tNFA_STATUS NFA_CeSetIsoDepListenTech(tNFA_TECHNOLOGY_MASK tech_mask) {
   tNFA_TECHNOLOGY_MASK use_mask =
       (NFA_TECHNOLOGY_MASK_A | NFA_TECHNOLOGY_MASK_B);
 
-  NFA_TRACE_API1("NFA_CeSetIsoDepListenTech (): 0x%x", tech_mask);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_CeSetIsoDepListenTech (): 0x%x", tech_mask);
   if (((tech_mask & use_mask) == 0) || ((tech_mask & ~use_mask) != 0)) {
-    NFA_TRACE_ERROR0("NFA_CeSetIsoDepListenTech: Invalid technology mask");
+    LOG(ERROR) << StringPrintf("NFA_CeSetIsoDepListenTech: Invalid technology mask");
     return (NFA_STATUS_INVALID_PARAM);
   }
 
diff --git a/src/nfa/ce/nfa_ce_main.c b/src/nfa/ce/nfa_ce_main.cc
similarity index 90%
rename from src/nfa/ce/nfa_ce_main.c
rename to src/nfa/ce/nfa_ce_main.cc
index 013f078..357cb29 100644
--- a/src/nfa/ce/nfa_ce_main.c
+++ b/src/nfa/ce/nfa_ce_main.cc
@@ -22,11 +22,16 @@
  *
  ******************************************************************************/
 #include <string.h>
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfa_ce_api.h"
-#include "nfa_sys.h"
 #include "nfa_ce_int.h"
-#include "nfa_dm_int.h"
-#include "nfa_sys_int.h"
+
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
 
 /* NFA_CE control block */
 tNFA_CE_CB nfa_ce_cb;
@@ -56,9 +61,7 @@ const tNFA_CE_ACTION nfa_ce_action_tbl[] = {
 /*****************************************************************************
 ** Local function prototypes
 *****************************************************************************/
-#if (BT_TRACE_VERBOSE == true)
-static char* nfa_ce_evt_2_str(uint16_t event);
-#endif
+static std::string nfa_ce_evt_2_str(uint16_t event);
 
 /*******************************************************************************
 **
@@ -70,7 +73,7 @@ static char* nfa_ce_evt_2_str(uint16_t event);
 **
 *******************************************************************************/
 void nfa_ce_init(void) {
-  NFA_TRACE_DEBUG0("nfa_ce_init ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ce_init ()");
 
   /* initialize control block */
   memset(&nfa_ce_cb, 0, sizeof(tNFA_CE_CB));
@@ -133,7 +136,7 @@ static void nfa_ce_proc_nfcc_power_mode(uint8_t nfcc_power_mode) {
   tNFA_CE_CB* p_cb = &nfa_ce_cb;
   uint8_t listen_info_idx;
 
-  NFA_TRACE_DEBUG1("nfa_ce_proc_nfcc_power_mode (): nfcc_power_mode=%d",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ce_proc_nfcc_power_mode (): nfcc_power_mode=%d",
                    nfcc_power_mode);
 
   /* if NFCC power mode is change to full power */
@@ -170,14 +173,9 @@ bool nfa_ce_hdl_event(NFC_HDR* p_msg) {
   uint16_t act_idx;
   bool freebuf = true;
 
-#if (BT_TRACE_VERBOSE == true)
-  NFA_TRACE_EVENT3("nfa_ce_handle_event event: %s (0x%02x), flags: %08x",
-                   nfa_ce_evt_2_str(p_msg->event), p_msg->event,
-                   nfa_ce_cb.flags);
-#else
-  NFA_TRACE_EVENT2("nfa_ce_handle_event event: 0x%x, flags: %08x", p_msg->event,
-                   nfa_ce_cb.flags);
-#endif
+DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "nfa_ce_handle_event event: %s (0x%02x), flags: %08x",
+      nfa_ce_evt_2_str(p_msg->event).c_str(), p_msg->event, nfa_ce_cb.flags);
 
   /* Get NFA_RW sub-event */
   act_idx = (p_msg->event & 0x00FF);
@@ -193,7 +191,6 @@ bool nfa_ce_hdl_event(NFC_HDR* p_msg) {
   return freebuf;
 }
 
-#if (BT_TRACE_VERBOSE == true)
 /*******************************************************************************
 **
 ** Function         nfa_ce_evt_2_str
@@ -201,7 +198,7 @@ bool nfa_ce_hdl_event(NFC_HDR* p_msg) {
 ** Description      convert nfc evt to string
 **
 *******************************************************************************/
-static char* nfa_ce_evt_2_str(uint16_t event) {
+static std::string nfa_ce_evt_2_str(uint16_t event) {
   switch (event) {
     case NFA_CE_API_CFG_LOCAL_TAG_EVT:
       return "NFA_CE_API_CFG_LOCAL_TAG_EVT";
@@ -224,5 +221,4 @@ static char* nfa_ce_evt_2_str(uint16_t event) {
     default:
       return "Unknown";
   }
-}
-#endif /* BT_TRACE_VERBOSE */
+}
\ No newline at end of file
diff --git a/src/nfa/dm/nfa_dm_act.c b/src/nfa/dm/nfa_dm_act.cc
old mode 100644
new mode 100755
similarity index 85%
rename from src/nfa/dm/nfa_dm_act.c
rename to src/nfa/dm/nfa_dm_act.cc
index 34ff680..6504dac
--- a/src/nfa/dm/nfa_dm_act.c
+++ b/src/nfa/dm/nfa_dm_act.cc
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -41,10 +41,10 @@
  *
  ******************************************************************************/
 #include <string.h>
-#include "nfa_sys.h"
-#include "nfa_api.h"
-#include "nfa_dm_int.h"
-#include "nfa_sys_int.h"
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfa_ce_int.h"
 #include "nfc_api.h"
 #include "nfa_rw_int.h"
@@ -53,14 +53,22 @@
 #include "nci_hmsgs.h"
 
 #if (NFC_NFCEE_INCLUDED == true)
+#ifdef ENABLE_ESE_CLIENT
+#include "hal_nxpese.h"
+#endif
 #include "nfa_ee_int.h"
 #include "nfa_hci_int.h"
+#include "nfc_int.h"
 #endif
 
 #if (NFA_SNEP_INCLUDED == true)
 #include "nfa_snep_int.h"
 #endif
 
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+
 /* This is the timeout value to guarantee disable is performed within reasonable
  * amount of time */
 #ifndef NFA_DM_DISABLE_TIMEOUT_VAL
@@ -110,7 +118,7 @@ static void nfa_dm_module_init_cback(void) {
 static void nfa_dm_nfcc_power_mode_proc_complete_cback(void) {
   tNFA_DM_PWR_MODE_CHANGE power_mode_change;
 
-  NFA_TRACE_DEBUG1(
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "nfa_dm_nfcc_power_mode_proc_complete_cback () nfcc_pwr_mode = 0x%x",
       nfa_dm_cb.nfcc_pwr_mode);
 
@@ -126,8 +134,9 @@ static void nfa_dm_nfcc_power_mode_proc_complete_cback(void) {
 
   power_mode_change.status = NFA_STATUS_OK;
   power_mode_change.power_mode = nfa_dm_cb.nfcc_pwr_mode;
-  (*nfa_dm_cb.p_dm_cback)(NFA_DM_PWR_MODE_CHANGE_EVT,
-                          (void*)&power_mode_change);
+  tNFA_DM_CBACK_DATA nfa_dm_cback_data;
+  nfa_dm_cback_data.power_mode = power_mode_change;
+  (*nfa_dm_cb.p_dm_cback)(NFA_DM_PWR_MODE_CHANGE_EVT, &nfa_dm_cback_data);
 }
 /*******************************************************************************
 **
@@ -150,44 +159,42 @@ void nfa_dm_sys_enable(void) { nfa_dm_set_init_nci_params(); }
 **
 *******************************************************************************/
 static void nfa_dm_set_init_nci_params(void) {
-  uint8_t xx, yy;
+  uint8_t xx;
 
   /* set NCI default value if other than zero */
 
-   if(NFC_GetNCIVersion() == NCI_VERSION_2_0) {
+  if (NFC_GetNCIVersion() == NCI_VERSION_2_0) {
     /* Default Values: For each identifier
      * Octet 0-1   = OxFF
      * Octet 2     = Ox02
      * Octet 3     = 0xFE
      * Octet 4-9   = 0x00
      * Octet 10-17 = 0xFF*/
-    for (xx = 0; xx < NFA_CE_LISTEN_INFO_MAX; xx++)
-    {
-        nfa_dm_cb.params.lf_t3t_id[xx][0] = 0xFF;
-        nfa_dm_cb.params.lf_t3t_id[xx][1] = 0xFF;
-        nfa_dm_cb.params.lf_t3t_id[xx][2] = 0x02;
-        nfa_dm_cb.params.lf_t3t_id[xx][3] = 0xFE;
+    for (xx = 0; xx < NFA_CE_LISTEN_INFO_MAX; xx++) {
+      nfa_dm_cb.params.lf_t3t_id[xx][0] = 0xFF;
+      nfa_dm_cb.params.lf_t3t_id[xx][1] = 0xFF;
+      nfa_dm_cb.params.lf_t3t_id[xx][2] = 0x02;
+      nfa_dm_cb.params.lf_t3t_id[xx][3] = 0xFE;
     }
 
     /* LF_T3T_PMM value is added to LF_T3T_IDENTIFIERS_X in NCI2.0. */
-    for (xx = 0; xx < NFA_CE_LISTEN_INFO_MAX ; xx++)
-    {
-        for (yy = 10; yy < NCI_PARAM_LEN_LF_T3T_ID(NCI_VERSION_2_0) ; yy++)
-           nfa_dm_cb.params.lf_t3t_id[xx][yy] = 0xFF;
+    for (xx = 0; xx < NFA_CE_LISTEN_INFO_MAX; xx++) {
+      for (uint8_t yy = 10; yy < NCI_PARAM_LEN_LF_T3T_ID(NFC_GetNCIVersion()); yy++)
+        nfa_dm_cb.params.lf_t3t_id[xx][yy] = 0xFF;
     }
   } else {
-      /* LF_T3T_IDENTIFIERS_1/2/.../16 */
-      for (xx = 0; xx < NFA_CE_LISTEN_INFO_MAX; xx++) {
-        nfa_dm_cb.params.lf_t3t_id[xx][0] = 0xFF;
-        nfa_dm_cb.params.lf_t3t_id[xx][1] = 0xFF;
-        nfa_dm_cb.params.lf_t3t_id[xx][2] = 0x02;
-        nfa_dm_cb.params.lf_t3t_id[xx][3] = 0xFE;
-      }
+    /* LF_T3T_IDENTIFIERS_1/2/.../16 */
+    for (xx = 0; xx < NFA_CE_LISTEN_INFO_MAX; xx++) {
+      nfa_dm_cb.params.lf_t3t_id[xx][0] = 0xFF;
+      nfa_dm_cb.params.lf_t3t_id[xx][1] = 0xFF;
+      nfa_dm_cb.params.lf_t3t_id[xx][2] = 0x02;
+      nfa_dm_cb.params.lf_t3t_id[xx][3] = 0xFE;
+    }
 
-      /* LF_T3T_PMM */
-      for (xx = 0; xx < NCI_PARAM_LEN_LF_T3T_PMM; xx++) {
-        nfa_dm_cb.params.lf_t3t_pmm[xx] = 0xFF;
-      }
+    /* LF_T3T_PMM */
+    for (xx = 0; xx < NCI_PARAM_LEN_LF_T3T_PMM; xx++) {
+      nfa_dm_cb.params.lf_t3t_pmm[xx] = 0xFF;
+    }
   }
 
   /* LF_T3T_FLAGS:
@@ -201,13 +208,10 @@ static void nfa_dm_set_init_nci_params(void) {
   /* WT */
   nfa_dm_cb.params.wt[0] = 14;
 
-// LF_T3T_PMM is not supported.
-/* Set CE default configuration */
-#if (NXP_EXTNS != TRUE)
+  /* Set CE default configuration */
   if (p_nfa_dm_ce_cfg[0]) {
     nfa_dm_check_set_config(p_nfa_dm_ce_cfg[0], &p_nfa_dm_ce_cfg[1], false);
   }
-#endif
 
   /* Set optional general default configuration */
   if (p_nfa_dm_gen_cfg && p_nfa_dm_gen_cfg[0]) {
@@ -215,8 +219,6 @@ static void nfa_dm_set_init_nci_params(void) {
   }
 
   if (p_nfa_dm_interface_mapping && nfa_dm_num_dm_interface_mapping) {
-  NFA_TRACE_DEBUG1("nfa_dm_num_dm_interface_mapping=%d",
-  nfa_dm_num_dm_interface_mapping);
     NFC_DiscoveryMap(nfa_dm_num_dm_interface_mapping,
                      p_nfa_dm_interface_mapping, NULL);
   }
@@ -232,13 +234,13 @@ static void nfa_dm_set_init_nci_params(void) {
 **
 *******************************************************************************/
 void nfa_dm_proc_nfcc_power_mode(uint8_t nfcc_power_mode) {
-  NFA_TRACE_DEBUG1("nfa_dm_proc_nfcc_power_mode (): nfcc_power_mode=%d",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_proc_nfcc_power_mode (): nfcc_power_mode=%d",
                    nfcc_power_mode);
 
   /* if NFCC power mode is change to full power */
   if (nfcc_power_mode == NFA_DM_PWR_MODE_FULL) {
     memset(&nfa_dm_cb.params, 0x00, sizeof(tNFA_DM_PARAMS));
-    NFA_TRACE_DEBUG2("setcfg_pending_mask=0x%x, setcfg_pending_num=%d",
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("setcfg_pending_mask=0x%x, setcfg_pending_num=%d",
                      nfa_dm_cb.setcfg_pending_mask,
                      nfa_dm_cb.setcfg_pending_num);
     nfa_dm_cb.setcfg_pending_mask = 0;
@@ -253,42 +255,6 @@ void nfa_dm_proc_nfcc_power_mode(uint8_t nfcc_power_mode) {
   nfa_sys_cback_notify_nfcc_power_mode_proc_complete(NFA_ID_DM);
 }
 
-/*******************************************************************************
-**
-** Function         nfa_dm_set_power_sub_state
-**
-** Description      Process the power sub state command
-**
-** Returns          TRUE (message buffer to be freed by caller)
-**
-*******************************************************************************/
-bool nfa_dm_set_power_sub_state (tNFA_DM_MSG *p_data)
-{
-   tNFC_STATUS status;
-   tNFA_DM_CBACK_DATA dm_cback_data;
-
-   NFA_TRACE_DEBUG0(" nfa_dm_set_power_sub_state ()");
-
-   nfa_dm_cb.power_state = p_data->set_power_state.screen_state;
-   if( nfa_dm_cb.disc_cb.disc_state == NFA_DM_RFST_LISTEN_ACTIVE)
-    {
-      NFA_TRACE_DEBUG0("nfa_dm_set_power_sub_state () : NFA_DM_RFST_LISTEN_ACTIVE");
-        /* NFCC will give semantic error for power sub state command in Rf listen active state */
-        status = NFC_STATUS_SEMANTIC_ERROR;
-    }
-   else
-    {
-        status = NFC_SetPowerSubState(p_data->set_power_state.screen_state);
-    }
-
-   if (status != NFC_STATUS_OK)
-    {
-        dm_cback_data.power_sub_state.status = NFC_STATUS_FAILED;
-        dm_cback_data.power_sub_state.power_state = nfa_dm_cb.power_state;
-        (*nfa_dm_cb.p_dm_cback) (NFA_DM_SET_POWER_SUB_STATE_EVT, &dm_cback_data);
-    }
-    return (true);
-}
 /*******************************************************************************
 **
 ** Function         nfa_dm_disable_event
@@ -321,7 +287,6 @@ static void nfa_dm_disable_event(void) {
 static void nfa_dm_nfc_response_cback(tNFC_RESPONSE_EVT event,
                                       tNFC_RESPONSE* p_data) {
   tNFA_DM_CBACK_DATA dm_cback_data;
-  tNFA_GET_CONFIG* p_nfa_get_confg;
 #if (NXP_EXTNS == TRUE)
   tNFA_GET_ROUTING* p_nfa_get_routing;
 #endif
@@ -329,12 +294,8 @@ static void nfa_dm_nfc_response_cback(tNFC_RESPONSE_EVT event,
   uint8_t dm_cback_evt;
   uint8_t max_ee = 0;
 
-#if (BT_TRACE_VERBOSE == true)
-  NFA_TRACE_DEBUG2("nfa_dm_nfc_response_cback () %s(0x%x)",
-                   nfa_dm_nfc_revt_2_str(event), event);
-#else
-  NFA_TRACE_DEBUG1("nfa_dm_nfc_response_cback () event=0x%x", event);
-#endif
+DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s(0x%x)", nfa_dm_nfc_revt_2_str(event).c_str(), event);
 
   switch (event) {
     case NFC_ENABLE_REVT: /* 0  Enable event */
@@ -359,11 +320,7 @@ static void nfa_dm_nfc_response_cback(tNFC_RESPONSE_EVT event,
         (*nfa_dm_cb.p_dm_cback)(NFA_DM_ENABLE_EVT, &dm_cback_data);
       }
       break;
-    case NFC_SET_POWER_SUB_STATE_REVT:
-      dm_cback_data.power_sub_state.status = p_data->status;
-      dm_cback_data.power_sub_state.power_state = nfa_dm_cb.power_state;
-      (*nfa_dm_cb.p_dm_cback) (NFA_DM_SET_POWER_SUB_STATE_EVT, &dm_cback_data);
-      break;
+
     case NFC_DISABLE_REVT: /* 1  Disable event */
       nfa_dm_disable_event();
       break;
@@ -386,28 +343,18 @@ static void nfa_dm_nfc_response_cback(tNFC_RESPONSE_EVT event,
       } else {
         /* This should not occur (means we got a SET_CONFIG_NTF that's
          * unaccounted for */
-        NFA_TRACE_ERROR0("NFA received unexpected NFC_SET_CONFIG_REVT");
+        LOG(ERROR) << StringPrintf("NFA received unexpected NFC_SET_CONFIG_REVT");
       }
       break;
 
     case NFC_GET_CONFIG_REVT: /* 3  Get Config Response */
       if (p_data->get_config.status == NFC_STATUS_OK) {
-        p_nfa_get_confg = (tNFA_GET_CONFIG*)GKI_getbuf(
-            (uint16_t)(sizeof(tNFA_GET_CONFIG) + p_data->get_config.tlv_size));
-        if (p_nfa_get_confg != NULL) {
-          p_nfa_get_confg->status = NFA_STATUS_OK;
-          p_nfa_get_confg->tlv_size = p_data->get_config.tlv_size;
-          memcpy(p_nfa_get_confg->param_tlvs, p_data->get_config.p_param_tlvs,
-                 p_data->get_config.tlv_size);
-          (*nfa_dm_cb.p_dm_cback)(NFA_DM_GET_CONFIG_EVT,
-                                  (tNFA_DM_CBACK_DATA*)p_nfa_get_confg);
-
-          GKI_freebuf(p_nfa_get_confg);
-          return;
-        } else {
-          NFA_TRACE_DEBUG0(
-              "nfa_dm_nfc_response_cback unable to allocate buffer");
-        }
+        tNFA_GET_CONFIG* p_nfa_get_confg = &dm_cback_data.get_config;
+        p_nfa_get_confg->status = NFA_STATUS_OK;
+        p_nfa_get_confg->tlv_size = p_data->get_config.tlv_size;
+        p_nfa_get_confg->param_tlvs = p_data->get_config.p_param_tlvs;
+        (*nfa_dm_cb.p_dm_cback)(NFA_DM_GET_CONFIG_EVT, &dm_cback_data);
+        return;
       }
 
       /* Return result of getconfig to the app */
@@ -445,6 +392,12 @@ static void nfa_dm_nfc_response_cback(tNFC_RESPONSE_EVT event,
 
 #endif
 
+    case NFC_SET_POWER_SUB_STATE_REVT:
+      dm_cback_data.power_sub_state.status = p_data->status;
+      dm_cback_data.power_sub_state.power_state = nfa_dm_cb.power_state;
+      (*nfa_dm_cb.p_dm_cback)(NFA_DM_SET_POWER_SUB_STATE_EVT, &dm_cback_data);
+      break;
+
     case NFC_RF_FIELD_REVT: /* RF Field information            */
       dm_cback_data.rf_field.status = NFA_STATUS_OK;
       dm_cback_data.rf_field.rf_field_status = p_data->rf_field.rf_field;
@@ -469,7 +422,7 @@ static void nfa_dm_nfc_response_cback(tNFC_RESPONSE_EVT event,
                                 (tNFA_DM_CBACK_DATA*)p_nfa_get_routing);
         GKI_freebuf(p_nfa_get_routing);
       } else {
-        NFA_TRACE_DEBUG0("nfa_dm_nfc_response_cback unable to allocate buffer");
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_nfc_response_cback unable to allocate buffer");
       }
 #endif
       break;
@@ -519,18 +472,20 @@ static void nfa_dm_nfc_response_cback(tNFC_RESPONSE_EVT event,
         break;
 
     case NFC_NFCC_TRANSPORT_ERR_REVT:
-      NFA_TRACE_DEBUG1("flags:0x%08x", nfa_dm_cb.flags);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("flags:0x%08x", nfa_dm_cb.flags);
 #if (NXP_EXTNS == TRUE)
       if(nfcFL.nfccFL._NFCC_I2C_READ_WRITE_IMPROVEMENT) {
           if (p_data->status == NFC_STATUS_FAILED) {
               dm_cback_data.status = p_data->status;
           }
           dm_cback_evt = NFA_DM_NFCC_TRANSPORT_ERR_EVT;
-      }
-#else
+      } else {
+#endif
       dm_cback_evt = (event == NFC_NFCC_TIMEOUT_REVT)
                          ? NFA_DM_NFCC_TIMEOUT_EVT
                          : NFA_DM_NFCC_TRANSPORT_ERR_EVT;
+#if (NXP_EXTNS == TRUE)
+      }
 #endif
       (*nfa_dm_cb.p_dm_cback)(dm_cback_evt, NULL);
       break;
@@ -565,7 +520,7 @@ static void nfa_dm_nfc_response_cback(tNFC_RESPONSE_EVT event,
 *******************************************************************************/
 bool nfa_dm_enable(tNFA_DM_MSG* p_data) {
   tNFA_DM_CBACK_DATA dm_cback_data;
-  NFA_TRACE_DEBUG0("nfa_dm_enable ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_enable ()");
 
   /* Check if NFA is already enabled */
   if (!(nfa_dm_cb.flags & NFA_DM_FLAGS_DM_IS_ACTIVE)) {
@@ -582,7 +537,7 @@ bool nfa_dm_enable(tNFA_DM_MSG* p_data) {
     /* Enable NFC stack */
     NFC_Enable(nfa_dm_nfc_response_cback);
   } else {
-    NFA_TRACE_ERROR0("nfa_dm_enable: ERROR ALREADY ENABLED.");
+    LOG(ERROR) << StringPrintf("nfa_dm_enable: ERROR ALREADY ENABLED.");
     dm_cback_data.status = NFA_STATUS_ALREADY_STARTED;
     (*(p_data->enable.p_dm_cback))(NFA_DM_ENABLE_EVT, &dm_cback_data);
   }
@@ -599,9 +554,7 @@ bool nfa_dm_enable(tNFA_DM_MSG* p_data) {
 **
 *******************************************************************************/
 bool nfa_dm_disable(tNFA_DM_MSG* p_data) {
-  tNFC_DEACT_TYPE deactivate_type = NFA_DEACTIVATE_TYPE_IDLE;
-
-  NFA_TRACE_DEBUG1("nfa_dm_disable (): graceful:%d", p_data->disable.graceful);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_disable (): graceful:%d", p_data->disable.graceful);
 
   if (p_data->disable.graceful) {
     /* if RF discovery is enabled */
@@ -615,8 +568,10 @@ bool nfa_dm_disable(tNFA_DM_MSG* p_data) {
         }
       } else {
         nfa_dm_cb.disc_cb.disc_flags |= NFA_DM_DISC_FLAGS_DISABLING;
-        nfa_dm_disc_sm_execute(NFA_DM_RF_DEACTIVATE_CMD,
-                               (void*)&deactivate_type);
+        tNFA_DM_RF_DISC_DATA nfa_dm_rf_disc_data;
+        nfa_dm_rf_disc_data.deactivate_type = NFA_DEACTIVATE_TYPE_IDLE;
+
+        nfa_dm_disc_sm_execute(NFA_DM_RF_DEACTIVATE_CMD, &nfa_dm_rf_disc_data);
         if ((nfa_dm_cb.disc_cb.disc_flags &
              (NFA_DM_DISC_FLAGS_W4_RSP | NFA_DM_DISC_FLAGS_W4_NTF)) == 0) {
           /* not waiting to deactivate, clear the flag now */
@@ -648,10 +603,10 @@ bool nfa_dm_disable(tNFA_DM_MSG* p_data) {
 **
 *******************************************************************************/
 void nfa_dm_disable_complete(void) {
-  NFA_TRACE_DEBUG0("nfa_dm_disable_complete ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_disable_complete ()");
 
   if ((nfa_dm_cb.flags & NFA_DM_FLAGS_DM_DISABLING_NFC) == 0) {
-    NFA_TRACE_DEBUG0(
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "nfa_dm_disable_complete (): proceeding with nfc core shutdown.");
 
     nfa_dm_cb.flags |= NFA_DM_FLAGS_DM_DISABLING_NFC;
@@ -713,9 +668,41 @@ bool nfa_dm_set_config(tNFA_DM_MSG* p_data) {
 bool nfa_dm_get_config(tNFA_DM_MSG* p_data) {
   NFC_GetConfig(p_data->getconfig.num_ids, p_data->getconfig.p_pmids);
 
-  return (true);
+  return true;
 }
+/*******************************************************************************
+**
+** Function         nfa_dm_set_power_sub_state
+**
+** Description      Process the power sub state command
+**
+** Returns          TRUE (message buffer to be freed by caller)
+**
+*******************************************************************************/
+bool nfa_dm_set_power_sub_state(tNFA_DM_MSG* p_data) {
+  tNFC_STATUS status;
+  tNFA_DM_CBACK_DATA dm_cback_data;
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(" nfa_dm_set_power_sub_state ()");
 
+  nfa_dm_cb.power_state = p_data->set_power_state.screen_state;
+  if (nfa_dm_cb.disc_cb.disc_state == NFA_DM_RFST_LISTEN_ACTIVE) {
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "nfa_dm_set_power_sub_state () : NFA_DM_RFST_LISTEN_ACTIVE");
+    /* NFCC will give semantic error for power sub state command in Rf listen
+     * active state */
+    status = NFC_STATUS_SEMANTIC_ERROR;
+  } else {
+    status = NFC_SetPowerSubState(p_data->set_power_state.screen_state);
+  }
+
+  if (status != NFC_STATUS_OK) {
+    dm_cback_data.power_sub_state.status = NFC_STATUS_FAILED;
+    dm_cback_data.power_sub_state.power_state = nfa_dm_cb.power_state;
+    (*nfa_dm_cb.p_dm_cback)(NFA_DM_SET_POWER_SUB_STATE_EVT, &dm_cback_data);
+  }
+  return (true);
+}
 /*******************************************************************************
 **
 ** Function         nfa_dm_conn_cback_event_notify
@@ -749,7 +736,7 @@ void nfa_dm_conn_cback_event_notify(uint8_t event, tNFA_CONN_EVT_DATA* p_data) {
 void nfa_dm_rel_excl_rf_control_and_notify(void) {
   tNFA_CONN_EVT_DATA conn_evt;
 
-  NFA_TRACE_DEBUG0("nfa_dm_rel_excl_rf_control_and_notify ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_rel_excl_rf_control_and_notify ()");
 
   /* Exclusive RF control stopped. Notify app */
   nfa_dm_cb.flags &= ~NFA_DM_FLAGS_EXCL_RF_ACTIVE;
@@ -777,7 +764,7 @@ void nfa_dm_rel_excl_rf_control_and_notify(void) {
 bool nfa_dm_act_request_excl_rf_ctrl(tNFA_DM_MSG* p_data) {
   tNFA_CONN_EVT_DATA conn_evt;
 
-  NFA_TRACE_DEBUG0("nfa_dm_act_request_excl_rf_ctrl ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_act_request_excl_rf_ctrl ()");
 
   if (!nfa_dm_cb.p_excl_conn_cback) {
     if (nfa_dm_cb.disc_cb.disc_state != NFA_DM_RFST_IDLE) {
@@ -798,7 +785,7 @@ bool nfa_dm_act_request_excl_rf_ctrl(tNFA_DM_MSG* p_data) {
                                 &p_data->req_excl_rf_ctrl.listen_cfg,
                                 nfa_dm_excl_disc_cback);
   } else {
-    NFA_TRACE_ERROR0("Exclusive rf control already requested");
+    LOG(ERROR) << StringPrintf("Exclusive rf control already requested");
 
     conn_evt.status = NFA_STATUS_FAILED;
     (*p_data->req_excl_rf_ctrl.p_conn_cback)(
@@ -817,9 +804,9 @@ bool nfa_dm_act_request_excl_rf_ctrl(tNFA_DM_MSG* p_data) {
 ** Returns          true (message buffer to be freed by caller)
 **
 *******************************************************************************/
-bool nfa_dm_act_release_excl_rf_ctrl(tNFA_DM_MSG* p_data) {
-  (void)p_data;
-  NFA_TRACE_DEBUG0("nfa_dm_act_release_excl_rf_ctrl ()");
+bool nfa_dm_act_release_excl_rf_ctrl(__attribute__((unused))
+                                      tNFA_DM_MSG* p_data) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_act_release_excl_rf_ctrl ()");
 
   /* nfa_dm_rel_excl_rf_control_and_notify() is called when discovery state goes
    * IDLE */
@@ -852,35 +839,30 @@ bool nfa_dm_act_deactivate(tNFA_DM_MSG* p_data) {
   tNFA_CONN_EVT_DATA conn_evt;
   tNFA_DEACTIVATE_TYPE deact_type;
 
-  NFA_TRACE_DEBUG0("nfa_dm_act_deactivate ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_act_deactivate ()");
 
   /* Always allow deactivate to IDLE */
   /* Do not allow deactivate to SLEEP for T1T,NFCDEP, ISO15693 */
   if ((p_data->deactivate.sleep_mode == false) ||
       ((nfa_dm_cb.disc_cb.activated_protocol != NFA_PROTOCOL_T1T) &&
+       (nfa_dm_cb.disc_cb.activated_protocol != NFA_PROTOCOL_NFC_DEP ||
+        appl_dta_mode_flag
 #if (NXP_EXTNS == TRUE)
-       (
+        || gFelicaReaderMode
 #endif
-           (nfa_dm_cb.disc_cb.activated_protocol != NFA_PROTOCOL_NFC_DEP)
-#if (NXP_EXTNS == TRUE)
-           || gFelicaReaderMode || appl_dta_mode_flag)
-#endif
-       &&
+       ) &&
+       (nfa_dm_cb.disc_cb.activated_protocol != NFA_PROTOCOL_T5T) &&
        (nfa_dm_cb.disc_cb.activated_protocol != NFC_PROTOCOL_KOVIO))) {
     deact_type = NFA_DEACTIVATE_TYPE_DISCOVERY;
     if (p_data->deactivate.sleep_mode) {
       if (nfa_dm_cb.disc_cb.disc_state == NFA_DM_RFST_W4_HOST_SELECT) {
         /* Deactivate to sleep mode not allowed in this state. */
         deact_type = NFA_DEACTIVATE_TYPE_IDLE;
-      }
-#if (NXP_EXTNS == TRUE)
-      else if (appl_dta_mode_flag == true &&
-               (nfa_dm_cb.disc_cb.disc_state != NFA_DM_RFST_LISTEN_SLEEP ||
-                nfa_dm_cb.disc_cb.disc_state == NFA_DM_RFST_POLL_ACTIVE)) {
+      } else if (appl_dta_mode_flag == true &&
+                 (nfa_dm_cb.disc_cb.disc_state != NFA_DM_RFST_LISTEN_SLEEP ||
+                  nfa_dm_cb.disc_cb.disc_state == NFA_DM_RFST_POLL_ACTIVE)) {
         deact_type = NFA_DEACTIVATE_TYPE_SLEEP;
-      }
-#endif
-      else if (nfa_dm_cb.disc_cb.disc_state != NFA_DM_RFST_LISTEN_SLEEP) {
+      } else if (nfa_dm_cb.disc_cb.disc_state != NFA_DM_RFST_LISTEN_SLEEP) {
         deact_type = NFA_DEACTIVATE_TYPE_SLEEP;
       }
     }
@@ -894,11 +876,8 @@ bool nfa_dm_act_deactivate(tNFA_DM_MSG* p_data) {
     }
 
     if ((nfa_dm_cb.disc_cb.activated_protocol == NFA_PROTOCOL_NFC_DEP) &&
-        ((nfa_dm_cb.flags & NFA_DM_FLAGS_EXCL_RF_ACTIVE) == 0x00)
-#if (NXP_EXTNS == TRUE)
-        && appl_dta_mode_flag != true
-#endif
-        ) {
+        ((nfa_dm_cb.flags & NFA_DM_FLAGS_EXCL_RF_ACTIVE) == 0x00) &&
+        appl_dta_mode_flag != true) {
       /* Exclusive RF control doesn't use NFA P2P */
       /* NFA P2P will deactivate NFC link after deactivating LLCP link */
       if (!(nfa_dm_cb.flags & NFA_DM_FLAGS_P2P_PAUSED)) {
@@ -917,7 +896,7 @@ bool nfa_dm_act_deactivate(tNFA_DM_MSG* p_data) {
     }
   }
 
-  NFA_TRACE_ERROR0("nfa_dm_act_deactivate (): invalid protocol, mode or state");
+  LOG(ERROR) << StringPrintf("nfa_dm_act_deactivate (): invalid protocol, mode or state");
 
   /* Notify error to application */
   conn_evt.status = NFA_STATUS_FAILED;
@@ -936,7 +915,7 @@ bool nfa_dm_act_deactivate(tNFA_DM_MSG* p_data) {
 **
 *******************************************************************************/
 bool nfa_dm_act_power_off_sleep(tNFA_DM_MSG* p_data) {
-  NFA_TRACE_DEBUG0("nfa_dm_act_power_off_sleep ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_act_power_off_sleep ()");
 
   NFC_SetPowerOffSleep((bool)(p_data->hdr.layer_specific));
 
@@ -955,7 +934,7 @@ bool nfa_dm_act_power_off_sleep(tNFA_DM_MSG* p_data) {
 bool nfa_dm_act_reg_vsc(tNFA_DM_MSG* p_data) {
   if (NFC_RegVSCback(p_data->reg_vsc.is_register, p_data->reg_vsc.p_cback) !=
       NFC_STATUS_OK) {
-    NFA_TRACE_ERROR0("NFC_RegVSCback failed");
+    LOG(ERROR) << StringPrintf("NFC_RegVSCback failed");
   }
   return (true);
 }
@@ -984,30 +963,29 @@ bool nfa_dm_act_send_vsc(tNFA_DM_MSG* p_data) {
   return (false);
 }
 
-#if (NXP_EXTNS == TRUE)
 /*******************************************************************************
 **
-** Function         nfa_dm_act_send_nxp
+** Function         nfa_dm_act_send_raw_vs
 **
-** Description      Send the NXP NCI command to the NCI command queue
+** Description      Send the raw vs command to the NCI command queue
 **
-** Returns          false (message buffer is NOT freed by caller)
+** Returns          FALSE (message buffer is NOT freed by caller)
 **
 *******************************************************************************/
-bool nfa_dm_act_send_nxp(tNFA_DM_MSG* p_data) {
+bool nfa_dm_act_send_raw_vs(tNFA_DM_MSG* p_data) {
   NFC_HDR* p_cmd = (NFC_HDR*)p_data;
 
   p_cmd->offset = sizeof(tNFA_DM_API_SEND_VSC) - NFC_HDR_SIZE;
   p_cmd->len = p_data->send_vsc.cmd_params_len;
-  NFC_SendNxpNciCommand(p_cmd, p_data->send_vsc.p_cback);
+  NFC_SendRawVsCommand(p_cmd, p_data->send_vsc.p_cback);
 
-  /* Most dm action functions return true, so nfa-sys frees the GKI buffer
+  /* Most dm action functions return TRUE, so nfa-sys frees the GKI buffer
    * carrying the message,
    * This action function re-use the GKI buffer to send the VSC, so the GKI
    * buffer can not be freed by nfa-sys */
-  return (false);
+  return false;
 }
-#endif
+
 /*******************************************************************************
 **
 ** Function         nfa_dm_start_polling
@@ -1022,7 +1000,7 @@ tNFA_STATUS nfa_dm_start_polling(void) {
   tNFA_TECHNOLOGY_MASK poll_tech_mask;
   tNFA_DM_DISC_TECH_PROTO_MASK poll_disc_mask = 0;
 
-  NFA_TRACE_DEBUG0("nfa_dm_start_polling ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_start_polling ()");
 
   poll_tech_mask = nfa_dm_cb.poll_mask;
 
@@ -1035,8 +1013,17 @@ tNFA_STATUS nfa_dm_start_polling(void) {
       poll_disc_mask |= NFA_DM_DISC_MASK_PA_NFC_DEP;
       poll_disc_mask |= NFA_DM_DISC_MASK_P_LEGACY;
     }
-    if (poll_tech_mask & NFA_TECHNOLOGY_MASK_A_ACTIVE) {
-      poll_disc_mask |= NFA_DM_DISC_MASK_PAA_NFC_DEP;
+    if (NFC_GetNCIVersion() == NCI_VERSION_2_0) {
+      if (poll_tech_mask & NFA_TECHNOLOGY_MASK_ACTIVE) {
+        poll_disc_mask |= NFA_DM_DISC_MASK_PACM_NFC_DEP;
+      }
+    } else {
+      if (poll_tech_mask & NFA_TECHNOLOGY_MASK_A_ACTIVE) {
+        poll_disc_mask |= NFA_DM_DISC_MASK_PAA_NFC_DEP;
+      }
+      if (poll_tech_mask & NFA_TECHNOLOGY_MASK_F_ACTIVE) {
+        poll_disc_mask |= NFA_DM_DISC_MASK_PFA_NFC_DEP;
+      }
     }
     if (poll_tech_mask & NFA_TECHNOLOGY_MASK_B) {
       poll_disc_mask |= NFA_DM_DISC_MASK_PB_ISO_DEP;
@@ -1048,11 +1035,8 @@ tNFA_STATUS nfa_dm_start_polling(void) {
       poll_disc_mask |= NFA_DM_DISC_MASK_PF_T3T;
       poll_disc_mask |= NFA_DM_DISC_MASK_PF_NFC_DEP;
     }
-    if (poll_tech_mask & NFA_TECHNOLOGY_MASK_F_ACTIVE) {
-      poll_disc_mask |= NFA_DM_DISC_MASK_PFA_NFC_DEP;
-    }
-    if (poll_tech_mask & NFA_TECHNOLOGY_MASK_ISO15693) {
-      poll_disc_mask |= NFA_DM_DISC_MASK_P_ISO15693;
+    if (poll_tech_mask & NFA_TECHNOLOGY_MASK_V) {
+      poll_disc_mask |= NFA_DM_DISC_MASK_P_T5T;
     }
     if (poll_tech_mask & NFA_TECHNOLOGY_MASK_B_PRIME) {
       poll_disc_mask |= NFA_DM_DISC_MASK_P_B_PRIME;
@@ -1087,7 +1071,7 @@ tNFA_STATUS nfa_dm_start_polling(void) {
 bool nfa_dm_act_enable_polling(tNFA_DM_MSG* p_data) {
   tNFA_CONN_EVT_DATA evt_data;
 
-  NFA_TRACE_DEBUG0("nfa_dm_act_enable_polling ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_act_enable_polling ()");
 
   if ((!(nfa_dm_cb.flags & NFA_DM_FLAGS_POLLING_ENABLED)) &&
       (!(nfa_dm_cb.flags & NFA_DM_FLAGS_EXCL_RF_ACTIVE))) {
@@ -1101,7 +1085,7 @@ bool nfa_dm_act_enable_polling(tNFA_DM_MSG* p_data) {
       return (true);
     }
   } else {
-    NFA_TRACE_ERROR0("nfa_dm_act_enable_polling (): already started");
+    LOG(ERROR) << StringPrintf("nfa_dm_act_enable_polling (): already started");
   }
 
   /* send NFA_POLL_ENABLED_EVT with NFA_STATUS_FAILED */
@@ -1121,7 +1105,7 @@ bool nfa_dm_act_enable_polling(tNFA_DM_MSG* p_data) {
 **
 *******************************************************************************/
 static bool nfa_dm_deactivate_polling(void) {
-  NFA_TRACE_DEBUG0("nfa_dm_deactivate_polling ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_deactivate_polling ()");
 
   if ((nfa_dm_cb.disc_cb.disc_state == NFA_DM_RFST_W4_ALL_DISCOVERIES) ||
       (nfa_dm_cb.disc_cb.disc_state == NFA_DM_RFST_W4_HOST_SELECT)) {
@@ -1149,11 +1133,10 @@ static bool nfa_dm_deactivate_polling(void) {
 ** Returns          true (message buffer to be freed by caller)
 **
 *******************************************************************************/
-bool nfa_dm_act_disable_polling(tNFA_DM_MSG* p_data) {
+bool nfa_dm_act_disable_polling(__attribute__((unused)) tNFA_DM_MSG* p_data) {
   tNFA_CONN_EVT_DATA evt_data;
-  (void)p_data;
 
-  NFA_TRACE_DEBUG0("nfa_dm_act_disable_polling ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_act_disable_polling ()");
 
   if (nfa_dm_cb.poll_disc_handle != NFA_HANDLE_INVALID) {
     nfa_dm_cb.flags &= ~NFA_DM_FLAGS_POLLING_ENABLED;
@@ -1184,11 +1167,10 @@ bool nfa_dm_act_disable_polling(tNFA_DM_MSG* p_data) {
 ** Returns          true (message buffer to be freed by caller)
 **
 *******************************************************************************/
-bool nfa_dm_act_enable_listening(tNFA_DM_MSG* p_data) {
+bool nfa_dm_act_enable_listening(__attribute__((unused)) tNFA_DM_MSG* p_data) {
   tNFA_CONN_EVT_DATA evt_data;
-  (void)p_data;
 
-  NFA_TRACE_DEBUG0("nfa_dm_act_enable_listening ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_act_enable_listening ()");
 
   nfa_dm_cb.flags &= ~NFA_DM_FLAGS_LISTEN_DISABLED;
 #if (NXP_EXTNS == TRUE)
@@ -1211,11 +1193,10 @@ bool nfa_dm_act_enable_listening(tNFA_DM_MSG* p_data) {
 ** Returns          true (message buffer to be freed by caller)
 **
 *******************************************************************************/
-bool nfa_dm_act_disable_listening(tNFA_DM_MSG* p_data) {
+bool nfa_dm_act_disable_listening(__attribute__((unused)) tNFA_DM_MSG* p_data) {
   tNFA_CONN_EVT_DATA evt_data;
-  (void)p_data;
 
-  NFA_TRACE_DEBUG0("nfa_dm_act_disable_listening ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_act_disable_listening ()");
 
   nfa_dm_cb.flags |= NFA_DM_FLAGS_LISTEN_DISABLED;
   evt_data.status = NFA_STATUS_OK;
@@ -1234,14 +1215,14 @@ bool nfa_dm_act_disable_listening(tNFA_DM_MSG* p_data) {
 ** Returns          true (message buffer to be freed by caller)
 **
 *******************************************************************************/
-bool nfa_dm_act_disable_passive_listening(tNFA_DM_MSG* p_data) {
+bool nfa_dm_act_disable_passive_listening(__attribute__((unused)) tNFA_DM_MSG* p_data) {
     if(!nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) {
-        NFA_TRACE_DEBUG0("NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION feature is not available!!");
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION feature is not available!!");
         return false;
     }
   tNFA_CONN_EVT_DATA evt_data;
 
-  NFA_TRACE_DEBUG0("nfa_dm_act_disable_passive_listening ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_act_disable_passive_listening ()");
 
   nfa_dm_cb.flags |= NFA_DM_FLAGS_PASSIVE_LISTEN_DISABLED;
   evt_data.status = NFA_STATUS_OK;
@@ -1249,6 +1230,28 @@ bool nfa_dm_act_disable_passive_listening(tNFA_DM_MSG* p_data) {
 
   return (true);
 }
+/*******************************************************************************
+**
+** Function         nfa_dm_set_transit_config
+**
+** Description      Sends transit configuration NFC Hal
+**
+** Returns          true (message buffer to be freed by caller)
+**
+*******************************************************************************/
+bool nfa_dm_set_transit_config(tNFA_DM_MSG* p_data) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
+  nfc_nci_IoctlInOutData_t inpOutData;
+  tNFA_DM_CBACK_DATA dm_cback_data;
+  dm_cback_data.set_transit_config.status = NFA_STATUS_OK;
+  inpOutData.inp.data.transitConfig.val =
+      p_data->transit_config.transitConfig;
+  inpOutData.inp.data.transitConfig.len =
+      strlen(p_data->transit_config.transitConfig);
+  nfc_cb.p_hal->ioctl(HAL_NFC_IOCTL_SET_TRANSIT_CONFIG, (void*)&inpOutData);
+  (*nfa_dm_cb.p_dm_cback)(NFA_DM_SET_TRANSIT_CONFIG_EVT, &dm_cback_data);
+  return true;
+}
 #endif
 /*******************************************************************************
 **
@@ -1259,11 +1262,10 @@ bool nfa_dm_act_disable_passive_listening(tNFA_DM_MSG* p_data) {
 ** Returns          true (message buffer to be freed by caller)
 **
 *******************************************************************************/
-bool nfa_dm_act_pause_p2p(tNFA_DM_MSG* p_data) {
+bool nfa_dm_act_pause_p2p(__attribute__((unused)) tNFA_DM_MSG* p_data) {
   tNFA_CONN_EVT_DATA evt_data;
-  (void)p_data;
 
-  NFA_TRACE_DEBUG0("nfa_dm_act_pause_p2p ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_act_pause_p2p ()");
 
   nfa_dm_cb.flags |= NFA_DM_FLAGS_P2P_PAUSED;
   evt_data.status = NFA_STATUS_OK;
@@ -1281,11 +1283,10 @@ bool nfa_dm_act_pause_p2p(tNFA_DM_MSG* p_data) {
 ** Returns          true (message buffer to be freed by caller)
 **
 *******************************************************************************/
-bool nfa_dm_act_resume_p2p(tNFA_DM_MSG* p_data) {
+bool nfa_dm_act_resume_p2p(__attribute__((unused)) tNFA_DM_MSG* p_data) {
   tNFA_CONN_EVT_DATA evt_data;
-  (void)(p_data);
 
-  NFA_TRACE_DEBUG0("nfa_dm_act_resume_p2p ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_act_resume_p2p ()");
 
   nfa_dm_cb.flags &= ~NFA_DM_FLAGS_P2P_PAUSED;
   evt_data.status = NFA_STATUS_OK;
@@ -1306,7 +1307,7 @@ bool nfa_dm_act_resume_p2p(tNFA_DM_MSG* p_data) {
 bool nfa_dm_act_send_raw_frame(tNFA_DM_MSG* p_data) {
   tNFC_STATUS status = NFC_STATUS_FAILED;
 
-  NFA_TRACE_DEBUG0("nfa_dm_act_send_raw_frame ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_act_send_raw_frame ()");
 
   /* If NFC link is activated */
   if ((nfa_dm_cb.disc_cb.disc_state == NFA_DM_RFST_POLL_ACTIVE) ||
@@ -1321,7 +1322,7 @@ bool nfa_dm_act_send_raw_frame(tNFA_DM_MSG* p_data) {
          (nfa_dm_cb.disc_cb.activated_protocol == NFA_PROTOCOL_T2T) ||
          (nfa_dm_cb.disc_cb.activated_protocol == NFA_PROTOCOL_T3T) ||
          (nfa_dm_cb.disc_cb.activated_protocol == NFA_PROTOCOL_ISO_DEP) ||
-         (nfa_dm_cb.disc_cb.activated_protocol == NFA_PROTOCOL_ISO15693))) {
+         (nfa_dm_cb.disc_cb.activated_protocol == NFA_PROTOCOL_T5T))) {
       /* if RW is checking presence then it will put into pending queue */
       status = nfa_rw_send_raw_frame((NFC_HDR*)p_data);
     } else {
@@ -1354,7 +1355,7 @@ bool nfa_dm_act_send_raw_frame(tNFA_DM_MSG* p_data) {
 **
 *******************************************************************************/
 bool nfa_dm_set_p2p_listen_tech(tNFA_DM_MSG* p_data) {
-  NFA_TRACE_DEBUG1("nfa_dm_set_p2p_listen_tech ()  tech_mask = %d",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_set_p2p_listen_tech ()  tech_mask = %d",
                    p_data->set_p2p_listen_tech.tech_mask);
 
   nfa_p2p_update_listen_tech(p_data->set_p2p_listen_tech.tech_mask);
@@ -1372,11 +1373,10 @@ bool nfa_dm_set_p2p_listen_tech(tNFA_DM_MSG* p_data) {
 ** Returns          true (message buffer to be freed by caller)
 **
 *******************************************************************************/
-bool nfa_dm_act_start_rf_discovery(tNFA_DM_MSG* p_data) {
+bool nfa_dm_act_start_rf_discovery(__attribute__((unused)) tNFA_DM_MSG* p_data) {
   tNFA_CONN_EVT_DATA evt_data;
-  (void)p_data;
 
-  NFA_TRACE_DEBUG0("nfa_dm_act_start_rf_discovery ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_act_start_rf_discovery ()");
 
   if (nfa_dm_cb.disc_cb.disc_flags & NFA_DM_DISC_FLAGS_ENABLED) {
     evt_data.status = NFA_STATUS_OK;
@@ -1402,11 +1402,10 @@ bool nfa_dm_act_start_rf_discovery(tNFA_DM_MSG* p_data) {
 ** Returns          true (message buffer to be freed by caller)
 **
 *******************************************************************************/
-bool nfa_dm_act_stop_rf_discovery(tNFA_DM_MSG* p_data) {
+bool nfa_dm_act_stop_rf_discovery(__attribute__((unused)) tNFA_DM_MSG* p_data) {
   tNFA_CONN_EVT_DATA evt_data;
-  (void)p_data;
 
-  NFA_TRACE_DEBUG0("nfa_dm_act_stop_rf_discovery ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_act_stop_rf_discovery ()");
 
 #if (NXP_EXTNS == TRUE)
   /* Reset P2P prio logic if deactivate is called from app layer */
@@ -1473,7 +1472,7 @@ uint16_t nfa_dm_act_get_rf_disc_duration() {
 **
 *******************************************************************************/
 bool nfa_dm_act_select(tNFA_DM_MSG* p_data) {
-  NFA_TRACE_DEBUG0("nfa_dm_act_select ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_act_select ()");
 
   nfa_dm_rf_discover_select(p_data->select.rf_disc_id, p_data->select.protocol,
                             p_data->select.rf_interface);
@@ -1492,7 +1491,7 @@ bool nfa_dm_act_select(tNFA_DM_MSG* p_data) {
 bool nfa_dm_act_update_rf_params(tNFA_DM_MSG* p_data) {
   tNFA_CONN_EVT_DATA conn_evt;
 
-  NFA_TRACE_DEBUG0("nfa_dm_act_update_rf_params ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_act_update_rf_params ()");
 
   if (NFC_UpdateRFCommParams(&p_data->update_rf_params.params) !=
       NFC_STATUS_OK) {
@@ -1512,12 +1511,10 @@ bool nfa_dm_act_update_rf_params(tNFA_DM_MSG* p_data) {
 ** Returns          true (message buffer to be freed by caller)
 **
 *******************************************************************************/
-bool nfa_dm_act_disable_timeout(tNFA_DM_MSG* p_data) {
-  tNFA_DM_API_DISABLE disable;
-  (void)p_data;
-
-  disable.graceful = false;
-  nfa_dm_disable((void*)&disable);
+bool nfa_dm_act_disable_timeout(__attribute__((unused)) tNFA_DM_MSG* p_data) {
+  tNFA_DM_MSG nfa_dm_msg;
+  nfa_dm_msg.disable.graceful = false;
+  nfa_dm_disable(&nfa_dm_msg);
   return (true);
 }
 
@@ -1531,7 +1528,7 @@ bool nfa_dm_act_disable_timeout(tNFA_DM_MSG* p_data) {
 **
 *******************************************************************************/
 void nfa_dm_act_conn_cback_notify(uint8_t event, tNFA_CONN_EVT_DATA* p_data) {
-  NFA_TRACE_DEBUG1("nfa_dm_act_conn_cback_notify (): event:0x%X", event);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_act_conn_cback_notify (): event:0x%X", event);
 
   /* Notify event using appropriate CONN_CBACK */
   nfa_dm_conn_cback_event_notify(event, p_data);
@@ -1565,13 +1562,12 @@ void nfa_dm_act_conn_cback_notify(uint8_t event, tNFA_CONN_EVT_DATA* p_data) {
 ** Returns          None
 **
 *******************************************************************************/
-static void nfa_dm_act_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
-                                  tNFC_CONN* p_data) {
+static void nfa_dm_act_data_cback(__attribute__((unused)) uint8_t conn_id,
+                                  tNFC_CONN_EVT event, tNFC_CONN* p_data) {
   NFC_HDR* p_msg;
   tNFA_CONN_EVT_DATA evt_data;
-  (void)conn_id;
 
-  NFA_TRACE_DEBUG1("nfa_dm_act_data_cback (): event = 0x%X", event);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_act_data_cback (): event = 0x%X", event);
 
   if (event == NFC_DATA_CEVT) {
     p_msg = (NFC_HDR*)p_data->data.p_data;
@@ -1585,7 +1581,7 @@ static void nfa_dm_act_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
 
       GKI_freebuf(p_msg);
     } else {
-      NFA_TRACE_ERROR0(
+      LOG(ERROR) << StringPrintf(
           "nfa_dm_act_data_cback (): received NFC_DATA_CEVT with NULL data "
           "pointer");
     }
@@ -1607,7 +1603,7 @@ static void nfa_dm_excl_disc_cback(tNFA_DM_RF_DISC_EVT event,
                                    tNFC_DISCOVER* p_data) {
   tNFA_CONN_EVT_DATA evt_data;
 
-  NFA_TRACE_DEBUG1("nfa_dm_excl_disc_cback (): event:0x%02X", event);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_excl_disc_cback (): event:0x%02X", event);
 
   switch (event) {
     case NFA_DM_RF_DISC_START_EVT:
@@ -1645,7 +1641,7 @@ static void nfa_dm_excl_disc_cback(tNFA_DM_RF_DISC_EVT event,
               (nfa_dm_cb.disc_cb.activated_protocol == NFC_PROTOCOL_T2T) ||
               (nfa_dm_cb.disc_cb.activated_protocol == NFC_PROTOCOL_T3T) ||
               (nfa_dm_cb.disc_cb.activated_protocol == NFC_PROTOCOL_ISO_DEP) ||
-              (nfa_dm_cb.disc_cb.activated_protocol == NFA_PROTOCOL_ISO15693) ||
+              (nfa_dm_cb.disc_cb.activated_protocol == NFA_PROTOCOL_T5T) ||
               (nfa_dm_cb.disc_cb.activated_protocol == NFC_PROTOCOL_KOVIO)) {
             /* Notify NFA tag sub-system */
             nfa_rw_proc_disc_evt(NFA_DM_RF_DISC_ACTIVATED_EVT, p_data, false);
@@ -1692,7 +1688,7 @@ static void nfa_dm_excl_disc_cback(tNFA_DM_RF_DISC_EVT event,
       break;
 
     default:
-      NFA_TRACE_ERROR0("Unexpected event");
+      LOG(ERROR) << StringPrintf("Unexpected event");
       break;
   }
 }
@@ -1710,7 +1706,7 @@ static void nfa_dm_poll_disc_cback(tNFA_DM_RF_DISC_EVT event,
                                    tNFC_DISCOVER* p_data) {
   tNFA_CONN_EVT_DATA evt_data;
 
-  NFA_TRACE_DEBUG1("nfa_dm_poll_disc_cback (): event:0x%02X", event);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_poll_disc_cback (): event:0x%02X", event);
 
   switch (event) {
     case NFA_DM_RF_DISC_START_EVT:
@@ -1731,21 +1727,17 @@ static void nfa_dm_poll_disc_cback(tNFA_DM_RF_DISC_EVT event,
       if (nfa_dm_cb.p_activate_ntf) {
         memcpy(nfa_dm_cb.p_activate_ntf, &(p_data->activate),
                sizeof(tNFC_ACTIVATE_DEVT));
-
         if ((nfa_dm_cb.disc_cb.activated_protocol == NFC_PROTOCOL_NFC_DEP) &&
-            ((nfa_dm_cb.disc_cb.activated_rf_interface ==
-              NFC_INTERFACE_NFC_DEP))) {
-#if (NXP_EXTNS == TRUE)
-          /*For P2P mode(Default DTA mode) open Raw channel to bypass LLCP
-           * layer. For LLCP DTA mode activate LLCP*/
+            (nfa_dm_cb.disc_cb.activated_rf_interface ==
+             NFC_INTERFACE_NFC_DEP)) {
+          /* For P2P mode(Default DTA mode) open Raw channel to bypass LLCP
+           * layer. For LLCP DTA mode activate LLCP */
           if ((appl_dta_mode_flag == 1) &&
               ((nfa_dm_cb.eDtaMode & 0x0F) == NFA_DTA_DEFAULT_MODE)) {
             /* Open raw channel in case of p2p for DTA testing */
             NFC_SetStaticRfCback(nfa_dm_act_data_cback);
             nfa_dm_notify_activation_status(NFA_STATUS_OK, NULL);
-
           } else {
-#endif
             if (!(nfa_dm_cb.flags & NFA_DM_FLAGS_P2P_PAUSED)) {
               /* activate LLCP */
               nfa_p2p_activate_llcp(p_data);
@@ -1754,19 +1746,16 @@ static void nfa_dm_poll_disc_cback(tNFA_DM_RF_DISC_EVT event,
                 nfa_dm_cb.p_activate_ntf = NULL;
               }
             } else {
-              NFA_TRACE_DEBUG0("P2P is paused");
+              DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("P2P is paused");
               nfa_dm_notify_activation_status(NFA_STATUS_OK, NULL);
             }
-#if (NXP_EXTNS == TRUE)
           }
-#endif
         } else if ((nfa_dm_cb.disc_cb.activated_protocol == NFC_PROTOCOL_T1T) ||
                    (nfa_dm_cb.disc_cb.activated_protocol == NFC_PROTOCOL_T2T) ||
                    (nfa_dm_cb.disc_cb.activated_protocol == NFC_PROTOCOL_T3T) ||
                    (nfa_dm_cb.disc_cb.activated_protocol ==
                     NFC_PROTOCOL_ISO_DEP) ||
-                   (nfa_dm_cb.disc_cb.activated_protocol ==
-                    NFC_PROTOCOL_15693) ||
+                   (nfa_dm_cb.disc_cb.activated_protocol == NFC_PROTOCOL_T5T) ||
                    (nfa_dm_cb.disc_cb.activated_protocol ==
                     NFC_PROTOCOL_KOVIO) ||
                    (nfa_dm_cb.disc_cb.activated_protocol == NFC_PROTOCOL_MIFARE)
@@ -1799,8 +1788,7 @@ static void nfa_dm_poll_disc_cback(tNFA_DM_RF_DISC_EVT event,
       }
 
       if ((nfa_dm_cb.disc_cb.activated_protocol == NFC_PROTOCOL_NFC_DEP) &&
-          ((nfa_dm_cb.disc_cb.activated_rf_interface ==
-            NFC_INTERFACE_NFC_DEP))) {
+          (nfa_dm_cb.disc_cb.activated_rf_interface == NFC_INTERFACE_NFC_DEP)) {
         /*
         ** If LLCP link is not deactivated yet,
         ** LLCP will receive deactivation ntf through data callback.
@@ -1854,12 +1842,10 @@ static void nfa_dm_poll_disc_cback(tNFA_DM_RF_DISC_EVT event,
 ** Returns          None
 **
 *******************************************************************************/
-#if (NXP_EXTNS == TRUE)
 void nfa_dm_poll_disc_cback_dta_wrapper(tNFA_DM_RF_DISC_EVT event,
                                         tNFC_DISCOVER* p_data) {
   nfa_dm_poll_disc_cback(event, p_data);
 }
-#endif
 
 /*******************************************************************************
 **
@@ -1876,7 +1862,7 @@ void nfa_dm_notify_activation_status(tNFA_STATUS status,
   tNFC_RF_TECH_PARAMS* p_tech_params;
   uint8_t* p_nfcid = NULL, nfcid_len;
 
-  NFA_TRACE_DEBUG1("nfa_dm_notify_activation_status (): status:0x%X", status);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_notify_activation_status (): status:0x%X", status);
 
   if (!nfa_dm_cb.p_activate_ntf) {
     /* this is for NFA P2P listen */
@@ -1929,7 +1915,7 @@ void nfa_dm_notify_activation_status(tNFA_STATUS status,
               (tNFC_ACTIVATE_DEVT*)nfa_dm_cb.p_activate_ntf;
           p_nfcid = activate_ntf->rf_tech_param.param.pb.pupiid;
           nfcid_len = activate_ntf->rf_tech_param.param.pb.pupiid_len;
-          NFA_TRACE_DEBUG1(
+           DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
               "nfa_dm_notify_activation_status (): update pupi_len=%x",
               nfcid_len);
           memcpy(evt_data.activated.activate_ntf.rf_tech_param.param.pb.pupiid,
@@ -1940,7 +1926,7 @@ void nfa_dm_notify_activation_status(tNFA_STATUS status,
     } else if (p_tech_params->mode == NFC_DISCOVERY_TYPE_POLL_F) {
       nfcid_len = NFC_NFCID2_LEN;
       p_nfcid = p_tech_params->param.pf.nfcid2;
-    } else if (p_tech_params->mode == NFC_DISCOVERY_TYPE_POLL_ISO15693) {
+    } else if (p_tech_params->mode == NFC_DISCOVERY_TYPE_POLL_V) {
       nfcid_len = NFC_ISO15693_UID_LEN;
       p_nfcid = p_tech_params->param.pi93.uid;
     } else if (p_tech_params->mode == NFC_DISCOVERY_TYPE_POLL_KOVIO) {
@@ -1976,7 +1962,7 @@ void nfa_dm_notify_activation_status(tNFA_STATUS status,
             ((nfa_dm_cb.disc_cb.activated_protocol == NFC_PROTOCOL_ISO_DEP) &&
              (nfa_dm_cb.disc_cb.activated_rf_interface ==
               NFC_INTERFACE_ISO_DEP)) ||
-            (nfa_dm_cb.disc_cb.activated_protocol == NFA_PROTOCOL_ISO15693)) {
+            (nfa_dm_cb.disc_cb.activated_protocol == NFA_PROTOCOL_T5T)) {
           if (p_nfa_dm_cfg->auto_detect_ndef) {
             if (p_nfa_dm_cfg->auto_read_ndef) {
               nfa_dm_cb.flags |= NFA_DM_FLAGS_AUTO_READING_NDEF;
@@ -2008,7 +1994,6 @@ void nfa_dm_notify_activation_status(tNFA_STATUS status,
   nfa_dm_cb.p_activate_ntf = NULL;
 }
 
-#if (BT_TRACE_VERBOSE == true)
 /*******************************************************************************
 **
 ** Function         nfa_dm_nfc_revt_2_str
@@ -2016,7 +2001,7 @@ void nfa_dm_notify_activation_status(tNFA_STATUS status,
 ** Description      convert nfc revt to string
 **
 *******************************************************************************/
-char* nfa_dm_nfc_revt_2_str(tNFC_RESPONSE_EVT event) {
+std::string nfa_dm_nfc_revt_2_str(tNFC_RESPONSE_EVT event) {
   switch (event) {
     case NFC_ENABLE_REVT:
       return "NFC_ENABLE_REVT";
@@ -2077,10 +2062,10 @@ char* nfa_dm_nfc_revt_2_str(tNFC_RESPONSE_EVT event) {
         if(nfcFL.eseFL._WIRED_MODE_STANDBY) {
             return "NFC_NFCEE_PWR_LNK_CTRL_REVT";
         }
+        [[fallthrough]];
 #endif
     default:
       return "unknown revt";
       break;
   }
 }
-#endif /* BT_VERBOSE */
diff --git a/src/nfa/dm/nfa_dm_api.c b/src/nfa/dm/nfa_dm_api.cc
similarity index 87%
rename from src/nfa/dm/nfa_dm_api.c
rename to src/nfa/dm/nfa_dm_api.cc
index 5fd8993..80e8ace 100644
--- a/src/nfa/dm/nfa_dm_api.c
+++ b/src/nfa/dm/nfa_dm_api.cc
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -41,17 +41,27 @@
  *
  ******************************************************************************/
 #include <string.h>
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfa_api.h"
-#include "nfa_sys.h"
-#include "nfa_dm_int.h"
 #include "nfa_ce_int.h"
-#include "nfa_sys_int.h"
 #include "ndef_utils.h"
 #if (NXP_EXTNS == TRUE)
+#ifdef ENABLE_ESE_CLIENT
+#include "hal_nxpese.h"
+#endif
+#include "nfa_sys_int.h"
+
 uint32_t gFelicaReaderMode;
 tHAL_NFC_CONTEXT hal_Initcntxt;
 #endif
 
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+
 /*****************************************************************************
 **  Constants
 *****************************************************************************/
@@ -74,7 +84,7 @@ tHAL_NFC_CONTEXT hal_Initcntxt;
 **
 *******************************************************************************/
 void NFA_Init(tHAL_NFC_ENTRY* p_hal_entry_tbl) {
-  NFA_TRACE_API0("NFA_Init ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
 #if (NXP_EXTNS == TRUE)
   hal_Initcntxt.hal_entry_func = p_hal_entry_tbl;
 #endif
@@ -129,11 +139,11 @@ tNFA_STATUS NFA_Enable(tNFA_DM_CBACK* p_dm_cback,
                        tNFA_CONN_CBACK* p_conn_cback) {
   tNFA_DM_API_ENABLE* p_msg;
 
-  NFA_TRACE_API0("NFA_Enable ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
 
   /* Validate parameters */
   if ((!p_dm_cback) || (!p_conn_cback)) {
-    NFA_TRACE_ERROR0("NFA_Enable (): error null callback");
+    LOG(ERROR) << StringPrintf("NFA_Enable (): error null callback");
     return (NFA_STATUS_FAILED);
   }
 
@@ -174,7 +184,7 @@ tNFA_STATUS NFA_Enable(tNFA_DM_CBACK* p_dm_cback,
 tNFA_STATUS NFA_Disable(bool graceful) {
   tNFA_DM_API_DISABLE* p_msg;
 
-  NFA_TRACE_API1("NFA_Disable (graceful=%i)", graceful);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_Disable (graceful=%i)", graceful);
 
   p_msg = (tNFA_DM_API_DISABLE*)GKI_getbuf(sizeof(tNFA_DM_API_DISABLE));
   if (p_msg != NULL) {
@@ -188,55 +198,53 @@ tNFA_STATUS NFA_Disable(bool graceful) {
 
   return (NFA_STATUS_FAILED);
 }
-
 /*******************************************************************************
 **
-** Function         NFA_SetPowerSubState
+** Function         NFA_SetPowerSubStateForScreenState
 **
-** Description      send the current screen state to NFCC
+** Description      Update the power sub-state as per current screen state to
+**                  NFCC.
 **
 ** Returns          NFA_STATUS_OK if successfully initiated
 **                  NFA_STATUS_FAILED otherwise
 **
 *******************************************************************************/
-tNFA_STATUS NFA_SetPowerSubState (uint8_t ScreenState)
-{
-  tNFA_DM_API_SET_POWER_SUB_STATE *p_msg;
-  uint8_t nci_scren_state = 0xFF;
-
-  NFA_TRACE_API1 ("NFA_SetPowerSubState (): state:0x%X", ScreenState);
+tNFA_STATUS NFA_SetPowerSubStateForScreenState(uint8_t screenState) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: state:0x%X", __func__, screenState);
 
+  uint8_t nci_scren_state = 0xFF;
+  uint16_t buf_size = sizeof(tNFA_DM_API_SET_POWER_SUB_STATE);
+  tNFA_DM_API_SET_POWER_SUB_STATE* p_msg =
+      (tNFA_DM_API_SET_POWER_SUB_STATE*)GKI_getbuf(buf_size);
 
-  if ((p_msg = (tNFA_DM_API_SET_POWER_SUB_STATE *) GKI_getbuf ((uint16_t) (sizeof (tNFA_DM_API_SET_POWER_SUB_STATE)))) != NULL)
-  {
+  if (p_msg != NULL) {
     p_msg->hdr.event = NFA_DM_API_SET_POWER_SUB_STATE_EVT;
-    switch (ScreenState){
+    switch (screenState) {
       case NFA_SCREEN_STATE_ON_UNLOCKED:
-         nci_scren_state = SCREEN_STATE_ON_UNLOCKED;
-         break;
+        nci_scren_state = SCREEN_STATE_ON_UNLOCKED;
+        break;
       case NFA_SCREEN_STATE_OFF_UNLOCKED:
-         nci_scren_state = SCREEN_STATE_OFF_UNLOCKED;
-         break;
+        nci_scren_state = SCREEN_STATE_OFF_UNLOCKED;
+        break;
       case NFA_SCREEN_STATE_ON_LOCKED:
-         nci_scren_state = SCREEN_STATE_ON_LOCKED;
-         break;
+        nci_scren_state = SCREEN_STATE_ON_LOCKED;
+        break;
       case NFA_SCREEN_STATE_OFF_LOCKED:
-         nci_scren_state = SCREEN_STATE_OFF_LOCKED;
-         break;
+        nci_scren_state = SCREEN_STATE_OFF_LOCKED;
+        break;
+
       default:
-         NFA_TRACE_API1("%s, unknown screen state", __FUNCTION__);
-         break;
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s, unknown screen state", __func__);
+        break;
     }
-    if(nci_scren_state != 0xFF) {
-      p_msg->screen_state = nci_scren_state;
 
-      nfa_sys_sendmsg (p_msg);
-        return (NFA_STATUS_OK);
-    }
+    p_msg->screen_state = nci_scren_state;
+
+    nfa_sys_sendmsg(p_msg);
+    return (NFA_STATUS_OK);
   }
   return (NFA_STATUS_FAILED);
 }
-
 /*******************************************************************************
 **
 ** Function         NFA_SetConfig
@@ -258,7 +266,7 @@ tNFA_STATUS NFA_SetPowerSubState (uint8_t ScreenState)
 tNFA_STATUS NFA_SetConfig(tNFA_PMID param_id, uint8_t length, uint8_t* p_data) {
   tNFA_DM_API_SET_CONFIG* p_msg;
 
-  NFA_TRACE_API1("NFA_SetConfig (): param_id:0x%X", param_id);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_SetConfig (): param_id:0x%X", param_id);
 
   p_msg = (tNFA_DM_API_SET_CONFIG*)GKI_getbuf(
       (uint16_t)(sizeof(tNFA_DM_API_SET_CONFIG) + length));
@@ -298,7 +306,7 @@ tNFA_STATUS NFA_GetConfig(uint8_t num_ids, tNFA_PMID* p_param_ids) {
   uint8_t bytes;
   uint8_t propConfigCnt;
 
-  NFA_TRACE_API1("NFA_GetConfig (): num_ids: %i", num_ids);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_GetConfig (): num_ids: %i", num_ids);
   // NXP_EXTN code added to handle propritory config IDs
   uint32_t idx = 0;
   uint8_t* params = p_param_ids;
@@ -317,7 +325,7 @@ tNFA_STATUS NFA_GetConfig(uint8_t num_ids, tNFA_PMID* p_param_ids) {
   p_msg = (tNFA_DM_API_GET_CONFIG*)GKI_getbuf(
       (uint16_t)(sizeof(tNFA_DM_API_GET_CONFIG) + bytes));
 #else
-  NFA_TRACE_API1("NFA_GetConfig (): num_ids: %i", num_ids);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_GetConfig (): num_ids: %i", num_ids);
   p_msg = (tNFA_DM_API_GET_CONFIG*)GKI_getbuf(
       (uint16_t)(sizeof(tNFA_DM_API_GET_CONFIG) + num_ids));
 #endif
@@ -342,6 +350,33 @@ tNFA_STATUS NFA_GetConfig(uint8_t num_ids, tNFA_PMID* p_param_ids) {
   return (NFA_STATUS_FAILED);
 }
 
+/*******************************************************************************
+**
+** Function         NFA_SetTransitConfig
+**
+** Description      Get the Transit configuration value from NFC Service. The
+**                  result is reported with an NFA_DM_SET_TRANSIT_CONFIG_EVT in
+**                  the tNFA_DM_CBACK callback.
+**
+** Returns          NFA_STATUS_OK if successfully initiated
+**                  NFA_STATUS_FAILED otherwise
+**
+*******************************************************************************/
+tNFA_STATUS NFA_SetTransitConfig(std::string config) {
+  tNFA_DM_API_SET_TRANSIT_CONFIG* p_msg;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s ", __func__);
+  p_msg = (tNFA_DM_API_SET_TRANSIT_CONFIG*)GKI_getbuf(
+      sizeof(tNFA_DM_API_SET_TRANSIT_CONFIG));
+
+  if (p_msg != NULL) {
+    p_msg->hdr.event = NFA_DM_SET_TRANSIT_CONFIG;
+    p_msg->transitConfig = (char*)config.c_str();
+
+    nfa_sys_sendmsg(p_msg);
+    return (NFA_STATUS_OK);
+  }
+  return (NFA_STATUS_FAILED);
+}
 /*******************************************************************************
 **
 ** Function         NFA_RequestExclusiveRfControl
@@ -383,10 +418,10 @@ tNFA_STATUS NFA_RequestExclusiveRfControl(tNFA_TECHNOLOGY_MASK poll_mask,
                                           tNFA_NDEF_CBACK* p_ndef_cback) {
   tNFA_DM_API_REQ_EXCL_RF_CTRL* p_msg;
 
-  NFA_TRACE_API1("NFA_RequestExclusiveRfControl () poll_mask=0x%x", poll_mask);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_RequestExclusiveRfControl () poll_mask=0x%x", poll_mask);
 
   if (!p_conn_cback) {
-    NFA_TRACE_ERROR0("NFA_RequestExclusiveRfControl (): error null callback");
+    LOG(ERROR) << StringPrintf("NFA_RequestExclusiveRfControl (): error null callback");
     return (NFA_STATUS_FAILED);
   }
 
@@ -425,10 +460,10 @@ tNFA_STATUS NFA_RequestExclusiveRfControl(tNFA_TECHNOLOGY_MASK poll_mask,
 tNFA_STATUS NFA_ReleaseExclusiveRfControl(void) {
   NFC_HDR* p_msg;
 
-  NFA_TRACE_API0("NFA_ReleaseExclusiveRfControl ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
 
   if (!nfa_dm_cb.p_excl_conn_cback) {
-    NFA_TRACE_ERROR0(
+    LOG(ERROR) << StringPrintf(
         "NFA_ReleaseExclusiveRfControl (): Exclusive rf control is not in "
         "progress");
     return (NFA_STATUS_FAILED);
@@ -482,7 +517,7 @@ tNFA_STATUS NFA_ReleaseExclusiveRfControl(void) {
 tNFA_STATUS NFA_EnablePolling(tNFA_TECHNOLOGY_MASK poll_mask) {
   tNFA_DM_API_ENABLE_POLL* p_msg;
 
-  NFA_TRACE_API1("NFA_EnablePolling () 0x%X", poll_mask);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_EnablePolling () 0x%X", poll_mask);
 
   p_msg = (tNFA_DM_API_ENABLE_POLL*)GKI_getbuf(sizeof(tNFA_DM_API_ENABLE_POLL));
   if (p_msg != NULL) {
@@ -516,7 +551,7 @@ tNFA_STATUS NFA_EnablePolling(tNFA_TECHNOLOGY_MASK poll_mask) {
 tNFA_STATUS NFA_DisablePolling(void) {
   NFC_HDR* p_msg;
 
-  NFA_TRACE_API0("NFA_DisablePolling ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
 
   p_msg = (NFC_HDR*)GKI_getbuf(sizeof(NFC_HDR));
   if (p_msg != NULL) {
@@ -556,7 +591,7 @@ tNFA_STATUS NFA_DisablePolling(void) {
 tNFA_STATUS NFA_EnableListening(void) {
   NFC_HDR* p_msg;
 
-  NFA_TRACE_API0("NFA_EnableListening ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
 
   p_msg = (NFC_HDR*)GKI_getbuf(sizeof(NFC_HDR));
   if (p_msg != NULL) {
@@ -590,7 +625,7 @@ tNFA_STATUS NFA_EnableListening(void) {
 tNFA_STATUS NFA_DisableListening(void) {
   NFC_HDR* p_msg;
 
-  NFA_TRACE_API0("NFA_DisableListening ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
 
   p_msg = (NFC_HDR*)GKI_getbuf(sizeof(NFC_HDR));
   if (p_msg != NULL) {
@@ -624,15 +659,15 @@ tNFA_STATUS NFA_DisableListening(void) {
 **
 *******************************************************************************/
 tNFA_STATUS NFA_DisablePassiveListening(void) {
-    NFA_TRACE_API0("NFA_DisablePassiveListening ()");
+    DLOG_IF(INFO, nfc_debug_enabled) << __func__;
     if(!nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION) {
-        NFA_TRACE_DEBUG0(" NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION"
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(" NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION"
                 " feature is not available!!");
         return (NFA_STATUS_FAILED);
     }
   NFC_HDR* p_msg;
 
-  NFA_TRACE_API0("NFA_DisablePassiveListening ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
 
   if ((p_msg = (NFC_HDR*)GKI_getbuf(sizeof(NFC_HDR))) != NULL) {
     p_msg->event = NFA_DM_API_DISABLE_PASSIVE_LISTENING_EVT;
@@ -657,9 +692,9 @@ tNFA_STATUS NFA_DisablePassiveListening(void) {
 **
 *******************************************************************************/
 void NFA_SetPreferredUiccId(uint8_t uicc_id) {
-    NFA_TRACE_API0("NFA_SetPreferredUiccId ()");
+    DLOG_IF(INFO, nfc_debug_enabled) << __func__;
     if(!nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH) {
-        NFA_TRACE_DEBUG0("NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH"
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_NXP_STAT_DUAL_UICC_WO_EXT_SWITCH"
                 " feature is not available!!");
         return;
     }
@@ -690,7 +725,7 @@ void NFA_SetPreferredUiccId(uint8_t uicc_id) {
 tNFA_STATUS NFA_PauseP2p(void) {
   NFC_HDR* p_msg;
 
-  NFA_TRACE_API0("NFA_PauseP2p ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
 
   p_msg = (NFC_HDR*)GKI_getbuf(sizeof(NFC_HDR));
   if (p_msg != NULL) {
@@ -723,7 +758,7 @@ tNFA_STATUS NFA_PauseP2p(void) {
 tNFA_STATUS NFA_ResumeP2p(void) {
   NFC_HDR* p_msg;
 
-  NFA_TRACE_API0("NFA_ResumeP2p ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
 
   p_msg = (NFC_HDR*)GKI_getbuf(sizeof(NFC_HDR));
   if (p_msg != NULL) {
@@ -760,7 +795,7 @@ tNFA_STATUS NFA_ResumeP2p(void) {
 tNFA_STATUS NFA_SetP2pListenTech(tNFA_TECHNOLOGY_MASK tech_mask) {
   tNFA_DM_API_SET_P2P_LISTEN_TECH* p_msg;
 
-  NFA_TRACE_API1("NFA_P2pSetListenTech (): tech_mask:0x%X", tech_mask);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_P2pSetListenTech (): tech_mask:0x%X", tech_mask);
 
   p_msg = (tNFA_DM_API_SET_P2P_LISTEN_TECH*)GKI_getbuf(
       sizeof(tNFA_DM_API_SET_P2P_LISTEN_TECH));
@@ -793,7 +828,7 @@ tNFA_STATUS NFA_SetP2pListenTech(tNFA_TECHNOLOGY_MASK tech_mask) {
 tNFA_STATUS NFA_StartRfDiscovery(void) {
   NFC_HDR* p_msg;
 
-  NFA_TRACE_API0("NFA_StartRfDiscovery ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
 
   p_msg = (NFC_HDR*)GKI_getbuf(sizeof(NFC_HDR));
   if (p_msg != NULL) {
@@ -823,7 +858,7 @@ tNFA_STATUS NFA_StartRfDiscovery(void) {
 tNFA_STATUS NFA_StopRfDiscovery(void) {
   NFC_HDR* p_msg;
 
-  NFA_TRACE_API0("NFA_StopRfDiscovery ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
 
   p_msg = (NFC_HDR*)GKI_getbuf(sizeof(NFC_HDR));
   if (p_msg != NULL) {
@@ -862,7 +897,7 @@ tNFA_STATUS NFA_StopRfDiscovery(void) {
 tNFA_STATUS NFA_SetRfDiscoveryDuration(uint16_t discovery_period_ms) {
   tNFA_DM_API_SET_RF_DISC_DUR* p_msg;
 
-  NFA_TRACE_API0("NFA_SetRfDiscoveryDuration ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
 
   /* Post the API message */
   p_msg = (tNFA_DM_API_SET_RF_DISC_DUR*)GKI_getbuf(sizeof(NFC_HDR));
@@ -902,7 +937,7 @@ tNFA_STATUS NFA_Select(uint8_t rf_disc_id, tNFA_NFC_PROTOCOL protocol,
                        tNFA_INTF_TYPE rf_interface) {
   tNFA_DM_API_SELECT* p_msg;
 
-  NFA_TRACE_API3(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "NFA_Select (): rf_disc_id:0x%X, protocol:0x%X, rf_interface:0x%X",
       rf_disc_id, protocol, rf_interface);
 
@@ -910,7 +945,7 @@ tNFA_STATUS NFA_Select(uint8_t rf_disc_id, tNFA_NFC_PROTOCOL protocol,
        (protocol != NFA_PROTOCOL_ISO_DEP)) ||
       ((rf_interface == NFA_INTERFACE_NFC_DEP) &&
        (protocol != NFA_PROTOCOL_NFC_DEP))) {
-    NFA_TRACE_ERROR0("NFA_Select (): RF interface is not matched protocol");
+    LOG(ERROR) << StringPrintf("NFA_Select (): RF interface is not matched protocol");
     return (NFA_STATUS_INVALID_PARAM);
   }
 
@@ -947,7 +982,7 @@ tNFA_STATUS NFA_Select(uint8_t rf_disc_id, tNFA_NFC_PROTOCOL protocol,
 tNFA_STATUS NFA_UpdateRFCommParams(tNFA_RF_COMM_PARAMS* p_params) {
   tNFA_DM_API_UPDATE_RF_PARAMS* p_msg;
 
-  NFA_TRACE_API0("NFA_UpdateRFCommParams ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
 
   p_msg = (tNFA_DM_API_UPDATE_RF_PARAMS*)GKI_getbuf(
       (uint16_t)(sizeof(tNFA_DM_API_UPDATE_RF_PARAMS)));
@@ -997,7 +1032,7 @@ tNFA_STATUS NFA_UpdateRFCommParams(tNFA_RF_COMM_PARAMS* p_params) {
 extern tNFA_STATUS NFA_Deactivate(bool sleep_mode) {
   tNFA_DM_API_DEACTIVATE* p_msg;
 
-  NFA_TRACE_API1("NFA_Deactivate (): sleep_mode:%i", sleep_mode);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_Deactivate (): sleep_mode:%i", sleep_mode);
 
   p_msg = (tNFA_DM_API_DEACTIVATE*)GKI_getbuf(
       (uint16_t)(sizeof(tNFA_DM_API_DEACTIVATE)));
@@ -1038,7 +1073,7 @@ tNFA_STATUS NFA_SendRawFrame(uint8_t* p_raw_data, uint16_t data_len,
   uint16_t size;
   uint8_t* p;
 
-  NFA_TRACE_API1("NFA_SendRawFrame () data_len:%d", data_len);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_SendRawFrame () data_len:%d", data_len);
 
 /* Validate parameters */
   if (nfcFL.nfccFL._NXP_NFCC_EMPTY_DATA_PACKET) {
@@ -1054,9 +1089,9 @@ tNFA_STATUS NFA_SendRawFrame(uint8_t* p_raw_data, uint16_t data_len,
       return (NFA_STATUS_INVALID_PARAM);
   }
 
-
   size = NFC_HDR_SIZE + NCI_MSG_OFFSET_SIZE + NCI_DATA_HDR_SIZE + data_len;
   p_msg = (NFC_HDR*)GKI_getbuf(size);
+
   if (p_msg != NULL) {
     p_msg->event = NFA_DM_API_RAW_FRAME_EVT;
     p_msg->layer_specific = presence_check_start_delay;
@@ -1064,13 +1099,13 @@ tNFA_STATUS NFA_SendRawFrame(uint8_t* p_raw_data, uint16_t data_len,
     p_msg->len = data_len;
 
     p = (uint8_t*)(p_msg + 1) + p_msg->offset;
+
     if (nfcFL.nfccFL._NXP_NFCC_EMPTY_DATA_PACKET) {
-        if (p_raw_data != NULL) {
-            memcpy(p, p_raw_data, data_len);
-        }
-    }
-    else {
+      if (p_raw_data != NULL) {
         memcpy(p, p_raw_data, data_len);
+      }
+    } else {
+      memcpy(p, p_raw_data, data_len);
     }
 
     nfa_sys_sendmsg(p_msg);
@@ -1115,14 +1150,14 @@ tNFA_STATUS NFA_RegisterNDefTypeHandler(bool handle_whole_message, tNFA_TNF tnf,
                                         tNFA_NDEF_CBACK* p_ndef_cback) {
   tNFA_DM_API_REG_NDEF_HDLR* p_msg;
 
-  NFA_TRACE_API2(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "NFA_RegisterNDefTypeHandler (): handle whole ndef message: %i, "
       "tnf=0x%02x",
       handle_whole_message, tnf);
 
   /* Check for NULL callback */
   if (!p_ndef_cback) {
-    NFA_TRACE_ERROR0("NFA_RegisterNDefTypeHandler (): error - null callback");
+    LOG(ERROR) << StringPrintf("NFA_RegisterNDefTypeHandler (): error - null callback");
     return (NFA_STATUS_INVALID_PARAM);
   }
 
@@ -1175,14 +1210,14 @@ extern tNFA_STATUS NFA_RegisterNDefUriHandler(bool handle_whole_message,
                                               tNFA_NDEF_CBACK* p_ndef_cback) {
   tNFA_DM_API_REG_NDEF_HDLR* p_msg;
 
-  NFA_TRACE_API2(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "NFA_RegisterNDefUriHandler (): handle whole ndef message: %i, "
       "uri_id=0x%02x",
       handle_whole_message, uri_id);
 
   /* Check for NULL callback */
   if (!p_ndef_cback) {
-    NFA_TRACE_ERROR0("NFA_RegisterNDefUriHandler (): error - null callback");
+    LOG(ERROR) << StringPrintf("NFA_RegisterNDefUriHandler (): error - null callback");
     return (NFA_STATUS_INVALID_PARAM);
   }
 
@@ -1229,7 +1264,7 @@ extern tNFA_STATUS NFA_RegisterNDefUriHandler(bool handle_whole_message,
 extern tNFA_STATUS NFA_DeregisterNDefTypeHandler(tNFA_HANDLE ndef_type_handle) {
   tNFA_DM_API_DEREG_NDEF_HDLR* p_msg;
 
-  NFA_TRACE_API1("NFA_DeregisterNDefHandler (): handle 0x%08x",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_DeregisterNDefHandler (): handle 0x%08x",
                  ndef_type_handle);
 
   p_msg = (tNFA_DM_API_DEREG_NDEF_HDLR*)GKI_getbuf(
@@ -1264,9 +1299,9 @@ extern tNFA_STATUS NFA_DeregisterNDefTypeHandler(tNFA_HANDLE ndef_type_handle) {
 tNFA_STATUS NFA_PowerOffSleepMode(bool start_stop) {
   NFC_HDR* p_msg;
 
-  NFA_TRACE_API1("NFA_PowerOffSleepState () start_stop=%d", start_stop);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_PowerOffSleepState () start_stop=%d", start_stop);
   if (nfa_dm_cb.flags & NFA_DM_FLAGS_SETTING_PWR_MODE) {
-    NFA_TRACE_ERROR0(
+    LOG(ERROR) << StringPrintf(
         "NFA_PowerOffSleepState (): NFA DM is busy to update power mode");
     return (NFA_STATUS_FAILED);
   } else {
@@ -1301,10 +1336,10 @@ tNFA_STATUS NFA_PowerOffSleepMode(bool start_stop) {
 tNFC_STATUS NFA_RegVSCback(bool is_register, tNFA_VSC_CBACK* p_cback) {
   tNFA_DM_API_REG_VSC* p_msg;
 
-  NFA_TRACE_API1("NFA_RegVSCback() is_register=%d", is_register);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_RegVSCback() is_register=%d", is_register);
 
   if (p_cback == NULL) {
-    NFA_TRACE_ERROR0("NFA_RegVSCback() requires a valid callback function");
+    LOG(ERROR) << StringPrintf("NFA_RegVSCback() requires a valid callback function");
     return (NFA_STATUS_FAILED);
   }
 
@@ -1344,7 +1379,7 @@ tNFA_STATUS NFA_SendVsCommand(uint8_t oid, uint8_t cmd_params_len,
   tNFA_DM_API_SEND_VSC* p_msg;
   uint16_t size = sizeof(tNFA_DM_API_SEND_VSC) + cmd_params_len;
 
-  NFA_TRACE_API1("NFA_SendVsCommand() oid=0x%x", oid);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_SendVsCommand() oid=0x%x", oid);
 
   p_msg = (tNFA_DM_API_SEND_VSC*)GKI_getbuf(size);
   if (p_msg != NULL) {
@@ -1368,33 +1403,32 @@ tNFA_STATUS NFA_SendVsCommand(uint8_t oid, uint8_t cmd_params_len,
   return (NFA_STATUS_FAILED);
 }
 
-#if (NXP_EXTNS == TRUE)
 /*******************************************************************************
 **
-** Function         NFA_SendNxpNciCommand
+** Function         NFA_SendRawVsCommand
 **
-** Description      This function is called to send an NXP NCI Vendor Specific
+** Description      This function is called to send raw Vendor Specific
 **                  command to NFCC.
 **
 **                  cmd_params_len  - The command parameter len
 **                  p_cmd_params    - The command parameter
 **                  p_cback         - The callback function to receive the
-*command
+**                                    command
 **
 ** Returns          NFA_STATUS_OK if successfully initiated
 **                  NFA_STATUS_FAILED otherwise
 **
 *******************************************************************************/
-tNFA_STATUS NFA_SendNxpNciCommand(uint8_t cmd_params_len, uint8_t* p_cmd_params,
-                                  tNFA_VSC_CBACK* p_cback) {
+tNFA_STATUS NFA_SendRawVsCommand(uint8_t cmd_params_len, uint8_t* p_cmd_params,
+                                 tNFA_VSC_CBACK* p_cback) {
   if (cmd_params_len == 0x00 || p_cmd_params == NULL || p_cback == NULL) {
-    return (NFA_STATUS_INVALID_PARAM);
+    return NFA_STATUS_INVALID_PARAM;
   }
-  tNFA_DM_API_SEND_VSC* p_msg;
   uint16_t size = sizeof(tNFA_DM_API_SEND_VSC) + cmd_params_len;
+  tNFA_DM_API_SEND_VSC* p_msg = (tNFA_DM_API_SEND_VSC*)GKI_getbuf(size);
 
-  if ((p_msg = (tNFA_DM_API_SEND_VSC*)GKI_getbuf(size)) != NULL) {
-    p_msg->hdr.event = NFA_DM_API_SEND_NXP_EVT;
+  if (p_msg != NULL) {
+    p_msg->hdr.event = NFA_DM_API_SEND_RAW_VS_EVT;
     p_msg->p_cback = p_cback;
     if (cmd_params_len && p_cmd_params) {
       p_msg->cmd_params_len = cmd_params_len;
@@ -1407,27 +1441,25 @@ tNFA_STATUS NFA_SendNxpNciCommand(uint8_t cmd_params_len, uint8_t* p_cmd_params,
 
     nfa_sys_sendmsg(p_msg);
 
-    return (NFA_STATUS_OK);
+    return NFA_STATUS_OK;
   }
 
-  return (NFA_STATUS_FAILED);
+  return NFA_STATUS_FAILED;
 }
-#endif
 
 /*******************************************************************************
 **
-** Function         NFA_SetTraceLevel
+** Function:        NFA_EnableDtamode
 **
-** Description      This function sets the trace level for NFA.  If called with
-**                  a value of 0xFF, it simply returns the current trace level.
+** Description:     Enable DTA Mode
 **
-** Returns          The new or current trace level
+** Returns:         none:
 **
 *******************************************************************************/
-uint8_t NFA_SetTraceLevel(uint8_t new_level) {
-  if (new_level != 0xFF) nfa_sys_set_trace_level(new_level);
-
-  return (nfa_sys_cb.trace_level);
+void NFA_EnableDtamode(tNFA_eDtaModes eDtaMode) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: 0x%x ", __func__, eDtaMode);
+  appl_dta_mode_flag = 0x01;
+  nfa_dm_cb.eDtaMode = eDtaMode;
 }
 #if (NXP_EXTNS == TRUE)
 /*******************************************************************************
@@ -1466,7 +1498,7 @@ bool NFA_checkNfcStateBusy() {
 void NFA_SetReaderMode(bool ReaderModeFlag, uint32_t Technologies) {
   (void)Technologies;
 
-  NFA_TRACE_API1("NFA_SetReaderMode =0x%x", ReaderModeFlag);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_SetReaderMode =0x%x", ReaderModeFlag);
   gFelicaReaderMode = ReaderModeFlag;
   return;
 }
@@ -1484,20 +1516,6 @@ void NFA_SetReaderMode(bool ReaderModeFlag, uint32_t Technologies) {
 **
 *******************************************************************************/
 void NFA_SetBootMode(uint8_t boot_mode) { hal_Initcntxt.boot_mode = boot_mode; }
-/*******************************************************************************
-**
-** Function:        NFA_EnableDtamode
-**
-** Description:     Enable DTA Mode
-**
-** Returns:         none:
-**
-*******************************************************************************/
-void NFA_EnableDtamode(tNFA_eDtaModes eDtaMode) {
-  NFA_TRACE_API1("0x%x: DTA Enabled", eDtaMode);
-  appl_dta_mode_flag = 0x01;
-  nfa_dm_cb.eDtaMode = eDtaMode;
-}
 tNFA_MW_VERSION NFA_GetMwVersion() {
   tNFA_MW_VERSION mwVer;
   mwVer.validation =
@@ -1507,15 +1525,31 @@ tNFA_MW_VERSION NFA_GetMwVersion() {
         | (NXP_EN_PN81A << 9) | (NXP_EN_PN553_MR2 << 10) | (NXP_EN_PN557 << 11)
         | (NXP_EN_PN81T << 12));
   mwVer.android_version = NXP_ANDROID_VER;
-  NFA_TRACE_API1("0x%x:NFC MW Major Version:", NFC_NXP_MW_VERSION_MAJ);
-  NFA_TRACE_API1("0x%x:NFC MW Minor Version:", NFC_NXP_MW_VERSION_MIN);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("0x%x:NFC MW Major Version:", NFC_NXP_MW_VERSION_MAJ);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("0x%x:NFC MW Minor Version:", NFC_NXP_MW_VERSION_MIN);
   mwVer.major_version = NFC_NXP_MW_VERSION_MAJ;
   mwVer.minor_version = NFC_NXP_MW_VERSION_MIN;
-  NFA_TRACE_API2("mwVer:Major=0x%x,Minor=0x%x", mwVer.major_version,
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("mwVer:Major=0x%x,Minor=0x%x", mwVer.major_version,
                  mwVer.minor_version);
   return mwVer;
 }
 
+/*******************************************************************************
+**
+** Function         NFA_SetLowRamDevice
+**
+** Description      This function sets the device is LOW RAM enabled or not
+**                  param mode is either true or false
+**                  true - LOW RAM DEVICE
+**                  false - NOT A LOW RAM DEVICE
+** Returns          none
+**
+*******************************************************************************/
+void NFA_SetLowRamDevice(bool mode)
+{
+  hal_Initcntxt.isLowRam = mode;
+}
+
 /*******************************************************************************
 **
 ** Function:        NFA_ResetNfcc
@@ -1527,9 +1561,9 @@ tNFA_MW_VERSION NFA_GetMwVersion() {
 **
 *******************************************************************************/
 tNFA_STATUS NFA_ResetNfcc() {
-    NFA_TRACE_DEBUG0("NFA_ResetNfcc()");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_ResetNfcc()");
     if(!nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
-        NFA_TRACE_DEBUG0("NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH"
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH"
                 " feature is not available!!");
         return (NFA_STATUS_FAILED);
     }
@@ -1551,16 +1585,16 @@ tNFA_STATUS NFA_ResetNfcc() {
 **
 *******************************************************************************/
 void NFA_EE_HCI_Control(bool flagEnable) {
-    NFA_TRACE_DEBUG0("NFA_EE_HCI_Control()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_EE_HCI_Control()");
     if(!nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
-        NFA_TRACE_DEBUG0("NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH"
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH"
                 " feature is not available!!");
         return;
     }
   uint8_t id[2] = {NFA_ID_HCI, NFA_ID_EE};
   uint8_t i = 0;
   if (!flagEnable) {
-    NFA_TRACE_DEBUG0("NFA_EE_HCI_Control (); Disable system");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_EE_HCI_Control (); Disable system");
     nfa_sys_cb.graceful_disable = true;
     for (i = 0; i < 2; i++) {
       if (nfa_sys_cb.is_reg[id[i]]) {
@@ -1576,7 +1610,7 @@ void NFA_EE_HCI_Control(bool flagEnable) {
     nfa_ee_init();
     nfa_hci_init();
 
-    NFA_TRACE_DEBUG0("NFA_EE_HCI_Control (); Enable system");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_EE_HCI_Control (); Enable system");
     for (i = 0; i < 2; i++) {
       if (nfa_sys_cb.is_reg[id[i]]) {
         if (nfa_sys_cb.reg[id[i]]->enable != NULL) {
diff --git a/src/nfa/dm/nfa_dm_cfg.c b/src/nfa/dm/nfa_dm_cfg.cc
old mode 100644
new mode 100755
similarity index 81%
rename from src/nfa/dm/nfa_dm_cfg.c
rename to src/nfa/dm/nfa_dm_cfg.cc
index 11748d3..48fc74c
--- a/src/nfa/dm/nfa_dm_cfg.c
+++ b/src/nfa/dm/nfa_dm_cfg.cc
@@ -35,12 +35,6 @@ const uint8_t nfa_dm_ce_cfg[] = {
 
 uint8_t* p_nfa_dm_ce_cfg = (uint8_t*)nfa_dm_ce_cfg;
 
-/* the SetConfig for optional general NFC stack functions */
-const uint8_t nfa_dm_gen_cfg[] = {
-    3, /* total length */
-    /* Instruct NFCC to report RF field generated by remote device (or not) */
-    NFC_PMID_RF_FIELD_INFO, 1, 0x01};
-
 uint8_t* p_nfa_dm_gen_cfg = NULL;
 
 /* the RF Discovery Frequency for each technology */
@@ -52,25 +46,20 @@ const tNFA_DM_DISC_FREQ_CFG nfa_dm_rf_disc_freq_cfg = {
     1, /* Frequency for Proprietary Technology/B-Prime */
     1, /* Frequency for Proprietary Technology/Kovio   */
     1, /* Frequency for NFC Technology A active mode   */
-    1  /* Frequency for NFC Technology F active mode   */
+    1, /* Frequency for NFC Technology F active mode   */
+    1  /* Frequency for NFC Technology active mode     */
 };
 
 tNFA_DM_DISC_FREQ_CFG* p_nfa_dm_rf_disc_freq_cfg =
     (tNFA_DM_DISC_FREQ_CFG*)&nfa_dm_rf_disc_freq_cfg;
 
 uint8_t nfa_ee_max_ee_cfg = NFA_EE_MAX_EE_SUPPORTED;
-const tNCI_DISCOVER_MAPS nfa_dm_interface_mapping[NFA_DM_NUM_INTERFACE_MAP] = {
-    /* Protocols that use Frame Interface do not need to be included in the
-       interface mapping */
-    {NCI_PROTOCOL_ISO_DEP, NCI_INTERFACE_MODE_POLL_N_LISTEN,
-     NCI_INTERFACE_ISO_DEP},
-    {NCI_PROTOCOL_NFC_DEP, NCI_INTERFACE_MODE_POLL_N_LISTEN,
-     NCI_INTERFACE_NFC_DEP}};
+
 /* set to NULL to use the default mapping set by stack */
 tNCI_DISCOVER_MAPS* p_nfa_dm_interface_mapping = NULL;
 uint8_t nfa_dm_num_dm_interface_mapping = 0;
 
-const tNFA_DM_CFG nfa_dm_cfg = {
+tNFA_DM_CFG nfa_dm_cfg = {
     /* Automatic NDEF detection (when not in exclusive RF mode) */
     NFA_DM_AUTO_DETECT_NDEF,
     /* Automatic NDEF read (when not in exclusive RF mode) */
@@ -86,7 +75,7 @@ tNFA_DM_CFG* p_nfa_dm_cfg = (tNFA_DM_CFG*)&nfa_dm_cfg;
 
 const uint8_t nfa_hci_whitelist[] = {0x02, 0x03, 0x04};
 
-const tNFA_HCI_CFG nfa_hci_cfg = {
+tNFA_HCI_CFG nfa_hci_cfg = {
     /* Max HCI Network IDLE time to wait for EE DISC REQ Ntf(s) */
     NFA_HCI_NETWK_INIT_IDLE_TIMEOUT,
     /* Maximum HCP Response time to any HCP Command */
@@ -99,7 +88,7 @@ const tNFA_HCI_CFG nfa_hci_cfg = {
 tNFA_HCI_CFG* p_nfa_hci_cfg = (tNFA_HCI_CFG*)&nfa_hci_cfg;
 
 bool nfa_poll_bail_out_mode = false;
-const tNFA_PROPRIETARY_CFG nfa_proprietary_cfg = {
+tNFA_PROPRIETARY_CFG nfa_proprietary_cfg = {
 #if (NXP_EXTNS == TRUE)
     0x05, /* NCI_PROTOCOL_18092_ACTIVE */
 #else
@@ -112,7 +101,7 @@ const tNFA_PROPRIETARY_CFG nfa_proprietary_cfg = {
 #else
     0x83, /* NCI_PROTOCOL_15693 */
 #endif
-#if (NXP_EXTNS == TRUE && NFC_NXP_CHIP_TYPE != PN547C2)
+#if (NXP_EXTNS == TRUE)
     0x81,
 #else
     0x8A, /* NCI_PROTOCOL_KOVIO */
@@ -122,7 +111,7 @@ const tNFA_PROPRIETARY_CFG nfa_proprietary_cfg = {
 #else
     0xFF, /* NCI_PROTOCOL_MIFARE */
 #endif
-#if (NXP_EXTNS == TRUE && NFC_NXP_CHIP_TYPE != PN547C2)
+#if (NXP_EXTNS == TRUE)
     0x70,
 #else
     0x77, /* NCI_DISCOVERY_TYPE_POLL_KOVIO */
diff --git a/src/nfa/dm/nfa_dm_discover.c b/src/nfa/dm/nfa_dm_discover.cc
similarity index 82%
rename from src/nfa/dm/nfa_dm_discover.c
rename to src/nfa/dm/nfa_dm_discover.cc
index b2d4030..e6d15c8 100644
--- a/src/nfa/dm/nfa_dm_discover.c
+++ b/src/nfa/dm/nfa_dm_discover.cc
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -41,11 +41,13 @@
  *
  ******************************************************************************/
 #include <string.h>
-#include "nfa_sys.h"
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfa_api.h"
 #include "nfa_dm_int.h"
 #include "nfa_p2p_int.h"
-#include "nfa_sys_int.h"
 #include "nci_hmsgs.h"
 #if (NFC_NFCEE_INCLUDED == true)
 #include "nfa_ee_api.h"
@@ -55,8 +57,13 @@
 
 #include "nfc_int.h"
 #if (NXP_EXTNS == TRUE)
-#include <config.h>
+#include <nfc_config.h>
 #endif
+
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+
 /*
 **  static functions
 */
@@ -69,7 +76,7 @@ static uint8_t gLastSak = 0x00;
 static uint8_t nfa_dm_get_rf_discover_config(
     tNFA_DM_DISC_TECH_PROTO_MASK dm_disc_mask,
     tNFC_DISCOVER_PARAMS disc_params[], uint8_t max_params);
-static tNFA_STATUS nfa_dm_set_rf_listen_mode_config(
+__attribute__((unused)) static tNFA_STATUS nfa_dm_set_rf_listen_mode_config(
     tNFA_DM_DISC_TECH_PROTO_MASK tech_proto_mask);
 static void nfa_dm_set_rf_listen_mode_raw_config(
     tNFA_DM_DISC_TECH_PROTO_MASK* p_disc_mask);
@@ -84,10 +91,8 @@ static void nfa_dm_disc_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
 static void nfa_dm_disc_kovio_timeout_cback(TIMER_LIST_ENT* p_tle);
 static void nfa_dm_disc_report_kovio_presence_check(tNFC_STATUS status);
 
-#if (BT_TRACE_VERBOSE == true)
-static char* nfa_dm_disc_state_2_str(uint8_t state);
-static char* nfa_dm_disc_event_2_str(uint8_t event);
-#endif
+static std::string nfa_dm_disc_state_2_str(uint8_t state);
+static std::string nfa_dm_disc_event_2_str(uint8_t event);
 
 #if (NXP_EXTNS == TRUE)
 typedef struct nfa_dm_p2p_prio_logic {
@@ -105,8 +110,6 @@ uint8_t T2T_SLP_REQ[] ={0x50,0x00};
 
 int getListenTechValue(int listenTechMask);
 #define P2P_RESUME_POLL_TIMEOUT 16 /*mili second timeout value*/
-static uint16_t P2P_PRIO_LOGIC_CLEANUP_TIMEOUT =
-    50; /*timeout value 500 ms for p2p_prio_logic_cleanup*/
 static uint16_t P2P_PRIO_LOGIC_DEACT_NTF_TIMEOUT =
     200; /* timeout value 2 sec waiting for deactivate ntf */
 #endif
@@ -129,10 +132,10 @@ static uint8_t nfa_dm_get_rf_discover_config(
     tNFC_DISCOVER_PARAMS disc_params[], uint8_t max_params) {
   uint8_t num_params = 0;
 
-  NFA_TRACE_DEBUG2("%s : dm_disc_mask = 0x%08X", __func__, dm_disc_mask);
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s : dm_disc_mask = 0x%08X", __func__, dm_disc_mask);
 
   if (nfa_dm_cb.flags & NFA_DM_FLAGS_LISTEN_DISABLED) {
-    NFA_TRACE_DEBUG1(
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "nfa_dm_get_rf_discover_config() : listen disabled, remove listen from "
         "0x%x",
         dm_disc_mask);
@@ -140,7 +143,7 @@ static uint8_t nfa_dm_get_rf_discover_config(
   }
 
   if (nfa_dm_is_p2p_paused()) {
-    NFA_TRACE_DEBUG1(
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "nfa_dm_get_rf_discover_config () removing active listen A/B 0x%x",
         dm_disc_mask);
     dm_disc_mask &= ~NFA_DM_DISC_MASK_NFC_DEP;
@@ -148,7 +151,7 @@ static uint8_t nfa_dm_get_rf_discover_config(
 #if (NXP_EXTNS == TRUE)
   if (nfcFL.eseFL._NFCC_ESE_UICC_CONCURRENT_ACCESS_PROTECTION &&
           (nfa_dm_cb.flags & NFA_DM_FLAGS_PASSIVE_LISTEN_DISABLED)) {
-    NFA_TRACE_DEBUG1(
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "nfa_dm_get_rf_discover_config () passive listen disabled, rm listen "
         "from 0x%x",
         dm_disc_mask);
@@ -190,25 +193,34 @@ static uint8_t nfa_dm_get_rf_discover_config(
 
     if (num_params >= max_params) return num_params;
   }
+  if (NFC_GetNCIVersion() == NCI_VERSION_2_0) {
+    /* Check polling Active mode  */
+    if (dm_disc_mask & NFA_DM_DISC_MASK_PACM_NFC_DEP) {
+      disc_params[num_params].type = NFC_DISCOVERY_TYPE_POLL_ACTIVE;
+      disc_params[num_params].frequency = p_nfa_dm_rf_disc_freq_cfg->pacm;
+      num_params++;
 
-  /* Check polling A Active mode  */
-  if (dm_disc_mask & NFA_DM_DISC_MASK_PAA_NFC_DEP) {
-    disc_params[num_params].type = NFC_DISCOVERY_TYPE_POLL_A_ACTIVE;
-    disc_params[num_params].frequency = p_nfa_dm_rf_disc_freq_cfg->paa;
-    num_params++;
+      if (num_params >= max_params) return num_params;
+    }
+  } else {
+    /* Check polling A Active mode  */
+    if (dm_disc_mask & NFA_DM_DISC_MASK_PAA_NFC_DEP) {
+      disc_params[num_params].type = NFC_DISCOVERY_TYPE_POLL_A_ACTIVE;
+      disc_params[num_params].frequency = p_nfa_dm_rf_disc_freq_cfg->paa;
+      num_params++;
 
-    if (num_params >= max_params) return num_params;
-  }
+      if (num_params >= max_params) return num_params;
+    }
 
-  /* Check polling F Active mode  */
-  if (dm_disc_mask & NFA_DM_DISC_MASK_PFA_NFC_DEP) {
-    disc_params[num_params].type = NFC_DISCOVERY_TYPE_POLL_F_ACTIVE;
-    disc_params[num_params].frequency = p_nfa_dm_rf_disc_freq_cfg->pfa;
-    num_params++;
+    /* Check polling F Active mode  */
+    if (dm_disc_mask & NFA_DM_DISC_MASK_PFA_NFC_DEP) {
+      disc_params[num_params].type = NFC_DISCOVERY_TYPE_POLL_F_ACTIVE;
+      disc_params[num_params].frequency = p_nfa_dm_rf_disc_freq_cfg->pfa;
+      num_params++;
 
-    if (num_params >= max_params) return num_params;
+      if (num_params >= max_params) return num_params;
+    }
   }
-
   /* Check listening A */
   if (dm_disc_mask &
       (NFA_DM_DISC_MASK_LA_T1T | NFA_DM_DISC_MASK_LA_T2T |
@@ -237,28 +249,37 @@ static uint8_t nfa_dm_get_rf_discover_config(
 
     if (num_params >= max_params) return num_params;
   }
+  if (NFC_GetNCIVersion() == NCI_VERSION_2_0) {
+    /* Check polling Active mode  */
+    if (dm_disc_mask & NFA_DM_DISC_MASK_LACM_NFC_DEP) {
+      disc_params[num_params].type = NFC_DISCOVERY_TYPE_LISTEN_ACTIVE;
+      disc_params[num_params].frequency = p_nfa_dm_rf_disc_freq_cfg->pacm;
+      num_params++;
+      if (num_params >= max_params) return num_params;
+    }
+  } else {
+    /* Check listening A Active mode */
+    if (dm_disc_mask & NFA_DM_DISC_MASK_LAA_NFC_DEP) {
+      disc_params[num_params].type = NFC_DISCOVERY_TYPE_LISTEN_A_ACTIVE;
+      disc_params[num_params].frequency = 1;
+      num_params++;
 
-  /* Check listening A Active mode */
-  if (dm_disc_mask & NFA_DM_DISC_MASK_LAA_NFC_DEP) {
-    disc_params[num_params].type = NFC_DISCOVERY_TYPE_LISTEN_A_ACTIVE;
-    disc_params[num_params].frequency = 1;
-    num_params++;
-
-    if (num_params >= max_params) return num_params;
-  }
+      if (num_params >= max_params) return num_params;
+    }
 
-  /* Check listening F Active mode */
-  if (dm_disc_mask & NFA_DM_DISC_MASK_LFA_NFC_DEP) {
-    disc_params[num_params].type = NFC_DISCOVERY_TYPE_LISTEN_F_ACTIVE;
-    disc_params[num_params].frequency = 1;
-    num_params++;
+    /* Check listening F Active mode */
+    if (dm_disc_mask & NFA_DM_DISC_MASK_LFA_NFC_DEP) {
+      disc_params[num_params].type = NFC_DISCOVERY_TYPE_LISTEN_F_ACTIVE;
+      disc_params[num_params].frequency = 1;
+      num_params++;
 
-    if (num_params >= max_params) return num_params;
+      if (num_params >= max_params) return num_params;
+    }
   }
 
   /* Check polling ISO 15693 */
-  if (dm_disc_mask & NFA_DM_DISC_MASK_P_ISO15693) {
-    disc_params[num_params].type = NFC_DISCOVERY_TYPE_POLL_ISO15693;
+  if (dm_disc_mask & NFA_DM_DISC_MASK_P_T5T) {
+    disc_params[num_params].type = NFC_DISCOVERY_TYPE_POLL_V;
     disc_params[num_params].frequency = p_nfa_dm_rf_disc_freq_cfg->pi93;
     num_params++;
 
@@ -320,15 +341,16 @@ static uint8_t nfa_dm_get_sak(tNFA_DM_DISC_TECH_PROTO_MASK tech_proto_mask) {
   uint8_t tech_list = 0;
   uint8_t hostListenMask = 0x00, fwdEnable = 0x00;
 
-  if ((GetNumValue(NAME_HOST_LISTEN_TECH_MASK, &hostListenMask,
-                   sizeof(hostListenMask)))) {
-    NFA_TRACE_DEBUG2("%s : HOST_LISTEN_TECH_MASK = 0x%X;", __func__,
-                     hostListenMask);
+  if (NfcConfig::hasKey(NAME_HOST_LISTEN_TECH_MASK)) {
+    hostListenMask = NfcConfig::getUnsigned(NAME_HOST_LISTEN_TECH_MASK);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s : HOST_LISTEN_TECH_MASK = 0x%x;", __func__,
+                    hostListenMask);
   }
-  if ((GetNumValue(NAME_NXP_FWD_FUNCTIONALITY_ENABLE, &fwdEnable,
-                   sizeof(fwdEnable)))) {
-    NFA_TRACE_DEBUG2("%s:NXP_FWD_FUNCTIONALITY_ENABLE=0x0%lu;", __func__,
-                     fwdEnable);
+
+  if (NfcConfig::hasKey(NAME_NXP_FWD_FUNCTIONALITY_ENABLE)) {
+    fwdEnable = NfcConfig::getUnsigned(NAME_NXP_FWD_FUNCTIONALITY_ENABLE);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s:NXP_FWD_FUNCTIONALITY_ENABLE=0x0%x;", __func__,
+                    fwdEnable);
   }
 
   tech_list = nfa_ee_get_supported_tech_list(nfa_dm_cb.selected_uicc_id);
@@ -374,12 +396,12 @@ static tNFA_STATUS nfa_dm_set_listen_mode_set_configs(
   uint8_t LF_PROTOTYPE = 0x00;
   unsigned long hostListenMask = 0x00;
 
-  NFA_TRACE_DEBUG2("%s : tech_proto_mask = 0x%08X", __func__, tech_proto_mask);
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s : tech_proto_mask = 0x%08X", __func__, tech_proto_mask);
 
-  if ((GetNumValue(NAME_HOST_LISTEN_TECH_MASK, &hostListenMask,
-                   sizeof(hostListenMask)))) {
-    NFA_TRACE_DEBUG2("%s : HOST_LISTEN_TECH_MASK = 0x0%lu;", __func__,
-                     hostListenMask);
+  if (NfcConfig::hasKey(NAME_HOST_LISTEN_TECH_MASK)) {
+    hostListenMask = NfcConfig::getUnsigned(NAME_HOST_LISTEN_TECH_MASK);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s : HOST_LISTEN_TECH_MASK = 0x0%lu;", __func__,
+                    hostListenMask);
   }
 
   p = params;
@@ -392,12 +414,12 @@ static tNFA_STATUS nfa_dm_set_listen_mode_set_configs(
     SAK &= 0x00;
   }
   if (tech_proto_mask & NFA_DM_DISC_MASK_LA_NFC_DEP) {
-    NFA_TRACE_DEBUG2("%s : gLastSak = 0x%X;", __func__, gLastSak);
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s : gLastSak = 0x%X;", __func__, gLastSak);
     if (gLastSak) SAK |= gLastSak;
     SAK |= NCI_PARAM_SEL_INFO_NFCDEP;
     gLastSak &= 0x00;
   }
-  NFA_TRACE_DEBUG2("%s : LA_SEL_INFO = 0x%X;", __func__, SAK);
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s : LA_SEL_INFO = 0x%X;", __func__, SAK);
   UINT8_TO_STREAM(p, NFC_PMID_LA_SEL_INFO);
   UINT8_TO_STREAM(p, NCI_PARAM_LEN_LA_SEL_INFO);
   UINT8_TO_STREAM(p, SAK);
@@ -408,7 +430,7 @@ static tNFA_STATUS nfa_dm_set_listen_mode_set_configs(
   } else {
     SENSB_RES &= 0x00;
   }
-  NFA_TRACE_DEBUG2("%s : LB_SENSB_INFO = 0x%X;", __func__, SENSB_RES);
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s : LB_SENSB_INFO = 0x%X;", __func__, SENSB_RES);
   UINT8_TO_STREAM(p, NFC_PMID_LB_SENSB_INFO);
   UINT8_TO_STREAM(p, NCI_PARAM_LEN_LB_SENSB_INFO);
   UINT8_TO_STREAM(p, SENSB_RES);
@@ -423,7 +445,7 @@ static tNFA_STATUS nfa_dm_set_listen_mode_set_configs(
   UINT8_TO_STREAM(p, NFC_PMID_LF_PROTOCOL);
   UINT8_TO_STREAM(p, NCI_PARAM_LEN_LF_PROTOCOL);
   UINT8_TO_STREAM(p, LF_PROTOTYPE);
-  NFA_TRACE_DEBUG2("%s : LF_PROTOCOL_TYPE = 0x%X;", __func__, LF_PROTOTYPE);
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s : LF_PROTOCOL_TYPE = 0x%X;", __func__, LF_PROTOTYPE);
 
   if (p > params) {
     nfa_dm_check_set_config((uint8_t)(p - params), params, false);
@@ -431,7 +453,6 @@ static tNFA_STATUS nfa_dm_set_listen_mode_set_configs(
   return NFA_STATUS_OK;
 }
 #endif
-
 /*******************************************************************************
 **
 ** Function         nfa_dm_set_rf_listen_mode_config
@@ -447,7 +468,7 @@ static tNFA_STATUS nfa_dm_set_rf_listen_mode_config(
   uint8_t platform = 0;
   uint8_t sens_info = 0;
 
-  NFA_TRACE_DEBUG1(
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "nfa_dm_set_rf_listen_mode_config () tech_proto_mask = 0x%08X",
       tech_proto_mask);
 
@@ -475,7 +496,7 @@ static tNFA_STATUS nfa_dm_set_rf_listen_mode_config(
     }
 #else
     sens_info = nfa_dm_get_sak(tech_proto_mask);
-    NFA_TRACE_DEBUG2("%s: sens_info=0x0%x;", __func__, sens_info);
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: sens_info=0x0%x;", __func__, sens_info);
 #endif
   }
 #if (NXP_EXTNS == TRUE)
@@ -608,7 +629,7 @@ static tNFA_STATUS nfa_dm_set_rf_listen_mode_config(
 static void nfa_dm_set_total_duration(void) {
   uint8_t params[10], *p;
 
-  NFA_TRACE_DEBUG0("nfa_dm_set_total_duration ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_set_total_duration ()");
 
   p = params;
 
@@ -637,7 +658,7 @@ static void nfa_dm_set_rf_listen_mode_raw_config(
   tNFA_LISTEN_CFG* p_cfg = &nfa_dm_cb.disc_cb.excl_listen_config;
   uint8_t params[250], *p, xx;
 
-  NFA_TRACE_DEBUG0("nfa_dm_set_rf_listen_mode_raw_config ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_set_rf_listen_mode_raw_config ()");
 
   /*
   ** Discovery Configuration Parameters for Listen A
@@ -819,7 +840,7 @@ static void nfa_dm_set_rf_listen_mode_raw_config(
 
   *p_disc_mask = disc_mask;
 
-  NFA_TRACE_DEBUG1("nfa_dm_set_rf_listen_mode_raw_config () disc_mask = 0x%x",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_set_rf_listen_mode_raw_config () disc_mask = 0x%x",
                    disc_mask);
 }
 
@@ -866,16 +887,12 @@ static tNFA_DM_DISC_TECH_PROTO_MASK nfa_dm_disc_get_disc_mask(
       disc_mask = NFA_DM_DISC_MASK_PF_T3T;
     else if (protocol == NFC_PROTOCOL_NFC_DEP)
       disc_mask = NFA_DM_DISC_MASK_PF_NFC_DEP;
-  } else if (NFC_DISCOVERY_TYPE_POLL_ISO15693 == tech_n_mode) {
-    disc_mask = NFA_DM_DISC_MASK_P_ISO15693;
+  } else if (NFC_DISCOVERY_TYPE_POLL_V == tech_n_mode) {
+    disc_mask = NFA_DM_DISC_MASK_P_T5T;
   } else if (NFC_DISCOVERY_TYPE_POLL_B_PRIME == tech_n_mode) {
     disc_mask = NFA_DM_DISC_MASK_P_B_PRIME;
   } else if (NFC_DISCOVERY_TYPE_POLL_KOVIO == tech_n_mode) {
     disc_mask = NFA_DM_DISC_MASK_P_KOVIO;
-  } else if (NFC_DISCOVERY_TYPE_POLL_A_ACTIVE == tech_n_mode) {
-    disc_mask = NFA_DM_DISC_MASK_PAA_NFC_DEP;
-  } else if (NFC_DISCOVERY_TYPE_POLL_F_ACTIVE == tech_n_mode) {
-    disc_mask = NFA_DM_DISC_MASK_PFA_NFC_DEP;
   } else if (NFC_DISCOVERY_TYPE_LISTEN_A == tech_n_mode) {
     switch (protocol) {
       case NFC_PROTOCOL_T1T:
@@ -903,13 +920,26 @@ static tNFA_DM_DISC_TECH_PROTO_MASK nfa_dm_disc_get_disc_mask(
     disc_mask = NFA_DM_DISC_MASK_L_ISO15693;
   } else if (NFC_DISCOVERY_TYPE_LISTEN_B_PRIME == tech_n_mode) {
     disc_mask = NFA_DM_DISC_MASK_L_B_PRIME;
-  } else if (NFC_DISCOVERY_TYPE_LISTEN_A_ACTIVE == tech_n_mode) {
-    disc_mask = NFA_DM_DISC_MASK_LAA_NFC_DEP;
-  } else if (NFC_DISCOVERY_TYPE_LISTEN_F_ACTIVE == tech_n_mode) {
-    disc_mask = NFA_DM_DISC_MASK_LFA_NFC_DEP;
+  }
+  if (NFC_GetNCIVersion() == NCI_VERSION_2_0) {
+    if (NFC_DISCOVERY_TYPE_POLL_ACTIVE == tech_n_mode) {
+      disc_mask = NFA_DM_DISC_MASK_PACM_NFC_DEP;
+    } else if (NFC_DISCOVERY_TYPE_LISTEN_ACTIVE == tech_n_mode) {
+      disc_mask = NFA_DM_DISC_MASK_LACM_NFC_DEP;
+    }
+  } else {
+    if (NFC_DISCOVERY_TYPE_POLL_A_ACTIVE == tech_n_mode) {
+      disc_mask = NFA_DM_DISC_MASK_PAA_NFC_DEP;
+    } else if (NFC_DISCOVERY_TYPE_POLL_F_ACTIVE == tech_n_mode) {
+      disc_mask = NFA_DM_DISC_MASK_PFA_NFC_DEP;
+    } else if (NFC_DISCOVERY_TYPE_LISTEN_A_ACTIVE == tech_n_mode) {
+      disc_mask = NFA_DM_DISC_MASK_LAA_NFC_DEP;
+    } else if (NFC_DISCOVERY_TYPE_LISTEN_F_ACTIVE == tech_n_mode) {
+      disc_mask = NFA_DM_DISC_MASK_LFA_NFC_DEP;
+    }
   }
 
-  NFA_TRACE_DEBUG3(
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "nfa_dm_disc_get_disc_mask (): tech_n_mode:0x%X, protocol:0x%X, "
       "disc_mask:0x%X",
       tech_n_mode, protocol, disc_mask);
@@ -929,7 +959,7 @@ static void nfa_dm_disc_discovery_cback(tNFC_DISCOVER_EVT event,
                                         tNFC_DISCOVER* p_data) {
   tNFA_DM_RF_DISC_SM_EVENT dm_disc_event = NFA_DM_DISC_SM_MAX_EVENT;
 
-  NFA_TRACE_DEBUG1("nfa_dm_disc_discovery_cback (): event:0x%X", event);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_disc_discovery_cback (): event:0x%X", event);
 
   switch (event) {
     case NFC_START_DEVT:
@@ -956,11 +986,13 @@ static void nfa_dm_disc_discovery_cback(tNFC_DISCOVER_EVT event,
         dm_disc_event = NFA_DM_RF_DEACTIVATE_RSP;
       break;
     default:
-      NFA_TRACE_ERROR0("Unexpected event");
+      LOG(ERROR) << StringPrintf("Unexpected event");
       return;
   }
 
-  nfa_dm_disc_sm_execute(dm_disc_event, (tNFA_DM_RF_DISC_DATA*)p_data);
+  tNFA_DM_RF_DISC_DATA nfa_dm_rf_disc_data;
+  nfa_dm_rf_disc_data.nfc_discover = *p_data;
+  nfa_dm_disc_sm_execute(dm_disc_event, &nfa_dm_rf_disc_data);
 }
 
 /*******************************************************************************
@@ -1028,7 +1060,7 @@ void nfa_dm_disc_conn_event_notify(uint8_t event, tNFA_STATUS status) {
 static tNFC_STATUS nfa_dm_disc_force_to_idle(void) {
   tNFC_STATUS status = NFC_STATUS_SEMANTIC_ERROR;
 
-  NFA_TRACE_DEBUG1("nfa_dm_disc_force_to_idle() disc_flags = 0x%x",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_disc_force_to_idle() disc_flags = 0x%x",
                    nfa_dm_cb.disc_cb.disc_flags);
 
   /* do not execute more than one */
@@ -1051,13 +1083,13 @@ static tNFC_STATUS nfa_dm_disc_force_to_idle(void) {
 ** Returns          void
 **
 *******************************************************************************/
-static void nfa_dm_disc_deact_ntf_timeout_cback(TIMER_LIST_ENT* p_tle) {
-    (void)p_tle;
+static void nfa_dm_disc_deact_ntf_timeout_cback(__attribute__((unused))
+                                                TIMER_LIST_ENT* p_tle) {
 
-    NFA_TRACE_ERROR0("nfa_dm_disc_deact_ntf_timeout_cback()");
+    LOG(ERROR) << StringPrintf("nfa_dm_disc_deact_ntf_timeout_cback()");
     if (nfcFL.nfcNxpEse && nfcFL.eseFL._ESE_ETSI_READER_ENABLE &&
             (nfc_cb.num_disc_maps == 1)) {
-        NFC_TRACE_ERROR0("reset Nfc..!!");
+        LOG(ERROR) << StringPrintf("reset Nfc..!!");
         etsi_reader_in_progress = true;
         nfc_ncif_cmd_timeout();
 
@@ -1099,20 +1131,21 @@ static tNFC_STATUS nfa_dm_send_deactivate_cmd(tNFC_DEACT_TYPE deactivate_type) {
           (TIMER_CBACK*)nfa_dm_disc_deact_ntf_timeout_cback;
 #if (NXP_EXTNS == TRUE)
       num = NFA_DM_DISC_TIMEOUT_W4_DEACT_NTF;
-      NFA_TRACE_DEBUG1("num_disc_maps=%d", nfc_cb.num_disc_maps);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("num_disc_maps=%d", nfc_cb.num_disc_maps);
       if (nfc_cb.num_disc_maps == 1) {
-        NFA_TRACE_DEBUG1(
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
             "Reading NAME_NFA_DM_DISC_NTF_TIMEOUT val   "
             "nfc_cb.num_disc_maps = %d",
             nfc_cb.num_disc_maps);
-        if (GetNumValue(NAME_NFA_DM_DISC_NTF_TIMEOUT, &num, sizeof(num))) {
-          num *= 1000;
-        } else {
+        if (NfcConfig::hasKey(NAME_NFA_DM_DISC_NTF_TIMEOUT)) {
+            num = NfcConfig::getUnsigned(NAME_NFA_DM_DISC_NTF_TIMEOUT);
+            num *= 1000;
+          } else {
           num = NFA_DM_DISC_TIMEOUT_W4_DEACT_NTF;
-          NFA_TRACE_DEBUG1("Overriding NFA_DM_DISC_NTF_TIMEOUT to use %d", num);
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Overriding NFA_DM_DISC_NTF_TIMEOUT to use %lu", num);
         }
       }
-      NFA_TRACE_DEBUG1("Starting timer value %d", num);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Starting timer value %lu", num);
       /*wait infinite time for deactivate NTF, if the timeout is configured to
        * 0*/
       if (num != 0) nfa_sys_start_timer(&nfa_dm_cb.disc_cb.tle, 0, num);
@@ -1150,18 +1183,18 @@ void nfa_dm_start_rf_discover(void) {
   uint8_t config_params[10], *p;
   uint8_t num_params, xx;
   uint8_t tech_list = 0x00;
-  unsigned long fwdEnable = 0x00;
-  unsigned long hostListenMask = 0x00;
-  unsigned long uiccListenMask = 0x00;
-  unsigned long eseListenMask  = 0x00;
-  unsigned long p2pListenMask = 0x00;
+  unsigned fwdEnable = 0x00;
+  unsigned hostListenMask = 0x00;
+  unsigned uiccListenMask = 0x00;
+  unsigned eseListenMask  = 0x00;
+  unsigned p2pListenMask = 0x00;
 
-  NFA_TRACE_DEBUG0("nfa_dm_start_rf_discover (): enter");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_start_rf_discover (): enter");
   /* Make sure that RF discovery was enabled, or some app has exclusive control
    */
   if ((!(nfa_dm_cb.disc_cb.disc_flags & NFA_DM_DISC_FLAGS_ENABLED)) &&
       (nfa_dm_cb.disc_cb.excl_disc_entry.in_use == false)) {
-    NFA_TRACE_DEBUG0("nfa_dm_start_rf_discover (): return");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_start_rf_discover (): return");
     return;
   }
 
@@ -1177,79 +1210,84 @@ void nfa_dm_start_rf_discover(void) {
     /* Collect RF discovery request from sub-modules */
     for (xx = 0; xx < NFA_DM_DISC_NUM_ENTRIES; xx++) {
       if (nfa_dm_cb.disc_cb.entry[xx].in_use) {
-        NFA_TRACE_DEBUG2("requested_disc_mask = 0x%x, xx=%d",
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("requested_disc_mask = 0x%x, xx=%d",
                          nfa_dm_cb.disc_cb.entry[xx].requested_disc_mask, xx);
         poll_mask = (nfa_dm_cb.disc_cb.entry[xx].requested_disc_mask &
                      NFA_DM_DISC_MASK_POLL);
 
-        /* clear poll mode technologies and protocols which are already used by
+        /* clear poll mode technolgies and protocols which are already used by
          * others */
         poll_mask &= ~(dm_disc_mask & NFA_DM_DISC_MASK_POLL);
-        /* reset listen mask before updating it for every discovery callback
-         * entry */
+
         listen_mask = 0;
+
         /*
-         ** add listen mode technologies and protocols if host ID is
-         ** matched to listen mode routing table
-         */
-        NFA_TRACE_DEBUG2("poll_mask=0x%X listen_mask=0x%X", poll_mask,
-                         listen_mask);
+        ** add listen mode technolgies and protocols if host ID is
+        ** matched to listen mode routing table
+        */
+
         /* NFC-A */
         if (nfa_dm_cb.disc_cb.entry[xx].host_id ==
             nfa_dm_cb.disc_cb.listen_RT[NFA_DM_DISC_LRT_NFC_A]) {
           listen_mask |=
               nfa_dm_cb.disc_cb.entry[xx].requested_disc_mask &
               (NFA_DM_DISC_MASK_LA_T1T | NFA_DM_DISC_MASK_LA_T2T |
-               NFA_DM_DISC_MASK_LA_ISO_DEP | NFA_DM_DISC_MASK_LA_NFC_DEP |
-               NFA_DM_DISC_MASK_LAA_NFC_DEP);
+               NFA_DM_DISC_MASK_LA_ISO_DEP | NFA_DM_DISC_MASK_LA_NFC_DEP);
+          if (NFC_GetNCIVersion() == NCI_VERSION_2_0) {
+            listen_mask |= nfa_dm_cb.disc_cb.entry[xx].requested_disc_mask &
+                           NFA_DM_DISC_MASK_LACM_NFC_DEP;
+          } else {
+            listen_mask |= nfa_dm_cb.disc_cb.entry[xx].requested_disc_mask &
+                           NFA_DM_DISC_MASK_LAA_NFC_DEP;
+          }
         } else {
           /* host can listen ISO-DEP based on AID routing */
           listen_mask |= (nfa_dm_cb.disc_cb.entry[xx].requested_disc_mask &
                           NFA_DM_DISC_MASK_LA_ISO_DEP);
-
-          /* host can listen NFC-DEP based on protocol routing */
-          listen_mask |= (nfa_dm_cb.disc_cb.entry[xx].requested_disc_mask &
-                          NFA_DM_DISC_MASK_LA_NFC_DEP);
           listen_mask |= (nfa_dm_cb.disc_cb.entry[xx].requested_disc_mask &
-                          NFA_DM_DISC_MASK_LAA_NFC_DEP);
+                            NFA_DM_DISC_MASK_LA_NFC_DEP);
+          if (NFC_GetNCIVersion() == NCI_VERSION_2_0) {
+            listen_mask |= (nfa_dm_cb.disc_cb.entry[xx].requested_disc_mask &
+                            NFA_DM_DISC_MASK_LACM_NFC_DEP);
+          } else {
+            listen_mask |= (nfa_dm_cb.disc_cb.entry[xx].requested_disc_mask &
+                            NFA_DM_DISC_MASK_LAA_NFC_DEP);
+          }
         }
-        NFA_TRACE_DEBUG1("listen_mask value after NFC-A = 0x%x", listen_mask);
 
         /* NFC-B */
         /* multiple hosts can listen ISO-DEP based on AID routing */
         listen_mask |= nfa_dm_cb.disc_cb.entry[xx].requested_disc_mask &
                        NFA_DM_DISC_MASK_LB_ISO_DEP;
-        NFA_TRACE_DEBUG1("listen_mask value after NFC-B = 0x%x", listen_mask);
 
         /* NFC-F */
+        /* NFCC can support NFC-DEP and T3T listening based on NFCID routing
+         * regardless of NFC-F tech routing */
         listen_mask |= nfa_dm_cb.disc_cb.entry[xx].requested_disc_mask &
-                       (NFA_DM_DISC_MASK_LF_T3T | NFA_DM_DISC_MASK_LF_NFC_DEP |
-                        NFA_DM_DISC_MASK_LFA_NFC_DEP);
-        NFA_TRACE_DEBUG1("listen_mask value after NFC-F = 0x%x", listen_mask);
-
+                       (NFA_DM_DISC_MASK_LF_T3T | NFA_DM_DISC_MASK_LF_NFC_DEP);
+        if (NFC_GetNCIVersion() != NCI_VERSION_2_0) {
+          listen_mask |= nfa_dm_cb.disc_cb.entry[xx].requested_disc_mask &
+                         NFA_DM_DISC_MASK_LFA_NFC_DEP;
+        }
         /* NFC-B Prime */
         if (nfa_dm_cb.disc_cb.entry[xx].host_id ==
             nfa_dm_cb.disc_cb.listen_RT[NFA_DM_DISC_LRT_NFC_BP]) {
           listen_mask |= nfa_dm_cb.disc_cb.entry[xx].requested_disc_mask &
                          NFA_DM_DISC_MASK_L_B_PRIME;
         }
-        NFA_TRACE_DEBUG1("listen_mask value after NFC-B Prime = 0x%x",
-                         listen_mask);
+
         /*
         ** clear listen mode technolgies and protocols which are already
         ** used by others
         */
 
         /* Check if other modules are listening T1T or T2T */
-        NFA_TRACE_DEBUG1("dm_disc_mask = 0x%x", dm_disc_mask);
         if (dm_disc_mask &
             (NFA_DM_DISC_MASK_LA_T1T | NFA_DM_DISC_MASK_LA_T2T)) {
           listen_mask &=
               ~(NFA_DM_DISC_MASK_LA_T1T | NFA_DM_DISC_MASK_LA_T2T |
                 NFA_DM_DISC_MASK_LA_ISO_DEP | NFA_DM_DISC_MASK_LA_NFC_DEP);
         }
-        NFA_TRACE_DEBUG1("listen_mask value after T1T and T2T = 0x%x",
-                         listen_mask);
 
         /* T1T/T2T has priority on NFC-A */
         if ((dm_disc_mask &
@@ -1264,68 +1302,67 @@ void nfa_dm_start_rf_discover(void) {
          * on AID routing */
 
         /* Check if other modules are listening NFC-DEP */
-        if (dm_disc_mask &
-            (NFA_DM_DISC_MASK_LA_NFC_DEP | NFA_DM_DISC_MASK_LAA_NFC_DEP)) {
-          listen_mask &=
-              ~(NFA_DM_DISC_MASK_LA_NFC_DEP | NFA_DM_DISC_MASK_LAA_NFC_DEP);
+        if (NFC_GetNCIVersion() == NCI_VERSION_2_0) {
+          if (dm_disc_mask &
+              (NFA_DM_DISC_MASK_LA_NFC_DEP | NFA_DM_DISC_MASK_LACM_NFC_DEP)) {
+            listen_mask &=
+                ~(NFA_DM_DISC_MASK_LA_NFC_DEP | NFA_DM_DISC_MASK_LACM_NFC_DEP);
+          }
+        } else {
+          if (dm_disc_mask &
+              (NFA_DM_DISC_MASK_LA_NFC_DEP | NFA_DM_DISC_MASK_LAA_NFC_DEP)) {
+            listen_mask &=
+                ~(NFA_DM_DISC_MASK_LA_NFC_DEP | NFA_DM_DISC_MASK_LAA_NFC_DEP);
+          }
         }
 
-        NFA_TRACE_DEBUG1("listen_mask value after NFC-DEP = 0x%x", listen_mask);
-
         nfa_dm_cb.disc_cb.entry[xx].selected_disc_mask =
             poll_mask | listen_mask;
 
-        NFA_TRACE_DEBUG2(
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
             "nfa_dm_cb.disc_cb.entry[%d].selected_disc_mask = 0x%x", xx,
             nfa_dm_cb.disc_cb.entry[xx].selected_disc_mask);
 
         dm_disc_mask |= nfa_dm_cb.disc_cb.entry[xx].selected_disc_mask;
-
-        NFA_TRACE_DEBUG2("selected dm_disc_mask 0x%X for entry[%d]",
-                         dm_disc_mask, xx);
       }
     }
-    NFA_TRACE_DEBUG1("dm_disc_mask calculated finally for discovery: 0x%X",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("dm_disc_mask calculated finally for discovery: 0x%X",
                      dm_disc_mask);
 
 #if (NXP_EXTNS == TRUE)
-    if ((GetNumValue(NAME_NXP_FWD_FUNCTIONALITY_ENABLE, &fwdEnable,
-                     sizeof(fwdEnable))) == false) {
-      fwdEnable = 0x01;  // default value
-      NFA_TRACE_DEBUG2("%s:NXP_FWD_FUNCTIONALITY_ENABLE=0x0%X;", __func__,
-                       fwdEnable);
-    }
-    if (GetNumValue(NAME_HOST_LISTEN_TECH_MASK, &hostListenMask,
-                    sizeof(hostListenMask))) {
-      NFA_TRACE_DEBUG2("%s:HOST_LISTEN_TECH_MASK = 0x0%X;", __func__,
-                       hostListenMask);
-    }
-    if (GetNumValue(NAME_UICC_LISTEN_TECH_MASK, &uiccListenMask,
-                    sizeof(uiccListenMask))) {
-      NFA_TRACE_DEBUG2("%s:UICC_LISTEN_TECH_MASK = 0x0%X;", __func__,
+    fwdEnable = NfcConfig::getUnsigned(NAME_NXP_FWD_FUNCTIONALITY_ENABLE,0x01);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s:NXP_FWD_FUNCTIONALITY_ENABLE=0x0%x;", __func__,
+                    fwdEnable);
+    if (NfcConfig::hasKey(NAME_HOST_LISTEN_TECH_MASK)) {
+      hostListenMask = NfcConfig::getUnsigned(NAME_HOST_LISTEN_TECH_MASK);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s:HOST_LISTEN_TECH_MASK = 0x0%X;", __func__,
+                      hostListenMask);
+    }
+    if (NfcConfig::hasKey(NAME_UICC_LISTEN_TECH_MASK)) {
+      uiccListenMask = NfcConfig::getUnsigned(NAME_UICC_LISTEN_TECH_MASK);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s:UICC_LISTEN_TECH_MASK = 0x0%X;", __func__,
                        uiccListenMask);
     }
-    if (GetNumValue(NAME_NXP_ESE_LISTEN_TECH_MASK, &eseListenMask,
-                    sizeof(eseListenMask))) {
-      NFA_TRACE_DEBUG2("%s:NXP_ESE_LISTEN_TECH_MASK = 0x0%X;", __func__,
-                       eseListenMask);
+    if (NfcConfig::hasKey(NAME_NXP_ESE_LISTEN_TECH_MASK)) {
+      eseListenMask = NfcConfig::getUnsigned(NAME_NXP_ESE_LISTEN_TECH_MASK);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s:NXP_ESE_LISTEN_TECH_MASK = 0x0%X;", __func__,
+                        eseListenMask);
     }
-    if (GetNumValue(NAME_P2P_LISTEN_TECH_MASK, &p2pListenMask,
-                    sizeof(p2pListenMask))) {
-      NFA_TRACE_DEBUG2("%s:P2P_LISTEN_TECH_MASK = 0x0%X;", __func__,
+    if (NfcConfig::hasKey(NAME_P2P_LISTEN_TECH_MASK)) {
+      p2pListenMask = NfcConfig::getUnsigned(NAME_P2P_LISTEN_TECH_MASK);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s:P2P_LISTEN_TECH_MASK = 0x0%X;", __func__,
                        p2pListenMask);
     }
-
     tech_list = nfa_ee_get_supported_tech_list(nfa_dm_cb.selected_uicc_id);
 
     if ((fwdEnable == 0x00) || (hostListenMask == 0x00)) {
       if (tech_list == NFA_TECHNOLOGY_MASK_B) {
-        NFA_TRACE_DEBUG0(
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
             "TypeB only sim handling in case of no FWD functionality");
         dm_disc_mask &=
             ~(NFA_DM_DISC_MASK_LA_ISO_DEP | NFA_DM_DISC_MASK_LA_NFC_DEP);
       } else if (tech_list == NFA_TECHNOLOGY_MASK_A) {
-        NFA_TRACE_DEBUG0(
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
             "TypeA only sim handling in case of no FWD functionality");
         dm_disc_mask &= ~(NFA_DM_DISC_MASK_LB_ISO_DEP);
       }
@@ -1336,57 +1373,58 @@ void nfa_dm_start_rf_discover(void) {
     if (dm_disc_mask & NFA_DM_DISC_MASK_NFC_DEP) {
       nfa_p2p_set_config(dm_disc_mask);
     }
-
-    if (dm_disc_mask &
-        (NFA_DM_DISC_MASK_PF_NFC_DEP | NFA_DM_DISC_MASK_PF_T3T)) {
-      /* According to the NFC Forum Activity spec, controllers must:
-       * 1) Poll with RC=0 and SC=FFFF to find NFC-DEP targets
-       * 2) Poll with RC=1 and SC=FFFF to find T3T targets
-       * Many controllers don't do this yet, and seem to be activating
-       * NFC-DEP by default.
-       *
-       * We can at least fix the scenario where we're not interested
-       * in NFC-DEP, by setting RC=1 in that case. Otherwise, keep
-       * the default of RC=0. */
-      p = config_params;
-      UINT8_TO_STREAM(p, NFC_PMID_PF_RC);
-      UINT8_TO_STREAM(p, NCI_PARAM_LEN_PF_RC);
-      if ((dm_disc_mask & NFA_DM_DISC_MASK_PF_NFC_DEP) &&
-          !nfa_dm_is_p2p_paused()) {
-        UINT8_TO_STREAM(p, 0x00);  // RC=0
-      } else {
-        UINT8_TO_STREAM(p, 0x01);  // RC=1
+    if (NFC_GetNCIVersion() == NCI_VERSION_1_0) {
+      if (dm_disc_mask &
+          (NFA_DM_DISC_MASK_PF_NFC_DEP | NFA_DM_DISC_MASK_PF_T3T)) {
+        /* According to the NFC Forum Activity spec, controllers must:
+         * 1) Poll with RC=0 and SC=FFFF to find NFC-DEP targets
+         * 2) Poll with RC=1 and SC=FFFF to find T3T targets
+         * Many controllers don't do this yet, and seem to be activating
+         * NFC-DEP by default.
+         *
+         * We can at least fix the scenario where we're not interested
+         * in NFC-DEP, by setting RC=1 in that case. Otherwise, keep
+         * the default of RC=0. */
+        p = config_params;
+        UINT8_TO_STREAM(p, NFC_PMID_PF_RC);
+        UINT8_TO_STREAM(p, NCI_PARAM_LEN_PF_RC);
+        if ((dm_disc_mask & NFA_DM_DISC_MASK_PF_NFC_DEP) &&
+            !nfa_dm_is_p2p_paused()) {
+          UINT8_TO_STREAM(p, 0x00);  // RC=0
+        } else {
+          UINT8_TO_STREAM(p, 0x01);  // RC=1
+        }
+        nfa_dm_check_set_config(p - config_params, config_params, false);
       }
-      nfa_dm_check_set_config(p - config_params, config_params, false);
     }
   }
 #if (NXP_EXTNS == TRUE)
-  NFA_TRACE_DEBUG1("dm_disc_mask before masking = 0x%x", dm_disc_mask);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("dm_disc_mask before masking = 0x%x", dm_disc_mask);
   if (((hostListenMask & 0x1) == 0x0) && ((uiccListenMask & 0x1) == 0x0) && ((eseListenMask & 0x1) == 0x0)) {
-    NFA_TRACE_DEBUG0(
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "nfa_dm_start_rf_discover (): try removing A passive listen for "
         "ISO-DEP");
     dm_disc_mask &= ~(NFA_DM_DISC_MASK_LA_ISO_DEP);
   }
   if (((hostListenMask & 0x2) == 0x0) && ((uiccListenMask & 0x2) == 0x0) && ((eseListenMask & 0x2) == 0x0)) {
-    NFA_TRACE_DEBUG0(
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "nfa_dm_start_rf_discover (): try removing B passive listen for "
         "ISO-DEP");
     dm_disc_mask &= ~(NFA_DM_DISC_MASK_LB_ISO_DEP);
   }
   if (((hostListenMask & 0x4) == 0x0) && ((uiccListenMask & 0x4) == 0x0) && ((eseListenMask & 0x4) == 0x0)) {
-    NFA_TRACE_DEBUG0(
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "nfa_dm_start_rf_discover (): try removing F passive listen for T3T");
     dm_disc_mask &= ~(NFA_DM_DISC_MASK_LF_T3T);
   }
   if ((p2pListenMask & 0x84) == 0x0) {
-    NFA_TRACE_DEBUG0(
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "nfa_dm_start_rf_discover (): try removing F passive listen for "
         "NFC-DEP");
     dm_disc_mask &= ~(NFA_DM_DISC_MASK_LF_NFC_DEP);
     dm_disc_mask &= ~(NFA_DM_DISC_MASK_LFA_NFC_DEP);
   }
-  NFA_TRACE_DEBUG1("dm_disc_mask after masking = 0x%x", dm_disc_mask);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("dm_disc_mask after masking = 0x%x", dm_disc_mask);
 #endif
 
   /* Get Discovery Technology parameters */
@@ -1475,7 +1513,7 @@ bool nfa_dm_disc_handle_kovio_activation(tNFC_DISCOVER* p_data,
          p_data->activate.rf_tech_param.param.pk.uid_len) ||
         (memcmp(p_data->activate.rf_tech_param.param.pk.uid,
                 nfa_dm_cb.activated_nfcid, nfa_dm_cb.activated_nfcid_len))) {
-      NFA_TRACE_DEBUG0("new Kovio tag is detected");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("new Kovio tag is detected");
 
       /* notify presence check failure for previous tag, if presence check is
        * pending */
@@ -1529,7 +1567,7 @@ static tNFA_STATUS nfa_dm_disc_notify_activation(tNFC_DISCOVER* p_data) {
 
   tNFA_DM_DISC_TECH_PROTO_MASK activated_disc_mask;
 
-  NFA_TRACE_DEBUG2(
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "nfa_dm_disc_notify_activation (): tech_n_mode:0x%X, proto:0x%X",
       tech_n_mode, protocol);
 
@@ -1568,7 +1606,7 @@ static tNFA_STATUS nfa_dm_disc_notify_activation(tNFC_DISCOVER* p_data) {
         nfa_dm_cb.disc_cb.activated_protocol = NFC_PROTOCOL_UNKNOWN;
         nfa_dm_cb.disc_cb.activated_handle = xx;
 
-        NFA_TRACE_DEBUG2("activated_rf_interface:0x%x, activated_handle: 0x%x",
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("activated_rf_interface:0x%x, activated_handle: 0x%x",
                          nfa_dm_cb.disc_cb.activated_rf_interface,
                          nfa_dm_cb.disc_cb.activated_handle);
 
@@ -1602,7 +1640,7 @@ static tNFA_STATUS nfa_dm_disc_notify_activation(tNFC_DISCOVER* p_data) {
             p_data->activate.intf_param.type;
         nfa_dm_cb.disc_cb.activated_handle = xx;
 
-        NFA_TRACE_DEBUG2(
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
             "activated_rf_uicc-ese_interface:0x%x, activated_handle: 0x%x",
             nfa_dm_cb.disc_cb.activated_rf_interface,
             nfa_dm_cb.disc_cb.activated_handle);
@@ -1677,22 +1715,20 @@ static tNFA_STATUS nfa_dm_disc_notify_activation(tNFC_DISCOVER* p_data) {
     /* if any ISO-DEP or T3T listening even if host in LRT is not matched */
     xx = iso_dep_t3t__listen;
   }
-
-#if (NXP_EXTNS == TRUE)
   if (protocol == NFC_PROTOCOL_NFC_DEP &&
       (tech_n_mode == NFC_DISCOVERY_TYPE_LISTEN_F_ACTIVE ||
        tech_n_mode == NFC_DISCOVERY_TYPE_LISTEN_A_ACTIVE ||
        tech_n_mode == NFC_DISCOVERY_TYPE_LISTEN_A)) {
-    if (appl_dta_mode_flag == 1 &&
-        (tech_n_mode == NFC_DISCOVERY_TYPE_LISTEN_A)) {
-      NFA_TRACE_DEBUG0("DTA Mode Enabled : NFC-A Passive Listen Mode");
-    } else {
+    if (appl_dta_mode_flag == 1 && tech_n_mode == NFC_DISCOVERY_TYPE_LISTEN_A) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("DTA Mode Enabled : NFC-A Passive Listen Mode");
+    }
+#if (NXP_EXTNS == TRUE)
+    else {
       extern tNFA_P2P_CB nfa_p2p_cb;
       xx = nfa_p2p_cb.dm_disc_handle;
     }
-  }
-
 #endif
+  }
 
   if (xx < NFA_DM_DISC_NUM_ENTRIES) {
     nfa_dm_cb.disc_cb.activated_tech_mode = tech_n_mode;
@@ -1701,7 +1737,7 @@ static tNFA_STATUS nfa_dm_disc_notify_activation(tNFC_DISCOVER* p_data) {
     nfa_dm_cb.disc_cb.activated_protocol = protocol;
     nfa_dm_cb.disc_cb.activated_handle = xx;
 
-    NFA_TRACE_DEBUG2("activated_protocol:0x%x, activated_handle: 0x%x",
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("activated_protocol:0x%x, activated_handle: 0x%x",
                      nfa_dm_cb.disc_cb.activated_protocol,
                      nfa_dm_cb.disc_cb.activated_handle);
 
@@ -1741,11 +1777,11 @@ static void nfa_dm_disc_notify_deactivation(tNFA_DM_RF_DISC_SM_EVENT sm_event,
   tNFA_CONN_EVT_DATA evt_data;
   tNFC_DISCOVER disc_data;
 
-  NFA_TRACE_DEBUG1("nfa_dm_disc_notify_deactivation (): activated_handle=%d",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_disc_notify_deactivation (): activated_handle=%d",
                    nfa_dm_cb.disc_cb.activated_handle);
 
   if (nfa_dm_cb.disc_cb.disc_flags & NFA_DM_DISC_FLAGS_CHECKING) {
-    NFA_TRACE_DEBUG0("nfa_dm_disc_notify_deactivation (): for sleep wakeup");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_disc_notify_deactivation (): for sleep wakeup");
     return;
   }
 
@@ -1921,8 +1957,10 @@ static void nfa_dm_disc_end_sleep_wakeup(tNFC_STATUS status) {
       /* Perform pending deactivate command and on response notfiy deactivation
        */
       nfa_dm_cb.disc_cb.deact_notify_pending = true;
-      nfa_dm_disc_sm_execute(NFA_DM_RF_DEACTIVATE_CMD,
-                             (void*)&nfa_dm_cb.disc_cb.pending_deact_type);
+      tNFA_DM_RF_DISC_DATA nfa_dm_rf_disc_data;
+      nfa_dm_rf_disc_data.deactivate_type =
+          nfa_dm_cb.disc_cb.pending_deact_type;
+      nfa_dm_disc_sm_execute(NFA_DM_RF_DEACTIVATE_CMD, &nfa_dm_rf_disc_data);
     }
   }
 }
@@ -1936,10 +1974,9 @@ static void nfa_dm_disc_end_sleep_wakeup(tNFC_STATUS status) {
 ** Returns          void
 **
 *******************************************************************************/
-static void nfa_dm_disc_kovio_timeout_cback(TIMER_LIST_ENT* p_tle) {
-  tNFC_DEACTIVATE_DEVT deact;
-  (void)p_tle;
-  NFA_TRACE_DEBUG0("nfa_dm_disc_kovio_timeout_cback()");
+static void nfa_dm_disc_kovio_timeout_cback(__attribute__((unused))
+                                            TIMER_LIST_ENT* p_tle) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_disc_kovio_timeout_cback()");
 
   /* notify presence check failure, if presence check is pending */
   nfa_dm_disc_report_kovio_presence_check(NFC_STATUS_FAILED);
@@ -1951,10 +1988,14 @@ static void nfa_dm_disc_kovio_timeout_cback(TIMER_LIST_ENT* p_tle) {
                         NFA_DM_DISC_TIMEOUT_KOVIO_PRESENCE_CHECK);
   } else {
     /* notify upper layer deactivated event */
+    tNFC_DEACTIVATE_DEVT deact;
     deact.status = NFC_STATUS_OK;
     deact.type = NFC_DEACTIVATE_TYPE_DISCOVERY;
     deact.is_ntf = true;
-    nfa_dm_disc_notify_deactivation(NFA_DM_RF_DEACTIVATE_NTF, (void*)&deact);
+    deact.reason = NCI_DEACTIVATE_REASON_DH_REQ;
+    tNFC_DISCOVER nfc_discover;
+    nfc_discover.deactivate = deact;
+    nfa_dm_disc_notify_deactivation(NFA_DM_RF_DEACTIVATE_NTF, &nfc_discover);
   }
 }
 
@@ -1970,7 +2011,7 @@ static void nfa_dm_disc_kovio_timeout_cback(TIMER_LIST_ENT* p_tle) {
 tNFC_STATUS nfa_dm_disc_start_kovio_presence_check(void) {
   tNFC_STATUS status = NFC_STATUS_FAILED;
 
-  NFA_TRACE_DEBUG0("nfa_dm_disc_start_kovio_presence_check ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_disc_start_kovio_presence_check ()");
 
   if ((nfa_dm_cb.disc_cb.activated_protocol == NFC_PROTOCOL_KOVIO) &&
       (nfa_dm_cb.disc_cb.kovio_tle.in_use)) {
@@ -2009,7 +2050,7 @@ tNFC_STATUS nfa_dm_disc_start_kovio_presence_check(void) {
 **
 *******************************************************************************/
 static void nfa_dm_disc_report_kovio_presence_check(tNFC_STATUS status) {
-  NFA_TRACE_DEBUG0("nfa_dm_disc_report_kovio_presence_check ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_disc_report_kovio_presence_check ()");
 
   if (nfa_dm_cb.disc_cb.disc_flags & NFA_DM_DISC_FLAGS_CHECKING) {
     nfa_dm_cb.disc_cb.disc_flags &= ~NFA_DM_DISC_FLAGS_CHECKING;
@@ -2019,8 +2060,10 @@ static void nfa_dm_disc_report_kovio_presence_check(tNFC_STATUS status) {
 
     if (nfa_dm_cb.disc_cb.deact_pending) {
       nfa_dm_cb.disc_cb.deact_pending = false;
-      nfa_dm_disc_sm_execute(NFA_DM_RF_DEACTIVATE_CMD,
-                             (void*)&nfa_dm_cb.disc_cb.pending_deact_type);
+      tNFA_DM_RF_DISC_DATA nfa_dm_rf_disc_data;
+      nfa_dm_rf_disc_data.deactivate_type =
+          nfa_dm_cb.disc_cb.pending_deact_type;
+      nfa_dm_disc_sm_execute(NFA_DM_RF_DEACTIVATE_CMD, &nfa_dm_rf_disc_data);
     }
   }
 }
@@ -2034,10 +2077,9 @@ static void nfa_dm_disc_report_kovio_presence_check(tNFC_STATUS status) {
 ** Returns          void
 **
 *******************************************************************************/
-static void nfa_dm_disc_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
-                                   tNFC_CONN* p_data) {
-  (void)conn_id;
-  NFA_TRACE_DEBUG0("nfa_dm_disc_data_cback ()");
+static void nfa_dm_disc_data_cback(__attribute__((unused)) uint8_t conn_id,
+                                    tNFC_CONN_EVT event, tNFC_CONN* p_data) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_disc_data_cback ()");
 
   /* if selection failed */
   if (event == NFC_ERROR_CEVT) {
@@ -2060,18 +2102,12 @@ void nfa_dm_disc_new_state(tNFA_DM_RF_DISC_STATE new_state) {
   tNFA_CONN_EVT_DATA evt_data;
   tNFA_DM_RF_DISC_STATE old_state = nfa_dm_cb.disc_cb.disc_state;
 
-#if (BT_TRACE_VERBOSE == true)
-  NFA_TRACE_DEBUG5(
-      "nfa_dm_disc_new_state (): old_state: %s (%d), new_state: %s (%d) "
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "old_state: %s (%d), new_state: %s (%d) "
       "disc_flags: 0x%x",
-      nfa_dm_disc_state_2_str(nfa_dm_cb.disc_cb.disc_state),
-      nfa_dm_cb.disc_cb.disc_state, nfa_dm_disc_state_2_str(new_state),
+      nfa_dm_disc_state_2_str(nfa_dm_cb.disc_cb.disc_state).c_str(),
+      nfa_dm_cb.disc_cb.disc_state, nfa_dm_disc_state_2_str(new_state).c_str(),
       new_state, nfa_dm_cb.disc_cb.disc_flags);
-#else
-  NFA_TRACE_DEBUG3(
-      "nfa_dm_disc_new_state(): old_state: %d, new_state: %d disc_flags: 0x%x",
-      nfa_dm_cb.disc_cb.disc_state, new_state, nfa_dm_cb.disc_cb.disc_flags);
-#endif
 
   nfa_dm_cb.disc_cb.disc_state = new_state;
 
@@ -2143,7 +2179,7 @@ static void nfa_dm_disc_sm_idle(tNFA_DM_RF_DISC_SM_EVENT event,
 
             if (nfa_dm_cb.disc_cb.excl_disc_entry.p_disc_cback)
               (*(nfa_dm_cb.disc_cb.excl_disc_entry.p_disc_cback))(
-                  NFA_DM_RF_DISC_START_EVT, (tNFC_DISCOVER*)p_data);
+                  NFA_DM_RF_DISC_START_EVT, &p_data->nfc_discover);
           }
         } else {
           /* notify event to each module which is waiting for start */
@@ -2159,7 +2195,7 @@ static void nfa_dm_disc_sm_idle(tNFA_DM_RF_DISC_SM_EVENT event,
 
               if (nfa_dm_cb.disc_cb.entry[xx].p_disc_cback)
                 (*(nfa_dm_cb.disc_cb.entry[xx].p_disc_cback))(
-                    NFA_DM_RF_DISC_START_EVT, (tNFC_DISCOVER*)p_data);
+                    NFA_DM_RF_DISC_START_EVT, &p_data->nfc_discover);
             }
           }
         }
@@ -2242,7 +2278,7 @@ static void nfa_dm_disc_sm_idle(tNFA_DM_RF_DISC_SM_EVENT event,
       break;
 
     default:
-      NFA_TRACE_ERROR0("nfa_dm_disc_sm_idle (): Unexpected discovery event");
+      LOG(ERROR) << StringPrintf("nfa_dm_disc_sm_idle (): Unexpected discovery event");
       break;
   }
 }
@@ -2286,7 +2322,7 @@ static void nfa_dm_disc_sm_discovery(tNFA_DM_RF_DISC_SM_EVENT event,
       if (p_data->nfc_discover.result.more == NCI_DISCOVER_NTF_LAST_ABORT) {
         /* Fix for multiple tags: After receiving deactivate event, restart
          * discovery */
-        NFA_TRACE_DEBUG0(
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
             "Received NCI_DISCOVER_NTF_LAST_ABORT, sending deactivate command");
         NFC_Deactivate(NFA_DEACTIVATE_TYPE_IDLE);
       } else {
@@ -2299,7 +2335,7 @@ static void nfa_dm_disc_sm_discovery(tNFA_DM_RF_DISC_SM_EVENT event,
       break;
     case NFA_DM_RF_INTF_ACTIVATED_NTF:
       if (nfa_dm_cb.disc_cb.disc_flags & NFA_DM_DISC_FLAGS_W4_RSP) {
-        NFA_TRACE_DEBUG0("RF Activated while waiting for deactivation RSP");
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RF Activated while waiting for deactivation RSP");
         /* it's race condition. DH has to wait for deactivation NTF */
         nfa_dm_cb.disc_cb.disc_flags |= NFA_DM_DISC_FLAGS_W4_NTF;
       } else {
@@ -2330,7 +2366,7 @@ static void nfa_dm_disc_sm_discovery(tNFA_DM_RF_DISC_SM_EVENT event,
 
         if (nfa_dm_disc_notify_activation(&(p_data->nfc_discover)) ==
             NFA_STATUS_FAILED) {
-          NFA_TRACE_DEBUG0(
+           DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
               "Not matched, restart discovery after receiving deactivate ntf");
 
           /* after receiving deactivate event, restart discovery */
@@ -2362,7 +2398,7 @@ static void nfa_dm_disc_sm_discovery(tNFA_DM_RF_DISC_SM_EVENT event,
     case NFA_DM_CORE_INTF_ERROR_NTF:
       break;
     default:
-      NFA_TRACE_ERROR0(
+      LOG(ERROR) << StringPrintf(
           "nfa_dm_disc_sm_discovery (): Unexpected discovery event");
       break;
   }
@@ -2402,7 +2438,7 @@ static void nfa_dm_disc_sm_w4_all_discoveries(tNFA_DM_RF_DISC_SM_EVENT event,
 #if (NXP_EXTNS == TRUE)
       if (p_data->nfc_discover.result.protocol == NCI_PROTOCOL_UNKNOWN) {
         /* fix for p2p interop with Nexus5 */
-        NFA_TRACE_DEBUG0("Unknown protocol - Restart Discovery");
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Unknown protocol - Restart Discovery");
         /* after receiving unknown protocol, restart discovery */
         NFC_Deactivate(NFA_DEACTIVATE_TYPE_IDLE);
         return;
@@ -2428,7 +2464,7 @@ static void nfa_dm_disc_sm_w4_all_discoveries(tNFA_DM_RF_DISC_SM_EVENT event,
 
       if (nfa_dm_disc_notify_activation(&(p_data->nfc_discover)) ==
           NFA_STATUS_FAILED) {
-        NFA_TRACE_DEBUG0(
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
             "Not matched, restart discovery after receiving deactivate ntf");
 
         /* after receiving deactivate event, restart discovery */
@@ -2436,7 +2472,7 @@ static void nfa_dm_disc_sm_w4_all_discoveries(tNFA_DM_RF_DISC_SM_EVENT event,
       }
       break;
     default:
-      NFA_TRACE_ERROR0(
+      LOG(ERROR) << StringPrintf(
           "nfa_dm_disc_sm_w4_all_discoveries (): Unexpected discovery event");
       break;
   }
@@ -2503,7 +2539,7 @@ static void nfa_dm_disc_sm_w4_host_select(tNFA_DM_RF_DISC_SM_EVENT event,
         nfa_rw_set_cback(&(p_data->nfc_discover));
 #endif
       } else if (status == NFA_STATUS_FAILED) {
-        NFA_TRACE_DEBUG0(
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
             "Not matched, restart discovery after receiving deactivate ntf");
 
         /* after receiving deactivate event, restart discovery */
@@ -2542,10 +2578,10 @@ static void nfa_dm_disc_sm_w4_host_select(tNFA_DM_RF_DISC_SM_EVENT event,
       }
       break;
     default:
-      NFA_TRACE_ERROR0(
+      LOG(ERROR) << StringPrintf(
           "nfa_dm_disc_sm_w4_host_select (): Unexpected discovery event");
 #if (NXP_EXTNS == TRUE)
-      NFA_TRACE_ERROR0("nfa_dm_disc_sm_w4_host_select (): Restarted discovery");
+      LOG(ERROR) << StringPrintf("nfa_dm_disc_sm_w4_host_select (): Restarted discovery");
       NFC_Deactivate(NFA_DEACTIVATE_TYPE_IDLE);
 #endif
       break;
@@ -2575,17 +2611,18 @@ static void nfa_dm_disc_sm_poll_active(tNFA_DM_RF_DISC_SM_EVENT event,
       (nfa_dm_cb.disc_cb.disc_flags & NFA_DM_DISC_FLAGS_CHECKING);
   bool sleep_wakeup_event = false;
   bool sleep_wakeup_event_processed = false;
-  tNFC_DEACTIVATE_DEVT deact;
 
   switch (event) {
     case NFA_DM_RF_DEACTIVATE_CMD:
-      if(NFC_GetNCIVersion()== NCI_VERSION_2_0){
-          if((nfa_dm_cb.disc_cb.activated_rf_interface == NFC_INTERFACE_FRAME) &&
-                  (p_data->deactivate_type == NFC_DEACTIVATE_TYPE_SLEEP)) {
-             /* NCI 2.0- DH is responsible for sending deactivation commands before RF_DEACTIVATE_CMD */
-             nfa_dm_send_tag_deselect_cmd(nfa_dm_cb.disc_cb.activated_protocol);
-          }
+      if (NFC_GetNCIVersion() == NCI_VERSION_2_0) {
+        if ((nfa_dm_cb.disc_cb.activated_rf_interface == NFC_INTERFACE_FRAME) &&
+            (p_data->deactivate_type == NFC_DEACTIVATE_TYPE_SLEEP)) {
+          /* NCI 2.0- DH is responsible for sending deactivation commands before
+           * RF_DEACTIVATE_CMD */
+          nfa_dm_send_tag_deselect_cmd(nfa_dm_cb.disc_cb.activated_protocol);
+        }
       }
+
       if (nfa_dm_cb.disc_cb.activated_protocol == NCI_PROTOCOL_MIFARE) {
         nfa_dm_cb.disc_cb.deact_pending = true;
         nfa_dm_cb.disc_cb.pending_deact_type = p_data->deactivate_type;
@@ -2611,11 +2648,15 @@ static void nfa_dm_disc_sm_poll_active(tNFA_DM_RF_DISC_SM_EVENT event,
       if (!(nfa_dm_cb.disc_cb.disc_flags & NFA_DM_DISC_FLAGS_W4_NTF)) {
         /* it's race condition. received deactivate NTF before receiving RSP */
 
+        tNFC_DEACTIVATE_DEVT deact;
         deact.status = NFC_STATUS_OK;
         deact.type = NFC_DEACTIVATE_TYPE_IDLE;
         deact.is_ntf = true;
+	deact.reason = NCI_DEACTIVATE_REASON_DH_REQ;
+        tNFC_DISCOVER nfc_discover;
+        nfc_discover.deactivate = deact;
         nfa_dm_disc_notify_deactivation(NFA_DM_RF_DEACTIVATE_NTF,
-                                        (void*)&deact);
+                                        &nfc_discover);
 
         /* NFCC is in IDLE state */
         nfa_dm_disc_new_state(NFA_DM_RFST_IDLE);
@@ -2630,38 +2671,63 @@ static void nfa_dm_disc_sm_poll_active(tNFA_DM_RF_DISC_SM_EVENT event,
       if (nfa_dm_cb.disc_cb.disc_flags & NFA_DM_DISC_FLAGS_W4_RSP) {
         /* it's race condition. received deactivate NTF before receiving RSP */
         /* notify deactivation after receiving deactivate RSP */
-        NFA_TRACE_DEBUG0("Rx deactivate NTF while waiting for deactivate RSP");
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Rx deactivate NTF while waiting for deactivate RSP");
         break;
       }
-
-      sleep_wakeup_event = true;
-
-      nfa_dm_disc_notify_deactivation(NFA_DM_RF_DEACTIVATE_NTF,
-                                      &(p_data->nfc_discover));
-
-      if ((p_data->nfc_discover.deactivate.type == NFC_DEACTIVATE_TYPE_SLEEP) ||
-          (p_data->nfc_discover.deactivate.type ==
-           NFC_DEACTIVATE_TYPE_SLEEP_AF)) {
-        nfa_dm_disc_new_state(NFA_DM_RFST_W4_HOST_SELECT);
-        if (old_sleep_wakeup_flag) {
-          sleep_wakeup_event_processed = true;
-          /* process pending deactivate request */
-          if (nfa_dm_cb.disc_cb.deact_pending) {
-            /* notify RW module that sleep wakeup is finished */
-            /* if deactivation is pending then deactivate  */
-            nfa_dm_disc_end_sleep_wakeup(NFC_STATUS_OK);
-
-            /* Notify NFA RW sub-systems because NFA_DM_RF_DEACTIVATE_RSP will
-             * not call this function */
-            nfa_rw_proc_disc_evt(NFA_DM_RF_DISC_DEACTIVATED_EVT, NULL, true);
-          } else {
-            /* Successfully went to sleep mode for sleep wakeup */
-            /* Now wake up the tag to complete the operation */
-            NFC_DiscoverySelect(nfa_dm_cb.disc_cb.activated_rf_disc_id,
-                                nfa_dm_cb.disc_cb.activated_protocol,
-                                nfa_dm_cb.disc_cb.activated_rf_interface);
-          }
+      if (p_data->nfc_discover.deactivate.reason !=
+          NFC_DEACTIVATE_REASON_DH_REQ_FAILED) {
+        sleep_wakeup_event = true;
+        nfa_dm_disc_notify_deactivation(NFA_DM_RF_DEACTIVATE_NTF,
+                                        &(p_data->nfc_discover));
         }
+        if ((p_data->nfc_discover.deactivate.type ==
+             NFC_DEACTIVATE_TYPE_SLEEP) ||
+            (p_data->nfc_discover.deactivate.type ==
+             NFC_DEACTIVATE_TYPE_SLEEP_AF)) {
+          if (p_data->nfc_discover.deactivate.reason !=
+              NFC_DEACTIVATE_REASON_DH_REQ_FAILED) {
+            /* count for number of times deactivate cmd sent */
+            nfa_dm_cb.deactivate_cmd_retry_count = 0;
+            nfa_dm_disc_new_state(NFA_DM_RFST_W4_HOST_SELECT);
+          }
+          if (old_sleep_wakeup_flag) {
+            sleep_wakeup_event_processed = true;
+            /* process pending deactivate request */
+            if (nfa_dm_cb.disc_cb.deact_pending) {
+              /* notify RW module that sleep wakeup is finished */
+              /* if deactivation is pending then deactivate  */
+              nfa_dm_disc_end_sleep_wakeup(NFC_STATUS_OK);
+
+              /* Notify NFA RW sub-systems because NFA_DM_RF_DEACTIVATE_RSP will
+               * not call this function */
+              nfa_rw_proc_disc_evt(NFA_DM_RF_DISC_DEACTIVATED_EVT, NULL, true);
+            } else {
+              /* Successfully went to sleep mode for sleep wakeup */
+              /* Now wake up the tag to complete the operation */
+              NFC_DiscoverySelect(nfa_dm_cb.disc_cb.activated_rf_disc_id,
+                                  nfa_dm_cb.disc_cb.activated_protocol,
+                                  nfa_dm_cb.disc_cb.activated_rf_interface);
+            }
+          }
+          if (p_data->nfc_discover.deactivate.reason ==
+              NFC_DEACTIVATE_REASON_DH_REQ_FAILED) {
+            /* in case deactivation is not sucessfull, NFCC shall send
+               RF_DEACTIVATE_NTF with DH Req failed due to error.
+               MW shall send deactivation cmd again for 3 three times. if
+               deactivation is not successfull 3 times also,
+               then MW shall send deacivate cmd with deactivate type is
+               discovery */
+            if (nfa_dm_cb.deactivate_cmd_retry_count == 3) {
+              if ((!old_sleep_wakeup_flag) ||
+                  (!nfa_dm_cb.disc_cb.deact_pending)) {
+                nfa_dm_send_deactivate_cmd(NFA_DEACTIVATE_TYPE_DISCOVERY);
+              }
+              nfa_dm_cb.deactivate_cmd_retry_count = 0;
+            } else {
+              nfa_dm_cb.deactivate_cmd_retry_count++;
+              nfa_dm_send_deactivate_cmd(p_data->nfc_discover.deactivate.type);
+            }
+          }
       } else if (p_data->nfc_discover.deactivate.type ==
                  NFC_DEACTIVATE_TYPE_IDLE) {
         nfa_dm_disc_new_state(NFA_DM_RFST_IDLE);
@@ -2686,7 +2752,7 @@ static void nfa_dm_disc_sm_poll_active(tNFA_DM_RF_DISC_SM_EVENT event,
       break;
 
     default:
-      NFA_TRACE_ERROR0(
+      LOG(ERROR) << StringPrintf(
           "nfa_dm_disc_sm_poll_active (): Unexpected discovery event");
       break;
   }
@@ -2725,8 +2791,11 @@ static void nfa_dm_disc_sm_listen_active(tNFA_DM_RF_DISC_SM_EVENT event,
         deact.status = NFC_STATUS_OK;
         deact.type = NFC_DEACTIVATE_TYPE_IDLE;
         deact.is_ntf = true;
+	deact.reason = NCI_DEACTIVATE_REASON_DH_REQ;
+        tNFC_DISCOVER nfc_discover;
+        nfc_discover.deactivate = deact;
         nfa_dm_disc_notify_deactivation(NFA_DM_RF_DEACTIVATE_NTF,
-                                        (void*)&deact);
+                                        &nfc_discover);
 
         /* NFCC is in IDLE state */
         nfa_dm_disc_new_state(NFA_DM_RFST_IDLE);
@@ -2741,7 +2810,7 @@ static void nfa_dm_disc_sm_listen_active(tNFA_DM_RF_DISC_SM_EVENT event,
       if (nfa_dm_cb.disc_cb.disc_flags & NFA_DM_DISC_FLAGS_W4_RSP) {
         /* it's race condition. received deactivate NTF before receiving RSP */
         /* notify deactivation after receiving deactivate RSP */
-        NFA_TRACE_DEBUG0("Rx deactivate NTF while waiting for deactivate RSP");
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Rx deactivate NTF while waiting for deactivate RSP");
       } else {
         nfa_dm_disc_notify_deactivation(NFA_DM_RF_DEACTIVATE_NTF,
                                         &(p_data->nfc_discover));
@@ -2769,7 +2838,7 @@ static void nfa_dm_disc_sm_listen_active(tNFA_DM_RF_DISC_SM_EVENT event,
     case NFA_DM_CORE_INTF_ERROR_NTF:
       break;
     default:
-      NFA_TRACE_ERROR0(
+      LOG(ERROR) << StringPrintf(
           "nfa_dm_disc_sm_listen_active (): Unexpected discovery event");
       break;
   }
@@ -2828,7 +2897,7 @@ static void nfa_dm_disc_sm_listen_sleep(tNFA_DM_RF_DISC_SM_EVENT event,
                  NFA_DEACTIVATE_TYPE_DISCOVERY) {
         nfa_dm_disc_new_state(NFA_DM_RFST_DISCOVERY);
       } else {
-        NFA_TRACE_ERROR0("Unexpected deactivation type");
+        LOG(ERROR) << StringPrintf("Unexpected deactivation type");
         nfa_dm_disc_new_state(NFA_DM_RFST_IDLE);
         nfa_dm_start_rf_discover();
       }
@@ -2837,7 +2906,7 @@ static void nfa_dm_disc_sm_listen_sleep(tNFA_DM_RF_DISC_SM_EVENT event,
       nfa_dm_disc_new_state(NFA_DM_RFST_LISTEN_ACTIVE);
       if (nfa_dm_disc_notify_activation(&(p_data->nfc_discover)) ==
           NFA_STATUS_FAILED) {
-        NFA_TRACE_DEBUG0(
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
             "Not matched, restart discovery after receiving deactivate ntf");
 
         /* after receiving deactivate event, restart discovery */
@@ -2845,7 +2914,7 @@ static void nfa_dm_disc_sm_listen_sleep(tNFA_DM_RF_DISC_SM_EVENT event,
       }
       break;
     default:
-      NFA_TRACE_ERROR0(
+      LOG(ERROR) << StringPrintf(
           "nfa_dm_disc_sm_listen_sleep (): Unexpected discovery event");
       break;
   }
@@ -2867,12 +2936,12 @@ static void nfa_dm_disc_sm_lp_listen(tNFA_DM_RF_DISC_SM_EVENT event,
       nfa_dm_disc_new_state(NFA_DM_RFST_LP_ACTIVE);
       if (nfa_dm_disc_notify_activation(&(p_data->nfc_discover)) ==
           NFA_STATUS_FAILED) {
-        NFA_TRACE_DEBUG0("Not matched, unexpected activation");
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Not matched, unexpected activation");
       }
       break;
 
     default:
-      NFA_TRACE_ERROR0(
+      LOG(ERROR) << StringPrintf(
           "nfa_dm_disc_sm_lp_listen (): Unexpected discovery event");
       break;
   }
@@ -2896,7 +2965,7 @@ static void nfa_dm_disc_sm_lp_active(tNFA_DM_RF_DISC_SM_EVENT event,
                                       &(p_data->nfc_discover));
       break;
     default:
-      NFA_TRACE_ERROR0(
+      LOG(ERROR) << StringPrintf(
           "nfa_dm_disc_sm_lp_active (): Unexpected discovery event");
       break;
   }
@@ -2913,18 +2982,12 @@ static void nfa_dm_disc_sm_lp_active(tNFA_DM_RF_DISC_SM_EVENT event,
 *******************************************************************************/
 void nfa_dm_disc_sm_execute(tNFA_DM_RF_DISC_SM_EVENT event,
                             tNFA_DM_RF_DISC_DATA* p_data) {
-#if (BT_TRACE_VERBOSE == true)
-  NFA_TRACE_DEBUG5(
-      "nfa_dm_disc_sm_execute (): state: %s (%d), event: %s(%d) disc_flags: "
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "state: %s (%d), event: %s(%d) disc_flags: "
       "0x%x",
-      nfa_dm_disc_state_2_str(nfa_dm_cb.disc_cb.disc_state),
-      nfa_dm_cb.disc_cb.disc_state, nfa_dm_disc_event_2_str(event), event,
+      nfa_dm_disc_state_2_str(nfa_dm_cb.disc_cb.disc_state).c_str(),
+      nfa_dm_cb.disc_cb.disc_state, nfa_dm_disc_event_2_str(event).c_str(), event,
       nfa_dm_cb.disc_cb.disc_flags);
-#else
-  NFA_TRACE_DEBUG3(
-      "nfa_dm_disc_sm_execute(): state: %d, event:%d disc_flags: 0x%x",
-      nfa_dm_cb.disc_cb.disc_state, event, nfa_dm_cb.disc_cb.disc_flags);
-#endif
 
   switch (nfa_dm_cb.disc_cb.disc_state) {
     /*  RF Discovery State - Idle */
@@ -2972,15 +3035,10 @@ void nfa_dm_disc_sm_execute(tNFA_DM_RF_DISC_SM_EVENT event,
       nfa_dm_disc_sm_lp_active(event, p_data);
       break;
   }
-#if (BT_TRACE_VERBOSE == true)
-  NFA_TRACE_DEBUG3(
-      "nfa_dm_disc_sm_execute (): new state: %s (%d), disc_flags: 0x%x",
-      nfa_dm_disc_state_2_str(nfa_dm_cb.disc_cb.disc_state),
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "new state: %s (%d), disc_flags: 0x%x",
+      nfa_dm_disc_state_2_str(nfa_dm_cb.disc_cb.disc_state).c_str(),
       nfa_dm_cb.disc_cb.disc_state, nfa_dm_cb.disc_cb.disc_flags);
-#else
-  NFA_TRACE_DEBUG2("nfa_dm_disc_sm_execute(): new state: %d,  disc_flags: 0x%x",
-                   nfa_dm_cb.disc_cb.disc_state, nfa_dm_cb.disc_cb.disc_flags);
-#endif
 }
 
 /*******************************************************************************
@@ -2997,12 +3055,12 @@ tNFA_HANDLE nfa_dm_add_rf_discover(tNFA_DM_DISC_TECH_PROTO_MASK disc_mask,
                                    tNFA_DISCOVER_CBACK* p_disc_cback) {
   uint8_t xx;
 
-  NFA_TRACE_DEBUG2("nfa_dm_add_rf_discover ():host_id=0x%X disc_mask=0x%x",
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_add_rf_discover ():host_id=0x%X disc_mask=0x%x",
                    host_id, disc_mask);
 
   for (xx = 0; xx < NFA_DM_DISC_NUM_ENTRIES; xx++) {
     if (!nfa_dm_cb.disc_cb.entry[xx].in_use) {
-      NFA_TRACE_DEBUG2(
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "nfa_dm_add_rf_discover ():disc_mask=0x%x, cback entry:[%d]",
           disc_mask, xx);
       nfa_dm_cb.disc_cb.entry[xx].in_use = true;
@@ -3031,7 +3089,7 @@ void nfa_dm_start_excl_discovery(tNFA_TECHNOLOGY_MASK poll_tech_mask,
                                  tNFA_DISCOVER_CBACK* p_disc_cback) {
   tNFA_DM_DISC_TECH_PROTO_MASK poll_disc_mask = 0;
 
-  NFA_TRACE_DEBUG0("nfa_dm_start_excl_discovery ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_start_excl_discovery ()");
 
   if (poll_tech_mask & NFA_TECHNOLOGY_MASK_A) {
     poll_disc_mask |= NFA_DM_DISC_MASK_PA_T1T;
@@ -3040,9 +3098,19 @@ void nfa_dm_start_excl_discovery(tNFA_TECHNOLOGY_MASK poll_tech_mask,
     poll_disc_mask |= NFA_DM_DISC_MASK_PA_NFC_DEP;
     poll_disc_mask |= NFA_DM_DISC_MASK_P_LEGACY;
   }
-  if (poll_tech_mask & NFA_TECHNOLOGY_MASK_A_ACTIVE) {
-    poll_disc_mask |= NFA_DM_DISC_MASK_PAA_NFC_DEP;
+  if (NFC_GetNCIVersion() == NCI_VERSION_2_0) {
+    if (poll_tech_mask & NFA_TECHNOLOGY_MASK_ACTIVE) {
+      poll_disc_mask |= NFA_DM_DISC_MASK_PACM_NFC_DEP;
+    }
+  } else {
+    if (poll_tech_mask & NFA_TECHNOLOGY_MASK_A_ACTIVE) {
+      poll_disc_mask |= NFA_DM_DISC_MASK_PAA_NFC_DEP;
+    }
+    if (poll_tech_mask & NFA_TECHNOLOGY_MASK_F_ACTIVE) {
+      poll_disc_mask |= NFA_DM_DISC_MASK_PFA_NFC_DEP;
+    }
   }
+
   if (poll_tech_mask & NFA_TECHNOLOGY_MASK_B) {
     poll_disc_mask |= NFA_DM_DISC_MASK_PB_ISO_DEP;
   }
@@ -3050,11 +3118,8 @@ void nfa_dm_start_excl_discovery(tNFA_TECHNOLOGY_MASK poll_tech_mask,
     poll_disc_mask |= NFA_DM_DISC_MASK_PF_T3T;
     poll_disc_mask |= NFA_DM_DISC_MASK_PF_NFC_DEP;
   }
-  if (poll_tech_mask & NFA_TECHNOLOGY_MASK_F_ACTIVE) {
-    poll_disc_mask |= NFA_DM_DISC_MASK_PFA_NFC_DEP;
-  }
-  if (poll_tech_mask & NFA_TECHNOLOGY_MASK_ISO15693) {
-    poll_disc_mask |= NFA_DM_DISC_MASK_P_ISO15693;
+  if (poll_tech_mask & NFA_TECHNOLOGY_MASK_V) {
+    poll_disc_mask |= NFA_DM_DISC_MASK_P_T5T;
   }
   if (poll_tech_mask & NFA_TECHNOLOGY_MASK_B_PRIME) {
     poll_disc_mask |= NFA_DM_DISC_MASK_P_B_PRIME;
@@ -3085,7 +3150,7 @@ void nfa_dm_start_excl_discovery(tNFA_TECHNOLOGY_MASK poll_tech_mask,
 **
 *******************************************************************************/
 void nfa_dm_stop_excl_discovery(void) {
-  NFA_TRACE_DEBUG0("nfa_dm_stop_excl_discovery ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_stop_excl_discovery ()");
 
   nfa_dm_cb.disc_cb.excl_disc_entry.in_use = false;
   nfa_dm_cb.disc_cb.excl_disc_entry.p_disc_cback = NULL;
@@ -3101,12 +3166,12 @@ void nfa_dm_stop_excl_discovery(void) {
 **
 *******************************************************************************/
 void nfa_dm_delete_rf_discover(tNFA_HANDLE handle) {
-  NFA_TRACE_DEBUG1("nfa_dm_delete_rf_discover () handle=0x%x", handle);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_delete_rf_discover () handle=0x%x", handle);
 
   if (handle < NFA_DM_DISC_NUM_ENTRIES) {
     nfa_dm_cb.disc_cb.entry[handle].in_use = false;
   } else {
-    NFA_TRACE_ERROR0("Invalid discovery handle");
+    LOG(ERROR) << StringPrintf("Invalid discovery handle");
   }
 }
 
@@ -3124,7 +3189,7 @@ void nfa_dm_rf_discover_select(uint8_t rf_disc_id, tNFA_NFC_PROTOCOL protocol,
   tNFA_DM_DISC_SELECT_PARAMS select_params;
   tNFA_CONN_EVT_DATA conn_evt;
 
-  NFA_TRACE_DEBUG3(
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "nfa_dm_disc_select () rf_disc_id:0x%X, protocol:0x%X, rf_interface:0x%X",
       rf_disc_id, protocol, rf_interface);
 
@@ -3135,8 +3200,9 @@ void nfa_dm_rf_discover_select(uint8_t rf_disc_id, tNFA_NFC_PROTOCOL protocol,
     select_params.rf_interface = rf_interface;
 
     nfa_dm_cb.disc_cb.disc_flags |= NFA_DM_DISC_FLAGS_NOTIFY;
-    nfa_dm_disc_sm_execute(NFA_DM_RF_DISCOVER_SELECT_CMD,
-                           (void*)&select_params);
+    tNFA_DM_RF_DISC_DATA nfa_dm_rf_disc_data;
+    nfa_dm_rf_disc_data.select = select_params;
+    nfa_dm_disc_sm_execute(NFA_DM_RF_DISCOVER_SELECT_CMD, &nfa_dm_rf_disc_data);
   } else {
     /* Wrong state: notify failed status right away */
     conn_evt.status = NFA_STATUS_FAILED;
@@ -3154,7 +3220,7 @@ void nfa_dm_rf_discover_select(uint8_t rf_disc_id, tNFA_NFC_PROTOCOL protocol,
 **
 *******************************************************************************/
 tNFA_STATUS nfa_dm_rf_deactivate(tNFA_DEACTIVATE_TYPE deactivate_type) {
-  NFA_TRACE_DEBUG1("nfa_dm_rf_deactivate () deactivate_type:0x%X",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_rf_deactivate () deactivate_type:0x%X",
                    deactivate_type);
 
   if (deactivate_type == NFA_DEACTIVATE_TYPE_SLEEP) {
@@ -3174,7 +3240,7 @@ tNFA_STATUS nfa_dm_rf_deactivate(tNFA_DEACTIVATE_TYPE deactivate_type) {
         return NFA_STATUS_OK;
       } else {
         /* it could be race condition. */
-        NFA_TRACE_DEBUG0("nfa_dm_rf_deactivate (): already in discovery state");
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_rf_deactivate (): already in discovery state");
         return NFA_STATUS_FAILED;
       }
     } else if (deactivate_type == NFA_DEACTIVATE_TYPE_IDLE) {
@@ -3182,7 +3248,9 @@ tNFA_STATUS nfa_dm_rf_deactivate(tNFA_DEACTIVATE_TYPE deactivate_type) {
         nfa_sys_stop_timer(&nfa_dm_cb.disc_cb.kovio_tle);
         nfa_dm_disc_kovio_timeout_cback(&nfa_dm_cb.disc_cb.kovio_tle);
       }
-      nfa_dm_disc_sm_execute(NFA_DM_RF_DEACTIVATE_CMD, (void*)&deactivate_type);
+      tNFA_DM_RF_DISC_DATA nfa_dm_rf_disc_data;
+      nfa_dm_rf_disc_data.deactivate_type = deactivate_type;
+      nfa_dm_disc_sm_execute(NFA_DM_RF_DEACTIVATE_CMD, &nfa_dm_rf_disc_data);
       return NFA_STATUS_OK;
     } else {
       return NFA_STATUS_FAILED;
@@ -3194,12 +3262,13 @@ tNFA_STATUS nfa_dm_rf_deactivate(tNFA_DEACTIVATE_TYPE deactivate_type) {
       nfa_dm_disc_kovio_timeout_cback(&nfa_dm_cb.disc_cb.kovio_tle);
     }
 #endif
-    nfa_dm_disc_sm_execute(NFA_DM_RF_DEACTIVATE_CMD, (void*)&deactivate_type);
+    tNFA_DM_RF_DISC_DATA nfa_dm_rf_disc_data;
+    nfa_dm_rf_disc_data.deactivate_type = deactivate_type;
+    nfa_dm_disc_sm_execute(NFA_DM_RF_DEACTIVATE_CMD, &nfa_dm_rf_disc_data);
     return NFA_STATUS_OK;
   }
 }
 
-#if (BT_TRACE_VERBOSE == true)
 /*******************************************************************************
 **
 ** Function         nfa_dm_disc_state_2_str
@@ -3207,7 +3276,7 @@ tNFA_STATUS nfa_dm_rf_deactivate(tNFA_DEACTIVATE_TYPE deactivate_type) {
 ** Description      convert nfc discovery state to string
 **
 *******************************************************************************/
-static char* nfa_dm_disc_state_2_str(uint8_t state) {
+static std::string nfa_dm_disc_state_2_str(uint8_t state) {
   switch (state) {
     case NFA_DM_RFST_IDLE:
       return "IDLE";
@@ -3246,7 +3315,7 @@ static char* nfa_dm_disc_state_2_str(uint8_t state) {
 ** Description      convert nfc discovery RSP/NTF to string
 **
 *******************************************************************************/
-static char* nfa_dm_disc_event_2_str(uint8_t event) {
+static std::string nfa_dm_disc_event_2_str(uint8_t event) {
   switch (event) {
     case NFA_DM_RF_DISCOVER_CMD:
       return "DISCOVER_CMD";
@@ -3283,7 +3352,6 @@ static char* nfa_dm_disc_event_2_str(uint8_t event) {
   }
   return "Unknown";
 }
-#endif /* BT_TRACE_VERBOSE */
 
 /*******************************************************************************
 **
@@ -3297,31 +3365,31 @@ static char* nfa_dm_disc_event_2_str(uint8_t event) {
 *******************************************************************************/
 bool nfa_dm_p2p_prio_logic(uint8_t event, uint8_t* p, uint8_t event_type) {
   if (!nfa_poll_bail_out_mode) {
-    NFA_TRACE_DEBUG0("p2p priority is running under bail out mode ONLY.");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("p2p priority is running under bail out mode ONLY.");
     return true;
   }
 
   if ((nfa_dm_cb.flags & NFA_DM_FLAGS_P2P_PAUSED) &&
       (nfa_dm_cb.flags & NFA_DM_FLAGS_LISTEN_DISABLED)) {
-    NFA_TRACE_DEBUG0(
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "returning from nfa_dm_p2p_prio_logic  Disable p2p_prio_logic");
     return true;
   }
 #if (NXP_EXTNS == TRUE)
   if ((true == reconnect_in_progress) || (true == is_emvco_active)) {
-    NFA_TRACE_DEBUG0(
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "returning from nfa_dm_p2p_prio_logic  reconnect_in_progress");
     return true;
   }
+#endif
   if (0x01 == appl_dta_mode_flag) {
     /*Disable the P2P Prio Logic when DTA is running*/
-    return true;
+    return TRUE;
   }
-#endif
   if (event == NCI_MSG_RF_DISCOVER &&
       p2p_prio_logic_data.timer_expired == true &&
       event_type == NFA_DM_P2P_PRIO_RSP) {
-    NFA_TRACE_DEBUG0(
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "nfa_dm_p2p_prio_logic starting a timer for next rf intf activated "
         "ntf");
     nfc_start_quick_timer(&p2p_prio_logic_data.timer_list,
@@ -3334,7 +3402,7 @@ bool nfa_dm_p2p_prio_logic(uint8_t event, uint8_t* p, uint8_t event_type) {
 
   if (event == NCI_MSG_RF_INTF_ACTIVATED &&
       p2p_prio_logic_data.timer_expired == true) {
-    NFA_TRACE_DEBUG0(
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "nfa_dm_p2p_prio_logic stopping a timer for next rf intf activated "
         "ntf");
     nfc_stop_quick_timer(&p2p_prio_logic_data.timer_list);
@@ -3346,7 +3414,7 @@ bool nfa_dm_p2p_prio_logic(uint8_t event, uint8_t* p, uint8_t event_type) {
     uint8_t protocol = 0xFF;
     uint8_t tech_mode = 0xFF;
 
-    NFA_TRACE_DEBUG0("P2P_Prio_Logic");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("P2P_Prio_Logic");
 
     if (event == NCI_MSG_RF_INTF_ACTIVATED) {
       rf_disc_id = *p++;
@@ -3354,19 +3422,23 @@ bool nfa_dm_p2p_prio_logic(uint8_t event, uint8_t* p, uint8_t event_type) {
       protocol = *p++;
       tech_mode = *p++;
     }
-    NFA_TRACE_DEBUG1("nfa_dm_p2p_prio_logic event_type = 0x%x", event_type);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_p2p_prio_logic event_type = 0x%x", event_type);
 
 #if (NXP_EXTNS == TRUE)
     if (type == nfcFL.nfcMwFL._NCI_INTERFACE_UICC_DIRECT || type == nfcFL.nfcMwFL._NCI_INTERFACE_ESE_DIRECT) {
-      NFA_TRACE_DEBUG0("Disable the p2p prio logic RDR_SWP");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Disable the p2p prio logic RDR_SWP");
       return true;
     }
 #endif
     if (event == NCI_MSG_RF_INTF_ACTIVATED && tech_mode >= 0x80) {
-      NFA_TRACE_DEBUG0(
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "nfa_dm_p2p_prio_logic listen mode activated reset all the "
           "nfa_dm_p2p_prio_logic variables ");
-      nfa_dm_p2p_prio_logic_cleanup();
+       if (p2p_prio_logic_data.timer_list.in_use){
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Stop quick timer");
+         nfc_stop_quick_timer(&p2p_prio_logic_data.timer_list);
+       }
+       nfa_dm_p2p_prio_logic_cleanup();
     }
 
     if ((tech_mode < 0x80) && event == NCI_MSG_RF_INTF_ACTIVATED &&
@@ -3375,7 +3447,7 @@ bool nfa_dm_p2p_prio_logic(uint8_t event, uint8_t* p, uint8_t event_type) {
       nfa_dm_p2p_prio_logic_cleanup();
       p2p_prio_logic_data.isodep_detected = true;
       p2p_prio_logic_data.first_tech_mode = tech_mode;
-      NFA_TRACE_DEBUG0("ISO-DEP Detected First Time  Resume the Polling Loop");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("ISO-DEP Detected First Time  Resume the Polling Loop");
       nci_snd_deactivate_cmd(NFA_DEACTIVATE_TYPE_DISCOVERY);
       nfc_start_quick_timer(&p2p_prio_logic_data.timer_list,
                             NFC_TTYPE_P2P_PRIO_LOGIC_DEACT_NTF_TIMEOUT,
@@ -3389,7 +3461,7 @@ bool nfa_dm_p2p_prio_logic(uint8_t event, uint8_t* p, uint8_t event_type) {
              p2p_prio_logic_data.first_tech_mode != tech_mode) {
       p2p_prio_logic_data.isodep_detected = true;
       p2p_prio_logic_data.timer_expired = false;
-      NFA_TRACE_DEBUG0(
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "ISO-DEP Detected Second Time Other Techmode  Resume the Polling "
           "Loop");
       nfc_stop_quick_timer(&p2p_prio_logic_data.timer_list);
@@ -3404,7 +3476,7 @@ bool nfa_dm_p2p_prio_logic(uint8_t event, uint8_t* p, uint8_t event_type) {
              protocol == NCI_PROTOCOL_ISO_DEP &&
              p2p_prio_logic_data.isodep_detected == true &&
              p2p_prio_logic_data.timer_expired == true) {
-      NFA_TRACE_DEBUG0(
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "ISO-DEP Detected TimerExpired, Final Notifying the Event");
       nfc_stop_quick_timer(&p2p_prio_logic_data.timer_list);
       nfa_dm_p2p_prio_logic_cleanup();
@@ -3414,20 +3486,20 @@ bool nfa_dm_p2p_prio_logic(uint8_t event, uint8_t* p, uint8_t event_type) {
              protocol == NCI_PROTOCOL_ISO_DEP &&
              p2p_prio_logic_data.isodep_detected == true &&
              p2p_prio_logic_data.first_tech_mode == tech_mode) {
-      NFA_TRACE_DEBUG0(
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "ISO-DEP Detected Same Techmode, Final Notifying the Event");
       nfc_stop_quick_timer(&p2p_prio_logic_data.timer_list);
-      NFA_TRACE_DEBUG0("P2P_Stop_Timer");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("P2P_Stop_Timer");
       nfa_dm_p2p_prio_logic_cleanup();
     }
 
     else if (event == NCI_MSG_RF_INTF_ACTIVATED &&
              protocol != NCI_PROTOCOL_ISO_DEP &&
              p2p_prio_logic_data.isodep_detected == true) {
-      NFA_TRACE_DEBUG0(
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "ISO-DEP Not Detected  Giving Priority for other Technology");
       nfc_stop_quick_timer(&p2p_prio_logic_data.timer_list);
-      NFA_TRACE_DEBUG0("P2P_Stop_Timer");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("P2P_Stop_Timer");
       nfa_dm_p2p_prio_logic_cleanup();
     }
 
@@ -3435,7 +3507,7 @@ bool nfa_dm_p2p_prio_logic(uint8_t event, uint8_t* p, uint8_t event_type) {
              p2p_prio_logic_data.isodep_detected == true &&
              p2p_prio_logic_data.timer_expired == false &&
              event_type == NFA_DM_P2P_PRIO_RSP) {
-      NFA_TRACE_DEBUG0("NFA_DM_RF_DEACTIVATE_RSP");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_DM_RF_DEACTIVATE_RSP");
       return false;
     }
 
@@ -3443,7 +3515,7 @@ bool nfa_dm_p2p_prio_logic(uint8_t event, uint8_t* p, uint8_t event_type) {
              p2p_prio_logic_data.isodep_detected == true &&
              p2p_prio_logic_data.timer_expired == false &&
              event_type == NFA_DM_P2P_PRIO_NTF) {
-      NFA_TRACE_DEBUG0("NFA_DM_RF_DEACTIVATE_NTF");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_DM_RF_DEACTIVATE_NTF");
       if (p2p_prio_logic_data.timer_list.in_use) {
         nfc_stop_quick_timer(&p2p_prio_logic_data.timer_list);
       }
@@ -3451,13 +3523,13 @@ bool nfa_dm_p2p_prio_logic(uint8_t event, uint8_t* p, uint8_t event_type) {
                             NFC_TTYPE_P2P_PRIO_RESPONSE,
                             ((uint32_t)160 * QUICK_TIMER_TICKS_PER_SEC) / 1000);
 
-      NFA_TRACE_DEBUG0("P2P_Start_Timer");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("P2P_Start_Timer");
 
       return false;
     }
   }
 
-  NFA_TRACE_DEBUG0("returning true");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("returning true");
   return true;
 }
 
@@ -3470,11 +3542,11 @@ void nfa_dm_p2p_prio_logic_disable() {
 
 void NFA_SetReconnectState(bool flag) {
   reconnect_in_progress = flag;
-  NFA_TRACE_DEBUG1("NFA_SetReconnectState = 0x%x", reconnect_in_progress);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_SetReconnectState = 0x%x", reconnect_in_progress);
 }
 void NFA_SetEmvCoState(bool flag) {
   is_emvco_active = flag;
-  NFA_TRACE_DEBUG1("NFA_SetEmvCoState = 0x%x", is_emvco_active);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_SetEmvCoState = 0x%x", is_emvco_active);
 }
 #endif
 /*******************************************************************************
@@ -3487,12 +3559,12 @@ void NFA_SetEmvCoState(bool flag) {
 **
 *******************************************************************************/
 void nfa_dm_p2p_timer_event() {
-  NFA_TRACE_DEBUG0("P2P_Timer_timeout NFC-DEP Not Discovered!!");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("P2P_Timer_timeout NFC-DEP Not Discovered!!");
 
   p2p_prio_logic_data.timer_expired = 1;
 
   if (p2p_prio_logic_data.isodep_detected == 1) {
-    NFA_TRACE_DEBUG0("Deactivate and Restart RF discovery");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Deactivate and Restart RF discovery");
     nci_snd_deactivate_cmd(NFC_DEACTIVATE_TYPE_IDLE);
   }
 }
@@ -3507,7 +3579,7 @@ void nfa_dm_p2p_timer_event() {
 **
 *******************************************************************************/
 void nfa_dm_p2p_prio_logic_cleanup() {
-  NFA_TRACE_DEBUG0(
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       " p2p_prio_logic_cleanup timeout no activated intf notification "
       "received ");
   memset(&p2p_prio_logic_data, 0x00, sizeof(nfa_dm_p2p_prio_logic_t));
@@ -3526,36 +3598,31 @@ void nfa_dm_deact_ntf_timeout() {
 **
 ** Returns          void
 **
-+*******************************************************************************/
+*******************************************************************************/
 static void nfa_dm_send_tag_deselect_cmd(tNFA_NFC_PROTOCOL protocol) {
   NFC_HDR* p_msg;
   uint8_t* p;
 
-  NFA_TRACE_DEBUG0("nfa_dm_send_tag_deselect_cmd!!");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_send_tag_deselect_cmd");
   p_msg = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (p_msg) {
-    if(protocol == NFC_PROTOCOL_ISO_DEP)
-    {
+    if (protocol == NFC_PROTOCOL_ISO_DEP) {
       /* send one byte of 0xc2 as as deselect command to Tag */
       p_msg->len = 1;
       p_msg->offset = NCI_MSG_OFFSET_SIZE + NCI_DATA_HDR_SIZE;
       p = (uint8_t*)(p_msg + 1) + p_msg->offset;
-      *p = TAG_DESELECT_CMD;
-    }
-    else if(protocol == NFC_PROTOCOL_T2T)
-    {
-      p_msg->len = sizeof(T2T_SLP_REQ);
+      *p = NFA_RW_TAG_DESELECT_CMD;
+    } else if (protocol == NFC_PROTOCOL_T2T) {
+      p_msg->len = NFA_RW_TAG_SLP_REQ_LEN;
       p_msg->offset = NCI_MSG_OFFSET_SIZE + NCI_DATA_HDR_SIZE;
       p = (uint8_t*)(p_msg + 1) + p_msg->offset;
-      memcpy((uint8_t*)(p_msg + 1) + p_msg->offset, T2T_SLP_REQ, p_msg->len);
-    }
-    else
-    {
+      memcpy((uint8_t*)(p_msg + 1) + p_msg->offset, NFA_RW_TAG_SLP_REQ,
+             p_msg->len);
+    } else {
       GKI_freebuf(p_msg);
       return;
     }
-
     NFC_SendData(NFC_RF_CONN_ID, p_msg);
   }
 }
diff --git a/src/nfa/dm/nfa_dm_main.c b/src/nfa/dm/nfa_dm_main.cc
old mode 100644
new mode 100755
similarity index 89%
rename from src/nfa/dm/nfa_dm_main.c
rename to src/nfa/dm/nfa_dm_main.cc
index 688de0e..eab0b9d
--- a/src/nfa/dm/nfa_dm_main.c
+++ b/src/nfa/dm/nfa_dm_main.cc
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -42,14 +42,20 @@
  ******************************************************************************/
 
 #include <string.h>
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfa_api.h"
-#include "nfa_sys.h"
 #include "nfa_dm_int.h"
-#include "nfa_sys_int.h"
 #if (NXP_EXTNS == TRUE)
 #include "nfc_int.h"
 #endif
 
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+
 /*****************************************************************************
 ** Constants and types
 *****************************************************************************/
@@ -60,9 +66,7 @@ static const tNFA_SYS_REG nfa_dm_sys_reg = {nfa_dm_sys_enable, nfa_dm_evt_hdlr,
 #if (NXP_EXTNS == TRUE)
 tNFA_DM_CB nfa_dm_cb;
 #else
-tNFA_DM_CB nfa_dm_cb = {
-    0,
-};
+tNFA_DM_CB nfa_dm_cb = {};
 #endif
 
 #define NFA_DM_NUM_ACTIONS (NFA_DM_MAX_EVT & 0x00ff)
@@ -85,7 +89,8 @@ const tNFA_DM_ACTION nfa_dm_action[] = {
     nfa_dm_act_disable_listening,    /* NFA_DM_API_DISABLE_LISTENING_EVT     */
 #if (NXP_EXTNS == TRUE)
     nfa_dm_act_disable_passive_listening, /* NFA_DM_API_DISABLE_PASSIVE_LISTENING_EVT
-                                             */
+                                           */
+    nfa_dm_set_transit_config, /* NFA_DM_SET_TRANSIT_CONFIG            */
 #endif
     nfa_dm_act_pause_p2p,            /* NFA_DM_API_PAUSE_P2P_EVT             */
     nfa_dm_act_resume_p2p,           /* NFA_DM_API_RESUME_P2P_EVT            */
@@ -102,20 +107,15 @@ const tNFA_DM_ACTION nfa_dm_action[] = {
     nfa_dm_ndef_dereg_hdlr,          /* NFA_DM_API_DEREG_NDEF_HDLR_EVT       */
     nfa_dm_act_reg_vsc,              /* NFA_DM_API_REG_VSC_EVT               */
     nfa_dm_act_send_vsc,             /* NFA_DM_API_SEND_VSC_EVT              */
-    nfa_dm_act_disable_timeout       /* NFA_DM_TIMEOUT_DISABLE_EVT           */
-#if (NXP_EXTNS == TRUE)
-    ,
-    nfa_dm_act_send_nxp /* NFA_DM_API_SEND_NXP_EVT              */
-#endif
-    ,nfa_dm_set_power_sub_state /* NFA_DM_API_SET_POWER_SUB_STATE_EVT  */
+    nfa_dm_act_disable_timeout,      /* NFA_DM_TIMEOUT_DISABLE_EVT           */
+    nfa_dm_set_power_sub_state,      /* NFA_DM_API_SET_POWER_SUB_STATE_EVT   */
+    nfa_dm_act_send_raw_vs           /* NFA_DM_API_SEND_RAW_VS_EVT           */
 };
 
 /*****************************************************************************
 ** Local function prototypes
 *****************************************************************************/
-#if (BT_TRACE_VERBOSE == true)
-static char* nfa_dm_evt_2_str(uint16_t event);
-#endif
+static std::string nfa_dm_evt_2_str(uint16_t event);
 #if (NXP_EXTNS == TRUE)
 void nfa_dm_init_cfgs(phNxpNci_getCfg_info_t* mGetCfg_info);
 #endif
@@ -129,7 +129,7 @@ void nfa_dm_init_cfgs(phNxpNci_getCfg_info_t* mGetCfg_info);
 **
 *******************************************************************************/
 void nfa_dm_init(void) {
-  NFA_TRACE_DEBUG0("nfa_dm_init ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_init ()");
   memset(&nfa_dm_cb, 0, sizeof(tNFA_DM_CB));
   nfa_dm_cb.poll_disc_handle = NFA_HANDLE_INVALID;
   nfa_dm_cb.disc_cb.disc_duration = NFA_DM_DISC_DURATION_POLL;
@@ -155,12 +155,9 @@ bool nfa_dm_evt_hdlr(NFC_HDR* p_msg) {
   bool freebuf = true;
   uint16_t event = p_msg->event & 0x00ff;
 
-#if (BT_TRACE_VERBOSE == true)
-  NFA_TRACE_EVENT2("nfa_dm_evt_hdlr event: %s (0x%02x)",
-                   nfa_dm_evt_2_str(event), event);
-#else
-  NFA_TRACE_EVENT1("nfa_dm_evt_hdlr event: 0x%x", event);
-#endif
+DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "event: %s (0x%02x)", nfa_dm_evt_2_str(event).c_str(), event);
+
 
   /* execute action functions */
   if (event < NFA_DM_NUM_ACTIONS) {
@@ -191,7 +188,7 @@ void nfa_dm_sys_disable(void) {
       nfa_dm_disable_complete();
     } else {
       /* probably waiting to be disabled */
-      NFA_TRACE_WARNING2("DM disc_state state = %d disc_flags:0x%x",
+      LOG(WARNING) << StringPrintf("DM disc_state state = %d disc_flags:0x%x",
                          nfa_dm_cb.disc_cb.disc_state,
                          nfa_dm_cb.disc_cb.disc_flags);
     }
@@ -216,7 +213,7 @@ bool nfa_dm_is_protocol_supported(tNFC_PROTOCOL protocol, uint8_t sel_res) {
            (sel_res == NFC_SEL_RES_NFC_FORUM_T2T)) ||
           (protocol == NFC_PROTOCOL_T3T) ||
           (protocol == NFC_PROTOCOL_ISO_DEP) ||
-          (protocol == NFC_PROTOCOL_NFC_DEP) || (protocol == NFC_PROTOCOL_15693)
+          (protocol == NFC_PROTOCOL_NFC_DEP) || (protocol == NFC_PROTOCOL_T5T)
 #if (NXP_EXTNS == TRUE)
           || (protocol == NFC_PROTOCOL_T3BT)
 #endif
@@ -234,7 +231,7 @@ bool nfa_dm_is_protocol_supported(tNFC_PROTOCOL protocol, uint8_t sel_res) {
 **
 *******************************************************************************/
 bool nfa_dm_is_active(void) {
-  NFA_TRACE_DEBUG1("nfa_dm_is_active () flags:0x%x", nfa_dm_cb.flags);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_is_active () flags:0x%x", nfa_dm_cb.flags);
   if ((nfa_dm_cb.flags & NFA_DM_FLAGS_DM_IS_ACTIVE) &&
       ((nfa_dm_cb.flags &
         (NFA_DM_FLAGS_ENABLE_EVT_PEND | NFA_DM_FLAGS_NFCC_IS_RESTORING |
@@ -265,11 +262,11 @@ tNFA_STATUS nfa_dm_check_set_config(uint8_t tlv_list_len, uint8_t* p_tlv_list,
   tNFC_STATUS nfc_status;
   uint32_t cur_bit;
 
-  NFA_TRACE_DEBUG1("nfa_dm_check_set_config () tlv_len=%d", tlv_list_len);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_check_set_config () tlv_len=%d", tlv_list_len);
 
   /* We only allow 32 pending SET_CONFIGs */
   if (nfa_dm_cb.setcfg_pending_num >= NFA_DM_SETCONFIG_PENDING_MAX) {
-    NFA_TRACE_ERROR0(
+    LOG(ERROR) << StringPrintf(
         "nfa_dm_check_set_config () error: pending number of SET_CONFIG "
         "exceeded");
     return NFA_STATUS_FAILED;
@@ -375,11 +372,11 @@ tNFA_STATUS nfa_dm_check_set_config(uint8_t tlv_list_len, uint8_t* p_tlv_list,
         max_len = NCI_PARAM_LEN_LF_T3T_FLAGS2;
         p_cur_len = &nfa_dm_cb.params.lf_t3t_flags2_len;
         break;
-#if (NXP_EXTNS != TRUE)
       case NFC_PMID_LF_T3T_PMM:
         p_stored = nfa_dm_cb.params.lf_t3t_pmm;
         max_len = NCI_PARAM_LEN_LF_T3T_PMM;
         break;
+
       /*
       **  ISO-DEP and NFC-DEP Configuration
       */
@@ -387,7 +384,6 @@ tNFA_STATUS nfa_dm_check_set_config(uint8_t tlv_list_len, uint8_t* p_tlv_list,
         p_stored = nfa_dm_cb.params.fwi;
         max_len = NCI_PARAM_LEN_FWI;
         break;
-#endif
       case NFC_PMID_WT:
         p_stored = nfa_dm_cb.params.wt;
         max_len = NCI_PARAM_LEN_WT;
@@ -425,30 +421,22 @@ tNFA_STATUS nfa_dm_check_set_config(uint8_t tlv_list_len, uint8_t* p_tlv_list,
           update = true;
         } else if (memcmp(p_value, p_stored, len)) {
           update = true;
-        }
-#if (NXP_EXTNS == TRUE)
-        else if (appl_dta_mode_flag &&
-                 app_init) { /*In DTA mode, config update is forced so that
-                              length of config params
-                              (i.e update_len) is updated accordingly even for
-                              setconfig have only one tlv*/
+        } else if (appl_dta_mode_flag && app_init) {
+          /* In DTA mode, config update is forced so that length of config
+           * params (i.e update_len) is updated accordingly even for setconfig
+           * have only one tlv */
           update = true;
         }
-#endif
       } else if (len == max_len) /* fixed length */
       {
         if (memcmp(p_value, p_stored, len)) {
           update = true;
-        }
-#if (NXP_EXTNS == TRUE)
-        else if (appl_dta_mode_flag &&
-                 app_init) { /*In DTA mode, config update is forced so that
-                              length of config params
-                              (i.e update_len) is updated accordingly even for
-                              setconfig have only one tlv*/
+        } else if (appl_dta_mode_flag && app_init) {
+          /* In DTA mode, config update is forced so that length of config
+           * params (i.e update_len) is updated accordingly even for setconfig
+           * have only one tlv */
           update = true;
         }
-#endif
       }
     }
 
@@ -470,28 +458,18 @@ tNFA_STATUS nfa_dm_check_set_config(uint8_t tlv_list_len, uint8_t* p_tlv_list,
 
   /* If any TVLs to update, or if the SetConfig was initiated by the
    * application, then send the SET_CONFIG command */
-  /*if (updated_len || app_init) app_init is true when setconfig is invoked from
-  application. For extra setconfigs from internal to
-  stack, updated_len will be true. To avoid extra setconfigs from stack which is
-  NOT required by DTA, condition is modified*/
-  if
+  if (((updated_len || app_init) &&
+       (appl_dta_mode_flag == 0x00 ||
+        (nfa_dm_cb.eDtaMode & 0x0F) == NFA_DTA_HCEF_MODE)) ||
+      (appl_dta_mode_flag && app_init)) {
 #if (NXP_EXTNS == TRUE)
-      ((
-#endif
-           (updated_len || app_init)
-#if (NXP_EXTNS == TRUE)
-           && (appl_dta_mode_flag == 0x00 ||
-               (nfa_dm_cb.eDtaMode & 0x0F) == NFA_DTA_HCEF_MODE)) ||
-       ((appl_dta_mode_flag) && (app_init)))
-#endif
-  {
-#if (NXP_EXTNS == TRUE)
-    NFA_TRACE_DEBUG1("nfa_dm_check_set_config () updated_len=%d", updated_len);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_check_set_config () updated_len=%d", updated_len);
     if (!updated_len) {
       return NFA_STATUS_OK;
     }
 #endif
     nfc_status = NFC_SetConfig(updated_len, p_tlv_list);
+
     if (nfc_status == NFC_STATUS_OK) {
       if ((nfa_dm_cb.eDtaMode & 0x0F) == NFA_DTA_HCEF_MODE) {
         nfa_dm_cb.eDtaMode &= ~NFA_DTA_HCEF_MODE;
@@ -536,7 +514,7 @@ tNFA_STATUS nfa_dm_check_set_config(uint8_t tlv_list_len, uint8_t* p_tlv_list,
 **
 *******************************************************************************/
 void nfa_dm_init_cfgs(phNxpNci_getCfg_info_t* mGetCfg_info) {
-  NFA_TRACE_DEBUG1("%s Enter", __func__);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s Enter", __func__);
 
   memcpy(&nfa_dm_cb.params.atr_req_gen_bytes, mGetCfg_info->atr_req_gen_bytes,
          mGetCfg_info->atr_req_gen_bytes_len);
@@ -552,7 +530,6 @@ void nfa_dm_init_cfgs(phNxpNci_getCfg_info_t* mGetCfg_info) {
          mGetCfg_info->pmid_wt_len);
 }
 #endif
-#if (BT_TRACE_VERBOSE == true)
 /*******************************************************************************
 **
 ** Function         nfa_dm_nfc_revt_2_str
@@ -560,7 +537,7 @@ void nfa_dm_init_cfgs(phNxpNci_getCfg_info_t* mGetCfg_info) {
 ** Description      convert nfc revt to string
 **
 *******************************************************************************/
-static char* nfa_dm_evt_2_str(uint16_t event) {
+static std::string nfa_dm_evt_2_str(uint16_t event) {
   switch (NFA_SYS_EVT_START(NFA_ID_DM) | event) {
     case NFA_DM_API_ENABLE_EVT:
       return "NFA_DM_API_ENABLE_EVT";
@@ -641,8 +618,10 @@ static char* nfa_dm_evt_2_str(uint16_t event) {
 
     case NFA_DM_API_SET_POWER_SUB_STATE_EVT:
       return "NFA_DM_API_SET_POWER_SUB_STATE_EVT";
+
+    case NFA_DM_SET_TRANSIT_CONFIG:
+      return "NFA_DM_SET_TRANSIT_CONFIG";
   }
 
   return "Unknown or Vendor Specific";
 }
-#endif /* BT_TRACE_VERBOSE */
diff --git a/src/nfa/dm/nfa_dm_ndef.c b/src/nfa/dm/nfa_dm_ndef.cc
similarity index 79%
rename from src/nfa/dm/nfa_dm_ndef.c
rename to src/nfa/dm/nfa_dm_ndef.cc
index eeba9e8..6fe6c4d 100644
--- a/src/nfa/dm/nfa_dm_ndef.c
+++ b/src/nfa/dm/nfa_dm_ndef.cc
@@ -1,4 +1,5 @@
 /******************************************************************************
+ *
  *  Copyright (c) 2016, The Linux Foundation. All rights reserved.
  *  Not a Contribution.
  *
@@ -24,13 +25,18 @@
  *
  ******************************************************************************/
 #include <string.h>
-#include "nfa_sys.h"
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfa_api.h"
 #include "nfa_dm_int.h"
-#include "nfa_sys_int.h"
-#include "nfc_api.h"
 #include "ndef_utils.h"
 
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+
 /*******************************************************************************
 * URI Well-known-type prefixes
 *******************************************************************************/
@@ -124,7 +130,7 @@ void nfa_dm_ndef_dereg_all(void) {
 **
 ** Description      Register NDEF record type handler
 **
-** Returns          true if message buffer is to be freed by caller
+** Returns          TRUE if message buffer is to be freed by caller
 **
 *******************************************************************************/
 bool nfa_dm_ndef_reg_hdlr(tNFA_DM_MSG* p_data) {
@@ -138,13 +144,13 @@ bool nfa_dm_ndef_reg_hdlr(tNFA_DM_MSG* p_data) {
   if (p_reg_info->tnf == NFA_TNF_DEFAULT) {
     /* check if default handler is already registered */
     if (p_cb->p_ndef_handler[NFA_NDEF_DEFAULT_HANDLER_IDX]) {
-      NFA_TRACE_WARNING0("Default NDEF handler being changed.");
+      LOG(WARNING) << StringPrintf("Default NDEF handler being changed.");
 
       /* Free old registration info */
       nfa_dm_ndef_dereg_hdlr_by_handle(
           (tNFA_HANDLE)NFA_NDEF_DEFAULT_HANDLER_IDX);
     }
-    NFA_TRACE_DEBUG0("Default NDEF handler successfully registered.");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Default NDEF handler successfully registered.");
     hdlr_idx = NFA_NDEF_DEFAULT_HANDLER_IDX;
   }
   /* Get available entry in ndef_handler table, and check if requested type is
@@ -173,24 +179,109 @@ bool nfa_dm_ndef_reg_hdlr(tNFA_DM_MSG* p_data) {
     ndef_register.ndef_type_handle = p_reg_info->ndef_type_handle;
     ndef_register.status = NFA_STATUS_OK;
 
-    NFA_TRACE_DEBUG1("NDEF handler successfully registered. Handle=0x%08x",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NDEF handler successfully registered. Handle=0x%08x",
                      p_reg_info->ndef_type_handle);
-    (*(p_reg_info->p_ndef_cback))(NFA_NDEF_REGISTER_EVT, (void*)&ndef_register);
+    tNFA_NDEF_EVT_DATA nfa_ndef_evt_data;
+    nfa_ndef_evt_data.ndef_reg = ndef_register;
+    (*(p_reg_info->p_ndef_cback))(NFA_NDEF_REGISTER_EVT, &nfa_ndef_evt_data);
 
     /* indicate that we will free message buffer when type_handler is
      * deregistered */
     return false;
   } else {
     /* Error */
-    NFA_TRACE_ERROR0("NDEF handler failed to register.");
+   LOG(ERROR) << StringPrintf("NDEF handler failed to register.");
     ndef_register.ndef_type_handle = NFA_HANDLE_INVALID;
     ndef_register.status = NFA_STATUS_FAILED;
-    (*(p_reg_info->p_ndef_cback))(NFA_NDEF_REGISTER_EVT, (void*)&ndef_register);
+    tNFA_NDEF_EVT_DATA nfa_ndef_evt_data;
+    nfa_ndef_evt_data.ndef_reg = ndef_register;
+    (*(p_reg_info->p_ndef_cback))(NFA_NDEF_REGISTER_EVT, &nfa_ndef_evt_data);
 
     return true;
   }
 }
 
+
+/*******************************************************************************
+**
+** Function         nfa_dm_ndef_handle_message
+**
+** Description      Register NDEF record type handler
+**
+** Returns          true if message buffer is to be freed by caller
+**
+*******************************************************************************/
+bool nfa_dm_ndef_handle_message(tNFA_DM_MSG* p_data) {
+  tNFA_DM_CB* p_cb = &nfa_dm_cb;
+  uint32_t hdlr_idx, i;
+  tNFA_DM_API_REG_NDEF_HDLR* p_reg_info = (tNFA_DM_API_REG_NDEF_HDLR*)p_data;
+  tNFA_NDEF_REGISTER ndef_register;
+
+  /* If registering default handler, check to see if one is already registered
+   */
+  if (p_reg_info->tnf == NFA_TNF_DEFAULT) {
+    /* check if default handler is already registered */
+    if (p_cb->p_ndef_handler[NFA_NDEF_DEFAULT_HANDLER_IDX]) {
+      LOG(WARNING) << StringPrintf("Default NDEF handler being changed.");
+
+      /* Free old registration info */
+      nfa_dm_ndef_dereg_hdlr_by_handle(
+          (tNFA_HANDLE)NFA_NDEF_DEFAULT_HANDLER_IDX);
+    }
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("Default NDEF handler successfully registered.");
+    hdlr_idx = NFA_NDEF_DEFAULT_HANDLER_IDX;
+  }
+  /* Get available entry in ndef_handler table, and check if requested type is
+     already registered */
+  else {
+    hdlr_idx = NFA_HANDLE_INVALID;
+
+    /* Check if this type is already registered */
+    for (i = (NFA_NDEF_DEFAULT_HANDLER_IDX + 1); i < NFA_NDEF_MAX_HANDLERS;
+         i++) {
+      /* If this is a free slot, then remember it */
+      if (p_cb->p_ndef_handler[i] == NULL) {
+        hdlr_idx = i;
+        break;
+      }
+    }
+  }
+
+
+  if (hdlr_idx != NFA_HANDLE_INVALID) {
+    /* Update the table */
+    p_cb->p_ndef_handler[hdlr_idx] = p_reg_info;
+
+    p_reg_info->ndef_type_handle =
+        (tNFA_HANDLE)(NFA_HANDLE_GROUP_NDEF_HANDLER | hdlr_idx);
+
+    ndef_register.ndef_type_handle = p_reg_info->ndef_type_handle;
+    ndef_register.status = NFA_STATUS_OK;
+
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NDEF handler successfully registered. Handle=0x%08x",
+                     p_reg_info->ndef_type_handle);
+    tNFA_NDEF_EVT_DATA nfa_ndef_evt_data;
+    nfa_ndef_evt_data.ndef_reg = ndef_register;
+    (*(p_reg_info->p_ndef_cback))(NFA_NDEF_REGISTER_EVT, &nfa_ndef_evt_data);
+
+    /* indicate that we will free message buffer when type_handler is
+     * deregistered */
+    return false;
+  } else {
+    /* Error */
+    LOG(ERROR) << StringPrintf("NDEF handler failed to register.");
+    ndef_register.ndef_type_handle = NFA_HANDLE_INVALID;
+    ndef_register.status = NFA_STATUS_FAILED;
+    tNFA_NDEF_EVT_DATA nfa_ndef_evt_data;
+    nfa_ndef_evt_data.ndef_reg = ndef_register;
+    (*(p_reg_info->p_ndef_cback))(NFA_NDEF_REGISTER_EVT, &nfa_ndef_evt_data);
+
+    return true;
+  }
+}
+
+
 /*******************************************************************************
 **
 ** Function         nfa_dm_ndef_dereg_hdlr
@@ -209,7 +300,7 @@ bool nfa_dm_ndef_dereg_hdlr(tNFA_DM_MSG* p_data) {
        NFA_HANDLE_GROUP_NDEF_HANDLER) ||
       ((p_dereginfo->ndef_type_handle & NFA_HANDLE_MASK) >=
        NFA_NDEF_MAX_HANDLERS)) {
-    NFA_TRACE_ERROR1("Invalid handle for NDEF type handler: 0x%08x",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Invalid handle for NDEF type handler: 0x%08x",
                      p_dereginfo->ndef_type_handle);
   } else {
     nfa_dm_ndef_dereg_hdlr_by_handle(p_dereginfo->ndef_type_handle);
@@ -364,7 +455,7 @@ void nfa_dm_ndef_handle_message(tNFA_STATUS status, uint8_t* p_msg_buf,
   uint8_t rec_count = 0;
   bool record_handled, entire_message_handled;
 
-  NFA_TRACE_DEBUG3("nfa_dm_ndef_handle_message status=%i, msgbuf=%08x, len=%i",
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_dm_ndef_handle_message status=%i, msgbuf=%p, len=%i",
                    status, p_msg_buf, len);
 
   if (status != NFA_STATUS_OK) {
@@ -381,7 +472,9 @@ void nfa_dm_ndef_handle_message(tNFA_STATUS status, uint8_t* p_msg_buf,
     ndef_data.ndef_type_handle = 0;
     ndef_data.p_data = p_msg_buf;
     ndef_data.len = len;
-    (*p_cb->p_excl_ndef_cback)(NFA_NDEF_DATA_EVT, (void*)&ndef_data);
+    tNFA_NDEF_EVT_DATA nfa_ndef_evt_data;
+    nfa_ndef_evt_data.ndef_data = ndef_data;
+    (*p_cb->p_excl_ndef_cback)(NFA_NDEF_DATA_EVT, &nfa_ndef_evt_data);
     return;
   }
 
@@ -389,12 +482,14 @@ void nfa_dm_ndef_handle_message(tNFA_STATUS status, uint8_t* p_msg_buf,
   if (len == 0) {
     p_handler = p_cb->p_ndef_handler[NFA_NDEF_DEFAULT_HANDLER_IDX];
     if (p_handler != NULL) {
-      NFA_TRACE_DEBUG0(
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "Notifying default handler of zero-length NDEF message...");
       ndef_data.ndef_type_handle = p_handler->ndef_type_handle;
       ndef_data.p_data = NULL; /* Start of record */
       ndef_data.len = 0;
-      (*p_handler->p_ndef_cback)(NFA_NDEF_DATA_EVT, (void*)&ndef_data);
+      tNFA_NDEF_EVT_DATA nfa_ndef_evt_data;
+      nfa_ndef_evt_data.ndef_data = ndef_data;
+      (*p_handler->p_ndef_cback)(NFA_NDEF_DATA_EVT, &nfa_ndef_evt_data);
     }
     return;
   }
@@ -402,7 +497,7 @@ void nfa_dm_ndef_handle_message(tNFA_STATUS status, uint8_t* p_msg_buf,
   /* Validate the NDEF message */
   ndef_status = NDEF_MsgValidate(p_msg_buf, len, true);
   if (ndef_status != NDEF_OK) {
-    NFA_TRACE_ERROR1("Received invalid NDEF message. NDEF status=0x%x",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Received invalid NDEF message. NDEF status=0x%x",
                      ndef_status);
     return;
   }
@@ -438,7 +533,7 @@ void nfa_dm_ndef_handle_message(tNFA_STATUS status, uint8_t* p_msg_buf,
       /* Not a registered NDEF type. Use default handler */
       p_handler = p_cb->p_ndef_handler[NFA_NDEF_DEFAULT_HANDLER_IDX];
       if (p_handler != NULL) {
-        NFA_TRACE_DEBUG0("No handler found. Using default handler...");
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("No handler found. Using default handler...");
       }
     }
 
@@ -453,7 +548,7 @@ void nfa_dm_ndef_handle_message(tNFA_STATUS status, uint8_t* p_msg_buf,
       }
 
       /* Get pointer to record payload */
-      NFA_TRACE_DEBUG1("Calling ndef type handler (%x)",
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Calling ndef type handler (%x)",
                        p_handler->ndef_type_handle);
 
       ndef_data.ndef_type_handle = p_handler->ndef_type_handle;
@@ -505,7 +600,9 @@ void nfa_dm_ndef_handle_message(tNFA_STATUS status, uint8_t* p_msg_buf,
       }
 
       /* Notify NDEF type handler */
-      (*p_handler->p_ndef_cback)(NFA_NDEF_DATA_EVT, (void*)&ndef_data);
+      tNFA_NDEF_EVT_DATA nfa_ndef_evt_data;
+      nfa_ndef_evt_data.ndef_data = ndef_data;
+      (*p_handler->p_ndef_cback)(NFA_NDEF_DATA_EVT, &nfa_ndef_evt_data);
 
       /* Indicate that at lease one handler has received this record */
       record_handled = true;
@@ -519,7 +616,7 @@ void nfa_dm_ndef_handle_message(tNFA_STATUS status, uint8_t* p_msg_buf,
      * if no default handler was register) */
     if ((!record_handled) && (!entire_message_handled)) {
       /* Unregistered NDEF record type; no default handler */
-      NFA_TRACE_WARNING1("Unhandled NDEF record (#%i)", rec_count);
+      LOG(WARNING) << StringPrintf("Unhandled NDEF record (#%i)", rec_count);
     }
 
     rec_count++;
diff --git a/src/nfa/ee/nfa_ee_act.c b/src/nfa/ee/nfa_ee_act.cc
similarity index 80%
rename from src/nfa/ee/nfa_ee_act.c
rename to src/nfa/ee/nfa_ee_act.cc
index 6ebe4f6..d015bf4 100644
--- a/src/nfa/ee/nfa_ee_act.c
+++ b/src/nfa/ee/nfa_ee_act.cc
@@ -1,8 +1,9 @@
 /******************************************************************************
+ *
  *  Copyright (c) 2016, The Linux Foundation. All rights reserved.
  *  Not a Contribution.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *  The original Work has been changed by NXP Semiconductors.
  *
  *  Copyright (C) 2010-2014 Broadcom Corporation
@@ -27,17 +28,22 @@
  *
  ******************************************************************************/
 #include <string.h>
-#include "nfa_sys.h"
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfa_api.h"
 #include "nfa_dm_int.h"
-#include "nfa_sys_int.h"
-#include "nfc_api.h"
 #include "nfa_ee_int.h"
 #include "nci_hmsgs.h"
 #if (NXP_EXTNS == TRUE)
 #include "nfa_hci_int.h"
 #endif
-#include <config.h>
+#include <nfc_config.h>
+
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
 
 /* the de-bounce timer:
  * The NFA-EE API functions are called to set the routing and VS configuration.
@@ -67,18 +73,31 @@ static void add_route_tech_proto_tlv(uint8_t** pp, uint8_t tlv_type,
   *(*pp)++ = tech_proto;
 }
 
-static void add_route_aid_tlv(uint8_t** pp, uint8_t* pa, uint8_t aid_rt_loc,
+static void add_route_aid_tlv(uint8_t** pp, uint8_t* pa, uint8_t nfcee_id,
                               uint8_t pwr_cfg, uint8_t tag) {
   pa++;                /* EMV tag */
   uint8_t len = *pa++; /* aid_len */
   *(*pp)++ = tag;
   *(*pp)++ = len + 2;
-  *(*pp)++ = aid_rt_loc;
+  *(*pp)++ = nfcee_id;
   *(*pp)++ = pwr_cfg;
   /* copy the AID */
   memcpy(*pp, pa, len);
   *pp += len;
 }
+
+static void add_route_sys_code_tlv(uint8_t** p_buff, uint8_t* p_sys_code_cfg,
+                                   uint8_t sys_code_rt_loc,
+                                   uint8_t sys_code_pwr_cfg) {
+  *(*p_buff)++ = NFC_ROUTE_TAG_SYSCODE | nfa_ee_cb.route_block_control;
+  *(*p_buff)++ = NFA_EE_SYSTEM_CODE_LEN + 2;
+  *(*p_buff)++ = sys_code_rt_loc;
+  *(*p_buff)++ = sys_code_pwr_cfg;
+  /* copy the system code */
+  memcpy(*p_buff, p_sys_code_cfg, NFA_EE_SYSTEM_CODE_LEN);
+  *p_buff += NFA_EE_SYSTEM_CODE_LEN;
+}
+
 const uint8_t nfa_ee_proto_mask_list[NFA_EE_NUM_PROTO] = {
     NFA_PROTOCOL_MASK_T1T, NFA_PROTOCOL_MASK_T2T, NFA_PROTOCOL_MASK_T3T,
     NFA_PROTOCOL_MASK_ISO_DEP, NFA_PROTOCOL_MASK_NFC_DEP
@@ -137,7 +156,7 @@ void nfa_ee_check_set_routing(uint16_t new_size, int* p_max_len, uint8_t* p,
 ** Returns          void
 **
 *******************************************************************************/
-static void nfa_ee_trace_aid(char* p_str, uint8_t id, uint8_t aid_len,
+static void nfa_ee_trace_aid(std::string p_str, uint8_t id, uint8_t aid_len,
                              uint8_t* p) {
   int len = aid_len;
   int xx, yy = 0;
@@ -145,14 +164,14 @@ static void nfa_ee_trace_aid(char* p_str, uint8_t id, uint8_t aid_len,
 
   buff[0] = 0;
   if (aid_len > NFA_MAX_AID_LEN) {
-    NFA_TRACE_ERROR2("aid_len: %d exceeds max(%d)", aid_len, NFA_MAX_AID_LEN);
+    LOG(ERROR) << StringPrintf("aid_len: %d exceeds max(%d)", aid_len, NFA_MAX_AID_LEN);
     len = NFA_MAX_AID_LEN;
   }
   for (xx = 0; xx < len; xx++) {
     yy += snprintf(&buff[yy], 100, "%02x ", *p);
     p++;
   }
-  NFA_TRACE_DEBUG4("%s id:0x%x len=%d aid:%s", p_str, id, aid_len, buff);
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s id:0x%x len=%d aid:%s", p_str.c_str(), id, aid_len, buff);
 }
 
 /*******************************************************************************
@@ -164,7 +183,7 @@ static void nfa_ee_trace_aid(char* p_str, uint8_t id, uint8_t aid_len,
 ** Returns          void
 **
 *******************************************************************************/
-static void nfa_ee_trace_apdu(char* p_str, tNFA_EE_API_ADD_APDU* p_apdu) {
+static void nfa_ee_trace_apdu(std::string p_str, tNFA_EE_API_ADD_APDU* p_apdu) {
   int apdu_len = p_apdu->apdu_len;
   int mask_len = p_apdu->mask_len;
   int xx, yy = 0;
@@ -174,13 +193,13 @@ static void nfa_ee_trace_apdu(char* p_str, tNFA_EE_API_ADD_APDU* p_apdu) {
   mask[0] = 0;
   uint8_t* p;
   if (apdu_len > NFA_MAX_APDU_DATA_LEN) {
-    NFA_TRACE_ERROR2("apdu_len: %d exceeds max(%d)", apdu_len, NFA_MAX_APDU_DATA_LEN);
+    LOG(ERROR) << StringPrintf("apdu_len: %d exceeds max(%d)", apdu_len, NFA_MAX_APDU_DATA_LEN);
     apdu_len = NFA_MAX_APDU_DATA_LEN;
     p_apdu->apdu_len = apdu_len;
   }
 
   if (mask_len > NFA_MAX_APDU_MASK_LEN) {
-    NFA_TRACE_ERROR2("mask_len: %d exceeds max(%d)", mask_len, NFA_MAX_APDU_MASK_LEN);
+    LOG(ERROR) << StringPrintf("mask_len: %d exceeds max(%d)", mask_len, NFA_MAX_APDU_MASK_LEN);
     mask_len = NFA_MAX_APDU_MASK_LEN;
     p_apdu->mask_len = mask_len;
   }
@@ -197,7 +216,8 @@ static void nfa_ee_trace_apdu(char* p_str, tNFA_EE_API_ADD_APDU* p_apdu) {
     yy += snprintf(&mask[yy], 125, "%02x ", *p);
     p++;
   }
-  NFA_TRACE_DEBUG6("%s id:0x%x apdu_len=%d apdu:%s mask_len=%d mask:%s", p_str, p_apdu->nfcee_id, apdu_len, apdu,mask_len,mask);
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s id:0x%x apdu_len=%d apdu:%s mask_len=%d mask:%s",
+                                                p_str.c_str(), p_apdu->nfcee_id, apdu_len, apdu,mask_len,mask);
 }
 /*******************************************************************************
 **
@@ -223,6 +243,15 @@ static void nfa_ee_update_route_size(tNFA_EE_ECB* p_cb) {
       power_cfg |= NCI_ROUTE_PWR_STATE_SWITCH_OFF;
     if (p_cb->tech_battery_off & nfa_ee_tech_mask_list[xx])
       power_cfg |= NCI_ROUTE_PWR_STATE_BATT_OFF;
+    if ((power_cfg & NCI_ROUTE_PWR_STATE_ON) &&
+        (NFC_GetNCIVersion() == NCI_VERSION_2_0)) {
+      if (p_cb->tech_screen_lock & nfa_ee_tech_mask_list[xx])
+        power_cfg |= NCI_ROUTE_PWR_STATE_SCREEN_ON_LOCK();
+      if (p_cb->tech_screen_off & nfa_ee_tech_mask_list[xx])
+        power_cfg |= NCI_ROUTE_PWR_STATE_SCREEN_OFF_UNLOCK();
+      if (p_cb->tech_screen_off_lock & nfa_ee_tech_mask_list[xx])
+        power_cfg |= NCI_ROUTE_PWR_STATE_SCREEN_OFF_LOCK();
+    }
     if (power_cfg) {
       /* 5 = 1 (tag) + 1 (len) + 1(nfcee_id) + 1(power cfg) + 1 (techonogy) */
       p_cb->size_mask += 5;
@@ -238,12 +267,21 @@ static void nfa_ee_update_route_size(tNFA_EE_ECB* p_cb) {
       power_cfg |= NCI_ROUTE_PWR_STATE_SWITCH_OFF;
     if (p_cb->proto_battery_off & nfa_ee_proto_mask_list[xx])
       power_cfg |= NCI_ROUTE_PWR_STATE_BATT_OFF;
+    if ((power_cfg & NCI_ROUTE_PWR_STATE_ON) &&
+        (NFC_GetNCIVersion() == NCI_VERSION_2_0)) {
+      if (p_cb->proto_screen_lock & nfa_ee_proto_mask_list[xx])
+        power_cfg |= NCI_ROUTE_PWR_STATE_SCREEN_ON_LOCK();
+      if (p_cb->proto_screen_off & nfa_ee_proto_mask_list[xx])
+        power_cfg |= NCI_ROUTE_PWR_STATE_SCREEN_OFF_UNLOCK();
+      if (p_cb->proto_screen_off_lock & nfa_ee_proto_mask_list[xx])
+        power_cfg |= NCI_ROUTE_PWR_STATE_SCREEN_OFF_LOCK();
+    }
     if (power_cfg) {
       /* 5 = 1 (tag) + 1 (len) + 1(nfcee_id) + 1(power cfg) + 1 (protocol) */
       p_cb->size_mask += 5;
     }
   }
-  NFA_TRACE_DEBUG2("nfa_ee_update_route_size nfcee_id:0x%x size_mask:%d",
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_update_route_size nfcee_id:0x%x size_mask:%d",
                    p_cb->nfcee_id, p_cb->size_mask);
 }
 
@@ -278,7 +316,7 @@ static void nfa_ee_update_route_apdu_size(tNFA_EE_ECB* p_cb) {
       start_offset += p_cb->apdu_len[xx];
     }
   }
-  NFA_TRACE_DEBUG2("nfa_ee_update_route_apdu_size nfcee_id:0x%x size_apdu:%d",
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_update_route_apdu_size nfcee_id:0x%x size_apdu:%d",
                    p_cb->nfcee_id, p_cb->size_apdu);
 }
 
@@ -313,10 +351,36 @@ static void nfa_ee_update_route_aid_size(tNFA_EE_ECB* p_cb) {
       start_offset += p_cb->aid_len[xx];
     }
   }
-  NFA_TRACE_DEBUG2("nfa_ee_update_route_aid_size nfcee_id:0x%x size_aid:%d",
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_update_route_aid_size nfcee_id:0x%x size_aid:%d",
                    p_cb->nfcee_id, p_cb->size_aid);
 }
 
+/*******************************************************************************
+**
+** Function         nfa_ee_update_route_sys_code_size
+**
+** Description      Update the size required for system code routing
+**                  of the given NFCEE ID.
+**
+** Returns          void
+**
+*******************************************************************************/
+static void nfa_ee_update_route_sys_code_size(tNFA_EE_ECB* p_cb) {
+  p_cb->size_sys_code = 0;
+  if (p_cb->sys_code_cfg_entries) {
+    for (uint8_t xx = 0; xx < p_cb->sys_code_cfg_entries; xx++) {
+      if (p_cb->sys_code_rt_loc_vs_info[xx] & NFA_EE_AE_ROUTE) {
+        /* 4 = 1 (tag) + 1 (len) + 1(nfcee_id) + 1(power cfg) */
+        p_cb->size_sys_code += 4;
+        p_cb->size_sys_code += NFA_EE_SYSTEM_CODE_LEN;
+      }
+    }
+  }
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "nfa_ee_update_route_sys_code_size nfcee_id:0x%x size_sys_code:%d",
+      p_cb->nfcee_id, p_cb->size_sys_code);
+}
+
 /*******************************************************************************
 **
 ** Function         nfa_ee_total_lmrt_size
@@ -335,15 +399,17 @@ static uint16_t nfa_ee_total_lmrt_size(void) {
   lmrt_size += p_cb->size_mask;
   lmrt_size += p_cb->size_aid;
   lmrt_size += p_cb->size_apdu;
+  lmrt_size += p_cb->size_sys_code;
   p_cb = &nfa_ee_cb.ecb[nfa_ee_cb.cur_ee - 1];
   for (xx = 0; xx < nfa_ee_cb.cur_ee; xx++, p_cb--) {
     if (p_cb->ee_status == NFC_NFCEE_STATUS_ACTIVE) {
       lmrt_size += p_cb->size_mask;
       lmrt_size += p_cb->size_aid;
       lmrt_size += p_cb->size_apdu;
+      lmrt_size += p_cb->size_sys_code;
     }
   }
-  NFA_TRACE_DEBUG1("nfa_ee_total_lmrt_size size:%d", lmrt_size);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_total_lmrt_size size:%d", lmrt_size);
   return lmrt_size;
 }
 
@@ -401,11 +467,16 @@ static void nfa_ee_add_proto_route_to_ecb(tNFA_EE_ECB* p_cb, uint8_t* pp,
     if (power_cfg) {
       /* Applying Route Block for ISO DEP Protocol, so that AIDs
        * which are not in the routing table can also be blocked */
-      if (nfa_ee_proto_mask_list[xx] == NFA_PROTOCOL_MASK_ISO_DEP||nfa_ee_proto_mask_list[xx] == NFC_PROTOCOL_MASK_ISO7816) {
+      if (nfa_ee_proto_mask_list[xx] == NFA_PROTOCOL_MASK_ISO_DEP
+#if(NXP_EXTNS == TRUE)
+          ||nfa_ee_proto_mask_list[xx] == NFC_PROTOCOL_MASK_ISO7816
+#endif
+         ) {
         proto_tag = NFC_ROUTE_TAG_PROTO | nfa_ee_cb.route_block_control;
 
         /* Enable screen on lock power state for ISO-DEP protocol to
            enable HCE screen lock */
+#if(NXP_EXTNS == TRUE)
        if (p_cb->nfcee_id == NFC_DH_ID)
           power_cfg |= NCI_ROUTE_PWR_STATE_SCREEN_ON_LOCK();
       else
@@ -417,6 +488,17 @@ static void nfa_ee_add_proto_route_to_ecb(tNFA_EE_ECB* p_cb, uint8_t* pp,
         if (p_cb->proto_screen_off_lock & nfa_ee_proto_mask_list[xx])
            power_cfg |= NCI_ROUTE_PWR_STATE_SCREEN_OFF_LOCK();
        }
+#else
+        if ((power_cfg & NCI_ROUTE_PWR_STATE_ON) &&
+            (NFC_GetNCIVersion() == NCI_VERSION_2_0)) {
+          if (p_cb->proto_screen_lock & nfa_ee_proto_mask_list[xx])
+            power_cfg |= NCI_ROUTE_PWR_STATE_SCREEN_ON_LOCK();
+          if (p_cb->proto_screen_off & nfa_ee_proto_mask_list[xx])
+            power_cfg |= NCI_ROUTE_PWR_STATE_SCREEN_OFF_UNLOCK();
+          if (p_cb->proto_screen_off_lock & nfa_ee_proto_mask_list[xx])
+            power_cfg |= NCI_ROUTE_PWR_STATE_SCREEN_OFF_LOCK();
+        }
+#endif
       } else {
         proto_tag = NFC_ROUTE_TAG_PROTO;
       }
@@ -435,7 +517,7 @@ static void nfa_ee_add_proto_route_to_ecb(tNFA_EE_ECB* p_cb, uint8_t* pp,
                              NCI_ROUTE_PWR_STATE_ON, NFC_PROTOCOL_NFC_DEP);
 
     num_tlv++;
-    NFA_TRACE_DEBUG1("%s - NFC DEP added for DH!!!", __func__);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s - NFC DEP added for DH!!!", __func__);
   }
   /* update the num_tlv and current offset */
   uint8_t entry_size = (uint8_t)(pp - p);
@@ -460,32 +542,40 @@ static void nfa_ee_add_aid_route_to_ecb(tNFA_EE_ECB* p_cb, uint8_t* pp,
       if (p_cb->aid_rt_info[xx] & NFA_EE_AE_ROUTE) {
         uint8_t* pa = &p_cb->aid_cfg[start_offset];
 
-        NFA_TRACE_DEBUG2("%s -  p_cb->aid_info%x", __func__,
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s -  p_cb->aid_info%x", __func__,
                          p_cb->aid_info[xx]);
         if (p_cb->aid_info[xx] & NCI_ROUTE_QUAL_LONG_SELECT) {
-          NFA_TRACE_DEBUG2("%s - %x", __func__,
+           DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s - %x", __func__,
                            p_cb->aid_info[xx] & NCI_ROUTE_QUAL_LONG_SELECT);
           route_qual |= NCI_ROUTE_QUAL_LONG_SELECT;
         }
         if (p_cb->aid_info[xx] & NCI_ROUTE_QUAL_SHORT_SELECT) {
-          NFA_TRACE_DEBUG2("%s - %x", __func__,
+           DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s - %x", __func__,
                            p_cb->aid_info[xx] & NCI_ROUTE_QUAL_SHORT_SELECT);
           route_qual |= NCI_ROUTE_QUAL_SHORT_SELECT;
         }
 
         uint8_t tag =
             NFC_ROUTE_TAG_AID | nfa_ee_cb.route_block_control | route_qual;
+#if(NXP_EXTNS == TRUE)
             if(nfa_ee_is_active(p_cb->aid_rt_loc[xx]|NFA_HANDLE_GROUP_EE)) {
                 add_route_aid_tlv(&pp, pa, p_cb->aid_rt_loc[xx], p_cb->aid_pwr_cfg[xx], tag);
                 num_tlv++;
             } else {
-                NFA_TRACE_DEBUG2("%s -  ignoring route loc%x", __func__,p_cb->aid_rt_loc[xx]);
+                 DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s -  ignoring route loc%x", __func__,p_cb->aid_rt_loc[xx]);
             }
+#else
+        add_route_aid_tlv(&pp, pa, p_cb->nfcee_id, p_cb->aid_pwr_cfg[xx], tag);
+#endif
       }
       start_offset += p_cb->aid_len[xx];
       uint8_t new_size = (uint8_t)(pp - p_start);
       nfa_ee_check_set_routing(new_size, p_max_len, ps, p_cur_offset);
-      if (*ps == 0 && (num_tlv > 0x00)) {
+      if (*ps == 0
+#if(NXP_EXTNS == TRUE)
+          && (num_tlv > 0x00)
+#endif
+         ) {
         /* just sent routing command, update local */
         *ps = 1;
         num_tlv = *ps;
@@ -501,7 +591,7 @@ static void nfa_ee_add_aid_route_to_ecb(tNFA_EE_ECB* p_cb, uint8_t* pp,
       }
     }
   } else {
-    NFA_TRACE_DEBUG1("%s - No AID entries available", __func__);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s - No AID entries available", __func__);
   }
 }
 static void nfa_ee_add_apdu_route_to_ecb(tNFA_EE_ECB* p_cb, uint8_t* pp,
@@ -530,7 +620,7 @@ static void nfa_ee_add_apdu_route_to_ecb(tNFA_EE_ECB* p_cb, uint8_t* pp,
                     *pp++ = NFC_ROUTE_TAG_APDU;
                     *pp++ = len + 2;
                     *pp++ = (p_cb->apdu_rt_info[xx] >> NFA_EE_APDU_ROUTE_MASK);
-                    NFA_TRACE_DEBUG1("nfa_ee_route_add_one_ecb_by_route_order p_cb->apdu_rt_info[xx] %x", p_cb->apdu_rt_info[xx]);
+                    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_route_add_one_ecb_by_route_order p_cb->apdu_rt_info[xx] %x", p_cb->apdu_rt_info[xx]);
                     *pp++ = p_cb->apdu_pwr_cfg[xx];
                     /* copy the APDU */
                     memcpy(pp, pa, len);
@@ -538,8 +628,8 @@ static void nfa_ee_add_apdu_route_to_ecb(tNFA_EE_ECB* p_cb, uint8_t* pp,
                 }
                 start_offset += p_cb->apdu_len[xx];
                 new_size = (uint8_t)(pp - p_start);
-                NFA_TRACE_DEBUG1("nfa_ee_route_add_one_ecb_by_route_order --before num_tlv:- %d", num_tlv);
-                NFA_TRACE_DEBUG1("nfa_ee_route_add_one_ecb_by_route_order --before new_size:- %d",new_size);
+                DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_route_add_one_ecb_by_route_order --before num_tlv:- %d", num_tlv);
+                DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_route_add_one_ecb_by_route_order --before new_size:- %d",new_size);
                 nfa_ee_check_set_routing(new_size, p_max_len, ps, p_cur_offset);
                 if (*ps == 0) {
                   /* just sent routing command, update local */
@@ -560,8 +650,8 @@ static void nfa_ee_add_apdu_route_to_ecb(tNFA_EE_ECB* p_cb, uint8_t* pp,
                      *p_cur_offset += new_size;
                 }
             }
-            NFA_TRACE_DEBUG1("nfa_ee_route_add_one_ecb_by_route_order --num_tlv:- %d", num_tlv);
-            NFA_TRACE_DEBUG1("nfa_ee_route_add_one_ecb_by_route_order --new_size:- %d",new_size);
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_route_add_one_ecb_by_route_order --num_tlv:- %d", num_tlv);
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_route_add_one_ecb_by_route_order --new_size:- %d",new_size);
           }
 }
 /*******************************************************************************
@@ -574,10 +664,10 @@ static void nfa_ee_add_apdu_route_to_ecb(tNFA_EE_ECB* p_cb, uint8_t* pp,
 **
 *******************************************************************************/
 static void nfa_ee_conn_cback(uint8_t conn_id, tNFC_CONN_EVT event,
-                              tNFC_CONN* p_data) {
+                              __attribute__((unused)) tNFC_CONN* p_data) {
   tNFA_EE_NCI_CONN cbk;
 
-  NFA_TRACE_DEBUG2("nfa_ee_conn_cback: conn_id: %d, event=0x%02x", conn_id,
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_conn_cback: conn_id: %d, event=0x%02x", conn_id,
                    event);
 
   cbk.hdr.event = NFA_EE_NCI_CONN_EVT;
@@ -585,11 +675,66 @@ static void nfa_ee_conn_cback(uint8_t conn_id, tNFC_CONN_EVT event,
     /* Treat data event specially to avoid potential memory leak */
     cbk.hdr.event = NFA_EE_NCI_DATA_EVT;
   }
-  cbk.conn_id = conn_id;
+  /*cbk.conn_id = conn_id;
   cbk.event = event;
-  cbk.p_data = p_data;
+  cbk.p_data = p_data;*/
+  tNFA_EE_MSG nfa_ee_msg;
+  nfa_ee_msg.conn = cbk;
 
-  nfa_ee_evt_hdlr((void*)&cbk);
+  nfa_ee_evt_hdlr(&nfa_ee_msg.conn.hdr);
+}
+
+__attribute__((unused)) static void nfa_ee_add_sys_code_route_to_ecb(tNFA_EE_ECB* p_cb, uint8_t* pp,
+                                             uint8_t* p, uint8_t* p_buff,
+                                             int* p_cur_offset,
+                                             int* p_max_len) {
+  uint8_t num_tlv = *p_buff;
+
+  /* add the SC routing */
+  if (p_cb->sys_code_cfg_entries) {
+    int start_offset = 0;
+    for (int xx = 0; xx < p_cb->sys_code_cfg_entries; xx++) {
+      /* remember the beginning of this SC routing entry, just in case we
+       * need to put it in next command */
+      uint8_t* p_start = pp;
+      /* add one SC entry */
+      if (p_cb->sys_code_rt_loc_vs_info[xx] & NFA_EE_AE_ROUTE) {
+        uint8_t* p_sys_code_cfg = &p_cb->sys_code_cfg[start_offset];
+        if (nfa_ee_is_active(p_cb->sys_code_rt_loc[xx] | NFA_HANDLE_GROUP_EE)) {
+          add_route_sys_code_tlv(&pp, p_sys_code_cfg, p_cb->sys_code_rt_loc[xx],
+                                 p_cb->sys_code_pwr_cfg[xx]);
+          p_cb->ecb_flags |= NFA_EE_ECB_FLAGS_ROUTING;
+          num_tlv++;
+        } else {
+          DLOG_IF(INFO, nfc_debug_enabled)
+              << StringPrintf("%s -  ignoring route loc%x", __func__,
+                              p_cb->sys_code_rt_loc[xx]);
+        }
+      }
+      start_offset += NFA_EE_SYSTEM_CODE_LEN;
+      uint8_t new_size = (uint8_t)(pp - p_start);
+      nfa_ee_check_set_routing(new_size, p_max_len, p_buff, p_cur_offset);
+      if (*p_buff == 0 && (num_tlv > 0x00)) {
+        /* just sent routing command, update local */
+        *p_buff = 1;
+        num_tlv = *p_buff;
+        *p_cur_offset = new_size;
+        pp = p_buff + 1;
+        p = pp;
+        memcpy(p, p_start, new_size);
+        pp += new_size;
+      } else {
+        /* add the new entry */
+        *p_buff = num_tlv;
+        *p_cur_offset += new_size;
+      }
+    }
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "nfa_ee_route_add_one_ecb_by_route_order --num_tlv:- %d", num_tlv);
+  } else {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("%s - No SC entries available", __func__);
+  }
 }
 
 /*******************************************************************************
@@ -679,6 +824,45 @@ int nfa_all_ee_find_total_apdu_pattern_len() {
 }
 #endif
 
+/*******************************************************************************
+**
+** Function         nfa_ee_find_total_sys_code_len
+**
+** Description      Find the total len in sys_code_cfg from start_entry to the
+**                  last in the given ecb.
+**
+** Returns          void
+**
+*******************************************************************************/
+int nfa_ee_find_total_sys_code_len(tNFA_EE_ECB* p_cb, int start_entry) {
+  int len = 0;
+  if (p_cb->sys_code_cfg_entries > start_entry) {
+    for (int xx = start_entry; xx < p_cb->sys_code_cfg_entries; xx++) {
+      len += NFA_EE_SYSTEM_CODE_LEN;
+    }
+  }
+  return len;
+}
+
+/*******************************************************************************
+**
+** Function         nfa_all_ee_find_total_sys_code_len
+**
+** Description      Find the total len in sys_code_cfg from start_entry to the
+**                  last for all EE and DH.
+**
+** Returns          total length
+**
+*******************************************************************************/
+int nfa_all_ee_find_total_sys_code_len() {
+  int total_len = 0;
+  for (int32_t xx = 0; xx < NFA_EE_NUM_ECBS; xx++) {
+    tNFA_EE_ECB* p_cb = &nfa_ee_cb.ecb[xx];
+    total_len += nfa_ee_find_total_sys_code_len(p_cb, 0);
+  }
+  return total_len;
+}
+
 /*******************************************************************************
 **
 ** Function         nfa_ee_find_aid_offset
@@ -696,7 +880,7 @@ tNFA_EE_ECB* nfa_ee_find_aid_offset(uint8_t aid_len, uint8_t* p_aid,
 
   p_ecb = &nfa_ee_cb.ecb[NFA_EE_CB_4_DH];
   aid_len_offset = 1; /* skip the tag */
-  for (yy = 0; yy < nfa_ee_cb.cur_ee; yy++, p_ecb++) {
+  for (yy = 0; yy <= nfa_ee_cb.cur_ee; yy++) {
     if (p_ecb->aid_entries) {
       offset = 0;
       for (xx = 0; xx < p_ecb->aid_entries; xx++) {
@@ -762,6 +946,49 @@ tNFA_EE_ECB* nfa_ee_find_apdu_offset(uint8_t apdu_len, uint8_t* p_apdu,
   return p_ret;
 }
 
+/*******************************************************************************
+ **
+ ** Function         nfa_ee_find_sys_code_offset
+ **
+ ** Description      Given the System Code, find the associated tNFA_EE_ECB and
+ *the
+ **                  offset in sys_code_cfg[]. *p_entry is the index.
+ **
+ ** Returns          void
+ **
+ *******************************************************************************/
+tNFA_EE_ECB* nfa_ee_find_sys_code_offset(uint16_t sys_code, int* p_offset,
+                                         int* p_entry) {
+  tNFA_EE_ECB* p_ret = NULL;
+
+  for (uint8_t xx = 0; xx < NFA_EE_NUM_ECBS; xx++) {
+    tNFA_EE_ECB* p_ecb = &nfa_ee_cb.ecb[xx];
+    uint8_t mask = nfa_ee_ecb_to_mask(p_ecb);
+    if ((nfa_ee_cb.ee_cfged & mask) == 0 || p_ecb->sys_code_cfg_entries == 0) {
+      continue; /*try next ecb*/
+    }
+    if (p_ecb->sys_code_cfg_entries) {
+      uint8_t offset = 0;
+      for (uint8_t yy = 0; yy < p_ecb->sys_code_cfg_entries; yy++) {
+        if ((memcmp(&p_ecb->sys_code_cfg[offset], &sys_code,
+                    NFA_EE_SYSTEM_CODE_LEN) == 0)) {
+          p_ret = p_ecb;
+          if (p_offset) *p_offset = offset;
+          if (p_entry) *p_entry = yy;
+          break;
+        }
+        offset += NFA_EE_SYSTEM_CODE_LEN;
+      }
+
+      if (p_ret) {
+        /* found the entry already */
+        return p_ret;
+      }
+    }
+  }
+  return p_ret;
+}
+
 /*******************************************************************************
 **
 ** Function         nfa_ee_report_event
@@ -836,11 +1063,11 @@ tNFA_STATUS nfa_ee_get_num_nfcee_configured(tNFA_VSC_CBACK* p_cback)
 
   *parm_len = (p - num_param);
   if (*num_param != 0x00) {
-    status = NFA_SendNxpNciCommand(p - p_data, p_data, p_cback);
+    status = NFA_SendRawVsCommand(p - p_data, p_data, p_cback);
   } else {
       status = NFA_STATUS_FAILED;
   }
-  NFA_TRACE_DEBUG1("nfa_ee_get_num_nfcee_configured %x", *num_param);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_get_num_nfcee_configured %x", *num_param);
 
   return status;
 }
@@ -855,9 +1082,9 @@ tNFA_STATUS nfa_ee_get_num_nfcee_configured(tNFA_VSC_CBACK* p_cback)
 ** Returns          None
 **
 *********************************************************************************/
- void nfa_ee_read_num_nfcee_config_cb(uint8_t event, uint16_t param_len,
+ void nfa_ee_read_num_nfcee_config_cb(__attribute__((unused)) uint8_t event, uint16_t param_len,
                                              uint8_t* p_param) {
-    uint8_t num_param_id = 0x00, xx;
+    uint8_t num_param_id = 0x00;
     uint8_t configured_num_nfcee = 0x00;
     uint8_t NFA_PARAM_ID_INDEX = 0x04;
     uint8_t param_id1 = 0x00;
@@ -895,7 +1122,7 @@ tNFA_STATUS nfa_ee_get_num_nfcee_configured(tNFA_VSC_CBACK* p_cback)
     }
     if(configured_num_nfcee)
         nfa_ee_max_ee_cfg = configured_num_nfcee;
-    NFA_TRACE_DEBUG1("nfa_ee_read_num_nfcee_config_cb %x", configured_num_nfcee);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_read_num_nfcee_config_cb %x", configured_num_nfcee);
 }
 
 /******************************************************************************
@@ -911,7 +1138,7 @@ void nfa_ee_api_discover(tNFA_EE_MSG* p_data) {
   tNFA_EE_CBACK* p_cback = p_data->ee_discover.p_cback;
   tNFA_EE_CBACK_DATA evt_data = {0};
 
-  NFA_TRACE_DEBUG1("nfa_ee_api_discover() in_use:%d",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_api_discover() in_use:%d",
                    nfa_ee_cb.discv_timer.in_use);
   if (nfa_ee_cb.discv_timer.in_use) {
     nfa_sys_stop_timer(&nfa_ee_cb.discv_timer);
@@ -979,19 +1206,19 @@ void nfa_ee_api_register(tNFA_EE_MSG* p_data) {
       }
       max_aid_config_length = nfa_ee_find_max_aid_config_length();
       max_aid_entries = max_aid_config_length / NFA_EE_MIN_AID_ENTRY_SIZE;
-      NFA_TRACE_DEBUG3(
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
               "max_routing_table_size = %d max_aid_config_length: %d and "
               "max_aid_entries: %d",
               max_routing_table_size, max_aid_config_length, max_aid_entries);
       /* Dynamic ecb allocation based on max aid entry calculated from max. routing
        * table size( from core_init rsp )*/
       for (xx = 0; xx < NFA_EE_NUM_ECBS; xx++) {
-          nfa_ee_cb.ecb[xx].aid_len = GKI_getbuf(max_aid_entries);
-          nfa_ee_cb.ecb[xx].aid_pwr_cfg = GKI_getbuf(max_aid_entries);
-          nfa_ee_cb.ecb[xx].aid_rt_info = GKI_getbuf(max_aid_entries);
-          nfa_ee_cb.ecb[xx].aid_rt_loc = GKI_getbuf(max_aid_entries);
-          nfa_ee_cb.ecb[xx].aid_info    = GKI_getbuf(max_aid_entries);
-          nfa_ee_cb.ecb[xx].aid_cfg = GKI_getbuf(max_aid_config_length);
+          nfa_ee_cb.ecb[xx].aid_len = (uint8_t*) GKI_getbuf(max_aid_entries);
+          nfa_ee_cb.ecb[xx].aid_pwr_cfg = (uint8_t*) GKI_getbuf(max_aid_entries);
+          nfa_ee_cb.ecb[xx].aid_rt_info = (uint8_t*) GKI_getbuf(max_aid_entries);
+          nfa_ee_cb.ecb[xx].aid_rt_loc = (uint8_t*) GKI_getbuf(max_aid_entries);
+          nfa_ee_cb.ecb[xx].aid_info    = (uint8_t*) GKI_getbuf(max_aid_entries);
+          nfa_ee_cb.ecb[xx].aid_cfg = (uint8_t*) GKI_getbuf(max_aid_config_length);
           if ((NULL != nfa_ee_cb.ecb[xx].aid_len) &&
                   (NULL != nfa_ee_cb.ecb[xx].aid_pwr_cfg) &&
                   (NULL != nfa_ee_cb.ecb[xx].aid_rt_info) &&
@@ -1005,7 +1232,7 @@ void nfa_ee_api_register(tNFA_EE_MSG* p_data) {
               memset(nfa_ee_cb.ecb[xx].aid_info, 0, max_aid_entries);
               memset(nfa_ee_cb.ecb[xx].aid_cfg, 0, max_aid_config_length);
           } else {
-              NFA_TRACE_ERROR0("GKI_getbuf allocation for ECB failed !");
+              LOG(ERROR) << StringPrintf("GKI_getbuf allocation for ECB failed !");
           }
       }
   }
@@ -1046,7 +1273,7 @@ void nfa_ee_api_deregister(tNFA_EE_MSG* p_data) {
 #endif
   tNFA_EE_CBACK_DATA evt_data = {0};
 
-  NFA_TRACE_DEBUG0("nfa_ee_api_deregister");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_api_deregister");
 #if (NXP_EXTNS == TRUE)
   if((nfcFL.chipType != pn547C2) &&
           (nfcFL.nfcMwFL._NFC_NXP_AID_MAX_SIZE_DYN == true)) {
@@ -1074,7 +1301,7 @@ void nfa_ee_api_deregister(tNFA_EE_MSG* p_data) {
 **
 *******************************************************************************/
 void nfa_ee_api_power_link_set(tNFA_EE_MSG* p_data) {
-    tNFA_EE_ECB* p_cb = p_data->cfg_hdr.p_cb;
+    __attribute__((unused)) tNFA_EE_ECB* p_cb = p_data->cfg_hdr.p_cb;
     NFC_Nfcee_PwrLinkCtrl(p_data->pwr_lnk_ctrl_set.nfcee_id, p_data->pwr_lnk_ctrl_set.cfg_value);
     return;
 }
@@ -1090,7 +1317,7 @@ void nfa_ee_api_power_link_set(tNFA_EE_MSG* p_data) {
 void nfa_ee_api_mode_set(tNFA_EE_MSG* p_data) {
   tNFA_EE_ECB* p_cb = p_data->cfg_hdr.p_cb;
   tNFA_EE_MODE_SET         mode_set;
-  NFA_TRACE_DEBUG2("nfa_ee_api_mode_set() handle:0x%02x mode:%d",
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_api_mode_set() handle:0x%02x mode:%d",
                    p_cb->nfcee_id, p_data->mode_set.mode);
   if(NFA_GetNCIVersion() != NCI_VERSION_2_0)
   {
@@ -1102,7 +1329,9 @@ void nfa_ee_api_mode_set(tNFA_EE_MSG* p_data) {
         /* the api is rejected at NFC layer, report the failure status right away */
         mode_set.ee_handle  = (tNFA_HANDLE)p_cb->nfcee_id | NFA_HANDLE_GROUP_EE;
         mode_set.ee_status  = p_data->mode_set.mode;
-        nfa_ee_report_event(NULL, NFA_EE_MODE_SET_EVT, (tNFA_EE_CBACK_DATA *)&mode_set);
+        tNFA_EE_CBACK_DATA nfa_ee_cback_data;
+        nfa_ee_cback_data.mode_set = mode_set;
+        nfa_ee_report_event(NULL, NFA_EE_MODE_SET_EVT, &nfa_ee_cback_data);
         return;
       }
   }
@@ -1149,22 +1378,17 @@ void nfa_ee_api_set_tech_cfg(tNFA_EE_MSG* p_data) {
   tNFA_TECHNOLOGY_MASK old_tech_switch_on = p_cb->tech_switch_on;
   tNFA_TECHNOLOGY_MASK old_tech_switch_off = p_cb->tech_switch_off;
   tNFA_TECHNOLOGY_MASK old_tech_battery_off = p_cb->tech_battery_off;
-#if (NXP_EXTNS == TRUE)
   tNFA_TECHNOLOGY_MASK old_tech_screen_lock = p_cb->tech_screen_lock;
   tNFA_TECHNOLOGY_MASK old_tech_screen_off = p_cb->tech_screen_off;
   tNFA_TECHNOLOGY_MASK old_tech_screen_off_lock = p_cb->tech_screen_off_lock;
-#endif
   uint8_t old_size_mask = p_cb->size_mask;
 
   if ((p_cb->tech_switch_on == p_data->set_tech.technologies_switch_on) &&
       (p_cb->tech_switch_off == p_data->set_tech.technologies_switch_off) &&
-      (p_cb->tech_battery_off == p_data->set_tech.technologies_battery_off)
-#if (NXP_EXTNS == TRUE)
-      &&
+      (p_cb->tech_battery_off == p_data->set_tech.technologies_battery_off) &&
       (p_cb->tech_screen_lock == p_data->set_tech.technologies_screen_lock) &&
       (p_cb->tech_screen_off == p_data->set_tech.technologies_screen_off) &&
       (p_cb->tech_screen_off_lock == p_data->set_tech.technologies_screen_off_lock)
-#endif
           ) {
     /* nothing to change */
     evt_data.status = NFA_STATUS_OK;
@@ -1174,31 +1398,24 @@ void nfa_ee_api_set_tech_cfg(tNFA_EE_MSG* p_data) {
   p_cb->tech_switch_on = p_data->set_tech.technologies_switch_on;
   p_cb->tech_switch_off = p_data->set_tech.technologies_switch_off;
   p_cb->tech_battery_off = p_data->set_tech.technologies_battery_off;
-#if (NXP_EXTNS == TRUE)
   p_cb->tech_screen_lock = p_data->set_tech.technologies_screen_lock;
   p_cb->tech_screen_off = p_data->set_tech.technologies_screen_off;
   p_cb->tech_screen_off_lock = p_data->set_tech.technologies_screen_off_lock;
-#endif
   nfa_ee_update_route_size(p_cb);
   if (nfa_ee_total_lmrt_size() > NFC_GetLmrtSize()) {
-    NFA_TRACE_ERROR0("nfa_ee_api_set_tech_cfg Exceed LMRT size");
+    LOG(ERROR) << StringPrintf("nfa_ee_api_set_tech_cfg Exceed LMRT size");
     evt_data.status = NFA_STATUS_BUFFER_FULL;
     p_cb->tech_switch_on = old_tech_switch_on;
     p_cb->tech_switch_off = old_tech_switch_off;
     p_cb->tech_battery_off = old_tech_battery_off;
-#if (NXP_EXTNS == TRUE)
     p_cb->tech_screen_lock = old_tech_screen_lock;
     p_cb->tech_screen_off = old_tech_screen_off;
     p_cb->tech_screen_off_lock = old_tech_screen_off_lock;
-#endif
     p_cb->size_mask = old_size_mask;
   } else {
     p_cb->ecb_flags |= NFA_EE_ECB_FLAGS_TECH;
-    if (p_cb->tech_switch_on | p_cb->tech_switch_off | p_cb->tech_battery_off
-#if (NXP_EXTNS == TRUE)
-        | p_cb->tech_screen_lock | p_cb->tech_screen_off | p_cb->tech_screen_off_lock
-#endif
-        ) {
+    if (p_cb->tech_switch_on | p_cb->tech_switch_off | p_cb->tech_battery_off |
+      p_cb->tech_screen_lock | p_cb->tech_screen_off | p_cb->tech_screen_off_lock) {
       /* if any technology in any power mode is configured, mark this entry as
        * configured */
       nfa_ee_cb.ee_cfged |= nfa_ee_ecb_to_mask(p_cb);
@@ -1225,22 +1442,17 @@ void nfa_ee_api_set_proto_cfg(tNFA_EE_MSG* p_data) {
   tNFA_PROTOCOL_MASK old_proto_switch_on = p_cb->proto_switch_on;
   tNFA_PROTOCOL_MASK old_proto_switch_off = p_cb->proto_switch_off;
   tNFA_PROTOCOL_MASK old_proto_battery_off = p_cb->proto_battery_off;
-#if (NXP_EXTNS == TRUE)
   tNFA_PROTOCOL_MASK old_proto_screen_lock = p_cb->proto_screen_lock;
   tNFA_PROTOCOL_MASK old_proto_screen_off = p_cb->proto_screen_off;
   tNFA_PROTOCOL_MASK old_proto_screen_off_lock = p_cb->proto_screen_off_lock;
-#endif
   uint8_t old_size_mask = p_cb->size_mask;
 
   if ((p_cb->proto_switch_on == p_data->set_proto.protocols_switch_on) &&
       (p_cb->proto_switch_off == p_data->set_proto.protocols_switch_off) &&
-      (p_cb->proto_battery_off == p_data->set_proto.protocols_battery_off)
-#if (NXP_EXTNS == TRUE)
-      && (p_cb->proto_screen_lock == p_data->set_proto.protocols_screen_lock) &&
+      (p_cb->proto_battery_off == p_data->set_proto.protocols_battery_off) &&
+      (p_cb->proto_screen_lock == p_data->set_proto.protocols_screen_lock) &&
       (p_cb->proto_screen_off == p_data->set_proto.protocols_screen_off) &&
-      (p_cb->proto_screen_off_lock == p_data->set_proto.protocols_screen_off_lock)
-#endif
-          ) {
+      (p_cb->proto_screen_off_lock == p_data->set_proto.protocols_screen_off_lock)) {
     /* nothing to change */
     evt_data.status = NFA_STATUS_OK;
     nfa_ee_report_event(p_cb->p_ee_cback, NFA_EE_SET_PROTO_CFG_EVT, &evt_data);
@@ -1249,31 +1461,24 @@ void nfa_ee_api_set_proto_cfg(tNFA_EE_MSG* p_data) {
   p_cb->proto_switch_on = p_data->set_proto.protocols_switch_on;
   p_cb->proto_switch_off = p_data->set_proto.protocols_switch_off;
   p_cb->proto_battery_off = p_data->set_proto.protocols_battery_off;
-#if (NXP_EXTNS == TRUE)
   p_cb->proto_screen_lock = p_data->set_proto.protocols_screen_lock;
   p_cb->proto_screen_off = p_data->set_proto.protocols_screen_off;
   p_cb->proto_screen_off_lock = p_data->set_proto.protocols_screen_off_lock;
-#endif
   nfa_ee_update_route_size(p_cb);
   if (nfa_ee_total_lmrt_size() > NFC_GetLmrtSize()) {
-    NFA_TRACE_ERROR0("nfa_ee_api_set_proto_cfg Exceed LMRT size");
+    LOG(ERROR) << StringPrintf("nfa_ee_api_set_proto_cfg Exceed LMRT size");
     evt_data.status = NFA_STATUS_BUFFER_FULL;
     p_cb->proto_switch_on = old_proto_switch_on;
     p_cb->proto_switch_off = old_proto_switch_off;
     p_cb->proto_battery_off = old_proto_battery_off;
-#if (NXP_EXTNS == TRUE)
     p_cb->proto_screen_lock = old_proto_screen_lock;
     p_cb->proto_screen_off = old_proto_screen_off;
     p_cb->proto_screen_off_lock = old_proto_screen_off_lock;
-#endif
     p_cb->size_mask = old_size_mask;
   } else {
     p_cb->ecb_flags |= NFA_EE_ECB_FLAGS_PROTO;
-    if (p_cb->proto_switch_on | p_cb->proto_switch_off | p_cb->proto_battery_off
-#if (NXP_EXTNS == TRUE)
-        | p_cb->proto_screen_lock | p_cb->proto_screen_off | p_cb->proto_screen_off_lock
-#endif
-        ) {
+    if (p_cb->proto_switch_on | p_cb->proto_switch_off | p_cb->proto_battery_off |
+      p_cb->proto_screen_lock | p_cb->proto_screen_off | p_cb->proto_screen_off_lock) {
       /* if any protocol in any power mode is configured, mark this entry as
        * configured */
       nfa_ee_cb.ee_cfged |= nfa_ee_ecb_to_mask(p_cb);
@@ -1300,7 +1505,6 @@ void nfa_ee_api_add_aid(tNFA_EE_MSG* p_data) {
 
 #if (NXP_EXTNS == TRUE)
   tNFA_EE_ECB* dh_ecb = NULL;
-  uint8_t aid_info = p_add->aid_info;
   uint16_t aid_config_length_max = 0;
   uint16_t aid_entries_max = 0;
 #endif
@@ -1327,22 +1531,24 @@ void nfa_ee_api_add_aid(tNFA_EE_MSG* p_data) {
     }
   }
   if (p_chk_cb) {
-    NFA_TRACE_DEBUG0(
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "nfa_ee_api_add_aid The AID entry is already in the database");
     if (p_chk_cb == p_cb) {
       p_cb->aid_rt_info[entry] |= NFA_EE_AE_ROUTE;
-      p_cb->aid_info[entry] = p_add->aid_info;
+      p_cb->aid_info[entry] = p_add->aidInfo;
       new_size = nfa_ee_total_lmrt_size();
       if (new_size > NFC_GetLmrtSize()) {
-        NFA_TRACE_ERROR1("Exceed LMRT size:%d (add ROUTE)", new_size);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Exceed LMRT size:%d (add ROUTE)", new_size);
         evt_data.status = NFA_STATUS_BUFFER_FULL;
         p_cb->aid_rt_info[entry] &= ~NFA_EE_AE_ROUTE;
       } else {
         p_cb->aid_pwr_cfg[entry] = p_add->power_state;
-        p_cb->aid_info[entry] = p_add->aid_info;
+#if (NXP_EXTNS == TRUE)
+        p_cb->aid_info[entry] = p_add->aidInfo;
+#endif
       }
     } else {
-      NFA_TRACE_ERROR1(
+      LOG(ERROR) << StringPrintf(
           "The AID entry is already in the database for different NFCEE "
           "ID:0x%02x",
           p_chk_cb->nfcee_id);
@@ -1377,12 +1583,12 @@ void nfa_ee_api_add_aid(tNFA_EE_MSG* p_data) {
 #endif
         ) {
 #if (NXP_EXTNS == TRUE)
-      NFA_TRACE_ERROR3(
+      LOG(ERROR) << StringPrintf(
           "Exceed capacity: (len_needed:%d + len:%d) > "
           "max_aid_config_length:%d",
           len_needed, len, aid_config_length_max);
 #else
-      NFA_TRACE_ERROR3(
+      LOG(ERROR) << StringPrintf(
           "Exceed capacity: (len_needed:%d + len:%d) > "
           "NFA_EE_MAX_AID_CFG_LEN:%d",
           len_needed, len, NFA_EE_MAX_AID_CFG_LEN);
@@ -1398,7 +1604,7 @@ void nfa_ee_api_add_aid(tNFA_EE_MSG* p_data) {
       /* 4 = 1 (tag) + 1 (len) + 1(nfcee_id) + 1(power cfg) */
       new_size = nfa_ee_total_lmrt_size() + 4 + p_add->aid_len;
       if (new_size > NFC_GetLmrtSize()) {
-        NFA_TRACE_ERROR1("Exceed LMRT size:%d", new_size);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Exceed LMRT size:%d", new_size);
         evt_data.status = NFA_STATUS_BUFFER_FULL;
       } else {
 /* add AID */
@@ -1408,15 +1614,14 @@ void nfa_ee_api_add_aid(tNFA_EE_MSG* p_data) {
         dh_ecb->aid_pwr_cfg[dh_ecb->aid_entries] = p_add->power_state;
         dh_ecb->aid_rt_info[dh_ecb->aid_entries] = NFA_EE_AE_ROUTE;
         dh_ecb->aid_rt_loc[dh_ecb->aid_entries] = p_cb->nfcee_id;
-        dh_ecb->aid_info[dh_ecb->aid_entries] = p_add->aid_info;
+        dh_ecb->aid_info[dh_ecb->aid_entries] = p_add->aidInfo;
         p = dh_ecb->aid_cfg + len;
 #else
         p_cb->aid_pwr_cfg[p_cb->aid_entries] = p_add->power_state;
-        p_cb->aid_info[p_cb->aid_entries] = p_add->aid_info;
+        p_cb->aid_info[p_cb->aid_entries] = p_add->aidInfo;
         p_cb->aid_rt_info[p_cb->aid_entries] = NFA_EE_AE_ROUTE;
         p = p_cb->aid_cfg + len;
 #endif
-
         p_start = p;
         *p++ = NFA_EE_AID_CFG_TAG_NAME;
         *p++ = p_add->aid_len;
@@ -1430,12 +1635,8 @@ void nfa_ee_api_add_aid(tNFA_EE_MSG* p_data) {
 #endif
       }
     } else {
-#if (NXP_EXTNS == TRUE)
-            NFA_TRACE_ERROR1("Exceed NFA_EE_MAX_AID_ENTRIES:%d", aid_entries_max);
-#else
-        NFA_TRACE_ERROR1("Exceed NFA_EE_MAX_AID_ENTRIES:%d",
-                NFA_EE_MAX_AID_ENTRIES);
-#endif
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Exceed NFA_EE_MAX_AID_ENTRIES:%d",
+                       NFA_EE_MAX_AID_ENTRIES);
       evt_data.status = NFA_STATUS_BUFFER_FULL;
     }
   }
@@ -1447,7 +1648,7 @@ void nfa_ee_api_add_aid(tNFA_EE_MSG* p_data) {
     nfa_ee_update_route_aid_size(p_cb);
     nfa_ee_start_timer();
   }
-  NFA_TRACE_DEBUG2("status:%d ee_cfged:0x%02x ", evt_data.status,
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("status:%d ee_cfged:0x%02x ", evt_data.status,
                    nfa_ee_cb.ee_cfged);
   /* report the status of this operation */
   nfa_ee_report_event(p_cb->p_ee_cback, NFA_EE_ADD_AID_EVT, &evt_data);
@@ -1476,7 +1677,7 @@ void nfa_ee_api_remove_aid(tNFA_EE_MSG* p_data) {
   p_cb = nfa_ee_find_aid_offset(p_data->rm_aid.aid_len, p_data->rm_aid.p_aid,
                                 &offset, &entry);
   if (p_cb && p_cb->aid_entries) {
-    NFA_TRACE_DEBUG2("aid_rt_info[%d]: 0x%02x", entry,
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("aid_rt_info[%d]: 0x%02x", entry,
                      p_cb->aid_rt_info[entry]);
     /* mark routing and VS changed */
     if (p_cb->aid_rt_info[entry] & NFA_EE_AE_ROUTE)
@@ -1492,7 +1693,7 @@ void nfa_ee_api_remove_aid(tNFA_EE_MSG* p_data) {
       rest_len = nfa_ee_find_total_aid_len(p_cb, entry + 1);
 
       len = p_cb->aid_len[entry];
-      NFA_TRACE_DEBUG2("nfa_ee_api_remove_aid len:%d, rest_len:%d", len,
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_api_remove_aid len:%d, rest_len:%d", len,
                        rest_len);
       GKI_shiftup(&p_cb->aid_cfg[offset], &p_cb->aid_cfg[offset + len],
                   rest_len);
@@ -1580,7 +1781,7 @@ void nfa_ee_api_remove_aid(tNFA_EE_MSG* p_data) {
   }
 #endif
   else {
-    NFA_TRACE_ERROR0(
+    LOG(ERROR) << StringPrintf(
         "nfa_ee_api_remove_aid The AID entry is not in the database");
     evt_data.status = NFA_STATUS_INVALID_PARAM;
   }
@@ -1626,27 +1827,27 @@ void nfa_ee_api_add_apdu(tNFA_EE_MSG* p_data) {
     }
   }
   if (p_chk_cb) {
-    NFA_TRACE_DEBUG0(
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "nfa_ee_api_add_apdu The APDU entry is already in the database");
     if (p_chk_cb == p_cb) {
       p_cb->apdu_rt_info[entry] |= NFA_EE_AE_ROUTE;
       new_size = nfa_ee_total_lmrt_size();
 #if (NXP_EXTNS == TRUE)
       if (((nfcFL.chipType != pn547C2) &&
-              nfcFL.nfcMwFL._NFC_NXP_AID_MAX_SIZE_DYN) && new_size > max_aid_config_length ||
+              (nfcFL.nfcMwFL._NFC_NXP_AID_MAX_SIZE_DYN) && (new_size > max_aid_config_length)) ||
               ((nfcFL.chipType == pn547C2) &&
-                      !nfcFL.nfcMwFL._NFC_NXP_AID_MAX_SIZE_DYN) && (new_size > NFC_GetLmrtSize())) {
+                      (!nfcFL.nfcMwFL._NFC_NXP_AID_MAX_SIZE_DYN) && (new_size > NFC_GetLmrtSize()))) {
 #else
       if (new_size > NFC_GetLmrtSize()) {
 #endif
-        NFA_TRACE_ERROR1("Exceed LMRT size:%d (add ROUTE)", new_size);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Exceed LMRT size:%d (add ROUTE)", new_size);
         evt_data.status = NFA_STATUS_BUFFER_FULL;
         p_cb->apdu_rt_info[entry] &= ~NFA_EE_AE_ROUTE;
       } else {
         p_cb->apdu_pwr_cfg[entry] = p_add->power_state;
       }
     } else {
-      NFA_TRACE_ERROR1(
+      LOG(ERROR) << StringPrintf(
           "The APDU entry is already in the database for different NFCEE "
           "ID:0x%02x",
           p_chk_cb->nfcee_id);
@@ -1677,22 +1878,16 @@ void nfa_ee_api_add_apdu(tNFA_EE_MSG* p_data) {
 #if (NXP_EXTNS == TRUE)
         if((nfcFL.chipType != pn547C2) &&
                 nfcFL.nfcMwFL._NFC_NXP_AID_MAX_SIZE_DYN) {
-            NFA_TRACE_ERROR4(
-                    "Exceed capacity: (len_needed:%d + len:%d) > "
-                    "max_aid_config_length:%d",
-                    len_needed, aid_len,apdu_len, max_aid_config_length);
+            LOG(ERROR) << StringPrintf("Exceed capacity: (len_needed:%d + len:%d) >  max_aid_config_length:%d",
+                          len_needed, aid_len, max_aid_config_length);
         }
         else {
-            NFA_TRACE_ERROR4(
-                    "Exceed capacity: (len_needed:%d + len:%d) > "
-                    "NFA_EE_TOTAL_APDU_PATTERN_SIZE:%d",
-                    len_needed, aid_len,apdu_len, NFA_EE_TOTAL_APDU_PATTERN_SIZE);
+            LOG(ERROR) << StringPrintf("Exceed capacity: (len_needed:%d + len:%d) > NFA_EE_TOTAL_APDU_PATTERN_SIZE:%d",
+                          len_needed, aid_len, NFA_EE_TOTAL_APDU_PATTERN_SIZE);
         }
 #else
-      NFA_TRACE_ERROR4(
-          "Exceed capacity: (len_needed:%d + len:%d) > "
-          "NFA_EE_TOTAL_APDU_PATTERN_SIZE:%d",
-          len_needed, aid_len,apdu_len, NFA_EE_TOTAL_APDU_PATTERN_SIZE);
+      LOG(ERROR) << StringPrintf("Exceed capacity: (len_needed:%d + len:%d) > NFA_EE_TOTAL_APDU_PATTERN_SIZE:%d",
+                    len_needed, aid_len, NFA_EE_TOTAL_APDU_PATTERN_SIZE);
 #endif
       evt_data.status = NFA_STATUS_BUFFER_FULL;
     }
@@ -1732,7 +1927,7 @@ void nfa_ee_api_add_apdu(tNFA_EE_MSG* p_data) {
     }
     else
     {
-       NFA_TRACE_ERROR1("Exceed NFA_EE_MAX_APDU_PATTERN_ENTRIES:%d", NFA_EE_MAX_APDU_PATTERN_ENTRIES);
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Exceed NFA_EE_MAX_APDU_PATTERN_ENTRIES:%d", NFA_EE_MAX_APDU_PATTERN_ENTRIES);
        evt_data.status = NFA_STATUS_BUFFER_FULL;
     }
   }
@@ -1744,7 +1939,7 @@ void nfa_ee_api_add_apdu(tNFA_EE_MSG* p_data) {
     nfa_ee_update_route_apdu_size(p_cb);
     nfa_ee_start_timer();
   }
-  NFA_TRACE_DEBUG2("status:%d ee_cfged:0x%02x ", evt_data.status,
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("status:%d ee_cfged:0x%02x ", evt_data.status,
                    nfa_ee_cb.ee_cfged);
   /* report the status of this operation */
   nfa_ee_report_event(p_cb->p_ee_cback, NFA_EE_ADD_APDU_EVT, &evt_data);
@@ -1771,7 +1966,7 @@ void nfa_ee_api_remove_apdu(tNFA_EE_MSG* p_data) {
   p_cb = nfa_ee_find_apdu_offset(p_data->rm_apdu.apdu_len, p_data->rm_apdu.p_apdu,
                                     &offset, &entry);
   if (p_cb && p_cb->apdu_pattern_entries) {
-    NFA_TRACE_DEBUG2("apdu_rt_info[%d]: 0x%02x", entry,
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("apdu_rt_info[%d]: 0x%02x", entry,
                          p_cb->apdu_rt_info[entry]);
    /* mark routing and VS changed */
     if (p_cb->apdu_rt_info[entry] & NFA_EE_AE_ROUTE)
@@ -1787,7 +1982,7 @@ void nfa_ee_api_remove_apdu(tNFA_EE_MSG* p_data) {
       rest_len = nfa_ee_find_total_apdu_len(p_cb, entry + 1);
 
       len = p_cb->apdu_len[entry];
-      NFA_TRACE_DEBUG2("nfa_ee_api_remove_apdu len:%d, rest_len:%d", len,
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_api_remove_apdu len:%d, rest_len:%d", len,
                        rest_len);
       GKI_shiftup(&p_cb->apdu_cfg[offset], &p_cb->apdu_cfg[offset + len],
                  rest_len);
@@ -1826,13 +2021,186 @@ void nfa_ee_api_remove_apdu(tNFA_EE_MSG* p_data) {
     }
 #endif
     else {
-      NFA_TRACE_ERROR0(
+      LOG(ERROR) << StringPrintf(
           "nfa_ee_api_remove_apdu The APDU entry is not in the database");
       evt_data.status = NFA_STATUS_INVALID_PARAM;
     }
     nfa_ee_report_event(p_cback, NFA_EE_REMOVE_APDU_EVT, &evt_data);
   }
 
+/*******************************************************************************
+ **
+ ** Function         nfa_ee_api_add_sys_code
+ **
+ ** Description      Adds System Code routing configuration from user. When the
+ **                  timer expires, the configuration collected in control block
+ **                  is sent to NFCC
+ **
+ ** Returns          void
+ **
+ *******************************************************************************/
+void nfa_ee_api_add_sys_code(tNFA_EE_MSG* p_data) {
+  tNFA_EE_CBACK_DATA evt_data = {0};
+  tNFA_EE_API_ADD_SYSCODE* p_add = &p_data->add_syscode;
+  tNFA_EE_ECB* p_cb = p_data->cfg_hdr.p_cb;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s id:0x%x SC:0x%X ", __func__, p_add->nfcee_id, p_add->syscode);
+
+  int offset = 0, entry = 0;
+  tNFA_EE_ECB* p_chk_cb =
+      nfa_ee_find_sys_code_offset(p_add->syscode, &offset, &entry);
+
+  if (p_chk_cb) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: The SC entry already registered "
+        "for this NFCEE id:0x%02x",
+        __func__, p_add->nfcee_id);
+
+    if (p_chk_cb == p_cb) {
+      p_cb->sys_code_rt_loc_vs_info[entry] |= NFA_EE_AE_ROUTE;
+      uint16_t new_size = nfa_ee_total_lmrt_size();
+      if (new_size > NFC_GetLmrtSize()) {
+        LOG(ERROR) << StringPrintf("Exceeded LMRT size:%d (add SYSCODE)",
+                                   new_size);
+        evt_data.status = NFA_STATUS_BUFFER_FULL;
+        p_cb->sys_code_rt_loc_vs_info[entry] &= ~NFA_EE_AE_ROUTE;
+      } else {
+        p_cb->sys_code_pwr_cfg[entry] = p_add->power_state;
+      }
+    } else {
+      LOG(ERROR) << StringPrintf(
+          "%s: SystemCode entry already registered for different "
+          "NFCEE id:0x%02x",
+          __func__, p_chk_cb->nfcee_id);
+      evt_data.status = NFA_STATUS_REJECTED;
+    }
+  } else {
+    /* Find the total length so far in sys_code_cfg */
+    int total_sc_len = nfa_all_ee_find_total_sys_code_len();
+    /* make sure the control block has enough room to hold this entry */
+    if ((NFA_EE_SYSTEM_CODE_LEN + total_sc_len) >
+        NFA_EE_MAX_SYSTEM_CODE_CFG_LEN) {
+      LOG(ERROR) << StringPrintf(
+          "Exceeded capacity: (NFA_EE_SYSTEM_CODE_LEN:%d + total_sc_len:%d) > "
+          "NFA_EE_MAX_SYSTEM_CODE_CFG_LEN:%d",
+          NFA_EE_SYSTEM_CODE_LEN, total_sc_len, NFA_EE_MAX_SYSTEM_CODE_CFG_LEN);
+      evt_data.status = NFA_STATUS_BUFFER_FULL;
+    } else if (p_cb->sys_code_cfg_entries < NFA_EE_MAX_SYSTEM_CODE_ENTRIES) {
+      /* 6 = 1 (tag) + 1 (len) + 1(nfcee_id) + 1(power cfg) + 2(system code)*/
+      uint16_t new_size =
+          nfa_ee_total_lmrt_size() + NFA_EE_SYSTEM_CODE_TLV_SIZE;
+      if (new_size > NFC_GetLmrtSize()) {
+        LOG(ERROR) << StringPrintf("Exceeded LMRT size:%d", new_size);
+        evt_data.status = NFA_STATUS_BUFFER_FULL;
+      } else {
+        /* add SC entry*/
+        uint32_t p_cb_sc_len = nfa_ee_find_total_sys_code_len(p_cb, 0);
+        p_cb->sys_code_pwr_cfg[p_cb->sys_code_cfg_entries] = p_add->power_state;
+        p_cb->sys_code_rt_loc[p_cb->sys_code_cfg_entries] = p_add->nfcee_id;
+        p_cb->sys_code_rt_loc_vs_info[p_cb->sys_code_cfg_entries] =
+            NFA_EE_AE_ROUTE;
+
+        uint8_t* p = p_cb->sys_code_cfg + p_cb_sc_len;
+        memcpy(p, &p_add->syscode, NFA_EE_SYSTEM_CODE_LEN);
+        p += NFA_EE_SYSTEM_CODE_LEN;
+
+        p_cb->sys_code_cfg_entries++;
+      }
+    } else {
+      LOG(ERROR) << StringPrintf("Exceeded NFA_EE_MAX_SYSTEM_CODE_ENTRIES:%d",
+                                 NFA_EE_MAX_SYSTEM_CODE_ENTRIES);
+      evt_data.status = NFA_STATUS_BUFFER_FULL;
+    }
+  }
+
+  if (evt_data.status == NFA_STATUS_OK) {
+    /* mark SC changed */
+    p_cb->ecb_flags |= NFA_EE_ECB_FLAGS_SYSCODE;
+    nfa_ee_cb.ee_cfged |= nfa_ee_ecb_to_mask(p_cb);
+    nfa_ee_update_route_sys_code_size(p_cb);
+    nfa_ee_start_timer();
+  }
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s: status:%d ee_cfged:0x%02x ", __func__,
+                      evt_data.status, nfa_ee_cb.ee_cfged);
+
+  /* report the status of this operation */
+  nfa_ee_report_event(p_cb->p_ee_cback, NFA_EE_ADD_SYSCODE_EVT, &evt_data);
+}
+
+/*******************************************************************************
+**
+** Function         nfa_ee_api_remove_sys_code
+**
+** Description      process remove an System Code routing configuration from
+**                  user start a 1 second timer. When the timer expires,
+**                  the configuration collected in control block is sent to NFCC
+**
+** Returns          void
+**
+*******************************************************************************/
+void nfa_ee_api_remove_sys_code(tNFA_EE_MSG* p_data) {
+  tNFA_EE_CBACK_DATA evt_data = {0};
+  tNFA_EE_API_REMOVE_SYSCODE* p_remove = &p_data->rm_syscode;
+
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("%s SC:0x%x", __func__, p_remove->syscode);
+
+  int offset = 0, entry = 0;
+  tNFA_EE_ECB* p_cb =
+      nfa_ee_find_sys_code_offset(p_data->rm_syscode.syscode, &offset, &entry);
+
+  if (p_cb && p_cb->sys_code_cfg_entries) {
+    DLOG_IF(INFO, nfc_debug_enabled)
+        << StringPrintf("sys_code_rt_loc_vs_info[%d]: 0x%02x", entry,
+                        p_cb->sys_code_rt_loc_vs_info[entry]);
+    /* mark routing and VS changed */
+    if (p_cb->sys_code_rt_loc_vs_info[entry] & NFA_EE_AE_ROUTE)
+      p_cb->ecb_flags |= NFA_EE_ECB_FLAGS_SYSCODE;
+
+    if (p_cb->sys_code_rt_loc_vs_info[entry] & NFA_EE_AE_VS)
+      p_cb->ecb_flags |= NFA_EE_ECB_FLAGS_VS;
+
+    /* remove the system code */
+    if ((entry + 1) < p_cb->sys_code_cfg_entries) {
+      /* not the last entry, move the SC entries in control block */
+      /* Find the total len from the next entry to the last one */
+      int total_len = nfa_ee_find_total_sys_code_len(p_cb, entry + 1);
+
+      int rm_len = NFA_EE_SYSTEM_CODE_LEN;
+
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("nfa_ee_api_remove_sys_code: rm_len:%d, total_len:%d",
+                          rm_len, total_len);
+
+      GKI_shiftup(&p_cb->sys_code_cfg[offset],
+                  &p_cb->sys_code_cfg[offset + rm_len], total_len);
+
+      total_len = p_cb->sys_code_cfg_entries - entry;
+
+      GKI_shiftup(&p_cb->sys_code_pwr_cfg[entry],
+                  &p_cb->sys_code_pwr_cfg[entry + 1], total_len);
+
+      GKI_shiftup(&p_cb->sys_code_rt_loc_vs_info[entry],
+                  &p_cb->sys_code_rt_loc_vs_info[entry + 1], total_len);
+
+      GKI_shiftup(&p_cb->sys_code_rt_loc[entry],
+                  &p_cb->sys_code_rt_loc[entry + 1], total_len);
+    }
+    /* else the last entry, just reduce the aid_entries by 1 */
+    p_cb->sys_code_cfg_entries--;
+    nfa_ee_cb.ee_cfged |= nfa_ee_ecb_to_mask(p_cb);
+    nfa_ee_update_route_sys_code_size(p_cb);
+    nfa_ee_start_timer();
+  } else {
+    LOG(ERROR) << StringPrintf(
+        "nfa_ee_api_remove_sys_code: The SC entry is not in the database");
+    evt_data.status = NFA_STATUS_INVALID_PARAM;
+  }
+  /* report the status of this operation */
+  nfa_ee_report_event(p_cb->p_ee_cback, NFA_EE_REMOVE_SYSCODE_EVT, &evt_data);
+}
+
 /*******************************************************************************
 **
 ** Function         nfa_ee_api_lmrt_size
@@ -1842,12 +2210,11 @@ void nfa_ee_api_remove_apdu(tNFA_EE_MSG* p_data) {
 ** Returns          void
 **
 *******************************************************************************/
-void nfa_ee_api_lmrt_size(tNFA_EE_MSG* p_data) {
+void nfa_ee_api_lmrt_size(__attribute__((unused)) tNFA_EE_MSG* p_data) {
   tNFA_EE_CBACK_DATA evt_data = {0};
   uint16_t total_size = NFC_GetLmrtSize();
-  (void)p_data;
   evt_data.size = total_size - nfa_ee_total_lmrt_size();
-  NFA_TRACE_DEBUG2("nfa_ee_api_lmrt_size total size:%d remaining size:%d",
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_api_lmrt_size total size:%d remaining size:%d",
                    total_size, evt_data.size);
 
   nfa_ee_report_event(NULL, NFA_EE_REMAINING_SIZE_EVT, &evt_data);
@@ -1866,7 +2233,7 @@ void nfa_ee_api_update_now(tNFA_EE_MSG* p_data) {
   tNFA_EE_CBACK_DATA evt_data;
 
   if (nfa_ee_cb.ee_wait_evt & NFA_EE_WAIT_UPDATE_ALL) {
-    NFA_TRACE_ERROR2(
+    LOG(ERROR) << StringPrintf(
         "nfa_ee_api_update_now still waiting for update complete "
         "ee_wait_evt:0x%x wait_rsp:%d",
         nfa_ee_cb.ee_wait_evt, nfa_ee_cb.wait_rsp);
@@ -1949,11 +2316,16 @@ void nfa_ee_api_send_data(tNFA_EE_MSG* p_data) {
       memcpy(p, p_data->send_data.p_data, p_pkt->len);
       NFC_SendData(p_cb->conn_id, p_pkt);
     } else {
+      tNFA_EE_CBACK_DATA nfa_ee_cback_data;
+      nfa_ee_cback_data.status = status;
       nfa_ee_report_event(p_cb->p_ee_cback, NFA_EE_NO_MEM_ERR_EVT,
-                          (void*)&status);
+                          &nfa_ee_cback_data);
     }
   } else {
-    nfa_ee_report_event(p_cb->p_ee_cback, NFA_EE_NO_CB_ERR_EVT, (void*)&status);
+    tNFA_EE_CBACK_DATA nfa_ee_cback_data;
+    nfa_ee_cback_data.status = status;
+    nfa_ee_report_event(p_cb->p_ee_cback, NFA_EE_NO_CB_ERR_EVT,
+                        &nfa_ee_cback_data);
   }
 }
 
@@ -1995,7 +2367,7 @@ void nfa_ee_report_disc_done(bool notify_enable_done) {
   tNFA_EE_CBACK* p_cback;
   tNFA_EE_CBACK_DATA evt_data = {0};
 
-  NFA_TRACE_DEBUG3(
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "nfa_ee_report_disc_done() em_state:%d num_ee_expecting:%d "
       "notify_enable_done:%d",
       nfa_ee_cb.em_state, nfa_ee_cb.num_ee_expecting, notify_enable_done);
@@ -2089,7 +2461,7 @@ static void nfa_ee_remove_pending(void) {
     }
   }
 
-  NFA_TRACE_DEBUG3(
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "nfa_ee_remove_pending() cur_ee:%d, num_removed:%d first_removed:%d",
       nfa_ee_cb.cur_ee, num_removed, first_removed);
   if (num_removed && (first_removed != (nfa_ee_cb.cur_ee - num_removed))) {
@@ -2128,7 +2500,7 @@ void nfa_ee_nci_disc_rsp(tNFA_EE_MSG* p_data) {
   uint8_t num_nfcee = p_evt->num_nfcee;
   bool notify_enable_done = false;
 
-  NFA_TRACE_DEBUG3("nfa_ee_nci_disc_rsp() em_state:%d cur_ee:%d, num_nfcee:%d",
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_nci_disc_rsp() em_state:%d cur_ee:%d, num_nfcee:%d",
                    nfa_ee_cb.em_state, nfa_ee_cb.cur_ee, num_nfcee);
   switch (nfa_ee_cb.em_state) {
     case NFA_EE_EM_STATE_INIT:
@@ -2175,12 +2547,12 @@ void nfa_ee_nci_disc_rsp(tNFA_EE_MSG* p_data) {
   if (p_evt->status == NFC_STATUS_OK) {
     nfa_ee_cb.num_ee_expecting = p_evt->num_nfcee;
     if (nfa_ee_cb.num_ee_expecting > nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED) {
-      NFA_TRACE_ERROR2("NFA-EE num_ee_expecting:%d > max:%d",
+      LOG(ERROR) << StringPrintf("NFA-EE num_ee_expecting:%d > max:%d",
                        nfa_ee_cb.num_ee_expecting, nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED);
     }
   }
   nfa_ee_report_disc_done(notify_enable_done);
-  NFA_TRACE_DEBUG3(
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "nfa_ee_nci_disc_rsp() em_state:%d cur_ee:%d num_ee_expecting:%d",
       nfa_ee_cb.em_state, nfa_ee_cb.cur_ee, nfa_ee_cb.num_ee_expecting);
 }
@@ -2203,7 +2575,7 @@ void nfa_ee_nci_disc_ntf(tNFA_EE_MSG* p_data) {
   tNFA_EE_INFO* p_info;
   tNFA_EE_EM_STATE new_em_state = NFA_EE_EM_STATE_MAX;
 
-  NFA_TRACE_DEBUG5(
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "nfa_ee_nci_disc_ntf() em_state:%d ee_flags:0x%x cur_ee:%d "
       "num_ee_expecting:%d, nfa_ee_max_ee_cfg : %d",
       nfa_ee_cb.em_state, nfa_ee_cb.ee_flags, nfa_ee_cb.cur_ee,
@@ -2245,7 +2617,7 @@ void nfa_ee_nci_disc_ntf(tNFA_EE_MSG* p_data) {
         nfa_ee_cb.cur_ee++;
         notify_new_ee = true;
       } else {
-        NFA_TRACE_DEBUG3("cur_ee:%d ecb_flags=0x%02x  ee_status=0x%x",
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("cur_ee:%d ecb_flags=0x%02x  ee_status=0x%x",
                          nfa_ee_cb.cur_ee, p_cb->ecb_flags, p_cb->ee_status);
       }
       break;
@@ -2270,7 +2642,7 @@ void nfa_ee_nci_disc_ntf(tNFA_EE_MSG* p_data) {
       }
       break;
   }
-  NFA_TRACE_DEBUG1("nfa_ee_nci_disc_ntf cur_ee:%d", nfa_ee_cb.cur_ee);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_nci_disc_ntf cur_ee:%d", nfa_ee_cb.cur_ee);
 
   if (p_cb) {
     p_cb->nfcee_id = p_ee->nfcee_id;
@@ -2296,7 +2668,7 @@ void nfa_ee_nci_disc_ntf(tNFA_EE_MSG* p_data) {
          * before enabling the NFCEE */
       }
     }
-    NFA_TRACE_DEBUG4("nfa_ee_cb.p_ee_disc_cback : %d notify_new_ee :%d "
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_cb.p_ee_disc_cback : %p notify_new_ee :%d "
     "nfa_dm_is_active() : %d p_cb->ee_status : %d", nfa_ee_cb.p_ee_disc_cback, notify_new_ee,
      nfa_dm_is_active(), p_cb->ee_status);
 
@@ -2330,7 +2702,7 @@ void nfa_ee_nci_disc_ntf(tNFA_EE_MSG* p_data) {
       nfa_ee_report_disc_done(notify_enable_done);
 
     if (p_cb->ecb_flags & NFA_EE_ECB_FLAGS_ORDER) {
-      NFA_TRACE_DEBUG0("NFA_EE_ECB_FLAGS_ORDER");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_EE_ECB_FLAGS_ORDER");
       p_cb->ecb_flags &= ~NFA_EE_ECB_FLAGS_ORDER;
       nfa_ee_report_discover_req_evt();
     }
@@ -2346,16 +2718,16 @@ void nfa_ee_nci_disc_ntf(tNFA_EE_MSG* p_data) {
     if (nfa_ee_cb.discv_timer.in_use) {
       nfa_sys_stop_timer(&nfa_ee_cb.discv_timer);
       p_data->hdr.event = NFA_EE_DISCV_TIMEOUT_EVT;
-      NFA_TRACE_DEBUG0("ee_disc_timeout");
-      nfa_ee_evt_hdlr((NFC_HDR*)p_data);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("ee_disc_timeout");
+      nfa_ee_evt_hdlr(&p_data->hdr);
     }
   }
-  NFA_TRACE_DEBUG0("after nfa_ee_nci_disc_ntf");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("after nfa_ee_nci_disc_ntf");
 #if (NXP_EXTNS == TRUE)
   if (p_cb) {
     if ((nfa_hci_cb.hci_state == NFA_HCI_STATE_WAIT_NETWK_ENABLE) &&
         (p_cb->ee_status != NFA_EE_STATUS_ACTIVE)) {
-      NFA_TRACE_DEBUG2(
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "nfa_ee_nci_disc_ntf hci_state : 0x%02x  ee_status : 0x%02x",
           nfa_hci_cb.hci_state, p_cb->ee_status);
       nfa_sys_stop_timer(&nfa_hci_cb.timer);
@@ -2363,7 +2735,7 @@ void nfa_ee_nci_disc_ntf(tNFA_EE_MSG* p_data) {
     }
   }
 #endif
-  NFA_TRACE_DEBUG0("nfa_ee_nci_disc_ntf last");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_nci_disc_ntf last");
 }
 
 /*******************************************************************************
@@ -2378,7 +2750,7 @@ void nfa_ee_nci_disc_ntf(tNFA_EE_MSG* p_data) {
 void nfa_ee_nci_nfcee_status_ntf(tNFA_EE_MSG* p_data) {
   tNFC_NFCEE_STATUS_REVT* p_ee = p_data->nfcee_status_ntf.p_data;
 
-  NFA_TRACE_DEBUG3(
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "nfa_ee_nci_nfcee_status_ntf() em_state:%d, nfcee_id:%d nfcee_status:%d",
       nfa_ee_cb.em_state, p_ee->nfcee_id, p_ee->nfcee_status);
   tNFA_EE_ECB* p_cb = nfa_ee_find_ecb(p_ee->nfcee_id);
@@ -2418,7 +2790,7 @@ void nfa_ee_check_restore_complete(void) {
     }
   }
 
-  NFA_TRACE_DEBUG2(
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "nfa_ee_check_restore_complete nfa_ee_cb.ee_cfg_sts:0x%02x "
       "proc_complete:%d",
       nfa_ee_cb.ee_cfg_sts, proc_complete);
@@ -2473,7 +2845,7 @@ static void nfa_ee_build_discover_req_evt(tNFA_EE_DISCOVER_REQ* p_evt_data) {
     p_evt_data->num_ee++;
     p_info++;
 
-    NFA_TRACE_DEBUG6(
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "[%d] ee_handle:0x%x, listen protocol A:%d, B:%d, F:%d, BP:%d",
         p_evt_data->num_ee, p_cb->nfcee_id, p_cb->la_protocol,
         p_cb->lb_protocol, p_cb->lf_protocol, p_cb->lbp_protocol);
@@ -2492,19 +2864,18 @@ static void nfa_ee_build_discover_req_evt(tNFA_EE_DISCOVER_REQ* p_evt_data) {
 **
 *******************************************************************************/
 static void nfa_ee_report_discover_req_evt(void) {
-  tNFA_EE_DISCOVER_REQ evt_data;
-
   if (nfa_ee_cb.p_enable_cback)
     (*nfa_ee_cb.p_enable_cback)(NFA_EE_DISC_STS_REQ);
 
   /* if this is restoring NFCC */
   if (!nfa_dm_is_active()) {
-    NFA_TRACE_DEBUG0("nfa_ee_report_discover_req_evt DM is not active");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_report_discover_req_evt DM is not active");
     return;
   }
 
-  nfa_ee_build_discover_req_evt(&evt_data);
-  nfa_ee_report_event(NULL, NFA_EE_DISCOVER_REQ_EVT, (void*)&evt_data);
+  tNFA_EE_CBACK_DATA nfa_ee_cback_data;
+  nfa_ee_build_discover_req_evt(&nfa_ee_cback_data.discover_req);
+  nfa_ee_report_event(NULL, NFA_EE_DISCOVER_REQ_EVT, &nfa_ee_cback_data);
 }
 #if (NXP_EXTNS == TRUE)
 /*******************************************************************************
@@ -2517,19 +2888,17 @@ static void nfa_ee_report_discover_req_evt(void) {
 **
 *******************************************************************************/
 void nfa_ee_nci_pwr_link_ctrl_rsp(tNFA_EE_MSG* p_data) {
-    NFA_TRACE_DEBUG0(" nfa_ee_nci_pwr_link_ctrl_rsp()");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(" nfa_ee_nci_pwr_link_ctrl_rsp()");
     if(nfcFL.eseFL._WIRED_MODE_STANDBY != true) {
-        NFA_TRACE_DEBUG0(" WIRED_MODE_STANDBY() not available. Returning");
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(" WIRED_MODE_STANDBY() not available. Returning");
         return;
     }
-    tNFA_EE_ECB* p_cb;
-    tNFA_EE_PWR_LNK_CTRL pwr_lnk_ctrl;
+    tNFA_EE_CBACK_DATA nfa_ee_cback_data;
     tNFC_NFCEE_EE_PWR_LNK_REVT* p_rsp = p_data->pwr_lnk_ctrl_rsp.p_data;
-    pwr_lnk_ctrl.status = p_rsp->status;
-    NFA_TRACE_DEBUG1(" nfa_ee_nci_pwr_link_ctrl_rsp: status = %d ",
-            pwr_lnk_ctrl.status);
-    nfa_ee_report_event(NULL, NFA_EE_PWR_LINK_CTRL_EVT,
-            (tNFA_EE_CBACK_DATA*)&pwr_lnk_ctrl);
+    nfa_ee_cback_data.pwr_lnk_ctrl.status = p_rsp->status;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(" nfa_ee_nci_pwr_link_ctrl_rsp: status = %d ",
+            nfa_ee_cback_data.pwr_lnk_ctrl.status);
+    nfa_ee_report_event(NULL, NFA_EE_PWR_LINK_CTRL_EVT, &nfa_ee_cback_data);
 }
 /*******************************************************************************
 **
@@ -2541,16 +2910,15 @@ void nfa_ee_nci_pwr_link_ctrl_rsp(tNFA_EE_MSG* p_data) {
 **
 *******************************************************************************/
 void nfa_ee_nci_set_mode_info(tNFA_EE_MSG* p_data) {
-  tNFA_EE_SET_MODE_INFO ee_set_mode_info;
+  tNFA_EE_CBACK_DATA nfa_ee_cback_data;
   tNFC_NFCEE_MODE_SET_INFO* p_rsp = p_data->mode_set_info.p_data;
-  ee_set_mode_info.status = p_rsp->status;
-  ee_set_mode_info.nfcee_id = p_rsp->nfcee_id;
-  NFA_TRACE_DEBUG1(" nfa_ee_nci_set_mode_info: status = %d ",
-                   ee_set_mode_info.status);
+  nfa_ee_cback_data.ee_set_mode_info.status = p_rsp->status;
+  nfa_ee_cback_data.ee_set_mode_info.nfcee_id = p_rsp->nfcee_id;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(" nfa_ee_nci_set_mode_info: status = %d ",
+                   nfa_ee_cback_data.ee_set_mode_info.status);
   if (nfa_ee_cb.p_enable_cback)
     (*nfa_ee_cb.p_enable_cback)(NFA_EE_MODE_SET_NTF);
-  nfa_ee_report_event(NULL, NFA_EE_SET_MODE_INFO_EVT,
-                      (tNFA_EE_CBACK_DATA*)&ee_set_mode_info);
+  nfa_ee_report_event(NULL, NFA_EE_SET_MODE_INFO_EVT, &nfa_ee_cback_data);
 }
 
 #endif
@@ -2568,12 +2936,12 @@ void nfa_ee_nci_mode_set_rsp(tNFA_EE_MSG* p_data) {
   tNFA_EE_MODE_SET mode_set;
   tNFC_NFCEE_MODE_SET_REVT* p_rsp = p_data->mode_set_rsp.p_data;
 
-  NFA_TRACE_DEBUG3("nfa_ee_nci_mode_set_rsp() handle:0x%02x mode:%d statu : %d",
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_nci_mode_set_rsp() handle:0x%02x mode:%d statu : %d",
                    p_rsp->nfcee_id, p_rsp->mode, p_rsp->status);
   p_cb = nfa_ee_find_ecb(p_rsp->nfcee_id);
 
   if (p_cb == NULL) {
-    NFA_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "nfa_ee_nci_mode_set_rsp() Can not find cb for handle:0x%02x",
         p_rsp->nfcee_id);
     return;
@@ -2602,7 +2970,7 @@ void nfa_ee_nci_mode_set_rsp(tNFA_EE_MSG* p_data) {
          * configuration */
         nfa_ee_cb.ee_cfged &= ~nfa_ee_ecb_to_mask(p_cb);
         nfa_ee_cb.ee_cfg_sts |= NFA_EE_STS_CHANGED_ROUTING;
-        NFA_TRACE_DEBUG0("deactivating/still configured. Force update");
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("deactivating/still configured. Force update");
       }
       p_cb->tech_switch_on = p_cb->tech_switch_off = p_cb->tech_battery_off = 0;
       p_cb->proto_switch_on = p_cb->proto_switch_off = p_cb->proto_battery_off =
@@ -2619,7 +2987,7 @@ void nfa_ee_nci_mode_set_rsp(tNFA_EE_MSG* p_data) {
       p_cb->ee_status = NFC_NFCEE_STATUS_REMOVED;
     }
   }
-  NFA_TRACE_DEBUG4("status:%d ecb_flags  :0x%02x ee_cfged:0x%02x ee_status:%d",
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("status:%d ecb_flags  :0x%02x ee_cfged:0x%02x ee_status:%d",
                    p_rsp->status, p_cb->ecb_flags, nfa_ee_cb.ee_cfged,
                    p_cb->ee_status);
   if (p_cb->ecb_flags & NFA_EE_ECB_FLAGS_RESTORE) {
@@ -2638,8 +3006,10 @@ void nfa_ee_nci_mode_set_rsp(tNFA_EE_MSG* p_data) {
     mode_set.ee_handle = (tNFA_HANDLE)p_rsp->nfcee_id | NFA_HANDLE_GROUP_EE;
     mode_set.ee_status = p_cb->ee_status;
 
+    tNFA_EE_CBACK_DATA nfa_ee_cback_data;
+    nfa_ee_cback_data.mode_set = mode_set;
     nfa_ee_report_event(p_cb->p_ee_cback, NFA_EE_MODE_SET_EVT,
-                        (void*)&mode_set);
+                        &nfa_ee_cback_data);
 
 #ifdef NXP_NCI20_DUAL_UICC
     if ((p_cb->ee_status == NFC_NFCEE_STATUS_INACTIVE) ||
@@ -2668,7 +3038,7 @@ void nfa_ee_nci_mode_set_rsp(tNFA_EE_MSG* p_data) {
 void nfa_ee_report_update_evt(void) {
   tNFA_EE_CBACK_DATA evt_data;
 
-  NFA_TRACE_DEBUG2("nfa_ee_report_update_evt ee_wait_evt:0x%x wait_rsp:%d",
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_report_update_evt ee_wait_evt:0x%x wait_rsp:%d",
                    nfa_ee_cb.ee_wait_evt, nfa_ee_cb.wait_rsp);
   if (nfa_ee_cb.wait_rsp == 0) {
     nfa_ee_cb.ee_wait_evt &= ~NFA_EE_WAIT_UPDATE_RSP;
@@ -2694,8 +3064,9 @@ void nfa_ee_report_update_evt(void) {
 void nfa_ee_nci_wait_rsp(tNFA_EE_MSG* p_data) {
   tNFA_EE_NCI_WAIT_RSP* p_rsp = &p_data->wait_rsp;
 
-  NFA_TRACE_DEBUG2("nfa_ee_nci_wait_rsp() ee_wait_evt:0x%x wait_rsp:%d",
-                   nfa_ee_cb.ee_wait_evt, nfa_ee_cb.wait_rsp);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "nfa_ee_nci_wait_rsp() ee_wait_evt:0x%x wait_rsp:%d p_rsp->opcode : %d",
+      nfa_ee_cb.ee_wait_evt, nfa_ee_cb.wait_rsp, p_rsp->opcode);
   if (nfa_ee_cb.wait_rsp) {
     if (p_rsp->opcode == NCI_MSG_RF_SET_ROUTING) nfa_ee_cb.wait_rsp--;
   }
@@ -2811,7 +3182,9 @@ void nfa_ee_nci_action_ntf(tNFA_EE_MSG* p_data) {
     nfa_ee_ce_p61_active = 0x01;
   }
 #endif
-  nfa_ee_report_event(NULL, NFA_EE_ACTION_EVT, (void*)&evt_data);
+  tNFA_EE_CBACK_DATA nfa_ee_cback_data;
+  nfa_ee_cback_data.action = evt_data;
+  nfa_ee_report_event(NULL, NFA_EE_ACTION_EVT, &nfa_ee_cback_data);
 }
 
 #if (NXP_EXTNS == TRUE)
@@ -2834,9 +3207,9 @@ uint8_t nfa_ee_get_supported_tech_list(uint8_t nfcee_id) {
     if (p_cb->lb_protocol) tech_list |= NFA_TECHNOLOGY_MASK_B;
     if (p_cb->lf_protocol) tech_list |= NFA_TECHNOLOGY_MASK_F;
   } else {
-    NFA_TRACE_DEBUG1("Cannot find cb for given nfcee_id: 0x%x", nfcee_id);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Cannot find cb for given nfcee_id: 0x%x", nfcee_id);
   }
-  NFA_TRACE_DEBUG2("supported tech list is 0x0%x for given nfcee_id: 0x%x ",
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("supported tech list is 0x0%x for given nfcee_id: 0x%x ",
                    tech_list, nfcee_id);
   return tech_list;
 }
@@ -2858,7 +3231,7 @@ void nfa_ee_nci_disc_req_ntf(tNFA_EE_MSG* p_data) {
   uint8_t report_ntf = 0;
   uint8_t xx;
 
-  NFA_TRACE_DEBUG2("nfa_ee_nci_disc_req_ntf () num_info: %d cur_ee:%d",
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_nci_disc_req_ntf () num_info: %d cur_ee:%d",
                    p_cbk->num_info, nfa_ee_cb.cur_ee);
 
   for (xx = 0; xx < p_cbk->num_info; xx++) {
@@ -2866,14 +3239,14 @@ void nfa_ee_nci_disc_req_ntf(tNFA_EE_MSG* p_data) {
 
     p_cb = nfa_ee_find_ecb(p_cbk->info[xx].nfcee_id);
     if (!p_cb) {
-      NFA_TRACE_DEBUG1("Cannot find cb for NFCEE: 0x%x",
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Cannot find cb for NFCEE: 0x%x",
                        p_cbk->info[xx].nfcee_id);
       p_cb = nfa_ee_find_ecb(NFA_EE_INVALID);
       if (p_cb) {
         p_cb->nfcee_id = p_cbk->info[xx].nfcee_id;
         p_cb->ecb_flags |= NFA_EE_ECB_FLAGS_ORDER;
       } else {
-        NFA_TRACE_ERROR1("Cannot allocate cb for NFCEE: 0x%x",
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Cannot allocate cb for NFCEE: 0x%x",
                          p_cbk->info[xx].nfcee_id);
         continue;
       }
@@ -2906,7 +3279,7 @@ void nfa_ee_nci_disc_req_ntf(tNFA_EE_MSG* p_data) {
         p_cb->pb_protocol = p_cbk->info[xx].protocol;
       }
 #endif
-      NFA_TRACE_DEBUG6(
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "nfcee_id=0x%x ee_status=0x%x ecb_flags=0x%x la_protocol=0x%x "
           "lb_protocol=0x%x lf_protocol=0x%x",
           p_cb->nfcee_id, p_cb->ee_status, p_cb->ecb_flags, p_cb->la_protocol,
@@ -2963,6 +3336,8 @@ bool nfa_ee_is_active(tNFA_HANDLE nfcee_id) {
   if ((NFA_HANDLE_GROUP_MASK & nfcee_id) == NFA_HANDLE_GROUP_EE)
     nfcee_id &= NFA_HANDLE_MASK;
 
+  if (nfcee_id == NFC_DH_ID) return true;
+
   /* compose output */
   for (xx = 0; xx < nfa_ee_cb.cur_ee; xx++, p_cb++) {
     if ((tNFA_HANDLE)p_cb->nfcee_id == nfcee_id) {
@@ -2996,7 +3371,7 @@ void nfa_ee_get_tech_route(uint8_t power_state, uint8_t* p_handles) {
       NFA_TECHNOLOGY_MASK_A, NFA_TECHNOLOGY_MASK_B, NFA_TECHNOLOGY_MASK_F,
       NFA_TECHNOLOGY_MASK_B_PRIME};
 
-  NFA_TRACE_DEBUG1("nfa_ee_get_tech_route(): power state : %d", power_state);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_get_tech_route(): power state : %d", power_state);
 
   for (xx = 0; xx < NFA_EE_MAX_TECH_ROUTE; xx++) {
     p_handles[xx] = NFC_DH_ID;
@@ -3020,7 +3395,7 @@ void nfa_ee_get_tech_route(uint8_t power_state, uint8_t* p_handles) {
       }
     }
   }
-  NFA_TRACE_DEBUG4(
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "TechA route: 0x%x, TechB route: 0x%x, TechF route: 0x%x, TechB' route: "
       "0x%x",
       p_handles[0], p_handles[1], p_handles[2], p_handles[3]);
@@ -3042,7 +3417,6 @@ void nfa_ee_check_set_routing(uint16_t new_size, int* p_max_len, uint8_t* p,
   uint8_t max_tlv = (uint8_t)((*p_max_len > NFA_EE_ROUT_MAX_TLV_SIZE)
                                   ? NFA_EE_ROUT_MAX_TLV_SIZE
                                   : *p_max_len);
-  tNFA_STATUS status = NFA_STATUS_OK;
 
   if (new_size + *p_cur_offset > max_tlv) {
     if (NFC_SetRouting(true, *p, *p_cur_offset, p + 1) == NFA_STATUS_OK) {
@@ -3060,414 +3434,6 @@ void nfa_ee_check_set_routing(uint16_t new_size, int* p_max_len, uint8_t* p,
   }
 }
 
-/*******************************************************************************
-**
-** Function         nfa_ee_route_add_one_ecb
-**
-** Description      Add the routing entries for one NFCEE/DH
-**
-** Returns          NFA_STATUS_OK, if ok to continue
-**
-*******************************************************************************/
-tNFA_STATUS nfa_ee_route_add_one_ecb(tNFA_EE_ECB* p_cb, int* p_max_len,
-                                     bool more, uint8_t* ps,
-                                     int* p_cur_offset) {
-  uint8_t* p, *pa;
-  uint16_t tlv_size;
-  uint8_t num_tlv, len;
-  int xx;
-  int start_offset;
-  uint8_t power_cfg = 0;
-  uint8_t* pp = ps + *p_cur_offset;
-  uint8_t entry_size;
-  uint8_t max_tlv;
-  uint8_t* p_start;
-  uint8_t new_size;
-  tNFA_STATUS status = NFA_STATUS_OK;
-
-  nfa_ee_check_set_routing(p_cb->size_mask, p_max_len, ps, p_cur_offset);
-  max_tlv = (uint8_t)((*p_max_len > NFA_EE_ROUT_MAX_TLV_SIZE)
-                          ? NFA_EE_ROUT_MAX_TLV_SIZE
-                          : *p_max_len);
-  /* use the first byte of the buffer (ps) to keep the num_tlv */
-  num_tlv = *ps;
-  NFA_TRACE_DEBUG5(
-      "nfa_ee_route_add_one_ecb max_len:%d, max_tlv:%d, cur_offset:%d, "
-      "more:%d, num_tlv:%d",
-      *p_max_len, max_tlv, *p_cur_offset, more, num_tlv);
-  pp = ps + 1 + *p_cur_offset;
-  p = pp;
-  tlv_size = (uint8_t)*p_cur_offset;
-/* Routing entries in the order of AID entries,protocol entries  and technology
- * entries*/
-#if ((NXP_EXTNS == TRUE) && (NFC_NXP_LISTEN_ROUTE_TBL_OPTIMIZATION == TRUE))
-  /* add the AID routing */
-  if (p_cb->nfcee_id == NFC_DH_ID && p_cb->aid_entries) {
-    start_offset = 0;
-    for (xx = 0; xx < p_cb->aid_entries; xx++) {
-      /* rememebr the beginning of this AID routing entry, just in case we need
-       * to put it in next command */
-      uint8_t route_qual = 0;
-      p_start = pp;
-      /* add one AID entry */
-      if ((p_cb->aid_rt_info[xx] & NFA_EE_AE_ROUTE) &&
-          ((nfa_ee_nfeeid_active(p_cb->aid_rt_loc[xx]) == true) ||
-           (p_cb->aid_rt_loc[xx] == NFC_DH_ID))) {
-        num_tlv++;
-        pa = &p_cb->aid_cfg[start_offset];
-        pa++;        /* EMV tag */
-        len = *pa++; /* aid_len */
-        if(p_cb->aid_info[xx] & NCI_ROUTE_QUAL_LONG_SELECT)
-          route_qual |= NCI_ROUTE_QUAL_LONG_SELECT;
-        if(p_cb->aid_info[xx] & NCI_ROUTE_QUAL_SHORT_SELECT)
-          route_qual |= NCI_ROUTE_QUAL_SHORT_SELECT;
-        *pp = NFC_ROUTE_TAG_AID | route_qual;
-         pp++;
-        *pp++ = len + 2;
-        *pp++ = p_cb->aid_rt_loc[xx];
-        *pp++ = p_cb->aid_pwr_cfg[xx];
-        /* copy the AID */
-        memcpy(pp, pa, len);
-        pp += len;
-      }
-      start_offset += p_cb->aid_len[xx];
-      new_size = (uint8_t)(pp - p_start);
-      nfa_ee_check_set_routing(new_size, p_max_len, ps, p_cur_offset);
-      if (*ps == 0 && num_tlv > 0x00) {
-        /* just sent routing command, update local */
-        *ps = 1;
-        num_tlv = *ps;
-        *p_cur_offset = new_size;
-        pp = ps + 1;
-        p = pp;
-        tlv_size = (uint8_t)*p_cur_offset;
-        max_tlv = (uint8_t)((*p_max_len > NFA_EE_ROUT_MAX_TLV_SIZE)
-                                ? NFA_EE_ROUT_MAX_TLV_SIZE
-                                : *p_max_len);
-        memcpy(p, p_start, new_size);
-        pp += new_size;
-      } else {
-        /* add the new entry */
-        *ps = num_tlv;
-        *p_cur_offset += new_size;
-      }
-    }
-  }
-
-  /* Store the Protocol based routing in temporary buffer */
-  for (xx = 0; xx < NFA_EE_NUM_PROTO; xx++) {
-    power_cfg = 0;
-    if (p_cb->proto_switch_on & nfa_ee_proto_mask_list[xx])
-      power_cfg |= NCI_ROUTE_PWR_STATE_ON;
-    if (p_cb->proto_switch_off & nfa_ee_proto_mask_list[xx])
-      power_cfg |= NCI_ROUTE_PWR_STATE_SWITCH_OFF;
-    if (p_cb->proto_battery_off & nfa_ee_proto_mask_list[xx])
-      power_cfg |= NCI_ROUTE_PWR_STATE_BATT_OFF;
-
-    if (power_cfg != 0x00) {
-        if ((nfcFL.chipType == pn547C2) && (p_cb->nfcee_id == NFC_DH_ID)) {
-            power_cfg |= NCI_ROUTE_PWR_STATE_SCREEN_ON_LOCK();
-        }
-        else {
-            if (p_cb->proto_screen_lock & nfa_ee_proto_mask_list[xx])
-                power_cfg |= NCI_ROUTE_PWR_STATE_SCREEN_ON_LOCK();
-            if (p_cb->proto_screen_off & nfa_ee_proto_mask_list[xx])
-                power_cfg |= NCI_ROUTE_PWR_STATE_SCREEN_OFF_UNLOCK();
-            if (p_cb->proto_screen_off_lock & nfa_ee_proto_mask_list[xx])
-                power_cfg |= NCI_ROUTE_PWR_STATE_SCREEN_OFF_LOCK();
-        }
-    }
-    if (power_cfg) {
-        *proto_pp = NFC_ROUTE_TAG_PROTO;
-        proto_pp++;
-        *proto_pp++ = 3;
-        *proto_pp++ = p_cb->nfcee_id;
-        *proto_pp++ = power_cfg;
-        *proto_pp++ = nfa_ee_proto_list[xx];
-        proto_tlv_ctr++;
-        if (power_cfg != NCI_ROUTE_PWR_STATE_ON)
-            nfa_ee_cb.ee_cfged |= NFA_EE_CFGED_OFF_ROUTING;
-    }
-  }
-
-  /* add NFC-DEP routing to HOST */
-  if ((p_cb->nfcee_id == NFC_DH_ID) &&
-      !(nfa_ee_cb.ee_flags & NFA_EE_FLAG_CFG_NFC_DEP)) {
-    nfa_ee_cb.ee_flags |= NFA_EE_FLAG_CFG_NFC_DEP;
-    *proto_pp++ = NFC_ROUTE_TAG_PROTO;
-    *proto_pp++ = 3;
-    *proto_pp++ = NFC_DH_ID;
-    if (gNfaProvisionMode) {
-      /* only if device is in provision mode, set power state to screen locked
-       */
-      *proto_pp++ = 0x41;
-    } else {
-      *proto_pp++ = 1;
-    }
-    *proto_pp++ = NFC_PROTOCOL_NFC_DEP;
-    proto_tlv_ctr++;
-  }
-  /* store  the Technology based routing entries in temporary buffer */
-  for (xx = 0; xx < NFA_EE_NUM_TECH; xx++) {
-    power_cfg = 0;
-    if (p_cb->tech_switch_on & nfa_ee_tech_mask_list[xx])
-      power_cfg |= NCI_ROUTE_PWR_STATE_ON;
-    if (p_cb->tech_switch_off & nfa_ee_tech_mask_list[xx])
-      power_cfg |= NCI_ROUTE_PWR_STATE_SWITCH_OFF;
-    if (p_cb->tech_battery_off & nfa_ee_tech_mask_list[xx])
-      power_cfg |= NCI_ROUTE_PWR_STATE_BATT_OFF;
-
-    if (power_cfg & NCI_ROUTE_PWR_STATE_ON) {
-      if (p_cb->tech_screen_lock & nfa_ee_tech_mask_list[xx])
-        power_cfg |= NCI_ROUTE_PWR_STATE_SCREEN_ON_LOCK();
-      if (p_cb->tech_screen_off & nfa_ee_tech_mask_list[xx])
-        power_cfg |= NCI_ROUTE_PWR_STATE_SCREEN_OFF_UNLOCK();
-      if (p_cb->tech_screen_off_lock & nfa_ee_tech_mask_list[xx])
-          power_cfg |= NCI_ROUTE_PWR_STATE_SCREEN_OFF_LOCK();
-    }
-    if (power_cfg) {
-      *tech_pp++ = NFC_ROUTE_TAG_TECH;
-      *tech_pp++ = 3;
-      *tech_pp++ = p_cb->nfcee_id;
-      *tech_pp++ = power_cfg;
-      *tech_pp++ = nfa_ee_tech_list[xx];
-      tech_tlv_ctr++;
-      if (power_cfg != NCI_ROUTE_PWR_STATE_ON)
-        nfa_ee_cb.ee_cfged |= NFA_EE_CFGED_OFF_ROUTING;
-    }
-  }
-#else /* +Routing Entries in the order: Technology, protocol and AID entries \
-         */
-  /* add the Technology based routing */
-  for (xx = 0; xx < NFA_EE_NUM_TECH; xx++) {
-    power_cfg = 0;
-    if (p_cb->tech_switch_on & nfa_ee_tech_mask_list[xx])
-      power_cfg |= NCI_ROUTE_PWR_STATE_ON;
-    if (p_cb->tech_switch_off & nfa_ee_tech_mask_list[xx])
-      power_cfg |= NCI_ROUTE_PWR_STATE_SWITCH_OFF;
-    if (p_cb->tech_battery_off & nfa_ee_tech_mask_list[xx])
-      power_cfg |= NCI_ROUTE_PWR_STATE_BATT_OFF;
-#if (NXP_EXTNS == TRUE)
-
-    if (power_cfg & NCI_ROUTE_PWR_STATE_ON) {
-      if (p_cb->tech_screen_lock & nfa_ee_tech_mask_list[xx])
-        power_cfg |= NCI_ROUTE_PWR_STATE_SCREEN_ON_LOCK();
-      if (p_cb->tech_screen_off & nfa_ee_tech_mask_list[xx])
-        power_cfg |= NCI_ROUTE_PWR_STATE_SCREEN_OFF;
-      if (p_cb->tech_screen_off_lock & nfa_ee_tech_mask_list[xx])
-          power_cfg |= NCI_ROUTE_PWR_STATE_SCREEN_OFF_LOCK();
-    }
-#endif
-    if (power_cfg) {
-      *pp++ = NFC_ROUTE_TAG_TECH;
-      *pp++ = 3;
-      *pp++ = p_cb->nfcee_id;
-      *pp++ = power_cfg;
-      *pp++ = nfa_ee_tech_list[xx];
-      num_tlv++;
-      if (power_cfg != NCI_ROUTE_PWR_STATE_ON)
-        nfa_ee_cb.ee_cfged |= NFA_EE_CFGED_OFF_ROUTING;
-    }
-  }
-
-  /* add the Protocol based routing */
-  for (xx = 0; xx < NFA_EE_NUM_PROTO; xx++) {
-    power_cfg = 0;
-    if (p_cb->proto_switch_on & nfa_ee_proto_mask_list[xx])
-      power_cfg |= NCI_ROUTE_PWR_STATE_ON;
-    if (p_cb->proto_switch_off & nfa_ee_proto_mask_list[xx])
-      power_cfg |= NCI_ROUTE_PWR_STATE_SWITCH_OFF;
-    if (p_cb->proto_battery_off & nfa_ee_proto_mask_list[xx])
-      power_cfg |= NCI_ROUTE_PWR_STATE_BATT_OFF;
-#if (NXP_EXTNS == TRUE)
-
-    if (power_cfg != 0x00) {
-        /* Blocking codes to enable protocol routing to host when screen is off.*/
-        if ((nfcFL.chipType == pn547C2) && (p_cb->nfcee_id == NFC_DH_ID)) {
-            power_cfg |= NCI_ROUTE_PWR_STATE_SCREEN_ON_LOCK();
-        }
-        else
-        {
-            if (p_cb->proto_screen_lock & nfa_ee_proto_mask_list[xx])
-                power_cfg |= NCI_ROUTE_PWR_STATE_SCREEN_ON_LOCK();
-            if (p_cb->proto_screen_off & nfa_ee_proto_mask_list[xx])
-                power_cfg |= NCI_ROUTE_PWR_STATE_SCREEN_OFF_UNLOCK();
-            if (p_cb->proto_screen_off_lock & nfa_ee_proto_mask_list[xx])
-                power_cfg |= NCI_ROUTE_PWR_STATE_SCREEN_OFF_LOCK();
-        }
-    }
-#endif
-
-    if (power_cfg) {
-      *pp = NFC_ROUTE_TAG_PROTO;
-      *pp++;
-      *pp++ = 3;
-      *pp++ = p_cb->nfcee_id;
-      *pp++ = power_cfg;
-      *pp++ = nfa_ee_proto_list[xx];
-      num_tlv++;
-      if (power_cfg != NCI_ROUTE_PWR_STATE_ON)
-        nfa_ee_cb.ee_cfged |= NFA_EE_CFGED_OFF_ROUTING;
-    }
-  }
-
-  /* add NFC-DEP routing to HOST */
-  if ((p_cb->nfcee_id == NFC_DH_ID)
-#if (NXP_EXTNS == TRUE)
-      && !(nfa_ee_cb.ee_flags & NFA_EE_FLAG_CFG_NFC_DEP)
-#endif
-          ) {
-#if (NXP_EXTNS == TRUE)
-    nfa_ee_cb.ee_flags |= NFA_EE_FLAG_CFG_NFC_DEP;
-#endif
-    *pp++ = NFC_ROUTE_TAG_PROTO;
-    *pp++ = 3;
-    *pp++ = NFC_DH_ID;
-    *pp++ = NCI_ROUTE_PWR_STATE_ON;
-    *pp++ = NFC_PROTOCOL_NFC_DEP;
-    num_tlv++;
-  }
-
-  /* update the num_tlv and current offset */
-  entry_size = (uint8_t)(pp - p);
-  *p_cur_offset += entry_size;
-  *ps = num_tlv;
-/* add the AID routing */
-#if (NXP_EXTNS == TRUE)
-  if (p_cb->nfcee_id == NFC_DH_ID && p_cb->aid_entries)
-#else
-  if (p_cb->aid_entries)
-#endif
-  {
-    start_offset = 0;
-    for (xx = 0; xx < p_cb->aid_entries; xx++) {
-      p_start =
-          pp; /* rememebr the beginning of this AID routing entry, just in case
-                 we need to put it in next command */
-/* add one AID entry */
-#if (NXP_EXTNS == TRUE)
-      if ((p_cb->aid_rt_info[xx] & NFA_EE_AE_ROUTE) &&
-          ((nfa_ee_nfeeid_active(p_cb->aid_rt_loc[xx]) == true) ||
-           (p_cb->aid_rt_loc[xx] == NFC_DH_ID)))
-#else
-      if (p_cb->aid_rt_info[xx] & NFA_EE_AE_ROUTE)
-#endif
-      {
-        num_tlv++;
-        pa = &p_cb->aid_cfg[start_offset];
-        pa++;        /* EMV tag */
-        len = *pa++; /* aid_len */
-#if (NXP_EXTNS == TRUE)
-        if(p_cb->aid_info[xx] & NCI_ROUTE_QUAL_LONG_SELECT)
-          route_qual |= NCI_ROUTE_QUAL_LONG_SELECT;
-        if(p_cb->aid_info[xx] & NCI_ROUTE_QUAL_SHORT_SELECT)
-          route_qual |= NCI_ROUTE_QUAL_SHORT_SELECT;
-        *pp = NFC_ROUTE_TAG_AID | route_qual;
-         pp++;
-#else
-        *pp++ = NFC_ROUTE_TAG_AID;
-#endif
-        *pp++ = len + 2;
-#if (NXP_EXTNS == TRUE)
-        *pp++ = p_cb->aid_rt_loc[xx];
-#else
-        *pp++ = p_cb->nfcee_id;
-#endif
-        *pp++ = p_cb->aid_pwr_cfg[xx];
-        /* copy the AID */
-        memcpy(pp, pa, len);
-        pp += len;
-      }
-      start_offset += p_cb->aid_len[xx];
-      new_size = (uint8_t)(pp - p_start);
-      nfa_ee_check_set_routing(new_size, p_max_len, ps, p_cur_offset);
-      if (*ps == 0) {
-        /* just sent routing command, update local */
-        *ps = 1;
-        num_tlv = *ps;
-        *p_cur_offset = new_size;
-        pp = ps + 1;
-        p = pp;
-        tlv_size = (uint8_t)*p_cur_offset;
-        max_tlv = (uint8_t)((*p_max_len > NFA_EE_ROUT_MAX_TLV_SIZE)
-                                ? NFA_EE_ROUT_MAX_TLV_SIZE
-                                : *p_max_len);
-        memcpy(p, p_start, new_size);
-        pp += new_size;
-      } else {
-        /* add the new entry */
-        *ps = num_tlv;
-        *p_cur_offset += new_size;
-      }
-    }
-  }
-#endif /* - Routing Entries in the order: Technology, protocol and AID entries \
-          */
-  tlv_size = nfa_ee_total_lmrt_size();
-  if (tlv_size) {
-    nfa_ee_cb.ee_cfged |= nfa_ee_ecb_to_mask(p_cb);
-  }
-  if (p_cb->ecb_flags & NFA_EE_ECB_FLAGS_ROUTING) {
-    nfa_ee_cb.ee_cfg_sts |= NFA_EE_STS_CHANGED_ROUTING;
-  }
-  NFA_TRACE_DEBUG2("ee_cfg_sts:0x%02x lmrt_size:%d", nfa_ee_cb.ee_cfg_sts,
-                   tlv_size);
-
-  if (more == false) {
-#if ((NXP_EXTNS == TRUE) && (NFC_NXP_LISTEN_ROUTE_TBL_OPTIMIZATION == TRUE))
-    /* add the protocol entries and technology entries  after AID entries*/
-    new_size = (uint8_t)(proto_pp - proto_route_buff);
-    new_size += (uint8_t)(tech_pp - tech_route_buff);
-    nfa_ee_check_set_routing(new_size, p_max_len, ps, p_cur_offset);
-    if (*ps == 0) {
-      p = ps + 1;
-      num_tlv = (proto_tlv_ctr + tech_tlv_ctr);
-    } else {
-      num_tlv += proto_tlv_ctr;
-      num_tlv += tech_tlv_ctr;
-      p = ps + 1 + *p_cur_offset;
-    }
-    if (proto_tlv_ctr != 0) {
-      new_size = (uint8_t)(proto_pp - proto_route_buff);
-      memcpy(p, proto_route_buff, new_size);
-      *p_cur_offset += new_size;
-      p = p + new_size;
-    }
-    if (tech_tlv_ctr != 0) {
-      new_size = (uint8_t)(tech_pp - tech_route_buff);
-      memcpy(p, tech_route_buff, new_size);
-      *p_cur_offset += new_size;
-    }
-#endif /* - Routing entries optimization */
-
-    /* last entry. update routing table now */
-    if (nfa_ee_cb.ee_cfg_sts & NFA_EE_STS_CHANGED_ROUTING) {
-      if (tlv_size) {
-        nfa_ee_cb.ee_cfg_sts |= NFA_EE_STS_PREV_ROUTING;
-      } else {
-        nfa_ee_cb.ee_cfg_sts &= ~NFA_EE_STS_PREV_ROUTING;
-      }
-      NFA_TRACE_DEBUG2(
-          "nfa_ee_route_add_one_ecb: set routing num_tlv:%d tlv_size:%d",
-          num_tlv, tlv_size);
-      if (NFC_SetRouting(more, num_tlv, (uint8_t)(*p_cur_offset), ps + 1) ==
-          NFA_STATUS_OK) {
-        nfa_ee_cb.wait_rsp++;
-      }
-    } else if (nfa_ee_cb.ee_cfg_sts & NFA_EE_STS_PREV_ROUTING) {
-      if (tlv_size == 0) {
-        nfa_ee_cb.ee_cfg_sts &= ~NFA_EE_STS_PREV_ROUTING;
-        /* indicated routing is configured to NFCC */
-        nfa_ee_cb.ee_cfg_sts |= NFA_EE_STS_CHANGED_ROUTING;
-        if (NFC_SetRouting(more, 0, 0, ps + 1) == NFA_STATUS_OK) {
-          nfa_ee_cb.wait_rsp++;
-        }
-      }
-    }
-  }
-
-  return status;
-}
 /*******************************************************************************
 **
 ** Function         nfa_ee_route_add_one_ecb_order
@@ -3484,7 +3450,7 @@ void nfa_ee_route_add_one_ecb_by_route_order(tNFA_EE_ECB* p_cb, int rout_type,
 
   /* use the first byte of the buffer (ps) to keep the num_tlv */
   uint8_t num_tlv = *ps;
-  NFA_TRACE_DEBUG6(
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "%s - max_len:%d, cur_offset:%d, more:%d, num_tlv:%d,rout_type:- %d",
       __func__, *p_max_len, *p_cur_offset, more, num_tlv, rout_type);
   uint8_t* pp = ps + 1 + *p_cur_offset;
@@ -3502,11 +3468,15 @@ void nfa_ee_route_add_one_ecb_by_route_order(tNFA_EE_ECB* p_cb, int rout_type,
     case NCI_ROUTE_ORDER_AID: {
       nfa_ee_add_aid_route_to_ecb(p_cb, pp, p, ps, p_cur_offset, p_max_len);
     } break;
-        case NCI_ROUTE_ORDER_PATTERN: {
+    case NCI_ROUTE_ORDER_PATTERN: {
         nfa_ee_add_apdu_route_to_ecb(p_cb, pp, p, ps, p_cur_offset, p_max_len);
     } break;
+    case NCI_ROUTE_ORDER_SYS_CODE: {
+      nfa_ee_add_sys_code_route_to_ecb(p_cb, pp, p, ps, p_cur_offset,
+                                       p_max_len);
+    } break;
     default: {
-      NFA_TRACE_DEBUG2("%s -  Route type - NA:- %d", __func__, rout_type);
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s -  Route type - NA:- %d", __func__, rout_type);
     }
   }
 
@@ -3520,7 +3490,7 @@ void nfa_ee_route_add_one_ecb_by_route_order(tNFA_EE_ECB* p_cb, int rout_type,
   if (p_cb->ecb_flags & NFA_EE_ECB_FLAGS_ROUTING) {
     nfa_ee_cb.ee_cfg_sts |= NFA_EE_STS_CHANGED_ROUTING;
   }
-  NFA_TRACE_DEBUG2("ee_cfg_sts:0x%02x lmrt_size:%d", nfa_ee_cb.ee_cfg_sts,
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("ee_cfg_sts:0x%02x lmrt_size:%d", nfa_ee_cb.ee_cfg_sts,
                    tlv_size);
 
   if (more == false) {
@@ -3531,7 +3501,7 @@ void nfa_ee_route_add_one_ecb_by_route_order(tNFA_EE_ECB* p_cb, int rout_type,
       } else {
         nfa_ee_cb.ee_cfg_sts &= ~NFA_EE_STS_PREV_ROUTING;
       }
-      NFA_TRACE_DEBUG3("%s : set routing num_tlv:%d tlv_size:%d", __func__,
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s : set routing num_tlv:%d tlv_size:%d", __func__,
                        num_tlv, tlv_size);
       if (NFC_SetRouting(more, num_tlv, (uint8_t)(*p_cur_offset), ps + 1) ==
           NFA_STATUS_OK) {
@@ -3586,21 +3556,21 @@ static bool nfa_ee_need_recfg(void) {
   tNFA_EE_ECB* p_cb;
   uint8_t mask;
 
-  NFA_TRACE_DEBUG2("nfa_ee_need_recfg() ee_cfged: 0x%02x ee_cfg_sts: 0x%02x",
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_need_recfg() ee_cfged: 0x%02x ee_cfg_sts: 0x%02x",
                    nfa_ee_cb.ee_cfged, nfa_ee_cb.ee_cfg_sts);
   /* if no routing/vs is configured, do not need to send the info to NFCC */
   if (nfa_ee_cb.ee_cfged || nfa_ee_cb.ee_cfg_sts) {
     if (nfa_ee_cb.ee_cfg_sts & NFA_EE_STS_CHANGED) {
-      NFA_TRACE_DEBUG1("%s:Routing table dirty, update required...", __func__);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s:Routing table dirty, update required...", __func__);
       needed = true;
     } else {
       p_cb = &nfa_ee_cb.ecb[NFA_EE_CB_4_DH];
       mask = 1 << NFA_EE_CB_4_DH;
       for (xx = 0; xx <= nfa_ee_cb.cur_ee; xx++) {
-        NFA_TRACE_DEBUG3("%d: ecb_flags  : 0x%02x, mask: 0x%02x", xx,
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%d: ecb_flags  : 0x%02x, mask: 0x%02x", xx,
                          p_cb->ecb_flags, mask);
         if ((p_cb->ecb_flags) && (nfa_ee_cb.ee_cfged & mask)) {
-          NFA_TRACE_DEBUG1("%s:Routing table dirty, update required...",
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s:Routing table dirty, update required...",
                            __func__);
           needed = true;
           break;
@@ -3625,11 +3595,10 @@ static bool nfa_ee_need_recfg(void) {
 ** Returns          void
 **
 *******************************************************************************/
-void nfa_ee_rout_timeout(tNFA_EE_MSG* p_data) {
+void nfa_ee_rout_timeout(__attribute__((unused)) tNFA_EE_MSG* p_data) {
   uint8_t ee_cfged = nfa_ee_cb.ee_cfged;
-  (void)p_data;
 
-  NFA_TRACE_DEBUG0("nfa_ee_rout_timeout()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_rout_timeout()");
   if (nfa_ee_need_recfg()) {
     /* Send deactivated to idle command if already not sent */
     if (nfa_dm_cb.disc_cb.disc_state != NFA_DM_RFST_IDLE)
@@ -3658,9 +3627,8 @@ void nfa_ee_rout_timeout(tNFA_EE_MSG* p_data) {
 ** Returns          void
 **
 *******************************************************************************/
-void nfa_ee_discv_timeout(tNFA_EE_MSG* p_data) {
-  (void)p_data;
-  NFA_TRACE_DEBUG0("nfa_ee_discv_timeout ()");
+void nfa_ee_discv_timeout(__attribute__((unused)) tNFA_EE_MSG* p_data) {
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_discv_timeout ()");
   if(NFA_GetNCIVersion() != NCI_VERSION_2_0)
       NFC_NfceeDiscover(false);
   if (nfa_ee_cb.p_enable_cback)
@@ -3677,7 +3645,7 @@ void nfa_ee_discv_timeout(tNFA_EE_MSG* p_data) {
 ** Returns          void
 **
 *******************************************************************************/
-void nfa_ee_lmrt_to_nfcc(tNFA_EE_MSG* p_data) {
+void nfa_ee_lmrt_to_nfcc(__attribute__((unused)) tNFA_EE_MSG* p_data) {
   int xx;
   tNFA_EE_ECB* p_cb;
   uint8_t* p = NULL;
@@ -3688,16 +3656,14 @@ void nfa_ee_lmrt_to_nfcc(tNFA_EE_MSG* p_data) {
   tNFA_STATUS status = NFA_STATUS_FAILED;
   int cur_offset;
   uint8_t max_tlv;
-  int rt;
 #if (NXP_EXTNS == TRUE)
   tNFA_EE_CBACK_DATA evt_data = {0};
 #endif
-  (void)p_data;
 
 #if (NXP_EXTNS == TRUE)
   if((nfcFL.chipType != pn547C2) &&
           (nfcFL.nfcMwFL._NFC_NXP_AID_MAX_SIZE_DYN == true)) {
-      NFA_TRACE_DEBUG1("max supported routing table size: %d",
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("max supported routing table size: %d",
               max_routing_table_size);
       /* update routing table: DH and the activated NFCEEs */
       p = (uint8_t*)GKI_getbuf(max_routing_table_size);
@@ -3711,14 +3677,15 @@ void nfa_ee_lmrt_to_nfcc(tNFA_EE_MSG* p_data) {
 #endif
 
   if (p == NULL) {
-    NFA_TRACE_ERROR0("nfa_ee_lmrt_to_nfcc() no buffer to send routing info.");
+    LOG(ERROR) << StringPrintf("nfa_ee_lmrt_to_nfcc() no buffer to send routing info.");
 #if (NXP_EXTNS == TRUE)
     evt_data.status = status;
     nfa_ee_report_event(NULL, NFA_EE_NO_MEM_ERR_EVT,
                         (tNFA_EE_CBACK_DATA*)&evt_data);
 #else
-    nfa_ee_report_event(NULL, NFA_EE_NO_MEM_ERR_EVT,
-                        (tNFA_EE_CBACK_DATA*)&status);
+    tNFA_EE_CBACK_DATA nfa_ee_cback_data;
+    nfa_ee_cback_data.status = status;
+    nfa_ee_report_event(NULL, NFA_EE_NO_MEM_ERR_EVT, &nfa_ee_cback_data);
 #endif
     return;
   }
@@ -3731,7 +3698,7 @@ void nfa_ee_lmrt_to_nfcc(tNFA_EE_MSG* p_data) {
       NFA_EE_TECH_BUFF_SIZE); /* Temporary buffer to store tech route entries */
 
   if (proto_route_buff == NULL || tech_route_buff == NULL) {
-    NFA_TRACE_ERROR0(
+    LOG(ERROR) << StringPrintf(
         "nfa_ee_lmrt_to_nfcc() no temp buffer to send routing info.");
     evt_data.status = status;
     nfa_ee_report_event(NULL, NFA_EE_NO_MEM_ERR_EVT,
@@ -3750,16 +3717,18 @@ void nfa_ee_lmrt_to_nfcc(tNFA_EE_MSG* p_data) {
     if (p_cb->ee_status == NFC_NFCEE_STATUS_ACTIVE) {
       if (last_active == NFA_EE_INVALID) {
         last_active = p_cb->nfcee_id;
-        NFA_TRACE_DEBUG1("last_active: 0x%x", last_active);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("last_active: 0x%x", last_active);
       }
     }
   }
   if (last_active == NFA_EE_INVALID) {
      check = false;
   }
+#if (NXP_EXTNS == TRUE)
   if(nfcFL.chipType != pn547C2) {
       find_and_resolve_tech_conflict();
   }
+#endif
 
   max_len = NFC_GetLmrtSize();
   max_tlv =
@@ -3771,32 +3740,29 @@ void nfa_ee_lmrt_to_nfcc(tNFA_EE_MSG* p_data) {
   for (int rt = NCI_ROUTE_ORDER_AID; rt <= NCI_ROUTE_ORDER_TECHNOLOGY; rt++) {
     /* add the routing entries for NFCEEs */
     p_cb = &nfa_ee_cb.ecb[0];
-  for (xx = 0; (xx < nfa_ee_cb.cur_ee) && check; xx++, p_cb++) {
-    if (p_cb->ee_status == NFC_NFCEE_STATUS_ACTIVE) {
-        NFA_TRACE_DEBUG1("%s --add the routing for NFCEEs!!", __func__);
+
+    for (xx = 0; (xx < nfa_ee_cb.cur_ee) && check; xx++, p_cb++) {
+      if (p_cb->ee_status == NFC_NFCEE_STATUS_ACTIVE) {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s --add the routing for NFCEEs!!", __func__);
         nfa_ee_route_add_one_ecb_by_route_order(p_cb, rt, &max_len, more, p,
                                                 &cur_offset);
       }
     }
     if (rt == NCI_ROUTE_ORDER_TECHNOLOGY) more = false;
     /* add the routing entries for DH */
-    NFA_TRACE_DEBUG1("%s --add the routing for DH!!", __func__);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s --add the routing for DH!!", __func__);
     nfa_ee_route_add_one_ecb_by_route_order(&nfa_ee_cb.ecb[NFA_EE_CB_4_DH], rt,
                                             &max_len, more, p, &cur_offset);
   }
 #if (NXP_EXTNS == TRUE)
   nfa_ee_cb.ee_flags &= ~NFA_EE_FLAG_CFG_NFC_DEP;
   evt_data.status = status;
-#endif
   if (status != NFA_STATUS_OK) {
-#if (NXP_EXTNS == TRUE)
     nfa_ee_report_event(NULL, NFA_EE_ROUT_ERR_EVT,
                         (tNFA_EE_CBACK_DATA*)&evt_data);
-#else
-    nfa_ee_report_event(NULL, NFA_EE_ROUT_ERR_EVT,
-                        (tNFA_EE_CBACK_DATA*)&status);
-#endif
   }
+#endif
+
   GKI_freebuf(p);
 #if ((NXP_EXTNS == TRUE) && (NFC_NXP_LISTEN_ROUTE_TBL_OPTIMIZATION == TRUE))
   GKI_freebuf(proto_route_buff);
@@ -3821,7 +3787,7 @@ void nfa_ee_lmrt_to_nfcc(tNFA_EE_MSG* p_data) {
 
 void find_and_resolve_tech_conflict() {
     if(nfcFL.chipType == pn547C2) {
-        NFA_TRACE_DEBUG1("%s: chipType : pn547C2. Returning", __func__);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: chipType : pn547C2. Returning", __func__);
     }
   int yy, xx;
   tNFA_EE_ECB* p_cb = nfa_ee_cb.ecb;
@@ -3831,7 +3797,7 @@ void find_and_resolve_tech_conflict() {
   bool conflict = false;
   uint8_t tech_to_rm, ee_from_rm;
 
-  NFA_TRACE_DEBUG1("%s:Enter", __func__);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s:Enter", __func__);
 
   // Finding the Technology and nfcee_id supported
   for (yy = 0; yy < nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED; yy++, p_cb++) {
@@ -3869,25 +3835,25 @@ void find_and_resolve_tech_conflict() {
     }
   }
 
-  NFA_TRACE_DEBUG5(
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "%s:p_cb->nfcee_id=0x%x,p_cb->tech_switch_on= "
       "0x%x,p_cb->tech_switch_off= 0x%x,p_cb->tech_battery_off= 0x%x",
       __func__, p_cb->nfcee_id, p_cb->tech_switch_on, p_cb->tech_switch_off,
       p_cb->tech_battery_off);
 
   // Preferred SE Selected.
-  if ((GetNumValue(NAME_DEFAULT_OFFHOST_ROUTE, &preferred_se,
-                   sizeof(preferred_se)))) {
-    NFA_TRACE_DEBUG2("%s:NXP_DEFAULT_OFFHOST_ROUTE=0x0%lu;", __func__,
+  if (NfcConfig::hasKey(NAME_DEFAULT_OFFHOST_ROUTE)) {
+    preferred_se = NfcConfig::getUnsigned(NAME_DEFAULT_OFFHOST_ROUTE);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s:NXP_DEFAULT_OFFHOST_ROUTE=0x0%lu;", __func__,
                      preferred_se);
     if (preferred_se == 0x01)
       preferred_se = 0xc0;  // Ese
     else if (preferred_se == 0x02)
       preferred_se = 0x02;  // UICC
   }
-  NFA_TRACE_DEBUG3("%s:techF_found=0x%x,techF_ee= 0x%x;", __func__, techF_found,
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s:techF_found=0x%x,techF_ee= 0x%x;", __func__, techF_found,
                    techF_ee);
-  NFA_TRACE_DEBUG3("%s:techA_found=0x%x,techA_ee= 0x%x;", __func__, techA_found,
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s:techA_found=0x%x,techA_ee= 0x%x;", __func__, techA_found,
                    techA_ee);
 
   if (techA_found == NFA_TECHNOLOGY_MASK_A &&
@@ -3899,7 +3865,7 @@ void find_and_resolve_tech_conflict() {
   }
 
   if (conflict == true) {
-    NFA_TRACE_DEBUG0("Conflict true");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Conflict true");
 
     if (techF_ee == preferred_se) {
       tech_to_rm = NFA_TECHNOLOGY_MASK_A;
@@ -3924,7 +3890,7 @@ void find_and_resolve_tech_conflict() {
         }
       }
     }
-    NFA_TRACE_DEBUG1("%s:Exit", __func__);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s:Exit", __func__);
   }
 }
 
@@ -3942,14 +3908,14 @@ void nfa_ee_update_rout(void) {
   int xx;
   tNFA_EE_ECB* p_cb;
   uint8_t mask;
-  NFC_HDR msg;
+  tNFA_EE_MSG nfa_ee_msg;
 
-  NFA_TRACE_DEBUG1("nfa_ee_update_rout ee_cfg_sts:0x%02x",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_update_rout ee_cfg_sts:0x%02x",
                    nfa_ee_cb.ee_cfg_sts);
 
   /* use action function to send routing and VS configuration to NFCC */
-  msg.event = NFA_EE_CFG_TO_NFCC_EVT;
-  nfa_ee_evt_hdlr(&msg);
+  nfa_ee_msg.hdr.event = NFA_EE_CFG_TO_NFCC_EVT;
+  nfa_ee_evt_hdlr(&nfa_ee_msg.hdr);
 
   /* all configuration is updated to NFCC, clear the status mask */
   nfa_ee_cb.ee_cfg_sts &= NFA_EE_STS_PREV;
@@ -3960,12 +3926,13 @@ void nfa_ee_update_rout(void) {
     mask = (1 << xx);
     if (p_cb->tech_switch_on | p_cb->tech_switch_off | p_cb->tech_battery_off |
         p_cb->proto_switch_on | p_cb->proto_switch_off |
-        p_cb->proto_battery_off | p_cb->aid_entries | p_cb->apdu_pattern_entries) {
+        p_cb->proto_battery_off | p_cb->aid_entries |
+        p_cb->apdu_pattern_entries | p_cb->sys_code_cfg_entries) {
       /* this entry has routing configuration. mark it configured */
       nfa_ee_cb.ee_cfged |= mask;
     }
   }
-  NFA_TRACE_DEBUG2("nfa_ee_update_rout ee_cfg_sts:0x%02x ee_cfged:0x%02x",
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_update_rout ee_cfg_sts:0x%02x ee_cfged:0x%02x",
                    nfa_ee_cb.ee_cfg_sts, nfa_ee_cb.ee_cfged);
 }
 
@@ -3980,7 +3947,7 @@ void nfa_ee_update_rout(void) {
 **
 *******************************************************************************/
 uint16_t nfa_ee_lmrt_size() {
-  NFA_TRACE_DEBUG0("nfa_ee_lmrt_size");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_lmrt_size");
   int len;
   len = nfa_all_ee_find_total_aid_len() + 2 /* tag/len */ +
         2 /*route/power state*/;
@@ -4018,7 +3985,7 @@ bool nfa_ee_nfeeid_active(uint8_t nfee_id) {
 **
 *******************************************************************************/
 uint16_t nfa_ee_find_max_aid_config_length() {
-    NFA_TRACE_DEBUG0("nfa_ee_find_max_aid_config_length");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_find_max_aid_config_length");
   /**
    * Max Routing Table Size = 720
    * After allocating size for Technology based routing and Protocol based
@@ -4044,7 +4011,7 @@ uint16_t nfa_ee_find_max_aid_config_length() {
                 NFA_EE_TOTAL_PROTO_TECH_FUTURE_EXT_ROUTE_SIZE);
     }
     else{
-        NFA_TRACE_DEBUG0("Not allowed for chip type. Returning");
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Not allowed for chip type. Returning");
         return 0;
     }
 }
@@ -4059,15 +4026,15 @@ uint16_t nfa_ee_find_max_aid_config_length() {
 **
 *******************************************************************************/
 uint16_t nfa_ee_api_get_max_aid_config_length() {
-    NFA_TRACE_DEBUG0("nfa_ee_api_get_max_aid_config_length");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_api_get_max_aid_config_length");
     if((nfcFL.chipType != pn547C2) &&
             (nfcFL.nfcMwFL._NFC_NXP_AID_MAX_SIZE_DYN == true)) {
-        NFA_TRACE_DEBUG1("nfa_ee_api_get_max_aid_config_length: %d",
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_api_get_max_aid_config_length: %d",
                 max_aid_config_length);
         return max_aid_config_length;
     }
     else{
-        NFA_TRACE_DEBUG0("Not allowed for chip type. Returning");
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Not allowed for chip type. Returning");
         return 0;
     }
 }
diff --git a/src/nfa/ee/nfa_ee_api.c b/src/nfa/ee/nfa_ee_api.cc
old mode 100644
new mode 100755
similarity index 79%
rename from src/nfa/ee/nfa_ee_api.c
rename to src/nfa/ee/nfa_ee_api.cc
index 0768366..5e8fe11
--- a/src/nfa/ee/nfa_ee_api.c
+++ b/src/nfa/ee/nfa_ee_api.cc
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -40,11 +40,17 @@
  *  NFA interface to NFCEE - API functions
  *
  ******************************************************************************/
-#include <string.h>
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfa_ee_api.h"
 #include "nfa_ee_int.h"
-#include "nfa_sys_int.h"
 #include "nfa_dm_int.h"
+#include "nfc_int.h"
+
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
 
 /*****************************************************************************
 **  APIs
@@ -68,13 +74,13 @@ tNFA_STATUS NFA_EeDiscover(tNFA_EE_CBACK* p_cback) {
   tNFA_EE_API_DISCOVER* p_msg;
   tNFA_STATUS status = NFA_STATUS_FAILED;
 
-  NFA_TRACE_API0("NFA_EeDiscover()");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
 
   if (nfa_ee_cb.em_state != NFA_EE_EM_STATE_INIT_DONE) {
-    NFA_TRACE_ERROR1("NFA_EeDiscover bad em state: %d", nfa_ee_cb.em_state);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_EeDiscover bad em state: %d", nfa_ee_cb.em_state);
     status = NFA_STATUS_FAILED;
   } else if ((nfa_ee_cb.p_ee_disc_cback != NULL) || (p_cback == NULL)) {
-    NFA_TRACE_ERROR0("NFA_EeDiscover() in progress or NULL callback function");
+    LOG(ERROR) << StringPrintf("NFA_EeDiscover() in progress or NULL callback function");
     status = NFA_STATUS_INVALID_PARAM;
   } else {
     p_msg = (tNFA_EE_API_DISCOVER*)GKI_getbuf(sizeof(tNFA_EE_API_DISCOVER));
@@ -110,23 +116,23 @@ tNFA_STATUS NFA_EeGetInfo(uint8_t* p_num_nfcee, tNFA_EE_INFO* p_info) {
   uint8_t max_ret;
   uint8_t num_ret = 0;
 
-  NFA_TRACE_DEBUG2("NFA_EeGetInfo em_state:%d cur_ee:%d", nfa_ee_cb.em_state,
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_EeGetInfo em_state:%d cur_ee:%d", nfa_ee_cb.em_state,
                    nfa_ee_cb.cur_ee);
   /* validate parameters */
   if (p_info == NULL || p_num_nfcee == NULL) {
-    NFA_TRACE_ERROR0("NFA_EeGetInfo bad parameter");
+    LOG(ERROR) << StringPrintf("NFA_EeGetInfo bad parameter");
     return (NFA_STATUS_INVALID_PARAM);
   }
   max_ret = *p_num_nfcee;
   *p_num_nfcee = 0;
   if (nfa_ee_cb.em_state == NFA_EE_EM_STATE_INIT) {
-    NFA_TRACE_ERROR1("NFA_EeGetInfo bad em state: %d", nfa_ee_cb.em_state);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_EeGetInfo bad em state: %d", nfa_ee_cb.em_state);
     return (NFA_STATUS_FAILED);
   }
 
   /* compose output */
   for (xx = 0; (xx < ret) && (num_ret < max_ret); xx++, p_cb++) {
-    NFA_TRACE_DEBUG4("xx:%d max_ret:%d, num_ret:%d ee_status:0x%x", xx, max_ret,
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("xx:%d max_ret:%d, num_ret:%d ee_status:0x%x", xx, max_ret,
                      num_ret, p_cb->ee_status);
     if ((p_cb->ee_status & NFA_EE_STATUS_INT_MASK) ||
         (p_cb->ee_status == NFA_EE_STATUS_REMOVED)) {
@@ -149,7 +155,7 @@ tNFA_STATUS NFA_EeGetInfo(uint8_t* p_num_nfcee, tNFA_EE_INFO* p_info) {
     p_info++;
     num_ret++;
   }
-  NFA_TRACE_DEBUG1("num_ret:%d", num_ret);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("num_ret:%d", num_ret);
   *p_num_nfcee = num_ret;
   return (NFA_STATUS_OK);
 }
@@ -175,23 +181,23 @@ tNFA_STATUS NFA_AllEeGetInfo(uint8_t* p_num_nfcee, tNFA_EE_INFO* p_info) {
   uint8_t max_ret;
   uint8_t num_ret = 0;
 
-  NFA_TRACE_DEBUG2("NFA_AllEeGetInfo em_state:%d cur_ee:%d", nfa_ee_cb.em_state,
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_AllEeGetInfo em_state:%d cur_ee:%d", nfa_ee_cb.em_state,
                    nfa_ee_cb.cur_ee);
   /* validate parameters */
   if (p_info == NULL || p_num_nfcee == NULL) {
-    NFA_TRACE_ERROR0("NFA_AllEeGetInfo bad parameter");
+    LOG(ERROR) << StringPrintf("NFA_AllEeGetInfo bad parameter");
     return (NFA_STATUS_INVALID_PARAM);
   }
   max_ret = *p_num_nfcee;
   *p_num_nfcee = 0;
   if (nfa_ee_cb.em_state == NFA_EE_EM_STATE_INIT) {
-    NFA_TRACE_ERROR1("NFA_AllEeGetInfo bad em state: %d", nfa_ee_cb.em_state);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_AllEeGetInfo bad em state: %d", nfa_ee_cb.em_state);
     return (NFA_STATUS_FAILED);
   }
 
   /* compose output */
   for (xx = 0; (xx < ret) && (num_ret < max_ret); xx++, p_cb++) {
-    NFA_TRACE_DEBUG6("xx:%d max_ret:%d, num_ret:%d ee_status:0x%x num_interface :%d p_cb->nfcee_id : %d", xx, max_ret,
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("xx:%d max_ret:%d, num_ret:%d ee_status:0x%x num_interface :%d p_cb->nfcee_id : %d", xx, max_ret,
                      num_ret, p_cb->ee_status, p_cb->num_interface, p_cb->nfcee_id);
     if (p_cb->ee_status & NFA_EE_STATUS_INT_MASK) {
       continue;
@@ -212,7 +218,7 @@ tNFA_STATUS NFA_AllEeGetInfo(uint8_t* p_num_nfcee, tNFA_EE_INFO* p_info) {
     p_info++;
     num_ret++;
   }
-  NFA_TRACE_DEBUG1("num_ret:%d", num_ret);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("num_ret:%d", num_ret);
   *p_num_nfcee = num_ret;
   return (NFA_STATUS_OK);
 }
@@ -227,7 +233,7 @@ tNFA_STATUS NFA_AllEeGetInfo(uint8_t* p_num_nfcee, tNFA_EE_INFO* p_info) {
 **
 *******************************************************************************/
 void NFA_setProvisionMode(bool provisionMode) {
-  NFA_TRACE_API1("NFA_setProvisionMode(), provisionMode:%d", provisionMode);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_setProvisionMode(), provisionMode:%d", provisionMode);
   gNfaProvisionMode = provisionMode;
 }
 #endif
@@ -248,10 +254,10 @@ tNFA_STATUS NFA_EeRegister(tNFA_EE_CBACK* p_cback) {
   tNFA_EE_API_REGISTER* p_msg;
   tNFA_STATUS status = NFA_STATUS_FAILED;
 
-  NFA_TRACE_API0("NFA_EeRegister()");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
 
   if (p_cback == NULL) {
-    NFA_TRACE_ERROR0("NFA_EeRegister(): with NULL callback function");
+    LOG(ERROR) << StringPrintf("NFA_EeRegister(): with NULL callback function");
     status = NFA_STATUS_INVALID_PARAM;
   } else {
     p_msg = (tNFA_EE_API_REGISTER*)GKI_getbuf(sizeof(tNFA_EE_API_REGISTER));
@@ -293,7 +299,7 @@ tNFA_STATUS NFA_EeDeregister(tNFA_EE_CBACK* p_cback) {
     }
   }
 
-  NFA_TRACE_API2("NFA_EeDeregister() %d, status:%d", index, status);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_EeDeregister() %d, status:%d", index, status);
   if ((status != NFA_STATUS_INVALID_PARAM) &&
       (p_msg = (tNFA_EE_API_DEREGISTER*)GKI_getbuf(
            sizeof(tNFA_EE_API_DEREGISTER))) != NULL) {
@@ -324,7 +330,7 @@ tNFA_STATUS NFA_EeDeregister(tNFA_EE_CBACK* p_cback) {
 tNFA_STATUS NFA_SendPowerLinkCommand(uint8_t nfcee_id, uint8_t cfg_value) {
   tNFA_EE_API_POWER_LINK_EVT* p_msg;
 
-  NFA_TRACE_API1("NFA_SendPowerLinkCommand() nfcee_id=0x%x", nfcee_id);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_SendPowerLinkCommand() nfcee_id=0x%x", nfcee_id);
 
   if ((p_msg = (tNFA_EE_API_POWER_LINK_EVT*)GKI_getbuf(sizeof(tNFA_EE_API_POWER_LINK_EVT))) != NULL) {
     p_msg->hdr.event = NFA_EE_NCI_PWR_LNK_CTRL_SET_EVT;
@@ -367,11 +373,11 @@ tNFA_STATUS NFA_EeModeSet(tNFA_HANDLE ee_handle, tNFA_EE_MD mode) {
       break;
     }
   }
-  NFA_TRACE_API2("NFA_EeModeSet(): handle:<0x%x>, mode:0x%02X", ee_handle,
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_EeModeSet(): handle:<0x%x>, mode:0x%02X", ee_handle,
                  mode);
 
   if (p_found == NULL) {
-    NFA_TRACE_ERROR1("NFA_EeModeSet() invalid NFCEE:0x%04x", ee_handle);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_EeModeSet() invalid NFCEE:0x%04x", ee_handle);
     status = NFA_STATUS_INVALID_PARAM;
   } else {
     p_msg = (tNFA_EE_API_MODE_SET*)GKI_getbuf(sizeof(tNFA_EE_API_MODE_SET));
@@ -414,38 +420,26 @@ tNFA_STATUS NFA_EeModeSet(tNFA_HANDLE ee_handle, tNFA_EE_MD mode) {
 tNFA_STATUS NFA_EeSetDefaultTechRouting(
     tNFA_HANDLE ee_handle, tNFA_TECHNOLOGY_MASK technologies_switch_on,
     tNFA_TECHNOLOGY_MASK technologies_switch_off,
-    tNFA_TECHNOLOGY_MASK technologies_battery_off
-#if (NXP_EXTNS == TRUE)
-    ,
+    tNFA_TECHNOLOGY_MASK technologies_battery_off,
     tNFA_TECHNOLOGY_MASK technologies_screen_lock,
     tNFA_TECHNOLOGY_MASK technologies_screen_off,
-    tNFA_TECHNOLOGY_MASK technologies_screen_off_lock
-#endif
-    ) {
+    tNFA_TECHNOLOGY_MASK technologies_screen_off_lock) {
   tNFA_EE_API_SET_TECH_CFG* p_msg;
   tNFA_STATUS status = NFA_STATUS_FAILED;
   uint8_t nfcee_id = (uint8_t)(ee_handle & 0xFF);
   tNFA_EE_ECB* p_cb;
 
-#if (NXP_EXTNS == TRUE)
-  NFA_TRACE_API6(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "NFA_EeSetDefaultTechRouting(): "
-      "handle:<0x%x>technology_mask:<0x%x>/<0x%x>/<0x%x><0x%x><0x%x>",
+      "handle:<0x%x>technology_mask:<0x%x>/<0x%x>/<0x%x><0x%x><0x%x><0x%x>",
       ee_handle, technologies_switch_on, technologies_switch_off,
       technologies_battery_off, technologies_screen_lock,
-      technologies_screen_off);
-#else
-  NFA_TRACE_API4(
-      "NFA_EeSetDefaultTechRouting(): "
-      "handle:<0x%x>technology_mask:<0x%x>/<0x%x>/<0x%x>",
-      ee_handle, technologies_switch_on, technologies_switch_off,
-      technologies_battery_off);
-#endif
+      technologies_screen_off, technologies_screen_off_lock);
 
   p_cb = nfa_ee_find_ecb(nfcee_id);
 
   if (p_cb == NULL) {
-    NFA_TRACE_ERROR0("Bad ee_handle");
+    LOG(ERROR) << StringPrintf("Bad ee_handle");
     status = NFA_STATUS_INVALID_PARAM;
   } else {
     p_msg =
@@ -457,11 +451,9 @@ tNFA_STATUS NFA_EeSetDefaultTechRouting(
       p_msg->technologies_switch_on = technologies_switch_on;
       p_msg->technologies_switch_off = technologies_switch_off;
       p_msg->technologies_battery_off = technologies_battery_off;
-#if (NXP_EXTNS == TRUE)
       p_msg->technologies_screen_lock = technologies_screen_lock;
       p_msg->technologies_screen_off = technologies_screen_off;
       p_msg->technologies_screen_off_lock = technologies_screen_off_lock;
-#endif
       nfa_sys_sendmsg(p_msg);
 
       status = NFA_STATUS_OK;
@@ -494,37 +486,25 @@ tNFA_STATUS NFA_EeSetDefaultTechRouting(
 tNFA_STATUS NFA_EeSetDefaultProtoRouting(
     tNFA_HANDLE ee_handle, tNFA_PROTOCOL_MASK protocols_switch_on,
     tNFA_PROTOCOL_MASK protocols_switch_off,
-    tNFA_PROTOCOL_MASK protocols_battery_off
-#if (NXP_EXTNS == TRUE)
-    ,
+    tNFA_PROTOCOL_MASK protocols_battery_off,
     tNFA_PROTOCOL_MASK protocols_screen_lock,
     tNFA_PROTOCOL_MASK protocols_screen_off,
-    tNFA_PROTOCOL_MASK protocols_screen_off_lock
-#endif
-    ) {
+    tNFA_PROTOCOL_MASK protocols_screen_off_lock) {
   tNFA_EE_API_SET_PROTO_CFG* p_msg;
   tNFA_STATUS status = NFA_STATUS_FAILED;
   uint8_t nfcee_id = (uint8_t)(ee_handle & 0xFF);
   tNFA_EE_ECB* p_cb;
 
-#if (NXP_EXTNS == TRUE)
-  NFA_TRACE_API6(
-      "NFA_EeSetDefaultProtoRouting(): "
-      "handle:<0x%x>protocol_mask:<0x%x>/<0x%x>/<0x%x><0x%x><0x%x>",
-      ee_handle, protocols_switch_on, protocols_switch_off,
-      protocols_battery_off, protocols_screen_lock, protocols_screen_off);
-#else
-  NFA_TRACE_API4(
-      "NFA_EeSetDefaultProtoRouting(): "
-      "handle:<0x%x>protocol_mask:<0x%x>/<0x%x>/<0x%x>",
-      ee_handle, protocols_switch_on, protocols_switch_off,
-      protocols_battery_off);
-#endif
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_EeSetDefaultProtoRouting():\
+              handle:<0x%x>protocol_mask:<0x%x>/<0x%x>/<0x%x><0x%x><0x%x><0x%x>",
+              ee_handle, protocols_switch_on, protocols_switch_off,
+              protocols_battery_off, protocols_screen_lock,
+              protocols_screen_off, protocols_screen_off_lock);
 
   p_cb = nfa_ee_find_ecb(nfcee_id);
 
   if (p_cb == NULL) {
-    NFA_TRACE_ERROR0("Bad ee_handle");
+    LOG(ERROR) << StringPrintf("Bad ee_handle");
     status = NFA_STATUS_INVALID_PARAM;
   } else {
     p_msg = (tNFA_EE_API_SET_PROTO_CFG*)GKI_getbuf(
@@ -536,11 +516,9 @@ tNFA_STATUS NFA_EeSetDefaultProtoRouting(
       p_msg->protocols_switch_on = protocols_switch_on;
       p_msg->protocols_switch_off = protocols_switch_off;
       p_msg->protocols_battery_off = protocols_battery_off;
-#if (NXP_EXTNS == TRUE)
       p_msg->protocols_screen_lock = protocols_screen_lock;
       p_msg->protocols_screen_off = protocols_screen_off;
       p_msg->protocols_screen_off_lock = protocols_screen_off_lock;
-#endif
       nfa_sys_sendmsg(p_msg);
 
       status = NFA_STATUS_OK;
@@ -570,47 +548,50 @@ tNFA_STATUS NFA_EeSetDefaultProtoRouting(
 **
 *******************************************************************************/
 tNFA_STATUS NFA_EeAddAidRouting(tNFA_HANDLE ee_handle, uint8_t aid_len,
-                                uint8_t* p_aid, tNFA_EE_PWR_STATE power_state
-#if (NXP_EXTNS == TRUE)
-                                ,
-                                uint8_t aidInfo)
-#else
-                                )
-#endif
-{
+                                uint8_t* p_aid, tNFA_EE_PWR_STATE power_state,
+                                uint8_t aidInfo) {
   tNFA_EE_API_ADD_AID* p_msg;
   tNFA_STATUS status = NFA_STATUS_FAILED;
   uint16_t size = sizeof(tNFA_EE_API_ADD_AID) + aid_len;
   uint8_t nfcee_id = (uint8_t)(ee_handle & 0xFF);
   tNFA_EE_ECB* p_cb;
-  NFA_TRACE_API1("NFA_EeAddAidRouting(): handle:<0x%x>", ee_handle);
+
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_EeAddAidRouting(): handle:<0x%x>", ee_handle);
   p_cb = nfa_ee_find_ecb(nfcee_id);
 
   /* validate parameters - make sure the AID is in valid length range */
+#if (NXP_EXTNS == TRUE)
   if ((p_cb == NULL) || ((NFA_GetNCIVersion() == NCI_VERSION_2_0) && (aid_len != 0) && (p_aid == NULL)) ||
           ((NFA_GetNCIVersion() != NCI_VERSION_2_0) &&
                   ((aid_len == 0) || (p_aid == NULL) || (aid_len < NFA_MIN_AID_LEN))) ||
                   (aid_len > NFA_MAX_AID_LEN)) {
-    NFA_TRACE_ERROR1("Bad ee_handle or AID (len=%d)", aid_len);
+#else
+  if ((p_cb == NULL) || (aid_len == 0) || (p_aid == NULL) ||
+      (aid_len < NFA_MIN_AID_LEN) || (aid_len > NFA_MAX_AID_LEN)) {
+#endif
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Bad ee_handle or AID (len=%d)", aid_len);
     status = NFA_STATUS_INVALID_PARAM;
   } else {
     p_msg = (tNFA_EE_API_ADD_AID*)GKI_getbuf(size);
     if (p_msg != NULL) {
+#if (NXP_EXTNS == TRUE)
         if(p_aid != NULL) {
-            NFA_TRACE_DEBUG2("aid:<%02x%02x>", p_aid[0], p_aid[1]);
+             DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("aid:<%02x%02x>", p_aid[0], p_aid[1]);
         }
+#else
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("aid:<%02x%02x>", p_aid[0], p_aid[1]);
+#endif
       p_msg->hdr.event = NFA_EE_API_ADD_AID_EVT;
       p_msg->nfcee_id = nfcee_id;
       p_msg->p_cb = p_cb;
       p_msg->aid_len = aid_len;
       p_msg->power_state = power_state;
       p_msg->p_aid = (uint8_t*)(p_msg + 1);
+      p_msg->aidInfo = aidInfo;
 #if (NXP_EXTNS == TRUE)
-      p_msg->aid_info = aidInfo;
+      if(p_aid != NULL)
 #endif
-      if(p_aid != NULL) {
-      memcpy(p_msg->p_aid, p_aid, aid_len);
-      }
+        memcpy(p_msg->p_aid, p_aid, aid_len);
       nfa_sys_sendmsg(p_msg);
 
       status = NFA_STATUS_OK;
@@ -647,15 +628,19 @@ tNFA_STATUS NFA_EeAddApduPatternRouting(uint8_t apdu_data_len,uint8_t* apdu_data
   uint16_t size = sizeof(tNFA_EE_API_ADD_AID) + apdu_data_len + apdu_mask_len;
   uint8_t nfcee_id = (uint8_t)(ee_handle & 0xFF);
 
-  NFA_TRACE_API1("NFA_EeAddApduRouting(): handle:<0x%x>", ee_handle);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_EeAddApduRouting(): handle:<0x%x>", ee_handle);
   p_cb = nfa_ee_find_ecb(nfcee_id);
   if(p_cb == NULL || apdu_data_len == 0 || apdu_mask_len == 0 || apdu_data == NULL
       || apdu_mask == NULL || apdu_data_len > NFC_MAX_APDU_DATA_LEN
       || apdu_mask_len > NFC_MAX_APDU_MASK_LEN || apdu_data_len != apdu_mask_len) {
-    NFA_TRACE_ERROR1("Bad ee_handle or AID (len=%d)", apdu_data_len+apdu_mask_len);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Bad ee_handle or AID (len=%d)", apdu_data_len+apdu_mask_len);
     status = NFA_STATUS_INVALID_PARAM;
   } else {
       p_msg = (tNFA_EE_API_ADD_APDU*)GKI_getbuf(size);
+      if (p_msg == NULL) {
+	LOG(ERROR) << StringPrintf("%s: failed to allocate memory\n",__func__);
+	return NFA_STATUS_FAILED;
+      }
       p_msg->hdr.event = NFA_EE_API_ADD_APDU_EVT;
       p_msg->apdu_len = apdu_data_len;
       p_msg->mask_len = apdu_mask_len;
@@ -701,7 +686,7 @@ tNFA_STATUS NFA_AddEePowerState(tNFA_HANDLE ee_handle,
   tNFA_EE_ECB* p_cb;
   uint8_t xx = 0;
 
-  NFA_TRACE_API1("NFA_AddEePowerState(): handle:<0x%x>", ee_handle);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_AddEePowerState(): handle:<0x%x>", ee_handle);
   p_cb = nfa_ee_find_ecb(nfcee_id);
 
   /* validate parameters */
@@ -825,9 +810,9 @@ tNFA_STATUS NFA_EeRemoveAidRouting(uint8_t aid_len, uint8_t* p_aid) {
   tNFA_STATUS status = NFA_STATUS_FAILED;
   uint16_t size = sizeof(tNFA_EE_API_REMOVE_AID) + aid_len;
 
-  NFA_TRACE_API0("NFA_EeRemoveAidRouting()");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
   if ((aid_len == 0) || (p_aid == NULL) || (aid_len > NFA_MAX_AID_LEN)) {
-    NFA_TRACE_ERROR0("Bad AID");
+    LOG(ERROR) << StringPrintf("Bad AID");
     status = NFA_STATUS_INVALID_PARAM;
   } else {
     p_msg = (tNFA_EE_API_REMOVE_AID*)GKI_getbuf(size);
@@ -872,9 +857,9 @@ tNFA_STATUS NFA_EeRemoveApduPatternRouting(uint8_t apdu_len, uint8_t* p_apdu) {
   tNFA_STATUS status = NFA_STATUS_FAILED;
   uint16_t size = sizeof(tNFA_EE_API_REMOVE_APDU) + apdu_len;
 
-  NFA_TRACE_API0("NFA_EeRemoveApduPatternRouting()");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
   if ((apdu_len == 0) || (p_apdu == NULL) || (apdu_len > NFC_MAX_APDU_DATA_LEN)) {
-    NFA_TRACE_ERROR0("Bad handle");
+    LOG(ERROR) << StringPrintf("Bad handle");
     status = NFA_STATUS_INVALID_PARAM;
   } else {
     p_msg = (tNFA_EE_API_REMOVE_APDU*)GKI_getbuf(size);
@@ -892,6 +877,103 @@ tNFA_STATUS NFA_EeRemoveApduPatternRouting(uint8_t apdu_len, uint8_t* p_apdu) {
   return status;
 }
 
+/*******************************************************************************
+**
+** Function         NFA_EeAddSystemCodeRouting
+**
+** Description      This function is called to add an system code entry in the
+**                  listen mode routing table in NFCC. The status of this
+**                  operation is reported as the NFA_EE_ADD_SYSCODE_EVT.
+**
+** Note:            If RF discovery is started,
+**                  NFA_StopRfDiscovery()/NFA_RF_DISCOVERY_STOPPED_EVT should
+**                  happen before calling this function
+**
+** Note:            NFA_EeUpdateNow() should be called after last NFA-EE
+**                  function to change the listen mode routing is called.
+**
+** Returns          NFA_STATUS_OK if successfully initiated
+**                  NFA_STATUS_FAILED otherwise
+**                  NFA_STATUS_INVALID_PARAM If bad parameter
+**
+*******************************************************************************/
+tNFA_STATUS NFA_EeAddSystemCodeRouting(uint16_t systemcode,
+                                       tNFA_HANDLE ee_handle,
+                                       tNFA_EE_PWR_STATE power_state) {
+  tNFA_STATUS status = NFA_STATUS_FAILED;
+  uint8_t nfcee_id = (uint8_t)(ee_handle & 0xFF);
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << StringPrintf("NFA_EeAddSystemCodeRouting(): handle:<0x%x>", ee_handle);
+  tNFA_EE_ECB* p_cb = nfa_ee_find_ecb(nfcee_id);
+
+  if (p_cb == NULL || systemcode == 0) {
+    LOG(ERROR) << StringPrintf("Bad ee_handle or System Code");
+    status = NFA_STATUS_INVALID_PARAM;
+  } else if ((NFA_GetNCIVersion() != NCI_VERSION_2_0) &&
+             (nfc_cb.isScbrSupported == false)) {
+    LOG(ERROR) << StringPrintf("Invalid NCI Version/SCBR not supported");
+    status = NFA_STATUS_NOT_SUPPORTED;
+  } else {
+    tNFA_EE_API_ADD_SYSCODE* p_msg =
+        (tNFA_EE_API_ADD_SYSCODE*)GKI_getbuf(sizeof(tNFA_EE_API_ADD_SYSCODE));
+    if (p_msg != NULL) {
+      p_msg->hdr.event = NFA_EE_API_ADD_SYSCODE_EVT;
+      p_msg->power_state = power_state;
+      p_msg->nfcee_id = nfcee_id;
+      p_msg->p_cb = p_cb;
+      // adjust endianness of syscode
+      p_msg->syscode = (systemcode & 0x00FF) << 8 | (systemcode & 0xFF00) >> 8;
+      nfa_sys_sendmsg(p_msg);
+      status = NFA_STATUS_OK;
+    }
+  }
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         NFA_EeRemoveSystemCodeRouting
+**
+** Description      This function is called to remove the given System Code
+**                  based entry from the listen mode routing table. The status
+**                  of this operation is reported as the
+**                  NFA_EE_REMOVE_SYSCODE_EVT.
+**
+** Note:            If RF discovery is started,
+**                  NFA_StopRfDiscovery()/NFA_RF_DISCOVERY_STOPPED_EVT should
+**                  happen before calling this function
+**
+** Note:            NFA_EeUpdateNow() should be called after last NFA-EE
+**                  function to change the listen mode routing is called.
+**
+** Returns          NFA_STATUS_OK if successfully initiated
+**                  NFA_STATUS_FAILED otherwise
+**                  NFA_STATUS_INVALID_PARAM If bad parameter
+**
+*******************************************************************************/
+tNFA_STATUS NFA_EeRemoveSystemCodeRouting(uint16_t systemcode) {
+  tNFA_STATUS status = NFA_STATUS_FAILED;
+
+  if (systemcode == 0) {
+    LOG(ERROR) << "Bad ee_handle or System Code";
+    status = NFA_STATUS_INVALID_PARAM;
+  } else if ((NFA_GetNCIVersion() != NCI_VERSION_2_0) &&
+             (nfc_cb.isScbrSupported == false)) {
+    LOG(ERROR) << "Invalid NCI Version/SCBR Not supported";
+    status = NFA_STATUS_NOT_SUPPORTED;
+  } else {
+    tNFA_EE_API_REMOVE_SYSCODE* p_msg = (tNFA_EE_API_REMOVE_SYSCODE*)GKI_getbuf(
+        sizeof(tNFA_EE_API_REMOVE_SYSCODE));
+    if (p_msg != NULL) {
+      p_msg->hdr.event = NFA_EE_API_REMOVE_SYSCODE_EVT;
+      p_msg->syscode = (systemcode & 0x00FF) << 8 | (systemcode & 0xFF00) >> 8;
+      nfa_sys_sendmsg(p_msg);
+      status = NFA_STATUS_OK;
+    }
+  }
+  return status;
+}
+
 /*******************************************************************************
 **
 ** Function         NFA_EeGetLmrtRemainingSize
@@ -908,7 +990,7 @@ tNFA_STATUS NFA_EeGetLmrtRemainingSize(void) {
   tNFA_EE_API_LMRT_SIZE* p_msg;
   tNFA_STATUS status = NFA_STATUS_FAILED;
 
-  NFA_TRACE_API0("NFA_EeGetLmrtRemainingSize()");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
   p_msg = (tNFA_EE_API_LMRT_SIZE*)GKI_getbuf(sizeof(tNFA_EE_API_LMRT_SIZE));
   if (p_msg != NULL) {
     p_msg->event = NFA_EE_API_LMRT_SIZE_EVT;
@@ -938,10 +1020,9 @@ tNFA_STATUS NFA_EeGetLmrtRemainingSize(void) {
 tNFA_STATUS NFA_EeUpdateNow(void) {
   NFC_HDR* p_msg;
   tNFA_STATUS status = NFA_STATUS_FAILED;
-
-  NFA_TRACE_API0("NFA_EeUpdateNow()");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
   if (nfa_ee_cb.ee_wait_evt & NFA_EE_WAIT_UPDATE_ALL) {
-    NFA_TRACE_ERROR0("update in progress");
+    LOG(ERROR) << StringPrintf("update in progress");
     status = NFA_STATUS_SEMANTIC_ERROR;
   } else {
     p_msg = (NFC_HDR*)GKI_getbuf(NFC_HDR_SIZE);
@@ -978,12 +1059,12 @@ tNFA_STATUS NFA_EeConnect(tNFA_HANDLE ee_handle, uint8_t ee_interface,
   uint8_t nfcee_id = (uint8_t)(ee_handle & 0xFF);
   tNFA_EE_ECB* p_cb;
 
-  NFA_TRACE_API2("NFA_EeConnect(): handle:<0x%x> ee_interface:0x%x", ee_handle,
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_EeConnect(): handle:<0x%x> ee_interface:0x%x", ee_handle,
                  ee_interface);
   p_cb = nfa_ee_find_ecb(nfcee_id);
 
   if ((p_cb == NULL) || (p_cback == NULL)) {
-    NFA_TRACE_ERROR0("Bad ee_handle or NULL callback function");
+    LOG(ERROR) << StringPrintf("Bad ee_handle or NULL callback function");
     status = NFA_STATUS_INVALID_PARAM;
   } else {
     p_msg = (tNFA_EE_API_CONNECT*)GKI_getbuf(sizeof(tNFA_EE_API_CONNECT));
@@ -1024,13 +1105,13 @@ tNFA_STATUS NFA_EeSendData(tNFA_HANDLE ee_handle, uint16_t data_len,
   uint8_t nfcee_id = (uint8_t)(ee_handle & 0xFF);
   tNFA_EE_ECB* p_cb;
 
-  NFA_TRACE_API1("NFA_EeSendData(): handle:<0x%x>", ee_handle);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_EeSendData(): handle:<0x%x>", ee_handle);
 
   p_cb = nfa_ee_find_ecb(nfcee_id);
 
   if ((p_cb == NULL) || (p_cb->conn_st != NFA_EE_CONN_ST_CONN) ||
       (p_data == NULL)) {
-    NFA_TRACE_ERROR0("Bad ee_handle or NULL data");
+    LOG(ERROR) << StringPrintf("Bad ee_handle or NULL data");
     status = NFA_STATUS_INVALID_PARAM;
   } else {
     p_msg = (tNFA_EE_API_SEND_DATA*)GKI_getbuf(
@@ -1071,11 +1152,11 @@ tNFA_STATUS NFA_EeDisconnect(tNFA_HANDLE ee_handle) {
   uint8_t nfcee_id = (uint8_t)(ee_handle & 0xFF);
   tNFA_EE_ECB* p_cb;
 
-  NFA_TRACE_API1("NFA_EeDisconnect(): handle:<0x%x>", ee_handle);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_EeDisconnect(): handle:<0x%x>", ee_handle);
   p_cb = nfa_ee_find_ecb(nfcee_id);
 
   if ((p_cb == NULL) || (p_cb->conn_st != NFA_EE_CONN_ST_CONN)) {
-    NFA_TRACE_ERROR0("NFA_EeDisconnect() Bad ee_handle");
+    LOG(ERROR) << StringPrintf("NFA_EeDisconnect() Bad ee_handle");
     status = NFA_STATUS_INVALID_PARAM;
   } else {
     p_msg = (tNFA_EE_API_DISCONNECT*)GKI_getbuf(sizeof(tNFA_EE_API_DISCONNECT));
diff --git a/src/nfa/ee/nfa_ee_main.c b/src/nfa/ee/nfa_ee_main.cc
old mode 100644
new mode 100755
similarity index 89%
rename from src/nfa/ee/nfa_ee_main.c
rename to src/nfa/ee/nfa_ee_main.cc
index adcd6b2..d2f0008
--- a/src/nfa/ee/nfa_ee_main.c
+++ b/src/nfa/ee/nfa_ee_main.cc
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -40,14 +40,18 @@
  *
  ******************************************************************************/
 #include <string.h>
-#include "nfc_api.h"
-#include "nfa_sys.h"
-#include "nfa_sys_int.h"
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfa_dm_int.h"
 #include "nfa_ee_int.h"
-#include "config.h"
+#include "nfc_config.h"
+
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
 
-extern void nfa_ee_vs_cback(tNFC_VS_EVT event, NFC_HDR* p_data);
 /*****************************************************************************
 **  Global Variables
 *****************************************************************************/
@@ -80,6 +84,8 @@ const tNFA_EE_SM_ACT nfa_ee_actions[] = {
     nfa_ee_api_set_proto_cfg, /* NFA_EE_API_SET_PROTO_CFG_EVT */
     nfa_ee_api_add_aid,       /* NFA_EE_API_ADD_AID_EVT       */
     nfa_ee_api_remove_aid,    /* NFA_EE_API_REMOVE_AID_EVT    */
+    nfa_ee_api_add_sys_code,  /* NFA_EE_API_ADD_SYSCODE_EVT   */
+    nfa_ee_api_remove_sys_code,/* NFA_EE_API_REMOVE_SYSCODE_EVT*/
     nfa_ee_api_lmrt_size,     /* NFA_EE_API_LMRT_SIZE_EVT     */
     nfa_ee_api_update_now,    /* NFA_EE_API_UPDATE_NOW_EVT    */
     nfa_ee_api_connect,       /* NFA_EE_API_CONNECT_EVT       */
@@ -119,7 +125,7 @@ const tNFA_EE_SM_ACT nfa_ee_actions[] = {
 void nfa_ee_init(void) {
   int xx;
 
-  NFA_TRACE_DEBUG0("nfa_ee_init ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_init ()");
 
   /* initialize control block */
   memset(&nfa_ee_cb, 0, sizeof(tNFA_EE_CB));
@@ -148,22 +154,32 @@ void nfa_ee_init(void) {
 **
 *******************************************************************************/
 void nfa_ee_sys_enable(void) {
-
-  unsigned long retlen = 0;
-
-  NFA_TRACE_DEBUG1("%s", __func__);
+  bool enableBlockRoute = false;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
 
   nfa_ee_cb.route_block_control = 0x00;
 
-  if (GetNumValue(NAME_NFA_BLOCK_ROUTE, (void*)&retlen, sizeof(retlen))) {
+  if (NfcConfig::hasKey(NAME_NXP_PROP_BLACKLIST_ROUTING)) {
+    unsigned retlen = NfcConfig::getUnsigned(NAME_NXP_PROP_BLACKLIST_ROUTING);
+    if ((retlen == 0x01) && ((NFC_GetNCIVersion() == NCI_VERSION_1_0) ||
+                             (nfcFL.nfccFL._NFCC_ROUTING_BLOCK_BIT == true))) {
+      enableBlockRoute = true;
+    }
+  } else if (NfcConfig::hasKey(NAME_AID_BLOCK_ROUTE)) {
+    unsigned retlen = NfcConfig::getUnsigned(NAME_AID_BLOCK_ROUTE);
     if ((retlen == 0x01) && ((NFC_GetNCIVersion() == NCI_VERSION_2_0)
         || (nfcFL.nfccFL._NFCC_ROUTING_BLOCK_BIT == true))) {
-      nfa_ee_cb.route_block_control = NCI_ROUTE_QUAL_BLOCK_ROUTE;
-      NFA_TRACE_DEBUG1("nfa_ee_cb.route_block_control=0x%x",
-                       nfa_ee_cb.route_block_control);
+      enableBlockRoute = true;
     }
   }
+  if (enableBlockRoute == true) {
+    nfa_ee_cb.route_block_control = NCI_ROUTE_QUAL_BLOCK_ROUTE;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "nfa_ee_cb.route_block_control=0x%x", nfa_ee_cb.route_block_control);
+  }
+#if (NXP_EXTNS == TRUE)
   nfa_ee_get_num_nfcee_configured(nfa_ee_read_num_nfcee_config_cb);
+#endif
   if (nfa_ee_max_ee_cfg) {
     /* collect NFCEE information */
     NFC_NfceeDiscover(true);
@@ -190,7 +206,7 @@ void nfa_ee_restore_one_ecb(tNFA_EE_ECB* p_cb) {
   tNFC_NFCEE_MODE_SET_REVT rsp;
   tNFA_EE_NCI_MODE_SET ee_msg;
 
-  NFA_TRACE_DEBUG4(
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "nfa_ee_restore_one_ecb () nfcee_id:0x%x, ecb_flags:0x%x ee_status:0x%x "
       "ee_old_status: 0x%x",
       p_cb->nfcee_id, p_cb->ecb_flags, p_cb->ee_status, p_cb->ee_old_status);
@@ -230,7 +246,9 @@ void nfa_ee_restore_one_ecb(tNFA_EE_ECB* p_cb) {
       rsp.nfcee_id = p_cb->nfcee_id;
       rsp.status = NFA_STATUS_OK;
       ee_msg.p_data = &rsp;
-      nfa_ee_nci_mode_set_rsp((void*)&ee_msg);
+      tNFA_EE_MSG nfa_ee_msg;
+      nfa_ee_msg.mode_set_rsp = ee_msg;
+      nfa_ee_nci_mode_set_rsp(&nfa_ee_msg);
     }
   }
 }
@@ -249,7 +267,7 @@ void nfa_ee_proc_nfcc_power_mode(uint8_t nfcc_power_mode) {
   tNFA_EE_ECB* p_cb;
   bool proc_complete = true;
 
-  NFA_TRACE_DEBUG1("nfa_ee_proc_nfcc_power_mode (): nfcc_power_mode=%d",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_proc_nfcc_power_mode (): nfcc_power_mode=%d",
                    nfcc_power_mode);
   /* if NFCC power state is change to full power */
   if (nfcc_power_mode == NFA_DM_PWR_MODE_FULL) {
@@ -310,7 +328,7 @@ void nfa_ee_proc_hci_info_cback(void) {
   tNFA_EE_ECB* p_cb;
   tNFA_EE_MSG data;
 
-  NFA_TRACE_DEBUG0("nfa_ee_proc_hci_info_cback ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_proc_hci_info_cback ()");
   /* if NFCC power state is change to full power */
   nfa_ee_cb.ee_flags &= ~NFA_EE_FLAG_WAIT_HCI;
 
@@ -332,7 +350,7 @@ void nfa_ee_proc_hci_info_cback(void) {
       if (nfa_ee_cb.discv_timer.in_use) {
         nfa_sys_stop_timer(&nfa_ee_cb.discv_timer);
         data.hdr.event = NFA_EE_DISCV_TIMEOUT_EVT;
-        nfa_ee_evt_hdlr((void*)&data);
+        nfa_ee_evt_hdlr(&data.hdr);
       }
     }
   }
@@ -351,7 +369,7 @@ void nfa_ee_proc_hci_info_cback(void) {
 void nfa_ee_proc_evt(tNFC_RESPONSE_EVT event, void* p_data) {
   tNFA_EE_INT_EVT int_event = 0;
   tNFA_EE_NCI_WAIT_RSP cbk;
-
+  cbk.opcode = 0;
   switch (event) {
     case NFC_NFCEE_DISCOVER_REVT: /* 4  NFCEE Discover response */
       int_event = NFA_EE_NCI_DISC_RSP_EVT;
@@ -394,13 +412,14 @@ void nfa_ee_proc_evt(tNFC_RESPONSE_EVT event, void* p_data) {
       break;
   }
 
-  NFA_TRACE_DEBUG2("nfa_ee_proc_evt: event=0x%02x int_event:0x%x", event,
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_proc_evt: event=0x%02x int_event:0x%x", event,
                    int_event);
   if (int_event) {
     cbk.hdr.event = int_event;
     cbk.p_data = p_data;
-
-    nfa_ee_evt_hdlr((void*)&cbk);
+    tNFA_EE_MSG nfa_ee_msg;
+    nfa_ee_msg.wait_rsp = cbk;
+    nfa_ee_evt_hdlr(&nfa_ee_msg.hdr);
   }
 }
 
@@ -436,7 +455,7 @@ uint8_t nfa_ee_ecb_to_mask(tNFA_EE_ECB* p_cb) {
 tNFA_EE_ECB* nfa_ee_find_ecb(uint8_t nfcee_id) {
   uint32_t xx;
   tNFA_EE_ECB* p_ret = NULL, *p_cb;
-  NFA_TRACE_DEBUG0("nfa_ee_find_ecb ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_find_ecb ()");
 
   if (nfcee_id == NFC_DH_ID) {
     p_ret = &nfa_ee_cb.ecb[NFA_EE_CB_4_DH];
@@ -465,7 +484,7 @@ tNFA_EE_ECB* nfa_ee_find_ecb(uint8_t nfcee_id) {
 tNFA_EE_ECB* nfa_ee_find_ecb_by_conn_id(uint8_t conn_id) {
   uint32_t xx;
   tNFA_EE_ECB* p_ret = NULL, *p_cb;
-  NFA_TRACE_DEBUG0("nfa_ee_find_ecb_by_conn_id ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_find_ecb_by_conn_id ()");
 
   p_cb = nfa_ee_cb.ecb;
   for (xx = 0; xx < nfa_ee_cb.cur_ee; xx++, p_cb++) {
@@ -493,7 +512,7 @@ void nfa_ee_sys_disable(void) {
   tNFA_EE_ECB* p_cb;
   tNFA_EE_MSG msg;
 
-  NFA_TRACE_DEBUG0("nfa_ee_sys_disable ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_ee_sys_disable ()");
 
   nfa_ee_cb.em_state = NFA_EE_EM_STATE_DISABLED;
   /* report NFA_EE_DEREGISTER_EVT to all registered to EE */
@@ -595,7 +614,6 @@ void nfa_ee_reg_cback_enable_done(tNFA_EE_ENABLE_DONE_CBACK* p_cback) {
   nfa_ee_cb.p_enable_cback = p_cback;
 }
 
-#if (BT_TRACE_VERBOSE == true)
 /*******************************************************************************
 **
 ** Function         nfa_ee_sm_st_2_str
@@ -603,7 +621,7 @@ void nfa_ee_reg_cback_enable_done(tNFA_EE_ENABLE_DONE_CBACK* p_cback) {
 ** Description      convert nfa-ee state to string
 **
 *******************************************************************************/
-static char* nfa_ee_sm_st_2_str(uint8_t state) {
+static std::string nfa_ee_sm_st_2_str(uint8_t state) {
   switch (state) {
     case NFA_EE_EM_STATE_INIT:
       return "INIT";
@@ -632,7 +650,7 @@ static char* nfa_ee_sm_st_2_str(uint8_t state) {
 ** Description      convert nfa-ee evt to string
 **
 *******************************************************************************/
-static char* nfa_ee_sm_evt_2_str(uint16_t event) {
+static std::string nfa_ee_sm_evt_2_str(uint16_t event) {
   switch (event) {
     case NFA_EE_API_DISCOVER_EVT:
       return "API_DISCOVER";
@@ -650,6 +668,10 @@ static char* nfa_ee_sm_evt_2_str(uint16_t event) {
       return "API_ADD_AID";
     case NFA_EE_API_REMOVE_AID_EVT:
       return "API_REMOVE_AID";
+    case NFA_EE_API_ADD_SYSCODE_EVT:
+      return "NFA_EE_API_ADD_SYSCODE_EVT";
+    case NFA_EE_API_REMOVE_SYSCODE_EVT:
+      return "NFA_EE_API_REMOVE_SYSCODE_EVT";
     case NFA_EE_API_LMRT_SIZE_EVT:
       return "API_LMRT_SIZE";
     case NFA_EE_API_UPDATE_NOW_EVT:
@@ -699,7 +721,6 @@ static char* nfa_ee_sm_evt_2_str(uint16_t event) {
       return "Unknown";
   }
 }
-#endif /* BT_TRACE_VERBOSE */
 
 /*******************************************************************************
 **
@@ -712,25 +733,18 @@ static char* nfa_ee_sm_evt_2_str(uint16_t event) {
 **
 *******************************************************************************/
 bool nfa_ee_evt_hdlr(NFC_HDR* p_msg) {
-  tNFA_EE_MSG* p_evt_data = (tNFA_EE_MSG*)p_msg;
-  uint16_t event = p_msg->event & 0x00ff;
   bool act = false;
 
-#if (BT_TRACE_VERBOSE == true)
-  NFA_TRACE_DEBUG4("nfa_ee_evt_hdlr (): Event %s(0x%02x), State: %s(%d)",
-                   nfa_ee_sm_evt_2_str(p_evt_data->hdr.event),
-                   p_evt_data->hdr.event,
-                   nfa_ee_sm_st_2_str(nfa_ee_cb.em_state), nfa_ee_cb.em_state);
-#else
-  NFA_TRACE_DEBUG2("nfa_ee_evt_hdlr (): Event 0x%02x, State: %d",
-                   p_evt_data->hdr.event, nfa_ee_cb.em_state);
-#endif
+DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "Event %s(0x%02x), State: %s(%d)",
+      nfa_ee_sm_evt_2_str(p_msg->event).c_str(), p_msg->event,
+      nfa_ee_sm_st_2_str(nfa_ee_cb.em_state).c_str(), nfa_ee_cb.em_state);
 
 #if 0
     /*This is required to receive Reader Over SWP event*/
     if(p_evt_data->hdr.event == NFA_EE_NCI_DISC_NTF_EVT)
     {
-        NFA_TRACE_DEBUG0("recived dis_ntf; stopping timer");
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("recived dis_ntf; stopping timer");
         nfa_sys_stop_timer(&nfa_ee_cb.discv_timer);
     }
 #endif
@@ -749,13 +763,15 @@ bool nfa_ee_evt_hdlr(NFC_HDR* p_msg) {
       if (p_msg->event == NFA_EE_NCI_CONN_EVT) act = true;
       break;
   }
+  tNFA_EE_MSG* p_evt_data = (tNFA_EE_MSG*)p_msg;
   if (act) {
+    uint16_t event = p_msg->event & 0x00ff;
     if (event < NFA_EE_NUM_ACTIONS) {
       (*nfa_ee_actions[event])(p_evt_data);
     }
   } else {
-    /* if the data event is not handled by action function, free the data packet
-     */
+    /* If the event is not handled, free the data packet. */
+    /* FIXME: Is it really always tNFA_EE_NCI_CONN? */
     if (p_msg->event == NFA_EE_NCI_DATA_EVT)
       GKI_freebuf(p_evt_data->conn.p_data);
   }
diff --git a/src/nfa/hci/nfa_hci_act.c b/src/nfa/hci/nfa_hci_act.cc
similarity index 93%
rename from src/nfa/hci/nfa_hci_act.c
rename to src/nfa/hci/nfa_hci_act.cc
index 3747a45..348ecb2 100755
--- a/src/nfa/hci/nfa_hci_act.c
+++ b/src/nfa/hci/nfa_hci_act.cc
@@ -1,8 +1,9 @@
 /******************************************************************************
+ *
  *  Copyright (c) 2016, The Linux Foundation. All rights reserved.
  *  Not a Contribution.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *  The original Work has been changed by NXP Semiconductors.
  *
  *  Copyright (C) 2010-2014 Broadcom Corporation
@@ -26,20 +27,23 @@
  *
  ******************************************************************************/
 #include <string.h>
-#include "trace_api.h"
-#include "nfc_api.h"
-#include "nfa_sys.h"
-#include "nfa_sys_int.h"
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfa_hci_api.h"
 #include "nfa_hci_int.h"
 #include "nfa_dm_int.h"
-#include "nfa_nv_co.h"
-#include "nfa_mem_co.h"
 #include "nfa_hci_defs.h"
 #if (NXP_EXTNS == TRUE)
 #include "nfa_ee_int.h"
 #endif
 
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+
+
 /* Static local functions       */
 static void nfa_hci_api_register(tNFA_HCI_EVENT_DATA* p_evt_data);
 static void nfa_hci_api_get_gate_pipe_list(tNFA_HCI_EVENT_DATA* p_evt_data);
@@ -64,18 +68,16 @@ static void nfa_hci_handle_connectivity_gate_pkt(uint8_t* p_data,
                                                  uint16_t data_len,
                                                  tNFA_HCI_DYN_PIPE* p_pipe);
 static void nfa_hci_handle_generic_gate_cmd(uint8_t* p_data, uint8_t data_len,
-                                            tNFA_HCI_DYN_GATE* p_gate,
                                             tNFA_HCI_DYN_PIPE* p_pipe);
 static void nfa_hci_handle_generic_gate_rsp(uint8_t* p_data, uint8_t data_len,
-                                            tNFA_HCI_DYN_GATE* p_gate,
                                             tNFA_HCI_DYN_PIPE* p_pipe);
 static void nfa_hci_handle_generic_gate_evt(uint8_t* p_data, uint16_t data_len,
                                             tNFA_HCI_DYN_GATE* p_gate,
                                             tNFA_HCI_DYN_PIPE* p_pipe);
 
 #if (NXP_EXTNS == TRUE)
-static void nfa_hci_api_get_host_id(tNFA_HCI_EVENT_DATA* p_evt_data);
-static void nfa_hci_api_get_host_type(tNFA_HCI_EVENT_DATA* p_evt_data);
+static __attribute__((unused)) void nfa_hci_api_get_host_id(tNFA_HCI_EVENT_DATA* p_evt_data);
+static __attribute__((unused)) void nfa_hci_api_get_host_type(tNFA_HCI_EVENT_DATA* p_evt_data);
 static tNFA_STATUS nfa_hci_api_get_host_type_list();
 static void nfa_hci_api_getnoofhosts(uint8_t* p_data, uint8_t data_len);
 static void nfa_hci_handle_Nfcee_admpipe_rsp(uint8_t* p_data, uint8_t data_len);
@@ -83,11 +85,11 @@ static void nfa_hci_handle_Nfcee_dynpipe_rsp(uint8_t pipeId, uint8_t* p_data,
                                              uint8_t data_len);
 static bool nfa_hci_api_checkforAPDUGate(uint8_t* p_data, uint8_t data_len);
 static bool nfa_hci_api_IspipePresent(uint8_t nfceeId, uint8_t gateId);
-static bool nfa_hci_api_GetpipeId(uint8_t nfceeId, uint8_t gateId,
+static __attribute__((unused)) bool nfa_hci_api_GetpipeId(uint8_t nfceeId, uint8_t gateId,
                                   uint8_t* pipeId);
 static void nfa_hci_poll_session_id_cb(uint8_t event, uint16_t param_len,
                                        uint8_t* p_param);
-static void nfa_hci_read_num_nfcee_config_cb(uint8_t event, uint16_t param_len,
+static __attribute__((unused)) void nfa_hci_read_num_nfcee_config_cb(uint8_t event, uint16_t param_len,
                                              uint8_t* p_param);
 static tNFA_STATUS nfa_hci_poll_session_id(uint8_t host_type);
 static void nfa_hci_get_pipe_state_cb(uint8_t event, uint16_t param_len, uint8_t* p_param);
@@ -248,7 +250,7 @@ void nfa_hci_check_api_requests(void) {
         break;
 #endif
       default:
-        NFA_TRACE_ERROR1("nfa_hci_check_api_requests ()  Unknown event: 0x%04x",
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_check_api_requests ()  Unknown event: 0x%04x",
                          p_msg->event);
         break;
     }
@@ -279,7 +281,7 @@ static void nfa_hci_api_register(tNFA_HCI_EVENT_DATA* p_evt_data) {
     if ((nfa_hci_cb.cfg.reg_app_names[xx][0] != 0) &&
         !strncmp(p_app_name, &nfa_hci_cb.cfg.reg_app_names[xx][0],
                  strlen(p_app_name))) {
-      NFA_TRACE_EVENT2("nfa_hci_api_register (%s)  Reusing: %u", p_app_name,
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_api_register (%s)  Reusing: %u", p_app_name,
                        xx);
       break;
     }
@@ -305,14 +307,14 @@ static void nfa_hci_api_register(tNFA_HCI_EVENT_DATA* p_evt_data) {
         NQ_STRLCPY_S (&nfa_hci_cb.cfg.reg_app_names[xx][0], sizeof (nfa_hci_cb.cfg.reg_app_names[xx]), p_app_name,
                 NFA_MAX_HCI_APP_NAME_LEN);
         nfa_hci_cb.nv_write_needed = true;
-        NFA_TRACE_EVENT2("nfa_hci_api_register (%s)  Allocated: %u", p_app_name,
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_api_register (%s)  Allocated: %u", p_app_name,
                          xx);
         break;
       }
     }
 
     if (xx == NFA_HCI_MAX_APP_CB) {
-      NFA_TRACE_ERROR1("nfa_hci_api_register (%s)  NO ENTRIES", p_app_name);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_api_register (%s)  NO ENTRIES", p_app_name);
 
       evt_data.hci_register.status = NFA_STATUS_FAILED;
       p_evt_data->app_info.p_cback(NFA_HCI_REGISTER_EVT, &evt_data);
@@ -357,14 +359,14 @@ void nfa_hci_api_deregister(tNFA_HCI_EVENT_DATA* p_evt_data) {
           !strncmp(p_evt_data->app_info.app_name,
                    &nfa_hci_cb.cfg.reg_app_names[xx][0],
                    strlen(p_evt_data->app_info.app_name))) {
-        NFA_TRACE_EVENT2("nfa_hci_api_deregister (%s) inx: %u",
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_api_deregister (%s) inx: %u",
                          p_evt_data->app_info.app_name, xx);
         break;
       }
     }
 
     if (xx == NFA_HCI_MAX_APP_CB) {
-      NFA_TRACE_WARNING1("nfa_hci_api_deregister () Unknown app: %s",
+      LOG(WARNING) << StringPrintf("nfa_hci_api_deregister () Unknown app: %s",
                          p_evt_data->app_info.app_name);
       return;
     }
@@ -517,7 +519,7 @@ static void nfa_hci_api_alloc_gate(tNFA_HCI_EVENT_DATA* p_evt_data) {
     } else if (p_gate->gate_owner != app_handle) {
       /* Some other app owns the gate */
       p_gate = NULL;
-      NFA_TRACE_ERROR1(
+      LOG(ERROR) << StringPrintf(
           "nfa_hci_api_alloc_gate (): The Gate (0X%02x) already taken!",
           p_evt_data->gate_info.gate);
     }
@@ -641,7 +643,7 @@ static bool nfa_hci_api_create_pipe(tNFA_HCI_EVENT_DATA* p_evt_data) {
   if ((p_gate == NULL) ||
       (p_gate->gate_owner != p_evt_data->create_pipe.hci_handle)) {
     report_failed = true;
-    NFA_TRACE_ERROR2(
+    LOG(ERROR) << StringPrintf(
         "nfa_hci_api_create_pipe Cannot create pipe! APP: 0x%02x does not own "
         "the gate:0x%x",
         p_evt_data->create_pipe.hci_handle,
@@ -651,7 +653,7 @@ static bool nfa_hci_api_create_pipe(tNFA_HCI_EVENT_DATA* p_evt_data) {
                  p_evt_data->create_pipe.dest_host,
                  p_evt_data->create_pipe.dest_gate)) {
     report_failed = true;
-    NFA_TRACE_ERROR0(
+    LOG(ERROR) << StringPrintf(
         "nfa_hci_api_create_pipe : Cannot create multiple pipe between the "
         "same two gates!");
   }
@@ -748,7 +750,7 @@ static bool nfa_hci_api_get_reg_value(tNFA_HCI_EVENT_DATA* p_evt_data) {
       }
 
       if (p_pipe->pipe_state == NFA_HCI_PIPE_CLOSED) {
-        NFA_TRACE_WARNING1("nfa_hci_api_get_reg_value pipe:%d not open",
+        LOG(WARNING) << StringPrintf("nfa_hci_api_get_reg_value pipe:%d not open",
                            p_evt_data->get_registry.pipe);
       } else {
         status = nfa_hciu_send_get_param_cmd(p_evt_data->get_registry.pipe,
@@ -796,7 +798,7 @@ static bool nfa_hci_api_set_reg_value(tNFA_HCI_EVENT_DATA* p_evt_data) {
       }
 
       if (p_pipe->pipe_state == NFA_HCI_PIPE_CLOSED) {
-        NFA_TRACE_WARNING1("nfa_hci_api_set_reg_value pipe:%d not open",
+        LOG(WARNING) << StringPrintf("nfa_hci_api_set_reg_value pipe:%d not open",
                            p_evt_data->set_registry.pipe);
       } else {
         status = nfa_hciu_send_set_param_cmd(
@@ -918,17 +920,17 @@ static bool nfa_hci_api_send_cmd(tNFA_HCI_EVENT_DATA* p_evt_data) {
                                    p_evt_data->send_cmd.data);
         if (status == NFA_STATUS_OK) return true;
       } else {
-        NFA_TRACE_WARNING1("nfa_hci_api_send_cmd pipe:%d not open",
+        LOG(WARNING) << StringPrintf("nfa_hci_api_send_cmd pipe:%d not open",
                            p_pipe->pipe_id);
       }
     } else {
-      NFA_TRACE_WARNING1(
+      LOG(WARNING) << StringPrintf(
           "nfa_hci_api_send_cmd pipe:%d Owned by different application or "
           "Destination host is not active",
           p_pipe->pipe_id);
     }
   } else {
-    NFA_TRACE_WARNING1("nfa_hci_api_send_cmd pipe:%d not found",
+    LOG(WARNING) << StringPrintf("nfa_hci_api_send_cmd pipe:%d not found",
                        p_evt_data->send_cmd.pipe);
   }
 
@@ -968,17 +970,17 @@ static void nfa_hci_api_send_rsp(tNFA_HCI_EVENT_DATA* p_evt_data) {
                                    p_evt_data->send_rsp.data);
         if (status == NFA_STATUS_OK) return;
       } else {
-        NFA_TRACE_WARNING1("nfa_hci_api_send_rsp pipe:%d not open",
+        LOG(WARNING) << StringPrintf("nfa_hci_api_send_rsp pipe:%d not open",
                            p_pipe->pipe_id);
       }
     } else {
-      NFA_TRACE_WARNING1(
+      LOG(WARNING) << StringPrintf(
           "nfa_hci_api_send_rsp pipe:%d Owned by different application or "
           "Destination host is not active",
           p_pipe->pipe_id);
     }
   } else {
-    NFA_TRACE_WARNING1("nfa_hci_api_send_rsp pipe:%d not found",
+    LOG(WARNING) << StringPrintf("nfa_hci_api_send_rsp pipe:%d not found",
                        p_evt_data->send_rsp.pipe);
   }
 
@@ -1054,17 +1056,17 @@ static bool nfa_hci_api_send_event(tNFA_HCI_EVENT_DATA* p_evt_data) {
           }
         }
       } else {
-        NFA_TRACE_WARNING1("nfa_hci_api_send_event pipe:%d not open",
+        LOG(WARNING) << StringPrintf("nfa_hci_api_send_event pipe:%d not open",
                            p_pipe->pipe_id);
       }
     } else {
-      NFA_TRACE_WARNING1(
+      LOG(WARNING) << StringPrintf(
           "nfa_hci_api_send_event pipe:%d Owned by different application or "
           "Destination host is not active",
           p_pipe->pipe_id);
     }
   } else {
-    NFA_TRACE_WARNING1("nfa_hci_api_send_event pipe:%d not found",
+    LOG(WARNING) << StringPrintf("nfa_hci_api_send_event pipe:%d not found",
                        p_evt_data->send_evt.pipe);
   }
 
@@ -1395,22 +1397,13 @@ void nfa_hci_handle_admin_gate_rsp(uint8_t* p_data, uint8_t data_len) {
 #if (NXP_EXTNS == TRUE)
   // Terminal Host Type as ETSI12  Byte1 -Host Id Byte2 - 00
   uint8_t terminal_host_type[NFA_HCI_HOST_TYPE_LEN] = {0x01, 0x00};
-  uint8_t count = 0;
 #endif
 
-#if (BT_TRACE_VERBOSE == true)
-  NFA_TRACE_DEBUG4(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "nfa_hci_handle_admin_gate_rsp - LastCmdSent: %s  App: 0x%04x  Gate: "
       "0x%02x  Pipe: 0x%02x",
-      nfa_hciu_instr_2_str(nfa_hci_cb.cmd_sent), nfa_hci_cb.app_in_use,
+      nfa_hciu_instr_2_str(nfa_hci_cb.cmd_sent).c_str(), nfa_hci_cb.app_in_use,
       nfa_hci_cb.local_gate_in_use, nfa_hci_cb.pipe_in_use);
-#else
-  NFA_TRACE_DEBUG4(
-      "nfa_hci_handle_admin_gate_rsp LastCmdSent: %u  App: 0x%04x  Gate: "
-      "0x%02x  Pipe: 0x%02x",
-      nfa_hci_cb.cmd_sent, nfa_hci_cb.app_in_use, nfa_hci_cb.local_gate_in_use,
-      nfa_hci_cb.pipe_in_use);
-#endif
 
   /* If starting up, handle events here */
   if ((nfa_hci_cb.hci_state == NFA_HCI_STATE_STARTUP) ||
@@ -1426,19 +1419,19 @@ void nfa_hci_handle_admin_gate_rsp(uint8_t* p_data, uint8_t data_len) {
 #if (NXP_EXTNS == TRUE)
       if (nfa_hci_cb.param_in_use == NFA_HCI_HOST_TYPE_INDEX) {
         if (nfa_hci_cb.cmd_sent == NFA_HCI_ANY_GET_PARAMETER) {
-          NFA_TRACE_DEBUG0(
+           DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
               "nfa_hci_handle_admin_gate_rsp - HCI Controller is ETSI 9 !!!");
           // Set a variable to set ETSI version of HCI Controller
           nfa_hci_cb.host_controller_version = NFA_HCI_CONTROLLER_VERSION_9;
         }
       } else {
-        NFA_TRACE_ERROR0(
+        LOG(ERROR) << StringPrintf(
             "nfa_hci_handle_admin_gate_rsp - Initialization failed");
         nfa_hci_startup_complete(NFA_STATUS_FAILED);
         return;
       }
 #else
-      NFA_TRACE_ERROR0("nfa_hci_handle_admin_gate_rsp - Initialization failed");
+      LOG(ERROR) << StringPrintf("nfa_hci_handle_admin_gate_rsp - Initialization failed");
       nfa_hci_startup_complete(NFA_STATUS_FAILED);
       return;
 #endif
@@ -1459,7 +1452,7 @@ void nfa_hci_handle_admin_gate_rsp(uint8_t* p_data, uint8_t data_len) {
         }
 #else
         if (nfa_hci_cb.param_in_use == NFA_HCI_WHITELIST_INDEX) {
-          NFA_TRACE_DEBUG0(
+           DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
               "nfa_hci_handle_admin_gate_rsp - Set the HOST_TYPE as per ETSI "
               "12 !!!");
           /* Set the HOST_TYPE as per ETSI 12 */
@@ -1471,7 +1464,7 @@ void nfa_hci_handle_admin_gate_rsp(uint8_t* p_data, uint8_t data_len) {
 
         if (nfa_hci_cb.param_in_use == NFA_HCI_HOST_TYPE_INDEX) {
           if (nfa_hci_cb.inst == NFA_HCI_ANY_OK) {
-            NFA_TRACE_DEBUG0(
+             DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
                 "nfa_hci_handle_admin_gate_rsp - HCI Controller is ETSI 12 "
                 "!!!");
             // Set a variable  to set ETSI version of HCI Controller
@@ -1711,7 +1704,7 @@ void nfa_hci_handle_admin_gate_rsp(uint8_t* p_data, uint8_t data_len) {
           STREAM_TO_UINT8(pipe, p_data);
           /* Sanity check */
           if (source_gate != nfa_hci_cb.local_gate_in_use) {
-            NFA_TRACE_WARNING2(
+            LOG(WARNING) << StringPrintf(
                 "nfa_hci_handle_admin_gate_rsp sent create pipe with gate: %u "
                 "got back: %u",
                 nfa_hci_cb.local_gate_in_use, source_gate);
@@ -1795,17 +1788,16 @@ void nfa_hci_handle_admin_gate_rsp(uint8_t* p_data, uint8_t data_len) {
 ** Returns          none
 **
 *******************************************************************************/
-void nfa_hci_handle_admin_gate_evt(uint8_t* p_data) {
+void nfa_hci_handle_admin_gate_evt() {
   tNFA_HCI_EVT_DATA evt_data;
   tNFA_HCI_API_GET_HOST_LIST* p_msg;
-  (void)p_data;
   if (nfa_hci_cb.inst != NFA_HCI_EVT_HOT_PLUG) {
-    NFA_TRACE_ERROR0(
+    LOG(ERROR) << StringPrintf(
         "nfa_hci_handle_admin_gate_evt - Unknown event on ADMIN Pipe");
     return;
   }
 
-  NFA_TRACE_DEBUG0(
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "nfa_hci_handle_admin_gate_evt - HOT PLUG EVT event on ADMIN Pipe");
   nfa_hci_cb.num_hot_plug_evts++;
 
@@ -1871,7 +1863,7 @@ void nfa_hci_handle_dyn_pipe_pkt(uint8_t pipe_id, uint8_t* p_data,
 
   if (p_pipe == NULL) {
     /* Invalid pipe ID */
-    NFA_TRACE_ERROR1("nfa_hci_handle_dyn_pipe_pkt - Unknown pipe %d", pipe_id);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_handle_dyn_pipe_pkt - Unknown pipe %d", pipe_id);
     if (nfa_hci_cb.type == NFA_HCI_COMMAND_TYPE)
       nfa_hciu_send_msg(pipe_id, NFA_HCI_RESPONSE_TYPE, NFA_HCI_ANY_E_NOK, 0,
                         NULL);
@@ -1906,13 +1898,11 @@ void nfa_hci_handle_dyn_pipe_pkt(uint8_t pipe_id, uint8_t* p_data,
 
     switch (nfa_hci_cb.type) {
       case NFA_HCI_COMMAND_TYPE:
-        nfa_hci_handle_generic_gate_cmd(p_data, (uint8_t)data_len, p_gate,
-                                        p_pipe);
+        nfa_hci_handle_generic_gate_cmd(p_data, (uint8_t)data_len, p_pipe);
         break;
 
       case NFA_HCI_RESPONSE_TYPE:
-        nfa_hci_handle_generic_gate_rsp(p_data, (uint8_t)data_len, p_gate,
-                                        p_pipe);
+        nfa_hci_handle_generic_gate_rsp(p_data, (uint8_t)data_len, p_pipe);
         break;
 
       case NFA_HCI_EVENT_TYPE:
@@ -1924,7 +1914,7 @@ void nfa_hci_handle_dyn_pipe_pkt(uint8_t pipe_id, uint8_t* p_data,
   else {
     p_gate = nfa_hciu_find_gate_by_gid(p_pipe->local_gate);
     if (p_gate == NULL) {
-      NFA_TRACE_ERROR1(
+      LOG(ERROR) << StringPrintf(
           "nfa_hci_handle_dyn_pipe_pkt - Pipe's gate %d is corrupt",
           p_pipe->local_gate);
       if (nfa_hci_cb.type == NFA_HCI_COMMAND_TYPE)
@@ -1935,13 +1925,11 @@ void nfa_hci_handle_dyn_pipe_pkt(uint8_t pipe_id, uint8_t* p_data,
     /* Check if data packet is a command, response or event */
     switch (nfa_hci_cb.type) {
       case NFA_HCI_COMMAND_TYPE:
-        nfa_hci_handle_generic_gate_cmd(p_data, (uint8_t)data_len, p_gate,
-                                        p_pipe);
+        nfa_hci_handle_generic_gate_cmd(p_data, (uint8_t)data_len, p_pipe);
         break;
 
       case NFA_HCI_RESPONSE_TYPE:
-        nfa_hci_handle_generic_gate_rsp(p_data, (uint8_t)data_len, p_gate,
-                                        p_pipe);
+        nfa_hci_handle_generic_gate_rsp(p_data, (uint8_t)data_len, p_pipe);
         break;
 
       case NFA_HCI_EVENT_TYPE:
@@ -2058,11 +2046,9 @@ static void nfa_hci_handle_identity_mgmt_gate_pkt(uint8_t* p_data,
 **
 *******************************************************************************/
 static void nfa_hci_handle_generic_gate_cmd(uint8_t* p_data, uint8_t data_len,
-                                            tNFA_HCI_DYN_GATE* p_gate,
                                             tNFA_HCI_DYN_PIPE* p_pipe) {
   tNFA_HCI_EVT_DATA evt_data;
   tNFA_HANDLE app_handle = nfa_hciu_get_pipe_owner(p_pipe->pipe_id);
-  (void)p_gate;
 
   switch (nfa_hci_cb.inst) {
     case NFA_HCI_ANY_SET_PARAMETER:
@@ -2129,11 +2115,9 @@ static void nfa_hci_handle_generic_gate_cmd(uint8_t* p_data, uint8_t data_len,
 **
 *******************************************************************************/
 static void nfa_hci_handle_generic_gate_rsp(uint8_t* p_data, uint8_t data_len,
-                                            tNFA_HCI_DYN_GATE* p_gate,
                                             tNFA_HCI_DYN_PIPE* p_pipe) {
   tNFA_HCI_EVT_DATA evt_data;
   tNFA_STATUS status = NFA_STATUS_OK;
-  (void)p_gate;
 
   if (nfa_hci_cb.inst != NFA_HCI_ANY_OK) status = NFA_STATUS_FAILED;
 
@@ -2179,6 +2163,12 @@ static void nfa_hci_handle_generic_gate_rsp(uint8_t* p_data, uint8_t data_len,
                          nfa_hci_cb.app_in_use);
   } else {
     /* Could be a response to application specific command sent, pass it on */
+#if (NXP_EXTNS == TRUE)
+    if(nfa_hci_cb.inst == NFA_HCI_ANY_E_PIPE_NOT_OPENED) {
+      p_pipe->pipe_state = NFA_HCI_PIPE_CLOSED;
+      nfa_hci_cb.nv_write_needed = true;
+    }
+#endif
     evt_data.rsp_rcvd.status = NFA_STATUS_OK;
     evt_data.rsp_rcvd.pipe = p_pipe->pipe_id;
     ;
@@ -2341,6 +2331,7 @@ static void nfa_hci_handle_generic_gate_evt(uint8_t* p_data, uint16_t data_len,
   evt_data.rcvd_evt.pipe = p_pipe->pipe_id;
   evt_data.rcvd_evt.evt_code = nfa_hci_cb.inst;
   evt_data.rcvd_evt.evt_len = data_len;
+  evt_data.rcvd_evt.last_SentEvtType = 0;
 
   if (nfa_hci_cb.assembly_failed)
     evt_data.rcvd_evt.status = NFA_STATUS_BUFFER_FULL;
@@ -2430,11 +2421,10 @@ static void nfa_hci_api_get_host_type(tNFA_HCI_EVENT_DATA* p_evt_data) {
 tNFA_STATUS nfa_hci_api_get_host_type_list() {
   tNFA_STATUS status = NFA_STATUS_FAILED;
   tNFA_HCI_EVT_DATA evt_data;
-  tNFA_HANDLE app_handle;
-  NFA_TRACE_DEBUG0("nfa_hci_api_get_host_type_list - enter!!");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_api_get_host_type_list - enter!!");
   if ((nfa_hci_cb.host_controller_version == NFA_HCI_CONTROLLER_VERSION_12) &&
       (nfa_hci_cb.hci_state == NFA_HCI_STATE_NFCEE_ENABLE)) {
-    NFA_TRACE_DEBUG0(
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "nfa_hci_api_get_host_type_list - Sending get_host_type_list!!!");
     if ((status = nfa_hciu_send_get_param_cmd(NFA_HCI_ADMIN_PIPE,
                                               NFA_HCI_HOST_TYPE_LIST_INDEX)) ==
@@ -2460,31 +2450,28 @@ tNFA_STATUS nfa_hci_api_get_host_type_list() {
 tNFA_STATUS nfa_hci_api_config_nfcee(uint8_t hostId) {
   tNFA_STATUS status = NFA_STATUS_OK;
   tNFA_HCI_EVT_DATA evt_data;
-  uint8_t count = 0;
-  uint8_t pipeId = 0;
-  bool bCreatepipe = false;
-  NFA_TRACE_DEBUG0("nfa_hci_api_config_nfcee - enter!!");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_api_config_nfcee - enter!!");
 
   nfa_hciu_set_nfceeid_config_mask(NFA_HCI_SET_CONFIG_EVENT, hostId);
   if ((nfa_hci_cb.host_controller_version == NFA_HCI_CONTROLLER_VERSION_12) &&
       (nfa_hci_cb.hci_state == NFA_HCI_STATE_NFCEE_ENABLE)) {
-    NFA_TRACE_DEBUG0("nfa_hci_api_config_nfcee -Entry");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_api_config_nfcee -Entry");
     if ((nfa_hci_api_IspipePresent(hostId, NFA_HCI_ETSI12_APDU_GATE) ==
          false)) {
       nfa_hci_cb.current_nfcee = hostId;
-      NFA_TRACE_DEBUG0 ("nfa_hci_api_config_nfcee - creating APDU gate pipe!!!");
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_api_config_nfcee - creating APDU gate pipe!!!");
       nfa_hciu_alloc_gate(NFA_HCI_ETSI12_APDU_GATE, NFA_HANDLE_GROUP_HCI);
       nfa_hciu_send_create_pipe_cmd (NFA_HCI_ETSI12_APDU_GATE, nfa_hci_cb.current_nfcee, NFA_HCI_ETSI12_APDU_GATE);
 
       return (NFA_STATUS_OK);
     } else {
       status = NFA_STATUS_OK;
-      NFA_TRACE_DEBUG0(
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "nfa_hci_api_config_nfcee - APDU Gate is present and pipe is already "
           "created!!!");
     }
   }
-  NFA_TRACE_DEBUG0("nfa_hci_api_config_nfcee - No NFCEE Config is needed!!!");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_api_config_nfcee - No NFCEE Config is needed!!!");
   evt_data.config_rsp_rcvd.status = status;
   /* Send NFA_HCI_CMD_SENT_EVT to notify failure */
   nfa_hciu_send_to_all_apps(NFA_HCI_CONFIG_DONE_EVT, &evt_data);
@@ -2545,8 +2532,8 @@ static tNFA_STATUS nfa_hci_get_num_nfcee_configured() {
           nfa_hci_cb.hci_ee_info[xx].ee_handle;
     }
   }
-  NFA_TRACE_DEBUG1("nfa_hci_read_num_nfcee_config_cb  nfa_ee_max_ee_cfg%x", nfa_ee_max_ee_cfg);
-  NFA_TRACE_DEBUG1("nfa_hci_read_num_nfcee_config_cb nfa_hci_cb.num_nfcee%x", nfa_hci_cb.num_nfcee);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_read_num_nfcee_config_cb  nfa_ee_max_ee_cfg%x", nfa_ee_max_ee_cfg);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_read_num_nfcee_config_cb nfa_hci_cb.num_nfcee%x", nfa_hci_cb.num_nfcee);
   if (nfa_ee_max_ee_cfg > nfa_hci_cb.num_nfcee) {
     nfa_sys_start_timer(&nfa_hci_cb.timer, NFA_HCI_NFCEE_DISCOVER_TIMEOUT_EVT,
                         nfa_hci_cb.max_nfcee_disc_timeout);
@@ -2565,11 +2552,10 @@ static tNFA_STATUS nfa_hci_get_num_nfcee_configured() {
 **
 *********************************************************************************/
 static tNFA_STATUS nfa_hci_poll_all_nfcee_session_id() {
-  uint8_t discovered_num_nfcee = NFA_HCI_MAX_HOST_IN_NETWORK, xx;
+  uint8_t xx;
   tNFA_STATUS status = NFA_STATUS_OK;
-  uint8_t host_index = 0x00;
   for (xx = 0; xx < nfa_hci_cb.num_nfcee; xx++) {
-    NFA_TRACE_DEBUG1("nfa_hci_pollsession_id   -%x",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_pollsession_id   -%x",
                      nfa_hci_cb.hci_ee_info[xx].ee_handle);
     if ((((nfa_hci_cb.hci_ee_info[xx].ee_interface[0] !=
         NCI_NFCEE_INTERFACE_HCI_ACCESS)&& nfa_hci_cb.hci_ee_info[xx].ee_status == NFA_EE_STATUS_ACTIVE))&&
@@ -2592,7 +2578,7 @@ static tNFA_STATUS nfa_hci_poll_all_nfcee_session_id() {
   }
   if (xx == nfa_hci_cb.num_nfcee)
     nfa_hci_handle_nfcee_config_evt(NFA_HCI_HOST_TYPE_LIST_INDEX);
-  NFA_TRACE_DEBUG0("nfa_hci_poll_all_nfcee_session_id - exit!!");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_poll_all_nfcee_session_id - exit!!");
   return status;
 }
 
@@ -2626,7 +2612,7 @@ static tNFA_STATUS nfa_hci_poll_session_id(uint8_t host_type) {
     status = NFA_STATUS_BAD_HANDLE;
 
   if (status == NFA_STATUS_OK && ((p - p_data) > 0x00)) {
-    NFA_TRACE_DEBUG0("nfa_hci_clear_all_pipe_ntf session id read");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_clear_all_pipe_ntf session id read");
     nfa_hci_cb.nfcee_cfg.session_id_retry++;
     status =
         nfa_hciu_send_raw_cmd(p - p_data, p_data, nfa_hci_poll_session_id_cb);
@@ -2643,7 +2629,7 @@ static tNFA_STATUS nfa_hci_poll_session_id(uint8_t host_type) {
 ** Returns          None
 **
 *******************************************************************************/
-static void nfa_hci_poll_session_id_cb(uint8_t event, uint16_t param_len,
+static void nfa_hci_poll_session_id_cb(__attribute__((unused)) uint8_t event, uint16_t param_len,
                                        uint8_t* p_param) {
   uint8_t default_session[NFA_HCI_SESSION_ID_LEN] = {0xFF, 0xFF, 0xFF, 0xFF,
                                                      0xFF, 0xFF, 0xFF, 0xFF};
@@ -2658,7 +2644,7 @@ static void nfa_hci_poll_session_id_cb(uint8_t event, uint16_t param_len,
 
   if (!memcmp((uint8_t*)default_session, p_param + SESSION_ID_INDEX,
               NFA_HCI_SESSION_ID_LEN)) {
-    NFA_TRACE_DEBUG0("nfa_hci_poll_session_id_cb invalid session id");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_poll_session_id_cb invalid session id");
     if (nfa_hci_cb.nfcee_cfg.session_id_retry <=
         nfa_hci_cb.max_hci_session_id_read_count) {
       nfa_sys_start_timer(&nfa_hci_cb.timer,
@@ -2668,7 +2654,7 @@ static void nfa_hci_poll_session_id_cb(uint8_t event, uint16_t param_len,
       nfa_hci_handle_nfcee_config_evt(NFA_HCI_READ_SESSIONID);
     }
   } else {
-    NFA_TRACE_DEBUG0("nfa_hci_poll_session_id_cb valid session id");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_poll_session_id_cb valid session id");
     nfa_hci_cb.nfcee_cfg.session_id_retry =
         nfa_hci_cb.max_hci_session_id_read_count + 1;
     nfa_hci_handle_nfcee_config_evt(NFA_HCI_READ_SESSIONID);
@@ -2701,7 +2687,7 @@ static void nfa_hci_poll_session_id_cb(uint8_t event, uint16_t param_len,
 **
 *******************************************************************************/
 void nfa_hci_handle_nfcee_config_evt(uint16_t event) {
-  NFA_TRACE_DEBUG1("nfa_hci_handle_nfcee_config_evt enter %x", event);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_handle_nfcee_config_evt enter %x", event);
   switch (event) {
     case NFA_HCI_GET_NUM_NFCEE_CONFIGURED:
       nfa_hci_cb.nfcee_cfg.nfc_init_state = true;
@@ -2710,7 +2696,6 @@ void nfa_hci_handle_nfcee_config_evt(uint16_t event) {
         nfa_hci_cb.nfcee_cfg.config_nfcee_state =
             NFA_HCI_GET_NUM_NFCEE_CONFIGURED;
         if (nfa_hci_get_num_nfcee_configured() != NFA_STATUS_BUSY) {
-          tNFA_HCI_API_CONFIGURE_EVT* p_msg;
           /* Send read session event to continue with other initialization*/
           /*Read the session ID of the host discovered */
           nfa_hci_cb.nfcee_cfg.config_nfcee_state = NFA_HCI_READ_SESSIONID;
@@ -2723,7 +2708,7 @@ void nfa_hci_handle_nfcee_config_evt(uint16_t event) {
     case NFA_HCI_ADM_NOTIFY_ALL_PIPE_CLEARED:
       /* Stop RF discovery if running and update state*/
       if (nfa_hci_cb.hci_state < NFA_HCI_STATE_IDLE) {
-        NFA_TRACE_DEBUG0(
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
             "nfa_hci_handle_nfcee_config_evt  will be handled later");
         return;
       }
@@ -2731,6 +2716,7 @@ void nfa_hci_handle_nfcee_config_evt(uint16_t event) {
         nfa_hci_cb.nfcee_cfg.discovery_stopped =
             nfa_dm_act_stop_rf_discovery(NULL);
       }
+      [[fallthrough]];
 
     case NFA_HCI_READ_SESSIONID:
       /*Read the session ID of the host discovered */
@@ -2764,7 +2750,7 @@ void nfa_hci_handle_nfcee_config_evt(uint16_t event) {
     nfa_hci_cb.nfcee_cfg.config_nfcee_state = NFA_HCI_NFCEE_CONFIG_COMPLETE;
     nfa_hci_cb.hci_state = NFA_HCI_STATE_IDLE;
 
-    NFA_TRACE_DEBUG0(
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "nfa_hci_handle_nfcee_config_evt  complete , notify upper layer");
     if (nfa_hci_cb.nfcee_cfg.nfc_init_state == true) {
       if (nfa_hciu_check_any_host_reset_pending()) {
@@ -2784,7 +2770,7 @@ void nfa_hci_handle_nfcee_config_evt(uint16_t event) {
 
     if (nfa_hciu_is_no_host_resetting()) nfa_hci_check_pending_api_requests();
   }
-  NFA_TRACE_DEBUG0("nfa_hci_handle_nfcee_config_evt exit");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_handle_nfcee_config_evt exit");
 }
 
 /*******************************************************************************
@@ -2825,25 +2811,25 @@ static void nfa_hci_api_getnoofhosts(uint8_t* p_data, uint8_t data_len) {
 
   nfa_hci_cb.host_count = host_id;
   noofhosts = ((data_len / NFA_HCI_HOST_TYPE_LEN) - 2);
-  NFA_TRACE_DEBUG1("nfa_hci_api_getnoofhosts :-no of hosts in HCI Network-%d",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_api_getnoofhosts :-no of hosts in HCI Network-%d",
                    noofhosts);
   for (count = 0; count < data_len; count++) {
-    NFA_TRACE_DEBUG2("nfa_hci_api_getnoofhosts :data[%d] - %d\n", count,
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_api_getnoofhosts :data[%d] - %d\n", count,
                      p_data[count]);
   }
   for (count = 0; count < noofhosts; count++) {
     host_id = (((count + 1) * NFA_HCI_HOST_TYPE_LEN) + NFA_HCI_HOST_TYPE_LEN);
-    NFA_TRACE_DEBUG1(
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "nfa_hci_api_getnoofhosts -NFA_HCI_HOST_TYPE_LIST_INDEX id -- %d !!!",
         host_id);
     if ((p_data[host_id] & p_data[host_id + 1]) != 0xFF) {
       if ((p_data[host_id] == NFA_HCI_HOST_ID_UICC0) &&
           (p_data[host_id + 1] == 0x00)) {
-        NFA_TRACE_DEBUG0("nfa_hci_api_getnoofhosts :- UICC !!!!");
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_api_getnoofhosts :- UICC !!!!");
         nfa_hci_cb.host_id[nfa_hci_cb.host_count] = p_data[host_id];
         nfa_hci_cb.host_count++;
       } else if ((p_data[host_id] == 0x03) && (p_data[host_id + 1] == 0x00)) {
-        NFA_TRACE_DEBUG0("nfa_hci_api_getnoofhosts :- eSE !!!!");
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_api_getnoofhosts :- eSE !!!!");
         nfa_hci_cb.host_id[nfa_hci_cb.host_count] = 0xC0;
         nfa_hci_cb.host_count++;
       }
@@ -2863,10 +2849,10 @@ static bool nfa_hci_api_checkforAPDUGate(uint8_t* p_data, uint8_t data_len) {
   uint8_t count = 0;
   bool status = false;
   for (count = 0; count < data_len; count++) {
-    NFA_TRACE_DEBUG1("nfa_hci_api_checkforAPDUGate -Gate id -- %d !!!",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_api_checkforAPDUGate -Gate id -- %d !!!",
                      p_data[count]);
     if (p_data[count] == NFA_HCI_ETSI12_APDU_GATE) {
-      NFA_TRACE_DEBUG1("nfa_hci_api_checkforAPDUGate -count -- %d !!!", count);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_api_checkforAPDUGate -count -- %d !!!", count);
       status = true;
       break;
     }
@@ -2895,19 +2881,11 @@ static void nfa_hci_handle_Nfcee_admpipe_rsp(uint8_t* p_data,
   uint8_t count = 0;
   tNFA_HCI_EVT_DATA evt_data;
   tNFA_STATUS status = NFA_STATUS_OK;
-#if (BT_TRACE_VERBOSE == true)
-  NFA_TRACE_DEBUG4(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "nfa_hci_handle_Nfcee_admpipe_rsp - LastCmdSent: %s  App: 0x%04x  Gate: "
       "0x%02x  Pipe: 0x%02x",
-      nfa_hciu_instr_2_str(nfa_hci_cb.cmd_sent), nfa_hci_cb.app_in_use,
+      nfa_hciu_instr_2_str(nfa_hci_cb.cmd_sent).c_str(), nfa_hci_cb.app_in_use,
       nfa_hci_cb.local_gate_in_use, nfa_hci_cb.pipe_in_use);
-#else
-  NFA_TRACE_DEBUG4(
-      "nfa_hci_handle_Nfcee_admpipe_rsp LastCmdSent: %u  App: 0x%04x  Gate: "
-      "0x%02x  Pipe: 0x%02x",
-      nfa_hci_cb.cmd_sent, nfa_hci_cb.app_in_use, nfa_hci_cb.local_gate_in_use,
-      nfa_hci_cb.pipe_in_use);
-#endif
   if (nfa_hci_cb.inst != NFA_HCI_ANY_OK) {
 
     nfa_sys_stop_timer(&nfa_hci_cb.timer);
@@ -2927,22 +2905,22 @@ static void nfa_hci_handle_Nfcee_admpipe_rsp(uint8_t* p_data,
              (nfa_hci_cb.inst == NFA_HCI_ANY_OK)) {
     if (nfa_hci_cb.param_in_use == NFA_HCI_HOST_TYPE_LIST_INDEX) {
       nfa_sys_stop_timer(&nfa_hci_cb.timer);
-      NFA_TRACE_DEBUG0(
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "nfa_hci_handle_admin_gate_rsp - Received the HOST_TYPE_LIST as per "
           "ETSI 12 !!!");
       if (data_len > 4) {
         nfa_hci_api_getnoofhosts(p_data, data_len);
-        NFA_TRACE_DEBUG0(
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
             "nfa_hci_handle_admin_gate_rsp - Calling complete here !!!");
         evt_data.admin_rsp_rcvd.status = NFA_STATUS_OK;
         evt_data.admin_rsp_rcvd.NoHostsPresent = nfa_hci_cb.host_count;
-        NFA_TRACE_DEBUG1(
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
             "nfa_hci_handle_admin_gate_rsp -nfa_hci_cb.host_countt --%d !",
             nfa_hci_cb.host_count);
         if (nfa_hci_cb.host_count > 0) {
           for (count = 0; count < nfa_hci_cb.host_count; count++) {
             evt_data.admin_rsp_rcvd.HostIds[count] = nfa_hci_cb.host_id[count];
-            NFA_TRACE_DEBUG1(
+             DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
                 "nfa_hci_handle_admin_gate_rsp -nfa_hci_cb.host_iddd --%d !",
                 nfa_hci_cb.host_id[count]);
           }
@@ -2950,7 +2928,7 @@ static void nfa_hci_handle_Nfcee_admpipe_rsp(uint8_t* p_data,
         nfa_hciu_send_to_all_apps(NFA_HCI_HOST_TYPE_LIST_READ_EVT, &evt_data);
 
       } else {
-        NFA_TRACE_DEBUG0(
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
             "nfa_hci_handle_admin_gate_rsp -No host is connected!!");
         evt_data.admin_rsp_rcvd.status = status;
         evt_data.admin_rsp_rcvd.NoHostsPresent = 0;
@@ -2966,7 +2944,7 @@ static void nfa_hci_handle_Nfcee_admpipe_rsp(uint8_t* p_data,
     STREAM_TO_UINT8(pipe, p_data);
 
     nfa_hciu_add_pipe_to_static_gate(source_gate, pipe, dest_host, dest_gate);
-    NFA_TRACE_DEBUG0("nfa_hci_handle_Nfcee_admpipe_rsp - Opening pipe!!!");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_handle_Nfcee_admpipe_rsp - Opening pipe!!!");
     nfa_hciu_send_open_pipe_cmd(pipe);
   } else {
     nfa_hci_cb.hci_state = NFA_HCI_STATE_IDLE;
@@ -2989,14 +2967,13 @@ static void nfa_hci_handle_Nfcee_admpipe_rsp(uint8_t* p_data,
 static void nfa_hci_handle_Nfcee_dynpipe_rsp(uint8_t pipeId, uint8_t* p_data,
                                              uint8_t data_len) {
   tNFA_HCI_DYN_PIPE* p_pipe = nfa_hciu_find_pipe_by_pid(pipeId);
-  tNFA_HCI_DYN_GATE* p_gate;
   tNFA_STATUS status = NFA_STATUS_FAILED;
   bool wStatus = false;
   tNFA_HCI_EVT_DATA evt_data;
 
   if (nfa_hci_cb.type == NFA_HCI_RESPONSE_TYPE) {
     nfa_sys_stop_timer(&nfa_hci_cb.timer);
-    NFA_TRACE_DEBUG0("nfa_hci_handle_Nfcee_dynpipe_rsp - HCI Timer stopped!!!");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_handle_Nfcee_dynpipe_rsp - HCI Timer stopped!!!");
     if (nfa_hci_cb.inst != NFA_HCI_ANY_OK) {
       nfa_hci_cb.hci_state = NFA_HCI_STATE_IDLE;
       evt_data.config_rsp_rcvd.status = status;
@@ -3005,9 +2982,9 @@ static void nfa_hci_handle_Nfcee_dynpipe_rsp(uint8_t pipeId, uint8_t* p_data,
       return;
     }
   }
-  if (pipeId == NULL) {
+  if (!pipeId) {
     /* Invalid pipe ID */
-    NFA_TRACE_ERROR1("nfa_hci_handle_Nfcee_dynpipe_rsp - Unknown pipe %d",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_handle_Nfcee_dynpipe_rsp - Unknown pipe %d",
                      pipeId);
     if (nfa_hci_cb.type == NFA_HCI_COMMAND_TYPE)
       nfa_hciu_send_msg(pipeId, NFA_HCI_RESPONSE_TYPE, NFA_HCI_ANY_E_NOK, 0,
@@ -3020,11 +2997,11 @@ static void nfa_hci_handle_Nfcee_dynpipe_rsp(uint8_t pipeId, uint8_t* p_data,
   }
   switch (nfa_hci_cb.cmd_sent) {
     case NFA_HCI_ANY_OPEN_PIPE:
-      NFA_TRACE_DEBUG0(
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "nfa_hci_handle_Nfcee_dynpipe_rsp - Response received open Pipe get "
           "the Gate List on Id Gate!!!");
       if (!p_pipe) {
-        NFA_TRACE_ERROR1(
+        LOG(ERROR) << StringPrintf(
             "nfa_hci_handle_Nfcee_dynpipe_rsp - NULL pipe for PipeId %d",
             pipeId);
         break;
@@ -3037,13 +3014,13 @@ static void nfa_hci_handle_Nfcee_dynpipe_rsp(uint8_t pipeId, uint8_t* p_data,
       break;
     case NFA_HCI_ANY_GET_PARAMETER:
       if (nfa_hci_cb.param_in_use == NFA_HCI_GATES_LIST_INDEX) {
-        NFA_TRACE_DEBUG0(
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
             "nfa_hci_handle_Nfcee_dynpipe_rsp - Response received Gate List on "
             "Id Gate!!!");
         if (data_len > 0) {
           wStatus = nfa_hci_api_checkforAPDUGate(p_data, data_len);
           if (wStatus == true) {
-            NFA_TRACE_DEBUG0(
+             DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
                 "nfa_hci_handle_Nfcee_dynpipe_rsp - creating APDU pipee!!!");
             nfa_hciu_alloc_gate(NFA_HCI_ETSI12_APDU_GATE, NFA_HANDLE_GROUP_HCI);
             nfa_hciu_send_create_pipe_cmd(NFA_HCI_ETSI12_APDU_GATE,
@@ -3058,7 +3035,7 @@ static void nfa_hci_handle_Nfcee_dynpipe_rsp(uint8_t pipeId, uint8_t* p_data,
         }
       } else if (nfa_hci_cb.param_in_use == NFA_HCI_MAX_C_APDU_SIZE_INDEX) {
         // Read the parameter and save in Non volatile Memory
-        NFA_TRACE_DEBUG0(
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
             "nfa_hci_handle_Nfcee_dynpipe_rsp - Read HCI Max Wait time!!!");
         nfa_hciu_send_get_param_cmd(pipeId, NFA_HCI_MAX_WAIT_TIME_INDEX);
       } else if (nfa_hci_cb.param_in_use == NFA_HCI_MAX_WAIT_TIME_INDEX) {
@@ -3072,9 +3049,9 @@ static void nfa_hci_handle_Nfcee_dynpipe_rsp(uint8_t pipeId, uint8_t* p_data,
   if (nfa_hci_cb.type == NFA_HCI_EVENT_TYPE) {
     if (nfa_hci_cb.inst == NFA_HCI_ABORT) {
       // display atr and read first parameter on APDU Gate
-      NFA_TRACE_DEBUG0(
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "nfa_hci_handle_Nfcee_dynpipe_rsp - ATR received read APDU Size!!!");
-      NFA_TRACE_DEBUG0 (
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "nfa_hci_handle_Nfcee_dynpipe_rsp - ETSI12 init complete");
       evt_data.admin_rsp_rcvd.status = NFA_STATUS_OK;
       nfa_hci_cb.hci_state = NFA_HCI_STATE_IDLE;
@@ -3094,12 +3071,12 @@ static void nfa_hci_handle_Nfcee_dynpipe_rsp(uint8_t pipeId, uint8_t* p_data,
 static bool nfa_hci_api_IspipePresent(uint8_t nfceeId, uint8_t gateId) {
   uint8_t count = 0;
   bool status = false;
-  NFA_TRACE_DEBUG0("nfa_hci_api_IspipePresent");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_api_IspipePresent");
   for (count = 0; count < NFA_HCI_MAX_PIPE_CB; count++) {
     if (((nfa_hci_cb.cfg.dyn_pipes[count].dest_host) == nfceeId) &&
         ((nfa_hci_cb.cfg.dyn_pipes[count].dest_gate) == gateId) &&
         ((nfa_hci_cb.cfg.dyn_pipes[count].local_gate) == gateId)) {
-      NFA_TRACE_DEBUG1("nfa_hci_api_IspipePresent -count -- %d !!!", count);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_api_IspipePresent -count -- %d !!!", count);
       status = true;
       break;
     }
@@ -3120,12 +3097,12 @@ static bool nfa_hci_api_GetpipeId(uint8_t nfceeId, uint8_t gateId,
                                   uint8_t* pipeId) {
   uint8_t count = 0;
   bool status = false;
-  NFA_TRACE_DEBUG0("nfa_hci_api_GetpipeId");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_api_GetpipeId");
   for (count = 0; count < NFA_HCI_MAX_PIPE_CB; count++) {
     if (((nfa_hci_cb.cfg.dyn_pipes[count].dest_host) == nfceeId) &&
         ((nfa_hci_cb.cfg.dyn_pipes[count].dest_gate) == gateId) &&
         ((nfa_hci_cb.cfg.dyn_pipes[count].local_gate) == gateId)) {
-      NFA_TRACE_DEBUG1("nfa_hci_api_GetpipeId -count -- %d !!!",
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_api_GetpipeId -count -- %d !!!",
                        nfa_hci_cb.cfg.dyn_pipes[count].pipe_id);
       *pipeId = nfa_hci_cb.cfg.dyn_pipes[count].pipe_id;
       status = true;
@@ -3167,7 +3144,7 @@ tNFA_STATUS nfa_hci_getApduAndConnectivity_PipeStatus()
     {
         status = nfa_hciu_send_raw_cmd(p-p_data, p_data, nfa_hci_get_pipe_state_cb);
     }
-    NFA_TRACE_DEBUG1 ("nfa_hci_getApduConnectivity_PipeStatus %x",*num_param);
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_getApduConnectivity_PipeStatus %x",*num_param);
 
     return status;
 }
@@ -3182,9 +3159,9 @@ tNFA_STATUS nfa_hci_getApduAndConnectivity_PipeStatus()
 ** Returns          None
 **
 *******************************************************************************/
-static void nfa_hci_get_pipe_state_cb(uint8_t event, uint16_t param_len, uint8_t* p_param)
-{
-    uint8_t num_param_id         = 0x00, xx;
+static void nfa_hci_get_pipe_state_cb(__attribute__((unused)) uint8_t event, __attribute__((unused))
+                                          uint16_t param_len, uint8_t* p_param) {
+    uint8_t num_param_id         = 0x00;
     uint8_t NFA_PARAM_ID_INDEX   = 0x04;
     uint8_t param_id1 = 0x00;
     uint8_t param_id2 = 0x00;
@@ -3209,6 +3186,7 @@ static void nfa_hci_get_pipe_state_cb(uint8_t event, uint16_t param_len, uint8_t
                 if(!nfa_hci_api_IspipePresent(NFA_HCI_HOST_ID_ESE, NFA_HCI_ETSI12_APDU_GATE))
                 {
                     nfa_hci_update_pipe_status(NFA_HCI_ETSI12_APDU_GATE, NFA_HCI_APDU_PIPE);
+                    nfa_hci_cb.IsApduPipeStatusNotCorrect = true;
                     if(nfa_hciu_find_gate_by_gid (NFA_HCI_ETSI12_APDU_GATE) == NULL)
                     {
                         tNFA_HCI_DYN_GATE   *pg;
@@ -3222,7 +3200,7 @@ static void nfa_hci_get_pipe_state_cb(uint8_t event, uint16_t param_len, uint8_t
                                 pg->gate_owner    = NFA_HANDLE_GROUP_HCI;
                                 pg->pipe_inx_mask = 0;
 
-                                NFA_TRACE_DEBUG2 ("nfa_hci_alloc_apdu_gate id:%d  app_handle: 0x%04x",
+                                 DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_alloc_apdu_gate id:%d  app_handle: 0x%04x",
                                 NFA_HCI_ETSI12_APDU_GATE, NFA_HANDLE_GROUP_HCI);
                                 break;
                             }
@@ -3276,7 +3254,7 @@ static void nfa_hci_update_pipe_status(uint8_t gateId, uint8_t pipeId)
         ((nfa_hci_cb.cfg.dyn_pipes[count].dest_gate) == gateId)
         &&((nfa_hci_cb.cfg.dyn_pipes[count].local_gate) == gateId))
         {
-            NFA_TRACE_DEBUG1 ("Set the pipe state to open  -- %d !!!",nfa_hci_cb.cfg.dyn_pipes[count].pipe_id);
+             DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Set the pipe state to open  -- %d !!!",nfa_hci_cb.cfg.dyn_pipes[count].pipe_id);
             nfa_hci_cb.cfg.dyn_pipes[count].pipe_state = NFA_HCI_PIPE_OPENED;
             break;
         }
diff --git a/src/nfa/hci/nfa_hci_api.c b/src/nfa/hci/nfa_hci_api.cc
old mode 100644
new mode 100755
similarity index 80%
rename from src/nfa/hci/nfa_hci_api.c
rename to src/nfa/hci/nfa_hci_api.cc
index 0c499c7..c41f152
--- a/src/nfa/hci/nfa_hci_api.c
+++ b/src/nfa/hci/nfa_hci_api.cc
@@ -1,8 +1,9 @@
 /******************************************************************************
+ *
  *  Copyright (c) 2016, The Linux Foundation. All rights reserved.
  *  Not a Contribution.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *  The original Work has been changed by NXP Semiconductors.
  *
  *  Copyright (C) 2010-2014 Broadcom Corporation
@@ -25,15 +26,22 @@
  *  NFA interface to HCI
  *
  ******************************************************************************/
-#include <string.h>
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include <unistd.h>
-#include "nfc_api.h"
-#include "nfa_sys.h"
-#include "nfa_sys_int.h"
 #include "nfa_hci_api.h"
 #include "nfa_hci_int.h"
 #include "nfa_hci_defs.h"
 
+
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+
+#if (NXP_EXTNS == TRUE)
+bool MW_RCVRY_FW_DNLD_ALLOWED;
+#endif
 /*******************************************************************************
 **
 ** Function         NFA_HciRegister
@@ -57,18 +65,16 @@ tNFA_STATUS NFA_HciRegister(char* p_app_name, tNFA_HCI_CBACK* p_cback,
   uint8_t app_name_len;
 
   if (p_app_name == NULL) {
-    NFA_TRACE_API0("NFA_HciRegister (): Invalid Application name");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(" %s: NFAInvalid Application name",__func__);
     return (NFA_STATUS_FAILED);
   }
 
   if (p_cback == NULL) {
-    NFA_TRACE_API0(
-        "NFA_HciRegister (): Application should provide callback function to "
-        "register!");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Application should provide callback function to register!",__func__);
     return (NFA_STATUS_FAILED);
   }
 
-  NFA_TRACE_API1("NFA_HciRegister (): Application Name: %s", p_app_name);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Application Name: %s", __func__, p_app_name);
 
   app_name_len = (uint8_t)strlen(p_app_name);
 
@@ -79,11 +85,11 @@ tNFA_STATUS NFA_HciRegister(char* p_app_name, tNFA_HCI_CBACK* p_cback,
             sizeof(tNFA_HCI_API_REGISTER_APP))) != NULL)) {
     p_msg->hdr.event = NFA_HCI_API_REGISTER_APP_EVT;
 
-        /* Save application name and callback */
-        memset (p_msg->app_name, 0, sizeof (p_msg->app_name));
-        NQ_STRLCPY_S (p_msg->app_name, sizeof (p_msg->app_name), p_app_name, NFA_MAX_HCI_APP_NAME_LEN);
-        p_msg->p_cback          = p_cback;
-        p_msg->b_send_conn_evts = b_send_conn_evts;
+    /* Save application name and callback */
+    memset(p_msg->app_name, 0, sizeof(p_msg->app_name));
+    NQ_STRLCPY_S (p_msg->app_name, sizeof (p_msg->app_name), p_app_name, NFA_MAX_HCI_APP_NAME_LEN);
+    p_msg->p_cback = p_cback;
+    p_msg->b_send_conn_evts = b_send_conn_evts;
 
     nfa_sys_sendmsg(p_msg);
     return (NFA_STATUS_OK);
@@ -112,12 +118,12 @@ tNFA_STATUS NFA_HciGetGateAndPipeList(tNFA_HANDLE hci_handle) {
   tNFA_HCI_API_GET_APP_GATE_PIPE* p_msg;
 
   if ((NFA_HANDLE_GROUP_MASK & hci_handle) != NFA_HANDLE_GROUP_HCI) {
-    NFA_TRACE_API1("NFA_HciGetGateAndPipeList (): Invalid hci_handle:0x%04x",
-                   hci_handle);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Invalid hci_handle:0x%04x",
+                                        __func__,hci_handle);
     return (NFA_STATUS_FAILED);
   }
 
-  NFA_TRACE_API1("NFA_HciGetGateAndPipeList (): hci_handle:0x%04x", hci_handle);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: hci_handle:0x%04x",__func__, hci_handle);
 
   /* Register the application with HCI */
   if ((nfa_hci_cb.hci_state != NFA_HCI_STATE_DISABLED) &&
@@ -155,11 +161,11 @@ tNFA_STATUS NFA_HciDeregister(char* p_app_name) {
   uint8_t app_name_len;
 
   if (p_app_name == NULL) {
-    NFA_TRACE_API0("NFA_HciDeregister (): Invalid Application");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Invalid Application",__func__);
     return (NFA_STATUS_FAILED);
   }
 
-  NFA_TRACE_API1("NFA_HciDeregister (): Application Name: %s", p_app_name);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("N%s: Application Name: %s", __func__,p_app_name);
   app_name_len = (uint8_t)strlen(p_app_name);
 
   if (app_name_len > NFA_MAX_HCI_APP_NAME_LEN) return (NFA_STATUS_FAILED);
@@ -173,8 +179,8 @@ tNFA_STATUS NFA_HciDeregister(char* p_app_name) {
   }
 
   if (xx == NFA_HCI_MAX_APP_CB) {
-    NFA_TRACE_ERROR1("NFA_HciDeregister (): Application Name: %s  NOT FOUND",
-                     p_app_name);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Application Name: %s  NOT FOUND",
+                                        __func__,p_app_name);
     return (NFA_STATUS_FAILED);
   }
 
@@ -184,8 +190,8 @@ tNFA_STATUS NFA_HciDeregister(char* p_app_name) {
             sizeof(tNFA_HCI_API_DEREGISTER_APP))) != NULL)) {
     p_msg->hdr.event = NFA_HCI_API_DEREGISTER_APP_EVT;
 
-        memset (p_msg->app_name, 0, sizeof (p_msg->app_name));
-        NQ_STRLCPY_S (p_msg->app_name, sizeof (p_msg->app_name), p_app_name, NFA_MAX_HCI_APP_NAME_LEN);
+    memset(p_msg->app_name, 0, sizeof(p_msg->app_name));
+    NQ_STRLCPY_S (p_msg->app_name, sizeof (p_msg->app_name), p_app_name, NFA_MAX_HCI_APP_NAME_LEN);
 
     nfa_sys_sendmsg(p_msg);
     return (NFA_STATUS_OK);
@@ -215,20 +221,20 @@ tNFA_STATUS NFA_HciAllocGate(tNFA_HANDLE hci_handle, uint8_t gate) {
   tNFA_HCI_API_ALLOC_GATE* p_msg;
 
   if ((NFA_HANDLE_GROUP_MASK & hci_handle) != NFA_HANDLE_GROUP_HCI) {
-    NFA_TRACE_API1("NFA_HciAllocGate (): Invalid hci_handle:0x%04x",
-                   hci_handle);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Invalid hci_handle:0x%04x",
+                   __func__, hci_handle);
     return (NFA_STATUS_FAILED);
   }
 
   if ((gate) && ((gate < NFA_HCI_FIRST_HOST_SPECIFIC_GENERIC_GATE) ||
                  (gate > NFA_HCI_LAST_PROP_GATE) ||
                  (gate == NFA_HCI_CONNECTIVITY_GATE))) {
-    NFA_TRACE_API1("NFA_HciAllocGate (): Cannot allocate gate:0x%02x", gate);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Cannot allocate gate:0x%02x", __func__, gate);
     return (NFA_STATUS_FAILED);
   }
 
-  NFA_TRACE_API2("NFA_HciAllocGate (): hci_handle:0x%04x, Gate:0x%02x",
-                 hci_handle, gate);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: hci_handle:0x%04x, Gate:0x%02x",
+                 __func__, hci_handle, gate);
 
   /* Request HCI to allocate gate to the application */
   if ((nfa_hci_cb.hci_state != NFA_HCI_STATE_DISABLED) &&
@@ -261,20 +267,20 @@ tNFA_STATUS NFA_HciDeallocGate(tNFA_HANDLE hci_handle, uint8_t gate) {
   tNFA_HCI_API_DEALLOC_GATE* p_msg;
 
   if ((NFA_HANDLE_GROUP_MASK & hci_handle) != NFA_HANDLE_GROUP_HCI) {
-    NFA_TRACE_API1("NFA_HciDeallocGate (): Invalid hci_handle:0x%04x",
-                   hci_handle);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Invalid hci_handle:0x%04x",
+                   __func__, hci_handle);
     return (NFA_STATUS_FAILED);
   }
 
   if ((gate < NFA_HCI_FIRST_HOST_SPECIFIC_GENERIC_GATE) ||
       (gate > NFA_HCI_LAST_PROP_GATE) || (gate == NFA_HCI_CONNECTIVITY_GATE)) {
-    NFA_TRACE_API1("NFA_HciDeallocGate (): Cannot deallocate the gate:0x%02x",
-                   gate);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Cannot deallocate the gate:0x%02x",
+                   __func__, gate);
     return (NFA_STATUS_FAILED);
   }
 
-  NFA_TRACE_API2("NFA_HciDeallocGate (): hci_handle:0x%04x, gate:0x%02X",
-                 hci_handle, gate);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: hci_handle:0x%04x, gate:0x%02X",
+                 __func__, hci_handle, gate);
 
   /* Request HCI to deallocate the gate that was previously allocated to the
    * application */
@@ -308,12 +314,12 @@ tNFA_STATUS NFA_HciGetHostList(tNFA_HANDLE hci_handle) {
   tNFA_HCI_API_GET_HOST_LIST* p_msg;
 
   if ((NFA_HANDLE_GROUP_MASK & hci_handle) != NFA_HANDLE_GROUP_HCI) {
-    NFA_TRACE_API1("NFA_HciGetHostList (): Invalid hci_handle:0x%04x",
-                   hci_handle);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("N%s: Invalid hci_handle:0x%04x",
+                   __func__, hci_handle);
     return (NFA_STATUS_FAILED);
   }
 
-  NFA_TRACE_API1("NFA_HciGetHostList (): hci_handle:0x%04x", hci_handle);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: hci_handle:0x%04x", __func__, hci_handle);
 
   /* Request HCI to get list of host in the hci network */
   if ((nfa_hci_cb.hci_state != NFA_HCI_STATE_DISABLED) &&
@@ -354,21 +360,21 @@ tNFA_STATUS NFA_HciCreatePipe(tNFA_HANDLE hci_handle, uint8_t source_gate_id,
   tNFA_HCI_API_CREATE_PIPE_EVT* p_msg;
   uint8_t xx;
 
-  NFA_TRACE_API4(
-      "NFA_HciCreatePipe (): hci_handle:0x%04x, source gate:0x%02X, "
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+      "%s: hci_handle:0x%04x, source gate:0x%02X, "
       "destination host:0x%02X , destination gate:0x%02X",
-      hci_handle, source_gate_id, dest_host, dest_gate);
+      __func__ , hci_handle, source_gate_id, dest_host, dest_gate);
 
   if ((NFA_HANDLE_GROUP_MASK & hci_handle) != NFA_HANDLE_GROUP_HCI) {
-    NFA_TRACE_API1("NFA_HciCreatePipe (): Invalid hci_handle:0x%04x",
-                   hci_handle);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Invalid hci_handle:0x%04x",
+                   __func__, hci_handle);
     return (NFA_STATUS_FAILED);
   }
 
   if ((source_gate_id < NFA_HCI_FIRST_HOST_SPECIFIC_GENERIC_GATE) ||
       (source_gate_id > NFA_HCI_LAST_PROP_GATE)) {
-    NFA_TRACE_API1("NFA_HciCreatePipe (): Invalid local Gate:0x%02x",
-                   source_gate_id);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Invalid local Gate:0x%02x",
+                   __func__, source_gate_id);
     return (NFA_STATUS_FAILED);
   }
 
@@ -376,8 +382,8 @@ tNFA_STATUS NFA_HciCreatePipe(tNFA_HANDLE hci_handle, uint8_t source_gate_id,
        (dest_gate != NFA_HCI_LOOP_BACK_GATE) &&
        (dest_gate != NFA_HCI_IDENTITY_MANAGEMENT_GATE)) ||
       (dest_gate > NFA_HCI_LAST_PROP_GATE)) {
-    NFA_TRACE_API1("NFA_HciCreatePipe (): Invalid Destination Gate:0x%02x",
-                   dest_gate);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Invalid Destination Gate:0x%02x",
+                   __func__, dest_gate);
     return (NFA_STATUS_FAILED);
   }
 
@@ -385,7 +391,7 @@ tNFA_STATUS NFA_HciCreatePipe(tNFA_HANDLE hci_handle, uint8_t source_gate_id,
     if (nfa_hci_cb.inactive_host[xx] == dest_host) break;
 
   if (xx != NFA_HCI_MAX_HOST_IN_NETWORK) {
-    NFA_TRACE_API1("NFA_HciCreatePipe (): Host not active:0x%02x", dest_host);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Host not active:0x%02x", __func__, dest_host);
     return (NFA_STATUS_FAILED);
   }
 
@@ -423,17 +429,17 @@ tNFA_STATUS NFA_HciOpenPipe(tNFA_HANDLE hci_handle, uint8_t pipe) {
   tNFA_HCI_API_OPEN_PIPE_EVT* p_msg;
 
   if ((NFA_HANDLE_GROUP_MASK & hci_handle) != NFA_HANDLE_GROUP_HCI) {
-    NFA_TRACE_API1("NFA_HciOpenPipe (): Invalid hci_handle:0x%04x", hci_handle);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciOpenPipe (): Invalid hci_handle:0x%04x", hci_handle);
     return (NFA_STATUS_FAILED);
   }
 
   if ((pipe < NFA_HCI_FIRST_DYNAMIC_PIPE) ||
       (pipe > NFA_HCI_LAST_DYNAMIC_PIPE)) {
-    NFA_TRACE_API1("NFA_HciOpenPipe (): Invalid Pipe:0x%02x", pipe);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciOpenPipe (): Invalid Pipe:0x%02x", pipe);
     return (NFA_STATUS_FAILED);
   }
 
-  NFA_TRACE_API2("NFA_HciOpenPipe (): hci_handle:0x%04x, pipe:0x%02X",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciOpenPipe (): hci_handle:0x%04x, pipe:0x%02X",
                  hci_handle, pipe);
 
   /* Request HCI to open a pipe if it is in closed state */
@@ -472,17 +478,17 @@ tNFA_STATUS NFA_HciGetRegistry(tNFA_HANDLE hci_handle, uint8_t pipe,
   tNFA_HCI_API_GET_REGISTRY* p_msg;
 
   if ((NFA_HANDLE_GROUP_MASK & hci_handle) != NFA_HANDLE_GROUP_HCI) {
-    NFA_TRACE_API1("NFA_HciGetRegistry (): Invalid hci_handle:0x%04x",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciGetRegistry (): Invalid hci_handle:0x%04x",
                    hci_handle);
     return (NFA_STATUS_FAILED);
   }
 
   if (pipe < NFA_HCI_FIRST_DYNAMIC_PIPE) {
-    NFA_TRACE_API1("NFA_HciGetRegistry (): Invalid Pipe:0x%02x", pipe);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciGetRegistry (): Invalid Pipe:0x%02x", pipe);
     return (NFA_STATUS_FAILED);
   }
 
-  NFA_TRACE_API2("NFA_HciGetRegistry (): hci_handle:0x%04x  Pipe: 0x%02x",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciGetRegistry (): hci_handle:0x%04x  Pipe: 0x%02x",
                  hci_handle, pipe);
 
   /* Request HCI to get list of gates supported by the specified host */
@@ -502,7 +508,7 @@ tNFA_STATUS NFA_HciGetRegistry(tNFA_HANDLE hci_handle, uint8_t pipe,
 }
 
 /*******************************************************************************
-**
+ **
 ** Function         NFA_HciSetRegistry
 **
 ** Description      This function requests a peer host to set the desired
@@ -523,24 +529,24 @@ extern tNFA_STATUS NFA_HciSetRegistry(tNFA_HANDLE hci_handle, uint8_t pipe,
   tNFA_HCI_API_SET_REGISTRY* p_msg;
 
   if ((NFA_HANDLE_GROUP_MASK & hci_handle) != NFA_HANDLE_GROUP_HCI) {
-    NFA_TRACE_API1("NFA_HciSetRegistry (): Invalid hci_handle:0x%04x",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciSetRegistry (): Invalid hci_handle:0x%04x",
                    hci_handle);
     return (NFA_STATUS_FAILED);
   }
 
   if (pipe < NFA_HCI_FIRST_DYNAMIC_PIPE) {
-    NFA_TRACE_API1("NFA_HciSetRegistry (): Invalid Pipe:0x%02x", pipe);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciSetRegistry (): Invalid Pipe:0x%02x", pipe);
     return (NFA_STATUS_FAILED);
   }
 
   if ((data_size == 0) || (p_data == NULL) ||
       (data_size > NFA_MAX_HCI_CMD_LEN)) {
-    NFA_TRACE_API1("NFA_HciSetRegistry (): Invalid data size:0x%02x",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciSetRegistry (): Invalid data size:0x%02x",
                    data_size);
     return (NFA_STATUS_FAILED);
   }
 
-  NFA_TRACE_API2("NFA_HciSetRegistry (): hci_handle:0x%04x  Pipe: 0x%02x",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciSetRegistry (): hci_handle:0x%04x  Pipe: 0x%02x",
                  hci_handle, pipe);
 
   /* Request HCI to get list of gates supported by the specified host */
@@ -582,22 +588,22 @@ tNFA_STATUS NFA_HciSendCommand(tNFA_HANDLE hci_handle, uint8_t pipe,
   tNFA_HCI_API_SEND_CMD_EVT* p_msg;
 
   if ((NFA_HANDLE_GROUP_MASK & hci_handle) != NFA_HANDLE_GROUP_HCI) {
-    NFA_TRACE_API1("NFA_HciSendCommand (): Invalid hci_handle:0x%04x",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciSendCommand (): Invalid hci_handle:0x%04x",
                    hci_handle);
     return (NFA_STATUS_FAILED);
   }
 
   if (pipe < NFA_HCI_FIRST_DYNAMIC_PIPE) {
-    NFA_TRACE_API1("NFA_HciSendCommand (): Invalid Pipe:0x%02x", pipe);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciSendCommand (): Invalid Pipe:0x%02x", pipe);
     return (NFA_STATUS_FAILED);
   }
 
   if ((cmd_size && (p_data == NULL)) || (cmd_size > NFA_MAX_HCI_CMD_LEN)) {
-    NFA_TRACE_API1("NFA_HciSendCommand (): Invalid cmd size:0x%02x", cmd_size);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciSendCommand (): Invalid cmd size:0x%02x", cmd_size);
     return (NFA_STATUS_FAILED);
   }
 
-  NFA_TRACE_API3(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "NFA_HciSendCommand (): hci_handle:0x%04x, pipe:0x%02x  Code: 0x%02x",
       hci_handle, pipe, cmd_code);
 
@@ -620,64 +626,6 @@ tNFA_STATUS NFA_HciSendCommand(tNFA_HANDLE hci_handle, uint8_t pipe,
   return (NFA_STATUS_FAILED);
 }
 
-/*******************************************************************************
-**
-** Function         NFA_HciSendResponse
-**
-** Description      This function is called to send a response on a pipe created
-**                  by the application.
-**                  The app will be notified by NFA_HCI_RSP_SENT_EVT if an error
-**                  occurs.
-**
-** Returns          NFA_STATUS_OK if successfully initiated
-**                  NFA_STATUS_FAILED otherwise
-**
-*******************************************************************************/
-extern tNFA_STATUS NFA_HciSendResponse(tNFA_HANDLE hci_handle, uint8_t pipe,
-                                       uint8_t response, uint8_t data_size,
-                                       uint8_t* p_data) {
-  tNFA_HCI_API_SEND_RSP_EVT* p_msg;
-
-  if ((NFA_HANDLE_GROUP_MASK & hci_handle) != NFA_HANDLE_GROUP_HCI) {
-    NFA_TRACE_API1("NFA_HciSendResponse (): Invalid hci_handle:0x%04x",
-                   hci_handle);
-    return (NFA_STATUS_FAILED);
-  }
-
-  if (pipe < NFA_HCI_FIRST_DYNAMIC_PIPE) {
-    NFA_TRACE_API1("NFA_HciSendResponse (): Invalid Pipe:0x%02x", pipe);
-    return (NFA_STATUS_FAILED);
-  }
-
-  if ((data_size && (p_data == NULL)) || (data_size > NFA_MAX_HCI_RSP_LEN)) {
-    NFA_TRACE_API1("NFA_HciSendResponse (): Invalid data size:0x%02x",
-                   data_size);
-    return (NFA_STATUS_FAILED);
-  }
-
-  NFA_TRACE_API3(
-      "NFA_HciSendResponse (): hci_handle:0x%04x  Pipe: 0x%02x  Response: "
-      "0x%02x",
-      hci_handle, pipe, response);
-
-  /* Request HCI to get list of gates supported by the specified host */
-  if ((nfa_hci_cb.hci_state != NFA_HCI_STATE_DISABLED) &&
-      ((p_msg = (tNFA_HCI_API_SEND_RSP_EVT*)GKI_getbuf(
-            sizeof(tNFA_HCI_API_SEND_RSP_EVT))) != NULL)) {
-    p_msg->hdr.event = NFA_HCI_API_SEND_RSP_EVT;
-    p_msg->hci_handle = hci_handle;
-    p_msg->response = response;
-    p_msg->size = data_size;
-
-    if (data_size) memcpy(p_msg->data, p_data, data_size);
-
-    nfa_sys_sendmsg(p_msg);
-    return (NFA_STATUS_OK);
-  }
-
-  return (NFA_STATUS_FAILED);
-}
-
 /*******************************************************************************
 **
 ** Function         NFA_HciSendEvent
@@ -721,28 +669,28 @@ tNFA_STATUS NFA_HciSendEvent(tNFA_HANDLE hci_handle, uint8_t pipe,
 {
   tNFA_HCI_API_SEND_EVENT_EVT* p_msg;
 
-  NFA_TRACE_API3(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "NFA_HciSendEvent(): hci_handle:0x%04x, pipe:0x%02x  Code: 0x%02x",
       hci_handle, pipe, evt_code);
 
   if ((NFA_HANDLE_GROUP_MASK & hci_handle) != NFA_HANDLE_GROUP_HCI) {
-    NFA_TRACE_API1("NFA_HciSendEvent (): Invalid hci_handle:0x%04x",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciSendEvent (): Invalid hci_handle:0x%04x",
                    hci_handle);
     return (NFA_STATUS_FAILED);
   }
 
   if (pipe < NFA_HCI_FIRST_DYNAMIC_PIPE) {
-    NFA_TRACE_API1("NFA_HciSendEvent (): Invalid Pipe:0x%02x", pipe);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciSendEvent (): Invalid Pipe:0x%02x", pipe);
     return (NFA_STATUS_FAILED);
   }
 
   if (evt_size && (p_data == NULL)) {
-    NFA_TRACE_API1("NFA_HciSendEvent (): Invalid Event size:0x%02x", evt_size);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciSendEvent (): Invalid Event size:0x%02x", evt_size);
     return (NFA_STATUS_FAILED);
   }
 
   if (rsp_size && (p_rsp_buf == NULL)) {
-    NFA_TRACE_API1(
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "NFA_HciSendEvent (): No Event buffer, but invalid event buffer size "
         ":%u",
         rsp_size);
@@ -786,18 +734,18 @@ tNFA_STATUS NFA_HciSendEvent(tNFA_HANDLE hci_handle, uint8_t pipe,
 tNFA_STATUS NFA_HciClosePipe(tNFA_HANDLE hci_handle, uint8_t pipe) {
   tNFA_HCI_API_CLOSE_PIPE_EVT* p_msg;
 
-  NFA_TRACE_API2("NFA_HciClosePipe (): hci_handle:0x%04x, pipe:0x%02X",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciClosePipe (): hci_handle:0x%04x, pipe:0x%02X",
                  hci_handle, pipe);
 
   if ((NFA_HANDLE_GROUP_MASK & hci_handle) != NFA_HANDLE_GROUP_HCI) {
-    NFA_TRACE_API1("NFA_HciClosePipe (): Invalid hci_handle:0x%04x",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciClosePipe (): Invalid hci_handle:0x%04x",
                    hci_handle);
     return (NFA_STATUS_FAILED);
   }
 
   if ((pipe < NFA_HCI_FIRST_DYNAMIC_PIPE) ||
       (pipe > NFA_HCI_LAST_DYNAMIC_PIPE)) {
-    NFA_TRACE_API1("NFA_HciClosePipe (): Invalid Pipe:0x%02x", pipe);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciClosePipe (): Invalid Pipe:0x%02x", pipe);
     return (NFA_STATUS_FAILED);
   }
 
@@ -836,18 +784,18 @@ tNFA_STATUS NFA_HciDeletePipe(tNFA_HANDLE hci_handle, uint8_t pipe) {
   tNFA_HCI_API_DELETE_PIPE_EVT* p_msg;
 
   if ((NFA_HANDLE_GROUP_MASK & hci_handle) != NFA_HANDLE_GROUP_HCI) {
-    NFA_TRACE_API1("NFA_HciDeletePipe (): Invalid hci_handle:0x%04x",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciDeletePipe (): Invalid hci_handle:0x%04x",
                    hci_handle);
     return (NFA_STATUS_FAILED);
   }
 
   if ((pipe < NFA_HCI_FIRST_DYNAMIC_PIPE) ||
       (pipe > NFA_HCI_LAST_DYNAMIC_PIPE)) {
-    NFA_TRACE_API1("NFA_HciDeletePipe (): Invalid Pipe:0x%02x", pipe);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciDeletePipe (): Invalid Pipe:0x%02x", pipe);
     return (NFA_STATUS_FAILED);
   }
 
-  NFA_TRACE_API2("NFA_HciDeletePipe (): hci_handle:0x%04x, pipe:0x%02X",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciDeletePipe (): hci_handle:0x%04x, pipe:0x%02X",
                  hci_handle, pipe);
 
   /* Request HCI to delete a pipe created by the application identified by hci
@@ -885,7 +833,7 @@ tNFA_STATUS NFA_HciAddStaticPipe(tNFA_HANDLE hci_handle, uint8_t host,
   uint8_t xx;
 
   if ((NFA_HANDLE_GROUP_MASK & hci_handle) != NFA_HANDLE_GROUP_HCI) {
-    NFA_TRACE_API1("NFA_HciAddStaticPipe (): Invalid hci_handle:0x%04x",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciAddStaticPipe (): Invalid hci_handle:0x%04x",
                    hci_handle);
     return (NFA_STATUS_FAILED);
   }
@@ -894,7 +842,7 @@ tNFA_STATUS NFA_HciAddStaticPipe(tNFA_HANDLE hci_handle, uint8_t host,
     if (nfa_hci_cb.inactive_host[xx] == host) break;
 
   if (xx != NFA_HCI_MAX_HOST_IN_NETWORK) {
-    NFA_TRACE_API1("NFA_HciAddStaticPipe (): Host not active:0x%02x", host);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciAddStaticPipe (): Host not active:0x%02x", host);
     return (NFA_STATUS_FAILED);
   }
 
@@ -904,16 +852,16 @@ tNFA_STATUS NFA_HciAddStaticPipe(tNFA_HANDLE hci_handle, uint8_t host,
               (gate != NFA_HCI_CONNECTIVITY_GATE))
 #endif
           ) {
-    NFA_TRACE_API1("NFA_HciAddStaticPipe (): Invalid Gate:0x%02x", gate);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciAddStaticPipe (): Invalid Gate:0x%02x", gate);
     return (NFA_STATUS_FAILED);
   }
 #if (NXP_EXTNS != TRUE)
   if (pipe <= NFA_HCI_LAST_DYNAMIC_PIPE) {
-    NFA_TRACE_API1("NFA_HciAddStaticPipe (): Invalid Pipe:0x%02x", pipe);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciAddStaticPipe (): Invalid Pipe:0x%02x", pipe);
     return (NFA_STATUS_FAILED);
   }
 #endif
-  NFA_TRACE_API2("NFA_HciAddStaticPipe (): hci_handle:0x%04x, pipe:0x%02X",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciAddStaticPipe (): hci_handle:0x%04x, pipe:0x%02X",
                  hci_handle, pipe);
 
   /* Request HCI to delete a pipe created by the application identified by hci
@@ -950,28 +898,28 @@ void NFA_HciDebug(uint8_t action, uint8_t size, uint8_t* p_data) {
 
   switch (action) {
     case NFA_HCI_DEBUG_DISPLAY_CB:
-      NFA_TRACE_API0("NFA_HciDebug  Host List:");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciDebug  Host List:");
       for (xx = 0; xx < NFA_HCI_MAX_APP_CB; xx++) {
         if (nfa_hci_cb.cfg.reg_app_names[xx][0] != 0) {
-          NFA_TRACE_API2("              Host Inx:  %u   Name: %s", xx,
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("              Host Inx:  %u   Name: %s", xx,
                          &nfa_hci_cb.cfg.reg_app_names[xx][0]);
         }
       }
 
-      NFA_TRACE_API0("NFA_HciDebug  Gate List:");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciDebug  Gate List:");
       for (xx = 0; xx < NFA_HCI_MAX_GATE_CB; xx++, pg++) {
         if (pg->gate_id != 0) {
-          NFA_TRACE_API4(
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
               "              Gate Inx: %x  ID: 0x%02x  Owner: 0x%04x  "
               "PipeInxMask: 0x%08x",
               xx, pg->gate_id, pg->gate_owner, pg->pipe_inx_mask);
         }
       }
 
-      NFA_TRACE_API0("NFA_HciDebug  Pipe List:");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciDebug  Pipe List:");
       for (xx = 0; xx < NFA_HCI_MAX_PIPE_CB; xx++, pp++) {
         if (pp->pipe_id != 0) {
-          NFA_TRACE_API6(
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
               "              Pipe Inx: %x  ID: 0x%02x  State: %u  LocalGate: "
               "0x%02x  Dest Gate: 0x%02x  Host: 0x%02x",
               xx, pp->pipe_id, pp->pipe_state, pp->local_gate, pp->dest_gate,
@@ -996,12 +944,12 @@ void NFA_HciDebug(uint8_t action, uint8_t size, uint8_t* p_data) {
       break;
 
     case NFA_HCI_DEBUG_ENABLE_LOOPBACK:
-      NFA_TRACE_API0("NFA_HciDebug  HCI_LOOPBACK_DEBUG = true");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciDebug  HCI_LOOPBACK_DEBUG = true");
       HCI_LOOPBACK_DEBUG = true;
       break;
 
     case NFA_HCI_DEBUG_DISABLE_LOOPBACK:
-      NFA_TRACE_API0("NFA_HciDebug  HCI_LOOPBACK_DEBUG = false");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciDebug  HCI_LOOPBACK_DEBUG = false");
       HCI_LOOPBACK_DEBUG = false;
       break;
   }
@@ -1020,8 +968,8 @@ void NFA_HciDebug(uint8_t action, uint8_t size, uint8_t* p_data) {
 *******************************************************************************/
 bool NFA_MW_Fwdnlwd_Recovery(bool mw_fwdnld_recovery) {
     if(!nfcFL.nfccFL._NFCC_MW_RCVRY_BLK_FW_DNLD) {
-        NFA_TRACE_API0("NFA_MW_Fwdnlwd_Recovery"
-                "  NFCC_MW_RCVRY_BLK_FW_DNLD not available. Returning");
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_MW_Fwdnlwd_Recovery "
+                                "NFCC_MW_RCVRY_BLK_FW_DNLD not available. Returning");
         return false;
     }
     if (mw_fwdnld_recovery) {
@@ -1043,7 +991,7 @@ bool NFA_MW_Fwdnlwd_Recovery(bool mw_fwdnld_recovery) {
 **
 *******************************************************************************/
 void NFA_HciW4eSETransaction_Complete(tNFA_HCI_TRANSCV_STATE type) {
-  NFA_TRACE_API1("NFA_HciW4eSETransaction_Complete; type=%u", type);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciW4eSETransaction_Complete; type=%u", type);
   uint8_t retry_cnt = 0;
   uint8_t max_time = NFA_HCI_MAX_RSP_WAIT_TIME;
 
@@ -1057,7 +1005,7 @@ void NFA_HciW4eSETransaction_Complete(tNFA_HCI_TRANSCV_STATE type) {
         break;
     } while (retry_cnt++ < max_time);
   }
-  NFA_TRACE_API0("NFA_HciW4eSETransaction_Complete; End");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciW4eSETransaction_Complete; End");
 }
 
 /*******************************************************************************
@@ -1076,7 +1024,7 @@ void NFA_HciW4eSETransaction_Complete(tNFA_HCI_TRANSCV_STATE type) {
 *******************************************************************************/
 tNFA_STATUS NFA_HciConfigureNfceeETSI12() {
   tNFA_HCI_API_CONFIGURE_EVT* p_msg;
-  NFA_TRACE_API0("NFA_HciConfigureNfceeETSI12 (): Entry");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciConfigureNfceeETSI12 (): Entry");
 
   /* Request HCI to post event data on a Admin pipe */
   /* Register the application with HCI */
@@ -1084,7 +1032,7 @@ tNFA_STATUS NFA_HciConfigureNfceeETSI12() {
       (nfa_hci_cb.host_count != 0) &&
       ((p_msg = (tNFA_HCI_API_CONFIGURE_EVT*)GKI_getbuf(
             sizeof(tNFA_HCI_API_CONFIGURE_EVT))) != NULL)) {
-    NFA_TRACE_API1("NFA_HciConfigureNfceeETSI12 (): Entry HCI state - %d",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_HciConfigureNfceeETSI12 (): Entry HCI state - %d",
                    nfa_hci_cb.hci_state);
     p_msg->hdr.event = NFA_HCI_API_CONFIGURE_EVT;
     p_msg->config_nfcee_event = NFA_HCI_INIT_NFCEE_CONFIG;
@@ -1094,4 +1042,21 @@ tNFA_STATUS NFA_HciConfigureNfceeETSI12() {
 
   return (NFA_STATUS_FAILED);
 }
+/*******************************************************************************
+**
+** Function         NFA_IsPipeStatusNotCorrect
+**
+** Description      Checks and resets pipe status
+**
+** Returns          TRUE/FALSE
+**
+*******************************************************************************/
+bool NFA_IsPipeStatusNotCorrect()
+{
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_IsPipeStatusNotCorrect (): pipe status not correct: %d", nfa_hci_cb.IsApduPipeStatusNotCorrect);
+  bool status;
+  status = nfa_hci_cb.IsApduPipeStatusNotCorrect;
+  nfa_hci_cb.IsApduPipeStatusNotCorrect = false;
+  return status;
+}
 #endif
diff --git a/src/nfa/hci/nfa_hci_ci.c b/src/nfa/hci/nfa_hci_ci.cc
similarity index 96%
rename from src/nfa/hci/nfa_hci_ci.c
rename to src/nfa/hci/nfa_hci_ci.cc
index 0cdcf93..dd11727 100644
--- a/src/nfa/hci/nfa_hci_ci.c
+++ b/src/nfa/hci/nfa_hci_ci.cc
@@ -22,7 +22,6 @@
  *
  ******************************************************************************/
 #include <string.h>
-#include "nfa_sys.h"
 #include "nfa_hci_api.h"
 #include "nfa_hci_int.h"
 #include "nfa_nv_co.h"
@@ -70,7 +69,8 @@ void nfa_nv_ci_write(tNFA_NV_CO_STATUS status) {
   p_msg = (tNFA_HCI_EVENT_DATA*)GKI_getbuf(sizeof(tNFA_HCI_EVENT_DATA));
   if (p_msg != NULL) {
     p_msg->nv_write.hdr.event = NFA_HCI_RSP_NV_WRITE_EVT;
-    p_msg->nv_write.status = 0;
+    p_msg->nv_write.status =
+        (status == NFA_NV_CO_OK) ? NFA_STATUS_OK : NFA_STATUS_FAILED;
     nfa_sys_sendmsg(p_msg);
   }
 }
diff --git a/src/nfa/hci/nfa_hci_main.c b/src/nfa/hci/nfa_hci_main.cc
old mode 100644
new mode 100755
similarity index 92%
rename from src/nfa/hci/nfa_hci_main.c
rename to src/nfa/hci/nfa_hci_main.cc
index 1d98f25..10cd622
--- a/src/nfa/hci/nfa_hci_main.c
+++ b/src/nfa/hci/nfa_hci_main.cc
@@ -1,8 +1,9 @@
 /******************************************************************************
+ *
  *  Copyright (c) 2016, The Linux Foundation. All rights reserved.
  *  Not a Contribution.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *  The original Work has been changed by NXP Semiconductors.
  *
  *  Copyright (C) 2010-2014 Broadcom Corporation
@@ -27,22 +28,22 @@
  *
  ******************************************************************************/
 #include <string.h>
-#include "nfc_api.h"
-#include "nfa_sys.h"
-#include "nfa_sys_int.h"
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfa_dm_int.h"
 #include "nfa_hci_api.h"
 #include "nfa_hci_int.h"
 #include "nfa_ee_api.h"
 #include "nfa_ee_int.h"
 #include "nfa_nv_co.h"
-#include "nfa_mem_co.h"
 #include "nfa_hci_defs.h"
-#include "trace_api.h"
 
 #if (NXP_EXTNS == TRUE)
 #ifndef __CONFIG_H
-#include <config.h>
+#include <nfc_config.h>
+#include "nfa_sys_int.h"
 #include <stdlib.h>
 #endif
 #endif
@@ -60,6 +61,10 @@ tNFA_HCI_CB nfa_hci_cb;
 #define NFA_HCI_CON_CREATE_TIMEOUT_VAL 1000
 #endif
 
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+
 /*****************************************************************************
 **  Static Functions
 *****************************************************************************/
@@ -73,7 +78,7 @@ extern void nfa_hci_conn_cback(uint8_t conn_id, tNFC_CONN_EVT event,
                                tNFC_CONN* p_data);
 static void nfa_hci_set_receive_buf(uint8_t pipe);
 #if (NXP_EXTNS == TRUE)
-void nfa_hci_rsp_timeout(tNFA_HCI_EVENT_DATA* p_evt_data);
+void nfa_hci_rsp_timeout(void);
 static void nfa_hci_assemble_msg(uint8_t* p_data, uint16_t data_len,
                                  uint8_t pipe);
 static uint8_t nfa_ee_ce_p61_completed = 0x00;
@@ -107,7 +112,7 @@ void nfa_hci_ee_info_cback(tNFA_EE_DISC_STS status) {
   uint8_t xx;
   uint8_t host_index = 0x00;
 
-  NFA_TRACE_DEBUG1("nfa_hci_ee_info_cback (): %d", status);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_ee_info_cback (): %d", status);
 
   switch (status) {
     case NFA_EE_DISC_STS_ON:
@@ -165,7 +170,7 @@ void nfa_hci_ee_info_cback(tNFA_EE_DISC_STS status) {
         /* No UICC Host is detected, HCI NETWORK is enabled */
         nfa_hci_cb.w4_hci_netwk_init = false;
       }
-      NFA_TRACE_DEBUG1("nfa_hci_ee_info_cback (): %d  nfa_hci_cb.num_nfcee",  nfa_hci_cb.num_nfcee);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_ee_info_cback (): %d  nfa_hci_cb.num_nfcee",  nfa_hci_cb.num_nfcee);
 
 #if (NXP_EXTNS == TRUE)
       if (nfa_hci_cb.hci_state == NFA_HCI_STATE_NFCEE_ENABLE &&
@@ -182,7 +187,7 @@ void nfa_hci_ee_info_cback(tNFA_EE_DISC_STS status) {
               (nfa_hci_cb.hci_ee_info[xx].ee_handle != 0x410)) {
             nfa_hci_cb.nfcee_cfg.host_cb[host_index++] =
                 nfa_hci_cb.hci_ee_info[xx].ee_handle;
-            NFA_TRACE_DEBUG1(" handle id   -%x",
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(" handle id   -%x",
                              nfa_hci_cb.hci_ee_info[xx].ee_handle);
           }
         }
@@ -193,7 +198,7 @@ void nfa_hci_ee_info_cback(tNFA_EE_DISC_STS status) {
 #if (NXP_EXTNS == TRUE)
     case NFA_EE_MODE_SET_NTF:
       if (nfa_hci_cb.hci_state == NFA_HCI_STATE_NFCEE_ENABLE) {
-        NFA_TRACE_DEBUG0("ETSI12 pipe creation configured");
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("ETSI12 pipe creation configured");
         nfa_hci_api_config_nfcee(nfa_hci_cb.current_nfcee);
       }
       break;
@@ -234,7 +239,7 @@ void nfa_hci_ee_info_cback(tNFA_EE_DISC_STS status) {
       break;
     case NFA_EE_MODE_SET_COMPLETE:
         /*received mode set Ntf */
-        NFA_TRACE_DEBUG1("nfa_hci_ee_info_cback (): %d  nfa_hci_cb.hci_state", nfa_hci_cb.hci_state);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_ee_info_cback (): %d  nfa_hci_cb.hci_state", nfa_hci_cb.hci_state);
         if ((nfa_hci_cb.hci_state == NFA_HCI_STATE_WAIT_NETWK_ENABLE) ||
             (nfa_hci_cb.hci_state == NFA_HCI_STATE_RESTORE_NETWK_ENABLE)||
             (nfa_hci_cb.hci_state == NFA_HCI_STATE_EE_RECOVERY)
@@ -244,7 +249,7 @@ void nfa_hci_ee_info_cback(tNFA_EE_DISC_STS status) {
           nfa_hci_enable_one_nfcee();
         }
         else if((nfa_hci_cb.hci_state == NFA_HCI_STATE_NFCEE_ENABLE) &&
-            (nfa_hci_cb.nfcee_cfg.config_nfcee_state == NFA_HCI_INIT_NFCEE_CONFIG))
+          (nfa_hci_cb.nfcee_cfg.config_nfcee_state == NFA_HCI_INIT_NFCEE_CONFIG))
         {
             nfa_hci_api_config_nfcee(nfa_hci_cb.current_nfcee);
         }
@@ -252,7 +257,7 @@ void nfa_hci_ee_info_cback(tNFA_EE_DISC_STS status) {
     case NFA_EE_RECOVERY:
         /*NFCEE recovery in progress*/
         if(nfa_hci_cb.hci_state == NFA_HCI_STATE_EE_RECOVERY) {
-            NFA_TRACE_DEBUG1("nfa_hci_ee_info_cback (): %d nfa_hci_cb.hci_state already in EE Recovery", nfa_hci_cb.hci_state);
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_ee_info_cback (): %d nfa_hci_cb.hci_state already in EE Recovery", nfa_hci_cb.hci_state);
         }
         else if (!((nfa_hci_cb.hci_state == NFA_HCI_STATE_WAIT_NETWK_ENABLE) ||
             (nfa_hci_cb.hci_state == NFA_HCI_STATE_RESTORE_NETWK_ENABLE))) {
@@ -287,7 +292,7 @@ void nfa_hci_ee_info_cback(tNFA_EE_DISC_STS status) {
 **
 *******************************************************************************/
 void nfa_hci_init(void) {
-  NFA_TRACE_DEBUG0("nfa_hci_init ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_init ()");
 
   /* initialize control block */
   memset(&nfa_hci_cb, 0, sizeof(tNFA_HCI_CB));
@@ -299,6 +304,7 @@ void nfa_hci_init(void) {
   nfa_hci_cb.IsHciTimerChanged = false;
   nfa_hci_cb.IsWiredSessionAborted = false;
   nfa_hci_cb.IsLastEvtAbortFailed = false;
+  nfa_hci_cb.IsApduPipeStatusNotCorrect = false;
   read_config_timeout_param_values();
 #endif
   /* register message handler on NFA SYS */
@@ -344,7 +350,7 @@ bool nfa_hci_is_valid_cfg(void) {
                       &nfa_hci_cb.cfg.reg_app_names[yy][0],
                       strlen(nfa_hci_cb.cfg.reg_app_names[xx])))) {
           /* Two app cannot have the same name , NVRAM is corrupted */
-          NFA_TRACE_EVENT2("nfa_hci_is_valid_cfg (%s)  Reusing: %u",
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_is_valid_cfg (%s)  Reusing: %u",
                            &nfa_hci_cb.cfg.reg_app_names[xx][0], xx);
           return false;
         }
@@ -371,14 +377,14 @@ bool nfa_hci_is_valid_cfg(void) {
         if ((nfa_hci_cb.cfg.dyn_gates[yy].gate_id != 0) &&
             (nfa_hci_cb.cfg.dyn_gates[xx].gate_id ==
              nfa_hci_cb.cfg.dyn_gates[yy].gate_id)) {
-          NFA_TRACE_EVENT1("nfa_hci_is_valid_cfg  Reusing: %u",
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_is_valid_cfg  Reusing: %u",
                            nfa_hci_cb.cfg.dyn_gates[xx].gate_id);
           return false;
         }
       }
       if ((nfa_hci_cb.cfg.dyn_gates[xx].gate_owner & (~NFA_HANDLE_GROUP_HCI)) >=
           NFA_HCI_MAX_APP_CB) {
-        NFA_TRACE_EVENT1("nfa_hci_is_valid_cfg  Invalid Gate owner: %u",
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_is_valid_cfg  Invalid Gate owner: %u",
                          nfa_hci_cb.cfg.dyn_gates[xx].gate_owner);
         return false;
       }
@@ -390,7 +396,7 @@ bool nfa_hci_is_valid_cfg(void) {
           if (nfa_hci_cb.cfg.dyn_gates[xx].gate_owner == reg_app[zz]) break;
         }
         if (zz == app_count) {
-          NFA_TRACE_EVENT1("nfa_hci_is_valid_cfg  Invalid Gate owner: %u",
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_is_valid_cfg  Invalid Gate owner: %u",
                            nfa_hci_cb.cfg.dyn_gates[xx].gate_owner);
           return false;
         }
@@ -457,7 +463,7 @@ bool nfa_hci_is_valid_cfg(void) {
           if ((nfa_hci_cb.cfg.dyn_pipes[yy].pipe_id != 0) &&
               (nfa_hci_cb.cfg.dyn_pipes[xx].pipe_id ==
                nfa_hci_cb.cfg.dyn_pipes[yy].pipe_id)) {
-            NFA_TRACE_EVENT1("nfa_hci_is_valid_cfg  Reusing: %u",
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_is_valid_cfg  Reusing: %u",
                              nfa_hci_cb.cfg.dyn_pipes[xx].pipe_id);
             return false;
           }
@@ -469,7 +475,7 @@ bool nfa_hci_is_valid_cfg(void) {
         if (nfa_hci_cb.cfg.dyn_pipes[xx].local_gate == valid_gate[zz]) break;
       }
       if (zz == gate_count) {
-        NFA_TRACE_EVENT1("nfa_hci_is_valid_cfg  Invalid Gate: %u",
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_is_valid_cfg  Invalid Gate: %u",
                          nfa_hci_cb.cfg.dyn_pipes[xx].local_gate);
         return false;
       }
@@ -487,7 +493,7 @@ bool nfa_hci_is_valid_cfg(void) {
   }
 #if (NXP_EXTNS == TRUE)
   if (validated_gate_count != gate_count && xx > NFA_HCI_MAX_PIPE_CB) {
-    NFA_TRACE_EVENT1("nfa_hci_is_valid_cfg  Invalid Gate: %u",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_is_valid_cfg  Invalid Gate: %u",
                      nfa_hci_cb.cfg.dyn_pipes[xx].local_gate);
     return false;
   }
@@ -548,7 +554,7 @@ void nfa_hci_restore_default_config(uint8_t* p_session_id) {
 **
 *******************************************************************************/
 void nfa_hci_proc_nfcc_power_mode(uint8_t nfcc_power_mode) {
-  NFA_TRACE_DEBUG1("nfa_hci_proc_nfcc_power_mode () nfcc_power_mode=%d",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_proc_nfcc_power_mode () nfcc_power_mode=%d",
                    nfcc_power_mode);
 
   /* if NFCC power mode is change to full power */
@@ -566,7 +572,7 @@ void nfa_hci_proc_nfcc_power_mode(uint8_t nfcc_power_mode) {
       nfa_hci_cb.num_ee_dis_req_ntf = 0;
       nfa_hci_cb.num_hot_plug_evts = 0;
     } else {
-      NFA_TRACE_ERROR0("nfa_hci_proc_nfcc_power_mode (): Cannot restore now");
+      LOG(ERROR) << StringPrintf("nfa_hci_proc_nfcc_power_mode (): Cannot restore now");
       nfa_sys_cback_notify_nfcc_power_mode_proc_complete(NFA_ID_HCI);
     }
   } else {
@@ -597,7 +603,7 @@ void nfa_hci_dh_startup_complete(void) {
   if (nfa_hci_cb.ee_disable_disc) {
     if (nfa_hci_cb.hci_state == NFA_HCI_STATE_STARTUP &&
         nfa_hci_cb.num_nfcee >= 1) {
-      NFA_TRACE_DEBUG0("nfa_hci_dh_startup_complete");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_dh_startup_complete");
       nfa_hci_cb.w4_hci_netwk_init = false;
       /* Received EE DISC REQ Ntf(s) */
       nfa_hciu_send_get_param_cmd(NFA_HCI_ADMIN_PIPE, NFA_HCI_HOST_LIST_INDEX);
@@ -687,7 +693,7 @@ void nfa_hci_dh_startup_complete(void) {
 void nfa_hci_startup_complete(tNFA_STATUS status) {
   tNFA_HCI_EVT_DATA evt_data;
 
-  NFA_TRACE_EVENT1("nfa_hci_startup_complete (): Status: %u", status);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_startup_complete (): Status: %u", status);
   nfa_sys_stop_timer(&nfa_hci_cb.timer);
 
   if ((nfa_hci_cb.hci_state == NFA_HCI_STATE_RESTORE) ||
@@ -728,7 +734,7 @@ void nfa_hci_startup_complete(tNFA_STATUS status) {
     nfa_hci_handle_nfcee_config_evt(NFA_HCI_GET_NUM_NFCEE_CONFIGURED);
     if(nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
         nfa_hci_cb.hci_state = NFA_HCI_STATE_IDLE;
-        NFA_TRACE_EVENT0("hci_state = NFA_HCI_STATE_IDLE");
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("hci_state = NFA_HCI_STATE_IDLE");
         if ((nfa_sys_cb.enable_cplt_flags == nfa_sys_cb.enable_cplt_mask) &&
                 (!(nfa_sys_cb.p_enable_cback))) {
             if ((nfa_dm_cb.p_dm_cback))
@@ -762,11 +768,12 @@ void nfa_hci_enable_one_nfcee(void) {
   uint8_t xx;
   uint8_t nfceeid = 0;
 
-  NFA_TRACE_DEBUG1("nfa_hci_enable_one_nfcee () %d",nfa_hci_cb.num_nfcee);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_enable_one_nfcee () %d",nfa_hci_cb.num_nfcee);
 
   for (xx = 0; xx < nfa_hci_cb.num_nfcee; xx++) {
     nfceeid = nfa_hci_cb.ee_info[xx].ee_handle & ~NFA_HANDLE_GROUP_EE;
-    if ((nfa_hci_cb.ee_info[xx].ee_status == NFA_EE_STATUS_INACTIVE)) {
+
+    if (nfa_hci_cb.ee_info[xx].ee_status == NFA_EE_STATUS_INACTIVE) {
       NFC_NfceeModeSet(nfceeid, NFC_MODE_ACTIVATE);
       return;
     }
@@ -800,8 +807,6 @@ void nfa_hci_enable_one_nfcee(void) {
 *******************************************************************************/
 void nfa_hci_startup(void) {
   tNFA_STATUS status = NFA_STATUS_FAILED;
-  tNFA_EE_INFO ee_info[2];
-  uint8_t num_nfcee = 2;
   uint8_t target_handle;
   uint8_t count = 0;
   bool found = false;
@@ -838,7 +843,7 @@ void nfa_hci_startup(void) {
                               NFA_HCI_CON_CREATE_TIMEOUT_VAL);
         else {
           nfa_hci_cb.hci_state = NFA_HCI_STATE_DISABLED;
-          NFA_TRACE_ERROR0(
+          LOG(ERROR) << StringPrintf(
               "nfa_hci_startup - Failed to Create Logical connection. HCI "
               "Initialization/Restore failed");
           nfa_hci_startup_complete(NFA_STATUS_FAILED);
@@ -853,7 +858,7 @@ void nfa_hci_startup(void) {
       count++;
     }
     if (!found) {
-      NFA_TRACE_ERROR0(
+      LOG(ERROR) << StringPrintf(
           "nfa_hci_startup - HCI ACCESS Interface not discovered. HCI "
           "Initialization/Restore failed");
       nfa_hci_startup_complete(NFA_STATUS_FAILED);
@@ -901,7 +906,7 @@ void nfa_hci_network_enable(void) {
 **
 *******************************************************************************/
 static void nfa_hci_sys_enable(void) {
-  NFA_TRACE_DEBUG0("nfa_hci_sys_enable ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_sys_enable ()");
   nfa_ee_reg_cback_enable_done(&nfa_hci_ee_info_cback);
 
   nfa_nv_co_read((uint8_t*)&nfa_hci_cb.cfg, sizeof(nfa_hci_cb.cfg),
@@ -937,7 +942,7 @@ static void nfa_hci_sys_disable(void) {
       {
         /* HCI module deregister should be triggered to sto the nfa_sys_main timer,
         so faking a connection close event */
-        NFA_TRACE_ERROR0("Fake NFC_CONN_CLOSE_CEVT triggered");
+        LOG(ERROR) << StringPrintf("Fake NFC_CONN_CLOSE_CEVT triggered");
         cData.data.status = NFA_STATUS_OK;
         cData.data.p_data = NULL;
         event = NFC_CONN_CLOSE_CEVT;
@@ -969,10 +974,8 @@ void nfa_hci_conn_cback(uint8_t conn_id, tNFC_CONN_EVT event,
   uint8_t chaining_bit;
   uint8_t pipe;
   uint16_t pkt_len;
-#if (BT_TRACE_VERBOSE == true)
-  char buff[VERBOSE_BUFF_SIZE];
+  char buff[100];
   static bool is_first_chain_pkt = true;
-#endif
 #if (NXP_EXTNS == TRUE)
   if(nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME ==
           nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
@@ -1037,7 +1040,7 @@ void nfa_hci_conn_cback(uint8_t conn_id, tNFC_CONN_EVT event,
 #endif
       /* deregister message handler on NFA SYS */
         nfa_sys_deregister (NFA_ID_HCI);
-      NFA_TRACE_DEBUG0("NFC_CONN_CLOSE_CEVT handled");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_CONN_CLOSE_CEVT handled");
 
 #if(NXP_EXTNS == TRUE)
       tNFA_EE_MSG p_msgdata;
@@ -1066,10 +1069,6 @@ void nfa_hci_conn_cback(uint8_t conn_id, tNFC_CONN_EVT event,
   p = (uint8_t*)(p_pkt + 1) + p_pkt->offset;
   pkt_len = p_pkt->len;
 
-#if (BT_TRACE_PROTOCOL == true)
-  DispHcp(p, pkt_len, true, (bool)!nfa_hci_cb.assembling);
-#endif
-
   chaining_bit = ((*p) >> 0x07) & 0x01;
   pipe = (*p++) & 0x7F;
   if (pkt_len != 0) pkt_len--;
@@ -1176,7 +1175,7 @@ void nfa_hci_conn_cback(uint8_t conn_id, tNFC_CONN_EVT event,
     {
       /* If Reassembly failed because of insufficient buffer, just drop the new
        * segmented packets */
-      NFA_TRACE_ERROR1(
+      LOG(ERROR) << StringPrintf(
           "nfa_hci_conn_cback (): Insufficient buffer to Reassemble HCP "
           "packet! Dropping :%u bytes",
           pkt_len);
@@ -1229,19 +1228,12 @@ void nfa_hci_conn_cback(uint8_t conn_id, tNFC_CONN_EVT event,
   }
 #endif
 
-#if (BT_TRACE_VERBOSE == true)
-  NFA_TRACE_EVENT5(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "nfa_hci_conn_cback Recvd data pipe:%d  %s  chain:%d  assmbl:%d  len:%d",
       (uint8_t)pipe, nfa_hciu_get_type_inst_names(pipe, nfa_hci_cb.type,
                                                   nfa_hci_cb.inst, buff),
       (uint8_t)chaining_bit, (uint8_t)nfa_hci_cb.assembling, p_pkt->len);
-#else
-  NFA_TRACE_EVENT6(
-      "nfa_hci_conn_cback Recvd data pipe:%d  Type: %u  Inst: %u  chain:%d "
-      "reassm:%d len:%d",
-      pipe, nfa_hci_cb.type, nfa_hci_cb.inst, chaining_bit,
-      nfa_hci_cb.assembling, p_pkt->len);
-#endif
+
 
 #if (NXP_EXTNS == TRUE)
   /*After the reception of WTX, if the next response is chained
@@ -1326,7 +1318,7 @@ void nfa_hci_conn_cback(uint8_t conn_id, tNFC_CONN_EVT event,
       } else if (nfa_hci_cb.type == NFA_HCI_RESPONSE_TYPE) {
         nfa_hci_handle_admin_gate_rsp(p, (uint8_t)pkt_len);
       } else if (nfa_hci_cb.type == NFA_HCI_EVENT_TYPE) {
-        nfa_hci_handle_admin_gate_evt(p);
+        nfa_hci_handle_admin_gate_evt();
       }
       break;
 
@@ -1408,7 +1400,7 @@ void nfa_hci_handle_nv_read(uint8_t block, tNFA_STATUS status) {
       if (!nfa_hci_is_valid_ese_cfg() &&
           (nfa_hci_cb.cfg.retry_cnt < NFA_HCI_INIT_MAX_RETRY)) {
         nfa_hci_cb.cfg.retry_cnt++;
-        NFA_TRACE_DEBUG0(" nfa_hci_handle_nv_read; reset ese session");
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(" nfa_hci_handle_nv_read; reset ese session");
         nfa_hciu_reset_session_id(nfa_hci_reset_session_rsp_cb);
       } else {
         NXP_NFC_RESET_MSB(nfa_hci_cb.cfg.retry_cnt);
@@ -1430,18 +1422,17 @@ void nfa_hci_handle_nv_read(uint8_t block, tNFA_STATUS status) {
 ** Returns          None
 **
 *******************************************************************************/
-void nfa_hci_rsp_timeout(tNFA_HCI_EVENT_DATA* p_evt_data) {
+void nfa_hci_rsp_timeout() {
   tNFA_HCI_EVT evt = 0;
   tNFA_HCI_EVT_DATA evt_data;
   uint8_t delete_pipe;
-  (void)p_evt_data;
 #if (NXP_EXTNS == TRUE)
   NFC_HDR* p_buf;
   uint8_t* p_data;
   uint8_t temp[] = {0xFF, 0xFF};
   uint16_t msg_len;
 #endif
-  NFA_TRACE_EVENT2("nfa_hci_rsp_timeout () State: %u  Cmd: %u",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_rsp_timeout () State: %u  Cmd: %u",
                    nfa_hci_cb.hci_state, nfa_hci_cb.cmd_sent);
 
   evt_data.status = NFA_STATUS_FAILED;
@@ -1452,7 +1443,7 @@ void nfa_hci_rsp_timeout(tNFA_HCI_EVENT_DATA* p_evt_data) {
 #if (NXP_EXTNS == TRUE)
     case NFA_HCI_STATE_NFCEE_ENABLE:
 #endif
-      NFA_TRACE_ERROR0("nfa_hci_rsp_timeout - Initialization failed!");
+      LOG(ERROR) << StringPrintf("nfa_hci_rsp_timeout - Initialization failed!");
       nfa_hci_startup_complete(NFA_STATUS_TIMEOUT);
       break;
 
@@ -1492,7 +1483,7 @@ void nfa_hci_rsp_timeout(tNFA_HCI_EVENT_DATA* p_evt_data) {
       nfa_hci_cb.hci_state = NFA_HCI_STATE_IDLE;
 #if (NXP_EXTNS == TRUE)
       if (nfa_hci_cb.w4_rsp_evt) {
-        NFA_TRACE_DEBUG0(
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
             "NxpNci:nfa_hci_rsp_timeout () Timeout: NFC_FlushData");
         nfa_hci_cb.bIsHciResponseTimedout = true;
         if (nfa_ee_nfeeid_active(NFA_HCI_HOST_ID_ESE)) {
@@ -1501,8 +1492,8 @@ void nfa_hci_rsp_timeout(tNFA_HCI_EVENT_DATA* p_evt_data) {
             /* send the dummy packet */
             NFC_FlushData(nfa_hci_cb.conn_id);
             msg_len = (((nfa_hci_cb.hci_packet_len + 1) % 2) == 0) ? 1 : 2;
-            NFA_TRACE_DEBUG1("NxpNci: Queue is not empty: %d", msg_len);
-            if ((p_buf = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID)) != NULL) {
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NxpNci: Queue is not empty: %d", msg_len);
+            if ((p_buf = (NFC_HDR*)GKI_getpoolbuf(NFC_WIRED_POOL_ID)) != NULL) {
               p_buf->offset = NCI_MSG_OFFSET_SIZE + NCI_DATA_HDR_SIZE;
               p_data = (uint8_t*)(p_buf + 1) + p_buf->offset;
               *p_data++ = (NFA_HCI_NO_MESSAGE_FRAGMENTATION << 7) |
@@ -1521,8 +1512,8 @@ void nfa_hci_rsp_timeout(tNFA_HCI_EVENT_DATA* p_evt_data) {
           } else if (!nfa_hci_cb.IsEventAbortSent) {
             NFC_FlushData(nfa_hci_cb.conn_id);
             /* send EVT_ABORT command */
-            if ((p_buf = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID)) != NULL) {
-              NFA_TRACE_DEBUG0("EVT_ABORT sent");
+            if ((p_buf = (NFC_HDR*)GKI_getpoolbuf(NFC_WIRED_POOL_ID)) != NULL) {
+              DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("EVT_ABORT sent");
               p_buf->offset = NCI_MSG_OFFSET_SIZE + NCI_DATA_HDR_SIZE;
               p_data = (uint8_t*)(p_buf + 1) + p_buf->offset;
               *p_data++ = (NFA_HCI_NO_MESSAGE_FRAGMENTATION << 7) |
@@ -1656,7 +1647,7 @@ void nfa_hci_rsp_timeout(tNFA_HCI_EVENT_DATA* p_evt_data) {
       break;
     case NFA_HCI_STATE_DISABLED:
     default:
-      NFA_TRACE_DEBUG0(
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "nfa_hci_rsp_timeout () Timeout in DISABLED/ Invalid state");
       break;
   }
@@ -1718,23 +1709,15 @@ static void nfa_hci_set_receive_buf(uint8_t pipe) {
 
 #if (NXP_EXTNS == TRUE)
 static void read_config_timeout_param_values() {
-  if (GetNumValue(NAME_NXP_DEFAULT_NFCEE_TIMEOUT,
-                  (void*)&nfa_hci_cb.max_hci_session_id_read_count,
-                  sizeof(nfa_hci_cb.max_hci_session_id_read_count)) == false) {
-    nfa_hci_cb.max_hci_session_id_read_count =
-        NFA_HCI_MAX_SESSION_ID_RETRY_CNT; /*Default  maximum session ID read
-                                             count*/
-  }
-  NFA_TRACE_DEBUG1("nfa_hci_init() %d",
+  nfa_hci_cb.max_hci_session_id_read_count =
+            NfcConfig::getUnsigned(NAME_NXP_DEFAULT_NFCEE_TIMEOUT,NFA_HCI_MAX_SESSION_ID_RETRY_CNT);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_init() %d",
                    nfa_hci_cb.max_hci_session_id_read_count);
-  if (GetNumValue(NAME_NXP_DEFAULT_NFCEE_DISC_TIMEOUT,
-                  (void*)&nfa_hci_cb.max_nfcee_disc_timeout,
-                  sizeof(nfa_hci_cb.max_nfcee_disc_timeout)) == false) {
-    nfa_hci_cb.max_nfcee_disc_timeout =
-        NFA_HCI_NFCEE_DISC_TIMEOUT; /*Default nfcee discover timeout*/
-  }
+
+  nfa_hci_cb.max_nfcee_disc_timeout =
+            NfcConfig::getUnsigned(NAME_NXP_DEFAULT_NFCEE_DISC_TIMEOUT,NFA_HCI_NFCEE_DISC_TIMEOUT);
   nfa_hci_cb.max_nfcee_disc_timeout = nfa_hci_cb.max_nfcee_disc_timeout * 1000;
-  NFA_TRACE_DEBUG1("nfa_hci_init() %d", nfa_hci_cb.max_nfcee_disc_timeout);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_init() %d", nfa_hci_cb.max_nfcee_disc_timeout);
 }
 #endif
 /*******************************************************************************
@@ -1757,7 +1740,7 @@ static void nfa_hci_assemble_msg(uint8_t* p_data, uint16_t data_len)
   if (pipe == NFA_HCI_APDU_PIPE) {
     if ((nfa_hci_cb.msg_len + data_len) > nfa_hci_cb.max_msg_len) {
       /* Fill the buffer as much it can hold */
-      NFA_TRACE_ERROR1(
+      LOG(ERROR) << StringPrintf(
           "nfa_hci_assemble_msg (): Insufficient buffer to Reassemble APDU HCP "
           "packet! Dropping :%u bytes",
           ((nfa_hci_cb.msg_len + data_len) - nfa_hci_cb.max_msg_len));
@@ -1776,7 +1759,7 @@ static void nfa_hci_assemble_msg(uint8_t* p_data, uint16_t data_len)
                   (pipe == NFA_HCI_CONN_UICC2_PIPE))) {
     if ((nfa_hci_cb.evt_len + data_len) > nfa_hci_cb.max_evt_len) {
       /* Fill the buffer as much it can hold */
-      NFA_TRACE_ERROR1(
+      LOG(ERROR) << StringPrintf(
           "nfa_hci_assemble_msg (): Insufficient buffer to Reassemble Event "
           "HCP packet! Dropping :%u bytes",
           ((nfa_hci_cb.msg_len + data_len) - nfa_hci_cb.max_msg_len));
@@ -1799,7 +1782,7 @@ static void nfa_hci_assemble_msg(uint8_t* p_data, uint16_t data_len)
     nfa_hci_cb.msg_len = nfa_hci_cb.max_msg_len;
     /* Set Reassembly failed */
     nfa_hci_cb.assembly_failed = true;
-    NFA_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "nfa_hci_assemble_msg (): Insufficient buffer to Reassemble HCP "
         "packet! Dropping :%u bytes",
         ((nfa_hci_cb.msg_len + data_len) - nfa_hci_cb.max_msg_len));
@@ -1820,23 +1803,18 @@ static void nfa_hci_assemble_msg(uint8_t* p_data, uint16_t data_len)
 **
 *******************************************************************************/
 static bool nfa_hci_evt_hdlr(NFC_HDR* p_msg) {
-  tNFA_HCI_EVENT_DATA* p_evt_data = (tNFA_HCI_EVENT_DATA*)p_msg;
-
-#if (BT_TRACE_VERBOSE == true)
-  NFA_TRACE_EVENT4(
-      "nfa_hci_evt_hdlr state: %s (%d) event: %s (0x%04x)",
-      nfa_hciu_get_state_name(nfa_hci_cb.hci_state), nfa_hci_cb.hci_state,
-      nfa_hciu_get_event_name(p_evt_data->hdr.event), p_evt_data->hdr.event);
-#else
-  NFA_TRACE_EVENT2("nfa_hci_evt_hdlr state: %d event: 0x%04x",
-                   nfa_hci_cb.hci_state, p_evt_data->hdr.event);
-#endif
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+                    "nfa_hci_evt_hdlr state: %s (%d) event: %s (0x%04x)",
+                    nfa_hciu_get_state_name(nfa_hci_cb.hci_state).c_str(),
+                    nfa_hci_cb.hci_state,
+                    nfa_hciu_get_event_name(p_msg->event).c_str(), p_msg->event);
 
   /* If this is an API request, queue it up */
   if ((p_msg->event >= NFA_HCI_FIRST_API_EVENT) &&
       (p_msg->event <= NFA_HCI_LAST_API_EVENT)) {
     GKI_enqueue(&nfa_hci_cb.hci_api_q, p_msg);
   } else {
+    tNFA_HCI_EVENT_DATA* p_evt_data = (tNFA_HCI_EVENT_DATA*)p_msg;
     switch (p_msg->event) {
       case NFA_HCI_RSP_NV_READ_EVT:
         nfa_hci_handle_nv_read(p_evt_data->nv_read.block,
@@ -1852,19 +1830,19 @@ static bool nfa_hci_evt_hdlr(NFC_HDR* p_msg) {
           if(nfcFL.nfcNxpEse) {
               if(nfcFL.eseFL._JCOP_WA_ENABLE) {
                   if (nfa_ee_ce_p61_completed != 0) {
-                      NFA_TRACE_EVENT0(
+                      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
                               "nfa_hci_evt_hdlr Restart timer expired for wired transceive");
                       nfa_ee_ce_p61_completed = 0;
                   } else {
                       uint32_t p61_access_status = 0x0000;
                       if (NFC_GetP61Status((void*)&p61_access_status) < 0) {
-                          NFA_TRACE_EVENT0(
+                          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
                                   "nfa_hci_evt_hdlr : Check dual mode : NFC_GetP61Status failed");
                       } else {
                           if (((p61_access_status == 0x400) ||
                                   (p61_access_status == 0x1000)) &&
                                   (NFA_check_p61_CL_Activated() != 0)) {
-                              NFA_TRACE_EVENT0(
+                              DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
                                       "nfa_hci_evt_hdlr Restart timer for wired transceive");
                               nfa_sys_start_timer(&nfa_hci_cb.timer, NFA_HCI_RSP_TIMEOUT_EVT,
                                       NFA_HCI_WTX_RESP_TIMEOUT);
@@ -1877,15 +1855,15 @@ static bool nfa_hci_evt_hdlr(NFC_HDR* p_msg) {
               }
           }
 #endif
-        nfa_hci_rsp_timeout((tNFA_HCI_EVENT_DATA*)p_msg);
+        nfa_hci_rsp_timeout();
         break;
 
       case NFA_HCI_CHECK_QUEUE_EVT:
         if (HCI_LOOPBACK_DEBUG) {
           if (p_msg->len != 0) {
-            tNFC_DATA_CEVT xx;
-            xx.p_data = p_msg;
-            nfa_hci_conn_cback(0, NFC_DATA_CEVT, (void*)&xx);
+            tNFC_CONN nfc_conn;
+            nfc_conn.data.p_data = p_msg;
+            nfa_hci_conn_cback(0, NFC_DATA_CEVT, &nfc_conn);
             return false;
           }
         }
@@ -1916,10 +1894,10 @@ static bool nfa_hci_evt_hdlr(NFC_HDR* p_msg) {
 
 #if (NXP_EXTNS == TRUE)
 void nfa_hci_release_transcieve() {
-  NFA_TRACE_DEBUG0("nfa_hci_release_transcieve (); Release ongoing transcieve");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_release_transcieve (); Release ongoing transcieve");
   if (nfa_hci_cb.hci_state == NFA_HCI_STATE_WAIT_RSP) {
     nfa_sys_stop_timer(&nfa_hci_cb.timer);
-    nfa_hci_rsp_timeout(NULL);
+    nfa_hci_rsp_timeout();
   }
 }
 
@@ -1943,14 +1921,14 @@ bool nfa_hci_is_valid_ese_cfg(void) {
          NFA_HCI_IDENTITY_MANAGEMENT_GATE) &&
         ((nfa_hci_cb.cfg.dyn_pipes[xx].local_gate) ==
          NFA_HCI_IDENTITY_MANAGEMENT_GATE)) {
-      NFA_TRACE_DEBUG0(
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "nfa_hci_is_valid_ese_cfg()  Validate ID Management Gate Pipe Data");
-      NFA_TRACE_DEBUG1("nfa_hci_is_valid_ese_cfg()  Pipe id: %u",
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_is_valid_ese_cfg()  Pipe id: %u",
                        nfa_hci_cb.cfg.dyn_pipes[xx].pipe_id);
-      NFA_TRACE_DEBUG1("nfa_hci_is_valid_ese_cfg()  Pipe state: %u",
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_is_valid_ese_cfg()  Pipe state: %u",
                        nfa_hci_cb.cfg.dyn_pipes[xx].pipe_state);
       if ((nfa_hci_cb.cfg.dyn_pipes[xx].pipe_id) != 0x00) {
-        NFA_TRACE_DEBUG0(
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
             "nfa_hci_is_valid_ese_cfg()  Validate ID Management Gate Pipe "
             "State");
         if ((nfa_hci_cb.cfg.dyn_pipes[xx].pipe_state) != NFA_HCI_PIPE_OPENED) {
@@ -1963,14 +1941,14 @@ bool nfa_hci_is_valid_ese_cfg(void) {
          NFA_HCI_ETSI12_APDU_GATE) &&
         ((nfa_hci_cb.cfg.dyn_pipes[xx].local_gate) ==
          NFA_HCI_ETSI12_APDU_GATE)) {
-      NFA_TRACE_DEBUG0(
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "nfa_hci_is_valid_ese_cfg()  Validate APDU Gate Pipe Data");
-      NFA_TRACE_DEBUG1("nfa_hci_is_valid_ese_cfg()  Pipe id: %u",
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_is_valid_ese_cfg()  Pipe id: %u",
                        nfa_hci_cb.cfg.dyn_pipes[xx].pipe_id);
-      NFA_TRACE_DEBUG1("nfa_hci_is_valid_ese_cfg()  Pipe state: %u",
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hci_is_valid_ese_cfg()  Pipe state: %u",
                        nfa_hci_cb.cfg.dyn_pipes[xx].pipe_state);
       if ((nfa_hci_cb.cfg.dyn_pipes[xx].pipe_id) != 0x00) {
-        NFA_TRACE_DEBUG0(
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
             "nfa_hci_is_valid_ese_cfg()  Validate APDU Gate Pipe State");
         if ((nfa_hci_cb.cfg.dyn_pipes[xx].pipe_state) != NFA_HCI_PIPE_OPENED) {
           isFoundEtsi12 = false;
@@ -1997,7 +1975,7 @@ bool nfa_hci_is_valid_ese_cfg(void) {
 static void nfa_hci_reset_session_rsp_cb(uint8_t event, uint16_t param_len,
                                          uint8_t* p_param) {
   (void)event;
-  NFA_TRACE_DEBUG2(
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "nfa_hci_reset_session_rsp_cb: Received length data = 0x%x status = 0x%x",
       param_len, p_param[3]);
 
diff --git a/src/nfa/hci/nfa_hci_utils.c b/src/nfa/hci/nfa_hci_utils.cc
similarity index 92%
rename from src/nfa/hci/nfa_hci_utils.c
rename to src/nfa/hci/nfa_hci_utils.cc
index 3cede30..85d2b01 100644
--- a/src/nfa/hci/nfa_hci_utils.c
+++ b/src/nfa/hci/nfa_hci_utils.cc
@@ -3,7 +3,7 @@
  *  Copyright (c) 2016, The Linux Foundation. All rights reserved.
  *  Not a Contribution.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *  The original Work has been changed by NXP Semiconductors.
  *
  *  Copyright (C) 2010-2014 Broadcom Corporation
@@ -28,18 +28,21 @@
  *
  ******************************************************************************/
 #include <string.h>
-#include "trace_api.h"
-#include "nfc_api.h"
-#include "nfa_sys.h"
-#include "nfa_sys_int.h"
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfa_dm_int.h"
 #include "nfa_hci_api.h"
 #include "nfa_hci_int.h"
-#include "nfa_nv_co.h"
-#include "nfa_mem_co.h"
 #include "nfa_hci_defs.h"
 
-static void handle_debug_loopback(NFC_HDR* p_buf, uint8_t pipe, uint8_t type,
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+
+
+static void handle_debug_loopback(NFC_HDR* p_buf, uint8_t type,
                                   uint8_t instruction);
 uint8_t HCI_LOOPBACK_DEBUG = false;
 
@@ -252,13 +255,16 @@ tNFA_HCI_DYN_GATE* nfa_hciu_alloc_gate(uint8_t gate_id,
       /* Skip connectivity gate */
       if (gate_id == NFA_HCI_CONNECTIVITY_GATE) gate_id++;
 
+      /* All possible gate IDs are exhausted. */
+      if (gate_id == 0) break;
+
       /* Check if the gate is already allocated */
       if (nfa_hciu_find_gate_by_gid(gate_id) == NULL) break;
     }
 #if (NXP_EXTNS == TRUE)
 #else
     if (gate_id > NFA_HCI_LAST_PROP_GATE) {
-      NFA_TRACE_ERROR2(
+      LOG(ERROR) << StringPrintf(
           "nfa_hci_alloc_gate - no free Gate ID: %u  App Handle: 0x%04x",
           gate_id, app_handle);
       return (NULL);
@@ -275,7 +281,7 @@ tNFA_HCI_DYN_GATE* nfa_hciu_alloc_gate(uint8_t gate_id,
       pg->gate_owner = app_handle;
       pg->pipe_inx_mask = 0;
 
-      NFA_TRACE_DEBUG2("nfa_hciu_alloc_gate id:%d  app_handle: 0x%04x", gate_id,
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hciu_alloc_gate id:%d  app_handle: 0x%04x", gate_id,
                        app_handle);
 
       nfa_hci_cb.nv_write_needed = true;
@@ -284,7 +290,7 @@ tNFA_HCI_DYN_GATE* nfa_hciu_alloc_gate(uint8_t gate_id,
   }
 
   /* If here, no free gate control block */
-  NFA_TRACE_ERROR2(
+  LOG(ERROR) << StringPrintf(
       "nfa_hci_alloc_gate - no CB  Gate ID: %u  App Handle: 0x%04x", gate_id,
       app_handle);
   return (NULL);
@@ -312,16 +318,10 @@ tNFA_STATUS nfa_hciu_send_msg(uint8_t pipe_id, uint8_t type,
 #if (NXP_EXTNS == TRUE)
   nfa_hci_cb.IsChainedPacket = false;
 #endif
-#if (BT_TRACE_VERBOSE == true)
   char buff[VERBOSE_BUFF_SIZE];
-
-  NFA_TRACE_DEBUG3(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "nfa_hciu_send_msg pipe_id:%d   %s  len:%d", pipe_id,
       nfa_hciu_get_type_inst_names(pipe_id, type, instruction, buff), msg_len);
-#else
-  NFA_TRACE_DEBUG4("nfa_hciu_send_msg pipe_id:%d   Type: %u  Inst: %u  len: %d",
-                   pipe_id, type, instruction, msg_len);
-#endif
 
   if (instruction == NFA_HCI_ANY_GET_PARAMETER)
     nfa_hci_cb.param_in_use = *p_msg;
@@ -331,11 +331,11 @@ tNFA_STATUS nfa_hciu_send_msg(uint8_t pipe_id, uint8_t type,
     nfa_hci_cb.hci_packet_len = msg_len;
     nfa_hci_cb.IsEventAbortSent = false;
     if (instruction == NFA_EVT_ABORT) {
-      NFA_TRACE_DEBUG0("Flush the queue!!!");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Flush the queue!!!");
       NFC_FlushData(nfa_hci_cb.conn_id);
     } else if (nfa_hci_cb.IsLastEvtAbortFailed) {
       /* send EVT_ABORT command */
-      if ((p_buf = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID)) != NULL) {
+      if ((p_buf = (NFC_HDR*)GKI_getpoolbuf(NFC_WIRED_POOL_ID)) != NULL) {
         p_buf->offset = NCI_MSG_OFFSET_SIZE + NCI_DATA_HDR_SIZE;
         p_data = (uint8_t*)(p_buf + 1) + p_buf->offset;
         *p_data++ = (NFA_HCI_NO_MESSAGE_FRAGMENTATION << 7) |
@@ -349,7 +349,11 @@ tNFA_STATUS nfa_hciu_send_msg(uint8_t pipe_id, uint8_t type,
 #endif
 
   while ((first_pkt == true) || (msg_len != 0)) {
+#if (NXP_EXTNS == TRUE)
+    p_buf = (NFC_HDR*)GKI_getpoolbuf(NFC_WIRED_POOL_ID);
+#else
     p_buf = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
+#endif
     if (p_buf != NULL) {
       p_buf->offset = NCI_MSG_OFFSET_SIZE + NCI_DATA_HDR_SIZE;
 
@@ -388,17 +392,12 @@ tNFA_STATUS nfa_hciu_send_msg(uint8_t pipe_id, uint8_t type,
         if (msg_len > 0) p_msg += data_len;
       }
 
-#if (BT_TRACE_PROTOCOL == true)
-      DispHcp(((uint8_t*)(p_buf + 1) + p_buf->offset), p_buf->len, false,
-              (bool)((p_buf->len - data_len) == 2));
-#endif
-
       if (HCI_LOOPBACK_DEBUG)
-        handle_debug_loopback(p_buf, pipe_id, type, instruction);
+        handle_debug_loopback(p_buf, type, instruction);
       else
         status = NFC_SendData(nfa_hci_cb.conn_id, p_buf);
     } else {
-      NFA_TRACE_ERROR0("nfa_hciu_send_data_packet no buffers");
+      LOG(ERROR) << StringPrintf("nfa_hciu_send_data_packet no buffers");
       status = NFA_STATUS_NO_BUFFERS;
       break;
     }
@@ -416,6 +415,7 @@ tNFA_STATUS nfa_hciu_send_msg(uint8_t pipe_id, uint8_t type,
 #if (NXP_EXTNS == TRUE)
   else if (type == NFA_HCI_EVENT_TYPE) {
     nfa_hci_cb.evt_sent.evt_type = instruction;
+    nfa_hci_cb.cmd_sent = HCI_INVALID_CMD;
   }
 #endif
   return status;
@@ -443,7 +443,7 @@ uint8_t nfa_hciu_get_allocated_gate_list(uint8_t* p_gate_list) {
     }
   }
 
-  NFA_TRACE_DEBUG1("nfa_hciu_get_allocated_gate_list () returns: %u", count);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hciu_get_allocated_gate_list () returns: %u", count);
 
   return (count);
 }
@@ -473,7 +473,7 @@ tNFA_HCI_DYN_PIPE* nfa_hciu_alloc_pipe(uint8_t pipe_id) {
   for (xx = 0, pp = nfa_hci_cb.cfg.dyn_pipes; xx < NFA_HCI_MAX_PIPE_CB;
        xx++, pp++) {
     if (pp->pipe_id == 0) {
-      NFA_TRACE_DEBUG2("nfa_hciu_alloc_pipe:%d, index:%d", pipe_id, xx);
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hciu_alloc_pipe:%d, index:%d", pipe_id, xx);
       pp->pipe_id = pipe_id;
 
       nfa_hci_cb.nv_write_needed = true;
@@ -481,7 +481,7 @@ tNFA_HCI_DYN_PIPE* nfa_hciu_alloc_pipe(uint8_t pipe_id) {
     }
   }
 
-  NFA_TRACE_DEBUG1("nfa_hciu_alloc_pipe:%d, NO free entries !!", pipe_id);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hciu_alloc_pipe:%d, NO free entries !!", pipe_id);
   return (NULL);
 }
 
@@ -498,7 +498,7 @@ void nfa_hciu_release_gate(uint8_t gate_id) {
   tNFA_HCI_DYN_GATE* p_gate = nfa_hciu_find_gate_by_gid(gate_id);
 
   if (p_gate != NULL) {
-    NFA_TRACE_DEBUG3(
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "nfa_hciu_release_gate () ID: %d  owner: 0x%04x  pipe_inx_mask: 0x%04x",
         gate_id, p_gate->gate_owner, p_gate->pipe_inx_mask);
 
@@ -508,7 +508,7 @@ void nfa_hciu_release_gate(uint8_t gate_id) {
 
     nfa_hci_cb.nv_write_needed = true;
   } else {
-    NFA_TRACE_WARNING1("nfa_hciu_release_gate () ID: %d  NOT FOUND", gate_id);
+    LOG(WARNING) << StringPrintf("nfa_hciu_release_gate () ID: %d  NOT FOUND", gate_id);
   }
 }
 
@@ -545,7 +545,7 @@ tNFA_HCI_RESPONSE nfa_hciu_add_pipe_to_gate(uint8_t pipe_id, uint8_t local_gate,
       pipe_index = (uint8_t)(p_pipe - nfa_hci_cb.cfg.dyn_pipes);
       p_gate->pipe_inx_mask |= (uint32_t)(1 << pipe_index);
 
-      NFA_TRACE_DEBUG4(
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "nfa_hciu_add_pipe_to_gate  Gate ID: 0x%02x  Pipe ID: 0x%02x  "
           "pipe_index: %u  App Handle: 0x%08x",
           local_gate, pipe_id, pipe_index, p_gate->gate_owner);
@@ -553,7 +553,7 @@ tNFA_HCI_RESPONSE nfa_hciu_add_pipe_to_gate(uint8_t pipe_id, uint8_t local_gate,
     }
   }
 
-  NFA_TRACE_DEBUG1("nfa_hciu_add_pipe_to_gate: 0x%02x  NOT FOUND", local_gate);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hciu_add_pipe_to_gate: 0x%02x  NOT FOUND", local_gate);
 
   return (NFA_HCI_ADM_E_NO_PIPES_AVAILABLE);
 }
@@ -575,7 +575,7 @@ tNFA_HCI_RESPONSE nfa_hciu_add_pipe_to_static_gate(uint8_t local_gate,
   tNFA_HCI_DYN_PIPE* p_pipe;
   uint8_t pipe_index;
 
-  NFA_TRACE_EVENT4(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "nfa_hciu_add_pipe_to_static_gate (%u)  Pipe: 0x%02x  Dest Host: 0x%02x  "
       "Dest Gate: 0x%02x)",
       local_gate, pipe_id, dest_host, dest_gate);
@@ -615,7 +615,7 @@ tNFA_HCI_DYN_PIPE* nfa_hciu_find_active_pipe_by_owner(tNFA_HANDLE app_handle) {
   tNFA_HCI_DYN_PIPE* pp;
   int xx;
 
-  NFA_TRACE_DEBUG1("nfa_hciu_find_pipe_by_owner () app_handle:0x%x",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hciu_find_pipe_by_owner () app_handle:0x%x",
                    app_handle);
 
   /* Loop through all pipes looking for the owner */
@@ -650,7 +650,7 @@ bool nfa_hciu_check_pipe_between_gates(uint8_t local_gate, uint8_t dest_host,
   tNFA_HCI_DYN_PIPE* pp;
   int xx;
 
-  NFA_TRACE_DEBUG3(
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "nfa_hciu_check_pipe_between_gates () Local gate: 0x%02X, Host[0x%02X] "
       "gate: 0x%02X",
       local_gate, dest_host, dest_gate);
@@ -684,7 +684,7 @@ tNFA_HCI_DYN_PIPE* nfa_hciu_find_pipe_by_owner(tNFA_HANDLE app_handle) {
   tNFA_HCI_DYN_PIPE* pp;
   int xx;
 
-  NFA_TRACE_DEBUG1("nfa_hciu_find_pipe_by_owner () app_handle:0x%x",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hciu_find_pipe_by_owner () app_handle:0x%x",
                    app_handle);
 
   /* Loop through all pipes looking for the owner */
@@ -715,7 +715,7 @@ tNFA_HCI_DYN_PIPE* nfa_hciu_find_pipe_on_gate(uint8_t gate_id) {
   tNFA_HCI_DYN_PIPE* pp;
   int xx;
 
-  NFA_TRACE_DEBUG1("nfa_hciu_find_pipe_on_gate () Gate:0x%x", gate_id);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hciu_find_pipe_on_gate () Gate:0x%x", gate_id);
 
   /* Loop through all pipes looking for the owner */
   for (xx = 0, pp = nfa_hci_cb.cfg.dyn_pipes; xx < NFA_HCI_MAX_PIPE_CB;
@@ -805,7 +805,7 @@ tNFA_HCI_DYN_PIPE* nfa_hciu_find_active_pipe_on_gate(uint8_t gate_id) {
   tNFA_HCI_DYN_PIPE* pp;
   int xx;
 
-  NFA_TRACE_DEBUG1("nfa_hciu_find_active_pipe_on_gate () Gate:0x%x", gate_id);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hciu_find_active_pipe_on_gate () Gate:0x%x", gate_id);
 
   /* Loop through all pipes looking for the owner */
   for (xx = 0, pp = nfa_hci_cb.cfg.dyn_pipes; xx < NFA_HCI_MAX_PIPE_CB;
@@ -838,13 +838,13 @@ tNFA_HCI_RESPONSE nfa_hciu_release_pipe(uint8_t pipe_id) {
   tNFA_HCI_DYN_PIPE* p_pipe;
   uint8_t pipe_index;
 
-  NFA_TRACE_EVENT1("nfa_hciu_release_pipe: %u", pipe_id);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hciu_release_pipe: %u", pipe_id);
 
   p_pipe = nfa_hciu_find_pipe_by_pid(pipe_id);
   if (p_pipe == NULL) return (NFA_HCI_ANY_E_NOK);
 
   if (pipe_id > NFA_HCI_LAST_DYNAMIC_PIPE) {
-    NFA_TRACE_DEBUG1("ignore pipe: %d", pipe_id);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("ignore pipe: %d", pipe_id);
     return (NFA_HCI_ANY_E_NOK);
   }
 
@@ -886,7 +886,7 @@ void nfa_hciu_remove_all_pipes_from_host(uint8_t host) {
   int xx;
   tNFA_HCI_EVT_DATA evt_data;
 
-  NFA_TRACE_EVENT1("nfa_hciu_remove_all_pipes_from_host (0x%02x)", host);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hciu_remove_all_pipes_from_host (0x%02x)", host);
 
   /* Remove all pipes from the specified host connected to all generic gates */
   for (xx = 0, pp = nfa_hci_cb.cfg.dyn_pipes; xx < NFA_HCI_MAX_PIPE_CB;
@@ -928,7 +928,7 @@ tNFA_STATUS nfa_hciu_send_create_pipe_cmd(uint8_t source_gate,
   data[1] = dest_host;
   data[2] = dest_gate;
 
-  NFA_TRACE_DEBUG3(
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "nfa_hciu_send_create_pipe_cmd source_gate:%d, dest_host:%d, "
       "dest_gate:%d",
       source_gate, dest_host, dest_gate);
@@ -951,10 +951,10 @@ tNFA_STATUS nfa_hciu_send_create_pipe_cmd(uint8_t source_gate,
 tNFA_STATUS nfa_hciu_send_delete_pipe_cmd(uint8_t pipe) {
   tNFA_STATUS status;
 
-  NFA_TRACE_DEBUG1("nfa_hciu_send_delete_pipe_cmd: %d", pipe);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hciu_send_delete_pipe_cmd: %d", pipe);
 
   if (pipe > NFA_HCI_LAST_DYNAMIC_PIPE) {
-    NFA_TRACE_DEBUG1("ignore pipe: %d", pipe);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("ignore pipe: %d", pipe);
     return (NFA_HCI_ANY_E_NOK);
   }
   nfa_hci_cb.pipe_in_use = pipe;
@@ -981,7 +981,7 @@ tNFA_STATUS nfa_hciu_send_clear_all_pipe_cmd(void) {
   tNFA_STATUS status;
   uint16_t id_ref_data = 0x0102;
 
-  NFA_TRACE_DEBUG0("nfa_hciu_send_clear_all_pipe_cmd");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hciu_send_clear_all_pipe_cmd");
 
   status =
       nfa_hciu_send_msg(NFA_HCI_ADMIN_PIPE, NFA_HCI_COMMAND_TYPE,
@@ -1098,7 +1098,7 @@ void nfa_hciu_send_to_app(tNFA_HCI_EVT event, tNFA_HCI_EVT_DATA* p_evt,
   }
 
   if (app_handle != NFA_HANDLE_INVALID) {
-    NFA_TRACE_WARNING2(
+    LOG(WARNING) << StringPrintf(
         "nfa_hciu_send_to_app no callback,  event: 0x%04x  app_handle: 0x%04x",
         event, app_handle);
   }
@@ -1159,7 +1159,7 @@ void nfa_hciu_send_to_apps_handling_connectivity_evts(
 tNFA_STATUS nfa_hciu_send_raw_cmd(uint8_t param_len, uint8_t* p_data,
                                   tNFA_VSC_CBACK* p_cback) {
   tNFA_STATUS status = NFA_STATUS_OK;
-  status = NFA_SendNxpNciCommand(param_len, p_data, p_cback);
+  status = NFA_SendRawVsCommand(param_len, p_data, p_cback);
   if (NFA_STATUS_OK == status) {
     nfa_sys_start_timer(&nfa_hci_cb.timer, NFA_HCI_RSP_TIMEOUT_EVT,
                         p_nfa_hci_cfg->hcp_response_timeout);
@@ -1177,7 +1177,7 @@ tNFA_STATUS nfa_hciu_send_raw_cmd(uint8_t param_len, uint8_t* p_data,
 **
 *******************************************************************************/
 bool nfa_hciu_check_nfcee_poll_done(uint8_t host_id) {
-  NFA_TRACE_DEBUG1("nfa_hciu_check_nfcee_poll_done enter: %x", host_id);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hciu_check_nfcee_poll_done enter: %x", host_id);
   uint8_t xx;
   for (xx = 0; xx < NFA_HCI_MAX_HOST_IN_NETWORK; xx++) {
     if ((nfa_hci_cb.nfcee_cfg.host_cb[xx] & NFA_HANDLE_MASK) == host_id) {
@@ -1199,7 +1199,7 @@ bool nfa_hciu_check_nfcee_poll_done(uint8_t host_id) {
 **
 *******************************************************************************/
 bool nfa_hciu_check_nfcee_config_done(uint8_t host_id) {
-  NFA_TRACE_DEBUG1("nfa_hciu_check_nfcee_config_done: %x", host_id);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hciu_check_nfcee_config_done: %x", host_id);
   uint8_t xx;
   for (xx = 0; xx < NFA_HCI_MAX_HOST_IN_NETWORK; xx++) {
     if ((nfa_hci_cb.nfcee_cfg.host_cb[xx] & NFA_HANDLE_MASK) == host_id) {
@@ -1221,7 +1221,7 @@ bool nfa_hciu_check_nfcee_config_done(uint8_t host_id) {
 **
 *******************************************************************************/
 void nfa_hciu_set_nfceeid_config_mask(uint8_t event, uint8_t host_id) {
-  NFA_TRACE_DEBUG1("nfa_hciu_set_nfceeid_config_mask: %x", host_id);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hciu_set_nfceeid_config_mask: %x", host_id);
   uint8_t xx;
   for (xx = 0; xx < NFA_HCI_MAX_HOST_IN_NETWORK; xx++) {
     if ((nfa_hci_cb.nfcee_cfg.host_cb[xx] & NFA_HANDLE_MASK) == host_id) {
@@ -1244,7 +1244,7 @@ void nfa_hciu_set_nfceeid_config_mask(uint8_t event, uint8_t host_id) {
 **
 *******************************************************************************/
 void nfa_hciu_set_nfceeid_poll_mask(uint8_t event, uint8_t host_id) {
-  NFA_TRACE_DEBUG1("nfa_hciu_set_nfceeid_config_mask: %x", host_id);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_hciu_set_nfceeid_config_mask: %x", host_id);
   uint8_t xx;
   for (xx = 0; xx < NFA_HCI_MAX_HOST_IN_NETWORK; xx++) {
     if ((nfa_hci_cb.nfcee_cfg.host_cb[xx] & NFA_HANDLE_MASK) == host_id) {
@@ -1300,7 +1300,7 @@ tNFA_STATUS nfa_hciu_reset_session_id(tNFA_VSC_CBACK* p_cback) {
   tNFA_DM_API_SEND_VSC* p_data;
   NFC_HDR* p_cmd;
   uint8_t id_buf[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
-  NFA_TRACE_DEBUG1("%s: enter", __func__);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: enter", __func__);
 
   p_data = (tNFA_DM_API_SEND_VSC*)GKI_getbuf(sizeof(tNFA_DM_API_SEND_VSC) +
                                              NXP_NFC_PROP_MAX_CMD_BUF_SIZE);
@@ -1322,12 +1322,11 @@ tNFA_STATUS nfa_hciu_reset_session_id(tNFA_VSC_CBACK* p_cback) {
     pp = p_start;
     UINT8_TO_STREAM(pp, cmd_len);
     p_cmd->len = cmd_len + NCI_DATA_HDR_SIZE;
-    status = NFC_SendNxpNciCommand(p_cmd, p_cback);
+    status = NFC_SendRawVsCommand(p_cmd, p_cback);
   }
   return status;
 }
 #endif
-#if (BT_TRACE_VERBOSE == true)
 /*******************************************************************************
 **
 ** Function         nfa_hciu_get_response_name
@@ -1339,7 +1338,7 @@ tNFA_STATUS nfa_hciu_reset_session_id(tNFA_VSC_CBACK* p_cback) {
 ** Returns          pointer to the name
 **
 *******************************************************************************/
-char* nfa_hciu_get_response_name(uint8_t rsp_code) {
+std::string nfa_hciu_get_response_name(uint8_t rsp_code) {
   switch (rsp_code) {
     case NFA_HCI_ANY_OK:
       return ("ANY_OK");
@@ -1379,7 +1378,7 @@ char* nfa_hciu_get_response_name(uint8_t rsp_code) {
 ** Returns          pointer to the name
 **
 *******************************************************************************/
-char* nfa_hciu_type_2_str(uint8_t type) {
+std::string nfa_hciu_type_2_str(uint8_t type) {
   switch (type) {
     case NFA_HCI_COMMAND_TYPE:
       return ("COMMAND");
@@ -1401,7 +1400,7 @@ char* nfa_hciu_type_2_str(uint8_t type) {
 ** Returns          pointer to the name
 **
 *******************************************************************************/
-char* nfa_hciu_instr_2_str(uint8_t instruction) {
+std::string nfa_hciu_instr_2_str(uint8_t instruction) {
   switch (instruction) {
     case NFA_HCI_ANY_SET_PARAMETER:
       return ("ANY_SET_PARAMETER");
@@ -1437,7 +1436,7 @@ char* nfa_hciu_instr_2_str(uint8_t instruction) {
 ** Returns          pointer to the name
 **
 *******************************************************************************/
-char* nfa_hciu_get_event_name(uint16_t event) {
+std::string nfa_hciu_get_event_name(uint16_t event) {
   switch (event) {
     case NFA_HCI_API_REGISTER_APP_EVT:
       return ("API_REGISTER");
@@ -1494,7 +1493,7 @@ char* nfa_hciu_get_event_name(uint16_t event) {
 ** Returns          pointer to the name
 **
 *******************************************************************************/
-char* nfa_hciu_get_state_name(uint8_t state) {
+std::string nfa_hciu_get_state_name(uint8_t state) {
   switch (state) {
     case NFA_HCI_STATE_DISABLED:
       return ("DISABLED");
@@ -1535,20 +1534,20 @@ char* nfa_hciu_get_type_inst_names(uint8_t pipe, uint8_t type, uint8_t inst,
                                    char* p_buff) {
   int xx;
 
-  xx = snprintf(p_buff, VERBOSE_BUFF_SIZE, "Type: %s [0x%02x] ", nfa_hciu_type_2_str(type), type);
+  xx = snprintf(p_buff, VERBOSE_BUFF_SIZE, "Type: %s [0x%02x] ", nfa_hciu_type_2_str(type).c_str(), type);
 
   switch (type) {
     case NFA_HCI_COMMAND_TYPE:
-      snprintf(&p_buff[xx], VERBOSE_BUFF_SIZE, "Inst: %s [0x%02x] ", nfa_hciu_instr_2_str(inst),
+      snprintf(&p_buff[xx], VERBOSE_BUFF_SIZE, "Inst: %s [0x%02x] ", nfa_hciu_instr_2_str(inst).c_str(),
               inst);
       break;
     case NFA_HCI_EVENT_TYPE:
-      snprintf(&p_buff[xx], VERBOSE_BUFF_SIZE, "Evt: %s [0x%02x] ", nfa_hciu_evt_2_str(pipe, inst),
+      snprintf(&p_buff[xx], VERBOSE_BUFF_SIZE, "Evt: %s [0x%02x] ", nfa_hciu_evt_2_str(pipe, inst).c_str(),
               inst);
       break;
     case NFA_HCI_RESPONSE_TYPE:
       snprintf(&p_buff[xx], VERBOSE_BUFF_SIZE, "Resp: %s [0x%02x] ",
-              nfa_hciu_get_response_name(inst), inst);
+              nfa_hciu_get_response_name(inst).c_str(), inst);
       break;
     default:
       snprintf(&p_buff[xx], VERBOSE_BUFF_SIZE, "Inst: %u ", inst);
@@ -1566,7 +1565,7 @@ char* nfa_hciu_get_type_inst_names(uint8_t pipe, uint8_t type, uint8_t inst,
 ** Returns          pointer to the name
 **
 *******************************************************************************/
-char* nfa_hciu_evt_2_str(uint8_t pipe_id, uint8_t evt) {
+std::string nfa_hciu_evt_2_str(uint8_t pipe_id, uint8_t evt) {
   tNFA_HCI_DYN_PIPE* p_pipe;
 
   if ((pipe_id != NFA_HCI_ADMIN_PIPE) &&
@@ -1601,9 +1600,8 @@ char* nfa_hciu_evt_2_str(uint8_t pipe_id, uint8_t evt) {
       return ("UNKNOWN");
   }
 }
-#endif
 
-static void handle_debug_loopback(NFC_HDR* p_buf, uint8_t pipe, uint8_t type,
+static void handle_debug_loopback(NFC_HDR* p_buf, uint8_t type,
                                   uint8_t instruction) {
   uint8_t* p = (uint8_t*)(p_buf + 1) + p_buf->offset;
   static uint8_t next_pipe = 0x10;
diff --git a/src/nfa/include/nfa_api.h b/src/nfa/include/nfa_api.h
old mode 100644
new mode 100755
index e2f23f2..5b73cf1
--- a/src/nfa/include/nfa_api.h
+++ b/src/nfa/include/nfa_api.h
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -59,66 +59,30 @@
 /* Max length of Appliction ID in 7816-4 */
 #define NFA_MAX_AID_LEN NFC_MAX_AID_LEN
 #define NFA_MIN_AID_LEN 5 /* per NCI specification */
-/* Result of NFA_SetPowerSubState */
-#define NFA_DM_SET_POWER_SUB_STATE_EVT 13
-/* NFA API return status codes */
+
 /* Command succeeded    */
 #define NFA_STATUS_OK NCI_STATUS_OK
 /* Command is rejected. */
 #define NFA_STATUS_REJECTED NCI_STATUS_REJECTED
-/* Message is corrupted */
-#define NFA_STATUS_MSG_CORRUPTED NCI_STATUS_MESSAGE_CORRUPTED
 /* buffer full          */
 #define NFA_STATUS_BUFFER_FULL NCI_STATUS_BUFFER_FULL
 /* failed               */
 #define NFA_STATUS_FAILED NCI_STATUS_FAILED
-/* not initialized      */
-#define NFA_STATUS_NOT_INITIALIZED NCI_STATUS_NOT_INITIALIZED
-/* Syntax error         */
-#define NFA_STATUS_SYNTAX_ERROR NCI_STATUS_SYNTAX_ERROR
+/* Optional feature of NCI Spec not supported */
+#define NFA_STATUS_NOT_SUPPORTED NCI_STATUS_NOT_SUPPORTED
 /* Semantic error       */
 #define NFA_STATUS_SEMANTIC_ERROR NCI_STATUS_SEMANTIC_ERROR
 /* Unknown NCI Group ID */
 #define NFA_STATUS_UNKNOWN_GID NCI_STATUS_UNKNOWN_GID
-/* Unknown NCI Opcode   */
-#define NFA_STATUS_UNKNOWN_OID NCI_STATUS_UNKNOWN_OID
 /* Invalid Parameter    */
 #define NFA_STATUS_INVALID_PARAM NCI_STATUS_INVALID_PARAM
-/* Message size too big */
-#define NFA_STATUS_MSG_SIZE_TOO_BIG NCI_STATUS_MSG_SIZE_TOO_BIG
 /* Already started      */
 #define NFA_STATUS_ALREADY_STARTED NCI_STATUS_ALREADY_STARTED
-/* Activation Failed    */
-#define NFA_STATUS_ACTIVATION_FAILED NCI_STATUS_ACTIVATION_FAILED
-/* Tear Down Error      */
-#define NFA_STATUS_TEAR_DOWN NCI_STATUS_TEAR_DOWN
-/* RF transmission error*/
-#define NFA_STATUS_RF_TRANSMISSION_ERR NCI_STATUS_RF_TRANSMISSION_ERR
-/* RF protocol error    */
-#define NFA_STATUS_RF_PROTOCOL_ERR NCI_STATUS_RF_PROTOCOL_ERR
 /* RF Timeout           */
 #define NFA_STATUS_TIMEOUT NCI_STATUS_TIMEOUT
-/* EE Intf activate err */
-#define NFA_STATUS_EE_INTF_ACTIVE_FAIL NCI_STATUS_EE_INTF_ACTIVE_FAIL
-/* EE transmission error*/
-#define NFA_STATUS_EE_TRANSMISSION_ERR NCI_STATUS_EE_TRANSMISSION_ERR
-/* EE protocol error    */
-#define NFA_STATUS_EE_PROTOCOL_ERR NCI_STATUS_EE_PROTOCOL_ERR
-/* EE Timeout           */
-#define NFA_STATUS_EE_TIMEOUT NCI_STATUS_EE_TIMEOUT
-
-/* Command started successfully */
-#define NFA_STATUS_CMD_STARTED NFC_STATUS_CMD_STARTED
-/* NFCC Timeout in responding to an NCI command */
-#define NFA_STATUS_HW_TIMEOUT NFC_STATUS_HW_TIMEOUT
-/* More NFA_CE_GET_ROUTING_REVT to follow */
-#define NFA_STATUS_CONTINUE NFC_STATUS_CONTINUE
-/* API is called to perform illegal function */
-#define NFA_STATUS_REFUSED NFC_STATUS_REFUSED
-/* Wrong format of R-APDU, CC file or NDEF file */
-#define NFA_STATUS_BAD_RESP NFC_STATUS_BAD_RESP
-/* 7816 Status Word is not command complete(0x9000) */
-#define NFA_STATUS_CMD_NOT_CMPLTD NFC_STATUS_CMD_NOT_CMPLTD
+/* not initialized      */
+#define NFA_STATUS_NOT_INITIALIZED NCI_STATUS_NOT_INITIALIZED
+
 /* Out of GKI buffers */
 #define NFA_STATUS_NO_BUFFERS NFC_STATUS_NO_BUFFERS
 /* Protocol mismatch between API and activated one */
@@ -145,8 +109,6 @@ typedef uint16_t tNFA_HANDLE;
 /* NFA Handle definitions */
 
 /* The upper byte of NFA_HANDLE signifies the handle group */
-/* Connection handles           */
-#define NFA_HANDLE_GROUP_CONNECTION 0x0100
 /* NDEF Type Handler handles    */
 #define NFA_HANDLE_GROUP_NDEF_HANDLER 0x0200
 /* DH Card Emulation handles    */
@@ -155,12 +117,9 @@ typedef uint16_t tNFA_HANDLE;
 #define NFA_HANDLE_GROUP_EE 0x0400
 /* P2P handles                  */
 #define NFA_HANDLE_GROUP_P2P 0x0500
-/* SNEP handles                 */
-#define NFA_HANDLE_GROUP_SNEP 0x0700
 /* HCI handles                  */
 #define NFA_HANDLE_GROUP_HCI 0x0800
 /* Local NDEF message handle    */
-#define NFA_HANDLE_GROUP_LOCAL_NDEF 0x0900
 #define NFA_HANDLE_GROUP_MASK 0xFF00
 #define NFA_HANDLE_MASK 0x00FF
 
@@ -171,15 +130,16 @@ typedef uint8_t tNFA_PMID;
 #define NFA_TECHNOLOGY_MASK_A 0x01        /* NFC Technology A             */
 #define NFA_TECHNOLOGY_MASK_B 0x02        /* NFC Technology B             */
 #define NFA_TECHNOLOGY_MASK_F 0x04        /* NFC Technology F             */
-#define NFA_TECHNOLOGY_MASK_ISO15693 0x08 /* Proprietary Technology       */
+/* TECHNOLOGY_MASK_V in NCI2.0 and TECHNOLOGY_MASK_15693 proprietary in NCI1.0*/
+#define NFA_TECHNOLOGY_MASK_V 0x08
 #define NFA_TECHNOLOGY_MASK_B_PRIME 0x10  /* Proprietary Technology       */
 #define NFA_TECHNOLOGY_MASK_KOVIO 0x20    /* Proprietary Technology       */
+/* NFC technology NFC-DEP protocol active mode */
+#define NFA_TECHNOLOGY_MASK_ACTIVE 0x40
 /* NFC Technology A active mode */
 #define NFA_TECHNOLOGY_MASK_A_ACTIVE 0x40
 /* NFC Technology F active mode */
 #define NFA_TECHNOLOGY_MASK_F_ACTIVE 0x80
-/* All supported technologies   */
-#define NFA_TECHNOLOGY_MASK_ALL 0xFF
 typedef uint8_t tNFA_TECHNOLOGY_MASK;
 
 /* Definitions for NFC protocol for RW, CE and P2P APIs */
@@ -193,10 +153,8 @@ typedef uint8_t tNFA_TECHNOLOGY_MASK;
 #define NFA_PROTOCOL_ISO_DEP NFC_PROTOCOL_ISO_DEP
 /* NFCDEP/LLCP - NFC-A or NFC-F */
 #define NFA_PROTOCOL_NFC_DEP NFC_PROTOCOL_NFC_DEP
-#define NFA_PROTOCOL_ISO15693 NFC_PROTOCOL_15693
-#define NFA_PROTOCOL_B_PRIME NFC_PROTOCOL_B_PRIME
-#define NFA_PROTOCOL_KOVIO NFC_PROTOCOL_KOVIO
-#define NFA_PROTOCOL_MIFARE NFC_PROTOCOL_MIFARE
+/* NFC_PROTOCOL_T5T in NCI2.0 and NFC_PROTOCOL_ISO15693 proprietary in NCI1.0*/
+#define NFA_PROTOCOL_T5T NFC_PROTOCOL_T5T
 #if (NXP_EXTNS == TRUE)
 #define NFA_PROTOCOL_T3BT NFC_PROTOCOL_T3BT
 #define NFA_NORMAL_BOOT_MODE NFC_NORMAL_BOOT_MODE
@@ -204,7 +162,6 @@ typedef uint8_t tNFA_TECHNOLOGY_MASK;
 #define NFA_OSU_BOOT_MODE NFC_OSU_BOOT_MODE
 #endif
 #define NFA_PROTOCOL_INVALID 0xFF
-#define NFA_MAX_NUM_PROTOCOLS 8
 typedef uint8_t tNFA_NFC_PROTOCOL;
 
 /* Definitions for tNFA_PROTOCOL_MASK */
@@ -234,6 +191,8 @@ typedef uint8_t tNFA_PROTOCOL_MASK;
 #define NFA_DM_NFCC_TIMEOUT_EVT 6
 /* NCI Tranport error               */
 #define NFA_DM_NFCC_TRANSPORT_ERR_EVT 7
+/* Result of NFA_SetPowerSubStateForScreenState */
+#define NFA_DM_SET_POWER_SUB_STATE_EVT 11
 #if (NXP_EXTNS == TRUE)
 /* Collision event in case of EMV-CO Profile (Nxp)*/
 #define NFA_DM_EMVCO_PCD_COLLISION_EVT 8
@@ -242,30 +201,19 @@ typedef uint8_t tNFA_PROTOCOL_MASK;
 /* Result of NFA_GetRouting         */
 #define NFA_DM_GET_ROUTE_CONFIG_REVT 10
 /*Status when EE HCI subsystems disabled*/
-#define NFA_DM_EE_HCI_DISABLE 11
+#define NFA_DM_EE_HCI_DISABLE 12
 /*Status when EE HCI susbsystems enabled*/
-#define NFA_DM_EE_HCI_ENABLE 12
-
-/* Reader over SWP Events*/
-#define NFA_RD_SWP_READER_REQUESTED 0
-#define NFA_RD_SWP_READER_START 1
-#define NFA_RD_SWP_READER_STOP 2
-#define NFA_RD_SWP_READER_START_FAIL 3
+#define NFA_DM_EE_HCI_ENABLE 13
+/*Status when Transit Config is set*/
+#define NFA_DM_SET_TRANSIT_CONFIG_EVT 14
 #endif
 
 /* T1T HR length            */
 #define NFA_T1T_HR_LEN T1T_HR_LEN
 /* Max UID length of T1/T2  */
 #define NFA_MAX_UID_LEN TAG_MAX_UID_LEN
-/* T1T UID length           */
-#define NFA_T1T_UID_LEN T1T_UID_LEN
 /* UID len for T1T cmds     */
 #define NFA_T1T_CMD_UID_LEN T1T_CMD_UID_LEN
-/* T2T UID length           */
-#define NFA_T2T_UID_LEN T2T_UID_LEN
-
-/* Tag is read only */
-#define NFA_RW_NDEF_FL_READ_ONLY RW_NDEF_FL_READ_ONLY
 /* Tag formated for NDEF */
 #define NFA_RW_NDEF_FL_FORMATED RW_NDEF_FL_FORMATED
 /* NDEF supported by the tag */
@@ -274,12 +222,6 @@ typedef uint8_t tNFA_PROTOCOL_MASK;
 #define NFA_RW_NDEF_FL_UNKNOWN RW_NDEF_FL_UNKNOWN
 /* Tag supports format operation */
 #define NFA_RW_NDEF_FL_FORMATABLE RW_NDEF_FL_FORMATABLE
-/* Tag can be soft locked */
-#define NFA_RW_NDEF_FL_SOFT_LOCKABLE RW_NDEF_FL_SOFT_LOCKABLE
-/* Tag can be hard locked */
-#define NFA_RW_NDEF_FL_HARD_LOCKABLE RW_NDEF_FL_HARD_LOCKABLE
-/* Tag is one time programmable */
-#define NFA_RW_NDEF_FL_OTP RW_NDEF_FL_OTP
 
 typedef uint8_t tNFA_RW_NDEF_FLAG;
 
@@ -294,7 +236,7 @@ typedef struct {
 typedef struct {
   tNFA_STATUS status;    /* NFA_STATUS_OK if successful              */
   uint16_t tlv_size;     /* The length of TLV                        */
-  uint8_t param_tlvs[1]; /* TLV (Parameter ID-Len-Value byte stream) */
+  uint8_t* param_tlvs; /* TLV (Parameter ID-Len-Value byte stream) */
 } tNFA_GET_CONFIG;
 
 #if (NXP_EXTNS == TRUE)
@@ -305,6 +247,7 @@ typedef struct {
   uint8_t tlv_size;        /* the total len of all TLVs                */
   uint8_t param_tlvs[150]; /* TLV (Parameter ID-Len-Value byte stream) */
 } tNFA_GET_ROUTING;
+typedef struct { tNFA_STATUS status; } tNFA_SET_TRANSIT_CONFIG;
 #endif
 
 #define NFA_DM_PWR_MODE_FULL 0x04
@@ -320,37 +263,23 @@ typedef struct {
 } tNFA_DM_PWR_MODE_CHANGE;
 
 /* Structure to store screen state */
-typedef enum screen_state_NCI2
-{
+typedef enum screen_state {
   NFA_SCREEN_STATE_UNKNOWN = 0x00,
   NFA_SCREEN_STATE_OFF_UNLOCKED = 0x01,
   NFA_SCREEN_STATE_OFF_LOCKED = 0x02,
   NFA_SCREEN_STATE_ON_LOCKED = 0x04,
   NFA_SCREEN_STATE_ON_UNLOCKED = 0x08
-}eScreenState_t;
+} eScreenState_t;
 
-typedef enum power_substate
-{
+typedef enum power_substate {
   SCREEN_STATE_ON_UNLOCKED = 0x00,
   SCREEN_STATE_OFF_UNLOCKED,
   SCREEN_STATE_ON_LOCKED,
   SCREEN_STATE_OFF_LOCKED,
-}epower_substate_t;
-
-// CONN_DISCOVER_PARAM
-#define NFA_LISTEN_DH_NFCEE_ENABLE_MASK  NCI_LISTEN_DH_NFCEE_ENABLE_MASK
-#define NFA_LISTEN_DH_NFCEE_DISABLE_MASK NCI_LISTEN_DH_NFCEE_DISABLE_MASK
-#define NFA_POLLING_DH_DISABLE_MASK      NCI_POLLING_DH_DISABLE_MASK
-#define NFA_POLLING_DH_ENABLE_MASK       NCI_POLLING_DH_ENABLE_MASK
+} epower_substate_t;
 
 #define NFA_SCREEN_STATE_MASK 0x0F
 
-typedef struct
-{
-  tNFA_STATUS status; /* NFA_STATUS_OK if successful  */
-  uint8_t power_state; /* current screen/power state */
-} tNFA_DM_POWER_STATE;
-
 /* Data for NFA_DM_RF_FIELD_EVT */
 #define NFA_DM_RF_FIELD_OFF 0x00
 #define NFA_DM_RF_FIELD_ON 0x01
@@ -361,6 +290,11 @@ typedef struct {
   uint8_t rf_field_status;
 } tNFA_DM_RF_FIELD;
 
+typedef struct {
+  tNFA_STATUS status;  /* NFA_STATUS_OK if successful  */
+  uint8_t power_state; /* current screen/power state */
+} tNFA_DM_POWER_STATE;
+
 /* Union of all DM callback structures */
 typedef union {
   tNFA_STATUS status;         /* NFA_DM_ENABLE_EVT        */
@@ -368,6 +302,7 @@ typedef union {
   tNFA_GET_CONFIG get_config; /* NFA_DM_GET_CONFIG_EVT    */
 #if (NXP_EXTNS == TRUE)
   tNFA_GET_ROUTING get_routing; /* NFA_DM_GET_ROUTING_EVT    */
+  tNFA_SET_TRANSIT_CONFIG set_transit_config; /* NFA_DM_SET_TRANSIT_CONFIG */
 #endif
   tNFA_DM_PWR_MODE_CHANGE power_mode; /* NFA_DM_PWR_MODE_CHANGE_EVT   */
   tNFA_DM_RF_FIELD rf_field;          /* NFA_DM_RF_FIELD_EVT      */
@@ -378,7 +313,6 @@ typedef union {
 /* NFA_DM callback */
 typedef void(tNFA_DM_CBACK)(uint8_t event, tNFA_DM_CBACK_DATA* p_data);
 
-#if (NXP_EXTNS == TRUE)
 /* NFA Enable DTA Type Mode */
 typedef enum {
   NFA_DTA_DEFAULT_MODE = 0x00000001,
@@ -391,6 +325,7 @@ typedef enum {
   NFA_DTA_CR11 = 0x000000B0,
   NFA_DTA_CR12 = 0x000000C0,
 } tNFA_eDtaModes;
+#if (NXP_EXTNS == TRUE)
 typedef struct {
   uint32_t validation; /* indicates on which platform validation is done like
                          pn547, pn548, pn65T, pn66T */
@@ -647,21 +582,6 @@ typedef struct {
 /* Union of all connection callback structures */
 typedef union {
   tNFA_STATUS status;           /* NFA_POLL_ENABLED_EVT                 */
-                                /* NFA_POLL_DISABLED_EVT                */
-                                /* NFA_CE_UICC_LISTEN_CONFIGURED_EVT    */
-                                /* NFA_EXCLUSIVE_RF_CONTROL_STARTED_EVT */
-                                /* NFA_EXCLUSIVE_RF_CONTROL_STOPPED_EVT */
-                                /* NFA_SELECT_RESULT_EVT                */
-                                /* NFA_DEACTIVATE_FAIL_EVT              */
-                                /* NFA_CE_NDEF_WRITE_START_EVT          */
-                                /* NFA_SELECT_CPLT_EVT                  */
-                                /* NFA_READ_CPLT_EVT                    */
-                                /* NFA_WRITE_CPLT_EVT                   */
-                                /* NFA_PRESENCE_CHECK_EVT               */
-                                /* NFA_FORMAT_CPLT_EVT                  */
-                                /* NFA_SET_TAG_RO_EVT                   */
-                                /* NFA_UPDATE_RF_PARAM_RESULT_EVT       */
-                                /* NFA_RW_INTF_ERROR_EVT                */
   tNFA_DISC_RESULT disc_result; /* NFA_DISC_RESULT_EVT                  */
   tNFA_ACTIVATED activated;     /* NFA_ACTIVATED_EVT                    */
   tNFA_DEACTIVATED deactivated; /* NFA_DEACTIVATED_EVT                  */
@@ -698,6 +618,7 @@ typedef struct {
   uint8_t pk;   /* Frequency for Proprietary Technology/Kovio   */
   uint8_t paa;  /* Frequency for NFC Technology A active mode   */
   uint8_t pfa;  /* Frequency for NFC Technology F active mode   */
+  uint8_t pacm; /* Frequency for NFC Technology active mode     */
 } tNFA_DM_DISC_FREQ_CFG;
 
 /* definitions for tNFA_DM_CFG.presence_check_option */
@@ -883,9 +804,6 @@ typedef void(tNFA_VSC_CBACK)(uint8_t event, uint16_t param_len,
 /*****************************************************************************
 **  External Function Declarations
 *****************************************************************************/
-#ifdef __cplusplus
-extern "C" {
-#endif
 
 /*******************************************************************************
 **
@@ -988,6 +906,20 @@ extern tNFA_STATUS NFA_SetConfig(tNFA_PMID param_id, uint8_t length,
 **
 *******************************************************************************/
 extern tNFA_STATUS NFA_GetConfig(uint8_t num_ids, tNFA_PMID* p_param_ids);
+/*******************************************************************************
+**
+** Function         NFA_SetTransitConfig
+**
+** Description      Get the Transit configuration value from NFC Service. The
+**                  result is reported with an NFA_DM_SET_TRANSIT_CONFIG_EVT in
+**                  the tNFA_DM_CBACK callback.
+**
+** Returns          NFA_STATUS_OK if successfully initiated
+**                  NFA_STATUS_BUSY if previous setting is on-going
+**                  NFA_STATUS_FAILED otherwise
+**
+*******************************************************************************/
+extern tNFA_STATUS NFA_SetTransitConfig(std::string config);
 
 /*******************************************************************************
 **
@@ -1498,28 +1430,28 @@ extern tNFA_STATUS NFA_SendVsCommand(uint8_t oid, uint8_t cmd_params_len,
                                      uint8_t* p_cmd_params,
                                      tNFA_VSC_CBACK* p_cback);
 
-#if (NXP_EXTNS == TRUE)
 /*******************************************************************************
 **
-** Function         NFA_SendNxpNciCommand
+** Function         NFA_SendRawVsCommand
 **
-** Description      This function is called to send NXP NCI Vendor Specific
+** Description      This function is called to send raw vendor specific
 **                  command to NFCC.
 **
 **                  cmd_params_len  - The command parameter len
 **                  p_cmd_params    - The command parameter
 **                  p_cback         - The callback function to receive the
-*command
+**                                    command
 **
 ** Returns          NFA_STATUS_OK if successfully initiated
 **                  NFA_STATUS_FAILED otherwise
 **
 *******************************************************************************/
 
-extern tNFA_STATUS NFA_SendNxpNciCommand(uint8_t cmd_params_len,
-                                         uint8_t* p_cmd_params,
-                                         tNFA_VSC_CBACK* p_cback);
+extern tNFA_STATUS NFA_SendRawVsCommand(uint8_t cmd_params_len,
+                                        uint8_t* p_cmd_params,
+                                        tNFA_VSC_CBACK* p_cback);
 
+#if (NXP_EXTNS == TRUE)
 /*******************************************************************************
 **
 ** Function         NFA_Send_Core_Reset
@@ -1546,27 +1478,14 @@ extern void NFA_Send_Core_Init(uint8_t** p);
 #endif
 
 /*******************************************************************************
-**
-** Function         NFA_SetTraceLevel
-**
-** Description      This function sets the trace level for NFA.  If called with
-**                  a value of 0xFF, it simply returns the current trace level.
-**
-** Returns          The new or current trace level
-**
-*******************************************************************************/
-extern uint8_t NFA_SetTraceLevel(uint8_t new_level);
-
-/*******************************************************************************
-**
-** Function:        NFA_SetPowerSubState
+** Function:        NFA_SetPowerSubStateForScreenState
 **
 ** Description:     This function send the current screen state
 **
 ** Returns:        NFA_STATUS_OK if successfully initiated
 **                  NFA_STATUS_FAILED otherwise
 *******************************************************************************/
-extern tNFA_STATUS NFA_SetPowerSubState (uint8_t  ScreenState);
+extern tNFA_STATUS NFA_SetPowerSubStateForScreenState(uint8_t ScreenState);
 
 /*******************************************************************************
 **
@@ -1577,6 +1496,8 @@ extern tNFA_STATUS NFA_SetPowerSubState (uint8_t  ScreenState);
 ** Returns:         none:
 **
 *******************************************************************************/
+extern void NFA_EnableDtamode(tNFA_eDtaModes eDtaMode);
+
 #if (NXP_EXTNS == TRUE)
 /*******************************************************************************
 **
@@ -1613,7 +1534,18 @@ extern void NFA_SetReaderMode(bool ReaderModeFlag, uint32_t Technologies);
 *******************************************************************************/
 extern void NFA_SetBootMode(uint8_t boot_mode);
 
-extern void NFA_EnableDtamode(tNFA_eDtaModes eDtaMode);
+/*******************************************************************************
+**
+** Function         NFA_SetLowRamDevice
+**
+** Description      This function sets the device is LOW RAM enabled or not
+**                  param mode is either true or false
+**                  true - LOW RAM DEVICE
+**                  false - NOT A LOW RAM DEVICE
+** Returns          none
+**
+*******************************************************************************/
+extern void NFA_SetLowRamDevice(bool mode);
 
 /*******************************************************************************
 **
@@ -1667,9 +1599,6 @@ extern void NFA_SetPreferredUiccId(uint8_t uicc_id);
 **
 *******************************************************************************/
 extern uint8_t NFA_GetNCIVersion();
-#ifdef __cplusplus
-}
-#endif
 
 
 #endif /* NFA_API_H */
diff --git a/src/nfa/include/nfa_ce_api.h b/src/nfa/include/nfa_ce_api.h
index 28a5708..d8af901 100644
--- a/src/nfa/include/nfa_ce_api.h
+++ b/src/nfa/include/nfa_ce_api.h
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -53,9 +53,6 @@
 /*****************************************************************************
 **  External Function Declarations
 *****************************************************************************/
-#ifdef __cplusplus
-extern "C" {
-#endif
 
 /*******************************************************************************
 **
@@ -182,7 +179,7 @@ extern tNFA_STATUS NFA_CeConfigureEseListenTech(tNFA_HANDLE ee_handle,
 *******************************************************************************/
 extern tNFA_STATUS NFA_CeRegisterFelicaSystemCodeOnDH(
     uint16_t system_code, uint8_t nfcid2[NCI_RF_F_UID_LEN],
-    tNFA_CONN_CBACK* p_conn_cback);
+    uint8_t t3tPmm[NCI_T3T_PMM_LEN], tNFA_CONN_CBACK* p_conn_cback);
 
 /*******************************************************************************
 **
@@ -281,8 +278,5 @@ extern tNFA_STATUS NFA_CeDeregisterAidOnDH(tNFA_HANDLE handle);
 *******************************************************************************/
 extern tNFA_STATUS NFA_CeSetIsoDepListenTech(tNFA_TECHNOLOGY_MASK tech_mask);
 
-#ifdef __cplusplus
-}
-#endif
 
 #endif /* NFA_CE_API_H */
diff --git a/src/nfa/int/nfa_ce_int.h b/src/nfa/include/nfa_ce_int.h
similarity index 98%
rename from src/nfa/int/nfa_ce_int.h
rename to src/nfa/include/nfa_ce_int.h
index 1fb4528..f5cbb5c 100644
--- a/src/nfa/int/nfa_ce_int.h
+++ b/src/nfa/include/nfa_ce_int.h
@@ -53,9 +53,6 @@
 **  Constants and data types
 *****************************************************************************/
 
-/* ce status callback */
-typedef void tNFA_CE_STATUS_CBACK(tNFA_STATUS status);
-
 /* CE events */
 enum {
   /* device manager local device API events */
@@ -64,14 +61,11 @@ enum {
   NFA_CE_API_DEREG_LISTEN_EVT,
   NFA_CE_API_CFG_ISODEP_TECH_EVT,
   NFA_CE_ACTIVATE_NTF_EVT,
-  NFA_CE_DEACTIVATE_NTF_EVT,
-
-  NFA_CE_MAX_EVT
+  NFA_CE_DEACTIVATE_NTF_EVT
 };
 
 /* Listen registration types */
 enum {
-  NFA_CE_REG_TYPE_NDEF,
   NFA_CE_REG_TYPE_ISO_DEP,
   NFA_CE_REG_TYPE_FELICA,
   NFA_CE_REG_TYPE_UICC
diff --git a/src/nfa/int/nfa_dm_int.h b/src/nfa/include/nfa_dm_int.h
old mode 100644
new mode 100755
similarity index 96%
rename from src/nfa/int/nfa_dm_int.h
rename to src/nfa/include/nfa_dm_int.h
index 6eede26..91c0a04
--- a/src/nfa/int/nfa_dm_int.h
+++ b/src/nfa/include/nfa_dm_int.h
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -43,6 +43,7 @@
 #ifndef NFA_DM_INT_H
 #define NFA_DM_INT_H
 
+#include <string>
 #include "nfc_api.h"
 #include "nfa_api.h"
 #include "nfa_sys.h"
@@ -66,6 +67,7 @@ enum {
   NFA_DM_API_DISABLE_LISTENING_EVT,
 #if (NXP_EXTNS == TRUE)
   NFA_DM_API_DISABLE_PASSIVE_LISTENING_EVT,
+  NFA_DM_SET_TRANSIT_CONFIG,
 #endif
   NFA_DM_API_PAUSE_P2P_EVT,
   NFA_DM_API_RESUME_P2P_EVT,
@@ -83,10 +85,8 @@ enum {
   NFA_DM_API_REG_VSC_EVT,
   NFA_DM_API_SEND_VSC_EVT,
   NFA_DM_TIMEOUT_DISABLE_EVT,
-#if (NXP_EXTNS == TRUE)
-  NFA_DM_API_SEND_NXP_EVT,
-#endif
   NFA_DM_API_SET_POWER_SUB_STATE_EVT,
+  NFA_DM_API_SEND_RAW_VS_EVT,
   NFA_DM_MAX_EVT
 };
 
@@ -164,7 +164,13 @@ typedef struct {
   NFC_HDR hdr;
   uint16_t rf_disc_dur_ms;
 } tNFA_DM_API_SET_RF_DISC_DUR;
-#define NFA_RF_DISC_DURATION_MAX 0xFFFF
+
+/* data type for NFA_DM_SET_TRANSIT_CONFIG*/
+typedef struct {
+  NFC_HDR hdr;
+  tNFA_DM_CBACK* p_dm_cback;
+  char* transitConfig;
+} tNFA_DM_API_SET_TRANSIT_CONFIG;
 
 /* data type for NFA_DM_API_REG_NDEF_HDLR_EVT */
 #define NFA_NDEF_FLAGS_HANDLE_WHOLE_MESSAGE 0x01
@@ -184,14 +190,6 @@ typedef struct {
                        registered.    */
 } tNFA_DM_API_REG_NDEF_HDLR;
 
-
-/* data type for NFA_DM_API_SET_POWER_SUB_STATE_EVT */
-typedef struct
-{
-  NFC_HDR hdr;
-  uint8_t screen_state;
-} tNFA_DM_API_SET_POWER_SUB_STATE;
-
 /* data type for NFA_DM_API_DEREG_NDEF_HDLR_EVT */
 typedef struct {
   NFC_HDR hdr;
@@ -216,6 +214,12 @@ typedef struct {
   uint8_t* p_cmd_params;
 } tNFA_DM_API_SEND_VSC;
 
+/* data type for NFA_DM_API_SET_POWER_SUB_STATE_EVT */
+typedef struct {
+  NFC_HDR hdr;
+  uint8_t screen_state;
+} tNFA_DM_API_SET_POWER_SUB_STATE;
+
 /* union of all data types */
 typedef union {
   /* GKI event buffer header */
@@ -225,6 +229,9 @@ typedef union {
                                     /* NFA_DM_API_DISABLE_POLLING_EVT       */
                                     /* NFA_DM_API_START_RF_DISCOVERY_EVT    */
                                     /* NFA_DM_API_STOP_RF_DISCOVERY_EVT     */
+#if (NXP_EXTNS == TRUE)
+  tNFA_DM_API_SET_TRANSIT_CONFIG transit_config; /* NFA_DM_SET_TRANSIT_CONFIG */
+#endif
   tNFA_DM_API_ENABLE enable;        /* NFA_DM_API_ENABLE_EVT                */
   tNFA_DM_API_DISABLE disable;      /* NFA_DM_API_DISABLE_EVT               */
   tNFA_DM_API_SET_CONFIG setconfig; /* NFA_DM_API_SET_CONFIG_EVT            */
@@ -245,7 +252,8 @@ typedef union {
   tNFA_DM_API_DEACTIVATE deactivate; /* NFA_DM_API_DEACTIVATE_EVT            */
   tNFA_DM_API_SEND_VSC send_vsc;     /* NFA_DM_API_SEND_VSC_EVT              */
   tNFA_DM_API_REG_VSC reg_vsc;       /* NFA_DM_API_REG_VSC_EVT               */
-  tNFA_DM_API_SET_POWER_SUB_STATE set_power_state; /* NFA_DM_API_SET_POWER_SUB_STATE_EVT   */
+  /* NFA_DM_API_SET_POWER_SUB_STATE_EVT */
+  tNFA_DM_API_SET_POWER_SUB_STATE set_power_state;
 } tNFA_DM_MSG;
 
 /* DM RF discovery state */
@@ -310,10 +318,11 @@ typedef uint8_t tNFA_DM_RF_DISC_EVT;
 #define NFA_DM_DISC_MASK_PB_ISO_DEP 0x00000010
 #define NFA_DM_DISC_MASK_PF_T3T 0x00000020
 #define NFA_DM_DISC_MASK_PF_NFC_DEP 0x00000040
-#define NFA_DM_DISC_MASK_P_ISO15693 0x00000100
+#define NFA_DM_DISC_MASK_P_T5T 0x00000100
 #define NFA_DM_DISC_MASK_P_B_PRIME 0x00000200
 #define NFA_DM_DISC_MASK_P_KOVIO 0x00000400
 #define NFA_DM_DISC_MASK_PAA_NFC_DEP 0x00000800
+#define NFA_DM_DISC_MASK_PACM_NFC_DEP 0x00000800
 #define NFA_DM_DISC_MASK_PFA_NFC_DEP 0x00001000
 /* Legacy/proprietary/non-NFC Forum protocol (e.g Shanghai transit card) */
 #define NFA_DM_DISC_MASK_P_LEGACY 0x00002000
@@ -329,6 +338,7 @@ typedef uint8_t tNFA_DM_RF_DISC_EVT;
 #define NFA_DM_DISC_MASK_LF_NFC_DEP 0x00400000
 #define NFA_DM_DISC_MASK_L_ISO15693 0x01000000
 #define NFA_DM_DISC_MASK_L_B_PRIME 0x02000000
+#define NFA_DM_DISC_MASK_LACM_NFC_DEP 0x04000000
 #define NFA_DM_DISC_MASK_LAA_NFC_DEP 0x04000000
 #define NFA_DM_DISC_MASK_LFA_NFC_DEP 0x08000000
 #define NFA_DM_DISC_MASK_L_LEGACY 0x10000000
@@ -393,8 +403,6 @@ enum {
   NFA_DM_DISC_LRT_NFC_BP
 };
 
-/* SLP_REQ (HLTA) command */
-#define SLP_REQ_CMD 0x5000
 /* NFA_EE_MAX_TECH_ROUTE. only A, B, F, Bprime are supported by UICC now */
 #define NFA_DM_MAX_TECH_ROUTE 4
 
@@ -439,8 +447,6 @@ typedef struct {
 /* Default handler entry in ndef_handler table      */
 #define NFA_NDEF_DEFAULT_HANDLER_IDX 0
 
-#define NFA_PARAM_ID_INVALID 0xFF
-
 /* Maximum number of pending SetConfigs */
 #define NFA_DM_SETCONFIG_PENDING_MAX 32
 
@@ -508,7 +514,8 @@ typedef struct {
   uint8_t lf_t3t_flags2[NCI_PARAM_LEN_LF_T3T_FLAGS2];
   uint8_t lf_t3t_flags2_len;
   uint8_t lf_t3t_pmm[NCI_PARAM_LEN_LF_T3T_PMM];
-  uint8_t lf_t3t_id[NFA_CE_LISTEN_INFO_MAX][NCI_PARAM_LEN_LF_T3T_ID(NCI_VERSION_2_0)];
+  uint8_t lf_t3t_id[NFA_CE_LISTEN_INFO_MAX]
+                   [NCI_PARAM_LEN_LF_T3T_ID(NCI_VERSION_2_0)];
 
   uint8_t fwi[NCI_PARAM_LEN_FWI];
   uint8_t wt[NCI_PARAM_LEN_WT];
@@ -576,8 +583,12 @@ typedef struct {
 
   /* NFCC power mode */
   uint8_t nfcc_pwr_mode; /* NFA_DM_PWR_MODE_FULL or NFA_DM_PWR_MODE_OFF_SLEEP */
-#if (NXP_EXTNS == TRUE)
+
+  uint8_t deactivate_cmd_retry_count; /*number of times the deactivation cmd
+                                         sent in case of error scenerio */
+
   uint32_t eDtaMode;        /* For enable the DTA type modes. */
+#if (NXP_EXTNS == TRUE)
   uint8_t selected_uicc_id; /* Current selected UICC ID */
 #endif
   uint8_t power_state;    /* current screen/power  state */
@@ -590,6 +601,9 @@ void nfa_dm_ndef_dereg_all(void);
 void nfa_dm_act_conn_cback_notify(uint8_t event, tNFA_CONN_EVT_DATA* p_data);
 void nfa_dm_notify_activation_status(tNFA_STATUS status,
                                      tNFA_TAG_PARAMS* p_params);
+
+bool nfa_dm_act_send_raw_vs(tNFA_DM_MSG* p_data);
+
 void nfa_dm_disable_complete(void);
 
 /* Internal functions from nfa_rw */
@@ -611,11 +625,10 @@ extern uint8_t nfa_ee_max_ee_cfg;
 extern tNCI_DISCOVER_MAPS* p_nfa_dm_interface_mapping;
 extern uint8_t nfa_dm_num_dm_interface_mapping;
 extern bool nfa_poll_bail_out_mode;
-#if (NXP_EXTNS == TRUE)
+
 void nfa_dm_poll_disc_cback_dta_wrapper(tNFA_DM_RF_DISC_EVT event,
                                         tNFC_DISCOVER* p_data);
 extern unsigned char appl_dta_mode_flag;
-#endif
 
 /* NFA device manager control block */
 extern tNFA_DM_CB nfa_dm_cb;
@@ -629,7 +642,6 @@ void nfa_snep_init(bool is_dta_mode);
 #define nfa_snep_init(is_dta_mode)
 #endif
 
-void nfa_dta_init(void);
 #if (NFC_NFCEE_INCLUDED == true)
 void nfa_ee_init(void);
 void nfa_hci_init(void);
@@ -651,6 +663,7 @@ bool nfa_dm_act_enable_listening(tNFA_DM_MSG* p_data);
 bool nfa_dm_act_disable_listening(tNFA_DM_MSG* p_data);
 #if (NXP_EXTNS == TRUE)
 bool nfa_dm_act_disable_passive_listening(tNFA_DM_MSG* p_data);
+bool nfa_dm_set_transit_config(tNFA_DM_MSG* p_data);
 #endif
 bool nfa_dm_act_pause_p2p(tNFA_DM_MSG* p_data);
 bool nfa_dm_act_resume_p2p(tNFA_DM_MSG* p_data);
@@ -665,17 +678,16 @@ bool nfa_dm_act_deactivate(tNFA_DM_MSG* p_data);
 bool nfa_dm_act_power_off_sleep(tNFA_DM_MSG* p_data);
 bool nfa_dm_ndef_reg_hdlr(tNFA_DM_MSG* p_data);
 bool nfa_dm_ndef_dereg_hdlr(tNFA_DM_MSG* p_data);
-bool nfa_dm_tout(tNFA_DM_MSG* p_data);
+
 bool nfa_dm_act_reg_vsc(tNFA_DM_MSG* p_data);
 bool nfa_dm_act_send_vsc(tNFA_DM_MSG* p_data);
 #if (NXP_EXTNS == TRUE)
 void nfa_dm_p2p_prio_logic_disable();
-bool nfa_dm_act_send_nxp(tNFA_DM_MSG* p_data);
 uint16_t nfa_dm_act_get_rf_disc_duration();
 #endif
 bool nfa_dm_act_disable_timeout(tNFA_DM_MSG* p_data);
-bool nfa_dm_act_nfc_cback_data(tNFA_DM_MSG* p_data);
-bool nfa_dm_set_power_sub_state (tNFA_DM_MSG *p_data);
+bool nfa_dm_set_power_sub_state(tNFA_DM_MSG* p_data);
+
 void nfa_dm_proc_nfcc_power_mode(uint8_t nfcc_power_mode);
 
 /* Main function prototypes */
@@ -719,9 +731,7 @@ void nfa_dm_deact_ntf_timeout();
   memset(ha, NFC_DH_ID, NFA_DM_MAX_TECH_ROUTE);
 #endif
 
-#if (BT_TRACE_VERBOSE == true)
-char* nfa_dm_nfc_revt_2_str(tNFC_RESPONSE_EVT event);
-#endif
+std::string nfa_dm_nfc_revt_2_str(tNFC_RESPONSE_EVT event);
 
 #if (NXP_EXTNS == TRUE)
 tNFC_STATUS nfc_ncif_reset_nfcc();
diff --git a/src/nfa/int/nfa_dta_int.h b/src/nfa/include/nfa_dta_int.h
similarity index 72%
rename from src/nfa/int/nfa_dta_int.h
rename to src/nfa/include/nfa_dta_int.h
index 2be5f96..17845ee 100644
--- a/src/nfa/int/nfa_dta_int.h
+++ b/src/nfa/include/nfa_dta_int.h
@@ -55,29 +55,9 @@
 /*****************************************************************************
 **  DTA definitions
 *****************************************************************************/
-#define NFA_DTA_PATTERN_NUMBER_INVALID 0xFFFF
-
-#define NFA_DTA_PATTERN_NUMBER_LLCP_CONNECT_BY_SAP 0x1200
-#define NFA_DTA_PATTERN_NUMBER_LLCP_CONNECT_BY_SN 0x1240
-#define NFA_DTA_PATTERN_NUMBER_LLCP_CONNECT_BY_SNL 0x1280
-
-#define NFA_DTA_PATTERN_NUMBER_SNEP_SERVER_ONLY 0x1300
-#define NFA_DTA_PATTERN_NUMBER_SNEP_DEFAULT_PUT_SHORT_NDEF 0x1301
-#define NFA_DTA_PATTERN_NUMBER_SNEP_DEFAULT_PUT_LONG_NDEF 0x1302
-#define NFA_DTA_PATTERN_NUMBER_SNEP_EXTENDED_GET 0x1303
 
 #define NFA_DTA_DISCOVER_PARAMS_MAX 6
 
-/* Header length for long NDEF text message */
-#define NDEF_WKT_TEXT_HDR_LEN 7
-/* Size of NDEF message for T3T write-tests ([DTA] $5.5.6) */
-#define NFA_DTA_T3T_WRITE_NDEF_SIZE 192
-/* System code to use for T3T Listen mode tests */
-#define NFA_DTA_T3T_LISTEN_SYSTEMCODE 0xBABE
-
-/* Maximum protocol preference rank */
-#define NFA_PROTOCOL_RANK_INVALID 0xFF
-
 #define NFA_DTA_SCRATCH_BUF_SIZE T3T_MSG_BLOCKSIZE
 
 #ifndef NFA_DTA_DEFAULT_CO_OUT_DSAP
@@ -205,9 +185,6 @@ enum {
 };
 typedef uint8_t tNFA_DTA_STATE;
 
-/* DTA Substates (while in ACTIVATED state) - substate enumerations are found in
- * protocol-specific files (nfa_dta_XXX.c) */
-#define NFA_DTA_SST_IDLE 0
 typedef uint8_t tNFA_DTA_SUBSTATE;
 
 /* DTA discovery states */
@@ -250,17 +227,6 @@ enum {
 /* DTA test step command */
 typedef tNFC_STATUS (*tNFA_DTA_CMD_FCN)(void*);
 
-/* dta control block flags */
-#define NFA_DTA_FL_ENABLED 0x00000001 /* DTA is enabled */
-/* Automatically start discovery when NFC is enabled */
-#define NFA_DTA_FL_AUTOSTART 0x00000002
-/* DTA is stopping (NFA_DtaStop called) */
-#define NFA_DTA_FL_STOPPING 0x00000004
-/* DTA is being disabled (NFA_DtaDisable called) */
-#define NFA_DTA_FL_DISABLING 0x00000008
-/* T4T/NFCDEP is deactivating to IDLE (need to DESELECT first) */
-#define NFA_DTA_FL_T4T_DESELECT_DEACT 0x00000010
-
 /* DTA control block */
 typedef struct {
   uint32_t dta_flags; /* dta_flags must be first item in structure (statically
@@ -322,11 +288,6 @@ typedef struct {
   uint16_t llcp_co_out_remote_miu; /* MIU of LT-CO-OUT-DEST */
   uint8_t llcp_co_out_remote_rw;   /* RW of LT-CO-OUT-DEST  */
 
-/* establishing outbound on connection-oriented */
-#define NFA_DTA_LLCP_FLAGS_CO_OUT_CONNECTING 0x01
-/* established outbound on connection-oriented  */
-#define NFA_DTA_LLCP_FLAGS_CO_OUT_CONNECTED 0x02
-
   uint8_t llcp_flags;      /* internal flags for LLCP echo test */
   uint8_t llcp_sdp_tid_cl; /* SDP transaction ID for outbound connectionless */
   uint8_t
@@ -382,79 +343,10 @@ extern uint8_t nfa_dta_start_up_cfg_len;
 /*****************************************************************************
 * DTA internal funciton protoytpes
 *****************************************************************************/
-/* Internal function prototypes */
-void nfa_dta_deactivate(uint8_t deactivate_type);
-void nfa_dta_shutdown(void);
-void nfa_dta_discover_start(void);
-
-/* nfa_sys handler for DTA */
-bool nfa_dta_evt_hdlr(NFC_HDR* p_msg);
-void nfa_dta_sys_disable(void);
-
-/* State machine action functions */
-bool nfa_dta_enable(tNFA_DTA_MSG* p_data);
-bool nfa_dta_disable(tNFA_DTA_MSG* p_data);
-bool nfa_dta_config(tNFA_DTA_MSG* p_data);
-bool nfa_dta_start(tNFA_DTA_MSG* p_data);
-bool nfa_dta_handle_deact(tNFA_DTA_MSG* p_data);
-bool nfa_dta_stop(tNFA_DTA_MSG* p_data);
-bool nfa_dta_run_test(tNFA_DTA_MSG* p_data);
-bool nfa_dta_proc_data(tNFA_DTA_MSG* p_msg_data);
-
-/* Utility functions */
-void nfa_dta_test_set_state(tNFA_DTA_STATE state);
-void nfa_dta_test_set_substate(tNFA_DTA_SUBSTATE substate);
-void nfa_dta_free_ndef_buf(uint8_t ndef_idx);
-uint8_t* nfa_dta_realloc_buf(uint8_t ndef_idx, uint32_t size);
-void nfa_dta_t3t_nfcid_rand(uint8_t nfcid2[NCI_RF_F_UID_LEN]);
-
-/* Test function entry points (in nfa_dta_XXX.c) */
-void nfa_dta_nfcdep_poll_test_start(void);
-void nfa_dta_nfcdep_proc_data(tNFC_CONN_EVT event, tNFC_CONN* p_data);
-void nfa_dta_t1t_poll_test_start(void);
-void nfa_dta_t2t_poll_test_start(void);
-void nfa_dta_t3t_poll_test_start(void);
-void nfa_dta_t4t_poll_test_start(void);
-
-void nfa_dta_nfcdep_listen_test_start(void);
-void nfa_dta_t3t_listen_test_start(void);
-void nfa_dta_t4t_listen_test_start(void);
-
-void nfa_dta_t1t_rw_cback(uint8_t event, tRW_DATA* p_data);
-void nfa_dta_t2t_rw_cback(uint8_t event, tRW_DATA* p_data);
-void nfa_dta_t3t_rw_cback(uint8_t event, tRW_DATA* p_data);
-void nfa_dta_t4t_rw_cback(uint8_t event, tRW_DATA* p_data);
-
-void nfa_dta_t3t_ce_cback(uint8_t event, tCE_DATA* p_data);
-void nfa_dta_t4t_ce_cback(uint8_t event, tCE_DATA* p_data);
-
-void nfa_dta_ce_cback(uint8_t event, tCE_DATA* p_ce_data);
-
-void nfa_dta_t4t_register_apps(void);
-void nfa_dta_t4t_deregister_apps(void);
-
-void nfa_dta_llcp_init(void);
-void nfa_dta_llcp_set_gen_bytes(void);
-void nfa_dta_llcp_clear_gen_bytes(void);
-void nfa_dta_llcp_register_pattern_number_service(void);
-void nfa_dta_llcp_deregister_pattern_number_service(void);
-void nfa_dta_llcp_register_echo(void);
-void nfa_dta_llcp_deregister_echo(void);
-void nfa_dta_llcp_activate_link(void);
-void nfa_dta_llcp_connect_co_echo_out(void);
-void nfa_dta_llcp_disconnect_co_echo_out(void);
-
-void nfa_dta_snep_init(void);
-void nfa_dta_snep_register(void);
-void nfa_dta_snep_deregister(void);
 #if (NXP_EXTNS == TRUE)
 void nfa_dta_snep_mode(tNFA_DTA_SNEP_MODE mode);
 #endif
 
-void nfa_dta_emvco_pcd_config_nfcc(bool enable);
-void nfa_dta_emvco_pcd_start(void);
-void nfa_dta_emvco_pcd_cback(uint8_t event, tRW_DATA* p_data);
-
 extern uint8_t* p_nfa_dta_brcm_start_up_cfg;
 extern uint8_t nfa_dta_brcm_start_up_cfg_len;
 extern uint8_t* p_nfa_dta_start_up_vsc_cfg;
diff --git a/src/nfa/include/nfa_ee_api.h b/src/nfa/include/nfa_ee_api.h
old mode 100644
new mode 100755
index 787c15f..fa731f6
--- a/src/nfa/include/nfa_ee_api.h
+++ b/src/nfa/include/nfa_ee_api.h
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -70,9 +70,13 @@ enum {
   NFA_EE_DEREGISTER_EVT, /* The status for NFA_EeDeregister () */
   NFA_EE_MODE_SET_EVT, /* The status for activating or deactivating an NFCEE */
   NFA_EE_ADD_AID_EVT,  /* The status for adding an AID to a routing table entry
-                          */
-  NFA_EE_REMOVE_AID_EVT, /* The status for removing an AID from a routing table
-                            */
+                        */
+  NFA_EE_REMOVE_AID_EVT,  /* The status for removing an AID from a routing table
+                           */
+  NFA_EE_ADD_SYSCODE_EVT, /* The status for adding an System Code to a routing
+                             table entry */
+  NFA_EE_REMOVE_SYSCODE_EVT, /* The status for removing an System Code from
+                              routing table */
   NFA_EE_REMAINING_SIZE_EVT, /* The remaining size of the Listen Mode Routing
                                 Table   */
   NFA_EE_SET_TECH_CFG_EVT,   /* The status for setting the routing based on RF
@@ -86,10 +90,10 @@ enum {
   NFA_EE_NEW_EE_EVT, /* A new NFCEE is discovered                             */
   NFA_EE_ACTION_EVT, /* An action happened in NFCEE                           */
   NFA_EE_DISCOVER_REQ_EVT, /* NFCEE Discover Request Notification */
-  NFA_EE_ROUT_ERR_EVT,     /* Error - exceed NFCC CE Routing size */
   NFA_EE_NO_MEM_ERR_EVT,   /* Error - out of GKI buffers */
   NFA_EE_NO_CB_ERR_EVT, /* Error - Can not find control block or wrong state */
 #if (NXP_EXTNS == TRUE)
+  NFA_EE_ROUT_ERR_EVT,     /* Error - exceed NFCC CE Routing size */
   NFA_EE_SET_MODE_INFO_EVT,
   NFA_EE_PWR_LINK_CTRL_EVT, /* NFCEE Pwr and link cotnrol command Evt */
 #endif
@@ -99,27 +103,13 @@ enum {
 typedef uint8_t tNFA_EE_EVT;
 
 /* tNFA_NFCEE_INTERFACE values */
-/* APDU Interface       */
-#define NFA_EE_INTERFACE_APDU NFC_NFCEE_INTERFACE_APDU
 /* HCI Access Interface*/
 #define NFA_EE_INTERFACE_HCI_ACCESS NFC_NFCEE_INTERFACE_HCI_ACCESS
-/* T3T Command Interface*/
-#define NFA_EE_INTERFACE_T3T NFC_NFCEE_INTERFACE_T3T
-/* Transparent Interface*/
-#define NFA_EE_INTERFACE_TRANSPARENT NFC_NFCEE_INTERFACE_TRANSPARENT
-/* Proprietary          */
-#define NFA_EE_INTERFACE_PROPRIETARY NFC_NFCEE_INTERFACE_PROPRIETARY
 typedef uint8_t tNFA_EE_INTERFACE;
 
-/* HW/Registration ID   */
-#define NFA_EE_TAG_HW_ID NFC_NFCEE_TAG_HW_ID
-/* ATR Bytes            */
-#define NFA_EE_TAG_ATR_BYTES NFC_NFCEE_TAG_ATR_BYTES
-/* T3T Supplement. Info */
-#define NFA_EE_TAG_T3T_INFO NFC_NFCEE_TAG_T3T_INFO
+#if (NXP_EXTNS == TRUE)
 /* Broadcom Proprietary */
 #define NFA_EE_TAG_HCI_HOST_ID NFC_NFCEE_TAG_HCI_HOST_ID
-#if (NXP_EXTNS == TRUE)
 typedef uint16_t tNFA_EE_TAG;
 #else
 typedef uint8_t tNFA_EE_TAG;
@@ -136,9 +126,7 @@ typedef uint8_t tNFA_EE_MD;
 #define NFA_EE_PWR_STATE_SWITCH_OFF 0x02
 /* The device's battery is removed  */
 #define NFA_EE_PWR_STATE_BATT_OFF 0x04
-/* used to remove a particular technology or protocol based routing cfg of a
- * handle from the routing table. */
-#define NFA_EE_PWR_STATE_NONE 0
+
 typedef uint8_t tNFA_EE_PWR_STATE;
 
 /* NFCEE connected and inactive */
@@ -149,10 +137,6 @@ typedef uint8_t tNFA_EE_PWR_STATE;
 #define NFA_EE_STATUS_REMOVED NFC_NFCEE_STATUS_REMOVED
 /* waiting for response from NFCC */
 #define NFA_EE_STATUS_PENDING 0x10
-#define NFA_EE_STATUS_ACTIVATING \
-  (NFA_EE_STATUS_PENDING + NFC_NFCEE_STATUS_ACTIVE)
-#define NFA_EE_STATUS_DEACTIVATING \
-  (NFA_EE_STATUS_PENDING + NFC_NFCEE_STATUS_INACTIVE)
 typedef uint8_t tNFA_EE_STATUS;
 
 /* list of events for controlling DWP transceive state */
@@ -204,14 +188,6 @@ typedef struct {
       ee_interface; /* NFCEE interface associated with this connection  */
 } tNFA_EE_CONNECT;
 
-/* ISO 7816-4 SELECT command */
-#define NFA_EE_TRGR_SELECT NFC_EE_TRIG_SELECT
-/* RF Protocol changed       */
-#define NFA_EE_TRGR_RF_PROTOCOL NFC_EE_TRIG_RF_PROTOCOL
-/* RF Technology changed     */
-#define NFA_EE_TRGR_RF_TECHNOLOGY NFC_EE_TRIG_RF_TECHNOLOGY
-/* Application initiation    */
-#define NFA_EE_TRGR_APP_INIT NFC_EE_TRIG_APP_INIT
 typedef tNFC_EE_TRIGGER tNFA_EE_TRIGGER;
 
 /* Union of NFCEE action parameter depending on the associated trigger */
@@ -287,6 +263,8 @@ typedef union {
   tNFA_STATUS deregister;
   tNFA_STATUS add_aid;
   tNFA_STATUS remove_aid;
+  tNFA_STATUS add_sc;
+  tNFA_STATUS remove_sc;
   tNFA_STATUS set_tech;
   tNFA_STATUS set_proto;
   uint16_t size;
@@ -307,9 +285,6 @@ typedef void(tNFA_EE_CBACK)(tNFA_EE_EVT event, tNFA_EE_CBACK_DATA* p_data);
 /*****************************************************************************
 **  External Function Declarations
 *****************************************************************************/
-#ifdef __cplusplus
-extern "C" {
-#endif
 
 /*******************************************************************************
 **
@@ -440,15 +415,10 @@ extern tNFA_STATUS NFA_EeModeSet(tNFA_HANDLE ee_handle, tNFA_EE_MD mode);
 extern tNFA_STATUS NFA_EeSetDefaultTechRouting(
     tNFA_HANDLE ee_handle, tNFA_TECHNOLOGY_MASK technologies_switch_on,
     tNFA_TECHNOLOGY_MASK technologies_switch_off,
-    tNFA_TECHNOLOGY_MASK technologies_battery_off
-#if (NXP_EXTNS == TRUE)
-    ,
+    tNFA_TECHNOLOGY_MASK technologies_battery_off,
     tNFA_TECHNOLOGY_MASK technologies_screen_lock,
     tNFA_TECHNOLOGY_MASK technologies_screen_off,
-    tNFA_TECHNOLOGY_MASK technologies_screen_off_lock
-#endif
-
-    );
+    tNFA_TECHNOLOGY_MASK technologies_screen_off_lock);
 
 /*******************************************************************************
 **
@@ -474,14 +444,10 @@ extern tNFA_STATUS NFA_EeSetDefaultTechRouting(
 extern tNFA_STATUS NFA_EeSetDefaultProtoRouting(
     tNFA_HANDLE ee_handle, tNFA_PROTOCOL_MASK protocols_switch_on,
     tNFA_PROTOCOL_MASK protocols_switch_off,
-    tNFA_PROTOCOL_MASK protocols_battery_off
-#if (NXP_EXTNS == TRUE)
-    ,
+    tNFA_PROTOCOL_MASK protocols_battery_off,
     tNFA_PROTOCOL_MASK protocols_screen_lock,
     tNFA_PROTOCOL_MASK protocols_screen_off,
-    tNFA_PROTOCOL_MASK protocols_screen_off_lock
-#endif
-    );
+    tNFA_PROTOCOL_MASK protocols_screen_off_lock);
 
 /*******************************************************************************
 **
@@ -505,12 +471,8 @@ extern tNFA_STATUS NFA_EeSetDefaultProtoRouting(
 *******************************************************************************/
 extern tNFA_STATUS NFA_EeAddAidRouting(tNFA_HANDLE ee_handle, uint8_t aid_len,
                                        uint8_t* p_aid,
-                                       tNFA_EE_PWR_STATE power_state
-#if (NXP_EXTNS == TRUE)
-                                       ,
-                                       uint8_t vs_info
-#endif
-                                       );
+                                       tNFA_EE_PWR_STATE power_state,
+                                       uint8_t aidInfo);
 
 /*******************************************************************************
 **
@@ -581,6 +543,54 @@ extern tNFA_STATUS NFA_EeAddApduPatternRouting(uint8_t apdu_data_len,uint8_t* ap
 *******************************************************************************/
 extern tNFA_STATUS NFA_EeRemoveApduPatternRouting(uint8_t apdu_len, uint8_t* p_apdu);
 
+/*******************************************************************************
+ **
+ ** Function         NFA_EeAddSystemCodeRouting
+ **
+ ** Description      This function is called to add an system code entry in the
+ **                  listen mode routing table in NFCC. The status of this
+ **                  operation is reported as the NFA_EE_ADD_SYSCODE_EVT.
+ **
+ ** Note:            If RF discovery is started,
+ **                  NFA_StopRfDiscovery()/NFA_RF_DISCOVERY_STOPPED_EVT should
+ **                  happen before calling this function
+ **
+ ** Note:            NFA_EeUpdateNow() should be called after last NFA-EE
+ **                  function to change the listen mode routing is called.
+ **
+ ** Returns          NFA_STATUS_OK if successfully initiated
+ **                  NFA_STATUS_FAILED otherwise
+ **                  NFA_STATUS_INVALID_PARAM If bad parameter
+ **
+ *******************************************************************************/
+extern tNFA_STATUS NFA_EeAddSystemCodeRouting(uint16_t systemcode,
+                                              tNFA_HANDLE ee_handle,
+                                              tNFA_EE_PWR_STATE power_state);
+
+/*******************************************************************************
+**
+** Function         NFA_EeRemoveSystemCodeRouting
+**
+** Description      This function is called to remove the given System Code
+*based entry from
+**                  the listen mode routing table. The status of this operation
+*is reported
+**                  as the NFA_EE_REMOVE_SYSCODE_EVT.
+**
+** Note:            If RF discovery is started,
+**                  NFA_StopRfDiscovery()/NFA_RF_DISCOVERY_STOPPED_EVT should
+**                  happen before calling this function
+**
+** Note:            NFA_EeUpdateNow() should be called after last NFA-EE
+**                  function to change the listen mode routing is called.
+**
+** Returns          NFA_STATUS_OK if successfully initiated
+**                  NFA_STATUS_FAILED otherwise
+**                  NFA_STATUS_INVALID_PARAM If bad parameter
+**
+*******************************************************************************/
+extern tNFA_STATUS NFA_EeRemoveSystemCodeRouting(uint16_t systemcode);
+
 /*******************************************************************************
 **
 ** Function         NFA_EeGetLmrtRemainingSize
@@ -734,8 +744,5 @@ extern void NFA_setProvisionMode(bool provisionMode);
 
 #endif
 
-#ifdef __cplusplus
-}
-#endif
 
 #endif /* NFA_EE_API_H */
diff --git a/src/nfa/int/nfa_ee_int.h b/src/nfa/include/nfa_ee_int.h
old mode 100644
new mode 100755
similarity index 93%
rename from src/nfa/int/nfa_ee_int.h
rename to src/nfa/include/nfa_ee_int.h
index 967a75f..693f580
--- a/src/nfa/int/nfa_ee_int.h
+++ b/src/nfa/include/nfa_ee_int.h
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -49,7 +49,6 @@
 /*****************************************************************************
 **  Constants and data types
 *****************************************************************************/
-#define NFA_EE_DEBUG BT_TRACE_VERBOSE
 /* the number of tNFA_EE_ECBs (for NFCEEs and DH) */
 #define NFA_EE_NUM_ECBS (NFA_EE_MAX_EE_SUPPORTED + 1)
 /* The index for DH in nfa_ee_cb.ee_cb[] */
@@ -74,6 +73,8 @@ enum {
   NFA_EE_API_SET_PROTO_CFG_EVT,
   NFA_EE_API_ADD_AID_EVT,
   NFA_EE_API_REMOVE_AID_EVT,
+  NFA_EE_API_ADD_SYSCODE_EVT,
+  NFA_EE_API_REMOVE_SYSCODE_EVT,
   NFA_EE_API_LMRT_SIZE_EVT,
   NFA_EE_API_UPDATE_NOW_EVT,
   NFA_EE_API_CONNECT_EVT,
@@ -125,8 +126,7 @@ enum {
   NFA_EE_CONN_ST_NONE, /* not connected */
   NFA_EE_CONN_ST_WAIT, /* connection is initiated; waiting for ack */
   NFA_EE_CONN_ST_CONN, /* connected; can send/receive data */
-  NFA_EE_CONN_ST_DISC, /* disconnecting; waiting for ack */
-  NFA_EE_CONN_ST_MAX
+  NFA_EE_CONN_ST_DISC /* disconnecting; waiting for ack */
 };
 typedef uint8_t tNFA_EE_CONN_ST;
 #if (NXP_EXTNS == TRUE)
@@ -187,6 +187,12 @@ typedef uint8_t tNFA_EE_CONN_ST;
 #endif
 #define NFA_EE_TOTAL_APDU_PATTERN_SIZE 250
 #define NFA_EE_APDU_ROUTE_MASK 8 /* APDU route location mask*/
+#define NFA_EE_SYSTEM_CODE_LEN 02
+#define NFA_EE_SYSTEM_CODE_TLV_SIZE 06
+#define NFA_EE_MAX_SYSTEM_CODE_ENTRIES 10
+#define NFA_EE_MAX_SYSTEM_CODE_CFG_LEN \
+  (NFA_EE_MAX_SYSTEM_CODE_ENTRIES * NFA_EE_SYSTEM_CODE_TLV_SIZE)
+
 /* NFA EE control block flags:
  * use to indicate an API function has changed the configuration of the
  * associated NFCEE
@@ -197,6 +203,8 @@ typedef uint8_t tNFA_EE_CONN_ST;
 #define NFA_EE_ECB_FLAGS_PROTO 0x04
 /* AID routing changed                */
 #define NFA_EE_ECB_FLAGS_AID 0x08
+/* System Code routing changed        */
+#define NFA_EE_ECB_FLAGS_SYSCODE 0xE0
 /* VS changed                         */
 #define NFA_EE_ECB_FLAGS_VS 0x10
 /* Restore related                    */
@@ -226,26 +234,24 @@ typedef struct {
       tech_switch_off; /* default routing - technologies switch_off */
   tNFA_TECHNOLOGY_MASK
       tech_battery_off; /* default routing - technologies battery_off*/
+  tNFA_TECHNOLOGY_MASK
+      tech_screen_lock; /* default routing - technologies screen_lock*/
+  tNFA_TECHNOLOGY_MASK
+      tech_screen_off; /* default routing - technologies screen_off*/
+  tNFA_TECHNOLOGY_MASK
+      tech_screen_off_lock; /* default routing - technologies screen_off*/
   tNFA_PROTOCOL_MASK
       proto_switch_on; /* default routing - protocols switch_on     */
   tNFA_PROTOCOL_MASK
       proto_switch_off; /* default routing - protocols switch_off    */
   tNFA_PROTOCOL_MASK
       proto_battery_off; /* default routing - protocols battery_off   */
-#if (NXP_EXTNS == TRUE)
   tNFA_PROTOCOL_MASK
       proto_screen_lock; /* default routing - protocols screen_lock    */
   tNFA_PROTOCOL_MASK
       proto_screen_off; /* default routing - protocols screen_off  */
   tNFA_PROTOCOL_MASK
       proto_screen_off_lock; /* default routing - protocols screen_off  */
-  tNFA_TECHNOLOGY_MASK
-      tech_screen_lock; /* default routing - technologies screen_lock*/
-  tNFA_TECHNOLOGY_MASK
-      tech_screen_off; /* default routing - technologies screen_off*/
-  tNFA_TECHNOLOGY_MASK
-      tech_screen_off_lock; /* default routing - technologies screen_off*/
-#endif
   tNFA_EE_CONN_ST conn_st;   /* connection status */
   uint8_t conn_id;           /* connection id */
   tNFA_EE_CBACK* p_ee_cback; /* the callback function */
@@ -292,6 +298,14 @@ typedef struct {
   uint8_t aid_info[NFA_EE_MAX_AID_ENTRIES]; /* route/vs info for this AID
                                                   entry */
 #endif
+  /*System Code Based Routing Variables*/
+  uint8_t sys_code_cfg[NFA_EE_MAX_SYSTEM_CODE_ENTRIES * NFA_EE_SYSTEM_CODE_LEN];
+  uint8_t sys_code_pwr_cfg[NFA_EE_MAX_SYSTEM_CODE_ENTRIES];
+  uint8_t sys_code_rt_loc[NFA_EE_MAX_SYSTEM_CODE_ENTRIES];
+  uint8_t sys_code_rt_loc_vs_info[NFA_EE_MAX_SYSTEM_CODE_ENTRIES];
+  /* The number of SC entries in sys_code_cfg buffer*/
+  uint8_t sys_code_cfg_entries;
+  uint16_t size_sys_code; /* The size for system code routing */
   uint8_t aid_entries;
   uint8_t nfcee_id;      /* ID for this NFCEE */
   uint8_t ee_status;     /* The NFCEE status */
@@ -358,11 +372,9 @@ typedef struct {
   tNFA_TECHNOLOGY_MASK technologies_switch_on;
   tNFA_TECHNOLOGY_MASK technologies_switch_off;
   tNFA_TECHNOLOGY_MASK technologies_battery_off;
-#if (NXP_EXTNS == TRUE)
   tNFA_TECHNOLOGY_MASK technologies_screen_lock;
   tNFA_TECHNOLOGY_MASK technologies_screen_off;
   tNFA_TECHNOLOGY_MASK technologies_screen_off_lock;
-#endif
 } tNFA_EE_API_SET_TECH_CFG;
 
 /* data type for NFA_EE_API_SET_PROTO_CFG_EVT */
@@ -373,12 +385,9 @@ typedef struct {
   tNFA_PROTOCOL_MASK protocols_switch_on;
   tNFA_PROTOCOL_MASK protocols_switch_off;
   tNFA_PROTOCOL_MASK protocols_battery_off;
-#if (NXP_EXTNS == TRUE)
   tNFA_PROTOCOL_MASK protocols_screen_lock;
   tNFA_PROTOCOL_MASK protocols_screen_off;
   tNFA_PROTOCOL_MASK protocols_screen_off_lock;
-#endif
-
 } tNFA_EE_API_SET_PROTO_CFG;
 
 /* data type for NFA_EE_API_ADD_AID_EVT */
@@ -389,9 +398,7 @@ typedef struct {
   uint8_t aid_len;
   uint8_t* p_aid;
   tNFA_EE_PWR_STATE power_state;
-#if (NXP_EXTNS == TRUE)
-  uint8_t aid_info;
-#endif
+  uint8_t aidInfo;
 } tNFA_EE_API_ADD_AID;
 
 /* data type for NFA_EE_API_REMOVE_AID_EVT */
@@ -420,6 +427,21 @@ typedef struct {
   uint8_t* p_apdu;
 } tNFA_EE_API_REMOVE_APDU;
 
+/* data type for NFA_EE_API_ADD_SYSCODE_EVT */
+typedef struct {
+  NFC_HDR hdr;
+  tNFA_EE_ECB* p_cb;
+  uint8_t nfcee_id;
+  uint16_t syscode;
+  tNFA_EE_PWR_STATE power_state;
+} tNFA_EE_API_ADD_SYSCODE;
+
+/* data type for NFA_EE_API_REMOVE_SYSCODE_EVT */
+typedef struct {
+  NFC_HDR hdr;
+  uint16_t syscode;
+} tNFA_EE_API_REMOVE_SYSCODE;
+
 /* data type for NFA_EE_API_LMRT_SIZE_EVT */
 typedef NFC_HDR tNFA_EE_API_LMRT_SIZE;
 
@@ -448,11 +470,6 @@ typedef struct {
   uint8_t nfcee_id;
 } tNFA_EE_API_DISCONNECT;
 
-typedef struct {
-  NFC_HDR hdr;
-  tNFC_STATUS status; /* The event status. */
-} tNFA_EE_MSG_STATUS;
-
 /* common data type for internal events with nfa_ee_use_cfg_cb[] as true */
 typedef struct {
   NFC_HDR hdr;
@@ -460,12 +477,6 @@ typedef struct {
   uint8_t nfcee_id;
 } tNFA_EE_CFG_HDR;
 
-/* data type for tNFC_RESPONSE_EVT */
-typedef struct {
-  NFC_HDR hdr;
-  void* p_data;
-} tNFA_EE_NCI_RESPONSE;
-
 /* data type for NFA_EE_NCI_DISC_RSP_EVT */
 typedef struct {
   NFC_HDR hdr;
@@ -542,6 +553,8 @@ typedef union {
   tNFA_EE_API_SET_PROTO_CFG set_proto;
   tNFA_EE_API_ADD_AID add_aid;
   tNFA_EE_API_REMOVE_AID rm_aid;
+  tNFA_EE_API_ADD_SYSCODE add_syscode;
+  tNFA_EE_API_REMOVE_SYSCODE rm_syscode;
   tNFA_EE_API_ADD_APDU add_apdu;
   tNFA_EE_API_REMOVE_APDU rm_apdu;
   tNFA_EE_API_LMRT_SIZE lmrt_size;
@@ -575,7 +588,6 @@ typedef void (*tNFA_EE_SM_ACT)(tNFA_EE_MSG* p_data);
 
 /* the following status are the definition used in ee_cfg_sts */
 #define NFA_EE_STS_CHANGED_ROUTING 0x01
-#define NFA_EE_STS_CHANGED_VS 0x02
 #define NFA_EE_STS_CHANGED 0x0f
 #define NFA_EE_STS_PREV_ROUTING 0x10
 #define NFA_EE_STS_PREV 0xf0
@@ -654,11 +666,11 @@ typedef struct {
 } tNFA_EE_CB;
 
 /* Order of Routing entries in Routing Table */
-#define NCI_ROUTE_ORDER_AID  0x01/* AID routing order */
-#define NCI_ROUTE_ORDER_PATTERN 0x02 /* Pattern routing order*/
-#define NCI_ROUTE_ORDER_SYS_CODE 0x03/* System Code routing order*/
-#define NCI_ROUTE_ORDER_PROTOCOL 0x04/* Protocol routing order*/
-#define NCI_ROUTE_ORDER_TECHNOLOGY 0x05/* Technology routing order*/
+#define NCI_ROUTE_ORDER_AID 0x01        /* AID routing order */
+#define NCI_ROUTE_ORDER_PATTERN 0x02    /* Pattern routing order*/
+#define NCI_ROUTE_ORDER_SYS_CODE 0x03   /* System Code routing order*/
+#define NCI_ROUTE_ORDER_PROTOCOL 0x04   /* Protocol routing order*/
+#define NCI_ROUTE_ORDER_TECHNOLOGY 0x05 /* Technology routing order*/
 
 /*****************************************************************************
 **  External variables
@@ -710,6 +722,8 @@ void nfa_ee_api_set_tech_cfg(tNFA_EE_MSG* p_data);
 void nfa_ee_api_set_proto_cfg(tNFA_EE_MSG* p_data);
 void nfa_ee_api_add_aid(tNFA_EE_MSG* p_data);
 void nfa_ee_api_remove_aid(tNFA_EE_MSG* p_data);
+void nfa_ee_api_add_sys_code(tNFA_EE_MSG* p_data);
+void nfa_ee_api_remove_sys_code(tNFA_EE_MSG* p_data);
 void nfa_ee_api_lmrt_size(tNFA_EE_MSG* p_data);
 void nfa_ee_api_update_now(tNFA_EE_MSG* p_data);
 void nfa_ee_api_connect(tNFA_EE_MSG* p_data);
@@ -741,7 +755,8 @@ void nfa_ee_report_event(tNFA_EE_CBACK* p_cback, tNFA_EE_EVT event,
                          tNFA_EE_CBACK_DATA* p_data);
 tNFA_EE_ECB* nfa_ee_find_aid_offset(uint8_t aid_len, uint8_t* p_aid,
                                     int* p_offset, int* p_entry);
-void nfa_ee_remove_labels(void);
+tNFA_EE_ECB* nfa_ee_find_sys_code_offset(uint16_t sys_code, int* p_offset,
+                                         int* p_entry);
 int nfa_ee_find_total_aid_len(tNFA_EE_ECB* p_cb, int start_entry);
 void nfa_ee_start_timer(void);
 void nfa_ee_reg_cback_enable_done(tNFA_EE_ENABLE_DONE_CBACK* p_cback);
diff --git a/src/nfa/include/nfa_hci_api.h b/src/nfa/include/nfa_hci_api.h
old mode 100644
new mode 100755
index f909b5b..b55f698
--- a/src/nfa/include/nfa_hci_api.h
+++ b/src/nfa/include/nfa_hci_api.h
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -366,10 +366,6 @@ typedef void(tNFA_HCI_CBACK)(tNFA_HCI_EVT event, tNFA_HCI_EVT_DATA* p_data);
 /*****************************************************************************
 **  External Function Declarations
 *****************************************************************************/
-#ifdef __cplusplus
-extern "C" {
-#endif
-
 /*******************************************************************************
 **
 ** Function         NFA_HciRegister
@@ -561,25 +557,6 @@ extern tNFA_STATUS NFA_HciSetRegistry(tNFA_HANDLE hci_handle, uint8_t pipe,
                                       uint8_t reg_inx, uint8_t data_size,
                                       uint8_t* p_data);
 
-/*******************************************************************************
-**
-** Function         NFA_HciSendCommand
-**
-** Description      This function is called to send a command on a pipe created
-**                  by the application.
-**                  The app will be notified by NFA_HCI_CMD_SENT_EVT if an error
-**                  occurs.
-**                  When the peer host responds,the app is notified with
-**                  NFA_HCI_RSP_RCVD_EVT
-**
-** Returns          NFA_STATUS_OK if successfully initiated
-**                  NFA_STATUS_FAILED otherwise
-**
-*******************************************************************************/
-extern tNFA_STATUS NFA_HciSendCommand(tNFA_HANDLE hci_handle, uint8_t pipe,
-                                      uint8_t cmd_code, uint16_t cmd_size,
-                                      uint8_t* p_data);
-
 /*******************************************************************************
 **
 ** Function         NFA_HciSendResponse
@@ -706,6 +683,16 @@ void NFA_HciDebug(uint8_t action, uint8_t size, uint8_t* p_data);
 #if (NXP_EXTNS == TRUE)
 extern tNFA_STATUS NFA_HciSendHostTypeListCommand(tNFA_HANDLE hci_handle);
 extern tNFA_STATUS NFA_HciConfigureNfceeETSI12();
+/*******************************************************************************
+**
+** Function         NFA_IsPipeStatusNotCorrect
+**
+** Description      Checks and resets pipe status
+**
+** Returns          TRUE/FALSE
+**
+*******************************************************************************/
+extern bool NFA_IsPipeStatusNotCorrect();
 #endif
 #if (NXP_EXTNS == TRUE)
 /*******************************************************************************
@@ -746,8 +733,4 @@ extern void nfa_hci_nfcee_config_rsp_handler(tNFA_HCI_EVT event,
 
 #endif
 
-#ifdef __cplusplus
-}
-#endif
-
 #endif /* NFA_P2P_API_H */
diff --git a/src/nfa/include/nfa_hci_defs.h b/src/nfa/include/nfa_hci_defs.h
old mode 100644
new mode 100755
index c245023..a6a6792
--- a/src/nfa/include/nfa_hci_defs.h
+++ b/src/nfa/include/nfa_hci_defs.h
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -52,7 +52,6 @@
 #endif
 
 #define NFA_HCI_FIRST_HOST_SPECIFIC_GENERIC_GATE 0x10
-#define NFA_HCI_LAST_HOST_SPECIFIC_GENERIC_GATE 0xEF
 #define NFA_HCI_FIRST_PROP_GATE 0xF0
 #define NFA_HCI_LAST_PROP_GATE 0xFF
 
@@ -75,8 +74,6 @@
 
 /* host_table */
 #define NFA_HCI_HOST_CONTROLLER 0x00
-#define NFA_HCI_DH_HOST 0x01
-#define NFA_HCI_UICC_HOST 0x02
 
 /* Type of instruction */
 #define NFA_HCI_COMMAND_TYPE 0x00
@@ -129,6 +126,7 @@
 #define NFA_HCI_EVT_WTX 0x11
 #define NFA_HCI_ABORT 0x12
 #define NFA_EVT_ABORT 0x11 /* ETSI12 */
+#define HCI_INVALID_CMD 0xFF
 #endif
 
 /* NFA HCI Connectivity gate Events */
@@ -138,7 +136,6 @@
 
 /* Host controller Admin gate registry identifiers */
 #define NFA_HCI_SESSION_IDENTITY_INDEX 0x01
-#define NFA_HCI_MAX_PIPE_INDEX 0x02
 #define NFA_HCI_WHITELIST_INDEX 0x03
 #define NFA_HCI_HOST_LIST_INDEX 0x04
 #if (NXP_EXTNS == TRUE)
@@ -147,9 +144,6 @@
 #define NFA_HCI_HOST_TYPE_LIST_INDEX 0x07
 #endif
 
-/* Host controller and DH Link management gate registry identifier */
-#define NFA_HCI_REC_ERROR_INDEX 0x02
-
 /* DH Identity management gate registry identifier */
 #define NFA_HCI_VERSION_SW_INDEX 0x01
 #define NFA_HCI_VERSION_HW_INDEX 0x03
diff --git a/src/nfa/int/nfa_hci_int.h b/src/nfa/include/nfa_hci_int.h
old mode 100644
new mode 100755
similarity index 96%
rename from src/nfa/int/nfa_hci_int.h
rename to src/nfa/include/nfa_hci_int.h
index 66f3cb3..1761e17
--- a/src/nfa/int/nfa_hci_int.h
+++ b/src/nfa/include/nfa_hci_int.h
@@ -1,15 +1,13 @@
 /******************************************************************************
- *  Copyright (c) 2016, The Linux Foundation. All rights reserved.
- *  Not a Contribution.
- *
- *  Copyright (C) 2015 NXP Semiconductors
- *  The original Work has been changed by NXP Semiconductors.
  *
  *  Copyright (C) 2010-2014 Broadcom Corporation
  *
+ *  The original Work has been changed by NXP Semiconductors.
+ *  Copyright (C) 2015-2018 NXP Semiconductors
+ *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at:
+ *  You may obtain a copy of the License at
  *
  *  http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -29,6 +27,7 @@
 #ifndef NFA_HCI_INT_H
 #define NFA_HCI_INT_H
 
+#include <string>
 #include "nfa_hci_api.h"
 #include "nfa_sys.h"
 #include "nfa_ee_api.h"
@@ -39,9 +38,6 @@ extern uint8_t HCI_LOOPBACK_DEBUG;
 #define NFA_HCI_DEBUG_ON 0x01
 #define NFA_HCI_DEBUG_OFF 0x00
 
-#if (NXP_EXTNS == TRUE)
-bool MW_RCVRY_FW_DNLD_ALLOWED;
-#endif
 /*****************************************************************************
 **  Constants and data types
 *****************************************************************************/
@@ -53,8 +49,6 @@ bool MW_RCVRY_FW_DNLD_ALLOWED;
 #define NFA_HCI_LAST_HOST_SPECIFIC_GATE 0xEF
 
 #define NFA_HCI_SESSION_ID_LEN 8 /* HCI Session ID length */
-/* Maximum pipes that can be created on a generic pipe  */
-#define NFA_MAX_PIPES_IN_GENERIC_GATE 0x0F
 
 #if (NXP_EXTNS == TRUE)
 /* HCI Host Type length */
@@ -147,8 +141,6 @@ typedef uint8_t tNFA_HCI_STATE;
 #define NFA_HCI_PIPE_CLOSED 0x00 /* Pipe is closed */
 #define NFA_HCI_PIPE_OPENED 0x01 /* Pipe is opened */
 
-#define NFA_HCI_INVALID_INX 0xFF
-
 typedef uint8_t tNFA_HCI_COMMAND;
 typedef uint8_t tNFA_HCI_RESPONSE;
 
@@ -194,8 +186,6 @@ enum {
 #define NFA_HCI_FIRST_API_EVENT NFA_HCI_API_REGISTER_APP_EVT
 #define NFA_HCI_LAST_API_EVENT NFA_HCI_API_SEND_EVENT_EVT
 
-typedef uint16_t tNFA_HCI_INT_EVT;
-
 /* Internal event structures.
 **
 ** Note, every internal structure starts with a NFC_HDR and an app handle
@@ -455,10 +445,6 @@ typedef struct {
   uint8_t hci_version;     /* HCI Version */
 } tNFA_ID_MGMT_GATE_INFO;
 
-/* Internal flags */
-/* sub system is being disabled */
-#define NFA_HCI_FL_DISABLING 0x01
-#define NFA_HCI_FL_NV_CHANGED 0x02 /* NV Ram changed */
 #if (NXP_EXTNS == TRUE)
 #define NFA_HCI_FL_CONN_PIPE 0x01
 #define NFA_HCI_FL_APDU_PIPE 0x02
@@ -532,6 +518,7 @@ typedef struct {
   bool IsEventAbortSent;
   bool IsLastEvtAbortFailed;
   bool w4_nfcee_enable;
+  bool IsApduPipeStatusNotCorrect;
   tNFA_HCI_EVENT_SENT evt_sent;
   struct {
     tNFA_CONFIG_STATE
@@ -624,7 +611,7 @@ extern void nfa_hci_check_pending_api_requests(void);
 extern void nfa_hci_check_api_requests(void);
 extern void nfa_hci_handle_admin_gate_cmd(uint8_t* p_data);
 extern void nfa_hci_handle_admin_gate_rsp(uint8_t* p_data, uint8_t data_len);
-extern void nfa_hci_handle_admin_gate_evt(uint8_t* p_data);
+extern void nfa_hci_handle_admin_gate_evt();
 extern void nfa_hci_handle_link_mgm_gate_cmd(uint8_t* p_data);
 extern void nfa_hci_handle_dyn_pipe_pkt(uint8_t pipe, uint8_t* p_data,
                                         uint16_t data_len);
@@ -656,8 +643,6 @@ extern tNFA_HCI_DYN_PIPE* nfa_hciu_find_active_pipe_on_gate(uint8_t gate_id);
 extern tNFA_HANDLE nfa_hciu_get_pipe_owner(uint8_t pipe_id);
 extern uint8_t nfa_hciu_count_open_pipes_on_gate(tNFA_HCI_DYN_GATE* p_gate);
 extern uint8_t nfa_hciu_count_pipes_on_gate(tNFA_HCI_DYN_GATE* p_gate);
-extern tNFA_STATUS nfa_hciu_asmbl_dyn_pipe_pkt(uint8_t* p_data,
-                                               uint8_t data_len);
 
 extern tNFA_HCI_RESPONSE nfa_hciu_add_pipe_to_gate(uint8_t pipe,
                                                    uint8_t local_gate,
@@ -694,16 +679,11 @@ extern tNFA_STATUS nfa_hciu_send_msg(uint8_t pipe_id, uint8_t type,
                                      uint8_t instruction, uint16_t pkt_len,
                                      uint8_t* p_pkt);
 
-#if (BT_TRACE_VERBOSE == true)
-extern char* nfa_hciu_type_2_str(uint8_t type);
-extern char* nfa_hciu_instr_2_str(uint8_t type);
-extern char* nfa_hciu_get_event_name(uint16_t event);
-extern char* nfa_hciu_get_response_name(uint8_t rsp_code);
-extern char* nfa_hciu_get_state_name(uint8_t state);
+extern std::string nfa_hciu_instr_2_str(uint8_t type);
+extern std::string nfa_hciu_get_event_name(uint16_t event);
+extern std::string nfa_hciu_get_state_name(uint8_t state);
 extern char* nfa_hciu_get_type_inst_names(uint8_t pipe, uint8_t type,
                                           uint8_t inst, char* p_buff);
-extern char* nfa_hciu_evt_2_str(uint8_t pipe_id, uint8_t evt);
+extern std::string nfa_hciu_evt_2_str(uint8_t pipe_id, uint8_t evt);
 #define VERBOSE_BUFF_SIZE 100
-#endif
-
 #endif /* NFA_HCI_INT_H */
diff --git a/src/nfa/include/nfa_mem_co.h b/src/nfa/include/nfa_mem_co.h
index decc5f3..bb7a05e 100644
--- a/src/nfa/include/nfa_mem_co.h
+++ b/src/nfa/include/nfa_mem_co.h
@@ -33,9 +33,6 @@
 /*****************************************************************************
 **  External Function Declarations
 *****************************************************************************/
-#ifdef __cplusplus
-extern "C" {
-#endif
 
 /*******************************************************************************
 **
@@ -62,8 +59,5 @@ extern void* nfa_mem_co_alloc(uint32_t num_bytes);
 *******************************************************************************/
 extern void nfa_mem_co_free(void* p_buf);
 
-#ifdef __cplusplus
-}
-#endif
 
 #endif /* NFA_MEM_CO_H */
diff --git a/src/nfa/include/nfa_nv_ci.h b/src/nfa/include/nfa_nv_ci.h
index eb519d6..814419e 100644
--- a/src/nfa/include/nfa_nv_ci.h
+++ b/src/nfa/include/nfa_nv_ci.h
@@ -26,31 +26,9 @@
 
 #include "nfa_nv_co.h"
 
-/*****************************************************************************
-**  Constants and data types
-*****************************************************************************/
-
-/* Read Ready Event */
-typedef struct {
-  NFC_HDR hdr;
-  tNFA_NV_CO_STATUS status;
-  int fd;
-  uint16_t num_read;
-} tNFA_NV_CI_READ_EVT;
-
-/* Write Ready Event */
-typedef struct {
-  NFC_HDR hdr;
-  tNFA_NV_CO_STATUS status;
-  int fd;
-} tNFA_NV_CI_WRITE_EVT;
-
 /*****************************************************************************
 **  Function Declarations
 *****************************************************************************/
-#ifdef __cplusplus
-extern "C" {
-#endif
 
 /*******************************************************************************
 **
@@ -95,8 +73,5 @@ extern void nfa_nv_ci_write(tNFA_NV_CO_STATUS status);
 extern void nfa_nv_ci_read(uint16_t num_bytes_read, tNFA_NV_CO_STATUS status,
                            uint8_t block);
 
-#ifdef __cplusplus
-}
-#endif
 
 #endif /* BTA_FS_CI_H */
diff --git a/src/nfa/include/nfa_nv_co.h b/src/nfa/include/nfa_nv_co.h
index e183c3e..0f32e9c 100644
--- a/src/nfa/include/nfa_nv_co.h
+++ b/src/nfa/include/nfa_nv_co.h
@@ -41,22 +41,12 @@
  * status */
 #define NFA_NV_CO_OK 0x00
 #define NFA_NV_CO_FAIL 0x01 /* Used to pass all other errors */
-#define NFA_NV_CO_EACCES 0x02
-#define NFA_NV_CO_ENOTEMPTY 0x03
-#define NFA_NV_CO_EOF 0x04
-#define NFA_NV_CO_EODIR 0x05
-#define NFA_NV_CO_ENOSPACE 0x06 /* Returned in nfa_nv_ci_open if no room */
-#define NFA_NV_CO_EIS_DIR 0x07
-#define NFA_NV_CO_RESUME 0x08 /* used in nfa_nv_ci_open, on resume */
-/* used in nfa_nv_ci_open, on resume (no file to resume) */
-#define NFA_NV_CO_NONE 0x09
 
 typedef uint8_t tNFA_NV_CO_STATUS;
 
 #define DH_NV_BLOCK 0x01
 #define HC_F3_NV_BLOCK 0x02
 #define HC_F4_NV_BLOCK 0x03
-#define HC_DH_NV_BLOCK 0x04
 #define HC_F5_NV_BLOCK 0x05
 
 /*****************************************************************************
diff --git a/src/nfa/include/nfa_p2p_api.h b/src/nfa/include/nfa_p2p_api.h
index b66a072..f2f9079 100644
--- a/src/nfa/include/nfa_p2p_api.h
+++ b/src/nfa/include/nfa_p2p_api.h
@@ -41,12 +41,8 @@
   0x02 /* no service bound in remote      */
 #define NFA_P2P_DISC_REASON_REMOTE_REJECT \
   0x03 /* remote rejected connection      */
-#define NFA_P2P_DISC_REASON_FRAME_ERROR \
-  0x04 /* sending or receiving FRMR PDU   */
 #define NFA_P2P_DISC_REASON_LLCP_DEACTIVATED \
   0x05 /* LLCP link deactivated           */
-#define NFA_P2P_DISC_REASON_NO_RESOURCE \
-  0x06 /* Out of resource in local device */
 #define NFA_P2P_DISC_REASON_NO_INFORMATION \
   0x80 /* Without information             */
 
@@ -80,16 +76,6 @@ typedef uint8_t tNFA_P2P_EVT;
 #define NFA_P2P_ANY_SAP LLCP_INVALID_SAP
 #define NFA_P2P_INVALID_SAP LLCP_INVALID_SAP
 
-/* Recommanded MIU's for connection-oriented */
-#define NFA_P2P_MIU_1 \
-  (NCI_NFC_DEP_MAX_DATA - LLCP_PDU_HEADER_SIZE - LLCP_SEQUENCE_SIZE)
-#define NFA_P2P_MIU_2 \
-  (2 * NCI_NFC_DEP_MAX_DATA - LLCP_PDU_HEADER_SIZE - LLCP_SEQUENCE_SIZE)
-#define NFA_P2P_MIU_3 \
-  (3 * NCI_NFC_DEP_MAX_DATA - LLCP_PDU_HEADER_SIZE - LLCP_SEQUENCE_SIZE)
-#define NFA_P2P_MIU_8 \
-  (8 * NCI_NFC_DEP_MAX_DATA - LLCP_PDU_HEADER_SIZE - LLCP_SEQUENCE_SIZE)
-
 #define NFA_P2P_LLINK_TYPE LLCP_LINK_TYPE_LOGICAL_DATA_LINK
 #define NFA_P2P_DLINK_TYPE LLCP_LINK_TYPE_DATA_LINK_CONNECTION
 typedef uint8_t tNFA_P2P_LINK_TYPE;
@@ -189,9 +175,6 @@ typedef void(tNFA_P2P_CBACK)(tNFA_P2P_EVT event, tNFA_P2P_EVT_DATA* p_data);
 /*****************************************************************************
 **  External Function Declarations
 *****************************************************************************/
-#ifdef __cplusplus
-extern "C" {
-#endif
 
 /*******************************************************************************
 **
@@ -560,20 +543,4 @@ extern void NFA_P2pGetLLCPConfig(uint16_t* p_link_miu, uint8_t* p_opt,
                                  uint16_t* p_data_link_timeout,
                                  uint16_t* p_delay_first_pdu_timeout);
 
-/*******************************************************************************
-**
-** Function         NFA_P2pSetTraceLevel
-**
-** Description      This function sets the trace level for P2P.  If called with
-**                  a value of 0xFF, it simply returns the current trace level.
-**
-** Returns          The new or current trace level
-**
-*******************************************************************************/
-extern uint8_t NFA_P2pSetTraceLevel(uint8_t new_level);
-
-#ifdef __cplusplus
-}
-#endif
-
 #endif /* NFA_P2P_API_H */
diff --git a/src/nfa/int/nfa_p2p_int.h b/src/nfa/include/nfa_p2p_int.h
similarity index 97%
rename from src/nfa/int/nfa_p2p_int.h
rename to src/nfa/include/nfa_p2p_int.h
index 8291112..f67fc2f 100644
--- a/src/nfa/int/nfa_p2p_int.h
+++ b/src/nfa/include/nfa_p2p_int.h
@@ -31,15 +31,12 @@
 /*****************************************************************************
 **  Constants and data types
 *****************************************************************************/
-#define NFA_P2P_DEBUG BT_TRACE_VERBOSE
 
 /* NFA P2P LLCP link state */
 enum {
   NFA_P2P_LLCP_STATE_IDLE,
   NFA_P2P_LLCP_STATE_LISTENING,
-  NFA_P2P_LLCP_STATE_ACTIVATED,
-
-  NFA_P2P_LLCP_STATE_MAX
+  NFA_P2P_LLCP_STATE_ACTIVATED
 };
 
 typedef uint8_t tNFA_P2P_LLCP_STATE;
@@ -256,7 +253,6 @@ typedef struct {
   uint8_t
       total_pending_i_pdu; /* total number of tx I PDU not processed by NFA */
 
-  uint8_t trace_level;
 } tNFA_P2P_CB;
 
 /*****************************************************************************
@@ -308,10 +304,6 @@ bool nfa_p2p_get_remote_sap(tNFA_P2P_MSG* p_msg);
 bool nfa_p2p_set_llcp_cfg(tNFA_P2P_MSG* p_msg);
 bool nfa_p2p_restart_rf_discovery(tNFA_P2P_MSG* p_msg);
 
-#if (BT_TRACE_VERBOSE == true)
-char* nfa_p2p_evt_code(uint16_t evt_code);
-#endif
-
 #else
 
 #define nfa_p2p_init ()
diff --git a/src/nfa/include/nfa_rw_api.h b/src/nfa/include/nfa_rw_api.h
index b35cd8f..91732f1 100644
--- a/src/nfa/include/nfa_rw_api.h
+++ b/src/nfa/include/nfa_rw_api.h
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -50,12 +50,10 @@
 **  Constants and data types
 *****************************************************************************/
 enum {
-  NFA_RW_PRES_CHK_DEFAULT, /* The default behavior             */
-  NFA_RW_PRES_CHK_I_BLOCK, /* Empty I Block                    */
-  NFA_RW_PRES_CHK_RESET,   /* Deactivate to Sleep; Re-activate */
-  NFA_RW_PRES_CHK_RB_CH0,  /* ReadBinary on Channel 0          */
-  NFA_RW_PRES_CHK_RB_CH3,   /* ReadBinary on Channel 3          */
-  NFA_RW_PRES_CHK_ISO_DEP_NAK /*presence check command ISO-DEP NAK as per NCI2.0*/
+  NFA_RW_PRES_CHK_DEFAULT,        /* The default behavior             */
+  NFA_RW_PRES_CHK_I_BLOCK,        /* Empty I Block                    */
+  NFA_RW_PRES_CHK_ISO_DEP_NAK = 5 /* presence check command ISO-DEP
+                                 NAK as per NCI2.0                */
 };
 typedef uint8_t tNFA_RW_PRES_CHK_OPTION;
 
@@ -72,9 +70,6 @@ typedef struct {
 /*****************************************************************************
 **  External Function Declarations
 *****************************************************************************/
-#ifdef __cplusplus
-extern "C" {
-#endif
 
 /*******************************************************************************
 **
@@ -792,8 +787,5 @@ extern void NFA_SetEmvCoState(bool flag);
 
 #endif
 
-#ifdef __cplusplus
-}
-#endif
 
 #endif /* NFA_RW_API_H */
diff --git a/src/nfa/int/nfa_rw_int.h b/src/nfa/include/nfa_rw_int.h
similarity index 98%
rename from src/nfa/int/nfa_rw_int.h
rename to src/nfa/include/nfa_rw_int.h
index 4260a69..a8f38a4 100644
--- a/src/nfa/int/nfa_rw_int.h
+++ b/src/nfa/include/nfa_rw_int.h
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -67,6 +67,14 @@
 /* Both Lock and Memory control Tlvs are detected */
 #define NFA_RW_TLV_DETECT_ST_COMPLETE 0x03
 
+/* Tag deselect cmd*/
+#define NFA_RW_TAG_DESELECT_CMD 0xC2
+
+#define NFA_RW_TAG_SLP_REQ_LEN 0x02
+
+/* Tag sleep req cmd*/
+extern uint8_t NFA_RW_TAG_SLP_REQ[];
+
 typedef uint8_t tNFA_RW_TLV_ST;
 
 /* RW events */
diff --git a/src/nfa/include/nfa_snep_api.h b/src/nfa/include/nfa_snep_api.h
index 1e16c09..c723824 100644
--- a/src/nfa/include/nfa_snep_api.h
+++ b/src/nfa/include/nfa_snep_api.h
@@ -30,36 +30,15 @@
 /*****************************************************************************
 **  Constants and data types
 *****************************************************************************/
-#define NFA_SNEP_VERSION 0x10 /* SNEP Version 1.0          */
 
-/* send remaining fragments         */
-#define NFA_SNEP_REQ_CODE_CONTINUE 0x00
 /* return an NDEF message           */
 #define NFA_SNEP_REQ_CODE_GET 0x01
 /* accept an NDEF message           */
 #define NFA_SNEP_REQ_CODE_PUT 0x02
 /* do not send remaining fragments  */
-#define NFA_SNEP_REQ_CODE_REJECT 0x7F
 
 #define tNFA_SNEP_REQ_CODE uint8_t
 
-/* continue send remaining fragments    */
-#define NFA_SNEP_RESP_CODE_CONTINUE 0x80
-/* the operation succeeded              */
-#define NFA_SNEP_RESP_CODE_SUCCESS 0x81
-/* resource not found                   */
-#define NFA_SNEP_RESP_CODE_NOT_FOUND 0xC0
-/* resource exceeds data size limit     */
-#define NFA_SNEP_RESP_CODE_EXCESS_DATA 0xC1
-/* malformed request not understood     */
-#define NFA_SNEP_RESP_CODE_BAD_REQ 0xC2
-/* unsupported functionality requested  */
-#define NFA_SNEP_RESP_CODE_NOT_IMPLM 0xE0
-/* unsupported protocol version         */
-#define NFA_SNEP_RESP_CODE_UNSUPP_VER 0xE1
-/* do not send remaining fragments      */
-#define NFA_SNEP_RESP_CODE_REJECT 0xFF
-
 #define tNFA_SNEP_RESP_CODE uint8_t
 
 /* NFA SNEP callback events */
@@ -89,15 +68,8 @@
 /* GET response sent to client          */
 #define NFA_SNEP_GET_RESP_CMPL_EVT 0x0B
 
-/* SNEP default server is started       */
-#define NFA_SNEP_DEFAULT_SERVER_STARTED_EVT 0x0C
-/* SNEP default server is stopped       */
-#define NFA_SNEP_DEFAULT_SERVER_STOPPED_EVT 0x0D
-
 typedef uint8_t tNFA_SNEP_EVT;
 
-#define NFA_SNEP_ANY_SAP LLCP_INVALID_SAP
-
 /* Data for NFA_SNEP_REG_EVT */
 typedef struct {
   tNFA_STATUS status;
@@ -199,291 +171,4 @@ typedef union {
 /* NFA SNEP callback */
 typedef void(tNFA_SNEP_CBACK)(tNFA_SNEP_EVT event, tNFA_SNEP_EVT_DATA* p_data);
 
-/*****************************************************************************
-**  External Function Declarations
-*****************************************************************************/
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*******************************************************************************
-**
-** Function         NFA_SnepStartDefaultServer
-**
-** Description      This function is called to listen to SAP, 0x04 as SNEP
-**                  default server ("urn:nfc:sn:snep") on LLCP.
-**
-**                  NFA_SNEP_DEFAULT_SERVER_STARTED_EVT without data will be
-**                  returned.
-**
-** Note:            If RF discovery is started,
-**                  NFA_StopRfDiscovery()/NFA_RF_DISCOVERY_STOPPED_EVT should
-**                  happen before calling this function
-**
-** Returns          NFA_STATUS_OK if successfully initiated
-**                  NFA_STATUS_FAILED otherwise
-**
-*******************************************************************************/
-extern tNFA_STATUS NFA_SnepStartDefaultServer(tNFA_SNEP_CBACK* p_cback);
-
-/*******************************************************************************
-**
-** Function         NFA_SnepStopDefaultServer
-**
-** Description      This function is called to stop SNEP default server on LLCP.
-**
-**                  NFA_SNEP_DEFAULT_SERVER_STOPPED_EVT without data will be
-**                  returned.
-**
-** Note:            If RF discovery is started,
-**                  NFA_StopRfDiscovery()/NFA_RF_DISCOVERY_STOPPED_EVT should
-**                  happen before calling this function
-**
-** Returns          NFA_STATUS_OK if successfully initiated
-**                  NFA_STATUS_FAILED otherwise
-**
-*******************************************************************************/
-extern tNFA_STATUS NFA_SnepStopDefaultServer(tNFA_SNEP_CBACK* p_cback);
-
-/*******************************************************************************
-**
-** Function         NFA_SnepRegisterServer
-**
-** Description      This function is called to listen to a SAP as SNEP server.
-**
-**                  If server_sap is set to NFA_SNEP_ANY_SAP, then NFA will
-**                  allocate a SAP between LLCP_LOWER_BOUND_SDP_SAP and
-**                  LLCP_UPPER_BOUND_SDP_SAP
-**
-**                  NFC Forum default SNEP server ("urn:nfc:sn:snep") may be
-**                  launched by NFA_SnepStartDefaultServer ().
-**
-**                  NFA_SNEP_REG_EVT will be returned with status, handle and
-**                  service name.
-**
-** Note:            If RF discovery is started,
-**                  NFA_StopRfDiscovery()/NFA_RF_DISCOVERY_STOPPED_EVT should
-**                  happen before calling this function
-**
-** Returns          NFA_STATUS_OK if successfully initiated
-**                  NFA_STATUS_INVALID_PARAM if p_service_name or p_cback is
-**                  NULL
-**                  NFA_STATUS_FAILED otherwise
-**
-*******************************************************************************/
-extern tNFA_STATUS NFA_SnepRegisterServer(uint8_t server_sap,
-                                          char* p_service_name,
-                                          tNFA_SNEP_CBACK* p_cback);
-
-/*******************************************************************************
-**
-** Function         NFA_SnepRegisterClient
-**
-** Description      This function is called to register SNEP client.
-**                  NFA_SNEP_REG_EVT will be returned with status, handle
-**                  and zero-length service name.
-**
-** Returns          NFA_STATUS_OK if successfully initiated
-**                  NFA_STATUS_INVALID_PARAM if p_cback is NULL
-**                  NFA_STATUS_FAILED otherwise
-**
-*******************************************************************************/
-extern tNFA_STATUS NFA_SnepRegisterClient(tNFA_SNEP_CBACK* p_cback);
-
-/*******************************************************************************
-**
-** Function         NFA_SnepDeregister
-**
-** Description      This function is called to stop listening as SNEP server
-**                  or SNEP client. Application shall use reg_handle returned in
-**                  NFA_SNEP_REG_EVT.
-**
-** Note:            If this function is called to de-register a SNEP server and
-**                  RF discovery is started,
-**                  NFA_StopRfDiscovery()/NFA_RF_DISCOVERY_STOPPED_EVT should
-**                  happen before calling this function
-**
-** Returns          NFA_STATUS_OK if successfully initiated
-**                  NFA_STATUS_BAD_HANDLE if handle is not valid
-**                  NFA_STATUS_FAILED otherwise
-**
-*******************************************************************************/
-extern tNFA_STATUS NFA_SnepDeregister(tNFA_HANDLE reg_handle);
-
-/*******************************************************************************
-**
-** Function         NFA_SnepConnect
-**
-** Description      This function is called by client to create data link
-**                  connection to SNEP server on peer device.
-**
-**                  Client handle and service name of server to connect shall be
-**                  provided. A conn_handle will be returned in
-**                  NFA_SNEP_CONNECTED_EVT, if successfully connected. Otherwise
-**                  NFA_SNEP_DISC_EVT will be returned.
-**
-** Returns          NFA_STATUS_OK if successfully initiated
-**                  NFA_STATUS_BAD_HANDLE if handle is not valid
-**                  NFA_STATUS_INVALID_PARAM if p_service_name or p_cback is
-**                  NULL
-**                  NFA_STATUS_FAILED otherwise
-**
-*******************************************************************************/
-extern tNFA_STATUS NFA_SnepConnect(tNFA_HANDLE client_handle,
-                                   char* p_service_name);
-
-/*******************************************************************************
-**
-** Function         NFA_SnepGet
-**
-** Description      This function is called by client to send GET request.
-**
-**                  Application shall allocate a buffer and put NDEF message
-**                  with desired record type to get from server. NDEF message
-**                  from server will be returned in the same buffer with
-**                  NFA_SNEP_GET_RESP_EVT. The size of buffer will be used as
-**                  "Acceptable Length".
-**
-**                  NFA_SNEP_GET_RESP_EVT or NFA_SNEP_DISC_EVT will be returned
-**                  through registered p_cback. Application may free the buffer
-**                  after receiving these events.
-**
-**
-** Returns          NFA_STATUS_OK if successfully initiated
-**                  NFA_STATUS_BAD_HANDLE if handle is not valid
-**                  NFA_STATUS_FAILED otherwise
-**
-*******************************************************************************/
-extern tNFA_STATUS NFA_SnepGet(tNFA_HANDLE conn_handle, uint32_t buff_length,
-                               uint32_t ndef_length, uint8_t* p_ndef_buff);
-
-/*******************************************************************************
-**
-** Function         NFA_SnepPut
-**
-** Description      This function is called by client to send PUT request.
-**
-**                  Application shall allocate a buffer and put desired NDEF
-**                  message to send to server.
-**
-**                  NFA_SNEP_PUT_RESP_EVT or NFA_SNEP_DISC_EVT will be returned
-**                  through p_cback. Application may free the buffer after
-**                  receiving these events.
-**
-** Returns          NFA_STATUS_OK if successfully initiated
-**                  NFA_STATUS_BAD_HANDLE if handle is not valid
-**                  NFA_STATUS_INVALID_PARAM if p_service_name or p_cback is
-**                  NULL
-**                  NFA_STATUS_FAILED otherwise
-**
-*******************************************************************************/
-extern tNFA_STATUS NFA_SnepPut(tNFA_HANDLE conn_handle, uint32_t ndef_length,
-                               uint8_t* p_ndef_buff);
-
-/*******************************************************************************
-**
-** Function         NFA_SnepGetResponse
-**
-** Description      This function is called by server to send response of GET
-**                  request.
-**
-**                  When server application receives NFA_SNEP_ALLOC_BUFF_EVT,
-**                  it shall allocate a buffer for incoming NDEF message and
-**                  pass the pointer within callback context. This buffer will
-**                  be returned with NFA_SNEP_GET_REQ_EVT after receiving
-**                  complete NDEF message. If buffer is not allocated,
-**                  NFA_SNEP_RESP_CODE_NOT_FOUND (Note:There is no proper
-**                  response code for this case) or NFA_SNEP_RESP_CODE_REJECT
-**                  will be sent to client.
-**
-**                  Server application shall provide conn_handle which is
-**                  received in NFA_SNEP_GET_REQ_EVT.
-**
-**                  Server application shall allocate a buffer and put NDEF
-**                  message if response code is NFA_SNEP_RESP_CODE_SUCCESS.
-**                  Otherwise, ndef_length shall be set to zero.
-**
-**                  NFA_SNEP_GET_RESP_CMPL_EVT or NFA_SNEP_DISC_EVT will be
-**                  returned through registered callback function. Application
-**                  may free the buffer after receiving these events.
-**
-** Returns          NFA_STATUS_OK if successfully initiated
-**                  NFA_STATUS_BAD_HANDLE if handle is not valid
-**                  NFA_STATUS_FAILED otherwise
-**
-*******************************************************************************/
-extern tNFA_STATUS NFA_SnepGetResponse(tNFA_HANDLE conn_handle,
-                                       tNFA_SNEP_RESP_CODE resp_code,
-                                       uint32_t ndef_length,
-                                       uint8_t* p_ndef_buff);
-
-/*******************************************************************************
-**
-** Function         NFA_SnepPutResponse
-**
-** Description      This function is called by server to send response of PUT
-**                  request.
-**
-**                  When server application receives NFA_SNEP_ALLOC_BUFF_EVT,
-**                  it shall allocate a buffer for incoming NDEF message and
-**                  pass the pointer within callback context. This buffer will
-**                  be returned with NFA_SNEP_PUT_REQ_EVT after receiving
-**                  complete NDEF message.  If buffer is not allocated,
-**                  NFA_SNEP_RESP_CODE_REJECT will be sent to client or NFA will
-**                  discard request and send NFA_SNEP_RESP_CODE_SUCCESS
-**                  (Note:There is no proper response code for this case).
-**
-**                  Server application shall provide conn_handle which is
-**                  received in NFA_SNEP_PUT_REQ_EVT.
-**
-**                  NFA_SNEP_DISC_EVT will be returned through registered
-**                  callback function when client disconnects data link
-**                  connection.
-**
-** Returns          NFA_STATUS_OK if successfully initiated
-**                  NFA_STATUS_BAD_HANDLE if handle is not valid
-**                  NFA_STATUS_FAILED otherwise
-**
-*******************************************************************************/
-extern tNFA_STATUS NFA_SnepPutResponse(tNFA_HANDLE conn_handle,
-                                       tNFA_SNEP_RESP_CODE resp_code);
-
-/*******************************************************************************
-**
-** Function         NFA_SnepDisconnect
-**
-** Description      This function is called to disconnect data link connection.
-**                  discard any pending data if flush is set to true
-**
-**                  Client application shall provide conn_handle in
-**                  NFA_SNEP_GET_RESP_EVT or NFA_SNEP_PUT_RESP_EVT.
-**
-**                  Server application shall provide conn_handle in
-**                  NFA_SNEP_GET_REQ_EVT or NFA_SNEP_PUT_REQ_EVT.
-**
-**                  NFA_SNEP_DISC_EVT will be returned
-**
-** Returns          NFA_STATUS_OK if successfully initiated
-**                  NFA_STATUS_BAD_HANDLE if handle is not valid
-**                  NFA_STATUS_FAILED otherwise
-**
-*******************************************************************************/
-extern tNFA_STATUS NFA_SnepDisconnect(tNFA_HANDLE conn_handle, bool flush);
-
-/*******************************************************************************
-**
-** Function         NFA_SnepSetTraceLevel
-**
-** Description      This function sets the trace level for SNEP.  If called with
-**                  a value of 0xFF, it simply returns the current trace level.
-**
-** Returns          The new or current trace level
-**
-*******************************************************************************/
-extern uint8_t NFA_SnepSetTraceLevel(uint8_t new_level);
-
-#ifdef __cplusplus
-}
-#endif
-
 #endif /* NFA_P2P_API_H */
diff --git a/src/nfa/int/nfa_snep_int.h b/src/nfa/include/nfa_snep_int.h
similarity index 77%
rename from src/nfa/int/nfa_snep_int.h
rename to src/nfa/include/nfa_snep_int.h
index 8b8ba91..ac2e9a5 100644
--- a/src/nfa/int/nfa_snep_int.h
+++ b/src/nfa/include/nfa_snep_int.h
@@ -31,12 +31,6 @@
 /*****************************************************************************
 **  Constants and data types
 *****************************************************************************/
-#define NFA_SNEP_DEFAULT_SERVER_SAP 0x04 /* SNEP default server SAP   */
-#define NFA_SNEP_HEADER_SIZE 6           /* SNEP header size          */
-/* SNEP Acceptable Length size */
-#define NFA_SNEP_ACCEPT_LEN_SIZE 4
-#define NFA_SNEP_CLIENT_TIMEOUT 1000 /* ms, waiting for response  */
-
 /* NFA SNEP events */
 enum {
   NFA_SNEP_API_START_DEFAULT_SERVER_EVT = NFA_SYS_EVT_START(NFA_ID_SNEP),
@@ -49,9 +43,7 @@ enum {
   NFA_SNEP_API_PUT_REQ_EVT,
   NFA_SNEP_API_GET_RESP_EVT,
   NFA_SNEP_API_PUT_RESP_EVT,
-  NFA_SNEP_API_DISCONNECT_EVT,
-
-  NFA_SNEP_LAST_EVT
+  NFA_SNEP_API_DISCONNECT_EVT
 };
 
 /* data type for NFA_SNEP_API_START_DEFAULT_SERVER_EVT */
@@ -155,20 +147,6 @@ typedef union {
 **  control block
 *****************************************************************************/
 
-/* NFA SNEP service control block */
-/* ignore flags while searching   */
-#define NFA_SNEP_FLAG_ANY 0x00
-#define NFA_SNEP_FLAG_SERVER 0x01 /* server */
-#define NFA_SNEP_FLAG_CLIENT 0x02 /* client */
-/* waiting for connection confirm */
-#define NFA_SNEP_FLAG_CONNECTING 0x04
-/* data link connected            */
-#define NFA_SNEP_FLAG_CONNECTED 0x08
-/* Waiting for continue response  */
-#define NFA_SNEP_FLAG_W4_RESP_CONTINUE 0x10
-/* Waiting for continue request   */
-#define NFA_SNEP_FLAG_W4_REQ_CONTINUE 0x20
-
 typedef struct {
   uint8_t local_sap;        /* local SAP of service */
   uint8_t remote_sap;       /* local SAP of service */
@@ -197,7 +175,6 @@ typedef struct {
   tNFA_SNEP_CONN conn[NFA_SNEP_MAX_CONN];
   bool listen_enabled;
   bool is_dta_mode;
-  uint8_t trace_level;
 } tNFA_SNEP_CB;
 
 /*
@@ -236,38 +213,6 @@ extern tNFA_SNEP_DEFAULT_CB nfa_snep_default_cb;
 **  nfa_snep_main.c
 */
 void nfa_snep_init(bool is_dta_mode);
-/*
-**  nfa_snep_default.c
-*/
-void nfa_snep_default_init(void);
-bool nfa_snep_start_default_server(tNFA_SNEP_MSG* p_msg);
-bool nfa_snep_stop_default_server(tNFA_SNEP_MSG* p_msg);
-/*
-**  nfa_snep_srv.c
-*/
-uint8_t nfa_snep_allocate_cb(void);
-void nfa_snep_deallocate_cb(uint8_t xx);
-void nfa_snep_send_msg(uint8_t opcode, uint8_t dlink);
-
-void nfa_snep_llcp_cback(tLLCP_SAP_CBACK_DATA* p_data);
-void nfa_snep_proc_llcp_data_ind(tLLCP_SAP_CBACK_DATA* p_data);
-void nfa_snep_proc_llcp_connect_ind(tLLCP_SAP_CBACK_DATA* p_data);
-void nfa_snep_proc_llcp_connect_resp(tLLCP_SAP_CBACK_DATA* p_data);
-void nfa_snep_proc_llcp_disconnect_ind(tLLCP_SAP_CBACK_DATA* p_data);
-void nfa_snep_proc_llcp_disconnect_resp(tLLCP_SAP_CBACK_DATA* p_data);
-void nfa_snep_proc_llcp_congest(tLLCP_SAP_CBACK_DATA* p_data);
-void nfa_snep_proc_llcp_link_status(tLLCP_SAP_CBACK_DATA* p_data);
-void nfa_snep_proc_llcp_tx_complete(tLLCP_SAP_CBACK_DATA* p_data);
-
-bool nfa_snep_reg_server(tNFA_SNEP_MSG* p_msg);
-bool nfa_snep_reg_client(tNFA_SNEP_MSG* p_msg);
-bool nfa_snep_dereg(tNFA_SNEP_MSG* p_msg);
-bool nfa_snep_connect(tNFA_SNEP_MSG* p_msg);
-bool nfa_snep_put_resp(tNFA_SNEP_MSG* p_msg);
-bool nfa_snep_get_resp(tNFA_SNEP_MSG* p_msg);
-bool nfa_snep_put_req(tNFA_SNEP_MSG* p_msg);
-bool nfa_snep_get_req(tNFA_SNEP_MSG* p_msg);
-bool nfa_snep_disconnect(tNFA_SNEP_MSG* p_msg);
 
 #endif /* #if (NFA_SNEP_INCLUDED==true) */
 #endif /* NFA_SNEP_INT_H */
diff --git a/src/nfa/int/nfa_sys.h b/src/nfa/include/nfa_sys.h
similarity index 96%
rename from src/nfa/int/nfa_sys.h
rename to src/nfa/include/nfa_sys.h
index f55aae8..3289f2f 100644
--- a/src/nfa/int/nfa_sys.h
+++ b/src/nfa/include/nfa_sys.h
@@ -61,7 +61,6 @@ typedef void(tNFA_SYS_DISABLE)(void);
 /* function type for processing the change of NFCC power mode */
 typedef void(tNFA_SYS_PROC_NFCC_PWR_MODE)(uint8_t nfcc_power_mode);
 
-typedef void(tNFA_SYS_CBACK)(void);
 typedef void(tNFA_SYS_ENABLE_CBACK)(void);
 typedef void(tNFA_SYS_PROC_NFCC_PWR_MODE_CMPL)(void);
 
@@ -78,7 +77,6 @@ typedef struct {
   uint16_t mbox_evt;   /* GKI mailbox event */
   uint8_t mbox;        /* GKI mailbox id */
   uint8_t timer;       /* GKI timer id */
-  uint8_t trace_level; /* initial trace level */
 } tNFA_SYS_CFG;
 
 /*****************************************************************************
@@ -96,10 +94,6 @@ typedef struct {
 **  Function declarations
 *****************************************************************************/
 
-#ifdef __cplusplus
-extern "C" {
-#endif
-
 extern void nfa_sys_init(void);
 extern void nfa_sys_event(NFC_HDR* p_msg);
 extern void nfa_sys_timer_update(void);
@@ -129,8 +123,5 @@ extern void nfa_sys_cback_notify_nfcc_power_mode_proc_complete(uint8_t id);
 #if (NXP_EXTNS == TRUE)
 extern void nfa_sys_cback_notify_MinEnable_complete(uint8_t id);
 #endif
-#ifdef __cplusplus
-}
-#endif
 
 #endif /* NFA_SYS_H */
diff --git a/src/nfa/int/nfa_sys_int.h b/src/nfa/include/nfa_sys_int.h
similarity index 96%
rename from src/nfa/int/nfa_sys_int.h
rename to src/nfa/include/nfa_sys_int.h
index a5e974a..0721176 100644
--- a/src/nfa/int/nfa_sys_int.h
+++ b/src/nfa/include/nfa_sys_int.h
@@ -25,6 +25,7 @@
 #define NFA_SYS_INT_H
 
 #include "nfa_sys_ptim.h"
+#include "nfa_sys.h"
 
 /*****************************************************************************
 **  Constants and data types
@@ -53,7 +54,6 @@ typedef struct {
 
   bool graceful_disable; /* true if NFA_Disable () is called with true */
   bool timers_disabled;  /* true if sys timers disabled */
-  uint8_t trace_level;   /* Trace level */
 } tNFA_SYS_CB;
 
 /*****************************************************************************
@@ -66,6 +66,4 @@ extern tNFA_SYS_CB nfa_sys_cb;
 /* system manager configuration structure */
 extern tNFA_SYS_CFG* p_nfa_sys_cfg;
 
-bool nfa_sys_sm_execute(NFC_HDR* p_msg);
-
 #endif /* NFA_SYS_INT_H */
diff --git a/src/nfa/int/nfa_sys_ptim.h b/src/nfa/include/nfa_sys_ptim.h
similarity index 98%
rename from src/nfa/int/nfa_sys_ptim.h
rename to src/nfa/include/nfa_sys_ptim.h
index 0549f63..b624044 100644
--- a/src/nfa/int/nfa_sys_ptim.h
+++ b/src/nfa/include/nfa_sys_ptim.h
@@ -37,9 +37,6 @@ typedef struct {
   uint8_t timer_id;         /* GKI timer id */
 } tPTIM_CB;
 
-#ifdef __cplusplus
-extern "C" {
-#endif
 
 /*****************************************************************************
 **  Function Declarations
@@ -92,8 +89,5 @@ extern void nfa_sys_ptim_start_timer(tPTIM_CB* p_cb, TIMER_LIST_ENT* p_tle,
 *******************************************************************************/
 extern void nfa_sys_ptim_stop_timer(tPTIM_CB* p_cb, TIMER_LIST_ENT* p_tle);
 
-#ifdef __cplusplus
-}
-#endif
 
 #endif /* NFA_SYS_PTIM_H */
diff --git a/src/nfa/p2p/nfa_p2p_act.c b/src/nfa/p2p/nfa_p2p_act.cc
similarity index 92%
rename from src/nfa/p2p/nfa_p2p_act.c
rename to src/nfa/p2p/nfa_p2p_act.cc
index f0dfa9a..61ec622 100644
--- a/src/nfa/p2p/nfa_p2p_act.c
+++ b/src/nfa/p2p/nfa_p2p_act.cc
@@ -1,4 +1,5 @@
 /******************************************************************************
+ *
  *  Copyright (c) 2016, The Linux Foundation. All rights reserved.
  *  Not a Contribution.
  *
@@ -23,28 +24,17 @@
  *  This is the implementation file for the NFA P2P.
  *
  ******************************************************************************/
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
 
-#include "string.h"
-#include "nfc_api.h"
-#include "nfa_sys.h"
-#include "nfa_sys_int.h"
 #include "nfa_dm_int.h"
-#include "llcp_defs.h"
 #include "llcp_api.h"
 #include "nfa_p2p_api.h"
 #include "nfa_p2p_int.h"
 
-/*****************************************************************************
-**  Global Variables
-*****************************************************************************/
-
-/*****************************************************************************
-**  Static Functions
-*****************************************************************************/
+using android::base::StringPrintf;
 
-/*****************************************************************************
-**  Constants
-*****************************************************************************/
+extern bool nfc_debug_enabled;
 
 /*******************************************************************************
 **
@@ -68,7 +58,7 @@ static uint8_t nfa_p2p_allocate_conn_cb(uint8_t local_sap) {
     }
   }
 
-  P2P_TRACE_ERROR0("nfa_p2p_allocate_conn_cb (): No resource");
+  LOG(ERROR) << StringPrintf("nfa_p2p_allocate_conn_cb (): No resource");
 
   return LLCP_MAX_DATA_LINK;
 }
@@ -87,7 +77,7 @@ static void nfa_p2p_deallocate_conn_cb(uint8_t xx) {
   if (xx < LLCP_MAX_DATA_LINK) {
     nfa_p2p_cb.conn_cb[xx].flags = 0;
   } else {
-    P2P_TRACE_ERROR1("nfa_p2p_deallocate_conn_cb (): Invalid index (%d)", xx);
+    LOG(ERROR) << StringPrintf("nfa_p2p_deallocate_conn_cb (): Invalid index (%d)", xx);
   }
 }
 
@@ -126,7 +116,7 @@ static uint8_t nfa_p2p_find_conn_cb(uint8_t local_sap, uint8_t remote_sap) {
 **
 *******************************************************************************/
 static void nfa_p2p_llcp_cback(tLLCP_SAP_CBACK_DATA* p_data) {
-  P2P_TRACE_DEBUG2("nfa_p2p_llcp_cback (): event:0x%02X, local_sap:0x%02X",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_llcp_cback (): event:0x%02X, local_sap:0x%02X",
                    p_data->hdr.event, p_data->hdr.local_sap);
 
   switch (p_data->hdr.event) {
@@ -159,7 +149,7 @@ static void nfa_p2p_llcp_cback(tLLCP_SAP_CBACK_DATA* p_data) {
       break;
 
     default:
-      P2P_TRACE_ERROR1("nfa_p2p_llcp_cback (): Unknown event:0x%02X",
+      LOG(ERROR) << StringPrintf("nfa_p2p_llcp_cback (): Unknown event:0x%02X",
                        p_data->hdr.event);
       return;
   }
@@ -180,7 +170,7 @@ void nfa_p2p_sdp_cback(uint8_t tid, uint8_t remote_sap) {
   uint8_t xx;
   tNFA_P2P_EVT_DATA evt_data;
 
-  P2P_TRACE_DEBUG2("nfa_p2p_sdp_cback (): tid:0x%02X, remote_sap:0x%02X", tid,
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_sdp_cback (): tid:0x%02X, remote_sap:0x%02X", tid,
                    remote_sap);
 
   /* search for callback function to process */
@@ -212,7 +202,7 @@ void nfa_p2p_sdp_cback(uint8_t tid, uint8_t remote_sap) {
 bool nfa_p2p_start_sdp(char* p_service_name, uint8_t local_sap) {
   int xx;
 
-  P2P_TRACE_DEBUG1("nfa_p2p_start_sdp (): SN:<%s>", p_service_name);
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_start_sdp (): SN:<%s>", p_service_name);
 
   /* search for empty slot */
   for (xx = 0; xx < LLCP_MAX_SDP_TRANSAC; xx++) {
@@ -245,7 +235,7 @@ void nfa_p2p_proc_llcp_data_ind(tLLCP_SAP_CBACK_DATA* p_data) {
   uint8_t local_sap, xx;
   tNFA_P2P_EVT_DATA evt_data;
 
-  P2P_TRACE_DEBUG0("nfa_p2p_proc_llcp_data_ind ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_proc_llcp_data_ind ()");
 
   local_sap = p_data->data_ind.local_sap;
 
@@ -287,7 +277,7 @@ void nfa_p2p_proc_llcp_connect_ind(tLLCP_SAP_CBACK_DATA* p_data) {
   tNFA_P2P_EVT_DATA evt_data;
   uint8_t xx;
 
-  P2P_TRACE_DEBUG1("nfa_p2p_proc_llcp_connect_ind () server_sap:0x%x",
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_proc_llcp_connect_ind () server_sap:0x%x",
                    p_data->connect_ind.server_sap);
 
   server_sap = p_data->connect_ind.server_sap;
@@ -314,7 +304,7 @@ void nfa_p2p_proc_llcp_connect_ind(tLLCP_SAP_CBACK_DATA* p_data) {
       nfa_p2p_cb.sap_cb[server_sap].p_cback(NFA_P2P_CONN_REQ_EVT, &evt_data);
     }
   } else {
-    P2P_TRACE_ERROR0("nfa_p2p_proc_llcp_connect_ind (): Not registered");
+    LOG(ERROR) << StringPrintf("nfa_p2p_proc_llcp_connect_ind (): Not registered");
   }
 }
 
@@ -332,7 +322,7 @@ void nfa_p2p_proc_llcp_connect_resp(tLLCP_SAP_CBACK_DATA* p_data) {
   uint8_t local_sap, xx;
   tNFA_P2P_EVT_DATA evt_data;
 
-  P2P_TRACE_DEBUG0("nfa_p2p_proc_llcp_connect_resp ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_proc_llcp_connect_resp ()");
 
   local_sap = p_data->connect_resp.local_sap;
 
@@ -373,7 +363,7 @@ void nfa_p2p_proc_llcp_disconnect_ind(tLLCP_SAP_CBACK_DATA* p_data) {
   uint8_t local_sap, xx;
   tNFA_P2P_EVT_DATA evt_data;
 
-  P2P_TRACE_DEBUG0("nfa_p2p_proc_llcp_disconnect_ind ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_proc_llcp_disconnect_ind ()");
 
   local_sap = p_data->disconnect_ind.local_sap;
 
@@ -401,7 +391,7 @@ void nfa_p2p_proc_llcp_disconnect_ind(tLLCP_SAP_CBACK_DATA* p_data) {
 
       nfa_p2p_cb.sap_cb[local_sap].p_cback(NFA_P2P_DISC_EVT, &evt_data);
 
-      P2P_TRACE_ERROR0("nfa_p2p_proc_llcp_disconnect_ind (): Link deactivated");
+      LOG(ERROR) << StringPrintf("nfa_p2p_proc_llcp_disconnect_ind (): Link deactivated");
     }
   }
 }
@@ -420,7 +410,7 @@ void nfa_p2p_proc_llcp_disconnect_resp(tLLCP_SAP_CBACK_DATA* p_data) {
   uint8_t local_sap, xx;
   tNFA_P2P_EVT_DATA evt_data;
 
-  P2P_TRACE_DEBUG0("nfa_p2p_proc_llcp_disconnect_resp ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_proc_llcp_disconnect_resp ()");
 
   local_sap = p_data->disconnect_resp.local_sap;
 
@@ -460,7 +450,7 @@ void nfa_p2p_proc_llcp_disconnect_resp(tLLCP_SAP_CBACK_DATA* p_data) {
 
         nfa_p2p_cb.sap_cb[local_sap].p_cback(NFA_P2P_DISC_EVT, &evt_data);
       } else {
-        P2P_TRACE_ERROR0(
+        LOG(ERROR) << StringPrintf(
             "nfa_p2p_proc_llcp_disconnect_resp (): No connection found");
       }
     } else {
@@ -491,11 +481,11 @@ void nfa_p2p_proc_llcp_congestion(tLLCP_SAP_CBACK_DATA* p_data) {
   evt_data.congest.is_congested = p_data->congest.is_congested;
 
   if (p_data->congest.is_congested) {
-    P2P_TRACE_DEBUG2("nfa_p2p_proc_llcp_congestion () START SAP=(0x%x,0x%x)",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_proc_llcp_congestion () START SAP=(0x%x,0x%x)",
                      local_sap, remote_sap);
 
   } else {
-    P2P_TRACE_DEBUG2("nfa_p2p_proc_llcp_congestion () END SAP=(0x%x,0x%x)",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_proc_llcp_congestion () END SAP=(0x%x,0x%x)",
                      local_sap, remote_sap);
   }
 
@@ -534,7 +524,7 @@ void nfa_p2p_proc_llcp_congestion(tLLCP_SAP_CBACK_DATA* p_data) {
           nfa_p2p_cb.sap_cb[local_sap].p_cback(NFA_P2P_CONGEST_EVT, &evt_data);
         }
       } else {
-        P2P_TRACE_ERROR0(
+        LOG(ERROR) << StringPrintf(
             "nfa_p2p_proc_llcp_congestion (): No connection found");
       }
     }
@@ -555,7 +545,7 @@ void nfa_p2p_proc_llcp_link_status(tLLCP_SAP_CBACK_DATA* p_data) {
   uint8_t local_sap, xx;
   tNFA_P2P_EVT_DATA evt_data;
 
-  P2P_TRACE_DEBUG1("nfa_p2p_proc_llcp_link_status () is_activated:%d",
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_proc_llcp_link_status () is_activated:%d",
                    p_data->link_status.is_activated);
 
   local_sap = p_data->link_status.local_sap;
@@ -617,7 +607,7 @@ bool nfa_p2p_reg_server(tNFA_P2P_MSG* p_msg) {
   tNFA_P2P_EVT_DATA evt_data;
   uint8_t server_sap;
 
-  P2P_TRACE_DEBUG0("nfa_p2p_reg_server ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_reg_server ()");
 
   server_sap = LLCP_RegisterServer(
       p_msg->api_reg_server.server_sap, p_msg->api_reg_server.link_type,
@@ -682,7 +672,7 @@ bool nfa_p2p_reg_client(tNFA_P2P_MSG* p_msg) {
   tNFA_P2P_EVT_DATA evt_data;
   uint8_t local_sap;
 
-  P2P_TRACE_DEBUG0("nfa_p2p_reg_client ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_reg_client ()");
 
   local_sap =
       LLCP_RegisterClient(p_msg->api_reg_client.link_type, nfa_p2p_llcp_cback);
@@ -726,7 +716,7 @@ bool nfa_p2p_reg_client(tNFA_P2P_MSG* p_msg) {
 bool nfa_p2p_dereg(tNFA_P2P_MSG* p_msg) {
   uint8_t local_sap, xx;
 
-  P2P_TRACE_DEBUG0("nfa_p2p_dereg ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_dereg ()");
 
   local_sap = (uint8_t)(p_msg->api_dereg.handle & NFA_HANDLE_MASK);
 
@@ -781,7 +771,7 @@ bool nfa_p2p_accept_connection(tNFA_P2P_MSG* p_msg) {
   uint8_t xx;
   tLLCP_CONNECTION_PARAMS params;
 
-  P2P_TRACE_DEBUG0("nfa_p2p_accept_connection ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_accept_connection ()");
 
   xx = (uint8_t)(p_msg->api_accept.conn_handle & NFA_HANDLE_MASK);
   xx &= ~NFA_P2P_HANDLE_FLAG_CONN;
@@ -809,7 +799,7 @@ bool nfa_p2p_accept_connection(tNFA_P2P_MSG* p_msg) {
 bool nfa_p2p_reject_connection(tNFA_P2P_MSG* p_msg) {
   uint8_t xx;
 
-  P2P_TRACE_DEBUG0("nfa_p2p_reject_connection ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_reject_connection ()");
 
   xx = (uint8_t)(p_msg->api_reject.conn_handle & NFA_HANDLE_MASK);
   xx &= ~NFA_P2P_HANDLE_FLAG_CONN;
@@ -839,7 +829,7 @@ bool nfa_p2p_disconnect(tNFA_P2P_MSG* p_msg) {
   tLLCP_STATUS status;
   tNFA_P2P_EVT_DATA evt_data;
 
-  P2P_TRACE_DEBUG0("nfa_p2p_disconnect ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_disconnect ()");
 
   xx = (uint8_t)(p_msg->api_disconnect.conn_handle & NFA_HANDLE_MASK);
 
@@ -871,7 +861,7 @@ bool nfa_p2p_disconnect(tNFA_P2P_MSG* p_msg) {
       }
     }
   } else {
-    P2P_TRACE_ERROR0("Handle is not for Data link connection");
+    LOG(ERROR) << StringPrintf("Handle is not for Data link connection");
   }
 
   return true;
@@ -893,7 +883,7 @@ bool nfa_p2p_create_data_link_connection(tNFA_P2P_MSG* p_msg) {
   tLLCP_CONNECTION_PARAMS conn_params;
   tLLCP_STATUS status;
 
-  P2P_TRACE_DEBUG0("nfa_p2p_create_data_link_connection ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_create_data_link_connection ()");
 
   local_sap = (uint8_t)(p_msg->api_connect.client_handle & NFA_HANDLE_MASK);
 
@@ -941,7 +931,7 @@ bool nfa_p2p_send_ui(tNFA_P2P_MSG* p_msg) {
   tLLCP_STATUS status;
   tNFA_P2P_EVT_DATA evt_data;
 
-  P2P_TRACE_DEBUG0("nfa_p2p_send_ui ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_send_ui ()");
 
   local_sap = (uint8_t)(p_msg->api_send_ui.handle & NFA_HANDLE_MASK);
 
@@ -987,7 +977,7 @@ bool nfa_p2p_send_data(tNFA_P2P_MSG* p_msg) {
   tLLCP_STATUS status;
   uint8_t xx;
 
-  P2P_TRACE_DEBUG0("nfa_p2p_send_data ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_send_data ()");
 
   xx = (uint8_t)(p_msg->api_send_data.conn_handle & NFA_HANDLE_MASK);
   xx &= ~NFA_P2P_HANDLE_FLAG_CONN;
@@ -1034,7 +1024,7 @@ bool nfa_p2p_send_data(tNFA_P2P_MSG* p_msg) {
 bool nfa_p2p_set_local_busy(tNFA_P2P_MSG* p_msg) {
   uint8_t xx;
 
-  P2P_TRACE_DEBUG0("nfa_p2p_set_local_busy ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_set_local_busy ()");
 
   xx = (uint8_t)(p_msg->api_local_busy.conn_handle & NFA_HANDLE_MASK);
   xx &= ~NFA_P2P_HANDLE_FLAG_CONN;
@@ -1060,7 +1050,7 @@ bool nfa_p2p_get_link_info(tNFA_P2P_MSG* p_msg) {
   tNFA_P2P_EVT_DATA evt_data;
   uint8_t local_sap;
 
-  P2P_TRACE_DEBUG0("nfa_p2p_get_link_info ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_get_link_info ()");
 
   evt_data.link_info.handle = p_msg->api_link_info.handle;
   evt_data.link_info.wks = LLCP_GetRemoteWKS();
@@ -1087,7 +1077,7 @@ bool nfa_p2p_get_remote_sap(tNFA_P2P_MSG* p_msg) {
   tNFA_P2P_EVT_DATA evt_data;
   uint8_t local_sap;
 
-  P2P_TRACE_DEBUG0("nfa_p2p_get_remote_sap ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_get_remote_sap ()");
 
   local_sap = (uint8_t)(p_msg->api_remote_sap.handle & NFA_HANDLE_MASK);
 
@@ -1133,9 +1123,9 @@ bool nfa_p2p_set_llcp_cfg(tNFA_P2P_MSG* p_msg) {
 ** Returns          true to deallocate buffer
 **
 *******************************************************************************/
-bool nfa_p2p_restart_rf_discovery(tNFA_P2P_MSG* p_msg) {
+bool nfa_p2p_restart_rf_discovery(__attribute__((unused)) tNFA_P2P_MSG* p_msg) {
   (void)p_msg;
-  P2P_TRACE_DEBUG0("nfa_p2p_restart_rf_discovery ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_restart_rf_discovery ()");
 
   nfa_dm_rf_deactivate(NFA_DEACTIVATE_TYPE_IDLE);
 
diff --git a/src/nfa/p2p/nfa_p2p_api.c b/src/nfa/p2p/nfa_p2p_api.cc
similarity index 87%
rename from src/nfa/p2p/nfa_p2p_api.c
rename to src/nfa/p2p/nfa_p2p_api.cc
index fb98795..f6010be 100644
--- a/src/nfa/p2p/nfa_p2p_api.c
+++ b/src/nfa/p2p/nfa_p2p_api.cc
@@ -17,21 +17,41 @@
  *  limitations under the License.
  *
  ******************************************************************************/
+/******************************************************************************
+ *
+ *  The original Work has been changed by NXP Semiconductors.
+ *
+ *  Copyright 2018 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
 
 /******************************************************************************
  *
  *  NFA interface to LLCP
  *
  ******************************************************************************/
-#include <string.h>
-#include "nfc_api.h"
-#include "nfa_sys.h"
-#include "nfa_sys_int.h"
-#include "llcp_defs.h"
-#include "llcp_api.h"
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfa_p2p_api.h"
 #include "nfa_p2p_int.h"
 
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+
 /*****************************************************************************
 **  Constants
 *****************************************************************************/
@@ -67,20 +87,20 @@ tNFA_STATUS NFA_P2pRegisterServer(uint8_t server_sap,
                                   tNFA_P2P_CBACK* p_cback) {
   tNFA_P2P_API_REG_SERVER* p_msg;
 
-  P2P_TRACE_API3(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "NFA_P2pRegisterServer (): server_sap:0x%02x, link_type:0x%x, SN:<%s>",
       server_sap, link_type, p_service_name);
 
   if ((server_sap != NFA_P2P_ANY_SAP) &&
       ((server_sap <= LLCP_SAP_SDP) ||
        (server_sap > LLCP_UPPER_BOUND_SDP_SAP))) {
-    P2P_TRACE_ERROR2(
+    LOG(ERROR) << StringPrintf(
         "NFA_P2pRegisterServer (): server_sap must be between %d and %d",
         LLCP_SAP_SDP + 1, LLCP_UPPER_BOUND_SDP_SAP);
     return (NFA_STATUS_FAILED);
   } else if (((link_type & NFA_P2P_LLINK_TYPE) == 0x00) &&
              ((link_type & NFA_P2P_DLINK_TYPE) == 0x00)) {
-    P2P_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "NFA_P2pRegisterServer(): link type (0x%x) must be specified",
         link_type);
     return (NFA_STATUS_FAILED);
@@ -126,11 +146,11 @@ tNFA_STATUS NFA_P2pRegisterClient(tNFA_P2P_LINK_TYPE link_type,
                                   tNFA_P2P_CBACK* p_cback) {
   tNFA_P2P_API_REG_CLIENT* p_msg;
 
-  P2P_TRACE_API1("NFA_P2pRegisterClient (): link_type:0x%x", link_type);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_P2pRegisterClient (): link_type:0x%x", link_type);
 
   if (((link_type & NFA_P2P_LLINK_TYPE) == 0x00) &&
       ((link_type & NFA_P2P_DLINK_TYPE) == 0x00)) {
-    P2P_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "NFA_P2pRegisterClient (): link type (0x%x) must be specified",
         link_type);
     return (NFA_STATUS_FAILED);
@@ -172,12 +192,12 @@ tNFA_STATUS NFA_P2pDeregister(tNFA_HANDLE handle) {
   tNFA_P2P_API_DEREG* p_msg;
   tNFA_HANDLE xx;
 
-  P2P_TRACE_API1("NFA_P2pDeregister (): handle:0x%02X", handle);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_P2pDeregister (): handle:0x%02X", handle);
 
   xx = handle & NFA_HANDLE_MASK;
 
   if ((xx >= NFA_P2P_NUM_SAP) || (nfa_p2p_cb.sap_cb[xx].p_cback == NULL)) {
-    P2P_TRACE_ERROR0(
+    LOG(ERROR) << StringPrintf(
         "NFA_P2pDeregister (): Handle is invalid or not registered");
     return (NFA_STATUS_BAD_HANDLE);
   }
@@ -213,25 +233,25 @@ tNFA_STATUS NFA_P2pAcceptConn(tNFA_HANDLE handle, uint16_t miu, uint8_t rw) {
   tNFA_P2P_API_ACCEPT_CONN* p_msg;
   tNFA_HANDLE xx;
 
-  P2P_TRACE_API3("NFA_P2pAcceptConn (): handle:0x%02X, MIU:%d, RW:%d", handle,
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_P2pAcceptConn (): handle:0x%02X, MIU:%d, RW:%d", handle,
                  miu, rw);
 
   xx = handle & NFA_HANDLE_MASK;
 
   if (!(xx & NFA_P2P_HANDLE_FLAG_CONN)) {
-    P2P_TRACE_ERROR0("NFA_P2pAcceptConn (): Connection Handle is not valid");
+    LOG(ERROR) << StringPrintf("NFA_P2pAcceptConn (): Connection Handle is not valid");
     return (NFA_STATUS_BAD_HANDLE);
   } else {
     xx &= ~NFA_P2P_HANDLE_FLAG_CONN;
   }
 
   if ((xx >= LLCP_MAX_DATA_LINK) || (nfa_p2p_cb.conn_cb[xx].flags == 0)) {
-    P2P_TRACE_ERROR0("NFA_P2pAcceptConn (): Connection Handle is not valid");
+    LOG(ERROR) << StringPrintf("NFA_P2pAcceptConn (): Connection Handle is not valid");
     return (NFA_STATUS_BAD_HANDLE);
   }
 
   if ((miu < LLCP_DEFAULT_MIU) || (nfa_p2p_cb.local_link_miu < miu)) {
-    P2P_TRACE_ERROR3("NFA_P2pAcceptConn (): MIU(%d) must be between %d and %d",
+    LOG(ERROR) << StringPrintf("NFA_P2pAcceptConn (): MIU(%d) must be between %d and %d",
                      miu, LLCP_DEFAULT_MIU, nfa_p2p_cb.local_link_miu);
   } else if ((p_msg = (tNFA_P2P_API_ACCEPT_CONN*)GKI_getbuf(
                   sizeof(tNFA_P2P_API_ACCEPT_CONN))) != NULL) {
@@ -266,19 +286,19 @@ tNFA_STATUS NFA_P2pRejectConn(tNFA_HANDLE handle) {
   tNFA_P2P_API_REJECT_CONN* p_msg;
   tNFA_HANDLE xx;
 
-  P2P_TRACE_API1("NFA_P2pRejectConn (): handle:0x%02X", handle);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_P2pRejectConn (): handle:0x%02X", handle);
 
   xx = handle & NFA_HANDLE_MASK;
 
   if (!(xx & NFA_P2P_HANDLE_FLAG_CONN)) {
-    P2P_TRACE_ERROR0("NFA_P2pRejectConn (): Connection Handle is not valid");
+    LOG(ERROR) << StringPrintf("NFA_P2pRejectConn (): Connection Handle is not valid");
     return (NFA_STATUS_BAD_HANDLE);
   } else {
     xx &= ~NFA_P2P_HANDLE_FLAG_CONN;
   }
 
   if ((xx >= LLCP_MAX_DATA_LINK) || (nfa_p2p_cb.conn_cb[xx].flags == 0)) {
-    P2P_TRACE_ERROR0("NFA_P2pRejectConn (): Connection Handle is not valid");
+    LOG(ERROR) << StringPrintf("NFA_P2pRejectConn (): Connection Handle is not valid");
     return (NFA_STATUS_BAD_HANDLE);
   }
 
@@ -318,7 +338,7 @@ tNFA_STATUS NFA_P2pDisconnect(tNFA_HANDLE handle, bool flush) {
   tNFA_P2P_API_DISCONNECT* p_msg;
   tNFA_HANDLE xx;
 
-  P2P_TRACE_API2("NFA_P2pDisconnect (): handle:0x%02X, flush=%d", handle,
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_P2pDisconnect (): handle:0x%02X, flush=%d", handle,
                  flush);
 
   xx = handle & NFA_HANDLE_MASK;
@@ -327,11 +347,11 @@ tNFA_STATUS NFA_P2pDisconnect(tNFA_HANDLE handle, bool flush) {
     xx &= ~NFA_P2P_HANDLE_FLAG_CONN;
 
     if ((xx >= LLCP_MAX_DATA_LINK) || (nfa_p2p_cb.conn_cb[xx].flags == 0)) {
-      P2P_TRACE_ERROR0("NFA_P2pDisconnect (): Connection Handle is not valid");
+      LOG(ERROR) << StringPrintf("NFA_P2pDisconnect (): Connection Handle is not valid");
       return (NFA_STATUS_BAD_HANDLE);
     }
   } else {
-    P2P_TRACE_ERROR0("NFA_P2pDisconnect (): Handle is not valid");
+    LOG(ERROR) << StringPrintf("NFA_P2pDisconnect (): Handle is not valid");
     return (NFA_STATUS_BAD_HANDLE);
   }
 
@@ -370,21 +390,21 @@ tNFA_STATUS NFA_P2pConnectByName(tNFA_HANDLE client_handle,
   tNFA_P2P_API_CONNECT* p_msg;
   tNFA_HANDLE xx;
 
-  P2P_TRACE_API4(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "NFA_P2pConnectByName (): client_handle:0x%x, SN:<%s>, MIU:%d, RW:%d",
       client_handle, p_service_name, miu, rw);
 
   xx = client_handle & NFA_HANDLE_MASK;
 
   if ((xx >= NFA_P2P_NUM_SAP) || (nfa_p2p_cb.sap_cb[xx].p_cback == NULL)) {
-    P2P_TRACE_ERROR0("NFA_P2pConnectByName (): Client Handle is not valid");
+    LOG(ERROR) << StringPrintf("NFA_P2pConnectByName (): Client Handle is not valid");
     return (NFA_STATUS_BAD_HANDLE);
   }
 
   if ((miu < LLCP_DEFAULT_MIU) ||
       (nfa_p2p_cb.llcp_state != NFA_P2P_LLCP_STATE_ACTIVATED) ||
       (nfa_p2p_cb.local_link_miu < miu)) {
-    P2P_TRACE_ERROR3(
+    LOG(ERROR) << StringPrintf(
         "NFA_P2pConnectByName (): MIU(%d) must be between %d and %d or LLCP "
         "link is not activated",
         miu, LLCP_DEFAULT_MIU, nfa_p2p_cb.local_link_miu);
@@ -427,21 +447,21 @@ tNFA_STATUS NFA_P2pConnectBySap(tNFA_HANDLE client_handle, uint8_t dsap,
   tNFA_P2P_API_CONNECT* p_msg;
   tNFA_HANDLE xx;
 
-  P2P_TRACE_API4(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "NFA_P2pConnectBySap (): client_handle:0x%x, DSAP:0x%02X, MIU:%d, RW:%d",
       client_handle, dsap, miu, rw);
 
   xx = client_handle & NFA_HANDLE_MASK;
 
   if ((xx >= NFA_P2P_NUM_SAP) || (nfa_p2p_cb.sap_cb[xx].p_cback == NULL)) {
-    P2P_TRACE_ERROR0("NFA_P2pConnectBySap (): Client Handle is not valid");
+    LOG(ERROR) << StringPrintf("NFA_P2pConnectBySap (): Client Handle is not valid");
     return (NFA_STATUS_BAD_HANDLE);
   }
 
   if ((miu < LLCP_DEFAULT_MIU) ||
       (nfa_p2p_cb.llcp_state != NFA_P2P_LLCP_STATE_ACTIVATED) ||
       (nfa_p2p_cb.local_link_miu < miu)) {
-    P2P_TRACE_ERROR3(
+    LOG(ERROR) << StringPrintf(
         "NFA_P2pConnectBySap (): MIU(%d) must be between %d and %d, or LLCP "
         "link is not activated",
         miu, LLCP_DEFAULT_MIU, nfa_p2p_cb.local_link_miu);
@@ -485,7 +505,7 @@ tNFA_STATUS NFA_P2pSendUI(tNFA_HANDLE handle, uint8_t dsap, uint16_t length,
   tNFA_STATUS ret_status = NFA_STATUS_FAILED;
   tNFA_HANDLE xx;
 
-  P2P_TRACE_API3("NFA_P2pSendUI (): handle:0x%X, DSAP:0x%02X, length:%d",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_P2pSendUI (): handle:0x%X, DSAP:0x%02X, length:%d",
                  handle, dsap, length);
 
   GKI_sched_lock();
@@ -493,16 +513,16 @@ tNFA_STATUS NFA_P2pSendUI(tNFA_HANDLE handle, uint8_t dsap, uint16_t length,
   xx = handle & NFA_HANDLE_MASK;
 
   if ((xx >= NFA_P2P_NUM_SAP) || (nfa_p2p_cb.sap_cb[xx].p_cback == NULL)) {
-    P2P_TRACE_ERROR1("NFA_P2pSendUI (): Handle (0x%X) is not valid", handle);
+    LOG(ERROR) << StringPrintf("NFA_P2pSendUI (): Handle (0x%X) is not valid", handle);
     ret_status = NFA_STATUS_BAD_HANDLE;
   } else if (length > nfa_p2p_cb.remote_link_miu) {
-    P2P_TRACE_ERROR3(
+    LOG(ERROR) << StringPrintf(
         "NFA_P2pSendUI (): handle:0x%X, length(%d) must be less than remote "
         "link MIU(%d)",
         handle, length, nfa_p2p_cb.remote_link_miu);
     ret_status = NFA_STATUS_BAD_LENGTH;
   } else if (nfa_p2p_cb.sap_cb[xx].flags & NFA_P2P_SAP_FLAG_LLINK_CONGESTED) {
-    P2P_TRACE_WARNING1(
+    LOG(WARNING) << StringPrintf(
         "NFA_P2pSendUI (): handle:0x%X, logical data link is already congested",
         handle);
     ret_status = NFA_STATUS_CONGESTED;
@@ -512,7 +532,7 @@ tNFA_STATUS NFA_P2pSendUI(tNFA_HANDLE handle, uint8_t dsap, uint16_t length,
                  nfa_p2p_cb.total_pending_i_pdu)) {
     nfa_p2p_cb.sap_cb[xx].flags |= NFA_P2P_SAP_FLAG_LLINK_CONGESTED;
 
-    P2P_TRACE_WARNING1(
+    LOG(WARNING) << StringPrintf(
         "NFA_P2pSendUI(): handle:0x%X, logical data link is congested", handle);
     ret_status = NFA_STATUS_CONGESTED;
   } else if ((p_msg = (tNFA_P2P_API_SEND_UI*)GKI_getbuf(
@@ -523,12 +543,12 @@ tNFA_STATUS NFA_P2pSendUI(tNFA_HANDLE handle, uint8_t dsap, uint16_t length,
     p_msg->dsap = dsap;
 
     p_msg->p_msg = (NFC_HDR*)GKI_getpoolbuf(LLCP_POOL_ID);
+
     if (p_msg->p_msg != NULL) {
       p_msg->p_msg->len = length;
       p_msg->p_msg->offset = LLCP_MIN_OFFSET;
       memcpy(((uint8_t*)(p_msg->p_msg + 1) + p_msg->p_msg->offset), p_data,
              length);
-
       /* increase number of tx UI PDU which is not processed by NFA for
        * congestion control */
       nfa_p2p_cb.sap_cb[xx].num_pending_ui_pdu++;
@@ -574,14 +594,14 @@ tNFA_STATUS NFA_P2pReadUI(tNFA_HANDLE handle, uint32_t max_data_len,
   tNFA_STATUS ret_status;
   tNFA_HANDLE xx;
 
-  P2P_TRACE_API1("NFA_P2pReadUI (): handle:0x%X", handle);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_P2pReadUI (): handle:0x%X", handle);
 
   GKI_sched_lock();
 
   xx = handle & NFA_HANDLE_MASK;
 
   if ((xx >= NFA_P2P_NUM_SAP) || (nfa_p2p_cb.sap_cb[xx].p_cback == NULL)) {
-    P2P_TRACE_ERROR1("NFA_P2pReadUI (): Handle (0x%X) is not valid", handle);
+    LOG(ERROR) << StringPrintf("NFA_P2pReadUI (): Handle (0x%X) is not valid", handle);
     ret_status = NFA_STATUS_BAD_HANDLE;
   } else {
     *p_more = LLCP_ReadLogicalLinkData((uint8_t)xx, max_data_len, p_remote_sap,
@@ -609,14 +629,14 @@ tNFA_STATUS NFA_P2pFlushUI(tNFA_HANDLE handle, uint32_t* p_length) {
   tNFA_STATUS ret_status;
   tNFA_HANDLE xx;
 
-  P2P_TRACE_API1("NFA_P2pReadUI (): handle:0x%X", handle);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_P2pReadUI (): handle:0x%X", handle);
 
   GKI_sched_lock();
 
   xx = handle & NFA_HANDLE_MASK;
 
   if ((xx >= NFA_P2P_NUM_SAP) || (nfa_p2p_cb.sap_cb[xx].p_cback == NULL)) {
-    P2P_TRACE_ERROR1("NFA_P2pFlushUI (): Handle (0x%X) is not valid", handle);
+    LOG(ERROR) << StringPrintf("NFA_P2pFlushUI (): Handle (0x%X) is not valid", handle);
     ret_status = NFA_STATUS_BAD_HANDLE;
     *p_length = 0;
   } else {
@@ -649,7 +669,7 @@ tNFA_STATUS NFA_P2pSendData(tNFA_HANDLE handle, uint16_t length,
   tNFA_STATUS ret_status = NFA_STATUS_FAILED;
   tNFA_HANDLE xx;
 
-  P2P_TRACE_API2("NFA_P2pSendData (): handle:0x%X, length:%d", handle, length);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_P2pSendData (): handle:0x%X, length:%d", handle, length);
 
   GKI_sched_lock();
 
@@ -658,20 +678,20 @@ tNFA_STATUS NFA_P2pSendData(tNFA_HANDLE handle, uint16_t length,
 
   if ((!(handle & NFA_P2P_HANDLE_FLAG_CONN)) || (xx >= LLCP_MAX_DATA_LINK) ||
       (nfa_p2p_cb.conn_cb[xx].flags == 0)) {
-    P2P_TRACE_ERROR1("NFA_P2pSendData (): Handle(0x%X) is not valid", handle);
+    LOG(ERROR) << StringPrintf("NFA_P2pSendData (): Handle(0x%X) is not valid", handle);
     ret_status = NFA_STATUS_BAD_HANDLE;
   } else if (nfa_p2p_cb.conn_cb[xx].flags & NFA_P2P_CONN_FLAG_REMOTE_RW_ZERO) {
-    P2P_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "NFA_P2pSendData (): handle:0x%X, Remote set RW to 0 (flow off)",
         handle);
     ret_status = NFA_STATUS_FAILED;
   } else if (nfa_p2p_cb.conn_cb[xx].remote_miu < length) {
-    P2P_TRACE_ERROR2(
+    LOG(ERROR) << StringPrintf(
         "NFA_P2pSendData (): handle:0x%X, Data more than remote MIU(%d)",
         handle, nfa_p2p_cb.conn_cb[xx].remote_miu);
     ret_status = NFA_STATUS_BAD_LENGTH;
   } else if (nfa_p2p_cb.conn_cb[xx].flags & NFA_P2P_CONN_FLAG_CONGESTED) {
-    P2P_TRACE_WARNING1(
+    LOG(WARNING) << StringPrintf(
         "NFA_P2pSendData (): handle:0x%X, data link connection is already "
         "congested",
         handle);
@@ -683,7 +703,7 @@ tNFA_STATUS NFA_P2pSendData(tNFA_HANDLE handle, uint16_t length,
                                       nfa_p2p_cb.total_pending_i_pdu)) {
     nfa_p2p_cb.conn_cb[xx].flags |= NFA_P2P_CONN_FLAG_CONGESTED;
 
-    P2P_TRACE_WARNING1(
+    LOG(WARNING) << StringPrintf(
         "NFA_P2pSendData (): handle:0x%X, data link connection is congested",
         handle);
     ret_status = NFA_STATUS_CONGESTED;
@@ -694,12 +714,12 @@ tNFA_STATUS NFA_P2pSendData(tNFA_HANDLE handle, uint16_t length,
     p_msg->conn_handle = handle;
 
     p_msg->p_msg = (NFC_HDR*)GKI_getpoolbuf(LLCP_POOL_ID);
+
     if (p_msg->p_msg != NULL) {
       p_msg->p_msg->len = length;
       p_msg->p_msg->offset = LLCP_MIN_OFFSET;
       memcpy(((uint8_t*)(p_msg->p_msg + 1) + p_msg->p_msg->offset), p_data,
              length);
-
       /* increase number of tx I PDU which is not processed by NFA for
        * congestion control */
       nfa_p2p_cb.conn_cb[xx].num_pending_i_pdu++;
@@ -743,7 +763,7 @@ tNFA_STATUS NFA_P2pReadData(tNFA_HANDLE handle, uint32_t max_data_len,
   tNFA_STATUS ret_status;
   tNFA_HANDLE xx;
 
-  P2P_TRACE_API1("NFA_P2pReadData (): handle:0x%X", handle);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_P2pReadData (): handle:0x%X", handle);
 
   GKI_sched_lock();
 
@@ -752,7 +772,7 @@ tNFA_STATUS NFA_P2pReadData(tNFA_HANDLE handle, uint32_t max_data_len,
 
   if ((!(handle & NFA_P2P_HANDLE_FLAG_CONN)) || (xx >= LLCP_MAX_DATA_LINK) ||
       (nfa_p2p_cb.conn_cb[xx].flags == 0)) {
-    P2P_TRACE_ERROR1("NFA_P2pReadData (): Handle(0x%X) is not valid", handle);
+    LOG(ERROR) << StringPrintf("NFA_P2pReadData (): Handle(0x%X) is not valid", handle);
     ret_status = NFA_STATUS_BAD_HANDLE;
   } else {
     *p_more = LLCP_ReadDataLinkData(nfa_p2p_cb.conn_cb[xx].local_sap,
@@ -781,7 +801,7 @@ tNFA_STATUS NFA_P2pFlushData(tNFA_HANDLE handle, uint32_t* p_length) {
   tNFA_STATUS ret_status;
   tNFA_HANDLE xx;
 
-  P2P_TRACE_API1("NFA_P2pFlushData (): handle:0x%X", handle);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_P2pFlushData (): handle:0x%X", handle);
 
   GKI_sched_lock();
 
@@ -790,7 +810,7 @@ tNFA_STATUS NFA_P2pFlushData(tNFA_HANDLE handle, uint32_t* p_length) {
 
   if ((!(handle & NFA_P2P_HANDLE_FLAG_CONN)) || (xx >= LLCP_MAX_DATA_LINK) ||
       (nfa_p2p_cb.conn_cb[xx].flags == 0)) {
-    P2P_TRACE_ERROR1("NFA_P2pFlushData (): Handle(0x%X) is not valid", handle);
+    LOG(ERROR) << StringPrintf("NFA_P2pFlushData (): Handle(0x%X) is not valid", handle);
     ret_status = NFA_STATUS_BAD_HANDLE;
   } else {
     *p_length = LLCP_FlushDataLinkRxData(nfa_p2p_cb.conn_cb[xx].local_sap,
@@ -819,20 +839,20 @@ tNFA_STATUS NFA_P2pSetLocalBusy(tNFA_HANDLE conn_handle, bool is_busy) {
   tNFA_P2P_API_SET_LOCAL_BUSY* p_msg;
   tNFA_HANDLE xx;
 
-  P2P_TRACE_API2("NFA_P2pSetLocalBusy (): conn_handle:0x%02X, is_busy:%d",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_P2pSetLocalBusy (): conn_handle:0x%02X, is_busy:%d",
                  conn_handle, is_busy);
 
   xx = conn_handle & NFA_HANDLE_MASK;
 
   if (!(xx & NFA_P2P_HANDLE_FLAG_CONN)) {
-    P2P_TRACE_ERROR0("NFA_P2pSetLocalBusy (): Connection Handle is not valid");
+    LOG(ERROR) << StringPrintf("NFA_P2pSetLocalBusy (): Connection Handle is not valid");
     return (NFA_STATUS_BAD_HANDLE);
   } else {
     xx &= ~NFA_P2P_HANDLE_FLAG_CONN;
   }
 
   if ((xx >= LLCP_MAX_DATA_LINK) || (nfa_p2p_cb.conn_cb[xx].flags == 0)) {
-    P2P_TRACE_ERROR0("NFA_P2pSetLocalBusy (): Connection Handle is not valid");
+    LOG(ERROR) << StringPrintf("NFA_P2pSetLocalBusy (): Connection Handle is not valid");
     return (NFA_STATUS_BAD_HANDLE);
   }
 
@@ -868,17 +888,17 @@ tNFA_STATUS NFA_P2pGetLinkInfo(tNFA_HANDLE handle) {
   tNFA_P2P_API_GET_LINK_INFO* p_msg;
   tNFA_HANDLE xx;
 
-  P2P_TRACE_API1("NFA_P2pGetLinkInfo (): handle:0x%x", handle);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_P2pGetLinkInfo (): handle:0x%x", handle);
 
   if (nfa_p2p_cb.llcp_state != NFA_P2P_LLCP_STATE_ACTIVATED) {
-    P2P_TRACE_ERROR0("NFA_P2pGetLinkInfo (): LLCP link is not activated");
+    LOG(ERROR) << StringPrintf("NFA_P2pGetLinkInfo (): LLCP link is not activated");
     return (NFA_STATUS_FAILED);
   }
 
   xx = handle & NFA_HANDLE_MASK;
 
   if ((xx >= NFA_P2P_NUM_SAP) || (nfa_p2p_cb.sap_cb[xx].p_cback == NULL)) {
-    P2P_TRACE_ERROR0(
+    LOG(ERROR) << StringPrintf(
         "NFA_P2pGetLinkInfo (): Handle is invalid or not registered");
     return (NFA_STATUS_BAD_HANDLE);
   }
@@ -914,18 +934,18 @@ tNFA_STATUS NFA_P2pGetRemoteSap(tNFA_HANDLE handle, char* p_service_name) {
   tNFA_P2P_API_GET_REMOTE_SAP* p_msg;
   tNFA_HANDLE xx;
 
-  P2P_TRACE_API2("NFA_P2pGetRemoteSap(): handle:0x%x, SN:<%s>", handle,
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_P2pGetRemoteSap(): handle:0x%x, SN:<%s>", handle,
                  p_service_name);
 
   if (nfa_p2p_cb.llcp_state != NFA_P2P_LLCP_STATE_ACTIVATED) {
-    P2P_TRACE_ERROR0("NFA_P2pGetRemoteSap(): LLCP link is not activated");
+    LOG(ERROR) << StringPrintf("NFA_P2pGetRemoteSap(): LLCP link is not activated");
     return (NFA_STATUS_FAILED);
   }
 
   xx = handle & NFA_HANDLE_MASK;
 
   if ((xx >= NFA_P2P_NUM_SAP) || (nfa_p2p_cb.sap_cb[xx].p_cback == NULL)) {
-    P2P_TRACE_ERROR0(
+    LOG(ERROR) << StringPrintf(
         "NFA_P2pGetRemoteSap (): Handle is invalid or not registered");
     return (NFA_STATUS_BAD_HANDLE);
   }
@@ -982,18 +1002,18 @@ tNFA_STATUS NFA_P2pSetLLCPConfig(uint16_t link_miu, uint8_t opt, uint8_t wt,
                                  uint16_t delay_first_pdu_timeout) {
   tNFA_P2P_API_SET_LLCP_CFG* p_msg;
 
-  P2P_TRACE_API4(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "NFA_P2pSetLLCPConfig ():link_miu:%d, opt:0x%02X, wt:%d, link_timeout:%d",
       link_miu, opt, wt, link_timeout);
-  P2P_TRACE_API4(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "                       inact_timeout(init:%d, target:%d), "
       "symm_delay:%d, data_link_timeout:%d",
       inact_timeout_init, inact_timeout_target, symm_delay, data_link_timeout);
-  P2P_TRACE_API1("                       delay_first_pdu_timeout:%d",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("                       delay_first_pdu_timeout:%d",
                  delay_first_pdu_timeout);
 
   if (nfa_p2p_cb.llcp_state == NFA_P2P_LLCP_STATE_ACTIVATED) {
-    P2P_TRACE_ERROR0("NFA_P2pSetLLCPConfig (): LLCP link is activated");
+    LOG(ERROR) << StringPrintf("NFA_P2pSetLLCPConfig (): LLCP link is activated");
     return (NFA_STATUS_FAILED);
   }
 
@@ -1049,29 +1069,13 @@ void NFA_P2pGetLLCPConfig(uint16_t* p_link_miu, uint8_t* p_opt, uint8_t* p_wt,
                  p_inact_timeout_target, p_symm_delay, p_data_link_timeout,
                  p_delay_first_pdu_timeout);
 
-  P2P_TRACE_API4(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "NFA_P2pGetLLCPConfig () link_miu:%d, opt:0x%02X, wt:%d, link_timeout:%d",
       *p_link_miu, *p_opt, *p_wt, *p_link_timeout);
-  P2P_TRACE_API4(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "                       inact_timeout(init:%d, target:%d), "
       "symm_delay:%d, data_link_timeout:%d",
       *p_inact_timeout_init, *p_inact_timeout_target, *p_symm_delay,
       *p_data_link_timeout);
-  P2P_TRACE_API1("delay_first_pdu_timeout:%d", *p_delay_first_pdu_timeout);
-}
-
-/*******************************************************************************
-**
-** Function         NFA_P2pSetTraceLevel
-**
-** Description      This function sets the trace level for P2P.  If called with
-**                  a value of 0xFF, it simply returns the current trace level.
-**
-** Returns          The new or current trace level
-**
-*******************************************************************************/
-uint8_t NFA_P2pSetTraceLevel(uint8_t new_level) {
-  if (new_level != 0xFF) nfa_p2p_cb.trace_level = new_level;
-
-  return (nfa_p2p_cb.trace_level);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("delay_first_pdu_timeout:%d", *p_delay_first_pdu_timeout);
 }
diff --git a/src/nfa/p2p/nfa_p2p_main.c b/src/nfa/p2p/nfa_p2p_main.cc
old mode 100644
new mode 100755
similarity index 78%
rename from src/nfa/p2p/nfa_p2p_main.c
rename to src/nfa/p2p/nfa_p2p_main.cc
index a6207a1..e27a5a1
--- a/src/nfa/p2p/nfa_p2p_main.c
+++ b/src/nfa/p2p/nfa_p2p_main.cc
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -41,15 +41,17 @@
  *
  ******************************************************************************/
 #include <string.h>
-#include "nfc_api.h"
-#include "nfa_sys.h"
-#include "nfa_sys_int.h"
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
 #include "nfa_dm_int.h"
 #include "llcp_api.h"
-#include "llcp_defs.h"
-#include "nfa_p2p_api.h"
 #include "nfa_p2p_int.h"
 
+
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+
 /*****************************************************************************
 **  Global Variables
 *****************************************************************************/
@@ -69,9 +71,8 @@ static void nfa_p2p_sys_disable(void);
 static void nfa_p2p_update_active_listen(void);
 
 /* debug functions type */
-#if (BT_TRACE_VERBOSE == true)
-static char* nfa_p2p_llcp_state_code(tNFA_P2P_LLCP_STATE state_code);
-#endif
+static std::string nfa_p2p_llcp_state_code(tNFA_P2P_LLCP_STATE state_code);
+static std::string nfa_p2p_evt_code(uint16_t evt_code);
 
 /*****************************************************************************
 **  Constants
@@ -118,7 +119,7 @@ const tNFA_P2P_ACTION nfa_p2p_action[] = {
 void nfa_p2p_discovery_cback(tNFA_DM_RF_DISC_EVT event, tNFC_DISCOVER* p_data) {
   tNFA_CONN_EVT_DATA evt_data;
 
-  P2P_TRACE_DEBUG1("nfa_p2p_discovery_cback (): event:0x%02X", event);
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_discovery_cback (): event:0x%02X", event);
 
   switch (event) {
     case NFA_DM_RF_DISC_START_EVT:
@@ -169,7 +170,7 @@ void nfa_p2p_discovery_cback(tNFA_DM_RF_DISC_EVT event, tNFC_DISCOVER* p_data) {
       break;
 
     default:
-      P2P_TRACE_ERROR0("Unexpected event");
+      LOG(ERROR) << StringPrintf("Unexpected event");
       break;
   }
 }
@@ -183,10 +184,9 @@ void nfa_p2p_discovery_cback(tNFA_DM_RF_DISC_EVT event, tNFC_DISCOVER* p_data) {
 ** Returns          void
 **
 *******************************************************************************/
-static void nfa_p2p_update_active_listen_timeout_cback(TIMER_LIST_ENT* p_tle) {
-  (void)p_tle;
-
-  NFA_TRACE_ERROR0("nfa_p2p_update_active_listen_timeout_cback()");
+static void nfa_p2p_update_active_listen_timeout_cback(__attribute__((unused))
+                                                        TIMER_LIST_ENT* p_tle) {
+  LOG(ERROR) << StringPrintf("nfa_p2p_update_active_listen_timeout_cback()");
 
   /* restore active listen mode */
   nfa_p2p_update_active_listen();
@@ -206,7 +206,7 @@ static void nfa_p2p_update_active_listen(void) {
   tNFA_DM_DISC_TECH_PROTO_MASK p2p_listen_mask = 0;
   NFC_HDR* p_msg;
 
-  P2P_TRACE_DEBUG1(
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "nfa_p2p_update_active_listen (): listen_tech_mask_to_restore:0x%x",
       nfa_p2p_cb.listen_tech_mask_to_restore);
 
@@ -227,8 +227,12 @@ static void nfa_p2p_update_active_listen(void) {
     nfa_p2p_cb.listen_tech_mask_to_restore = nfa_p2p_cb.listen_tech_mask;
 
     /* remove active listen mode */
-    nfa_p2p_cb.listen_tech_mask &=
-        ~(NFA_TECHNOLOGY_MASK_A_ACTIVE | NFA_TECHNOLOGY_MASK_F_ACTIVE);
+    if (NFC_GetNCIVersion() == NCI_VERSION_2_0) {
+      nfa_p2p_cb.listen_tech_mask &= ~(NFA_TECHNOLOGY_MASK_ACTIVE);
+    } else {
+      nfa_p2p_cb.listen_tech_mask &=
+          ~(NFA_TECHNOLOGY_MASK_A_ACTIVE | NFA_TECHNOLOGY_MASK_F_ACTIVE);
+    }
   }
 
   if (nfa_p2p_cb.dm_disc_handle != NFA_HANDLE_INVALID) {
@@ -242,29 +246,31 @@ static void nfa_p2p_update_active_listen(void) {
 
   if (nfa_p2p_cb.listen_tech_mask & NFA_TECHNOLOGY_MASK_F)
     p2p_listen_mask |= NFA_DM_DISC_MASK_LF_NFC_DEP;
+  if (NFC_GetNCIVersion() == NCI_VERSION_2_0) {
+    if (nfa_p2p_cb.listen_tech_mask & NFA_TECHNOLOGY_MASK_ACTIVE)
+      p2p_listen_mask |= NFA_DM_DISC_MASK_LACM_NFC_DEP;
+  } else {
+    if (nfa_p2p_cb.listen_tech_mask & NFA_TECHNOLOGY_MASK_A_ACTIVE)
+      p2p_listen_mask |= NFA_DM_DISC_MASK_LAA_NFC_DEP;
+    if (nfa_p2p_cb.listen_tech_mask & NFA_TECHNOLOGY_MASK_F_ACTIVE)
+      p2p_listen_mask |= NFA_DM_DISC_MASK_LFA_NFC_DEP;
+  }
 
-  if (nfa_p2p_cb.listen_tech_mask & NFA_TECHNOLOGY_MASK_A_ACTIVE)
-    p2p_listen_mask |= NFA_DM_DISC_MASK_LAA_NFC_DEP;
-
-  if (nfa_p2p_cb.listen_tech_mask & NFA_TECHNOLOGY_MASK_F_ACTIVE)
-    p2p_listen_mask |= NFA_DM_DISC_MASK_LFA_NFC_DEP;
+  /* For P2P mode(Default DTA mode) open Raw channel to bypass LLCP layer. For
+   * LLCP DTA mode activate LLCP Bypassing LLCP is handled in
+   * nfa_dm_poll_disc_cback */
 
-#if (NXP_EXTNS == TRUE)
-  /*For P2P mode(Default DTA mode) open Raw channel to bypass LLCP layer. For
-   * LLCP DTA mode activate LLCP
-   * Bypassing LLCP is handled in nfa_dm_poll_disc_cback*/
-  if ((appl_dta_mode_flag == 1) &&
+  if (appl_dta_mode_flag == 1 &&
       ((nfa_dm_cb.eDtaMode & 0x0F) == NFA_DTA_DEFAULT_MODE)) {
-    /* Configure listen technologies and protocols and register callback to NFA
-     * DM discovery */
-    P2P_TRACE_DEBUG0(
-        "DTA mode1:Registering nfa_dm_poll_disc_cback to avoid LLCP in P2P ");
+    // Configure listen technologies and protocols and register callback to DTA
+
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "%s: DTA mode:Registering nfa_dm_poll_disc_cback to avoid LLCP in P2P",
+        __func__);
     nfa_p2p_cb.dm_disc_handle =
         nfa_dm_add_rf_discover(p2p_listen_mask, NFA_DM_DISC_HOST_ID_DH,
                                nfa_dm_poll_disc_cback_dta_wrapper);
-  } else
-#endif
-  {
+  } else {
     /* Configure listen technologies and protocols and register callback to NFA
      * DM discovery */
     nfa_p2p_cb.dm_disc_handle = nfa_dm_add_rf_discover(
@@ -293,7 +299,7 @@ void nfa_p2p_llcp_link_cback(uint8_t event, uint8_t reason) {
   tNFA_LLCP_ACTIVATED llcp_activated;
   tNFA_LLCP_DEACTIVATED llcp_deactivated;
 
-  P2P_TRACE_DEBUG2("nfa_p2p_llcp_link_cback () event:0x%x, reason:0x%x", event,
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_llcp_link_cback () event:0x%x, reason:0x%x", event,
                    reason);
 
   if (event == LLCP_LINK_ACTIVATION_COMPLETE_EVT) {
@@ -312,8 +318,9 @@ void nfa_p2p_llcp_link_cback(uint8_t event, uint8_t reason) {
     llcp_activated.remote_wks = LLCP_GetRemoteWKS();
     llcp_activated.remote_version = LLCP_GetRemoteVersion();
 
-    nfa_dm_act_conn_cback_notify(NFA_LLCP_ACTIVATED_EVT,
-                                 (void*)&llcp_activated);
+    tNFA_CONN_EVT_DATA nfa_conn_evt_data;
+    nfa_conn_evt_data.llcp_activated = llcp_activated;
+    nfa_dm_act_conn_cback_notify(NFA_LLCP_ACTIVATED_EVT, &nfa_conn_evt_data);
 
   } else if (event == LLCP_LINK_ACTIVATION_FAILED_EVT) {
     nfa_p2p_cb.llcp_state = NFA_P2P_LLCP_STATE_IDLE;
@@ -339,7 +346,7 @@ void nfa_p2p_llcp_link_cback(uint8_t event, uint8_t reason) {
         if ((nfa_p2p_cb.listen_tech_mask_to_restore == 0x00) &&
             (nfa_p2p_cb.listen_tech_mask &
              (NFA_TECHNOLOGY_MASK_A | NFA_TECHNOLOGY_MASK_F))) {
-          P2P_TRACE_DEBUG0("Retry without active listen mode");
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Retry without active listen mode");
 
           /* retry without active listen mode */
           nfa_p2p_update_active_listen();
@@ -358,29 +365,26 @@ void nfa_p2p_llcp_link_cback(uint8_t event, uint8_t reason) {
     }
 
     llcp_deactivated.reason = reason;
-    nfa_dm_act_conn_cback_notify(NFA_LLCP_DEACTIVATED_EVT,
-                                 (void*)&llcp_deactivated);
+    tNFA_CONN_EVT_DATA nfa_conn_evt_data;
+    nfa_conn_evt_data.llcp_deactivated = llcp_deactivated;
+    nfa_dm_act_conn_cback_notify(NFA_LLCP_DEACTIVATED_EVT, &nfa_conn_evt_data);
 
     if (reason != LLCP_LINK_RF_LINK_LOSS_ERR) /* if NFC link is still up */
     {
       if (nfa_p2p_cb.is_initiator) {
-#if (NXP_EXTNS == TRUE)
         /*For LLCP DTA test, Deactivate to Sleep is needed to send DSL_REQ*/
-        if ((appl_dta_mode_flag == 1) &&
+        if (appl_dta_mode_flag == 1 &&
             ((nfa_dm_cb.eDtaMode & 0x0F) == NFA_DTA_LLCP_MODE)) {
           nfa_dm_rf_deactivate(NFA_DEACTIVATE_TYPE_SLEEP);
         } else {
-#endif
           nfa_dm_rf_deactivate(NFA_DEACTIVATE_TYPE_DISCOVERY);
-#if (NXP_EXTNS == TRUE)
         }
-#endif
       } else if ((nfa_p2p_cb.is_active_mode) && (reason == LLCP_LINK_TIMEOUT)) {
         /*
         ** target needs to trun off RF in case of receiving invalid
         ** frame from initiator
         */
-        P2P_TRACE_DEBUG0("Got LLCP_LINK_TIMEOUT in active mode on target");
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Got LLCP_LINK_TIMEOUT in active mode on target");
         nfa_dm_rf_deactivate(NFA_DEACTIVATE_TYPE_DISCOVERY);
       }
     }
@@ -400,30 +404,48 @@ void nfa_p2p_llcp_link_cback(uint8_t event, uint8_t reason) {
 void nfa_p2p_activate_llcp(tNFC_DISCOVER* p_data) {
   tLLCP_ACTIVATE_CONFIG config;
 
-  P2P_TRACE_DEBUG0("nfa_p2p_activate_llcp ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_activate_llcp ()");
 
   if ((p_data->activate.rf_tech_param.mode == NFC_DISCOVERY_TYPE_POLL_A) ||
-      (p_data->activate.rf_tech_param.mode == NFC_DISCOVERY_TYPE_POLL_F) ||
-      (p_data->activate.rf_tech_param.mode ==
-       NFC_DISCOVERY_TYPE_POLL_A_ACTIVE) ||
-      (p_data->activate.rf_tech_param.mode ==
-       NFC_DISCOVERY_TYPE_POLL_F_ACTIVE)) {
+      (p_data->activate.rf_tech_param.mode == NFC_DISCOVERY_TYPE_POLL_F)) {
     config.is_initiator = true;
   } else {
     config.is_initiator = false;
   }
-
-  if ((p_data->activate.rf_tech_param.mode ==
-       NFC_DISCOVERY_TYPE_POLL_A_ACTIVE) ||
-      (p_data->activate.rf_tech_param.mode ==
-       NFC_DISCOVERY_TYPE_POLL_F_ACTIVE) ||
-      (p_data->activate.rf_tech_param.mode ==
-       NFC_DISCOVERY_TYPE_LISTEN_A_ACTIVE) ||
-      (p_data->activate.rf_tech_param.mode ==
-       NFC_DISCOVERY_TYPE_LISTEN_F_ACTIVE)) {
-    nfa_p2p_cb.is_active_mode = true;
+  if (NFC_GetNCIVersion() == NCI_VERSION_2_0) {
+    if (p_data->activate.rf_tech_param.mode == NFC_DISCOVERY_TYPE_POLL_ACTIVE) {
+      config.is_initiator = true;
+    }
   } else {
-    nfa_p2p_cb.is_active_mode = false;
+    if ((p_data->activate.rf_tech_param.mode ==
+         NFC_DISCOVERY_TYPE_POLL_A_ACTIVE) ||
+        (p_data->activate.rf_tech_param.mode ==
+         NFC_DISCOVERY_TYPE_POLL_F_ACTIVE)) {
+      config.is_initiator = true;
+    }
+  }
+  if (NFC_GetNCIVersion() == NCI_VERSION_2_0) {
+    if ((p_data->activate.rf_tech_param.mode ==
+         NFC_DISCOVERY_TYPE_POLL_ACTIVE) ||
+        (p_data->activate.rf_tech_param.mode ==
+         NFC_DISCOVERY_TYPE_LISTEN_ACTIVE)) {
+      nfa_p2p_cb.is_active_mode = true;
+    } else {
+      nfa_p2p_cb.is_active_mode = false;
+    }
+  } else {
+    if ((p_data->activate.rf_tech_param.mode ==
+         NFC_DISCOVERY_TYPE_POLL_A_ACTIVE) ||
+        (p_data->activate.rf_tech_param.mode ==
+         NFC_DISCOVERY_TYPE_POLL_F_ACTIVE) ||
+        (p_data->activate.rf_tech_param.mode ==
+         NFC_DISCOVERY_TYPE_LISTEN_A_ACTIVE) ||
+        (p_data->activate.rf_tech_param.mode ==
+         NFC_DISCOVERY_TYPE_LISTEN_F_ACTIVE)) {
+      nfa_p2p_cb.is_active_mode = true;
+    } else {
+      nfa_p2p_cb.is_active_mode = false;
+    }
   }
 
   nfa_p2p_cb.is_initiator = config.is_initiator;
@@ -450,7 +472,7 @@ void nfa_p2p_activate_llcp(tNFC_DISCOVER* p_data) {
 **
 *******************************************************************************/
 void nfa_p2p_deactivate_llcp(void) {
-  P2P_TRACE_DEBUG0("nfa_p2p_deactivate_llcp ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_deactivate_llcp ()");
 
   LLCP_DeactivateLink();
 }
@@ -468,12 +490,11 @@ void nfa_p2p_deactivate_llcp(void) {
 void nfa_p2p_init(void) {
   uint8_t xx;
 
-  P2P_TRACE_DEBUG0("nfa_p2p_init ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_init ()");
 
   /* initialize control block */
   memset(&nfa_p2p_cb, 0, sizeof(tNFA_P2P_CB));
   nfa_p2p_cb.dm_disc_handle = NFA_HANDLE_INVALID;
-  nfa_p2p_cb.trace_level = APPL_INITIAL_TRACE_LEVEL;
 
   for (xx = 0; xx < LLCP_MAX_SDP_TRANSAC; xx++) {
     nfa_p2p_cb.sdp_cb[xx].local_sap = LLCP_INVALID_SAP;
@@ -494,7 +515,7 @@ void nfa_p2p_init(void) {
 **
 *******************************************************************************/
 static void nfa_p2p_sys_disable(void) {
-  P2P_TRACE_DEBUG0("nfa_p2p_sys_disable()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_sys_disable()");
 
   nfa_sys_stop_timer(&nfa_p2p_cb.active_listen_restore_timer);
 
@@ -516,16 +537,20 @@ void nfa_p2p_set_config(tNFA_DM_DISC_TECH_PROTO_MASK disc_mask) {
   uint8_t wt, gen_bytes_len = LLCP_MAX_GEN_BYTES;
   uint8_t params[LLCP_MAX_GEN_BYTES + 5], *p, length;
 
-  P2P_TRACE_DEBUG0("nfa_p2p_set_config ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_set_config ()");
 
   LLCP_GetDiscoveryConfig(&wt, params + 2, &gen_bytes_len);
   if (nfa_dm_is_p2p_paused()) {
     gen_bytes_len = 0;
   }
 
-  if (disc_mask &
-      (NFA_DM_DISC_MASK_PA_NFC_DEP | NFA_DM_DISC_MASK_PF_NFC_DEP |
-       NFA_DM_DISC_MASK_PAA_NFC_DEP | NFA_DM_DISC_MASK_PFA_NFC_DEP)) {
+  if ((disc_mask &
+       (NFA_DM_DISC_MASK_PA_NFC_DEP | NFA_DM_DISC_MASK_PF_NFC_DEP)) ||
+      ((NFC_GetNCIVersion() == NCI_VERSION_2_0) &&
+       (disc_mask & NFA_DM_DISC_MASK_PACM_NFC_DEP)) ||
+      ((NFC_GetNCIVersion() != NCI_VERSION_2_0) &&
+       (disc_mask &
+        (NFA_DM_DISC_MASK_PAA_NFC_DEP | NFA_DM_DISC_MASK_PFA_NFC_DEP)))) {
     p = params;
 
     UINT8_TO_BE_STREAM(p, NFC_PMID_ATR_REQ_GEN_BYTES);
@@ -537,9 +562,13 @@ void nfa_p2p_set_config(tNFA_DM_DISC_TECH_PROTO_MASK disc_mask) {
     nfa_dm_check_set_config(length, params, false);
   }
 
-  if (disc_mask &
-      (NFA_DM_DISC_MASK_LA_NFC_DEP | NFA_DM_DISC_MASK_LF_NFC_DEP |
-       NFA_DM_DISC_MASK_LAA_NFC_DEP | NFA_DM_DISC_MASK_LFA_NFC_DEP)) {
+  if ((disc_mask &
+       (NFA_DM_DISC_MASK_LA_NFC_DEP | NFA_DM_DISC_MASK_LF_NFC_DEP)) ||
+      ((NFC_GetNCIVersion() == NCI_VERSION_2_0) &&
+       (disc_mask & NFA_DM_DISC_MASK_LACM_NFC_DEP)) ||
+      ((NFC_GetNCIVersion() != NCI_VERSION_2_0) &&
+       (disc_mask &
+        (NFA_DM_DISC_MASK_LFA_NFC_DEP | NFA_DM_DISC_MASK_LAA_NFC_DEP)))) {
     p = params;
 
     UINT8_TO_BE_STREAM(p, NFC_PMID_ATR_RES_GEN_BYTES);
@@ -571,7 +600,7 @@ void nfa_p2p_set_config(tNFA_DM_DISC_TECH_PROTO_MASK disc_mask) {
 void nfa_p2p_enable_listening(tNFA_SYS_ID sys_id, bool update_wks) {
   tNFA_DM_DISC_TECH_PROTO_MASK p2p_listen_mask = 0;
 
-  P2P_TRACE_DEBUG2("nfa_p2p_enable_listening () sys_id = %d, update_wks = %d",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_enable_listening () sys_id = %d, update_wks = %d",
                    sys_id, update_wks);
 
   if (sys_id == NFA_ID_P2P)
@@ -596,29 +625,33 @@ void nfa_p2p_enable_listening(tNFA_SYS_ID sys_id, bool update_wks) {
   if (nfa_p2p_cb.listen_tech_mask & NFA_TECHNOLOGY_MASK_F)
     p2p_listen_mask |= NFA_DM_DISC_MASK_LF_NFC_DEP;
 
-  if (nfa_p2p_cb.listen_tech_mask & NFA_TECHNOLOGY_MASK_A_ACTIVE)
-    p2p_listen_mask |= NFA_DM_DISC_MASK_LAA_NFC_DEP;
+  if (NFC_GetNCIVersion() == NCI_VERSION_2_0) {
+    if (nfa_p2p_cb.listen_tech_mask & NFA_TECHNOLOGY_MASK_ACTIVE)
+      p2p_listen_mask |= NFA_DM_DISC_MASK_LACM_NFC_DEP;
+  } else {
+    if (nfa_p2p_cb.listen_tech_mask & NFA_TECHNOLOGY_MASK_A_ACTIVE)
+      p2p_listen_mask |= NFA_DM_DISC_MASK_LAA_NFC_DEP;
 
-  if (nfa_p2p_cb.listen_tech_mask & NFA_TECHNOLOGY_MASK_F_ACTIVE)
-    p2p_listen_mask |= NFA_DM_DISC_MASK_LFA_NFC_DEP;
+    if (nfa_p2p_cb.listen_tech_mask & NFA_TECHNOLOGY_MASK_F_ACTIVE)
+      p2p_listen_mask |= NFA_DM_DISC_MASK_LFA_NFC_DEP;
+  }
 
   if (p2p_listen_mask) {
-#if (NXP_EXTNS == TRUE)
-    /*For P2P mode(Default DTA mode) open Raw channel to bypass LLCP layer. For
-     * LLCP DTA mode activate LLCP
-     * Bypassing LLCP is handled in nfa_dm_poll_disc_cback*/
-    if ((appl_dta_mode_flag == 1) &&
+    /* For P2P mode(Default DTA mode) open Raw channel to bypass LLCP layer.
+     * For LLCP DTA mode activate LLCP Bypassing LLCP is handled in
+     * nfa_dm_poll_disc_cback */
+    if (appl_dta_mode_flag == 1 &&
         ((nfa_dm_cb.eDtaMode & 0x0F) == NFA_DTA_DEFAULT_MODE)) {
       /* Configure listen technologies and protocols and register callback to
        * NFA DM discovery */
-      P2P_TRACE_DEBUG0(
-          "DTA mode2:Registering nfa_dm_poll_disc_cback to avoid LLCP in P2P ");
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s: DTA mode:Registering nfa_dm_poll_disc_cback to avoid LLCP in "
+          "P2P",
+          __func__);
       nfa_p2p_cb.dm_disc_handle =
           nfa_dm_add_rf_discover(p2p_listen_mask, NFA_DM_DISC_HOST_ID_DH,
                                  nfa_dm_poll_disc_cback_dta_wrapper);
-    } else
-#endif
-    {
+    } else {
       /* Configure listen technologies and protocols and register callback to
        * NFA DM discovery */
       nfa_p2p_cb.dm_disc_handle = nfa_dm_add_rf_discover(
@@ -640,7 +673,7 @@ void nfa_p2p_enable_listening(tNFA_SYS_ID sys_id, bool update_wks) {
 **
 *******************************************************************************/
 void nfa_p2p_disable_listening(tNFA_SYS_ID sys_id, bool update_wks) {
-  P2P_TRACE_DEBUG2("nfa_p2p_disable_listening ()  sys_id = %d, update_wks = %d",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_disable_listening ()  sys_id = %d, update_wks = %d",
                    sys_id, update_wks);
 
   if (sys_id == NFA_ID_P2P)
@@ -675,7 +708,7 @@ void nfa_p2p_disable_listening(tNFA_SYS_ID sys_id, bool update_wks) {
 **
 *******************************************************************************/
 void nfa_p2p_update_listen_tech(tNFA_TECHNOLOGY_MASK tech_mask) {
-  P2P_TRACE_DEBUG1("nfa_p2p_update_listen_tech ()  tech_mask = 0x%x",
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_update_listen_tech ()  tech_mask = 0x%x",
                    tech_mask);
 
   if (nfa_p2p_cb.listen_tech_mask_to_restore) {
@@ -694,11 +727,7 @@ void nfa_p2p_update_listen_tech(tNFA_TECHNOLOGY_MASK tech_mask) {
     }
 
     /* restart discovery without updating sub-module status */
-    if (nfa_p2p_cb.is_p2p_listening
-#if (NXP_EXTNS == TRUE)
-        || appl_dta_mode_flag
-#endif
-        )
+    if (nfa_p2p_cb.is_p2p_listening || appl_dta_mode_flag)
       nfa_p2p_enable_listening(NFA_ID_P2P, false);
     else if (nfa_p2p_cb.is_snep_listening)
       nfa_p2p_enable_listening(NFA_ID_SNEP, false);
@@ -719,30 +748,23 @@ static bool nfa_p2p_evt_hdlr(NFC_HDR* p_hdr) {
   bool delete_msg = true;
   uint16_t event;
 
-  tNFA_P2P_MSG* p_msg = (tNFA_P2P_MSG*)p_hdr;
-
-#if (BT_TRACE_VERBOSE == true)
-  P2P_TRACE_DEBUG2("nfa_p2p_evt_hdlr (): LLCP State [%s], Event [%s]",
-                   nfa_p2p_llcp_state_code(nfa_p2p_cb.llcp_state),
-                   nfa_p2p_evt_code(p_msg->hdr.event));
-#else
-  P2P_TRACE_DEBUG2("nfa_p2p_evt_hdlr (): State 0x%02x, Event 0x%02x",
-                   nfa_p2p_cb.llcp_state, p_msg->hdr.event);
-#endif
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_p2p_evt_hdlr (): LLCP State [%s], Event [%s]",
+                   nfa_p2p_llcp_state_code(nfa_p2p_cb.llcp_state).c_str(),
+                   nfa_p2p_evt_code(p_hdr->event).c_str());
 
-  event = p_msg->hdr.event & 0x00ff;
+  event = p_hdr->event & 0x00ff;
 
   /* execute action functions */
   if (event < NFA_P2P_NUM_ACTIONS) {
+    tNFA_P2P_MSG* p_msg = (tNFA_P2P_MSG*)p_hdr;
     delete_msg = (*nfa_p2p_action[event])(p_msg);
   } else {
-    P2P_TRACE_ERROR0("Unhandled event");
+    LOG(ERROR) << StringPrintf("Unhandled event");
   }
 
   return delete_msg;
 }
 
-#if (BT_TRACE_VERBOSE == true)
 /*******************************************************************************
 **
 ** Function         nfa_p2p_llcp_state_code
@@ -752,7 +774,7 @@ static bool nfa_p2p_evt_hdlr(NFC_HDR* p_hdr) {
 ** Returns          string of state
 **
 *******************************************************************************/
-static char* nfa_p2p_llcp_state_code(tNFA_P2P_LLCP_STATE state_code) {
+static std::string nfa_p2p_llcp_state_code(tNFA_P2P_LLCP_STATE state_code) {
   switch (state_code) {
     case NFA_P2P_LLCP_STATE_IDLE:
       return "Link IDLE";
@@ -774,7 +796,7 @@ static char* nfa_p2p_llcp_state_code(tNFA_P2P_LLCP_STATE state_code) {
 ** Returns          string of event
 **
 *******************************************************************************/
-char* nfa_p2p_evt_code(uint16_t evt_code) {
+static std::string nfa_p2p_evt_code(uint16_t evt_code) {
   switch (evt_code) {
     case NFA_P2P_API_REG_SERVER_EVT:
       return "API_REG_SERVER";
@@ -807,5 +829,4 @@ char* nfa_p2p_evt_code(uint16_t evt_code) {
     default:
       return "Unknown event";
   }
-}
-#endif /* Debug Functions */
+}
\ No newline at end of file
diff --git a/src/nfa/rw/nfa_rw_act.c b/src/nfa/rw/nfa_rw_act.cc
similarity index 92%
rename from src/nfa/rw/nfa_rw_act.c
rename to src/nfa/rw/nfa_rw_act.cc
index afad221..08646cd 100644
--- a/src/nfa/rw/nfa_rw_act.c
+++ b/src/nfa/rw/nfa_rw_act.cc
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -40,15 +40,25 @@
  *
  ******************************************************************************/
 #include <string.h>
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfa_rw_int.h"
 #include "nfa_dm_int.h"
-#include "nfa_sys_int.h"
 #include "nfa_mem_co.h"
 #include "ndef_utils.h"
-#include "rw_api.h"
+
+
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
 
 #define NFA_RW_OPTION_INVALID 0xFF
 
+/* Tag sleep req cmd*/
+uint8_t NFA_RW_TAG_SLP_REQ[] = {0x50, 0x00};
+
 /* Local static function prototypes */
 static tNFC_STATUS nfa_rw_start_ndef_read(void);
 static tNFC_STATUS nfa_rw_start_ndef_write(void);
@@ -58,7 +68,7 @@ static bool nfa_rw_op_req_while_busy(tNFA_RW_MSG* p_data);
 static void nfa_rw_error_cleanup(uint8_t event);
 static void nfa_rw_presence_check(tNFA_RW_MSG* p_data);
 static void nfa_rw_handle_t2t_evt(tRW_EVENT event, tRW_DATA* p_rw_data);
-static bool nfa_rw_detect_ndef(tNFA_RW_MSG* p_data);
+static bool nfa_rw_detect_ndef();
 static void nfa_rw_cback(tRW_EVENT event, tRW_DATA* p_rw_data);
 
 /*******************************************************************************
@@ -90,12 +100,12 @@ static void nfa_rw_store_ndef_rx_buf(tRW_DATA* p_rw_data) {
   uint8_t* p;
 
   if (NULL == p_rw_data) {
-    NFA_TRACE_DEBUG0("nfa_rw_store_ndef_rx_buf;  p_rw_data is NULL");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_rw_store_ndef_rx_buf;  p_rw_data is NULL");
     return;
   }
 
   if (NULL == p_rw_data->data.p_data) {
-    NFA_TRACE_DEBUG0(
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "nfa_rw_store_ndef_rx_buf;  p_rw_data->data.p_data is NULL");
     return;
   }
@@ -126,14 +136,9 @@ static void nfa_rw_send_data_to_upper(tRW_DATA* p_rw_data) {
       (p_rw_data->data.p_data == NULL))
     return;
 
-#if (BT_TRACE_VERBOSE == true)
-  NFA_TRACE_DEBUG2("nfa_rw_send_data_to_upper: Len [0x%X] Status [%s]",
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_rw_send_data_to_upper: Len [0x%X] Status [%s]",
                    p_rw_data->data.p_data->len,
-                   NFC_GetStatusName(p_rw_data->data.status));
-#else
-  NFA_TRACE_DEBUG2("nfa_rw_send_data_to_upper: Len [0x%X] Status [0x%X]",
-                   p_rw_data->data.p_data->len, p_rw_data->data.status);
-#endif
+                   NFC_GetStatusName(p_rw_data->data.status).c_str());
 
   /* Notify conn cback of NFA_DATA_EVT */
   conn_evt_data.data.status = p_rw_data->data.status;
@@ -181,7 +186,7 @@ static void nfa_rw_check_start_presence_check_timer(
 
   if (nfa_rw_cb.flags & NFA_RW_FL_NOT_EXCL_RF_MODE) {
     if (presence_check_start_delay) {
-      NFA_TRACE_DEBUG0("Starting presence check timer...");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Starting presence check timer...");
       nfa_sys_start_timer(&nfa_rw_cb.tle, NFA_RW_PRESENCE_CHECK_TICK_EVT,
                           presence_check_start_delay);
     } else {
@@ -202,7 +207,7 @@ static void nfa_rw_check_start_presence_check_timer(
 *******************************************************************************/
 void nfa_rw_stop_presence_check_timer(void) {
   nfa_sys_stop_timer(&nfa_rw_cb.tle);
-  NFA_TRACE_DEBUG0("Stopped presence check timer (if started)");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Stopped presence check timer (if started)");
 }
 
 /*******************************************************************************
@@ -214,10 +219,9 @@ void nfa_rw_stop_presence_check_timer(void) {
 ** Returns          Nothing
 **
 *******************************************************************************/
-static void nfa_rw_handle_ndef_detect(tRW_EVENT event, tRW_DATA* p_rw_data) {
+static void nfa_rw_handle_ndef_detect(tRW_DATA* p_rw_data) {
   tNFA_CONN_EVT_DATA conn_evt_data;
-  (void)event;
-  NFA_TRACE_DEBUG3(
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "NDEF Detection completed: cur_size=%i, max_size=%i, flags=0x%x",
       p_rw_data->ndef.cur_size, p_rw_data->ndef.max_size,
       p_rw_data->ndef.flags);
@@ -325,9 +329,8 @@ static void nfa_rw_handle_ndef_detect(tRW_EVENT event, tRW_DATA* p_rw_data) {
 ** Returns          Nothing
 **
 *******************************************************************************/
-static void nfa_rw_handle_tlv_detect(tRW_EVENT event, tRW_DATA* p_rw_data) {
+static void nfa_rw_handle_tlv_detect(tRW_DATA* p_rw_data) {
   tNFA_CONN_EVT_DATA conn_evt_data;
-  (void)event;
   /* Set TLV detection state */
   if (nfa_rw_cb.cur_op == NFA_RW_OP_SET_TAG_RO) {
     if (nfa_rw_cb.tlv_st == NFA_RW_TLV_DETECT_ST_OP_NOT_STARTED) {
@@ -345,7 +348,7 @@ static void nfa_rw_handle_tlv_detect(tRW_EVENT event, tRW_DATA* p_rw_data) {
 
   /* Check if TLV detection succeeded */
   if (p_rw_data->tlv.status == NFC_STATUS_OK) {
-    NFA_TRACE_DEBUG1("TLV Detection succeeded: num_bytes=%i",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("TLV Detection succeeded: num_bytes=%i",
                      p_rw_data->tlv.num_bytes);
 
     /* Store tlv properties */
@@ -404,12 +407,12 @@ void nfa_rw_handle_sleep_wakeup_rsp(tNFC_STATUS status) {
       (nfa_rw_cb.activated_tech_mode == NFC_DISCOVERY_TYPE_POLL_A) &&
       (nfa_rw_cb.protocol == NFC_PROTOCOL_T2T) &&
       (nfa_rw_cb.pa_sel_res == NFC_SEL_RES_NFC_FORUM_T2T)) {
-    NFA_TRACE_DEBUG0(
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "nfa_rw_handle_sleep_wakeup_rsp; Attempt to wake up Type 2 tag from "
         "HALT State is complete");
     if (status == NFC_STATUS_OK) {
       /* Type 2 Tag is wakeup from HALT state */
-      NFA_TRACE_DEBUG0(
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "nfa_rw_handle_sleep_wakeup_rsp; Handle the NACK rsp received now");
       /* Initialize control block */
       activate_params.protocol = nfa_rw_cb.protocol;
@@ -420,7 +423,7 @@ void nfa_rw_handle_sleep_wakeup_rsp(tNFC_STATUS status) {
       if ((RW_SetActivatedTagType(&activate_params, nfa_rw_cback)) !=
           NFC_STATUS_OK) {
         /* Log error (stay in NFA_RW_ST_ACTIVATED state until deactivation) */
-        NFA_TRACE_ERROR0("RW_SetActivatedTagType failed.");
+        LOG(ERROR) << StringPrintf("RW_SetActivatedTagType failed.");
         if (nfa_rw_cb.halt_event == RW_T2T_READ_CPLT_EVT) {
           if (nfa_rw_cb.rw_data.data.p_data)
             GKI_freebuf(nfa_rw_cb.rw_data.data.p_data);
@@ -452,11 +455,11 @@ void nfa_rw_handle_sleep_wakeup_rsp(tNFC_STATUS status) {
      * mode) then deactivate the link if sleep wakeup failed */
     if ((nfa_rw_cb.flags & NFA_RW_FL_NOT_EXCL_RF_MODE) &&
         (status != NFC_STATUS_OK)) {
-      NFA_TRACE_DEBUG0("Sleep wakeup failed. Deactivating...");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Sleep wakeup failed. Deactivating...");
       nfa_dm_rf_deactivate(NFA_DEACTIVATE_TYPE_DISCOVERY);
     }
   } else {
-    NFA_TRACE_DEBUG0(
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "nfa_rw_handle_sleep_wakeup_rsp; Legacy presence check performed");
     /* Legacy presence check performed */
     nfa_rw_handle_presence_check_rsp(status);
@@ -496,14 +499,17 @@ void nfa_rw_handle_presence_check_rsp(tNFC_STATUS status) {
        * app of result */
       if (nfa_rw_cb.p_pending_msg->op_req.op == NFA_RW_OP_PRESENCE_CHECK) {
         /* Notify app of presence check status */
-        nfa_dm_act_conn_cback_notify(NFA_PRESENCE_CHECK_EVT, (void*)&status);
+        tNFA_CONN_EVT_DATA nfa_conn_evt_data;
+        nfa_conn_evt_data.status = status;
+        nfa_dm_act_conn_cback_notify(NFA_PRESENCE_CHECK_EVT,
+                                    &nfa_conn_evt_data);
         GKI_freebuf(nfa_rw_cb.p_pending_msg);
         nfa_rw_cb.p_pending_msg = NULL;
       }
       /* For all other APIs called during auto-presence check, perform the
          command now (if tag is still present) */
       else if (status == NFC_STATUS_OK) {
-        NFA_TRACE_DEBUG0(
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
             "Performing deferred operation after presence check...");
         p_pending_msg = (NFC_HDR*)nfa_rw_cb.p_pending_msg;
         nfa_rw_cb.p_pending_msg = NULL;
@@ -518,20 +524,22 @@ void nfa_rw_handle_presence_check_rsp(tNFC_STATUS status) {
 
     /* Auto-presence check failed. Deactivate */
     if (status != NFC_STATUS_OK) {
-      NFA_TRACE_DEBUG0("Auto presence check failed. Deactivating...");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Auto presence check failed. Deactivating...");
       nfa_dm_rf_deactivate(NFA_DEACTIVATE_TYPE_DISCOVERY);
     }
   }
   /* Handle presence check due to NFA_RwPresenceCheck API call */
   else {
     /* Notify app of presence check status */
-    nfa_dm_act_conn_cback_notify(NFA_PRESENCE_CHECK_EVT, (void*)&status);
+    tNFA_CONN_EVT_DATA nfa_conn_evt_data;
+    nfa_conn_evt_data.status = status;
+    nfa_dm_act_conn_cback_notify(NFA_PRESENCE_CHECK_EVT, &nfa_conn_evt_data);
 
     /* If in normal mode (not-exclusive RF mode) then deactivate the link if
      * presence check failed */
     if ((nfa_rw_cb.flags & NFA_RW_FL_NOT_EXCL_RF_MODE) &&
-        (status != NFC_STATUS_OK)) {
-      NFA_TRACE_DEBUG0("Presence check failed. Deactivating...");
+        (nfa_conn_evt_data.status != NFC_STATUS_OK)) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Presence check failed. Deactivating...");
       nfa_dm_rf_deactivate(NFA_DEACTIVATE_TYPE_DISCOVERY);
     }
   }
@@ -600,7 +608,7 @@ static void nfa_rw_handle_t1t_evt(tRW_EVENT event, tRW_DATA* p_rw_data) {
       break;
 
     case RW_T1T_TLV_DETECT_EVT:
-      nfa_rw_handle_tlv_detect(event, p_rw_data);
+      nfa_rw_handle_tlv_detect(p_rw_data);
       break;
 
     case RW_T1T_NDEF_DETECT_EVT:
@@ -616,7 +624,7 @@ static void nfa_rw_handle_t1t_evt(tRW_EVENT event, tRW_DATA* p_rw_data) {
         if (RW_T1tFormatNDef() == NFC_STATUS_OK) break;
       }
 
-      nfa_rw_handle_ndef_detect(event, p_rw_data);
+      nfa_rw_handle_ndef_detect(p_rw_data);
 
       break;
 
@@ -727,7 +735,7 @@ static void nfa_rw_handle_t2t_evt(tRW_EVENT event, tRW_DATA* p_rw_data) {
   conn_evt_data.status = p_rw_data->status;
 
   if (p_rw_data->status == NFC_STATUS_REJECTED) {
-    NFA_TRACE_DEBUG0(
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "nfa_rw_handle_t2t_evt(); Waking the tag first before handling the "
         "response!");
     /* Received NACK. Let DM wakeup the tag first (by putting tag to sleep and
@@ -768,18 +776,18 @@ static void nfa_rw_handle_t2t_evt(tRW_EVENT event, tRW_DATA* p_rw_data) {
           (nfa_rw_cb.skip_dyn_locks == true)) {
         /* NDEF Detection is complete */
         nfa_rw_cb.skip_dyn_locks = false;
-        nfa_rw_handle_ndef_detect(event, p_rw_data);
+        nfa_rw_handle_ndef_detect(p_rw_data);
       } else {
         /* Try to detect NDEF again, this time without reading dynamic lock
          * bytes */
         nfa_rw_cb.skip_dyn_locks = true;
-        nfa_rw_detect_ndef(NULL);
+        nfa_rw_detect_ndef();
       }
       break;
 
     case RW_T2T_TLV_DETECT_EVT: /* Lock control/Mem/Prop tlv detection complete
                                    */
-      nfa_rw_handle_tlv_detect(event, p_rw_data);
+      nfa_rw_handle_tlv_detect(p_rw_data);
       break;
 
     case RW_T2T_NDEF_READ_EVT: /* NDEF read completed     */
@@ -873,7 +881,7 @@ static void nfa_rw_handle_t3t_evt(tRW_EVENT event, tRW_DATA* p_rw_data) {
 
   switch (event) {
     case RW_T3T_NDEF_DETECT_EVT: /* NDEF detection complete */
-      nfa_rw_handle_ndef_detect(event, p_rw_data);
+      nfa_rw_handle_ndef_detect(p_rw_data);
       break;
 
     case RW_T3T_UPDATE_CPLT_EVT: /* Write completed */
@@ -985,7 +993,7 @@ static void nfa_rw_handle_t3t_evt(tRW_EVENT event, tRW_DATA* p_rw_data) {
       break;
 
     default:
-      NFA_TRACE_DEBUG1("nfa_rw_handle_t3t_evt(); Unhandled RW event 0x%X",
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_rw_handle_t3t_evt(); Unhandled RW event 0x%X",
                        event);
       break;
   }
@@ -1005,7 +1013,7 @@ static void nfa_rw_handle_t4t_evt(tRW_EVENT event, tRW_DATA* p_rw_data) {
 
   switch (event) {
     case RW_T4T_NDEF_DETECT_EVT: /* Result of NDEF detection procedure */
-      nfa_rw_handle_ndef_detect(event, p_rw_data);
+      nfa_rw_handle_ndef_detect(p_rw_data);
       break;
 
     case RW_T4T_NDEF_FORMAT_CPLT_EVT:
@@ -1132,7 +1140,7 @@ static void nfa_rw_handle_t4t_evt(tRW_EVENT event, tRW_DATA* p_rw_data) {
       break;
 
     default:
-      NFA_TRACE_DEBUG1("nfa_rw_handle_t4t_evt(); Unhandled RW event 0x%X",
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_rw_handle_t4t_evt(); Unhandled RW event 0x%X",
                        event);
       break;
   }
@@ -1153,7 +1161,7 @@ static void nfa_rw_handle_i93_evt(tRW_EVENT event, tRW_DATA* p_rw_data) {
 
   switch (event) {
     case RW_I93_NDEF_DETECT_EVT: /* Result of NDEF detection procedure */
-      nfa_rw_handle_ndef_detect(event, p_rw_data);
+      nfa_rw_handle_ndef_detect(p_rw_data);
       break;
 
     case RW_I93_NDEF_READ_EVT: /* Segment of data received from type 4 tag */
@@ -1406,25 +1414,24 @@ static void nfa_rw_handle_i93_evt(tRW_EVENT event, tRW_DATA* p_rw_data) {
       break;
 
     default:
-      NFA_TRACE_DEBUG1("nfa_rw_handle_i93_evt(); Unhandled RW event 0x%X",
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_rw_handle_i93_evt(); Unhandled RW event 0x%X",
                        event);
       break;
   }
 }
 #if (NXP_EXTNS == TRUE)
-static void nfa_rw_handle_t3bt_evt(tRW_EVENT event, tRW_DATA* p_rw_data) {
-  (void)p_rw_data;
+static void nfa_rw_handle_t3bt_evt(tRW_EVENT event, __attribute__((unused)) tRW_DATA* p_rw_data) {
 
   // tNFC_ACTIVATE_DEVT *activate_ntf =
   // (tNFC_ACTIVATE_DEVT*)nfa_dm_cb.p_activate_ntf;
-  NFA_TRACE_DEBUG0("nfa_rw_handle_t3bt_evt:");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_rw_handle_t3bt_evt:");
 
   switch (event) {
     case RW_T3BT_RAW_READ_CPLT_EVT:
       nfa_rw_command_complete();
       break;
     default:
-      NFA_TRACE_DEBUG0("nfa_rw_handle_t3bt_evt: default event");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_rw_handle_t3bt_evt: default event");
       break;
   }
   nfa_dm_notify_activation_status(NFA_STATUS_OK, NULL);
@@ -1440,9 +1447,9 @@ static void nfa_rw_handle_t3bt_evt(tRW_EVENT event, tRW_DATA* p_rw_data) {
 **
 *******************************************************************************/
 static void nfa_rw_cback(tRW_EVENT event, tRW_DATA* p_rw_data) {
-  NFA_TRACE_DEBUG1("nfa_rw_cback: event=0x%02x", event);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_rw_cback: event=0x%02x", event);
   if (NULL == p_rw_data) {
-    NFA_TRACE_ERROR0("nfa_rw_cback: p_rw_data is NULL");
+    LOG(ERROR) << StringPrintf("nfa_rw_cback: p_rw_data is NULL");
     return;
   }
   /* Call appropriate event handler for tag type */
@@ -1469,7 +1476,7 @@ static void nfa_rw_cback(tRW_EVENT event, tRW_DATA* p_rw_data) {
   }
 #endif
   else {
-    NFA_TRACE_ERROR1("nfa_rw_cback: unhandled event=0x%02x", event);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_rw_cback: unhandled event=0x%02x", event);
   }
 }
 
@@ -1500,7 +1507,8 @@ static tNFC_STATUS nfa_rw_start_ndef_detection(void) {
   } else if (NFC_PROTOCOL_ISO_DEP ==
              protocol) { /* ISODEP/4A,4B- NFC-A or NFC-B */
     status = RW_T4tDetectNDef();
-  } else if (NFC_PROTOCOL_15693 == protocol) { /* ISO 15693 */
+  } else if (NFC_PROTOCOL_T5T == protocol) {
+    /* ISO 15693 */
     status = RW_I93DetectNDef();
   }
 
@@ -1523,7 +1531,7 @@ static tNFC_STATUS nfa_rw_start_ndef_read(void) {
 
   /* Handle zero length NDEF message */
   if (nfa_rw_cb.ndef_cur_size == 0) {
-    NFA_TRACE_DEBUG0("NDEF message is zero-length");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NDEF message is zero-length");
 
     /* Send zero-lengh NDEF message to ndef callback */
     nfa_dm_ndef_handle_message(NFA_STATUS_OK, NULL, 0);
@@ -1540,7 +1548,7 @@ static tNFC_STATUS nfa_rw_start_ndef_read(void) {
   nfa_rw_free_ndef_rx_buf();
   nfa_rw_cb.p_ndef_buf = (uint8_t*)nfa_mem_co_alloc(nfa_rw_cb.ndef_cur_size);
   if (nfa_rw_cb.p_ndef_buf == NULL) {
-    NFA_TRACE_ERROR1("Unable to allocate a buffer for reading NDEF (size=%i)",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Unable to allocate a buffer for reading NDEF (size=%i)",
                      nfa_rw_cb.ndef_cur_size);
 
     /* Command complete - perform cleanup, notify app */
@@ -1564,7 +1572,8 @@ static tNFC_STATUS nfa_rw_start_ndef_read(void) {
   } else if (NFC_PROTOCOL_ISO_DEP ==
              protocol) { /* ISODEP/4A,4B- NFC-A or NFC-B */
     status = RW_T4tReadNDef();
-  } else if (NFC_PROTOCOL_15693 == protocol) { /* ISO 15693 */
+  } else if (NFC_PROTOCOL_T5T == protocol) {
+    /* ISO 15693 */
     status = RW_I93ReadNDef();
   }
   return (status);
@@ -1579,10 +1588,9 @@ static tNFC_STATUS nfa_rw_start_ndef_read(void) {
 ** Returns          true (message buffer to be freed by caller)
 **
 *******************************************************************************/
-static bool nfa_rw_detect_ndef(tNFA_RW_MSG* p_data) {
+static bool nfa_rw_detect_ndef() {
   tNFA_CONN_EVT_DATA conn_evt_data;
-  (void)p_data;
-  NFA_TRACE_DEBUG0("nfa_rw_detect_ndef");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_rw_detect_ndef");
 
   conn_evt_data.ndef_detect.status = nfa_rw_start_ndef_detection();
   if (conn_evt_data.ndef_detect.status != NFC_STATUS_OK) {
@@ -1613,13 +1621,13 @@ static tNFC_STATUS nfa_rw_start_ndef_write(void) {
   if (nfa_rw_cb.flags & NFA_RW_FL_TAG_IS_READONLY) {
     /* error: ndef tag is read-only */
     status = NFC_STATUS_FAILED;
-    NFA_TRACE_ERROR0("Unable to write NDEF. Tag is read-only")
+    LOG(ERROR) << StringPrintf("Unable to write NDEF. Tag is read-only");
   } else if (nfa_rw_cb.ndef_max_size < nfa_rw_cb.ndef_wr_len) {
     /* error: ndef tag size is too small */
     status = NFC_STATUS_BUFFER_FULL;
-    NFA_TRACE_ERROR2(
+    LOG(ERROR) << StringPrintf(
         "Unable to write NDEF. Tag maxsize=%i, request write size=%i",
-        nfa_rw_cb.ndef_max_size, nfa_rw_cb.ndef_wr_len)
+        nfa_rw_cb.ndef_max_size, nfa_rw_cb.ndef_wr_len);
   } else {
     if (NFC_PROTOCOL_T1T == protocol) { /* Type1Tag    - NFC-A */
       status = RW_T1tWriteNDef((uint16_t)nfa_rw_cb.ndef_wr_len,
@@ -1635,7 +1643,8 @@ static tNFC_STATUS nfa_rw_start_ndef_write(void) {
                protocol) { /* ISODEP/4A,4B- NFC-A or NFC-B */
       status = RW_T4tUpdateNDef((uint16_t)nfa_rw_cb.ndef_wr_len,
                                 nfa_rw_cb.p_ndef_wr_buf);
-    } else if (NFC_PROTOCOL_15693 == protocol) { /* ISO 15693 */
+    } else if (NFC_PROTOCOL_T5T == protocol) {
+      /* ISO 15693 */
       status = RW_I93UpdateNDef((uint16_t)nfa_rw_cb.ndef_wr_len,
                                 nfa_rw_cb.p_ndef_wr_buf);
     }
@@ -1653,12 +1662,11 @@ static tNFC_STATUS nfa_rw_start_ndef_write(void) {
 ** Returns          true (message buffer to be freed by caller)
 **
 *******************************************************************************/
-static bool nfa_rw_read_ndef(tNFA_RW_MSG* p_data) {
+static bool nfa_rw_read_ndef() {
   tNFA_STATUS status = NFA_STATUS_OK;
   tNFA_CONN_EVT_DATA conn_evt_data;
-  (void)p_data;
 
-  NFA_TRACE_DEBUG0("nfa_rw_read_ndef");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_rw_read_ndef");
 
   /* Check if ndef detection has been performed yet */
   if (nfa_rw_cb.ndef_st == NFA_RW_NDEF_ST_UNKNOWN) {
@@ -1696,13 +1704,13 @@ static bool nfa_rw_write_ndef(tNFA_RW_MSG* p_data) {
   tNDEF_STATUS ndef_status;
   tNFA_STATUS write_status = NFA_STATUS_OK;
   tNFA_CONN_EVT_DATA conn_evt_data;
-  NFA_TRACE_DEBUG0("nfa_rw_write_ndef");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_rw_write_ndef");
 
   /* Validate NDEF message */
   ndef_status = NDEF_MsgValidate(p_data->op_req.params.write_ndef.p_data,
                                  p_data->op_req.params.write_ndef.len, false);
   if (ndef_status != NDEF_OK) {
-    NFA_TRACE_ERROR1("Invalid NDEF message. NDEF_MsgValidate returned %i",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Invalid NDEF message. NDEF_MsgValidate returned %i",
                      ndef_status);
 
     /* Command complete - perform cleanup, notify app */
@@ -1762,11 +1770,9 @@ void nfa_rw_presence_check(tNFA_RW_MSG* p_data) {
   bool unsupported = false;
   uint8_t option = NFA_RW_OPTION_INVALID;
   tNFA_RW_PRES_CHK_OPTION op_param = NFA_RW_PRES_CHK_DEFAULT;
-#if (NXP_EXTNS == TRUE)
-  uint16_t iso_15693_max_presence_check_timeout =
-      NFA_DM_ISO_15693_MAX_PRESENCE_CHECK_TIMEOUT + RW_I93_MAX_RSP_TIMEOUT;
-#endif
-  if (NFC_PROTOCOL_T1T == protocol) { /* Type1Tag    - NFC-A */
+
+  if (NFC_PROTOCOL_T1T == protocol) {
+    /* Type1Tag    - NFC-A */
     status = RW_T1tPresenceCheck();
   } else if (NFC_PROTOCOL_T2T == protocol) {
     /* If T2T NFC-Forum, then let RW handle presence check */
@@ -1777,10 +1783,11 @@ void nfa_rw_presence_check(tNFA_RW_MSG* p_data) {
       /* Will fall back to deactivate/reactivate */
       unsupported = true;
     }
-  } else if (NFC_PROTOCOL_T3T == protocol) { /* Type3Tag    - NFC-F */
+  } else if (NFC_PROTOCOL_T3T == protocol) {
+    /* Type3Tag    - NFC-F */
     status = RW_T3tPresenceCheck();
-  } else if (NFC_PROTOCOL_ISO_DEP ==
-             protocol) { /* ISODEP/4A,4B- NFC-A or NFC-B */
+  } else if (NFC_PROTOCOL_ISO_DEP == protocol) {
+    /* ISODEP/4A,4B- NFC-A or NFC-B */
     if (p_data) {
       op_param = p_data->op_req.params.option;
     }
@@ -1790,48 +1797,14 @@ void nfa_rw_presence_check(tNFA_RW_MSG* p_data) {
         option = RW_T4T_CHK_EMPTY_I_BLOCK;
         break;
 
-      case NFA_RW_PRES_CHK_RESET:
-        /* option is initialized to NFA_RW_OPTION_INVALID, which will Deactivate
-         * to Sleep; Re-activate */
-        break;
-
-      case NFA_RW_PRES_CHK_RB_CH0:
-        option = RW_T4T_CHK_READ_BINARY_CH0;
-        break;
-
-      case NFA_RW_PRES_CHK_RB_CH3:
-        option = RW_T4T_CHK_READ_BINARY_CH3;
-        break;
-
       case NFA_RW_PRES_CHK_ISO_DEP_NAK:
         if (NFC_GetNCIVersion() == NCI_VERSION_2_0) {
           option = RW_T4T_CHK_ISO_DEP_NAK_PRES_CHK;
         }
         break;
       default:
-        if (nfa_rw_cb.flags & NFA_RW_FL_NDEF_OK) {
-          /* read binary on channel 0 */
-          option = RW_T4T_CHK_READ_BINARY_CH0;
-        } else {
-          /* NDEF DETECT failed.*/
-          if (nfa_dm_is_raw_frame_session()) {
-            /* NFA_SendRawFrame() is called */
-            if (p_nfa_dm_cfg->presence_check_option &
-                NFA_DM_PCO_EMPTY_I_BLOCK) {
-              /* empty I block */
-              option = RW_T4T_CHK_EMPTY_I_BLOCK;
-            } else {
-              /* read binary on channel 3 */
-              option = RW_T4T_CHK_READ_BINARY_CH3;
-            }
-          } else if (!(p_nfa_dm_cfg->presence_check_option &
-                       NFA_DM_PCO_ISO_SLEEP_WAKE) &&
-                     (nfa_rw_cb.intf_type == NFC_INTERFACE_ISO_DEP)) {
-            /* the option indicates to use empty I block && ISODEP interface is
-             * activated */
-            option = RW_T4T_CHK_EMPTY_I_BLOCK;
-          }
-        }
+      /* empty I block */
+      option = RW_T4T_CHK_EMPTY_I_BLOCK;
     }
 
     if (option != NFA_RW_OPTION_INVALID) {
@@ -1841,8 +1814,8 @@ void nfa_rw_presence_check(tNFA_RW_MSG* p_data) {
       /* use sleep/wake for presence check */
       unsupported = true;
     }
-
-  } else if (NFC_PROTOCOL_15693 == protocol) { /* ISO 15693 */
+  } else if (NFC_PROTOCOL_T5T == protocol) {
+    /* T5T/ISO 15693 */
     status = RW_I93PresenceCheck();
   } else {
     /* Protocol unsupported by RW module... */
@@ -1864,16 +1837,8 @@ void nfa_rw_presence_check(tNFA_RW_MSG* p_data) {
   if (status != NFC_STATUS_OK)
     nfa_rw_handle_presence_check_rsp(NFC_STATUS_FAILED);
   else if (!unsupported) {
-#if (NXP_EXTNS == TRUE)
-    if (protocol == NFC_PROTOCOL_15693) {
-      nfa_sys_start_timer(&nfa_rw_cb.tle, NFA_RW_PRESENCE_CHECK_TIMEOUT_EVT,
-                          iso_15693_max_presence_check_timeout);
-    } else
-#endif
-    {
-      nfa_sys_start_timer(&nfa_rw_cb.tle, NFA_RW_PRESENCE_CHECK_TIMEOUT_EVT,
-                          p_nfa_dm_cfg->presence_check_timeout);
-    }
+    nfa_sys_start_timer(&nfa_rw_cb.tle, NFA_RW_PRESENCE_CHECK_TIMEOUT_EVT,
+                        p_nfa_dm_cfg->presence_check_timeout);
   }
 }
 
@@ -1887,13 +1852,11 @@ void nfa_rw_presence_check(tNFA_RW_MSG* p_data) {
 ** Returns          true (caller frees message buffer)
 **
 *******************************************************************************/
-bool nfa_rw_presence_check_tick(tNFA_RW_MSG* p_data) {
-  (void)p_data;
-
+bool nfa_rw_presence_check_tick(__attribute__((unused)) tNFA_RW_MSG* p_data) {
   /* Store the current operation */
   nfa_rw_cb.cur_op = NFA_RW_OP_PRESENCE_CHECK;
   nfa_rw_cb.flags |= NFA_RW_FL_AUTO_PRESENCE_CHECK_BUSY;
-  NFA_TRACE_DEBUG0("Auto-presence check starting...");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Auto-presence check starting...");
 
   /* Perform presence check */
   nfa_rw_presence_check(NULL);
@@ -1910,9 +1873,7 @@ bool nfa_rw_presence_check_tick(tNFA_RW_MSG* p_data) {
 ** Returns          true (caller frees message buffer)
 **
 *******************************************************************************/
-bool nfa_rw_presence_check_timeout(tNFA_RW_MSG* p_data) {
-  (void)p_data;
-
+bool nfa_rw_presence_check_timeout(__attribute__((unused)) tNFA_RW_MSG* p_data) {
   nfa_rw_handle_presence_check_rsp(NFC_STATUS_FAILED);
   return true;
 }
@@ -1926,10 +1887,9 @@ bool nfa_rw_presence_check_timeout(tNFA_RW_MSG* p_data) {
 ** Returns          Nothing
 **
 *******************************************************************************/
-static void nfa_rw_format_tag(tNFA_RW_MSG* p_data) {
+static void nfa_rw_format_tag() {
   tNFC_PROTOCOL protocol = nfa_rw_cb.protocol;
   tNFC_STATUS status = NFC_STATUS_FAILED;
-  (void)p_data;
 
   if (protocol == NFC_PROTOCOL_T1T) {
     status = RW_T1tFormatNDef();
@@ -1938,7 +1898,7 @@ static void nfa_rw_format_tag(tNFA_RW_MSG* p_data) {
     status = RW_T2tFormatNDef();
   } else if (protocol == NFC_PROTOCOL_T3T) {
     status = RW_T3tFormatNDef();
-  } else if (protocol == NFC_PROTOCOL_15693) {
+  } else if (protocol == NFC_PROTOCOL_T5T) {
     status = RW_I93FormatNDef();
   } else if (protocol == NFC_PROTOCOL_ISO_DEP) {
     status = RW_T4tFormatNDef();
@@ -1957,10 +1917,9 @@ static void nfa_rw_format_tag(tNFA_RW_MSG* p_data) {
 ** Returns          true (message buffer to be freed by caller)
 **
 *******************************************************************************/
-static bool nfa_rw_detect_tlv(tNFA_RW_MSG* p_data, uint8_t tlv) {
-  (void)p_data;
+static bool nfa_rw_detect_tlv(uint8_t tlv) {
 
-  NFA_TRACE_DEBUG0("nfa_rw_detect_tlv");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_rw_detect_tlv");
 
   switch (nfa_rw_cb.protocol) {
     case NFC_PROTOCOL_T1T:
@@ -1995,7 +1954,7 @@ static tNFC_STATUS nfa_rw_config_tag_ro(bool b_hard_lock) {
   tNFC_PROTOCOL protocol = nfa_rw_cb.protocol;
   tNFC_STATUS status = NFC_STATUS_FAILED;
 
-  NFA_TRACE_DEBUG0("nfa_rw_config_tag_ro ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_rw_config_tag_ro ()");
 
   if (NFC_PROTOCOL_T1T == protocol) { /* Type1Tag    - NFC-A */
     if ((nfa_rw_cb.tlv_st == NFA_RW_TLV_DETECT_ST_OP_NOT_STARTED) ||
@@ -2015,7 +1974,7 @@ static tNFC_STATUS nfa_rw_config_tag_ro(bool b_hard_lock) {
   } else if (NFC_PROTOCOL_ISO_DEP == protocol) {
     /* ISODEP/4A,4B- NFC-A or NFC-B */
     status = RW_T4tSetNDefReadOnly();
-  } else if (NFC_PROTOCOL_15693 == protocol) {
+  } else if (NFC_PROTOCOL_T5T == protocol) {
     /* ISO 15693 */
     status = RW_I93SetTagReadOnly();
   }
@@ -2038,8 +1997,7 @@ static tNFC_STATUS nfa_rw_config_tag_ro(bool b_hard_lock) {
 ** Returns          true (message buffer to be freed by caller)
 **
 *******************************************************************************/
-static bool nfa_rw_t1t_rid(tNFA_RW_MSG* p_data) {
-  (void)p_data;
+static bool nfa_rw_t1t_rid() {
 
   if (RW_T1tRid() != NFC_STATUS_OK) nfa_rw_error_cleanup(NFA_READ_CPLT_EVT);
 
@@ -2055,8 +2013,7 @@ static bool nfa_rw_t1t_rid(tNFA_RW_MSG* p_data) {
 ** Returns          true (message buffer to be freed by caller)
 **
 *******************************************************************************/
-static bool nfa_rw_t1t_rall(tNFA_RW_MSG* p_data) {
-  (void)p_data;
+static bool nfa_rw_t1t_rall() {
 
   if (RW_T1tReadAll() != NFC_STATUS_OK) nfa_rw_error_cleanup(NFA_READ_CPLT_EVT);
 
@@ -2300,10 +2257,9 @@ static bool nfa_rw_t3t_write(tNFA_RW_MSG* p_data) {
 ** Returns          true (message buffer to be freed by caller)
 **
 *******************************************************************************/
-static bool nfa_rw_t3t_get_system_codes(tNFA_RW_MSG* p_data) {
+static bool nfa_rw_t3t_get_system_codes() {
   tNFC_STATUS status;
   tNFA_TAG_PARAMS tag_params;
-  (void)p_data;
 
   status = RW_T3tGetSystemCodes();
 
@@ -2320,9 +2276,8 @@ static bool nfa_rw_t3t_get_system_codes(tNFA_RW_MSG* p_data) {
 }
 
 #if (NXP_EXTNS == TRUE)
-static bool nfa_rw_t3bt_get_pupi(tNFA_RW_MSG* p_data) {
+static bool nfa_rw_t3bt_get_pupi(__attribute__((unused)) tNFA_RW_MSG* p_data) {
   tNFC_STATUS status;
-  (void)p_data;
 
   status = RW_T3BtGetPupiID();
 
@@ -2473,13 +2428,12 @@ static bool nfa_rw_i93_command(tNFA_RW_MSG* p_data) {
 ** Returns          nothing
 **
 *******************************************************************************/
-static void nfa_rw_raw_mode_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
-                                       tNFC_CONN* p_data) {
+static void nfa_rw_raw_mode_data_cback(__attribute__((unused)) uint8_t conn_id,
+                                        tNFC_CONN_EVT event, tNFC_CONN* p_data) {
   NFC_HDR* p_msg;
   tNFA_CONN_EVT_DATA evt_data;
-  (void)conn_id;
 
-  NFA_TRACE_DEBUG1("nfa_rw_raw_mode_data_cback(): event = 0x%X", event);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_rw_raw_mode_data_cback(): event = 0x%X", event);
 
   if ((event == NFC_DATA_CEVT) &&
       ((p_data->data.status == NFC_STATUS_OK) ||
@@ -2495,7 +2449,7 @@ static void nfa_rw_raw_mode_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
 
       GKI_freebuf(p_msg);
     } else {
-      NFA_TRACE_ERROR0(
+      LOG(ERROR) << StringPrintf(
           "nfa_rw_raw_mode_data_cback (): received NFC_DATA_CEVT with NULL "
           "data pointer");
     }
@@ -2517,7 +2471,6 @@ bool nfa_rw_activate_ntf(tNFA_RW_MSG* p_data) {
   tNFC_ACTIVATE_DEVT* p_activate_params =
       p_data->activate_ntf.p_activate_params;
   tNFA_TAG_PARAMS tag_params;
-  tNFA_RW_OPERATION msg;
   bool activate_notify = true;
   uint8_t* p;
 
@@ -2530,12 +2483,12 @@ bool nfa_rw_activate_ntf(tNFA_RW_MSG* p_data) {
       GKI_freebuf(nfa_dm_cb.p_activate_ntf);
       nfa_dm_cb.p_activate_ntf = NULL;
     }
-    NFA_TRACE_DEBUG0(
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "nfa_rw_activate_ntf () - Type 2 tag wake up from HALT State");
     return true;
   }
 
-  NFA_TRACE_DEBUG0("nfa_rw_activate_ntf");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_rw_activate_ntf");
 
   /* Initialize control block */
   nfa_rw_cb.protocol = p_activate_params->protocol;
@@ -2562,7 +2515,7 @@ bool nfa_rw_activate_ntf(tNFA_RW_MSG* p_data) {
     if ((p_activate_params->protocol != NFA_PROTOCOL_T1T) &&
         (p_activate_params->protocol != NFA_PROTOCOL_T2T) &&
         (p_activate_params->protocol != NFA_PROTOCOL_T3T) &&
-        (p_activate_params->protocol != NFC_PROTOCOL_15693)
+        (p_activate_params->protocol != NFA_PROTOCOL_T5T)
 #if (NXP_EXTNS == TRUE)
         && (p_activate_params->protocol != NFA_PROTOCOL_T3BT)
 #endif
@@ -2607,44 +2560,53 @@ bool nfa_rw_activate_ntf(tNFA_RW_MSG* p_data) {
   if ((RW_SetActivatedTagType(p_activate_params, nfa_rw_cback)) !=
       NFC_STATUS_OK) {
     /* Log error (stay in NFA_RW_ST_ACTIVATED state until deactivation) */
-    NFA_TRACE_ERROR0("RW_SetActivatedTagType failed.");
+    LOG(ERROR) << StringPrintf("RW_SetActivatedTagType failed.");
     return true;
   }
 
   /* Perform protocol-specific actions */
   if (NFC_PROTOCOL_T1T == nfa_rw_cb.protocol) {
     /* Retrieve HR and UID fields from activation notification */
-    memcpy(tag_params.t1t.hr, p_activate_params->rf_tech_param.param.pa.hr,
-           NFA_T1T_HR_LEN);
     memcpy(tag_params.t1t.uid, p_activate_params->rf_tech_param.param.pa.nfcid1,
            p_activate_params->rf_tech_param.param.pa.nfcid1_len);
-    if(NFC_GetNCIVersion() == NCI_VERSION_1_0) {
-    msg.op = NFA_RW_OP_T1T_RID;
-    nfa_rw_handle_op_req((void*)&msg);
-    activate_notify = false; /* Delay notifying upper layer of NFA_ACTIVATED_EVT
-                                until HR0/HR1 is received */
-   }
+
+    if (NFC_GetNCIVersion() == NCI_VERSION_2_0) {
+      memcpy(tag_params.t1t.hr, p_activate_params->rf_tech_param.param.pa.hr,
+             NFA_T1T_HR_LEN);
+    } else {
+      memcpy(tag_params.t1t.hr,
+             p_activate_params->intf_param.intf_param.frame.param,
+             NFA_T1T_HR_LEN);
+      tNFA_RW_MSG msg;
+      msg.op_req.op = NFA_RW_OP_T1T_RID;
+      bool free_buf = nfa_rw_handle_op_req(&msg);
+      CHECK(free_buf)
+          << "nfa_rw_handle_op_req is holding on to soon-garbage stack memory.";
+      /* Delay notifying upper layer of NFA_ACTIVATED_EVT
+         until HR0/HR1 is received */
+      activate_notify = false;
+    }
   } else if (NFC_PROTOCOL_T2T == nfa_rw_cb.protocol) {
     /* Retrieve UID fields from activation notification */
     memcpy(tag_params.t2t.uid, p_activate_params->rf_tech_param.param.pa.nfcid1,
            p_activate_params->rf_tech_param.param.pa.nfcid1_len);
   } else if (NFC_PROTOCOL_T3T == nfa_rw_cb.protocol) {
-#if (NXP_EXTNS == TRUE)
     if (appl_dta_mode_flag) {
-      /*Incase of DTA mode Dont send commands to get system code. Just notify
-       * activation*/
+      /* Incase of DTA mode Dont send commands to get system code. Just notify
+       * activation */
       activate_notify = true;
     } else {
-#endif
-      /* Delay notifying upper layer of NFA_ACTIVATED_EVT until system codes are
-       * retrieved */
+      /* Delay notifying upper layer of NFA_ACTIVATED_EVT until system codes
+       * are retrieved */
       activate_notify = false;
+
       /* Issue command to get Felica system codes */
-      msg.op = NFA_RW_OP_T3T_GET_SYSTEM_CODES;
-      nfa_rw_handle_op_req((void*)&msg);
-#if (NXP_EXTNS == TRUE)
+      tNFA_RW_MSG msg;
+      msg.op_req.op = NFA_RW_OP_T3T_GET_SYSTEM_CODES;
+      bool free_buf = nfa_rw_handle_op_req(&msg);
+      CHECK(free_buf)
+          << "nfa_rw_handle_op_req is holding on to soon-garbage stack memory.";
     }
-#endif
   }
 #if (NXP_EXTNS == TRUE)
   else if (NFC_PROTOCOL_T3BT == nfa_rw_cb.protocol) {
@@ -2652,11 +2614,12 @@ bool nfa_rw_activate_ntf(tNFA_RW_MSG* p_data) {
     activate_notify =
         false; /* Delay notifying upper layer of NFA_ACTIVATED_EVT until system
                   codes are retrieved */
-    msg.op = NFA_RW_OP_T3BT_PUPI;
-    nfa_rw_handle_op_req((void*)&msg);
+    tNFA_RW_MSG msg;
+    msg.op_req.op = NFA_RW_OP_T3BT_PUPI;
+    nfa_rw_handle_op_req(&msg);
   }
 #endif
-  else if (NFC_PROTOCOL_15693 == nfa_rw_cb.protocol) {
+  else if (NFC_PROTOCOL_T5T == nfa_rw_cb.protocol) {
     /* Delay notifying upper layer of NFA_ACTIVATED_EVT to retrieve additional
      * tag infomation */
     nfa_rw_cb.flags |= NFA_RW_FL_ACTIVATION_NTF_PENDING;
@@ -2742,9 +2705,7 @@ bool nfa_rw_activate_ntf(tNFA_RW_MSG* p_data) {
 ** Returns          true (message buffer to be freed by caller)
 **
 *******************************************************************************/
-bool nfa_rw_deactivate_ntf(tNFA_RW_MSG* p_data) {
-  (void)p_data;
-
+bool nfa_rw_deactivate_ntf(__attribute__((unused)) tNFA_RW_MSG* p_data) {
   /* Clear the activated flag */
   nfa_rw_cb.flags &= ~NFA_RW_FL_ACTIVATED;
 
@@ -2792,7 +2753,7 @@ bool nfa_rw_handle_op_req(tNFA_RW_MSG* p_data) {
 
   /* Check if activated */
   if (!(nfa_rw_cb.flags & NFA_RW_FL_ACTIVATED)) {
-    NFA_TRACE_ERROR0("nfa_rw_handle_op_req: not activated");
+    LOG(ERROR) << StringPrintf("nfa_rw_handle_op_req: not activated");
     return true;
   }
   /* Check if currently busy with another API call */
@@ -2803,7 +2764,7 @@ bool nfa_rw_handle_op_req(tNFA_RW_MSG* p_data) {
   else if (nfa_rw_cb.flags & NFA_RW_FL_AUTO_PRESENCE_CHECK_BUSY) {
     /* Cache the command (will be handled once auto-presence check is completed)
      */
-    NFA_TRACE_DEBUG1(
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "Deferring operation %i until after auto-presence check is completed",
         p_data->op_req.op);
     nfa_rw_cb.p_pending_msg = p_data;
@@ -2811,7 +2772,7 @@ bool nfa_rw_handle_op_req(tNFA_RW_MSG* p_data) {
     return (false);
   }
 
-  NFA_TRACE_DEBUG1("nfa_rw_handle_op_req: op=0x%02x", p_data->op_req.op);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_rw_handle_op_req: op=0x%02x", p_data->op_req.op);
 
   nfa_rw_cb.flags |= NFA_RW_FL_API_BUSY;
 
@@ -2825,11 +2786,11 @@ bool nfa_rw_handle_op_req(tNFA_RW_MSG* p_data) {
   switch (p_data->op_req.op) {
     case NFA_RW_OP_DETECT_NDEF:
       nfa_rw_cb.skip_dyn_locks = false;
-      nfa_rw_detect_ndef(p_data);
+      nfa_rw_detect_ndef();
       break;
 
     case NFA_RW_OP_READ_NDEF:
-      nfa_rw_read_ndef(p_data);
+      nfa_rw_read_ndef();
       break;
 
     case NFA_RW_OP_WRITE_NDEF:
@@ -2854,15 +2815,15 @@ bool nfa_rw_handle_op_req(tNFA_RW_MSG* p_data) {
       break;
 
     case NFA_RW_OP_FORMAT_TAG:
-      nfa_rw_format_tag(p_data);
+      nfa_rw_format_tag();
       break;
 
     case NFA_RW_OP_DETECT_LOCK_TLV:
-      nfa_rw_detect_tlv(p_data, TAG_LOCK_CTRL_TLV);
+      nfa_rw_detect_tlv(TAG_LOCK_CTRL_TLV);
       break;
 
     case NFA_RW_OP_DETECT_MEM_TLV:
-      nfa_rw_detect_tlv(p_data, TAG_MEM_CTRL_TLV);
+      nfa_rw_detect_tlv(TAG_MEM_CTRL_TLV);
       break;
 
     case NFA_RW_OP_SET_TAG_RO:
@@ -2871,11 +2832,11 @@ bool nfa_rw_handle_op_req(tNFA_RW_MSG* p_data) {
       break;
 
     case NFA_RW_OP_T1T_RID:
-      nfa_rw_t1t_rid(p_data);
+      nfa_rw_t1t_rid();
       break;
 
     case NFA_RW_OP_T1T_RALL:
-      nfa_rw_t1t_rall(p_data);
+      nfa_rw_t1t_rall();
       break;
 
     case NFA_RW_OP_T1T_READ:
@@ -2921,7 +2882,7 @@ bool nfa_rw_handle_op_req(tNFA_RW_MSG* p_data) {
       break;
 
     case NFA_RW_OP_T3T_GET_SYSTEM_CODES:
-      nfa_rw_t3t_get_system_codes(p_data);
+      nfa_rw_t3t_get_system_codes();
       break;
 
     /* ISO 15693 tag commands */
@@ -2950,7 +2911,7 @@ bool nfa_rw_handle_op_req(tNFA_RW_MSG* p_data) {
 #endif
 
     default:
-      NFA_TRACE_ERROR1("nfa_rw_handle_api: unhandled operation: %i",
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_rw_handle_api: unhandled operation: %i",
                        p_data->op_req.op);
       break;
   }
@@ -2973,7 +2934,7 @@ static bool nfa_rw_op_req_while_busy(tNFA_RW_MSG* p_data) {
   tNFA_CONN_EVT_DATA conn_evt_data;
   uint8_t event;
 
-  NFA_TRACE_ERROR0("nfa_rw_op_req_while_busy: unable to handle API");
+  LOG(ERROR) << StringPrintf("nfa_rw_op_req_while_busy: unable to handle API");
 
   /* Return appropriate event for requested API, with status=BUSY */
   conn_evt_data.status = NFA_STATUS_BUSY;
@@ -3060,12 +3021,12 @@ void nfa_rw_command_complete(void) {
 
 #if (NXP_EXTNS == TRUE)
 void nfa_rw_set_cback(tNFC_DISCOVER* p_data) {
-  NFA_TRACE_DEBUG0("nfa_rw_set_cback:");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_rw_set_cback:");
   if ((p_data != NULL) &&
       !nfa_dm_is_protocol_supported(
           p_data->activate.protocol,
           p_data->activate.rf_tech_param.param.pa.sel_rsp)) {
-    NFA_TRACE_DEBUG0("nfa_rw_set_cback: nfa_rw_raw_mode_data_cback");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_rw_set_cback: nfa_rw_raw_mode_data_cback");
     /* Set data callback (pass all incoming data to upper layer using
      * NFA_DATA_EVT) */
     NFC_SetStaticRfCback(nfa_rw_raw_mode_data_cback);
@@ -3076,12 +3037,12 @@ void nfa_rw_update_pupi_id(uint8_t* p, uint8_t len) {
   tNFC_ACTIVATE_DEVT* activate_ntf =
       (tNFC_ACTIVATE_DEVT*)nfa_dm_cb.p_activate_ntf;
 
-  NFA_TRACE_DEBUG0("nfa_rw_update_pupi_id:");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_rw_update_pupi_id:");
   if (len != 0) {
     activate_ntf->rf_tech_param.param.pb.pupiid_len = len;
     memcpy(activate_ntf->rf_tech_param.param.pb.pupiid, p, len);
   } else {
-    NFA_TRACE_DEBUG1("nfa_rw_update_pupi_id: invalid resp_len=%d", len);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_rw_update_pupi_id: invalid resp_len=%d", len);
   }
 }
 #endif
diff --git a/src/nfa/rw/nfa_rw_api.c b/src/nfa/rw/nfa_rw_api.cc
similarity index 89%
rename from src/nfa/rw/nfa_rw_api.c
rename to src/nfa/rw/nfa_rw_api.cc
index 7b36343..c22d53b 100644
--- a/src/nfa/rw/nfa_rw_api.c
+++ b/src/nfa/rw/nfa_rw_api.cc
@@ -22,10 +22,16 @@
  *
  ******************************************************************************/
 #include <string.h>
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfa_api.h"
-#include "nfa_sys.h"
 #include "nfa_rw_int.h"
-#include "nfa_sys_int.h"
+
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
 
 /*****************************************************************************
 **  Constants
@@ -61,7 +67,7 @@
 tNFA_STATUS NFA_RwDetectNDef(void) {
   tNFA_RW_OPERATION* p_msg;
 
-  NFA_TRACE_API0("NFA_RwDetectNDef");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
 
   p_msg = (tNFA_RW_OPERATION*)GKI_getbuf((uint16_t)(sizeof(tNFA_RW_OPERATION)));
   if (p_msg != NULL) {
@@ -106,7 +112,7 @@ tNFA_STATUS NFA_RwDetectNDef(void) {
 tNFA_STATUS NFA_RwReadNDef(void) {
   tNFA_RW_OPERATION* p_msg;
 
-  NFA_TRACE_API0("NFA_RwReadNDef");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
 
   p_msg = (tNFA_RW_OPERATION*)GKI_getbuf((uint16_t)(sizeof(tNFA_RW_OPERATION)));
   if (p_msg != NULL) {
@@ -145,7 +151,7 @@ tNFA_STATUS NFA_RwReadNDef(void) {
 tNFA_STATUS NFA_RwWriteNDef(uint8_t* p_data, uint32_t len) {
   tNFA_RW_OPERATION* p_msg;
 
-  NFA_TRACE_API2("NFA_RwWriteNDef (): ndef p_data=%08x, len: %i", p_data, len);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_RwWriteNDef (): ndef p_data=%hhu, len: %i", *p_data, len);
 
   /* Validate parameters */
   if (p_data == NULL) return (NFA_STATUS_INVALID_PARAM);
@@ -183,7 +189,7 @@ tNFA_STATUS NFA_RwWriteNDef(uint8_t* p_data, uint32_t len) {
 tNFA_STATUS NFA_RwPresenceCheck(tNFA_RW_PRES_CHK_OPTION option) {
   tNFA_RW_OPERATION* p_msg;
 
-  NFA_TRACE_API0("NFA_RwPresenceCheck");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
 
   p_msg = (tNFA_RW_OPERATION*)GKI_getbuf((uint16_t)(sizeof(tNFA_RW_OPERATION)));
   if (p_msg != NULL) {
@@ -216,7 +222,7 @@ tNFA_STATUS NFA_RwPresenceCheck(tNFA_RW_PRES_CHK_OPTION option) {
 tNFA_STATUS NFA_RwFormatTag(void) {
   tNFA_RW_OPERATION* p_msg;
 
-  NFA_TRACE_API0("NFA_RwFormatTag");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
 
   p_msg = (tNFA_RW_OPERATION*)GKI_getbuf((uint16_t)(sizeof(tNFA_RW_OPERATION)));
   if (p_msg != NULL) {
@@ -243,8 +249,8 @@ tNFA_STATUS NFA_RwFormatTag(void) {
 **
 ** Returns:
 **      NFA_STATUS_OK if successfully initiated
-**      NFA_STATUS_REJECTED if protocol is not T1/T2/ISO15693
-**                 (or) if hard lock is not requested for protocol ISO15693
+**      NFA_STATUS_REJECTED if protocol is not T1/T2/T5T
+**                 (or) if hard lock is not requested for protocol T5T
 **      NFA_STATUS_FAILED otherwise
 **
 *******************************************************************************/
@@ -253,23 +259,23 @@ tNFA_STATUS NFA_RwSetTagReadOnly(bool b_hard_lock) {
   tNFC_PROTOCOL protocol = nfa_rw_cb.protocol;
 
   if ((protocol != NFC_PROTOCOL_T1T) && (protocol != NFC_PROTOCOL_T2T) &&
-      (protocol != NFC_PROTOCOL_15693) && (protocol != NFC_PROTOCOL_ISO_DEP) &&
+      (protocol != NFC_PROTOCOL_T5T) && (protocol != NFC_PROTOCOL_ISO_DEP) &&
       (protocol != NFC_PROTOCOL_T3T)) {
-    NFA_TRACE_API1(
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "NFA_RwSetTagReadOnly (): Cannot Configure as read only for Protocol: "
         "%d",
         protocol);
     return (NFA_STATUS_REJECTED);
   }
 
-  if ((!b_hard_lock && (protocol == NFC_PROTOCOL_15693)) ||
+  if ((!b_hard_lock && (protocol == NFC_PROTOCOL_T5T)) ||
       (b_hard_lock && (protocol == NFC_PROTOCOL_ISO_DEP))) {
-    NFA_TRACE_API2("NFA_RwSetTagReadOnly (): Cannot %s for Protocol: %d",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_RwSetTagReadOnly (): Cannot %s for Protocol: %d",
                    b_hard_lock ? "Hard lock" : "Soft lock", protocol);
     return (NFA_STATUS_REJECTED);
   }
 
-  NFA_TRACE_API1("NFA_RwSetTagReadOnly (): %s",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_RwSetTagReadOnly (): %s",
                  b_hard_lock ? "Hard lock" : "Soft lock");
 
   p_msg = (tNFA_RW_OPERATION*)GKI_getbuf((uint16_t)(sizeof(tNFA_RW_OPERATION)));
@@ -328,7 +334,7 @@ tNFA_STATUS NFA_RwSetTagReadOnly(bool b_hard_lock) {
 tNFA_STATUS NFA_RwLocateTlv(uint8_t tlv_type) {
   tNFA_RW_OPERATION* p_msg;
 
-  NFA_TRACE_API0("NFA_RwLocateTlv");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
 
   p_msg = (tNFA_RW_OPERATION*)GKI_getbuf((uint16_t)(sizeof(tNFA_RW_OPERATION)));
   if (p_msg != NULL) {
@@ -601,7 +607,7 @@ tNFA_STATUS NFA_RwT1tWrite8(uint8_t block_number, uint8_t* p_data,
 tNFA_STATUS NFA_RwT2tRead(uint8_t block_number) {
   tNFA_RW_OPERATION* p_msg;
 
-  NFA_TRACE_API1("NFA_RwT2tRead (): Block to read: %d", block_number);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_RwT2tRead (): Block to read: %d", block_number);
 
   p_msg = (tNFA_RW_OPERATION*)GKI_getbuf((uint16_t)(sizeof(tNFA_RW_OPERATION)));
   if (p_msg != NULL) {
@@ -634,7 +640,7 @@ tNFA_STATUS NFA_RwT2tRead(uint8_t block_number) {
 tNFA_STATUS NFA_RwT2tWrite(uint8_t block_number, uint8_t* p_data) {
   tNFA_RW_OPERATION* p_msg;
 
-  NFA_TRACE_API1("NFA_RwT2tWrite (): Block to write: %d", block_number);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_RwT2tWrite (): Block to write: %d", block_number);
 
   p_msg = (tNFA_RW_OPERATION*)GKI_getbuf((uint16_t)(sizeof(tNFA_RW_OPERATION)));
   if (p_msg != NULL) {
@@ -670,7 +676,7 @@ tNFA_STATUS NFA_RwT2tWrite(uint8_t block_number, uint8_t* p_data) {
 tNFA_STATUS NFA_RwT2tSectorSelect(uint8_t sector_number) {
   tNFA_RW_OPERATION* p_msg;
 
-  NFA_TRACE_API1("NFA_RwT2tRead (): sector to select: %d", sector_number);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_RwT2tRead (): sector to select: %d", sector_number);
 
   p_msg = (tNFA_RW_OPERATION*)GKI_getbuf((uint16_t)(sizeof(tNFA_RW_OPERATION)));
   if (p_msg != NULL) {
@@ -706,7 +712,7 @@ tNFA_STATUS NFA_RwT3tRead(uint8_t num_blocks, tNFA_T3T_BLOCK_DESC* t3t_blocks) {
   tNFA_RW_OPERATION* p_msg;
   uint8_t* p_block_desc;
 
-  NFA_TRACE_API1("NFA_RwT3tRead (): num_blocks to read: %i", num_blocks);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_RwT3tRead (): num_blocks to read: %i", num_blocks);
 
   /* Validate parameters */
   if ((num_blocks == 0) || (t3t_blocks == NULL))
@@ -755,9 +761,9 @@ tNFA_STATUS NFA_RwT3tRead(uint8_t num_blocks, tNFA_T3T_BLOCK_DESC* t3t_blocks) {
 tNFA_STATUS NFA_RwT3tWrite(uint8_t num_blocks, tNFA_T3T_BLOCK_DESC* t3t_blocks,
                            uint8_t* p_data) {
   tNFA_RW_OPERATION* p_msg;
-  uint8_t* p_block_desc, *p_data_area;
+  uint8_t *p_block_desc, *p_data_area;
 
-  NFA_TRACE_API1("NFA_RwT3tWrite (): num_blocks to write: %i", num_blocks);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_RwT3tWrite (): num_blocks to write: %i", num_blocks);
 
   /* Validate parameters */
   if ((num_blocks == 0) || (t3t_blocks == NULL) | (p_data == NULL))
@@ -799,7 +805,7 @@ tNFA_STATUS NFA_RwT3tWrite(uint8_t num_blocks, tNFA_T3T_BLOCK_DESC* t3t_blocks,
 ** Function         NFA_RwI93Inventory
 **
 ** Description:
-**      Send Inventory command to the activated ISO 15693 tag with/without AFI
+**      Send Inventory command to the activated ISO T5T tag with/without AFI
 **      If UID is provided then set UID[0]:MSB, ... UID[7]:LSB
 **
 **      When the operation has completed (or if an error occurs), the
@@ -807,17 +813,17 @@ tNFA_STATUS NFA_RwT3tWrite(uint8_t num_blocks, tNFA_T3T_BLOCK_DESC* t3t_blocks,
 **
 ** Returns:
 **      NFA_STATUS_OK if successfully initiated
-**      NFA_STATUS_WRONG_PROTOCOL: ISO 15693 tag not activated
+**      NFA_STATUS_WRONG_PROTOCOL: T5T tag not activated
 **      NFA_STATUS_FAILED otherwise
 **
 *******************************************************************************/
 tNFA_STATUS NFA_RwI93Inventory(bool afi_present, uint8_t afi, uint8_t* p_uid) {
   tNFA_RW_OPERATION* p_msg;
 
-  NFA_TRACE_API2("NFA_RwI93Inventory (): afi_present:%d, AFI: 0x%02X",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_RwI93Inventory (): afi_present:%d, AFI: 0x%02X",
                  afi_present, afi);
 
-  if (nfa_rw_cb.protocol != NFC_PROTOCOL_15693) {
+  if (nfa_rw_cb.protocol != NFC_PROTOCOL_T5T) {
     return (NFA_STATUS_WRONG_PROTOCOL);
   }
 
@@ -850,23 +856,23 @@ tNFA_STATUS NFA_RwI93Inventory(bool afi_present, uint8_t afi, uint8_t* p_uid) {
 ** Function         NFA_RwI93StayQuiet
 **
 ** Description:
-**      Send Stay Quiet command to the activated ISO 15693 tag.
+**      Send Stay Quiet command to the activated T5T tag.
 **
 **      When the operation has completed (or if an error occurs), the
 **      app will be notified with NFA_I93_CMD_CPLT_EVT.
 **
 ** Returns:
 **      NFA_STATUS_OK if successfully initiated
-**      NFA_STATUS_WRONG_PROTOCOL: ISO 15693 tag not activated
+**      NFA_STATUS_WRONG_PROTOCOL: T5T tag not activated
 **      NFA_STATUS_FAILED otherwise
 **
 *******************************************************************************/
 tNFA_STATUS NFA_RwI93StayQuiet(void) {
   tNFA_RW_OPERATION* p_msg;
 
-  NFA_TRACE_API0("NFA_RwI93StayQuiet ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
 
-  if (nfa_rw_cb.protocol != NFC_PROTOCOL_15693) {
+  if (nfa_rw_cb.protocol != NFC_PROTOCOL_T5T) {
     return (NFA_STATUS_WRONG_PROTOCOL);
   }
 
@@ -889,7 +895,7 @@ tNFA_STATUS NFA_RwI93StayQuiet(void) {
 ** Function         NFA_RwI93ReadSingleBlock
 **
 ** Description:
-**      Send Read Single Block command to the activated ISO 15693 tag.
+**      Send Read Single Block command to the activated T5T tag.
 **
 **      Data is returned to the application using the NFA_DATA_EVT. When the
 **      read operation has completed, or if an error occurs, the app will be
@@ -897,17 +903,17 @@ tNFA_STATUS NFA_RwI93StayQuiet(void) {
 **
 ** Returns:
 **      NFA_STATUS_OK if successfully initiated
-**      NFA_STATUS_WRONG_PROTOCOL: ISO 15693 tag not activated
+**      NFA_STATUS_WRONG_PROTOCOL: T5T tag not activated
 **      NFA_STATUS_FAILED otherwise
 **
 *******************************************************************************/
 tNFA_STATUS NFA_RwI93ReadSingleBlock(uint8_t block_number) {
   tNFA_RW_OPERATION* p_msg;
 
-  NFA_TRACE_API1("NFA_RwI93ReadSingleBlock (): block_number: 0x%02X",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_RwI93ReadSingleBlock (): block_number: 0x%02X",
                  block_number);
 
-  if (nfa_rw_cb.protocol != NFC_PROTOCOL_15693) {
+  if (nfa_rw_cb.protocol != NFC_PROTOCOL_T5T) {
     return (NFA_STATUS_WRONG_PROTOCOL);
   }
 
@@ -932,24 +938,24 @@ tNFA_STATUS NFA_RwI93ReadSingleBlock(uint8_t block_number) {
 ** Function         NFA_RwI93WriteSingleBlock
 **
 ** Description:
-**      Send Write Single Block command to the activated ISO 15693 tag.
+**      Send Write Single Block command to the activated T5T tag.
 **
 **      When the write operation has completed (or if an error occurs), the
 **      app will be notified with NFA_I93_CMD_CPLT_EVT.
 **
 ** Returns:
 **      NFA_STATUS_OK if successfully initiated
-**      NFA_STATUS_WRONG_PROTOCOL: ISO 15693 tag not activated
+**      NFA_STATUS_WRONG_PROTOCOL: T5T tag not activated
 **      NFA_STATUS_FAILED otherwise
 **
 *******************************************************************************/
 tNFA_STATUS NFA_RwI93WriteSingleBlock(uint8_t block_number, uint8_t* p_data) {
   tNFA_RW_OPERATION* p_msg;
 
-  NFA_TRACE_API1("NFA_RwI93WriteSingleBlock (): block_number: 0x%02X",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_RwI93WriteSingleBlock (): block_number: 0x%02X",
                  block_number);
 
-  if (nfa_rw_cb.protocol != NFC_PROTOCOL_15693) {
+  if (nfa_rw_cb.protocol != NFC_PROTOCOL_T5T) {
     return (NFA_STATUS_WRONG_PROTOCOL);
   }
 
@@ -983,23 +989,23 @@ tNFA_STATUS NFA_RwI93WriteSingleBlock(uint8_t block_number, uint8_t* p_data) {
 ** Function         NFA_RwI93LockBlock
 **
 ** Description:
-**      Send Lock block command to the activated ISO 15693 tag.
+**      Send Lock block command to the activated T5T tag.
 **
 **      When the operation has completed (or if an error occurs), the
 **      app will be notified with NFA_I93_CMD_CPLT_EVT.
 **
 ** Returns:
 **      NFA_STATUS_OK if successfully initiated
-**      NFA_STATUS_WRONG_PROTOCOL: ISO 15693 tag not activated
+**      NFA_STATUS_WRONG_PROTOCOL: T5T tag not activated
 **      NFA_STATUS_FAILED otherwise
 **
 *******************************************************************************/
 tNFA_STATUS NFA_RwI93LockBlock(uint8_t block_number) {
   tNFA_RW_OPERATION* p_msg;
 
-  NFA_TRACE_API1("NFA_RwI93LockBlock (): block_number: 0x%02X", block_number);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_RwI93LockBlock (): block_number: 0x%02X", block_number);
 
-  if (nfa_rw_cb.protocol != NFC_PROTOCOL_15693) {
+  if (nfa_rw_cb.protocol != NFC_PROTOCOL_T5T) {
     return (NFA_STATUS_WRONG_PROTOCOL);
   }
 
@@ -1024,7 +1030,7 @@ tNFA_STATUS NFA_RwI93LockBlock(uint8_t block_number) {
 ** Function         NFA_RwI93ReadMultipleBlocks
 **
 ** Description:
-**      Send Read Multiple Block command to the activated ISO 15693 tag.
+**      Send Read Multiple Block command to the activated T5T tag.
 **
 **      Data is returned to the application using the NFA_DATA_EVT. When the
 **      read operation has completed, or if an error occurs, the app will be
@@ -1032,7 +1038,7 @@ tNFA_STATUS NFA_RwI93LockBlock(uint8_t block_number) {
 **
 ** Returns:
 **      NFA_STATUS_OK if successfully initiated
-**      NFA_STATUS_WRONG_PROTOCOL: ISO 15693 tag not activated
+**      NFA_STATUS_WRONG_PROTOCOL: T5T tag not activated
 **      NFA_STATUS_FAILED otherwise
 **
 *******************************************************************************/
@@ -1040,10 +1046,10 @@ tNFA_STATUS NFA_RwI93ReadMultipleBlocks(uint8_t first_block_number,
                                         uint16_t number_blocks) {
   tNFA_RW_OPERATION* p_msg;
 
-  NFA_TRACE_API2("NFA_RwI93ReadMultipleBlocks(): %d, %d", first_block_number,
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_RwI93ReadMultipleBlocks(): %d, %d", first_block_number,
                  number_blocks);
 
-  if (nfa_rw_cb.protocol != NFC_PROTOCOL_15693) {
+  if (nfa_rw_cb.protocol != NFC_PROTOCOL_T5T) {
     return (NFA_STATUS_WRONG_PROTOCOL);
   }
 
@@ -1069,14 +1075,14 @@ tNFA_STATUS NFA_RwI93ReadMultipleBlocks(uint8_t first_block_number,
 ** Function         NFA_RwI93WriteMultipleBlocks
 **
 ** Description:
-**      Send Write Multiple Block command to the activated ISO 15693 tag.
+**      Send Write Multiple Block command to the activated T5T tag.
 **
 **      When the write operation has completed (or if an error occurs), the
 **      app will be notified with NFA_I93_CMD_CPLT_EVT.
 **
 ** Returns:
 **      NFA_STATUS_OK if successfully initiated
-**      NFA_STATUS_WRONG_PROTOCOL: ISO 15693 tag not activated
+**      NFA_STATUS_WRONG_PROTOCOL: T5T tag not activated
 **      NFA_STATUS_FAILED otherwise
 **
 *******************************************************************************/
@@ -1086,10 +1092,10 @@ tNFA_STATUS NFA_RwI93WriteMultipleBlocks(uint8_t first_block_number,
   tNFA_RW_OPERATION* p_msg;
   uint16_t data_length;
 
-  NFA_TRACE_API2("NFA_RwI93WriteMultipleBlocks (): %d, %d", first_block_number,
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_RwI93WriteMultipleBlocks (): %d, %d", first_block_number,
                  number_blocks);
 
-  if (nfa_rw_cb.protocol != NFC_PROTOCOL_15693) {
+  if (nfa_rw_cb.protocol != NFC_PROTOCOL_T5T) {
     return (NFA_STATUS_WRONG_PROTOCOL);
   }
 
@@ -1126,7 +1132,7 @@ tNFA_STATUS NFA_RwI93WriteMultipleBlocks(uint8_t first_block_number,
 ** Function         NFA_RwI93Select
 **
 ** Description:
-**      Send Select command to the activated ISO 15693 tag.
+**      Send Select command to the activated T5T tag.
 **
 **      UID[0]: 0xE0, MSB
 **      UID[1]: IC Mfg Code
@@ -1138,17 +1144,17 @@ tNFA_STATUS NFA_RwI93WriteMultipleBlocks(uint8_t first_block_number,
 **
 ** Returns:
 **      NFA_STATUS_OK if successfully initiated
-**      NFA_STATUS_WRONG_PROTOCOL: ISO 15693 tag not activated
+**      NFA_STATUS_WRONG_PROTOCOL: T5T tag not activated
 **      NFA_STATUS_FAILED otherwise
 **
 *******************************************************************************/
 tNFA_STATUS NFA_RwI93Select(uint8_t* p_uid) {
   tNFA_RW_OPERATION* p_msg;
 
-  NFA_TRACE_API3("NFA_RwI93Select (): UID: [%02X%02X%02X...]", *(p_uid),
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_RwI93Select (): UID: [%02X%02X%02X...]", *(p_uid),
                  *(p_uid + 1), *(p_uid + 2));
 
-  if (nfa_rw_cb.protocol != NFC_PROTOCOL_15693) {
+  if (nfa_rw_cb.protocol != NFC_PROTOCOL_T5T) {
     return (NFA_STATUS_WRONG_PROTOCOL);
   }
 
@@ -1175,23 +1181,23 @@ tNFA_STATUS NFA_RwI93Select(uint8_t* p_uid) {
 ** Function         NFA_RwI93ResetToReady
 **
 ** Description:
-**      Send Reset to ready command to the activated ISO 15693 tag.
+**      Send Reset to ready command to the activated T5T tag.
 **
 **      When the operation has completed (or if an error occurs), the
 **      app will be notified with NFA_I93_CMD_CPLT_EVT.
 **
 ** Returns:
 **      NFA_STATUS_OK if successfully initiated
-**      NFA_STATUS_WRONG_PROTOCOL: ISO 15693 tag not activated
+**      NFA_STATUS_WRONG_PROTOCOL: T5T tag not activated
 **      NFA_STATUS_FAILED otherwise
 **
 *******************************************************************************/
 tNFA_STATUS NFA_RwI93ResetToReady(void) {
   tNFA_RW_OPERATION* p_msg;
 
-  NFA_TRACE_API0("NFA_RwI93ResetToReady ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
 
-  if (nfa_rw_cb.protocol != NFC_PROTOCOL_15693) {
+  if (nfa_rw_cb.protocol != NFC_PROTOCOL_T5T) {
     return (NFA_STATUS_WRONG_PROTOCOL);
   }
 
@@ -1214,23 +1220,23 @@ tNFA_STATUS NFA_RwI93ResetToReady(void) {
 ** Function         NFA_RwI93WriteAFI
 **
 ** Description:
-**      Send Write AFI command to the activated ISO 15693 tag.
+**      Send Write AFI command to the activated T5T tag.
 **
 **      When the operation has completed (or if an error occurs), the
 **      app will be notified with NFA_I93_CMD_CPLT_EVT.
 **
 ** Returns:
 **      NFA_STATUS_OK if successfully initiated
-**      NFA_STATUS_WRONG_PROTOCOL: ISO 15693 tag not activated
+**      NFA_STATUS_WRONG_PROTOCOL: T5T tag not activated
 **      NFA_STATUS_FAILED otherwise
 **
 *******************************************************************************/
 tNFA_STATUS NFA_RwI93WriteAFI(uint8_t afi) {
   tNFA_RW_OPERATION* p_msg;
 
-  NFA_TRACE_API1("NFA_RwI93WriteAFI (): AFI: 0x%02X", afi);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_RwI93WriteAFI (): AFI: 0x%02X", afi);
 
-  if (nfa_rw_cb.protocol != NFC_PROTOCOL_15693) {
+  if (nfa_rw_cb.protocol != NFC_PROTOCOL_T5T) {
     return (NFA_STATUS_WRONG_PROTOCOL);
   }
 
@@ -1255,23 +1261,23 @@ tNFA_STATUS NFA_RwI93WriteAFI(uint8_t afi) {
 ** Function         NFA_RwI93LockAFI
 **
 ** Description:
-**      Send Lock AFI command to the activated ISO 15693 tag.
+**      Send Lock AFI command to the activated T5T tag.
 **
 **      When the operation has completed (or if an error occurs), the
 **      app will be notified with NFA_I93_CMD_CPLT_EVT.
 **
 ** Returns:
 **      NFA_STATUS_OK if successfully initiated
-**      NFA_STATUS_WRONG_PROTOCOL: ISO 15693 tag not activated
+**      NFA_STATUS_WRONG_PROTOCOL: T5T tag not activated
 **      NFA_STATUS_FAILED otherwise
 **
 *******************************************************************************/
 tNFA_STATUS NFA_RwI93LockAFI(void) {
   tNFA_RW_OPERATION* p_msg;
 
-  NFA_TRACE_API0("NFA_RwI93LockAFI ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
 
-  if (nfa_rw_cb.protocol != NFC_PROTOCOL_15693) {
+  if (nfa_rw_cb.protocol != NFC_PROTOCOL_T5T) {
     return (NFA_STATUS_WRONG_PROTOCOL);
   }
 
@@ -1294,23 +1300,23 @@ tNFA_STATUS NFA_RwI93LockAFI(void) {
 ** Function         NFA_RwI93WriteDSFID
 **
 ** Description:
-**      Send Write DSFID command to the activated ISO 15693 tag.
+**      Send Write DSFID command to the activated T5T tag.
 **
 **      When the operation has completed (or if an error occurs), the
 **      app will be notified with NFA_I93_CMD_CPLT_EVT.
 **
 ** Returns:
 **      NFA_STATUS_OK if successfully initiated
-**      NFA_STATUS_WRONG_PROTOCOL: ISO 15693 tag not activated
+**      NFA_STATUS_WRONG_PROTOCOL: T5T tag not activated
 **      NFA_STATUS_FAILED otherwise
 **
 *******************************************************************************/
 tNFA_STATUS NFA_RwI93WriteDSFID(uint8_t dsfid) {
   tNFA_RW_OPERATION* p_msg;
 
-  NFA_TRACE_API1("NFA_RwI93WriteDSFID (): DSFID: 0x%02X", dsfid);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_RwI93WriteDSFID (): DSFID: 0x%02X", dsfid);
 
-  if (nfa_rw_cb.protocol != NFC_PROTOCOL_15693) {
+  if (nfa_rw_cb.protocol != NFC_PROTOCOL_T5T) {
     return (NFA_STATUS_WRONG_PROTOCOL);
   }
 
@@ -1335,23 +1341,23 @@ tNFA_STATUS NFA_RwI93WriteDSFID(uint8_t dsfid) {
 ** Function         NFA_RwI93LockDSFID
 **
 ** Description:
-**      Send Lock DSFID command to the activated ISO 15693 tag.
+**      Send Lock DSFID command to the activated T5T tag.
 **
 **      When the operation has completed (or if an error occurs), the
 **      app will be notified with NFA_I93_CMD_CPLT_EVT.
 **
 ** Returns:
 **      NFA_STATUS_OK if successfully initiated
-**      NFA_STATUS_WRONG_PROTOCOL: ISO 15693 tag not activated
+**      NFA_STATUS_WRONG_PROTOCOL: T5T tag not activated
 **      NFA_STATUS_FAILED otherwise
 **
 *******************************************************************************/
 tNFA_STATUS NFA_RwI93LockDSFID(void) {
   tNFA_RW_OPERATION* p_msg;
 
-  NFA_TRACE_API0("NFA_RwI93LockDSFID ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
 
-  if (nfa_rw_cb.protocol != NFC_PROTOCOL_15693) {
+  if (nfa_rw_cb.protocol != NFC_PROTOCOL_T5T) {
     return (NFA_STATUS_WRONG_PROTOCOL);
   }
 
@@ -1374,7 +1380,7 @@ tNFA_STATUS NFA_RwI93LockDSFID(void) {
 ** Function         NFA_RwI93GetSysInfo
 **
 ** Description:
-**      Send Get system information command to the activated ISO 15693 tag.
+**      Send Get system information command to the activated T5T tag.
 **      If UID is provided then set UID[0]:MSB, ... UID[7]:LSB
 **
 **      When the operation has completed (or if an error occurs), the
@@ -1382,16 +1388,16 @@ tNFA_STATUS NFA_RwI93LockDSFID(void) {
 **
 ** Returns:
 **      NFA_STATUS_OK if successfully initiated
-**      NFA_STATUS_WRONG_PROTOCOL: ISO 15693 tag not activated
+**      NFA_STATUS_WRONG_PROTOCOL: T5T tag not activated
 **      NFA_STATUS_FAILED otherwise
 **
 *******************************************************************************/
 tNFA_STATUS NFA_RwI93GetSysInfo(uint8_t* p_uid) {
   tNFA_RW_OPERATION* p_msg;
 
-  NFA_TRACE_API0("NFA_RwI93GetSysInfo ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
 
-  if (nfa_rw_cb.protocol != NFC_PROTOCOL_15693) {
+  if (nfa_rw_cb.protocol != NFC_PROTOCOL_T5T) {
     return (NFA_STATUS_WRONG_PROTOCOL);
   }
 
@@ -1421,8 +1427,8 @@ tNFA_STATUS NFA_RwI93GetSysInfo(uint8_t* p_uid) {
 ** Function         NFA_RwI93GetMultiBlockSecurityStatus
 **
 ** Description:
-**      Send Get Multiple block security status command to the activated ISO
-**      15693 tag.
+**      Send Get Multiple block security status command to the activated
+**      T5T tag.
 **
 **      Data is returned to the application using the NFA_DATA_EVT. When the
 **      read operation has completed, or if an error occurs, the app will be
@@ -1430,7 +1436,7 @@ tNFA_STATUS NFA_RwI93GetSysInfo(uint8_t* p_uid) {
 **
 ** Returns:
 **      NFA_STATUS_OK if successfully initiated
-**      NFA_STATUS_WRONG_PROTOCOL: ISO 15693 tag not activated
+**      NFA_STATUS_WRONG_PROTOCOL: T5T tag not activated
 **      NFA_STATUS_FAILED otherwise
 **
 *******************************************************************************/
@@ -1438,10 +1444,10 @@ tNFA_STATUS NFA_RwI93GetMultiBlockSecurityStatus(uint8_t first_block_number,
                                                  uint16_t number_blocks) {
   tNFA_RW_OPERATION* p_msg;
 
-  NFA_TRACE_API2("NFA_RwI93GetMultiBlockSecurityStatus(): %d, %d",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_RwI93GetMultiBlockSecurityStatus(): %d, %d",
                  first_block_number, number_blocks);
 
-  if (nfa_rw_cb.protocol != NFC_PROTOCOL_15693) {
+  if (nfa_rw_cb.protocol != NFC_PROTOCOL_T5T) {
     return (NFA_STATUS_WRONG_PROTOCOL);
   }
 
diff --git a/src/nfa/rw/nfa_rw_main.c b/src/nfa/rw/nfa_rw_main.cc
similarity index 89%
rename from src/nfa/rw/nfa_rw_main.c
rename to src/nfa/rw/nfa_rw_main.cc
index 3c409bf..9c8747d 100644
--- a/src/nfa/rw/nfa_rw_main.c
+++ b/src/nfa/rw/nfa_rw_main.cc
@@ -22,11 +22,18 @@
  *
  ******************************************************************************/
 #include <string.h>
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfa_rw_api.h"
-#include "nfa_sys.h"
 #include "nfa_rw_int.h"
 #include "nfa_dm_int.h"
-#include "nfa_sys_int.h"
+
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+
 
 /* NFA_RW control block */
 tNFA_RW_CB nfa_rw_cb;
@@ -49,10 +56,7 @@ const tNFA_RW_ACTION nfa_rw_action_tbl[] = {
 /*****************************************************************************
 ** Local function prototypes
 *****************************************************************************/
-#if (BT_TRACE_VERBOSE == true)
-static char* nfa_rw_evt_2_str(uint16_t event);
-#endif
-
+static std::string nfa_rw_evt_2_str(uint16_t event);
 /*******************************************************************************
 **
 ** Function         nfa_rw_init
@@ -63,7 +67,7 @@ static char* nfa_rw_evt_2_str(uint16_t event);
 **
 *******************************************************************************/
 void nfa_rw_init(void) {
-  NFA_TRACE_DEBUG0("nfa_rw_init ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_rw_init ()");
 
   /* initialize control block */
   memset(&nfa_rw_cb, 0, sizeof(tNFA_RW_CB));
@@ -120,13 +124,13 @@ void nfa_rw_proc_disc_evt(tNFA_DM_RF_DISC_EVT event, tNFC_DISCOVER* p_data,
       msg.activate_ntf.p_activate_params = &p_data->activate;
       msg.activate_ntf.excl_rf_not_active = excl_rf_not_active;
 
-      nfa_rw_handle_event((void*)&msg);
+      nfa_rw_handle_event((NFC_HDR*)&msg);
       break;
 
     case NFA_DM_RF_DISC_DEACTIVATED_EVT:
       msg.hdr.event = NFA_RW_DEACTIVATE_NTF_EVT;
 
-      nfa_rw_handle_event((void*)&msg);
+      nfa_rw_handle_event((NFC_HDR*)&msg);
       break;
 
     default:
@@ -172,27 +176,21 @@ tNFA_STATUS nfa_rw_send_raw_frame(NFC_HDR* p_data) {
 bool nfa_rw_handle_event(NFC_HDR* p_msg) {
   uint16_t act_idx;
 
-#if (BT_TRACE_VERBOSE == true)
-  NFA_TRACE_EVENT3("nfa_rw_handle_event event: %s (0x%02x), flags: %08x",
-                   nfa_rw_evt_2_str(p_msg->event), p_msg->event,
-                   nfa_rw_cb.flags);
-#else
-  NFA_TRACE_EVENT2("nfa_rw_handle_event event: 0x%x, flags: %08x", p_msg->event,
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_rw_handle_event event: %s (0x%02x), flags: %08x",
+                   nfa_rw_evt_2_str(p_msg->event).c_str(), p_msg->event,
                    nfa_rw_cb.flags);
-#endif
 
   /* Get NFA_RW sub-event */
   act_idx = (p_msg->event & 0x00FF);
   if (act_idx < (NFA_RW_MAX_EVT & 0xFF)) {
     return (*nfa_rw_action_tbl[act_idx])((tNFA_RW_MSG*)p_msg);
   } else {
-    NFA_TRACE_ERROR1("nfa_rw_handle_event: unhandled event 0x%02X",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_rw_handle_event: unhandled event 0x%02X",
                      p_msg->event);
     return true;
   }
 }
 
-#if (BT_TRACE_VERBOSE == true)
 /*******************************************************************************
 **
 ** Function         nfa_rw_evt_2_str
@@ -200,7 +198,7 @@ bool nfa_rw_handle_event(NFC_HDR* p_msg) {
 ** Description      convert nfa_rw evt to string
 **
 *******************************************************************************/
-static char* nfa_rw_evt_2_str(uint16_t event) {
+static std::string nfa_rw_evt_2_str(uint16_t event) {
   switch (event) {
     case NFA_RW_OP_REQUEST_EVT:
       return "NFA_RW_OP_REQUEST_EVT";
@@ -221,4 +219,3 @@ static char* nfa_rw_evt_2_str(uint16_t event) {
       return "Unknown";
   }
 }
-#endif /* BT_TRACE_VERBOSE */
diff --git a/src/nfa/sys/nfa_sys_cback.c b/src/nfa/sys/nfa_sys_cback.cc
similarity index 95%
rename from src/nfa/sys/nfa_sys_cback.c
rename to src/nfa/sys/nfa_sys_cback.cc
index 44de648..ab1d56a 100644
--- a/src/nfa/sys/nfa_sys_cback.c
+++ b/src/nfa/sys/nfa_sys_cback.cc
@@ -21,9 +21,16 @@
  *  Registration/deregistration functions for inter-module callbacks
  *
  ******************************************************************************/
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfa_sys.h"
 #include "nfa_sys_int.h"
 
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+
 /*******************************************************************************
 **
 ** Function         nfa_sys_cback_reg_enable_complete
@@ -52,7 +59,7 @@ void nfa_sys_cback_reg_enable_complete(tNFA_SYS_ENABLE_CBACK* p_cback) {
 void nfa_sys_cback_notify_enable_complete(uint8_t id) {
   nfa_sys_cb.enable_cplt_flags |= (0x0001 << id);
 
-  NFA_TRACE_DEBUG2(
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "nfa_sys_cback_notify_enable_complete () enable_cplt_flags=0x%x, "
       "enable_cplt_mask=0x%x",
       nfa_sys_cb.enable_cplt_flags, nfa_sys_cb.enable_cplt_mask);
@@ -110,7 +117,7 @@ void nfa_sys_cback_reg_nfcc_power_mode_proc_complete(
 void nfa_sys_cback_notify_nfcc_power_mode_proc_complete(uint8_t id) {
   nfa_sys_cb.proc_nfcc_pwr_mode_cplt_flags |= (0x0001 << id);
 
-  NFA_TRACE_DEBUG2(
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "nfa_sys_cback_notify_nfcc_power_mode_proc_complete () flags=0x%x, "
       "mask=0x%x",
       nfa_sys_cb.proc_nfcc_pwr_mode_cplt_flags,
diff --git a/src/nfa/sys/nfa_sys_cfg.c b/src/nfa/sys/nfa_sys_cfg.cc
similarity index 94%
rename from src/nfa/sys/nfa_sys_cfg.c
rename to src/nfa/sys/nfa_sys_cfg.cc
index aaaf15e..ccf01f2 100644
--- a/src/nfa/sys/nfa_sys_cfg.c
+++ b/src/nfa/sys/nfa_sys_cfg.cc
@@ -23,7 +23,6 @@
  *
  ******************************************************************************/
 
-#include "nfc_target.h"
 #include "gki.h"
 #include "nfa_sys.h"
 
@@ -31,7 +30,6 @@ const tNFA_SYS_CFG nfa_sys_cfg = {
     NFA_MBOX_EVT_MASK,       /* GKI mailbox event */
     NFA_MBOX_ID,             /* GKI mailbox id */
     NFA_TIMER_ID,            /* GKI timer id */
-    APPL_INITIAL_TRACE_LEVEL /* initial trace level */
 };
 
 tNFA_SYS_CFG* p_nfa_sys_cfg = (tNFA_SYS_CFG*)&nfa_sys_cfg;
diff --git a/src/nfa/sys/nfa_sys_main.c b/src/nfa/sys/nfa_sys_main.cc
old mode 100644
new mode 100755
similarity index 90%
rename from src/nfa/sys/nfa_sys_main.c
rename to src/nfa/sys/nfa_sys_main.cc
index 28e2c22..8ca899e
--- a/src/nfa/sys/nfa_sys_main.c
+++ b/src/nfa/sys/nfa_sys_main.cc
@@ -22,10 +22,12 @@
  *
  ******************************************************************************/
 #include <string.h>
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfa_api.h"
-#include "nfa_sys.h"
 #include "nfa_sys_int.h"
-#include "nfa_sys_ptim.h"
 #include "nfa_dm_int.h"
 
 /* protocol timer update period, in milliseconds */
@@ -33,9 +35,14 @@
 #define NFA_SYS_TIMER_PERIOD 10
 #endif
 
+
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+
 /* system manager control block definition */
-tNFA_SYS_CB nfa_sys_cb = {.flags = 0}; /* nfa_sys control block. statically
-                                          initialize 'flags' field to 0 */
+tNFA_SYS_CB nfa_sys_cb = {};
+/* nfa_sys control block. statically initialize 'flags' field to 0 */
 
 /*******************************************************************************
 **
@@ -52,7 +59,6 @@ void nfa_sys_init(void) {
   nfa_sys_cb.flags |= NFA_SYS_FL_INITIALIZED;
   nfa_sys_ptim_init(&nfa_sys_cb.ptim_cb, NFA_SYS_TIMER_PERIOD,
                     p_nfa_sys_cfg->timer);
-  nfa_sys_cb.trace_level = p_nfa_sys_cfg->trace_level;
 }
 
 /*******************************************************************************
@@ -69,7 +75,7 @@ void nfa_sys_event(NFC_HDR* p_msg) {
   uint8_t id;
   bool freebuf = true;
 
-  NFA_TRACE_EVENT1("NFA got event 0x%04X", p_msg->event);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA got event 0x%04X", p_msg->event);
 
   /* get subsystem id from event */
   id = (uint8_t)(p_msg->event >> 8);
@@ -78,7 +84,7 @@ void nfa_sys_event(NFC_HDR* p_msg) {
   if ((id < NFA_ID_MAX) && (nfa_sys_cb.is_reg[id])) {
     freebuf = (*nfa_sys_cb.reg[id]->evt_hdlr)(p_msg);
   } else {
-    NFA_TRACE_WARNING1("NFA got unregistered event id %d", id);
+    LOG(WARNING) << StringPrintf("NFA got unregistered event id %d", id);
   }
 
   if (freebuf) {
@@ -124,7 +130,7 @@ void nfa_sys_register(uint8_t id, const tNFA_SYS_REG* p_reg) {
       nfa_sys_cb.proc_nfcc_pwr_mode_cplt_mask |= (0x0001 << id);
   }
 
-  NFA_TRACE_DEBUG2("nfa_sys_register () id=%i, enable_cplt_mask=0x%x", id,
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_sys_register () id=%i, enable_cplt_mask=0x%x", id,
                    nfa_sys_cb.enable_cplt_mask);
 }
 
@@ -169,7 +175,7 @@ void nfa_sys_check_disabled(void) {
 **
 *******************************************************************************/
 void nfa_sys_deregister(uint8_t id) {
-  NFA_TRACE_DEBUG1("nfa_sys: deregistering subsystem %i", id);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_sys: deregistering subsystem %i", id);
 
   nfa_sys_cb.is_reg[id] = false;
 
@@ -226,7 +232,7 @@ bool nfa_sys_is_graceful_disable(void) { return nfa_sys_cb.graceful_disable; }
 void nfa_sys_enable_subsystems(void) {
   uint8_t id;
 
-  NFA_TRACE_DEBUG0("nfa_sys: enabling subsystems");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_sys: enabling subsystems");
 
   /* Enable all subsystems except SYS */
   for (id = NFA_ID_DM; id < NFA_ID_MAX; id++) {
@@ -256,7 +262,7 @@ void nfa_sys_disable_subsystems(bool graceful) {
   uint8_t id;
   bool done = true;
 
-  NFA_TRACE_DEBUG1("nfa_sys: disabling subsystems:%d", graceful);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_sys: disabling subsystems:%d", graceful);
   nfa_sys_cb.graceful_disable = graceful;
 
   /* Disable all subsystems above NFA_DM. (NFA_DM and NFA_SYS will be disabled
@@ -293,7 +299,7 @@ void nfa_sys_disable_subsystems(bool graceful) {
 void nfa_sys_notify_nfcc_power_mode(uint8_t nfcc_power_mode) {
   uint8_t id;
 
-  NFA_TRACE_DEBUG1("nfa_sys: notify NFCC power mode(%d) to subsystems",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_sys: notify NFCC power mode(%d) to subsystems",
                    nfcc_power_mode);
 
   /* Notify NFCC power state to all subsystems except NFA_SYS */
@@ -359,14 +365,3 @@ void nfa_sys_stop_timer(TIMER_LIST_ENT* p_tle) {
 **
 *******************************************************************************/
 void nfa_sys_disable_timers(void) { nfa_sys_cb.timers_disabled = true; }
-
-/*******************************************************************************
-**
-** Function         nfa_sys_set_trace_level
-**
-** Description      Set trace level for BTA
-**
-** Returns          void
-**
-*******************************************************************************/
-void nfa_sys_set_trace_level(uint8_t level) { nfa_sys_cb.trace_level = level; }
diff --git a/src/nfa/sys/nfa_sys_ptim.c b/src/nfa/sys/nfa_sys_ptim.cc
similarity index 89%
rename from src/nfa/sys/nfa_sys_ptim.c
rename to src/nfa/sys/nfa_sys_ptim.cc
index cd9341c..798051f 100644
--- a/src/nfa/sys/nfa_sys_ptim.c
+++ b/src/nfa/sys/nfa_sys_ptim.cc
@@ -21,12 +21,15 @@
  *  Protocol timer services (taken from bta ptim)
  *
  ******************************************************************************/
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
 
-#include "nfc_target.h"
-#include "gki.h"
 #include "nfa_sys_ptim.h"
 #include "nfa_sys.h"
-#include "nfa_sys_int.h"
+
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
 
 /*******************************************************************************
 **
@@ -86,7 +89,7 @@ void nfa_sys_ptim_timer_update(tPTIM_CB* p_cb) {
          (p_cb->timer_queue.p_first->ticks <= 0)) {
     /* removed expired timer from list */
     p_tle = p_cb->timer_queue.p_first;
-    NFA_TRACE_DEBUG1("nfa_sys_ptim_timer_update expired: %08x", p_tle);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_sys_ptim_timer_update expired: %p", p_tle);
     GKI_remove_from_timer_list(&p_cb->timer_queue, p_tle);
 
     /* call timer callback */
@@ -104,7 +107,7 @@ void nfa_sys_ptim_timer_update(tPTIM_CB* p_cb) {
 
   /* if timer list is empty stop periodic GKI timer */
   if (p_cb->timer_queue.p_first == NULL) {
-    NFA_TRACE_DEBUG0("ptim timer stop");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("ptim timer stop");
     GKI_stop_timer(p_cb->timer_id);
   }
 }
@@ -121,11 +124,11 @@ void nfa_sys_ptim_timer_update(tPTIM_CB* p_cb) {
 *******************************************************************************/
 void nfa_sys_ptim_start_timer(tPTIM_CB* p_cb, TIMER_LIST_ENT* p_tle,
                               uint16_t type, int32_t timeout) {
-  NFA_TRACE_DEBUG1("nfa_sys_ptim_start_timer %08x", p_tle);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_sys_ptim_start_timer %p", p_tle);
 
   /* if timer list is currently empty, start periodic GKI timer */
   if (p_cb->timer_queue.p_first == NULL) {
-    NFA_TRACE_DEBUG0("ptim timer start");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("ptim timer start");
     p_cb->last_gki_ticks = GKI_get_tick_count();
     GKI_start_timer(p_cb->timer_id, GKI_MS_TO_TICKS(p_cb->period), true);
   }
@@ -148,13 +151,13 @@ void nfa_sys_ptim_start_timer(tPTIM_CB* p_cb, TIMER_LIST_ENT* p_tle,
 **
 *******************************************************************************/
 void nfa_sys_ptim_stop_timer(tPTIM_CB* p_cb, TIMER_LIST_ENT* p_tle) {
-  NFA_TRACE_DEBUG1("nfa_sys_ptim_stop_timer %08x", p_tle);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfa_sys_ptim_stop_timer %p", p_tle);
 
   GKI_remove_from_timer_list(&p_cb->timer_queue, p_tle);
 
   /* if timer list is empty stop periodic GKI timer */
   if (p_cb->timer_queue.p_first == NULL) {
-    NFA_TRACE_DEBUG0("ptim timer stop");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("ptim timer stop");
     GKI_stop_timer(p_cb->timer_id);
   }
 }
diff --git a/src/nfc/include/ce_api.h b/src/nfc/include/ce_api.h
index be3fcbc..9fa25df 100644
--- a/src/nfc/include/ce_api.h
+++ b/src/nfc/include/ce_api.h
@@ -38,26 +38,16 @@ enum {
   CE_T3T_NDEF_UPDATE_START_EVT = CE_T3T_FIRST_EVT,
   CE_T3T_NDEF_UPDATE_CPLT_EVT,
   CE_T3T_UPDATE_EVT,
-  CE_T3T_CHECK_EVT,
   CE_T3T_RAW_FRAME_EVT,
-  CE_T3T_MAX_EVT,
 
   CE_T4T_NDEF_UPDATE_START_EVT = CE_T4T_FIRST_EVT,
   CE_T4T_NDEF_UPDATE_CPLT_EVT,
   CE_T4T_NDEF_UPDATE_ABORT_EVT,
-  CE_T4T_RAW_FRAME_EVT,
-  CE_T4T_MAX_EVT
+  CE_T4T_RAW_FRAME_EVT
 };
 
-#define CE_RAW_FRAME_EVT 0xFF
-
 typedef uint8_t tCE_EVENT;
 
-typedef struct {
-  tNFC_STATUS status;
-  NFC_HDR* p_data;
-} tCE_T2T_DATA;
-
 typedef struct {
   tNFC_STATUS status;
   uint8_t* p_data;
@@ -192,33 +182,6 @@ extern tCE_T4T_AID_HANDLE CE_T4tRegisterAID(uint8_t aid_len, uint8_t* p_aid,
 *******************************************************************************/
 extern void CE_T4tDeregisterAID(tCE_T4T_AID_HANDLE aid_handle);
 
-/*******************************************************************************
-**
-** Function         CE_T4TTestSetCC
-**
-** Description      Set fields in Capability Container File for testing
-**
-** Returns          NFC_STATUS_OK if success
-**
-*******************************************************************************/
-extern tNFC_STATUS CE_T4TTestSetCC(uint16_t cc_len, uint8_t version,
-                                   uint16_t max_le, uint16_t max_lc);
-
-/*******************************************************************************
-**
-** Function         CE_T4TTestSetNDEFCtrlTLV
-**
-** Description      Set fields in NDEF File Control TLV for testing
-**
-** Returns          NFC_STATUS_OK if success
-**
-*******************************************************************************/
-extern tNFC_STATUS CE_T4TTestSetNDEFCtrlTLV(uint8_t type, uint8_t length,
-                                            uint16_t file_id,
-                                            uint16_t max_file_size,
-                                            uint8_t read_access,
-                                            uint8_t write_access);
-
 /*******************************************************************************
 **
 ** Function         CE_SendRawFrame
@@ -243,17 +206,4 @@ extern tNFC_STATUS CE_SetActivatedTagType(tNFC_ACTIVATE_DEVT* p_activate_params,
                                           uint16_t t3t_system_code,
                                           tCE_CBACK* p_cback);
 
-/*******************************************************************************
-**
-** Function         CE_SetTraceLevel
-**
-** Description      This function sets the trace level for Card Emulation mode.
-**                  If called with a value of 0xFF,
-**                  it simply returns the current trace level.
-**
-** Returns          The new or current trace level
-**
-*******************************************************************************/
-extern uint8_t CE_SetTraceLevel(uint8_t new_level);
-
-#endif /* CE_API_H */
+#endif /* CE_API_H */
\ No newline at end of file
diff --git a/src/nfc/int/ce_int.h b/src/nfc/include/ce_int.h
similarity index 96%
rename from src/nfc/int/ce_int.h
rename to src/nfc/include/ce_int.h
index 4965dcb..59c525d 100644
--- a/src/nfc/int/ce_int.h
+++ b/src/nfc/include/ce_int.h
@@ -36,9 +36,6 @@
 #define CE_MAX_SUP_PROTO NCI_PROTOCOL_MIFARE
 #endif
 
-/* 2^8=256. CB use uint8_t for BytesPerPage, so max is 7 */
-#define CE_MAX_BYTE_PER_PAGE 7
-
 /* CE Type 3 Tag structures */
 
 /* Type 3 Tag NDEF card-emulation */
@@ -133,8 +130,6 @@ typedef struct {
   uint16_t ndef_max; /* max size of p_ndef */
   uint16_t ndef_cur; /* current size of p_ndef */
   tNFC_RF_TECH tech;
-  uint8_t trace_level;
-
 } tCE_CB;
 
 /*
@@ -155,10 +150,6 @@ typedef struct {
 /*****************************************************************************
 **  EXTERNAL FUNCTION DECLARATIONS
 *****************************************************************************/
-#ifdef __cplusplus
-extern "C" {
-#endif
-
 /* Global NFC data */
 extern tCE_CB ce_cb;
 
@@ -173,8 +164,5 @@ tNFC_STATUS ce_select_t3t(uint16_t system_code,
 extern tNFC_STATUS ce_select_t4t(void);
 extern void ce_t4t_process_timeout(TIMER_LIST_ENT* p_tle);
 
-#ifdef __cplusplus
-}
-#endif
 
 #endif /* CE_INT_H_ */
diff --git a/src/nfc/include/llcp_api.h b/src/nfc/include/llcp_api.h
old mode 100644
new mode 100755
index a0bc10a..41fffec
--- a/src/nfc/include/llcp_api.h
+++ b/src/nfc/include/llcp_api.h
@@ -20,7 +20,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -44,6 +44,7 @@
 #ifndef LLCP_API_H
 #define LLCP_API_H
 
+#include <string>
 #include "nfc_target.h"
 #include "llcp_defs.h"
 
@@ -106,8 +107,6 @@ typedef struct {
 #define LLCP_LINK_VERSION_FAILED 0x01
 /* Failed to parse received general bytes   */
 #define LLCP_LINK_BAD_GEN_BYTES 0x02
-/* internal error                           */
-#define LLCP_LINK_INTERNAL_ERROR 0x03
 /* Link has been deactivated by local       */
 #define LLCP_LINK_LOCAL_INITIATED 0x04
 /* Link has been deactivated by remote      */
@@ -119,9 +118,6 @@ typedef struct {
 /* RF link loss without any rx LLC PDU      */
 #define LLCP_LINK_RF_LINK_LOSS_NO_RX_LLC 0x08
 
-#define LLCP_LINK_RF_TRANSMISSION_ERR NFC_STATUS_RF_TRANSMISSION_ERR
-#define LLCP_LINK_RF_PROTOCOL_ERR NFC_STATUS_RF_PROTOCOL_ERR
-#define LLCP_LINK_RF_TIMEOUT NFC_STATUS_TIMEOUT
 #define LLCP_LINK_RF_LINK_LOSS_ERR NFC_STATUS_LINK_LOSS
 
 typedef void(tLLCP_LINK_CBACK)(uint8_t event, uint8_t reason);
@@ -243,10 +239,6 @@ typedef void(tLLCP_DTA_CBACK)(void);
 /*****************************************************************************
 **  External Function Declarations
 *****************************************************************************/
-#ifdef __cplusplus
-extern "C" {
-#endif
-
 /*******************************************************************************
 **
 ** Function         LLCP_SetConfig
@@ -377,7 +369,7 @@ extern tLLCP_STATUS LLCP_DeactivateLink(void);
 **
 *******************************************************************************/
 extern uint8_t LLCP_RegisterServer(uint8_t reg_sap, uint8_t link_type,
-                                   char* p_service_name,
+                                   std::string p_service_name,
                                    tLLCP_APP_CBACK* p_sap_cback);
 
 /*******************************************************************************
@@ -679,19 +671,6 @@ extern void LLCP_GetLinkMIU(uint16_t* p_local_link_miu,
 extern tLLCP_STATUS LLCP_DiscoverService(char* p_name, tLLCP_SDP_CBACK* p_cback,
                                          uint8_t* p_tid);
 
-/*******************************************************************************
-**
-** Function         LLCP_SetTraceLevel
-**
-** Description      This function sets the trace level for LLCP.  If called with
-**                  a value of 0xFF, it simply returns the current trace level.
-**
-** Returns          The new or current trace level
-**
-*******************************************************************************/
-extern uint8_t LLCP_SetTraceLevel(uint8_t new_level);
-
-#if (NXP_EXTNS == TRUE)
 /*******************************************************************************
 **
 ** Function         LLCP_RegisterDtaCback
@@ -703,7 +682,6 @@ extern uint8_t LLCP_SetTraceLevel(uint8_t new_level);
 **
 *******************************************************************************/
 extern void LLCP_RegisterDtaCback(tLLCP_DTA_CBACK* p_dta_cback);
-#endif
 
 #if (LLCP_TEST_INCLUDED == true)
 /*******************************************************************************
@@ -718,8 +696,4 @@ extern void LLCP_RegisterDtaCback(tLLCP_DTA_CBACK* p_dta_cback);
 extern void LLCP_SetTestParams(uint8_t version, uint16_t wks);
 #endif
 
-#ifdef __cplusplus
-}
-#endif
-
 #endif /* LLCP_API_H */
diff --git a/src/nfc/include/llcp_defs.h b/src/nfc/include/llcp_defs.h
old mode 100644
new mode 100755
index ba25710..f79c029
--- a/src/nfc/include/llcp_defs.h
+++ b/src/nfc/include/llcp_defs.h
@@ -52,12 +52,9 @@
 #define LLCP_PDU_DM_TYPE 7
 #define LLCP_PDU_FRMR_TYPE 8
 #define LLCP_PDU_SNL_TYPE 9
-#define LLCP_PDU_RESERVED_1010 10
-#define LLCP_PDU_RESERVED_1011 11
 #define LLCP_PDU_I_TYPE 12
 #define LLCP_PDU_RR_TYPE 13
 #define LLCP_PDU_RNR_TYPE 14
-#define LLCP_PDU_RESERVED_1111 15
 
 #define LLCP_PDU_SYMM_SIZE 2
 #define LLCP_PDU_DISC_SIZE 2
@@ -81,16 +78,6 @@
 #define LLCP_FRMR_R_ERROR_FLAG 0x02 /* Receive Sequence Error */
 #define LLCP_FRMR_S_ERROR_FLAG 0x01 /* Send Sequence Error */
 
-#define LLCP_GET_FRMR_W_ERROR_FLAG(u8) (((uint8_t)(u8) >> 7) & 0x01)
-#define LLCP_GET_FRMR_I_ERROR_FLAG(u8) (((uint8_t)(u8) >> 6) & 0x01)
-#define LLCP_GET_FRMR_R_ERROR_FLAG(u8) (((uint8_t)(u8) >> 5) & 0x01)
-#define LLCP_GET_FRMR_S_ERROR_FLAG(u8) (((uint8_t)(u8) >> 4) & 0x01)
-#define LLCP_GET_FRMR_PTYPE(u8) ((uint8_t)(u8)&0x0F)
-#define LLCP_GET_FRMR_VS(u16) (((uint16_t)(u16) >> 12) & 0x000F)
-#define LLCP_GET_FRMR_VR(u16) (((uint16_t)(u16) >> 8) & 0x000F)
-#define LLCP_GET_FRMR_VSA(u16) (((uint16_t)(u16) >> 4) & 0x000F)
-#define LLCP_GET_FRMR_VRA(u16) (((uint16_t)(u16) >> 0) & 0x000F)
-
 /*
 ** LLCP Parameter Descriptions
 */
@@ -122,21 +109,10 @@
 
 /* Well-Known Service Bitmap */
 #define LLCP_WKS_MASK_LM 0x0001  /* Link Management */
-#define LLCP_WKS_MASK_SDP 0x0002 /* Service Discovery "urn:nfc:sn:sdp" */
-#define LLCP_WKS_MASK_IP 0x0004  /* IP over LLCP Binding "urn:nfc:sn:ip" */
-/* OBEX over LLCP Binding "urn:nfc:sn:obex" */
-#define LLCP_WKS_MASK_OBEX 0x0008
-/* Simple NDEP Exchange Protocol "urn:nfc:sn:snep" */
-#define LLCP_WKS_MASK_SNEP 0x0010
 
 /* Well-Known Service Access Points */
 #define LLCP_SAP_LM 0x00  /* Link Management */
 #define LLCP_SAP_SDP 0x01 /* Service Discovery "urn:nfc:sn:sdp" */
-#define LLCP_SAP_IP 0x02  /* IP over LLCP Binding "urn:nfc:sn:ip" */
-/* OBEX over LLCP Binding "urn:nfc:sn:obex" */
-#define LLCP_SAP_OBEX 0x03
-/* Simple NDEP Exchange Protocol "urn:nfc:sn:snep" */
-#define LLCP_SAP_SNEP 0x04
 
 /* Link Timeout, LTO */
 #define LLCP_LTO_TYPE 0x04
@@ -157,7 +133,6 @@
 /* Option, OPT */
 #define LLCP_OPT_TYPE 0x07
 #define LLCP_OPT_LEN 0x01
-#define LLCP_GET_OPT_LSC(u8) ((uint8_t)(u8)&0x03)
 
 /* Service Discovery Request, SDREQ */
 #define LLCP_SDREQ_TYPE 0x08
@@ -182,7 +157,6 @@
 #define LLCP_SEQ_MODULO 16
 
 #define LLCP_NUM_SAPS 64
-#define LLCP_LOWER_BOUND_WK_SAP 0x00
 #define LLCP_UPPER_BOUND_WK_SAP 0x0F
 #define LLCP_LOWER_BOUND_SDP_SAP 0x10
 #define LLCP_UPPER_BOUND_SDP_SAP 0x1F
@@ -192,10 +166,6 @@
 /* Max Payload */
 /* Maximum Payload size, Length Reduction LRi/LRt */
 #define LLCP_NCI_MAX_PAYL_SIZE 254
-/* Data exchange protocol header, 3 bytes */
-#define LLCP_NFC_DEP_HEADER_SIZE 3
-#define LLCP_MAX_PAYLOAD_SIZE \
-  (LLCP_NCI_MAX_PAYL_SIZE - LLCP_NFC_DEP_HEADER_SIZE)
 
 #define LLCP_MAX_GEN_BYTES 48
 
diff --git a/src/nfc/int/llcp_int.h b/src/nfc/include/llcp_int.h
similarity index 96%
rename from src/nfc/int/llcp_int.h
rename to src/nfc/include/llcp_int.h
index 51473d9..723cf2c 100644
--- a/src/nfc/int/llcp_int.h
+++ b/src/nfc/include/llcp_int.h
@@ -20,7 +20,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -127,7 +127,7 @@ typedef struct {
 
 typedef struct {
   uint8_t link_type;       /* logical link and/or data link                */
-  uint8_t* p_service_name; /* GKI buffer containing service name           */
+  char* p_service_name; /* GKI buffer containing service name           */
   tLLCP_APP_CBACK* p_app_cback; /* application's callback pointer */
 
   BUFFER_Q ui_xmit_q;      /* UI PDU queue for transmitting                */
@@ -145,8 +145,7 @@ enum {
   LLCP_DLC_STATE_W4_LOCAL_RESP,  /* waiting for connection confirm from upper
                                     layer  */
   LLCP_DLC_STATE_CONNECTED,      /* data link connection has been established */
-  LLCP_DLC_STATE_W4_REMOTE_DM, /* waiting for disconnection confirm from peer */
-  LLCP_DLC_STATE_MAX
+  LLCP_DLC_STATE_W4_REMOTE_DM /* waiting for disconnection confirm from peer */
 };
 typedef uint8_t tLLCP_DLC_STATE;
 
@@ -236,8 +235,6 @@ typedef struct {
 */
 
 typedef struct {
-  uint8_t trace_level; /* LLCP trace level                             */
-
   tLLCP_SDP_CB sdp_cb; /* SDP control block                            */
   tLLCP_LCB lcb;       /* LLCP link control block                      */
   tLLCP_APP_CB wks_cb[LLCP_MAX_WKS]; /* Application's registration for
@@ -290,11 +287,9 @@ typedef struct {
 
   uint8_t total_rx_ui_pdu;   /* total number of rx UI PDU in all of ui_rx_q  */
   uint8_t total_rx_i_pdu;    /* total number of rx I PDU in all of i_rx_q    */
-  bool overall_rx_congested; /* true if overall rx link is congested         */
-#if (NXP_EXTNS == TRUE)
+  bool overall_rx_congested; /* TRUE if overall rx link is congested         */
   tLLCP_DTA_CBACK* p_dta_cback; /* callback to notify DTA when respoding SNL */
-  bool dta_snl_resp; /* true if need to notify DTA when respoding SNL*/
-#endif
+  bool dta_snl_resp; /* TRUE if need to notify DTA when respoding SNL*/
 } tLLCP_CB;
 
 #if (LLCP_TEST_INCLUDED == true) /* this is for LLCP testing */
@@ -306,9 +301,6 @@ typedef struct {
 
 #endif
 
-#ifdef __cplusplus
-extern "C" {
-#endif
 
 /*
 ** LLCP global data
@@ -385,8 +377,5 @@ uint8_t llcp_sdp_get_sap_by_name(char* p_name, uint8_t length);
 tLLCP_STATUS llcp_sdp_proc_snl(uint16_t sdu_length, uint8_t* p);
 void llcp_sdp_check_send_snl(void);
 void llcp_sdp_proc_deactivation(void);
-#ifdef __cplusplus
-}
-#endif
 
 #endif
diff --git a/src/nfc/include/nci_hmsgs.h b/src/nfc/include/nci_hmsgs.h
old mode 100644
new mode 100755
index 4df6cce..f110640
--- a/src/nfc/include/nci_hmsgs.h
+++ b/src/nfc/include/nci_hmsgs.h
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -43,14 +43,13 @@
 #ifndef NFC_NCI_HMSGS_H
 #define NFC_NCI_HMSGS_H
 
-#ifdef __cplusplus
-extern "C" {
-#endif
 
-#include "nfc_types.h"
 #include "nci_defs.h"
+#include "nfc_types.h"
 
 #include <stdbool.h>
+/*Timeout in ms blocks powerLink/modeSet notifying upperLayer*/
+#define DWP_BLOCK_TIMEOUT 3500
 
 bool nci_proc_core_rsp(NFC_HDR* p_msg);
 void nci_proc_rf_management_rsp(NFC_HDR* p_msg);
@@ -59,10 +58,7 @@ void nci_proc_core_ntf(NFC_HDR* p_msg);
 void nci_proc_rf_management_ntf(NFC_HDR* p_msg);
 void nci_proc_ee_management_ntf(NFC_HDR* p_msg);
 void nci_proc_prop_rsp(NFC_HDR* p_msg);
-#if (NXP_EXTNS == TRUE)
-void nci_proc_prop_nxp_rsp(NFC_HDR* p_msg);
-uint8_t nci_snd_iso_dep_nak_presence_check_cmd();
-#endif
+void nci_proc_prop_raw_vs_rsp(NFC_HDR* p_msg);
 void nci_proc_prop_ntf(NFC_HDR* p_msg);
 
 uint8_t nci_snd_core_reset(uint8_t reset_type);
@@ -82,6 +78,8 @@ uint8_t nci_snd_deactivate_cmd(uint8_t de_act_type);
 uint8_t nci_snd_discover_map_cmd(uint8_t num, tNCI_DISCOVER_MAPS* p_maps);
 uint8_t nci_snd_t3t_polling(uint16_t system_code, uint8_t rc, uint8_t tsn);
 uint8_t nci_snd_parameter_update_cmd(uint8_t* p_param_tlvs, uint8_t tlv_size);
+uint8_t nci_snd_iso_dep_nak_presence_check_cmd();
+uint8_t nci_snd_core_set_power_sub_state(uint8_t screen_state);
 #if (NXP_EXTNS == TRUE)
 uint8_t nci_snd_pwr_nd_lnk_ctrl_cmd(uint8_t nfcee_id, uint8_t cfg_value);
 #endif
@@ -93,9 +91,5 @@ uint8_t nci_snd_set_routing_cmd(bool more, uint8_t num_tlv, uint8_t tlv_size,
 uint8_t nci_snd_get_routing_cmd(void);
 uint8_t nci_snd_nfcee_power_link_control (uint8_t nfcee_id, uint8_t pl_config);
 #endif
-uint8_t nci_snd_core_set_power_sub_state(uint8_t screen_state);
-#ifdef __cplusplus
-}
-#endif
 
 #endif /* NFC_NCI_MSGS_H */
diff --git a/src/nfc/include/ndef_utils.h b/src/nfc/include/ndef_utils.h
index 6e7caab..39f4ebe 100644
--- a/src/nfc/include/ndef_utils.h
+++ b/src/nfc/include/ndef_utils.h
@@ -69,19 +69,6 @@ enum {
 };
 typedef uint8_t tNDEF_STATUS;
 
-#define HR_REC_TYPE_LEN 2        /* Handover Request Record Type     */
-#define HS_REC_TYPE_LEN 2        /* Handover Select Record Type      */
-#define HC_REC_TYPE_LEN 2        /* Handover Carrier recrod Type     */
-#define CR_REC_TYPE_LEN 2        /* Collision Resolution Record Type */
-#define AC_REC_TYPE_LEN 2        /* Alternative Carrier Record Type  */
-#define ERR_REC_TYPE_LEN 3       /* Error Record Type                */
-#define BT_OOB_REC_TYPE_LEN 32   /* Bluetooth OOB Data Type          */
-#define WIFI_WSC_REC_TYPE_LEN 23 /* Wifi WSC Data Type               */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
 /* Functions to parse a received NDEF Message
 */
 /*******************************************************************************
@@ -279,39 +266,6 @@ extern tNDEF_STATUS NDEF_MsgAddRec(uint8_t* p_msg, uint32_t max_size,
                                    uint8_t* p_id, uint8_t id_len,
                                    uint8_t* p_payload, uint32_t payload_len);
 
-/*******************************************************************************
-**
-** Function         NDEF_MsgInsertRec
-**
-** Description      This function inserts a record at a specific index into the
-**                  given NDEF message
-**
-** Returns          OK, or error if the record did not fit
-**                  *p_cur_size is updated
-**
-*******************************************************************************/
-extern tNDEF_STATUS NDEF_MsgInsertRec(uint8_t* p_msg, uint32_t max_size,
-                                      uint32_t* p_cur_size, int32_t index,
-                                      uint8_t tnf, uint8_t* p_type,
-                                      uint8_t type_len, uint8_t* p_id,
-                                      uint8_t id_len, uint8_t* p_payload,
-                                      uint32_t payload_len);
-
-/*******************************************************************************
-**
-** Function         NDEF_MsgAppendRec
-**
-** Description      This function adds NDEF records to the end of an NDEF
-**                  message.
-**
-** Returns          OK, or error if the record did not fit
-**                  *p_cur_size is updated
-**
-*******************************************************************************/
-extern tNDEF_STATUS NDEF_MsgAppendRec(uint8_t* p_msg, uint32_t max_size,
-                                      uint32_t* p_cur_size, uint8_t* p_new_rec,
-                                      uint32_t new_rec_len);
-
 /*******************************************************************************
 **
 ** Function         NDEF_MsgAppendPayload
@@ -405,8 +359,5 @@ extern tNDEF_STATUS NDEF_MsgCopyAndDechunk(uint8_t* p_src, uint32_t src_len,
                                            uint8_t* p_dest,
                                            uint32_t* p_out_len);
 
-#ifdef __cplusplus
-}
-#endif
 
 #endif /* NDEF_UTILS_H */
diff --git a/src/nfc/include/nfc_api.h b/src/nfc/include/nfc_api.h
old mode 100644
new mode 100755
index 065a93a..f9ba810
--- a/src/nfc/include/nfc_api.h
+++ b/src/nfc/include/nfc_api.h
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -103,6 +103,8 @@
 #define NFC_STATUS_DWP_APDU_DROPPPED \
   NCI_STATUS_DWP_APDU_DROPPPED /* FW dropped the APDU because UICC switch */
 #define NFC_STATUS_ALREADY_INITIALIZED NCI_STATUS_ALREADY_INITIALIZED
+/*Operation not permitted*/
+#define NFC_STATUS_EPERM NCI_STATUS_EPERM
 // DTA API for MW Version need to change according to release
 #define NXP_EN_PN547C2 0
 #define NXP_EN_PN65T 0
@@ -111,14 +113,14 @@
 #define NXP_EN_PN551 0
 #define NXP_EN_PN67T 0
 #define NXP_EN_PN553 1
-#define NXP_EN_PN80T 1
+#define NXP_EN_PN80T 0
 #define NXP_EN_PN553_MR1 0
 #define NXP_EN_PN81A     0
 #define NXP_EN_PN553_MR2 0
-#define NXP_EN_PN557     1
-#define NXP_EN_PN81T     1
-#define NXP_ANDROID_VER (8U)        /* NXP android version */
-#define NFC_NXP_MW_VERSION_MAJ (0x02) /* MW Major Version */
+#define NXP_EN_PN557     0
+#define NXP_EN_PN81T     0
+#define NXP_ANDROID_VER (9U)        /* NXP android version */
+#define NFC_NXP_MW_VERSION_MAJ (0x03) /* MW Major Version */
 #define NFC_NXP_MW_VERSION_MIN (0x00) /* MW Minor Version */
 #endif
 /* 0xE0 ~0xFF are proprietary status codes */
@@ -208,57 +210,33 @@ typedef uint8_t tNFC_STATUS;
   ((unsigned char)0xEA) /* param for retrieveing HCI session ID for UICC */
 #define NXP_NFC_PARAM_SWP_SESSIONID_INT1A \
   ((unsigned char)0x1E) /* param for retrieveing HCI session ID for UICC2 */
+
+/**********************************************
+ * NFC self test Parameter IDs defined by NXP NFC
+ **********************************************/
+#define NXP_NFC_NCI_PACM_BIT_RATE 0x68
 #endif
 
 /**********************************************
  * NFC Config Parameter IDs defined by NCI
  **********************************************/
 #define NFC_PMID_TOTAL_DURATION NCI_PARAM_ID_TOTAL_DURATION
-#define NFC_PMID_CON_DEVICES_LIMIT NCI_PARAM_ID_CON_DEVICES_LIMIT
-#define NFC_PMID_PA_BAILOUT NCI_PARAM_ID_PA_BAILOUT
-#define NFC_PMID_CON_DISCOVERY_PARAM NCI_PARAM_ID_CON_DISCOVERY_PARAM
-#define NFC_PMID_PB_AFI NCI_PARAM_ID_PB_AFI
-#define NFC_PMID_PB_BAILOUT NCI_PARAM_ID_PB_BAILOUT
-#define NFC_PMID_PB_ATTRIB_PARAM1 NCI_PARAM_ID_PB_ATTRIB_PARAM1
-#define NFC_PMID_PF_BIT_RATE NCI_PARAM_ID_PF_BIT_RATE
 #define NFC_PMID_PF_RC NCI_PARAM_ID_PF_RC
-#define NFC_PMID_PB_H_INFO NCI_PARAM_ID_PB_H_INFO
-#define NFC_PMID_BITR_NFC_DEP NCI_PARAM_ID_BITR_NFC_DEP
 #define NFC_PMID_ATR_REQ_GEN_BYTES NCI_PARAM_ID_ATR_REQ_GEN_BYTES
-#define NFC_PMID_ATR_REQ_CONFIG NCI_PARAM_ID_ATR_REQ_CONFIG
 #define NFC_PMID_LA_HIST_BY NCI_PARAM_ID_LA_HIST_BY
 #define NFC_PMID_LA_NFCID1 NCI_PARAM_ID_LA_NFCID1
-#define NFC_PMID_PI_BIT_RATE NCI_PARAM_ID_PI_BIT_RATE
 #define NFC_PMID_LA_BIT_FRAME_SDD NCI_PARAM_ID_LA_BIT_FRAME_SDD
 #define NFC_PMID_LA_PLATFORM_CONFIG NCI_PARAM_ID_LA_PLATFORM_CONFIG
 #define NFC_PMID_LA_SEL_INFO NCI_PARAM_ID_LA_SEL_INFO
-#define NFC_PMID_LI_BIT_RATE NCI_PARAM_ID_LI_BIT_RATE
 #define NFC_PMID_LB_SENSB_INFO NCI_PARAM_ID_LB_SENSB_INFO
-#define NFC_PMID_LB_PROTOCOL NCI_PARAM_ID_LB_PROTOCOL
 #define NFC_PMID_LB_H_INFO NCI_PARAM_ID_LB_H_INFO_RSP
 #define NFC_PMID_LB_NFCID0 NCI_PARAM_ID_LB_NFCID0
 #define NFC_PMID_LB_APPDATA NCI_PARAM_ID_LB_APPDATA
 #define NFC_PMID_LB_SFGI NCI_PARAM_ID_LB_SFGI
 #define NFC_PMID_LB_ADC_FO NCI_PARAM_ID_LB_ADC_FO
 #define NFC_PMID_LF_T3T_ID1 NCI_PARAM_ID_LF_T3T_ID1
-#define NFC_PMID_LF_T3T_ID2 NCI_PARAM_ID_LF_T3T_ID2
-#define NFC_PMID_LF_T3T_ID3 NCI_PARAM_ID_LF_T3T_ID3
-#define NFC_PMID_LF_T3T_ID4 NCI_PARAM_ID_LF_T3T_ID4
-#define NFC_PMID_LF_T3T_ID5 NCI_PARAM_ID_LF_T3T_ID5
-#define NFC_PMID_LF_T3T_ID6 NCI_PARAM_ID_LF_T3T_ID6
-#define NFC_PMID_LF_T3T_ID7 NCI_PARAM_ID_LF_T3T_ID7
-#define NFC_PMID_LF_T3T_ID8 NCI_PARAM_ID_LF_T3T_ID8
-#define NFC_PMID_LF_T3T_ID9 NCI_PARAM_ID_LF_T3T_ID9
-#define NFC_PMID_LF_T3T_ID10 NCI_PARAM_ID_LF_T3T_ID10
-#define NFC_PMID_LF_T3T_ID11 NCI_PARAM_ID_LF_T3T_ID11
-#define NFC_PMID_LF_T3T_ID12 NCI_PARAM_ID_LF_T3T_ID12
-#define NFC_PMID_LF_T3T_ID13 NCI_PARAM_ID_LF_T3T_ID13
-#define NFC_PMID_LF_T3T_ID14 NCI_PARAM_ID_LF_T3T_ID14
-#define NFC_PMID_LF_T3T_ID15 NCI_PARAM_ID_LF_T3T_ID15
-#define NFC_PMID_LF_T3T_ID16 NCI_PARAM_ID_LF_T3T_ID16
 #define NFC_PMID_LF_PROTOCOL NCI_PARAM_ID_LF_PROTOCOL
 #define NFC_PMID_LF_T3T_PMM NCI_PARAM_ID_LF_T3T_PMM
-#define NFC_PMID_LF_T3T_MAX NCI_PARAM_ID_LF_T3T_MAX
 #define NFC_PMID_LF_T3T_FLAGS2 NCI_PARAM_ID_LF_T3T_FLAGS2
 #define NFC_PMID_FWI NCI_PARAM_ID_FWI
 #define NFC_PMID_LF_CON_BITR_F NCI_PARAM_ID_LF_CON_BITR_F
@@ -266,9 +244,6 @@ typedef uint8_t tNFC_STATUS;
 #define NFC_PMID_ATR_RES_GEN_BYTES NCI_PARAM_ID_ATR_RES_GEN_BYTES
 #define NFC_PMID_ATR_RSP_CONFIG NCI_PARAM_ID_ATR_RSP_CONFIG
 #define NFC_PMID_RF_FIELD_INFO NCI_PARAM_ID_RF_FIELD_INFO
-#define NFC_PMID_NFC_DEP_OP NCI_PARAM_ID_NFC_DEP_OP
-#define NFC_PARAM_ID_RF_EE_ACTION NCI_PARAM_ID_RF_EE_ACTION
-#define NFC_PARAM_ID_ISO_DEP_OP NCI_PARAM_ID_ISO_DEP_OP
 
 /* Technology based routing  */
 #define NFC_ROUTE_TAG_TECH NCI_ROUTE_TAG_TECH
@@ -276,8 +251,7 @@ typedef uint8_t tNFC_STATUS;
 #define NFC_ROUTE_TAG_PROTO NCI_ROUTE_TAG_PROTO
 #define NFC_ROUTE_TAG_AID NCI_ROUTE_TAG_AID /* AID routing */
 #define NFC_ROUTE_TAG_APDU NCI_ROUTE_TAG_APDU /* APDU routing*/
-/* tag, len, 2 byte value for technology/protocol based routing */
-#define NFC_ROUTE_TLV_ENTRY_SIZE 4
+#define NFC_ROUTE_TAG_SYSCODE NCI_ROUTE_TAG_SYSCODE /* System Code routing*/
 
 /* For routing */
 #define NFC_DH_ID NCI_DH_ID /* for DH */
@@ -285,7 +259,6 @@ typedef uint8_t tNFC_STATUS;
 /* use a proprietary range */
 #define NFC_TEST_ID NCI_TEST_ID
 
-typedef uint8_t tNFC_PMID;
 #define NFC_TL_SIZE 2
 #define NFC_SAVED_CMD_SIZE 2
 
@@ -304,12 +277,42 @@ typedef tNCI_DISCOVER_PARAMS tNFC_DISCOVER_PARAMS;
 #define NFC_FIRST_CEVT 0x6000
 #define NFC_FIRST_TEVT 0x8000
 #if (NXP_EXTNS == TRUE)
-void nfc_ncif_onWiredModeHold_timeout();
-void nfc_ncif_allow_dwp_transmission();
-void nfc_ncif_modeSet_Ntf_timeout();
-void nfc_ncif_modeSet_rsp_timeout();
-void nfc_ncif_resume_dwp_wired_mode();
-void nfc_ncif_pwr_link_rsp_timeout();
+  void nfc_ncif_onWiredModeHold_timeout();
+  void nfc_ncif_allow_dwp_transmission();
+  void nfc_ncif_modeSet_Ntf_timeout();
+  void nfc_ncif_modeSet_rsp_timeout();
+  void nfc_ncif_resume_dwp_wired_mode();
+  void nfc_ncif_pwr_link_rsp_timeout();
+
+/**********************************************
+ * NFC self test Parameter IDs defined by NXP NFC
+ **********************************************/
+enum {
+  NFC_CMD_TYPE_SWP           =  0x00,
+  NFC_CMD_TYPE_PRBS_START,
+  NFC_CMD_TYPE_PRBS_STOP,
+  NFC_CMD_TYPE_CORE_RESET,
+  NFC_CMD_TYPE_CORE_INIT,
+  NFC_CMD_TYPE_ACT_PROP_EXTN,
+  NFC_CMD_TYPE_RF_ON,
+  NFC_CMD_TYPE_RF_OFF,
+  NFC_CMD_TYPE_TRANSAC_A,
+  NFC_CMD_TYPE_TRANSAC_B,
+  NFC_CMD_TYPE_DISC_MAP,
+  NFC_CMD_TYPE_DEACTIVATE,
+  NFC_CMD_TYPE_NFCC_STANDBY_ON,
+  NFC_CMD_TYPE_NFCC_STANDBY_OFF,
+  NFC_CMD_TYPE_TYPE_NONE     = 0xFF
+};
+
+enum NFCCSELFTESTTYPE {
+  TEST_TYPE_RF_ON = 0x00,
+  TEST_TYPE_RF_OFF,
+  TEST_TYPE_TRANSAC_A,
+  TEST_TYPE_TRANSAC_B,
+  TEST_TYPE_NONE = 0xFF
+};
+#endif
 /* the events reported on tNFC_RESPONSE_CBACK */
 enum {
   NFC_ENABLE_REVT = NFC_FIRST_REVT, /* 0  Enable event                  */
@@ -330,15 +333,14 @@ enum {
   NFC_NFCC_TIMEOUT_REVT,            /* 15 NFCC is not responding        */
   NFC_NFCC_TRANSPORT_ERR_REVT,      /* 16 NCI Tranport error            */
   NFC_NFCC_POWER_OFF_REVT,          /* 17 NFCC turned off               */
+  NFC_SET_POWER_SUB_STATE_REVT,     /* 18 Set power sub state response  */
   NFC_NFCEE_PL_CONTROL_REVT,              /* NFCEE Power/Link Ctrl response*/
-  NFC_FIRST_VS_REVT,          /* First vendor-specific rsp event  */
   NFC_NFCEE_PWR_LNK_CTRL_REVT, /* PWR LINK CTRL Event for Wired Mode standby */
   NFC_NFCEE_STATUS_REVT                  /* NFCEE Status Notification     */
 #if (NXP_EXTNS == TRUE)
   ,
   NFC_NFCEE_MODE_SET_INFO /*  NFCEE Mode Set Notification*/
 #endif
-  ,NFC_SET_POWER_SUB_STATE_REVT     /* 18 Set power sub state response  */
 };
 typedef uint16_t tNFC_RESPONSE_EVT;
 
@@ -375,10 +377,9 @@ typedef struct {
       [NFC_NFCC_MAX_NUM_VS_INTERFACE]; /* the NCI VS interfaces of NFCC    */
   uint8_t hci_packet_size;             /*HCI payload size*/
   uint8_t hci_conn_credits;            /*max number of HCI credits*/
-  uint16_t max_nfc_v_size;        /* maximum frame size for NFC-V*/
+  uint16_t max_nfc_v_size;             /* maximum frame size for NFC-V*/
 } tNFC_ENABLE_REVT;
 
-
 #define NFC_MAX_NUM_IDS 125
 /* the data type associated with NFC_SET_CONFIG_REVT */
 typedef struct {
@@ -395,13 +396,6 @@ typedef struct {
 } tNFC_GET_CONFIG_REVT;
 
 #if (NXP_EXTNS == TRUE)
-/* This data type is for FW Version */
-typedef struct {
-  uint8_t rom_code_version; /* ROM code Version  */
-  uint8_t major_version;    /* Major Version */
-  uint8_t minor_version;    /* Minor Version  */
-} tNFC_FW_VERSION;
-
 typedef struct {
   tNFC_STATUS status;
   uint8_t nfcee_id;
@@ -432,7 +426,6 @@ typedef struct {
 #define NFC_NFCEE_INTERFACE_T3T NCI_NFCEE_INTERFACE_T3T
 #define NFC_NFCEE_INTERFACE_TRANSPARENT NCI_NFCEE_INTERFACE_TRANSPARENT
 #define NFC_NFCEE_INTERFACE_PROPRIETARY NCI_NFCEE_INTERFACE_PROPRIETARY
-typedef uint8_t tNFC_NFCEE_INTERFACE;
 
 #define NFC_NFCEE_TAG_HW_ID NCI_NFCEE_TAG_HW_ID
 #define NFC_NFCEE_TAG_ATR_BYTES NCI_NFCEE_TAG_ATR_BYTES
@@ -461,10 +454,6 @@ typedef struct {
 /* NFCEE removed                */
 #define NFC_NFCEE_STATUS_REMOVED NCI_NFCEE_STS_REMOVED
 /* the data type associated with NFC_NFCEE_INFO_REVT */
-#define NFC_NFCEE_STS_INTF_ACTIVATION_FAILED NCI_NFCEE_STS_INTF_ACTIVATION_FAILED
-#define NFC_NFCEE_STS_TRANSMISSION_ERROR     NCI_NFCEE_STS_TRANSMISSION_ERROR
-#define NFC_NFCEE_STS_PROTOCOL_ERROR         NCI_NFCEE_STS_PROTOCOL_ERROR
-#define NFC_NFCEE_STS_TIMEOUT_ERROR          NCI_NFCEE_STS_TIMEOUT_ERROR
 
 typedef struct {
   tNFC_STATUS status;    /* The event status - place holder  */
@@ -487,6 +476,14 @@ typedef struct {
   tNFC_NFCEE_MODE mode; /* NFCEE mode       */
 } tNFC_NFCEE_MODE_SET_REVT;
 
+#if (NXP_EXTNS == TRUE || APPL_DTA_MODE == TRUE)
+/* This data type is for FW Version */
+typedef struct {
+  uint8_t rom_code_version; /* ROM code Version  */
+  uint8_t major_version;    /* Major Version */
+  uint8_t minor_version;    /* Minor Version  */
+} tNFC_FW_VERSION;
+#endif
 typedef struct {
   tNFC_STATUS status; /* The event status.*/
   uint8_t nfcee_id;   /* NFCEE ID         */
@@ -547,20 +544,17 @@ typedef struct
 } tNFC_NFCEE_STATUS_REVT;
 
 /* RF Field Status */
-/* No field generated by remote device  */
-#define NFC_RF_STS_NO_REMOTE NCI_RF_STS_NO_REMOTE
-/* field generated by remote device     */
-#define NFC_RF_STS_REMOTE NCI_RF_STS_REMOTE
 typedef uint8_t tNFC_RF_STS;
 
 /* RF Field Technologies */
 #define NFC_RF_TECHNOLOGY_A NCI_RF_TECHNOLOGY_A
 #define NFC_RF_TECHNOLOGY_B NCI_RF_TECHNOLOGY_B
 #define NFC_RF_TECHNOLOGY_F NCI_RF_TECHNOLOGY_F
-#define NFC_RF_TECHNOLOGY_15693 NCI_RF_TECHNOLOGY_15693
 typedef uint8_t tNFC_RF_TECH;
 
+
 extern uint8_t NFC_GetNCIVersion();
+
 /* Supported Protocols */
 #define NFC_PROTOCOL_UNKNOWN NCI_PROTOCOL_UNKNOWN /* Unknown */
 /* Type1Tag    - NFC-A            */
@@ -569,6 +563,10 @@ extern uint8_t NFC_GetNCIVersion();
 #define NFC_PROTOCOL_T2T NCI_PROTOCOL_T2T
 /* Type3Tag    - NFC-F            */
 #define NFC_PROTOCOL_T3T NCI_PROTOCOL_T3T
+/* Type5Tag    - NFC-V/ISO15693*/
+#define NFC_PROTOCOL_T5T NFC_PROTOCOL_T5T_(NFC_GetNCIVersion())
+#define NFC_PROTOCOL_T5T_(x) \
+  (((x) == NCI_VERSION_2_0) ? NCI_PROTOCOL_T5T : NCI_PROTOCOL_15693)
 /* Type 4A,4B  - NFC-A or NFC-B   */
 #define NFC_PROTOCOL_ISO_DEP NCI_PROTOCOL_ISO_DEP
 /* NFCDEP/LLCP - NFC-A or NFC-F       */
@@ -580,7 +578,7 @@ extern uint8_t NFC_GetNCIVersion();
 #define NFC_PROTOCOL_T3BT NCI_PROTOCOL_T3BT
 #endif
 #define NFC_PROTOCOL_B_PRIME NCI_PROTOCOL_B_PRIME
-#define NFC_PROTOCOL_15693 NCI_PROTOCOL_15693
+#define NFC_PROTOCOL_ISO15693 NCI_PROTOCOL_15693
 #define NFC_PROTOCOL_KOVIO NCI_PROTOCOL_KOVIO
 typedef uint8_t tNFC_PROTOCOL;
 
@@ -590,7 +588,8 @@ typedef uint8_t tNFC_PROTOCOL;
 #define NFC_DISCOVERY_TYPE_POLL_F NCI_DISCOVERY_TYPE_POLL_F
 #define NFC_DISCOVERY_TYPE_POLL_A_ACTIVE NCI_DISCOVERY_TYPE_POLL_A_ACTIVE
 #define NFC_DISCOVERY_TYPE_POLL_F_ACTIVE NCI_DISCOVERY_TYPE_POLL_F_ACTIVE
-#define NFC_DISCOVERY_TYPE_POLL_ISO15693 NCI_DISCOVERY_TYPE_POLL_ISO15693
+#define NFC_DISCOVERY_TYPE_POLL_ACTIVE NCI_DISCOVERY_TYPE_POLL_ACTIVE
+#define NFC_DISCOVERY_TYPE_POLL_V NCI_DISCOVERY_TYPE_POLL_V
 #define NFC_DISCOVERY_TYPE_POLL_B_PRIME NCI_DISCOVERY_TYPE_POLL_B_PRIME
 #define NFC_DISCOVERY_TYPE_POLL_KOVIO NCI_DISCOVERY_TYPE_POLL_KOVIO
 #define NFC_DISCOVERY_TYPE_LISTEN_A NCI_DISCOVERY_TYPE_LISTEN_A
@@ -598,6 +597,7 @@ typedef uint8_t tNFC_PROTOCOL;
 #define NFC_DISCOVERY_TYPE_LISTEN_F NCI_DISCOVERY_TYPE_LISTEN_F
 #define NFC_DISCOVERY_TYPE_LISTEN_A_ACTIVE NCI_DISCOVERY_TYPE_LISTEN_A_ACTIVE
 #define NFC_DISCOVERY_TYPE_LISTEN_F_ACTIVE NCI_DISCOVERY_TYPE_LISTEN_F_ACTIVE
+#define NFC_DISCOVERY_TYPE_LISTEN_ACTIVE NCI_DISCOVERY_TYPE_LISTEN_ACTIVE
 #define NFC_DISCOVERY_TYPE_LISTEN_ISO15693 NCI_DISCOVERY_TYPE_LISTEN_ISO15693
 #define NFC_DISCOVERY_TYPE_LISTEN_B_PRIME NCI_DISCOVERY_TYPE_LISTEN_B_PRIME
 typedef uint8_t tNFC_DISCOVERY_TYPE;
@@ -605,18 +605,12 @@ typedef uint8_t tNFC_RF_TECH_N_MODE;
 
 /* Select Response codes */
 #define NFC_SEL_RES_NFC_FORUM_T2T 0x00
-#define NFC_SEL_RES_MF_CLASSIC 0x08
 
-#define  NCI_CALCULATE_ACK(a,v) {a &=  ((1 << v) -1);}
+#define  NCI_CALCULATE_ACK(a,v) {(a) &=  ((1 << (v)) -1);}
 #define  MAX_NUM_VALID_BITS_FOR_ACK      0x07
 /* Bit Rates */
-#define NFC_BIT_RATE_106 NCI_BIT_RATE_106   /* 106 kbit/s */
 #define NFC_BIT_RATE_212 NCI_BIT_RATE_212   /* 212 kbit/s */
 #define NFC_BIT_RATE_424 NCI_BIT_RATE_424   /* 424 kbit/s */
-#define NFC_BIT_RATE_848 NCI_BIT_RATE_848   /* 848 Kbit/s */
-#define NFC_BIT_RATE_1696 NCI_BIT_RATE_1696 /* 1696 Kbit/s*/
-#define NFC_BIT_RATE_3392 NCI_BIT_RATE_3392 /* 3392 Kbit/s*/
-#define NFC_BIT_RATE_6784 NCI_BIT_RATE_6784 /* 6784 Kbit/s*/
 typedef uint8_t tNFC_BIT_RATE;
 
 /**********************************************
@@ -625,11 +619,7 @@ typedef uint8_t tNFC_BIT_RATE;
 #define NFC_INTERFACE_EE_DIRECT_RF NCI_INTERFACE_EE_DIRECT_RF
 #define NFC_INTERFACE_FRAME NCI_INTERFACE_FRAME
 #define NFC_INTERFACE_ISO_DEP NCI_INTERFACE_ISO_DEP
-#define NFC_INTERFACE_NDEF NCI_INTERFACE_NDEF
 #define NFC_INTERFACE_NFC_DEP NCI_INTERFACE_NFC_DEP
-#define NFC_INTERFACE_LLCP_LOW NCI_INTERFACE_LLCP_LOW
-#define NFC_INTERFACE_LLCP_HIGH NCI_INTERFACE_LLCP_HIGH
-#define NFC_INTERFACE_VS_T2T_CE NCI_INTERFACE_VS_T2T_CE
 #define NFC_INTERFACE_MIFARE NCI_INTERFACE_VS_MIFARE
 typedef tNCI_INTF_TYPE tNFC_INTF_TYPE;
 
@@ -645,10 +635,7 @@ typedef uint8_t tNFC_DEACT_TYPE;
 /**********************************************
  *  Deactivation Reasons
  **********************************************/
-#define NFC_DEACTIVATE_REASON_DH_REQ NCI_DEACTIVATE_REASON_DH_REQ
-#define NFC_DEACTIVATE_REASON_ENDPOINT_REQ NCI_DEACTIVATE_REASON_ENDPOINT_REQ
-#define NFC_DEACTIVATE_REASON_RF_LINK_LOSS NCI_DEACTIVATE_REASON_RF_LINK_LOSS
-#define NFC_DEACTIVATE_REASON_NFCB_BAD_AFI NCI_DEACTIVATE_REASON_NFCB_BAD_AFI
+#define NFC_DEACTIVATE_REASON_DH_REQ_FAILED NCI_DEACTIVATE_REASON_DH_REQ_FAILED
 typedef uint8_t tNFC_DEACT_REASON;
 
 /* the data type associated with NFC_RF_FIELD_REVT */
@@ -821,6 +808,8 @@ typedef struct {
   uint8_t uid[NFC_KOVIO_MAX_LEN];
 } tNFC_RF_PKOVIO_PARAMS;
 
+typedef tNCI_RF_ACM_P_PARAMS tNFC_RF_ACM_P_PARAMS;
+
 typedef union {
   tNFC_RF_PA_PARAMS pa;
   tNFC_RF_PB_PARAMS pb;
@@ -828,6 +817,7 @@ typedef union {
   tNFC_RF_LF_PARAMS lf;
   tNFC_RF_PISO15693_PARAMS pi93;
   tNFC_RF_PKOVIO_PARAMS pk;
+  tNFC_RF_ACM_P_PARAMS acm_p;
 } tNFC_RF_TECH_PARAMU;
 
 typedef struct {
@@ -945,7 +935,8 @@ typedef struct {
 typedef struct {
   tNFC_STATUS status;   /* The event status.        */
   tNFC_DEACT_TYPE type; /* De-activate type         */
-  bool is_ntf;          /* true, if deactivate notif*/
+  bool is_ntf;          /* TRUE, if deactivate notif*/
+  tNFC_DEACT_REASON reason; /* De-activate reason    */
 } tNFC_DEACTIVATE_DEVT;
 
 typedef union {
@@ -958,30 +949,6 @@ typedef union {
   tNFC_DEACTIVATE_DEVT deactivate;
 } tNFC_DISCOVER;
 
-/* Min TR0 indicates to tag the min delay before responding after the end of
- * command */
-#define NFC_RF_PARAM_MIN_TR0_DEFAULT 0x00
-#define NFC_RF_PARAM_MIN_TR0_48X 0x01 /* 48 x 16/fc */
-#define NFC_RF_PARAM_MIN_TR0_16X 0x02 /* 16 x 16/fc */
-
-/* Min TR1 indicates to tag the min delay between subcarrier modulation and data
- * transmission */
-#define NFC_RF_PARAM_MIN_TR1_DEFAULT 0x00
-#define NFC_RF_PARAM_MIN_TR1_64X 0x01 /* 64 x 16/fc */
-#define NFC_RF_PARAM_MIN_TR1_16X 0x02 /* 16 x 16/fc */
-
-/* Min TR2 indicates to RW the min delay between EoS of tag and SoS of RW */
-#define NFC_RF_PARAM_MIN_TR2_1792 0x00 /* 1792/fc (10etu + 32/fc) */
-#define NFC_RF_PARAM_MIN_TR2_3328 0x01 /* 3328/fc (10etu + 128/fc) */
-#define NFC_RF_PARAM_MIN_TR2_5376 0x02 /* 5376/fc (10etu + 256/fc) */
-#define NFC_RF_PARAM_MIN_TR2_9472 0x03 /* 9472/fc (10etu + 512/fc) */
-
-#define NFC_RF_PARAM_EOS_REQUIRED 0x00     /* EoS required */
-#define NFC_RF_PARAM_EOS_NOT_REQUIRED 0x01 /* EoS not required */
-
-#define NFC_RF_PARAM_SOS_REQUIRED 0x00     /* SoS required */
-#define NFC_RF_PARAM_SOS_NOT_REQUIRED 0x01 /* SoS not required */
-
 typedef struct {
   bool include_rf_tech_mode; /* true if including RF Tech and Mode update    */
   tNFC_RF_TECH_N_MODE rf_tech_n_mode; /* RF tech and mode */
@@ -1003,12 +970,6 @@ typedef struct {
 typedef void(tNFC_DISCOVER_CBACK)(tNFC_DISCOVER_EVT event,
                                   tNFC_DISCOVER* p_data);
 
-/* the events reported on tNFC_TEST_CBACK */
-enum {
-  NFC_LOOPBACK_TEVT = NFC_FIRST_TEVT, /* 0  Loopback test             */
-  NFC_RF_CONTROL_TEVT,                /* 1  RF control Test response  */
-  NFC_RF_FIELD_DONE_TEVT              /* 1  RF control Test notificatn*/
-};
 typedef uint16_t tNFC_TEST_EVT;
 
 /* the data type associated with NFC_LOOPBACK_TEVT */
@@ -1052,17 +1013,10 @@ typedef void(tNFC_CONN_CBACK)(uint8_t conn_id, tNFC_CONN_EVT event,
 #define NFC_NFCEE_CONN_ID 0x03 /* the connection ID for NFCEE */
 #endif
 #define NFC_HCI_CONN_ID 3 /* the static connection ID for HCI transport */
-/*************************************
-**  Status callback function
-**************************************/
-typedef void(tNFC_STATUS_CBACK)(tNFC_STATUS status);
 
 /*****************************************************************************
 **  EXTERNAL FUNCTION DECLARATIONS
 *****************************************************************************/
-#ifdef __cplusplus
-extern "C" {
-#endif
 
 /*******************************************************************************
 **
@@ -1402,6 +1356,21 @@ extern tNFC_STATUS NFC_UpdateRFCommParams(tNFC_RF_COMM_PARAMS* p_params);
 *******************************************************************************/
 extern tNFC_STATUS NFC_SetPowerOffSleep(bool enable);
 
+/*******************************************************************************
+**
+** Function         NFC_SetPowerSubState
+**
+** Description      This function is called to send the power sub state(screen
+**                  state) to NFCC. The response from NFCC is reported by
+**                  tNFC_RESPONSE_CBACK as NFC_SET_POWER_STATE_REVT.
+**
+** Parameters       scree_state
+**
+** Returns          tNFC_STATUS
+**
+*******************************************************************************/
+extern tNFC_STATUS NFC_SetPowerSubState(uint8_t screen_state);
+
 /*******************************************************************************
 **
 ** Function         NFC_PowerCycleNFCC
@@ -1474,23 +1443,23 @@ extern tNFC_STATUS NFC_RegVSCback(bool is_register, tNFC_VS_CBACK* p_cback);
 extern tNFC_STATUS NFC_SendVsCommand(uint8_t oid, NFC_HDR* p_data,
                                      tNFC_VS_CBACK* p_cback);
 
-#if (NXP_EXTNS == TRUE)
 /*******************************************************************************
 **
-** Function         NFC_SendNxpNciCommand
+** Function         NFC_SendRawVsCommand
 **
-** Description      This function is called to send the given nxp specific
-**                  command to NFCC. The response from NFCC is reported to the
-**                  given tNFC_VS_CBACK.
+** Description      This function is called to send the given raw command to
+**                  NFCC. The response from NFCC is reported to the given
+**                  tNFC_VS_CBACK.
 **
 ** Parameters       p_data - The command buffer
 **
 ** Returns          tNFC_STATUS
 **
 *******************************************************************************/
-extern tNFC_STATUS NFC_SendNxpNciCommand(NFC_HDR* p_data,
+extern tNFC_STATUS NFC_SendRawVsCommand(NFC_HDR* p_data,
                                          tNFC_VS_CBACK* p_cback);
 
+#if (NXP_EXTNS == TRUE)
 /*******************************************************************************
 **
 ** Function         NFC_SetP61Status
@@ -1522,28 +1491,16 @@ extern tNFC_STATUS NFC_TestLoopback(NFC_HDR* p_data);
 
 /*******************************************************************************
 **
-** Function         NFC_SetTraceLevel
-**
-** Description      This function sets the trace level for NFC.  If called with
-**                  a value of 0xFF, it simply returns the current trace level.
-**
-** Returns          The new or current trace level
-**
-*******************************************************************************/
-extern uint8_t NFC_SetTraceLevel(uint8_t new_level);
-
-/*******************************************************************************
-**
-** Function         NFC_GetChipType
+** Function         NFC_ISODEPNakPresCheck
 **
-** Description      Gets the chipType
+** Description      This function is called to send the ISO DEP nak presenc check cmd
+**                  to check that the remote end point in RF field.
 **
-** Returns          ChipType
+** Returns          tNFC_STATUS
 **
 *******************************************************************************/
-tNFC_chipType NFC_GetChipType();
+extern tNFC_STATUS NFC_ISODEPNakPresCheck ();
 
-#if (BT_TRACE_VERBOSE == true)
 /*******************************************************************************
 **
 ** Function         NFC_GetStatusName
@@ -1555,10 +1512,9 @@ tNFC_chipType NFC_GetChipType();
 ** Returns          pointer to the name
 **
 *******************************************************************************/
-extern char* NFC_GetStatusName(tNFC_STATUS status);
-#endif
+extern std::string NFC_GetStatusName(tNFC_STATUS status);
 
-#if (NXP_EXTNS == TRUE)
+#if (NXP_EXTNS == TRUE || APPL_DTA_MODE == TRUE)
 /*******************************************************************************
 **
 ** Function         nfc_ncif_getFWVersion
@@ -1570,6 +1526,9 @@ extern char* NFC_GetStatusName(tNFC_STATUS status);
 **
 *******************************************************************************/
 extern tNFC_FW_VERSION nfc_ncif_getFWVersion();
+#endif
+
+#if (NXP_EXTNS == TRUE)
 /*******************************************************************************
 **
 ** Function         nfc_ncif_storeScreenState
@@ -1666,6 +1625,31 @@ int32_t NFC_GetP61Status(void* pdata);
 **
 *******************************************************************************/
 int32_t NFC_DisableWired(void* pdata);
+
+/*******************************************************************************
+**
+** Function         NFC_ReleaseEsePwr
+**
+** Description      This function request to pn553 driver to
+**                  turn ese vdd gpio low
+**
+** Returns          0 if api call success, else -1
+**
+*******************************************************************************/
+int32_t NFC_ReleaseEsePwr(void* pdata);
+
+/*******************************************************************************
+**
+** Function         NFC_AcquireEsePwr
+**
+** Description      This function request to pn553 driver to
+**                  turn ese vdd gpio high
+**
+** Returns          0 if api call success, else -1
+**
+*******************************************************************************/
+int32_t NFC_AcquireEsePwr(void* pdata);
+
 /*******************************************************************************
 **
 ** Function         NFC_eSEChipReset
@@ -1709,6 +1693,18 @@ int32_t NFC_SetNfcServicePid();
 **
 *******************************************************************************/
 int32_t NFC_ResetNfcServicePid();
+
+/*******************************************************************************
+**
+** Function         NFC_IsLowRamDevice
+**
+** Description      This function provides low_ram is enabled or not
+**
+** Returns          true or false
+**
+*******************************************************************************/
+bool NFC_IsLowRamDevice();
+
 /*******************************************************************************
 **
 ** Function         NFC_GetEseAccess
@@ -1757,6 +1753,18 @@ int32_t NFC_RelSvddWait(void* pdata);
 *******************************************************************************/
 tNFC_chipType NFC_GetChipType();
 
+/*******************************************************************************
+**
+** Function         NFC_RelForceDwpOnOffWait
+**
+** Description      This function release wait for DWP On/Off
+**                  of P73. Status would be updated to pdata
+**
+** Returns          0 if api call success, else -1
+**
+*******************************************************************************/
+int32_t NFC_RelForceDwpOnOffWait (void *pdata);
+
 /*******************************************************************************
 **
 ** Function         NFC_Queue_Is_empty
@@ -1768,11 +1776,7 @@ tNFC_chipType NFC_GetChipType();
 *******************************************************************************/
 extern bool NFC_Queue_Is_empty(uint8_t conn_id);
 #endif
-#endif
 
-#ifdef __cplusplus
-}
-#endif
 
 /*******************************************************************************
 **
@@ -1811,30 +1815,4 @@ extern tNFC_STATUS NFC_NfceePLConfig (uint8_t                 nfcee_id,
 *******************************************************************************/
 extern void NFC_SetStaticHciCback (tNFC_CONN_CBACK    *p_cback);
 
-/*******************************************************************************
-**
-** Function         NFC_SetPowerSubState
-**
-** Description      This function is called to send the power sub state( screen state)
-**                      to NFCC. The response from NFCC is reported by
-**                  tNFC_RESPONSE_CBACK as NFC_SET_POWER_STATE_REVT.
-**
-** Parameters       scree_state
-**
-** Returns          tNFC_STATUS
-**
-*******************************************************************************/
-extern tNFC_STATUS NFC_SetPowerSubState (uint8_t screen_state);
-
-/*******************************************************************************
-**
-** Function         NFC_ISODEPNakPresCheck
-**
-** Description      This function is called to send the ISO DEP nak presenc check cmd
-**                  to check that the remote end point in RF field.
-**
-** Returns          tNFC_STATUS
-**
-*******************************************************************************/
-extern tNFC_STATUS NFC_ISODEPNakPresCheck ();
 #endif /* NFC_API_H */
diff --git a/src/nfc/int/nfc_int.h b/src/nfc/include/nfc_int.h
similarity index 96%
rename from src/nfc/int/nfc_int.h
rename to src/nfc/include/nfc_int.h
index 5835632..7af2dc5 100644
--- a/src/nfc/int/nfc_int.h
+++ b/src/nfc/include/nfc_int.h
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -50,9 +50,6 @@
 #include "nci_defs.h"
 #include "nfc_api.h"
 
-#ifdef __cplusplus
-extern "C" {
-#endif
 /****************************************************************************
  ** Internal NFC constants and definitions
  ****************************************************************************/
@@ -70,6 +67,7 @@ extern "C" {
 /* NFC Timer events */
 #define NFC_TTYPE_NCI_WAIT_RSP 0
 #define NFC_TTYPE_WAIT_2_DEACTIVATE 1
+#define NFC_WAIT_RSP_RAW_VS 0x02
 #define NFC_TTYPE_WAIT_SETMODE_NTF 6
 #if (NXP_EXTNS == TRUE)
 #define NFC_TTYPE_NCI_WAIT_DATA_NTF 2
@@ -97,7 +95,6 @@ extern "C" {
 #define NFC_TTYPE_LISTEN_ACTIVATION 111
 #define NFC_TTYPE_P2P_PRIO_LOGIC_DEACT_NTF_TIMEOUT 113
 #endif
-#define NFC_TTYPE_VS_BASE 200
 /* time out for modeSet notification */
 #define NFC_SETMODE_NTF_TIMEOUT     2
 #if (NXP_EXTNS == TRUE)
@@ -160,11 +157,9 @@ typedef enum {
 #define NFC_FL_WAIT_MODE_SET_NTF        0x0100  /* Waiting for NFCEE Mode Set NTF*/
 
 #define NFC_PEND_CONN_ID 0xFE
-#define NFC_CONN_ID_INT_MASK 0xF0
 #define NFC_CONN_ID_ID_MASK NCI_CID_MASK
 /* set num_buff to this for no flow control */
 #define NFC_CONN_NO_FC 0xFF
-#define NFC_NCI_CONN_NO_FC 0xFF
 
 #if (NFC_RW_ONLY == FALSE)
 /* only allow the entries that the NFCC can support */
@@ -208,8 +203,6 @@ typedef struct {
 /* callback function pointer(8; use 8 to be safe + NFC_SAVED_CMD_SIZE(2) */
 #define NFC_RECEIVE_MSGS_OFFSET (10)
 
-/* NFCC power state change pending callback */
-typedef void(tNFC_PWR_ST_CBACK)(void);
 #define NFC_SAVED_HDR_SIZE (2)
 /* data Reassembly error (in NFC_HDR.layer_specific) */
 #define NFC_RAS_TOO_BIG 0x08
@@ -218,7 +211,6 @@ typedef void(tNFC_PWR_ST_CBACK)(void);
 /* NCI command buffer contains a VSC (in NFC_HDR.layer_specific) */
 #define NFC_WAIT_RSP_VSC 0x01
 #if (NXP_EXTNS == TRUE)
-#define NFC_WAIT_RSP_NXP 0x02
 #endif
 typedef struct {
   bool bPwrLinkCmdRequested;
@@ -244,9 +236,6 @@ typedef struct {
   tNFC_TEST_CBACK* p_test_cback;
   tNFC_VS_CBACK*
       p_vs_cb[NFC_NUM_VS_CBACKS]; /* Register for vendor specific events  */
-#if (NXP_EXTNS == TRUE)
-  uint8_t nxpCbflag;
-#endif
 
 #if (NFC_RW_ONLY == FALSE)
   /* NFCC information at init rsp */
@@ -261,8 +250,8 @@ typedef struct {
   uint8_t vs_interface
       [NFC_NFCC_MAX_NUM_VS_INTERFACE]; /* the NCI VS interfaces of NFCC    */
   uint16_t nci_interfaces;             /* the NCI interfaces of NFCC       */
-  uint8_t  nci_intf_extensions;
-  uint8_t  nci_intf_extension_map[NCI_INTERFACE_EXTENSION_MAX];
+  uint8_t nci_intf_extensions;
+  uint8_t nci_intf_extension_map[NCI_INTERFACE_EXTENSION_MAX];
   uint8_t num_disc_maps; /* number of RF Discovery interface mappings */
   void* p_disc_pending;  /* the parameters associated with pending
                             NFC_DiscoveryStart */
@@ -282,7 +271,6 @@ typedef struct {
 #if (NXP_EXTNS == TRUE)
   tNFC_STATE old_nfc_state;
 #endif
-  uint8_t trace_level;
   uint8_t last_hdr[NFC_SAVED_HDR_SIZE]; /* part of last NCI command header */
   uint8_t last_cmd[NFC_SAVED_CMD_SIZE]; /* part of last NCI command payload */
 #if (NXP_EXTNS == TRUE)
@@ -326,9 +314,12 @@ typedef struct {
   bool bIssueModeSetCmd;
   bool bBlkPwrlinkAndModeSetCmd;
   NFC_HDR* temp_data;
+  bool isLowRam;
 #endif
   uint8_t nci_version;     /* NCI version used for NCI communication*/
 
+  bool isScbrSupported; /* indicating if system code based route is supported */
+
   uint8_t hci_packet_size; /* maximum hci payload size*/
 
   uint8_t hci_conn_credits; /* maximum conn credits for static HCI*/
@@ -336,6 +327,8 @@ typedef struct {
   uint16_t nci_max_v_size; /*maximum NFC V rf frame size*/
 
   TIMER_LIST_ENT nci_setmode_ntf_timer;/*Mode notification timer*/
+  uint8_t rawVsCbflag;
+  uint8_t deact_reason;
 } tNFC_CB;
 
 #if (NXP_EXTNS == TRUE)
@@ -366,8 +359,6 @@ extern tNFC_CB nfc_cb;
 /****************************************************************************
  ** Internal nfc functions
  ****************************************************************************/
-extern void nfc_init(void);
-
 /* from nfc_utils.c */
 extern tNFC_CONN_CB* nfc_alloc_conn_cb(tNFC_CONN_CBACK* p_cback);
 extern tNFC_CONN_CB* nfc_find_conn_cb_by_conn_id(uint8_t conn_id);
@@ -377,7 +368,6 @@ extern void nfc_free_conn_cb(tNFC_CONN_CB* p_cb);
 extern void nfc_reset_all_conn_cbs(void);
 extern void nfc_data_event(tNFC_CONN_CB* p_cb);
 
-void nfc_ncif_send(NFC_HDR* p_buf, bool is_cmd);
 extern uint8_t nfc_ncif_send_data(tNFC_CONN_CB* p_cb, NFC_HDR* p_data);
 extern void nfc_ncif_cmd_timeout(void);
 extern void nfc_wait_2_deactivate_timeout(void);
@@ -410,19 +400,19 @@ extern void nfc_ncif_proc_init_rsp(NFC_HDR* p_msg);
 extern void nfc_ncif_proc_get_config_rsp(NFC_HDR* p_msg);
 extern void nfc_ncif_proc_data(NFC_HDR* p_msg);
 #if (NXP_EXTNS == TRUE)
-extern uint8_t nfc_ncif_retransmit_data(tNFC_CONN_CB* p_cb, NFC_HDR* p_data);
 extern tNFC_STATUS nfc_ncif_store_FWVersion(uint8_t* p_buf);
+extern uint8_t nfc_ncif_retransmit_data(tNFC_CONN_CB* p_cb, NFC_HDR* p_data);
 extern tNFC_STATUS nfc_ncif_set_MaxRoutingTableSize(uint8_t* p_buf);
-extern void nfc_ncif_proc_isodep_nak_presence_check_status (uint8_t status, bool is_ntf);
-extern void nfc_ncif_update_window(void);
 extern void nfc_ncif_empty_cmd_queue();
-extern bool nfc_ncif_proc_proprietary_rsp(uint8_t mt, uint8_t gid, uint8_t oid);
 extern void nfc_ncif_proc_rf_wtx_ntf(uint8_t* p, uint16_t plen);
 #endif
 extern bool nfa_dm_p2p_prio_logic(uint8_t event, uint8_t* p, uint8_t ntf_rsp);
 extern void nfa_dm_p2p_timer_event();
+extern bool nfc_ncif_proc_proprietary_rsp(uint8_t mt, uint8_t gid, uint8_t oid);
 extern void nfa_dm_p2p_prio_logic_cleanup();
-
+extern void nfc_ncif_proc_isodep_nak_presence_check_status(uint8_t status,
+                                                           bool is_ntf);
+extern void nfc_ncif_update_window(void);
 #if (NFC_RW_ONLY == FALSE)
 extern void nfc_ncif_proc_rf_field_ntf(uint8_t rf_status);
 #else
@@ -430,7 +420,7 @@ extern void nfc_ncif_proc_rf_field_ntf(uint8_t rf_status);
 #endif
 
 /* From nfc_task.c */
-extern uint32_t nfc_task(uint32_t param);
+extern uint32_t nfc_task(uint32_t);
 void nfc_task_shutdown_nfcc(void);
 
 /* From nfc_main.c */
@@ -452,8 +442,4 @@ void nfc_process_quick_timer_evt(void);
 void set_i2c_fragmentation_enabled(int value);
 int get_i2c_fragmentation_enabled();
 
-#ifdef __cplusplus
-}
-#endif
-
 #endif /* NFC_INT_H_ */
diff --git a/src/nfc/include/nfc_vs.h b/src/nfc/include/nfc_vs.h
new file mode 100755
index 0000000..2889cd1
--- /dev/null
+++ b/src/nfc/include/nfc_vs.h
@@ -0,0 +1,29 @@
+/******************************************************************************
+ * Copyright (C) 2017-2018 NXP Semiconductors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ *  This file contains the Near Field Communication (NFC) VS related internal
+ *  function / definitions.
+ *
+ ******************************************************************************/
+
+#ifndef NFC_VS_H_
+#define NFC_VS_H_
+
+
+#endif /* NFC_VS_H_ */
diff --git a/src/nfc/include/rw_api.h b/src/nfc/include/rw_api.h
index c2aebc9..bc46fe3 100644
--- a/src/nfc/include/rw_api.h
+++ b/src/nfc/include/rw_api.h
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -44,10 +44,11 @@
 
 #ifndef RW_API_H
 #define RW_API_H
+#include "nfc_api.h"
 #include "tags_defs.h"
 
-#define RW_T1T_BLD_ADD(a, k, y) a = ((k & 0xF) << 3) | (y & 0x7);
-#define RW_T1T_BLD_ADDS(a, s) a = ((s & 0xF) << 4);
+#define RW_T1T_BLD_ADD(a, k, y) (a) = (((k) & 0xF) << 3) | ((y) & 0x7);
+#define RW_T1T_BLD_ADDS(a, s) (a) = (((s) & 0xF) << 4);
 
 #define RW_T1T_FIRST_EVT 0x20
 #define RW_T2T_FIRST_EVT 0x40
@@ -178,23 +179,11 @@ typedef uint8_t tRW_EVENT;
 /* Tag is one time programmable */
 #define RW_NDEF_FL_OTP 0x80
 
-#define RW_T4T_CHK_ISO_DEP_NAK_PRES_CHK 5
-
 typedef uint8_t tRW_NDEF_FLAG;
 
-
 /* options for RW_T4tPresenceCheck  */
-#define RW_T4T_CHK_READ_BINARY_CH0 0
-#define RW_T4T_CHK_READ_BINARY_CH1 1
-#define RW_T4T_CHK_READ_BINARY_CH2 2
-#define RW_T4T_CHK_READ_BINARY_CH3 3
-#define RW_T4T_CHK_EMPTY_I_BLOCK 4
-
-typedef struct {
-  tNFC_STATUS status;
-  uint8_t hr[T1T_HR_LEN];
-  uint8_t uid[T1T_CMD_UID_LEN];
-} tRW_T1T_RID_EVT;
+#define RW_T4T_CHK_EMPTY_I_BLOCK 1
+#define RW_T4T_CHK_ISO_DEP_NAK_PRES_CHK 5
 
 typedef struct {
   tNFC_STATUS status;
@@ -284,6 +273,7 @@ typedef struct {
 
 typedef union {
   tNFC_STATUS status;
+  tRW_T2T_DETECT t2t_detect;       /* t2t NDEF information                  */
   tRW_T3T_POLL t3t_poll;           /* Response to t3t poll command          */
   tRW_T3T_SYSTEM_CODES t3t_sc;     /* Received system codes from t3 tag     */
   tRW_DETECT_TLV_DATA tlv;         /* The information of detected TLV data  */
@@ -1113,7 +1103,7 @@ extern tNFC_STATUS RW_I93ReadMultipleBlocks(uint16_t first_block_number,
 **                  NFC_STATUS_FAILED if other error
 **
 *******************************************************************************/
-extern tNFC_STATUS RW_I93WriteMultipleBlocks(uint8_t first_block_number,
+extern tNFC_STATUS RW_I93WriteMultipleBlocks(uint16_t first_block_number,
                                              uint16_t number_blocks,
                                              uint8_t* p_data);
 
@@ -1375,20 +1365,6 @@ extern tNFC_STATUS RW_SendRawFrame(uint8_t* p_raw_data, uint16_t data_len);
 *******************************************************************************/
 extern tNFC_STATUS RW_SetActivatedTagType(tNFC_ACTIVATE_DEVT* p_activate_params,
                                           tRW_CBACK* p_cback);
-
-/*******************************************************************************
-**
-** Function         RW_SetTraceLevel
-**
-** Description      This function sets the trace level for Reader/Writer mode.
-**                  If called with a value of 0xFF,
-**                  it simply returns the current trace level.
-**
-** Returns          The new or current trace level
-**
-*******************************************************************************/
-extern uint8_t RW_SetTraceLevel(uint8_t new_level);
-
 #if (NXP_EXTNS == TRUE)
 extern tNFC_STATUS RW_T3BtGetPupiID();
 #endif
diff --git a/src/nfc/int/rw_int.h b/src/nfc/include/rw_int.h
similarity index 97%
rename from src/nfc/int/rw_int.h
rename to src/nfc/include/rw_int.h
index ccb523d..f9e24db 100644
--- a/src/nfc/int/rw_int.h
+++ b/src/nfc/include/rw_int.h
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -50,14 +50,6 @@
 #include "rw_api.h"
 
 /* Proprietary definitions for HR0 and HR1 */
-/* HI NIB Tag                                               */
-#define RW_T1T_HR0_HI_NIB 0xF0
-/* Jewel 64 Tag                                             */
-#define RW_T1T_IS_JEWEL64 0x20
-/* Jewel Tag                                                */
-#define RW_T1T_IS_JEWEL 0x00
-/* TOPAZ Tag                                                */
-#define RW_T1T_IS_TOPAZ 0x10
 /* TOPAZ96 Tag                                              */
 #define RW_T1T_IS_TOPAZ96 0x11
 /* TOPAZ512 Tag                                             */
@@ -284,11 +276,6 @@ typedef struct {
 #define T2T_NDEF_DETECTED 0x01
 #define T2T_NDEF_READ 0x02
 
-/* Max offset of an NDEF message in a T2 tag */
-#define T2T_MAX_NDEF_OFFSET 128
-#define T2T_MAX_RESERVED_BYTES_IN_TAG 0x64
-#define T2T_MAX_LOCK_BYTES_IN_TAG 0x64
-
 /* Maximum supported Memory control TLVS in the tag         */
 #define RW_T2T_MAX_MEM_TLVS 0x05
 /* Maximum supported Lock control TLVS in the tag           */
@@ -447,7 +434,6 @@ typedef struct {
   bool b_read_hdr;         /* Tag header read from tag */
   bool b_read_data;        /* Tag data block read from tag */
   bool b_hard_lock; /* Hard lock the tag as part of config tag to Read only */
-  uint8_t last_cmd_sent;
   bool check_tag_halt; /* Resent command after NACK rsp to find tag is in HALT
                           State   */
 #if (RW_NDEF_INCLUDED == true)
@@ -660,6 +646,8 @@ typedef uint8_t tRW_I93_RW_SUBSTATE;
 #define RW_I93_FLAG_RESET_AFI 0x08
 /* use 2 bytes for number of blocks        */
 #define RW_I93_FLAG_16BIT_NUM_BLOCK 0x10
+/* use extended commands */
+#define RW_I93_FLAG_EXT_COMMANDS 0x20
 
 /* searching for type                      */
 #define RW_I93_TLV_DETECT_STATE_TYPE 0x01
@@ -688,6 +676,8 @@ enum {
   RW_I93_STM_M24LR04E_R,             /* STM M24LR04E-R                   */
   RW_I93_STM_M24LR16E_R,             /* STM M24LR16E-R                   */
   RW_I93_STM_M24LR64E_R,             /* STM M24LR64E-R                   */
+  RW_I93_STM_ST25DV04K,              /* STM ST25DV04K                    */
+  RW_I93_STM_ST25DVHIK,              /* STM ST25DV 16K OR 64K            */
   RW_I93_UNKNOWN_PRODUCT             /* Unknwon product version          */
 };
 
@@ -741,16 +731,12 @@ typedef struct {
 #if (RW_STATS_INCLUDED == true)
   tRW_STATS stats;
 #endif /* RW_STATS_INCLUDED */
-  uint8_t trace_level;
 } tRW_CB;
 
 /*****************************************************************************
 **  EXTERNAL FUNCTION DECLARATIONS
 *****************************************************************************/
 
-#ifdef __cplusplus
-extern "C" {
-#endif
 
 /* Global NFC data */
 extern tRW_CB rw_cb;
@@ -788,7 +774,7 @@ extern void rw_t2t_handle_rsp(uint8_t* p_data);
 extern tNFC_STATUS rw_t2t_sector_change(uint8_t sector);
 extern tNFC_STATUS rw_t2t_read(uint16_t block);
 extern tNFC_STATUS rw_t2t_write(uint16_t block, uint8_t* p_write_data);
-extern void rw_t2t_process_timeout(TIMER_LIST_ENT* p_tle);
+extern void rw_t2t_process_timeout();
 extern tNFC_STATUS rw_t2t_select(void);
 void rw_t2t_handle_op_complete(void);
 
@@ -806,7 +792,7 @@ extern tNFC_STATUS rw_i93_select(uint8_t* p_uid);
 extern void rw_i93_process_timeout(TIMER_LIST_ENT* p_tle);
 
 void nfa_rw_update_pupi_id(uint8_t* p, uint8_t len);
-extern void rw_t4t_handle_isodep_nak_rsp(uint8_t status,bool is_ntf);
+extern void rw_t4t_handle_isodep_nak_rsp(uint8_t status, bool is_ntf);
 #if (RW_STATS_INCLUDED == true)
 /* Internal fcns for statistics (from rw_main.c) */
 void rw_main_reset_stats(void);
@@ -818,8 +804,4 @@ void rw_main_update_fail_stats(void);
 void rw_main_log_stats(void);
 #endif /* RW_STATS_INCLUDED */
 
-#ifdef __cplusplus
-}
-#endif
-
 #endif /* RW_INT_H_ */
diff --git a/src/nfc/include/tags_defs.h b/src/nfc/include/tags_defs.h
index 60ae9f1..a781dd1 100644
--- a/src/nfc/include/tags_defs.h
+++ b/src/nfc/include/tags_defs.h
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -99,28 +99,17 @@
 
 /* HRO value to indicate static Tag               */
 #define T1T_STATIC_HR0 0x11
-/* 0x1y, as long as (y!=1)                        */
-#define T1T_DYNAMIC_HR0 0x12
 /* HR0 value is 0x1y, indicates NDEF supported    */
 #define T1T_NDEF_SUPPORTED 0x10
-/* should be ignored                              */
-#define T1T_HR1 0x00
 /* UID block                                      */
 #define T1T_UID_BLOCK 0x00
 /* Reserved block                                 */
 #define T1T_RES_BLOCK 0x0D
 /* Static lock block                              */
 #define T1T_LOCK_BLOCK 0x0E
-/* Manufacturer ID offset                         */
-#define T1T_MID_OFFSET 0x06
-/* Reserved bytes offset                          */
-#define T1T_STATIC_RES_OFFSET 0x68
 /* Static lock offset                             */
 #define T1T_LOCK_0_OFFSET 0x70
-/* Static lock offset                             */
-#define T1T_LOCK_1_OFFSET 0x71
 /* Block F - typically used for dynamic locks     */
-#define T1T_DYNAMIC_LOCK_OFFSET 0x78
 #define T1T_DYNAMIC_LOCK_BYTES 0x08
 
 /* the len of reserved byte in T1T block 0        */
@@ -134,10 +123,6 @@
 /* CC offset */
 /* Offset for NDEF magic number in CC             */
 #define T1T_CC_NMN_OFFSET 0x00
-/* Offset for Version number in CC                */
-#define T1T_CC_VNO_OFFSET 0x01
-/* Offset for Tag memory size in CC               */
-#define T1T_CC_TMS_OFFSET 0x02
 /* Offset for Read/Write access in CC             */
 #define T1T_CC_RWA_OFFSET 0x03
 /* NDEF Magic Number byte number                  */
@@ -154,26 +139,10 @@
 #define T1T_CC_LEGACY_VNO 0x10
 /* Version Number                                 */
 #define T1T_CC_VNO 0x11
-/* TMS static memory - (8 * (n+1)).               */
-#define T1T_CC_TMS_STATIC 0x0E
 /* RWA - Read/write allowed                       */
 #define T1T_CC_RWA_RW 0x00
 /* RWA - Read only                                */
 #define T1T_CC_RWA_RO 0x0F
-
-/* May be used for padding. SHALL ignore this     */
-#define T1T_TAG_NULL 0
-/* Defines details of the lock bytes              */
-#define T1T_TAG_LOCK_CTRL 1
-/* Identifies reserved memory areas               */
-#define T1T_TAG_MEM_CTRL 2
-/* Contains the NDEF message                      */
-#define T1T_TAG_NDEF 3
-/* Tag proprietary information                    */
-#define T1T_TAG_PROPRIETARY 0xFD
-/* Last TLV block in the data area                */
-#define T1T_TAG_TERMINATOR 0xFE
-
 /* Tlv len for LOCK_CTRL/MEM TLV per spec         */
 #define T1T_DEFAULT_TLV_LEN 3
 /* Tlv type identifier len                        */
@@ -196,7 +165,6 @@
 /* Byte 0 in Length field to indicate LNDEF*/
 #define T1T_LONG_NDEF_LEN_FIELD_BYTE0 0xFF
 /* Min. len of NDEF to qualify as LNDEF  */
-#define T1T_LONG_NDEF_MIN_LEN 0x00FF
 
 /* Type 1 Tag Commands (7 bits) */
 /* read id                                      */
@@ -222,44 +190,27 @@
 /* Lock */
 /* Number of static lock bytes in tag   */
 #define T1T_NUM_STATIC_LOCK_BYTES 2
-/* Bytes locked by one static lock bit  */
-#define T1T_BYTES_LOCKED_BY_STATIC_LOCK_BIT 4
 
 /* Type 2 Tag related definitions */
-#define T2T_STATIC_MEM_STR 0
-#define T2T_DYNAMIC_MEM_STR 1
 #define T2T_STATIC_SIZE 64
-#define T2T_STATIC_BLOCKS 16 /* block 0 to Block 15 */
 #define T2T_BLOCK_SIZE 4
-#define T2T_HEADER_BLOCKS 4
 #define T2T_HEADER_SIZE 16
 #define T2T_SECTOR_SIZE 1024
 #define T2T_BLOCKS_PER_SECTOR 0x100
 
 #define T2T_UID_LEN 4        /* the len of UID used in T2T tag */
-#define T2T_BLOCK0_UID_LEN 3 /* the len of UID in Block 0 of T2T tag */
-#define T2T_BCC0_LEN 1       /* the len of BCC0 of T2T tag */
-#define T2T_BLOCK1_UID_LEN 4 /* the len of UID in Block 1 of T2T tag */
-#define T2T_BCC1_LEN 1       /* the len of BCC0 of T2T tag */
 /* the len of Serial number used in T2T tag */
-#define T2T_SNO_LEN 4
 #define T2T_INTERNAL_BYTES_LEN 2 /* the len of internal used in T2T tag */
-/* the len of static lock used in T2T tag */
-#define T2T_STATIC_LOCK_LEN 2
 /* Static Lock Bytes */
 #define T2T_STATIC_LOCK0 0x0A /* Static Lock 0 offset */
 #define T2T_STATIC_LOCK1 0x0B /* Static Lock 1 offset */
 
-/* the len of CC used in T2T tag                  */
-#define T2T_CC_LEN 4
-
 /* Capability Container definitions */
 #define T2T_CC_BLOCK 0x03     /* Capability container block */
 #define T2T_CC0_NMN_BYTE 0x0C /* NDEF Magic Number byte number */
 #define T2T_CC1_VNO_BYTE 0x0D /* Version Number byte number*/
 #define T2T_CC2_TMS_BYTE 0x0E /* Tag Memory Size byte number */
 #define T2T_CC3_RWA_BYTE 0x0F /* Read Write Access byte number */
-#define T2T_DATA_MEM 0x10     /* Data Memory */
 
 #define T2T_CC0_NMN 0xE1        /* NDEF Magic Number */
 #define T2T_CC1_VNO 0x11        /* Version Number */
@@ -279,15 +230,8 @@
 #define T2T_CMD_WRITE 0xA2   /* write 1 block  (4 bytes)  */
 #define T2T_CMD_SEC_SEL 0xC2 /* Sector select             */
 #define T2T_RSP_ACK 0xA
-#define T2T_RSP_NACK5 0x5
-#define T2T_RSP_NACK1 0x1 /* Nack can be either 1    */
 
 #define T2T_STATUS_OK_1_BIT 0x11
-#define T2T_STATUS_OK_2_BIT 0x12
-#define T2T_STATUS_OK_3_BIT 0x13
-#define T2T_STATUS_OK_4_BIT 0x14
-#define T2T_STATUS_OK_5_BIT 0x15
-#define T2T_STATUS_OK_6_BIT 0x16
 #define T2T_STATUS_OK_7_BIT 0x17
 
 #define T2T_FIRST_DATA_BLOCK 4
@@ -298,31 +242,20 @@
 
 /* Type 2 TLV definitions */
 /* May be used for padding. SHALL ignore this */
-#define T2T_TLV_TYPE_NULL 0
 #define T2T_TLV_TYPE_LOCK_CTRL 1      /* Defines details of the lock bytes */
-#define T2T_TLV_TYPE_MEM_CTRL 2       /* Identifies reserved memory areas */
-#define T2T_TLV_TYPE_NDEF 3           /* Contains the NDEF message */
-#define T2T_TLV_TYPE_PROPRIETARY 0xFD /* Tag proprietary information */
-#define T2T_TLV_TYPE_TERMINATOR 0xFE  /* Last TLV block in the data area */
 
 /* Tag len for LOCK_CTRL TLV per spec */
 #define T2T_TLEN_LOCK_CTRL_TLV 3
-/* Tag len for MEM_CTRL TLV per spec */
-#define T2T_TLEN_MEM_CTRL_TLV 3
 
-#if (NXP_EXTNS == TRUE)
 /* Maximum number of sectors supported */
+#if (NXP_EXTNS==TRUE || APPL_DTA_MODE == TRUE)
 #define T2T_MAX_SECTOR 3
 #else
-/* Maximum number of sectors supported */
 #define T2T_MAX_SECTOR 2
 #endif
-
 /* Tlv type identifier len                */
 #define T2T_TLV_TYPE_LEN 1
 
-/* Tlv len for LOCK_CTRL/MEM TLV per spec     */
-#define T2T_DEFAULT_TLV_LEN 3
 /* Length Field size of short NDEF Message    */
 #define T2T_SHORT_NDEF_LEN_FIELD_LEN 1
 /* Length Field size of Long NDEF Message     */
@@ -335,8 +268,6 @@
 /* Lock */
 /* Number of static lock bytes in tag   */
 #define T2T_NUM_STATIC_LOCK_BYTES 2
-/* Bytes locked by one static lock bit  */
-#define T2T_BYTES_LOCKED_BY_STATIC_LOCK_BIT 4
 
 #define T2T_CC2_TMS_MUL 0x06
 #define T2T_CC2_TMS_MULC 0x12
@@ -361,10 +292,7 @@ typedef struct {
 } tT3T_BLOCK_DESC;
 
 /* Poll RC (request code) definitions */
-#define T3T_POLL_RC_NONE 0 /* No RD requested in SENSF_RES */
 #define T3T_POLL_RC_SC 1   /* System code requested in SENSF_RES */
-/* Avanced protocol features requested in SENSF_RES */
-#define T3T_POLL_RC_COMM 2
 typedef uint8_t tT3T_POLL_RC;
 
 /* Definitions for constructing t3t command messages */
@@ -379,7 +307,6 @@ typedef uint8_t tT3T_POLL_RC;
 #define T3T_MSG_OPC_POLL_CMD 0x00
 #define T3T_MSG_OPC_POLL_RSP 0x01
 #define T3T_MSG_OPC_REQ_SERVICE_CMD 0x02
-#define T3T_MSG_OPC_REQ_SERVICE_RSP 0x03
 #define T3T_MSG_OPC_REQ_RESPONSE_CMD 0x04
 #define T3T_MSG_OPC_REQ_RESPONSE_RSP 0x05
 #define T3T_MSG_OPC_REQ_SYSTEMCODE_CMD 0x0C
@@ -397,22 +324,12 @@ typedef uint8_t tT3T_POLL_RC;
 /* Size of NDEF attribute info block (minus checksum) */
 #define T3T_MSG_NDEF_ATTR_INFO_SIZE 14
 
-/* offset of Manufacturer ID in UPDATE/CHECK messages */
-#define T3T_MSG_OFFSET_IDM 1
-/* offset of Number of Services parameter in UPDATE/CHECK messages */
-#define T3T_MSG_OFFSET_NUM_SERVICES 9
-/* offset of Service Code List parameter in UPDATE/CHECK messages */
-#define T3T_MSG_OFFSET_SERVICE_CODE_LIST 10
 /* len flag for Block List Element */
 #define T3T_MSG_MASK_TWO_BYTE_BLOCK_DESC_FORMAT 0x80
 /* service code list mask */
 #define T3T_MSG_SERVICE_LIST_MASK 0x0F
 #define T3T_MSG_SERVICE_LIST_MAX 16
 
-/* Max Number of Services per UPDATE command */
-#define T3T_MSG_NUM_SERVICES_UPDATE_MAX 12
-/* Max Number of Services per CHECK command */
-#define T3T_MSG_NUM_SERVICES_CHECK_MAX 15
 /* Max Number of Blocks per UPDATE command */
 #define T3T_MSG_NUM_BLOCKS_UPDATE_MAX 13
 /* Max Number of Blocks per CHECK command */
@@ -428,8 +345,6 @@ typedef uint8_t tT3T_POLL_RC;
 /* Common header definition for T3t responses */
 /* Common header: rspcode + NFCID2 + StatusFlag1 + StatusFlag2  */
 #define T3T_MSG_RSP_COMMON_HDR_LEN 11
-/* Common header + NumBlocks */
-#define T3T_MSG_RSP_CHECK_HDR_LEN (T3T_MSG_RSP_COMMON_HDR_LEN + 1)
 /* Offset for Response code */
 #define T3T_MSG_RSP_OFFSET_RSPCODE 0
 /* Offset for Manufacturer ID */
@@ -440,23 +355,13 @@ typedef uint8_t tT3T_POLL_RC;
 #define T3T_MSG_RSP_OFFSET_NUMBLOCKS 11
 /* Offset for Block Data (in CHECK response) */
 #define T3T_MSG_RSP_OFFSET_CHECK_DATA 12
-/* Offset for PMm (in POLL response) */
-#define T3T_MSG_RSP_OFFSET_POLL_PMM 9
-/* Offset for RD (in POLL response) */
-#define T3T_MSG_RSP_OFFSET_POLL_RD 17
-/* Offset for Number of Systems */
-#define T3T_MSG_RSP_OFFSET_NUMSYS 9
 
 #define T3T_MSG_RSP_STATUS_OK 0x00
 #define T3T_MSG_RSP_STATUS_ERROR 0x01
 
 #define T3T_MSG_RSP_STATUS2_ERROR_MEMORY 0x70
-#define T3T_MSG_RSP_STATUS2_ERROR_EXCESSIVE_WRITES 0x71
 #define T3T_MSG_RSP_STATUS2_ERROR_PROCESSING 0xFF
 
-/* Maximum payload lenght for NFC-F messages (including SoD) */
-#define T3T_NFC_F_MAX_PAYLOAD_LEN 0xFE
-
 /* Felica Lite defintions */
 /* Block ID for MC (memory configuration)                       */
 #define T3T_MSG_FELICALITE_BLOCK_ID_MC 0x88
@@ -464,9 +369,6 @@ typedef uint8_t tT3T_POLL_RC;
 /* Memory Configuration Block offset: MC_SP (Memory Configuration for scratch
  * pad)   */
 #define T3T_MSG_FELICALITE_MC_OFFSET_MC_SP 0x00
-/* Memory Configuration Block offset: MC_ALL (Memory Configuration for system
- * block) */
-#define T3T_MSG_FELICALITE_MC_OFFSET_MC_ALL 0x02
 /* Memory Configuration Block offset: SYS_OP (System Option) */
 #define T3T_MSG_FELICALITE_MC_OFFSET_SYS_OP 0x03
 /* Memory Configuration Block offset: RF_PRM (Memory Configuration for RF
@@ -485,7 +387,6 @@ typedef uint8_t tT3T_POLL_RC;
 #define T4T_VERSION_1_0 0x10 /* version 1.0 */
 #define T4T_MY_VERSION T4T_VERSION_2_0
 #define T4T_GET_MAJOR_VERSION(x) ((x) >> 4)
-#define T4T_GET_MINOR_VERSION(x) ((x)&0x0F)
 
 #define T4T_CMD_CLASS 0x00
 #define T4T_CMD_INS_SELECT 0xA4
@@ -535,8 +436,6 @@ typedef uint8_t tT3T_POLL_RC;
 #define T4T_FC_WRITE_ACCESS_OFFSET_IN_TLV 0x07
 
 #define T4T_NDEF_FILE_CONTROL_TYPE 0x04 /* NDEF File Control Type */
-/* Proprietary File Control Type */
-#define T4T_PROP_FILE_CONTROL_TYPE 0x05
 
 /* size of T(1),L(1),V(6) for file control */
 #define T4T_FILE_CONTROL_TLV_SIZE 0x08
@@ -571,104 +470,46 @@ typedef uint8_t tT3T_POLL_RC;
  **
  */
 
-/* Request flags 1 to 4 definition */
-#define I93_FLAG_SUB_CARRIER_MASK 0x01 /* Sub_carrier_flag */
 /* A single sub-carrier frequency shall be used by VICC */
 #define I93_FLAG_SUB_CARRIER_SINGLE 0x00
-/* Two sub-carriers shall be used by VICC               */
-#define I93_FLAG_SUB_CARRIER_DOUBLE 0x01
-
-#define I93_FLAG_DATA_RATE_MASK 0x02 /* Data_rate_flag */
-/* Low data rate shall be used  */
-#define I93_FLAG_DATA_RATE_LOW 0x00
 /* High data rate shall be used */
 #define I93_FLAG_DATA_RATE_HIGH 0x02
 
-#define I93_FLAG_INVENTORY_MASK 0x04 /* Inventory_flag */
-/* Flags 5 to 8 meaning is according to table 4 */
-#define I93_FLAG_INVENTORY_UNSET 0x00
 /* Flags 5 to 8 meaning is according to table 5 */
 #define I93_FLAG_INVENTORY_SET 0x04
 
-/* Protocol_Extension_flag */
-#define I93_FLAG_PROT_EXT_MASK 0x08
 /* No protocol format extension                         */
 #define I93_FLAG_PROT_EXT_NO 0x00
 /* Protocol format is extended. Reserved for future use */
 #define I93_FLAG_PROT_EXT_YES 0x08
 
-/* Request flags 5 to 6 definition when inventory flag is not set */
-#define I93_FLAG_SELECT_MASK 0x10 /* Select_flag */
-/* Request shall be executed by any VICC according to the setting of
- * Address_flag */
-#define I93_FLAG_SELECT_UNSET 0x00
-/* Request shall be executed only by VICC in selected state */
-#define I93_FLAG_SELECT_SET 0x10
-/* The Address_flag shall be set to 0 and the UID field shall bot be included in
- * the request */
-
-#define I93_FLAG_ADDRESS_MASK 0x20 /* Address_flag */
-/* Request is not addressed. UID field is not included. It shall be executed by
- * any VICC */
-#define I93_FLAG_ADDRESS_UNSET 0x00
 /* Request is addressed. UID field is included. It shall be executed only by
  * VICC */
 #define I93_FLAG_ADDRESS_SET 0x20
 /* whose UID matches the UID specified in the request */
 
-/* Request flags 5 to 6 definition when inventory flag is set */
-#define I93_FLAG_AFI_MASK 0x10 /* AFI_flag */
-/* AFI field is not present */
-#define I93_FLAG_AFI_NOT_PRESENT 0x00
 /* AFI field is present     */
 #define I93_FLAG_AFI_PRESENT 0x10
 
-#define I93_FLAG_SLOT_MASK 0x20 /* Nb_slots_flag */
-#define I93_FLAG_SLOT_16 0x00   /* 16 slots */
 #define I93_FLAG_SLOT_ONE 0x20  /* 1 slot   */
 
-/* Request flags 6 to 8 definition when inventory flag is set or not set */
-
-#define I93_FLAG_OPTION_MASK 0x40 /* Option_flag */
-/* Meaning is defined by the command description. */
-#define I93_FLAG_OPTION_UNSET 0x00
 /* It shall be set to 0 if not otherwise defined by command */
 /* Meaning is defined by the command description. */
 #define I93_FLAG_OPTION_SET 0x40
 
-/* Response flags */
-#define I93_FLAG_ERROR_MASK 0x01 /* Error_flag */
-/* No error                                           */
-#define I93_FLAG_ERORR_NOT_DETECTED 0x00
 /* Error detected, Error code is in the "Error" field */
 #define I93_FLAG_ERROR_DETECTED 0x01
 
 /* Response error code */
-/* The command is not supported, i.e. the request code is not recognized */
-#define I93_ERROR_CODE_NOT_SUPPORTED 0x01
-/* The command is not recognized, for example: a format error occured    */
-#define I93_ERROR_CODE_NOT_RECOGNIZED 0x02
 /* The command option is not supported                                   */
 #define I93_ERROR_CODE_OPTION_NOT_SUPPORTED 0x03
-/* Error with no information given or a specific error code is not supported */
-#define I93_ERROR_CODE_NO_INFO 0x0F
-/* The specific block is not available (doesn't exist)                   */
-#define I93_ERROR_CODE_BLOCK_NOT_AVAILABLE 0x10
-/* The specific block is already locked and thus cannot be locked again  */
-#define I93_ERROR_CODE_BLOCK_ALREADY_LOCKED 0x11
-/* The specific block is locked and its content cannot be changed        */
-#define I93_ERROR_CODE_BLOCK_LOCKED 0x12
 /* The specific block is was not successfully programmed                 */
 #define I93_ERROR_CODE_BLOCK_FAIL_TO_WRITE 0x13
-/* The specific block is was not successfully locked                     */
-#define I93_ERROR_CODE_BLOCK_FAIL_TO_LOCK 0x14
 
 /* UID length in bytes                  */
 #define I93_UID_BYTE_LEN 8
 /* Data Storage Format is not supported */
 #define I93_DFS_UNSUPPORTED 0x00
-/* Block is not locked                  */
-#define I93_BLOCK_UNLOCKED 0x00
 /* Block is locked                      */
 #define I93_BLOCK_LOCKED 0x01
 
@@ -678,10 +519,15 @@ typedef uint8_t tT3T_POLL_RC;
 
 /* ISO 15693 Optional commands */
 #define I93_CMD_READ_SINGLE_BLOCK 0x20  /* Read single block     */
+#define I93_CMD_EXT_READ_SINGLE_BLOCK 0x30 /* Extended Read single block */
 #define I93_CMD_WRITE_SINGLE_BLOCK 0x21 /* Write single block    */
+#define I93_CMD_EXT_WRITE_SINGLE_BLOCK 0x31 /* Extended Write single block */
 #define I93_CMD_LOCK_BLOCK 0x22         /* Lock block            */
+#define I93_CMD_EXT_LOCK_BLOCK 0x32     /* Extended Lock block            */
 #define I93_CMD_READ_MULTI_BLOCK 0x23   /* Read multiple blocks  */
+#define I93_CMD_EXT_READ_MULTI_BLOCK 0x33 /* Extended Read multiple blocks  */
 #define I93_CMD_WRITE_MULTI_BLOCK 0x24  /* Write multiple blocks */
+#define I93_CMD_EXT_WRITE_MULTI_BLOCK 0x34 /* Write multiple blocks */
 #define I93_CMD_SELECT 0x25             /* Select                */
 #define I93_CMD_RESET_TO_READY 0x26     /* Reset to ready        */
 #define I93_CMD_WRITE_AFI 0x27          /* Wreite AFI            */
@@ -690,8 +536,12 @@ typedef uint8_t tT3T_POLL_RC;
 #define I93_CMD_LOCK_DSFID 0x2A         /* Lock DSFID            */
 /* Get system information             */
 #define I93_CMD_GET_SYS_INFO 0x2B
+/* Get extended system information    */
+#define I93_CMD_EXT_GET_SYS_INFO 0x3B
 /* Get multiple block security status */
 #define I93_CMD_GET_MULTI_BLK_SEC 0x2C
+/* Get extended multiple block security status */
+#define I93_CMD_EXT_GET_MULTI_BLK_SEC 0x3C
 
 /* Information flags definition */
 /* DSFID is supported and DSFID field is present */
@@ -702,16 +552,15 @@ typedef uint8_t tT3T_POLL_RC;
 #define I93_INFO_FLAG_MEM_SIZE 0x04
 /* IC reference field is present                 */
 #define I93_INFO_FLAG_IC_REF 0x08
+/* Memory coded in 2 bytes address               */
+#define I93_INFO_FLAG_MOI 0x10
 
 /* Max block size in bytes */
 #define I93_MAX_BLOCK_LENGH 32
-/* Max number of blocks    */
-#define I93_MAX_NUM_BLOCK 256
 
 /* ICODE Capability Container(CC) definition */
-#define I93_ICODE_CC_MAGIC_NUMER 0xE1    /* magic number in CC[0]  */
-#define I93_ICODE_CC_MAJOR_VER_MASK 0xC0 /* major version in CC[1] */
-#define I93_ICODE_CC_MINOR_VER_MASK 0x30 /* minor version in CC[1] */
+#define I93_ICODE_CC_MAGIC_NUMER_E1 0xE1 /* magic number in CC[0]  */
+#define I93_ICODE_CC_MAGIC_NUMER_E2 0xE2 /* magic number in CC[0]  */
 /* read access condition in CC[1]        */
 #define I93_ICODE_CC_READ_ACCESS_MASK 0x0C
 /* read access granted without security  */
@@ -799,6 +648,13 @@ typedef uint8_t tT3T_POLL_RC;
 /* IC Reference for M24LR64E-R: 01011110(b), blockSize: 4, numberBlocks: 0x800
  */
 #define I93_IC_REF_STM_M24LR64E_R 0x5E
+/* IC Reference for ST25DV04K: 00100100(b), blockSize: 4, numberBlocks: 0x80
++ */
+#define I93_IC_REF_STM_ST25DV04K 0x24
+/* IC Reference for ST25DVHIK: 00100110(b), blockSize: 4, numberBlocks: 0x800
++ * or 0x200
++ */
+#define I93_IC_REF_STM_ST25DVHIK 0x26
 
 #define I93_STM_BLOCKS_PER_SECTOR 32
 #define I93_STM_MAX_BLOCKS_PER_READ 32
diff --git a/src/nfc/int/tags_int.h b/src/nfc/include/tags_int.h
similarity index 94%
rename from src/nfc/int/tags_int.h
rename to src/nfc/include/tags_int.h
index 550c34c..9b6defd 100644
--- a/src/nfc/int/tags_int.h
+++ b/src/nfc/include/tags_int.h
@@ -82,14 +82,9 @@ extern const tT2T_CMD_RSP_INFO t2t_cmd_rsp_infos[];
 extern const tT2T_CMD_RSP_INFO* t2t_cmd_to_rsp_info(uint8_t opcode);
 extern uint8_t t2t_info_to_evt(const tT2T_CMD_RSP_INFO* p_info);
 
-#if (BT_TRACE_PROTOCOL == true)
 extern const char* t1t_info_to_str(const tT1T_CMD_RSP_INFO* p_info);
 extern const char* t2t_info_to_str(const tT2T_CMD_RSP_INFO* p_info);
-#else
-#define t1t_info_to_str(x) ""
-#define t2t_info_to_str(x) ""
-#endif
 extern int tags_pow(int x, int y);
-extern unsigned int tags_log2(register unsigned int x);
+extern unsigned int tags_log2(unsigned int x);
 
 #endif /* TAGS_INT_H */
diff --git a/src/nfc/llcp/llcp_api.c b/src/nfc/llcp/llcp_api.cc
similarity index 87%
rename from src/nfc/llcp/llcp_api.c
rename to src/nfc/llcp/llcp_api.cc
index 7cca07a..f7db33c 100644
--- a/src/nfc/llcp/llcp_api.c
+++ b/src/nfc/llcp/llcp_api.cc
@@ -1,8 +1,9 @@
 /******************************************************************************
+ *
  *  Copyright (c) 2016, The Linux Foundation. All rights reserved.
  *  Not a Contribution.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *  The original Work has been changed by NXP Semiconductors.
  *
  *  Copyright (C) 2010-2014 Broadcom Corporation
@@ -26,14 +27,18 @@
  *  This file contains the LLCP API code
  *
  ******************************************************************************/
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
 
+#include <string>
 #include <string.h>
 #include "gki.h"
-#include "nfc_target.h"
-#include "bt_types.h"
 #include "llcp_api.h"
 #include "llcp_int.h"
-#include "llcp_defs.h"
+
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
 
 #if (LLCP_TEST_INCLUDED == true) /* this is for LLCP testing */
 
@@ -52,7 +57,7 @@ tLLCP_TEST_PARAMS llcp_test_params = {
 **
 *******************************************************************************/
 void LLCP_SetTestParams(uint8_t version, uint16_t wks) {
-  LLCP_TRACE_API2("LLCP_SetTestParams () version:0x%02X, wks:0x%04X", version,
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("LLCP_SetTestParams () version:0x%02X, wks:0x%04X", version,
                   wks);
 
   if (version != 0xFF) llcp_test_params.version = version;
@@ -61,7 +66,6 @@ void LLCP_SetTestParams(uint8_t version, uint16_t wks) {
 }
 #endif
 
-#if (NXP_EXTNS == TRUE)
 /*******************************************************************************
 **
 ** Function         LLCP_RegisterDtaCback
@@ -73,11 +77,10 @@ void LLCP_SetTestParams(uint8_t version, uint16_t wks) {
 **
 *******************************************************************************/
 void LLCP_RegisterDtaCback(tLLCP_DTA_CBACK* p_dta_cback) {
-  LLCP_TRACE_API0("LLCP_RegisterDtaCback ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s", __func__);
 
   llcp_cb.p_dta_cback = p_dta_cback;
 }
-#endif
 
 /*******************************************************************************
 **
@@ -102,24 +105,24 @@ void LLCP_SetConfig(uint16_t link_miu, uint8_t opt, uint8_t wt,
                     uint16_t inact_timeout_target, uint16_t symm_delay,
                     uint16_t data_link_timeout,
                     uint16_t delay_first_pdu_timeout) {
-  LLCP_TRACE_API4(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "LLCP_SetConfig () link_miu:%d, opt:0x%02X, wt:%d, link_timeout:%d",
       link_miu, opt, wt, link_timeout);
-  LLCP_TRACE_API4(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "                 inact_timeout (init:%d,target:%d), symm_delay:%d, "
       "data_link_timeout:%d",
       inact_timeout_init, inact_timeout_target, symm_delay, data_link_timeout);
-  LLCP_TRACE_API1("                 delay_first_pdu_timeout:%d",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("                 delay_first_pdu_timeout:%d",
                   delay_first_pdu_timeout);
 
   if (link_miu < LLCP_DEFAULT_MIU) {
-    LLCP_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "LLCP_SetConfig (): link_miu shall not be smaller than "
         "LLCP_DEFAULT_MIU (%d)",
         LLCP_DEFAULT_MIU);
     link_miu = LLCP_DEFAULT_MIU;
   } else if (link_miu > LLCP_MAX_MIU) {
-    LLCP_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "LLCP_SetConfig (): link_miu shall not be bigger than LLCP_MAX_MIU "
         "(%d)",
         LLCP_MAX_MIU);
@@ -128,9 +131,9 @@ void LLCP_SetConfig(uint16_t link_miu, uint8_t opt, uint8_t wt,
 
   /* if Link MIU is bigger than GKI buffer */
   if (link_miu > LLCP_MIU) {
-    LLCP_TRACE_ERROR1(
-        "LLCP_SetConfig (): link_miu shall not be bigger than LLCP_MIU (%d)",
-        LLCP_MIU);
+    LOG(ERROR) << StringPrintf(
+        "LLCP_SetConfig (): link_miu shall not be bigger than LLCP_MIU (%lu)",
+        (unsigned long)LLCP_MIU);
     llcp_cb.lcb.local_link_miu = LLCP_MIU;
   } else
     llcp_cb.lcb.local_link_miu = link_miu;
@@ -139,13 +142,13 @@ void LLCP_SetConfig(uint16_t link_miu, uint8_t opt, uint8_t wt,
   llcp_cb.lcb.local_wt = wt;
 
   if (link_timeout < LLCP_LTO_UNIT) {
-    LLCP_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "LLCP_SetConfig (): link_timeout shall not be smaller than "
         "LLCP_LTO_UNIT (%d ms)",
         LLCP_LTO_UNIT);
     llcp_cb.lcb.local_lto = LLCP_DEFAULT_LTO_IN_MS;
   } else if (link_timeout > LLCP_MAX_LTO_IN_MS) {
-    LLCP_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "LLCP_SetConfig (): link_timeout shall not be bigger than "
         "LLCP_MAX_LTO_IN_MS (%d ms)",
         LLCP_MAX_LTO_IN_MS);
@@ -193,15 +196,15 @@ void LLCP_GetConfig(uint16_t* p_link_miu, uint8_t* p_opt, uint8_t* p_wt,
   *p_data_link_timeout = llcp_cb.lcb.data_link_timeout;
   *p_delay_first_pdu_timeout = llcp_cb.lcb.delay_first_pdu_timeout;
 
-  LLCP_TRACE_API4(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "LLCP_GetConfig () link_miu:%d, opt:0x%02X, wt:%d, link_timeout:%d",
       *p_link_miu, *p_opt, *p_wt, *p_link_timeout);
-  LLCP_TRACE_API4(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "                 inact_timeout (init:%d, target:%d), symm_delay:%d, "
       "data_link_timeout:%d",
       *p_inact_timeout_init, *p_inact_timeout_target, *p_symm_delay,
       *p_data_link_timeout);
-  LLCP_TRACE_API1("                 delay_first_pdu_timeout:%d",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("                 delay_first_pdu_timeout:%d",
                   *p_delay_first_pdu_timeout);
 }
 
@@ -234,10 +237,10 @@ void LLCP_GetDiscoveryConfig(uint8_t* p_wt, uint8_t* p_gen_bytes,
                              uint8_t* p_gen_bytes_len) {
   uint8_t* p = p_gen_bytes;
 
-  LLCP_TRACE_API0("LLCP_GetDiscoveryConfig ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("LLCP_GetDiscoveryConfig ()");
 
   if (*p_gen_bytes_len < LLCP_MIN_GEN_BYTES) {
-    LLCP_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "LLCP_GetDiscoveryConfig (): GenBytes length shall not be smaller than "
         "LLCP_MIN_GEN_BYTES (%d)",
         LLCP_MIN_GEN_BYTES);
@@ -309,7 +312,7 @@ void LLCP_GetDiscoveryConfig(uint8_t* p_wt, uint8_t* p_gen_bytes,
 *******************************************************************************/
 tLLCP_STATUS LLCP_ActivateLink(tLLCP_ACTIVATE_CONFIG config,
                                tLLCP_LINK_CBACK* p_link_cback) {
-  LLCP_TRACE_API1("LLCP_ActivateLink () link_state = %d",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("LLCP_ActivateLink () link_state = %d",
                   llcp_cb.lcb.link_state);
 
   if ((llcp_cb.lcb.link_state == LLCP_LINK_STATE_DEACTIVATED) &&
@@ -334,7 +337,7 @@ tLLCP_STATUS LLCP_ActivateLink(tLLCP_ACTIVATE_CONFIG config,
 **
 *******************************************************************************/
 tLLCP_STATUS LLCP_DeactivateLink(void) {
-  LLCP_TRACE_API1("LLCP_DeactivateLink () link_state = %d",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("LLCP_DeactivateLink () link_state = %d",
                   llcp_cb.lcb.link_state);
 
   if (llcp_cb.lcb.link_state != LLCP_LINK_STATE_DEACTIVATED) {
@@ -364,7 +367,7 @@ tLLCP_STATUS LLCP_DeactivateLink(void) {
 **
 *******************************************************************************/
 uint8_t LLCP_RegisterServer(uint8_t reg_sap, uint8_t link_type,
-                            char* p_service_name,
+                            std::string p_service_name,
                             tLLCP_APP_CBACK* p_app_cback) {
   uint8_t sap;
   uint16_t length;
@@ -372,16 +375,16 @@ uint8_t LLCP_RegisterServer(uint8_t reg_sap, uint8_t link_type,
       0,
   };
 
-  LLCP_TRACE_API3(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "LLCP_RegisterServer (): SAP:0x%x, link_type:0x%x, ServiceName:<%s>",
-      reg_sap, link_type, ((p_service_name == NULL) ? "" : p_service_name));
+      reg_sap, link_type, p_service_name.c_str());
 
   if (!p_app_cback) {
-    LLCP_TRACE_ERROR0("LLCP_RegisterServer (): Callback must be provided");
+    LOG(ERROR) << StringPrintf("LLCP_RegisterServer (): Callback must be provided");
     return LLCP_INVALID_SAP;
   } else if (((link_type & LLCP_LINK_TYPE_LOGICAL_DATA_LINK) == 0x00) &&
              ((link_type & LLCP_LINK_TYPE_DATA_LINK_CONNECTION) == 0x00)) {
-    LLCP_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "LLCP_RegisterServer (): link type (0x%x) must be specified",
         link_type);
     return LLCP_INVALID_SAP;
@@ -398,20 +401,20 @@ uint8_t LLCP_RegisterServer(uint8_t reg_sap, uint8_t link_type,
     }
 
     if (reg_sap == LLCP_INVALID_SAP) {
-      LLCP_TRACE_ERROR0("LLCP_RegisterServer (): out of resource");
+      LOG(ERROR) << StringPrintf("LLCP_RegisterServer (): out of resource");
       return LLCP_INVALID_SAP;
     }
   } else if (reg_sap == LLCP_SAP_LM) {
-    LLCP_TRACE_ERROR1("LLCP_RegisterServer (): SAP (0x%x) is for link manager",
+    LOG(ERROR) << StringPrintf("LLCP_RegisterServer (): SAP (0x%x) is for link manager",
                       reg_sap);
     return LLCP_INVALID_SAP;
   } else if (reg_sap <= LLCP_UPPER_BOUND_WK_SAP) {
     if (reg_sap >= LLCP_MAX_WKS) {
-      LLCP_TRACE_ERROR1(
+      LOG(ERROR) << StringPrintf(
           "LLCP_RegisterServer (): out of resource for SAP (0x%x)", reg_sap);
       return LLCP_INVALID_SAP;
     } else if (llcp_cb.wks_cb[reg_sap].p_app_cback) {
-      LLCP_TRACE_ERROR1(
+      LOG(ERROR) << StringPrintf(
           "LLCP_RegisterServer (): SAP (0x%x) is already registered", reg_sap);
       return LLCP_INVALID_SAP;
     } else {
@@ -419,19 +422,19 @@ uint8_t LLCP_RegisterServer(uint8_t reg_sap, uint8_t link_type,
     }
   } else if (reg_sap <= LLCP_UPPER_BOUND_SDP_SAP) {
     if (reg_sap - LLCP_LOWER_BOUND_SDP_SAP >= LLCP_MAX_SERVER) {
-      LLCP_TRACE_ERROR1(
+      LOG(ERROR) << StringPrintf(
           "LLCP_RegisterServer (): out of resource for SAP (0x%x)", reg_sap);
       return LLCP_INVALID_SAP;
     } else if (llcp_cb.server_cb[reg_sap - LLCP_LOWER_BOUND_SDP_SAP]
                    .p_app_cback) {
-      LLCP_TRACE_ERROR1(
+      LOG(ERROR) << StringPrintf(
           "LLCP_RegisterServer (): SAP (0x%x) is already registered", reg_sap);
       return LLCP_INVALID_SAP;
     } else {
       p_app_cb = &llcp_cb.server_cb[reg_sap - LLCP_LOWER_BOUND_SDP_SAP];
     }
   } else if (reg_sap >= LLCP_LOWER_BOUND_LOCAL_SAP) {
-    LLCP_TRACE_ERROR2(
+    LOG(ERROR) << StringPrintf(
         "LLCP_RegisterServer (): SAP (0x%x) must be less than 0x%x", reg_sap,
         LLCP_LOWER_BOUND_LOCAL_SAP);
     return LLCP_INVALID_SAP;
@@ -439,24 +442,23 @@ uint8_t LLCP_RegisterServer(uint8_t reg_sap, uint8_t link_type,
 
   memset(p_app_cb, 0x00, sizeof(tLLCP_APP_CB));
 
-  if (p_service_name) {
-    length = (uint8_t)strlen(p_service_name);
+  if (p_service_name.c_str()) {
+    length = p_service_name.length();
     if (length > LLCP_MAX_SN_LEN) {
-      LLCP_TRACE_ERROR1(
+      LOG(ERROR) << StringPrintf(
           "LLCP_RegisterServer (): Service Name (%d bytes) is too long",
           length);
       return LLCP_INVALID_SAP;
     }
 
-        p_app_cb->p_service_name = (uint8_t*) GKI_getbuf ((uint16_t) (length + 1));
-        if (p_app_cb->p_service_name == NULL)
-        {
-            LLCP_TRACE_ERROR0 ("LLCP_RegisterServer (): Out of resource");
-            return LLCP_INVALID_SAP;
-        }
+    p_app_cb->p_service_name = (char *)GKI_getbuf((uint16_t)(length + 1));
+    if (p_app_cb->p_service_name == NULL) {
+      LOG(ERROR) << StringPrintf("LLCP_RegisterServer (): Out of resource");
+      return LLCP_INVALID_SAP;
+    }
 
-        NQ_STRLCPY_S ((char *) p_app_cb->p_service_name, length + 1, (char *) p_service_name, length + 1);
-        p_app_cb->p_service_name[length] = 0;
+    NQ_STRLCPY_S ((char *) p_app_cb->p_service_name, length + 1, p_service_name.c_str(), length + 1);
+    p_app_cb->p_service_name[length] = 0;
   } else
     p_app_cb->p_service_name = NULL;
 
@@ -467,7 +469,7 @@ uint8_t LLCP_RegisterServer(uint8_t reg_sap, uint8_t link_type,
     llcp_cb.lcb.wks |= (1 << reg_sap);
   }
 
-  LLCP_TRACE_DEBUG1("LLCP_RegisterServer (): Registered SAP = 0x%02X", reg_sap);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("LLCP_RegisterServer (): Registered SAP = 0x%02X", reg_sap);
 
   if (link_type & LLCP_LINK_TYPE_LOGICAL_DATA_LINK) {
     llcp_cb.num_logical_data_link++;
@@ -495,14 +497,14 @@ uint8_t LLCP_RegisterClient(uint8_t link_type, tLLCP_APP_CBACK* p_app_cback) {
   uint8_t sap;
   tLLCP_APP_CB* p_app_cb;
 
-  LLCP_TRACE_API1("LLCP_RegisterClient (): link_type = 0x%x", link_type);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("LLCP_RegisterClient (): link_type = 0x%x", link_type);
 
   if (!p_app_cback) {
-    LLCP_TRACE_ERROR0("LLCP_RegisterClient (): Callback must be provided");
+    LOG(ERROR) << StringPrintf("LLCP_RegisterClient (): Callback must be provided");
     return LLCP_INVALID_SAP;
   } else if (((link_type & LLCP_LINK_TYPE_LOGICAL_DATA_LINK) == 0x00) &&
              ((link_type & LLCP_LINK_TYPE_DATA_LINK_CONNECTION) == 0x00)) {
-    LLCP_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "LLCP_RegisterClient (): link type (0x%x) must be specified",
         link_type);
     return LLCP_INVALID_SAP;
@@ -519,7 +521,7 @@ uint8_t LLCP_RegisterClient(uint8_t link_type, tLLCP_APP_CBACK* p_app_cback) {
   }
 
   if (reg_sap == LLCP_INVALID_SAP) {
-    LLCP_TRACE_ERROR0("LLCP_RegisterClient (): out of resource");
+    LOG(ERROR) << StringPrintf("LLCP_RegisterClient (): out of resource");
     return LLCP_INVALID_SAP;
   }
 
@@ -527,7 +529,7 @@ uint8_t LLCP_RegisterClient(uint8_t link_type, tLLCP_APP_CBACK* p_app_cback) {
   p_app_cb->p_service_name = NULL;
   p_app_cb->link_type = link_type;
 
-  LLCP_TRACE_DEBUG1("LLCP_RegisterClient (): Registered SAP = 0x%02X", reg_sap);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("LLCP_RegisterClient (): Registered SAP = 0x%02X", reg_sap);
 
   if (link_type & LLCP_LINK_TYPE_LOGICAL_DATA_LINK) {
     llcp_cb.num_logical_data_link++;
@@ -551,12 +553,12 @@ tLLCP_STATUS LLCP_Deregister(uint8_t local_sap) {
   uint8_t idx;
   tLLCP_APP_CB* p_app_cb;
 
-  LLCP_TRACE_API1("LLCP_Deregister () SAP:0x%x", local_sap);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("LLCP_Deregister () SAP:0x%x", local_sap);
 
   p_app_cb = llcp_util_get_app_cb(local_sap);
 
   if ((!p_app_cb) || (p_app_cb->p_app_cback == NULL)) {
-    LLCP_TRACE_ERROR1("LLCP_Deregister (): SAP (0x%x) is not registered",
+    LOG(ERROR) << StringPrintf("LLCP_Deregister (): SAP (0x%x) is not registered",
                       local_sap);
     return LLCP_STATUS_FAIL;
   }
@@ -614,7 +616,7 @@ bool LLCP_IsLogicalLinkCongested(uint8_t local_sap, uint8_t num_pending_ui_pdu,
                                  uint8_t total_pending_i_pdu) {
   tLLCP_APP_CB* p_app_cb;
 
-  LLCP_TRACE_API4(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "LLCP_IsLogicalLinkCongested () Local SAP:0x%x, pending = (%d, %d, %d)",
       local_sap, num_pending_ui_pdu, total_pending_ui_pdu, total_pending_i_pdu);
 
@@ -656,33 +658,33 @@ tLLCP_STATUS LLCP_SendUI(uint8_t ssap, uint8_t dsap, NFC_HDR* p_buf) {
   tLLCP_STATUS status = LLCP_STATUS_FAIL;
   tLLCP_APP_CB* p_app_cb;
 
-  LLCP_TRACE_API2("LLCP_SendUI () SSAP=0x%x, DSAP=0x%x", ssap, dsap);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("LLCP_SendUI () SSAP=0x%x, DSAP=0x%x", ssap, dsap);
 
   p_app_cb = llcp_util_get_app_cb(ssap);
 
   if ((p_app_cb == NULL) || (p_app_cb->p_app_cback == NULL)) {
-    LLCP_TRACE_ERROR1("LLCP_SendUI (): SSAP (0x%x) is not registered", ssap);
+    LOG(ERROR) << StringPrintf("LLCP_SendUI (): SSAP (0x%x) is not registered", ssap);
   } else if ((p_app_cb->link_type & LLCP_LINK_TYPE_LOGICAL_DATA_LINK) == 0) {
-    LLCP_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "LLCP_SendUI (): Logical link on SSAP (0x%x) is not enabled", ssap);
   } else if (llcp_cb.lcb.link_state != LLCP_LINK_STATE_ACTIVATED) {
-    LLCP_TRACE_ERROR0("LLCP_SendUI (): LLCP link is not activated");
+    LOG(ERROR) << StringPrintf("LLCP_SendUI (): LLCP link is not activated");
   } else if ((llcp_cb.lcb.peer_opt == LLCP_LSC_UNKNOWN) ||
              (llcp_cb.lcb.peer_opt & LLCP_LSC_1)) {
     if (p_buf->len <= llcp_cb.lcb.peer_miu) {
       if (p_buf->offset >= LLCP_MIN_OFFSET) {
         status = llcp_util_send_ui(ssap, dsap, p_app_cb, p_buf);
       } else {
-        LLCP_TRACE_ERROR2("LLCP_SendUI (): offset (%d) must be %d at least",
+        LOG(ERROR) << StringPrintf("LLCP_SendUI (): offset (%d) must be %d at least",
                           p_buf->offset, LLCP_MIN_OFFSET);
       }
     } else {
-      LLCP_TRACE_ERROR0(
+      LOG(ERROR) << StringPrintf(
           "LLCP_SendUI (): Data length shall not be bigger than peer's link "
           "MIU");
     }
   } else {
-    LLCP_TRACE_ERROR0(
+    LOG(ERROR) << StringPrintf(
         "LLCP_SendUI (): Peer doesn't support connectionless link");
   }
 
@@ -716,7 +718,7 @@ bool LLCP_ReadLogicalLinkData(uint8_t local_sap, uint32_t max_data_len,
   uint8_t* p_ui_pdu;
   uint16_t pdu_hdr, ui_pdu_length;
 
-  LLCP_TRACE_API1("LLCP_ReadLogicalLinkData () Local SAP:0x%x", local_sap);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("LLCP_ReadLogicalLinkData () Local SAP:0x%x", local_sap);
 
   *p_data_len = 0;
 
@@ -779,7 +781,7 @@ bool LLCP_ReadLogicalLinkData(uint8_t local_sap, uint32_t max_data_len,
       return (false);
     }
   } else {
-    LLCP_TRACE_ERROR1("LLCP_ReadLogicalLinkData (): Unregistered SAP:0x%x",
+    LOG(ERROR) << StringPrintf("LLCP_ReadLogicalLinkData (): Unregistered SAP:0x%x",
                       local_sap);
 
     return (false);
@@ -803,7 +805,7 @@ uint32_t LLCP_FlushLogicalLinkRxData(uint8_t local_sap) {
   uint8_t* p_ui_pdu;
   uint16_t ui_pdu_length;
 
-  LLCP_TRACE_API1("LLCP_FlushLogicalLinkRxData () Local SAP:0x%x", local_sap);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("LLCP_FlushLogicalLinkRxData () Local SAP:0x%x", local_sap);
 
   p_app_cb = llcp_util_get_app_cb(local_sap);
 
@@ -836,7 +838,7 @@ uint32_t LLCP_FlushLogicalLinkRxData(uint8_t local_sap) {
     /* number of received UI PDU is decreased so check rx congestion status */
     llcp_util_check_rx_congested_status();
   } else {
-    LLCP_TRACE_ERROR1("LLCP_FlushLogicalLinkRxData (): Unregistered SAP:0x%x",
+    LOG(ERROR) << StringPrintf("LLCP_FlushLogicalLinkRxData (): Unregistered SAP:0x%x",
                       local_sap);
   }
 
@@ -862,11 +864,11 @@ tLLCP_STATUS LLCP_ConnectReq(uint8_t reg_sap, uint8_t dsap,
   tLLCP_APP_CB* p_app_cb;
   tLLCP_CONNECTION_PARAMS params;
 
-  LLCP_TRACE_API2("LLCP_ConnectReq () reg_sap=0x%x, DSAP=0x%x", reg_sap, dsap);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("LLCP_ConnectReq () reg_sap=0x%x, DSAP=0x%x", reg_sap, dsap);
 
   if ((llcp_cb.lcb.peer_opt != LLCP_LSC_UNKNOWN) &&
       ((llcp_cb.lcb.peer_opt & LLCP_LSC_2) == 0)) {
-    LLCP_TRACE_ERROR0(
+    LOG(ERROR) << StringPrintf(
         "LLCP_ConnectReq (): Peer doesn't support connection-oriented link");
     return LLCP_STATUS_FAIL;
   }
@@ -882,28 +884,28 @@ tLLCP_STATUS LLCP_ConnectReq(uint8_t reg_sap, uint8_t dsap,
 
   /* if application is registered */
   if ((p_app_cb == NULL) || (p_app_cb->p_app_cback == NULL)) {
-    LLCP_TRACE_ERROR1("LLCP_ConnectReq (): SSAP (0x%x) is not registered",
+    LOG(ERROR) << StringPrintf("LLCP_ConnectReq (): SSAP (0x%x) is not registered",
                       reg_sap);
     return LLCP_STATUS_FAIL;
   }
 
   if (dsap == LLCP_SAP_LM) {
-    LLCP_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "LLCP_ConnectReq (): DSAP (0x%x) must not be link manager SAP", dsap);
     return LLCP_STATUS_FAIL;
   }
 
   if (dsap == LLCP_SAP_SDP) {
     if (strlen(p_params->sn) > LLCP_MAX_SN_LEN) {
-      LLCP_TRACE_ERROR1(
-          "LLCP_ConnectReq (): Service Name (%d bytes) is too long",
+      LOG(ERROR) << StringPrintf(
+          "LLCP_ConnectReq (): Service Name (%zu bytes) is too long",
           strlen(p_params->sn));
       return LLCP_STATUS_FAIL;
     }
   }
 
   if ((p_params) && (p_params->miu > llcp_cb.lcb.local_link_miu)) {
-    LLCP_TRACE_ERROR0(
+    LOG(ERROR) << StringPrintf(
         "LLCP_ConnectReq (): Data link MIU shall not be bigger than local link "
         "MIU");
     return LLCP_STATUS_FAIL;
@@ -917,7 +919,7 @@ tLLCP_STATUS LLCP_ConnectReq(uint8_t reg_sap, uint8_t dsap,
     ** link connection if there is multiple pending connection request on
     ** the same local SAP.
     */
-    LLCP_TRACE_ERROR0(
+    LOG(ERROR) << StringPrintf(
         "LLCP_ConnectReq (): There is pending connect request on this reg_sap");
     return LLCP_STATUS_FAIL;
   }
@@ -928,7 +930,7 @@ tLLCP_STATUS LLCP_ConnectReq(uint8_t reg_sap, uint8_t dsap,
     status =
         llcp_dlsm_execute(p_dlcb, LLCP_DLC_EVENT_API_CONNECT_REQ, p_params);
     if (status != LLCP_STATUS_SUCCESS) {
-      LLCP_TRACE_ERROR0("LLCP_ConnectReq (): Error in state machine");
+      LOG(ERROR) << StringPrintf("LLCP_ConnectReq (): Error in state machine");
       llcp_util_deallocate_data_link(p_dlcb);
       return LLCP_STATUS_FAIL;
     }
@@ -956,7 +958,7 @@ tLLCP_STATUS LLCP_ConnectCfm(uint8_t local_sap, uint8_t remote_sap,
   tLLCP_DLCB* p_dlcb;
   tLLCP_CONNECTION_PARAMS params;
 
-  LLCP_TRACE_API2("LLCP_ConnectCfm () Local SAP:0x%x, Remote SAP:0x%x)",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("LLCP_ConnectCfm () Local SAP:0x%x, Remote SAP:0x%x)",
                   local_sap, remote_sap);
 
   if (!p_params) {
@@ -966,7 +968,7 @@ tLLCP_STATUS LLCP_ConnectCfm(uint8_t local_sap, uint8_t remote_sap,
     p_params = &params;
   }
   if (p_params->miu > llcp_cb.lcb.local_link_miu) {
-    LLCP_TRACE_ERROR0(
+    LOG(ERROR) << StringPrintf(
         "LLCP_ConnectCfm (): Data link MIU shall not be bigger than local link "
         "MIU");
     return LLCP_STATUS_FAIL;
@@ -978,7 +980,7 @@ tLLCP_STATUS LLCP_ConnectCfm(uint8_t local_sap, uint8_t remote_sap,
     status =
         llcp_dlsm_execute(p_dlcb, LLCP_DLC_EVENT_API_CONNECT_CFM, p_params);
   } else {
-    LLCP_TRACE_ERROR0("LLCP_ConnectCfm (): No data link");
+    LOG(ERROR) << StringPrintf("LLCP_ConnectCfm (): No data link");
     status = LLCP_STATUS_FAIL;
   }
 
@@ -1006,7 +1008,7 @@ tLLCP_STATUS LLCP_ConnectReject(uint8_t local_sap, uint8_t remote_sap,
   tLLCP_STATUS status;
   tLLCP_DLCB* p_dlcb;
 
-  LLCP_TRACE_API3(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "LLCP_ConnectReject () Local SAP:0x%x, Remote SAP:0x%x, reason:0x%x",
       local_sap, remote_sap, reason);
 
@@ -1017,7 +1019,7 @@ tLLCP_STATUS LLCP_ConnectReject(uint8_t local_sap, uint8_t remote_sap,
         llcp_dlsm_execute(p_dlcb, LLCP_DLC_EVENT_API_CONNECT_REJECT, &reason);
     llcp_util_deallocate_data_link(p_dlcb);
   } else {
-    LLCP_TRACE_ERROR0("LLCP_ConnectReject (): No data link");
+    LOG(ERROR) << StringPrintf("LLCP_ConnectReject (): No data link");
     status = LLCP_STATUS_FAIL;
   }
 
@@ -1040,7 +1042,7 @@ bool LLCP_IsDataLinkCongested(uint8_t local_sap, uint8_t remote_sap,
                               uint8_t total_pending_i_pdu) {
   tLLCP_DLCB* p_dlcb;
 
-  LLCP_TRACE_API5(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "LLCP_IsDataLinkCongested () Local SAP:0x%x, Remote SAP:0x%x, pending = "
       "(%d, %d, %d)",
       local_sap, remote_sap, num_pending_i_pdu, total_pending_ui_pdu,
@@ -1081,7 +1083,7 @@ tLLCP_STATUS LLCP_SendData(uint8_t local_sap, uint8_t remote_sap,
   tLLCP_STATUS status = LLCP_STATUS_FAIL;
   tLLCP_DLCB* p_dlcb;
 
-  LLCP_TRACE_API2("LLCP_SendData () Local SAP:0x%x, Remote SAP:0x%x", local_sap,
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("LLCP_SendData () Local SAP:0x%x, Remote SAP:0x%x", local_sap,
                   remote_sap);
 
   p_dlcb = llcp_dlc_find_dlcb_by_sap(local_sap, remote_sap);
@@ -1091,17 +1093,17 @@ tLLCP_STATUS LLCP_SendData(uint8_t local_sap, uint8_t remote_sap,
       if (p_buf->offset >= LLCP_MIN_OFFSET) {
         status = llcp_dlsm_execute(p_dlcb, LLCP_DLC_EVENT_API_DATA_REQ, p_buf);
       } else {
-        LLCP_TRACE_ERROR2("LLCP_SendData (): offset (%d) must be %d at least",
+        LOG(ERROR) << StringPrintf("LLCP_SendData (): offset (%d) must be %d at least",
                           p_buf->offset, LLCP_MIN_OFFSET);
       }
     } else {
-      LLCP_TRACE_ERROR2(
+      LOG(ERROR) << StringPrintf(
           "LLCP_SendData (): Information (%d bytes) cannot be more than peer "
           "MIU (%d bytes)",
           p_buf->len, p_dlcb->remote_miu);
     }
   } else {
-    LLCP_TRACE_ERROR0("LLCP_SendData (): No data link");
+    LOG(ERROR) << StringPrintf("LLCP_SendData (): No data link");
   }
 
   if (status == LLCP_STATUS_FAIL) {
@@ -1134,7 +1136,7 @@ bool LLCP_ReadDataLinkData(uint8_t local_sap, uint8_t remote_sap,
   uint8_t* p_i_pdu;
   uint16_t i_pdu_length;
 
-  LLCP_TRACE_API2("LLCP_ReadDataLinkData () Local SAP:0x%x, Remote SAP:0x%x",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("LLCP_ReadDataLinkData () Local SAP:0x%x, Remote SAP:0x%x",
                   local_sap, remote_sap);
 
   p_dlcb = llcp_dlc_find_dlcb_by_sap(local_sap, remote_sap);
@@ -1202,7 +1204,7 @@ bool LLCP_ReadDataLinkData(uint8_t local_sap, uint8_t remote_sap,
       return (false);
     }
   } else {
-    LLCP_TRACE_ERROR0("LLCP_ReadDataLinkData (): No data link connection");
+    LOG(ERROR) << StringPrintf("LLCP_ReadDataLinkData (): No data link connection");
 
     return (false);
   }
@@ -1225,7 +1227,7 @@ uint32_t LLCP_FlushDataLinkRxData(uint8_t local_sap, uint8_t remote_sap) {
   uint8_t* p_i_pdu;
   uint16_t i_pdu_length;
 
-  LLCP_TRACE_API2("LLCP_FlushDataLinkRxData () Local SAP:0x%x, Remote SAP:0x%x",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("LLCP_FlushDataLinkRxData () Local SAP:0x%x, Remote SAP:0x%x",
                   local_sap, remote_sap);
 
   p_dlcb = llcp_dlc_find_dlcb_by_sap(local_sap, remote_sap);
@@ -1266,7 +1268,7 @@ uint32_t LLCP_FlushDataLinkRxData(uint8_t local_sap, uint8_t remote_sap) {
     /* number of received I PDU is decreased so check rx congestion status */
     llcp_util_check_rx_congested_status();
   } else {
-    LLCP_TRACE_ERROR0("LLCP_FlushDataLinkRxData (): No data link connection");
+    LOG(ERROR) << StringPrintf("LLCP_FlushDataLinkRxData (): No data link connection");
   }
 
   return (flushed_length);
@@ -1287,7 +1289,7 @@ tLLCP_STATUS LLCP_DisconnectReq(uint8_t local_sap, uint8_t remote_sap,
   tLLCP_STATUS status;
   tLLCP_DLCB* p_dlcb;
 
-  LLCP_TRACE_API3(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "LLCP_DisconnectReq () Local SAP:0x%x, Remote SAP:0x%x, flush=%d",
       local_sap, remote_sap, flush);
 
@@ -1297,7 +1299,7 @@ tLLCP_STATUS LLCP_DisconnectReq(uint8_t local_sap, uint8_t remote_sap,
     status =
         llcp_dlsm_execute(p_dlcb, LLCP_DLC_EVENT_API_DISCONNECT_REQ, &flush);
   } else {
-    LLCP_TRACE_ERROR0("LLCP_DisconnectReq (): No data link");
+    LOG(ERROR) << StringPrintf("LLCP_DisconnectReq (): No data link");
     status = LLCP_STATUS_FAIL;
   }
 
@@ -1320,7 +1322,7 @@ tLLCP_STATUS LLCP_SetTxCompleteNtf(uint8_t local_sap, uint8_t remote_sap) {
   tLLCP_STATUS status;
   tLLCP_DLCB* p_dlcb;
 
-  LLCP_TRACE_API2("LLCP_SetTxCompleteNtf () Local SAP:0x%x, Remote SAP:0x%x",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("LLCP_SetTxCompleteNtf () Local SAP:0x%x, Remote SAP:0x%x",
                   local_sap, remote_sap);
 
   p_dlcb = llcp_dlc_find_dlcb_by_sap(local_sap, remote_sap);
@@ -1330,7 +1332,7 @@ tLLCP_STATUS LLCP_SetTxCompleteNtf(uint8_t local_sap, uint8_t remote_sap) {
     p_dlcb->flags |= LLCP_DATA_LINK_FLAG_NOTIFY_TX_DONE;
     status = LLCP_STATUS_SUCCESS;
   } else {
-    LLCP_TRACE_ERROR0("LLCP_SetTxCompleteNtf (): No data link");
+    LOG(ERROR) << StringPrintf("LLCP_SetTxCompleteNtf (): No data link");
     status = LLCP_STATUS_FAIL;
   }
 
@@ -1352,7 +1354,7 @@ tLLCP_STATUS LLCP_SetLocalBusyStatus(uint8_t local_sap, uint8_t remote_sap,
   tLLCP_STATUS status;
   tLLCP_DLCB* p_dlcb;
 
-  LLCP_TRACE_API2("LLCP_SetLocalBusyStatus () Local SAP:0x%x, is_busy=%d",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("LLCP_SetLocalBusyStatus () Local SAP:0x%x, is_busy=%d",
                   local_sap, is_busy);
 
   p_dlcb = llcp_dlc_find_dlcb_by_sap(local_sap, remote_sap);
@@ -1372,7 +1374,7 @@ tLLCP_STATUS LLCP_SetLocalBusyStatus(uint8_t local_sap, uint8_t remote_sap,
     }
     status = LLCP_STATUS_SUCCESS;
   } else {
-    LLCP_TRACE_ERROR0("LLCP_SetLocalBusyStatus (): No data link");
+    LOG(ERROR) << StringPrintf("LLCP_SetLocalBusyStatus (): No data link");
     status = LLCP_STATUS_FAIL;
   }
 
@@ -1390,7 +1392,7 @@ tLLCP_STATUS LLCP_SetLocalBusyStatus(uint8_t local_sap, uint8_t remote_sap,
 **
 *******************************************************************************/
 uint16_t LLCP_GetRemoteWKS(void) {
-  LLCP_TRACE_API1("LLCP_GetRemoteWKS () WKS:0x%04x",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("LLCP_GetRemoteWKS () WKS:0x%04x",
                   (llcp_cb.lcb.link_state == LLCP_LINK_STATE_ACTIVATED)
                       ? llcp_cb.lcb.peer_wks
                       : 0);
@@ -1412,7 +1414,7 @@ uint16_t LLCP_GetRemoteWKS(void) {
 **
 *******************************************************************************/
 uint8_t LLCP_GetRemoteLSC(void) {
-  LLCP_TRACE_API1("LLCP_GetRemoteLSC () LSC:0x%x",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("LLCP_GetRemoteLSC () LSC:0x%x",
                   (llcp_cb.lcb.link_state == LLCP_LINK_STATE_ACTIVATED)
                       ? llcp_cb.lcb.peer_opt & (LLCP_LSC_1 | LLCP_LSC_2)
                       : 0);
@@ -1434,7 +1436,7 @@ uint8_t LLCP_GetRemoteLSC(void) {
 **
 *******************************************************************************/
 uint8_t LLCP_GetRemoteVersion(void) {
-  LLCP_TRACE_API1("LLCP_GetRemoteVersion () Version: 0x%x",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("LLCP_GetRemoteVersion () Version: 0x%x",
                   (llcp_cb.lcb.link_state == LLCP_LINK_STATE_ACTIVATED)
                       ? llcp_cb.lcb.peer_version
                       : 0);
@@ -1456,7 +1458,7 @@ uint8_t LLCP_GetRemoteVersion(void) {
 **
 *******************************************************************************/
 void LLCP_GetLinkMIU(uint16_t* p_local_link_miu, uint16_t* p_remote_link_miu) {
-  LLCP_TRACE_API0("LLCP_GetLinkMIU ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("LLCP_GetLinkMIU ()");
 
   if (llcp_cb.lcb.link_state == LLCP_LINK_STATE_ACTIVATED) {
     *p_local_link_miu = llcp_cb.lcb.local_link_miu;
@@ -1466,7 +1468,7 @@ void LLCP_GetLinkMIU(uint16_t* p_local_link_miu, uint16_t* p_remote_link_miu) {
     *p_remote_link_miu = 0;
   }
 
-  LLCP_TRACE_DEBUG2(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "LLCP_GetLinkMIU (): local_link_miu = %d, remote_link_miu = %d",
       *p_local_link_miu, *p_remote_link_miu);
 }
@@ -1487,22 +1489,22 @@ tLLCP_STATUS LLCP_DiscoverService(char* p_name, tLLCP_SDP_CBACK* p_cback,
   tLLCP_STATUS status;
   uint8_t i;
 
-  LLCP_TRACE_API1("LLCP_DiscoverService () Service Name:%s", p_name);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("LLCP_DiscoverService () Service Name:%s", p_name);
 
   if (llcp_cb.lcb.link_state != LLCP_LINK_STATE_ACTIVATED) {
-    LLCP_TRACE_ERROR0("LLCP_DiscoverService (): Link is not activated");
+    LOG(ERROR) << StringPrintf("LLCP_DiscoverService (): Link is not activated");
     return LLCP_STATUS_FAIL;
   }
 
   if (!p_cback) {
-    LLCP_TRACE_ERROR0("LLCP_DiscoverService (): Callback must be provided.");
+    LOG(ERROR) << StringPrintf("LLCP_DiscoverService (): Callback must be provided.");
     return LLCP_STATUS_FAIL;
   }
 
   /* if peer version is less than V1.1 then SNL is not supported */
   if ((llcp_cb.lcb.agreed_major_version == 0x01) &&
       (llcp_cb.lcb.agreed_minor_version < 0x01)) {
-    LLCP_TRACE_ERROR0("LLCP_DiscoverService (): Peer doesn't support SNL");
+    LOG(ERROR) << StringPrintf("LLCP_DiscoverService (): Peer doesn't support SNL");
     return LLCP_STATUS_FAIL;
   }
 
@@ -1523,7 +1525,7 @@ tLLCP_STATUS LLCP_DiscoverService(char* p_name, tLLCP_SDP_CBACK* p_cback,
     }
   }
 
-  LLCP_TRACE_ERROR0("LLCP_DiscoverService (): Out of resource");
+  LOG(ERROR) << StringPrintf("LLCP_DiscoverService (): Out of resource");
 
   return LLCP_STATUS_FAIL;
 }
diff --git a/src/nfc/llcp/llcp_dlc.c b/src/nfc/llcp/llcp_dlc.cc
similarity index 89%
rename from src/nfc/llcp/llcp_dlc.c
rename to src/nfc/llcp/llcp_dlc.cc
index 73e5003..5ba3590 100644
--- a/src/nfc/llcp/llcp_dlc.c
+++ b/src/nfc/llcp/llcp_dlc.cc
@@ -3,7 +3,7 @@
  *  Copyright (c) 2016, The Linux Foundation. All rights reserved.
  *  Not a Contribution.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *  The original Work has been changed by NXP Semiconductors.
  *
  *  Copyright (C) 2010-2014 Broadcom Corporation
@@ -29,13 +29,18 @@
  ******************************************************************************/
 
 #include <string.h>
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "gki.h"
-#include "nfc_target.h"
 #include "bt_types.h"
 #include "llcp_int.h"
 #include "llcp_defs.h"
 #include "nfc_int.h"
 
+using android::base::StringPrintf;
+
 static tLLCP_STATUS llcp_dlsm_idle(tLLCP_DLCB* p_dlcb, tLLCP_DLC_EVENT event,
                                    void* p_data);
 static tLLCP_STATUS llcp_dlsm_w4_remote_resp(tLLCP_DLCB* p_dlcb,
@@ -47,16 +52,12 @@ static tLLCP_STATUS llcp_dlsm_w4_local_resp(tLLCP_DLCB* p_dlcb,
 static tLLCP_STATUS llcp_dlsm_connected(tLLCP_DLCB* p_dlcb,
                                         tLLCP_DLC_EVENT event, void* p_data);
 static tLLCP_STATUS llcp_dlsm_w4_remote_dm(tLLCP_DLCB* p_dlcb,
-                                           tLLCP_DLC_EVENT event, void* p_data);
+                                           tLLCP_DLC_EVENT event);
+static std::string llcp_dlsm_get_state_name(tLLCP_DLC_STATE state);
+static std::string llcp_dlsm_get_event_name(tLLCP_DLC_EVENT event);
 
-#if (NXP_EXTNS == TRUE)
+extern bool nfc_debug_enabled;
 extern unsigned char appl_dta_mode_flag;
-#endif
-
-#if (BT_TRACE_VERBOSE == true)
-static char* llcp_dlsm_get_state_name(tLLCP_DLC_STATE state);
-static char* llcp_dlsm_get_event_name(tLLCP_DLC_EVENT event);
-#endif
 
 /*******************************************************************************
 **
@@ -72,14 +73,9 @@ tLLCP_STATUS llcp_dlsm_execute(tLLCP_DLCB* p_dlcb, tLLCP_DLC_EVENT event,
                                void* p_data) {
   tLLCP_STATUS status;
 
-#if (BT_TRACE_VERBOSE == true)
-  LLCP_TRACE_EVENT3("DLC (0x%02X) - state: %s, evt: %s", p_dlcb->local_sap,
-                    llcp_dlsm_get_state_name(p_dlcb->state),
-                    llcp_dlsm_get_event_name(event));
-#else
-  LLCP_TRACE_EVENT3("DLC (0x%02X) - state: %d, evt: %d", p_dlcb->local_sap,
-                    p_dlcb->state, event);
-#endif
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("DLC (0x%02X) - state: %s, evt: %s", p_dlcb->local_sap,
+                    llcp_dlsm_get_state_name(p_dlcb->state).c_str(),
+                    llcp_dlsm_get_event_name(event).c_str());
 
   switch (p_dlcb->state) {
     case LLCP_DLC_STATE_IDLE:
@@ -99,7 +95,7 @@ tLLCP_STATUS llcp_dlsm_execute(tLLCP_DLCB* p_dlcb, tLLCP_DLC_EVENT event,
       break;
 
     case LLCP_DLC_STATE_W4_REMOTE_DM:
-      status = llcp_dlsm_w4_remote_dm(p_dlcb, event, p_data);
+      status = llcp_dlsm_w4_remote_dm(p_dlcb, event);
       break;
 
     default:
@@ -153,7 +149,7 @@ static tLLCP_STATUS llcp_dlsm_idle(tLLCP_DLCB* p_dlcb, tLLCP_DLC_EVENT event,
       p_params = (tLLCP_CONNECTION_PARAMS*)p_data;
 
       if (p_params->miu > llcp_cb.lcb.peer_miu) {
-        LLCP_TRACE_WARNING0(
+        LOG(WARNING) << StringPrintf(
             "llcp_dlsm_idle (): Peer sent data link MIU bigger than peer's "
             "link MIU");
         p_params->miu = llcp_cb.lcb.peer_miu;
@@ -170,7 +166,7 @@ static tLLCP_STATUS llcp_dlsm_idle(tLLCP_DLCB* p_dlcb, tLLCP_DLC_EVENT event,
       p_dlcb->remote_miu = p_params->miu;
       p_dlcb->remote_rw = p_params->rw;
 
-      LLCP_TRACE_DEBUG2("llcp_dlsm_idle (): Remote MIU:%d, RW:%d",
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("llcp_dlsm_idle (): Remote MIU:%d, RW:%d",
                         p_dlcb->remote_miu, p_dlcb->remote_rw);
 
       /* wait for response from upper layer */
@@ -186,7 +182,7 @@ static tLLCP_STATUS llcp_dlsm_idle(tLLCP_DLCB* p_dlcb, tLLCP_DLC_EVENT event,
       break;
 
     default:
-      LLCP_TRACE_ERROR0("llcp_dlsm_idle (): Unexpected event");
+      LOG(ERROR) << StringPrintf("llcp_dlsm_idle (): Unexpected event");
       status = LLCP_STATUS_FAIL;
       break;
   }
@@ -221,7 +217,7 @@ static tLLCP_STATUS llcp_dlsm_w4_remote_resp(tLLCP_DLCB* p_dlcb,
 
       /* data link MIU must be up to link MIU */
       if (p_params->miu > llcp_cb.lcb.peer_miu) {
-        LLCP_TRACE_WARNING0(
+        LOG(WARNING) << StringPrintf(
             "llcp_dlsm_w4_remote_resp (): Peer sent data link MIU bigger than "
             "peer's link MIU");
         p_params->miu = llcp_cb.lcb.peer_miu;
@@ -230,7 +226,7 @@ static tLLCP_STATUS llcp_dlsm_w4_remote_resp(tLLCP_DLCB* p_dlcb,
       p_dlcb->remote_miu = p_params->miu;
       p_dlcb->remote_rw = p_params->rw;
 
-      LLCP_TRACE_DEBUG2("llcp_dlsm_w4_remote_resp (): Remote MIU:%d, RW:%d",
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("llcp_dlsm_w4_remote_resp (): Remote MIU:%d, RW:%d",
                         p_dlcb->remote_miu, p_dlcb->remote_rw);
 
       p_dlcb->state = LLCP_DLC_STATE_CONNECTED;
@@ -280,7 +276,7 @@ static tLLCP_STATUS llcp_dlsm_w4_remote_resp(tLLCP_DLCB* p_dlcb,
       break;
 
     default:
-      LLCP_TRACE_ERROR0("llcp_dlsm_w4_remote_resp (): Unexpected event");
+      LOG(ERROR) << StringPrintf("llcp_dlsm_w4_remote_resp (): Unexpected event");
       status = LLCP_STATUS_FAIL;
       break;
   }
@@ -368,7 +364,7 @@ static tLLCP_STATUS llcp_dlsm_w4_local_resp(tLLCP_DLCB* p_dlcb,
       break;
 
     default:
-      LLCP_TRACE_ERROR0("llcp_dlsm_w4_local_resp (): Unexpected event");
+      LOG(ERROR) << StringPrintf("llcp_dlsm_w4_local_resp (): Unexpected event");
       status = LLCP_STATUS_FAIL;
       break;
   }
@@ -453,7 +449,7 @@ static tLLCP_STATUS llcp_dlsm_connected(tLLCP_DLCB* p_dlcb,
             (p_dlcb->i_xmit_q.count >=
              p_dlcb->remote_rw)) /*if enough data to send next round */
         {
-          LLCP_TRACE_DEBUG3(
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
               "llcp_dlsm_connected (): Data link (SSAP:DSAP=0x%X:0x%X) "
               "congested: xmit_q.count=%d",
               p_dlcb->local_sap, p_dlcb->remote_sap, p_dlcb->i_xmit_q.count);
@@ -464,7 +460,7 @@ static tLLCP_STATUS llcp_dlsm_connected(tLLCP_DLCB* p_dlcb,
           status = LLCP_STATUS_CONGESTED;
         }
       } else {
-        LLCP_TRACE_ERROR0(
+        LOG(ERROR) << StringPrintf(
             "llcp_dlsm_connected (): Remote RW is zero: discard data");
         /* buffer will be freed when returned to API function */
         status = LLCP_STATUS_FAIL;
@@ -497,7 +493,7 @@ static tLLCP_STATUS llcp_dlsm_connected(tLLCP_DLCB* p_dlcb,
       break;
 
     default:
-      LLCP_TRACE_ERROR0("llcp_dlsm_connected (): Unexpected event");
+      LOG(ERROR) << StringPrintf("llcp_dlsm_connected (): Unexpected event");
       status = LLCP_STATUS_FAIL;
       break;
   }
@@ -516,11 +512,9 @@ static tLLCP_STATUS llcp_dlsm_connected(tLLCP_DLCB* p_dlcb,
 **
 *******************************************************************************/
 static tLLCP_STATUS llcp_dlsm_w4_remote_dm(tLLCP_DLCB* p_dlcb,
-                                           tLLCP_DLC_EVENT event,
-                                           void* p_data) {
+                                           tLLCP_DLC_EVENT event) {
   tLLCP_STATUS status = LLCP_STATUS_SUCCESS;
   tLLCP_SAP_CBACK_DATA data;
-  (void)p_data;
 
   switch (event) {
     case LLCP_DLC_EVENT_PEER_DISCONNECT_RESP:
@@ -560,7 +554,7 @@ static tLLCP_STATUS llcp_dlsm_w4_remote_dm(tLLCP_DLCB* p_dlcb,
       break;
 
     default:
-      LLCP_TRACE_ERROR0("llcp_dlsm_w4_remote_dm (): Unexpected event");
+      LOG(ERROR) << StringPrintf("llcp_dlsm_w4_remote_dm (): Unexpected event");
       status = LLCP_STATUS_FAIL;
       break;
   }
@@ -608,7 +602,7 @@ tLLCP_DLCB* llcp_dlc_find_dlcb_by_sap(uint8_t local_sap, uint8_t remote_sap) {
 *******************************************************************************/
 void llcp_dlc_flush_q(tLLCP_DLCB* p_dlcb) {
   if (p_dlcb) {
-    LLCP_TRACE_DEBUG1("llcp_dlc_flush_q (): local SAP:0x%02X",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("llcp_dlc_flush_q (): local SAP:0x%02X",
                       p_dlcb->local_sap);
 
     /* Release any held buffers */
@@ -620,7 +614,7 @@ void llcp_dlc_flush_q(tLLCP_DLCB* p_dlcb) {
     /* discard any received I PDU on data link  including in AGF */
     LLCP_FlushDataLinkRxData(p_dlcb->local_sap, p_dlcb->remote_sap);
   } else {
-    LLCP_TRACE_ERROR0("llcp_dlc_flush_q (): p_dlcb is NULL");
+    LOG(ERROR) << StringPrintf("llcp_dlc_flush_q (): p_dlcb is NULL");
   }
 }
 
@@ -641,13 +635,13 @@ static void llcp_dlc_proc_connect_pdu(uint8_t dsap, uint8_t ssap,
 
   tLLCP_CONNECTION_PARAMS params;
 
-  LLCP_TRACE_DEBUG0("llcp_dlc_proc_connect_pdu ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("llcp_dlc_proc_connect_pdu ()");
 
   p_app_cb = llcp_util_get_app_cb(dsap);
 
   if ((p_app_cb == NULL) || (p_app_cb->p_app_cback == NULL) ||
       ((p_app_cb->link_type & LLCP_LINK_TYPE_DATA_LINK_CONNECTION) == 0)) {
-    LLCP_TRACE_ERROR1("llcp_dlc_proc_connect_pdu (): Unregistered SAP:0x%x",
+    LOG(ERROR) << StringPrintf("llcp_dlc_proc_connect_pdu (): Unregistered SAP:0x%x",
                       dsap);
     llcp_util_send_dm(ssap, dsap, LLCP_SAP_DM_REASON_NO_SERVICE);
     return;
@@ -655,17 +649,23 @@ static void llcp_dlc_proc_connect_pdu(uint8_t dsap, uint8_t ssap,
 
   /* parse CONNECT PDU and get connection parameters */
   if (llcp_util_parse_connect(p_data, length, &params) != LLCP_STATUS_SUCCESS) {
-    LLCP_TRACE_ERROR0("llcp_dlc_proc_connect_pdu (): Bad format CONNECT");
+    LOG(ERROR) << StringPrintf("llcp_dlc_proc_connect_pdu (): Bad format CONNECT");
     /* fix to pass TC_CTO_TAR_BI_02_x (x=5) test case
      * As per the LLCP test specification v1.2.00 by receiving erroneous SNL PDU
      * i'e with improper length and service name "urn:nfc:sn:dta-co-echo-in",
-     * the IUT should not
-     * send any PDU except SYMM PDU*/
+     * the IUT should not send any PDU except SYMM PDU */
+#if (NXP_EXTNS != TRUE)
+    if (appl_dta_mode_flag == 1 &&
+        p_data[1] == strlen((const char*)&p_data[2])) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Strings are not equal", __func__);
+      llcp_util_send_dm(ssap, dsap, LLCP_SAP_DM_REASON_NO_SERVICE);
+#else
     if (appl_dta_mode_flag == 1) {
-      if (p_data[1] == strlen((const char*)&p_data[2])) {
-        LLCP_TRACE_DEBUG0("llcp_dlc_proc_connect_pdu () Strings are not equal");
+      if(p_data[1] == strlen((const char*)&p_data[2])) {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Strings are not equal", __func__);
         llcp_util_send_dm(ssap, dsap, LLCP_SAP_DM_REASON_NO_SERVICE);
       }
+#endif
     } else {
       llcp_util_send_dm(ssap, dsap, LLCP_SAP_DM_REASON_NO_SERVICE);
     }
@@ -690,14 +690,14 @@ static void llcp_dlc_proc_connect_pdu(uint8_t dsap, uint8_t ssap,
     }
 
     if (dsap == LLCP_SAP_SDP) {
-      LLCP_TRACE_ERROR0(
+      LOG(ERROR) << StringPrintf(
           "llcp_dlc_proc_connect_pdu (): SDP doesn't accept connection");
 
       llcp_util_send_dm(ssap, LLCP_SAP_SDP,
                         LLCP_SAP_DM_REASON_PERM_REJECT_THIS);
       return;
     } else if (dsap == 0) {
-      LLCP_TRACE_ERROR1("llcp_dlc_proc_connect_pdu (): Unregistered Service:%s",
+      LOG(ERROR) << StringPrintf("llcp_dlc_proc_connect_pdu (): Unregistered Service:%s",
                         params.sn);
 
       llcp_util_send_dm(ssap, LLCP_SAP_SDP, LLCP_SAP_DM_REASON_NO_SERVICE);
@@ -708,7 +708,7 @@ static void llcp_dlc_proc_connect_pdu(uint8_t dsap, uint8_t ssap,
 
       if ((p_app_cb == NULL) || (p_app_cb->p_app_cback == NULL) ||
           ((p_app_cb->link_type & LLCP_LINK_TYPE_DATA_LINK_CONNECTION) == 0)) {
-        LLCP_TRACE_ERROR1(
+        LOG(ERROR) << StringPrintf(
             "llcp_dlc_proc_connect_pdu (): SAP(0x%x) doesn't support "
             "connection-oriented",
             dsap);
@@ -721,7 +721,7 @@ static void llcp_dlc_proc_connect_pdu(uint8_t dsap, uint8_t ssap,
   /* check if any data link */
   p_dlcb = llcp_dlc_find_dlcb_by_sap(dsap, ssap);
   if (p_dlcb) {
-    LLCP_TRACE_ERROR0(
+    LOG(ERROR) << StringPrintf(
         "llcp_dlc_proc_connect_pdu (): Data link is aleady established");
     llcp_util_send_dm(ssap, dsap, LLCP_SAP_DM_REASON_TEMP_REJECT_THIS);
   } else {
@@ -733,12 +733,12 @@ static void llcp_dlc_proc_connect_pdu(uint8_t dsap, uint8_t ssap,
       status =
           llcp_dlsm_execute(p_dlcb, LLCP_DLC_EVENT_PEER_CONNECT_IND, &params);
       if (status != LLCP_STATUS_SUCCESS) {
-        LLCP_TRACE_ERROR0(
+        LOG(ERROR) << StringPrintf(
             "llcp_dlc_proc_connect_pdu (): Error in state machine");
         llcp_util_deallocate_data_link(p_dlcb);
       }
     } else {
-      LLCP_TRACE_ERROR0("llcp_dlc_proc_connect_pdu (): Out of resource");
+      LOG(ERROR) << StringPrintf("llcp_dlc_proc_connect_pdu (): Out of resource");
       llcp_util_send_dm(ssap, dsap, LLCP_SAP_DM_REASON_TEMP_REJECT_ANY);
     }
   }
@@ -753,17 +753,16 @@ static void llcp_dlc_proc_connect_pdu(uint8_t dsap, uint8_t ssap,
 ** Returns          void
 **
 *******************************************************************************/
-static void llcp_dlc_proc_disc_pdu(uint8_t dsap, uint8_t ssap, uint16_t length,
-                                   uint8_t* p_data) {
+static void llcp_dlc_proc_disc_pdu(uint8_t dsap, uint8_t ssap,
+                                              uint16_t length) {
   tLLCP_DLCB* p_dlcb;
-  (void)p_data;
 
-  LLCP_TRACE_DEBUG0("llcp_dlc_proc_disc_pdu ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("llcp_dlc_proc_disc_pdu ()");
 
   p_dlcb = llcp_dlc_find_dlcb_by_sap(dsap, ssap);
   if (p_dlcb) {
     if (length > 0) {
-      LLCP_TRACE_ERROR1(
+      LOG(ERROR) << StringPrintf(
           "llcp_dlc_proc_disc_pdu (): Received extra data (%d bytes) in DISC "
           "PDU",
           length);
@@ -776,7 +775,7 @@ static void llcp_dlc_proc_disc_pdu(uint8_t dsap, uint8_t ssap, uint16_t length,
       llcp_dlsm_execute(p_dlcb, LLCP_DLC_EVENT_PEER_DISCONNECT_IND, NULL);
     }
   } else {
-    LLCP_TRACE_ERROR2(
+    LOG(ERROR) << StringPrintf(
         "llcp_dlc_proc_disc_pdu (): No data link for SAP (0x%x,0x%x)", dsap,
         ssap);
   }
@@ -797,7 +796,7 @@ static void llcp_dlc_proc_cc_pdu(uint8_t dsap, uint8_t ssap, uint16_t length,
   tLLCP_CONNECTION_PARAMS params;
   tLLCP_STATUS status;
 
-  LLCP_TRACE_DEBUG0("llcp_dlc_proc_cc_pdu ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("llcp_dlc_proc_cc_pdu ()");
 
   /* find a DLCB waiting for CC on this local SAP */
   p_dlcb = llcp_dlc_find_dlcb_by_sap(dsap, LLCP_INVALID_SAP);
@@ -811,7 +810,7 @@ static void llcp_dlc_proc_cc_pdu(uint8_t dsap, uint8_t ssap, uint16_t length,
       status =
           llcp_dlsm_execute(p_dlcb, LLCP_DLC_EVENT_PEER_CONNECT_CFM, &params);
       if (status != LLCP_STATUS_SUCCESS) {
-        LLCP_TRACE_ERROR0("llcp_dlc_proc_cc_pdu (): Error in state machine");
+        LOG(ERROR) << StringPrintf("llcp_dlc_proc_cc_pdu (): Error in state machine");
         llcp_util_deallocate_data_link(p_dlcb);
       }
     } else {
@@ -821,7 +820,7 @@ static void llcp_dlc_proc_cc_pdu(uint8_t dsap, uint8_t ssap, uint16_t length,
       llcp_dlsm_execute(p_dlcb, LLCP_DLC_EVENT_FRAME_ERROR, NULL);
     }
   } else {
-    LLCP_TRACE_ERROR2(
+    LOG(ERROR) << StringPrintf(
         "llcp_dlc_proc_cc_pdu (): No data link for SAP (0x%x,0x%x)", dsap,
         ssap);
   }
@@ -840,10 +839,10 @@ static void llcp_dlc_proc_dm_pdu(uint8_t dsap, uint8_t ssap, uint16_t length,
                                  uint8_t* p_data) {
   tLLCP_DLCB* p_dlcb;
 
-  LLCP_TRACE_DEBUG0("llcp_dlc_proc_dm_pdu ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("llcp_dlc_proc_dm_pdu ()");
 
   if (length != LLCP_PDU_DM_SIZE - LLCP_PDU_HEADER_SIZE) {
-    LLCP_TRACE_ERROR0("llcp_dlc_proc_dm_pdu (): Received invalid DM PDU");
+    LOG(ERROR) << StringPrintf("llcp_dlc_proc_dm_pdu (): Received invalid DM PDU");
   } else {
     if (*p_data == LLCP_SAP_DM_REASON_RESP_DISC) {
       /* local device initiated disconnecting */
@@ -858,7 +857,7 @@ static void llcp_dlc_proc_dm_pdu(uint8_t dsap, uint8_t ssap, uint16_t length,
       llcp_dlsm_execute(p_dlcb, LLCP_DLC_EVENT_PEER_DISCONNECT_RESP,
                         p_data); /* passing reason */
     } else {
-      LLCP_TRACE_ERROR2(
+      LOG(ERROR) << StringPrintf(
           "llcp_dlc_proc_dm_pdu (): No data link for SAP (0x%x,0x%x)", dsap,
           ssap);
     }
@@ -882,7 +881,7 @@ void llcp_dlc_proc_i_pdu(uint8_t dsap, uint8_t ssap, uint16_t i_pdu_length,
   bool appended;
   NFC_HDR* p_last_buf;
 
-  LLCP_TRACE_DEBUG0("llcp_dlc_proc_i_pdu ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("llcp_dlc_proc_i_pdu ()");
 
   p_dlcb = llcp_dlc_find_dlcb_by_sap(dsap, ssap);
 
@@ -890,7 +889,7 @@ void llcp_dlc_proc_i_pdu(uint8_t dsap, uint8_t ssap, uint16_t i_pdu_length,
     error_flags = 0;
 
     if ((p_msg == NULL) && (p_i_pdu == NULL)) {
-      LLCP_TRACE_ERROR0(
+      LOG(ERROR) << StringPrintf(
           "llcp_dlc_proc_i_pdu (): Both p_msg and p_i_pdu are NULL");
       /* Frame reject cannot be sent in this case, as we don't have sequence
        * number */
@@ -905,7 +904,7 @@ void llcp_dlc_proc_i_pdu(uint8_t dsap, uint8_t ssap, uint16_t i_pdu_length,
     info_len = i_pdu_length - LLCP_PDU_HEADER_SIZE - LLCP_SEQUENCE_SIZE;
 
     if (info_len > p_dlcb->local_miu) {
-      LLCP_TRACE_ERROR2(
+      LOG(ERROR) << StringPrintf(
           "llcp_dlc_proc_i_pdu (): exceeding local MIU (%d bytes): got %d "
           "bytes SDU",
           p_dlcb->local_miu, info_len);
@@ -919,16 +918,14 @@ void llcp_dlc_proc_i_pdu(uint8_t dsap, uint8_t ssap, uint16_t i_pdu_length,
     send_seq = LLCP_GET_NS(*p);
     rcv_seq = LLCP_GET_NR(*p);
 
-#if (BT_TRACE_VERBOSE == true)
-    LLCP_TRACE_DEBUG6(
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "LLCP RX I PDU - N(S,R):(%d,%d) V(S,SA,R,RA):(%d,%d,%d,%d)", send_seq,
         rcv_seq, p_dlcb->next_tx_seq, p_dlcb->rcvd_ack_seq, p_dlcb->next_rx_seq,
         p_dlcb->sent_ack_seq);
-#endif
 
     /* if send sequence number, N(S) is not expected one, V(R) */
     if (p_dlcb->next_rx_seq != send_seq) {
-      LLCP_TRACE_ERROR2("llcp_dlc_proc_i_pdu (): Bad N(S) got:%d, expected:%d",
+      LOG(ERROR) << StringPrintf("llcp_dlc_proc_i_pdu (): Bad N(S) got:%d, expected:%d",
                         send_seq, p_dlcb->next_rx_seq);
 
       error_flags |= LLCP_FRMR_S_ERROR_FLAG;
@@ -936,7 +933,7 @@ void llcp_dlc_proc_i_pdu(uint8_t dsap, uint8_t ssap, uint16_t i_pdu_length,
       /* if peer device sends more than our receiving window size */
       if ((uint8_t)(send_seq - p_dlcb->sent_ack_seq) % LLCP_SEQ_MODULO >=
           p_dlcb->local_rw) {
-        LLCP_TRACE_ERROR3(
+        LOG(ERROR) << StringPrintf(
             "llcp_dlc_proc_i_pdu (): Bad N(S):%d >= V(RA):%d + RW(L):%d",
             send_seq, p_dlcb->sent_ack_seq, p_dlcb->local_rw);
 
@@ -950,7 +947,7 @@ void llcp_dlc_proc_i_pdu(uint8_t dsap, uint8_t ssap, uint16_t i_pdu_length,
         (uint8_t)(p_dlcb->next_tx_seq - p_dlcb->rcvd_ack_seq) %
             LLCP_SEQ_MODULO) {
       error_flags |= LLCP_FRMR_R_ERROR_FLAG;
-      LLCP_TRACE_ERROR3(
+      LOG(ERROR) << StringPrintf(
           "llcp_dlc_proc_i_pdu (): Bad N(R):%d valid range [V(SA):%d, V(S):%d]",
           rcv_seq, p_dlcb->rcvd_ack_seq, p_dlcb->next_tx_seq);
     }
@@ -1028,7 +1025,7 @@ void llcp_dlc_proc_i_pdu(uint8_t dsap, uint8_t ssap, uint16_t i_pdu_length,
             p_msg->len = LLCP_PDU_AGF_LEN_SIZE + info_len;
             p_msg->layer_specific = 0;
           } else {
-            LLCP_TRACE_ERROR0("llcp_dlc_proc_i_pdu (): out of buffer");
+            LOG(ERROR) << StringPrintf("llcp_dlc_proc_i_pdu (): out of buffer");
           }
         }
 
@@ -1052,7 +1049,7 @@ void llcp_dlc_proc_i_pdu(uint8_t dsap, uint8_t ssap, uint16_t i_pdu_length,
 
       if ((!p_dlcb->is_rx_congested) &&
           (p_dlcb->num_rx_i_pdu >= p_dlcb->rx_congest_threshold)) {
-        LLCP_TRACE_DEBUG2(
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
             "llcp_dlc_proc_i_pdu (): congested num_rx_i_pdu=%d, "
             "rx_congest_threshold=%d",
             p_dlcb->num_rx_i_pdu, p_dlcb->rx_congest_threshold);
@@ -1063,7 +1060,7 @@ void llcp_dlc_proc_i_pdu(uint8_t dsap, uint8_t ssap, uint16_t i_pdu_length,
       }
     }
   } else {
-    LLCP_TRACE_ERROR2(
+    LOG(ERROR) << StringPrintf(
         "llcp_dlc_proc_i_pdu (): No data link for SAP (0x%x,0x%x)", dsap, ssap);
     llcp_util_send_dm(ssap, dsap, LLCP_SAP_DM_REASON_NO_ACTIVE_CONNECTION);
   }
@@ -1090,7 +1087,7 @@ static void llcp_dlc_proc_rr_rnr_pdu(uint8_t dsap, uint8_t ptype, uint8_t ssap,
   tLLCP_SAP_CBACK_DATA cback_data;
   bool old_remote_busy;
 
-  LLCP_TRACE_DEBUG0("llcp_dlc_proc_rr_rnr_pdu ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("llcp_dlc_proc_rr_rnr_pdu ()");
 
   p_dlcb = llcp_dlc_find_dlcb_by_sap(dsap, ssap);
   if (p_dlcb != NULL) {
@@ -1108,7 +1105,7 @@ static void llcp_dlc_proc_rr_rnr_pdu(uint8_t dsap, uint8_t ptype, uint8_t ssap,
         (uint8_t)(p_dlcb->next_tx_seq - p_dlcb->rcvd_ack_seq) %
             LLCP_SEQ_MODULO) {
       error_flags |= LLCP_FRMR_R_ERROR_FLAG;
-      LLCP_TRACE_ERROR3(
+      LOG(ERROR) << StringPrintf(
           "llcp_dlc_proc_rr_rnr_pdu (): Bad N(R):%d valid range [V(SA):%d, "
           "V(S):%d]",
           rcv_seq, p_dlcb->rcvd_ack_seq, p_dlcb->next_tx_seq);
@@ -1120,17 +1117,15 @@ static void llcp_dlc_proc_rr_rnr_pdu(uint8_t dsap, uint8_t ptype, uint8_t ssap,
     } else {
       p_dlcb->rcvd_ack_seq = rcv_seq;
 
-#if (BT_TRACE_VERBOSE == true)
-      LLCP_TRACE_DEBUG5("LLCP RX - N(S,R):(NA,%d) V(S,SA,R,RA):(%d,%d,%d,%d)",
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("LLCP RX - N(S,R):(NA,%d) V(S,SA,R,RA):(%d,%d,%d,%d)",
                         rcv_seq, p_dlcb->next_tx_seq, p_dlcb->rcvd_ack_seq,
                         p_dlcb->next_rx_seq, p_dlcb->sent_ack_seq);
-#endif
       old_remote_busy = p_dlcb->remote_busy;
       if (ptype == LLCP_PDU_RNR_TYPE) {
         p_dlcb->remote_busy = true;
         /* if upper layer hasn't get congestion started notification */
         if ((!old_remote_busy) && (!p_dlcb->is_tx_congested)) {
-          LLCP_TRACE_WARNING3(
+          LOG(WARNING) << StringPrintf(
               "llcp_dlc_proc_rr_rnr_pdu (): Data link (SSAP:DSAP=0x%X:0x%X) "
               "congestion start: i_xmit_q.count=%d",
               p_dlcb->local_sap, p_dlcb->remote_sap, p_dlcb->i_xmit_q.count);
@@ -1148,7 +1143,7 @@ static void llcp_dlc_proc_rr_rnr_pdu(uint8_t dsap, uint8_t ptype, uint8_t ssap,
         /* if upper layer hasn't get congestion ended notification and data link
          * is not congested */
         if ((old_remote_busy) && (!p_dlcb->is_tx_congested)) {
-          LLCP_TRACE_WARNING3(
+          LOG(WARNING) << StringPrintf(
               "llcp_dlc_proc_rr_rnr_pdu (): Data link (SSAP:DSAP=0x%X:0x%X) "
               "congestion end: i_xmit_q.count=%d",
               p_dlcb->local_sap, p_dlcb->remote_sap, p_dlcb->i_xmit_q.count);
@@ -1175,7 +1170,7 @@ static void llcp_dlc_proc_rr_rnr_pdu(uint8_t dsap, uint8_t ptype, uint8_t ssap,
       }
     }
   } else {
-    LLCP_TRACE_ERROR2(
+    LOG(ERROR) << StringPrintf(
         "llcp_dlc_proc_rr_rnr_pdu (): No data link for SAP (0x%x,0x%x)", dsap,
         ssap);
   }
@@ -1194,11 +1189,11 @@ void llcp_dlc_proc_rx_pdu(uint8_t dsap, uint8_t ptype, uint8_t ssap,
                           uint16_t length, uint8_t* p_data) {
   tLLCP_DLCB* p_dlcb;
 
-  LLCP_TRACE_DEBUG3("llcp_dlc_proc_rx_pdu (): DSAP:0x%x, PTYPE:0x%x, SSAP:0x%x",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("llcp_dlc_proc_rx_pdu (): DSAP:0x%x, PTYPE:0x%x, SSAP:0x%x",
                     dsap, ptype, ssap);
 
   if (dsap == LLCP_SAP_LM) {
-    LLCP_TRACE_ERROR2(
+    LOG(ERROR) << StringPrintf(
         "llcp_dlc_proc_rx_pdu (): Invalid SAP:0x%x for PTYPE:0x%x", dsap,
         ptype);
     return;
@@ -1210,7 +1205,7 @@ void llcp_dlc_proc_rx_pdu(uint8_t dsap, uint8_t ptype, uint8_t ssap,
       break;
 
     case LLCP_PDU_DISC_TYPE:
-      llcp_dlc_proc_disc_pdu(dsap, ssap, length, p_data);
+      llcp_dlc_proc_disc_pdu(dsap, ssap, length);
       break;
 
     case LLCP_PDU_CC_TYPE:
@@ -1234,7 +1229,7 @@ void llcp_dlc_proc_rx_pdu(uint8_t dsap, uint8_t ptype, uint8_t ssap,
       break;
 
     default:
-      LLCP_TRACE_ERROR1("llcp_dlc_proc_rx_pdu (): Unexpected PDU type (0x%x)",
+      LOG(ERROR) << StringPrintf("llcp_dlc_proc_rx_pdu (): Unexpected PDU type (0x%x)",
                         ptype);
 
       p_dlcb = llcp_dlc_find_dlcb_by_sap(dsap, ssap);
@@ -1259,7 +1254,7 @@ void llcp_dlc_check_to_send_rr_rnr(void) {
   uint8_t idx;
   bool flush = true;
 
-  LLCP_TRACE_DEBUG0("llcp_dlc_check_to_send_rr_rnr ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("llcp_dlc_check_to_send_rr_rnr ()");
 
   /*
   ** DLC doesn't send RR PDU for each received I PDU because multiple I PDUs
@@ -1303,7 +1298,7 @@ bool llcp_dlc_is_rw_open(tLLCP_DLCB* p_dlcb) {
       p_dlcb->remote_rw) {
     return true;
   } else {
-    LLCP_TRACE_DEBUG3(
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "llcp_dlc_is_rw_open ():Flow Off, V(S):%d, V(SA):%d, RW(R):%d",
         p_dlcb->next_tx_seq, p_dlcb->rcvd_ack_seq, p_dlcb->remote_rw);
     return false;
@@ -1324,34 +1319,27 @@ NFC_HDR* llcp_dlc_get_next_pdu(tLLCP_DLCB* p_dlcb) {
   bool flush = true;
   tLLCP_SAP_CBACK_DATA data;
 
-#if (BT_TRACE_VERBOSE == true)
   uint8_t send_seq = p_dlcb->next_tx_seq;
-#endif
 
-    /* if there is data to send and remote device can receive it */
-    if (  (p_dlcb->i_xmit_q.count)
-        &&(!p_dlcb->remote_busy)
-        &&(llcp_dlc_is_rw_open (p_dlcb))  )
-    {
-        p_msg = (NFC_HDR *) GKI_dequeue (&p_dlcb->i_xmit_q);
-        llcp_cb.total_tx_i_pdu--;
-        if(p_msg)
-        {
-            if (p_msg->offset >= LLCP_MIN_OFFSET)
-            {
-                /* add LLCP header, DSAP, PTYPE, SSAP, N(S), N(R) and update sent_ack_seq, V(RA) */
-                llcp_util_build_info_pdu (p_dlcb, p_msg);
+  /* if there is data to send and remote device can receive it */
+  if ((p_dlcb->i_xmit_q.count) && (!p_dlcb->remote_busy) &&
+      (llcp_dlc_is_rw_open(p_dlcb))) {
+    p_msg = (NFC_HDR*)GKI_dequeue(&p_dlcb->i_xmit_q);
+    llcp_cb.total_tx_i_pdu--;
+    if (p_msg) {
+      if (p_msg->offset >= LLCP_MIN_OFFSET) {
+        /* add LLCP header, DSAP, PTYPE, SSAP, N(S), N(R) and update
+         * sent_ack_seq, V(RA) */
+        llcp_util_build_info_pdu(p_dlcb, p_msg);
 
         p_dlcb->next_tx_seq = (p_dlcb->next_tx_seq + 1) % LLCP_SEQ_MODULO;
 
-#if (BT_TRACE_VERBOSE == true)
-        LLCP_TRACE_DEBUG6("LLCP TX - N(S,R):(%d,%d) V(S,SA,R,RA):(%d,%d,%d,%d)",
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("LLCP TX - N(S,R):(%d,%d) V(S,SA,R,RA):(%d,%d,%d,%d)",
                           send_seq, p_dlcb->next_rx_seq, p_dlcb->next_tx_seq,
                           p_dlcb->rcvd_ack_seq, p_dlcb->next_rx_seq,
                           p_dlcb->sent_ack_seq);
-#endif
       } else {
-        LLCP_TRACE_ERROR2(
+        LOG(ERROR) << StringPrintf(
             "LLCP - llcp_dlc_get_next_pdu (): offset (%d) must be %d at least",
             p_msg->offset, LLCP_MIN_OFFSET);
         GKI_freebuf(p_msg);
@@ -1407,7 +1395,6 @@ uint16_t llcp_dlc_get_next_pdu_length(tLLCP_DLCB* p_dlcb) {
   return 0;
 }
 
-#if (BT_TRACE_VERBOSE == true)
 /*******************************************************************************
 **
 ** Function         llcp_dlsm_get_state_name
@@ -1417,7 +1404,7 @@ uint16_t llcp_dlc_get_next_pdu_length(tLLCP_DLCB* p_dlcb) {
 ** Returns          pointer to the name
 **
 *******************************************************************************/
-static char* llcp_dlsm_get_state_name(tLLCP_DLC_STATE state) {
+static std::string llcp_dlsm_get_state_name(tLLCP_DLC_STATE state) {
   switch (state) {
     case LLCP_DLC_STATE_IDLE:
       return ("IDLE");
@@ -1443,7 +1430,7 @@ static char* llcp_dlsm_get_state_name(tLLCP_DLC_STATE state) {
 ** Returns          pointer to the name
 **
 *******************************************************************************/
-static char* llcp_dlsm_get_event_name(tLLCP_DLC_EVENT event) {
+static std::string llcp_dlsm_get_event_name(tLLCP_DLC_EVENT event) {
   switch (event) {
     case LLCP_DLC_EVENT_API_CONNECT_REQ:
       return ("API_CONNECT_REQ");
@@ -1480,4 +1467,3 @@ static char* llcp_dlsm_get_event_name(tLLCP_DLC_EVENT event) {
       return ("???? UNKNOWN EVENT");
   }
 }
-#endif /* (BT_TRACE_VERBOSE == true) */
diff --git a/src/nfc/llcp/llcp_link.c b/src/nfc/llcp/llcp_link.cc
similarity index 91%
rename from src/nfc/llcp/llcp_link.c
rename to src/nfc/llcp/llcp_link.cc
index e19e630..9578168 100644
--- a/src/nfc/llcp/llcp_link.c
+++ b/src/nfc/llcp/llcp_link.cc
@@ -3,7 +3,7 @@
  *  Copyright (c) 2016, The Linux Foundation. All rights reserved.
  *  Not a Contribution.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *  The original Work has been changed by NXP Semiconductors.
  *
  *  Copyright (C) 2010-2014 Broadcom Corporation
@@ -29,16 +29,20 @@
  ******************************************************************************/
 
 #include <string.h>
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "gki.h"
-#include "nfc_target.h"
 #include "bt_types.h"
-#include "trace_api.h"
 #include "llcp_int.h"
 #include "llcp_defs.h"
 #include "nfc_int.h"
 #include "nfa_sys.h"
 #include "nfa_dm_int.h"
 
+using android::base::StringPrintf;
+
 const uint16_t llcp_link_rwt
     [15] = /* RWT = (302us)*2**WT; 302us = 256*16/fc; fc = 13.56MHz */
     {
@@ -84,14 +88,11 @@ static void llcp_link_send_to_lower(NFC_HDR* p_msg);
 extern tLLCP_TEST_PARAMS llcp_test_params;
 #endif
 
-#if (NXP_EXTNS == TRUE)
+extern bool nfc_debug_enabled;
 extern unsigned char appl_dta_mode_flag;
-#endif
 
 /* debug functions type */
-#if (BT_TRACE_VERBOSE == true)
-static char* llcp_pdu_type(uint8_t ptype);
-#endif
+static std::string llcp_pdu_type(uint8_t ptype);
 
 /*******************************************************************************
 **
@@ -105,7 +106,7 @@ static char* llcp_pdu_type(uint8_t ptype);
 static void llcp_link_start_inactivity_timer(void) {
   if ((llcp_cb.lcb.inact_timer.in_use == false) &&
       (llcp_cb.lcb.inact_timeout > 0)) {
-    LLCP_TRACE_DEBUG1("Start inactivity_timer: %d ms",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Start inactivity_timer: %d ms",
                       llcp_cb.lcb.inact_timeout);
 
     nfc_start_quick_timer(&llcp_cb.lcb.inact_timer, NFC_TTYPE_LLCP_LINK_INACT,
@@ -125,7 +126,7 @@ static void llcp_link_start_inactivity_timer(void) {
 *******************************************************************************/
 static void llcp_link_stop_inactivity_timer(void) {
   if (llcp_cb.lcb.inact_timer.in_use) {
-    LLCP_TRACE_DEBUG0("Stop inactivity_timer");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Stop inactivity_timer");
 
     nfc_stop_quick_timer(&llcp_cb.lcb.inact_timer);
   }
@@ -178,14 +179,14 @@ static void llcp_link_stop_link_timer(void) {
 **
 *******************************************************************************/
 tLLCP_STATUS llcp_link_activate(tLLCP_ACTIVATE_CONFIG* p_config) {
-  LLCP_TRACE_DEBUG0("llcp_link_activate ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("llcp_link_activate ()");
 
   /* At this point, MAC link activation procedure has been successfully
    * completed */
 
   /* The Length Reduction values LRi and LRt MUST be 11b. (254bytes) */
   if (p_config->max_payload_size != LLCP_NCI_MAX_PAYL_SIZE) {
-    LLCP_TRACE_WARNING2(
+    LOG(WARNING) << StringPrintf(
         "llcp_link_activate (): max payload size (%d) must be %d bytes",
         p_config->max_payload_size, LLCP_NCI_MAX_PAYL_SIZE);
   }
@@ -194,32 +195,28 @@ tLLCP_STATUS llcp_link_activate(tLLCP_ACTIVATE_CONFIG* p_config) {
    * activation */
   if (llcp_link_parse_gen_bytes(p_config->gen_bytes_len,
                                 p_config->p_gen_bytes) == false) {
-    LLCP_TRACE_ERROR0("llcp_link_activate (): Failed to parse general bytes");
-#if (NXP_EXTNS == TRUE)
-    /*For LLCP DTA test, In case of bad magic bytes normal p2p communication is
-     * expected
-     * In case of wrong magic bytes in ATR_REQ LLC layer will be disconnected
-     * but P2P connection
-     * is expected to be in connected state. So, non LLC PDU is expected.
-     * Below changes is to send PDU after disconnect of LLCP PDU.
-     * fix for TC_MAC_TAR_BI_01 LLCP test case*/
-    if ((appl_dta_mode_flag == 1) && (p_config->is_initiator == false)) {
-      NFC_HDR* p_msg;
-      uint8_t* p;
-      p_msg = (NFC_HDR*)GKI_getpoolbuf(LLCP_POOL_ID);
+    LOG(ERROR) << StringPrintf("llcp_link_activate (): Failed to parse general bytes");
+    /* For LLCP DTA test, In case of bad magic bytes normal p2p communication is
+     * expected,but in case of wrong magic bytes in ATR_REQ, LLC layer will be
+     * disconnected but P2P connection is expected to be in connected state
+     * and non LLC PDU is expected.
+     * As per NFC forum expectation below changes is to send PDU after
+     * disconnect of LLCP PDU.
+     * This is fix for TC_MAC_TAR_BI_01 LLCP test case */
+
+    if (appl_dta_mode_flag == 1 && p_config->is_initiator == FALSE) {
+      NFC_HDR* p_msg = (NFC_HDR*)GKI_getpoolbuf(LLCP_POOL_ID);
 
       if (p_msg) {
         /*LLCP test scenario requires non LLC PDU to be sent in case of wrong
-          magic bytes.
-          So sending NFC-DEP pdu with size 1 (0x00)*/
+          magic bytes. So sending NFC-DEP pdu with size 1 (0x00)*/
         p_msg->len = 1;
         p_msg->offset = NCI_MSG_OFFSET_SIZE + NCI_DATA_HDR_SIZE;
 
-        p = (uint8_t*)(p_msg + 1) + p_msg->offset;
         NFC_SendData(NFC_RF_CONN_ID, p_msg);
       }
     }
-#endif
+
     (*llcp_cb.lcb.p_link_cback)(LLCP_LINK_ACTIVATION_FAILED_EVT,
                                 LLCP_LINK_BAD_GEN_BYTES);
 
@@ -237,26 +234,22 @@ tLLCP_STATUS llcp_link_activate(tLLCP_ACTIVATE_CONFIG* p_config) {
   */
   if ((p_config->is_initiator) &&
       (llcp_link_rwt[p_config->waiting_time] > llcp_cb.lcb.peer_lto)) {
-    LLCP_TRACE_WARNING3(
+    LOG(WARNING) << StringPrintf(
         "llcp_link_activate (): WT (%d, %dms) must be less than or equal to "
         "LTO (%dms)",
         p_config->waiting_time, llcp_link_rwt[p_config->waiting_time],
         llcp_cb.lcb.peer_lto);
   }
-#if (NXP_EXTNS == TRUE)
-  /*For DTA mode Peer LTO Should not include TX RX Delay, Just llcp deactivate
+  /* For DTA mode Peer LTO Should not include TX RX Delay, Just llcp deactivate
    * after Peer LTO time */
   if (!appl_dta_mode_flag) {
-#endif
     /* extend LTO as much as internally required processing time and propagation
      * delays */
     llcp_cb.lcb.peer_lto += LLCP_INTERNAL_TX_DELAY + LLCP_INTERNAL_RX_DELAY;
-#if (NXP_EXTNS == TRUE)
   }
-#endif
   /* LLCP version number agreement */
   if (llcp_link_version_agreement() == false) {
-    LLCP_TRACE_ERROR0("llcp_link_activate (): Failed to agree version");
+    LOG(ERROR) << StringPrintf("llcp_link_activate (): Failed to agree version");
     (*llcp_cb.lcb.p_link_cback)(LLCP_LINK_ACTIVATION_FAILED_EVT,
                                 LLCP_LINK_VERSION_FAILED);
 
@@ -267,6 +260,7 @@ tLLCP_STATUS llcp_link_activate(tLLCP_ACTIVATE_CONFIG* p_config) {
     }
     return LLCP_STATUS_FAIL;
   }
+
   llcp_cb.lcb.received_first_packet = false;
   llcp_cb.lcb.is_initiator = p_config->is_initiator;
 
@@ -285,7 +279,7 @@ tLLCP_STATUS llcp_link_activate(tLLCP_ACTIVATE_CONFIG* p_config) {
   ** symmetry procedure.
   */
   if (llcp_cb.lcb.is_initiator) {
-    LLCP_TRACE_DEBUG0("llcp_link_activate (): Connected as Initiator");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("llcp_link_activate (): Connected as Initiator");
 
     llcp_cb.lcb.inact_timeout = llcp_cb.lcb.inact_timeout_init;
     llcp_cb.lcb.symm_state = LLCP_LINK_SYMM_LOCAL_XMIT_NEXT;
@@ -300,7 +294,7 @@ tLLCP_STATUS llcp_link_activate(tLLCP_ACTIVATE_CONFIG* p_config) {
       llcp_link_send_SYMM();
     }
   } else {
-    LLCP_TRACE_DEBUG0("llcp_link_activate (): Connected as Target");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("llcp_link_activate (): Connected as Target");
     llcp_cb.lcb.inact_timeout = llcp_cb.lcb.inact_timeout_target;
     llcp_cb.lcb.symm_state = LLCP_LINK_SYMM_REMOTE_XMIT_NEXT;
 
@@ -368,7 +362,7 @@ void llcp_link_process_link_timeout(void) {
     if ((llcp_cb.lcb.symm_delay > 0) &&
         (llcp_cb.lcb.symm_state == LLCP_LINK_SYMM_LOCAL_XMIT_NEXT)) {
       /* upper layer doesn't have anything to send */
-      LLCP_TRACE_DEBUG0(
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "llcp_link_process_link_timeout (): LEVT_TIMEOUT in state of "
           "LLCP_LINK_SYMM_LOCAL_XMIT_NEXT");
       llcp_link_send_SYMM();
@@ -381,7 +375,7 @@ void llcp_link_process_link_timeout(void) {
         llcp_link_start_inactivity_timer();
       }
     } else {
-      LLCP_TRACE_ERROR0(
+      LOG(ERROR) << StringPrintf(
           "llcp_link_process_link_timeout (): LEVT_TIMEOUT in state of "
           "LLCP_LINK_SYMM_REMOTE_XMIT_NEXT");
       llcp_link_deactivate(LLCP_LINK_TIMEOUT);
@@ -407,7 +401,7 @@ void llcp_link_deactivate(uint8_t reason) {
   tLLCP_DLCB* p_dlcb;
   tLLCP_APP_CB* p_app_cb;
 
-  LLCP_TRACE_DEBUG1("llcp_link_deactivate () reason = 0x%x", reason);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("llcp_link_deactivate () reason = 0x%x", reason);
 
   /* Release any held buffers in signaling PDU queue */
   while (llcp_cb.lcb.sig_xmit_q.p_first)
@@ -444,21 +438,19 @@ void llcp_link_deactivate(uint8_t reason) {
 
   llcp_cb.overall_tx_congested = false;
   llcp_cb.overall_rx_congested = false;
+
   /* As per the LLCP test specification v1.2.00 for test case TC_LLC_TAR_BV_04
    * the receiving LLC shall commence sending an LLC PDU to the remote
-   * LLC. So, after IUT receiving DISC PDU from LT(remote device), IUT shall
-   * send DISC PDU to LT.
-     * appl_dta_mode_flag condition is added to fulfill above requirement.
-     * Only in CR8, the IUT shall acknoweledge with SYMM for DISC PDU.
-     * For other CRx, send DISC PDU.
-     */
-
+   * LLC. So, after IUT receives DISC PDU from LT(remote device), IUT shall
+   * send DISC PDU to LT. appl_dta_mode_flag condition is added to fulfil
+   * above requirement. Only in CR8, the IUT shall acknoweledge with SYMM for
+   * DISC PDU. For other CRx, send DISC PDU.
+   */
   if ((reason == LLCP_LINK_FRAME_ERROR) ||
       (reason == LLCP_LINK_LOCAL_INITIATED) ||
-      ((appl_dta_mode_flag) && (reason == LLCP_LINK_REMOTE_INITIATED) &&
-       (llcp_cb.lcb.is_initiator == false) &&
-       ((nfa_dm_cb.eDtaMode & 0xF0) != NFA_DTA_CR8)))
-  {
+      (appl_dta_mode_flag && reason == LLCP_LINK_REMOTE_INITIATED &&
+       llcp_cb.lcb.is_initiator == false &&
+       (nfa_dm_cb.eDtaMode & 0xF0) != NFA_DTA_CR8)) {
     /* get rid of the data pending in NFC tx queue, so DISC PDU can be sent ASAP
      */
     NFC_FlushData(NFC_RF_CONN_ID);
@@ -466,7 +458,7 @@ void llcp_link_deactivate(uint8_t reason) {
     llcp_util_send_disc(LLCP_SAP_LM, LLCP_SAP_LM);
 
     /* Wait until DISC is sent to peer */
-    LLCP_TRACE_DEBUG0(
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "llcp_link_deactivate (): Wait until DISC is sent to peer");
 
     llcp_cb.lcb.link_state = LLCP_LINK_STATE_DEACTIVATING;
@@ -494,6 +486,7 @@ void llcp_link_deactivate(uint8_t reason) {
 
     NFC_FlushData(NFC_RF_CONN_ID);
   }
+
   llcp_deactivate_cleanup(reason);
 }
 
@@ -544,7 +537,7 @@ static bool llcp_link_version_agreement(void) {
   peer_minor_version = LLCP_GET_MINOR_VERSION(llcp_cb.lcb.peer_version);
 
   if (peer_major_version < LLCP_MIN_MAJOR_VERSION) {
-    LLCP_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "llcp_link_version_agreement(): unsupported peer version number. Peer "
         "Major Version:%d",
         peer_major_version);
@@ -567,7 +560,7 @@ static bool llcp_link_version_agreement(void) {
       llcp_cb.lcb.agreed_minor_version = LLCP_VERSION_MINOR;
     }
 
-    LLCP_TRACE_DEBUG6(
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "local version:%d.%d, remote version:%d.%d, agreed version:%d.%d",
         LLCP_VERSION_MAJOR, LLCP_VERSION_MINOR, peer_major_version,
         peer_minor_version, llcp_cb.lcb.agreed_major_version,
@@ -631,7 +624,7 @@ static void llcp_link_check_congestion(void) {
     /* overall buffer usage is high */
     llcp_cb.overall_tx_congested = true;
 
-    LLCP_TRACE_WARNING2(
+    LOG(WARNING) << StringPrintf(
         "overall tx congestion start: total_tx_ui_pdu=%d, total_tx_i_pdu=%d",
         llcp_cb.total_tx_ui_pdu, llcp_cb.total_tx_i_pdu);
 
@@ -651,7 +644,7 @@ static void llcp_link_check_congestion(void) {
         if (!p_app_cb->is_ui_tx_congested) {
           p_app_cb->is_ui_tx_congested = true;
 
-          LLCP_TRACE_WARNING2(
+          LOG(WARNING) << StringPrintf(
               "Logical link (SAP=0x%X) congestion start: count=%d", sap,
               p_app_cb->ui_xmit_q.count);
 
@@ -670,7 +663,7 @@ static void llcp_link_check_congestion(void) {
           (llcp_cb.dlcb[idx].is_tx_congested == false)) {
         llcp_cb.dlcb[idx].is_tx_congested = true;
 
-        LLCP_TRACE_WARNING3(
+        LOG(WARNING) << StringPrintf(
             "Data link (SSAP:DSAP=0x%X:0x%X) congestion start: count=%d",
             llcp_cb.dlcb[idx].local_sap, llcp_cb.dlcb[idx].remote_sap,
             llcp_cb.dlcb[idx].i_xmit_q.count);
@@ -706,7 +699,7 @@ static void llcp_link_check_uncongested(void) {
       /* overall congestion is cleared */
       llcp_cb.overall_tx_congested = false;
 
-      LLCP_TRACE_WARNING2(
+      LOG(WARNING) << StringPrintf(
           "overall tx congestion end: total_tx_ui_pdu=%d, total_tx_i_pdu=%d",
           llcp_cb.total_tx_ui_pdu, llcp_cb.total_tx_i_pdu);
     } else {
@@ -742,7 +735,7 @@ static void llcp_link_check_uncongested(void) {
           /* if it was congested but now tx queue count is below threshold */
           p_app_cb->is_ui_tx_congested = false;
 
-          LLCP_TRACE_DEBUG2("Logical link (SAP=0x%X) congestion end: count=%d",
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Logical link (SAP=0x%X) congestion end: count=%d",
                             sap, p_app_cb->ui_xmit_q.count);
 
           data.congest.local_sap = sap;
@@ -787,7 +780,7 @@ static void llcp_link_check_uncongested(void) {
       llcp_cb.dlcb[idx].is_tx_congested = false;
 
       if (llcp_cb.dlcb[idx].remote_busy == false) {
-        LLCP_TRACE_DEBUG3(
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
             "Data link (SSAP:DSAP=0x%X:0x%X) congestion end: count=%d",
             llcp_cb.dlcb[idx].local_sap, llcp_cb.dlcb[idx].remote_sap,
             llcp_cb.dlcb[idx].i_xmit_q.count);
@@ -890,7 +883,7 @@ void llcp_link_check_send_data(void) {
   if (llcp_cb.lcb.symm_state == LLCP_LINK_SYMM_LOCAL_XMIT_NEXT ||
       (appl_dta_mode_flag &&
        llcp_cb.lcb.link_state == LLCP_LINK_STATE_DEACTIVATING)) {
-    LLCP_TRACE_DEBUG0(
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "llcp_link_check_send_data () in state of "
         "LLCP_LINK_SYMM_LOCAL_XMIT_NEXT");
 
@@ -988,7 +981,7 @@ static void llcp_link_proc_ui_pdu(uint8_t local_sap, uint8_t remote_sap,
   /* if application is registered and expecting UI PDU on logical data link */
   if ((p_app_cb) && (p_app_cb->p_app_cback) &&
       (p_app_cb->link_type & LLCP_LINK_TYPE_LOGICAL_DATA_LINK)) {
-    LLCP_TRACE_DEBUG2(
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "llcp_link_proc_ui_pdu () Local SAP:0x%x, Remote SAP:0x%x", local_sap,
         remote_sap);
 
@@ -1016,8 +1009,8 @@ static void llcp_link_proc_ui_pdu(uint8_t local_sap, uint8_t remote_sap,
         /* add length of UI PDU */
         UINT16_TO_BE_STREAM(p_dst, ui_pdu_length);
 
-                /* copy UI PDU with LLCP header */
-                memcpy (p_dst, p_ui_pdu, ui_pdu_length);
+        /* copy UI PDU with LLCP header */
+        memcpy(p_dst, p_ui_pdu, ui_pdu_length);
 
         p_last_buf->len += LLCP_PDU_AGF_LEN_SIZE + ui_pdu_length;
 
@@ -1027,15 +1020,13 @@ static void llcp_link_proc_ui_pdu(uint8_t local_sap, uint8_t remote_sap,
       }
     }
 
-        /* if it is not available to append */
-        if (!appended)
-        {
-            /* if it's not from AGF PDU */
-            if (p_msg)
-            {
-                /* add length of PDU in front of UI PDU (reuse room for NCI header) */
-                p_ui_pdu -= LLCP_PDU_AGF_LEN_SIZE;
-                UINT16_TO_BE_STREAM (p_ui_pdu, ui_pdu_length);
+    /* if it is not available to append */
+    if (!appended) {
+      /* if it's not from AGF PDU */
+      if (p_msg) {
+        /* add length of PDU in front of UI PDU (reuse room for NCI header) */
+        p_ui_pdu -= LLCP_PDU_AGF_LEN_SIZE;
+        UINT16_TO_BE_STREAM(p_ui_pdu, ui_pdu_length);
 
         p_msg->offset -= LLCP_PDU_AGF_LEN_SIZE;
         p_msg->len += LLCP_PDU_AGF_LEN_SIZE;
@@ -1055,7 +1046,7 @@ static void llcp_link_proc_ui_pdu(uint8_t local_sap, uint8_t remote_sap,
           p_msg->len = LLCP_PDU_AGF_LEN_SIZE + ui_pdu_length;
           p_msg->layer_specific = 0;
         } else {
-          LLCP_TRACE_ERROR0("llcp_link_proc_ui_pdu (): out of buffer");
+          LOG(ERROR) << StringPrintf("llcp_link_proc_ui_pdu (): out of buffer");
         }
       }
 
@@ -1067,7 +1058,7 @@ static void llcp_link_proc_ui_pdu(uint8_t local_sap, uint8_t remote_sap,
     }
 
     if (p_app_cb->ui_rx_q.count > llcp_cb.ll_rx_congest_start) {
-      LLCP_TRACE_WARNING2(
+      LOG(WARNING) << StringPrintf(
           "llcp_link_proc_ui_pdu (): SAP:0x%x, rx link is congested (%d), "
           "discard oldest UI PDU",
           local_sap, p_app_cb->ui_rx_q.count);
@@ -1084,7 +1075,7 @@ static void llcp_link_proc_ui_pdu(uint8_t local_sap, uint8_t remote_sap,
       (*p_app_cb->p_app_cback)(&data);
     }
   } else {
-    LLCP_TRACE_ERROR1("llcp_link_proc_ui_pdu (): Unregistered SAP:0x%x",
+    LOG(ERROR) << StringPrintf("llcp_link_proc_ui_pdu (): Unregistered SAP:0x%x",
                       local_sap);
 
     if (p_msg) {
@@ -1134,7 +1125,7 @@ static void llcp_link_proc_agf_pdu(NFC_HDR* p_agf) {
   }
 
   if (agf_length != 0) {
-    LLCP_TRACE_ERROR0("llcp_link_proc_agf_pdu (): Received invalid AGF PDU");
+    LOG(ERROR) << StringPrintf("llcp_link_proc_agf_pdu (): Received invalid AGF PDU");
     GKI_freebuf(p_agf);
     return;
   }
@@ -1159,12 +1150,10 @@ static void llcp_link_proc_agf_pdu(NFC_HDR* p_agf) {
     ptype = (uint8_t)(LLCP_GET_PTYPE(pdu_hdr));
     ssap = LLCP_GET_SSAP(pdu_hdr);
 
-#if (BT_TRACE_VERBOSE == true)
-    LLCP_TRACE_DEBUG4(
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "llcp_link_proc_agf_pdu (): Rx DSAP:0x%x, PTYPE:%s (0x%x), SSAP:0x%x "
         "in AGF",
-        dsap, llcp_pdu_type(ptype), ptype, ssap);
-#endif
+        dsap, llcp_pdu_type(ptype).c_str(), ptype, ssap);
 
     if ((ptype == LLCP_PDU_DISC_TYPE) && (dsap == LLCP_SAP_LM) &&
         (ssap == LLCP_SAP_LM)) {
@@ -1172,10 +1161,10 @@ static void llcp_link_proc_agf_pdu(NFC_HDR* p_agf) {
       llcp_link_deactivate(LLCP_LINK_REMOTE_INITIATED);
       return;
     } else if (ptype == LLCP_PDU_SYMM_TYPE) {
-      LLCP_TRACE_ERROR0(
+      LOG(ERROR) << StringPrintf(
           "llcp_link_proc_agf_pdu (): SYMM PDU exchange shall not be in AGF");
     } else if (ptype == LLCP_PDU_PAX_TYPE) {
-      LLCP_TRACE_ERROR0(
+      LOG(ERROR) << StringPrintf(
           "llcp_link_proc_agf_pdu (): PAX PDU exchange shall not be used");
     } else if (ptype == LLCP_PDU_SNL_TYPE) {
       llcp_sdp_proc_snl((uint16_t)(pdu_length - LLCP_PDU_HEADER_SIZE), p_info);
@@ -1214,7 +1203,7 @@ static void llcp_link_proc_rx_pdu(uint8_t dsap, uint8_t ptype, uint8_t ssap,
 
   switch (ptype) {
     case LLCP_PDU_PAX_TYPE:
-      LLCP_TRACE_ERROR0(
+      LOG(ERROR) << StringPrintf(
           "llcp_link_proc_rx_pdu (); PAX PDU exchange shall not be used");
       break;
 
@@ -1294,7 +1283,7 @@ static void llcp_link_proc_rx_data(NFC_HDR* p_msg) {
         llcp_link_process_link_timeout();
     } else {
       if (p_msg->len < LLCP_PDU_HEADER_SIZE) {
-        LLCP_TRACE_ERROR1("Received too small PDU: got %d bytes", p_msg->len);
+        LOG(ERROR) << StringPrintf("Received too small PDU: got %d bytes", p_msg->len);
         frame_error = true;
       } else {
         p = (uint8_t*)(p_msg + 1) + p_msg->offset;
@@ -1311,7 +1300,7 @@ static void llcp_link_proc_rx_data(NFC_HDR* p_msg) {
             info_length =
                 p_msg->len - LLCP_PDU_HEADER_SIZE - LLCP_SEQUENCE_SIZE;
           } else {
-            LLCP_TRACE_ERROR0("Received I/RR/RNR PDU without sequence");
+            LOG(ERROR) << StringPrintf("Received I/RR/RNR PDU without sequence");
             frame_error = true;
           }
         } else {
@@ -1320,21 +1309,19 @@ static void llcp_link_proc_rx_data(NFC_HDR* p_msg) {
 
         /* check if length of information is bigger than link MIU */
         if ((!frame_error) && (info_length > llcp_cb.lcb.local_link_miu)) {
-          LLCP_TRACE_ERROR2("Received exceeding MIU (%d): got %d bytes SDU",
+          LOG(ERROR) << StringPrintf("Received exceeding MIU (%d): got %d bytes SDU",
                             llcp_cb.lcb.local_link_miu, info_length);
 
           frame_error = true;
         } else {
-#if (BT_TRACE_VERBOSE == true)
-          LLCP_TRACE_DEBUG4(
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
               "llcp_link_proc_rx_data (): DSAP:0x%x, PTYPE:%s (0x%x), "
               "SSAP:0x%x",
-              dsap, llcp_pdu_type(ptype), ptype, ssap);
-#endif
+              dsap, llcp_pdu_type(ptype).c_str(), ptype, ssap);
 
           if (ptype == LLCP_PDU_SYMM_TYPE) {
             if (info_length > 0) {
-              LLCP_TRACE_ERROR1("Received extra data (%d bytes) in SYMM PDU",
+              LOG(ERROR) << StringPrintf("Received extra data (%d bytes) in SYMM PDU",
                                 info_length);
               frame_error = true;
             }
@@ -1353,7 +1340,7 @@ static void llcp_link_proc_rx_data(NFC_HDR* p_msg) {
       llcp_link_check_send_data();
     }
   } else {
-    LLCP_TRACE_ERROR0("Received PDU in state of SYMM_MUST_XMIT_NEXT");
+    LOG(ERROR) << StringPrintf("Received PDU in state of SYMM_MUST_XMIT_NEXT");
   }
 
   if (free_buffer) GKI_freebuf(p_msg);
@@ -1489,7 +1476,7 @@ static NFC_HDR* llcp_link_build_next_pdu(NFC_HDR* p_pdu) {
   uint8_t* p, ptype;
   uint16_t next_pdu_length, pdu_hdr;
 
-  LLCP_TRACE_DEBUG0("llcp_link_build_next_pdu ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("llcp_link_build_next_pdu ()");
 
   /* add any pending SNL PDU into sig_xmit_q for transmitting */
   llcp_sdp_check_send_snl();
@@ -1540,7 +1527,7 @@ static NFC_HDR* llcp_link_build_next_pdu(NFC_HDR* p_pdu) {
           GKI_freebuf(p_msg);
           p_msg = p_agf;
         } else {
-          LLCP_TRACE_ERROR0("llcp_link_build_next_pdu (): Out of buffer");
+          LOG(ERROR) << StringPrintf("llcp_link_build_next_pdu (): Out of buffer");
           return p_msg;
         }
       } else {
@@ -1568,7 +1555,7 @@ static NFC_HDR* llcp_link_build_next_pdu(NFC_HDR* p_pdu) {
          */
         llcp_link_get_next_pdu(true, &next_pdu_length);
       } else {
-        LLCP_TRACE_ERROR0(
+        LOG(ERROR) << StringPrintf(
             "llcp_link_build_next_pdu (): Unable to get next pdu from queue");
         break;
       }
@@ -1593,9 +1580,6 @@ static NFC_HDR* llcp_link_build_next_pdu(NFC_HDR* p_pdu) {
 **
 *******************************************************************************/
 static void llcp_link_send_to_lower(NFC_HDR* p_pdu) {
-#if (BT_TRACE_PROTOCOL == true)
-  DispLLCP(p_pdu, false);
-#endif
   llcp_cb.lcb.symm_state = LLCP_LINK_SYMM_REMOTE_XMIT_NEXT;
   NFC_SendData(NFC_RF_CONN_ID, p_pdu);
 }
@@ -1609,14 +1593,10 @@ static void llcp_link_send_to_lower(NFC_HDR* p_pdu) {
 ** Returns          void
 **
 *******************************************************************************/
-void llcp_link_connection_cback(uint8_t conn_id, tNFC_CONN_EVT event,
-                                tNFC_CONN* p_data) {
-  (void)conn_id;
+void llcp_link_connection_cback(__attribute__((unused)) uint8_t conn_id,
+                                tNFC_CONN_EVT event, tNFC_CONN* p_data) {
 
   if (event == NFC_DATA_CEVT) {
-#if (BT_TRACE_PROTOCOL == true)
-    DispLLCP((NFC_HDR*)p_data->data.p_data, true);
-#endif
     if (llcp_cb.lcb.link_state == LLCP_LINK_STATE_DEACTIVATED) {
       /* respoding SYMM while LLCP is deactivated but RF link is not deactivated
        * yet */
@@ -1666,7 +1646,6 @@ void llcp_link_connection_cback(uint8_t conn_id, tNFC_CONN_EVT event,
   */
 }
 
-#if (BT_TRACE_VERBOSE == true)
 /*******************************************************************************
 **
 ** Function         llcp_pdu_type
@@ -1676,7 +1655,7 @@ void llcp_link_connection_cback(uint8_t conn_id, tNFC_CONN_EVT event,
 ** Returns          string of PDU type
 **
 *******************************************************************************/
-static char* llcp_pdu_type(uint8_t ptype) {
+static std::string llcp_pdu_type(uint8_t ptype) {
   switch (ptype) {
     case LLCP_PDU_SYMM_TYPE:
       return "SYMM";
@@ -1709,5 +1688,3 @@ static char* llcp_pdu_type(uint8_t ptype) {
       return "RESERVED";
   }
 }
-
-#endif
diff --git a/src/nfc/llcp/llcp_main.c b/src/nfc/llcp/llcp_main.cc
similarity index 85%
rename from src/nfc/llcp/llcp_main.c
rename to src/nfc/llcp/llcp_main.cc
index 73dedf6..9aba4a6 100644
--- a/src/nfc/llcp/llcp_main.c
+++ b/src/nfc/llcp/llcp_main.cc
@@ -23,14 +23,20 @@
  ******************************************************************************/
 
 #include <string.h>
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "gki.h"
-#include "nfc_target.h"
 #include "bt_types.h"
 #include "llcp_api.h"
 #include "llcp_int.h"
-#include "llcp_defs.h"
 #include "nfc_int.h"
 
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+
 tLLCP_CB llcp_cb;
 
 /*******************************************************************************
@@ -48,9 +54,7 @@ void llcp_init(void) {
 
   memset(&llcp_cb, 0, sizeof(tLLCP_CB));
 
-  llcp_cb.trace_level = LLCP_INITIAL_TRACE_LEVEL;
-
-  LLCP_TRACE_DEBUG0("LLCP - llcp_init ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("LLCP - llcp_init ()");
 
   llcp_cb.lcb.local_link_miu =
       (LLCP_MIU <= LLCP_MAX_MIU ? LLCP_MIU : LLCP_MAX_MIU);
@@ -82,7 +86,7 @@ void llcp_init(void) {
   llcp_cb.max_num_ll_rx_buff =
       (uint8_t)((llcp_cb.num_rx_buff * LLCP_LL_RX_BUFF_LIMIT) / 100);
 
-  LLCP_TRACE_DEBUG4(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "num_rx_buff = %d, rx_congest_start = %d, rx_congest_end = %d, "
       "max_num_ll_rx_buff = %d",
       llcp_cb.num_rx_buff, llcp_cb.overall_rx_congest_start,
@@ -95,7 +99,7 @@ void llcp_init(void) {
   llcp_cb.max_num_ll_tx_buff =
       (uint8_t)((llcp_cb.max_num_tx_buff * LLCP_LL_TX_BUFF_LIMIT) / 100);
 
-  LLCP_TRACE_DEBUG2("max_num_tx_buff = %d, max_num_ll_tx_buff = %d",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("max_num_tx_buff = %d, max_num_ll_tx_buff = %d",
                     llcp_cb.max_num_tx_buff, llcp_cb.max_num_ll_tx_buff);
 
   llcp_cb.ll_tx_uncongest_ntf_start_sap = LLCP_SAP_SDP + 1;
@@ -117,7 +121,7 @@ void llcp_cleanup(void) {
   uint8_t sap;
   tLLCP_APP_CB* p_app_cb;
 
-  LLCP_TRACE_DEBUG0("LLCP - llcp_cleanup ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("LLCP - llcp_cleanup ()");
 
   for (sap = LLCP_SAP_SDP; sap < LLCP_NUM_SAPS; sap++) {
     p_app_cb = llcp_util_get_app_cb(sap);
@@ -143,7 +147,7 @@ void llcp_cleanup(void) {
 void llcp_process_timeout(TIMER_LIST_ENT* p_tle) {
   uint8_t reason;
 
-  LLCP_TRACE_DEBUG1("llcp_process_timeout: event=%d", p_tle->event);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("llcp_process_timeout: event=%d", p_tle->event);
 
   switch (p_tle->event) {
     case NFC_TTYPE_LLCP_LINK_MANAGER:
@@ -169,20 +173,4 @@ void llcp_process_timeout(TIMER_LIST_ENT* p_tle) {
     default:
       break;
   }
-}
-
-/*******************************************************************************
-**
-** Function         LLCP_SetTraceLevel
-**
-** Description      This function sets the trace level for LLCP.  If called with
-**                  a value of 0xFF, it simply returns the current trace level.
-**
-** Returns          The new or current trace level
-**
-*******************************************************************************/
-uint8_t LLCP_SetTraceLevel(uint8_t new_level) {
-  if (new_level != 0xFF) llcp_cb.trace_level = new_level;
-
-  return (llcp_cb.trace_level);
-}
+}
\ No newline at end of file
diff --git a/src/nfc/llcp/llcp_sdp.c b/src/nfc/llcp/llcp_sdp.cc
similarity index 85%
rename from src/nfc/llcp/llcp_sdp.c
rename to src/nfc/llcp/llcp_sdp.cc
index 2ad9407..dabc333 100644
--- a/src/nfc/llcp/llcp_sdp.c
+++ b/src/nfc/llcp/llcp_sdp.cc
@@ -20,7 +20,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -43,18 +43,23 @@
  ******************************************************************************/
 
 #include <string.h>
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "gki.h"
-#include "nfc_target.h"
 #include "bt_types.h"
 #include "llcp_api.h"
 #include "llcp_int.h"
-#include "llcp_defs.h"
-
+#include "nfa_dm_int.h"
 #if (NXP_EXTNS == TRUE)
 #include "nfa_sys.h"
-#include "nfa_dm_int.h"
 #endif
 
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+
 /*******************************************************************************
 **
 ** Function         llcp_sdp_proc_data
@@ -65,9 +70,7 @@
 ** Returns          void
 **
 *******************************************************************************/
-void llcp_sdp_proc_data(tLLCP_SAP_CBACK_DATA* p_data) {
-  (void)p_data;
-
+void llcp_sdp_proc_data(__attribute__((unused)) tLLCP_SAP_CBACK_DATA* p_data) {
   /*
   ** Do nothing
   ** llcp_sdp_proc_SNL () is called by link layer
@@ -89,7 +92,7 @@ void llcp_sdp_check_send_snl(void) {
   uint8_t* p;
 
   if (llcp_cb.sdp_cb.p_snl) {
-    LLCP_TRACE_DEBUG0("SDP: llcp_sdp_check_send_snl ()");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("SDP: llcp_sdp_check_send_snl ()");
 
     llcp_cb.sdp_cb.p_snl->len += LLCP_PDU_HEADER_SIZE;
     llcp_cb.sdp_cb.p_snl->offset -= LLCP_PDU_HEADER_SIZE;
@@ -100,17 +103,14 @@ void llcp_sdp_check_send_snl(void) {
 
     GKI_enqueue(&llcp_cb.lcb.sig_xmit_q, llcp_cb.sdp_cb.p_snl);
     llcp_cb.sdp_cb.p_snl = NULL;
-  }
-#if (NXP_EXTNS == TRUE)
-  else {
+  } else {
     /* Notify DTA after sending out SNL with SDRES not to send SNLs in AGF PDU
      */
-    if ((llcp_cb.p_dta_cback) && (llcp_cb.dta_snl_resp)) {
+    if (llcp_cb.p_dta_cback && llcp_cb.dta_snl_resp) {
       llcp_cb.dta_snl_resp = false;
       (*llcp_cb.p_dta_cback)();
     }
   }
-#endif
 }
 
 /*******************************************************************************
@@ -153,7 +153,7 @@ tLLCP_STATUS llcp_sdp_send_sdreq(uint8_t tid, char* p_name) {
   uint16_t name_len;
   uint16_t available_bytes;
 
-  LLCP_TRACE_DEBUG2("llcp_sdp_send_sdreq (): tid=0x%x, ServiceName=%s", tid,
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("llcp_sdp_send_sdreq (): tid=0x%x, ServiceName=%s", tid,
                     p_name);
 
   /* if there is no pending SNL */
@@ -246,7 +246,7 @@ static tLLCP_STATUS llcp_sdp_send_sdres(uint8_t tid, uint8_t sap) {
   tLLCP_STATUS status;
   uint16_t available_bytes;
 
-  LLCP_TRACE_DEBUG2("llcp_sdp_send_sdres (): tid=0x%x, SAP=0x%x", tid, sap);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("llcp_sdp_send_sdres (): tid=0x%x, SAP=0x%x", tid, sap);
 
   /* if there is no pending SNL */
   if (!llcp_cb.sdp_cb.p_snl) {
@@ -314,19 +314,17 @@ uint8_t llcp_sdp_get_sap_by_name(char* p_name, uint8_t length) {
 
   for (sap = LLCP_SAP_SDP; sap <= LLCP_UPPER_BOUND_SDP_SAP; sap++) {
     p_app_cb = llcp_util_get_app_cb(sap);
-
-    if ((p_app_cb) && (p_app_cb->p_app_cback) &&
-        (strlen((char*)p_app_cb->p_service_name) == length) &&
-        (!strncmp((char*)p_app_cb->p_service_name, p_name, length))) {
-#if (NXP_EXTNS == TRUE)
-      /* if device is under LLCP DTA testing */
-      if ((llcp_cb.p_dta_cback) &&
-          (!strncmp((char*)p_app_cb->p_service_name, "urn:nfc:sn:cl-echo-in",
-                    length))) {
-        llcp_cb.dta_snl_resp = true;
+    if((p_app_cb != nullptr) && (p_app_cb->p_service_name!=nullptr)) {
+      if ((p_app_cb) && (p_app_cb->p_app_cback) &&
+          (strlen((char*)p_app_cb->p_service_name) == length) &&
+          (!strncmp((char*)p_app_cb->p_service_name, p_name, length))) {
+        /* if device is under LLCP DTA testing */
+        if (llcp_cb.p_dta_cback && (!strncmp((char*)p_app_cb->p_service_name,
+                                             "urn:nfc:sn:cl-echo-in", length))) {
+          llcp_cb.dta_snl_resp = true;
+        }
+        return (sap);
       }
-#endif
-      return (sap);
     }
   }
   return 0;
@@ -345,7 +343,7 @@ uint8_t llcp_sdp_get_sap_by_name(char* p_name, uint8_t length) {
 static void llcp_sdp_return_sap(uint8_t tid, uint8_t sap) {
   uint8_t i;
 
-  LLCP_TRACE_DEBUG2("llcp_sdp_return_sap (): tid=0x%x, SAP=0x%x", tid, sap);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("llcp_sdp_return_sap (): tid=0x%x, SAP=0x%x", tid, sap);
 
   for (i = 0; i < LLCP_MAX_SDP_TRANSAC; i++) {
     if ((llcp_cb.sdp_cb.transac[i].p_cback) &&
@@ -371,7 +369,7 @@ static void llcp_sdp_return_sap(uint8_t tid, uint8_t sap) {
 void llcp_sdp_proc_deactivation(void) {
   uint8_t i;
 
-  LLCP_TRACE_DEBUG0("llcp_sdp_proc_deactivation ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("llcp_sdp_proc_deactivation ()");
 
   for (i = 0; i < LLCP_MAX_SDP_TRANSAC; i++) {
     if (llcp_cb.sdp_cb.transac[i].p_cback) {
@@ -388,9 +386,7 @@ void llcp_sdp_proc_deactivation(void) {
   }
 
   llcp_cb.sdp_cb.next_tid = 0;
-#if (NXP_EXTNS == TRUE)
   llcp_cb.dta_snl_resp = false;
-#endif
 }
 
 /*******************************************************************************
@@ -406,12 +402,12 @@ void llcp_sdp_proc_deactivation(void) {
 tLLCP_STATUS llcp_sdp_proc_snl(uint16_t sdu_length, uint8_t* p) {
   uint8_t type, length, tid, sap, *p_value;
 
-  LLCP_TRACE_DEBUG0("llcp_sdp_proc_snl ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("llcp_sdp_proc_snl ()");
 
   if ((llcp_cb.lcb.agreed_major_version < LLCP_MIN_SNL_MAJOR_VERSION) ||
       ((llcp_cb.lcb.agreed_major_version == LLCP_MIN_SNL_MAJOR_VERSION) &&
        (llcp_cb.lcb.agreed_minor_version < LLCP_MIN_SNL_MINOR_VERSION))) {
-    LLCP_TRACE_DEBUG0(
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "llcp_sdp_proc_snl(): version number less than 1.1, SNL not "
         "supported.");
     return LLCP_STATUS_FAIL;
@@ -430,41 +426,30 @@ tLLCP_STATUS llcp_sdp_proc_snl(uint16_t sdu_length, uint8_t* p) {
           p_value = p;
           BE_STREAM_TO_UINT8(tid, p_value);
           sap = llcp_sdp_get_sap_by_name((char*)p_value, (uint8_t)(length - 1));
-#if (NXP_EXTNS == TRUE)
           /* fix to pass TC_CTO_TAR_BI_03_x (x=5) test case
            * As per the LLCP test specification v1.2.00 by receiving erroneous
-           * SNL PDU
-           * i'e with improper service name "urn:nfc:sn:dta-co-echo-in", the IUT
-           * should not
-           * send any PDU except SYMM PDU*/
-          if ((appl_dta_mode_flag == 1) && (sap == 0x00)) {
-            LLCP_TRACE_DEBUG1(
-                "llcp_sdp_proc_snl () In dta mode sap == 0x00 p_value = %s",
-                p_value);
+           * SNL PDU i'e with improper service name "urn:nfc:sn:dta-co-echo-in",
+           * the IUT should not send any PDU except SYMM PDU */
+          if (appl_dta_mode_flag == 1 && sap == 0x00) {
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: In dta mode sap == 0x00 p_value = %s",
+                              __func__, p_value);
             if ((length - 1) == strlen((const char*)p_value)) {
-              LLCP_TRACE_DEBUG0(
-                  "DEBUG> llcp_sdp_proc_snl () Strings are not equal");
+              DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: Strings are not equal", __func__);
               llcp_sdp_send_sdres(tid, sap);
             }
           } else {
             llcp_sdp_send_sdres(tid, sap);
           }
-#else
-          llcp_sdp_send_sdres(tid, sap);
-#endif
         } else {
-#if (NXP_EXTNS == TRUE)
           /*For P2P in LLCP mode TC_CTO_TAR_BI_03_x(x=3) fix*/
-          if ((appl_dta_mode_flag == 1) &&
+          if (appl_dta_mode_flag == 1 &&
               ((nfa_dm_cb.eDtaMode & 0x0F) == NFA_DTA_LLCP_MODE)) {
-            LLCP_TRACE_ERROR0(
-                " llcp_sdp_proc_snl () Calling llcp_sdp_send_sdres");
+            LOG(ERROR) << StringPrintf("%s: Calling llcp_sdp_send_sdres", __func__);
             tid = 0x01;
             sap = 0x00;
             llcp_sdp_send_sdres(tid, sap);
           }
-#endif
-          LLCP_TRACE_ERROR1(
+          LOG(ERROR) << StringPrintf(
               "llcp_sdp_proc_snl (): bad length (%d) in LLCP_SDREQ_TYPE",
               length);
         }
@@ -479,14 +464,14 @@ tLLCP_STATUS llcp_sdp_proc_snl(uint16_t sdu_length, uint8_t* p) {
           BE_STREAM_TO_UINT8(sap, p_value);
           llcp_sdp_return_sap(tid, sap);
         } else {
-          LLCP_TRACE_ERROR1(
+          LOG(ERROR) << StringPrintf(
               "llcp_sdp_proc_snl (): bad length (%d) in LLCP_SDRES_TYPE",
               length);
         }
         break;
 
       default:
-        LLCP_TRACE_WARNING1(
+        LOG(WARNING) << StringPrintf(
             "llcp_sdp_proc_snl (): Unknown type (0x%x) is ignored", type);
         break;
     }
@@ -501,7 +486,7 @@ tLLCP_STATUS llcp_sdp_proc_snl(uint16_t sdu_length, uint8_t* p) {
   }
 
   if (sdu_length) {
-    LLCP_TRACE_ERROR0("llcp_sdp_proc_snl (): Bad format of SNL");
+    LOG(ERROR) << StringPrintf("llcp_sdp_proc_snl (): Bad format of SNL");
     return LLCP_STATUS_FAIL;
   } else {
     return LLCP_STATUS_SUCCESS;
diff --git a/src/nfc/llcp/llcp_util.c b/src/nfc/llcp/llcp_util.cc
similarity index 87%
rename from src/nfc/llcp/llcp_util.c
rename to src/nfc/llcp/llcp_util.cc
index 3520e78..95928d9 100644
--- a/src/nfc/llcp/llcp_util.c
+++ b/src/nfc/llcp/llcp_util.cc
@@ -15,6 +15,25 @@
  *  limitations under the License.
  *
  ******************************************************************************/
+/******************************************************************************
+ *
+ *  The original Work has been changed by NXP Semiconductors.
+ *
+ *  Copyright 2018 NXP
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
 
 /******************************************************************************
  *
@@ -23,14 +42,20 @@
  ******************************************************************************/
 
 #include <string.h>
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "gki.h"
-#include "nfc_target.h"
 #include "bt_types.h"
-#include "trace_api.h"
 #include "llcp_int.h"
 #include "llcp_defs.h"
 #include "nfc_int.h"
 
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+
 /*******************************************************************************
 **
 ** Function         llcp_util_parse_link_params
@@ -51,7 +76,7 @@ bool llcp_util_parse_link_params(uint16_t length, uint8_t* p_bytes) {
       case LLCP_VERSION_TYPE:
         BE_STREAM_TO_UINT8(param_len, p);
         BE_STREAM_TO_UINT8(llcp_cb.lcb.peer_version, p);
-        LLCP_TRACE_DEBUG1("Peer Version - 0x%02X", llcp_cb.lcb.peer_version);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Peer Version - 0x%02X", llcp_cb.lcb.peer_version);
         break;
 
       case LLCP_MIUX_TYPE:
@@ -59,30 +84,30 @@ bool llcp_util_parse_link_params(uint16_t length, uint8_t* p_bytes) {
         BE_STREAM_TO_UINT16(llcp_cb.lcb.peer_miu, p);
         llcp_cb.lcb.peer_miu &= LLCP_MIUX_MASK;
         llcp_cb.lcb.peer_miu += LLCP_DEFAULT_MIU;
-        LLCP_TRACE_DEBUG1("Peer MIU - %d bytes", llcp_cb.lcb.peer_miu);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Peer MIU - %d bytes", llcp_cb.lcb.peer_miu);
         break;
 
       case LLCP_WKS_TYPE:
         BE_STREAM_TO_UINT8(param_len, p);
         BE_STREAM_TO_UINT16(llcp_cb.lcb.peer_wks, p);
-        LLCP_TRACE_DEBUG1("Peer WKS - 0x%04X", llcp_cb.lcb.peer_wks);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Peer WKS - 0x%04X", llcp_cb.lcb.peer_wks);
         break;
 
       case LLCP_LTO_TYPE:
         BE_STREAM_TO_UINT8(param_len, p);
         BE_STREAM_TO_UINT8(llcp_cb.lcb.peer_lto, p);
         llcp_cb.lcb.peer_lto *= LLCP_LTO_UNIT; /* 10ms unit */
-        LLCP_TRACE_DEBUG1("Peer LTO - %d ms", llcp_cb.lcb.peer_lto);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Peer LTO - %d ms", llcp_cb.lcb.peer_lto);
         break;
 
       case LLCP_OPT_TYPE:
         BE_STREAM_TO_UINT8(param_len, p);
         BE_STREAM_TO_UINT8(llcp_cb.lcb.peer_opt, p);
-        LLCP_TRACE_DEBUG1("Peer OPT - 0x%02X", llcp_cb.lcb.peer_opt);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Peer OPT - 0x%02X", llcp_cb.lcb.peer_opt);
         break;
 
       default:
-        LLCP_TRACE_ERROR1(
+        LOG(ERROR) << StringPrintf(
             "llcp_util_parse_link_params (): Unexpected type 0x%x", param_type);
         BE_STREAM_TO_UINT8(param_len, p);
         p += param_len;
@@ -92,7 +117,7 @@ bool llcp_util_parse_link_params(uint16_t length, uint8_t* p_bytes) {
     if (length >= param_len + 1)
       length -= param_len + 1;
     else {
-      LLCP_TRACE_ERROR0("llcp_util_parse_link_params (): Bad LTV's");
+      LOG(ERROR) << StringPrintf("llcp_util_parse_link_params (): Bad LTV's");
       return (false);
     }
   }
@@ -134,7 +159,7 @@ void llcp_util_adjust_ll_congestion(void) {
     llcp_cb.ll_tx_congest_end = 0;
   }
 
-  LLCP_TRACE_DEBUG4(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "num_logical_data_link=%d, ll_tx_congest_start=%d, ll_tx_congest_end=%d, "
       "ll_rx_congest_start=%d",
       llcp_cb.num_logical_data_link, llcp_cb.ll_tx_congest_start,
@@ -172,7 +197,7 @@ void llcp_util_adjust_dl_rx_congestion(void) {
           llcp_cb.dlcb[idx].rx_congest_threshold = LLCP_DL_MIN_RX_CONGEST;
         }
 
-        LLCP_TRACE_DEBUG3("DLC[%d], local_rw=%d, rx_congest_threshold=%d", idx,
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("DLC[%d], local_rw=%d, rx_congest_threshold=%d", idx,
                           llcp_cb.dlcb[idx].local_rw,
                           llcp_cb.dlcb[idx].rx_congest_threshold);
       }
@@ -196,7 +221,7 @@ void llcp_util_check_rx_congested_status(void) {
     /* check if rx congestion clear */
     if (llcp_cb.total_rx_ui_pdu + llcp_cb.total_rx_i_pdu <=
         llcp_cb.overall_rx_congest_end) {
-      LLCP_TRACE_DEBUG3(
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "llcp_util_check_rx_congested_status (): rx link is uncongested, "
           "%d+%d <= %d",
           llcp_cb.total_rx_ui_pdu, llcp_cb.total_rx_i_pdu,
@@ -216,7 +241,7 @@ void llcp_util_check_rx_congested_status(void) {
     /* check if rx link is congested */
     if (llcp_cb.total_rx_ui_pdu + llcp_cb.total_rx_i_pdu >=
         llcp_cb.overall_rx_congest_start) {
-      LLCP_TRACE_WARNING3(
+      LOG(WARNING) << StringPrintf(
           "llcp_util_check_rx_congested_status (): rx link is congested, %d+%d "
           ">= %d",
           llcp_cb.total_rx_ui_pdu, llcp_cb.total_rx_i_pdu,
@@ -253,6 +278,7 @@ tLLCP_STATUS llcp_util_send_ui(uint8_t ssap, uint8_t dsap,
   p_msg->len += LLCP_PDU_HEADER_SIZE;
 
   p = (uint8_t*)(p_msg + 1) + p_msg->offset;
+
   UINT16_TO_BE_STREAM(p, LLCP_GET_PDU_HEADER(dsap, LLCP_PDU_UI_TYPE, ssap));
 
   GKI_enqueue(&p_app_cb->ui_xmit_q, p_msg);
@@ -269,7 +295,7 @@ tLLCP_STATUS llcp_util_send_ui(uint8_t ssap, uint8_t dsap,
     /* or notify uncongestion later */
     p_app_cb->is_ui_tx_congested = true;
 
-    LLCP_TRACE_WARNING2("Logical link (SAP=0x%X) congested: ui_xmit_q.count=%d",
+    LOG(WARNING) << StringPrintf("Logical link (SAP=0x%X) congested: ui_xmit_q.count=%d",
                         ssap, p_app_cb->ui_xmit_q.count);
 
     status = LLCP_STATUS_CONGESTED;
@@ -318,7 +344,7 @@ tLLCP_DLCB* llcp_util_allocate_data_link(uint8_t reg_sap, uint8_t remote_sap) {
   tLLCP_DLCB* p_dlcb = NULL;
   int idx;
 
-  LLCP_TRACE_DEBUG2(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "llcp_util_allocate_data_link (): reg_sap = 0x%x, remote_sap = 0x%x",
       reg_sap, remote_sap);
 
@@ -332,7 +358,7 @@ tLLCP_DLCB* llcp_util_allocate_data_link(uint8_t reg_sap, uint8_t remote_sap) {
   }
 
   if (!p_dlcb) {
-    LLCP_TRACE_ERROR0("llcp_util_allocate_data_link (): Out of DLCB");
+    LOG(ERROR) << StringPrintf("llcp_util_allocate_data_link (): Out of DLCB");
   } else {
     p_dlcb->p_app_cb = llcp_util_get_app_cb(reg_sap);
     p_dlcb->local_sap = reg_sap;
@@ -342,7 +368,7 @@ tLLCP_DLCB* llcp_util_allocate_data_link(uint8_t reg_sap, uint8_t remote_sap) {
     /* this is for inactivity timer and congestion control. */
     llcp_cb.num_data_link_connection++;
 
-    LLCP_TRACE_DEBUG3(
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "llcp_util_allocate_data_link (): local_sap = 0x%x, remote_sap = 0x%x, "
         "num_data_link_connection = %d",
         p_dlcb->local_sap, p_dlcb->remote_sap,
@@ -362,7 +388,7 @@ tLLCP_DLCB* llcp_util_allocate_data_link(uint8_t reg_sap, uint8_t remote_sap) {
 ******************************************************************************/
 void llcp_util_deallocate_data_link(tLLCP_DLCB* p_dlcb) {
   if (p_dlcb) {
-    LLCP_TRACE_DEBUG1("llcp_util_deallocate_data_link (): local_sap = 0x%x",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("llcp_util_deallocate_data_link (): local_sap = 0x%x",
                       p_dlcb->local_sap);
 
     if (p_dlcb->state != LLCP_DLC_STATE_IDLE) {
@@ -375,7 +401,7 @@ void llcp_util_deallocate_data_link(tLLCP_DLCB* p_dlcb) {
         llcp_cb.num_data_link_connection--;
       }
 
-      LLCP_TRACE_DEBUG1(
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "llcp_util_deallocate_data_link (): num_data_link_connection = %d",
           llcp_cb.num_data_link_connection);
     }
@@ -476,7 +502,7 @@ tLLCP_STATUS llcp_util_parse_connect(uint8_t* p_bytes, uint16_t length,
         p_params->miu &= LLCP_MIUX_MASK;
         p_params->miu += LLCP_DEFAULT_MIU;
 
-        LLCP_TRACE_DEBUG1("llcp_util_parse_connect (): LLCP_MIUX_TYPE:%d",
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("llcp_util_parse_connect (): LLCP_MIUX_TYPE:%d",
                           p_params->miu);
         break;
 
@@ -485,7 +511,7 @@ tLLCP_STATUS llcp_util_parse_connect(uint8_t* p_bytes, uint16_t length,
         BE_STREAM_TO_UINT8(p_params->rw, p);
         p_params->rw &= 0x0F;
 
-        LLCP_TRACE_DEBUG1("llcp_util_parse_connect (): LLCP_RW_TYPE:%d",
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("llcp_util_parse_connect (): LLCP_RW_TYPE:%d",
                           p_params->rw);
         break;
 
@@ -504,12 +530,12 @@ tLLCP_STATUS llcp_util_parse_connect(uint8_t* p_bytes, uint16_t length,
         }
         p += param_len;
 
-        LLCP_TRACE_DEBUG1("llcp_util_parse_connect (): LLCP_SN_TYPE:<%s>",
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("llcp_util_parse_connect (): LLCP_SN_TYPE:<%s>",
                           p_params->sn);
         break;
 
       default:
-        LLCP_TRACE_ERROR1("llcp_util_parse_connect (): Unexpected type 0x%x",
+        LOG(ERROR) << StringPrintf("llcp_util_parse_connect (): Unexpected type 0x%x",
                           param_type);
         BE_STREAM_TO_UINT8(param_len, p);
         p += param_len;
@@ -520,7 +546,7 @@ tLLCP_STATUS llcp_util_parse_connect(uint8_t* p_bytes, uint16_t length,
     if (length >= param_len + 1) {
       length -= param_len + 1;
     } else {
-      LLCP_TRACE_ERROR0("llcp_util_parse_connect (): Bad LTV's");
+      LOG(ERROR) << StringPrintf("llcp_util_parse_connect (): Bad LTV's");
       return LLCP_STATUS_FAIL;
     }
   }
@@ -610,7 +636,7 @@ tLLCP_STATUS llcp_util_parse_cc(uint8_t* p_bytes, uint16_t length,
         (*p_miu) &= LLCP_MIUX_MASK;
         (*p_miu) += LLCP_DEFAULT_MIU;
 
-        LLCP_TRACE_DEBUG1("llcp_util_parse_cc (): LLCP_MIUX_TYPE:%d", *p_miu);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("llcp_util_parse_cc (): LLCP_MIUX_TYPE:%d", *p_miu);
         break;
 
       case LLCP_RW_TYPE:
@@ -618,11 +644,11 @@ tLLCP_STATUS llcp_util_parse_cc(uint8_t* p_bytes, uint16_t length,
         BE_STREAM_TO_UINT8((*p_rw), p);
         (*p_rw) &= 0x0F;
 
-        LLCP_TRACE_DEBUG1("llcp_util_parse_cc (): LLCP_RW_TYPE:%d", *p_rw);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("llcp_util_parse_cc (): LLCP_RW_TYPE:%d", *p_rw);
         break;
 
       default:
-        LLCP_TRACE_ERROR1("llcp_util_parse_cc (): Unexpected type 0x%x",
+        LOG(ERROR) << StringPrintf("llcp_util_parse_cc (): Unexpected type 0x%x",
                           param_type);
         BE_STREAM_TO_UINT8(param_len, p);
         p += param_len;
@@ -632,7 +658,7 @@ tLLCP_STATUS llcp_util_parse_cc(uint8_t* p_bytes, uint16_t length,
     if (length >= param_len + 1)
       length -= param_len + 1;
     else {
-      LLCP_TRACE_ERROR0("llcp_util_parse_cc (): Bad LTV's");
+      LOG(ERROR) << StringPrintf("llcp_util_parse_cc (): Bad LTV's");
       return LLCP_STATUS_FAIL;
     }
   }
@@ -683,6 +709,7 @@ void llcp_util_build_info_pdu(tLLCP_DLCB* p_dlcb, NFC_HDR* p_msg) {
 
   p_msg->offset -= LLCP_PDU_HEADER_SIZE + LLCP_SEQUENCE_SIZE;
   p_msg->len += LLCP_PDU_HEADER_SIZE + LLCP_SEQUENCE_SIZE;
+
   p = (uint8_t*)(p_msg + 1) + p_msg->offset;
 
   UINT16_TO_BE_STREAM(p,
@@ -736,7 +763,7 @@ tLLCP_STATUS llcp_util_send_frmr(tLLCP_DLCB* p_dlcb, uint8_t flags,
 
     return LLCP_STATUS_SUCCESS;
   } else {
-    LLCP_TRACE_ERROR0("llcp_util_send_frmr (): Out of resource");
+    LOG(ERROR) << StringPrintf("llcp_util_send_frmr (): Out of resource");
     return LLCP_STATUS_FAIL;
   }
 }
@@ -775,7 +802,7 @@ void llcp_util_send_rr_rnr(tLLCP_DLCB* p_dlcb) {
 
   if ((p_dlcb->local_busy) || (p_dlcb->is_rx_congested) ||
       (llcp_cb.overall_rx_congested)) {
-    LLCP_TRACE_DEBUG3(
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "llcp_util_send_rr_rnr (): "
         "local_busy=%d,is_rx_congested=%d,overall_rx_congested=%d",
         p_dlcb->local_busy, p_dlcb->is_rx_congested,
@@ -809,16 +836,14 @@ void llcp_util_send_rr_rnr(tLLCP_DLCB* p_dlcb) {
 
     UINT8_TO_BE_STREAM(p, rcv_seq);
 
-#if (BT_TRACE_VERBOSE == true)
-    LLCP_TRACE_DEBUG5("LLCP TX - N(S,R):(NA,%d) V(S,SA,R,RA):(%d,%d,%d,%d)",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("LLCP TX - N(S,R):(NA,%d) V(S,SA,R,RA):(%d,%d,%d,%d)",
                       p_dlcb->next_rx_seq, p_dlcb->next_tx_seq,
                       p_dlcb->rcvd_ack_seq, p_dlcb->next_rx_seq,
                       p_dlcb->sent_ack_seq);
-#endif
     GKI_enqueue(&llcp_cb.lcb.sig_xmit_q, p_msg);
     llcp_link_check_send_data();
   } else {
-    LLCP_TRACE_ERROR0("llcp_util_send_rr_rnr (): Out of resource");
+    LOG(ERROR) << StringPrintf("llcp_util_send_rr_rnr (): Out of resource");
   }
 }
 
diff --git a/src/nfc/nci/nci_hmsgs.c b/src/nfc/nci/nci_hmsgs.cc
old mode 100644
new mode 100755
similarity index 93%
rename from src/nfc/nci/nci_hmsgs.c
rename to src/nfc/nci/nci_hmsgs.cc
index c965329..969638c
--- a/src/nfc/nci/nci_hmsgs.c
+++ b/src/nfc/nci/nci_hmsgs.cc
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -42,12 +42,21 @@
  *
  ******************************************************************************/
 #include <string.h>
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfc_target.h"
 
 #include "nci_defs.h"
 #include "nci_hmsgs.h"
 #include "nfc_api.h"
 #include "nfc_int.h"
+
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+
 /*******************************************************************************
 **
 ** Function         nci_snd_core_reset
@@ -91,8 +100,8 @@ uint8_t nci_snd_core_reset(uint8_t reset_type) {
 uint8_t nci_snd_core_init(uint8_t nci_version) {
   NFC_HDR* p;
   uint8_t* pp;
-  p = NCI_GET_CMD_BUF(NCI_CORE_PARAM_SIZE_INIT(nci_version));
-  if (p == NULL) return (NCI_STATUS_FAILED);
+  if ((p = NCI_GET_CMD_BUF(NCI_CORE_PARAM_SIZE_INIT(nci_version))) == NULL)
+    return (NCI_STATUS_FAILED);
 
   p->event = BT_EVT_TO_NFC_NCI;
   p->len = NCI_MSG_HDR_SIZE + NCI_CORE_PARAM_SIZE_INIT(nci_version);
@@ -111,40 +120,6 @@ uint8_t nci_snd_core_init(uint8_t nci_version) {
   return (NCI_STATUS_OK);
 }
 
-/*******************************************************************************
-**
-** Function         nci_snd_set_power_sub_state_cmd
-**
-** Description      compose and send core CORE_SET_POWER_SUB_STATE command
-**                  to command queue
-**
-** Returns          status
-**
-*******************************************************************************/
-uint8_t nci_snd_core_set_power_sub_state(uint8_t screen_state)
-{
-  NFC_HDR *p;
-  uint8_t *pp;
-
-  if ((p = NCI_GET_CMD_BUF(NCI_CORE_PARAM_SIZE_SET_POWER_SUB_STATE)) == NULL)
-    return (NCI_STATUS_FAILED);
-
-  p->event            = BT_EVT_TO_NFC_NCI;
-  p->offset           = NCI_MSG_OFFSET_SIZE;
-  p->len              = NCI_MSG_HDR_SIZE + NCI_CORE_PARAM_SIZE_SET_POWER_SUB_STATE;
-  p->layer_specific   = 0;
-  pp                  = (uint8_t *) (p + 1) + p->offset;
-
-  NCI_MSG_BLD_HDR0 (pp, NCI_MT_CMD, NCI_GID_CORE);
-  NCI_MSG_BLD_HDR1 (pp, NCI_MSG_CORE_SET_POWER_SUB_STATE);
-  UINT8_TO_STREAM (pp, NCI_CORE_PARAM_SIZE_SET_POWER_SUB_STATE);
-  UINT8_TO_STREAM (pp, screen_state);
-
-  nfc_ncif_send_cmd (p);
-
-  return (NCI_STATUS_OK);
-}
-
 /*******************************************************************************
 **
 ** Function         nci_snd_core_get_config
@@ -371,9 +346,9 @@ uint8_t nci_snd_nfcee_discover(uint8_t discover_action) {
 **
 *******************************************************************************/
 uint8_t nci_snd_pwr_nd_lnk_ctrl_cmd(uint8_t nfcee_id, uint8_t cfg_value) {
-    NFC_TRACE_DEBUG0("nci_snd_pwr_nd_lnk_ctrl_cmd() Enter ");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nci_snd_pwr_nd_lnk_ctrl_cmd() Enter ");
     if(!nfcFL.eseFL._WIRED_MODE_STANDBY) {
-        NFC_TRACE_DEBUG0("WIRED_MODE_STANDBY not available. Returning");
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("WIRED_MODE_STANDBY not available. Returning");
         return (NCI_STATUS_FAILED);
     }
   NFC_HDR* p;
@@ -381,12 +356,12 @@ uint8_t nci_snd_pwr_nd_lnk_ctrl_cmd(uint8_t nfcee_id, uint8_t cfg_value) {
   if (nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME ==
           nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
       if (nfc_cb.bBlkPwrlinkAndModeSetCmd) {
-          NFC_TRACE_DEBUG0("pwr link cmd ignored due to RF session");
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("pwr link cmd ignored due to RF session");
           nfc_cb.pwr_link_cmd.bPwrLinkCmdRequested = true;
           nfc_cb.pwr_link_cmd.param = cfg_value;
-          nfc_start_quick_timer(&nfc_cb.nci_wait_pwrLinkRsp_timer,
-                  NFC_TTYPE_PWR_LINK_RSP,
-                  ((uint32_t)100) * QUICK_TIMER_TICKS_PER_SEC / 1000);
+          nfc_start_quick_timer(
+              &nfc_cb.nci_wait_pwrLinkRsp_timer, NFC_TTYPE_PWR_LINK_RSP,
+              ((uint32_t)DWP_BLOCK_TIMEOUT) * QUICK_TIMER_TICKS_PER_SEC / 1000);
           return (NCI_STATUS_OK);
       }
   }
@@ -409,6 +384,37 @@ uint8_t nci_snd_pwr_nd_lnk_ctrl_cmd(uint8_t nfcee_id, uint8_t cfg_value) {
   return (NCI_STATUS_OK);
 }
 #endif
+
+/*******************************************************************************
+**
+** Function         nci_snd_iso_dep_nak_presence_check_cmd
+**
+** Description      compose and send RF Management presence check ISO-DEP NAK
+**                  command.
+**
+**
+** Returns          status
+**
+*******************************************************************************/
+uint8_t nci_snd_iso_dep_nak_presence_check_cmd()
+{
+    NFC_HDR *p;
+    uint8_t *pp;
+
+    if ((p = NCI_GET_CMD_BUF(0)) == NULL) return (NCI_STATUS_FAILED);
+
+    p->event            = BT_EVT_TO_NFC_NCI;
+    p->offset           = NCI_MSG_OFFSET_SIZE;
+    p->len              = NCI_MSG_HDR_SIZE + 0;
+    p->layer_specific   = 0;
+    pp                  = (uint8_t *) (p + 1) + p->offset;
+
+    NCI_MSG_BLD_HDR0 (pp, NCI_MT_CMD, NCI_GID_RF_MANAGE);
+    NCI_MSG_BLD_HDR1 (pp, NCI_MSG_RF_ISO_DEP_NAK_PRESENCE);
+    UINT8_TO_STREAM(pp, 0x00);
+    nfc_ncif_send_cmd (p);
+    return (NCI_STATUS_OK);
+}
 /*******************************************************************************
 **
 ** Function         nci_snd_nfcee_mode_set
@@ -425,10 +431,10 @@ uint8_t nci_snd_nfcee_mode_set(uint8_t nfcee_id, uint8_t nfcee_mode) {
   if (nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME ==
           nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
       if ((nfc_cb.bBlkPwrlinkAndModeSetCmd) && (NFCEE_ID_ESE == nfcee_id)) {
-          NFC_TRACE_DEBUG0("mode set cmd ignored due to RF session");
-          nfc_start_quick_timer(&nfc_cb.nci_wait_pwrLinkRsp_timer,
-                  NFC_TTYPE_SET_MODE_RSP,
-                  ((uint32_t)100) * QUICK_TIMER_TICKS_PER_SEC / 1000);
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("mode set cmd ignored due to RF session");
+          nfc_start_quick_timer(
+              &nfc_cb.nci_wait_setModeRsp_timer, NFC_TTYPE_SET_MODE_RSP,
+              ((uint32_t)DWP_BLOCK_TIMEOUT) * QUICK_TIMER_TICKS_PER_SEC / 1000);
           nfc_cb.bSetmodeOnReq = true;
           return NCI_STATUS_OK;
       }
@@ -747,7 +753,37 @@ uint8_t nci_snd_set_routing_cmd(bool more, uint8_t num_tlv, uint8_t tlv_size,
 
   return (NCI_STATUS_OK);
 }
+/*******************************************************************************
+**
+** Function         nci_snd_set_power_sub_state_cmd
+**
+** Description      compose and send core CORE_SET_POWER_SUB_STATE command
+**                  to command queue
+**
+** Returns          status
+**
+*******************************************************************************/
+uint8_t nci_snd_core_set_power_sub_state(uint8_t screen_state) {
+  NFC_HDR* p = NCI_GET_CMD_BUF(NCI_CORE_PARAM_SIZE_SET_POWER_SUB_STATE);
+  uint8_t* pp;
 
+  if (p == NULL) return (NCI_STATUS_FAILED);
+
+  p->event = BT_EVT_TO_NFC_NCI;
+  p->offset = NCI_MSG_OFFSET_SIZE;
+  p->len = NCI_MSG_HDR_SIZE + NCI_CORE_PARAM_SIZE_SET_POWER_SUB_STATE;
+  p->layer_specific = 0;
+  pp = (uint8_t*)(p + 1) + p->offset;
+
+  NCI_MSG_BLD_HDR0(pp, NCI_MT_CMD, NCI_GID_CORE);
+  NCI_MSG_BLD_HDR1(pp, NCI_MSG_CORE_SET_POWER_SUB_STATE);
+  UINT8_TO_STREAM(pp, NCI_CORE_PARAM_SIZE_SET_POWER_SUB_STATE);
+  UINT8_TO_STREAM(pp, screen_state);
+
+  nfc_ncif_send_cmd(p);
+
+  return (NCI_STATUS_OK);
+}
 /*******************************************************************************
 **
 ** Function         nci_snd_get_routing_cmd
@@ -813,36 +849,4 @@ uint8_t nci_snd_nfcee_power_link_control (uint8_t nfcee_id, uint8_t pl_config)
     nfc_ncif_send_cmd (p);
     return (NCI_STATUS_OK);
 }
-
-/*******************************************************************************
-**
-** Function         nci_snd_iso_dep_nak_presence_check_cmd
-**
-** Description      compose and send RF Management presence check ISO-DEP NAK
-**                  command.
-**
-**
-** Returns          status
-**
-*******************************************************************************/
-uint8_t nci_snd_iso_dep_nak_presence_check_cmd()
-{
-    NFC_HDR *p;
-    uint8_t *pp;
-
-    if ((p = NCI_GET_CMD_BUF(0)) == NULL) return (NCI_STATUS_FAILED);
-
-    p->event            = BT_EVT_TO_NFC_NCI;
-    p->offset           = NCI_MSG_OFFSET_SIZE;
-    p->len              = NCI_MSG_HDR_SIZE + 0;
-    p->layer_specific   = 0;
-    pp                  = (uint8_t *) (p + 1) + p->offset;
-
-    NCI_MSG_BLD_HDR0 (pp, NCI_MT_CMD, NCI_GID_RF_MANAGE);
-    NCI_MSG_BLD_HDR1 (pp, NCI_MSG_RF_ISO_DEP_NAK_PRESENCE);
-    UINT8_TO_STREAM(pp, 0x00);
-    nfc_ncif_send_cmd (p);
-    return (NCI_STATUS_OK);
-}
 #endif
-
diff --git a/src/nfc/nci/nci_hrcv.c b/src/nfc/nci/nci_hrcv.cc
old mode 100644
new mode 100755
similarity index 76%
rename from src/nfc/nci/nci_hrcv.c
rename to src/nfc/nci/nci_hrcv.cc
index c99048e..3995c98
--- a/src/nfc/nci/nci_hrcv.c
+++ b/src/nfc/nci/nci_hrcv.cc
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -42,6 +42,10 @@
  *
  ******************************************************************************/
 #include <string.h>
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfc_target.h"
 #include "bt_types.h"
 #include "gki.h"
@@ -54,6 +58,11 @@
 #include "nfa_sys.h"
 #endif
 #include "nfa_ee_int.h"
+
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+
 /*******************************************************************************
 **
 ** Function         nci_proc_core_rsp
@@ -73,7 +82,7 @@ bool nci_proc_core_rsp(NFC_HDR* p_msg) {
   p = (uint8_t*)(p_msg + 1) + p_msg->offset;
   pp = p + 1;
   NCI_MSG_PRS_HDR1(pp, op_code);
-  NFC_TRACE_DEBUG1("nci_proc_core_rsp opcode:0x%x", op_code);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nci_proc_core_rsp opcode:0x%x", op_code);
   len = *pp++;
 
   /* process the message based on the opcode and message type */
@@ -102,12 +111,11 @@ bool nci_proc_core_rsp(NFC_HDR* p_msg) {
     case NCI_MSG_CORE_CONN_CLOSE:
       nfc_ncif_report_conn_close_evt(*p_old, *pp);
       break;
-
     case NCI_MSG_CORE_SET_POWER_SUB_STATE:
       nfc_ncif_event_status(NFC_SET_POWER_SUB_STATE_REVT, *pp);
       break;
     default:
-      NFC_TRACE_ERROR1("unknown opcode:0x%x", op_code);
+      LOG(ERROR) << StringPrintf("unknown opcode:0x%x", op_code);
       break;
   }
 
@@ -132,7 +140,7 @@ void nci_proc_core_ntf(NFC_HDR* p_msg) {
   p = (uint8_t*)(p_msg + 1) + p_msg->offset;
   pp = p + 1;
   NCI_MSG_PRS_HDR1(pp, op_code);
-  NFC_TRACE_DEBUG1("nci_proc_core_ntf opcode:0x%x", op_code);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nci_proc_core_ntf opcode:0x%x", op_code);
   len = *pp++;
 
   /* process the message based on the opcode and message type */
@@ -158,7 +166,7 @@ void nci_proc_core_ntf(NFC_HDR* p_msg) {
       break;
 
     default:
-      NFC_TRACE_ERROR1("unknown opcode:0x%x", op_code);
+      LOG(ERROR) << StringPrintf("unknown opcode:0x%x", op_code);
       break;
   }
 }
@@ -229,7 +237,7 @@ void nci_proc_rf_management_rsp(NFC_HDR* p_msg) {
       nfc_ncif_proc_isodep_nak_presence_check_status(*pp, false);
       break;
     default:
-      NFC_TRACE_ERROR1("unknown opcode:0x%x", op_code);
+      LOG(ERROR) << StringPrintf("unknown opcode:0x%x", op_code);
       break;
   }
 }
@@ -262,6 +270,9 @@ void nci_proc_rf_management_ntf(NFC_HDR* p_msg) {
       if (false == nfa_dm_p2p_prio_logic(op_code, pp, NFA_DM_P2P_PRIO_NTF)) {
         return;
       }
+      if (NFC_GetNCIVersion() == NCI_VERSION_2_0) {
+        nfc_cb.deact_reason = *(pp + 1);
+      }
       nfc_ncif_proc_deactivate(NFC_STATUS_OK, *pp, true);
       break;
 
@@ -300,7 +311,7 @@ void nci_proc_rf_management_ntf(NFC_HDR* p_msg) {
       nfc_ncif_proc_isodep_nak_presence_check_status(*pp, true);
       break;
     default:
-      NFC_TRACE_ERROR1("unknown opcode:0x%x", op_code);
+      LOG(ERROR) << StringPrintf("unknown opcode:0x%x", op_code);
       break;
   }
 }
@@ -321,15 +332,7 @@ void nci_proc_ee_management_rsp(NFC_HDR* p_msg) {
   uint8_t* p;
   uint8_t* pp, len, op_code;
   tNFC_RESPONSE_CBACK* p_cback = nfc_cb.p_resp_cback;
-  tNFC_NFCEE_DISCOVER_REVT nfcee_discover;
-  tNFC_NFCEE_MODE_SET_REVT mode_set;
-  tNFC_NFCEE_PL_CONTROL_REVT  pl_control;
-#if (NXP_EXTNS == TRUE)
-  tNFC_NFCEE_MODE_SET_INFO mode_set_info;
-  tNFC_NFCEE_EE_PWR_LNK_REVT pwr_lnk_ctrl;
-
-#endif
-  void* p_evt = NULL;
+  tNFC_RESPONSE nfc_response;
   tNFC_RESPONSE_EVT event = NFC_NFCEE_INFO_REVT;
   uint8_t* p_old = nfc_cb.last_cmd;
 
@@ -337,27 +340,27 @@ void nci_proc_ee_management_rsp(NFC_HDR* p_msg) {
   p = (uint8_t*)(p_msg + 1) + p_msg->offset;
   pp = p + 1;
   NCI_MSG_PRS_HDR1(pp, op_code);
-  NFC_TRACE_DEBUG1("nci_proc_ee_management_rsp opcode:0x%x", op_code);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nci_proc_ee_management_rsp opcode:0x%x", op_code);
   len = *pp++;
 
   switch (op_code) {
     case NCI_MSG_NFCEE_DISCOVER:
-      p_evt = (void*)&nfcee_discover;
-      nfcee_discover.status = *pp++;
-      nfcee_discover.num_nfcee = *pp++;
+      nfc_response.nfcee_discover.status = *pp++;
+      nfc_response.nfcee_discover.num_nfcee = *pp++;
 
-      if (nfcee_discover.status != NFC_STATUS_OK) nfcee_discover.num_nfcee = 0;
+      if (nfc_response.nfcee_discover.status != NFC_STATUS_OK)
+        nfc_response.nfcee_discover.num_nfcee = 0;
 
       event = NFC_NFCEE_DISCOVER_REVT;
       break;
 
     case NCI_MSG_NFCEE_MODE_SET:
-      p_evt = (void*)&mode_set;
-      mode_set.status = *pp;
-      mode_set.nfcee_id = 0;
+      nfc_response.mode_set.status = *pp;
+      nfc_response.mode_set.nfcee_id = *p_old++;
+      //mode_set.nfcee_id = 0;
       event = NFC_NFCEE_MODE_SET_REVT;
-      mode_set.nfcee_id = *p_old++;
-      mode_set.mode = *p_old++;
+      //mode_set.nfcee_id = *p_old++;
+      nfc_response.mode_set.mode = *p_old++;
       if (nfc_cb.nci_version != NCI_VERSION_2_0 || *pp != NCI_STATUS_OK)
       {
           nfc_cb.flags  &= ~NFC_FL_WAIT_MODE_SET_NTF;
@@ -373,15 +376,14 @@ void nci_proc_ee_management_rsp(NFC_HDR* p_msg) {
 #if (NXP_EXTNS == TRUE)
     case NCI_MSG_NFCEE_PWR_LNK_CTRL:
         if(nfcFL.eseFL._WIRED_MODE_STANDBY) {
-            p_evt = (tNFC_RESPONSE*)&pwr_lnk_ctrl;
-            pwr_lnk_ctrl.status = *pp;
-            pwr_lnk_ctrl.nfcee_id = 0;
+            nfc_response.pl_control.status = *pp;
+            nfc_response.pl_control.nfcee_id = *p_old++;
+            nfc_response.pl_control.pl_control = *p_old++;
             event = NFC_NFCEE_PWR_LNK_CTRL_REVT;
-            pwr_lnk_ctrl.nfcee_id = *p_old++;
             if(nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME ==
                     nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
                 if (nfc_cb.bIssueModeSetCmd) {
-                    NFC_TRACE_DEBUG0("mode set cmd send after pwrlink cmd");
+                    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("mode set cmd send after pwrlink cmd");
                     nfc_cb.bSetmodeOnReq = true;
                     nci_snd_nfcee_mode_set(NFCEE_ID_ESE, NFC_MODE_ACTIVATE);
                     nfc_start_timer(&nfc_cb.nci_wait_setMode_Ntf_timer,
@@ -394,21 +396,21 @@ void nci_proc_ee_management_rsp(NFC_HDR* p_msg) {
             }
             break;
         }
+        [[fallthrough]];
 #endif
     case NCI_MSG_NFCEE_POWER_LINK_CTRL:
-        p_evt                   = (tNFC_RESPONSE *) &pl_control;
-        pl_control.status        = *pp;
-        pl_control.nfcee_id      = *p_old++;
-        pl_control.pl_control    = *p_old++;
+        nfc_response.pl_control.status        = *pp;
+        nfc_response.pl_control.nfcee_id      = *p_old++;
+        nfc_response.pl_control.pl_control    = *p_old++;
         event               = NFC_NFCEE_PL_CONTROL_REVT;
         break;
     default:
       p_cback = NULL;
-      NFC_TRACE_ERROR1("unknown opcode:0x%x", op_code);
+      LOG(ERROR) << StringPrintf("unknown opcode:0x%x", op_code);
       break;
   }
 
-  if (p_cback) (*p_cback)(event, p_evt);
+  if (p_cback) (*p_cback)(event, &nfc_response);
 }
 
 /*******************************************************************************
@@ -424,54 +426,47 @@ void nci_proc_ee_management_ntf(NFC_HDR* p_msg) {
   uint8_t* p;
   uint8_t* pp, len, op_code;
   tNFC_RESPONSE_CBACK* p_cback = nfc_cb.p_resp_cback;
-  tNFC_NFCEE_INFO_REVT nfcee_info;
-  void* p_evt = (void*)&nfcee_info;
+  tNFC_RESPONSE nfc_response;
   tNFC_RESPONSE_EVT event = NFC_NFCEE_INFO_REVT;
-  uint8_t* p_old = nfc_cb.last_cmd;
+  //uint8_t* p_old = nfc_cb.last_cmd;
   uint8_t xx;
   uint8_t yy;
-  uint8_t ee_status;
   tNFC_NFCEE_TLV* p_tlv;
-#if (NXP_EXTNS == TRUE)
-  tNFC_NFCEE_MODE_SET_INFO mode_set_info;
-#endif
-  tNFC_NFCEE_MODE_SET_REVT    mode_set;
-  tNFC_NFCEE_STATUS_REVT      nfcee_status;
   /* find the start of the NCI message and parse the NCI header */
   p = (uint8_t*)(p_msg + 1) + p_msg->offset;
   pp = p + 1;
   NCI_MSG_PRS_HDR1(pp, op_code);
-  NFC_TRACE_DEBUG1("nci_proc_ee_management_ntf opcode:0x%x", op_code);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nci_proc_ee_management_ntf opcode:0x%x", op_code);
   len = *pp++;
 
   if (op_code == NCI_MSG_NFCEE_DISCOVER) {
-    nfcee_info.nfcee_id = *pp++;
-    ee_status = *pp++;
+    nfc_response.nfcee_info.nfcee_id = *pp++;
 
-    nfcee_info.ee_status = ee_status;
+    nfc_response.nfcee_info.ee_status = *pp++;
     yy = *pp;
-    nfcee_info.num_interface = *pp++;
+    nfc_response.nfcee_info.num_interface = *pp++;
     p = pp;
 
-    if (nfcee_info.num_interface > NFC_MAX_EE_INTERFACE)
-      nfcee_info.num_interface = NFC_MAX_EE_INTERFACE;
+    if (nfc_response.nfcee_info.num_interface > NFC_MAX_EE_INTERFACE)
+      nfc_response.nfcee_info.num_interface = NFC_MAX_EE_INTERFACE;
 
-    for (xx = 0; xx < nfcee_info.num_interface; xx++) {
-      nfcee_info.ee_interface[xx] = *pp++;
+    for (xx = 0; xx < nfc_response.nfcee_info.num_interface; xx++) {
+      nfc_response.nfcee_info.ee_interface[xx] = *pp++;
     }
 
     pp = p + yy;
-    nfcee_info.num_tlvs = *pp++;
-    NFC_TRACE_DEBUG4("nfcee_id: 0x%x num_interface:0x%x/0x%x, num_tlvs:0x%x",
-                     nfcee_info.nfcee_id, nfcee_info.num_interface, yy,
-                     nfcee_info.num_tlvs);
+    nfc_response.nfcee_info.num_tlvs = *pp++;
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfcee_id: 0x%x num_interface:0x%x/0x%x, num_tlvs:0x%x",
+                     nfc_response.nfcee_info.nfcee_id,
+                     nfc_response.nfcee_info.num_interface, yy,
+                     nfc_response.nfcee_info.num_tlvs);
 
-    if (nfcee_info.num_tlvs > NFC_MAX_EE_TLVS)
-      nfcee_info.num_tlvs = NFC_MAX_EE_TLVS;
+    if (nfc_response.nfcee_info.num_tlvs > NFC_MAX_EE_TLVS)
+      nfc_response.nfcee_info.num_tlvs = NFC_MAX_EE_TLVS;
 
-    p_tlv = &nfcee_info.ee_tlv[0];
+    p_tlv = &nfc_response.nfcee_info.ee_tlv[0];
 
-    for (xx = 0; xx < nfcee_info.num_tlvs; xx++, p_tlv++) {
+    for (xx = 0; xx < nfc_response.nfcee_info.num_tlvs; xx++, p_tlv++) {
 #if (NXP_EXTNS == TRUE)
       if (*pp < 0xA0) {
         p_tlv->tag = *pp++;
@@ -483,7 +478,7 @@ void nci_proc_ee_management_ntf(NFC_HDR* p_msg) {
       p_tlv->tag = *pp++;
 #endif
       p_tlv->len = yy = *pp++;
-      NFC_TRACE_DEBUG2("tag:0x%x, len:0x%x", p_tlv->tag, p_tlv->len);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("tag:0x%x, len:0x%x", p_tlv->tag, p_tlv->len);
       if (p_tlv->len > NFC_MAX_EE_INFO) p_tlv->len = NFC_MAX_EE_INFO;
       p = pp;
       STREAM_TO_ARRAY(p_tlv->info, pp, p_tlv->len);
@@ -492,27 +487,31 @@ void nci_proc_ee_management_ntf(NFC_HDR* p_msg) {
   }
 #if (NXP_EXTNS == TRUE)
   else if (op_code == NCI_MSG_NFCEE_MODE_SET) {
-      NFC_TRACE_DEBUG2("nci_proc_ee_management_ntf status:0x%x, nfceeid:0x%x",
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nci_proc_ee_management_ntf status:0x%x, nfceeid:0x%x",
               *pp, *(pp + 1));
       nfc_stop_timer(&nfc_cb.nci_wait_setMode_Ntf_timer);
       if(nfc_cb.nci_version != NCI_VERSION_2_0)
       {
-          p_evt = (tNFC_RESPONSE*)&mode_set_info;
+          //p_evt = (tNFC_RESPONSE*)&mode_set_info;
           event = NFC_NFCEE_MODE_SET_INFO;
-          ee_status = *pp++;
-          mode_set_info.nfcee_id = *pp++;
-          mode_set_info.status = ee_status;
+          //ee_status = *pp++;
+          //mode_set_info.nfcee_id = *pp++;
+          //mode_set_info.status = ee_status;
+          nfc_response.mode_set_info.status = *pp++;
+          nfc_response.mode_set_info.nfcee_id = *pp++;
+
       }
       else
       {
-          NFC_TRACE_DEBUG2("nci_proc_ee_management_last ntf mode:0x%x, nfceeid:0x%x",
-                  mode_set.mode, mode_set.nfcee_id);
-          p_evt   = (tNFC_RESPONSE *) &mode_set;
-          mode_set.status = *pp;
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nci_proc_ee_management_last ntf mode:0x%x, nfceeid:0x%x",
+                  nfc_response.mode_set.mode, nfc_response.mode_set.nfcee_id);
+          nfc_response.mode_set.status = *pp;
+          nfc_response.mode_set.nfcee_id = nfa_ee_cb.nfcee_id;
+          nfc_response.mode_set.mode = nfa_ee_cb.mode;
           /*mode_set.nfcee_id = *p_old++;
       mode_set.mode = *p_old++;*/
-          mode_set.nfcee_id = nfa_ee_cb.nfcee_id;
-          mode_set.mode = nfa_ee_cb.mode;
+          /*mode_set.nfcee_id = nfa_ee_cb.nfcee_id;
+          mode_set.mode = nfa_ee_cb.mode;*/
           event   = NFC_NFCEE_MODE_SET_REVT;
           nfc_cb.flags  &= ~NFC_FL_WAIT_MODE_SET_NTF;
           nfc_stop_timer(&nfc_cb.nci_setmode_ntf_timer);
@@ -528,18 +527,17 @@ void nci_proc_ee_management_ntf(NFC_HDR* p_msg) {
   }
 #endif
   else if (op_code == NCI_MSG_NFCEE_STATUS) {
-      p_evt   = (tNFC_RESPONSE *) &nfcee_status;
       event   = NFC_NFCEE_STATUS_REVT;
-      nfcee_status.status         = NCI_STATUS_OK;
-      nfcee_status.nfcee_id       = *pp++;
-      nfcee_status.nfcee_status   = *pp;
+      nfc_response.nfcee_status.status = NCI_STATUS_OK;
+      nfc_response.nfcee_status.nfcee_id = *pp++;
+      nfc_response.nfcee_status.nfcee_status = *pp;
      }
   else {
     p_cback = NULL;
-    NFC_TRACE_ERROR1("unknown opcode:0x%x", op_code);
+    LOG(ERROR) << StringPrintf("unknown opcode:0x%x", op_code);
   }
 
-  if (p_cback) (*p_cback)(event, p_evt);
+  if (p_cback) (*p_cback)(event, &nfc_response);
 }
 
 #endif
@@ -572,38 +570,33 @@ void nci_proc_prop_rsp(NFC_HDR* p_msg) {
     (*p_cback)((tNFC_VS_EVT)(NCI_RSP_BIT | op_code), p_msg->len, p_evt);
 }
 
-#if (NXP_EXTNS == TRUE)
 /*******************************************************************************
 **
-** Function         nci_proc_prop_nxp_rsp
+** Function         nci_proc_prop_raw_vs_rsp
 **
-** Description      Process NXP NCI responses
+** Description      Process RAW VS responses
 **
 ** Returns          void
 **
 *******************************************************************************/
-void nci_proc_prop_nxp_rsp(NFC_HDR* p_msg) {
-  uint8_t* p;
-  uint8_t* p_evt;
-  uint8_t* pp, len, op_code;
+void nci_proc_prop_raw_vs_rsp(NFC_HDR* p_msg) {
+  uint8_t op_code;
   tNFC_VS_CBACK* p_cback = (tNFC_VS_CBACK*)nfc_cb.p_vsc_cback;
 
   /* find the start of the NCI message and parse the NCI header */
-  p = p_evt = (uint8_t*)(p_msg + 1) + p_msg->offset;
-  pp = p + 1;
-  NCI_MSG_PRS_HDR1(pp, op_code);
-  len = *pp++;
+  uint8_t* p_evt = (uint8_t*)(p_msg + 1) + p_msg->offset;
+  uint8_t* p = p_evt + 1;
+  NCI_MSG_PRS_HDR1(p, op_code);
 
-  /*If there's a pending/stored command, restore the associated address of the
+  /* If there's a pending/stored command, restore the associated address of the
    * callback function */
   if (p_cback) {
     (*p_cback)((tNFC_VS_EVT)(NCI_RSP_BIT | op_code), p_msg->len, p_evt);
     nfc_cb.p_vsc_cback = NULL;
   }
-  nfc_cb.nxpCbflag = false;
+  nfc_cb.rawVsCbflag = false;
   nfc_ncif_update_window();
 }
-#endif
 
 /*******************************************************************************
 **
@@ -627,7 +620,7 @@ void nci_proc_prop_ntf(NFC_HDR* p_msg) {
   len = *pp++;
 
 #if (NXP_EXTNS == TRUE)
-  NFC_TRACE_DEBUG1("nci_proc_prop_ntf:op_code =0x%x", op_code);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nci_proc_prop_ntf:op_code =0x%x", op_code);
   switch (op_code) {
     case NCI_MSG_RF_WTX:
       nfc_ncif_proc_rf_wtx_ntf(p, p_msg->len);
diff --git a/src/nfc/ndef/ndef_utils.c b/src/nfc/ndef/ndef_utils.cc
similarity index 90%
rename from src/nfc/ndef/ndef_utils.c
rename to src/nfc/ndef/ndef_utils.cc
index 0b5cc17..f6faf7d 100644
--- a/src/nfc/ndef/ndef_utils.c
+++ b/src/nfc/ndef/ndef_utils.cc
@@ -39,9 +39,9 @@
 **
 *******************************************************************************/
 static void shiftdown(uint8_t* p_mem, uint32_t len, uint32_t shift_amount) {
-  register uint8_t* ps = p_mem + len - 1;
-  register uint8_t* pd = ps + shift_amount;
-  register uint32_t xx;
+  uint8_t* ps = p_mem + len - 1;
+  uint8_t* pd = ps + shift_amount;
+  uint32_t xx;
 
   for (xx = 0; xx < len; xx++) *pd-- = *ps--;
 }
@@ -54,9 +54,9 @@ static void shiftdown(uint8_t* p_mem, uint32_t len, uint32_t shift_amount) {
 **
 *******************************************************************************/
 static void shiftup(uint8_t* p_dest, uint8_t* p_src, uint32_t len) {
-  register uint8_t* ps = p_src;
-  register uint8_t* pd = p_dest;
-  register uint32_t xx;
+  uint8_t* ps = p_src;
+  uint8_t* pd = p_dest;
+  uint32_t xx;
 
   for (xx = 0; xx < len; xx++) *pd++ = *ps++;
 }
@@ -881,143 +881,6 @@ extern tNDEF_STATUS NDEF_MsgAddRec(uint8_t* p_msg, uint32_t max_size,
   return (NDEF_OK);
 }
 
-/*******************************************************************************
-**
-** Function         NDEF_MsgInsertRec
-**
-** Description      This function inserts a record at a specific index into the
-**                  given NDEF message
-**
-** Returns          OK, or error if the record did not fit
-**                  *p_cur_size is updated
-**
-*******************************************************************************/
-extern tNDEF_STATUS NDEF_MsgInsertRec(uint8_t* p_msg, uint32_t max_size,
-                                      uint32_t* p_cur_size, int32_t index,
-                                      uint8_t tnf, uint8_t* p_type,
-                                      uint8_t type_len, uint8_t* p_id,
-                                      uint8_t id_len, uint8_t* p_payload,
-                                      uint32_t payload_len) {
-  uint8_t* p_rec;
-  uint32_t recSize;
-  int32_t plen = (payload_len < 256) ? 1 : 4;
-  int32_t ilen = (id_len == 0) ? 0 : 1;
-
-  /* First, make sure the record will fit. we need at least 2 bytes for header
-   * and type length */
-  recSize = payload_len + 2 + type_len + plen + ilen + id_len;
-
-  if ((*p_cur_size + recSize) > max_size) return (NDEF_MSG_INSUFFICIENT_MEM);
-
-  /* See where the new record goes. If at the end, call the 'AddRec' function */
-  if ((index >= NDEF_MsgGetNumRecs(p_msg)) ||
-      ((p_rec = NDEF_MsgGetRecByIndex(p_msg, index)) == NULL)) {
-    return NDEF_MsgAddRec(p_msg, max_size, p_cur_size, tnf, p_type, type_len,
-                          p_id, id_len, p_payload, payload_len);
-  }
-
-  /* If we are inserting at the beginning, remove the MB bit from the current
-   * first */
-  if (index == 0) *p_msg &= ~NDEF_MB_MASK;
-
-  /* Make space for the new record */
-  shiftdown(p_rec, (uint32_t)(*p_cur_size - (p_rec - p_msg)), recSize);
-
-  /* If adding at the beginning, set begin bit */
-  if (index == 0)
-    *p_rec = tnf | NDEF_MB_MASK;
-  else
-    *p_rec = tnf;
-
-  if (plen == 1) *p_rec |= NDEF_SR_MASK;
-
-  if (ilen != 0) *p_rec |= NDEF_IL_MASK;
-
-  p_rec++;
-
-  /* The next byte is the type field length */
-  *p_rec++ = type_len;
-
-  /* Payload length - can be 1 or 4 bytes */
-  if (plen == 1)
-    *p_rec++ = (uint8_t)payload_len;
-  else
-    UINT32_TO_BE_STREAM(p_rec, payload_len);
-
-  /* ID field Length (optional) */
-  if (ilen != 0) *p_rec++ = id_len;
-
-  /* Next comes the type */
-  if (type_len) {
-    if (p_type) memcpy(p_rec, p_type, type_len);
-
-    p_rec += type_len;
-  }
-
-  /* Next comes the ID */
-  if (ilen != 0) {
-    if (p_id) memcpy(p_rec, p_id, id_len);
-
-    p_rec += id_len;
-  }
-
-  /* And lastly the payload. If NULL, the app just wants to reserve memory */
-  if (p_payload) memcpy(p_rec, p_payload, payload_len);
-
-  *p_cur_size += recSize;
-
-  return (NDEF_OK);
-}
-
-/*******************************************************************************
-**
-** Function         NDEF_MsgAppendRec
-**
-** Description      This function adds NDEF records to the end of an NDEF
-**                  message.
-**
-** Returns          OK, or error if the record did not fit
-**                  *p_cur_size is updated
-**
-*******************************************************************************/
-extern tNDEF_STATUS NDEF_MsgAppendRec(uint8_t* p_msg, uint32_t max_size,
-                                      uint32_t* p_cur_size, uint8_t* p_new_rec,
-                                      uint32_t new_rec_len) {
-  uint8_t* p_rec;
-  tNDEF_STATUS status;
-
-  /* First, validate new records */
-  status = NDEF_MsgValidate(p_new_rec, new_rec_len, false);
-  if (status != NDEF_OK) return (status);
-
-  /* First, make sure the record will fit */
-  if ((*p_cur_size + new_rec_len) > max_size)
-    return (NDEF_MSG_INSUFFICIENT_MEM);
-
-  /* Find where to copy new record */
-  if (*p_cur_size == 0)
-    p_rec = p_msg;
-  else {
-    /* Find the previous last and clear his 'Message End' bit */
-    uint8_t* pLast = NDEF_MsgGetLastRecInMsg(p_msg);
-
-    if (!pLast) return (NDEF_MSG_NO_MSG_END);
-
-    *pLast &= ~NDEF_ME_MASK;
-    p_rec = p_msg + *p_cur_size;
-
-    /* clear 'Message Begin' bit of new record */
-    *p_new_rec &= ~NDEF_MB_MASK;
-  }
-
-  /* append new records */
-  memcpy(p_rec, p_new_rec, new_rec_len);
-
-  *p_cur_size += new_rec_len;
-
-  return (NDEF_OK);
-}
-
 /*******************************************************************************
 **
 ** Function         NDEF_MsgAppendPayload
diff --git a/src/nfc/nfc/nfc_ee.c b/src/nfc/nfc/nfc_ee.cc
old mode 100644
new mode 100755
similarity index 92%
rename from src/nfc/nfc/nfc_ee.c
rename to src/nfc/nfc/nfc_ee.cc
index e26ac8c..d3881bb
--- a/src/nfc/nfc/nfc_ee.c
+++ b/src/nfc/nfc/nfc_ee.cc
@@ -22,15 +22,19 @@
  *
  ******************************************************************************/
 #include <string.h>
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "gki.h"
 #include "nfc_target.h"
-#include "bt_types.h"
 
 #include "nfc_api.h"
 #include "nfc_int.h"
 #include "nci_hmsgs.h"
 #include "nfa_ee_int.h"
 
+using android::base::StringPrintf;
 /*******************************************************************************
 **
 ** Function         NFC_NfceeDiscover
@@ -48,7 +52,7 @@
 *******************************************************************************/
 tNFC_STATUS NFC_NfceeDiscover(bool discover) {
   if(nfc_cb.flags & NFC_FL_WAIT_MODE_SET_NTF) {
-    NFC_TRACE_ERROR1("mode set ntf pending ,not allowing nfcee_discover %d", discover);
+    LOG(ERROR) << StringPrintf("mode set ntf pending ,not allowing nfcee_discover %d", discover);
     return NFC_STATUS_FAILED;
   }
   return nci_snd_nfcee_discover((uint8_t)(
@@ -74,12 +78,14 @@ tNFC_STATUS NFC_NfceeDiscover(bool discover) {
 tNFC_STATUS NFC_NfceeModeSet(uint8_t nfcee_id, tNFC_NFCEE_MODE mode) {
   tNFC_STATUS status = NCI_STATUS_OK;
   if (mode >= NCI_NUM_NFCEE_MODE|| nfcee_id == 0x00) {
-    NFC_TRACE_ERROR1("NFC_NfceeModeSet bad mode:%d", mode);
+    LOG(ERROR) << StringPrintf("NFC_NfceeModeSet bad mode:%d", mode);
     return NFC_STATUS_FAILED;
   }
-  if(nfc_cb.nci_version != NCI_VERSION_2_0)
+  /* PN553 and PN80T supports proprierty mode set notifications */
+  if ((nfc_cb.nci_version != NCI_VERSION_2_0) &&
+      ((nfcFL.chipType != pn553) || (nfcFL.chipType != pn80T))) {
     status = nci_snd_nfcee_mode_set (nfcee_id, mode);
-  else {
+  } else {
     if (nfc_cb.flags & NFC_FL_WAIT_MODE_SET_NTF)
       status = NFC_STATUS_REFUSED;
     else {
diff --git a/src/nfc/nfc/nfc_main.c b/src/nfc/nfc/nfc_main.cc
old mode 100644
new mode 100755
similarity index 86%
rename from src/nfc/nfc/nfc_main.c
rename to src/nfc/nfc/nfc_main.cc
index a83fae8..e212fc9
--- a/src/nfc/nfc/nfc_main.c
+++ b/src/nfc/nfc/nfc_main.cc
@@ -3,7 +3,7 @@
  *  Copyright (c) 2016, The Linux Foundation. All rights reserved.
  *  Not a Contribution.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *  The original Work has been changed by NXP Semiconductors.
  *
  *  Copyright (C) 2010-2014 Broadcom Corporation
@@ -30,31 +30,37 @@
  *
  ******************************************************************************/
 #include <string.h>
-#include "gki.h"
+
+#include <android-base/stringprintf.h>
+#include <android/hardware/nfc/1.1/types.h>
+#include <base/logging.h>
+#include <cutils/properties.h>
+
 #include "nfc_target.h"
 #include "bt_types.h"
+#include "gki.h"
 #include <stdlib.h>
 #include <sys/types.h>
 #include <unistd.h>
-#include "nfc_hal_api.h"
-#include "nfc_api.h"
 #include "nfc_int.h"
 #include "nci_hmsgs.h"
 #include "rw_int.h"
 #include "ce_int.h"
 #include "nfa_sys.h"
+#ifdef ENABLE_ESE_CLIENT
+#include "hal_nxpese.h"
+#endif
 #include <config.h>
 #if (NFC_RW_ONLY == FALSE)
-#include "ce_api.h"
-#include "ce_int.h"
+
 #include "llcp_int.h"
 
-#if(NXP_EXTNS == TRUE)
-static phNxpNci_getCfg_info_t* mGetCfg_info_main = NULL;
+#if (NXP_EXTNS == TRUE)
+#include "nfa_dm_int.h"
 extern void nfa_dm_init_cfgs(phNxpNci_getCfg_info_t* mGetCfg_info_main);
-extern nfa_ee_max_ee_cfg;
 #endif
 
+
 /* NFC mandates support for at least one logical connection;
  * Update max_conn to the NFCC capability on InitRsp */
 #define NFC_SET_MAX_CONN_DEFAULT() \
@@ -67,6 +73,13 @@ extern nfa_ee_max_ee_cfg;
 #define NFC_SET_MAX_CONN_DEFAULT()
 
 #endif /* NFC_RW_ONLY */
+
+using android::base::StringPrintf;
+using android::hardware::nfc::V1_1::NfcEvent;
+
+extern bool nfc_debug_enabled;
+extern void delete_stack_non_volatile_store(bool forceDelete);
+
 /****************************************************************************
 ** Declarations
 ****************************************************************************/
@@ -74,7 +87,7 @@ tNFC_CB nfc_cb;
 uint8_t i2c_fragmentation_enabled = 0xff;
 
 tNfc_featureList nfcFL;
-static tNFC_chipType chipType = 0;
+static tNFC_chipType chipType = (tNFC_chipType)0x00;
 #if (NFC_RW_ONLY == FALSE)
 #if (NXP_EXTNS == TRUE)
 #define NFC_NUM_INTERFACE_MAP 3
@@ -119,7 +132,6 @@ static const tNCI_DISCOVER_MAPS nfc_interface_mapping_stat[NFC_NUM_INTERFACE_MAP
 #endif
 };
 
-#if (BT_TRACE_VERBOSE == true)
 /*******************************************************************************
 **
 ** Function         nfc_state_name
@@ -131,7 +143,7 @@ static const tNCI_DISCOVER_MAPS nfc_interface_mapping_stat[NFC_NUM_INTERFACE_MAP
 ** Returns          pointer to the name
 **
 *******************************************************************************/
-static char* nfc_state_name(uint8_t state) {
+static std::string nfc_state_name(uint8_t state) {
   switch (state) {
     case NFC_STATE_NONE:
       return ("NONE");
@@ -167,7 +179,7 @@ static char* nfc_state_name(uint8_t state) {
 ** Returns          pointer to the name
 **
 *******************************************************************************/
-static char* nfc_hal_event_name(uint8_t event) {
+static std::string nfc_hal_event_name(uint8_t event) {
   switch (event) {
     case HAL_NFC_OPEN_CPLT_EVT:
       return ("HAL_NFC_OPEN_CPLT_EVT");
@@ -189,6 +201,8 @@ static char* nfc_hal_event_name(uint8_t event) {
 
     case HAL_NFC_ERROR_EVT:
       return ("HAL_NFC_ERROR_EVT");
+    case (uint32_t)NfcEvent::HCI_NETWORK_RESET:
+      return "HCI_NETWORK_RESET";
 #if (NXP_EXTNS == TRUE)
     case HAL_NFC_POST_MIN_INIT_CPLT_EVT:
       return ("HAL_NFC_POST_MIN_INIT_CPLT_EVT");
@@ -200,7 +214,6 @@ static char* nfc_hal_event_name(uint8_t event) {
       return ("???? UNKNOWN EVENT");
   }
 }
-#endif /* BT_TRACE_VERBOSE == true */
 
 /*******************************************************************************
 **
@@ -245,7 +258,6 @@ void nfc_enabled(tNFC_STATUS nfc_status, NFC_HDR* p_init_rsp_msg) {
   uint8_t num_interface_extensions = 0, zz;
   uint8_t interface_type;
   int yy = 0;
-
   memset(&evt_data, 0, sizeof(tNFC_RESPONSE));
 
   if (nfc_status == NCI_STATUS_OK) {
@@ -255,26 +267,26 @@ void nfc_enabled(tNFC_STATUS nfc_status, NFC_HDR* p_init_rsp_msg) {
         NCI_MSG_HDR_SIZE + 1;
     /* we currently only support NCI of the same version.
     * We may need to change this, when we support multiple version of NFCC */
+
     evt_data.enable.nci_version = nfc_cb.nci_version;
     STREAM_TO_UINT32(evt_data.enable.nci_features, p);
-    if(nfc_cb.nci_version == NCI_VERSION_1_0) {
-        STREAM_TO_UINT8(num_interfaces, p);
-        evt_data.enable.nci_interfaces = 0;
-        for (xx = 0; xx < num_interfaces; xx++) {
-          if ((*p) <= NCI_INTERFACE_MAX)
-            evt_data.enable.nci_interfaces |= (1 << (*p));
-          else if (((*p) >= NCI_INTERFACE_FIRST_VS) &&
-                   (yy < NFC_NFCC_MAX_NUM_VS_INTERFACE)) {
-            /* save the VS RF interface in control block, if there's still room */
-            nfc_cb.vs_interface[yy++] = *p;
-          }
-          p++;
+    if (nfc_cb.nci_version == NCI_VERSION_1_0) {
+      STREAM_TO_UINT8(num_interfaces, p);
+      evt_data.enable.nci_interfaces = 0;
+      for (xx = 0; xx < num_interfaces; xx++) {
+        if ((*p) <= NCI_INTERFACE_MAX)
+          evt_data.enable.nci_interfaces |= (1 << (*p));
+        else if (((*p) >= NCI_INTERFACE_FIRST_VS) &&
+                 (yy < NFC_NFCC_MAX_NUM_VS_INTERFACE)) {
+          /* save the VS RF interface in control block, if there's still room */
+          nfc_cb.vs_interface[yy++] = *p;
         }
-        nfc_cb.nci_interfaces = evt_data.enable.nci_interfaces;
-        memcpy(evt_data.enable.vs_interface, nfc_cb.vs_interface,
-               NFC_NFCC_MAX_NUM_VS_INTERFACE);
+        p++;
+      }
+      nfc_cb.nci_interfaces = evt_data.enable.nci_interfaces;
+      memcpy(evt_data.enable.vs_interface, nfc_cb.vs_interface,
+             NFC_NFCC_MAX_NUM_VS_INTERFACE);
     }
-
     evt_data.enable.max_conn = *p++;
     STREAM_TO_UINT16(evt_data.enable.max_ce_table, p);
 #if (NFC_RW_ONLY == FALSE)
@@ -284,7 +296,6 @@ void nfc_enabled(tNFC_STATUS nfc_status, NFC_HDR* p_init_rsp_msg) {
 #endif
     nfc_cb.nci_ctrl_size = *p++; /* Max Control Packet Payload Length */
     p_cb->init_credits = p_cb->num_buff = 0;
-
     nfc_set_conn_id(p_cb, NFC_RF_CONN_ID);
     if(nfc_cb.nci_version == NCI_VERSION_2_0) {
       if (evt_data.enable.nci_features & NCI_FEAT_HCI_NETWORK)
@@ -298,7 +309,7 @@ void nfc_enabled(tNFC_STATUS nfc_status, NFC_HDR* p_init_rsp_msg) {
         p_cb->init_credits = p_cb->num_buff;
         evt_data.enable.hci_packet_size  = p_cb->buff_size;
         evt_data.enable.hci_conn_credits = p_cb->init_credits;
-        NFC_TRACE_DEBUG2 ("hci num_buf=%d buf_size=%d", p_cb->num_buff, p_cb->buff_size);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("hci num_buf=%d buf_size=%d", p_cb->num_buff, p_cb->buff_size);
       }
       else
       {
@@ -339,7 +350,7 @@ void nfc_enabled(tNFC_STATUS nfc_status, NFC_HDR* p_init_rsp_msg) {
       evt_data.enable.manufacture_id = *p++;
       STREAM_TO_ARRAY(evt_data.enable.nfcc_info, p, NFC_NFCC_INFO_LEN);
     }
-    NFC_TRACE_DEBUG1("nfc_cb.num_disc_maps = %d", nfc_cb.num_disc_maps);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_cb.num_disc_maps = %d", nfc_cb.num_disc_maps);
     NFC_DiscoveryMap(nfc_cb.num_disc_maps,
                      (tNCI_DISCOVER_MAPS*)nfc_cb.p_disc_maps, NULL);
   }
@@ -373,13 +384,9 @@ void nfc_enabled(tNFC_STATUS nfc_status, NFC_HDR* p_init_rsp_msg) {
 **
 *******************************************************************************/
 void nfc_set_state(tNFC_STATE nfc_state) {
-#if (BT_TRACE_VERBOSE == true)
-  NFC_TRACE_DEBUG4("nfc_set_state %d (%s)->%d (%s)", nfc_cb.nfc_state,
-                   nfc_state_name(nfc_cb.nfc_state), nfc_state,
-                   nfc_state_name(nfc_state));
-#else
-  NFC_TRACE_DEBUG2("nfc_set_state %d->%d", nfc_cb.nfc_state, nfc_state);
-#endif
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_set_state %d (%s)->%d (%s)", nfc_cb.nfc_state,
+                   nfc_state_name(nfc_cb.nfc_state).c_str(), nfc_state,
+                   nfc_state_name(nfc_state).c_str());
   nfc_cb.nfc_state = nfc_state;
 }
 
@@ -442,7 +449,7 @@ void nfc_gen_cleanup(void) {
 *******************************************************************************/
 void nfc_main_handle_hal_evt(tNFC_HAL_EVT_MSG* p_msg) {
   uint8_t* ps;
-  NFC_TRACE_DEBUG1("nfc_main_handle_hal_evt(): HAL event=0x%x", p_msg->hal_evt);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_main_handle_hal_evt(): HAL event=0x%x", p_msg->hal_evt);
 
   switch (p_msg->hal_evt) {
     case HAL_NFC_OPEN_CPLT_EVT: /* only for failure case */
@@ -574,18 +581,21 @@ void nfc_main_handle_hal_evt(tNFC_HAL_EVT_MSG* p_msg) {
             return;
           }
           break;
-
         default:
           break;
       }
       break;
+    case (uint32_t)NfcEvent::HCI_NETWORK_RESET:
+      delete_stack_non_volatile_store(true);
+      property_set("persist.nfc.hci_network_reset_req", "false");
+      break;
 #if (NXP_EXTNS == TRUE)
     case HAL_NFC_POST_MIN_INIT_CPLT_EVT:
       nfa_sys_cback_notify_MinEnable_complete(0);
       break;
 #endif
     default:
-      NFC_TRACE_ERROR1("nfc_main_handle_hal_evt (): unhandled event (0x%x).",
+      LOG(ERROR) << StringPrintf("nfc_main_handle_hal_evt (): unhandled event (0x%x).",
                        p_msg->hal_evt);
       break;
   }
@@ -603,7 +613,7 @@ void nfc_main_handle_hal_evt(tNFC_HAL_EVT_MSG* p_msg) {
 void nfc_main_flush_cmd_queue(void) {
   NFC_HDR* p_msg;
 
-  NFC_TRACE_DEBUG0("nfc_main_flush_cmd_queue ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_main_flush_cmd_queue ()");
 
   /* initialize command window */
   nfc_cb.nci_cmd_window = NCI_MAX_CMD_WINDOW;
@@ -646,7 +656,7 @@ void nfc_main_post_hal_evt(uint8_t hal_evt, tHAL_NFC_STATUS status) {
     p_msg->status = status;
     GKI_send_msg(NFC_TASK, NFC_MBOX_ID, p_msg);
   } else {
-    NFC_TRACE_ERROR0("nfc_main_post_hal_evt (): No buffer");
+    LOG(ERROR) << StringPrintf("nfc_main_post_hal_evt (): No buffer");
   }
 }
 
@@ -660,12 +670,8 @@ void nfc_main_post_hal_evt(uint8_t hal_evt, tHAL_NFC_STATUS status) {
 **
 *******************************************************************************/
 static void nfc_main_hal_cback(uint8_t event, tHAL_NFC_STATUS status) {
-#if (BT_TRACE_VERBOSE == true)
-  NFC_TRACE_DEBUG3("nfc_main_hal_cback event: %s(0x%x), status=%d",
-                   nfc_hal_event_name(event), event, status);
-#else
-  NFC_TRACE_DEBUG2("nfc_main_hal_cback event: 0x%x, status=%d", event, status);
-#endif
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_main_hal_cback event: %s(0x%x), status=%d",
+                   nfc_hal_event_name(event).c_str(), event, status);
 #if (NXP_EXTNS == TRUE)
   tNFC_RESPONSE eventData;
 #endif
@@ -684,7 +690,7 @@ static void nfc_main_hal_cback(uint8_t event, tHAL_NFC_STATUS status) {
           nfc_main_post_hal_evt(event, status);
         }
         nfa_ee_max_ee_cfg = nfcFL.nfccFL._NFA_EE_MAX_EE_SUPPORTED;
-        NFC_TRACE_DEBUG1("NFA_EE_MAX_EE_SUPPORTED to use %d", nfa_ee_max_ee_cfg);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFA_EE_MAX_EE_SUPPORTED to use %d", nfa_ee_max_ee_cfg);
       }
       break;
 
@@ -694,6 +700,7 @@ static void nfc_main_hal_cback(uint8_t event, tHAL_NFC_STATUS status) {
     case HAL_NFC_REQUEST_CONTROL_EVT:
     case HAL_NFC_RELEASE_CONTROL_EVT:
     case HAL_NFC_ERROR_EVT:
+    case (uint32_t)NfcEvent::HCI_NETWORK_RESET:
 #if (NXP_EXTNS == TRUE)
     case HAL_NFC_POST_MIN_INIT_CPLT_EVT:
         if( nfcFL.nfccFL._NFCC_I2C_READ_WRITE_IMPROVEMENT) {
@@ -714,11 +721,11 @@ static void nfc_main_hal_cback(uint8_t event, tHAL_NFC_STATUS status) {
       nfc_main_post_hal_evt(event, status);
       break;
     case HAL_NFC_ENABLE_I2C_FRAGMENTATION_EVT: {
-      NFC_TRACE_DEBUG1("nfc_main_hal_cback handled  event  %x", event);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_main_hal_cback handled  event  %x", event);
       set_i2c_fragmentation_enabled(I2C_FRAGMENATATION_ENABLED);
     } break;
     default:
-      NFC_TRACE_DEBUG1("nfc_main_hal_cback unhandled event %x", event);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_main_hal_cback unhandled event %x", event);
       break;
   }
 }
@@ -753,7 +760,7 @@ static void nfc_main_hal_data_cback(uint16_t data_len, uint8_t* p_data) {
 
       GKI_send_msg(NFC_TASK, NFC_MBOX_ID, p_msg);
     } else {
-      NFC_TRACE_ERROR0("nfc_main_hal_data_cback (): No buffer");
+      LOG(ERROR) << StringPrintf("nfc_main_hal_data_cback (): No buffer");
     }
   }
 }
@@ -782,7 +789,7 @@ static void nfc_main_hal_data_cback(uint16_t data_len, uint8_t* p_data) {
 **
 *******************************************************************************/
 tNFC_STATUS NFC_Enable(tNFC_RESPONSE_CBACK* p_cback) {
-  NFC_TRACE_API0("NFC_Enable ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_Enable ()");
 
   /* Validate callback */
   if (!p_cback) {
@@ -819,7 +826,12 @@ tNFC_STATUS NFC_Enable(tNFC_RESPONSE_CBACK* p_cback) {
 **
 *******************************************************************************/
 void NFC_Disable(void) {
-  NFC_TRACE_API1("NFC_Disable (): nfc_state = %d", nfc_cb.nfc_state);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_Disable (): nfc_state = %d", nfc_cb.nfc_state);
+
+#if (NXP_EXTNS == TRUE)
+  if(nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME == nfcFL.eseFL._ESE_WIRED_MODE_RESUME)
+    nfc_stop_timer(&nfc_cb.rf_filed_event_timeout_timer);
+#endif
 
   if ((nfc_cb.nfc_state == NFC_STATE_NONE) ||
       (nfc_cb.nfc_state == NFC_STATE_NFCC_POWER_OFF_SLEEP)) {
@@ -838,19 +850,6 @@ void NFC_Disable(void) {
     nfc_cb.p_hal->ioctl(HAL_NFC_IOCTL_SET_BOOT_MODE, (void*)&inpOutData);
   }
 #endif
-
-  if(nfcFL.nfcNxpEse) {
-      tNFC_STATUS setPidStatus = NFC_STATUS_OK;
-      nfc_nci_IoctlInOutData_t inpOutData;
-      inpOutData.inp.data.nfcServicePid = 0;
-      setPidStatus = nfc_cb.p_hal->ioctl(HAL_NFC_IOCTL_SET_NFC_SERVICE_PID,(void*)&inpOutData);
-      if (setPidStatus == NFC_STATUS_OK) {
-          NFC_TRACE_API0("nfc service set pid done");
-      } else {
-          NFC_TRACE_API0("nfc service set pid failed");
-      }
-  }
-
   /* Close transport and clean up */
   nfc_task_shutdown_nfcc();
 
@@ -899,7 +898,6 @@ void NFC_Init(tHAL_NFC_ENTRY* p_hal_entry_tbl)
   }
 
   nfc_cb.num_disc_maps = NFC_NUM_INTERFACE_MAP;
-  nfc_cb.trace_level = NFC_INITIAL_TRACE_LEVEL;
   nfc_cb.nci_ctrl_size = NCI_CTRL_INIT_SIZE;
   nfc_cb.reassembly = true;
   nfc_cb.nci_version = NCI_VERSION_UNKNOWN;
@@ -915,6 +913,7 @@ void NFC_Init(tHAL_NFC_ENTRY* p_hal_entry_tbl)
   nfc_cb.bCeActivatedeSE = false;
   nfc_cb.pwr_link_cmd.bPwrLinkCmdRequested = false;
   nfc_cb.bBlkPwrlinkAndModeSetCmd = false;
+  nfc_cb.isLowRam = p_hal_entry_cntxt->isLowRam;
   if (p_hal_entry_cntxt->boot_mode != NFC_FAST_BOOT_MODE)
 #endif
   {
@@ -955,9 +954,7 @@ uint16_t NFC_GetLmrtSize(void) {
 ** Returns          NCI version NCI2.0 / NCI1.0
 **
 *******************************************************************************/
-uint8_t NFC_GetNCIVersion() {
-  return nfc_cb.nci_version;
-}
+uint8_t NFC_GetNCIVersion() { return nfc_cb.nci_version; }
 
 /*******************************************************************************
 **
@@ -1022,7 +1019,7 @@ tNFC_STATUS NFC_DiscoveryMap(uint8_t num, tNFC_DISCOVER_MAPS* p_maps,
 #endif
   nfc_cb.p_discv_cback = p_cback;
   num_intf = 0;
-  NFC_TRACE_DEBUG2("nci_interfaces supported by NFCC: 0x%x num = 0x%x",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nci_interfaces supported by NFCC: 0x%x num = 0x%x",
                    nfc_cb.nci_interfaces, num);
 
   for (xx = 0; xx < NFC_NFCC_MAX_NUM_VS_INTERFACE + NCI_INTERFACE_MAX; xx++) {
@@ -1045,25 +1042,25 @@ tNFC_STATUS NFC_DiscoveryMap(uint8_t num, tNFC_DISCOVER_MAPS* p_maps,
                 }
             }
         }
-        NFC_TRACE_DEBUG3("[%d]: vs intf_type:0x%x is_supported:%d", xx,
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("[%d]: vs intf_type:0x%x is_supported:%d", xx,
                 p_maps[xx].intf_type, is_supported);
     } else {
       intf_mask = (1 << (p_maps[xx].intf_type));
       if ((intf_mask & nfc_cb.nci_interfaces)) {
         is_supported = true;
       }
-      NFC_TRACE_DEBUG4("[%d]: intf_type:%d intf_mask: 0x%x is_supported:%d", xx,
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("[%d]: intf_type:%d intf_mask: 0x%x is_supported:%d", xx,
                        p_maps[xx].intf_type, intf_mask, is_supported);
     }
     if (is_supported) {
       if (num_intf < (NFC_NFCC_MAX_NUM_VS_INTERFACE + NCI_INTERFACE_MAX)) {
         memcpy(&max_maps[num_intf++], &p_maps[xx], sizeof(tNFC_DISCOVER_MAPS));
       } else {
-        NFC_TRACE_DEBUG1("num_intf exeeds the limit 0x%02x",
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("num_intf exeeds the limit 0x%02x",
                          NFC_NFCC_MAX_NUM_VS_INTERFACE + NCI_INTERFACE_MAX);
       }
     } else {
-      NFC_TRACE_WARNING1(
+      LOG(WARNING) << StringPrintf(
           "NFC_DiscoveryMap interface=0x%x is not supported by NFCC",
           p_maps[xx].intf_type);
       if(nfcFL.chipType != pn547C2) {
@@ -1072,13 +1069,13 @@ tNFC_STATUS NFC_DiscoveryMap(uint8_t num, tNFC_DISCOVER_MAPS* p_maps,
     }
   }
 
-  NFC_TRACE_WARNING1("num_intf = 0x%2x", num_intf);
+  LOG(WARNING) << StringPrintf("num_intf = 0x%2x", num_intf);
 
   for (xx = 0; xx < NFC_NFCC_MAX_NUM_VS_INTERFACE + NCI_INTERFACE_MAX; xx++) {
-    NFC_TRACE_WARNING2("max_maps[%d].intf_type = 0x%2x", xx,
+    LOG(WARNING) << StringPrintf("max_maps[%d].intf_type = 0x%2x", xx,
                        max_maps[xx].intf_type);
-    NFC_TRACE_WARNING2("max_maps[%d].mode = 0x%2x", xx, max_maps[xx].mode);
-    NFC_TRACE_WARNING2("max_maps[%d].protocol = 0x%2x", xx,
+    LOG(WARNING) << StringPrintf("max_maps[%d].mode = 0x%2x", xx, max_maps[xx].mode);
+    LOG(WARNING) << StringPrintf("max_maps[%d].protocol = 0x%2x", xx,
                        max_maps[xx].protocol);
   }
   return nci_snd_discover_map_cmd(num_intf, (tNCI_DISCOVER_MAPS*)max_maps);
@@ -1107,9 +1104,9 @@ tNFC_STATUS NFC_DiscoveryStart(uint8_t num_params,
   int params_size;
   tNFC_STATUS status = NFC_STATUS_NO_BUFFERS;
 
-  NFC_TRACE_API0("NFC_DiscoveryStart");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_DiscoveryStart");
   if (nfc_cb.p_disc_pending) {
-    NFC_TRACE_ERROR0("There's pending NFC_DiscoveryStart");
+    LOG(ERROR) << StringPrintf("There's pending NFC_DiscoveryStart");
     status = NFC_STATUS_BUSY;
   } else {
     nfc_cb.p_discv_cback = p_cback;
@@ -1128,7 +1125,7 @@ tNFC_STATUS NFC_DiscoveryStart(uint8_t num_params,
     }
   }
 
-  NFC_TRACE_API1("NFC_DiscoveryStart status: 0x%x", status);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_DiscoveryStart status: 0x%x", status);
   return status;
 }
 
@@ -1292,7 +1289,6 @@ tNFC_STATUS NFC_SendData(uint8_t conn_id, NFC_HDR* p_data) {
       p_data->offset >= NCI_MSG_OFFSET_SIZE + NCI_DATA_HDR_SIZE) {
     status = nfc_ncif_send_data(p_cb, p_data);
   }
-
   if (status != NFC_STATUS_OK) GKI_freebuf(p_data);
 
   return status;
@@ -1363,13 +1359,8 @@ tNFC_STATUS NFC_Deactivate(tNFC_DEACT_TYPE deactivate_type) {
   tNFC_CONN_CB* p_cb = &nfc_cb.conn_cb[NFC_RF_CONN_ID];
   tNFC_STATUS status = NFC_STATUS_OK;
 
-#if (BT_TRACE_VERBOSE == true)
-  NFC_TRACE_API3("NFC_Deactivate %d (%s) deactivate_type:%d", nfc_cb.nfc_state,
-                 nfc_state_name(nfc_cb.nfc_state), deactivate_type);
-#else
-    NFC_TRACE_API2("NFC_Deactivate %d deactivate_type:%d", nfc_cb.nfc_state,
-                   deactivate_type);
-#endif
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_Deactivate %d (%s) deactivate_type:%d", nfc_cb.nfc_state,
+                 nfc_state_name(nfc_cb.nfc_state).c_str(), deactivate_type);
 
   if (nfc_cb.flags & NFC_FL_DISCOVER_PENDING) {
     /* the HAL pre-discover is still active - clear the pending flag */
@@ -1384,6 +1375,7 @@ tNFC_STATUS NFC_Deactivate(tNFC_DEACT_TYPE deactivate_type) {
       nfc_cb.p_last_disc = NULL;
     }
     nfc_cb.p_last_disc = nfc_cb.p_disc_pending;
+    nfa_dm_cb.disc_cb.disc_flags &= ~NFA_DM_DISC_FLAGS_W4_RSP;
 #else
       GKI_freebuf(nfc_cb.p_disc_pending);
 #endif
@@ -1393,7 +1385,7 @@ tNFC_STATUS NFC_Deactivate(tNFC_DEACT_TYPE deactivate_type) {
 
   if (nfc_cb.nfc_state == NFC_STATE_OPEN) {
     nfc_set_state(NFC_STATE_CLOSING);
-    NFC_TRACE_DEBUG3("act_protocol %d credits:%d/%d", p_cb->act_protocol,
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("act_protocol %d credits:%d/%d", p_cb->act_protocol,
                      p_cb->init_credits, p_cb->num_buff);
     if ((p_cb->act_protocol == NCI_PROTOCOL_NFC_DEP) &&
         (p_cb->init_credits != p_cb->num_buff)) {
@@ -1409,7 +1401,22 @@ tNFC_STATUS NFC_Deactivate(tNFC_DEACT_TYPE deactivate_type) {
   status = nci_snd_deactivate_cmd(deactivate_type);
   return status;
 }
-
+/*******************************************************************************
+**
+** Function         NFC_SetPowerSubState
+**
+** Description      This function is called to send the power sub state (screen
+**                  state) to NFCC. The response from NFCC is reported by
+**                  tNFC_RESPONSE_CBACK as NFC_SET_POWER_STATE_REVT.
+**
+** Parameters       scree_state
+**
+** Returns          tNFC_STATUS
+**
+*******************************************************************************/
+tNFC_STATUS NFC_SetPowerSubState(uint8_t screen_state) {
+  return nci_snd_core_set_power_sub_state(screen_state);
+}
 /*******************************************************************************
 **
 ** Function         NFC_UpdateRFCommParams
@@ -1479,7 +1486,7 @@ tNFC_STATUS NFC_UpdateRFCommParams(tNFC_RF_COMM_PARAMS* p_params) {
 **
 *******************************************************************************/
 tNFC_STATUS NFC_SetPowerOffSleep(bool enable) {
-  NFC_TRACE_API1("NFC_SetPowerOffSleep () enable = %d", enable);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_SetPowerOffSleep () enable = %d", enable);
 
   if ((enable == false) &&
       (nfc_cb.nfc_state == NFC_STATE_NFCC_POWER_OFF_SLEEP)) {
@@ -1498,28 +1505,11 @@ tNFC_STATUS NFC_SetPowerOffSleep(bool enable) {
     return NFC_STATUS_OK;
   }
 
-  NFC_TRACE_ERROR1("NFC_SetPowerOffSleep () invalid state = %d",
+  LOG(ERROR) << StringPrintf("NFC_SetPowerOffSleep () invalid state = %d",
                    nfc_cb.nfc_state);
   return NFC_STATUS_FAILED;
 }
 
-/*******************************************************************************
-**
-** Function         NFC_SetPowerSubState
-**
-** Description      This function is called to send the power sub state( screen state)
-**                      to NFCC. The response from NFCC is reported by
-**                  tNFC_RESPONSE_CBACK as NFC_SET_POWER_STATE_REVT.
-**
-** Parameters       scree_state
-**
-** Returns          tNFC_STATUS
-**
-*******************************************************************************/
-tNFC_STATUS NFC_SetPowerSubState (uint8_t screen_state)
-{
-  return nci_snd_core_set_power_sub_state(screen_state);
-}
 /*******************************************************************************
 **
 ** Function         NFC_PowerCycleNFCC
@@ -1530,7 +1520,7 @@ tNFC_STATUS NFC_SetPowerSubState (uint8_t screen_state)
 **
 *******************************************************************************/
 tNFC_STATUS NFC_PowerCycleNFCC(void) {
-  NFC_TRACE_API0("NFC_PowerCycleNFCC ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_PowerCycleNFCC ()");
 
   if (nfc_cb.nfc_state == NFC_STATE_IDLE) {
     /* power cycle NFCC */
@@ -1540,28 +1530,11 @@ tNFC_STATUS NFC_PowerCycleNFCC(void) {
     return NFC_STATUS_OK;
   }
 
-  NFC_TRACE_ERROR1("NFC_PowerCycleNFCC () invalid state = %d",
+  LOG(ERROR) << StringPrintf("NFC_PowerCycleNFCC () invalid state = %d",
                    nfc_cb.nfc_state);
   return NFC_STATUS_FAILED;
 }
 
-/*******************************************************************************
-**
-** Function         NFC_SetTraceLevel
-**
-** Description      This function sets the trace level for NFC.  If called with
-**                  a value of 0xFF, it simply returns the current trace level.
-**
-** Returns          The new or current trace level
-**
-*******************************************************************************/
-uint8_t NFC_SetTraceLevel(uint8_t new_level) {
-  NFC_TRACE_API1("NFC_SetTraceLevel () new_level = %d", new_level);
-
-  if (new_level != 0xFF) nfc_cb.trace_level = new_level;
-
-  return (nfc_cb.trace_level);
-}
 void set_i2c_fragmentation_enabled(int value) {
   i2c_fragmentation_enabled = value;
 }
@@ -1580,10 +1553,10 @@ int get_i2c_fragmentation_enabled() { return i2c_fragmentation_enabled; }
 **
 *******************************************************************************/
 int32_t NFC_ReqWiredAccess(void* pdata) {
-    NFC_TRACE_API0("NFC_ReqWiredAccess");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_ReqWiredAccess");
 
     if(!nfcFL.nfcNxpEse) {
-        NFC_TRACE_API0("nfcNxpEse is not available.. Returning");
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfcNxpEse is not available.. Returning");
         return -1;
     }
   nfc_nci_IoctlInOutData_t inpOutData;
@@ -1660,6 +1633,42 @@ int32_t NFC_EnableWired(void* pdata) {
   *(tNFC_STATUS*)pdata = inpOutData.out.data.status;
   return status;
 }
+
+/*******************************************************************************
+**
+** Function         NFC_ReleaseEsePwr
+**
+** Description      This function request to pn553 driver to
+**                  turn ese vdd gpio low
+**
+** Returns          0 if api call success, else -1
+**
+*******************************************************************************/
+int32_t NFC_ReleaseEsePwr(void* pdata) {
+  nfc_nci_IoctlInOutData_t inpOutData;
+  int32_t status;
+  status = nfc_cb.p_hal->ioctl(HAL_NFC_IOCTL_P61_REL_ESE_PWR, &inpOutData);
+  *(tNFC_STATUS*)pdata = inpOutData.out.data.status;
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function         NFC_AcquireEsePwr
+**
+** Description      This function request to pn553 driver to
+**                  turn ese vdd gpio high
+**
+** Returns          0 if api call success, else -1
+**
+*******************************************************************************/
+int32_t NFC_AcquireEsePwr(void* pdata) {
+  nfc_nci_IoctlInOutData_t inpOutData;
+  int32_t status;
+  status = nfc_cb.p_hal->ioctl(HAL_NFC_IOCTL_P61_SET_ESE_PWR, &inpOutData);
+  *(tNFC_STATUS*)pdata = inpOutData.out.data.status;
+  return status;
+}
 #if (NXP_EXTNS == TRUE)
 /*******************************************************************************
 +**
@@ -1680,7 +1689,7 @@ NFCEEs.
 *******************************************************************************/
 tNFC_STATUS NFC_Nfcee_PwrLinkCtrl(uint8_t nfcee_id, uint8_t cfg_value) {
     if(!nfcFL.eseFL._WIRED_MODE_STANDBY) {
-        NFC_TRACE_API0("NFC_Nfcee_PwrLinkCtrl :"
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_Nfcee_PwrLinkCtrl :"
                 "WIRED_MODE_STANDBY is not available.. Returning");
         return NFC_STATUS_FAILED;
     }
@@ -1699,17 +1708,16 @@ tNFC_STATUS NFC_Nfcee_PwrLinkCtrl(uint8_t nfcee_id, uint8_t cfg_value) {
 *******************************************************************************/
 int32_t NFC_SetP61Status(void* pdata, jcop_dwnld_state_t isJcopState) {
     if(!nfcFL.eseFL._ESE_JCOP_DWNLD_PROTECTION) {
-        NFC_TRACE_API0("NFC_SetP61Status :"
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_SetP61Status :"
                 "ESE_JCOP_DWNLD_PROTECTION is not available.. Returning");
         return -1;
     }
   nfc_nci_IoctlInOutData_t inpOutData;
-  int32_t status;
   if (isJcopState == JCP_DWNLD_START)
-    isJcopState =
+    isJcopState =(jcop_dwnld_state_t)
         nfc_cb.p_hal->ioctl(HAL_NFC_IOCTL_SET_JCP_DWNLD_ENABLE, &inpOutData);
   else if (isJcopState == JCP_DWP_DWNLD_COMPLETE)
-    isJcopState =
+    isJcopState =(jcop_dwnld_state_t)
         (nfc_cb.p_hal->ioctl(HAL_NFC_IOCTL_SET_JCP_DWNLD_DISABLE, &inpOutData));
   *(tNFC_STATUS*)pdata = inpOutData.out.data.status;
   return isJcopState;
@@ -1746,10 +1754,10 @@ int32_t NFC_eSEChipReset(void* pdata) {
 **
 *******************************************************************************/
 int32_t NFC_GetEseAccess(void* pdata) {
-    int32_t status;
+    int32_t status = NFC_STATUS_EPERM;
     if((nfcFL.eseFL._NXP_ESE_VER != JCOP_VER_3_1) &&
             (nfcFL.eseFL._NXP_ESE_VER != JCOP_VER_3_2)) {
-        NFC_TRACE_API0("NFC_GetEseAccess NXP_ESE_VER !="
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_GetEseAccess NXP_ESE_VER !="
                 "JCOP_VER_3_1 or JCOP_VER_3_2 . Returning");
         return status;
     }
@@ -1770,10 +1778,10 @@ int32_t NFC_GetEseAccess(void* pdata) {
 **
 *******************************************************************************/
 int32_t NFC_RelEseAccess(void* pdata) {
-    int32_t status;
+    int32_t status = NFC_STATUS_EPERM;
     if((nfcFL.eseFL._NXP_ESE_VER != JCOP_VER_3_1) &&
             (nfcFL.eseFL._NXP_ESE_VER != JCOP_VER_3_2)) {
-        NFC_TRACE_API0("NFC_RelEseAccess NXP_ESE_VER !="
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_RelEseAccess NXP_ESE_VER !="
                 "JCOP_VER_3_1 or JCOP_VER_3_2 . Returning");
         return status;
     }
@@ -1796,17 +1804,33 @@ int32_t NFC_RelEseAccess(void* pdata) {
 *******************************************************************************/
 int32_t NFC_RelSvddWait(void* pdata) {
     if(!nfcFL.eseFL._ESE_SVDD_SYNC) {
-        NFC_TRACE_API0("NFC_RelSvddWait :"
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_RelSvddWait :"
                 "ESE_SVDD_SYNC is not available.. Returning");
-        return -1;
+        return NFC_STATUS_EPERM;
     }
   nfc_nci_IoctlInOutData_t inpOutData;
+  inpOutData.inp.level = *(uint32_t*)pdata;
   int32_t status;
   status = nfc_cb.p_hal->ioctl(HAL_NFC_IOCTL_REL_SVDD_WAIT, &inpOutData);
   *(tNFC_STATUS*)pdata = inpOutData.out.data.status;
   return status;
 }
-
+/*******************************************************************************
+**
+** Function         NFC_RelForceDwpOnOffWait
+**
+** Description      This function release wait for DWP On/Off
+**                  of P73. Status would be updated to pdata
+**
+** Returns          0 if api call success, else -1
+**
+*******************************************************************************/
+int32_t NFC_RelForceDwpOnOffWait (void *pdata)
+{
+  nfc_nci_IoctlInOutData_t inpOutData;
+  inpOutData.inp.level = *(uint32_t*)pdata;
+  return (nfc_cb.p_hal->ioctl(HAL_NFC_IOCTL_REL_DWP_WAIT, &inpOutData));
+}
 #endif
 
 #if (NXP_EXTNS == TRUE)
@@ -1839,13 +1863,17 @@ void NFC_EnableDisableHalLog(uint8_t type) {
 int32_t NFC_SetNfcServicePid() {
     tNFC_STATUS setPidStatus = NFC_STATUS_OK;
     nfc_nci_IoctlInOutData_t inpOutData;
+    if(NFC_IsLowRamDevice()) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_SetNfcServicePid: Not valid for low RAM device");
+      return setPidStatus;
+    }
     inpOutData.inp.data.nfcServicePid = getpid();
     setPidStatus = nfc_cb.p_hal->ioctl(HAL_NFC_IOCTL_SET_NFC_SERVICE_PID,
                                        (void*)&inpOutData);
     if (setPidStatus == NFC_STATUS_OK) {
-      NFC_TRACE_API0("nfc service set pid done");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc service set pid done");
     } else {
-      NFC_TRACE_API0("nfc service set pid failed");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc service set pid failed");
     }
   return setPidStatus;
 }
@@ -1864,30 +1892,50 @@ int32_t NFC_ResetNfcServicePid()
     tNFC_STATUS setPidStatus = NFC_STATUS_OK;
     nfc_nci_IoctlInOutData_t inpOutData;
     inpOutData.inp.data.nfcServicePid = 0;
+    if(NFC_IsLowRamDevice()) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_ResetNfcServicePid: Not valid for low RAM device");
+      return setPidStatus;
+    }
     setPidStatus = nfc_cb.p_hal->ioctl(HAL_NFC_IOCTL_SET_NFC_SERVICE_PID,
                                        (void*)&inpOutData);
     if (setPidStatus == NFC_STATUS_OK) {
-      NFC_TRACE_API0("nfc service set pid done");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc service set pid done");
     } else {
-      NFC_TRACE_API0("nfc service set pid failed");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc service set pid failed");
     }
     return setPidStatus;
 }
+
+/*******************************************************************************
+**
+** Function         NFC_IsLowRamDevice
+**
+** Description      This function provides low_ram is enabled or not
+**
+** Returns          true or false
+**
+*******************************************************************************/
+bool NFC_IsLowRamDevice()
+{
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_IsLowRamDevice: %s",nfc_cb.isLowRam?"true":"false");
+  return nfc_cb.isLowRam;
+}
 #endif
 /*******************************************************************************
 **
 ** Function         NFC_ISODEPNakPresCheck
 **
-** Description      This function is called to send the ISO DEP nak presenc check cmd
-**                  to check that the remote end point in RF field.
+** Description      This function is called to send the ISO DEP nak presenc
+**                  check cmd to check that the remote end point in RF field.
 **
-**                  The response from NFCC is reported by call back.The ntf indicates
-**                  success if card is present in field or failed if card is lost.
+**                  The response from NFCC is reported by call back.The ntf
+**                  indicates success if card is present in field or failed
+**                  if card is lost.
 **
 ** Returns          tNFC_STATUS
 **
 *******************************************************************************/
-tNFC_STATUS NFC_ISODEPNakPresCheck () {
+tNFC_STATUS NFC_ISODEPNakPresCheck() {
   return nci_snd_iso_dep_nak_presence_check_cmd();
 }
 /*******************************************************************************
@@ -1904,14 +1952,14 @@ tNFC_STATUS NFC_ISODEPNakPresCheck () {
 *******************************************************************************/
 void NFC_SetStaticHciCback (tNFC_CONN_CBACK    *p_cback)
 {
-    NFC_TRACE_API1("NFC_SetStaticHciCback () evt_data.conn_create.dest_type  = %d", NCI_DEST_TYPE_NFCEE);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_SetStaticHciCback () evt_data.conn_create.dest_type  = %d", NCI_DEST_TYPE_NFCEE);
     tNFC_CONN_CB * p_cb = &nfc_cb.conn_cb[NFC_HCI_CONN_ID];
     tNFC_CONN   evt_data;
 
     p_cb->p_cback = p_cback;
     if (p_cback && p_cb->buff_size && p_cb->num_buff)
     {
-        NFC_TRACE_API1("NFC_SetStaticHciCback 2 () evt_data.conn_create.dest_type  = %d", NCI_DEST_TYPE_NFCEE);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_SetStaticHciCback 2 () evt_data.conn_create.dest_type  = %d", NCI_DEST_TYPE_NFCEE);
         evt_data.conn_create.status         = NFC_STATUS_OK;
         evt_data.conn_create.dest_type      = NCI_DEST_TYPE_NFCEE;
         evt_data.conn_create.id             = p_cb->id;
@@ -1932,20 +1980,20 @@ void NFC_SetStaticHciCback (tNFC_CONN_CBACK    *p_cback)
  ** Returns          Nothing
  *******************************************************************************/
 void NFC_GetFeatureList() {
-    NFC_TRACE_API0("NFC_GetFeatureList() Enter");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_GetFeatureList() Enter");
     tNFC_STATUS status = NFC_STATUS_FAILED;
     nfc_nci_IoctlInOutData_t inpOutData;
     status = nfc_cb.p_hal->ioctl(HAL_NFC_IOCTL_GET_FEATURE_LIST,
             (void*)&inpOutData);
     if(status == NFC_STATUS_OK) {
         chipType = (tNFC_chipType)inpOutData.out.data.chipType;
-        NFC_TRACE_API1("NFC_GetFeatureList ()chipType = %d", chipType);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_GetFeatureList ()chipType = %d", chipType);
 
     }else{
         chipType = pn553;
     }
     CONFIGURE_FEATURELIST(chipType);
-    NFC_TRACE_API1("NFC_GetFeatureList ()chipType = %d", chipType);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_GetFeatureList ()chipType = %d", chipType);
 
 }
 
@@ -1960,7 +2008,6 @@ tNFC_chipType NFC_GetChipType() {
     return chipType;
 }
 
-#if (BT_TRACE_VERBOSE == true)
 /*******************************************************************************
 **
 ** Function         NFC_GetStatusName
@@ -1972,7 +2019,7 @@ tNFC_chipType NFC_GetChipType() {
 ** Returns          pointer to the name
 **
 *******************************************************************************/
-char* NFC_GetStatusName(tNFC_STATUS status) {
+std::string NFC_GetStatusName(tNFC_STATUS status) {
   switch (status) {
     case NFC_STATUS_OK:
       return "OK";
@@ -2048,4 +2095,3 @@ char* NFC_GetStatusName(tNFC_STATUS status) {
       return "UNKNOWN";
   }
 }
-#endif
diff --git a/src/nfc/nfc/nfc_ncif.c b/src/nfc/nfc/nfc_ncif.cc
old mode 100644
new mode 100755
similarity index 78%
rename from src/nfc/nfc/nfc_ncif.c
rename to src/nfc/nfc/nfc_ncif.cc
index aa001e5..91be27f
--- a/src/nfc/nfc/nfc_ncif.c
+++ b/src/nfc/nfc/nfc_ncif.cc
@@ -3,7 +3,7 @@
  *  Copyright (c) 2016, The Linux Foundation. All rights reserved.
  *  Not a Contribution.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *  The original Work has been changed by NXP Semiconductors.
  *
  *  Copyright (C) 1999-2014 Broadcom Corporation
@@ -29,57 +29,122 @@
  *  (callback). On the transmit side, it manages the command transmission.
  *
  ******************************************************************************/
-#include <string.h>
-#include <stdlib.h>
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+#include <metricslogger/metrics_logger.h>
+
 #include "nfc_target.h"
 
-#include "nfc_hal_api.h"
-#include "nfc_api.h"
+#include <sys/stat.h>
+#ifdef ENABLE_ESE_CLIENT
+#include "hal_nxpese.h"
+#endif
+#include "include/debug_nfcsnoop.h"
 #include "nci_defs.h"
 #include "nci_hmsgs.h"
+#include "nfc_api.h"
+#include "nfc_hal_api.h"
 #include "nfc_int.h"
 #include "rw_api.h"
 #include "rw_int.h"
-#include "nfc_hal_api.h"
-
 #if (NXP_EXTNS == TRUE)
 #include "nfa_ce_int.h"
 #include "nfa_sys.h"
 #include "nfa_dm_int.h"
 #include "nfa_hci_int.h"
-#include <config.h>
+#include <nfc_config.h>
 #endif
+
+using android::base::StringPrintf;
+
 tNFC_CONN_CB* p_cb_stored = NULL;
 #if (NFC_RW_ONLY == FALSE)
 static const uint8_t nfc_mpl_code_to_size[] = {64, 128, 192, 254};
 
 #endif /* NFC_RW_ONLY */
-
+#if (NXP_EXTNS == TRUE || APPL_DTA_MODE == TRUE)
+// Global Structure varibale for FW Version
+static tNFC_FW_VERSION nfc_fw_version;
+#endif
 #if (NXP_EXTNS == TRUE)
 #define NFC_NCI_WAIT_DATA_NTF_TOUT 2
 #define NFC_NCI_RFFIELD_EVT_TIMEOUT 2
 uint8_t temp_buff[660];
 #endif
-
 #define NFC_PB_ATTRIB_REQ_FIXED_BYTES 1
 #define NFC_LB_ATTRIB_REQ_FIXED_BYTES 8
 
+extern unsigned char appl_dta_mode_flag;
+extern bool nfc_debug_enabled;
+
 #if (NXP_EXTNS == TRUE)
 // Global Structure varibale for FW Version
-static tNFC_FW_VERSION nfc_fw_version;
 static uint8_t gScreenState = 0x0;  // SCREEN ON UNLOCKED
 static uint16_t maxRoutingTableSize;
 uint8_t sListenActivated;
 extern tNFA_CE_CB nfa_ce_cb;
+extern bool MW_RCVRY_FW_DNLD_ALLOWED;
 bool core_reset_init_num_buff = false;
 uint8_t nfcc_dh_conn_id = 0xFF;
-extern void nfa_hci_rsp_timeout(tNFA_HCI_EVENT_DATA* p_evt_data);
+extern void nfa_hci_rsp_timeout();
 void disc_deact_ntf_timeout_handler(tNFC_RESPONSE_EVT event);
 extern bool etsi_reader_in_progress;
 void uicc_eeprom_get_config(uint8_t* config_resp);
 void uicc_eeprom_set_config(uint8_t* config_resp);
 #endif
 
+/*******************************************************************************
+**
+** Function         nfc_hal_nfcc_get_reset_info
+**
+** Description      Register dump when CORE_RESET_NTF happens
+**
+** Returns          status of command transceive
+**
+*******************************************************************************/
+uint8_t nfc_hal_nfcc_get_reset_info(void) {
+  nfc_nci_IoctlInOutData_t inpOutData;
+  /*NCI_RESET_CMD*/
+  uint8_t nfc_hal_nfcc_get_reset_info[6][6] = {
+      {
+       0x20, 0x00, 0x01, 0x00,
+      },
+      {
+       0x20, 0x01, 0x00,
+      },
+      {0x20, 0x03, 0x03, 0x01, 0xA0, 0x1A},
+      {0x20, 0x03, 0x03, 0x01, 0xA0, 0x1B},
+      {0x20, 0x03, 0x03, 0x01, 0xA0, 0x1C},
+      {0x20, 0x03, 0x03, 0x01, 0xA0, 0x27}};
+  uint8_t core_status = NCI_STATUS_FAILED;
+  uint8_t retry_count = 0;
+  uint8_t i = 0, j = 0;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s Enter", __func__);
+
+  for (i = 0; i < 6; i++) {
+    memset(&inpOutData, 0x00, sizeof(nfc_nci_IoctlInOutData_t));
+    inpOutData.inp.data.nciCmd.cmd_len = nfc_hal_nfcc_get_reset_info[i][2] + 3;
+    memcpy(inpOutData.inp.data.nciCmd.p_cmd,
+           (uint8_t*)&nfc_hal_nfcc_get_reset_info[i],
+           nfc_hal_nfcc_get_reset_info[i][2] + 3);
+    do {
+      core_status =
+          nfc_cb.p_hal->ioctl(HAL_NFC_IOCTL_NCI_TRANSCEIVE, &inpOutData);
+      retry_count++;
+    } while (NCI_STATUS_OK != core_status &&
+             retry_count < (NFC_NFCC_INIT_MAX_RETRY + 1));
+    if (core_status == NCI_STATUS_OK) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+          "%s No.%d response for nfc_hal_nfcc_get_reset_info", __func__, i);
+      for (j = 0; j < inpOutData.out.data.nciRsp.rsp_len; j++) {
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            " %s 0x%02x", __func__, inpOutData.out.data.nciRsp.p_rsp[j]);
+      }
+    }
+  }
+  return core_status;
+}
+
 /*******************************************************************************
 **
 ** Function         nfc_ncif_update_window
@@ -93,7 +158,7 @@ void nfc_ncif_update_window(void) {
   /* Sanity check - see if we were expecting a update_window */
   if (nfc_cb.nci_cmd_window == NCI_MAX_CMD_WINDOW) {
     if (nfc_cb.nfc_state != NFC_STATE_W4_HAL_CLOSE) {
-      NFC_TRACE_ERROR0("nfc_ncif_update_window: Unexpected call");
+      LOG(ERROR) << StringPrintf("nfc_ncif_update_window: Unexpected call");
     }
     return;
   }
@@ -119,7 +184,7 @@ void nfc_ncif_update_window(void) {
 *********************************************************************************/
 void nfc_ncif_update_data_queue(void) {
   nfc_cb.nci_cmd_window++;
-  NFC_TRACE_ERROR0("nfc_ncif_update_data_queue- incrementing window");
+  LOG(ERROR) << StringPrintf("nfc_ncif_update_data_queue- incrementing window");
   /* Check if there were any commands waiting to be sent */
   nfc_ncif_check_cmd_queue(NULL);
 }
@@ -133,10 +198,10 @@ void nfc_ncif_update_data_queue(void) {
 **
 *******************************************************************************/
 void nfc_ncif_cmd_timeout(void) {
-  NFC_TRACE_DEBUG0("nfc_ncif_cmd_timeout(): enter");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_ncif_cmd_timeout(): enter");
 
 #if (NXP_EXTNS == TRUE)
-  NFC_TRACE_DEBUG0("Start Middleware Recovery Procedure");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Start Middleware Recovery Procedure");
   {
     // TO DO:
     // Sending command which are core_reset,init,discovery as raw packet (Hard
@@ -176,7 +241,7 @@ void nfc_ncif_cmd_timeout(void) {
     buffer = (uint8_t*)malloc(bufflen * sizeof(uint8_t));
 
     if (NULL == buffer) {
-      NFC_TRACE_ERROR0("Recovery MEM Allocation is failed!!");
+      LOG(ERROR) << StringPrintf("Recovery MEM Allocation is failed!!");
       return;
     }
     memset(buffer, 0x00, (bufflen * sizeof(uint8_t)));
@@ -187,45 +252,55 @@ void nfc_ncif_cmd_timeout(void) {
     /*Set the last screen state*/
     buffer[295] = gScreenState;
 
-    NFC_TRACE_DEBUG1("MW last RF discovery flags 0x%x",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("MW last RF discovery flags 0x%x",
                      nfa_dm_cb.disc_cb.disc_flags);
-    NFC_TRACE_DEBUG1("MW last RF discovery state 0x%x",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("MW last RF discovery state 0x%x",
                      nfa_dm_cb.disc_cb.disc_state);
 
     if (nfc_cb.nfc_state == NFC_STATE_CORE_INIT) {
 #if (NXP_EXTNS == TRUE)
         if(nfcFL.nfccFL._NFCC_MW_RCVRY_BLK_FW_DNLD) {
-            NFC_TRACE_DEBUG0(
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
                     "MW recovery should abort FW download checking at time of "
                     "cmd_timeout");
         }
         else {
-            NFC_TRACE_DEBUG0("Force FW Download !");
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Force FW Download !");
             nfc_cb.p_hal->ioctl(HAL_NFC_IOCTL_CHECK_FLASH_REQ, &inpOutData);
             fw_update_inf = *(tNFC_FWUpdate_Info_t*)&inpOutData.out.data.fwUpdateInf;
             nfc_cb.p_hal->ioctl(HAL_NFC_IOCTL_FW_DWNLD, &inpOutData);
             fw_dwnld_status = inpOutData.out.data.fwDwnldStatus;
-            NFC_TRACE_DEBUG1("FW Download 0x%x", fw_dwnld_status);
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("FW Download 0x%x", fw_dwnld_status);
             if (fw_dwnld_status != NFC_STATUS_OK)
                 nfc_enabled(NFC_STATUS_FAILED, NULL);
         }
 #else
-        NFC_TRACE_DEBUG0("Force FW Download !");
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Force FW Download !");
         nfc_cb.p_hal->ioctl(HAL_NFC_IOCTL_CHECK_FLASH_REQ, &fw_update_inf);
         nfc_cb.p_hal->ioctl(HAL_NFC_IOCTL_FW_DWNLD, &fw_dwnld_status);
-        NFC_TRACE_DEBUG1("FW Download 0x%x", fw_dwnld_status);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("FW Download 0x%x", fw_dwnld_status);
         if (fw_dwnld_status != NFC_STATUS_OK)
             nfc_enabled(NFC_STATUS_FAILED, NULL);
 #endif
     }
+
+    /*For debug purpose,register dump when CORE_RESET_NTF happens*/
+    if (core_reset_init_num_buff) {
+      uint8_t stat = 0;
+      stat = nfc_hal_nfcc_get_reset_info();
+      if (stat != NCI_STATUS_OK)
+        DLOG_IF(INFO, nfc_debug_enabled)
+            << StringPrintf("Failed to get reset info");
+    }
+
     /*Prepare the DISCOVERY command*/
     if (!(nfa_dm_cb.disc_cb.disc_state > NFA_DM_RFST_IDLE)) {
-      NFC_TRACE_DEBUG0("NFCC last NCI RF state is IDLE");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFCC last NCI RF state is IDLE");
       /*NCI stack RF state set to IDLE*/
       buffer[1] = 0x00;
     } else {
       uint8_t* ps = (uint8_t*)nfc_cb.p_last_disc;
-      NFC_TRACE_DEBUG0("NFCC last NCI RF state is DISCOVERY");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFCC last NCI RF state is DISCOVERY");
       /*Last NFCC state set to DISCOVERY*/
       buffer[1] = 0x01;
       /*NCI stack RF state set to DISCOVERY*/
@@ -304,7 +379,7 @@ void nfc_ncif_cmd_timeout(void) {
       NFC_HDR* p_msg;
       nfa_sys_stop_timer(&nfa_hci_cb.timer);
       if ((p_msg = (NFC_HDR*)GKI_getbuf(sizeof(NFC_HDR))) != NULL) {
-        NFC_TRACE_DEBUG0(
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
             "nfc_ncif_cmd_timeout(): Sending HCI response timeout to upper "
             "layer");
         p_msg->event = NFA_HCI_RSP_TIMEOUT_EVT;
@@ -316,22 +391,22 @@ void nfc_ncif_cmd_timeout(void) {
       /* Flush the data if any before proceeding further with the recovery */
       p_cb = nfc_find_conn_cb_by_conn_id(nfcc_dh_conn_id);
       if (NULL != p_cb) {
-        NFC_TRACE_DEBUG1("nfc_ncif_cmd_timeout(): connection id %d",
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_ncif_cmd_timeout(): connection id %d",
                          nfcc_dh_conn_id);
         status = NFC_FlushData(p_cb->conn_id);
         if (status != NFC_STATUS_OK) {
-          NFC_TRACE_ERROR0("nfc_ncif_cmd_timeout(): NFC data flush failed");
+          LOG(ERROR) << StringPrintf("nfc_ncif_cmd_timeout(): NFC data flush failed");
         }
       }
     }
-    NFC_TRACE_DEBUG3(
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "nfc_ncif_cmd_timeout(): Indicator:0x%02X disc cmd len:0x%02X last cmd "
         "len:0x%02X",
         buffer[0], buffer[2], buffer[38]);
 
     nfc_cb.p_hal->core_initialized(bufflen, buffer);
     if (buffer != NULL) free(buffer);
-    NFC_TRACE_DEBUG0("nfc_ncif_cmd_timeout(): exit");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_ncif_cmd_timeout(): exit");
   }
 #else
   /* report an error */
@@ -357,7 +432,7 @@ void nfc_ncif_cmd_timeout(void) {
 **
 *******************************************************************************/
 void nfc_wait_2_deactivate_timeout(void) {
-  NFC_TRACE_ERROR0("nfc_wait_2_deactivate_timeout");
+  LOG(ERROR) << StringPrintf("nfc_wait_2_deactivate_timeout");
   nfc_cb.flags &= ~NFC_FL_DEACTIVATING;
   nci_snd_deactivate_cmd((uint8_t)nfc_cb.deactivate_timer.param);
 }
@@ -372,9 +447,9 @@ void nfc_wait_2_deactivate_timeout(void) {
 **
 *******************************************************************************/
 uint8_t nfc_ncif_retransmit_data(tNFC_CONN_CB* p_cb, NFC_HDR* p_data) {
-  NFC_TRACE_ERROR0("nfc_ncif_retransmit_data");
+  LOG(ERROR) << StringPrintf("nfc_ncif_retransmit_data");
   if (p_data == NULL) {
-    NFC_TRACE_ERROR0("nfc_ncif_retransmit_data: p_data is NULL");
+    LOG(ERROR) << StringPrintf("nfc_ncif_retransmit_data: p_data is NULL");
     return NCI_STATUS_FAILED;
   }
   if (p_cb->num_buff != NFC_CONN_NO_FC) p_cb->num_buff--;
@@ -413,7 +488,7 @@ uint8_t nfc_ncif_send_data(tNFC_CONN_CB* p_cb, NFC_HDR* p_data) {
 #if (NXP_EXTNS == TRUE)
   uint8_t* pTemp;
   if (core_reset_init_num_buff == true) {
-    NFC_TRACE_ERROR0("Reinitializing the num_buff");
+    LOG(ERROR) << StringPrintf("Reinitializing the num_buff");
 
     if (!p_cb->num_buff) p_cb->num_buff++;
     core_reset_init_num_buff = false;
@@ -421,14 +496,14 @@ uint8_t nfc_ncif_send_data(tNFC_CONN_CB* p_cb, NFC_HDR* p_data) {
 #endif
   if (get_i2c_fragmentation_enabled() == I2C_FRAGMENATATION_ENABLED) {
     if (nfc_cb.i2c_data_t.nci_cmd_channel_busy == 1 && p_data) {
-      NFC_TRACE_DEBUG0("NxpNci : avoiding data packet sending data packet");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NxpNci : avoiding data packet sending data packet");
       nfc_cb.i2c_data_t.conn_id = p_cb->conn_id;
       GKI_enqueue(&p_cb->tx_q, p_data);
       nfc_cb.i2c_data_t.data_stored = 1;
       return NCI_STATUS_OK;
     }
   }
-  NFC_TRACE_DEBUG3("nfc_ncif_send_data :%d, num_buff:%d qc:%d", p_cb->conn_id,
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_ncif_send_data :%d, num_buff:%d qc:%d", p_cb->conn_id,
                    p_cb->num_buff, p_cb->tx_q.count);
   if (p_cb->id == NFC_RF_CONN_ID) {
     if (nfc_cb.nfc_state != NFC_STATE_OPEN) {
@@ -438,7 +513,7 @@ uint8_t nfc_ncif_send_data(tNFC_CONN_CB* p_cb, NFC_HDR* p_data) {
           if (p_cb->init_credits == p_cb->num_buff) {
             /* all the credits are back */
             nfc_cb.flags &= ~NFC_FL_DEACTIVATING;
-            NFC_TRACE_DEBUG2(
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
                 "deactivating NFC-DEP init_credits:%d, num_buff:%d",
                 p_cb->init_credits, p_cb->num_buff);
             nfc_stop_timer(&nfc_cb.deactivate_timer);
@@ -468,7 +543,7 @@ uint8_t nfc_ncif_send_data(tNFC_CONN_CB* p_cb, NFC_HDR* p_data) {
   p_data = (NFC_HDR*)GKI_getfirst(&p_cb->tx_q);
 
   /* post data fragment to NCIT task as credits are available */
-  while (p_data && (p_data->len >= 0) && (p_cb->num_buff > 0)) {
+  while (p_data && (p_cb->num_buff > 0)) {
     if (p_data->len <= buffer_size) {
       pbf = 0; /* last fragment */
       ulen = (uint8_t)(p_data->len);
@@ -487,9 +562,12 @@ uint8_t nfc_ncif_send_data(tNFC_CONN_CB* p_cb, NFC_HDR* p_data) {
        * prepare a new GKI buffer
        * (even the last fragment to avoid issues) */
       p = NCI_GET_CMD_BUF(ulen);
-      if (p == NULL) return (NCI_STATUS_BUFFER_FULL);
+      if (p == NULL)
+        return (NCI_STATUS_BUFFER_FULL);
+
       p->len = ulen;
       p->offset = NCI_MSG_OFFSET_SIZE + NCI_DATA_HDR_SIZE + 1;
+
       if (p->len) {
         pp = (uint8_t*)(p + 1) + p->offset;
         ps = (uint8_t*)(p_data + 1) + p_data->offset;
@@ -517,12 +595,13 @@ uint8_t nfc_ncif_send_data(tNFC_CONN_CB* p_cb, NFC_HDR* p_data) {
         nfc_cb.temp_data->offset = p->offset;
         pTemp = (uint8_t*)(nfc_cb.temp_data + 1) + nfc_cb.temp_data->offset;
         nfc_cb.temp_data->len = p->len;
-        memcpy(pTemp, (uint8_t*)(p + 1) + (p->offset), p->len);
+        memcpy(pTemp, ((uint8_t*)(p + 1) + p->offset), p->len);
     }
 #endif
 
     /* send to HAL */
     HAL_WRITE(p);
+    nfcsnoop_capture(p, false);
 #if (NXP_EXTNS == TRUE)
     /* start NFC data ntf timeout timer */
     if (get_i2c_fragmentation_enabled() == I2C_FRAGMENATATION_ENABLED) {
@@ -587,7 +666,7 @@ void nfc_ncif_check_cmd_queue(NFC_HDR* p_buf) {
       GKI_enqueue(&nfc_cb.nci_cmd_xmit_q, p_buf);
 #if (NXP_EXTNS == TRUE)
       if (p_buf != NULL) {
-        NFC_TRACE_DEBUG0("nfc_ncif_check_cmd_queue : making p_buf NULL.");
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_ncif_check_cmd_queue : making p_buf NULL.");
         p_buf = NULL;
       }
 #else
@@ -603,14 +682,14 @@ void nfc_ncif_check_cmd_queue(NFC_HDR* p_buf) {
 
     if (p_buf) {
 #if (NXP_EXTNS == TRUE)
-      NFC_TRACE_DEBUG0("nfc_ncif_check_cmd_queue : Writing to HAL...");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_ncif_check_cmd_queue : Writing to HAL...");
       /*save the message header to double check the response */
       ps = (uint8_t*)(p_buf + 1) + p_buf->offset;
       /*save command HEADER(GID+OID) only*/
       memcpy(nfc_cb.last_hdr, ps, NFC_SAVED_HDR_SIZE);
       /*save command length only*/
       nfc_cb.cmd_size = *(ps + NFC_SAVED_HDR_SIZE);
-      NFC_TRACE_DEBUG2("%s : cmd_size:%d", __func__, nfc_cb.cmd_size);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s : cmd_size:%d", __func__, nfc_cb.cmd_size);
       if ((nfc_cb.last_hdr[0] == 0x20 &&
            (nfc_cb.last_hdr[1] == 0x02 || nfc_cb.last_hdr[1] == 0x03)) ||
           (nfc_cb.last_hdr[0] == 0x2F && nfc_cb.last_hdr[1] == 0x15) ||
@@ -626,7 +705,7 @@ void nfc_ncif_check_cmd_queue(NFC_HDR* p_buf) {
                  (nfc_cb.cmd_size + 1));
           memcpy(nfc_cb.last_cmd, ps + NCI_MSG_HDR_SIZE, NFC_SAVED_CMD_SIZE);
         } else {
-          NFC_TRACE_DEBUG0("NULL buffer nfc_cb.last_cmd_buf");
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NULL buffer nfc_cb.last_cmd_buf");
         }
       } else {
         memcpy(nfc_cb.last_cmd, ps + NCI_MSG_HDR_SIZE, NFC_SAVED_CMD_SIZE);
@@ -640,16 +719,15 @@ void nfc_ncif_check_cmd_queue(NFC_HDR* p_buf) {
       if (p_buf->layer_specific == NFC_WAIT_RSP_VSC) {
         /* save the callback for NCI VSCs)  */
         nfc_cb.p_vsc_cback = (void*)((tNFC_NCI_VS_MSG*)p_buf)->p_cback;
-      }
-#if (NXP_EXTNS == TRUE)
-      else if (p_buf->layer_specific == NFC_WAIT_RSP_NXP) {
-        /* save the callback for NCI NXPs)  */
+      } else if (p_buf->layer_specific == NFC_WAIT_RSP_RAW_VS) {
+        /* save the callback for RAW VS */
         nfc_cb.p_vsc_cback = (void*)((tNFC_NCI_VS_MSG*)p_buf)->p_cback;
-        nfc_cb.nxpCbflag = true;
+        nfc_cb.rawVsCbflag = true;
       }
+
       /* Indicate command is pending */
       nfc_cb.nci_cmd_window--;
-#endif
+
       /* send to HAL */
       HAL_WRITE(p_buf);
 #if (NXP_EXTNS != TRUE)
@@ -658,7 +736,7 @@ void nfc_ncif_check_cmd_queue(NFC_HDR* p_buf) {
 #endif
       if (get_i2c_fragmentation_enabled() == I2C_FRAGMENATATION_ENABLED) {
         nfc_cb.i2c_data_t.nci_cmd_channel_busy = 1;
-        NFC_TRACE_DEBUG0("setting channel busy flag");
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("setting channel busy flag");
       }
 
       /* start NFC command-timeout timer */
@@ -706,6 +784,19 @@ void nfc_ncif_check_cmd_queue(NFC_HDR* p_buf) {
   }
 }
 
+#if (NXP_EXTNS == TRUE || APPL_DTA_MODE == TRUE)
+/*******************************************************************************
+**
+** Function         nfc_ncif_getFWVersion
+**
+** Description      This function is called to fet the FW Version
+**
+** Returns          tNFC_FW_VERSION
+**
+*******************************************************************************/
+tNFC_FW_VERSION nfc_ncif_getFWVersion() { return nfc_fw_version; }
+#endif
+
 /*******************************************************************************
 **
 ** Function         nfc_ncif_send_cmd
@@ -717,9 +808,9 @@ void nfc_ncif_check_cmd_queue(NFC_HDR* p_buf) {
 *******************************************************************************/
 void nfc_ncif_send_cmd(NFC_HDR* p_buf) {
 #if (NXP_EXTNS == TRUE)
-  NFC_TRACE_DEBUG0("nfc_ncif_send_cmd()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_ncif_send_cmd()");
   if (p_buf == NULL) {
-    NFC_TRACE_DEBUG0("p_buf is NULL.");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("p_buf is NULL.");
     return;
   }
   uint8_t* cmd = NULL;
@@ -733,6 +824,7 @@ void nfc_ncif_send_cmd(NFC_HDR* p_buf) {
   /* post the p_buf to NCIT task */
   p_buf->event = BT_EVT_TO_NFC_NCI;
   p_buf->layer_specific = 0;
+  nfcsnoop_capture(p_buf, false);
   nfc_ncif_check_cmd_queue(p_buf);
 }
 
@@ -755,30 +847,30 @@ bool nfc_ncif_process_event(NFC_HDR* p_msg) {
 
   pp = p;
   NCI_MSG_PRS_HDR0(pp, mt, pbf, gid);
-#if (NXP_EXTNS == TRUE)
   oid = ((*pp) & NCI_OID_MASK);
-
+#if (NXP_EXTNS == TRUE)
   if (sListenActivated == true) {
     nfc_stop_timer(&nfc_cb.listen_activation_timer_list);
     sListenActivated = false;
   }
-
-  if ((nfc_cb.nxpCbflag == true) &&
-      (nfc_ncif_proc_proprietary_rsp(mt, gid, oid) == true)) {
-    nci_proc_prop_nxp_rsp(p_msg);
-    return (free);
-  }
 #endif
+  if (nfc_cb.rawVsCbflag == true &&
+      nfc_ncif_proc_proprietary_rsp(mt, gid, oid) == true) {
+    nci_proc_prop_raw_vs_rsp(p_msg);
+    nfc_cb.rawVsCbflag = false;
+    return free;
+  }
 
+  nfcsnoop_capture(p_msg, true);
   switch (mt) {
     case NCI_MT_DATA:
-      NFC_TRACE_DEBUG0("NFC received data");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC received data");
       nfc_ncif_proc_data(p_msg);
       free = false;
       break;
 
     case NCI_MT_RSP:
-      NFC_TRACE_DEBUG1("NFC received rsp gid:%d", gid);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC received rsp gid:%d", gid);
       oid = ((*pp) & NCI_OID_MASK);
       p_old = nfc_cb.last_hdr;
       NCI_MSG_PRS_HDR0(p_old, old_mt, pbf, old_gid);
@@ -789,7 +881,7 @@ bool nfc_ncif_process_event(NFC_HDR* p_msg) {
           if ((nfcFL.nfcNxpEse && nfcFL.eseFL._ESE_ETSI_READER_ENABLE) &&
                   ((gid == NCI_GID_RF_MANAGE) && (oid == NCI_MSG_RF_DISCOVER)) &&
                   (etsi_reader_in_progress == true)) {
-              NFC_TRACE_DEBUG0("Changing disc_state and disc_flags");
+              DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Changing disc_state and disc_flags");
               nfa_dm_cb.disc_cb.disc_state = NFA_DM_RFST_IDLE;
               nfa_dm_cb.disc_cb.disc_flags &=
                       ~(NFA_DM_DISC_FLAGS_W4_NTF | NFA_DM_DISC_FLAGS_STOPPING);
@@ -802,10 +894,10 @@ bool nfc_ncif_process_event(NFC_HDR* p_msg) {
                * scenario after the recovery*/
               if ((gid == NCI_GID_RF_MANAGE) && (oid == NCI_MSG_RF_DISCOVER) &&
                       (nfc_cb.nci_cmd_window == 0)) {
-                  NFC_TRACE_DEBUG0("resetting the nci_cmd_window");
+                  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("resetting the nci_cmd_window");
                   nfc_cb.nci_cmd_window++;
               } else {
-                  NFC_TRACE_ERROR2(
+                  LOG(ERROR) << StringPrintf(
                           "nfc_ncif_process_event unexpected rsp: gid:0x%x, oid:0x%x",
                           gid, oid);
                   return true;
@@ -831,7 +923,7 @@ bool nfc_ncif_process_event(NFC_HDR* p_msg) {
           nci_proc_prop_rsp(p_msg);
           break;
         default:
-          NFC_TRACE_ERROR1("NFC: Unknown gid:%d", gid);
+          LOG(ERROR) << StringPrintf("NFC: Unknown gid:%d", gid);
           break;
       }
 #if (NXP_EXTNS == TRUE)
@@ -843,12 +935,12 @@ bool nfc_ncif_process_event(NFC_HDR* p_msg) {
 #endif
       if (get_i2c_fragmentation_enabled() == I2C_FRAGMENATATION_ENABLED) {
         nfc_cb.i2c_data_t.nci_cmd_channel_busy = 0;
-        NFC_TRACE_DEBUG1("%s,updating window", __func__);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s,updating window", __func__);
         p_cb_stored = nfc_find_conn_cb_by_conn_id(nfc_cb.i2c_data_t.conn_id);
         nfc_ncif_update_window();
         if (p_cb_stored && (nfc_cb.i2c_data_t.data_stored == 1) &&
             (nfc_cb.i2c_data_t.nci_cmd_channel_busy == 0x00)) {
-          NFC_TRACE_ERROR0("resending the stored data  packet");
+          LOG(ERROR) << StringPrintf("resending the stored data  packet");
           nfc_ncif_send_data(p_cb_stored, NULL);
           nfc_cb.i2c_data_t.data_stored = 0;
         }
@@ -857,7 +949,7 @@ bool nfc_ncif_process_event(NFC_HDR* p_msg) {
       }
       break;
     case NCI_MT_NTF:
-      NFC_TRACE_DEBUG1("NFC received ntf gid:%d", gid);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC received ntf gid:%d", gid);
       switch (gid) {
         case NCI_GID_CORE: /* 0000b NCI Core group */
           nci_proc_core_ntf(p_msg);
@@ -876,13 +968,13 @@ bool nfc_ncif_process_event(NFC_HDR* p_msg) {
           nci_proc_prop_ntf(p_msg);
           break;
         default:
-          NFC_TRACE_ERROR1("NFC: Unknown gid:%d", gid);
+          LOG(ERROR) << StringPrintf("NFC: Unknown gid:%d", gid);
           break;
       }
       break;
 
     default:
-      NFC_TRACE_DEBUG2("NFC received unknown mt:0x%x, gid:%d", mt, gid);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC received unknown mt:0x%x, gid:%d", mt, gid);
   }
 
   return (free);
@@ -914,9 +1006,9 @@ void nfc_ncif_rf_management_status(tNFC_DISCOVER_EVT event, uint8_t status) {
 ** Returns          void
 **
 *******************************************************************************/
-void nfc_ncif_set_config_status(uint8_t* p, uint8_t len) {
+void nfc_ncif_set_config_status(uint8_t* p,
+                                __attribute__((unused))uint8_t len) {
   tNFC_RESPONSE evt_data;
-  (void)len;
 
   if (nfc_cb.p_resp_cback) {
     evt_data.set_config.status = (tNFC_STATUS)*p++;
@@ -942,7 +1034,8 @@ void nfc_ncif_set_config_status(uint8_t* p, uint8_t len) {
 *******************************************************************************/
 void nfc_ncif_event_status(tNFC_RESPONSE_EVT event, uint8_t status) {
   tNFC_RESPONSE evt_data;
-
+  if (event == NFC_NFCC_TIMEOUT_REVT && status == NFC_STATUS_HW_TIMEOUT)
+    android::metricslogger::LogCounter("nfc_hw_timeout_error", 1);
 #if (NXP_EXTNS == TRUE)
   if ((nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME ==
           nfcFL.eseFL._ESE_WIRED_MODE_RESUME) &&
@@ -993,11 +1086,28 @@ void nfc_ncif_event_status(tNFC_RESPONSE_EVT event, uint8_t status) {
 **
 *******************************************************************************/
 void nfc_ncif_error_status(uint8_t conn_id, uint8_t status) {
-  tNFC_CONN_CB* p_cb;
-  p_cb = nfc_find_conn_cb_by_conn_id(conn_id);
+  tNFC_CONN_CB* p_cb = nfc_find_conn_cb_by_conn_id(conn_id);
   if (p_cb && p_cb->p_cback) {
-    (*p_cb->p_cback)(conn_id, NFC_ERROR_CEVT, (void*)&status);
-  }
+    tNFC_CONN nfc_conn;
+    nfc_conn.status = status;
+    (*p_cb->p_cback)(conn_id, NFC_ERROR_CEVT, &nfc_conn);
+  }
+  if (status == NFC_STATUS_TIMEOUT)
+    android::metricslogger::LogCounter("nfc_rf_timeout_error", 1);
+  else if (status == NFC_STATUS_EE_TIMEOUT)
+    android::metricslogger::LogCounter("nfc_ee_timeout_error", 1);
+  else if (status == NFC_STATUS_ACTIVATION_FAILED)
+    android::metricslogger::LogCounter("nfc_rf_activation_failed", 1);
+  else if (status == NFC_STATUS_EE_INTF_ACTIVE_FAIL)
+    android::metricslogger::LogCounter("nfc_ee_activation_failed", 1);
+  else if (status == NFC_STATUS_RF_TRANSMISSION_ERR)
+    android::metricslogger::LogCounter("nfc_rf_transmission_error", 1);
+  else if (status == NFC_STATUS_EE_TRANSMISSION_ERR)
+    android::metricslogger::LogCounter("nfc_ee_transmission_error", 1);
+  else if (status == NFC_STATUS_RF_PROTOCOL_ERR)
+    android::metricslogger::LogCounter("nfc_rf_protocol_error", 1);
+  else if (status == NFC_STATUS_EE_PROTOCOL_ERR)
+    android::metricslogger::LogCounter("nfc_ee_protocol_error", 1);
 }
 
 /*******************************************************************************
@@ -1011,13 +1121,13 @@ void nfc_ncif_error_status(uint8_t conn_id, uint8_t status) {
 *******************************************************************************/
 #if (NFC_RW_ONLY == FALSE)
 void nfc_ncif_proc_rf_field_ntf(uint8_t rf_status) {
-  NFC_TRACE_DEBUG0("nfc_ncif_proc_rf_field_ntf");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_ncif_proc_rf_field_ntf");
   tNFC_RESPONSE evt_data;
 #if (NXP_EXTNS == TRUE)
   if(nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME ==
           nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
       if (rf_status == 0x01) {
-          NFC_TRACE_DEBUG0("nfc_ncif_proc_rf_field_ntf ON_EVT");
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_ncif_proc_rf_field_ntf ON_EVT");
           nfc_cb.bBlockWiredMode = true;
           nfc_cb.bBlkPwrlinkAndModeSetCmd = true;
           nfc_stop_timer(&nfc_cb.nci_wait_setMode_Ntf_timer); /* stop mode set Ntf
@@ -1029,9 +1139,10 @@ void nfc_ncif_proc_rf_field_ntf(uint8_t rf_status) {
       } else {
           nfc_stop_timer(&nfc_cb.rf_filed_event_timeout_timer);
           if (nfc_cb.bBlockWiredMode) {
-              nfc_start_timer(&nfc_cb.rf_filed_event_timeout_timer,
-                      (uint16_t)(NFC_TTYPE_NCI_WAIT_RF_FIELD_NTF),
-                      NFC_NCI_RFFIELD_EVT_TIMEOUT);
+            /*Timeout for field off is reduced to 1s which will be enough to get
+             * next field ntf if any*/
+            nfc_start_timer(&nfc_cb.rf_filed_event_timeout_timer,
+                            (uint16_t)(NFC_TTYPE_NCI_WAIT_RF_FIELD_NTF), 1);
           }
       }
   }
@@ -1058,15 +1169,15 @@ void nfc_ncif_proc_rf_field_ntf(uint8_t rf_status) {
 **
 *******************************************************************************/
 void nfc_ncif_allow_dwp_transmission() {
-    NFC_TRACE_DEBUG0("nfc_ncif_allow_dwp_transmission Enter");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_ncif_allow_dwp_transmission Enter");
     if(nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME !=
             nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
-        NFC_TRACE_DEBUG0("DUAL_MODE_PRIO_SCHEME != WIRED_MODE_RESUME. Returning");
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("DUAL_MODE_PRIO_SCHEME != WIRED_MODE_RESUME. Returning");
         return;
     }
   tNFC_RESPONSE evt_data;
   tNFC_CONN_CB* p_cb;
-  NFC_TRACE_DEBUG2("nfc_ncif_allow_dwp_transmission %d, %d ",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_ncif_allow_dwp_transmission %d, %d ",
                    nfc_cb.bIsDwpResPending, nfc_cb.bRetransmitDwpPacket);
   p_cb = nfc_find_conn_cb_by_conn_id(nfa_hci_cb.conn_id);
 
@@ -1107,10 +1218,10 @@ void nfc_ncif_allow_dwp_transmission() {
 **
 *******************************************************************************/
 void nfc_ncif_onWiredModeHold_timeout() {
-  NFC_TRACE_DEBUG0("nfc_ncif_onWiredModeHold_timeout");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_ncif_onWiredModeHold_timeout");
   if(nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME !=
           nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
-      NFC_TRACE_DEBUG0("DUAL_MODE_PRIO_SCHEME != WIRED_MODE_RESUME. Returning");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("DUAL_MODE_PRIO_SCHEME != WIRED_MODE_RESUME. Returning");
       return;
   }
   if (nfc_cb.bBlockWiredMode) {
@@ -1128,24 +1239,31 @@ void nfc_ncif_onWiredModeHold_timeout() {
 **
 *******************************************************************************/
 void nfc_ncif_resume_dwp_wired_mode() {
-  NFC_TRACE_DEBUG0("nfc_ncif_resume_dwp_wired_mode");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_ncif_resume_dwp_wired_mode");
   if(nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME !=
           nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
-      NFC_TRACE_DEBUG0("DUAL_MODE_PRIO_SCHEME != WIRED_MODE_RESUME. Returning");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("DUAL_MODE_PRIO_SCHEME != WIRED_MODE_RESUME. Returning");
       return;
   }
   tNFC_CONN_CB* p_cb;
   p_cb = nfc_find_conn_cb_by_conn_id(nfa_hci_cb.conn_id);
+  if (p_cb == NULL) {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Control block not found. Returning");
+    return;
+  }
+
   nfc_cb.bBlkPwrlinkAndModeSetCmd = false;
   nfc_cb.bIssueModeSetCmd = false;
   if (nfc_cb.pwr_link_cmd.bPwrLinkCmdRequested) {
-    NFC_TRACE_DEBUG0("pwr link cmd to send");
+    nfc_stop_quick_timer(&nfc_cb.nci_wait_pwrLinkRsp_timer);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("pwr link cmd to send");
     nci_snd_pwr_nd_lnk_ctrl_cmd(NFCEE_ID_ESE, nfc_cb.pwr_link_cmd.param);
     nfc_cb.pwr_link_cmd.bPwrLinkCmdRequested = false;
     if (!nfc_cb.bCeActivatedeSE) nfc_cb.bIssueModeSetCmd = true;
   } else if (((nfc_cb.bSetmodeOnReq) || (!GKI_queue_is_empty(&p_cb->tx_q))) &&
              (!nfc_cb.bCeActivatedeSE)) {
-    NFC_TRACE_DEBUG0("mode set cmd to send");
+    nfc_stop_quick_timer(&nfc_cb.nci_wait_setModeRsp_timer);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("mode set cmd to send");
     nfc_cb.bSetmodeOnReq = true;
     nci_snd_nfcee_mode_set(NFCEE_ID_ESE, NFC_MODE_ACTIVATE);
     nfc_start_timer(&nfc_cb.nci_wait_setMode_Ntf_timer,
@@ -1168,10 +1286,10 @@ void nfc_ncif_resume_dwp_wired_mode() {
 **
 *******************************************************************************/
 void nfc_ncif_modeSet_Ntf_timeout() {
-  NFC_TRACE_DEBUG0("nfc_ncif_modeSet_Ntf_timeout");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_ncif_modeSet_Ntf_timeout");
   if(nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME !=
           nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
-      NFC_TRACE_DEBUG0("DUAL_MODE_PRIO_SCHEME != WIRED_MODE_RESUME. Returning");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("DUAL_MODE_PRIO_SCHEME != WIRED_MODE_RESUME. Returning");
       return;
   }
   if (nfc_cb.bBlockWiredMode) {
@@ -1191,10 +1309,10 @@ void nfc_ncif_modeSet_Ntf_timeout() {
 **
 *******************************************************************************/
 void nfc_ncif_modeSet_rsp_timeout() {
-  NFC_TRACE_DEBUG0("nfc_ncif_modeSet_rsp_timeout");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_ncif_modeSet_rsp_timeout");
   if(nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME !=
           nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
-      NFC_TRACE_DEBUG0("DUAL_MODE_PRIO_SCHEME != WIRED_MODE_RESUME. Returning");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("DUAL_MODE_PRIO_SCHEME != WIRED_MODE_RESUME. Returning");
       return;
   }
   tNFC_NFCEE_MODE_SET_REVT mode_set_info;
@@ -1223,10 +1341,10 @@ void nfc_ncif_modeSet_rsp_timeout() {
 **
 *******************************************************************************/
 void nfc_ncif_pwr_link_rsp_timeout() {
-  NFC_TRACE_DEBUG0("nfc_ncif_pwr_link_rsp_timeout");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_ncif_pwr_link_rsp_timeout");
   if(nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME !=
           nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
-      NFC_TRACE_DEBUG0("DUAL_MODE_PRIO_SCHEME != WIRED_MODE_RESUME. Returning");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("DUAL_MODE_PRIO_SCHEME != WIRED_MODE_RESUME. Returning");
       return;
   }
   tNFC_RESPONSE_CBACK* p_cback = nfc_cb.p_resp_cback;
@@ -1251,10 +1369,10 @@ void nfc_ncif_pwr_link_rsp_timeout() {
 ** Returns          void
 **
 *******************************************************************************/
-void nfc_ncif_proc_credits(uint8_t* p, uint16_t plen) {
+void nfc_ncif_proc_credits(uint8_t* p,
+                           __attribute__((unused)) uint16_t plen) {
   uint8_t num, xx;
   tNFC_CONN_CB* p_cb;
-  (void)plen;
 
   num = *p++;
   for (xx = 0; xx < num; xx++) {
@@ -1267,7 +1385,7 @@ void nfc_ncif_proc_credits(uint8_t* p, uint16_t plen) {
           /* if this happens in activated state, it's very likely that our NFCC
            * has issues */
           /* However, credit may be returned after deactivation */
-          NFC_TRACE_ERROR2("num_buff:0x%x, init_credits:0x%x", p_cb->num_buff,
+          LOG(ERROR) << StringPrintf("num_buff:0x%x, init_credits:0x%x", p_cb->num_buff,
                            p_cb->init_credits);
         }
         p_cb->num_buff = p_cb->init_credits;
@@ -1308,12 +1426,15 @@ uint8_t* nfc_ncif_decode_rf_params(tNFC_RF_TECH_PARAMS* p_param, uint8_t* p) {
   tNFC_RF_LF_PARAMS* p_lf;
   tNFC_RF_PF_PARAMS* p_pf;
   tNFC_RF_PISO15693_PARAMS* p_i93;
-
+  tNFC_RF_ACM_P_PARAMS* acm_p;
+  uint8_t mpl_idx = 0;
+  uint8_t gb_idx = 0, mpl;
   len = *p++;
   p_start = p;
   memset(&p_param->param, 0, sizeof(tNFC_RF_TECH_PARAMU));
-  if (NCI_DISCOVERY_TYPE_POLL_A == p_param->mode ||
-      NCI_DISCOVERY_TYPE_POLL_A_ACTIVE == p_param->mode) {
+ if (NCI_DISCOVERY_TYPE_POLL_A == p_param->mode ||
+      (NCI_DISCOVERY_TYPE_POLL_A_ACTIVE == p_param->mode &&
+       NFC_GetNCIVersion() != NCI_VERSION_2_0)) {
     p_pa = &p_param->param.pa;
     /*
 SENS_RES Response   2 bytes Defined in [DIGPROT] Available after Technology
@@ -1360,7 +1481,8 @@ Available after Technology Detection
     STREAM_TO_ARRAY(p_pb->sensb_res, p, p_pb->sensb_res_len);
     memcpy(p_pb->nfcid0, p_pb->sensb_res, NFC_NFCID0_MAX_LEN);
   } else if (NCI_DISCOVERY_TYPE_POLL_F == p_param->mode ||
-             NCI_DISCOVERY_TYPE_POLL_F_ACTIVE == p_param->mode) {
+             (NCI_DISCOVERY_TYPE_POLL_F_ACTIVE == p_param->mode &&
+              NFC_GetNCIVersion() != NCI_VERSION_2_0)) {
     /*
 Bit Rate    1 byte  1   212 kbps/2   424 kbps/0 and 3 to 255  RFU
 SENSF_RES Response length.(n) 1 byte  Length of SENSF_RES (Byte 2 - Byte 17 or
@@ -1378,13 +1500,14 @@ Available after Technology Detection
     p_pf->mrti_check = p_pf->sensf_res[NCI_MRTI_CHECK_INDEX];
     p_pf->mrti_update = p_pf->sensf_res[NCI_MRTI_UPDATE_INDEX];
   } else if (NCI_DISCOVERY_TYPE_LISTEN_F == p_param->mode ||
-             NCI_DISCOVERY_TYPE_LISTEN_F_ACTIVE == p_param->mode) {
+             (NCI_DISCOVERY_TYPE_LISTEN_F_ACTIVE == p_param->mode &&
+              NFC_GetNCIVersion() != NCI_VERSION_2_0)) {
     p_lf = &p_param->param.lf;
     u8 = *p++;
     if (u8) {
       STREAM_TO_ARRAY(p_lf->nfcid2, p, NCI_NFCID2_LEN);
     }
-  } else if (NCI_DISCOVERY_TYPE_POLL_ISO15693 == p_param->mode) {
+  } else if (NCI_DISCOVERY_TYPE_POLL_V == p_param->mode) {
     p_i93 = &p_param->param.pi93;
     p_i93->flag = *p++;
     p_i93->dsfid = *p++;
@@ -1392,11 +1515,54 @@ Available after Technology Detection
   } else if (NCI_DISCOVERY_TYPE_POLL_KOVIO == p_param->mode) {
     p_param->param.pk.uid_len = len;
     if (p_param->param.pk.uid_len > NFC_KOVIO_MAX_LEN) {
-      NFC_TRACE_ERROR2("Kovio UID len:0x%x exceeds max(0x%x)",
+      LOG(ERROR) << StringPrintf("Kovio UID len:0x%x exceeds max(0x%x)",
                        p_param->param.pk.uid_len, NFC_KOVIO_MAX_LEN);
       p_param->param.pk.uid_len = NFC_KOVIO_MAX_LEN;
     }
     STREAM_TO_ARRAY(p_param->param.pk.uid, p, p_param->param.pk.uid_len);
+  } else if (NCI_DISCOVERY_TYPE_POLL_ACTIVE == p_param->mode) {
+    acm_p = &p_param->param.acm_p;
+    acm_p->atr_res_len = *p++;
+    if (acm_p->atr_res_len > 0) {
+      if (acm_p->atr_res_len > NFC_MAX_ATS_LEN)
+        acm_p->atr_res_len = NFC_MAX_ATS_LEN;
+      STREAM_TO_ARRAY(acm_p->atr_res, p, acm_p->atr_res_len);
+      /* ATR_RES
+      Byte 3~12 Byte 13 Byte 14 Byte 15 Byte 16 Byte 17 Byte 18~18+n
+      NFCID3T   DIDT    BST     BRT     TO      PPT     [GT0 ... GTn] */
+      mpl_idx = 14;
+      gb_idx = NCI_P_GEN_BYTE_INDEX;
+      acm_p->waiting_time = acm_p->atr_res[NCI_L_NFC_DEP_TO_INDEX] & 0x0F;
+      mpl = ((acm_p->atr_res[mpl_idx]) >> 4) & 0x03;
+      acm_p->max_payload_size = nfc_mpl_code_to_size[mpl];
+      if (acm_p->atr_res_len > gb_idx) {
+        acm_p->gen_bytes_len = acm_p->atr_res_len - gb_idx;
+        if (acm_p->gen_bytes_len > NFC_MAX_GEN_BYTES_LEN)
+          acm_p->gen_bytes_len = NFC_MAX_GEN_BYTES_LEN;
+        memcpy(acm_p->gen_bytes, &acm_p->atr_res[gb_idx], acm_p->gen_bytes_len);
+      }
+    }
+  } else if (NCI_DISCOVERY_TYPE_LISTEN_ACTIVE == p_param->mode) {
+    acm_p = &p_param->param.acm_p;
+    acm_p->atr_res_len = *p++;
+    if (acm_p->atr_res_len > 0) {
+      if (acm_p->atr_res_len > NFC_MAX_ATS_LEN)
+        acm_p->atr_res_len = NFC_MAX_ATS_LEN;
+      STREAM_TO_ARRAY(acm_p->atr_res, p, acm_p->atr_res_len);
+      /* ATR_REQ
+      Byte 3~12 Byte 13 Byte 14 Byte 15 Byte 16 Byte 17~17+n
+      NFCID3I   DIDI    BSI     BRI     PPI     [GI0 ... GIn] */
+      mpl_idx = 13;
+      gb_idx = NCI_L_GEN_BYTE_INDEX;
+      mpl = ((acm_p->atr_res[mpl_idx]) >> 4) & 0x03;
+      acm_p->max_payload_size = nfc_mpl_code_to_size[mpl];
+      if (acm_p->atr_res_len > gb_idx) {
+        acm_p->gen_bytes_len = acm_p->atr_res_len - gb_idx;
+        if (acm_p->gen_bytes_len > NFC_MAX_GEN_BYTES_LEN)
+          acm_p->gen_bytes_len = NFC_MAX_GEN_BYTES_LEN;
+        memcpy(acm_p->gen_bytes, &acm_p->atr_res[gb_idx], acm_p->gen_bytes_len);
+      }
+    }
   }
 
   return (p_start + len);
@@ -1411,9 +1577,9 @@ Available after Technology Detection
 ** Returns          void
 **
 *******************************************************************************/
-void nfc_ncif_proc_discover_ntf(uint8_t* p, uint16_t plen) {
+void nfc_ncif_proc_discover_ntf(uint8_t* p,
+                                __attribute__((unused)) uint16_t plen) {
   tNFC_DISCOVER evt_data;
-  (void)plen;
 
   if (nfc_cb.p_discv_cback) {
     p += NCI_MSG_HDR_SIZE;
@@ -1452,11 +1618,9 @@ void nfc_ncif_proc_isodep_nak_presence_check_status (uint8_t status, bool is_ntf
 ** Returns          void
 **
 *******************************************************************************/
-void nfc_ncif_proc_rf_wtx_ntf(uint8_t* p, uint16_t plen) {
+void nfc_ncif_proc_rf_wtx_ntf(__attribute__((unused)) uint8_t* p,
+                              __attribute__((unused)) uint16_t plen) {
   tNFC_CONN_CB* p_cb = NULL;
-  (void)p;
-  (void)plen;
-
   p_cb = nfc_find_conn_cb_by_conn_id(NFC_RF_CONN_ID);
 
   if (NULL != p_cb) {
@@ -1524,7 +1688,7 @@ void nfc_ncif_proc_activate(uint8_t* p, uint8_t len) {
   evt_data.activate.rx_bitrate = *p++;
   mode = evt_data.activate.rf_tech_param.mode;
   len_act = *p++;
-  NFC_TRACE_DEBUG3("nfc_ncif_proc_activate:%d %d, mode:0x%02x", len, len_act,
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_ncif_proc_activate:%d %d, mode:0x%02x", len, len_act,
                    mode);
 
 #if (NXP_EXTNS == TRUE)
@@ -1534,11 +1698,12 @@ void nfc_ncif_proc_activate(uint8_t* p, uint8_t len) {
     nfc_start_timer(&nfc_cb.listen_activation_timer_list,
                     (uint16_t)(NFC_TTYPE_LISTEN_ACTIVATION), 2);
   }
-
-  if ((nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME ==
+/*Do not stop the rf_filed timer to synchronize dual mode or triple mode
+ * involving RF*/
+/*  if ((nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME ==
           nfcFL.eseFL._ESE_WIRED_MODE_RESUME) && nfc_cb.bBlockWiredMode) {
       nfc_stop_timer(&nfc_cb.rf_filed_event_timeout_timer);
-  }
+  }*/
 #endif
 
   /* just in case the interface reports activation parameters not defined in the
@@ -1663,8 +1828,11 @@ void nfc_ncif_proc_activate(uint8_t* p, uint8_t len) {
       STREAM_TO_ARRAY(p_pa_nfc->atr_res, p, p_pa_nfc->atr_res_len);
       if ((mode == NCI_DISCOVERY_TYPE_POLL_A) ||
           (mode == NCI_DISCOVERY_TYPE_POLL_F) ||
-          (mode == NCI_DISCOVERY_TYPE_POLL_A_ACTIVE) ||
-          (mode == NCI_DISCOVERY_TYPE_POLL_F_ACTIVE)) {
+          ((mode == NCI_DISCOVERY_TYPE_POLL_A_ACTIVE ||
+            mode == NCI_DISCOVERY_TYPE_POLL_F_ACTIVE) &&
+           NFC_GetNCIVersion() != NCI_VERSION_2_0) ||
+          (NFC_GetNCIVersion() == NCI_VERSION_2_0 &&
+           mode == NCI_DISCOVERY_TYPE_POLL_ACTIVE)) {
         /* ATR_RES
         Byte 3~12 Byte 13 Byte 14 Byte 15 Byte 16 Byte 17 Byte 18~18+n
         NFCID3T   DIDT    BST     BRT     TO      PPT     [GT0 ... GTn] */
@@ -1674,8 +1842,11 @@ void nfc_ncif_proc_activate(uint8_t* p, uint8_t len) {
             p_pa_nfc->atr_res[NCI_L_NFC_DEP_TO_INDEX] & 0x0F;
       } else if ((mode == NCI_DISCOVERY_TYPE_LISTEN_A) ||
                  (mode == NCI_DISCOVERY_TYPE_LISTEN_F) ||
-                 (mode == NCI_DISCOVERY_TYPE_LISTEN_A_ACTIVE) ||
-                 (mode == NCI_DISCOVERY_TYPE_LISTEN_F_ACTIVE)) {
+                 (NFC_GetNCIVersion() != NCI_VERSION_2_0 &&
+                  (mode == NCI_DISCOVERY_TYPE_LISTEN_A_ACTIVE ||
+                   mode == NCI_DISCOVERY_TYPE_LISTEN_F_ACTIVE)) ||
+                 (NFC_GetNCIVersion() == NCI_VERSION_2_0 &&
+                  mode == NCI_DISCOVERY_TYPE_LISTEN_ACTIVE)) {
         /* ATR_REQ
         Byte 3~12 Byte 13 Byte 14 Byte 15 Byte 16 Byte 17~17+n
         NFCID3I   DIDI    BSI     BRI     PPI     [GI0 ... GIn] */
@@ -1712,14 +1883,14 @@ void nfc_ncif_proc_activate(uint8_t* p, uint8_t len) {
    */
   else if (evt_data.activate.intf_param.type == nfcFL.nfcMwFL._NCI_INTERFACE_UICC_DIRECT ||
            evt_data.activate.intf_param.type == nfcFL.nfcMwFL._NCI_INTERFACE_ESE_DIRECT) {
-    NFC_TRACE_DEBUG1("nfc_ncif_proc_activate:interface type  %x",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_ncif_proc_activate:interface type  %x",
                      evt_data.activate.intf_param.type);
   }
 #endif
 
   p_cb->act_protocol = evt_data.activate.protocol;
-#if (NXP_EXTNS == TRUE)
   p_cb->act_interface = evt_data.activate.intf_param.type;
+#if (NXP_EXTNS == TRUE)
   p_cb->sel_res = evt_data.activate.rf_tech_param.param.pa.sel_rsp;
 #endif
   p_cb->buff_size = buff_size;
@@ -1743,7 +1914,6 @@ void nfc_ncif_proc_activate(uint8_t* p, uint8_t len) {
 *******************************************************************************/
 void nfc_ncif_proc_deactivate(uint8_t status, uint8_t deact_type, bool is_ntf) {
   tNFC_DISCOVER evt_data;
-  tNFC_DEACTIVATE_DEVT* p_deact;
   tNFC_CONN_CB* p_cb = &nfc_cb.conn_cb[NFC_RF_CONN_ID];
 #if (NXP_EXTNS == TRUE)
     tRW_T3T_CB *p_t3tcb = &rw_cb.tcb.t3t;
@@ -1751,10 +1921,12 @@ void nfc_ncif_proc_deactivate(uint8_t status, uint8_t deact_type, bool is_ntf) {
   void* p_data;
 
   nfc_set_state(NFC_STATE_IDLE);
-  p_deact = &evt_data.deactivate;
-  p_deact->status = status;
-  p_deact->type = deact_type;
-  p_deact->is_ntf = is_ntf;
+  evt_data.deactivate.status = status;
+  evt_data.deactivate.type = deact_type;
+  evt_data.deactivate.is_ntf = is_ntf;
+  if (NFC_GetNCIVersion() == NCI_VERSION_2_0) {
+    evt_data.deactivate.reason = nfc_cb.deact_reason;
+  }
 
   while ((p_data = GKI_dequeue(&p_cb->rx_q)) != NULL) {
     GKI_freebuf(p_data);
@@ -1764,19 +1936,34 @@ void nfc_ncif_proc_deactivate(uint8_t status, uint8_t deact_type, bool is_ntf) {
     GKI_freebuf(p_data);
   }
 
-  if (p_cb->p_cback)
-    (*p_cb->p_cback)(NFC_RF_CONN_ID, NFC_DEACTIVATE_CEVT, (tNFC_CONN*)p_deact);
+  if (p_cb->p_cback) {
+    tNFC_CONN nfc_conn;
+    nfc_conn.deactivate = evt_data.deactivate;
+    (*p_cb->p_cback)(NFC_RF_CONN_ID, NFC_DEACTIVATE_CEVT, &nfc_conn);
+  }
 
 #if (NXP_EXTNS == TRUE)
+  /*Do not reset the rf_filed timer to synchronize dual mode or triple mode
+   * involving RF*/
+    // if((nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME == nfcFL.eseFL._ESE_WIRED_MODE_RESUME) &&
+    //     (deact_type != NFC_DEACTIVATE_TYPE_SLEEP) && is_ntf)
+    // {
+    //     if(nfc_cb.bBlockWiredMode)
+    //     {
+    //         nfc_stop_timer(&nfc_cb.rf_filed_event_timeout_timer);
+    //         nfc_start_timer(&nfc_cb.rf_filed_event_timeout_timer, (uint16_t)(NFC_TTYPE_NCI_WAIT_RF_FIELD_NTF), NFC_NCI_RFFIELD_EVT_TIMEOUT);
+    //     }
+    // }
+
     if (p_t3tcb->poll_timer.in_use)
     {
-        NFC_TRACE_DEBUG1 ("%s: stopping t3t polling timer", __func__);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: stopping t3t polling timer", __func__);
         nfc_stop_quick_timer (&p_t3tcb->poll_timer);
     }
 
   if ((nfc_cb.flags & (NFC_FL_DISCOVER_PENDING | NFC_FL_CONTROL_REQUESTED)) &&
       (deact_type == NFC_DEACTIVATE_TYPE_DISCOVERY) && (is_ntf == true)) {
-    NFC_TRACE_DEBUG0(
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "Abnormal State, Deactivate NTF is ignored, MW is already going to "
         "Discovery state");
     return;
@@ -1815,7 +2002,7 @@ void nfc_ncif_proc_ee_action(uint8_t* p, uint16_t plen) {
     switch (evt_data.act_data.trigger) {
       case NCI_EE_TRIG_7816_SELECT:
         if (data_len > NFC_MAX_AID_LEN) data_len = NFC_MAX_AID_LEN;
-        NFC_TRACE_DEBUG1("AID len = %d", data_len);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("AID len = %d", data_len);
         evt_data.act_data.param.aid.len_aid = data_len;
         STREAM_TO_ARRAY(evt_data.act_data.param.aid.aid, p, data_len);
         break;
@@ -1857,7 +2044,9 @@ void nfc_ncif_proc_ee_action(uint8_t* p, uint16_t plen) {
 #if (NXP_EXTNS == TRUE)
     if(nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME ==
             nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
-        nfc_stop_timer(&nfc_cb.rf_filed_event_timeout_timer);
+      /*Do not reset the rf_filed timer to synchronize dual mode or triple mode
+       * involving RF*/
+      // nfc_stop_timer(&nfc_cb.rf_filed_event_timeout_timer);
         tNFC_CONN_CB* p_cb;
         p_cb = nfc_find_conn_cb_by_conn_id(nfa_hci_cb.conn_id);
         if (evt_data.nfcee_id != 0xC0) {
@@ -1866,7 +2055,7 @@ void nfc_ncif_proc_ee_action(uint8_t* p, uint16_t plen) {
             if (!nfc_cb.bIsDwpResPending && nfa_hci_cb.assembling) {
                     /* To faster transceive time out when CE is activated with UICC during
                      * chained response being received*/
-                    NFC_TRACE_DEBUG0("restarted hci timer during chained response");
+                    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("restarted hci timer during chained response");
                     nfa_hci_cb.IsWiredSessionAborted = true;
                     nfa_sys_stop_timer(&nfa_hci_cb.timer);
                     if (p_cb && p_cb->p_cback)
@@ -1884,7 +2073,9 @@ void nfc_ncif_proc_ee_action(uint8_t* p, uint16_t plen) {
         }
     }
 #endif
-    (*p_cback)(NFC_EE_ACTION_REVT, (tNFC_RESPONSE*)&evt_data);
+    tNFC_RESPONSE nfc_response;
+    nfc_response.ee_action = evt_data;
+    (*p_cback)(NFC_EE_ACTION_REVT, &nfc_response);
   }
 }
 
@@ -1903,7 +2094,7 @@ void nfc_ncif_proc_ee_discover_req(uint8_t* p, uint16_t plen) {
   tNFC_EE_DISCOVER_INFO* p_info;
   uint8_t u8;
 
-  NFC_TRACE_DEBUG2("nfc_ncif_proc_ee_discover_req %d len:%d", *p, plen);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_ncif_proc_ee_discover_req %d len:%d", *p, plen);
   if (p_cback) {
     u8 = *p;
     ee_disc_req.status = NFC_STATUS_OK;
@@ -1914,7 +2105,7 @@ void nfc_ncif_proc_ee_discover_req(uint8_t* p, uint16_t plen) {
       p_info->op = *p++;                  /* T */
       if (*p != NFC_EE_DISCOVER_INFO_LEN) /* L */
       {
-        NFC_TRACE_DEBUG1("bad entry len:%d", *p);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("bad entry len:%d", *p);
         return;
       }
       p++;
@@ -1926,7 +2117,9 @@ void nfc_ncif_proc_ee_discover_req(uint8_t* p, uint16_t plen) {
       plen -= NFC_EE_DISCOVER_ENTRY_LEN;
       p_info++;
     }
-    (*p_cback)(NFC_EE_DISCOVER_REQ_REVT, (void*)&ee_disc_req);
+    tNFC_RESPONSE nfc_response;
+    nfc_response.ee_discover_req = ee_disc_req;
+    (*p_cback)(NFC_EE_DISCOVER_REQ_REVT, &nfc_response);
   }
 }
 
@@ -1939,14 +2132,9 @@ void nfc_ncif_proc_ee_discover_req(uint8_t* p, uint16_t plen) {
 ** Returns          void
 **
 *******************************************************************************/
-void nfc_ncif_proc_get_routing(uint8_t* p, uint8_t len) {
-  tNFC_GET_ROUTING_REVT evt_data;
-  uint8_t more, num_entries, xx, yy, *pn, tl;
-  tNFC_STATUS status = NFC_STATUS_CONTINUE;
-#if (NXP_EXTNS == TRUE)
-  (void)(p);
-  (void)(len);
-#endif
+void nfc_ncif_proc_get_routing(__attribute__((unused)) uint8_t* p,
+                               __attribute__((unused))uint8_t len) {
+  __attribute__((unused)) tNFC_STATUS status = NFC_STATUS_CONTINUE;
 
 #if (NXP_EXTNS == FALSE)
   if (nfc_cb.p_resp_cback) {
@@ -1978,7 +2166,9 @@ void nfc_ncif_proc_get_routing(uint8_t* p, uint8_t len) {
     evt_data.num_tlvs = *(p + 1);
     evt_data.tlv_size = len;
     memcpy(evt_data.param_tlvs, p, len);
-    (*nfc_cb.p_resp_cback)(NFC_GET_ROUTING_REVT, (tNFC_RESPONSE*)&evt_data);
+    tNFC_RESPONSE nfc_response;
+    nfc_response.get_routing = evt_data;
+    (*nfc_cb.p_resp_cback)(NFC_GET_ROUTING_REVT, &nfc_response);
   }
 #endif
 }
@@ -1994,14 +2184,14 @@ void nfc_ncif_proc_get_routing(uint8_t* p, uint8_t len) {
 ** Returns          void
 **
 *******************************************************************************/
-void nfc_ncif_proc_conn_create_rsp(uint8_t* p, uint16_t plen,
+void nfc_ncif_proc_conn_create_rsp(uint8_t* p,
+                                  __attribute__((unused)) uint16_t plen,
                                    uint8_t dest_type) {
   tNFC_CONN_CB* p_cb;
   tNFC_STATUS status;
   tNFC_CONN_CBACK* p_cback;
   tNFC_CONN evt_data;
   uint8_t conn_id;
-  (void)plen;
 
   /* find the pending connection control block */
   p_cb = nfc_find_conn_cb_by_conn_id(NFC_PEND_CONN_ID);
@@ -2067,22 +2257,21 @@ void nfc_ncif_report_conn_close_evt(uint8_t conn_id, tNFC_STATUS status) {
 *******************************************************************************/
 void nfc_ncif_proc_reset_rsp(uint8_t* p, bool is_ntf) {
   uint8_t* temp = p, len;
-  uint8_t *p_len = p - 1;
+  uint8_t* p_len = p - 1;
   uint8_t status = *p++;
-  bool wait_for_ntf = false;
-
+  uint8_t wait_for_ntf = FALSE;
   if (is_ntf) {
 #if (NXP_EXTNS == TRUE)
       if(nfcFL.nfccFL._NFCC_FORCE_NCI1_0_INIT) {
           if (status == 0x02) {
-              NFC_TRACE_DEBUG2(
+              DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
                       "CORE_RESET_NTF 2 reason Command Received status nfc_state : 0x%x : "
                       "0x%x",
                       status, nfc_cb.nfc_state);
               wait_for_ntf = false;
               status = NCI_STATUS_OK;
           } else if (status == 0x00) {
-              NFC_TRACE_DEBUG2(
+              DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
                       "CORE_RESET_NTF 2 reason Unrecoverable Error status nfc_state : 0x%x "
                       ": 0x%x",
                       status, nfc_cb.nfc_state);
@@ -2090,30 +2279,30 @@ void nfc_ncif_proc_reset_rsp(uint8_t* p, bool is_ntf) {
               if(nfa_dm_is_active())
                   nfc_ncif_cmd_timeout();
           } else {
-              NFC_TRACE_DEBUG1("CORE_RESET_NTF 1 nfc_state :0x%x ", nfc_cb.nfc_state);
-              NFC_TRACE_DEBUG1("CORE_RESET_NTF 1 status :0x%x ", status);
+              DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("CORE_RESET_NTF 1 nfc_state :0x%x ", nfc_cb.nfc_state);
+              DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("CORE_RESET_NTF 1 status :0x%x ", status);
               core_reset_init_num_buff = true;
               if(nfa_dm_is_active())
                   nfc_ncif_cmd_timeout();
           }
       }
       else {
-          NFC_TRACE_DEBUG1("reset notification nfc_state :0x%x ", nfc_cb.nfc_state);
-          NFC_TRACE_DEBUG1("reset notification!!:0x%x ", status);
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("reset notification nfc_state :0x%x ", nfc_cb.nfc_state);
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("reset notification!!:0x%x ", status);
 
           if(status == NCI2_0_RESET_TRIGGER_TYPE_CORE_RESET_CMD_RECEIVED ||
                   status == NCI2_0_RESET_TRIGGER_TYPE_POWERED_ON) {
-              NFC_TRACE_DEBUG2 ("CORE_RESET_NTF Received status nfc_state : 0x%x : 0x%x",
+              DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("CORE_RESET_NTF Received status nfc_state : 0x%x : 0x%x",
                       status ,nfc_cb.nfc_state);
               nfc_stop_timer(&nfc_cb.nci_wait_rsp_timer);
               p++;
               STREAM_TO_UINT8(nfc_cb.nci_version, p);
-              NFC_TRACE_ERROR1(" CORE_RESET_NTF nci_version%x", nfc_cb.nci_version);
+              LOG(ERROR) << StringPrintf(" CORE_RESET_NTF nci_version%x", nfc_cb.nci_version);
               status = NCI_STATUS_OK;
           } else {
               core_reset_init_num_buff = true;
               /* CORE_RESET_NTF received error case , trigger recovery*/
-              NFC_TRACE_DEBUG2 ("CORE_RESET_NTF Received status nfc_state : 0x%x : 0x%x",
+              DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("CORE_RESET_NTF Received status nfc_state : 0x%x : 0x%x",
                       status ,nfc_cb.nfc_state);
               if(nfa_dm_is_active())
                   nfc_ncif_cmd_timeout();
@@ -2125,7 +2314,7 @@ void nfc_ncif_proc_reset_rsp(uint8_t* p, bool is_ntf) {
           if ((*p_len) == NCI_CORE_RESET_RSP_LEN(NCI_VERSION_1_0)) {
               nfc_cb.nci_version = NCI_VERSION_1_0;
           }
-          NFC_TRACE_DEBUG1("CORE_RESET_RSP 2 nfc_state :0x%x ", nfc_cb.nfc_state);
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("CORE_RESET_RSP 2 nfc_state :0x%x ", nfc_cb.nfc_state);
           len = *(--temp);  // extract the no of params in reset response
           if (nfc_cb.flags & (NFC_FL_RESTARTING | NFC_FL_POWER_CYCLE_NFCC)) {
               nfc_reset_all_conn_cbs();
@@ -2137,7 +2326,7 @@ void nfc_ncif_proc_reset_rsp(uint8_t* p, bool is_ntf) {
       }
       else {
 
-          NFC_TRACE_DEBUG1 ("CORE_RESET_RSP len :0x%x ", *p_len);
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("CORE_RESET_RSP len :0x%x ", *p_len);
           if ((*p_len) == NCI_CORE_RESET_RSP_LEN(NCI_VERSION_2_0)) {
               wait_for_ntf = true;
           }
@@ -2145,63 +2334,59 @@ void nfc_ncif_proc_reset_rsp(uint8_t* p, bool is_ntf) {
               nfc_cb.nci_version = NCI_VERSION_1_0;
           }
 
-          NFC_TRACE_DEBUG1("reset response nfc_state :0x%x ", nfc_cb.nfc_state);
+          DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("reset response nfc_state :0x%x ", nfc_cb.nfc_state);
           if (nfc_cb.flags & (NFC_FL_RESTARTING | NFC_FL_POWER_CYCLE_NFCC)) {
               nfc_reset_all_conn_cbs();
           }
-#if 0
-          /*Check NCI version only in case of reset rsp*/
-          if (!is_ntf && status == NCI_STATUS_OK) {
-              if ((*p) != NCI_VERSION) {
-                  NFC_TRACE_ERROR2("NCI version mismatch!!:0x%02x != 0x%02x ",
-                          NCI_VERSION, *p);
-                  if ((*p) < NCI_VERSION_0_F) {
-                      NFC_TRACE_ERROR0("NFCC version is too old");
-                      status = NCI_STATUS_FAILED;
-                  }
-              }
-          }
-#endif
       }
   }
 #else
-    NFC_TRACE_ERROR1("reset notification!!:0x%x ", status);
+    LOG(ERROR) << StringPrintf("reset notification!!:0x%x ", status);
     /* clean up, if the state is OPEN
      * FW does not report reset ntf right now */
+    if (status == NCI2_0_RESET_TRIGGER_TYPE_CORE_RESET_CMD_RECEIVED ||
+        status == NCI2_0_RESET_TRIGGER_TYPE_POWERED_ON) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("CORE_RESET_NTF Received status nfc_state : 0x%x : 0x%x",
+                       status, nfc_cb.nfc_state);
+      nfc_stop_timer(&nfc_cb.nci_wait_rsp_timer);
+      p++;
+      STREAM_TO_UINT8(nfc_cb.nci_version, p);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(" CORE_RESET_NTF nci_version%x", nfc_cb.nci_version);
+      status = NCI_STATUS_OK;
+    } else {
+      /* CORE_RESET_NTF received error case , trigger recovery*/
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("CORE_RESET_NTF Received status nfc_state : 0x%x : 0x%x",
+                       status, nfc_cb.nfc_state);
+      nfc_ncif_cmd_timeout();
+      status = NCI_STATUS_FAILED;
+    }
     if (nfc_cb.nfc_state == NFC_STATE_OPEN) {
       /*if any conn_cb is connected, close it.
         if any pending outgoing packets are dropped.*/
       nfc_reset_all_conn_cbs();
     }
-    status = NCI_STATUS_OK;
+  } else {
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("CORE_RESET_RSP len :0x%x ", *p_len);
+    if ((*p_len) == NCI_CORE_RESET_RSP_LEN(NCI_VERSION_2_0)) {
+      wait_for_ntf = TRUE;
+    } else if ((*p_len) == NCI_CORE_RESET_RSP_LEN(NCI_VERSION_1_0)) {
+      nfc_cb.nci_version = NCI_VERSION_1_0;
+    }
   }
 
   if (nfc_cb.flags & (NFC_FL_RESTARTING | NFC_FL_POWER_CYCLE_NFCC)) {
     nfc_reset_all_conn_cbs();
   }
-
-  if (status ==
-      NCI_STATUS_OK)  // Status of CORE_RESET_RESPONSE if not notification
-      {
-    if ((*p) != NCI_VERSION) {
-      NFC_TRACE_ERROR2("NCI version mismatch!!:0x%02x != 0x%02x ", NCI_VERSION,
-                       *p);
-      if ((*p) < NCI_VERSION_0_F) {
-        NFC_TRACE_ERROR0("NFCC version is too old");
-        status = NCI_STATUS_FAILED;
-      }
-    }
-  }
 #endif
 
   if (status == NCI_STATUS_OK) {
 #if (NXP_EXTNS == TRUE)
       if(nfcFL.nfccFL._NFCC_FORCE_NCI1_0_INIT) {
           if (!wait_for_ntf) {
-              NFC_TRACE_DEBUG0("Got CORE_RESET_NTF 2 sending CORE_INIT_CMD 1");
+              DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Got CORE_RESET_NTF 2 sending CORE_INIT_CMD 1");
               nci_snd_core_init(NCI_VERSION_1_0);
           } else {
-              NFC_TRACE_DEBUG0("Waiting for CORE_RESET_NTF 2 reason CMD received");
+              DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Waiting for CORE_RESET_NTF 2 reason CMD received");
               /* start NFC command-timeout timer */
               nfc_start_timer(&nfc_cb.nci_wait_rsp_timer,
                       (uint16_t)(NFC_TTYPE_NCI_WAIT_RSP),
@@ -2209,33 +2394,40 @@ void nfc_ncif_proc_reset_rsp(uint8_t* p, bool is_ntf) {
           }
       }
       else {
-          if(wait_for_ntf == true) {
-              /* reset version reported by NFCC is NCI2.0 , start a timer for 2000ms to
-               * wait for NTF*/
-              nfc_start_timer (&nfc_cb.nci_wait_rsp_timer, (uint16_t)(NFC_TTYPE_NCI_WAIT_RSP),
-                      nfc_cb.nci_wait_rsp_tout);
+#endif
+          if(wait_for_ntf == TRUE) {
+            /* reset version reported by NFCC is NCI2.0 , start a timer for 2000ms to
+             * wait for NTF*/
+            nfc_start_timer (&nfc_cb.nci_wait_rsp_timer,
+                             (uint16_t)(NFC_TTYPE_NCI_WAIT_RSP),
+                             nfc_cb.nci_wait_rsp_tout);
           } else {
-              if(nfc_cb.nci_version == NCI_VERSION_1_0)
-                  nci_snd_core_init(NCI_VERSION_1_0);
-              else
-                  nci_snd_core_init(NCI_VERSION_2_0);
+            /*MW tries to reInitialize, so clear nfa_dm_cb.params before
+             *proceeding, to avoid having previously initialized values if any*/
+            memset(&nfa_dm_cb.params, 0x00, sizeof(tNFA_DM_PARAMS));
+            if (nfc_cb.nci_version == NCI_VERSION_1_0)
+              nci_snd_core_init(NCI_VERSION_1_0);
+            else
+              nci_snd_core_init(NCI_VERSION_2_0);
           }
+#if (NXP_EXTNS == TRUE)
       }
-    NFC_TRACE_ERROR0("reset notification sending core init");
-#else
-    nci_snd_core_init();
 #endif
   } else {
+#if (NXP_EXTNS == TRUE)
     if(!core_reset_init_num_buff)
+    {
+        if(!nfa_dm_is_active())
         {
-            if(!nfa_dm_is_active())
-            {
-                status = NCI_STATUS_NOT_INITIALIZED;
-                NFC_Disable();
-            }
-            NFC_TRACE_ERROR0 ("Failed to reset NFCC");
-            nfc_enabled (status, NULL);
+            status = NCI_STATUS_NOT_INITIALIZED;
+            NFC_Disable();
         }
+#endif
+        LOG(ERROR) << StringPrintf("Failed to reset NFCC");
+        nfc_enabled (status, NULL);
+#if (NXP_EXTNS == TRUE)
+    }
+#endif
   }
 }
 
@@ -2246,7 +2438,7 @@ uint8_t nfc_hal_nfcc_reset(void) {
   uint8_t cmd_reset_nci[] = {0x20, 0x00, 0x01, 0x00};
   uint8_t core_status = NCI_STATUS_FAILED;
   uint8_t retry_count = 0;
-  NFC_TRACE_DEBUG0("Inside nfc_hal_nfcc_reset");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Inside nfc_hal_nfcc_reset");
 
   memset(&inpOutData, 0x00, sizeof(nfc_nci_IoctlInOutData_t));
   inpOutData.inp.data.nciCmd.cmd_len = sizeof(cmd_reset_nci);
@@ -2267,7 +2459,7 @@ uint8_t nfc_hal_nfcc_init(uint8_t** pinit_rsp) {
   uint8_t cmd_init_nci2_0[] = {0x20,0x01,0x02,0x00,0x00};
   uint8_t init_status = NCI_STATUS_FAILED;
   uint8_t retry_count = 0;
-  NFC_TRACE_DEBUG0("Inside nfc_hal_nfcc_init");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Inside nfc_hal_nfcc_init");
   if (pinit_rsp == NULL) return init_status;
 
   memset(&inpOutData, 0x00, sizeof(nfc_nci_IoctlInOutData_t));
@@ -2288,13 +2480,13 @@ uint8_t nfc_hal_nfcc_init(uint8_t** pinit_rsp) {
   } while (NCI_STATUS_OK != init_status &&
            retry_count < (NFC_NFCC_INIT_MAX_RETRY + 1));
   if (init_status == NCI_STATUS_OK && inpOutData.out.data.nciRsp.rsp_len > 0) {
-    *pinit_rsp = GKI_getbuf(inpOutData.out.data.nciRsp.rsp_len);
+    *pinit_rsp = (uint8_t*)GKI_getbuf(inpOutData.out.data.nciRsp.rsp_len);
     if (NULL != *pinit_rsp)
       memcpy(*pinit_rsp, inpOutData.out.data.nciRsp.p_rsp,
              inpOutData.out.data.nciRsp.rsp_len);
     else {
       init_status = NCI_STATUS_FAILED;
-      NFC_TRACE_DEBUG0("nfc_hal_nfcc_init: Memory alocation failed");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_hal_nfcc_init: Memory alocation failed");
     }
   }
   return init_status;
@@ -2310,7 +2502,7 @@ uint8_t nfc_hal_nfcc_init(uint8_t** pinit_rsp) {
 **
 *******************************************************************************/
 void nfc_ncif_proc_init_rsp(NFC_HDR* p_msg) {
-  uint8_t* p, status;
+  uint8_t *p, status;
   tNFC_CONN_CB* p_cb = &nfc_cb.conn_cb[NFC_RF_CONN_ID];
 #if (NXP_EXTNS == TRUE)
   nfc_nci_IoctlInOutData_t inpOutData;
@@ -2318,51 +2510,14 @@ void nfc_ncif_proc_init_rsp(NFC_HDR* p_msg) {
   uint16_t fw_status, fw_dwnld_status = NCI_STATUS_FAILED,
                       fw_mw_ver_status = NCI_STATUS_FAILED;
   tNFC_FWUpdate_Info_t fw_update_inf;
-  uint8_t* init_rsp = NULL;
   uint8_t config_resp[16];
-  int i;
   memset(&fw_update_inf, 0x00, sizeof(tNFC_FWUpdate_Info_t));
 #endif
   p = (uint8_t*)(p_msg + 1) + p_msg->offset;
+
   /* handle init params in nfc_enabled */
   status = *(p + NCI_MSG_HDR_SIZE);
 #if (NXP_EXTNS == TRUE)
-  if (NCI_STATUS_OK == status) {
-    // MW_FW recovery disabling at time of sig/crash/die
-    NFC_TRACE_DEBUG1("MW_RCVRY_FW_DNLD_ALLOWED  -> %d",
-                     MW_RCVRY_FW_DNLD_ALLOWED);
-    if (((nfcFL.nfccFL._NFCC_MW_RCVRY_BLK_FW_DNLD) &&
-            ((NFC_STATE_CORE_INIT == nfc_cb.nfc_state) &&
-                    (MW_RCVRY_FW_DNLD_ALLOWED == false))) ||
-            ((!nfcFL.nfccFL._NFCC_MW_RCVRY_BLK_FW_DNLD) &&
-                    (nfcFL.nfccFL._NFCC_MW_RCVRY_BLK_FW_DNLD)))
-    {
-      nfc_cb.p_hal->ioctl(HAL_NFC_IOCTL_CHECK_FLASH_REQ, &inpOutData);
-      fw_update_inf = *(tNFC_FWUpdate_Info_t*)&inpOutData.out.data.fwUpdateInf;
-      NFC_TRACE_DEBUG1("fw_update required  -> %d",
-                       fw_update_inf.fw_update_reqd);
-
-      if (fw_update_inf.fw_update_reqd == true) {
-          if(nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
-              uicc_eeprom_get_config(config_resp);
-          }
-        nfc_cb.p_hal->ioctl(HAL_NFC_IOCTL_FW_DWNLD, &inpOutData);
-        fw_dwnld_status = inpOutData.out.data.fwDwnldStatus;
-        status = nfc_hal_nfcc_reset();
-        if (NCI_STATUS_OK == status) {
-          status = nfc_hal_nfcc_init(&init_rsp);
-          if (NCI_STATUS_OK == status) {
-            /* Initialize NFC_HDR */
-            p_msg->len = init_rsp[2] + 3;
-            /* copying init rsp to p_msg  */
-            memcpy((uint8_t*)(p_msg + 1) + p_msg->offset, init_rsp, p_msg->len);
-          }
-          if (init_rsp)
-              GKI_freebuf(init_rsp);
-        }
-      }
-    }
-  }
   if(nfc_cb.nci_version != NCI_VERSION_2_0)
   {
       fw_status = nfc_ncif_store_FWVersion(p);
@@ -2398,11 +2553,29 @@ void nfc_ncif_proc_init_rsp(NFC_HDR* p_msg) {
       nci_snd_core_reset(NCI_RESET_TYPE_RESET_CFG);
     } else {
       p_cb->id = NFC_RF_CONN_ID;
+      // check scbr bit as per NCI 2.0 spec
+      nfc_cb.isScbrSupported = p[5] & NCI_SCBR_MASK;
+      DLOG_IF(INFO, nfc_debug_enabled)
+          << StringPrintf("scbr support: 0x%x", nfc_cb.isScbrSupported);
       p_cb->act_protocol = NCI_PROTOCOL_UNKNOWN;
+
       nfc_set_state(NFC_STATE_W4_POST_INIT_CPLT);
 
       nfc_cb.p_nci_init_rsp = p_msg;
-      nfc_cb.p_hal->core_initialized(p_msg->len - p_msg->offset, p);
+      nfc_cb.p_hal->core_initialized(p_msg->len, p);
+      struct stat file_stat;
+      /* In NCI 1.0 if pipe details not present (nfaStorage.bin not present)
+       * resetting nfcee session to get all pipe details.
+       * In case of NCI2.0 it is handled as part of NFCEE_MODE_SET_NTF */
+      if ((NFC_GetNCIVersion() < NCI_VERSION_2_0) &&
+          (stat("/data/nfc/nfaStorage.bin1", &file_stat) != 0)) {
+        status =
+            nfc_cb.p_hal->ioctl(HAL_NFC_IOCTL_NFCEE_SESSION_RESET, &inpOutData);
+        if (status != NCI_STATUS_OK) {
+          LOG(ERROR) << StringPrintf(
+              "HAL_NFC_IOCTL_NFCEE_SESSION_RESET Failed");
+        }
+      }
     }
   }
 #if (NXP_EXTNS == TRUE)
@@ -2423,6 +2596,7 @@ void nfc_ncif_proc_init_rsp(NFC_HDR* p_msg) {
 #if (NXP_EXTNS == TRUE)
     status = NCI_STATUS_FAILED;
     retry_cnt = 0;
+#endif
     if(nfc_cb.nci_version == NCI_VERSION_UNKNOWN) {
       nfc_cb.nci_version = NCI_VERSION_1_0;
       nci_snd_core_reset(NCI_RESET_TYPE_RESET_CFG);
@@ -2430,10 +2604,6 @@ void nfc_ncif_proc_init_rsp(NFC_HDR* p_msg) {
       nfc_enabled(status, NULL);
       GKI_freebuf(p_msg);
     }
-#else
-    nfc_enabled(status, NULL);
-    GKI_freebuf(p_msg);
-#endif
   }
 }
 
@@ -2459,7 +2629,7 @@ tNFC_STATUS nfc_ncif_store_FWVersion(uint8_t* p_buf) {
       nfc_fw_version.major_version == 0) {
     status = NFC_STATUS_FAILED;
   }
-  NFC_TRACE_DEBUG3("FW Version: %x.%x.%x", nfc_fw_version.rom_code_version,
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("FW Version: %x.%x.%x", nfc_fw_version.rom_code_version,
                    nfc_fw_version.major_version, nfc_fw_version.minor_version);
   return status;
 }
@@ -2473,10 +2643,10 @@ tNFC_STATUS nfc_ncif_store_FWVersion(uint8_t* p_buf) {
 **
 *******************************************************************************/
 tNFC_STATUS nfc_ncif_set_MaxRoutingTableSize(uint8_t* p_buf) {
-    NFC_TRACE_DEBUG0("nfc_ncif_set_MaxRoutingTableSize Enter");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_ncif_set_MaxRoutingTableSize Enter");
 
     if(!((nfcFL.chipType != pn547C2) && nfcFL.nfcMwFL._NFC_NXP_AID_MAX_SIZE_DYN)) {
-        NFC_TRACE_DEBUG0("chipType : pn547C2 or NFC_NXP_AID_MAX_SIZE_DYN"
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("chipType : pn547C2 or NFC_NXP_AID_MAX_SIZE_DYN"
                 " not available.. Returning");
         return NFC_STATUS_FAILED;
 
@@ -2485,7 +2655,7 @@ tNFC_STATUS nfc_ncif_set_MaxRoutingTableSize(uint8_t* p_buf) {
   int len = p_buf[2] + 2; /*include 2 byte header*/
   maxRoutingTableSize = p_buf[len - 8];
   maxRoutingTableSize = maxRoutingTableSize << 8 | p_buf[len - 9];
-  NFC_TRACE_DEBUG1("MAX Routing size : %d", maxRoutingTableSize);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("MAX Routing size : %d", maxRoutingTableSize);
   if (maxRoutingTableSize == 0) {
     status = NFC_STATUS_FAILED;
   }
@@ -2503,23 +2673,13 @@ tNFC_STATUS nfc_ncif_set_MaxRoutingTableSize(uint8_t* p_buf) {
 *******************************************************************************/
 uint16_t nfc_ncif_getMaxRoutingTableSize() {
     if(!((nfcFL.chipType != pn547C2) && nfcFL.nfcMwFL._NFC_NXP_AID_MAX_SIZE_DYN)) {
-        NFC_TRACE_DEBUG0("getMaxRoutingTableSize : chipType : pn547C2 or "
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("getMaxRoutingTableSize : chipType : pn547C2 or "
                 "NFC_NXP_AID_MAX_SIZE_DYN not available.. Returning");
         return 0;
 
     }
     return maxRoutingTableSize;
 }
-/*******************************************************************************
-**
-** Function         nfc_ncif_getFWVersion
-**
-** Description      This function is called to fet the FW Version
-**
-** Returns          tNFC_FW_VERSION
-**
-*******************************************************************************/
-tNFC_FW_VERSION nfc_ncif_getFWVersion() { return nfc_fw_version; }
 
 /*******************************************************************************
 **
@@ -2533,7 +2693,7 @@ tNFC_FW_VERSION nfc_ncif_getFWVersion() { return nfc_fw_version; }
 void nfc_ncif_storeScreenState(uint8_t state) {
   /* store the screen state */
   gScreenState = state;
-  NFC_TRACE_DEBUG1("nfc_ncif_storeScreenState gScreenState : %d", gScreenState);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_ncif_storeScreenState gScreenState : %d", gScreenState);
 }
 #endif
 /*******************************************************************************
@@ -2639,7 +2799,7 @@ void nfc_data_event(tNFC_CONN_CB* p_cb) {
           if ((p_cb->act_protocol == NCI_PROTOCOL_T2T) &&
               (p_cb->act_interface == NCI_INTERFACE_FIRST_VS) &&
               (p_cb->sel_res == 0x01)) {
-            NFC_TRACE_ERROR0("Skylander tag detected dont handle this");
+            LOG(ERROR) << StringPrintf("Skylander tag detected dont handle this");
           } else
 #endif
           {
@@ -2652,23 +2812,26 @@ void nfc_data_event(tNFC_CONN_CB* p_cb) {
              if((data_cevt.status != NFC_STATUS_OK) &&
                      ((data_cevt.status >= T2T_STATUS_OK_1_BIT)&&(data_cevt.status <= T2T_STATUS_OK_7_BIT)))
              {
-                 NFC_TRACE_DEBUG0("nfc_data_event: T2T tag data xchange");
+                 DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_data_event: T2T tag data xchange");
                  data_cevt.status = NFC_STATUS_OK;
              }
               }
           }
         }
 #if (NXP_EXTNS == TRUE)
-        if(p_cb->act_protocol == NCI_PROTOCOL_15693)
-        {
+        if ( p_cb->act_protocol == NCI_PROTOCOL_T5T) {
+#else
+        if ((NFC_GetNCIVersion() == NCI_VERSION_2_0) &&
+            (p_cb->act_protocol == NCI_PROTOCOL_T5T)) {
+#endif
           p_evt->len--;
           p = (uint8_t*)(p_evt + 1);
           data_cevt.status = *(p + p_evt->offset + p_evt->len);
         }
-#endif
       }
-
-      (*p_cb->p_cback)(p_cb->conn_id, NFC_DATA_CEVT, (void*)&data_cevt);
+      tNFC_CONN nfc_conn;
+      nfc_conn.data = data_cevt;
+      (*p_cb->p_cback)(p_cb->conn_id, NFC_DATA_CEVT, &nfc_conn);
       p_evt = NULL;
     }
   }
@@ -2696,7 +2859,7 @@ void nfc_ncif_proc_data(NFC_HDR* p_msg) {
   uint16_t len;
 
   pp = (uint8_t*)(p_msg + 1) + p_msg->offset;
-  NFC_TRACE_DEBUG3("nfc_ncif_proc_data 0x%02x%02x%02x", pp[0], pp[1], pp[2]);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_ncif_proc_data 0x%02x%02x%02x", pp[0], pp[1], pp[2]);
   NCI_DATA_PRS_HDR(pp, pbf, cid, len);
   p_cb = nfc_find_conn_cb_by_conn_id(cid);
 #if (NXP_EXTNS == TRUE)
@@ -2707,15 +2870,13 @@ void nfc_ncif_proc_data(NFC_HDR* p_msg) {
   }
 #endif
   if (p_cb && (p_msg->len >= NCI_DATA_HDR_SIZE)) {
-    NFC_TRACE_DEBUG1("nfc_ncif_proc_data len:%d", len);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_ncif_proc_data len:%d", len);
 
     p_msg->layer_specific = 0;
     if (pbf) {
-#if (NXP_EXTNS == TRUE)
-      NFC_TRACE_DEBUG0(
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "nfc_ncif_proc_data requesting reassembly for chained data");
-      nfc_cb.reassembly = true;
-#endif
+      NFC_SetReassemblyFlag(true);
       p_msg->layer_specific = NFC_RAS_FRAGMENTED;
     }
     p_last = (NFC_HDR*)GKI_getlast(&p_cb->rx_q);
@@ -2760,15 +2921,9 @@ void nfc_ncif_proc_data(NFC_HDR* p_msg) {
         p_last->len += len;
         /* do not need to update pbf and len in NCI header.
          * They are stripped off at NFC_DATA_CEVT and len may exceed 255 */
-        NFC_TRACE_DEBUG1("nfc_ncif_proc_data len:%d", p_last->len);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_ncif_proc_data len:%d", p_last->len);
         p_last->layer_specific = p_msg->layer_specific;
         GKI_freebuf(p_msg);
-#ifdef DISP_NCI
-        if (!(p_last->layer_specific & NFC_RAS_FRAGMENTED)) {
-          /* this packet was reassembled. display the complete packet */
-          DISP_NCI((uint8_t*)(p_last + 1) + p_last->offset, p_last->len, true);
-        }
-#endif
         nfc_data_event(p_cb);
       } else {
         /* Not enough memory to add new buffer
@@ -2803,19 +2958,20 @@ void nfc_ncif_proc_data(NFC_HDR* p_msg) {
 *******************************************************************************/
 void nfc_modeset_ntf_timeout()
 {
-  NFC_TRACE_ERROR0("nfc_ncif_modeSet_Ntf_timeout");
-  tNFC_NFCEE_MODE_SET_REVT    mode_set_info;
-  tNFC_RESPONSE_CBACK  *p_cback = nfc_cb.p_resp_cback;
-  tNFC_NFCEE_INFO_REVT nfcee_info;
+  LOG(ERROR) << StringPrintf("nfc_ncif_modeSet_Ntf_timeout");
+  tNFC_RESPONSE nfc_response;
+  nfc_response.mode_set.status = NCI_STATUS_FAILED;
+  nfc_response.mode_set.nfcee_id = *nfc_cb.last_cmd;
+  nfc_response.mode_set.mode = NCI_NFCEE_MD_DEACTIVATE;
   nfc_cb.flags  &= ~NFC_FL_WAIT_MODE_SET_NTF;
+
+  tNFC_RESPONSE_CBACK  *p_cback = nfc_cb.p_resp_cback;
   tNFC_RESPONSE_EVT event    = NFC_NFCEE_MODE_SET_REVT;
-  mode_set_info.status        = NCI_STATUS_FAILED;
 
-  tNFC_RESPONSE* p_evt = (tNFC_RESPONSE*)&nfcee_info;
-  p_evt = (tNFC_RESPONSE*)&mode_set_info;
+
 
     if (p_cback)
-        (*p_cback) (event, p_evt);
+        (*p_cback) (event, &nfc_response);
 }
 
 #if (NXP_EXTNS == TRUE)
@@ -2829,7 +2985,7 @@ void nfc_modeset_ntf_timeout()
 **
 *******************************************************************************/
 void nfc_ncif_credit_ntf_timeout() {
-  NFC_TRACE_DEBUG0("nfc_ncif_credit_ntf_timeout : Enter");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_ncif_credit_ntf_timeout : Enter");
 
 #if (NXP_EXTNS == TRUE)
   tNFC_CONN_CB* p_cb;
@@ -2842,7 +2998,7 @@ void nfc_ncif_credit_ntf_timeout() {
     nfa_sys_stop_timer(&nfa_hci_cb.timer);
 
     // send timeout event to upper layer
-    nfa_hci_rsp_timeout(NULL);
+    nfa_hci_rsp_timeout();
 
     // will be used to reset credit buffer after recovery
     core_reset_init_num_buff = true;
@@ -2859,7 +3015,7 @@ void nfc_ncif_credit_ntf_timeout() {
 
   if (get_i2c_fragmentation_enabled() == I2C_FRAGMENATATION_ENABLED) {
     // nfc_cb.nfc_state = NFC_STATE_RECOVERY;
-    NFC_TRACE_DEBUG0("nfc_ncif_credit_ntf_timeout :decrementing window");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_ncif_credit_ntf_timeout :decrementing window");
     // TODO: Write logic for VEN_RESET.
     nfc_cb.p_hal->power_cycle();
     // Remove the pending cmds from the cmd queue. send any pending rsp/cback to
@@ -2879,7 +3035,7 @@ void nfc_ncif_credit_ntf_timeout() {
       nfc_cb.i2c_data_t.data_ntf_timeout = 0;
     }
   }
-  NFC_TRACE_ERROR0("cmd timeout sending core reset!!!");
+  LOG(ERROR) << StringPrintf("cmd timeout sending core reset!!!");
   nfc_ncif_cmd_timeout();
   // nci_snd_core_reset(0x00);
 }
@@ -2889,90 +3045,50 @@ void nfc_ncif_credit_ntf_timeout() {
 ** Function         nfc_ncif_process_proprietary_rsp
 **
 ** Description      Process the response to avoid collision
-**                  while nxpCbflag is set
+**                  while rawVsCbflag is set
 **
 ** Returns          true if proprietary response else false
 **
 *******************************************************************************/
-
 bool nfc_ncif_proc_proprietary_rsp(uint8_t mt, uint8_t gid, uint8_t oid) {
-  bool stat = false;
-  NFC_TRACE_DEBUG3("nfc_ncif_proc_proprietary_rsp: mt=%u, gid=%u, oid=%u", mt,
-                   gid, oid);
+  bool stat = FALSE;
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: mt=%u, gid=%u, oid=%u", __func__, mt, gid, oid);
+
   switch (mt) {
     case NCI_MT_DATA:
-      switch (gid) {
-        case 0x03:
-          switch (oid) {
-            case 0x00: /*Data Response*/
-              stat = false;
-              break;
-
-            default:
-              stat = true;
-              break;
-          }
-          break;
-
-        default:
-          stat = true;
-          break;
-      }
+      /* check for Data Response */
+      if (gid != 0x03 && oid != 0x00) stat = TRUE;
       break;
 
     case NCI_MT_NTF:
       switch (gid) {
         case NCI_GID_CORE:
-          switch (oid) {
-            case 0x00: /*CORE_RESET_NTF*/
-            case 0x06: /*CORE_CONN_CREDITS_NTF*/
-              stat = false;
-              break;
-
-            default:
-              stat = true;
-              break;
-          }
+          /* check for CORE_RESET_NTF or CORE_CONN_CREDITS_NTF */
+          if (oid != 0x00 && oid != 0x06) stat = TRUE;
           break;
         case NCI_GID_RF_MANAGE:
-          switch (oid) {
-            case 0x06: /*CORE_CONN_CREDITS_NTF*/
-              stat = false;
-              break;
-            case 0x09:
-              stat = false; /*NFA_EE_ACTION_NTF*/
-              break;
-            case 0x0A: /*NFA_EE_DISCOVERY_REQ_NTF*/
-              stat = false;
-              break;
-            default:
-              stat = true;
-              break;
-          }
+          /* check for CORE_CONN_CREDITS_NTF or NFA_EE_ACTION_NTF or
+           * NFA_EE_DISCOVERY_REQ_NTF */
+          if (oid != 0x06 && oid != 0x09 && oid != 0x0A) stat = TRUE;
           break;
         case NCI_GID_EE_MANAGE:
-          switch (oid) {
-            case 0x00:
-            case 0x01:
-            /*FALL_THRU: NFCEE_MODE_SET_NTF*/
-              stat = false;
-              break;
-            default:
-              stat = true;
-              break;
-          }
+          if (oid != 0x00
+#if (NXP_EXTNS == TRUE)
+          && oid != 0x01
+#endif
+           ) stat = TRUE;
           break;
         default:
-          stat = true;
+          stat = TRUE;
           break;
       }
       break;
 
     default:
-      stat = true;
+      stat = TRUE;
       break;
   }
-  NFC_TRACE_DEBUG1("nfc_ncif_proc_proprietary_rsp: exit status=%u", stat);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: exit status=%u", __func__, stat);
   return stat;
 }
 
@@ -2981,7 +3097,7 @@ bool nfc_ncif_proc_proprietary_rsp(uint8_t mt, uint8_t gid, uint8_t oid) {
 #if (NXP_EXTNS == TRUE)
 void disc_deact_ntf_timeout_handler(tNFC_RESPONSE_EVT event) {
     if(!(nfcFL.nfcNxpEse && nfcFL.eseFL._ESE_ETSI_READER_ENABLE)) {
-        NFC_TRACE_DEBUG0("disc_deact_ntf_timeout_handler : nfcNxpEse or "
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("disc_deact_ntf_timeout_handler : nfcNxpEse or "
                 "ETSI_READER_ENABLE not available. Returning..");
         return;
     }
@@ -3006,18 +3122,16 @@ void disc_deact_ntf_timeout_handler(tNFC_RESPONSE_EVT event) {
 **
 *******************************************************************************/
 tNFC_STATUS nfc_ncif_reset_nfcc() {
-  NFC_TRACE_DEBUG1("%s : Enter", __func__);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s : Enter", __func__);
   if(!nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
-      NFC_TRACE_DEBUG0("NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH"
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH"
               " feature is not available!!");
       return (NFA_STATUS_FAILED);
   }
   nfc_nci_IoctlInOutData_t inpOutData;
   uint8_t status = NCI_STATUS_FAILED;
-  int isfound, retry_count = 0;
+  int retry_count = 0;
   long retlen = 0;
-  uint8_t* buffer = NULL;
-  long bufflen = 256;
 
   /*NCI_INIT_CMD*/
   static uint8_t cmd_init_nci[] = {0x20, 0x01, 0x00};
@@ -3081,7 +3195,7 @@ tNFC_STATUS nfc_ncif_reset_nfcc() {
     retry_count++;
   } while ((status != NCI_STATUS_OK) && (retry_count <= 3));
 TheEndReset:
-  NFC_TRACE_DEBUG1("%s : Exit", __func__);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s : Exit", __func__);
   return status;
 }
 /*******************************************************************************
@@ -3094,28 +3208,25 @@ TheEndReset:
 **
 *******************************************************************************/
 void uicc_eeprom_get_config(uint8_t* config_resp) {
-  NFC_TRACE_DEBUG1("%s : Enter", __func__);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s : Enter", __func__);
   if(!nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
-      NFC_TRACE_DEBUG0("NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH"
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH"
               " feature is not available!!");
       return;
   }
   uint8_t cmd_get_dualUicc_config[] = {0x20, 0x03, 0x03, 0x01, 0xA0, 0xEC};
   nfc_nci_IoctlInOutData_t inpOutData;
   int uicc_mode = 0;
-  uint8_t* config_rsp = NULL;
   uint8_t config_status = NCI_STATUS_FAILED;
   uint8_t retry_count = 0;
 
-  if (GetNumValue(NAME_NXP_DUAL_UICC_ENABLE, &uicc_mode,
-          sizeof(int))) {
-    NFC_TRACE_DEBUG1("NXP_DUAL_UICC_ENABLE : 0x%02x", uicc_mode);
-
+  if (NfcConfig::hasKey(NAME_NXP_DUAL_UICC_ENABLE)) {
+    uicc_mode = NfcConfig::getUnsigned(NAME_NXP_DUAL_UICC_ENABLE);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NXP_DUAL_UICC_ENABLE : 0x%02x", uicc_mode);
   } else {
     uicc_mode = 0x00;
-    NFC_TRACE_DEBUG1(
-        "NXP_DUAL_UICC_ENABLE not found; taking default value : 0x%02x",
-        uicc_mode);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "NXP_DUAL_UICC_ENABLE not found; taking default value : 0x%02x", uicc_mode);
   }
   memset(&inpOutData, 0x00, sizeof(nfc_nci_IoctlInOutData_t));
   inpOutData.inp.data.nciCmd.cmd_len = sizeof(cmd_get_dualUicc_config);
@@ -3130,7 +3241,7 @@ void uicc_eeprom_get_config(uint8_t* config_resp) {
       inpOutData.out.data.nciRsp.rsp_len > 0) {
     memcpy(config_resp, inpOutData.out.data.nciRsp.p_rsp, inpOutData.out.data.nciRsp.rsp_len);
   } else {
-    NFC_TRACE_DEBUG1("%s :HAL_NFC_IOCTL_NCI_TRANSCEIVE Failed", __func__);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s :HAL_NFC_IOCTL_NCI_TRANSCEIVE Failed", __func__);
   }
 }
 
@@ -3144,9 +3255,9 @@ void uicc_eeprom_get_config(uint8_t* config_resp) {
 **
 *******************************************************************************/
 void uicc_eeprom_set_config(uint8_t* config_rsp) {
-  NFC_TRACE_DEBUG1("%s : Enter", __func__);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s : Enter", __func__);
   if(!nfcFL.nfccFL._NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH) {
-      NFC_TRACE_DEBUG0("NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH"
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_NXP_STAT_DUAL_UICC_EXT_SWITCH"
               " feature is not available!!");
       return;
   }
@@ -3157,16 +3268,15 @@ void uicc_eeprom_set_config(uint8_t* config_rsp) {
   uint8_t config_status = NCI_STATUS_FAILED;
   uint8_t retry_count = 0;
 
-  if (GetNumValue(NAME_NXP_DUAL_UICC_ENABLE, &uicc_mode,
-          sizeof(int))) {
-    NFC_TRACE_DEBUG1("NXP_DUAL_UICC_ENABLE : 0x%02x", uicc_mode);
-
+  if (NfcConfig::hasKey(NAME_NXP_DUAL_UICC_ENABLE)) {
+    uicc_mode = NfcConfig::getUnsigned(NAME_NXP_DUAL_UICC_ENABLE);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NXP_DUAL_UICC_ENABLE : 0x%02x", uicc_mode);
   } else {
     uicc_mode = 0x00;
-    NFC_TRACE_DEBUG1(
-        "NXP_DUAL_UICC_ENABLE not found; taking default value : 0x%02x",
-        uicc_mode);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+        "NXP_DUAL_UICC_ENABLE not found; taking default value : 0x%02x", uicc_mode);
   }
+
   memset(&inpOutData, 0x00, sizeof(nfc_nci_IoctlInOutData_t));
 
   if (uicc_mode == 0x00) {
@@ -3184,7 +3294,7 @@ void uicc_eeprom_set_config(uint8_t* config_rsp) {
     retry_count++;
   } while ((config_status != NCI_STATUS_OK) && (retry_count <= 3));
   if ((config_status != NCI_STATUS_OK) && (retry_count = 4)) {
-    NFC_TRACE_DEBUG1("%s :HAL_NFC_IOCTL_NCI_TRANSCEIVE Failed", __func__);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s :HAL_NFC_IOCTL_NCI_TRANSCEIVE Failed", __func__);
   }
 }
 #endif
diff --git a/src/nfc/nfc/nfc_task.c b/src/nfc/nfc/nfc_task.cc
old mode 100644
new mode 100755
similarity index 92%
rename from src/nfc/nfc/nfc_task.c
rename to src/nfc/nfc/nfc_task.cc
index 15d00a6..7be6327
--- a/src/nfc/nfc/nfc_task.c
+++ b/src/nfc/nfc/nfc_task.cc
@@ -42,12 +42,13 @@
  *
  ******************************************************************************/
 #include <string.h>
-#include "gki.h"
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfc_target.h"
 #include "bt_types.h"
-
-#include "nfc_api.h"
-#include "nfc_hal_api.h"
+#include "gki.h"
 #include "nfc_int.h"
 #include "nci_hmsgs.h"
 #include "rw_int.h"
@@ -58,9 +59,12 @@
 #define llcp_cleanup()
 #endif
 
-#include "nfa_sys.h"
 #include "nfa_dm_int.h"
 
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+
 /*******************************************************************************
 **
 ** Function         nfc_start_timer
@@ -131,7 +135,8 @@ void nfc_process_timer_evt(void) {
     GKI_remove_from_timer_list(&nfc_cb.timer_queue, p_tle);
 #if(NXP_EXTNS == TRUE)
     /*Ignore expired timer when NFC off is in progress*/
-    if(nfc_cb.nfc_state == NFC_STATE_W4_HAL_CLOSE){
+    if(nfc_cb.nfc_state == NFC_STATE_W4_HAL_CLOSE ||
+       nfc_cb.nfc_state == NFC_STATE_NONE){
         return;
     }
 #endif
@@ -175,9 +180,9 @@ void nfc_process_timer_evt(void) {
 #endif
 
       default:
-        NFC_TRACE_DEBUG2("nfc_process_timer_evt: timer:0x%x event (0x%04x)",
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_process_timer_evt: timer:0x%p event (0x%04x)",
                          p_tle, p_tle->event);
-        NFC_TRACE_DEBUG1(
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
             "nfc_process_timer_evt: unhandled timer event (0x%04x)",
             p_tle->event);
     }
@@ -300,7 +305,7 @@ void nfc_process_quick_timer_evt(void) {
         rw_t1t_process_timeout(p_tle);
         break;
       case NFC_TTYPE_RW_T2T_RESPONSE:
-        rw_t2t_process_timeout(p_tle);
+        rw_t2t_process_timeout();
         break;
       case NFC_TTYPE_RW_T3T_RESPONSE:
         rw_t3t_process_timeout(p_tle);
@@ -340,7 +345,7 @@ void nfc_process_quick_timer_evt(void) {
           break;
 #endif
       default:
-        NFC_TRACE_DEBUG1(
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
             "nfc_process_quick_timer_evt: unhandled timer event (0x%04x)",
             p_tle->event);
         break;
@@ -365,12 +370,6 @@ void nfc_process_quick_timer_evt(void) {
 void nfc_task_shutdown_nfcc(void) {
   NFC_HDR* p_msg;
 
-#if (NXP_EXTNS == TRUE)
- if(nfcFL.eseFL._ESE_DUAL_MODE_PRIO_SCHEME == nfcFL.eseFL._ESE_WIRED_MODE_RESUME) {
-     nfc_stop_timer(&nfc_cb.rf_filed_event_timeout_timer);
- }
-#endif
-
   /* Free any messages still in the mbox */
   while ((p_msg = (NFC_HDR*)GKI_read_mbox(NFC_MBOX_ID)) != NULL) {
     GKI_freebuf(p_msg);
@@ -407,27 +406,29 @@ void nfc_task_shutdown_nfcc(void) {
 ** Returns          nothing
 **
 *******************************************************************************/
-uint32_t nfc_task(uint32_t param) {
+uint32_t nfc_task(__attribute__((unused)) uint32_t arg) {
   uint16_t event;
   NFC_HDR* p_msg;
   bool free_buf;
-  (void)param;
 
   /* Initialize the nfc control block */
   memset(&nfc_cb, 0, sizeof(tNFC_CB));
-  nfc_cb.trace_level = NFC_INITIAL_TRACE_LEVEL;
 
-  NFC_TRACE_DEBUG0("NFC_TASK started.");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_TASK started.");
 
   /* main loop */
   while (true) {
     event = GKI_wait(0xFFFF, 0);
-    if (event == EVENT_MASK(GKI_SHUTDOWN_EVT)) {
+    if (event == EVENT_MASK(GKI_UNKNOWN_TASK_EVT)) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("GKI_UNKNOWN_TASK_EVT");
+      break;
+    } else if (event == EVENT_MASK(GKI_SHUTDOWN_EVT)) {
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("GKI_SHUTDOWN_EVT");
       break;
     }
     /* Handle NFC_TASK_EVT_TRANSPORT_READY from NFC HAL */
     if (event & NFC_TASK_EVT_TRANSPORT_READY) {
-      NFC_TRACE_DEBUG0("NFC_TASK got NFC_TASK_EVT_TRANSPORT_READY.");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NFC_TASK got NFC_TASK_EVT_TRANSPORT_READY.");
 
       /* Reset the NFC controller. */
       nfc_set_state(NFC_STATE_CORE_INIT);
@@ -466,7 +467,7 @@ uint32_t nfc_task(uint32_t param) {
             break;
 
           default:
-            NFC_TRACE_DEBUG1("nfc_task: unhandle mbox message, event=%04x",
+            DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_task: unhandle mbox message, event=%04x",
                              p_msg->event);
             break;
         }
@@ -498,8 +499,6 @@ uint32_t nfc_task(uint32_t param) {
     }
   }
 
-  NFC_TRACE_DEBUG0("nfc_task terminated");
-
-  GKI_exit_task(GKI_get_taskid());
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_task terminated");
   return 0;
 }
diff --git a/src/nfc/nfc/nfc_test.c b/src/nfc/nfc/nfc_test.cc
similarity index 100%
rename from src/nfc/nfc/nfc_test.c
rename to src/nfc/nfc/nfc_test.cc
diff --git a/src/nfc/nfc/nfc_utils.c b/src/nfc/nfc/nfc_utils.cc
similarity index 93%
rename from src/nfc/nfc/nfc_utils.c
rename to src/nfc/nfc/nfc_utils.cc
index 9176807..a0a4a31 100644
--- a/src/nfc/nfc/nfc_utils.c
+++ b/src/nfc/nfc/nfc_utils.cc
@@ -23,12 +23,17 @@
  *  (callback). On the transmit side, it manages the command transmission.
  *
  ******************************************************************************/
-#include "nfc_target.h"
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "bt_types.h"
 #include "nfc_api.h"
-
 #include "nfc_int.h"
 
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+
 /*******************************************************************************
 **
 ** Function         nfc_alloc_conn_cb
@@ -79,7 +84,7 @@ void nfc_set_conn_id(tNFC_CONN_CB* p_cb, uint8_t conn_id) {
   p_cb->conn_id = conn_id;
   handle = (uint8_t)(p_cb - nfc_cb.conn_cb + 1);
   nfc_cb.conn_id[conn_id] = handle;
-  NFC_TRACE_DEBUG2("nfc_set_conn_id conn_id:%d, handle:%d", conn_id, handle);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("nfc_set_conn_id conn_id:%d, handle:%d", conn_id, handle);
 }
 
 /*******************************************************************************
@@ -181,11 +186,15 @@ extern void nfc_reset_all_conn_cbs(void) {
   deact.status = NFC_STATUS_NOT_INITIALIZED;
   deact.type = NFC_DEACTIVATE_TYPE_IDLE;
   deact.is_ntf = true;
+  deact.reason = NCI_DEACTIVATE_REASON_DH_REQ;
   for (xx = 0; xx < NCI_MAX_CONN_CBS; xx++, p_conn_cb++) {
     if (p_conn_cb->conn_id != NFC_ILLEGAL_CONN_ID) {
-      if (p_conn_cb->p_cback)
+      if (p_conn_cb->p_cback) {
+        tNFC_CONN nfc_conn;
+        nfc_conn.deactivate = deact;
         (*p_conn_cb->p_cback)(p_conn_cb->conn_id, NFC_DEACTIVATE_CEVT,
-                              (void*)&deact);
+                              &nfc_conn);
+      }
       nfc_free_conn_cb(p_conn_cb);
     }
   }
diff --git a/src/nfc/nfc/nfc_vs.c b/src/nfc/nfc/nfc_vs.cc
similarity index 88%
rename from src/nfc/nfc/nfc_vs.c
rename to src/nfc/nfc/nfc_vs.cc
index 286cc64..1076edb 100644
--- a/src/nfc/nfc/nfc_vs.c
+++ b/src/nfc/nfc/nfc_vs.cc
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -43,11 +43,17 @@
  *
  ******************************************************************************/
 #include <string.h>
-#include "gki.h"
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfc_target.h"
 
+#include "gki.h"
 #include "nfc_int.h"
 
+using android::base::StringPrintf;
+
 /****************************************************************************
 ** Declarations
 ****************************************************************************/
@@ -90,6 +96,36 @@ tNFC_STATUS NFC_RegVSCback(bool is_register, tNFC_VS_CBACK* p_cback) {
   return status;
 }
 
+/*******************************************************************************
+**
+** Function         NFC_SendRawVsCommand
+**
+** Description      This function is called to send the raw vendor specific
+**                  command to NFCC. The response from NFCC is reported to the
+**                  given tNFC_VS_CBACK.
+**
+** Parameters       p_data - The command buffer
+**
+** Returns          tNFC_STATUS
+**
+*******************************************************************************/
+tNFC_STATUS NFC_SendRawVsCommand(NFC_HDR* p_data, tNFC_VS_CBACK* p_cback) {
+  /* Validate parameters */
+  if (p_data == NULL || (p_data->len > NCI_MAX_VSC_SIZE)) {
+    LOG(ERROR) << StringPrintf("buffer offset must be >= %d", NCI_VSC_MSG_HDR_SIZE);
+    if (p_data) GKI_freebuf(p_data);
+    return NFC_STATUS_INVALID_PARAM;
+  }
+
+  p_data->event = BT_EVT_TO_NFC_NCI;
+  p_data->layer_specific = NFC_WAIT_RSP_RAW_VS;
+  /* save the callback function in the BT_HDR, to receive the response */
+  ((tNFC_NCI_VS_MSG*)p_data)->p_cback = p_cback;
+
+  nfc_ncif_check_cmd_queue(p_data);
+  return NFC_STATUS_OK;
+}
+
 /*******************************************************************************
 **
 ** Function         NFC_SendVsCommand
@@ -121,7 +157,7 @@ tNFC_STATUS NFC_SendVsCommand(uint8_t oid, NFC_HDR* p_data,
   /* Validate parameters */
   if ((p_data == NULL) || (p_data->offset < NCI_VSC_MSG_HDR_SIZE) ||
       (p_data->len > NCI_MAX_VSC_SIZE)) {
-    NFC_TRACE_ERROR1("buffer offset must be >= %d", NCI_VSC_MSG_HDR_SIZE);
+    LOG(ERROR) << StringPrintf("buffer offset must be >= %d", NCI_VSC_MSG_HDR_SIZE);
     if (p_data) GKI_freebuf(p_data);
     return NFC_STATUS_INVALID_PARAM;
   }
@@ -140,38 +176,3 @@ tNFC_STATUS NFC_SendVsCommand(uint8_t oid, NFC_HDR* p_data,
   nfc_ncif_check_cmd_queue(p_data);
   return status;
 }
-#if (NXP_EXTNS == TRUE)
-/*******************************************************************************
-**
-** Function         NFC_SendNxpNciCommand
-**
-** Description      This function is called to send the given nxp specific
-**                  command to NFCC. The response from NFCC is reported to the
-**                  given tNFC_VS_CBACK.
-**
-** Parameters       p_data - The command buffer
-**
-** Returns          tNFC_STATUS
-**
-*******************************************************************************/
-tNFC_STATUS NFC_SendNxpNciCommand(NFC_HDR* p_data, tNFC_VS_CBACK* p_cback) {
-  tNFC_STATUS status = NFC_STATUS_OK;
-  uint8_t* pp;
-
-  /* Validate parameters */
-  if ((p_data == NULL) || (p_data->len > NCI_MAX_VSC_SIZE)) {
-    NFC_TRACE_ERROR1("buffer offset must be >= %d", NCI_VSC_MSG_HDR_SIZE);
-    if (p_data) GKI_freebuf(p_data);
-    return NFC_STATUS_INVALID_PARAM;
-  }
-
-  p_data->event = BT_EVT_TO_NFC_NCI;
-  p_data->layer_specific = NFC_WAIT_RSP_NXP;
-  /* save the callback function in the NFC_HDR, to receive the response */
-  ((tNFC_NCI_VS_MSG*)p_data)->p_cback = p_cback;
-  pp = (uint8_t*)(p_data + 1) + p_data->offset;
-
-  nfc_ncif_check_cmd_queue(p_data);
-  return status;
-}
-#endif
diff --git a/src/nfc/tags/ce_main.c b/src/nfc/tags/ce_main.cc
similarity index 81%
rename from src/nfc/tags/ce_main.c
rename to src/nfc/tags/ce_main.cc
index 30d97fa..b1d1668 100644
--- a/src/nfc/tags/ce_main.c
+++ b/src/nfc/tags/ce_main.cc
@@ -24,14 +24,19 @@
  *
  ******************************************************************************/
 #include <string.h>
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfc_target.h"
 #include "bt_types.h"
 
-#include "nfc_api.h"
-#include "nci_hmsgs.h"
 #include "ce_api.h"
 #include "ce_int.h"
-#include "gki.h"
+
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
 
 tCE_CB ce_cb;
 
@@ -39,7 +44,6 @@ tCE_CB ce_cb;
 *******************************************************************************/
 void ce_init(void) {
   memset(&ce_cb, 0, sizeof(tCE_CB));
-  ce_cb.trace_level = NFC_INITIAL_TRACE_LEVEL;
 
   /* Initialize tag-specific fields of ce control block */
   ce_t3t_init();
@@ -67,7 +71,7 @@ tNFC_STATUS CE_SendRawFrame(uint8_t* p_raw_data, uint16_t data_len) {
       p = (uint8_t*)(p_data + 1) + p_data->offset;
       memcpy(p, p_raw_data, data_len);
       p_data->len = data_len;
-      CE_TRACE_EVENT1("CE SENT raw frame (0x%x)", data_len);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("CE SENT raw frame (0x%x)", data_len);
       status = NFC_SendData(NFC_RF_CONN_ID, p_data);
     }
   }
@@ -89,7 +93,7 @@ tNFC_STATUS CE_SetActivatedTagType(tNFC_ACTIVATE_DEVT* p_activate_params,
   tNFC_STATUS status = NFC_STATUS_FAILED;
   tNFC_PROTOCOL protocol = p_activate_params->protocol;
 
-  CE_TRACE_API1("CE_SetActivatedTagType protocol:%d", protocol);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("CE_SetActivatedTagType protocol:%d", protocol);
 
   switch (protocol) {
     case NFC_PROTOCOL_T1T:
@@ -110,7 +114,7 @@ tNFC_STATUS CE_SetActivatedTagType(tNFC_ACTIVATE_DEVT* p_activate_params,
       break;
 
     default:
-      CE_TRACE_ERROR0("CE_SetActivatedTagType Invalid protocol");
+      LOG(ERROR) << StringPrintf("CE_SetActivatedTagType Invalid protocol");
       return NFC_STATUS_FAILED;
   }
 
@@ -120,20 +124,3 @@ tNFC_STATUS CE_SetActivatedTagType(tNFC_ACTIVATE_DEVT* p_activate_params,
   }
   return status;
 }
-
-/*******************************************************************************
-**
-** Function         CE_SetTraceLevel
-**
-** Description      This function sets the trace level for Card Emulation mode.
-**                  If called with a value of 0xFF,
-**                  it simply returns the current trace level.
-**
-** Returns          The new or current trace level
-**
-*******************************************************************************/
-uint8_t CE_SetTraceLevel(uint8_t new_level) {
-  if (new_level != 0xFF) ce_cb.trace_level = new_level;
-
-  return (ce_cb.trace_level);
-}
diff --git a/src/nfc/tags/ce_t3t.c b/src/nfc/tags/ce_t3t.cc
similarity index 90%
rename from src/nfc/tags/ce_t3t.c
rename to src/nfc/tags/ce_t3t.cc
index 7512506..3a60943 100644
--- a/src/nfc/tags/ce_t3t.c
+++ b/src/nfc/tags/ce_t3t.cc
@@ -23,16 +23,19 @@
  *
  ******************************************************************************/
 #include <string.h>
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfc_target.h"
 #include "bt_types.h"
-#include "trace_api.h"
 
-#include "nfc_api.h"
-#include "nfc_int.h"
 #include "ce_api.h"
 #include "ce_int.h"
-#include "tags_int.h"
-#include "gki.h"
+
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
 
 enum {
   CE_T3T_COMMAND_INVALID,
@@ -90,12 +93,8 @@ void ce_t3t_send_to_lower(NFC_HDR* p_msg) {
   UINT8_TO_STREAM(p, (p_msg->len + 1));
   p_msg->len += 1; /* Increment len to include SoD */
 
-#if (BT_TRACE_PROTOCOL == true)
-  DispT3TagMessage(p_msg, false);
-#endif
-
   if (NFC_SendData(NFC_RF_CONN_ID, p_msg) != NFC_STATUS_OK) {
-    CE_TRACE_ERROR0("ce_t3t_send_to_lower (): NFC_SendData () failed");
+    LOG(ERROR) << StringPrintf("ce_t3t_send_to_lower (): NFC_SendData () failed");
   }
 }
 
@@ -182,7 +181,7 @@ void ce_t3t_send_rsp(tCE_CB* p_ce_cb, uint8_t* p_nfcid2, uint8_t opcode,
     p_rsp_msg->len = (uint16_t)(p_dst - p_rsp_start);
     ce_t3t_send_to_lower(p_rsp_msg);
   } else {
-    CE_TRACE_ERROR0("CE: Unable to allocat buffer for response message");
+    LOG(ERROR) << StringPrintf("CE: Unable to allocat buffer for response message");
   }
 }
 
@@ -206,7 +205,6 @@ void ce_t3t_handle_update_cmd(tCE_CB* p_ce_cb, NFC_HDR* p_cmd_msg) {
   tCE_T3T_NDEF_INFO ndef_info;
   tNFC_STATUS nfc_status = NFC_STATUS_OK;
   uint8_t update_flags = 0;
-  tCE_UPDATE_INFO update_info;
 
   /* If in idle state, notify app that update is starting */
   if (p_cb->state == CE_T3T_STATE_IDLE) {
@@ -230,7 +228,7 @@ void ce_t3t_handle_update_cmd(tCE_CB* p_ce_cb, NFC_HDR* p_cmd_msg) {
     /* Reject UPDATE command if service code=T3T_MSG_NDEF_SC_RO */
     if (service_code == T3T_MSG_NDEF_SC_RO) {
       /* Error: invalid block number to update */
-      CE_TRACE_ERROR0("CE: UPDATE request using read-only service");
+      LOG(ERROR) << StringPrintf("CE: UPDATE request using read-only service");
       nfc_status = NFC_STATUS_FAILED;
       break;
     }
@@ -238,17 +236,17 @@ void ce_t3t_handle_update_cmd(tCE_CB* p_ce_cb, NFC_HDR* p_cmd_msg) {
     /* Check for NDEF */
     if (service_code == T3T_MSG_NDEF_SC_RW) {
       if (p_cb->cur_cmd.num_blocks > p_cb->ndef_info.nbw) {
-        CE_TRACE_ERROR2(
+        LOG(ERROR) << StringPrintf(
             "CE: Requested too many blocks to update (requested: %i, max: %i)",
             p_cb->cur_cmd.num_blocks, p_cb->ndef_info.nbw);
         nfc_status = NFC_STATUS_FAILED;
         break;
       } else if (p_cb->ndef_info.rwflag == T3T_MSG_NDEF_RWFLAG_RO) {
-        CE_TRACE_ERROR0("CE: error: write-request to read-only NDEF message.");
+        LOG(ERROR) << StringPrintf("CE: error: write-request to read-only NDEF message.");
         nfc_status = NFC_STATUS_FAILED;
         break;
       } else if (block_number == 0) {
-        CE_TRACE_DEBUG2("CE: Update sc 0x%04x block %i.", service_code,
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("CE: Update sc 0x%04x block %i.", service_code,
                         block_number);
 
         /* Special caes: NDEF block0 is the ndef attribute block */
@@ -271,7 +269,7 @@ void ce_t3t_handle_update_cmd(tCE_CB* p_ce_cb, NFC_HDR* p_cmd_msg) {
 
         /* Compare calcuated checksum with received checksum */
         if (checksum != checksum_rx) {
-          CE_TRACE_ERROR0("CE: Checksum failed for NDEF attribute block.");
+          LOG(ERROR) << StringPrintf("CE: Checksum failed for NDEF attribute block.");
           nfc_status = NFC_STATUS_FAILED;
         } else {
           /* Update NDEF attribute block (only allowed to update current length
@@ -289,13 +287,13 @@ void ce_t3t_handle_update_cmd(tCE_CB* p_ce_cb, NFC_HDR* p_cmd_msg) {
           }
         }
       } else {
-        CE_TRACE_DEBUG2("CE: Udpate sc 0x%04x block %i.", service_code,
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("CE: Udpate sc 0x%04x block %i.", service_code,
                         block_number);
 
         /* Verify that block_number is within NDEF memory */
         if (block_number > p_cb->ndef_info.nmaxb) {
           /* Error: invalid block number to update */
-          CE_TRACE_ERROR2(
+          LOG(ERROR) << StringPrintf(
               "CE: Requested invalid NDEF block number to update %i (max is "
               "%i).",
               block_number, p_cb->ndef_info.nmaxb);
@@ -314,7 +312,7 @@ void ce_t3t_handle_update_cmd(tCE_CB* p_ce_cb, NFC_HDR* p_cmd_msg) {
       }
     } else {
       /* Error: invalid service code */
-      CE_TRACE_ERROR1("CE: Requested invalid service code: 0x%04x.",
+      LOG(ERROR) << StringPrintf("CE: Requested invalid service code: 0x%04x.",
                       service_code);
       nfc_status = NFC_STATUS_FAILED;
       break;
@@ -344,11 +342,12 @@ void ce_t3t_handle_update_cmd(tCE_CB* p_ce_cb, NFC_HDR* p_cmd_msg) {
 
   if (update_flags & CE_T3T_UPDATE_FL_NDEF_UPDATE_CPLT) {
     /* NDEF attribute got updated with WriteF=false */
-    update_info.status = nfc_status;
-    update_info.p_data = p_cb->ndef_info.p_scratch_buf;
-    update_info.length = p_cb->ndef_info.scratch_ln;
+    tCE_DATA ce_data;
+    ce_data.update_info.status = nfc_status;
+    ce_data.update_info.p_data = p_cb->ndef_info.p_scratch_buf;
+    ce_data.update_info.length = p_cb->ndef_info.scratch_ln;
     p_cb->state = CE_T3T_STATE_IDLE;
-    p_ce_cb->p_cback(CE_T3T_NDEF_UPDATE_CPLT_EVT, (void*)&update_info);
+    p_ce_cb->p_cback(CE_T3T_NDEF_UPDATE_CPLT_EVT, &ce_data);
   }
 
   GKI_freebuf(p_cmd_msg);
@@ -412,7 +411,7 @@ void ce_t3t_handle_check_cmd(tCE_CB* p_ce_cb, NFC_HDR* p_cmd_msg) {
         /* Verify Nbr (NDEF only) */
         if (p_cb->cur_cmd.num_blocks > p_cb->ndef_info.nbr) {
           /* Error: invalid number of blocks to check */
-          CE_TRACE_ERROR2(
+          LOG(ERROR) << StringPrintf(
               "CE: Requested too many blocks to check (requested: %i, max: %i)",
               p_cb->cur_cmd.num_blocks, p_cb->ndef_info.nbr);
 
@@ -456,7 +455,7 @@ void ce_t3t_handle_check_cmd(tCE_CB* p_ce_cb, NFC_HDR* p_cmd_msg) {
             /* Invalid block number */
             p_dst = p_status;
 
-            CE_TRACE_ERROR1("CE: Requested block number to check %i.",
+            LOG(ERROR) << StringPrintf("CE: Requested block number to check %i.",
                             block_number);
 
             /* Error: invalid number of blocks to check */
@@ -483,7 +482,7 @@ void ce_t3t_handle_check_cmd(tCE_CB* p_ce_cb, NFC_HDR* p_cmd_msg) {
         }
       } else {
         /* Error: invalid service code */
-        CE_TRACE_ERROR1("CE: Requested invalid service code: 0x%04x.",
+        LOG(ERROR) << StringPrintf("CE: Requested invalid service code: 0x%04x.",
                         service_code);
 
         p_dst = p_status;
@@ -496,7 +495,7 @@ void ce_t3t_handle_check_cmd(tCE_CB* p_ce_cb, NFC_HDR* p_cmd_msg) {
     p_rsp_msg->len = (uint16_t)(p_dst - p_rsp_start);
     ce_t3t_send_to_lower(p_rsp_msg);
   } else {
-    CE_TRACE_ERROR0("CE: Unable to allocat buffer for response message");
+    LOG(ERROR) << StringPrintf("CE: Unable to allocat buffer for response message");
   }
 
   GKI_freebuf(p_cmd_msg);
@@ -583,7 +582,7 @@ void ce_t3t_handle_non_nfc_forum_cmd(tCE_CB* p_mem_cb, uint8_t cmd_id,
       case T3T_MSG_OPC_REQ_SERVICE_CMD:
       default:
         /* Unhandled command */
-        CE_TRACE_ERROR1("Unhandled CE opcode: %02x", cmd_id);
+        LOG(ERROR) << StringPrintf("Unhandled CE opcode: %02x", cmd_id);
         send_response = false;
         break;
     }
@@ -595,7 +594,7 @@ void ce_t3t_handle_non_nfc_forum_cmd(tCE_CB* p_mem_cb, uint8_t cmd_id,
       GKI_freebuf(p_rsp_msg);
     }
   } else {
-    CE_TRACE_ERROR0("CE: Unable to allocat buffer for response message");
+    LOG(ERROR) << StringPrintf("CE: Unable to allocat buffer for response message");
   }
   GKI_freebuf(p_cmd_msg);
 }
@@ -609,7 +608,7 @@ void ce_t3t_handle_non_nfc_forum_cmd(tCE_CB* p_mem_cb, uint8_t cmd_id,
 ** Returns          none
 **
 *******************************************************************************/
-void ce_t3t_data_cback(uint8_t conn_id, tNFC_DATA_CEVT* p_data) {
+void ce_t3t_data_cback(tNFC_DATA_CEVT* p_data) {
   tCE_CB* p_ce_cb = &ce_cb;
   tCE_T3T_MEM* p_cb = &p_ce_cb->mem.t3t;
   NFC_HDR* p_msg = p_data->p_data;
@@ -624,11 +623,6 @@ void ce_t3t_data_cback(uint8_t conn_id, tNFC_DATA_CEVT* p_data) {
   uint8_t sod;
   uint8_t cmd_type;
 
-#if (BT_TRACE_PROTOCOL == true)
-  DispT3TagMessage(p_msg, true);
-#endif
-  (void)conn_id;
-
   /* If activate system code is not NDEF, or if no local NDEF contents was set,
    * then pass data up to the app */
   if ((p_cb->system_code != T3T_SYSTEM_CODE_NDEF) ||
@@ -641,7 +635,7 @@ void ce_t3t_data_cback(uint8_t conn_id, tNFC_DATA_CEVT* p_data) {
 
   /* Verify that message contains at least Sod and cmd_id */
   if (p_msg->len < 2) {
-    CE_TRACE_ERROR1("CE: received invalid T3t message (invalid length: %i)",
+    LOG(ERROR) << StringPrintf("CE: received invalid T3t message (invalid length: %i)",
                     p_msg->len);
   } else {
     /* Get and validate command opcode */
@@ -651,7 +645,7 @@ void ce_t3t_data_cback(uint8_t conn_id, tNFC_DATA_CEVT* p_data) {
     /* Valid command and message length */
     cmd_type = ce_t3t_is_valid_opcode(cmd_id);
     if (cmd_type == CE_T3T_COMMAND_INVALID) {
-      CE_TRACE_ERROR1(
+      LOG(ERROR) << StringPrintf(
           "CE: received invalid T3t message (invalid command: 0x%02X)", cmd_id);
     } else if (cmd_type == CE_T3T_COMMAND_FELICA) {
       ce_t3t_handle_non_nfc_forum_cmd(p_ce_cb, cmd_id, p_msg);
@@ -659,7 +653,7 @@ void ce_t3t_data_cback(uint8_t conn_id, tNFC_DATA_CEVT* p_data) {
     } else {
       /* Verify that message contains at least NFCID2 and NUM services */
       if (p_msg->len < T3T_MSG_CMD_COMMON_HDR_LEN) {
-        CE_TRACE_ERROR1("CE: received invalid T3t message (invalid length: %i)",
+        LOG(ERROR) << StringPrintf("CE: received invalid T3t message (invalid length: %i)",
                         p_msg->len);
       } else {
         /* Handle NFC_FORUM command (UPDATE or CHECK) */
@@ -671,17 +665,17 @@ void ce_t3t_data_cback(uint8_t conn_id, tNFC_DATA_CEVT* p_data) {
             T3T_MSG_CMD_COMMON_HDR_LEN + 2 * p_cb->cur_cmd.num_services + 1;
 
         if (p_cb->state == CE_T3T_STATE_NOT_ACTIVATED) {
-          CE_TRACE_ERROR2(
+          LOG(ERROR) << StringPrintf(
               "CE: received command 0x%02X while in bad state (%i))", cmd_id,
               p_cb->state);
         } else if (memcmp(cmd_nfcid2, p_cb->local_nfcid2, NCI_RF_F_UID_LEN) !=
                    0) {
-          CE_TRACE_ERROR0("CE: received invalid T3t message (invalid NFCID2)");
+          LOG(ERROR) << StringPrintf("CE: received invalid T3t message (invalid NFCID2)");
           p_nfcid2 = cmd_nfcid2; /* respond with ERROR using the NFCID2 from the
                                     command message */
         } else if (p_msg->len < block_list_start_offset) {
           /* Does not have minimum (including number_of_blocks field) */
-          CE_TRACE_ERROR0("CE: incomplete message");
+          LOG(ERROR) << StringPrintf("CE: incomplete message");
         } else {
           /* Parse service code list */
           for (i = 0; i < p_cb->cur_cmd.num_services; i++) {
@@ -697,7 +691,7 @@ void ce_t3t_data_cback(uint8_t conn_id, tNFC_DATA_CEVT* p_data) {
             /* Each entry is at lease 2 bytes long */
             if (remaining < 2) {
               /* Unexpected end of message (while reading block-list) */
-              CE_TRACE_ERROR0(
+              LOG(ERROR) << StringPrintf(
                   "CE: received invalid T3t message (unexpected end of "
                   "block-list)");
               block_list_ok = false;
@@ -711,7 +705,7 @@ void ce_t3t_data_cback(uint8_t conn_id, tNFC_DATA_CEVT* p_data) {
             if ((bl0 & T3T_MSG_SERVICE_LIST_MASK) >=
                 p_cb->cur_cmd.num_services) {
               /* Invalid service code */
-              CE_TRACE_ERROR1(
+              LOG(ERROR) << StringPrintf(
                   "CE: received invalid T3t message (invalid service index: "
                   "%i)",
                   (bl0 & T3T_MSG_SERVICE_LIST_MASK));
@@ -720,7 +714,7 @@ void ce_t3t_data_cback(uint8_t conn_id, tNFC_DATA_CEVT* p_data) {
             } else if ((!(bl0 & T3T_MSG_MASK_TWO_BYTE_BLOCK_DESC_FORMAT)) &&
                        (remaining < 3)) {
               /* Unexpected end of message (while reading 3-byte entry) */
-              CE_TRACE_ERROR0(
+              LOG(ERROR) << StringPrintf(
                   "CE: received invalid T3t message (unexpected end of "
                   "block-list)");
               block_list_ok = false;
@@ -740,8 +734,8 @@ void ce_t3t_data_cback(uint8_t conn_id, tNFC_DATA_CEVT* p_data) {
               /* This is a CHECK command. Sanity check: there shouldn't be any
                * more data remaining after reading block list */
               if (remaining) {
-                CE_TRACE_ERROR1(
-                    "CE: unexpected data after after CHECK command (#i bytes)",
+                LOG(ERROR) << StringPrintf(
+                    "CE: unexpected data after after CHECK command (%x bytes)",
                     remaining);
               }
               ce_t3t_handle_check_cmd(p_ce_cb, p_msg);
@@ -750,7 +744,7 @@ void ce_t3t_data_cback(uint8_t conn_id, tNFC_DATA_CEVT* p_data) {
               /* This is an UPDATE command. See if message contains all the
                * expected block data */
               if (remaining < p_cb->cur_cmd.num_blocks * T3T_MSG_BLOCKSIZE) {
-                CE_TRACE_ERROR0("CE: unexpected end of block-data");
+                LOG(ERROR) << StringPrintf("CE: unexpected end of block-data");
               } else {
                 ce_t3t_handle_update_cmd(p_ce_cb, p_msg);
                 msg_processed = true;
@@ -783,7 +777,7 @@ void ce_t3t_conn_cback(uint8_t conn_id, tNFC_CONN_EVT event,
                        tNFC_CONN* p_data) {
   tCE_T3T_MEM* p_cb = &ce_cb.mem.t3t;
 
-  CE_TRACE_DEBUG2("ce_t3t_conn_cback: conn_id=%i, evt=%i", conn_id, event);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("ce_t3t_conn_cback: conn_id=%i, evt=%i", conn_id, event);
 
   switch (event) {
     case NFC_CONN_CREATE_CEVT:
@@ -795,7 +789,7 @@ void ce_t3t_conn_cback(uint8_t conn_id, tNFC_CONN_EVT event,
 
     case NFC_DATA_CEVT:
       if (p_data->data.status == NFC_STATUS_OK) {
-        ce_t3t_data_cback(conn_id, &p_data->data);
+        ce_t3t_data_cback(&p_data->data);
       }
       break;
 
@@ -822,7 +816,7 @@ tNFC_STATUS ce_select_t3t(uint16_t system_code,
                           uint8_t nfcid2[NCI_RF_F_UID_LEN]) {
   tCE_T3T_MEM* p_cb = &ce_cb.mem.t3t;
 
-  CE_TRACE_DEBUG0("ce_select_t3t ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("ce_select_t3t ()");
 
   p_cb->state = CE_T3T_STATE_IDLE;
   p_cb->system_code = system_code;
@@ -846,12 +840,12 @@ tNFC_STATUS CE_T3tSetLocalNDEFMsg(bool read_only, uint32_t size_max,
                                   uint8_t* p_scratch_buf) {
   tCE_T3T_MEM* p_cb = &ce_cb.mem.t3t;
 
-  CE_TRACE_API3("CE_T3tSetContent: ro=%i, size_max=%i, size_current=%i",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("CE_T3tSetContent: ro=%i, size_max=%i, size_current=%i",
                 read_only, size_max, size_current);
 
   /* Verify scratch buffer was provided if NDEF message is read/write */
   if ((!read_only) && (!p_scratch_buf)) {
-    CE_TRACE_ERROR0(
+    LOG(ERROR) << StringPrintf(
         "CE_T3tSetLocalNDEFMsg (): p_scratch_buf cannot be NULL if not "
         "read-only");
     return NFC_STATUS_FAILED;
@@ -898,12 +892,12 @@ tNFC_STATUS CE_T3tSetLocalNDEFMsg(bool read_only, uint32_t size_max,
 tNFC_STATUS CE_T3tSetLocalNDefParams(uint8_t nbr, uint8_t nbw) {
   tCE_T3T_MEM* p_cb = &ce_cb.mem.t3t;
 
-  CE_TRACE_API2("CE_T3tSetLocalNDefParams: nbr=%i, nbw=%i", nbr, nbw);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("CE_T3tSetLocalNDefParams: nbr=%i, nbw=%i", nbr, nbw);
 
   /* Validate */
   if ((nbr > T3T_MSG_NUM_BLOCKS_CHECK_MAX) ||
       (nbw > T3T_MSG_NUM_BLOCKS_UPDATE_MAX) || (nbr < 1) || (nbw < 1)) {
-    CE_TRACE_ERROR0("CE_T3tSetLocalNDefParams: invalid params");
+    LOG(ERROR) << StringPrintf("CE_T3tSetLocalNDefParams: invalid params");
     return NFC_STATUS_FAILED;
   }
 
@@ -929,12 +923,12 @@ tNFC_STATUS CE_T3tSendCheckRsp(uint8_t status1, uint8_t status2,
   NFC_HDR* p_rsp_msg;
   uint8_t* p_dst, *p_rsp_start;
 
-  CE_TRACE_API3("CE_T3tCheckRsp: status1=0x%02X, status2=0x%02X, num_blocks=%i",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("CE_T3tCheckRsp: status1=0x%02X, status2=0x%02X, num_blocks=%i",
                 status1, status2, num_blocks);
 
   /* Validate num_blocks */
   if (num_blocks > T3T_MSG_NUM_BLOCKS_CHECK_MAX) {
-    CE_TRACE_ERROR2("CE_T3tCheckRsp num_blocks (%i) exceeds maximum (%i)",
+    LOG(ERROR) << StringPrintf("CE_T3tCheckRsp num_blocks (%i) exceeds maximum (%i)",
                     num_blocks, T3T_MSG_NUM_BLOCKS_CHECK_MAX);
     return (NFC_STATUS_FAILED);
   }
@@ -961,7 +955,7 @@ tNFC_STATUS CE_T3tSendCheckRsp(uint8_t status1, uint8_t status2,
     p_rsp_msg->len = (uint16_t)(p_dst - p_rsp_start);
     ce_t3t_send_to_lower(p_rsp_msg);
   } else {
-    CE_TRACE_ERROR0("CE: Unable to allocate buffer for response message");
+    LOG(ERROR) << StringPrintf("CE: Unable to allocate buffer for response message");
   }
 
   return (retval);
@@ -980,7 +974,7 @@ tNFC_STATUS CE_T3tSendUpdateRsp(uint8_t status1, uint8_t status2) {
   tNFC_STATUS retval = NFC_STATUS_OK;
   tCE_CB* p_ce_cb = &ce_cb;
 
-  CE_TRACE_API2("CE_T3tUpdateRsp: status1=0x%02X, status2=0x%02X", status1,
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("CE_T3tUpdateRsp: status1=0x%02X, status2=0x%02X", status1,
                 status2);
   ce_t3t_send_rsp(p_ce_cb, NULL, T3T_MSG_OPC_UPDATE_RSP, status1, status2);
 
diff --git a/src/nfc/tags/ce_t4t.c b/src/nfc/tags/ce_t4t.cc
old mode 100644
new mode 100755
similarity index 80%
rename from src/nfc/tags/ce_t4t.c
rename to src/nfc/tags/ce_t4t.cc
index ae3af2a..7d5ca38
--- a/src/nfc/tags/ce_t4t.c
+++ b/src/nfc/tags/ce_t4t.cc
@@ -23,16 +23,21 @@
  *
  ******************************************************************************/
 #include <string.h>
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfc_target.h"
 #include "bt_types.h"
-#include "trace_api.h"
 
-#include "nfc_api.h"
 #include "nfc_int.h"
 #include "ce_api.h"
 #include "ce_int.h"
 #include "tags_int.h"
-#include "gki.h"
+
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
 
 #if (CE_TEST_INCLUDED == true) /* test only */
 bool mapping_aid_test_enabled = false;
@@ -50,12 +55,9 @@ uint8_t ce_test_tag_app_id[T4T_V20_NDEF_TAG_AID_LEN] = {0xD2, 0x76, 0x00, 0x00,
 **
 *******************************************************************************/
 static bool ce_t4t_send_to_lower(NFC_HDR* p_r_apdu) {
-#if (BT_TRACE_PROTOCOL == true)
-  DispCET4Tags(p_r_apdu, false);
-#endif
 
   if (NFC_SendData(NFC_RF_CONN_ID, p_r_apdu) != NFC_STATUS_OK) {
-    CE_TRACE_ERROR0("ce_t4t_send_to_lower (): NFC_SendData () failed");
+    LOG(ERROR) << StringPrintf("ce_t4t_send_to_lower (): NFC_SendData () failed");
     return false;
   }
   return true;
@@ -74,12 +76,12 @@ static bool ce_t4t_send_status(uint16_t status) {
   NFC_HDR* p_r_apdu;
   uint8_t* p;
 
-  CE_TRACE_DEBUG1("ce_t4t_send_status (): Status:0x%04X", status);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("ce_t4t_send_status (): Status:0x%04X", status);
 
   p_r_apdu = (NFC_HDR*)GKI_getpoolbuf(NFC_CE_POOL_ID);
 
   if (!p_r_apdu) {
-    CE_TRACE_ERROR0("ce_t4t_send_status (): Cannot allocate buffer");
+    LOG(ERROR) << StringPrintf("ce_t4t_send_status (): Cannot allocate buffer");
     return false;
   }
 
@@ -108,10 +110,10 @@ static bool ce_t4t_send_status(uint16_t status) {
 static bool ce_t4t_select_file(uint16_t file_id) {
   tCE_T4T_MEM* p_t4t = &ce_cb.mem.t4t;
 
-  CE_TRACE_DEBUG1("ce_t4t_select_file (): FileID:0x%04X", file_id);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("ce_t4t_select_file (): FileID:0x%04X", file_id);
 
   if (file_id == T4T_CC_FILE_ID) {
-    CE_TRACE_DEBUG0("ce_t4t_select_file (): Select CC file");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("ce_t4t_select_file (): Select CC file");
 
     p_t4t->status |= CE_T4T_STATUS_CC_FILE_SELECTED;
     p_t4t->status &= ~(CE_T4T_STATUS_NDEF_SELECTED);
@@ -120,7 +122,7 @@ static bool ce_t4t_select_file(uint16_t file_id) {
   }
 
   if (file_id == CE_T4T_MANDATORY_NDEF_FILE_ID) {
-    CE_TRACE_DEBUG3(
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "ce_t4t_select_file (): NLEN:0x%04X, MaxFileSize:0x%04X, "
         "WriteAccess:%s",
         p_t4t->nlen, p_t4t->max_file_size,
@@ -131,7 +133,7 @@ static bool ce_t4t_select_file(uint16_t file_id) {
 
     return true;
   } else {
-    CE_TRACE_ERROR1("ce_t4t_select_file (): Cannot find file ID (0x%04X)",
+    LOG(ERROR) << StringPrintf("ce_t4t_select_file (): Cannot find file ID (0x%04X)",
                     file_id);
 
     p_t4t->status &= ~(CE_T4T_STATUS_CC_FILE_SELECTED);
@@ -155,7 +157,7 @@ static bool ce_t4t_read_binary(uint16_t offset, uint8_t length) {
   uint8_t* p_src = NULL, *p_dst;
   NFC_HDR* p_r_apdu;
 
-  CE_TRACE_DEBUG3(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "ce_t4t_read_binary (): Offset:0x%04X, Length:0x%04X, selected status = "
       "0x%02X",
       offset, length, p_t4t->status);
@@ -173,7 +175,7 @@ static bool ce_t4t_read_binary(uint16_t offset, uint8_t length) {
     p_r_apdu = (NFC_HDR*)GKI_getpoolbuf(NFC_CE_POOL_ID);
 
     if (!p_r_apdu) {
-      CE_TRACE_ERROR0("ce_t4t_read_binary (): Cannot allocate buffer");
+      LOG(ERROR) << StringPrintf("ce_t4t_read_binary (): Cannot allocate buffer");
       return false;
     }
 
@@ -216,7 +218,7 @@ static bool ce_t4t_read_binary(uint16_t offset, uint8_t length) {
     }
     return true;
   } else {
-    CE_TRACE_ERROR0("ce_t4t_read_binary (): No selected file");
+    LOG(ERROR) << StringPrintf("ce_t4t_read_binary (): No selected file");
 
     if (!ce_t4t_send_status(T4T_RSP_CMD_NOT_ALLOWED)) {
       return false;
@@ -242,7 +244,7 @@ static bool ce_t4t_update_binary(uint16_t offset, uint8_t length,
   uint16_t starting_offset;
   tCE_DATA ce_data;
 
-  CE_TRACE_DEBUG3(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "ce_t4t_update_binary (): Offset:0x%04X, Length:0x%04X, selected status "
       "= 0x%02X",
       offset, length, p_t4t->status);
@@ -277,7 +279,7 @@ static bool ce_t4t_update_binary(uint16_t offset, uint8_t length,
       ce_data.update_info.p_data = p_t4t->p_scratch_buf;
 
       (*ce_cb.p_cback)(CE_T4T_NDEF_UPDATE_CPLT_EVT, &ce_data);
-      CE_TRACE_DEBUG0(
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "ce_t4t_update_binary (): Sent CE_T4T_NDEF_UPDATE_CPLT_EVT");
     }
 
@@ -317,7 +319,7 @@ static void ce_t4t_set_version_in_cc(uint8_t version) {
   tCE_T4T_MEM* p_t4t = &ce_cb.mem.t4t;
   uint8_t* p;
 
-  CE_TRACE_DEBUG1("ce_t4t_set_version_in_cc (): version = 0x%02X", version);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("ce_t4t_set_version_in_cc (): version = 0x%02X", version);
 
   p = p_t4t->cc_file + T4T_VERSION_OFFSET_IN_CC;
 
@@ -337,7 +339,7 @@ static bool ce_t4t_process_select_file_cmd(uint8_t* p_cmd) {
   uint8_t data_len;
   uint16_t file_id, status_words;
 
-  CE_TRACE_DEBUG0("ce_t4t_process_select_file_cmd ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("ce_t4t_process_select_file_cmd ()");
 
   p_cmd++; /* skip P2 */
 
@@ -382,7 +384,7 @@ static void ce_t4t_process_select_app_cmd(uint8_t* p_cmd, NFC_HDR* p_c_apdu) {
   tCE_DATA ce_data;
   uint8_t xx;
 
-  CE_TRACE_DEBUG0("ce_t4t_process_select_app_cmd ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("ce_t4t_process_select_app_cmd ()");
 
   p_cmd++; /* skip P2 */
 
@@ -424,7 +426,7 @@ static void ce_t4t_process_select_app_cmd(uint8_t* p_cmd, NFC_HDR* p_c_apdu) {
     ce_cb.mem.t4t.status &= ~(CE_T4T_STATUS_WILDCARD_AID_SELECTED);
     ce_cb.mem.t4t.status |= CE_T4T_STATUS_REG_AID_SELECTED;
 
-    CE_TRACE_DEBUG4(
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "ce_t4t_process_select_app_cmd (): Registered AID[%02X%02X%02X%02X...] "
         "is selected",
         ce_cb.mem.t4t.reg_aid[ce_cb.mem.t4t.selected_aid_idx].aid[0],
@@ -453,7 +455,7 @@ static void ce_t4t_process_select_app_cmd(uint8_t* p_cmd, NFC_HDR* p_c_apdu) {
       ce_t4t_set_version_in_cc(T4T_VERSION_2_0);
       status_words = T4T_RSP_CMD_CMPLTED;
     } else {
-      CE_TRACE_DEBUG0(
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "ce_t4t_process_select_app_cmd (): Not found matched AID");
       status_words = T4T_RSP_NOT_FOUND;
     }
@@ -469,11 +471,11 @@ static void ce_t4t_process_select_app_cmd(uint8_t* p_cmd, NFC_HDR* p_c_apdu) {
     ce_data.raw_frame.aid_handle = CE_T4T_WILDCARD_AID_HANDLE;
     p_c_apdu = NULL;
 
-    CE_TRACE_DEBUG0(
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "CET4T: Forward raw frame (SELECT APP) to wildcard AID handler");
     (*(ce_cb.mem.t4t.p_wildcard_aid_cback))(CE_T4T_RAW_FRAME_EVT, &ce_data);
   } else {
-    CE_TRACE_DEBUG0(
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "ce_t4t_process_select_app_cmd (): Not found matched AID or not "
         "listening T4T NDEF");
     status_words = T4T_RSP_NOT_FOUND;
@@ -488,7 +490,7 @@ static void ce_t4t_process_select_app_cmd(uint8_t* p_cmd, NFC_HDR* p_c_apdu) {
       ce_cb.mem.t4t.status &= ~(CE_T4T_STATUS_WILDCARD_AID_SELECTED);
       ce_cb.mem.t4t.status |= CE_T4T_STATUS_T4T_APP_SELECTED;
 
-      CE_TRACE_DEBUG0("ce_t4t_process_select_app_cmd (): T4T CE App selected");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("ce_t4t_process_select_app_cmd (): T4T CE App selected");
     }
 
     ce_t4t_send_status(status_words);
@@ -512,7 +514,7 @@ void ce_t4t_process_timeout(TIMER_LIST_ENT* p_tle) {
   tCE_T4T_MEM* p_t4t = &ce_cb.mem.t4t;
   tCE_DATA ce_data;
 
-  CE_TRACE_DEBUG1("ce_t4t_process_timeout () event=%d", p_tle->event);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("ce_t4t_process_timeout () event=%d", p_tle->event);
 
   if (p_tle->event == NFC_TTYPE_CE_T4T_UPDATE) {
     if (p_t4t->status & CE_T4T_STATUS_NDEF_FILE_UPDATING) {
@@ -524,7 +526,7 @@ void ce_t4t_process_timeout(TIMER_LIST_ENT* p_tle) {
       p_t4t->status &= ~(CE_T4T_STATUS_NDEF_FILE_UPDATING);
     }
   } else {
-    CE_TRACE_ERROR1("ce_t4t_process_timeout () unknown event=%d", p_tle->event);
+    LOG(ERROR) << StringPrintf("ce_t4t_process_timeout () unknown event=%d", p_tle->event);
   }
 }
 
@@ -555,11 +557,7 @@ static void ce_t4t_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
 
   p_c_apdu = (NFC_HDR*)p_data->data.p_data;
 
-#if (BT_TRACE_PROTOCOL == true)
-  DispCET4Tags(p_c_apdu, true);
-#endif
-
-  CE_TRACE_DEBUG1("ce_t4t_data_cback (): conn_id = 0x%02X", conn_id);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("ce_t4t_data_cback (): conn_id = 0x%02X", conn_id);
 
   p_cmd = (uint8_t*)(p_c_apdu + 1) + p_c_apdu->offset;
 
@@ -590,7 +588,7 @@ static void ce_t4t_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
 
   /* if registered AID is selected */
   if (ce_cb.mem.t4t.status & CE_T4T_STATUS_REG_AID_SELECTED) {
-    CE_TRACE_DEBUG0("CET4T: Forward raw frame to registered AID");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("CET4T: Forward raw frame to registered AID");
 
     /* forward raw frame to upper layer */
     if (ce_cb.mem.t4t.selected_aid_idx < CE_T4T_MAX_REG_AID) {
@@ -606,7 +604,7 @@ static void ce_t4t_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
       ce_t4t_send_status(T4T_RSP_NOT_FOUND);
     }
   } else if (ce_cb.mem.t4t.status & CE_T4T_STATUS_WILDCARD_AID_SELECTED) {
-    CE_TRACE_DEBUG0("CET4T: Forward raw frame to wildcard AID handler");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("CET4T: Forward raw frame to wildcard AID handler");
 
     /* forward raw frame to upper layer */
     ce_data.raw_frame.status = p_data->data.status;
@@ -621,7 +619,7 @@ static void ce_t4t_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
       if (select_type == T4T_CMD_P1_SELECT_BY_FILE_ID) {
         ce_t4t_process_select_file_cmd(p_cmd);
       } else {
-        CE_TRACE_ERROR1("CET4T: Bad P1 byte (0x%02X)", select_type);
+        LOG(ERROR) << StringPrintf("CET4T: Bad P1 byte (0x%02X)", select_type);
         ce_t4t_send_status(T4T_RSP_WRONG_PARAMS);
       }
     } else if (instruct == T4T_CMD_INS_READ_BINARY) {
@@ -644,19 +642,19 @@ static void ce_t4t_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
             if (offset < max_file_size) {
               length = (uint8_t)(max_file_size - offset);
 
-              CE_TRACE_DEBUG2(
+              DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
                   "CET4T: length is reduced to %d by max_file_size (%d)",
                   length, max_file_size);
             } else {
-              CE_TRACE_ERROR2(
+              LOG(ERROR) << StringPrintf(
                   "CET4T: offset (%d) must be less than max_file_size (%d)",
                   offset, max_file_size);
               length = 0;
             }
           }
         } else {
-          CE_TRACE_ERROR2("CET4T: length (%d) must be less than MLe (%d)",
-                          length, CE_T4T_MAX_LE);
+          LOG(ERROR) << StringPrintf("CET4T: length (%d) must be less than MLe (%lu)",
+                          length, (unsigned long)CE_T4T_MAX_LE);
           length = 0;
         }
 
@@ -665,12 +663,12 @@ static void ce_t4t_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
         else
           ce_t4t_send_status(T4T_RSP_WRONG_PARAMS);
       } else {
-        CE_TRACE_ERROR0("CET4T: File has not been selected");
+        LOG(ERROR) << StringPrintf("CET4T: File has not been selected");
         ce_t4t_send_status(T4T_RSP_CMD_NOT_ALLOWED);
       }
     } else if (instruct == T4T_CMD_INS_UPDATE_BINARY) {
       if (ce_cb.mem.t4t.status & CE_T4T_STATUS_NDEF_FILE_READ_ONLY) {
-        CE_TRACE_ERROR0("CET4T: No access right");
+        LOG(ERROR) << StringPrintf("CET4T: No access right");
         ce_t4t_send_status(T4T_RSP_CMD_NOT_ALLOWED);
       } else if (ce_cb.mem.t4t.status & CE_T4T_STATUS_NDEF_SELECTED) {
         BE_STREAM_TO_UINT16(offset, p_cmd); /* Offset */
@@ -679,15 +677,15 @@ static void ce_t4t_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
         /* check if valid parameters */
         if ((uint32_t)length <= CE_T4T_MAX_LC) {
           if (length + offset > ce_cb.mem.t4t.max_file_size) {
-            CE_TRACE_ERROR3(
+            LOG(ERROR) << StringPrintf(
                 "CET4T: length (%d) + offset (%d) must be less than "
                 "max_file_size (%d)",
                 length, offset, ce_cb.mem.t4t.max_file_size);
             length = 0;
           }
         } else {
-          CE_TRACE_ERROR2("CET4T: length (%d) must be less than MLc (%d)",
-                          length, CE_T4T_MAX_LC);
+          LOG(ERROR) << StringPrintf("CET4T: length (%d) must be less than MLc (%lu)",
+                          length, (unsigned long)CE_T4T_MAX_LC);
           length = 0;
         }
 
@@ -696,15 +694,15 @@ static void ce_t4t_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
         else
           ce_t4t_send_status(T4T_RSP_WRONG_PARAMS);
       } else {
-        CE_TRACE_ERROR0("CET4T: NDEF File has not been selected");
+        LOG(ERROR) << StringPrintf("CET4T: NDEF File has not been selected");
         ce_t4t_send_status(T4T_RSP_CMD_NOT_ALLOWED);
       }
     } else {
-      CE_TRACE_ERROR1("CET4T: Unsupported Instruction byte (0x%02X)", instruct);
+      LOG(ERROR) << StringPrintf("CET4T: Unsupported Instruction byte (0x%02X)", instruct);
       ce_t4t_send_status(T4T_RSP_INSTR_NOT_SUPPORTED);
     }
   } else {
-    CE_TRACE_ERROR0("CET4T: Application has not been selected");
+    LOG(ERROR) << StringPrintf("CET4T: Application has not been selected");
     ce_t4t_send_status(T4T_RSP_CMD_NOT_ALLOWED);
   }
 
@@ -723,7 +721,7 @@ static void ce_t4t_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
 tNFC_STATUS ce_select_t4t(void) {
   tCE_T4T_MEM* p_t4t = &ce_cb.mem.t4t;
 
-  CE_TRACE_DEBUG0("ce_select_t4t ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("ce_select_t4t ()");
 
   nfc_stop_quick_timer(&p_t4t->timer);
 
@@ -762,19 +760,19 @@ tNFC_STATUS CE_T4tSetLocalNDEFMsg(bool read_only, uint16_t ndef_msg_max,
   tCE_T4T_MEM* p_t4t = &ce_cb.mem.t4t;
   uint8_t* p;
 
-  CE_TRACE_API3(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "CE_T4tSetLocalNDEFMsg () read_only=%d, ndef_msg_max=%d, ndef_msg_len=%d",
       read_only, ndef_msg_max, ndef_msg_len);
 
   if (!p_ndef_msg) {
     p_t4t->p_ndef_msg = NULL;
 
-    CE_TRACE_DEBUG0("CE_T4tSetLocalNDEFMsg (): T4T is disabled");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("CE_T4tSetLocalNDEFMsg (): T4T is disabled");
     return NFC_STATUS_OK;
   }
 
   if ((!read_only) && (!p_scratch_buf)) {
-    CE_TRACE_ERROR0(
+    LOG(ERROR) << StringPrintf(
         "CE_T4tSetLocalNDEFMsg (): p_scratch_buf cannot be NULL if not "
         "read-only");
     return NFC_STATUS_FAILED;
@@ -844,43 +842,43 @@ tCE_T4T_AID_HANDLE CE_T4tRegisterAID(uint8_t aid_len, uint8_t* p_aid,
 
   /* Handle registering callback for wildcard AID (all AIDs) */
   if (aid_len == 0) {
-    CE_TRACE_API0(
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "CE_T4tRegisterAID (): registering callback for wildcard AID ");
 
     /* Check if a wildcard callback is already registered (only one is allowed)
      */
     if (p_t4t->p_wildcard_aid_cback != NULL) {
-      CE_TRACE_ERROR0(
+      LOG(ERROR) << StringPrintf(
           "CE_T4tRegisterAID (): only one wildcard AID can be registered at "
           "time.");
       return CE_T4T_AID_HANDLE_INVALID;
     }
 
-    CE_TRACE_DEBUG1(
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "CE_T4tRegisterAID (): handle 0x%02x registered (for wildcard AID)",
         CE_T4T_WILDCARD_AID_HANDLE);
     p_t4t->p_wildcard_aid_cback = p_cback;
     return CE_T4T_WILDCARD_AID_HANDLE;
   }
 
-  CE_TRACE_API5("CE_T4tRegisterAID () AID [%02X%02X%02X%02X...], %d bytes",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("CE_T4tRegisterAID () AID [%02X%02X%02X%02X...], %d bytes",
                 *p_aid, *(p_aid + 1), *(p_aid + 2), *(p_aid + 3), aid_len);
 
   if (aid_len > NFC_MAX_AID_LEN) {
-    CE_TRACE_ERROR1("CE_T4tRegisterAID (): AID is up to %d bytes",
+    LOG(ERROR) << StringPrintf("CE_T4tRegisterAID (): AID is up to %d bytes",
                     NFC_MAX_AID_LEN);
     return CE_T4T_AID_HANDLE_INVALID;
   }
 
   if (p_cback == NULL) {
-    CE_TRACE_ERROR0("CE_T4tRegisterAID (): callback must be provided");
+    LOG(ERROR) << StringPrintf("CE_T4tRegisterAID (): callback must be provided");
     return CE_T4T_AID_HANDLE_INVALID;
   }
 
   for (xx = 0; xx < CE_T4T_MAX_REG_AID; xx++) {
     if ((p_t4t->reg_aid[xx].aid_len == aid_len) &&
         (!(memcmp(p_t4t->reg_aid[xx].aid, p_aid, aid_len)))) {
-      CE_TRACE_ERROR0("CE_T4tRegisterAID (): already registered");
+      LOG(ERROR) << StringPrintf("CE_T4tRegisterAID (): already registered");
       return CE_T4T_AID_HANDLE_INVALID;
     }
   }
@@ -895,10 +893,10 @@ tCE_T4T_AID_HANDLE CE_T4tRegisterAID(uint8_t aid_len, uint8_t* p_aid,
   }
 
   if (xx >= CE_T4T_MAX_REG_AID) {
-    CE_TRACE_ERROR0("CE_T4tRegisterAID (): No resource");
+    LOG(ERROR) << StringPrintf("CE_T4tRegisterAID (): No resource");
     return CE_T4T_AID_HANDLE_INVALID;
   } else {
-    CE_TRACE_DEBUG1("CE_T4tRegisterAID (): handle 0x%02x registered", xx);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("CE_T4tRegisterAID (): handle 0x%02x registered", xx);
   }
 
   return (xx);
@@ -916,14 +914,14 @@ tCE_T4T_AID_HANDLE CE_T4tRegisterAID(uint8_t aid_len, uint8_t* p_aid,
 extern void CE_T4tDeregisterAID(tCE_T4T_AID_HANDLE aid_handle) {
   tCE_T4T_MEM* p_t4t = &ce_cb.mem.t4t;
 
-  CE_TRACE_API1("CE_T4tDeregisterAID () handle 0x%02x", aid_handle);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("CE_T4tDeregisterAID () handle 0x%02x", aid_handle);
 
   /* Check if deregistering wildcard AID */
   if (aid_handle == CE_T4T_WILDCARD_AID_HANDLE) {
     if (p_t4t->p_wildcard_aid_cback != NULL) {
       p_t4t->p_wildcard_aid_cback = NULL;
     } else {
-      CE_TRACE_ERROR0("CE_T4tDeregisterAID (): Invalid handle");
+      LOG(ERROR) << StringPrintf("CE_T4tDeregisterAID (): Invalid handle");
     }
     return;
   }
@@ -931,145 +929,10 @@ extern void CE_T4tDeregisterAID(tCE_T4T_AID_HANDLE aid_handle) {
   /* Deregister AID */
   if ((aid_handle >= CE_T4T_MAX_REG_AID) ||
       (p_t4t->reg_aid[aid_handle].aid_len == 0)) {
-    CE_TRACE_ERROR0("CE_T4tDeregisterAID (): Invalid handle");
+    LOG(ERROR) << StringPrintf("CE_T4tDeregisterAID (): Invalid handle");
   } else {
     p_t4t->reg_aid[aid_handle].aid_len = 0;
     p_t4t->reg_aid[aid_handle].p_cback = NULL;
   }
 }
 
-/*******************************************************************************
-**
-** Function         CE_T4TTestSetCC
-**
-** Description      Set fields in Capability Container File for testing
-**
-** Returns          NFC_STATUS_OK if success
-**
-*******************************************************************************/
-tNFC_STATUS CE_T4TTestSetCC(uint16_t cc_len, uint8_t version, uint16_t max_le,
-                            uint16_t max_lc) {
-#if (CE_TEST_INCLUDED == false)
-  (void)(cc_len);
-  (void)(version);
-  (void)(max_le);
-  (void)(max_lc);
-#endif
-
-#if (CE_TEST_INCLUDED == true)
-  tCE_T4T_MEM* p_t4t = &ce_cb.mem.t4t;
-  uint8_t* p;
-
-  CE_TRACE_DEBUG4(
-      "CE_T4TTestSetCC (): CCLen:0x%04X, Ver:0x%02X, MaxLe:0x%04X, "
-      "MaxLc:0x%04X",
-      cc_len, version, max_le, max_lc);
-
-  /* CC file */
-  p = p_t4t->cc_file;
-
-  if (cc_len != 0xFFFF) {
-    UINT16_TO_BE_STREAM(p, cc_len);
-  } else
-    p += 2;
-
-  if (version != 0xFF) {
-    mapping_aid_test_enabled = true;
-    if (version == T4T_VERSION_1_0)
-      ce_test_tag_app_id[T4T_V20_NDEF_TAG_AID_LEN - 1] = 0x00;
-    else if (version == T4T_VERSION_2_0)
-      ce_test_tag_app_id[T4T_V20_NDEF_TAG_AID_LEN - 1] = 0x01;
-    else /* Undefined version */
-      ce_test_tag_app_id[T4T_V20_NDEF_TAG_AID_LEN - 1] = 0xFF;
-
-    UINT8_TO_BE_STREAM(p, version);
-  } else {
-    mapping_aid_test_enabled = false;
-    p += 1;
-  }
-
-  if (max_le != 0xFFFF) {
-    UINT16_TO_BE_STREAM(p, max_le);
-  } else
-    p += 2;
-
-  if (max_lc != 0xFFFF) {
-    UINT16_TO_BE_STREAM(p, max_lc);
-  } else
-    p += 2;
-
-  return NFC_STATUS_OK;
-#else
-  return NFC_STATUS_FAILED;
-#endif
-}
-
-/*******************************************************************************
-**
-** Function         CE_T4TTestSetNDEFCtrlTLV
-**
-** Description      Set fields in NDEF File Control TLV for testing
-**
-** Returns          NFC_STATUS_OK if success
-**
-*******************************************************************************/
-tNFC_STATUS CE_T4TTestSetNDEFCtrlTLV(uint8_t type, uint8_t length,
-                                     uint16_t file_id, uint16_t max_file_size,
-                                     uint8_t read_access,
-                                     uint8_t write_access) {
-#if (CE_TEST_INCLUDED == false)
-  (void)(type);
-  (void)(length);
-  (void)(file_id);
-  (void)(max_file_size);
-  (void)(read_access);
-  (void)(write_access);
-#endif
-
-#if (CE_TEST_INCLUDED == true)
-  tCE_T4T_MEM* p_t4t = &ce_cb.mem.t4t;
-  uint8_t* p;
-
-  CE_TRACE_DEBUG6(
-      "CE_T4TTestSetNDEFCtrlTLV (): type:0x%02X, len:0x%02X, FileID:0x%04X, "
-      "MaxFile:0x%04X, RdAcc:0x%02X, WrAcc:0x%02X",
-      type, length, file_id, max_file_size, read_access, write_access);
-
-  /* NDEF File control TLV */
-  p = p_t4t->cc_file + T4T_FC_TLV_OFFSET_IN_CC;
-
-  if (type != 0xFF) {
-    UINT8_TO_BE_STREAM(p, type);
-  } else
-    p += 1;
-
-  if (length != 0xFF) {
-    UINT8_TO_BE_STREAM(p, length);
-  } else
-    p += 1;
-
-  if (file_id != 0xFFFF) {
-    UINT16_TO_BE_STREAM(p, file_id);
-  } else
-    p += 2;
-
-  if (max_file_size != 0xFFFF) {
-    UINT16_TO_BE_STREAM(p, max_file_size);
-  } else
-    p += 2;
-
-  if (read_access != 0xFF) {
-    UINT8_TO_BE_STREAM(p, read_access);
-  } else
-    p += 1;
-
-  if (write_access != 0xFF) {
-    UINT8_TO_BE_STREAM(p, write_access);
-  } else
-    p += 1;
-
-  return NFC_STATUS_OK;
-#else
-  return NFC_STATUS_FAILED;
-#endif
-}
diff --git a/src/nfc/tags/rw_i93.c b/src/nfc/tags/rw_i93.cc
old mode 100644
new mode 100755
similarity index 85%
rename from src/nfc/tags/rw_i93.c
rename to src/nfc/tags/rw_i93.cc
index fbe09fc..62c5b54
--- a/src/nfc/tags/rw_i93.c
+++ b/src/nfc/tags/rw_i93.cc
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -42,14 +42,22 @@
  *
  ******************************************************************************/
 #include <string.h>
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfc_target.h"
 #include "bt_types.h"
-#include "trace_api.h"
 
 #include "nfc_api.h"
 #include "nfc_int.h"
 #include "rw_api.h"
 #include "rw_int.h"
+#include "nfa_sys.h"
+
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
 
 #if (NXP_EXTNS == TRUE)
 /* Response timeout     */
@@ -104,16 +112,15 @@ enum {
   RW_I93_SUBSTATE_WAIT_LOCK_CC    /* lock block of CC                     */
 };
 
-#if (BT_TRACE_VERBOSE == true)
-static char* rw_i93_get_state_name(uint8_t state);
-static char* rw_i93_get_sub_state_name(uint8_t sub_state);
-static char* rw_i93_get_tag_name(uint8_t product_version);
-#endif
+static std::string rw_i93_get_state_name(uint8_t state);
+static std::string rw_i93_get_sub_state_name(uint8_t sub_state);
+static std::string rw_i93_get_tag_name(uint8_t product_version);
 
 static void rw_i93_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
                               tNFC_CONN* p_data);
 void rw_i93_handle_error(tNFC_STATUS status);
 tNFC_STATUS rw_i93_send_cmd_get_sys_info(uint8_t* p_uid, uint8_t extra_flag);
+tNFC_STATUS rw_i93_send_cmd_get_ext_sys_info(uint8_t* p_uid);
 
 /*******************************************************************************
 **
@@ -131,7 +138,7 @@ void rw_i93_get_product_version(uint8_t* p_uid) {
     return;
   }
 
-  RW_TRACE_DEBUG0("rw_i93_get_product_version ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_i93_get_product_version ()");
 
   memcpy(p_i93->uid, p_uid, I93_UID_BYTE_LEN);
 
@@ -167,6 +174,10 @@ void rw_i93_get_product_version(uint8_t* p_uid) {
       p_i93->product_version = RW_I93_STM_M24LR16E_R;
     else if (p_i93->ic_reference == I93_IC_REF_STM_M24LR64E_R)
       p_i93->product_version = RW_I93_STM_M24LR64E_R;
+    else if (p_i93->ic_reference == I93_IC_REF_STM_ST25DVHIK)
+      p_i93->product_version = RW_I93_STM_ST25DVHIK;
+    else if (p_i93->ic_reference == I93_IC_REF_STM_ST25DV04K)
+      p_i93->product_version = RW_I93_STM_ST25DV04K;
     else {
       switch (p_i93->ic_reference & I93_IC_REF_STM_MASK) {
         case I93_IC_REF_STM_LRI1K:
@@ -193,12 +204,8 @@ void rw_i93_get_product_version(uint8_t* p_uid) {
     p_i93->product_version = RW_I93_UNKNOWN_PRODUCT;
   }
 
-#if (BT_TRACE_VERBOSE == true)
-  RW_TRACE_DEBUG1("product_version = <%s>",
-                  rw_i93_get_tag_name(p_i93->product_version));
-#else
-  RW_TRACE_DEBUG1("product_version = %d", p_i93->product_version);
-#endif
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("product_version = <%s>",
+                  rw_i93_get_tag_name(p_i93->product_version).c_str());
 
   switch (p_i93->product_version) {
     case RW_I93_TAG_IT_HF_I_STD_CHIP_INLAY:
@@ -214,6 +221,62 @@ void rw_i93_get_product_version(uint8_t* p_uid) {
   }
 }
 
+/*******************************************************************************
+**
+** Function         rw_i93_process_ext_sys_info
+**
+** Description      Store extended system information of tag
+**
+** Returns          FALSE if retrying with protocol extension flag
+**
+*******************************************************************************/
+bool rw_i93_process_ext_sys_info(uint8_t* p_data) {
+  uint8_t* p = p_data;
+  tRW_I93_CB* p_i93 = &rw_cb.tcb.i93;
+  uint8_t uid[I93_UID_BYTE_LEN], *p_uid;
+
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
+
+  STREAM_TO_UINT8(p_i93->info_flags, p);
+
+  p_uid = uid;
+  STREAM_TO_ARRAY8(p_uid, p);
+
+  if (p_i93->info_flags & I93_INFO_FLAG_DSFID) {
+    STREAM_TO_UINT8(p_i93->dsfid, p);
+  }
+  if (p_i93->info_flags & I93_INFO_FLAG_AFI) {
+    STREAM_TO_UINT8(p_i93->afi, p);
+  }
+  if (p_i93->info_flags & I93_INFO_FLAG_MEM_SIZE) {
+    STREAM_TO_UINT16(p_i93->num_block, p);
+
+    /* it is one less than actual number of bytes */
+    p_i93->num_block += 1;
+
+    STREAM_TO_UINT8(p_i93->block_size, p);
+    /* it is one less than actual number of blocks */
+    p_i93->block_size = (p_i93->block_size & 0x1F) + 1;
+  }
+  if (p_i93->info_flags & I93_INFO_FLAG_IC_REF) {
+    STREAM_TO_UINT8(p_i93->ic_reference, p);
+
+    /* clear existing UID to set product version */
+    p_i93->uid[0] = 0x00;
+
+    /* store UID and get product version */
+    rw_i93_get_product_version(p_uid);
+
+    if (p_i93->uid[0] == I93_UID_FIRST_BYTE) {
+      if (p_i93->uid[1] == I93_UID_IC_MFG_CODE_STM) {
+        /* STM supports more than 2040 bytes */
+        p_i93->intl_flags |= RW_I93_FLAG_EXT_COMMANDS;
+      }
+    }
+  }
+  return true;
+}
+
 /*******************************************************************************
 **
 ** Function         rw_i93_process_sys_info
@@ -228,7 +291,7 @@ bool rw_i93_process_sys_info(uint8_t* p_data) {
   tRW_I93_CB* p_i93 = &rw_cb.tcb.i93;
   uint8_t uid[I93_UID_BYTE_LEN], *p_uid;
 
-  RW_TRACE_DEBUG0("rw_i93_process_sys_info ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_i93_process_sys_info ()");
 
   STREAM_TO_UINT8(p_i93->info_flags, p);
 
@@ -297,12 +360,20 @@ bool rw_i93_process_sys_info(uint8_t* p_data) {
               return false;
             }
           }
-          return true;
         } else if ((p_i93->product_version == RW_I93_STM_LRI2K) &&
                    (p_i93->ic_reference == 0x21)) {
           /* workaround of byte order in memory size information */
           p_i93->num_block = 64;
           p_i93->block_size = 4;
+          } else if (!(p_i93->info_flags & I93_INFO_FLAG_MEM_SIZE)) {
+          if (!(p_i93->intl_flags & RW_I93_FLAG_EXT_COMMANDS)) {
+            if (rw_i93_send_cmd_get_ext_sys_info(NULL) == NFC_STATUS_OK) {
+              /* STM supports more than 2040 bytes */
+              p_i93->intl_flags |= RW_I93_FLAG_EXT_COMMANDS;
+
+              return false;
+            }
+          }
         }
       }
     }
@@ -324,7 +395,7 @@ bool rw_i93_process_sys_info(uint8_t* p_data) {
 bool rw_i93_check_sys_info_prot_ext(uint8_t error_code) {
   tRW_I93_CB* p_i93 = &rw_cb.tcb.i93;
 
-  RW_TRACE_DEBUG0("rw_i93_check_sys_info_prot_ext ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_i93_check_sys_info_prot_ext ()");
 
   if ((p_i93->uid[1] == I93_UID_IC_MFG_CODE_STM) &&
       (p_i93->sent_cmd == I93_CMD_GET_SYS_INFO) &&
@@ -355,7 +426,7 @@ void rw_i93_send_to_upper(NFC_HDR* p_resp) {
   uint8_t flags;
   NFC_HDR* p_buff;
 
-  RW_TRACE_DEBUG0("rw_i93_send_to_upper ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_i93_send_to_upper ()");
 
   STREAM_TO_UINT8(flags, p);
   length--;
@@ -395,8 +466,11 @@ void rw_i93_send_to_upper(NFC_HDR* p_resp) {
       break;
 
     case I93_CMD_READ_SINGLE_BLOCK:
+    case I93_CMD_EXT_READ_SINGLE_BLOCK:
     case I93_CMD_READ_MULTI_BLOCK:
+    case I93_CMD_EXT_READ_MULTI_BLOCK:
     case I93_CMD_GET_MULTI_BLK_SEC:
+    case I93_CMD_EXT_GET_MULTI_BLK_SEC:
 
       /* forward tag data or security status */
       p_buff = (NFC_HDR*)GKI_getbuf((uint16_t)(length + NFC_HDR_SIZE));
@@ -422,8 +496,11 @@ void rw_i93_send_to_upper(NFC_HDR* p_resp) {
       break;
 
     case I93_CMD_WRITE_SINGLE_BLOCK:
+    case I93_CMD_EXT_WRITE_SINGLE_BLOCK:
     case I93_CMD_LOCK_BLOCK:
+    case I93_CMD_EXT_LOCK_BLOCK:
     case I93_CMD_WRITE_MULTI_BLOCK:
+    case I93_CMD_EXT_WRITE_MULTI_BLOCK:
     case I93_CMD_SELECT:
     case I93_CMD_RESET_TO_READY:
     case I93_CMD_WRITE_AFI:
@@ -460,6 +537,28 @@ void rw_i93_send_to_upper(NFC_HDR* p_resp) {
       }
       break;
 
+    case I93_CMD_EXT_GET_SYS_INFO:
+
+      if (rw_i93_process_ext_sys_info(p)) {
+        rw_data.i93_sys_info.status = NFC_STATUS_OK;
+        rw_data.i93_sys_info.info_flags = p_i93->info_flags;
+        rw_data.i93_sys_info.dsfid = p_i93->dsfid;
+        rw_data.i93_sys_info.afi = p_i93->afi;
+        rw_data.i93_sys_info.num_block = p_i93->num_block;
+        rw_data.i93_sys_info.block_size = p_i93->block_size;
+        rw_data.i93_sys_info.IC_reference = p_i93->ic_reference;
+
+        memcpy(rw_data.i93_sys_info.uid, p_i93->uid, I93_UID_BYTE_LEN);
+
+        event = RW_I93_SYS_INFO_EVT;
+      } else {
+        /* retrying with protocol extension flag or with extended sys info
+         * command */
+        p_i93->state = RW_I93_STATE_BUSY;
+        return;
+      }
+      break;
+
     default:
       break;
   }
@@ -468,7 +567,7 @@ void rw_i93_send_to_upper(NFC_HDR* p_resp) {
   if (event != RW_I93_MAX_EVT) {
     (*(rw_cb.p_cback))(event, &rw_data);
   } else {
-    RW_TRACE_ERROR0("rw_i93_send_to_upper (): Invalid response");
+    LOG(ERROR) << StringPrintf("rw_i93_send_to_upper (): Invalid response");
   }
 }
 
@@ -482,9 +581,6 @@ void rw_i93_send_to_upper(NFC_HDR* p_resp) {
 **
 *******************************************************************************/
 bool rw_i93_send_to_lower(NFC_HDR* p_msg) {
-#if (BT_TRACE_PROTOCOL == true)
-  DispRWI93Tag(p_msg, false, 0x00);
-#endif
 
   /* store command for retransmitting */
   if (rw_cb.tcb.i93.p_retry_cmd) {
@@ -500,7 +596,7 @@ bool rw_i93_send_to_lower(NFC_HDR* p_msg) {
   }
 
   if (NFC_SendData(NFC_RF_CONN_ID, p_msg) != NFC_STATUS_OK) {
-    RW_TRACE_ERROR0("rw_i93_send_to_lower (): NFC_SendData () failed");
+    LOG(ERROR) << StringPrintf("rw_i93_send_to_lower (): NFC_SendData () failed");
     return false;
   }
 
@@ -524,13 +620,13 @@ tNFC_STATUS rw_i93_send_cmd_inventory(uint8_t* p_uid, bool including_afi,
   NFC_HDR* p_cmd;
   uint8_t* p, flags;
 
-  RW_TRACE_DEBUG2("rw_i93_send_cmd_inventory () including_afi:%d, AFI:0x%02X",
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_i93_send_cmd_inventory () including_afi:%d, AFI:0x%02X",
                   including_afi, afi);
 
   p_cmd = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_cmd) {
-    RW_TRACE_ERROR0("rw_i93_send_cmd_inventory (): Cannot allocate buffer");
+    LOG(ERROR) << StringPrintf("rw_i93_send_cmd_inventory (): Cannot allocate buffer");
     return NFC_STATUS_NO_BUFFERS;
   }
 
@@ -585,12 +681,12 @@ tNFC_STATUS rw_i93_send_cmd_stay_quiet(void) {
   NFC_HDR* p_cmd;
   uint8_t* p;
 
-  RW_TRACE_DEBUG0("rw_i93_send_cmd_stay_quiet ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_i93_send_cmd_stay_quiet ()");
 
   p_cmd = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_cmd) {
-    RW_TRACE_ERROR0("rw_i93_send_cmd_stay_quiet (): Cannot allocate buffer");
+    LOG(ERROR) << StringPrintf("rw_i93_send_cmd_stay_quiet (): Cannot allocate buffer");
     return NFC_STATUS_NO_BUFFERS;
   }
 
@@ -635,12 +731,12 @@ tNFC_STATUS rw_i93_send_cmd_read_single_block(uint16_t block_number,
   NFC_HDR* p_cmd;
   uint8_t* p, flags;
 
-  RW_TRACE_DEBUG0("rw_i93_send_cmd_read_single_block ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_i93_send_cmd_read_single_block ()");
 
   p_cmd = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_cmd) {
-    RW_TRACE_ERROR0(
+    LOG(ERROR) << StringPrintf(
         "rw_i93_send_cmd_read_single_block (): Cannot allocate buffer");
     return NFC_STATUS_NO_BUFFERS;
   }
@@ -661,12 +757,17 @@ tNFC_STATUS rw_i93_send_cmd_read_single_block(uint16_t block_number,
   UINT8_TO_STREAM(p, flags);
 
   /* Command Code */
-  UINT8_TO_STREAM(p, I93_CMD_READ_SINGLE_BLOCK);
+  if (rw_cb.tcb.i93.intl_flags & RW_I93_FLAG_EXT_COMMANDS) {
+    UINT8_TO_STREAM(p, I93_CMD_EXT_READ_SINGLE_BLOCK);
+  } else {
+    UINT8_TO_STREAM(p, I93_CMD_READ_SINGLE_BLOCK);
+  }
 
   /* Parameters */
   ARRAY8_TO_STREAM(p, rw_cb.tcb.i93.uid); /* UID */
 
-  if (rw_cb.tcb.i93.intl_flags & RW_I93_FLAG_16BIT_NUM_BLOCK) {
+  if (rw_cb.tcb.i93.intl_flags & RW_I93_FLAG_16BIT_NUM_BLOCK ||
+      rw_cb.tcb.i93.intl_flags & RW_I93_FLAG_EXT_COMMANDS) {
     UINT16_TO_STREAM(p, block_number); /* Block number */
     p_cmd->len++;
   } else {
@@ -674,7 +775,10 @@ tNFC_STATUS rw_i93_send_cmd_read_single_block(uint16_t block_number,
   }
 
   if (rw_i93_send_to_lower(p_cmd)) {
-    rw_cb.tcb.i93.sent_cmd = I93_CMD_READ_SINGLE_BLOCK;
+    if (rw_cb.tcb.i93.intl_flags & RW_I93_FLAG_EXT_COMMANDS)
+      rw_cb.tcb.i93.sent_cmd = I93_CMD_EXT_READ_SINGLE_BLOCK;
+    else
+      rw_cb.tcb.i93.sent_cmd = I93_CMD_READ_SINGLE_BLOCK;
     return NFC_STATUS_OK;
   } else {
     return NFC_STATUS_FAILED;
@@ -695,12 +799,12 @@ tNFC_STATUS rw_i93_send_cmd_write_single_block(uint16_t block_number,
   NFC_HDR* p_cmd;
   uint8_t* p, flags;
 
-  RW_TRACE_DEBUG0("rw_i93_send_cmd_write_single_block ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_i93_send_cmd_write_single_block ()");
 
   p_cmd = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_cmd) {
-    RW_TRACE_ERROR0(
+    LOG(ERROR) << StringPrintf(
         "rw_i93_send_cmd_write_single_block (): Cannot allocate buffer");
     return NFC_STATUS_NO_BUFFERS;
   }
@@ -728,12 +832,17 @@ tNFC_STATUS rw_i93_send_cmd_write_single_block(uint16_t block_number,
   UINT8_TO_STREAM(p, flags);
 
   /* Command Code */
-  UINT8_TO_STREAM(p, I93_CMD_WRITE_SINGLE_BLOCK);
+  if (rw_cb.tcb.i93.intl_flags & RW_I93_FLAG_EXT_COMMANDS) {
+    UINT8_TO_STREAM(p, I93_CMD_EXT_WRITE_SINGLE_BLOCK);
+  } else {
+    UINT8_TO_STREAM(p, I93_CMD_WRITE_SINGLE_BLOCK);
+  }
 
   /* Parameters */
   ARRAY8_TO_STREAM(p, rw_cb.tcb.i93.uid); /* UID */
 
-  if (rw_cb.tcb.i93.intl_flags & RW_I93_FLAG_16BIT_NUM_BLOCK) {
+  if (rw_cb.tcb.i93.intl_flags & RW_I93_FLAG_16BIT_NUM_BLOCK ||
+      rw_cb.tcb.i93.intl_flags & RW_I93_FLAG_EXT_COMMANDS) {
     UINT16_TO_STREAM(p, block_number); /* Block number */
     p_cmd->len++;
   } else {
@@ -744,7 +853,10 @@ tNFC_STATUS rw_i93_send_cmd_write_single_block(uint16_t block_number,
   ARRAY_TO_STREAM(p, p_data, rw_cb.tcb.i93.block_size);
 
   if (rw_i93_send_to_lower(p_cmd)) {
-    rw_cb.tcb.i93.sent_cmd = I93_CMD_WRITE_SINGLE_BLOCK;
+    if (rw_cb.tcb.i93.intl_flags & RW_I93_FLAG_EXT_COMMANDS)
+      rw_cb.tcb.i93.sent_cmd = I93_CMD_EXT_WRITE_SINGLE_BLOCK;
+    else
+      rw_cb.tcb.i93.sent_cmd = I93_CMD_WRITE_SINGLE_BLOCK;
     return NFC_STATUS_OK;
   } else {
     return NFC_STATUS_FAILED;
@@ -767,12 +879,12 @@ tNFC_STATUS rw_i93_send_cmd_lock_block(uint8_t block_number) {
   NFC_HDR* p_cmd;
   uint8_t* p;
 
-  RW_TRACE_DEBUG0("rw_i93_send_cmd_lock_block ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_i93_send_cmd_lock_block ()");
 
   p_cmd = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_cmd) {
-    RW_TRACE_ERROR0("rw_i93_send_cmd_lock_block (): Cannot allocate buffer");
+    LOG(ERROR) << StringPrintf("rw_i93_send_cmd_lock_block (): Cannot allocate buffer");
     return NFC_STATUS_NO_BUFFERS;
   }
 
@@ -794,14 +906,26 @@ tNFC_STATUS rw_i93_send_cmd_lock_block(uint8_t block_number) {
   }
 
   /* Command Code */
-  UINT8_TO_STREAM(p, I93_CMD_LOCK_BLOCK);
+  if (rw_cb.tcb.i93.intl_flags & RW_I93_FLAG_EXT_COMMANDS) {
+    UINT8_TO_STREAM(p, I93_CMD_EXT_LOCK_BLOCK);
+  } else {
+    UINT8_TO_STREAM(p, I93_CMD_LOCK_BLOCK);
+  }
 
   /* Parameters */
   ARRAY8_TO_STREAM(p, rw_cb.tcb.i93.uid); /* UID */
-  UINT8_TO_STREAM(p, block_number);       /* Block number */
+  if (rw_cb.tcb.i93.intl_flags & RW_I93_FLAG_EXT_COMMANDS) {
+    UINT16_TO_STREAM(p, block_number); /* Block number */
+    p_cmd->len++;
+  } else {
+    UINT8_TO_STREAM(p, block_number); /* Block number */
+  }
 
   if (rw_i93_send_to_lower(p_cmd)) {
-    rw_cb.tcb.i93.sent_cmd = I93_CMD_LOCK_BLOCK;
+    if (rw_cb.tcb.i93.intl_flags & RW_I93_FLAG_EXT_COMMANDS)
+      rw_cb.tcb.i93.sent_cmd = I93_CMD_EXT_LOCK_BLOCK;
+    else
+      rw_cb.tcb.i93.sent_cmd = I93_CMD_LOCK_BLOCK;
     return NFC_STATUS_OK;
   } else {
     return NFC_STATUS_FAILED;
@@ -822,12 +946,12 @@ tNFC_STATUS rw_i93_send_cmd_read_multi_blocks(uint16_t first_block_number,
   NFC_HDR* p_cmd;
   uint8_t* p, flags;
 
-  RW_TRACE_DEBUG0("rw_i93_send_cmd_read_multi_blocks ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_i93_send_cmd_read_multi_blocks ()");
 
   p_cmd = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_cmd) {
-    RW_TRACE_ERROR0(
+    LOG(ERROR) << StringPrintf(
         "rw_i93_send_cmd_read_multi_blocks (): Cannot allocate buffer");
     return NFC_STATUS_NO_BUFFERS;
   }
@@ -840,29 +964,44 @@ tNFC_STATUS rw_i93_send_cmd_read_multi_blocks(uint16_t first_block_number,
   flags =
       (I93_FLAG_ADDRESS_SET | RW_I93_FLAG_SUB_CARRIER | RW_I93_FLAG_DATA_RATE);
 
-  if (rw_cb.tcb.i93.intl_flags & RW_I93_FLAG_16BIT_NUM_BLOCK)
+  if (rw_cb.tcb.i93.intl_flags & RW_I93_FLAG_16BIT_NUM_BLOCK) {
     flags |= I93_FLAG_PROT_EXT_YES;
+  }
 
   UINT8_TO_STREAM(p, flags);
 
   /* Command Code */
-  UINT8_TO_STREAM(p, I93_CMD_READ_MULTI_BLOCK);
+  if (rw_cb.tcb.i93.intl_flags & RW_I93_FLAG_EXT_COMMANDS) {
+    UINT8_TO_STREAM(p, I93_CMD_EXT_READ_MULTI_BLOCK);
+  } else {
+    UINT8_TO_STREAM(p, I93_CMD_READ_MULTI_BLOCK);
+  }
 
   /* Parameters */
   ARRAY8_TO_STREAM(p, rw_cb.tcb.i93.uid); /* UID */
 
-  if (rw_cb.tcb.i93.intl_flags & RW_I93_FLAG_16BIT_NUM_BLOCK) {
+  if (rw_cb.tcb.i93.intl_flags & RW_I93_FLAG_16BIT_NUM_BLOCK ||
+      rw_cb.tcb.i93.intl_flags & RW_I93_FLAG_EXT_COMMANDS) {
     UINT16_TO_STREAM(p, first_block_number); /* First block number */
     p_cmd->len++;
   } else {
     UINT8_TO_STREAM(p, first_block_number); /* First block number */
   }
 
-  UINT8_TO_STREAM(
-      p, number_blocks - 1); /* Number of blocks, 0x00 to read one block */
+  if (rw_cb.tcb.i93.intl_flags & RW_I93_FLAG_EXT_COMMANDS) {
+    UINT16_TO_STREAM(
+        p, number_blocks - 1); /* Number of blocks, 0x00 to read one block */
+    p_cmd->len++;
+  } else {
+    UINT8_TO_STREAM(
+        p, number_blocks - 1); /* Number of blocks, 0x00 to read one block */
+  }
 
   if (rw_i93_send_to_lower(p_cmd)) {
-    rw_cb.tcb.i93.sent_cmd = I93_CMD_READ_MULTI_BLOCK;
+    if (rw_cb.tcb.i93.intl_flags & RW_I93_FLAG_EXT_COMMANDS)
+      rw_cb.tcb.i93.sent_cmd = I93_CMD_EXT_READ_MULTI_BLOCK;
+    else
+      rw_cb.tcb.i93.sent_cmd = I93_CMD_READ_MULTI_BLOCK;
     return NFC_STATUS_OK;
   } else {
     return NFC_STATUS_FAILED;
@@ -878,18 +1017,18 @@ tNFC_STATUS rw_i93_send_cmd_read_multi_blocks(uint16_t first_block_number,
 ** Returns          tNFC_STATUS
 **
 *******************************************************************************/
-tNFC_STATUS rw_i93_send_cmd_write_multi_blocks(uint8_t first_block_number,
+tNFC_STATUS rw_i93_send_cmd_write_multi_blocks(uint16_t first_block_number,
                                                uint16_t number_blocks,
                                                uint8_t* p_data) {
   NFC_HDR* p_cmd;
   uint8_t* p;
 
-  RW_TRACE_DEBUG0("rw_i93_send_cmd_write_multi_blocks ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_i93_send_cmd_write_multi_blocks ()");
 
   p_cmd = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_cmd) {
-    RW_TRACE_ERROR0(
+    LOG(ERROR) << StringPrintf(
         "rw_i93_send_cmd_write_multi_blocks (): Cannot allocate buffer");
     return NFC_STATUS_NO_BUFFERS;
   }
@@ -903,11 +1042,25 @@ tNFC_STATUS rw_i93_send_cmd_write_multi_blocks(uint8_t first_block_number,
                       RW_I93_FLAG_DATA_RATE));
 
   /* Command Code */
-  UINT8_TO_STREAM(p, I93_CMD_WRITE_MULTI_BLOCK);
+  if (rw_cb.tcb.i93.intl_flags & RW_I93_FLAG_EXT_COMMANDS) {
+    INT8_TO_STREAM(p, I93_CMD_EXT_WRITE_MULTI_BLOCK);
+  } else {
+    UINT8_TO_STREAM(p, I93_CMD_WRITE_MULTI_BLOCK);
+  }
 
   /* Parameters */
   ARRAY8_TO_STREAM(p, rw_cb.tcb.i93.uid); /* UID */
-  UINT8_TO_STREAM(p, first_block_number); /* First block number */
+  if (rw_cb.tcb.i93.intl_flags & RW_I93_FLAG_EXT_COMMANDS) {
+    UINT16_TO_STREAM(p, first_block_number); /* Block number */
+    UINT16_TO_STREAM(
+        p, number_blocks - 1); /* Number of blocks, 0x00 to read one block */
+    p_cmd->len += 2;
+  } else {
+    UINT8_TO_STREAM(p, first_block_number); /* Block number */
+    UINT8_TO_STREAM(
+        p, number_blocks - 1); /* Number of blocks, 0x00 to read one block */
+  }
+
   UINT8_TO_STREAM(
       p, number_blocks - 1); /* Number of blocks, 0x00 to read one block */
 
@@ -915,7 +1068,10 @@ tNFC_STATUS rw_i93_send_cmd_write_multi_blocks(uint8_t first_block_number,
   ARRAY_TO_STREAM(p, p_data, number_blocks * rw_cb.tcb.i93.block_size);
 
   if (rw_i93_send_to_lower(p_cmd)) {
-    rw_cb.tcb.i93.sent_cmd = I93_CMD_WRITE_MULTI_BLOCK;
+    if (rw_cb.tcb.i93.intl_flags & RW_I93_FLAG_EXT_COMMANDS)
+      rw_cb.tcb.i93.sent_cmd = I93_CMD_EXT_WRITE_MULTI_BLOCK;
+    else
+      rw_cb.tcb.i93.sent_cmd = I93_CMD_WRITE_MULTI_BLOCK;
     return NFC_STATUS_OK;
   } else {
     return NFC_STATUS_FAILED;
@@ -935,12 +1091,12 @@ tNFC_STATUS rw_i93_send_cmd_select(uint8_t* p_uid) {
   NFC_HDR* p_cmd;
   uint8_t* p;
 
-  RW_TRACE_DEBUG0("rw_i93_send_cmd_select ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_i93_send_cmd_select ()");
 
   p_cmd = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_cmd) {
-    RW_TRACE_ERROR0("rw_i93_send_cmd_select (): Cannot allocate buffer");
+    LOG(ERROR) << StringPrintf("rw_i93_send_cmd_select (): Cannot allocate buffer");
     return NFC_STATUS_NO_BUFFERS;
   }
 
@@ -979,12 +1135,12 @@ tNFC_STATUS rw_i93_send_cmd_reset_to_ready(void) {
   NFC_HDR* p_cmd;
   uint8_t* p;
 
-  RW_TRACE_DEBUG0("rw_i93_send_cmd_reset_to_ready ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_i93_send_cmd_reset_to_ready ()");
 
   p_cmd = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_cmd) {
-    RW_TRACE_ERROR0(
+    LOG(ERROR) << StringPrintf(
         "rw_i93_send_cmd_reset_to_ready (): Cannot allocate buffer");
     return NFC_STATUS_NO_BUFFERS;
   }
@@ -1024,12 +1180,12 @@ tNFC_STATUS rw_i93_send_cmd_write_afi(uint8_t afi) {
   NFC_HDR* p_cmd;
   uint8_t* p;
 
-  RW_TRACE_DEBUG0("rw_i93_send_cmd_write_afi ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_i93_send_cmd_write_afi ()");
 
   p_cmd = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_cmd) {
-    RW_TRACE_ERROR0("rw_i93_send_cmd_write_afi (): Cannot allocate buffer");
+    LOG(ERROR) << StringPrintf("rw_i93_send_cmd_write_afi (): Cannot allocate buffer");
     return NFC_STATUS_NO_BUFFERS;
   }
 
@@ -1069,12 +1225,12 @@ tNFC_STATUS rw_i93_send_cmd_lock_afi(void) {
   NFC_HDR* p_cmd;
   uint8_t* p;
 
-  RW_TRACE_DEBUG0("rw_i93_send_cmd_lock_afi ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_i93_send_cmd_lock_afi ()");
 
   p_cmd = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_cmd) {
-    RW_TRACE_ERROR0("rw_i93_send_cmd_lock_afi (): Cannot allocate buffer");
+    LOG(ERROR) << StringPrintf("rw_i93_send_cmd_lock_afi (): Cannot allocate buffer");
     return NFC_STATUS_NO_BUFFERS;
   }
 
@@ -1113,12 +1269,12 @@ tNFC_STATUS rw_i93_send_cmd_write_dsfid(uint8_t dsfid) {
   NFC_HDR* p_cmd;
   uint8_t* p;
 
-  RW_TRACE_DEBUG0("rw_i93_send_cmd_write_dsfid ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_i93_send_cmd_write_dsfid ()");
 
   p_cmd = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_cmd) {
-    RW_TRACE_ERROR0("rw_i93_send_cmd_write_dsfid (): Cannot allocate buffer");
+    LOG(ERROR) << StringPrintf("rw_i93_send_cmd_write_dsfid (): Cannot allocate buffer");
     return NFC_STATUS_NO_BUFFERS;
   }
 
@@ -1158,12 +1314,12 @@ tNFC_STATUS rw_i93_send_cmd_lock_dsfid(void) {
   NFC_HDR* p_cmd;
   uint8_t* p;
 
-  RW_TRACE_DEBUG0("rw_i93_send_cmd_lock_dsfid ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_i93_send_cmd_lock_dsfid ()");
 
   p_cmd = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_cmd) {
-    RW_TRACE_ERROR0("rw_i93_send_cmd_lock_dsfid (): Cannot allocate buffer");
+    LOG(ERROR) << StringPrintf("rw_i93_send_cmd_lock_dsfid (): Cannot allocate buffer");
     return NFC_STATUS_NO_BUFFERS;
   }
 
@@ -1189,6 +1345,60 @@ tNFC_STATUS rw_i93_send_cmd_lock_dsfid(void) {
   }
 }
 
+/*******************************************************************************
+**
+** Function         rw_i93_send_cmd_get_ext_sys_info
+**
+** Description      Send Get Extended System Information Request to VICC
+**
+** Returns          tNFC_STATUS
+**
+*******************************************************************************/
+tNFC_STATUS rw_i93_send_cmd_get_ext_sys_info(uint8_t* p_uid) {
+  NFC_HDR* p_cmd;
+  uint8_t* p;
+
+  DLOG_IF(INFO, nfc_debug_enabled) << __func__;
+
+  p_cmd = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
+
+  if (!p_cmd) {
+    DLOG_IF(INFO, nfc_debug_enabled) << __func__ << "Cannot allocate buffer";
+    return NFC_STATUS_NO_BUFFERS;
+  }
+
+  p_cmd->offset = NCI_MSG_OFFSET_SIZE + NCI_DATA_HDR_SIZE;
+  p_cmd->len = 11;
+  p = (uint8_t*)(p_cmd + 1) + p_cmd->offset;
+
+  /* Flags */
+  UINT8_TO_STREAM(p, (I93_FLAG_ADDRESS_SET | RW_I93_FLAG_SUB_CARRIER |
+                      RW_I93_FLAG_DATA_RATE));
+
+  /* Command Code */
+  UINT8_TO_STREAM(p, I93_CMD_EXT_GET_SYS_INFO);
+
+  /* Parameters request field */
+  UINT8_TO_STREAM(p,
+                  (I93_INFO_FLAG_MOI | I93_INFO_FLAG_DSFID | I93_INFO_FLAG_AFI |
+                   I93_INFO_FLAG_MEM_SIZE | I93_INFO_FLAG_IC_REF));
+
+  /* Parameters */
+  if (p_uid) {
+    ARRAY8_TO_STREAM(p, p_uid); /* UID */
+  } else {
+    ARRAY8_TO_STREAM(p, rw_cb.tcb.i93.uid); /* UID */
+  }
+
+  if (rw_i93_send_to_lower(p_cmd)) {
+    rw_cb.tcb.i93.sent_cmd = I93_CMD_EXT_GET_SYS_INFO;
+    return NFC_STATUS_OK;
+  } else {
+    return NFC_STATUS_FAILED;
+  }
+}
+
+
 /*******************************************************************************
 **
 ** Function         rw_i93_send_cmd_get_sys_info
@@ -1202,12 +1412,12 @@ tNFC_STATUS rw_i93_send_cmd_get_sys_info(uint8_t* p_uid, uint8_t extra_flags) {
   NFC_HDR* p_cmd;
   uint8_t* p;
 
-  RW_TRACE_DEBUG0("rw_i93_send_cmd_get_sys_info ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_i93_send_cmd_get_sys_info ()");
 
   p_cmd = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_cmd) {
-    RW_TRACE_ERROR0("rw_i93_send_cmd_get_sys_info (): Cannot allocate buffer");
+    LOG(ERROR) << StringPrintf("rw_i93_send_cmd_get_sys_info (): Cannot allocate buffer");
     return NFC_STATUS_NO_BUFFERS;
   }
 
@@ -1251,12 +1461,12 @@ tNFC_STATUS rw_i93_send_cmd_get_multi_block_sec(uint16_t first_block_number,
   NFC_HDR* p_cmd;
   uint8_t* p, flags;
 
-  RW_TRACE_DEBUG0("rw_i93_send_cmd_get_multi_block_sec ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_i93_send_cmd_get_multi_block_sec ()");
 
   p_cmd = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_cmd) {
-    RW_TRACE_ERROR0(
+    LOG(ERROR) << StringPrintf(
         "rw_i93_send_cmd_get_multi_block_sec (): Cannot allocate buffer");
     return NFC_STATUS_NO_BUFFERS;
   }
@@ -1275,12 +1485,17 @@ tNFC_STATUS rw_i93_send_cmd_get_multi_block_sec(uint16_t first_block_number,
   UINT8_TO_STREAM(p, flags);
 
   /* Command Code */
-  UINT8_TO_STREAM(p, I93_CMD_GET_MULTI_BLK_SEC);
+  if (rw_cb.tcb.i93.intl_flags & RW_I93_FLAG_EXT_COMMANDS) {
+    UINT8_TO_STREAM(p, I93_CMD_EXT_GET_MULTI_BLK_SEC);
+  } else {
+    UINT8_TO_STREAM(p, I93_CMD_GET_MULTI_BLK_SEC);
+  }
 
   /* Parameters */
   ARRAY8_TO_STREAM(p, rw_cb.tcb.i93.uid); /* UID */
 
-  if (rw_cb.tcb.i93.intl_flags & RW_I93_FLAG_16BIT_NUM_BLOCK) {
+  if (rw_cb.tcb.i93.intl_flags & RW_I93_FLAG_16BIT_NUM_BLOCK ||
+     rw_cb.tcb.i93.intl_flags & RW_I93_FLAG_EXT_COMMANDS) {
     UINT16_TO_STREAM(p, first_block_number); /* First block number */
     UINT16_TO_STREAM(
         p, number_blocks - 1); /* Number of blocks, 0x00 to read one block */
@@ -1292,7 +1507,10 @@ tNFC_STATUS rw_i93_send_cmd_get_multi_block_sec(uint16_t first_block_number,
   }
 
   if (rw_i93_send_to_lower(p_cmd)) {
-    rw_cb.tcb.i93.sent_cmd = I93_CMD_GET_MULTI_BLK_SEC;
+    if (rw_cb.tcb.i93.intl_flags & RW_I93_FLAG_EXT_COMMANDS)
+      rw_cb.tcb.i93.sent_cmd = I93_CMD_EXT_GET_MULTI_BLK_SEC;
+    else
+      rw_cb.tcb.i93.sent_cmd = I93_CMD_GET_MULTI_BLK_SEC;
     return NFC_STATUS_OK;
   } else {
     return NFC_STATUS_FAILED;
@@ -1314,7 +1532,7 @@ tNFC_STATUS rw_i93_get_next_blocks(uint16_t offset) {
   uint16_t first_block;
   uint16_t num_block;
 
-  RW_TRACE_DEBUG0("rw_i93_get_next_blocks ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_i93_get_next_blocks ()");
 
   first_block = offset / p_i93->block_size;
 
@@ -1368,10 +1586,10 @@ tNFC_STATUS rw_i93_get_next_block_sec(void) {
   tRW_I93_CB* p_i93 = &rw_cb.tcb.i93;
   uint16_t num_blocks;
 
-  RW_TRACE_DEBUG0("rw_i93_get_next_block_sec ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_i93_get_next_block_sec ()");
 
   if (p_i93->num_block <= p_i93->rw_offset) {
-    RW_TRACE_ERROR2("rw_offset(0x%x) must be less than num_block(0x%x)",
+    LOG(ERROR) << StringPrintf("rw_offset(0x%x) must be less than num_block(0x%x)",
                     p_i93->rw_offset, p_i93->num_block);
     return NFC_STATUS_FAILED;
   }
@@ -1381,6 +1599,8 @@ tNFC_STATUS rw_i93_get_next_block_sec(void) {
   if (num_blocks > RW_I93_GET_MULTI_BLOCK_SEC_SIZE)
     num_blocks = RW_I93_GET_MULTI_BLOCK_SEC_SIZE;
 
+  DLOG_IF(INFO, nfc_debug_enabled)
+      << __func__ << std::hex << rw_cb.tcb.i93.intl_flags;
   return rw_i93_send_cmd_get_multi_block_sec(p_i93->rw_offset, num_blocks);
 }
 
@@ -1408,13 +1628,9 @@ void rw_i93_sm_detect_ndef(NFC_HDR* p_resp) {
   tRW_DATA rw_data;
   tNFC_STATUS status = NFC_STATUS_FAILED;
 
-#if (BT_TRACE_VERBOSE == true)
-  RW_TRACE_DEBUG2("rw_i93_sm_detect_ndef () sub_state:%s (0x%x)",
-                  rw_i93_get_sub_state_name(p_i93->sub_state),
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_i93_sm_detect_ndef () sub_state:%s (0x%x)",
+                  rw_i93_get_sub_state_name(p_i93->sub_state).c_str(),
                   p_i93->sub_state);
-#else
-  RW_TRACE_DEBUG1("rw_i93_sm_detect_ndef () sub_state:0x%x", p_i93->sub_state);
-#endif
 
   STREAM_TO_UINT8(flags, p);
   length--;
@@ -1425,7 +1641,7 @@ void rw_i93_sm_detect_ndef(NFC_HDR* p_resp) {
       /* This STM tag supports more than 2040 bytes */
       p_i93->intl_flags |= RW_I93_FLAG_16BIT_NUM_BLOCK;
     } else {
-      RW_TRACE_DEBUG1("Got error flags (0x%02x)", flags);
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Got error flags (0x%02x)", flags);
       rw_i93_handle_error(NFC_STATUS_FAILED);
     }
     return;
@@ -1440,7 +1656,7 @@ void rw_i93_sm_detect_ndef(NFC_HDR* p_resp) {
 
       if (u8 != I93_DFS_UNSUPPORTED) {
         /* if Data Storage Format is unknown */
-        RW_TRACE_DEBUG1("Got unknown DSFID (0x%02x)", u8);
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Got unknown DSFID (0x%02x)", u8);
         rw_i93_handle_error(NFC_STATUS_FAILED);
       } else {
         /* get system information to get memory size */
@@ -1464,7 +1680,7 @@ void rw_i93_sm_detect_ndef(NFC_HDR* p_resp) {
       }
 
       if ((p_i93->block_size == 0) || (p_i93->num_block == 0)) {
-        RW_TRACE_DEBUG0("Unable to get tag memory size");
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Unable to get tag memory size");
         rw_i93_handle_error(status);
       } else {
         /* read CC in the first block */
@@ -1500,16 +1716,15 @@ void rw_i93_sm_detect_ndef(NFC_HDR* p_resp) {
       **       : Bit 2:More than 2040 bytes are supported [STM]
       */
 
-      RW_TRACE_DEBUG4(
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "rw_i93_sm_detect_ndef (): cc: 0x%02X 0x%02X 0x%02X 0x%02X", cc[0],
           cc[1], cc[2], cc[3]);
-      RW_TRACE_DEBUG2(
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "rw_i93_sm_detect_ndef (): Total blocks:0x%04X, Block size:0x%02X",
           p_i93->num_block, p_i93->block_size);
 
-      if ((cc[0] == I93_ICODE_CC_MAGIC_NUMER) &&
-          ((cc[3] & I93_STM_CC_OVERFLOW_MASK) ||
-           (cc[2] * 8) == (p_i93->num_block * p_i93->block_size))) {
+      if ((cc[0] == I93_ICODE_CC_MAGIC_NUMER_E1) ||
+          (cc[0] == I93_ICODE_CC_MAGIC_NUMER_E2)) {
         if ((cc[1] & I93_ICODE_CC_READ_ACCESS_MASK) ==
             I93_ICODE_CC_READ_ACCESS_GRANTED) {
           if ((cc[1] & I93_ICODE_CC_WRITE_ACCESS_MASK) !=
@@ -1521,6 +1736,9 @@ void rw_i93_sm_detect_ndef(NFC_HDR* p_resp) {
             /* tag supports read multi blocks command */
             p_i93->intl_flags |= RW_I93_FLAG_READ_MULTI_BLOCK;
           }
+          if (cc[0] == I93_ICODE_CC_MAGIC_NUMER_E2) {
+            p_i93->intl_flags |= RW_I93_FLAG_EXT_COMMANDS;
+          }
           status = NFC_STATUS_OK;
         }
       }
@@ -1564,7 +1782,7 @@ void rw_i93_sm_detect_ndef(NFC_HDR* p_resp) {
             p_i93->tlv_type = I93_ICODE_TLV_TYPE_TERM;
             break;
           } else {
-            RW_TRACE_DEBUG1("Invalid type: 0x%02x", *(p + xx));
+           DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Invalid type: 0x%02x", *(p + xx));
             rw_i93_handle_error(NFC_STATUS_FAILED);
             return;
           }
@@ -1743,7 +1961,7 @@ void rw_i93_sm_detect_ndef(NFC_HDR* p_resp) {
       }
 
       rw_data.ndef.status = NFC_STATUS_OK;
-      rw_data.ndef.protocol = NFC_PROTOCOL_15693;
+      rw_data.ndef.protocol = NFC_PROTOCOL_T5T;
       rw_data.ndef.flags = 0;
       rw_data.ndef.flags |= RW_NDEF_FL_SUPPORTED;
       rw_data.ndef.flags |= RW_NDEF_FL_FORMATED;
@@ -1761,7 +1979,7 @@ void rw_i93_sm_detect_ndef(NFC_HDR* p_resp) {
       p_i93->state = RW_I93_STATE_IDLE;
       p_i93->sent_cmd = 0;
 
-      RW_TRACE_DEBUG3("NDEF cur_size(%d),max_size (%d), flags (0x%x)",
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NDEF cur_size(%d),max_size (%d), flags (0x%x)",
                       rw_data.ndef.cur_size, rw_data.ndef.max_size,
                       rw_data.ndef.flags);
 
@@ -1796,10 +2014,10 @@ void rw_i93_sm_read_ndef(NFC_HDR* p_resp) {
   tRW_I93_CB* p_i93 = &rw_cb.tcb.i93;
   tRW_DATA rw_data;
 
-  RW_TRACE_DEBUG0("rw_i93_sm_read_ndef ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_i93_sm_read_ndef ()");
 
   if (NULL == p_resp) {
-    RW_TRACE_DEBUG0("rw_i93_sm_read_ndef: p_resp is NULL");
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_i93_sm_read_ndef: p_resp is NULL");
     return;
   }
 #if (NXP_EXTNS == TRUE)
@@ -1810,7 +2028,7 @@ void rw_i93_sm_read_ndef(NFC_HDR* p_resp) {
   length--;
 
   if (flags & I93_FLAG_ERROR_DETECTED) {
-    RW_TRACE_DEBUG1("Got error flags (0x%02x)", flags);
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Got error flags (0x%02x)", flags);
     rw_i93_handle_error(NFC_STATUS_FAILED);
     return;
   }
@@ -1856,12 +2074,12 @@ void rw_i93_sm_read_ndef(NFC_HDR* p_resp) {
     p_i93->state = RW_I93_STATE_IDLE;
     p_i93->sent_cmd = 0;
 
-    RW_TRACE_DEBUG2("NDEF read complete read (%d)/total (%d)", p_resp->len,
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NDEF read complete read (%d)/total (%d)", p_resp->len,
                     p_i93->ndef_length);
 
     (*(rw_cb.p_cback))(RW_I93_NDEF_READ_CPLT_EVT, &rw_data);
   } else {
-    RW_TRACE_DEBUG2("NDEF read segment read (%d)/total (%d)", p_resp->len,
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NDEF read segment read (%d)/total (%d)", p_resp->len,
                     p_i93->ndef_length);
 
     if (p_resp->len > 0) {
@@ -1897,13 +2115,9 @@ void rw_i93_sm_update_ndef(NFC_HDR* p_resp) {
   tRW_I93_CB* p_i93 = &rw_cb.tcb.i93;
   tRW_DATA rw_data;
 
-#if (BT_TRACE_VERBOSE == true)
-  RW_TRACE_DEBUG2("rw_i93_sm_update_ndef () sub_state:%s (0x%x)",
-                  rw_i93_get_sub_state_name(p_i93->sub_state),
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_i93_sm_update_ndef () sub_state:%s (0x%x)",
+                  rw_i93_get_sub_state_name(p_i93->sub_state).c_str(),
                   p_i93->sub_state);
-#else
-  RW_TRACE_DEBUG1("rw_i93_sm_update_ndef () sub_state:0x%x", p_i93->sub_state);
-#endif
 
   STREAM_TO_UINT8(flags, p);
   length--;
@@ -1916,7 +2130,7 @@ void rw_i93_sm_update_ndef(NFC_HDR* p_resp) {
         (*p == I93_ERROR_CODE_BLOCK_FAIL_TO_WRITE)) {
       /* ignore error */
     } else {
-      RW_TRACE_DEBUG1("Got error flags (0x%02x)", flags);
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Got error flags (0x%02x)", flags);
       rw_i93_handle_error(NFC_STATUS_FAILED);
       return;
     }
@@ -2110,7 +2324,7 @@ void rw_i93_sm_update_ndef(NFC_HDR* p_resp) {
           }
         }
       } else {
-        RW_TRACE_DEBUG3("NDEF update complete, %d bytes, (%d-%d)",
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("NDEF update complete, %d bytes, (%d-%d)",
                         p_i93->ndef_length, p_i93->ndef_tlv_start_offset,
                         p_i93->ndef_tlv_last_offset);
 
@@ -2150,13 +2364,9 @@ void rw_i93_sm_format(NFC_HDR* p_resp) {
   tRW_DATA rw_data;
   tNFC_STATUS status = NFC_STATUS_FAILED;
 
-#if (BT_TRACE_VERBOSE == true)
-  RW_TRACE_DEBUG2("rw_i93_sm_format () sub_state:%s (0x%x)",
-                  rw_i93_get_sub_state_name(p_i93->sub_state),
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_i93_sm_format () sub_state:%s (0x%x)",
+                  rw_i93_get_sub_state_name(p_i93->sub_state).c_str(),
                   p_i93->sub_state);
-#else
-  RW_TRACE_DEBUG1("rw_i93_sm_format () sub_state:0x%x", p_i93->sub_state);
-#endif
 
   STREAM_TO_UINT8(flags, p);
   length--;
@@ -2174,7 +2384,7 @@ void rw_i93_sm_format(NFC_HDR* p_resp) {
       p_i93->intl_flags |= RW_I93_FLAG_16BIT_NUM_BLOCK;
       return;
     } else {
-      RW_TRACE_DEBUG1("Got error flags (0x%02x)", flags);
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Got error flags (0x%02x)", flags);
       rw_i93_handle_error(NFC_STATUS_FAILED);
       return;
     }
@@ -2220,7 +2430,7 @@ void rw_i93_sm_format(NFC_HDR* p_resp) {
       }
 
       if ((p_i93->block_size == 0) || (p_i93->num_block == 0)) {
-        RW_TRACE_DEBUG0("Unable to get tag memory size");
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Unable to get tag memory size");
         rw_i93_handle_error(status);
       } else if (p_i93->intl_flags & RW_I93_FLAG_RESET_DSFID) {
         if (rw_i93_send_cmd_write_dsfid(I93_DFS_UNSUPPORTED) == NFC_STATUS_OK) {
@@ -2366,7 +2576,7 @@ void rw_i93_sm_format(NFC_HDR* p_resp) {
       p_i93->p_update_data = (uint8_t*)GKI_getbuf(RW_I93_FORMAT_DATA_LEN);
 
       if (!p_i93->p_update_data) {
-        RW_TRACE_ERROR0("rw_i93_sm_format (): Cannot allocate buffer");
+        LOG(ERROR) << StringPrintf("rw_i93_sm_format (): Cannot allocate buffer");
         rw_i93_handle_error(NFC_STATUS_FAILED);
         break;
       }
@@ -2374,7 +2584,7 @@ void rw_i93_sm_format(NFC_HDR* p_resp) {
       p = p_i93->p_update_data;
 
       /* Capability Container */
-      *(p++) = I93_ICODE_CC_MAGIC_NUMER; /* magic number */
+      *(p++) = I93_ICODE_CC_MAGIC_NUMER_E1; /* magic number */
       *(p++) = 0x40;                     /* version 1.0, read/write */
 
       /* if memory size is less than 2048 bytes */
@@ -2482,14 +2692,9 @@ void rw_i93_sm_set_read_only(NFC_HDR* p_resp) {
   tRW_I93_CB* p_i93 = &rw_cb.tcb.i93;
   tRW_DATA rw_data;
 
-#if (BT_TRACE_VERBOSE == true)
-  RW_TRACE_DEBUG2("rw_i93_sm_set_read_only () sub_state:%s (0x%x)",
-                  rw_i93_get_sub_state_name(p_i93->sub_state),
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_i93_sm_set_read_only () sub_state:%s (0x%x)",
+                  rw_i93_get_sub_state_name(p_i93->sub_state).c_str(),
                   p_i93->sub_state);
-#else
-  RW_TRACE_DEBUG1("rw_i93_sm_set_read_only () sub_state:0x%x",
-                  p_i93->sub_state);
-#endif
 
   STREAM_TO_UINT8(flags, p);
   length--;
@@ -2502,7 +2707,7 @@ void rw_i93_sm_set_read_only(NFC_HDR* p_resp) {
         (*p == I93_ERROR_CODE_BLOCK_FAIL_TO_WRITE)) {
       /* ignore error */
     } else {
-      RW_TRACE_DEBUG1("Got error flags (0x%02x)", flags);
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Got error flags (0x%02x)", flags);
       rw_i93_handle_error(NFC_STATUS_FAILED);
       return;
     }
@@ -2595,7 +2800,7 @@ void rw_i93_handle_error(tNFC_STATUS status) {
   tRW_DATA rw_data;
   tRW_EVENT event;
 
-  RW_TRACE_DEBUG2("rw_i93_handle_error (): status:0x%02X, state:0x%X", status,
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_i93_handle_error (): status:0x%02X, state:0x%X", status,
                   p_i93->state);
 
   nfc_stop_quick_timer(&p_i93->timer);
@@ -2621,7 +2826,7 @@ void rw_i93_handle_error(tNFC_STATUS status) {
         break;
 
       case RW_I93_STATE_DETECT_NDEF:
-        rw_data.ndef.protocol = NFC_PROTOCOL_15693;
+        rw_data.ndef.protocol = NFC_PROTOCOL_T5T;
         rw_data.ndef.cur_size = 0;
         rw_data.ndef.max_size = 0;
         rw_data.ndef.flags = 0;
@@ -2683,14 +2888,14 @@ void rw_i93_handle_error(tNFC_STATUS status) {
 void rw_i93_process_timeout(TIMER_LIST_ENT* p_tle) {
   NFC_HDR* p_buf;
 
-  RW_TRACE_DEBUG1("rw_i93_process_timeout () event=%d", p_tle->event);
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_i93_process_timeout () event=%d", p_tle->event);
 
   if (p_tle->event == NFC_TTYPE_RW_I93_RESPONSE) {
     if ((rw_cb.tcb.i93.retry_count < RW_MAX_RETRIES) &&
         (rw_cb.tcb.i93.p_retry_cmd) &&
         (rw_cb.tcb.i93.sent_cmd != I93_CMD_STAY_QUIET)) {
       rw_cb.tcb.i93.retry_count++;
-      RW_TRACE_ERROR1("rw_i93_process_timeout (): retry_count = %d",
+      LOG(ERROR) << StringPrintf("rw_i93_process_timeout (): retry_count = %d",
                       rw_cb.tcb.i93.retry_count);
 
       p_buf = rw_cb.tcb.i93.p_retry_cmd;
@@ -2709,7 +2914,7 @@ void rw_i93_process_timeout(TIMER_LIST_ENT* p_tle) {
     }
     rw_i93_handle_error(NFC_STATUS_TIMEOUT);
   } else {
-    RW_TRACE_ERROR1("rw_i93_process_timeout () unknown event=%d", p_tle->event);
+    LOG(ERROR) << StringPrintf("rw_i93_process_timeout () unknown event=%d", p_tle->event);
   }
 }
 
@@ -2722,46 +2927,39 @@ void rw_i93_process_timeout(TIMER_LIST_ENT* p_tle) {
 ** Returns          none
 **
 *******************************************************************************/
-static void rw_i93_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
-                              tNFC_CONN* p_data) {
+static void rw_i93_data_cback(__attribute__((unused)) uint8_t conn_id,
+                              tNFC_CONN_EVT event, tNFC_CONN* p_data) {
   tRW_I93_CB* p_i93 = &rw_cb.tcb.i93;
   NFC_HDR* p_resp;
   tRW_DATA rw_data;
 
-#if (BT_TRACE_VERBOSE == true)
   uint8_t begin_state = p_i93->state;
-#endif
-  (void)conn_id;
 
   if(p_data == NULL) {
-       RW_TRACE_ERROR0 ("rw_i93_data_cback (): p_data is NULL");
+       LOG(ERROR) << StringPrintf("rw_i93_data_cback (): p_data is NULL");
        return;
     }
 
-  RW_TRACE_DEBUG2 ("rw_i93_data_cback () event = 0x%X 0x%X", event, p_data->status);
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_i93_data_cback () event = 0x%X 0x%X", event, p_data->status);
 
-  if ((event == NFC_DEACTIVATE_CEVT) || (event == NFC_ERROR_CEVT)
-#if (NXP_EXTNS == TRUE)
-          || ((event == NFC_DATA_CEVT)&&(p_data->status != NFC_STATUS_OK))
-#endif
-    )
-  {
+  if ((event == NFC_DEACTIVATE_CEVT) || (event == NFC_ERROR_CEVT) ||
+      ((event == NFC_DATA_CEVT) && (p_data->status != NFC_STATUS_OK))) {
     nfc_stop_quick_timer(&p_i93->timer);
-#if(NXP_EXTNS == TRUE)
-        if ((event == NFC_ERROR_CEVT) || (p_data->status != NFC_STATUS_OK))
-#else
-    if (event == NFC_ERROR_CEVT)
-#endif
-    {
+
+    if (event == NFC_ERROR_CEVT || (p_data->status != NFC_STATUS_OK)) {
       if ((p_i93->retry_count < RW_MAX_RETRIES) && (p_i93->p_retry_cmd)) {
         p_i93->retry_count++;
 
-        RW_TRACE_ERROR1("rw_i93_data_cback (): retry_count = %d",
+        LOG(ERROR) << StringPrintf("rw_i93_data_cback (): retry_count = %d",
                         p_i93->retry_count);
 
         p_resp = p_i93->p_retry_cmd;
         p_i93->p_retry_cmd = NULL;
         if (rw_i93_send_to_lower(p_resp)) {
+          if (event == NFC_DATA_CEVT) {
+            p_resp = (NFC_HDR*)p_data->data.p_data;
+            GKI_freebuf(p_resp);
+          }
           return;
         }
       }
@@ -2774,6 +2972,10 @@ static void rw_i93_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
       }
 
       rw_i93_handle_error((tNFC_STATUS)(*(uint8_t*)p_data));
+      if (event == NFC_DATA_CEVT) {
+        p_resp = (NFC_HDR*)p_data->data.p_data;
+        GKI_freebuf(p_resp);
+      }
     } else {
       /* free retry buffer */
       if (p_i93->p_retry_cmd) {
@@ -2802,16 +3004,8 @@ static void rw_i93_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
     p_i93->retry_count = 0;
   }
 
-#if (BT_TRACE_PROTOCOL == true)
-  DispRWI93Tag(p_resp, true, p_i93->sent_cmd);
-#endif
-
-#if (BT_TRACE_VERBOSE == true)
-  RW_TRACE_DEBUG2("RW I93 state: <%s (%d)>",
-                  rw_i93_get_state_name(p_i93->state), p_i93->state);
-#else
-  RW_TRACE_DEBUG1("RW I93 state: %d", p_i93->state);
-#endif
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW I93 state: <%s (%d)>",
+                  rw_i93_get_state_name(p_i93->state).c_str(), p_i93->state);
 
   switch (p_i93->state) {
     case RW_I93_STATE_IDLE:
@@ -2869,25 +3063,23 @@ static void rw_i93_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
       break;
 
     default:
-      RW_TRACE_ERROR1("rw_i93_data_cback (): invalid state=%d", p_i93->state);
+      LOG(ERROR) << StringPrintf("rw_i93_data_cback (): invalid state=%d", p_i93->state);
       GKI_freebuf(p_resp);
       break;
   }
 
-#if (BT_TRACE_VERBOSE == true)
   if (begin_state != p_i93->state) {
-    RW_TRACE_DEBUG2("RW I93 state changed:<%s> -> <%s>",
-                    rw_i93_get_state_name(begin_state),
-                    rw_i93_get_state_name(p_i93->state));
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW I93 state changed:<%s> -> <%s>",
+                    rw_i93_get_state_name(begin_state).c_str(),
+                    rw_i93_get_state_name(p_i93->state).c_str());
   }
-#endif
 }
 
 /*******************************************************************************
 **
 ** Function         rw_i93_select
 **
-** Description      Initialise ISO 15693 RW
+** Description      Initialise ISO 15693 / T5T RW
 **
 ** Returns          NFC_STATUS_OK if success
 **
@@ -2896,7 +3088,7 @@ tNFC_STATUS rw_i93_select(uint8_t* p_uid) {
   tRW_I93_CB* p_i93 = &rw_cb.tcb.i93;
   uint8_t uid[I93_UID_BYTE_LEN], *p;
 
-  RW_TRACE_DEBUG0("rw_i93_select ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_i93_select ()");
 
   NFC_SetStaticRfCback(rw_i93_data_cback);
 
@@ -2929,11 +3121,11 @@ tNFC_STATUS rw_i93_select(uint8_t* p_uid) {
 tNFC_STATUS RW_I93Inventory(bool including_afi, uint8_t afi, uint8_t* p_uid) {
   tNFC_STATUS status;
 
-  RW_TRACE_API2("RW_I93Inventory (), including_afi:%d, AFI:0x%02X",
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_I93Inventory (), including_afi:%d, AFI:0x%02X",
                 including_afi, afi);
 
   if (rw_cb.tcb.i93.state != RW_I93_STATE_IDLE) {
-    RW_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "RW_I93Inventory ():Unable to start command at state (0x%X)",
         rw_cb.tcb.i93.state);
     return NFC_STATUS_BUSY;
@@ -2965,10 +3157,10 @@ tNFC_STATUS RW_I93Inventory(bool including_afi, uint8_t afi, uint8_t* p_uid) {
 tNFC_STATUS RW_I93StayQuiet(void) {
   tNFC_STATUS status;
 
-  RW_TRACE_API0("RW_I93StayQuiet ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_I93StayQuiet ()");
 
   if (rw_cb.tcb.i93.state != RW_I93_STATE_IDLE) {
-    RW_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "RW_I93StayQuiet ():Unable to start command at state (0x%X)",
         rw_cb.tcb.i93.state);
     return NFC_STATUS_BUSY;
@@ -2999,10 +3191,10 @@ tNFC_STATUS RW_I93StayQuiet(void) {
 tNFC_STATUS RW_I93ReadSingleBlock(uint16_t block_number) {
   tNFC_STATUS status;
 
-  RW_TRACE_API1("RW_I93ReadSingleBlock () block_number:0x%02X", block_number);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_I93ReadSingleBlock () block_number:0x%02X", block_number);
 
   if (rw_cb.tcb.i93.state != RW_I93_STATE_IDLE) {
-    RW_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "RW_I93ReadSingleBlock ():Unable to start command at state (0x%X)",
         rw_cb.tcb.i93.state);
     return NFC_STATUS_BUSY;
@@ -3035,17 +3227,17 @@ tNFC_STATUS RW_I93ReadSingleBlock(uint16_t block_number) {
 tNFC_STATUS RW_I93WriteSingleBlock(uint16_t block_number, uint8_t* p_data) {
   tNFC_STATUS status;
 
-  RW_TRACE_API0("RW_I93WriteSingleBlock ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_I93WriteSingleBlock ()");
 
   if (rw_cb.tcb.i93.state != RW_I93_STATE_IDLE) {
-    RW_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "RW_I93WriteSingleBlock ():Unable to start command at state (0x%X)",
         rw_cb.tcb.i93.state);
     return NFC_STATUS_BUSY;
   }
 
   if (rw_cb.tcb.i93.block_size == 0) {
-    RW_TRACE_ERROR0("RW_I93WriteSingleBlock ():Block size is unknown");
+    LOG(ERROR) << StringPrintf("RW_I93WriteSingleBlock ():Block size is unknown");
     return NFC_STATUS_FAILED;
   }
 
@@ -3074,10 +3266,10 @@ tNFC_STATUS RW_I93WriteSingleBlock(uint16_t block_number, uint8_t* p_data) {
 tNFC_STATUS RW_I93LockBlock(uint8_t block_number) {
   tNFC_STATUS status;
 
-  RW_TRACE_API0("RW_I93LockBlock ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_I93LockBlock ()");
 
   if (rw_cb.tcb.i93.state != RW_I93_STATE_IDLE) {
-    RW_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "RW_I93LockBlock ():Unable to start command at state (0x%X)",
         rw_cb.tcb.i93.state);
     return NFC_STATUS_BUSY;
@@ -3109,10 +3301,10 @@ tNFC_STATUS RW_I93ReadMultipleBlocks(uint16_t first_block_number,
                                      uint16_t number_blocks) {
   tNFC_STATUS status;
 
-  RW_TRACE_API0("RW_I93ReadMultipleBlocks ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_I93ReadMultipleBlocks ()");
 
   if (rw_cb.tcb.i93.state != RW_I93_STATE_IDLE) {
-    RW_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "RW_I93ReadMultipleBlocks ():Unable to start command at state (0x%X)",
         rw_cb.tcb.i93.state);
     return NFC_STATUS_BUSY;
@@ -3140,21 +3332,21 @@ tNFC_STATUS RW_I93ReadMultipleBlocks(uint16_t first_block_number,
 **                  NFC_STATUS_FAILED if other error
 **
 *******************************************************************************/
-tNFC_STATUS RW_I93WriteMultipleBlocks(uint8_t first_block_number,
+tNFC_STATUS RW_I93WriteMultipleBlocks(uint16_t first_block_number,
                                       uint16_t number_blocks, uint8_t* p_data) {
   tNFC_STATUS status;
 
-  RW_TRACE_API0("RW_I93WriteMultipleBlocks ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_I93WriteMultipleBlocks ()");
 
   if (rw_cb.tcb.i93.state != RW_I93_STATE_IDLE) {
-    RW_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "RW_I93WriteMultipleBlocks ():Unable to start command at state (0x%X)",
         rw_cb.tcb.i93.state);
     return NFC_STATUS_BUSY;
   }
 
   if (rw_cb.tcb.i93.block_size == 0) {
-    RW_TRACE_ERROR0("RW_I93WriteSingleBlock ():Block size is unknown");
+    LOG(ERROR) << StringPrintf("RW_I93WriteSingleBlock ():Block size is unknown");
     return NFC_STATUS_FAILED;
   }
 
@@ -3189,10 +3381,10 @@ tNFC_STATUS RW_I93WriteMultipleBlocks(uint8_t first_block_number,
 tNFC_STATUS RW_I93Select(uint8_t* p_uid) {
   tNFC_STATUS status;
 
-  RW_TRACE_API0("RW_I93Select ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_I93Select ()");
 
   if (rw_cb.tcb.i93.state != RW_I93_STATE_IDLE) {
-    RW_TRACE_ERROR1("RW_I93Select ():Unable to start command at state (0x%X)",
+    LOG(ERROR) << StringPrintf("RW_I93Select ():Unable to start command at state (0x%X)",
                     rw_cb.tcb.i93.state);
     return NFC_STATUS_BUSY;
   }
@@ -3203,7 +3395,7 @@ tNFC_STATUS RW_I93Select(uint8_t* p_uid) {
       rw_cb.tcb.i93.state = RW_I93_STATE_BUSY;
     }
   } else {
-    RW_TRACE_ERROR0("RW_I93Select ():UID shall be provided");
+    LOG(ERROR) << StringPrintf("RW_I93Select ():UID shall be provided");
     status = NFC_STATUS_FAILED;
   }
 
@@ -3227,10 +3419,10 @@ tNFC_STATUS RW_I93Select(uint8_t* p_uid) {
 tNFC_STATUS RW_I93ResetToReady(void) {
   tNFC_STATUS status;
 
-  RW_TRACE_API0("RW_I93ResetToReady ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_I93ResetToReady ()");
 
   if (rw_cb.tcb.i93.state != RW_I93_STATE_IDLE) {
-    RW_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "RW_I93ResetToReady ():Unable to start command at state (0x%X)",
         rw_cb.tcb.i93.state);
     return NFC_STATUS_BUSY;
@@ -3261,10 +3453,10 @@ tNFC_STATUS RW_I93ResetToReady(void) {
 tNFC_STATUS RW_I93WriteAFI(uint8_t afi) {
   tNFC_STATUS status;
 
-  RW_TRACE_API0("RW_I93WriteAFI ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_I93WriteAFI ()");
 
   if (rw_cb.tcb.i93.state != RW_I93_STATE_IDLE) {
-    RW_TRACE_ERROR1("RW_I93WriteAFI ():Unable to start command at state (0x%X)",
+    LOG(ERROR) << StringPrintf("RW_I93WriteAFI ():Unable to start command at state (0x%X)",
                     rw_cb.tcb.i93.state);
     return NFC_STATUS_BUSY;
   }
@@ -3294,10 +3486,10 @@ tNFC_STATUS RW_I93WriteAFI(uint8_t afi) {
 tNFC_STATUS RW_I93LockAFI(void) {
   tNFC_STATUS status;
 
-  RW_TRACE_API0("RW_I93LockAFI ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_I93LockAFI ()");
 
   if (rw_cb.tcb.i93.state != RW_I93_STATE_IDLE) {
-    RW_TRACE_ERROR1("RW_I93LockAFI ():Unable to start command at state (0x%X)",
+    LOG(ERROR) << StringPrintf("RW_I93LockAFI ():Unable to start command at state (0x%X)",
                     rw_cb.tcb.i93.state);
     return NFC_STATUS_BUSY;
   }
@@ -3327,10 +3519,10 @@ tNFC_STATUS RW_I93LockAFI(void) {
 tNFC_STATUS RW_I93WriteDSFID(uint8_t dsfid) {
   tNFC_STATUS status;
 
-  RW_TRACE_API0("RW_I93WriteDSFID ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_I93WriteDSFID ()");
 
   if (rw_cb.tcb.i93.state != RW_I93_STATE_IDLE) {
-    RW_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "RW_I93WriteDSFID ():Unable to start command at state (0x%X)",
         rw_cb.tcb.i93.state);
     return NFC_STATUS_BUSY;
@@ -3361,10 +3553,10 @@ tNFC_STATUS RW_I93WriteDSFID(uint8_t dsfid) {
 tNFC_STATUS RW_I93LockDSFID(void) {
   tNFC_STATUS status;
 
-  RW_TRACE_API0("RW_I93LockDSFID ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_I93LockDSFID ()");
 
   if (rw_cb.tcb.i93.state != RW_I93_STATE_IDLE) {
-    RW_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "RW_I93LockDSFID ():Unable to start command at state (0x%X)",
         rw_cb.tcb.i93.state);
     return NFC_STATUS_BUSY;
@@ -3395,10 +3587,10 @@ tNFC_STATUS RW_I93LockDSFID(void) {
 tNFC_STATUS RW_I93GetSysInfo(uint8_t* p_uid) {
   tNFC_STATUS status;
 
-  RW_TRACE_API0("RW_I93GetSysInfo ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_I93GetSysInfo ()");
 
   if (rw_cb.tcb.i93.state != RW_I93_STATE_IDLE) {
-    RW_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "RW_I93GetSysInfo ():Unable to start command at state (0x%X)",
         rw_cb.tcb.i93.state);
     return NFC_STATUS_BUSY;
@@ -3436,10 +3628,10 @@ tNFC_STATUS RW_I93GetMultiBlockSecurityStatus(uint16_t first_block_number,
                                               uint16_t number_blocks) {
   tNFC_STATUS status;
 
-  RW_TRACE_API0("RW_I93GetMultiBlockSecurityStatus ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_I93GetMultiBlockSecurityStatus ()");
 
   if (rw_cb.tcb.i93.state != RW_I93_STATE_IDLE) {
-    RW_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "RW_I93GetMultiBlockSecurityStatus ():Unable to start command at state "
         "(0x%X)",
         rw_cb.tcb.i93.state);
@@ -3471,10 +3663,10 @@ tNFC_STATUS RW_I93DetectNDef(void) {
   tNFC_STATUS status;
   tRW_I93_RW_SUBSTATE sub_state;
 
-  RW_TRACE_API0("RW_I93DetectNDef ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_I93DetectNDef ()");
 
   if (rw_cb.tcb.i93.state != RW_I93_STATE_IDLE) {
-    RW_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "RW_I93DetectNDef ():Unable to start command at state (0x%X)",
         rw_cb.tcb.i93.state);
     return NFC_STATUS_FAILED;
@@ -3526,10 +3718,10 @@ tNFC_STATUS RW_I93DetectNDef(void) {
 **
 *******************************************************************************/
 tNFC_STATUS RW_I93ReadNDef(void) {
-  RW_TRACE_API0("RW_I93ReadNDef ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_I93ReadNDef ()");
 
   if (rw_cb.tcb.i93.state != RW_I93_STATE_IDLE) {
-    RW_TRACE_ERROR1("RW_I93ReadNDef ():Unable to start command at state (0x%X)",
+    LOG(ERROR) << StringPrintf("RW_I93ReadNDef ():Unable to start command at state (0x%X)",
                     rw_cb.tcb.i93.state);
     return NFC_STATUS_FAILED;
   }
@@ -3545,7 +3737,7 @@ tNFC_STATUS RW_I93ReadNDef(void) {
       return NFC_STATUS_FAILED;
     }
   } else {
-    RW_TRACE_ERROR0("RW_I93ReadNDef ():No NDEF detected");
+    LOG(ERROR) << StringPrintf("RW_I93ReadNDef ():No NDEF detected");
     return NFC_STATUS_FAILED;
   }
 
@@ -3572,10 +3764,10 @@ tNFC_STATUS RW_I93ReadNDef(void) {
 tNFC_STATUS RW_I93UpdateNDef(uint16_t length, uint8_t* p_data) {
   uint16_t block_number;
 
-  RW_TRACE_API1("RW_I93UpdateNDef () length:%d", length);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_I93UpdateNDef () length:%d", length);
 
   if (rw_cb.tcb.i93.state != RW_I93_STATE_IDLE) {
-    RW_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "RW_I93UpdateNDef ():Unable to start command at state (0x%X)",
         rw_cb.tcb.i93.state);
     return NFC_STATUS_FAILED;
@@ -3583,11 +3775,11 @@ tNFC_STATUS RW_I93UpdateNDef(uint16_t length, uint8_t* p_data) {
 
   if (rw_cb.tcb.i93.tlv_type == I93_ICODE_TLV_TYPE_NDEF) {
     if (rw_cb.tcb.i93.intl_flags & RW_I93_FLAG_READ_ONLY) {
-      RW_TRACE_ERROR0("RW_I93UpdateNDef ():NDEF is read-only");
+      LOG(ERROR) << StringPrintf("RW_I93UpdateNDef ():NDEF is read-only");
       return NFC_STATUS_FAILED;
     }
     if (rw_cb.tcb.i93.max_ndef_length < length) {
-      RW_TRACE_ERROR2(
+      LOG(ERROR) << StringPrintf(
           "RW_I93UpdateNDef ():data (%d bytes) is more than max NDEF length "
           "(%d)",
           length, rw_cb.tcb.i93.max_ndef_length);
@@ -3611,7 +3803,7 @@ tNFC_STATUS RW_I93UpdateNDef(uint16_t length, uint8_t* p_data) {
       return NFC_STATUS_FAILED;
     }
   } else {
-    RW_TRACE_ERROR0("RW_I93ReadNDef ():No NDEF detected");
+    LOG(ERROR) << StringPrintf("RW_I93ReadNDef ():No NDEF detected");
     return NFC_STATUS_FAILED;
   }
 
@@ -3634,10 +3826,10 @@ tNFC_STATUS RW_I93FormatNDef(void) {
   tNFC_STATUS status;
   tRW_I93_RW_SUBSTATE sub_state;
 
-  RW_TRACE_API0("RW_I93FormatNDef ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_I93FormatNDef ()");
 
   if (rw_cb.tcb.i93.state != RW_I93_STATE_IDLE) {
-    RW_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "RW_I93FormatNDef ():Unable to start command at state (0x%X)",
         rw_cb.tcb.i93.state);
     return NFC_STATUS_FAILED;
@@ -3682,10 +3874,10 @@ tNFC_STATUS RW_I93FormatNDef(void) {
 **
 *******************************************************************************/
 tNFC_STATUS RW_I93SetTagReadOnly(void) {
-  RW_TRACE_API0("RW_I93SetTagReadOnly ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_I93SetTagReadOnly ()");
 
   if (rw_cb.tcb.i93.state != RW_I93_STATE_IDLE) {
-    RW_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "RW_I93SetTagReadOnly ():Unable to start command at state (0x%X)",
         rw_cb.tcb.i93.state);
     return NFC_STATUS_FAILED;
@@ -3693,7 +3885,7 @@ tNFC_STATUS RW_I93SetTagReadOnly(void) {
 
   if (rw_cb.tcb.i93.tlv_type == I93_ICODE_TLV_TYPE_NDEF) {
     if (rw_cb.tcb.i93.intl_flags & RW_I93_FLAG_READ_ONLY) {
-      RW_TRACE_ERROR0("RW_I93SetTagReadOnly ():NDEF is already read-only");
+      LOG(ERROR) << StringPrintf("RW_I93SetTagReadOnly ():NDEF is already read-only");
       return NFC_STATUS_FAILED;
     }
 
@@ -3705,7 +3897,7 @@ tNFC_STATUS RW_I93SetTagReadOnly(void) {
       return NFC_STATUS_FAILED;
     }
   } else {
-    RW_TRACE_ERROR0("RW_I93SetTagReadOnly ():No NDEF detected");
+    LOG(ERROR) << StringPrintf("RW_I93SetTagReadOnly ():No NDEF detected");
     return NFC_STATUS_FAILED;
   }
 
@@ -3731,7 +3923,7 @@ tNFC_STATUS RW_I93PresenceCheck(void) {
   tNFC_STATUS status;
   tRW_DATA evt_data;
 
-  RW_TRACE_API0("RW_I93PresenceCheck ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_I93PresenceCheck ()");
 
   if (!rw_cb.p_cback) {
     return NFC_STATUS_FAILED;
@@ -3756,7 +3948,6 @@ tNFC_STATUS RW_I93PresenceCheck(void) {
   return (status);
 }
 
-#if (BT_TRACE_VERBOSE == true)
 /*******************************************************************************
 **
 ** Function         rw_i93_get_state_name
@@ -3768,7 +3959,7 @@ tNFC_STATUS RW_I93PresenceCheck(void) {
 ** Returns          pointer to the name
 **
 *******************************************************************************/
-static char* rw_i93_get_state_name(uint8_t state) {
+static std::string rw_i93_get_state_name(uint8_t state) {
   switch (state) {
     case RW_I93_STATE_NOT_ACTIVATED:
       return ("NOT_ACTIVATED");
@@ -3806,7 +3997,7 @@ static char* rw_i93_get_state_name(uint8_t state) {
 ** Returns          pointer to the name
 **
 *******************************************************************************/
-static char* rw_i93_get_sub_state_name(uint8_t sub_state) {
+static std::string rw_i93_get_sub_state_name(uint8_t sub_state) {
   switch (sub_state) {
     case RW_I93_SUBSTATE_WAIT_UID:
       return ("WAIT_UID");
@@ -3852,7 +4043,7 @@ static char* rw_i93_get_sub_state_name(uint8_t sub_state) {
 ** Returns          pointer to the name
 **
 *******************************************************************************/
-static char* rw_i93_get_tag_name(uint8_t product_version) {
+static std::string rw_i93_get_tag_name(uint8_t product_version) {
   switch (product_version) {
     case RW_I93_ICODE_SLI:
       return ("SLI/SLIX");
@@ -3884,10 +4075,12 @@ static char* rw_i93_get_tag_name(uint8_t product_version) {
       return ("M24LR16E");
     case RW_I93_STM_M24LR64E_R:
       return ("M24LR64E");
+    case RW_I93_STM_ST25DV04K:
+      return "ST25DV04";
+    case RW_I93_STM_ST25DVHIK:
+      return "ST25DV";
     case RW_I93_UNKNOWN_PRODUCT:
     default:
       return ("UNKNOWN");
   }
-}
-
-#endif
+}
\ No newline at end of file
diff --git a/src/nfc/tags/rw_main.c b/src/nfc/tags/rw_main.cc
similarity index 87%
rename from src/nfc/tags/rw_main.c
rename to src/nfc/tags/rw_main.cc
index 0ffefce..520f92c 100644
--- a/src/nfc/tags/rw_main.c
+++ b/src/nfc/tags/rw_main.cc
@@ -19,7 +19,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -43,6 +43,10 @@
  *
 ******************************************************************************/
 #include <string.h>
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfc_target.h"
 #include "bt_types.h"
 
@@ -51,12 +55,15 @@
 #include "rw_api.h"
 #include "rw_int.h"
 
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+
 tRW_CB rw_cb;
 /*******************************************************************************
 *******************************************************************************/
 void rw_init(void) {
   memset(&rw_cb, 0, sizeof(tRW_CB));
-  rw_cb.trace_level = NFC_INITIAL_TRACE_LEVEL;
 }
 
 #if (RW_STATS_INCLUDED == true)
@@ -156,14 +163,14 @@ void rw_main_log_stats(void) {
   ticks = GKI_get_tick_count() - rw_cb.stats.start_tick;
   elapsed_ms = GKI_TICKS_TO_MS(ticks);
 
-  RW_TRACE_DEBUG5(
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "NFC tx stats: cmds:%i, retries:%i, aborted: %i, tx_errs: %i, bytes "
       "sent:%i",
       rw_cb.stats.num_ops, rw_cb.stats.num_retries, rw_cb.stats.num_fail,
       rw_cb.stats.num_trans_err, rw_cb.stats.bytes_sent);
-  RW_TRACE_DEBUG2("    rx stats: rx-crc errors %i, bytes received: %i",
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("    rx stats: rx-crc errors %i, bytes received: %i",
                   rw_cb.stats.num_crc, rw_cb.stats.bytes_received);
-  RW_TRACE_DEBUG1("    time activated %i ms", elapsed_ms);
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("    time activated %i ms", elapsed_ms);
 }
 #endif /* RW_STATS_INCLUDED */
 
@@ -190,7 +197,7 @@ tNFC_STATUS RW_SendRawFrame(uint8_t* p_raw_data, uint16_t data_len) {
       memcpy(p, p_raw_data, data_len);
       p_data->len = data_len;
 
-      RW_TRACE_EVENT1("RW SENT raw frame (0x%x)", data_len);
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW SENT raw frame (0x%x)", data_len);
       status = NFC_SendData(NFC_RF_CONN_ID, p_data);
     }
   }
@@ -211,13 +218,13 @@ tNFC_STATUS RW_SetActivatedTagType(tNFC_ACTIVATE_DEVT* p_activate_params,
   tNFC_STATUS status = NFC_STATUS_FAILED;
 
   /* check for null cback here / remove checks from rw_t?t */
-  RW_TRACE_DEBUG3("RW_SetActivatedTagType protocol:%d, technology:%d, SAK:%d",
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_SetActivatedTagType protocol:%d, technology:%d, SAK:%d",
                   p_activate_params->protocol,
                   p_activate_params->rf_tech_param.mode,
                   p_activate_params->rf_tech_param.param.pa.sel_rsp);
 
   if (p_cback == NULL) {
-    RW_TRACE_ERROR0("RW_SetActivatedTagType called with NULL callback");
+    LOG(ERROR) << StringPrintf("RW_SetActivatedTagType called with NULL callback");
     return (NFC_STATUS_FAILED);
   }
 
@@ -262,33 +269,15 @@ tNFC_STATUS RW_SetActivatedTagType(tNFC_ACTIVATE_DEVT* p_activate_params,
         (p_activate_params->rf_tech_param.mode == NFC_DISCOVERY_TYPE_POLL_A)) {
       status = rw_t4t_select();
     }
-  } else if (NFC_PROTOCOL_15693 ==
-             p_activate_params->protocol) { /* ISO 15693 */
-    if (p_activate_params->rf_tech_param.mode ==
-        NFC_DISCOVERY_TYPE_POLL_ISO15693) {
+  } else if (NFC_PROTOCOL_T5T == p_activate_params->protocol) {
+    /* T5T */
+    if (p_activate_params->rf_tech_param.mode == NFC_DISCOVERY_TYPE_POLL_V) {
       status = rw_i93_select(p_activate_params->rf_tech_param.param.pi93.uid);
     }
   } else {
-    RW_TRACE_ERROR0("RW_SetActivatedTagType Invalid protocol");
+    LOG(ERROR) << StringPrintf("RW_SetActivatedTagType Invalid protocol");
   }
 
   if (status != NFC_STATUS_OK) rw_cb.p_cback = NULL;
   return status;
 }
-
-/*******************************************************************************
-**
-** Function         RW_SetTraceLevel
-**
-** Description      This function sets the trace level for Reader/Writer mode.
-**                  If called with a value of 0xFF,
-**                  it simply returns the current trace level.
-**
-** Returns          The new or current trace level
-**
-*******************************************************************************/
-uint8_t RW_SetTraceLevel(uint8_t new_level) {
-  if (new_level != 0xFF) rw_cb.trace_level = new_level;
-
-  return (rw_cb.trace_level);
-}
diff --git a/src/nfc/tags/rw_t1t.c b/src/nfc/tags/rw_t1t.cc
similarity index 86%
rename from src/nfc/tags/rw_t1t.c
rename to src/nfc/tags/rw_t1t.cc
index ec3de9f..e3e89d7 100644
--- a/src/nfc/tags/rw_t1t.c
+++ b/src/nfc/tags/rw_t1t.cc
@@ -20,7 +20,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -43,6 +43,10 @@
  *
  ******************************************************************************/
 #include <string.h>
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfc_target.h"
 
 #include "nfc_api.h"
@@ -52,9 +56,11 @@
 #include "nfc_int.h"
 #include "gki.h"
 
-#if (NXP_EXTNS == TRUE)
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
 extern unsigned char appl_dta_mode_flag;
-#endif
+
 /* Local Functions */
 static tRW_EVENT rw_t1t_handle_rid_rsp(NFC_HDR* p_pkt);
 static void rw_t1t_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
@@ -62,11 +68,7 @@ static void rw_t1t_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
 static void rw_t1t_process_frame_error(void);
 static void rw_t1t_process_error(void);
 static void rw_t1t_handle_presence_check_rsp(tNFC_STATUS status);
-#if (BT_TRACE_VERBOSE == true)
-static char* rw_t1t_get_state_name(uint8_t state);
-static char* rw_t1t_get_sub_state_name(uint8_t sub_state);
-static char* rw_t1t_get_event_name(uint8_t event);
-#endif
+static std::string rw_t1t_get_state_name(uint8_t state);
 
 /*******************************************************************************
 **
@@ -77,7 +79,8 @@ static char* rw_t1t_get_event_name(uint8_t event);
 ** Returns          none
 **
 *******************************************************************************/
-static void rw_t1t_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
+static void rw_t1t_data_cback(__attribute__((unused)) uint8_t conn_id,
+                              __attribute__((unused)) tNFC_CONN_EVT event,
                               tNFC_CONN* p_data) {
   tRW_T1T_CB* p_t1t = &rw_cb.tcb.t1t;
   tRW_EVENT rw_event = RW_RAW_FRAME_EVT;
@@ -87,23 +90,15 @@ static void rw_t1t_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
   uint8_t* p;
   tT1T_CMD_RSP_INFO* p_cmd_rsp_info =
       (tT1T_CMD_RSP_INFO*)rw_cb.tcb.t1t.p_cmd_rsp_info;
-#if (BT_TRACE_VERBOSE == true)
   uint8_t begin_state = p_t1t->state;
-#endif
-  (void)conn_id;
-  (void)event;
 
   p_pkt = (NFC_HDR*)(p_data->data.p_data);
   if (p_pkt == NULL) return;
   /* Assume the data is just the response byte sequence */
   p = (uint8_t*)(p_pkt + 1) + p_pkt->offset;
 
-#if (BT_TRACE_VERBOSE == true)
-  RW_TRACE_DEBUG2("rw_t1t_data_cback (): state:%s (%d)",
-                  rw_t1t_get_state_name(p_t1t->state), p_t1t->state);
-#else
-  RW_TRACE_DEBUG1("rw_t1t_data_cback (): state=%d", p_t1t->state);
-#endif
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t1t_data_cback (): state:%s (%d)",
+                  rw_t1t_get_state_name(p_t1t->state).c_str(), p_t1t->state);
 
   evt_data.status = NFC_STATUS_OK;
 
@@ -121,7 +116,7 @@ static void rw_t1t_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
          (p_t1t->prev_cmd_rsp_info.op_code == T1T_CMD_RALL) ||
          (p_t1t->prev_cmd_rsp_info.addr == *p))) {
       /* Response to previous command retransmission */
-      RW_TRACE_ERROR2(
+      LOG(ERROR) << StringPrintf(
           "T1T Response to previous command in Idle state. command=0x%02x, "
           "Remaining max retx rsp:0x%02x ",
           p_t1t->prev_cmd_rsp_info.op_code,
@@ -131,7 +126,7 @@ static void rw_t1t_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
     } else {
       /* Raw frame event */
       evt_data.data.p_data = p_pkt;
-      (*rw_cb.p_cback)(RW_T1T_RAW_FRAME_EVT, (tRW_DATA*)&evt_data);
+      (*rw_cb.p_cback)(RW_T1T_RAW_FRAME_EVT, &evt_data);
     }
     return;
   }
@@ -158,7 +153,7 @@ static void rw_t1t_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
         ((p_t1t->prev_cmd_rsp_info.op_code == T1T_CMD_RID) ||
          (p_t1t->prev_cmd_rsp_info.op_code == T1T_CMD_RALL) ||
          (p_t1t->prev_cmd_rsp_info.addr == *p))) {
-      RW_TRACE_ERROR2(
+      LOG(ERROR) << StringPrintf(
           "T1T Response to previous command. command=0x%02x, Remaining max "
           "retx rsp:0x%02x",
           p_t1t->prev_cmd_rsp_info.op_code,
@@ -168,14 +163,9 @@ static void rw_t1t_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
       /* Stop timer as some response to current command is received */
       nfc_stop_quick_timer(&p_t1t->timer);
 /* Retrasmit the last sent command if retry-count < max retry */
-#if (BT_TRACE_VERBOSE == true)
-      RW_TRACE_ERROR2("T1T Frame error. state=%s command (opcode) = 0x%02x",
-                      rw_t1t_get_state_name(p_t1t->state),
+      LOG(ERROR) << StringPrintf("T1T Frame error. state=%s command (opcode) = 0x%02x",
+                      rw_t1t_get_state_name(p_t1t->state).c_str(),
                       p_cmd_rsp_info->opcode);
-#else
-      RW_TRACE_ERROR2("T1T Frame error. state=0x%02x command = 0x%02x ",
-                      p_t1t->state, p_cmd_rsp_info->opcode);
-#endif
       rw_t1t_process_frame_error();
     }
     GKI_freebuf(p_pkt);
@@ -185,7 +175,7 @@ static void rw_t1t_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
   /* Stop timer as response to current command is received */
   nfc_stop_quick_timer(&p_t1t->timer);
 
-  RW_TRACE_EVENT2("RW RECV [%s]:0x%x RSP", t1t_info_to_str(p_cmd_rsp_info),
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW RECV [%s]:0x%x RSP", t1t_info_to_str(p_cmd_rsp_info),
                   p_cmd_rsp_info->opcode);
 
   /* If we did not receive response to all retransmitted previous command,
@@ -227,17 +217,15 @@ static void rw_t1t_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
       evt_data.data.p_data = p_pkt;
     }
     rw_t1t_handle_op_complete();
-    (*rw_cb.p_cback)(rw_event, (tRW_DATA*)&evt_data);
+    (*rw_cb.p_cback)(rw_event, &evt_data);
   } else
     GKI_freebuf(p_pkt);
 
-#if (BT_TRACE_VERBOSE == true)
   if (begin_state != p_t1t->state) {
-    RW_TRACE_DEBUG2("RW T1T state changed:<%s> -> <%s>",
-                    rw_t1t_get_state_name(begin_state),
-                    rw_t1t_get_state_name(p_t1t->state));
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW T1T state changed:<%s> -> <%s>",
+                    rw_t1t_get_state_name(begin_state).c_str(),
+                    rw_t1t_get_state_name(p_t1t->state).c_str());
   }
-#endif
 }
 
 /*******************************************************************************
@@ -252,12 +240,11 @@ static void rw_t1t_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
 void rw_t1t_conn_cback(uint8_t conn_id, tNFC_CONN_EVT event,
                        tNFC_CONN* p_data) {
   tRW_T1T_CB* p_t1t = &rw_cb.tcb.t1t;
-  tRW_READ_DATA evt_data;
 
-  RW_TRACE_DEBUG2("rw_t1t_conn_cback: conn_id=%i, evt=0x%x", conn_id, event);
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t1t_conn_cback: conn_id=%i, evt=0x%x", conn_id, event);
   /* Only handle static conn_id */
   if (conn_id != NFC_RF_CONN_ID) {
-    RW_TRACE_WARNING1("rw_t1t_conn_cback - Not static connection id: =%i",
+    LOG(WARNING) << StringPrintf("rw_t1t_conn_cback - Not static connection id: =%i",
                       conn_id);
     return;
   }
@@ -298,14 +285,14 @@ void rw_t1t_conn_cback(uint8_t conn_id, tNFC_CONN_EVT event,
         }
       }
     /* Data event with error status...fall through to NFC_ERROR_CEVT case */
-
+    [[fallthrough]];
     case NFC_ERROR_CEVT:
       if ((p_t1t->state == RW_T1T_STATE_NOT_ACTIVATED) ||
           (p_t1t->state == RW_T1T_STATE_IDLE)) {
 #if (RW_STATS_INCLUDED == true)
         rw_main_update_trans_error_stats();
 #endif /* RW_STATS_INCLUDED */
-
+        tRW_READ_DATA evt_data;
         if (event == NFC_ERROR_CEVT)
           evt_data.status = (tNFC_STATUS)(*(uint8_t*)p_data);
         else if (p_data)
@@ -314,7 +301,9 @@ void rw_t1t_conn_cback(uint8_t conn_id, tNFC_CONN_EVT event,
           evt_data.status = NFC_STATUS_FAILED;
 
         evt_data.p_data = NULL;
-        (*rw_cb.p_cback)(RW_T1T_INTF_ERROR_EVT, (void*)&evt_data);
+        tRW_DATA rw_data;
+        rw_data.data = evt_data;
+        (*rw_cb.p_cback)(RW_T1T_INTF_ERROR_EVT, &rw_data);
         break;
       }
       nfc_stop_quick_timer(&p_t1t->timer);
@@ -379,7 +368,7 @@ tNFC_STATUS rw_t1t_send_static_cmd(uint8_t opcode, uint8_t add, uint8_t dat) {
       rw_main_update_tx_stats(p_data->len, false);
 #endif /* RW_STATS_INCLUDED */
 
-      RW_TRACE_EVENT2("RW SENT [%s]:0x%x CMD", t1t_info_to_str(p_cmd_rsp_info),
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW SENT [%s]:0x%x CMD", t1t_info_to_str(p_cmd_rsp_info),
                       p_cmd_rsp_info->opcode);
       status = NFC_SendData(NFC_RF_CONN_ID, p_data);
       if (status == NFC_STATUS_OK) {
@@ -443,7 +432,7 @@ tNFC_STATUS rw_t1t_send_dyn_cmd(uint8_t opcode, uint8_t add, uint8_t* p_dat) {
       rw_main_update_tx_stats(p_data->len, false);
 #endif /* RW_STATS_INCLUDED */
 
-      RW_TRACE_EVENT2("RW SENT [%s]:0x%x CMD", t1t_info_to_str(p_cmd_rsp_info),
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW SENT [%s]:0x%x CMD", t1t_info_to_str(p_cmd_rsp_info),
                       p_cmd_rsp_info->opcode);
 
       status = NFC_SendData(NFC_RF_CONN_ID, p_data);
@@ -489,13 +478,10 @@ static tRW_EVENT rw_t1t_handle_rid_rsp(NFC_HDR* p_pkt) {
   /* Extract HR and UID from response */
   STREAM_TO_ARRAY(p_t1t->hr, p_rid_rsp, T1T_HR_LEN);
 
-#if (BT_TRACE_VERBOSE == true)
-  RW_TRACE_DEBUG2("hr0:0x%x, hr1:0x%x", p_t1t->hr[0], p_t1t->hr[1]);
-  RW_TRACE_DEBUG4("rw_t1t_handle_rid_rsp (): UID0-3=%02x%02x%02x%02x",
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("hr0:0x%x, hr1:0x%x", p_t1t->hr[0], p_t1t->hr[1]);
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t1t_handle_rid_rsp (): UID0-3=%02x%02x%02x%02x",
                   p_rid_rsp[0], p_rid_rsp[1], p_rid_rsp[2], p_rid_rsp[3]);
-#else
-  RW_TRACE_DEBUG0("rw_t1t_handle_rid_rsp ()");
-#endif
+
 
   /* Fetch UID0-3 from RID response message */
   STREAM_TO_ARRAY(p_t1t->mem, p_rid_rsp, T1T_CMD_UID_LEN);
@@ -525,7 +511,7 @@ tNFC_STATUS rw_t1t_select(uint8_t hr[T1T_HR_LEN],
   if (p_t1t->p_cur_cmd_buf == NULL) {
     p_t1t->p_cur_cmd_buf = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
     if (p_t1t->p_cur_cmd_buf == NULL) {
-      RW_TRACE_ERROR0(
+      LOG(ERROR) << StringPrintf(
           "rw_t1t_select: unable to allocate buffer for retransmission");
       return status;
     }
@@ -550,18 +536,12 @@ tNFC_STATUS rw_t1t_select(uint8_t hr[T1T_HR_LEN],
 ** Returns          none
 **
 *******************************************************************************/
-void rw_t1t_process_timeout(TIMER_LIST_ENT* p_tle) {
+void rw_t1t_process_timeout(__attribute__((unused)) TIMER_LIST_ENT* p_tle) {
   tRW_T1T_CB* p_t1t = &rw_cb.tcb.t1t;
-  (void)p_tle;
 
-#if (BT_TRACE_VERBOSE == true)
-  RW_TRACE_ERROR2("T1T timeout. state=%s command (opcode)=0x%02x ",
-                  rw_t1t_get_state_name(p_t1t->state),
+  LOG(ERROR) << StringPrintf("T1T timeout. state=%s command (opcode)=0x%02x ",
+                  rw_t1t_get_state_name(p_t1t->state).c_str(),
                   (rw_cb.tcb.t1t.p_cmd_rsp_info)->opcode);
-#else
-  RW_TRACE_ERROR2("T1T timeout. state=0x%02x command=0x%02x ", p_t1t->state,
-                  (rw_cb.tcb.t1t.p_cmd_rsp_info)->opcode);
-#endif
 
   if (p_t1t->state == RW_T1T_STATE_CHECK_PRESENCE) {
     /* Tag has moved from range */
@@ -600,22 +580,20 @@ static void rw_t1t_process_frame_error(void) {
 **
 *******************************************************************************/
 static void rw_t1t_process_error(void) {
-  tRW_READ_DATA evt_data;
   tRW_EVENT rw_event;
   NFC_HDR* p_cmd_buf;
   tRW_T1T_CB* p_t1t = &rw_cb.tcb.t1t;
   tT1T_CMD_RSP_INFO* p_cmd_rsp_info =
       (tT1T_CMD_RSP_INFO*)rw_cb.tcb.t1t.p_cmd_rsp_info;
-  tRW_DETECT_NDEF_DATA ndef_data;
 
-  RW_TRACE_DEBUG1("rw_t1t_process_error () State: %u", p_t1t->state);
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t1t_process_error () State: %u", p_t1t->state);
 
   /* Retry sending command if retry-count < max */
   if (rw_cb.cur_retry < RW_MAX_RETRIES) {
     /* retry sending the command */
     rw_cb.cur_retry++;
 
-    RW_TRACE_DEBUG2("T1T retransmission attempt %i of %i", rw_cb.cur_retry,
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("T1T retransmission attempt %i of %i", rw_cb.cur_retry,
                     RW_MAX_RETRIES);
 
     /* allocate a new buffer for message */
@@ -642,7 +620,7 @@ static void rw_t1t_process_error(void) {
   } else {
     /* we might get response later to all or some of the retrasnmission
      * of the current command, update previous command response information */
-    RW_TRACE_DEBUG1("T1T maximum retransmission attempts reached (%i)",
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("T1T maximum retransmission attempts reached (%i)",
                     RW_MAX_RETRIES);
     p_t1t->prev_cmd_rsp_info.addr = ((p_cmd_rsp_info->opcode != T1T_CMD_RALL) &&
                                      (p_cmd_rsp_info->opcode != T1T_CMD_RID))
@@ -661,17 +639,23 @@ static void rw_t1t_process_error(void) {
   rw_event = rw_t1t_info_to_event(p_cmd_rsp_info);
   if (p_t1t->state != RW_T1T_STATE_NOT_ACTIVATED) rw_t1t_handle_op_complete();
 
-  evt_data.status = NFC_STATUS_TIMEOUT;
   if (rw_event == RW_T2T_NDEF_DETECT_EVT) {
-    ndef_data.status = evt_data.status;
+    tRW_DETECT_NDEF_DATA ndef_data;
+    ndef_data.status = NFC_STATUS_TIMEOUT;
     ndef_data.protocol = NFC_PROTOCOL_T1T;
     ndef_data.flags = RW_NDEF_FL_UNKNOWN;
     ndef_data.max_size = 0;
     ndef_data.cur_size = 0;
-    (*rw_cb.p_cback)(rw_event, (void*)&ndef_data);
+    tRW_DATA rw_data;
+    rw_data.ndef = ndef_data;
+    (*rw_cb.p_cback)(rw_event, &rw_data);
   } else {
+    tRW_READ_DATA evt_data;
+    evt_data.status = NFC_STATUS_TIMEOUT;
     evt_data.p_data = NULL;
-    (*rw_cb.p_cback)(rw_event, (void*)&evt_data);
+    tRW_DATA rw_data;
+    rw_data.data = evt_data;
+    (*rw_cb.p_cback)(rw_event, &rw_data);
   }
 }
 
@@ -685,13 +669,13 @@ static void rw_t1t_process_error(void) {
 **
 *****************************************************************************/
 void rw_t1t_handle_presence_check_rsp(tNFC_STATUS status) {
-  tRW_READ_DATA evt_data;
+  tRW_DATA rw_data;
 
   /* Notify, Tag is present or not */
-  evt_data.status = status;
+  rw_data.data.status = status;
   rw_t1t_handle_op_complete();
 
-  (*(rw_cb.p_cback))(RW_T1T_PRESENCE_CHECK_EVT, (void*)&evt_data);
+  (*(rw_cb.p_cback))(RW_T1T_PRESENCE_CHECK_EVT, &rw_data);
 }
 
 /*****************************************************************************
@@ -707,13 +691,8 @@ void rw_t1t_handle_op_complete(void) {
   tRW_T1T_CB* p_t1t = &rw_cb.tcb.t1t;
 
   p_t1t->state = RW_T1T_STATE_IDLE;
-#if (RW_NDEF_INCLUDED == true)
-#if (NXP_EXTNS == TRUE)
-  if ((appl_dta_mode_flag == 0) && (p_t1t->state != RW_T1T_STATE_READ_NDEF))
-#else
-  if (p_t1t->state != RW_T1T_STATE_READ_NDEF)
-#endif
-  {
+#if (RW_NDEF_INCLUDED == TRUE)
+  if (appl_dta_mode_flag == 0 && (p_t1t->state != RW_T1T_STATE_READ_NDEF)) {
     p_t1t->b_update = false;
     p_t1t->b_rseg = false;
   }
@@ -743,7 +722,7 @@ tNFC_STATUS RW_T1tPresenceCheck(void) {
   tRW_DATA evt_data;
   tRW_CB* p_rw_cb = &rw_cb;
 
-  RW_TRACE_API0("RW_T1tPresenceCheck");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_T1tPresenceCheck");
 
   /* If RW_SelectTagType was not called (no conn_callback) return failure */
   if (!p_rw_cb->p_cback) {
@@ -786,10 +765,10 @@ tNFC_STATUS RW_T1tRid(void) {
   tRW_T1T_CB* p_t1t = &rw_cb.tcb.t1t;
   tNFC_STATUS status = NFC_STATUS_FAILED;
 
-  RW_TRACE_API0("RW_T1tRid");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_T1tRid");
 
   if (p_t1t->state != RW_T1T_STATE_IDLE) {
-    RW_TRACE_WARNING1("RW_T1tRid - Busy - State: %u", p_t1t->state);
+    LOG(WARNING) << StringPrintf("RW_T1tRid - Busy - State: %u", p_t1t->state);
     return (NFC_STATUS_BUSY);
   }
 
@@ -815,10 +794,10 @@ tNFC_STATUS RW_T1tReadAll(void) {
   tRW_T1T_CB* p_t1t = &rw_cb.tcb.t1t;
   tNFC_STATUS status = NFC_STATUS_FAILED;
 
-  RW_TRACE_API0("RW_T1tReadAll");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_T1tReadAll");
 
   if (p_t1t->state != RW_T1T_STATE_IDLE) {
-    RW_TRACE_WARNING1("RW_T1tReadAll - Busy - State: %u", p_t1t->state);
+    LOG(WARNING) << StringPrintf("RW_T1tReadAll - Busy - State: %u", p_t1t->state);
     return (NFC_STATUS_BUSY);
   }
 
@@ -846,7 +825,7 @@ tNFC_STATUS RW_T1tRead(uint8_t block, uint8_t byte) {
   uint8_t addr;
 
   if (p_t1t->state != RW_T1T_STATE_IDLE) {
-    RW_TRACE_WARNING1("RW_T1tRead - Busy - State: %u", p_t1t->state);
+    LOG(WARNING) << StringPrintf("RW_T1tRead - Busy - State: %u", p_t1t->state);
     return (NFC_STATUS_BUSY);
   }
 
@@ -875,21 +854,21 @@ tNFC_STATUS RW_T1tWriteErase(uint8_t block, uint8_t byte, uint8_t new_byte) {
   uint8_t addr;
 
   if (p_t1t->state != RW_T1T_STATE_IDLE) {
-    RW_TRACE_WARNING1("RW_T1tWriteErase - Busy - State: %u", p_t1t->state);
+    LOG(WARNING) << StringPrintf("RW_T1tWriteErase - Busy - State: %u", p_t1t->state);
     return (NFC_STATUS_BUSY);
   }
   if ((p_t1t->tag_attribute == RW_T1_TAG_ATTRB_READ_ONLY) &&
       (block != T1T_CC_BLOCK) && (byte != T1T_CC_RWA_OFFSET)) {
-    RW_TRACE_ERROR0("RW_T1tWriteErase - Tag is in Read only state");
+    LOG(ERROR) << StringPrintf("RW_T1tWriteErase - Tag is in Read only state");
     return (NFC_STATUS_REFUSED);
   }
   if ((block >= T1T_STATIC_BLOCKS) || (byte >= T1T_BLOCK_SIZE)) {
-    RW_TRACE_ERROR2("RW_T1tWriteErase - Invalid Block/byte: %u / %u", block,
+    LOG(ERROR) << StringPrintf("RW_T1tWriteErase - Invalid Block/byte: %u / %u", block,
                     byte);
     return (NFC_STATUS_REFUSED);
   }
   if ((block == T1T_UID_BLOCK) || (block == T1T_RES_BLOCK)) {
-    RW_TRACE_WARNING1("RW_T1tWriteErase - Cannot write to Locked block: %u",
+    LOG(WARNING) << StringPrintf("RW_T1tWriteErase - Cannot write to Locked block: %u",
                       block);
     return (NFC_STATUS_REFUSED);
   }
@@ -922,21 +901,21 @@ tNFC_STATUS RW_T1tWriteNoErase(uint8_t block, uint8_t byte, uint8_t new_byte) {
   uint8_t addr;
 
   if (p_t1t->state != RW_T1T_STATE_IDLE) {
-    RW_TRACE_WARNING1("RW_T1tWriteNoErase - Busy - State: %u", p_t1t->state);
+    LOG(WARNING) << StringPrintf("RW_T1tWriteNoErase - Busy - State: %u", p_t1t->state);
     return (NFC_STATUS_BUSY);
   }
   if ((p_t1t->tag_attribute == RW_T1_TAG_ATTRB_READ_ONLY) &&
       (block != T1T_CC_BLOCK) && (byte != T1T_CC_RWA_OFFSET)) {
-    RW_TRACE_ERROR0("RW_T1tWriteErase - Tag is in Read only state");
+    LOG(ERROR) << StringPrintf("RW_T1tWriteErase - Tag is in Read only state");
     return (NFC_STATUS_REFUSED);
   }
   if ((block >= T1T_STATIC_BLOCKS) || (byte >= T1T_BLOCK_SIZE)) {
-    RW_TRACE_ERROR2("RW_T1tWriteErase - Invalid Block/byte: %u / %u", block,
+    LOG(ERROR) << StringPrintf("RW_T1tWriteErase - Invalid Block/byte: %u / %u", block,
                     byte);
     return (NFC_STATUS_REFUSED);
   }
   if ((block == T1T_UID_BLOCK) || (block == T1T_RES_BLOCK)) {
-    RW_TRACE_WARNING1("RW_T1tWriteNoErase - Cannot write to Locked block: %u",
+    LOG(WARNING) << StringPrintf("RW_T1tWriteNoErase - Cannot write to Locked block: %u",
                       block);
     return (NFC_STATUS_REFUSED);
   }
@@ -968,11 +947,11 @@ tNFC_STATUS RW_T1tReadSeg(uint8_t segment) {
   uint8_t adds;
 
   if (p_t1t->state != RW_T1T_STATE_IDLE) {
-    RW_TRACE_WARNING1("RW_T1tReadSeg - Busy - State: %u", p_t1t->state);
+    LOG(WARNING) << StringPrintf("RW_T1tReadSeg - Busy - State: %u", p_t1t->state);
     return (NFC_STATUS_BUSY);
   }
   if (segment >= T1T_MAX_SEGMENTS) {
-    RW_TRACE_ERROR1("RW_T1tReadSeg - Invalid Segment: %u", segment);
+    LOG(ERROR) << StringPrintf("RW_T1tReadSeg - Invalid Segment: %u", segment);
     return (NFC_STATUS_REFUSED);
   }
   if (rw_cb.tcb.t1t.hr[0] != T1T_STATIC_HR0) {
@@ -1000,7 +979,7 @@ tNFC_STATUS RW_T1tRead8(uint8_t block) {
   tRW_T1T_CB* p_t1t = &rw_cb.tcb.t1t;
 
   if (p_t1t->state != RW_T1T_STATE_IDLE) {
-    RW_TRACE_WARNING1("RW_T1tRead8 - Busy - State: %u", p_t1t->state);
+    LOG(WARNING) << StringPrintf("RW_T1tRead8 - Busy - State: %u", p_t1t->state);
     return (NFC_STATUS_BUSY);
   }
 
@@ -1030,18 +1009,18 @@ tNFC_STATUS RW_T1tWriteErase8(uint8_t block, uint8_t* p_new_dat) {
   tNFC_STATUS status = NFC_STATUS_FAILED;
 
   if (p_t1t->state != RW_T1T_STATE_IDLE) {
-    RW_TRACE_WARNING1("RW_T1tWriteErase8 - Busy - State: %u", p_t1t->state);
+    LOG(WARNING) << StringPrintf("RW_T1tWriteErase8 - Busy - State: %u", p_t1t->state);
     return (NFC_STATUS_BUSY);
   }
 
   if ((p_t1t->tag_attribute == RW_T1_TAG_ATTRB_READ_ONLY) &&
       (block != T1T_CC_BLOCK)) {
-    RW_TRACE_ERROR0("RW_T1tWriteErase8 - Tag is in Read only state");
+    LOG(ERROR) << StringPrintf("RW_T1tWriteErase8 - Tag is in Read only state");
     return (NFC_STATUS_REFUSED);
   }
 
   if ((block == T1T_UID_BLOCK) || (block == T1T_RES_BLOCK)) {
-    RW_TRACE_WARNING1("RW_T1tWriteErase8 - Cannot write to Locked block: %u",
+    LOG(WARNING) << StringPrintf("RW_T1tWriteErase8 - Cannot write to Locked block: %u",
                       block);
     return (NFC_STATUS_REFUSED);
   }
@@ -1076,18 +1055,18 @@ tNFC_STATUS RW_T1tWriteNoErase8(uint8_t block, uint8_t* p_new_dat) {
   tRW_T1T_CB* p_t1t = &rw_cb.tcb.t1t;
 
   if (p_t1t->state != RW_T1T_STATE_IDLE) {
-    RW_TRACE_WARNING1("RW_T1tWriteNoErase8 - Busy - State: %u", p_t1t->state);
+    LOG(WARNING) << StringPrintf("RW_T1tWriteNoErase8 - Busy - State: %u", p_t1t->state);
     return (NFC_STATUS_BUSY);
   }
 
   if ((p_t1t->tag_attribute == RW_T1_TAG_ATTRB_READ_ONLY) &&
       (block != T1T_CC_BLOCK)) {
-    RW_TRACE_ERROR0("RW_T1tWriteNoErase8 - Tag is in Read only state");
+    LOG(ERROR) << StringPrintf("RW_T1tWriteNoErase8 - Tag is in Read only state");
     return (NFC_STATUS_REFUSED);
   }
 
   if ((block == T1T_UID_BLOCK) || (block == T1T_RES_BLOCK)) {
-    RW_TRACE_WARNING1("RW_T1tWriteNoErase8 - Cannot write to Locked block: %u",
+    LOG(WARNING) << StringPrintf("RW_T1tWriteNoErase8 - Cannot write to Locked block: %u",
                       block);
     return (NFC_STATUS_REFUSED);
   }
@@ -1107,7 +1086,6 @@ tNFC_STATUS RW_T1tWriteNoErase8(uint8_t block, uint8_t* p_new_dat) {
   return status;
 }
 
-#if (BT_TRACE_VERBOSE == true)
 /*******************************************************************************
 **
 ** Function         rw_t1t_get_state_name
@@ -1119,7 +1097,7 @@ tNFC_STATUS RW_T1tWriteNoErase8(uint8_t block, uint8_t* p_new_dat) {
 ** Returns          pointer to the name
 **
 *******************************************************************************/
-static char* rw_t1t_get_state_name(uint8_t state) {
+static std::string rw_t1t_get_state_name(uint8_t state) {
   switch (state) {
     case RW_T1T_STATE_IDLE:
       return ("IDLE");
@@ -1146,4 +1124,3 @@ static char* rw_t1t_get_state_name(uint8_t state) {
   }
 }
 
-#endif /* (BT_TRACE_VERBOSE == true) */
diff --git a/src/nfc/tags/rw_t1t_ndef.c b/src/nfc/tags/rw_t1t_ndef.cc
similarity index 96%
rename from src/nfc/tags/rw_t1t_ndef.c
rename to src/nfc/tags/rw_t1t_ndef.cc
index 6d9ae16..5d34ed6 100644
--- a/src/nfc/tags/rw_t1t_ndef.c
+++ b/src/nfc/tags/rw_t1t_ndef.cc
@@ -42,14 +42,20 @@
  *
  ******************************************************************************/
 #include <string.h>
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfc_target.h"
 
 #include "nfc_api.h"
 #include "nci_hmsgs.h"
 #include "rw_api.h"
 #include "rw_int.h"
-#include "nfc_int.h"
-#include "gki.h"
+
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
 
 #if (RW_NDEF_INCLUDED == true)
 
@@ -595,7 +601,6 @@ tNFC_STATUS rw_t1t_handle_read_rsp(bool* p_notify, uint8_t* p_data) {
   tRW_DETECT_NDEF_DATA ndef_data;
   tRW_DETECT_TLV_DATA tlv_data;
   uint8_t count;
-  tRW_READ_DATA evt_data;
 
   *p_notify = false;
   /* Handle the response based on the current state */
@@ -607,10 +612,11 @@ tNFC_STATUS rw_t1t_handle_read_rsp(bool* p_notify, uint8_t* p_data) {
     case RW_T1T_STATE_READ_NDEF:
       status = rw_t1t_handle_ndef_rall_rsp();
       if (status != NFC_STATUS_CONTINUE) {
-        evt_data.status = status;
-        evt_data.p_data = NULL;
+        tRW_DATA rw_data;
+        rw_data.data.status = status;
+        rw_data.data.p_data = NULL;
         rw_t1t_handle_op_complete();
-        (*rw_cb.p_cback)(RW_T1T_NDEF_READ_EVT, (void*)&evt_data);
+        (*rw_cb.p_cback)(RW_T1T_NDEF_READ_EVT, &rw_data);
       }
       break;
 
@@ -626,7 +632,9 @@ tNFC_STATUS rw_t1t_handle_read_rsp(bool* p_notify, uint8_t* p_data) {
               tlv_data.num_bytes = p_t1t->num_lockbytes;
               tlv_data.status = status;
               rw_t1t_handle_op_complete();
-              (*rw_cb.p_cback)(RW_T1T_TLV_DETECT_EVT, (void*)&tlv_data);
+              tRW_DATA rw_data;
+              rw_data.tlv = tlv_data;
+              (*rw_cb.p_cback)(RW_T1T_TLV_DETECT_EVT, &rw_data);
             } else if (p_t1t->tlv_detect == TAG_NDEF_TLV) {
               ndef_data.protocol = NFC_PROTOCOL_T1T;
               ndef_data.flags = rw_t1t_get_ndef_flags();
@@ -646,7 +654,9 @@ tNFC_STATUS rw_t1t_handle_read_rsp(bool* p_notify, uint8_t* p_data) {
               }
               ndef_data.status = status;
               rw_t1t_handle_op_complete();
-              (*rw_cb.p_cback)(RW_T1T_NDEF_DETECT_EVT, (void*)&ndef_data);
+              tRW_DATA rw_data;
+              rw_data.ndef = ndef_data;
+              (*rw_cb.p_cback)(RW_T1T_NDEF_DETECT_EVT, &rw_data);
             }
           }
           break;
@@ -664,7 +674,9 @@ tNFC_STATUS rw_t1t_handle_read_rsp(bool* p_notify, uint8_t* p_data) {
             }
             rw_t1t_handle_op_complete();
             /* Send response to upper layer */
-            (*rw_cb.p_cback)(RW_T1T_TLV_DETECT_EVT, (void*)&tlv_data);
+            tRW_DATA rw_data;
+            rw_data.tlv = tlv_data;
+            (*rw_cb.p_cback)(RW_T1T_TLV_DETECT_EVT, &rw_data);
           } else if (p_t1t->tlv_detect == TAG_LOCK_CTRL_TLV) {
             tlv_data.status = rw_t1t_handle_tlv_detect_rsp(p_t1t->mem);
             tlv_data.protocol = NFC_PROTOCOL_T1T;
@@ -674,7 +686,9 @@ tNFC_STATUS rw_t1t_handle_read_rsp(bool* p_notify, uint8_t* p_data) {
               rw_t1t_handle_op_complete();
 
               /* Send Negative response to upper layer */
-              (*rw_cb.p_cback)(RW_T1T_TLV_DETECT_EVT, (void*)&tlv_data);
+              tRW_DATA rw_data;
+              rw_data.tlv = tlv_data;
+              (*rw_cb.p_cback)(RW_T1T_TLV_DETECT_EVT, &rw_data);
             } else {
               rw_t1t_extract_lock_bytes(p_data);
               status = rw_t1t_read_locks();
@@ -682,8 +696,9 @@ tNFC_STATUS rw_t1t_handle_read_rsp(bool* p_notify, uint8_t* p_data) {
                 /* Send positive response to upper layer */
                 tlv_data.status = status;
                 rw_t1t_handle_op_complete();
-
-                (*rw_cb.p_cback)(RW_T1T_TLV_DETECT_EVT, (void*)&tlv_data);
+                tRW_DATA rw_data;
+                rw_data.tlv = tlv_data;
+                (*rw_cb.p_cback)(RW_T1T_TLV_DETECT_EVT, &rw_data);
               }
             }
           } else if (p_t1t->tlv_detect == TAG_NDEF_TLV) {
@@ -706,7 +721,9 @@ tNFC_STATUS rw_t1t_handle_read_rsp(bool* p_notify, uint8_t* p_data) {
                 /* Send Negative response to upper layer */
                 rw_t1t_handle_op_complete();
 
-                (*rw_cb.p_cback)(RW_T1T_NDEF_DETECT_EVT, (void*)&ndef_data);
+                tRW_DATA rw_data;
+                rw_data.ndef = ndef_data;
+                (*rw_cb.p_cback)(RW_T1T_NDEF_DETECT_EVT, &rw_data);
               } else {
                 ndef_data.flags |= RW_NDEF_FL_FORMATED;
                 rw_t1t_extract_lock_bytes(p_data);
@@ -727,7 +744,9 @@ tNFC_STATUS rw_t1t_handle_read_rsp(bool* p_notify, uint8_t* p_data) {
                   ndef_data.status = status;
                   rw_t1t_handle_op_complete();
 
-                  (*rw_cb.p_cback)(RW_T1T_NDEF_DETECT_EVT, (void*)&ndef_data);
+                  tRW_DATA rw_data;
+                rw_data.ndef = ndef_data;
+                (*rw_cb.p_cback)(RW_T1T_NDEF_DETECT_EVT, &rw_data);
                 }
               }
             } else {
@@ -745,7 +764,9 @@ tNFC_STATUS rw_t1t_handle_read_rsp(bool* p_notify, uint8_t* p_data) {
               }
               rw_t1t_handle_op_complete();
 
-              (*rw_cb.p_cback)(RW_T1T_NDEF_DETECT_EVT, (void*)&ndef_data);
+              tRW_DATA rw_data;
+              rw_data.ndef = ndef_data;
+              (*rw_cb.p_cback)(RW_T1T_NDEF_DETECT_EVT, &rw_data);
             }
           }
           break;
@@ -815,7 +836,7 @@ static tNFC_STATUS rw_t1t_handle_rall_rsp(bool* p_notify, uint8_t* p_data) {
   p_data +=
       T1T_UID_LEN + T1T_RES_BYTE_LEN; /* skip Block 0, UID and Reserved byte */
 
-  RW_TRACE_DEBUG0("rw_t1t_handle_rall_rsp ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t1t_handle_rall_rsp ()");
 
   rw_t1t_update_tag_state();
   rw_t1t_update_attributes();
@@ -1018,7 +1039,10 @@ static tNFC_STATUS rw_t1t_handle_tlv_detect_rsp(uint8_t* p_data) {
             bytes_count--;
             if ((p_t1t->tlv_detect == TAG_LOCK_CTRL_TLV) ||
                 (p_t1t->tlv_detect == TAG_NDEF_TLV)) {
+              if(bytes_count < 3)
+              {
               tlv_value[2 - bytes_count] = p_readbytes[offset];
+              }
               if (bytes_count == 0) {
                 if (p_t1t->num_lock_tlvs < RW_T1T_MAX_LOCK_TLVS) {
                   p_t1t->lock_tlv[p_t1t->num_lock_tlvs].offset =
@@ -1040,7 +1064,7 @@ static tNFC_STATUS rw_t1t_handle_tlv_detect_rsp(uint8_t* p_data) {
                       p_t1t->lockbyte[p_t1t->num_lockbytes].b_lock_read = false;
                       p_t1t->num_lockbytes++;
                     } else
-                      RW_TRACE_ERROR1(
+                      LOG(ERROR) << StringPrintf(
                           "T1T Buffer overflow error. Max supported lock "
                           "bytes=0x%02X",
                           RW_T1T_MAX_LOCK_BYTES);
@@ -1049,7 +1073,7 @@ static tNFC_STATUS rw_t1t_handle_tlv_detect_rsp(uint8_t* p_data) {
                   p_t1t->num_lock_tlvs++;
                   rw_t1t_update_attributes();
                 } else
-                  RW_TRACE_ERROR1(
+                  LOG(ERROR) << StringPrintf(
                       "T1T Buffer overflow error. Max supported lock "
                       "tlvs=0x%02X",
                       RW_T1T_MAX_LOCK_TLVS);
@@ -1070,7 +1094,7 @@ static tNFC_STATUS rw_t1t_handle_tlv_detect_rsp(uint8_t* p_data) {
               tlv_value[2 - bytes_count] = p_readbytes[offset];
               if (bytes_count == 0) {
                 if (p_t1t->num_mem_tlvs >= RW_T1T_MAX_MEM_TLVS) {
-                  RW_TRACE_ERROR0(
+                  LOG(ERROR) << StringPrintf(
                       "rw_t1t_handle_tlv_detect_rsp - Maximum buffer allocated "
                       "for Memory tlv has reached");
                   failed = true;
@@ -1188,7 +1212,7 @@ static tNFC_STATUS rw_t1t_handle_ndef_rall_rsp(void) {
         }
       }
     } else {
-      RW_TRACE_ERROR1("RW_T1tReadNDef - Invalid NDEF len: %u or NDEF corrupted",
+      LOG(ERROR) << StringPrintf("RW_T1tReadNDef - Invalid NDEF len: %u or NDEF corrupted",
                       p_t1t->ndef_msg_len);
       status = NFC_STATUS_FAILED;
     }
@@ -2142,13 +2166,13 @@ tNFC_STATUS RW_T1tFormatNDef(void) {
   uint8_t* p;
 
   if (p_t1t->state != RW_T1T_STATE_IDLE) {
-    RW_TRACE_WARNING1("RW_T1tFormatNDef - Tag not initialized/ Busy! State: %u",
+    LOG(WARNING) << StringPrintf("RW_T1tFormatNDef - Tag not initialized/ Busy! State: %u",
                       p_t1t->state);
     return (NFC_STATUS_FAILED);
   }
 
   if ((p_t1t->hr[0] & 0xF0) != T1T_NDEF_SUPPORTED) {
-    RW_TRACE_WARNING1(
+    LOG(WARNING) << StringPrintf(
         "RW_T1tFormatNDef - Cannot format tag as NDEF not supported. HR0: %u",
         p_t1t->hr[0]);
     return (NFC_STATUS_REJECTED);
@@ -2156,7 +2180,7 @@ tNFC_STATUS RW_T1tFormatNDef(void) {
 
   p_ret = t1t_tag_init_data(p_t1t->hr[0]);
   if (p_ret == NULL) {
-    RW_TRACE_WARNING2("RW_T1tFormatNDef - Invalid HR - HR0: %u, HR1: %u",
+    LOG(WARNING) << StringPrintf("RW_T1tFormatNDef - Invalid HR - HR0: %u, HR1: %u",
                       p_t1t->hr[0], p_t1t->hr[1]);
     return (NFC_STATUS_REJECTED);
   }
@@ -2237,14 +2261,14 @@ tNFC_STATUS RW_T1tLocateTlv(uint8_t tlv_type) {
   uint8_t adds;
 
   if (p_t1t->state != RW_T1T_STATE_IDLE) {
-    RW_TRACE_WARNING1("RW_T1tLocateTlv - Busy - State: %u", p_t1t->state);
+    LOG(WARNING) << StringPrintf("RW_T1tLocateTlv - Busy - State: %u", p_t1t->state);
     return (NFC_STATUS_FAILED);
   }
   p_t1t->tlv_detect = tlv_type;
 
   if ((p_t1t->tlv_detect == TAG_NDEF_TLV) &&
       (((p_t1t->hr[0]) & 0xF0) != T1T_NDEF_SUPPORTED)) {
-    RW_TRACE_ERROR0("RW_T1tLocateTlv - Error: NDEF not supported by the tag");
+    LOG(ERROR) << StringPrintf("RW_T1tLocateTlv - Error: NDEF not supported by the tag");
     return (NFC_STATUS_REFUSED);
   }
 
@@ -2322,18 +2346,18 @@ tNFC_STATUS RW_T1tReadNDef(uint8_t* p_buffer, uint16_t buf_len) {
       t1t_cmd_to_rsp_info(T1T_CMD_RSEG);
 
   if (p_t1t->state != RW_T1T_STATE_IDLE) {
-    RW_TRACE_WARNING1("RW_T1tReadNDef - Busy - State: %u", p_t1t->state);
+    LOG(WARNING) << StringPrintf("RW_T1tReadNDef - Busy - State: %u", p_t1t->state);
     return (NFC_STATUS_FAILED);
   }
 
   /* Check HR0 if NDEF supported by the tag */
   if (((p_t1t->hr[0]) & 0xF0) != T1T_NDEF_SUPPORTED) {
-    RW_TRACE_ERROR0("RW_T1tReadNDef - Error: NDEF not supported by the tag");
+    LOG(ERROR) << StringPrintf("RW_T1tReadNDef - Error: NDEF not supported by the tag");
     return (NFC_STATUS_REFUSED);
   }
 
   if (p_t1t->tag_attribute == RW_T1_TAG_ATTRB_INITIALIZED_NDEF) {
-    RW_TRACE_WARNING1(
+    LOG(WARNING) << StringPrintf(
         "RW_T1tReadNDef - NDEF Message length is zero, NDEF Length : %u ",
         p_t1t->ndef_msg_len);
     return (NFC_STATUS_NOT_INITIALIZED);
@@ -2341,14 +2365,14 @@ tNFC_STATUS RW_T1tReadNDef(uint8_t* p_buffer, uint16_t buf_len) {
 
   if ((p_t1t->tag_attribute != RW_T1_TAG_ATTRB_READ_WRITE) &&
       (p_t1t->tag_attribute != RW_T1_TAG_ATTRB_READ_ONLY)) {
-    RW_TRACE_ERROR0(
+    LOG(ERROR) << StringPrintf(
         "RW_T1tReadNDef - Error: NDEF detection not performed yet/ Tag is in "
         "Initialized state");
     return (NFC_STATUS_FAILED);
   }
 
   if (buf_len < p_t1t->ndef_msg_len) {
-    RW_TRACE_WARNING2(
+    LOG(WARNING) << StringPrintf(
         "RW_T1tReadNDef - buffer size: %u  less than NDEF msg sise: %u",
         buf_len, p_t1t->ndef_msg_len);
     return (NFC_STATUS_FAILED);
@@ -2411,24 +2435,24 @@ tNFC_STATUS RW_T1tWriteNDef(uint16_t msg_len, uint8_t* p_msg) {
   uint16_t init_ndef_msg_offset;
 
   if (p_t1t->state != RW_T1T_STATE_IDLE) {
-    RW_TRACE_WARNING1("RW_T1tWriteNDef - Busy - State: %u", p_t1t->state);
+    LOG(WARNING) << StringPrintf("RW_T1tWriteNDef - Busy - State: %u", p_t1t->state);
     return (NFC_STATUS_FAILED);
   }
 
   /* Check HR0 if NDEF supported by the tag */
   if (((p_t1t->hr[0]) & 0xF0) != T1T_NDEF_SUPPORTED) {
-    RW_TRACE_ERROR0("RW_T1tWriteNDef - Error: NDEF not supported by the tag");
+    LOG(ERROR) << StringPrintf("RW_T1tWriteNDef - Error: NDEF not supported by the tag");
     return (NFC_STATUS_REFUSED);
   }
 
   if ((p_t1t->tag_attribute != RW_T1_TAG_ATTRB_READ_WRITE) &&
       (p_t1t->tag_attribute != RW_T1_TAG_ATTRB_INITIALIZED_NDEF)) {
-    RW_TRACE_ERROR0("RW_T1tWriteNDef - Tag cannot update NDEF");
+    LOG(ERROR) << StringPrintf("RW_T1tWriteNDef - Tag cannot update NDEF");
     return (NFC_STATUS_REFUSED);
   }
 
   if (msg_len > p_t1t->max_ndef_msg_len) {
-    RW_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "RW_T1tWriteNDef - Cannot write NDEF of size greater than %u bytes",
         p_t1t->max_ndef_msg_len);
     return (NFC_STATUS_REFUSED);
@@ -2516,7 +2540,7 @@ tNFC_STATUS RW_T1tSetTagReadOnly(bool b_hard_lock) {
   uint8_t num_locks;
 
   if (p_t1t->state != RW_T1T_STATE_IDLE) {
-    RW_TRACE_WARNING1("RW_T1tSetTagReadOnly - Busy - State: %u", p_t1t->state);
+    LOG(WARNING) << StringPrintf("RW_T1tSetTagReadOnly - Busy - State: %u", p_t1t->state);
     return (NFC_STATUS_BUSY);
   }
 
@@ -2547,47 +2571,4 @@ tNFC_STATUS RW_T1tSetTagReadOnly(bool b_hard_lock) {
   return status;
 }
 
-#if (BT_TRACE_VERBOSE == true)
-/*******************************************************************************
-**
-** Function         rw_t1t_get_sub_state_name
-**
-** Description      This function returns the sub_state name.
-**
-** NOTE             conditionally compiled to save memory.
-**
-** Returns          pointer to the name
-**
-*******************************************************************************/
-static char* rw_t1t_get_sub_state_name(uint8_t sub_state) {
-  switch (sub_state) {
-    case RW_T1T_SUBSTATE_NONE:
-      return ("NONE");
-    case RW_T1T_SUBSTATE_WAIT_READ_TLV_VALUE:
-      return ("EXTRACT_TLV_VALUE");
-    case RW_T1T_SUBSTATE_WAIT_READ_LOCKS:
-      return ("READING_LOCKS");
-    case RW_T1T_SUBSTATE_WAIT_READ_NDEF_BLOCK:
-      return ("READ_NDEF_FINAL_BLOCK");
-    case RW_T1T_SUBSTATE_WAIT_INVALIDATE_NDEF:
-      return ("INVALIDATING_NDEF");
-    case RW_T1T_SUBSTATE_WAIT_NDEF_WRITE:
-      return ("WRITE_NDEF_TLV_MESSAGE");
-    case RW_T1T_SUBSTATE_WAIT_NDEF_UPDATED:
-      return ("WAITING_RSP_FOR_LAST_NDEF_WRITE");
-    case RW_T1T_SUBSTATE_WAIT_VALIDATE_NDEF:
-      return ("VALIDATING_NDEF");
-    case RW_T1T_SUBSTATE_WAIT_SET_CC_RWA_RO:
-      return ("SET_RWA_RO");
-    case RW_T1T_SUBSTATE_WAIT_SET_ST_LOCK_BITS:
-      return ("SET_STATIC_LOCK_BITS");
-    case RW_T1T_SUBSTATE_WAIT_SET_DYN_LOCK_BITS:
-      return ("SET_DYNAMIC_LOCK_BITS");
-
-    default:
-      return ("???? UNKNOWN SUBSTATE");
-  }
-}
-#endif /* (BT_TRACE_VERBOSE == true) */
-
 #endif /* (RW_NDEF_INCLUDED == true) */
diff --git a/src/nfc/tags/rw_t2t.c b/src/nfc/tags/rw_t2t.cc
old mode 100644
new mode 100755
similarity index 89%
rename from src/nfc/tags/rw_t2t.c
rename to src/nfc/tags/rw_t2t.cc
index 2a952e2..2ad2114
--- a/src/nfc/tags/rw_t2t.c
+++ b/src/nfc/tags/rw_t2t.cc
@@ -20,7 +20,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -43,6 +43,10 @@
  *
  ******************************************************************************/
 #include <string.h>
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfc_target.h"
 #include "bt_types.h"
 
@@ -53,6 +57,10 @@
 #include "nfc_int.h"
 #include "gki.h"
 
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
+
 /* Static local functions */
 static void rw_t2t_proc_data(uint8_t conn_id, tNFC_DATA_CEVT* p_data);
 static tNFC_STATUS rw_t2t_send_cmd(uint8_t opcode, uint8_t* p_dat);
@@ -61,10 +69,8 @@ static void rw_t2t_process_frame_error(void);
 static void rw_t2t_handle_presence_check_rsp(tNFC_STATUS status);
 static void rw_t2t_resume_op(void);
 
-#if (BT_TRACE_VERBOSE == true)
-static char* rw_t2t_get_state_name(uint8_t state);
-static char* rw_t2t_get_substate_name(uint8_t substate);
-#endif
+static std::string rw_t2t_get_state_name(uint8_t state);
+static std::string rw_t2t_get_substate_name(uint8_t substate);
 
 /*******************************************************************************
 **
@@ -82,25 +88,20 @@ static void rw_t2t_proc_data(uint8_t conn_id, tNFC_DATA_CEVT* p_data) {
   bool b_notify = true;
   bool b_release = true;
   uint8_t* p;
-  tRW_READ_DATA evt_data = {0, NULL};
+  tRW_READ_DATA evt_data = {};
   tT2T_CMD_RSP_INFO* p_cmd_rsp_info =
       (tT2T_CMD_RSP_INFO*)rw_cb.tcb.t2t.p_cmd_rsp_info;
   tRW_DETECT_NDEF_DATA ndef_data;
-#if (BT_TRACE_VERBOSE == true)
   uint8_t begin_state = p_t2t->state;
-#endif
 
   if ((p_t2t->state == RW_T2T_STATE_IDLE) || (p_cmd_rsp_info == NULL)) {
-#if (BT_TRACE_VERBOSE == true)
-    RW_TRACE_DEBUG2("RW T2T Raw Frame: Len [0x%X] Status [%s]", p_pkt->len,
-                    NFC_GetStatusName(p_data->status));
-#else
-    RW_TRACE_DEBUG2("RW T2T Raw Frame: Len [0x%X] Status [0x%X]", p_pkt->len,
-                    p_data->status);
-#endif
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW T2T Raw Frame: Len [0x%X] Status [%s]", p_pkt->len,
+                    NFC_GetStatusName(p_data->status).c_str());
     evt_data.status = p_data->status;
     evt_data.p_data = p_pkt;
-    (*rw_cb.p_cback)(RW_T2T_RAW_FRAME_EVT, (void*)&evt_data);
+    tRW_DATA rw_data;
+    rw_data.data = evt_data;
+    (*rw_cb.p_cback)(RW_T2T_RAW_FRAME_EVT, &rw_data);
     return;
   }
 #if (RW_STATS_INCLUDED == true)
@@ -110,20 +111,15 @@ static void rw_t2t_proc_data(uint8_t conn_id, tNFC_DATA_CEVT* p_data) {
   /* Stop timer as response is received */
   nfc_stop_quick_timer(&p_t2t->t2_timer);
 
-  RW_TRACE_EVENT2("RW RECV [%s]:0x%x RSP", t2t_info_to_str(p_cmd_rsp_info),
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW RECV [%s]:0x%x RSP", t2t_info_to_str(p_cmd_rsp_info),
                   p_cmd_rsp_info->opcode);
 
   if (((p_pkt->len != p_cmd_rsp_info->rsp_len) &&
        (p_pkt->len != p_cmd_rsp_info->nack_rsp_len) &&
        (p_t2t->substate != RW_T2T_SUBSTATE_WAIT_SELECT_SECTOR)) ||
       (p_t2t->state == RW_T2T_STATE_HALT)) {
-#if (BT_TRACE_VERBOSE == true)
-    RW_TRACE_ERROR1("T2T Frame error. state=%s ",
-                    rw_t2t_get_state_name(p_t2t->state));
-#else
-    RW_TRACE_ERROR1("T2T Frame error. state=0x%02X command=0x%02X ",
-                    p_t2t->state);
-#endif
+    LOG(ERROR) << StringPrintf("T2T Frame error. state=%s ",
+                    rw_t2t_get_state_name(p_t2t->state).c_str());
     if (p_t2t->state != RW_T2T_STATE_HALT) {
       /* Retrasmit the last sent command if retry-count < max retry */
       rw_t2t_process_frame_error();
@@ -137,7 +133,7 @@ static void rw_t2t_proc_data(uint8_t conn_id, tNFC_DATA_CEVT* p_data) {
   /* Assume the data is just the response byte sequence */
   p = (uint8_t*)(p_pkt + 1) + p_pkt->offset;
 
-  RW_TRACE_EVENT4(
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "rw_t2t_proc_data State: %u  conn_id: %u  len: %u  data[0]: 0x%02x",
       p_t2t->state, conn_id, p_pkt->len, *p);
 
@@ -151,7 +147,7 @@ static void rw_t2t_proc_data(uint8_t conn_id, tNFC_DATA_CEVT* p_data) {
       else
         evt_data.status = NFC_STATUS_FAILED;
     } else {
-      RW_TRACE_EVENT1(
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "rw_t2t_proc_data - Received NACK response(0x%x) to SEC-SELCT CMD",
           (*p & 0x0f));
       evt_data.status = NFC_STATUS_REJECTED;
@@ -165,7 +161,7 @@ static void rw_t2t_proc_data(uint8_t conn_id, tNFC_DATA_CEVT* p_data) {
     evt_data.p_data = p_pkt;
     if (p_t2t->state == RW_T2T_STATE_READ) b_release = false;
 
-    RW_TRACE_EVENT1("rw_t2t_proc_data - Received NACK response(0x%x)",
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t2t_proc_data - Received NACK response(0x%x)",
                     (*p & 0x0f));
 
     if (!p_t2t->check_tag_halt) {
@@ -236,23 +232,25 @@ static void rw_t2t_proc_data(uint8_t conn_id, tNFC_DATA_CEVT* p_data) {
       ndef_data.cur_size = 0;
       /* Move back to idle state */
       rw_t2t_handle_op_complete();
-      (*rw_cb.p_cback)(rw_event, (void*)&ndef_data);
+      tRW_DATA rw_data;
+      rw_data.ndef = ndef_data;
+      (*rw_cb.p_cback)(rw_event, &rw_data);
     } else {
       /* Move back to idle state */
       rw_t2t_handle_op_complete();
-      (*rw_cb.p_cback)(rw_event, (void*)&evt_data);
+      tRW_DATA rw_data;
+      rw_data.data = evt_data;
+      (*rw_cb.p_cback)(rw_event, &rw_data);
     }
   }
 
   if (b_release) GKI_freebuf(p_pkt);
 
-#if (BT_TRACE_VERBOSE == true)
   if (begin_state != p_t2t->state) {
-    RW_TRACE_DEBUG2("RW T2T state changed:<%s> -> <%s>",
-                    rw_t2t_get_state_name(begin_state),
-                    rw_t2t_get_state_name(p_t2t->state));
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW T2T state changed:<%s> -> <%s>",
+                    rw_t2t_get_state_name(begin_state).c_str(),
+                    rw_t2t_get_state_name(p_t2t->state).c_str());
   }
-#endif
 }
 
 /*******************************************************************************
@@ -269,7 +267,7 @@ void rw_t2t_conn_cback(uint8_t conn_id, tNFC_CONN_EVT event,
   tRW_T2T_CB* p_t2t = &rw_cb.tcb.t2t;
   tRW_READ_DATA evt_data;
 
-  RW_TRACE_DEBUG2("rw_t2t_conn_cback: conn_id=%i, evt=%i", conn_id, event);
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t2t_conn_cback: conn_id=%i, evt=%i", conn_id, event);
   /* Only handle static conn_id */
   if (conn_id != NFC_RF_CONN_ID) {
     return;
@@ -316,7 +314,7 @@ void rw_t2t_conn_cback(uint8_t conn_id, tNFC_CONN_EVT event,
         }
       }
     /* Data event with error status...fall through to NFC_ERROR_CEVT case */
-
+    [[fallthrough]];
     case NFC_ERROR_CEVT:
       if ((p_t2t->state == RW_T2T_STATE_NOT_ACTIVATED) ||
           (p_t2t->state == RW_T2T_STATE_IDLE) ||
@@ -332,7 +330,9 @@ void rw_t2t_conn_cback(uint8_t conn_id, tNFC_CONN_EVT event,
           evt_data.status = NFC_STATUS_FAILED;
 
         evt_data.p_data = NULL;
-        (*rw_cb.p_cback)(RW_T2T_INTF_ERROR_EVT, (void*)&evt_data);
+        tRW_DATA rw_data;
+        rw_data.data = evt_data;
+        (*rw_cb.p_cback)(RW_T2T_INTF_ERROR_EVT, &rw_data);
         break;
       }
       nfc_stop_quick_timer(&p_t2t->t2_timer);
@@ -401,25 +401,18 @@ tNFC_STATUS rw_t2t_send_cmd(uint8_t opcode, uint8_t* p_dat) {
       /* Update stats */
       rw_main_update_tx_stats(p_data->len, false);
 #endif
-      RW_TRACE_EVENT2("RW SENT [%s]:0x%x CMD", t2t_info_to_str(p_cmd_rsp_info),
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW SENT [%s]:0x%x CMD", t2t_info_to_str(p_cmd_rsp_info),
                       p_cmd_rsp_info->opcode);
 
       status = NFC_SendData(NFC_RF_CONN_ID, p_data);
       if (status == NFC_STATUS_OK) {
-        p_t2t->last_cmd_sent = opcode;
         nfc_start_quick_timer(
             &p_t2t->t2_timer, NFC_TTYPE_RW_T2T_RESPONSE,
             (RW_T2T_TOUT_RESP * QUICK_TIMER_TICKS_PER_SEC) / 1000);
       } else {
-#if (BT_TRACE_VERBOSE == true)
-        RW_TRACE_ERROR2("T2T NFC Send data failed. state=%s substate=%s ",
-                        rw_t2t_get_state_name(p_t2t->state),
-                        rw_t2t_get_substate_name(p_t2t->substate));
-#else
-        RW_TRACE_ERROR2(
-            "T2T NFC Send data failed. state=0x%02X substate=0x%02X ",
-            p_t2t->state, p_t2t->substate);
-#endif
+        LOG(ERROR) << StringPrintf("T2T NFC Send data failed. state=%s substate=%s ",
+                        rw_t2t_get_state_name(p_t2t->state).c_str(),
+                        rw_t2t_get_substate_name(p_t2t->substate).c_str());
       }
     } else {
       status = NFC_STATUS_NO_BUFFERS;
@@ -437,10 +430,9 @@ tNFC_STATUS rw_t2t_send_cmd(uint8_t opcode, uint8_t* p_dat) {
 ** Returns          none
 **
 *******************************************************************************/
-void rw_t2t_process_timeout(TIMER_LIST_ENT* p_tle) {
+void rw_t2t_process_timeout() {
   tRW_READ_DATA evt_data;
   tRW_T2T_CB* p_t2t = &rw_cb.tcb.t2t;
-  (void)p_tle;
 
   if (p_t2t->state == RW_T2T_STATE_CHECK_PRESENCE) {
     if (p_t2t->check_tag_halt) {
@@ -461,18 +453,16 @@ void rw_t2t_process_timeout(TIMER_LIST_ENT* p_tle) {
       rw_t2t_handle_op_complete();
       evt_data.status = NFC_STATUS_OK;
       evt_data.p_data = NULL;
-      (*rw_cb.p_cback)(RW_T2T_SELECT_CPLT_EVT, (void*)&evt_data);
+      tRW_DATA rw_data;
+      rw_data.data = evt_data;
+      (*rw_cb.p_cback)(RW_T2T_SELECT_CPLT_EVT, &rw_data);
     } else {
       /* Resume operation from where we stopped before sector change */
       rw_t2t_resume_op();
     }
   } else if (p_t2t->state != RW_T2T_STATE_IDLE) {
-#if (BT_TRACE_VERBOSE == true)
-    RW_TRACE_ERROR1("T2T timeout. state=%s ",
-                    rw_t2t_get_state_name(p_t2t->state));
-#else
-    RW_TRACE_ERROR1("T2T timeout. state=0x%02X ", p_t2t->state);
-#endif
+    LOG(ERROR) << StringPrintf("T2T timeout. state=%s ",
+                    rw_t2t_get_state_name(p_t2t->state).c_str());
     /* Handle timeout error as no response to the command sent */
     rw_t2t_process_error();
   }
@@ -516,14 +506,14 @@ static void rw_t2t_process_error(void) {
       (tT2T_CMD_RSP_INFO*)rw_cb.tcb.t2t.p_cmd_rsp_info;
   tRW_DETECT_NDEF_DATA ndef_data;
 
-  RW_TRACE_DEBUG1("rw_t2t_process_error () State: %u", p_t2t->state);
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t2t_process_error () State: %u", p_t2t->state);
 
   /* Retry sending command if retry-count < max */
   if ((!p_t2t->check_tag_halt) && (rw_cb.cur_retry < RW_MAX_RETRIES)) {
     /* retry sending the command */
     rw_cb.cur_retry++;
 
-    RW_TRACE_DEBUG2("T2T retransmission attempt %i of %i", rw_cb.cur_retry,
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("T2T retransmission attempt %i of %i", rw_cb.cur_retry,
                     RW_MAX_RETRIES);
 
     /* allocate a new buffer for message */
@@ -547,9 +537,9 @@ static void rw_t2t_process_error(void) {
     }
   } else {
     if (p_t2t->check_tag_halt) {
-      RW_TRACE_DEBUG0("T2T Went to HALT State!");
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("T2T Went to HALT State!");
     } else {
-      RW_TRACE_DEBUG1("T2T maximum retransmission attempts reached (%i)",
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("T2T maximum retransmission attempts reached (%i)",
                       RW_MAX_RETRIES);
     }
   }
@@ -576,14 +566,18 @@ static void rw_t2t_process_error(void) {
     /* If not Halt move to idle state */
     rw_t2t_handle_op_complete();
 
-    (*rw_cb.p_cback)(rw_event, (void*)&ndef_data);
+    tRW_DATA rw_data;
+    rw_data.ndef = ndef_data;
+    (*rw_cb.p_cback)(rw_event, &rw_data);
   } else {
     evt_data.p_data = NULL;
     /* If activated and not Halt move to idle state */
     if (p_t2t->state != RW_T2T_STATE_NOT_ACTIVATED) rw_t2t_handle_op_complete();
 
     p_t2t->substate = RW_T2T_SUBSTATE_NONE;
-    (*rw_cb.p_cback)(rw_event, (void*)&evt_data);
+    tRW_DATA rw_data;
+    rw_data.data = evt_data;
+    (*rw_cb.p_cback)(rw_event, &rw_data);
   }
 }
 
@@ -597,13 +591,13 @@ static void rw_t2t_process_error(void) {
 **
 *****************************************************************************/
 void rw_t2t_handle_presence_check_rsp(tNFC_STATUS status) {
-  tRW_READ_DATA evt_data;
+  tRW_DATA rw_data;
 
   /* Notify, Tag is present or not */
-  evt_data.status = status;
+  rw_data.data.status = status;
   rw_t2t_handle_op_complete();
 
-  (*rw_cb.p_cback)(RW_T2T_PRESENCE_CHECK_EVT, (void*)&evt_data);
+  (*rw_cb.p_cback)(RW_T2T_PRESENCE_CHECK_EVT, &rw_data);
 }
 
 /*******************************************************************************
@@ -657,7 +651,9 @@ static void rw_t2t_resume_op(void) {
       evt_data.status = NFC_STATUS_FAILED;
       event = rw_t2t_info_to_event(p_cmd_rsp_info);
       rw_t2t_handle_op_complete();
-      (*rw_cb.p_cback)(event, (void*)&evt_data);
+      tRW_DATA rw_data;
+      rw_data.data = evt_data;
+      (*rw_cb.p_cback)(event, &rw_data);
     }
   }
 }
@@ -680,7 +676,7 @@ tNFC_STATUS rw_t2t_sector_change(uint8_t sector) {
 
   p_data = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
   if (p_data == NULL) {
-    RW_TRACE_ERROR0("rw_t2t_sector_change - No buffer");
+    LOG(ERROR) << StringPrintf("rw_t2t_sector_change - No buffer");
     return (NFC_STATUS_NO_BUFFERS);
   }
 
@@ -700,12 +696,12 @@ tNFC_STATUS rw_t2t_sector_change(uint8_t sector) {
     p_t2t->p_cmd_rsp_info = NULL;
     p_t2t->substate = RW_T2T_SUBSTATE_WAIT_SELECT_SECTOR;
 
-    RW_TRACE_EVENT0("rw_t2t_sector_change Sent Second Command");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t2t_sector_change Sent Second Command");
     nfc_start_quick_timer(
         &p_t2t->t2_timer, NFC_TTYPE_RW_T2T_RESPONSE,
         (RW_T2T_SEC_SEL_TOUT_RESP * QUICK_TIMER_TICKS_PER_SEC) / 1000);
   } else {
-    RW_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "rw_t2t_sector_change Send failed at rw_t2t_send_cmd, error: %u",
         status);
   }
@@ -763,7 +759,7 @@ tNFC_STATUS rw_t2t_read(uint16_t block) {
   status = rw_t2t_send_cmd(T2T_CMD_READ, (uint8_t*)read_cmd);
   if (status == NFC_STATUS_OK) {
     p_t2t->block_read = block;
-    RW_TRACE_EVENT1("rw_t2t_read Sent Command for Block: %u", block);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t2t_read Sent Command for Block: %u", block);
   }
 
   return status;
@@ -820,7 +816,7 @@ tNFC_STATUS rw_t2t_write(uint16_t block, uint8_t* p_write_data) {
   /* Send Write command as sector change is not needed */
   status = rw_t2t_send_cmd(T2T_CMD_WRITE, write_cmd);
   if (status == NFC_STATUS_OK) {
-    RW_TRACE_EVENT1("rw_t2t_write Sent Command for Block: %u", block);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t2t_write Sent Command for Block: %u", block);
   }
 
   return status;
@@ -845,7 +841,7 @@ tNFC_STATUS rw_t2t_select(void) {
   if (p_t2t->p_cur_cmd_buf == NULL) {
     p_t2t->p_cur_cmd_buf = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
     if (p_t2t->p_cur_cmd_buf == NULL) {
-      RW_TRACE_ERROR0(
+      LOG(ERROR) << StringPrintf(
           "rw_t2t_select: unable to allocate buffer for retransmission");
       return (NFC_STATUS_FAILED);
     }
@@ -854,7 +850,7 @@ tNFC_STATUS rw_t2t_select(void) {
   if (p_t2t->p_sec_cmd_buf == NULL) {
     p_t2t->p_sec_cmd_buf = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
     if (p_t2t->p_sec_cmd_buf == NULL) {
-      RW_TRACE_ERROR0(
+      LOG(ERROR) << StringPrintf(
           "rw_t2t_select: unable to allocate buffer used during sector change");
       return (NFC_STATUS_FAILED);
     }
@@ -911,7 +907,7 @@ tNFC_STATUS RW_T2tPresenceCheck(void) {
   tRW_CB* p_rw_cb = &rw_cb;
   uint8_t sector_blk = 0; /* block 0 of current sector */
 
-  RW_TRACE_API0("RW_T2tPresenceCheck");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_T2tPresenceCheck");
 
   /* If RW_SelectTagType was not called (no conn_callback) return failure */
   if (!p_rw_cb->p_cback) {
@@ -953,7 +949,7 @@ tNFC_STATUS RW_T2tRead(uint16_t block) {
   tNFC_STATUS status;
 
   if (p_t2t->state != RW_T2T_STATE_IDLE) {
-    RW_TRACE_ERROR1("Error: Type 2 tag not activated or Busy - State: %u",
+    LOG(ERROR) << StringPrintf("Error: Type 2 tag not activated or Busy - State: %u",
                     p_t2t->state);
     return (NFC_STATUS_FAILED);
   }
@@ -961,7 +957,7 @@ tNFC_STATUS RW_T2tRead(uint16_t block) {
   status = rw_t2t_read(block);
   if (status == NFC_STATUS_OK) {
     p_t2t->state = RW_T2T_STATE_READ;
-    RW_TRACE_EVENT0("RW_T2tRead Sent Read command");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_T2tRead Sent Read command");
   }
 
   return status;
@@ -985,7 +981,7 @@ tNFC_STATUS RW_T2tWrite(uint16_t block, uint8_t* p_write_data) {
   tNFC_STATUS status;
 
   if (p_t2t->state != RW_T2T_STATE_IDLE) {
-    RW_TRACE_ERROR1("Error: Type 2 tag not activated or Busy - State: %u",
+    LOG(ERROR) << StringPrintf("Error: Type 2 tag not activated or Busy - State: %u",
                     p_t2t->state);
     return (NFC_STATUS_FAILED);
   }
@@ -997,7 +993,7 @@ tNFC_STATUS RW_T2tWrite(uint16_t block, uint8_t* p_write_data) {
       p_t2t->b_read_hdr = false;
     else if (block < (T2T_FIRST_DATA_BLOCK + T2T_READ_BLOCKS))
       p_t2t->b_read_data = false;
-    RW_TRACE_EVENT0("RW_T2tWrite Sent Write command");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_T2tWrite Sent Write command");
   }
 
   return status;
@@ -1027,13 +1023,13 @@ tNFC_STATUS RW_T2tSectorSelect(uint8_t sector) {
   uint8_t sector_byte2[1];
 
   if (p_t2t->state != RW_T2T_STATE_IDLE) {
-    RW_TRACE_ERROR1("Error: Type 2 tag not activated or Busy - State: %u",
+    LOG(ERROR) << StringPrintf("Error: Type 2 tag not activated or Busy - State: %u",
                     p_t2t->state);
     return (NFC_STATUS_FAILED);
   }
 
   if (sector >= T2T_MAX_SECTOR) {
-    RW_TRACE_ERROR2(
+    LOG(ERROR) << StringPrintf(
         "RW_T2tSectorSelect - Invalid sector: %u, T2 Max supported sector "
         "value: %u",
         sector, T2T_MAX_SECTOR - 1);
@@ -1048,13 +1044,12 @@ tNFC_STATUS RW_T2tSectorSelect(uint8_t sector) {
     p_t2t->select_sector = sector;
     p_t2t->substate = RW_T2T_SUBSTATE_WAIT_SELECT_SECTOR_SUPPORT;
 
-    RW_TRACE_EVENT0("RW_T2tSectorSelect Sent Sector select first command");
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_T2tSectorSelect Sent Sector select first command");
   }
 
   return status;
 }
 
-#if (BT_TRACE_VERBOSE == true)
 /*******************************************************************************
 **
 ** Function         rw_t2t_get_state_name
@@ -1066,7 +1061,7 @@ tNFC_STATUS RW_T2tSectorSelect(uint8_t sector) {
 ** Returns          pointer to the name
 **
 *******************************************************************************/
-static char* rw_t2t_get_state_name(uint8_t state) {
+static std::string rw_t2t_get_state_name(uint8_t state) {
   switch (state) {
     case RW_T2T_STATE_NOT_ACTIVATED:
       return ("NOT_ACTIVATED");
@@ -1104,7 +1099,7 @@ static char* rw_t2t_get_state_name(uint8_t state) {
 ** Returns          pointer to the name
 **
 *******************************************************************************/
-static char* rw_t2t_get_substate_name(uint8_t substate) {
+static std::string rw_t2t_get_substate_name(uint8_t substate) {
   switch (substate) {
     case RW_T2T_SUBSTATE_NONE:
       return ("RW_T2T_SUBSTATE_NONE");
@@ -1150,5 +1145,3 @@ static char* rw_t2t_get_substate_name(uint8_t substate) {
       return ("???? UNKNOWN SUBSTATE");
   }
 }
-
-#endif /* (BT_TRACE_VERBOSE == true) */
diff --git a/src/nfc/tags/rw_t2t_ndef.c b/src/nfc/tags/rw_t2t_ndef.cc
old mode 100644
new mode 100755
similarity index 97%
rename from src/nfc/tags/rw_t2t_ndef.c
rename to src/nfc/tags/rw_t2t_ndef.cc
index 3741755..42bccbf
--- a/src/nfc/tags/rw_t2t_ndef.c
+++ b/src/nfc/tags/rw_t2t_ndef.cc
@@ -29,14 +29,20 @@
  *
  ******************************************************************************/
 #include <string.h>
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfc_target.h"
 
 #include "nfc_api.h"
 #include "nci_hmsgs.h"
 #include "rw_api.h"
 #include "rw_int.h"
-#include "nfc_int.h"
-#include "gki.h"
+
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
 
 #if (RW_NDEF_INCLUDED == true)
 
@@ -121,7 +127,7 @@ void rw_t2t_handle_rsp(uint8_t* p_data) {
           if (p_t2t->tag_hdr[T2T_CC0_NMN_BYTE] == T2T_CC0_NMN) {
             rw_t2t_handle_cc_read_rsp();
           } else {
-            RW_TRACE_WARNING3(
+            LOG(WARNING) << StringPrintf(
                 "NDEF Detection failed!, CC[0]: 0x%02x, CC[1]: 0x%02x, CC[3]: "
                 "0x%02x",
                 p_t2t->tag_hdr[T2T_CC0_NMN_BYTE],
@@ -251,13 +257,11 @@ static void rw_t2t_handle_cc_read_rsp(void) {
 *******************************************************************************/
 static void rw_t2t_ntf_tlv_detect_complete(tNFC_STATUS status) {
   tRW_T2T_CB* p_t2t = &rw_cb.tcb.t2t;
-  tRW_DETECT_NDEF_DATA ndef_data = {.status = 0};
-  tRW_DETECT_TLV_DATA tlv_data;
-  tRW_T2T_DETECT evt_data;
   uint8_t xx;
 
   if (p_t2t->tlv_detect == TAG_NDEF_TLV) {
     /* Notify upper layer the result of NDEF detect op */
+    tRW_DETECT_NDEF_DATA ndef_data = {};
     ndef_data.status = status;
     ndef_data.protocol = NFC_PROTOCOL_T2T;
     ndef_data.flags = rw_t2t_get_ndef_flags();
@@ -281,14 +285,21 @@ static void rw_t2t_ntf_tlv_detect_complete(tNFC_STATUS status) {
     }
 
     rw_t2t_handle_op_complete();
-    (*rw_cb.p_cback)(RW_T2T_NDEF_DETECT_EVT, (void*)&ndef_data);
+    tRW_DATA rw_data;
+    rw_data.ndef = ndef_data;
+    (*rw_cb.p_cback)(RW_T2T_NDEF_DETECT_EVT, &rw_data);
   } else if (p_t2t->tlv_detect == TAG_PROPRIETARY_TLV) {
+    tRW_T2T_DETECT evt_data;
     evt_data.msg_len = p_t2t->prop_msg_len;
     evt_data.status = status;
     rw_t2t_handle_op_complete();
-    (*rw_cb.p_cback)(RW_T2T_TLV_DETECT_EVT, (void*)&evt_data);
+    tRW_DATA rw_data;
+    rw_data.t2t_detect = evt_data;
+    /* FIXME: Unsafe cast */
+    (*rw_cb.p_cback)(RW_T2T_TLV_DETECT_EVT, &rw_data);
   } else {
     /* Notify upper layer the result of Lock/Mem TLV detect op */
+    tRW_DETECT_TLV_DATA tlv_data;
     tlv_data.protocol = NFC_PROTOCOL_T2T;
     if (p_t2t->tlv_detect == TAG_LOCK_CTRL_TLV) {
       tlv_data.num_bytes = p_t2t->num_lockbytes;
@@ -300,7 +311,9 @@ static void rw_t2t_ntf_tlv_detect_complete(tNFC_STATUS status) {
     }
     tlv_data.status = status;
     rw_t2t_handle_op_complete();
-    (*rw_cb.p_cback)(RW_T2T_TLV_DETECT_EVT, (void*)&tlv_data);
+    tRW_DATA rw_data;
+    rw_data.tlv = tlv_data;
+    (*rw_cb.p_cback)(RW_T2T_TLV_DETECT_EVT, &rw_data);
   }
 }
 
@@ -651,7 +664,7 @@ static void rw_t2t_handle_tlv_detect_rsp(uint8_t* p_data) {
               p_t2t->tlv_value[2 - p_t2t->bytes_count] = p_data[offset];
               if (p_t2t->bytes_count == 0) {
                 if (p_t2t->num_mem_tlvs >= RW_T2T_MAX_MEM_TLVS) {
-                  RW_TRACE_ERROR0(
+                  LOG(ERROR) << StringPrintf(
                       "rw_t2t_handle_tlv_detect_rsp - Maximum buffer allocated "
                       "for Memory tlv has reached");
                   failed = true;
@@ -1246,7 +1259,10 @@ tNFC_STATUS rw_t2t_write_ndef_next_block(uint16_t block, uint16_t msg_len,
              p_t2t->work_offset < p_t2t->new_ndef_msg_len) {
         if (rw_t2t_is_lock_res_byte(
                 (uint16_t)((block * T2T_BLOCK_SIZE) + index)) == false) {
+          if(p_t2t->work_offset < 3)
+          {
           write_block[index] = length_field[p_t2t->work_offset];
+          }
           p_t2t->work_offset++;
         }
         index++;
@@ -1509,7 +1525,9 @@ static void rw_t2t_handle_ndef_read_rsp(uint8_t* p_data) {
     evt_data.status = failed ? NFC_STATUS_FAILED : NFC_STATUS_OK;
     evt_data.p_data = NULL;
     rw_t2t_handle_op_complete();
-    (*rw_cb.p_cback)(RW_T2T_NDEF_READ_EVT, (void*)&evt_data);
+    tRW_DATA rw_data;
+    rw_data.data = evt_data;
+    (*rw_cb.p_cback)(RW_T2T_NDEF_READ_EVT, &rw_data);
   }
 }
 
@@ -1675,7 +1693,9 @@ static void rw_t2t_handle_ndef_write_rsp(uint8_t* p_data) {
       p_t2t->ndef_msg_len = p_t2t->new_ndef_msg_len;
     }
     rw_t2t_handle_op_complete();
-    (*rw_cb.p_cback)(RW_T2T_NDEF_WRITE_EVT, (void*)&evt_data);
+    tRW_DATA rw_data;
+    rw_data.data = evt_data;
+    (*rw_cb.p_cback)(RW_T2T_NDEF_WRITE_EVT, &rw_data);
   }
 }
 
@@ -1720,7 +1740,6 @@ static void rw_t2t_handle_config_tag_readonly(uint8_t* p_data) {
   tNFC_STATUS status = NFC_STATUS_FAILED;
   bool b_notify = false;
   uint8_t write_block[T2T_BLOCK_SIZE];
-  tRW_DATA evt;
   bool b_pending = false;
   uint8_t read_lock = 0;
   uint8_t num_locks = 0;
@@ -1744,6 +1763,7 @@ static void rw_t2t_handle_config_tag_readonly(uint8_t* p_data) {
         b_notify = true;
         break;
       }
+      [[fallthrough]];
 
     /* Coverity: [false-POSITIVE error] intended fall through */
     /* Missing break statement between cases in switch statement */
@@ -1804,9 +1824,10 @@ static void rw_t2t_handle_config_tag_readonly(uint8_t* p_data) {
 
   if (status != NFC_STATUS_OK || b_notify) {
     /* Notify upper layer the result of Configuring Tag as Read only */
+    tRW_DATA evt;
     evt.status = status;
     rw_t2t_handle_op_complete();
-    (*rw_cb.p_cback)(RW_T2T_SET_TAG_RO_EVT, (tRW_DATA*)&evt);
+    (*rw_cb.p_cback)(RW_T2T_SET_TAG_RO_EVT, &evt);
   }
 }
 
@@ -1820,7 +1841,6 @@ static void rw_t2t_handle_config_tag_readonly(uint8_t* p_data) {
 **
 *******************************************************************************/
 static void rw_t2t_handle_format_tag_rsp(uint8_t* p_data) {
-  tRW_DATA evt;
   uint8_t* p;
   tRW_T2T_CB* p_t2t = &rw_cb.tcb.t2t;
   tNFC_STATUS status = NFC_STATUS_FAILED;
@@ -1890,6 +1910,7 @@ static void rw_t2t_handle_format_tag_rsp(uint8_t* p_data) {
         } else
           break;
       }
+      [[fallthrough]];
 
     /* falls through */
     case RW_T2T_SUBSTATE_WAIT_SET_LOCK_TLV:
@@ -1922,9 +1943,10 @@ static void rw_t2t_handle_format_tag_rsp(uint8_t* p_data) {
 
   if (status != NFC_STATUS_OK || b_notify) {
     /* Notify upper layer the result of Format op */
+    tRW_DATA evt;
     evt.status = status;
     rw_t2t_handle_op_complete();
-    (*rw_cb.p_cback)(RW_T2T_FORMAT_CPLT_EVT, (tRW_DATA*)&evt);
+    (*rw_cb.p_cback)(RW_T2T_FORMAT_CPLT_EVT, &evt);
   }
 }
 
@@ -2581,7 +2603,7 @@ tNFC_STATUS rw_t2t_format_tag(void) {
 
   p_ret = t2t_tag_init_data(p_t2t->tag_hdr[0], false, 0);
   if (p_ret == NULL) {
-    RW_TRACE_WARNING1(
+    LOG(WARNING) << StringPrintf(
         "rw_t2t_format_tag - Unknown Manufacturer ID: %u, Cannot Format the "
         "tag!",
         p_t2t->tag_hdr[0]);
@@ -2591,7 +2613,7 @@ tNFC_STATUS rw_t2t_format_tag(void) {
   if (p_t2t->tag_hdr[T2T_CC2_TMS_BYTE] != 0) {
     /* If OTP tag has valid NDEF Message, cannot format the tag */
     if ((p_t2t->ndef_msg_len > 0) && (p_ret->b_otp)) {
-      RW_TRACE_WARNING0(
+      LOG(WARNING) << StringPrintf(
           "rw_t2t_format_tag - Cannot Format a OTP tag with NDEF Message!");
       return (NFC_STATUS_FAILED);
     }
@@ -2602,7 +2624,7 @@ tNFC_STATUS rw_t2t_format_tag(void) {
          (p_t2t->tag_hdr[T2T_CC1_VNO_BYTE] != T2T_CC1_LEGACY_VNO) &&
          (p_t2t->tag_hdr[T2T_CC1_VNO_BYTE] != T2T_CC1_VNO) &&
          (p_t2t->tag_hdr[T2T_CC1_VNO_BYTE] != T2T_CC1_NEW_VNO))) {
-      RW_TRACE_WARNING0("rw_t2t_format_tag - Tag not blank to Format!");
+      LOG(WARNING) << StringPrintf("rw_t2t_format_tag - Tag not blank to Format!");
       return (NFC_STATUS_FAILED);
     } else {
       tms = p_t2t->tag_hdr[T2T_CC2_TMS_BYTE];
@@ -2653,7 +2675,7 @@ tNFC_STATUS rw_t2t_soft_lock_tag(void) {
 
   /* If CC block is read and cc3 is soft locked, reject the command */
   if ((p_t2t->tag_hdr[T2T_CC3_RWA_BYTE] & T2T_CC3_RWA_RO) == T2T_CC3_RWA_RO) {
-    RW_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "rw_t2t_soft_lock_tag: Error: Type 2 tag is in Read only state, CC3: "
         "%u",
         p_t2t->tag_hdr[T2T_CC3_RWA_BYTE]);
@@ -2668,7 +2690,7 @@ tNFC_STATUS rw_t2t_soft_lock_tag(void) {
 
     if ((p_t2t->tag_hdr[T2T_CC2_TMS_BYTE] != T2T_CC2_TMS_STATIC) &&
         (p_t2t->num_lockbytes == 0)) {
-      RW_TRACE_ERROR0(
+      LOG(ERROR) << StringPrintf(
           "rw_t2t_soft_lock_tag: Error: Lock TLV not detected! Cannot hard "
           "lock the tag");
       return (NFC_STATUS_FAILED);
@@ -2716,7 +2738,7 @@ tNFC_STATUS RW_T2tFormatNDef(void) {
   tNFC_STATUS status = NFC_STATUS_FAILED;
 
   if (p_t2t->state != RW_T2T_STATE_IDLE) {
-    RW_TRACE_WARNING1("RW_T2tFormatNDef - Tag not initialized/ Busy! State: %u",
+    LOG(WARNING) << StringPrintf("RW_T2tFormatNDef - Tag not initialized/ Busy! State: %u",
                       p_t2t->state);
     return (NFC_STATUS_FAILED);
   }
@@ -2760,21 +2782,21 @@ tNFC_STATUS RW_T2tLocateTlv(uint8_t tlv_type) {
   uint16_t block;
 
   if (p_t2t->state != RW_T2T_STATE_IDLE) {
-    RW_TRACE_ERROR1("Error: Type 2 tag not activated or Busy - State: %u",
+    LOG(ERROR) << StringPrintf("Error: Type 2 tag not activated or Busy - State: %u",
                     p_t2t->state);
     return (NFC_STATUS_BUSY);
   }
 
   if ((tlv_type != TAG_LOCK_CTRL_TLV) && (tlv_type != TAG_MEM_CTRL_TLV) &&
       (tlv_type != TAG_NDEF_TLV) && (tlv_type != TAG_PROPRIETARY_TLV)) {
-    RW_TRACE_API1("RW_T2tLocateTlv - Cannot search TLV: 0x%02x", tlv_type);
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_T2tLocateTlv - Cannot search TLV: 0x%02x", tlv_type);
     return (NFC_STATUS_FAILED);
   }
 
   if ((tlv_type == TAG_LOCK_CTRL_TLV) && (p_t2t->b_read_hdr) &&
       (p_t2t->tag_hdr[T2T_CC2_TMS_BYTE] == T2T_CC2_TMS_STATIC)) {
     p_t2t->b_read_hdr = false;
-    RW_TRACE_API1(
+    DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "RW_T2tLocateTlv - No Lock tlv in static structure tag, CC[0]: 0x%02x",
         p_t2t->tag_hdr[T2T_CC2_TMS_BYTE]);
     return (NFC_STATUS_FAILED);
@@ -2783,7 +2805,7 @@ tNFC_STATUS RW_T2tLocateTlv(uint8_t tlv_type) {
   if ((tlv_type == TAG_NDEF_TLV) && (p_t2t->b_read_hdr) &&
       (p_t2t->tag_hdr[T2T_CC0_NMN_BYTE] != T2T_CC0_NMN)) {
     p_t2t->b_read_hdr = false;
-    RW_TRACE_WARNING3(
+    LOG(WARNING) << StringPrintf(
         "RW_T2tLocateTlv - Invalid NDEF Magic Number!, CC[0]: 0x%02x, CC[1]: "
         "0x%02x, CC[3]: 0x%02x",
         p_t2t->tag_hdr[T2T_CC0_NMN_BYTE], p_t2t->tag_hdr[T2T_CC1_VNO_BYTE],
@@ -2884,25 +2906,25 @@ tNFC_STATUS RW_T2tReadNDef(uint8_t* p_buffer, uint16_t buf_len) {
   uint16_t block;
 
   if (p_t2t->state != RW_T2T_STATE_IDLE) {
-    RW_TRACE_ERROR1("Error: Type 2 tag not activated or Busy - State: %u",
+    LOG(ERROR) << StringPrintf("Error: Type 2 tag not activated or Busy - State: %u",
                     p_t2t->state);
     return (NFC_STATUS_FAILED);
   }
 
   if (p_t2t->ndef_status == T2T_NDEF_NOT_DETECTED) {
-    RW_TRACE_ERROR0("RW_T2tReadNDef - Error: NDEF detection not performed yet");
+    LOG(ERROR) << StringPrintf("RW_T2tReadNDef - Error: NDEF detection not performed yet");
     return (NFC_STATUS_FAILED);
   }
 
   if (buf_len < p_t2t->ndef_msg_len) {
-    RW_TRACE_WARNING2(
+    LOG(WARNING) << StringPrintf(
         "RW_T2tReadNDef - buffer size: %u  less than NDEF msg sise: %u",
         buf_len, p_t2t->ndef_msg_len);
     return (NFC_STATUS_FAILED);
   }
 
   if (!p_t2t->ndef_msg_len) {
-    RW_TRACE_WARNING1("RW_T2tReadNDef - NDEF Message length is zero ",
+    LOG(WARNING) << StringPrintf("RW_T2tReadNDef - NDEF Message length is zero %u",
                       p_t2t->ndef_msg_len);
     return (NFC_STATUS_NOT_INITIALIZED);
   }
@@ -2962,25 +2984,25 @@ tNFC_STATUS RW_T2tWriteNDef(uint16_t msg_len, uint8_t* p_msg) {
   tNFC_STATUS status = NFC_STATUS_OK;
 
   if (p_t2t->state != RW_T2T_STATE_IDLE) {
-    RW_TRACE_ERROR1("Error: Type 2 tag not activated or Busy - State: %u",
+    LOG(ERROR) << StringPrintf("Error: Type 2 tag not activated or Busy - State: %u",
                     p_t2t->state);
     return (NFC_STATUS_FAILED);
   }
 
   if (p_t2t->ndef_status == T2T_NDEF_NOT_DETECTED) {
-    RW_TRACE_ERROR0("RW_T2tWriteNDef - Error: NDEF detection not performed!");
+    LOG(ERROR) << StringPrintf("RW_T2tWriteNDef - Error: NDEF detection not performed!");
     return (NFC_STATUS_FAILED);
   }
 
   if (p_t2t->tag_hdr[T2T_CC3_RWA_BYTE] != T2T_CC3_RWA_RW) {
-    RW_TRACE_ERROR1("RW_T2tWriteNDef - Write access not granted - CC3: %u",
+    LOG(ERROR) << StringPrintf("RW_T2tWriteNDef - Write access not granted - CC3: %u",
                     p_t2t->tag_hdr[T2T_CC3_RWA_BYTE]);
     return (NFC_STATUS_REFUSED);
   }
 
   /* Check if there is enough memory on the tag */
   if (msg_len > p_t2t->max_ndef_msg_len) {
-    RW_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "RW_T2tWriteNDef - Cannot write NDEF of size greater than %u bytes",
         p_t2t->max_ndef_msg_len);
     return (NFC_STATUS_FAILED);
@@ -2991,7 +3013,7 @@ tNFC_STATUS RW_T2tWriteNDef(uint16_t msg_len, uint8_t* p_msg) {
   if ((p_t2t->ndef_msg_len > 0) &&
       ((p_ret = t2t_tag_init_data(p_t2t->tag_hdr[0], false, 0)) != NULL) &&
       (p_ret->b_otp)) {
-    RW_TRACE_WARNING0(
+    LOG(WARNING) << StringPrintf(
         "RW_T2tWriteNDef - Cannot Overwrite NDEF Message on a OTP tag!");
     return (NFC_STATUS_FAILED);
   }
@@ -3012,7 +3034,7 @@ tNFC_STATUS RW_T2tWriteNDef(uint16_t msg_len, uint8_t* p_msg) {
     if (offset <= T2T_READ_DATA_LEN)
       rw_t2t_handle_ndef_write_rsp(&p_t2t->tag_data[offset]);
     else {
-      RW_TRACE_WARNING0("tag_data offset exceeds the limit");
+      LOG(WARNING) << StringPrintf("tag_data offset exceeds the limit");
       return (NFC_STATUS_FAILED);
     }
   } else {
@@ -3043,7 +3065,7 @@ tNFC_STATUS RW_T2tSetTagReadOnly(bool b_hard_lock) {
   tRW_T2T_CB* p_t2t = &rw_cb.tcb.t2t;
 
   if (p_t2t->state != RW_T2T_STATE_IDLE) {
-    RW_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "RW_T2tSetTagReadOnly: Error: Type 2 tag not activated or Busy - "
         "State: %u",
         p_t2t->state);
diff --git a/src/nfc/tags/rw_t3t.c b/src/nfc/tags/rw_t3t.cc
old mode 100644
new mode 100755
similarity index 92%
rename from src/nfc/tags/rw_t3t.c
rename to src/nfc/tags/rw_t3t.cc
index 2f18030..aa040df
--- a/src/nfc/tags/rw_t3t.c
+++ b/src/nfc/tags/rw_t3t.cc
@@ -42,17 +42,22 @@
  *
  ******************************************************************************/
 #include <string.h>
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfc_target.h"
 #include "bt_types.h"
-#include "trace_api.h"
 
 #include "nfc_api.h"
 #include "nfc_int.h"
 #include "nci_hmsgs.h"
 #include "rw_api.h"
 #include "rw_int.h"
-#include "tags_int.h"
-#include "gki.h"
+
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
 
 /* Definitions for constructing t3t command messages */
 #define RW_T3T_FL_PADDING 0x01 /* Padding needed for last NDEF block */
@@ -140,14 +145,12 @@ enum {
                                   block-write to complete */
 };
 
-#if (BT_TRACE_VERBOSE == true)
-static char* rw_t3t_cmd_str(uint8_t cmd_id);
-static char* rw_t3t_state_str(uint8_t state_id);
-#endif
+static std::string rw_t3t_cmd_str(uint8_t cmd_id);
+static std::string rw_t3t_state_str(uint8_t state_id);
 
 /* Local static functions */
 static void rw_t3t_update_ndef_flag(uint8_t* p_flag);
-static tNFC_STATUS rw_t3t_unselect(uint8_t peer_nfcid2[]);
+static tNFC_STATUS rw_t3t_unselect();
 static NFC_HDR* rw_t3t_get_cmd_buf(void);
 static tNFC_STATUS rw_t3t_send_to_lower(NFC_HDR* p_msg);
 static void rw_t3t_handle_get_system_codes_cplt(void);
@@ -158,16 +161,11 @@ static void rw_t3t_handle_get_sc_poll_rsp(tRW_T3T_CB* p_cb, uint8_t nci_status,
 static void rw_t3t_handle_ndef_detect_poll_rsp(tRW_T3T_CB* p_cb,
                                                uint8_t nci_status,
                                                uint8_t num_responses,
-                                               uint8_t sensf_res_buf_size,
                                                uint8_t* p_sensf_res_buf);
 static void rw_t3t_handle_fmt_poll_rsp(tRW_T3T_CB* p_cb, uint8_t nci_status,
-                                       uint8_t num_responses,
-                                       uint8_t sensf_res_buf_size,
-                                       uint8_t* p_sensf_res_buf);
+                                       uint8_t num_responses);
 static void rw_t3t_handle_sro_poll_rsp(tRW_T3T_CB* p_cb, uint8_t nci_status,
-                                       uint8_t num_responses,
-                                       uint8_t sensf_res_buf_size,
-                                       uint8_t* p_sensf_res_buf);
+                                       uint8_t num_responses);
 
 /* Default NDEF attribute information block (used when formatting Felica-Lite
  * tags) */
@@ -275,7 +273,7 @@ void rw_t3t_process_error(tNFC_STATUS status) {
       /* retry sending the command */
       rw_cb.cur_retry++;
 
-      RW_TRACE_DEBUG2("T3T retransmission attempt %i of %i", rw_cb.cur_retry,
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("T3T retransmission attempt %i of %i", rw_cb.cur_retry,
                       RW_MAX_RETRIES);
 
       /* allocate a new buffer for message */
@@ -296,7 +294,7 @@ void rw_t3t_process_error(tNFC_STATUS status) {
         }
       }
     } else {
-      RW_TRACE_DEBUG1("T3T maximum retransmission attempts reached (%i)",
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("T3T maximum retransmission attempts reached (%i)",
                       RW_MAX_RETRIES);
     }
 
@@ -338,7 +336,7 @@ void rw_t3t_process_error(tNFC_STATUS status) {
 **
 *******************************************************************************/
 void rw_t3t_start_poll_timer(tRW_T3T_CB* p_cb) {
-  RW_TRACE_DEBUG1 ("%s: starting t3t poll timer", __func__);
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: starting t3t poll timer", __func__);
   nfc_start_quick_timer(&p_cb->poll_timer, NFC_TTYPE_RW_T3T_RESPONSE,
                         RW_T3T_POLL_CMD_TIMEOUT_TICKS);
 }
@@ -355,7 +353,7 @@ void rw_t3t_start_poll_timer(tRW_T3T_CB* p_cb) {
 *******************************************************************************/
 void rw_t3t_stop_poll_timer (tRW_T3T_CB *p_cb)
 {
-    RW_TRACE_DEBUG1 ("%s: stopping t3t poll timer", __func__);
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("%s: stopping t3t poll timer", __func__);
     if(p_cb->poll_timer.in_use)
         nfc_stop_quick_timer (&p_cb->poll_timer);
 }
@@ -388,7 +386,7 @@ void rw_t3t_handle_nci_poll_ntf(uint8_t nci_status, uint8_t num_responses,
     p_cb->flags &= ~RW_T3T_FL_W4_PRESENCE_CHECK_POLL_RSP;
     evt_data.status = nci_status;
     p_cb->rw_state = RW_T3T_STATE_IDLE;
-    (*(rw_cb.p_cback))(RW_T3T_PRESENCE_CHECK_EVT, (tRW_DATA*)&evt_data);
+    (*(rw_cb.p_cback))(RW_T3T_PRESENCE_CHECK_EVT, &evt_data);
   } else if (p_cb->flags & RW_T3T_FL_W4_GET_SC_POLL_RSP) {
     /* Handle POLL ntf in response to get system codes */
     p_cb->flags &= ~RW_T3T_FL_W4_GET_SC_POLL_RSP;
@@ -397,18 +395,15 @@ void rw_t3t_handle_nci_poll_ntf(uint8_t nci_status, uint8_t num_responses,
   } else if (p_cb->flags & RW_T3T_FL_W4_FMT_FELICA_LITE_POLL_RSP) {
     /* Handle POLL ntf in response to get system codes */
     p_cb->flags &= ~RW_T3T_FL_W4_FMT_FELICA_LITE_POLL_RSP;
-    rw_t3t_handle_fmt_poll_rsp(p_cb, nci_status, num_responses,
-                               sensf_res_buf_size, p_sensf_res_buf);
+    rw_t3t_handle_fmt_poll_rsp(p_cb, nci_status, num_responses);
   } else if (p_cb->flags & RW_T3T_FL_W4_SRO_FELICA_LITE_POLL_RSP) {
     /* Handle POLL ntf in response to get system codes */
     p_cb->flags &= ~RW_T3T_FL_W4_SRO_FELICA_LITE_POLL_RSP;
-    rw_t3t_handle_sro_poll_rsp(p_cb, nci_status, num_responses,
-                               sensf_res_buf_size, p_sensf_res_buf);
+    rw_t3t_handle_sro_poll_rsp(p_cb, nci_status, num_responses);
   } else if (p_cb->flags & RW_T3T_FL_W4_NDEF_DETECT_POLL_RSP) {
     /* Handle POLL ntf in response to ndef detection */
     p_cb->flags &= ~RW_T3T_FL_W4_NDEF_DETECT_POLL_RSP;
-    rw_t3t_handle_ndef_detect_poll_rsp(p_cb, nci_status, num_responses,
-                                       sensf_res_buf_size, p_sensf_res_buf);
+    rw_t3t_handle_ndef_detect_poll_rsp(p_cb, nci_status, num_responses,p_sensf_res_buf);
   } else {
     /* Handle POLL ntf in response to RW_T3tPoll */
     evt_data.t3t_poll.status = nci_status;
@@ -442,10 +437,10 @@ void rw_t3t_handle_get_system_codes_cplt(void) {
   evt_data.t3t_sc.num_system_codes = p_cb->num_system_codes;
   evt_data.t3t_sc.p_system_codes = p_cb->system_codes;
 
-  RW_TRACE_DEBUG1("rw_t3t_handle_get_system_codes_cplt, number of systems: %i",
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t3t_handle_get_system_codes_cplt, number of systems: %i",
                   evt_data.t3t_sc.num_system_codes);
   for (i = 0; i < evt_data.t3t_sc.num_system_codes; i++) {
-    RW_TRACE_DEBUG2("   system %i: %04X", i, evt_data.t3t_sc.p_system_codes[i]);
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("   system %i: %04X", i, evt_data.t3t_sc.p_system_codes[i]);
   }
 
   p_cb->rw_state = RW_T3T_STATE_IDLE;
@@ -520,19 +515,14 @@ void rw_t3t_process_timeout(TIMER_LIST_ENT* p_tle) {
   /* Check which timer timed out */
   if (p_tle == &p_cb->timer) {
 /* UPDATE/CHECK response timeout */
-#if (BT_TRACE_VERBOSE == true)
-    RW_TRACE_ERROR3("T3T timeout. state=%s cur_cmd=0x%02X (%s)",
-                    rw_t3t_state_str(rw_cb.tcb.t3t.rw_state),
+    LOG(ERROR) << StringPrintf("T3T timeout. state=%s cur_cmd=0x%02X (%s)",
+                    rw_t3t_state_str(rw_cb.tcb.t3t.rw_state).c_str(),
                     rw_cb.tcb.t3t.cur_cmd,
-                    rw_t3t_cmd_str(rw_cb.tcb.t3t.cur_cmd));
-#else
-    RW_TRACE_ERROR2("T3T timeout. state=0x%02X cur_cmd=0x%02X",
-                    rw_cb.tcb.t3t.rw_state, rw_cb.tcb.t3t.cur_cmd);
-#endif
+                    rw_t3t_cmd_str(rw_cb.tcb.t3t.cur_cmd).c_str());
 
     rw_t3t_process_error(NFC_STATUS_TIMEOUT);
   } else {
-    RW_TRACE_ERROR0("T3T POLL timeout.");
+    LOG(ERROR) << StringPrintf("T3T POLL timeout.");
 
     /* POLL response timeout */
     if (p_cb->flags & RW_T3T_FL_W4_PRESENCE_CHECK_POLL_RSP) {
@@ -540,7 +530,7 @@ void rw_t3t_process_timeout(TIMER_LIST_ENT* p_tle) {
       p_cb->flags &= ~RW_T3T_FL_W4_PRESENCE_CHECK_POLL_RSP;
       evt_data.status = NFC_STATUS_FAILED;
       p_cb->rw_state = RW_T3T_STATE_IDLE;
-      (*(rw_cb.p_cback))(RW_T3T_PRESENCE_CHECK_EVT, (tRW_DATA*)&evt_data);
+      (*(rw_cb.p_cback))(RW_T3T_PRESENCE_CHECK_EVT, &evt_data);
     } else if (p_cb->flags & RW_T3T_FL_W4_GET_SC_POLL_RSP) {
       /* POLL timeout for getting system codes */
       p_cb->flags &= ~RW_T3T_FL_W4_GET_SC_POLL_RSP;
@@ -548,22 +538,22 @@ void rw_t3t_process_timeout(TIMER_LIST_ENT* p_tle) {
     } else if (p_cb->flags & RW_T3T_FL_W4_FMT_FELICA_LITE_POLL_RSP) {
       /* POLL timeout for formatting Felica Lite */
       p_cb->flags &= ~RW_T3T_FL_W4_FMT_FELICA_LITE_POLL_RSP;
-      RW_TRACE_ERROR0("Felica-Lite tag not detected");
+      LOG(ERROR) << StringPrintf("Felica-Lite tag not detected");
       rw_t3t_format_cplt(NFC_STATUS_FAILED);
     } else if (p_cb->flags & RW_T3T_FL_W4_SRO_FELICA_LITE_POLL_RSP) {
       /* POLL timeout for configuring Felica Lite read only */
       p_cb->flags &= ~RW_T3T_FL_W4_SRO_FELICA_LITE_POLL_RSP;
-      RW_TRACE_ERROR0("Felica-Lite tag not detected");
+      LOG(ERROR) << StringPrintf("Felica-Lite tag not detected");
       rw_t3t_set_readonly_cplt(NFC_STATUS_FAILED);
     } else if (p_cb->flags & RW_T3T_FL_W4_NDEF_DETECT_POLL_RSP) {
       /* POLL timeout for ndef detection */
       p_cb->flags &= ~RW_T3T_FL_W4_NDEF_DETECT_POLL_RSP;
-      rw_t3t_handle_ndef_detect_poll_rsp(p_cb, NFC_STATUS_TIMEOUT, 0, 0, NULL);
+      rw_t3t_handle_ndef_detect_poll_rsp(p_cb, NFC_STATUS_TIMEOUT, 0, NULL);
     } else {
       /* Timeout waiting for response for RW_T3tPoll */
       evt_data.t3t_poll.status = NFC_STATUS_FAILED;
       p_cb->rw_state = RW_T3T_STATE_IDLE;
-      (*(rw_cb.p_cback))(RW_T3T_POLL_EVT, (tRW_DATA*)&evt_data);
+      (*(rw_cb.p_cback))(RW_T3T_POLL_EVT, &evt_data);
     }
   }
 }
@@ -578,14 +568,9 @@ void rw_t3t_process_timeout(TIMER_LIST_ENT* p_tle) {
 **
 *******************************************************************************/
 void rw_t3t_process_frame_error(void) {
-#if (BT_TRACE_VERBOSE == true)
-  RW_TRACE_ERROR3("T3T frame error. state=%s cur_cmd=0x%02X (%s)",
-                  rw_t3t_state_str(rw_cb.tcb.t3t.rw_state),
-                  rw_cb.tcb.t3t.cur_cmd, rw_t3t_cmd_str(rw_cb.tcb.t3t.cur_cmd));
-#else
-  RW_TRACE_ERROR2("T3T frame error. state=0x%02X cur_cmd=0x%02X",
-                  rw_cb.tcb.t3t.rw_state, rw_cb.tcb.t3t.cur_cmd);
-#endif
+  LOG(ERROR) << StringPrintf("T3T frame error. state=%s cur_cmd=0x%02X (%s)",
+                  rw_t3t_state_str(rw_cb.tcb.t3t.rw_state).c_str(),
+                  rw_cb.tcb.t3t.cur_cmd, rw_t3t_cmd_str(rw_cb.tcb.t3t.cur_cmd).c_str());
 
 #if (RW_STATS_INCLUDED == true)
   /* Update stats */
@@ -620,10 +605,6 @@ tNFC_STATUS rw_t3t_send_to_lower(NFC_HDR* p_msg) {
   UINT8_TO_STREAM(p, (p_msg->len + 1));
   p_msg->len += 1; /* Increment len to include SoD */
 
-#if (BT_TRACE_PROTOCOL == true)
-  DispT3TagMessage(p_msg, false);
-#endif
-
   return (NFC_SendData(NFC_RF_CONN_ID, p_msg));
 }
 
@@ -682,7 +663,7 @@ tNFC_STATUS rw_t3t_send_cmd(tRW_T3T_CB* p_cb, uint8_t rw_t3t_cmd,
     p_cb->rw_state = RW_T3T_STATE_IDLE;
   }
 
-  RW_TRACE_DEBUG3("rw_t3t_send_cmd: cur_tout: %d, timeout_ticks: %d ret:%d",
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t3t_send_cmd: cur_tout: %d, timeout_ticks: %d ret:%d",
                   p_cb->cur_tout, timeout_ticks, retval);
   return (retval);
 }
@@ -967,7 +948,7 @@ tNFC_STATUS rw_t3t_send_next_ndef_check_cmd(tRW_T3T_CB* p_cb) {
       p_cb->ndef_rx_readlen = ((uint32_t)p_cb->ndef_attrib.nbr * 16);
     }
 
-    RW_TRACE_DEBUG3(
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
         "rw_t3t_send_next_ndef_check_cmd: bytes_remaining: %i, "
         "cur_blocks_to_read: %i, is_final: %i",
         ndef_bytes_remaining, cur_blocks_to_read,
@@ -1226,7 +1207,7 @@ tNFC_STATUS rw_t3t_check_mc_block(tRW_T3T_CB* p_cb) {
     return rw_t3t_send_cmd(p_cb, p_cb->cur_cmd, p_cmd_buf,
                            rw_t3t_check_timeout(1));
   } else {
-    RW_TRACE_ERROR0("Unable to allocate buffer to read MC block");
+    LOG(ERROR) << StringPrintf("Unable to allocate buffer to read MC block");
     return (NFC_STATUS_NO_BUFFERS);
   }
 }
@@ -1290,10 +1271,11 @@ void rw_t3t_act_handle_ndef_detect_rsp(tRW_T3T_CB* p_cb, NFC_HDR* p_msg_rsp) {
 
   evt_data.status = NFC_STATUS_FAILED;
   evt_data.flags = RW_NDEF_FL_UNKNOWN;
+  evt_data.protocol = 0;
 
   /* Check if response code is CHECK resp (for reading NDEF attribute block) */
   if (p_t3t_rsp[T3T_MSG_RSP_OFFSET_RSPCODE] != T3T_MSG_OPC_CHECK_RSP) {
-    RW_TRACE_ERROR2("Response error: expecting rsp_code %02X, but got %02X",
+    LOG(ERROR) << StringPrintf("Response error: expecting rsp_code %02X, but got %02X",
                     T3T_MSG_OPC_CHECK_RSP,
                     p_t3t_rsp[T3T_MSG_RSP_OFFSET_RSPCODE]);
     evt_data.status = NFC_STATUS_FAILED;
@@ -1324,7 +1306,7 @@ void rw_t3t_act_handle_ndef_detect_rsp(tRW_T3T_CB* p_cb, NFC_HDR* p_msg_rsp) {
           NFC_STATUS_FAILED; /* only ok or failed passed to the app. can be
                                 boolean*/
 
-      RW_TRACE_ERROR0("RW_T3tDetectNDEF checksum failed");
+      LOG(ERROR) << StringPrintf("RW_T3tDetectNDEF checksum failed");
     } else {
       p_cb->ndef_attrib.status = NFC_STATUS_OK;
 
@@ -1335,7 +1317,7 @@ void rw_t3t_act_handle_ndef_detect_rsp(tRW_T3T_CB* p_cb, NFC_HDR* p_msg_rsp) {
           T3T_GET_MAJOR_VERSION(p_cb->ndef_attrib.version)) {
         /* Remote tag's MajorVer is newer than our's. Reject NDEF as per T3TOP
          * RQ_T3T_NDA_024 */
-        RW_TRACE_ERROR2(
+        LOG(ERROR) << StringPrintf(
             "RW_T3tDetectNDEF: incompatible NDEF version. Local=0x%02x, "
             "Remote=0x%02x",
             T3T_MSG_NDEF_VERSION, p_cb->ndef_attrib.version);
@@ -1369,8 +1351,8 @@ void rw_t3t_act_handle_ndef_detect_rsp(tRW_T3T_CB* p_cb, NFC_HDR* p_msg_rsp) {
         BE_STREAM_TO_UINT16(p_cb->ndef_attrib.ln, p); /* Ln: lo-word */
         p_cb->ndef_attrib.ln += (temp << 16);
 
-        RW_TRACE_DEBUG1("Detected NDEF Ver: 0x%02x", p_cb->ndef_attrib.version);
-        RW_TRACE_DEBUG6(
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Detected NDEF Ver: 0x%02x", p_cb->ndef_attrib.version);
+        DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
             "Detected NDEF Attributes: Nbr=%i, Nbw=%i, Nmaxb=%i, WriteF=%i, "
             "RWFlag=%i, Ln=%i",
             p_cb->ndef_attrib.nbr, p_cb->ndef_attrib.nbw,
@@ -1389,12 +1371,14 @@ void rw_t3t_act_handle_ndef_detect_rsp(tRW_T3T_CB* p_cb, NFC_HDR* p_msg_rsp) {
     }
   }
 
-  RW_TRACE_DEBUG1("RW_T3tDetectNDEF response: %i", evt_data.status);
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_T3tDetectNDEF response: %i", evt_data.status);
 
   p_cb->rw_state = RW_T3T_STATE_IDLE;
   rw_t3t_update_ndef_flag(&evt_data.flags);
   /* Notify app of NDEF detection result */
-  (*(rw_cb.p_cback))(RW_T3T_NDEF_DETECT_EVT, (void*)&evt_data);
+  tRW_DATA rw_data;
+  rw_data.ndef = evt_data;
+  (*(rw_cb.p_cback))(RW_T3T_NDEF_DETECT_EVT, &rw_data);
 
   GKI_freebuf(p_msg_rsp);
 }
@@ -1423,7 +1407,7 @@ void rw_t3t_act_handle_check_rsp(tRW_T3T_CB* p_cb, NFC_HDR* p_msg_rsp) {
     nfc_status = NFC_STATUS_FAILED;
     GKI_freebuf(p_msg_rsp);
   } else if (p_t3t_rsp[T3T_MSG_RSP_OFFSET_RSPCODE] != T3T_MSG_OPC_CHECK_RSP) {
-    RW_TRACE_ERROR2("Response error: expecting rsp_code %02X, but got %02X",
+    LOG(ERROR) << StringPrintf("Response error: expecting rsp_code %02X, but got %02X",
                     T3T_MSG_OPC_CHECK_RSP,
                     p_t3t_rsp[T3T_MSG_RSP_OFFSET_RSPCODE]);
     nfc_status = NFC_STATUS_FAILED;
@@ -1435,12 +1419,16 @@ void rw_t3t_act_handle_check_rsp(tRW_T3T_CB* p_cb, NFC_HDR* p_msg_rsp) {
     p_msg_rsp->len -= T3T_MSG_RSP_OFFSET_CHECK_DATA;
     evt_data.status = NFC_STATUS_OK;
     evt_data.p_data = p_msg_rsp;
-    (*(rw_cb.p_cback))(RW_T3T_CHECK_EVT, (void*)&evt_data);
+    tRW_DATA rw_data;
+    rw_data.data = evt_data;
+    (*(rw_cb.p_cback))(RW_T3T_CHECK_EVT, &rw_data);
   }
 
   p_cb->rw_state = RW_T3T_STATE_IDLE;
 
-  (*(rw_cb.p_cback))(RW_T3T_CHECK_CPLT_EVT, (void*)&nfc_status);
+  tRW_DATA rw_data;
+  rw_data.status = nfc_status;
+  (*(rw_cb.p_cback))(RW_T3T_CHECK_CPLT_EVT, &rw_data);
 }
 
 /*****************************************************************************
@@ -1465,7 +1453,7 @@ void rw_t3t_act_handle_update_rsp(tRW_T3T_CB* p_cb, NFC_HDR* p_msg_rsp) {
   {
     evt_data.status = NFC_STATUS_FAILED;
   } else if (p_t3t_rsp[T3T_MSG_RSP_OFFSET_RSPCODE] != T3T_MSG_OPC_UPDATE_RSP) {
-    RW_TRACE_ERROR2("Response error: expecting rsp_code %02X, but got %02X",
+    LOG(ERROR) << StringPrintf("Response error: expecting rsp_code %02X, but got %02X",
                     T3T_MSG_OPC_UPDATE_RSP,
                     p_t3t_rsp[T3T_MSG_RSP_OFFSET_RSPCODE]);
     evt_data.status = NFC_STATUS_FAILED;
@@ -1476,7 +1464,9 @@ void rw_t3t_act_handle_update_rsp(tRW_T3T_CB* p_cb, NFC_HDR* p_msg_rsp) {
 
   p_cb->rw_state = RW_T3T_STATE_IDLE;
 
-  (*(rw_cb.p_cback))(RW_T3T_UPDATE_CPLT_EVT, (void*)&evt_data);
+  tRW_DATA rw_data;
+  rw_data.data = evt_data;
+  (*(rw_cb.p_cback))(RW_T3T_RAW_FRAME_EVT, &rw_data);
 
   GKI_freebuf(p_msg_rsp);
 }
@@ -1495,13 +1485,8 @@ void rw_t3t_act_handle_raw_senddata_rsp(tRW_T3T_CB* p_cb,
   tRW_READ_DATA evt_data;
   NFC_HDR* p_pkt = p_data->p_data;
 
-#if (BT_TRACE_VERBOSE == true)
-  RW_TRACE_DEBUG2("RW T3T Raw Frame: Len [0x%X] Status [%s]", p_pkt->len,
-                  NFC_GetStatusName(p_data->status));
-#else
-  RW_TRACE_DEBUG2("RW T3T Raw Frame: Len [0x%X] Status [0x%X]", p_pkt->len,
-                  p_data->status);
-#endif
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW T3T Raw Frame: Len [0x%X] Status [%s]", p_pkt->len,
+                  NFC_GetStatusName(p_data->status).c_str());
 
   /* Copy incoming data into buffer */
   evt_data.status = p_data->status;
@@ -1509,7 +1494,9 @@ void rw_t3t_act_handle_raw_senddata_rsp(tRW_T3T_CB* p_cb,
 
   p_cb->rw_state = RW_T3T_STATE_IDLE;
 
-  (*(rw_cb.p_cback))(RW_T3T_RAW_FRAME_EVT, (void*)&evt_data);
+  tRW_DATA ndef_evt_data;
+  ndef_evt_data.data = evt_data;
+  (*(rw_cb.p_cback))(RW_T3T_RAW_FRAME_EVT, &ndef_evt_data);
 }
 
 /*****************************************************************************
@@ -1524,8 +1511,6 @@ void rw_t3t_act_handle_raw_senddata_rsp(tRW_T3T_CB* p_cb,
 void rw_t3t_act_handle_check_ndef_rsp(tRW_T3T_CB* p_cb, NFC_HDR* p_msg_rsp) {
   bool check_complete = true;
   tNFC_STATUS nfc_status = NFC_STATUS_OK;
-  tRW_READ_DATA read_data;
-  tRW_DATA evt_data;
   uint8_t* p_t3t_rsp = (uint8_t*)(p_msg_rsp + 1) + p_msg_rsp->offset;
   uint8_t rsp_num_bytes_rx;
 
@@ -1539,13 +1524,13 @@ void rw_t3t_act_handle_check_ndef_rsp(tRW_T3T_CB* p_cb, NFC_HDR* p_msg_rsp) {
       (p_t3t_rsp[T3T_MSG_RSP_OFFSET_NUMBLOCKS] !=
        ((p_cb->ndef_rx_readlen + 15) >> 4))) /* verify length of response */
   {
-    RW_TRACE_ERROR2("Response error: bad status, nfcid2, or invalid len: %i %i",
+    LOG(ERROR) << StringPrintf("Response error: bad status, nfcid2, or invalid len: %i %i",
                     p_t3t_rsp[T3T_MSG_RSP_OFFSET_NUMBLOCKS],
                     ((p_cb->ndef_rx_readlen + 15) >> 4));
     nfc_status = NFC_STATUS_FAILED;
     GKI_freebuf(p_msg_rsp);
   } else if (p_t3t_rsp[T3T_MSG_RSP_OFFSET_RSPCODE] != T3T_MSG_OPC_CHECK_RSP) {
-    RW_TRACE_ERROR2("Response error: expecting rsp_code %02X, but got %02X",
+    LOG(ERROR) << StringPrintf("Response error: expecting rsp_code %02X, but got %02X",
                     T3T_MSG_OPC_CHECK_RSP,
                     p_t3t_rsp[T3T_MSG_RSP_OFFSET_RSPCODE]);
     nfc_status = NFC_STATUS_FAILED;
@@ -1555,7 +1540,6 @@ void rw_t3t_act_handle_check_ndef_rsp(tRW_T3T_CB* p_cb, NFC_HDR* p_msg_rsp) {
     rsp_num_bytes_rx = p_t3t_rsp[T3T_MSG_RSP_OFFSET_NUMBLOCKS] *
                        16; /* Number of bytes received, according to header */
     p_cb->ndef_rx_offset += p_cb->ndef_rx_readlen;
-    read_data.status = NFC_STATUS_OK;
     p_msg_rsp->offset +=
         T3T_MSG_RSP_OFFSET_CHECK_DATA; /* Skip over t3t header (point to block
                                           data) */
@@ -1564,7 +1548,7 @@ void rw_t3t_act_handle_check_ndef_rsp(tRW_T3T_CB* p_cb, NFC_HDR* p_msg_rsp) {
     /* Verify that the bytes received is really the amount indicated in the
      * check-response header */
     if (rsp_num_bytes_rx > p_msg_rsp->len) {
-      RW_TRACE_ERROR2(
+      LOG(ERROR) << StringPrintf(
           "Response error: CHECK rsp header indicates %i bytes, but only "
           "received %i bytes",
           rsp_num_bytes_rx, p_msg_rsp->len);
@@ -1579,8 +1563,10 @@ void rw_t3t_act_handle_check_ndef_rsp(tRW_T3T_CB* p_cb, NFC_HDR* p_msg_rsp) {
       }
 
       p_msg_rsp->len = rsp_num_bytes_rx;
-      read_data.p_data = p_msg_rsp;
-      (*(rw_cb.p_cback))(RW_T3T_CHECK_EVT, (void*)&read_data);
+      tRW_DATA rw_data;
+      rw_data.data.status = NFC_STATUS_OK;
+      rw_data.data.p_data = p_msg_rsp;
+      (*(rw_cb.p_cback))(RW_T3T_CHECK_EVT, &rw_data);
 
       /* Send CHECK cmd for next NDEF segment, if needed */
       if (!(p_cb->flags & RW_T3T_FL_IS_FINAL_NDEF_SEGMENT)) {
@@ -1598,8 +1584,9 @@ void rw_t3t_act_handle_check_ndef_rsp(tRW_T3T_CB* p_cb, NFC_HDR* p_msg_rsp) {
    * failure */
   if (check_complete) {
     p_cb->rw_state = RW_T3T_STATE_IDLE;
+    tRW_DATA evt_data;
     evt_data.status = nfc_status;
-    (*(rw_cb.p_cback))(RW_T3T_CHECK_CPLT_EVT, (tRW_DATA*)&evt_data);
+    (*(rw_cb.p_cback))(RW_T3T_CHECK_CPLT_EVT, &evt_data);
   }
 }
 
@@ -1615,7 +1602,6 @@ void rw_t3t_act_handle_check_ndef_rsp(tRW_T3T_CB* p_cb, NFC_HDR* p_msg_rsp) {
 void rw_t3t_act_handle_update_ndef_rsp(tRW_T3T_CB* p_cb, NFC_HDR* p_msg_rsp) {
   bool update_complete = true;
   tNFC_STATUS nfc_status = NFC_STATUS_OK;
-  tRW_DATA evt_data;
   uint8_t* p_t3t_rsp = (uint8_t*)(p_msg_rsp + 1) + p_msg_rsp->offset;
 
   /* Check nfcid2 and status of response */
@@ -1629,7 +1615,7 @@ void rw_t3t_act_handle_update_ndef_rsp(tRW_T3T_CB* p_cb, NFC_HDR* p_msg_rsp) {
   }
   /* Validate response opcode */
   else if (p_t3t_rsp[T3T_MSG_RSP_OFFSET_RSPCODE] != T3T_MSG_OPC_UPDATE_RSP) {
-    RW_TRACE_ERROR2("Response error: expecting rsp_code %02X, but got %02X",
+    LOG(ERROR) << StringPrintf("Response error: expecting rsp_code %02X, but got %02X",
                     T3T_MSG_OPC_UPDATE_RSP,
                     p_t3t_rsp[T3T_MSG_RSP_OFFSET_RSPCODE]);
     nfc_status = NFC_STATUS_FAILED;
@@ -1662,8 +1648,9 @@ void rw_t3t_act_handle_update_ndef_rsp(tRW_T3T_CB* p_cb, NFC_HDR* p_msg_rsp) {
   /* If update is completed, then notify app */
   if (update_complete) {
     p_cb->rw_state = RW_T3T_STATE_IDLE;
+    tRW_DATA evt_data;
     evt_data.status = nfc_status;
-    (*(rw_cb.p_cback))(RW_T3T_UPDATE_CPLT_EVT, (tRW_DATA*)&evt_data);
+    (*(rw_cb.p_cback))(RW_T3T_UPDATE_CPLT_EVT, &evt_data);
   }
 
   GKI_freebuf(p_msg_rsp);
@@ -1694,7 +1681,7 @@ static void rw_t3t_handle_get_sc_poll_rsp(tRW_T3T_CB* p_cb, uint8_t nci_status,
     p = &p_sensf_res_buf[RW_T3T_SENSF_RES_RD_OFFSET];
     BE_STREAM_TO_UINT16(sc, p);
 
-    RW_TRACE_DEBUG1("FeliCa detected (RD, system code %04X)", sc);
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("FeliCa detected (RD, system code %04X)", sc);
     p_cb->system_codes[p_cb->num_system_codes++] = sc;
   }
 
@@ -1713,12 +1700,10 @@ static void rw_t3t_handle_get_sc_poll_rsp(tRW_T3T_CB* p_cb, uint8_t nci_status,
 static void rw_t3t_handle_ndef_detect_poll_rsp(tRW_T3T_CB* p_cb,
                                                uint8_t nci_status,
                                                uint8_t num_responses,
-                                               uint8_t sensf_res_buf_size,
                                                uint8_t* p_sensf_res_buf) {
   NFC_HDR* p_cmd_buf;
   uint8_t* p, *p_cmd_start;
   tRW_DATA evt_data;
-  (void)sensf_res_buf_size;
 
   /* Validate response for NDEF poll */
   if ((nci_status == NCI_STATUS_OK) && (num_responses > 0)) {
@@ -1842,12 +1827,8 @@ tNFC_STATUS rw_t3t_update_block(tRW_T3T_CB* p_cb, uint8_t block_id,
 **
 *****************************************************************************/
 static void rw_t3t_handle_fmt_poll_rsp(tRW_T3T_CB* p_cb, uint8_t nci_status,
-                                       uint8_t num_responses,
-                                       uint8_t sensf_res_buf_size,
-                                       uint8_t* p_sensf_res_buf) {
+                                       uint8_t num_responses) {
   tRW_DATA evt_data;
-  (void)sensf_res_buf_size;
-  (void)p_sensf_res_buf;
 
   evt_data.status = NFC_STATUS_OK;
 
@@ -1855,14 +1836,14 @@ static void rw_t3t_handle_fmt_poll_rsp(tRW_T3T_CB* p_cb, uint8_t nci_status,
   if ((nci_status == NCI_STATUS_OK) && (num_responses > 0)) {
     /* Tag responded for Felica-Lite poll */
     /* Get MemoryControl block */
-    RW_TRACE_DEBUG0("Felica-Lite tag detected...getting Memory Control block.");
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Felica-Lite tag detected...getting Memory Control block.");
 
     p_cb->rw_substate = RW_T3T_FMT_SST_CHECK_MC_BLK;
 
     /* Send command to check Memory Configuration block */
     evt_data.status = rw_t3t_check_mc_block(p_cb);
   } else {
-    RW_TRACE_ERROR0("Felica-Lite tag not detected");
+    LOG(ERROR) << StringPrintf("Felica-Lite tag not detected");
     evt_data.status = NFC_STATUS_FAILED;
   }
 
@@ -1892,7 +1873,7 @@ void rw_t3t_act_handle_fmt_rsp(tRW_T3T_CB* p_cb, NFC_HDR* p_msg_rsp) {
   if (p_cb->rw_substate == RW_T3T_FMT_SST_CHECK_MC_BLK) {
     /* Validate response opcode */
     if (p_t3t_rsp[T3T_MSG_RSP_OFFSET_RSPCODE] != T3T_MSG_OPC_CHECK_RSP) {
-      RW_TRACE_ERROR2("Response error: expecting rsp_code %02X, but got %02X",
+      LOG(ERROR) << StringPrintf("Response error: expecting rsp_code %02X, but got %02X",
                       T3T_MSG_OPC_CHECK_RSP,
                       p_t3t_rsp[T3T_MSG_RSP_OFFSET_RSPCODE]);
       evt_data.status = NFC_STATUS_FAILED;
@@ -1944,7 +1925,7 @@ void rw_t3t_act_handle_fmt_rsp(tRW_T3T_CB* p_cb, NFC_HDR* p_msg_rsp) {
         (p_t3t_rsp[T3T_MSG_RSP_OFFSET_STATUS1] != T3T_MSG_RSP_STATUS_OK))
 
     {
-      RW_TRACE_ERROR2("Response error: rsp_code=%02X, status=%02X",
+      LOG(ERROR) << StringPrintf("Response error: rsp_code=%02X, status=%02X",
                       p_t3t_rsp[T3T_MSG_RSP_OFFSET_RSPCODE],
                       p_t3t_rsp[T3T_MSG_RSP_OFFSET_STATUS1]);
       evt_data.status = NFC_STATUS_FAILED;
@@ -1966,7 +1947,7 @@ void rw_t3t_act_handle_fmt_rsp(tRW_T3T_CB* p_cb, NFC_HDR* p_msg_rsp) {
         (p_t3t_rsp[T3T_MSG_RSP_OFFSET_STATUS1] != T3T_MSG_RSP_STATUS_OK))
 
     {
-      RW_TRACE_ERROR2("Response error: rsp_code=%02X, status=%02X",
+      LOG(ERROR) << StringPrintf("Response error: rsp_code=%02X, status=%02X",
                       p_t3t_rsp[T3T_MSG_RSP_OFFSET_RSPCODE],
                       p_t3t_rsp[T3T_MSG_RSP_OFFSET_STATUS1]);
       evt_data.status = NFC_STATUS_FAILED;
@@ -1988,17 +1969,13 @@ void rw_t3t_act_handle_fmt_rsp(tRW_T3T_CB* p_cb, NFC_HDR* p_msg_rsp) {
 **
 *****************************************************************************/
 static void rw_t3t_handle_sro_poll_rsp(tRW_T3T_CB* p_cb, uint8_t nci_status,
-                                       uint8_t num_responses,
-                                       uint8_t sensf_res_buf_size,
-                                       uint8_t* p_sensf_res_buf) {
+                                       uint8_t num_responses) {
   tRW_DATA evt_data;
   uint8_t rw_t3t_ndef_attrib_info[T3T_MSG_BLOCKSIZE];
   uint8_t* p;
   uint8_t tempU8;
   uint16_t checksum, i;
   uint32_t tempU32 = 0;
-  (void)sensf_res_buf_size;
-  (void)p_sensf_res_buf;
 
   evt_data.status = NFC_STATUS_OK;
 
@@ -2007,7 +1984,7 @@ static void rw_t3t_handle_sro_poll_rsp(tRW_T3T_CB* p_cb, uint8_t nci_status,
     /* Tag responded for Felica-Lite poll */
     if (p_cb->ndef_attrib.rwflag != T3T_MSG_NDEF_RWFLAG_RO) {
       /* First update attribute information block */
-      RW_TRACE_DEBUG0(
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "Felica-Lite tag detected...update NDef attribution block.");
 
       p_cb->rw_substate = RW_T3T_SRO_SST_UPDATE_NDEF_ATTRIB;
@@ -2049,7 +2026,7 @@ static void rw_t3t_handle_sro_poll_rsp(tRW_T3T_CB* p_cb, uint8_t nci_status,
           rw_t3t_update_block(p_cb, 0, (uint8_t*)rw_t3t_ndef_attrib_info);
     } else if (p_cb->cur_cmd == RW_T3T_CMD_SET_READ_ONLY_HARD) {
       /* NDEF is already read only, Read and update MemoryControl block */
-      RW_TRACE_DEBUG0(
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "Felica-Lite tag detected...getting Memory Control block.");
       p_cb->rw_substate = RW_T3T_SRO_SST_CHECK_MC_BLK;
 
@@ -2057,7 +2034,7 @@ static void rw_t3t_handle_sro_poll_rsp(tRW_T3T_CB* p_cb, uint8_t nci_status,
       evt_data.status = rw_t3t_check_mc_block(p_cb);
     }
   } else {
-    RW_TRACE_ERROR0("Felica-Lite tag not detected");
+    LOG(ERROR) << StringPrintf("Felica-Lite tag not detected");
     evt_data.status = NFC_STATUS_FAILED;
   }
 
@@ -2089,7 +2066,7 @@ void rw_t3t_act_handle_sro_rsp(tRW_T3T_CB* p_cb, NFC_HDR* p_msg_rsp) {
         (p_t3t_rsp[T3T_MSG_RSP_OFFSET_STATUS1] != T3T_MSG_RSP_STATUS_OK))
 
     {
-      RW_TRACE_ERROR2("Response error: rsp_code=%02X, status=%02X",
+      LOG(ERROR) << StringPrintf("Response error: rsp_code=%02X, status=%02X",
                       p_t3t_rsp[T3T_MSG_RSP_OFFSET_RSPCODE],
                       p_t3t_rsp[T3T_MSG_RSP_OFFSET_STATUS1]);
       evt_data.status = NFC_STATUS_FAILED;
@@ -2108,7 +2085,7 @@ void rw_t3t_act_handle_sro_rsp(tRW_T3T_CB* p_cb, NFC_HDR* p_msg_rsp) {
     /* Check tags's response for reading MemoryControl block, Validate response
      * opcode */
     if (p_t3t_rsp[T3T_MSG_RSP_OFFSET_RSPCODE] != T3T_MSG_OPC_CHECK_RSP) {
-      RW_TRACE_ERROR2("Response error: expecting rsp_code %02X, but got %02X",
+      LOG(ERROR) << StringPrintf("Response error: expecting rsp_code %02X, but got %02X",
                       T3T_MSG_OPC_CHECK_RSP,
                       p_t3t_rsp[T3T_MSG_RSP_OFFSET_RSPCODE]);
       evt_data.status = NFC_STATUS_FAILED;
@@ -2153,7 +2130,7 @@ void rw_t3t_act_handle_sro_rsp(tRW_T3T_CB* p_cb, NFC_HDR* p_msg_rsp) {
         (p_t3t_rsp[T3T_MSG_RSP_OFFSET_STATUS1] != T3T_MSG_RSP_STATUS_OK))
 
     {
-      RW_TRACE_ERROR2("Response error: rsp_code=%02X, status=%02X",
+      LOG(ERROR) << StringPrintf("Response error: rsp_code=%02X, status=%02X",
                       p_t3t_rsp[T3T_MSG_RSP_OFFSET_RSPCODE],
                       p_t3t_rsp[T3T_MSG_RSP_OFFSET_STATUS1]);
       evt_data.status = NFC_STATUS_FAILED;
@@ -2179,12 +2156,11 @@ void rw_t3t_act_handle_sro_rsp(tRW_T3T_CB* p_cb, NFC_HDR* p_msg_rsp) {
 ** Returns          none
 **
 *******************************************************************************/
-void rw_t3t_data_cback(uint8_t conn_id, tNFC_DATA_CEVT* p_data) {
+void rw_t3t_data_cback(__attribute__((unused)) uint8_t conn_id, tNFC_DATA_CEVT* p_data) {
   tRW_T3T_CB* p_cb = &rw_cb.tcb.t3t;
   NFC_HDR* p_msg = p_data->p_data;
   bool free_msg = false; /* if true, free msg buffer before returning */
   uint8_t* p, sod;
-  (void)conn_id;
 
   /* Stop rsponse timer */
   nfc_stop_quick_timer(&p_cb->timer);
@@ -2204,7 +2180,7 @@ void rw_t3t_data_cback(uint8_t conn_id, tNFC_DATA_CEVT* p_data) {
   }
   /* Sanity check: verify msg len is big enough to contain t3t header */
   else if (p_msg->len < T3T_MSG_RSP_COMMON_HDR_LEN) {
-    RW_TRACE_ERROR1("T3T: invalid Type3 Tag Message (invalid len: %i)",
+    LOG(ERROR) << StringPrintf("T3T: invalid Type3 Tag Message (invalid len: %i)",
                     p_msg->len);
     free_msg = true;
 
@@ -2214,17 +2190,13 @@ void rw_t3t_data_cback(uint8_t conn_id, tNFC_DATA_CEVT* p_data) {
     p = (uint8_t*)(p_msg + 1) + p_msg->offset;
     sod = p[0];
     if (p[sod] != NCI_STATUS_OK) {
-      RW_TRACE_ERROR1("T3T: rf frame error (crc status=%i)", p[sod]);
+      LOG(ERROR) << StringPrintf("T3T: rf frame error (crc status=%i)", p[sod]);
       GKI_freebuf(p_msg);
 
       rw_t3t_process_frame_error();
       return;
     }
 
-#if (BT_TRACE_PROTOCOL == true)
-    DispT3TagMessage(p_msg, true);
-#endif
-
     /* Skip over SoD */
     p_msg->offset++;
     p_msg->len--;
@@ -2287,7 +2259,7 @@ void rw_t3t_data_cback(uint8_t conn_id, tNFC_DATA_CEVT* p_data) {
 void rw_t3t_conn_cback(uint8_t conn_id, tNFC_CONN_EVT event,
                        tNFC_CONN* p_data) {
   tRW_T3T_CB* p_cb = &rw_cb.tcb.t3t;
-  RW_TRACE_DEBUG2("rw_t3t_conn_cback: conn_id=%i, evt=0x%02x", conn_id, event);
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t3t_conn_cback: conn_id=%i, evt=0x%02x", conn_id, event);
 
   /* Only handle NFC_RF_CONN_ID conn_id */
   if (conn_id != NFC_RF_CONN_ID) {
@@ -2296,7 +2268,7 @@ void rw_t3t_conn_cback(uint8_t conn_id, tNFC_CONN_EVT event,
 
   switch (event) {
     case NFC_DEACTIVATE_CEVT:
-      rw_t3t_unselect(NULL);
+      rw_t3t_unselect();
       break;
 
     case NFC_DATA_CEVT: /* check for status in tNFC_CONN */
@@ -2305,10 +2277,9 @@ void rw_t3t_conn_cback(uint8_t conn_id, tNFC_CONN_EVT event,
         rw_t3t_data_cback(conn_id, &(p_data->data));
         break;
       } else if ((p_data != NULL) && (p_data->data.p_data != NULL)) {
-        RW_TRACE_DEBUG2(
-            "rw_t3t_conn_cback: p_data->data.p_data=0x%X "
-            "p_data->data.status=0x%02x",
-            p_data->data.p_data, p_data->data.status);
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
+            "rw_t3t_conn_cback: p_data->data.p_data=%p , p_data->data.status=0x%02x",
+             p_data->data.p_data, p_data->data.status);
         /* Free the response buffer in case of error response */
         GKI_freebuf((NFC_HDR*)(p_data->data.p_data));
         p_data->data.p_data = NULL;
@@ -2318,7 +2289,7 @@ void rw_t3t_conn_cback(uint8_t conn_id, tNFC_CONN_EVT event,
         p_data->data.p_data = NULL;
       }
     /* Data event with error status...fall through to NFC_ERROR_CEVT case */
-
+    [[fallthrough]];
     case NFC_ERROR_CEVT:
       nfc_stop_quick_timer(&p_cb->timer);
 
@@ -2332,7 +2303,7 @@ void rw_t3t_conn_cback(uint8_t conn_id, tNFC_CONN_EVT event,
         rw_t3t_process_error(p_data->status);
 #if (NXP_EXTNS == TRUE)
       if ((p_data != NULL) && (p_data->data.p_data != NULL)) {
-        RW_TRACE_DEBUG0("rw_t3t_conn_cback: free GKI buffer");
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t3t_conn_cback: free GKI buffer");
         GKI_freebuf((NFC_HDR*)(p_data->data.p_data));
       }
 #endif
@@ -2379,7 +2350,7 @@ tNFC_STATUS rw_t3t_select(uint8_t peer_nfcid2[NCI_RF_F_UID_LEN],
                           uint8_t mrti_check, uint8_t mrti_update) {
   tRW_T3T_CB* p_cb = &rw_cb.tcb.t3t;
 
-  RW_TRACE_API0("rw_t3t_select");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t3t_select");
 
   memcpy(p_cb->peer_nfcid2, peer_nfcid2,
          NCI_NFCID2_LEN); /* Store tag's NFCID2 */
@@ -2395,7 +2366,7 @@ tNFC_STATUS rw_t3t_select(uint8_t peer_nfcid2[NCI_RF_F_UID_LEN],
   if (p_cb->p_cur_cmd_buf == NULL) {
     p_cb->p_cur_cmd_buf = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
     if (p_cb->p_cur_cmd_buf == NULL) {
-      RW_TRACE_ERROR0(
+      LOG(ERROR) << StringPrintf(
           "rw_t3t_select: unable to allocate buffer for retransmission");
       p_cb->rw_state = RW_T3T_STATE_NOT_ACTIVATED;
       return (NFC_STATUS_FAILED);
@@ -2416,9 +2387,8 @@ tNFC_STATUS rw_t3t_select(uint8_t peer_nfcid2[NCI_RF_F_UID_LEN],
 ** Returns          NFC_STATUS_OK
 **
 *******************************************************************************/
-static tNFC_STATUS rw_t3t_unselect(uint8_t peer_nfcid2[]) {
+static tNFC_STATUS rw_t3t_unselect() {
   tRW_T3T_CB* p_cb = &rw_cb.tcb.t3t;
-  (void)peer_nfcid2;
 
 #if (RW_STATS_INCLUDED == true)
   /* Display stats */
@@ -2462,7 +2432,6 @@ static void rw_t3t_update_ndef_flag(uint8_t* p_flag) {
   }
 }
 
-#if (BT_TRACE_VERBOSE == true)
 /*******************************************************************************
 **
 ** Function         rw_t3t_cmd_str
@@ -2472,7 +2441,7 @@ static void rw_t3t_update_ndef_flag(uint8_t* p_flag) {
 ** Returns          command string
 **
 *******************************************************************************/
-static char* rw_t3t_cmd_str(uint8_t cmd_id) {
+static std::string rw_t3t_cmd_str(uint8_t cmd_id) {
   switch (cmd_id) {
     case RW_T3T_CMD_DETECT_NDEF:
       return "RW_T3T_CMD_DETECT_NDEF";
@@ -2509,7 +2478,7 @@ static char* rw_t3t_cmd_str(uint8_t cmd_id) {
 ** Returns          command string
 **
 *******************************************************************************/
-static char* rw_t3t_state_str(uint8_t state_id) {
+static std::string rw_t3t_state_str(uint8_t state_id) {
   switch (state_id) {
     case RW_T3T_STATE_NOT_ACTIVATED:
       return "RW_T3T_STATE_NOT_ACTIVATED";
@@ -2524,7 +2493,6 @@ static char* rw_t3t_state_str(uint8_t state_id) {
       return "Unknown";
   }
 }
-#endif
 
 /*****************************************************************************
 **  Type3 Tag API Functions
@@ -2552,11 +2520,11 @@ tNFC_STATUS RW_T3tDetectNDef(void) {
   tRW_T3T_CB* p_cb = &rw_cb.tcb.t3t;
   tNFC_STATUS retval = NFC_STATUS_OK;
 
-  RW_TRACE_API0("RW_T3tDetectNDef");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_T3tDetectNDef");
 
   /* Check if we are in valid state to handle this API */
   if (p_cb->rw_state != RW_T3T_STATE_IDLE) {
-    RW_TRACE_ERROR1("Error: invalid state to handle API (0x%x)",
+    LOG(ERROR) << StringPrintf("Error: invalid state to handle API (0x%x)",
                     p_cb->rw_state);
     return (NFC_STATUS_FAILED);
   }
@@ -2605,20 +2573,20 @@ tNFC_STATUS RW_T3tCheckNDef(void) {
   tNFC_STATUS retval = NFC_STATUS_OK;
   tRW_T3T_CB* p_cb = &rw_cb.tcb.t3t;
 
-  RW_TRACE_API0("RW_T3tCheckNDef");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_T3tCheckNDef");
 
   /* Check if we are in valid state to handle this API */
   if (p_cb->rw_state != RW_T3T_STATE_IDLE) {
-    RW_TRACE_ERROR1("Error: invalid state to handle API (0x%x)",
+    LOG(ERROR) << StringPrintf("Error: invalid state to handle API (0x%x)",
                     p_cb->rw_state);
     return (NFC_STATUS_FAILED);
   } else if (p_cb->ndef_attrib.status !=
              NFC_STATUS_OK) /* NDEF detection not performed yet? */
   {
-    RW_TRACE_ERROR0("Error: NDEF detection not performed yet");
+    LOG(ERROR) << StringPrintf("Error: NDEF detection not performed yet");
     return (NFC_STATUS_NOT_INITIALIZED);
   } else if (p_cb->ndef_attrib.ln == 0) {
-    RW_TRACE_ERROR0("Type 3 tag contains empty NDEF message");
+    LOG(ERROR) << StringPrintf("Type 3 tag contains empty NDEF message");
     return (NFC_STATUS_FAILED);
   }
 
@@ -2660,17 +2628,17 @@ tNFC_STATUS RW_T3tUpdateNDef(uint32_t len, uint8_t* p_data) {
   tNFC_STATUS retval = NFC_STATUS_OK;
   tRW_T3T_CB* p_cb = &rw_cb.tcb.t3t;
 
-  RW_TRACE_API1("RW_T3tUpdateNDef (len=%i)", len);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_T3tUpdateNDef (len=%i)", len);
 
   /* Check if we are in valid state to handle this API */
   if (p_cb->rw_state != RW_T3T_STATE_IDLE) {
-    RW_TRACE_ERROR1("Error: invalid state to handle API (0x%x)",
+    LOG(ERROR) << StringPrintf("Error: invalid state to handle API (0x%x)",
                     p_cb->rw_state);
     return (NFC_STATUS_FAILED);
   } else if (p_cb->ndef_attrib.status !=
              NFC_STATUS_OK) /* NDEF detection not performed yet? */
   {
-    RW_TRACE_ERROR0("Error: NDEF detection not performed yet");
+    LOG(ERROR) << StringPrintf("Error: NDEF detection not performed yet");
     return (NFC_STATUS_NOT_INITIALIZED);
   } else if (len > (((uint32_t)p_cb->ndef_attrib.nmaxb) *
                     16)) /* Len exceed's tag's NDEF memory? */
@@ -2719,11 +2687,11 @@ tNFC_STATUS RW_T3tCheck(uint8_t num_blocks, tT3T_BLOCK_DESC* t3t_blocks) {
   tNFC_STATUS retval = NFC_STATUS_OK;
   tRW_T3T_CB* p_cb = &rw_cb.tcb.t3t;
 
-  RW_TRACE_API1("RW_T3tCheck (num_blocks = %i)", num_blocks);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_T3tCheck (num_blocks = %i)", num_blocks);
 
   /* Check if we are in valid state to handle this API */
   if (p_cb->rw_state != RW_T3T_STATE_IDLE) {
-    RW_TRACE_ERROR1("Error: invalid state to handle API (0x%x)",
+    LOG(ERROR) << StringPrintf("Error: invalid state to handle API (0x%x)",
                     p_cb->rw_state);
     return (NFC_STATUS_FAILED);
   }
@@ -2759,11 +2727,11 @@ tNFC_STATUS RW_T3tUpdate(uint8_t num_blocks, tT3T_BLOCK_DESC* t3t_blocks,
   tNFC_STATUS retval = NFC_STATUS_OK;
   tRW_T3T_CB* p_cb = &rw_cb.tcb.t3t;
 
-  RW_TRACE_API1("RW_T3tUpdate (num_blocks = %i)", num_blocks);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_T3tUpdate (num_blocks = %i)", num_blocks);
 
   /* Check if we are in valid state to handle this API */
   if (p_cb->rw_state != RW_T3T_STATE_IDLE) {
-    RW_TRACE_ERROR1("Error: invalid state to handle API (0x%x)",
+    LOG(ERROR) << StringPrintf("Error: invalid state to handle API (0x%x)",
                     p_cb->rw_state);
     return (NFC_STATUS_FAILED);
   }
@@ -2795,7 +2763,7 @@ tNFC_STATUS RW_T3tPresenceCheck(void) {
   tRW_DATA evt_data;
   tRW_CB* p_rw_cb = &rw_cb;
 
-  RW_TRACE_API0("RW_T3tPresenceCheck");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_T3tPresenceCheck");
 
   /* If RW_SelectTagType was not called (no conn_callback) return failure */
   if (!(p_rw_cb->p_cback)) {
@@ -2810,7 +2778,7 @@ tNFC_STATUS RW_T3tPresenceCheck(void) {
   else if (p_rw_cb->tcb.t3t.rw_state == RW_T3T_STATE_COMMAND_PENDING) {
     /* If already performing presence check, return error */
     if (p_rw_cb->tcb.t3t.flags & RW_T3T_FL_W4_PRESENCE_CHECK_POLL_RSP) {
-      RW_TRACE_DEBUG0("RW_T3tPresenceCheck already in progress");
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_T3tPresenceCheck already in progress");
       retval = NFC_STATUS_FAILED;
     }
     /* If busy with any other command, assume that the tag is present */
@@ -2829,7 +2797,7 @@ tNFC_STATUS RW_T3tPresenceCheck(void) {
       /* start timer for waiting for responses */
       rw_t3t_start_poll_timer(&p_rw_cb->tcb.t3t);
     } else {
-      RW_TRACE_DEBUG1(
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
           "RW_T3tPresenceCheck error sending NCI_RF_T3T_POLLING cmd (status = "
           "0x%0x)",
           retval);
@@ -2856,11 +2824,11 @@ tNFC_STATUS RW_T3tPoll(uint16_t system_code, tT3T_POLL_RC rc, uint8_t tsn) {
   tNFC_STATUS retval = NFC_STATUS_OK;
   tRW_T3T_CB* p_cb = &rw_cb.tcb.t3t;
 
-  RW_TRACE_API0("RW_T3tPoll");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_T3tPoll");
 
   /* Check if we are in valid state to handle this API */
   if (p_cb->rw_state != RW_T3T_STATE_IDLE) {
-    RW_TRACE_ERROR1("Error: invalid state to handle API (0x%x)",
+    LOG(ERROR) << StringPrintf("Error: invalid state to handle API (0x%x)",
                     p_cb->rw_state);
     return (NFC_STATUS_FAILED);
   }
@@ -2900,11 +2868,11 @@ tNFC_STATUS RW_T3tSendRawFrame(uint16_t len, uint8_t* p_data) {
   tNFC_STATUS retval = NFC_STATUS_OK;
   tRW_T3T_CB* p_cb = &rw_cb.tcb.t3t;
 
-  RW_TRACE_API1("RW_T3tSendRawFrame (len = %i)", len);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_T3tSendRawFrame (len = %i)", len);
 
   /* Check if we are in valid state to handle this API */
   if (p_cb->rw_state != RW_T3T_STATE_IDLE) {
-    RW_TRACE_ERROR1("Error: invalid state to handle API (0x%x)",
+    LOG(ERROR) << StringPrintf("Error: invalid state to handle API (0x%x)",
                     p_cb->rw_state);
     return (NFC_STATUS_FAILED);
   }
@@ -2936,11 +2904,11 @@ tNFC_STATUS RW_T3tGetSystemCodes(void) {
   tNFC_STATUS retval = NFC_STATUS_OK;
   tRW_T3T_CB* p_cb = &rw_cb.tcb.t3t;
 
-  RW_TRACE_API0("RW_T3tGetSystemCodes");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_T3tGetSystemCodes");
 
   /* Check if we are in valid state to handle this API */
   if (p_cb->rw_state != RW_T3T_STATE_IDLE) {
-    RW_TRACE_ERROR1("Error: invalid state to handle API (0x%x)",
+    LOG(ERROR) << StringPrintf("Error: invalid state to handle API (0x%x)",
                     p_cb->rw_state);
     return (NFC_STATUS_FAILED);
   } else {
@@ -2981,11 +2949,11 @@ tNFC_STATUS RW_T3tFormatNDef(void) {
   tNFC_STATUS retval = NFC_STATUS_OK;
   tRW_T3T_CB* p_cb = &rw_cb.tcb.t3t;
 
-  RW_TRACE_API0("RW_T3tFormatNDef");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_T3tFormatNDef");
 
   /* Check if we are in valid state to handle this API */
   if (p_cb->rw_state != RW_T3T_STATE_IDLE) {
-    RW_TRACE_ERROR1("Error: invalid state to handle API (0x%x)",
+    LOG(ERROR) << StringPrintf("Error: invalid state to handle API (0x%x)",
                     p_cb->rw_state);
     return (NFC_STATUS_FAILED);
   } else {
@@ -3027,11 +2995,11 @@ tNFC_STATUS RW_T3tSetReadOnly(bool b_hard_lock) {
   tRW_T3T_CB* p_cb = &rw_cb.tcb.t3t;
   tRW_DATA evt_data;
 
-  RW_TRACE_API1("RW_T3tSetReadOnly (): b_hard_lock=%d", b_hard_lock);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_T3tSetReadOnly (): b_hard_lock=%d", b_hard_lock);
 
   /* Check if we are in valid state to handle this API */
   if (p_cb->rw_state != RW_T3T_STATE_IDLE) {
-    RW_TRACE_ERROR1("Error: invalid state to handle API (0x%x)",
+    LOG(ERROR) << StringPrintf("Error: invalid state to handle API (0x%x)",
                     p_cb->rw_state);
     return (NFC_STATUS_FAILED);
   }
@@ -3039,7 +3007,7 @@ tNFC_STATUS RW_T3tSetReadOnly(bool b_hard_lock) {
   if (p_cb->ndef_attrib.status !=
       NFC_STATUS_OK) /* NDEF detection not performed yet? */
   {
-    RW_TRACE_ERROR0("Error: NDEF detection not performed yet");
+    LOG(ERROR) << StringPrintf("Error: NDEF detection not performed yet");
     return (NFC_STATUS_NOT_INITIALIZED);
   }
 
diff --git a/src/nfc/tags/rw_t4t.c b/src/nfc/tags/rw_t4t.cc
old mode 100644
new mode 100755
similarity index 89%
rename from src/nfc/tags/rw_t4t.c
rename to src/nfc/tags/rw_t4t.cc
index b9392f3..754f166
--- a/src/nfc/tags/rw_t4t.c
+++ b/src/nfc/tags/rw_t4t.cc
@@ -20,7 +20,7 @@
  *
  *  The original Work has been changed by NXP Semiconductors.
  *
- *  Copyright (C) 2015 NXP Semiconductors
+ *  Copyright (C) 2015-2018 NXP Semiconductors
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -43,16 +43,21 @@
  *
  ******************************************************************************/
 #include <string.h>
+
+#include <android-base/stringprintf.h>
+#include <base/logging.h>
+
 #include "nfc_target.h"
 #include "bt_types.h"
-#include "trace_api.h"
 
 #include "nfc_api.h"
 #include "nfc_int.h"
 #include "rw_api.h"
 #include "rw_int.h"
-#include "tags_int.h"
-#include "gki.h"
+
+using android::base::StringPrintf;
+
+extern bool nfc_debug_enabled;
 
 /* main state */
 /* T4T is not activated                 */
@@ -108,10 +113,8 @@
 #define RW_T3BT_SUBSTATE_WAIT_GET_PUPI 0x12
 #endif
 
-#if (BT_TRACE_VERBOSE == true)
-static char* rw_t4t_get_state_name(uint8_t state);
-static char* rw_t4t_get_sub_state_name(uint8_t sub_state);
-#endif
+static std::string rw_t4t_get_state_name(uint8_t state);
+static std::string rw_t4t_get_sub_state_name(uint8_t sub_state);
 
 static bool rw_t4t_send_to_lower(NFC_HDR* p_c_apdu);
 static bool rw_t4t_select_file(uint16_t file_id);
@@ -154,12 +157,8 @@ static void rw_t4t_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
 **
 *******************************************************************************/
 static bool rw_t4t_send_to_lower(NFC_HDR* p_c_apdu) {
-#if (BT_TRACE_PROTOCOL == true)
-  DispRWT4Tags(p_c_apdu, false);
-#endif
-
   if (NFC_SendData(NFC_RF_CONN_ID, p_c_apdu) != NFC_STATUS_OK) {
-    RW_TRACE_ERROR0("rw_t4t_send_to_lower (): NFC_SendData () failed");
+    LOG(ERROR) << StringPrintf("rw_t4t_send_to_lower (): NFC_SendData () failed");
     return false;
   }
 
@@ -185,7 +184,7 @@ static bool rw_t4t_get_hw_version(void) {
   p_c_apdu = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_c_apdu) {
-    RW_TRACE_ERROR0("rw_t4t_get_hw_version (): Cannot allocate buffer");
+    LOG(ERROR) << StringPrintf("rw_t4t_get_hw_version (): Cannot allocate buffer");
     return false;
   }
 
@@ -222,7 +221,7 @@ static bool rw_t4t_get_sw_version(void) {
   p_c_apdu = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_c_apdu) {
-    RW_TRACE_ERROR0("rw_t4t_get_sw_version (): Cannot allocate buffer");
+    LOG(ERROR) << StringPrintf("rw_t4t_get_sw_version (): Cannot allocate buffer");
     return false;
   }
 
@@ -302,7 +301,7 @@ static bool rw_t4t_get_uid_details(void) {
   p_c_apdu = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_c_apdu) {
-    RW_TRACE_ERROR0("rw_t4t_get_uid_details (): Cannot allocate buffer");
+    LOG(ERROR) << StringPrintf("rw_t4t_get_uid_details (): Cannot allocate buffer");
     return false;
   }
 
@@ -341,7 +340,7 @@ static bool rw_t4t_create_app(void) {
   p_c_apdu = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_c_apdu) {
-    RW_TRACE_ERROR0("rw_t4t_create_app (): Cannot allocate buffer");
+    LOG(ERROR) << StringPrintf("rw_t4t_create_app (): Cannot allocate buffer");
     return false;
   }
 
@@ -391,7 +390,7 @@ static bool rw_t4t_select_app(void) {
   p_c_apdu = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_c_apdu) {
-    RW_TRACE_ERROR0("rw_t4t_select_app (): Cannot allocate buffer");
+    LOG(ERROR) << StringPrintf("rw_t4t_select_app (): Cannot allocate buffer");
     return false;
   }
 
@@ -434,7 +433,7 @@ static bool rw_t4t_create_ccfile(void) {
   p_c_apdu = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_c_apdu) {
-    RW_TRACE_ERROR0("rw_t4t_create_ccfile (): Cannot allocate buffer");
+    LOG(ERROR) << StringPrintf("rw_t4t_create_ccfile (): Cannot allocate buffer");
     return false;
   }
 
@@ -482,7 +481,7 @@ static bool rw_t4t_create_ndef(void) {
   p_c_apdu = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_c_apdu) {
-    RW_TRACE_ERROR0("rw_t4t_create_ndef (): Cannot allocate buffer");
+    LOG(ERROR) << StringPrintf("rw_t4t_create_ndef (): Cannot allocate buffer");
     return false;
   }
 
@@ -534,7 +533,7 @@ static bool rw_t4t_write_cc(void) {
   p_c_apdu = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_c_apdu) {
-    RW_TRACE_ERROR0("rw_t4t_write_cc (): Cannot allocate buffer");
+    LOG(ERROR) << StringPrintf("rw_t4t_write_cc (): Cannot allocate buffer");
     return false;
   }
 
@@ -583,7 +582,7 @@ static bool rw_t4t_write_ndef(void) {
   p_c_apdu = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_c_apdu) {
-    RW_TRACE_ERROR0("rw_t4t_write_ndef (): Cannot allocate buffer");
+    LOG(ERROR) << StringPrintf("rw_t4t_write_ndef (): Cannot allocate buffer");
     return false;
   }
 
@@ -614,14 +613,13 @@ static bool rw_t4t_write_ndef(void) {
 
 #if (NXP_EXTNS == TRUE)
 static bool rw_t3bt_get_pupi(void) {
-  tRW_T4T_CB* p_t4t = &rw_cb.tcb.t4t;
   NFC_HDR* p_c_apdu;
   uint8_t* p;
 
   p_c_apdu = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_c_apdu) {
-    RW_TRACE_ERROR0("rw_t3bt_get_pupi (): Cannot allocate buffer");
+    LOG(ERROR) << StringPrintf("rw_t3bt_get_pupi (): Cannot allocate buffer");
     return false;
   }
 
@@ -654,12 +652,12 @@ static bool rw_t4t_select_file(uint16_t file_id) {
   NFC_HDR* p_c_apdu;
   uint8_t* p;
 
-  RW_TRACE_DEBUG1("rw_t4t_select_file (): File ID:0x%04X", file_id);
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t4t_select_file (): File ID:0x%04X", file_id);
 
   p_c_apdu = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_c_apdu) {
-    RW_TRACE_ERROR0("rw_t4t_select_file (): Cannot allocate buffer");
+    LOG(ERROR) << StringPrintf("rw_t4t_select_file (): Cannot allocate buffer");
     return false;
   }
 
@@ -705,13 +703,13 @@ static bool rw_t4t_read_file(uint16_t offset, uint16_t length,
   NFC_HDR* p_c_apdu;
   uint8_t* p;
 
-  RW_TRACE_DEBUG3("rw_t4t_read_file () offset:%d, length:%d, is_continue:%d, ",
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t4t_read_file () offset:%d, length:%d, is_continue:%d, ",
                   offset, length, is_continue);
 
   p_c_apdu = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_c_apdu) {
-    RW_TRACE_ERROR0("rw_t4t_read_file (): Cannot allocate buffer");
+    LOG(ERROR) << StringPrintf("rw_t4t_read_file (): Cannot allocate buffer");
     return false;
   }
 
@@ -759,12 +757,12 @@ static bool rw_t4t_update_nlen(uint16_t ndef_len) {
   NFC_HDR* p_c_apdu;
   uint8_t* p;
 
-  RW_TRACE_DEBUG1("rw_t4t_update_nlen () NLEN:%d", ndef_len);
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t4t_update_nlen () NLEN:%d", ndef_len);
 
   p_c_apdu = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_c_apdu) {
-    RW_TRACE_ERROR0("rw_t4t_update_nlen (): Cannot allocate buffer");
+    LOG(ERROR) << StringPrintf("rw_t4t_update_nlen (): Cannot allocate buffer");
     return false;
   }
 
@@ -801,13 +799,13 @@ static bool rw_t4t_update_file(void) {
   uint8_t* p;
   uint16_t length;
 
-  RW_TRACE_DEBUG2("rw_t4t_update_file () rw_offset:%d, rw_length:%d",
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t4t_update_file () rw_offset:%d, rw_length:%d",
                   p_t4t->rw_offset, p_t4t->rw_length);
 
   p_c_apdu = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_c_apdu) {
-    RW_TRACE_ERROR0("rw_t4t_write_file (): Cannot allocate buffer");
+    LOG(ERROR) << StringPrintf("rw_t4t_write_file (): Cannot allocate buffer");
     return false;
   }
 
@@ -857,13 +855,13 @@ static bool rw_t4t_update_cc_to_readonly(void) {
   NFC_HDR* p_c_apdu;
   uint8_t* p;
 
-  RW_TRACE_DEBUG0(
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "rw_t4t_update_cc_to_readonly (): Remove Write access from CC");
 
   p_c_apdu = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_c_apdu) {
-    RW_TRACE_ERROR0("rw_t4t_update_cc_to_readonly (): Cannot allocate buffer");
+    LOG(ERROR) << StringPrintf("rw_t4t_update_cc_to_readonly (): Cannot allocate buffer");
     return false;
   }
 
@@ -911,12 +909,12 @@ static bool rw_t4t_select_application(uint8_t version) {
   NFC_HDR* p_c_apdu;
   uint8_t* p;
 
-  RW_TRACE_DEBUG1("rw_t4t_select_application () version:0x%X", version);
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t4t_select_application () version:0x%X", version);
 
   p_c_apdu = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_c_apdu) {
-    RW_TRACE_ERROR0("rw_t4t_select_application (): Cannot allocate buffer");
+    LOG(ERROR) << StringPrintf("rw_t4t_select_application (): Cannot allocate buffer");
     return false;
   }
 
@@ -968,17 +966,17 @@ static bool rw_t4t_select_application(uint8_t version) {
 static bool rw_t4t_validate_cc_file(void) {
   tRW_T4T_CB* p_t4t = &rw_cb.tcb.t4t;
 
-  RW_TRACE_DEBUG0("rw_t4t_validate_cc_file ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t4t_validate_cc_file ()");
 
   if (p_t4t->cc_file.cclen < T4T_CC_FILE_MIN_LEN) {
-    RW_TRACE_ERROR1("rw_t4t_validate_cc_file (): CCLEN (%d) is too short",
+    LOG(ERROR) << StringPrintf("rw_t4t_validate_cc_file (): CCLEN (%d) is too short",
                     p_t4t->cc_file.cclen);
     return false;
   }
 
   if (T4T_GET_MAJOR_VERSION(p_t4t->cc_file.version) !=
       T4T_GET_MAJOR_VERSION(p_t4t->version)) {
-    RW_TRACE_ERROR2(
+    LOG(ERROR) << StringPrintf(
         "rw_t4t_validate_cc_file (): Peer version (0x%02X) is matched to ours "
         "(0x%02X)",
         p_t4t->cc_file.version, p_t4t->version);
@@ -986,13 +984,13 @@ static bool rw_t4t_validate_cc_file(void) {
   }
 
   if (p_t4t->cc_file.max_le < 0x000F) {
-    RW_TRACE_ERROR1("rw_t4t_validate_cc_file (): MaxLe (%d) is too small",
+    LOG(ERROR) << StringPrintf("rw_t4t_validate_cc_file (): MaxLe (%d) is too small",
                     p_t4t->cc_file.max_le);
     return false;
   }
 
   if (p_t4t->cc_file.max_lc < 0x0001) {
-    RW_TRACE_ERROR1("rw_t4t_validate_cc_file (): MaxLc (%d) is too small",
+    LOG(ERROR) << StringPrintf("rw_t4t_validate_cc_file (): MaxLc (%d) is too small",
                     p_t4t->cc_file.max_lc);
     return false;
   }
@@ -1005,21 +1003,21 @@ static bool rw_t4t_validate_cc_file(void) {
       (p_t4t->cc_file.ndef_fc.file_id == 0x3F00) ||
       (p_t4t->cc_file.ndef_fc.file_id == 0x3FFF) ||
       (p_t4t->cc_file.ndef_fc.file_id == 0xFFFF)) {
-    RW_TRACE_ERROR1("rw_t4t_validate_cc_file (): File ID (0x%04X) is invalid",
+    LOG(ERROR) << StringPrintf("rw_t4t_validate_cc_file (): File ID (0x%04X) is invalid",
                     p_t4t->cc_file.ndef_fc.file_id);
     return false;
   }
 
   if ((p_t4t->cc_file.ndef_fc.max_file_size < 0x0005) ||
       (p_t4t->cc_file.ndef_fc.max_file_size == 0xFFFF)) {
-    RW_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "rw_t4t_validate_cc_file (): max_file_size (%d) is reserved",
         p_t4t->cc_file.ndef_fc.max_file_size);
     return false;
   }
 
   if (p_t4t->cc_file.ndef_fc.read_access != T4T_FC_READ_ACCESS) {
-    RW_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "rw_t4t_validate_cc_file (): Read Access (0x%02X) is invalid",
         p_t4t->cc_file.ndef_fc.read_access);
     return false;
@@ -1027,7 +1025,7 @@ static bool rw_t4t_validate_cc_file(void) {
 
   if ((p_t4t->cc_file.ndef_fc.write_access != T4T_FC_WRITE_ACCESS) &&
       (p_t4t->cc_file.ndef_fc.write_access < T4T_FC_WRITE_ACCESS_PROP_START)) {
-    RW_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "rw_t4t_validate_cc_file (): Write Access (0x%02X) is invalid",
         p_t4t->cc_file.ndef_fc.write_access);
     return false;
@@ -1050,7 +1048,7 @@ static void rw_t4t_handle_error(tNFC_STATUS status, uint8_t sw1, uint8_t sw2) {
   tRW_DATA rw_data;
   tRW_EVENT event;
 
-  RW_TRACE_DEBUG4(
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
       "rw_t4t_handle_error (): status:0x%02X, sw1:0x%02X, sw2:0x%02X, "
       "state:0x%X",
       status, sw1, sw2, p_t4t->state);
@@ -1122,17 +1120,13 @@ static void rw_t4t_handle_error(tNFC_STATUS status, uint8_t sw1, uint8_t sw2) {
 *******************************************************************************/
 static void rw_t4t_sm_ndef_format(NFC_HDR* p_r_apdu) {
   tRW_T4T_CB* p_t4t = &rw_cb.tcb.t4t;
-  uint8_t* p, type, length;
-  uint16_t status_words, nlen;
+  uint8_t* p;
+  uint16_t status_words;
   tRW_DATA rw_data;
 
-#if (BT_TRACE_VERBOSE == true)
-  RW_TRACE_DEBUG2("rw_t4t_sm_ndef_format (): sub_state:%s (%d)",
-                  rw_t4t_get_sub_state_name(p_t4t->sub_state),
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t4t_sm_ndef_format (): sub_state:%s (%d)",
+                  rw_t4t_get_sub_state_name(p_t4t->sub_state).c_str(),
                   p_t4t->sub_state);
-#else
-  RW_TRACE_DEBUG1("rw_t4t_sm_ndef_format (): sub_state=%d", p_t4t->sub_state);
-#endif
 
   /* get status words */
   p = (uint8_t*)(p_r_apdu + 1) + p_r_apdu->offset;
@@ -1277,14 +1271,14 @@ static void rw_t4t_sm_ndef_format(NFC_HDR* p_r_apdu) {
 
           (*(rw_cb.p_cback))(RW_T4T_NDEF_FORMAT_CPLT_EVT, &rw_data);
 
-          RW_TRACE_DEBUG0(
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
               "rw_t4t_ndef_format (): Sent RW_T4T_NDEF_FORMAT_CPLT_EVT");
         }
       }
       break;
 
     default:
-      RW_TRACE_ERROR1("rw_t4t_sm_ndef_format (): unknown sub_state=%d",
+      LOG(ERROR) << StringPrintf("rw_t4t_sm_ndef_format (): unknown sub_state=%d",
                       p_t4t->sub_state);
       rw_t4t_handle_error(NFC_STATUS_FAILED, 0, 0);
       break;
@@ -1294,17 +1288,13 @@ static void rw_t4t_sm_ndef_format(NFC_HDR* p_r_apdu) {
 #if (NXP_EXTNS == TRUE)
 static void rw_t3Bt_sm_get_card_id(NFC_HDR* p_r_apdu) {
   tRW_T4T_CB* p_t4t = &rw_cb.tcb.t4t;
-  uint8_t* p, type, length;
-  uint16_t status_words, nlen;
+  uint8_t* p;
+  uint16_t status_words;
   tRW_DATA rw_data;
 
-#if (BT_TRACE_VERBOSE == true)
-  RW_TRACE_DEBUG2("rw_t3Bt_sm_get_id (): sub_state:%s (%d)",
-                  rw_t4t_get_sub_state_name(p_t4t->sub_state),
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t3Bt_sm_get_id (): sub_state:%s (%d)",
+                  rw_t4t_get_sub_state_name(p_t4t->sub_state).c_str(),
                   p_t4t->sub_state);
-#else
-  RW_TRACE_DEBUG1("rw_t3Bt_sm_get_id (): sub_state=%d", p_t4t->sub_state);
-#endif
 
   /* get status words */
   p = (uint8_t*)(p_r_apdu + 1) + p_r_apdu->offset;
@@ -1336,13 +1326,13 @@ static void rw_t3Bt_sm_get_card_id(NFC_HDR* p_r_apdu) {
         if (rw_cb.p_cback) {
           (*(rw_cb.p_cback))(RW_T3BT_RAW_READ_CPLT_EVT, &rw_data);
         } else {
-          RW_TRACE_ERROR0("rw_t3Bt_sm_get_id (): NULL callback");
+          LOG(ERROR) << StringPrintf("rw_t3Bt_sm_get_id (): NULL callback");
         }
       }
       break;
 
     default:
-      RW_TRACE_ERROR1("rw_t3Bt_sm_get_id (): unknown sub_state=%d",
+      LOG(ERROR) << StringPrintf("rw_t3Bt_sm_get_id (): unknown sub_state=%d",
                       p_t4t->sub_state);
       rw_t4t_handle_error(NFC_STATUS_FAILED, 0, 0);
       break;
@@ -1364,13 +1354,9 @@ static void rw_t4t_sm_detect_ndef(NFC_HDR* p_r_apdu) {
   uint16_t status_words, nlen;
   tRW_DATA rw_data;
 
-#if (BT_TRACE_VERBOSE == true)
-  RW_TRACE_DEBUG2("rw_t4t_sm_detect_ndef (): sub_state:%s (%d)",
-                  rw_t4t_get_sub_state_name(p_t4t->sub_state),
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t4t_sm_detect_ndef (): sub_state:%s (%d)",
+                  rw_t4t_get_sub_state_name(p_t4t->sub_state).c_str(),
                   p_t4t->sub_state);
-#else
-  RW_TRACE_DEBUG1("rw_t4t_sm_detect_ndef (): sub_state=%d", p_t4t->sub_state);
-#endif
 
   /* get status words */
   p = (uint8_t*)(p_r_apdu + 1) + p_r_apdu->offset;
@@ -1383,7 +1369,7 @@ static void rw_t4t_sm_detect_ndef(NFC_HDR* p_r_apdu) {
         (p_t4t->version == T4T_VERSION_2_0)) {
       p_t4t->version = T4T_VERSION_1_0;
 
-      RW_TRACE_DEBUG1("rw_t4t_sm_detect_ndef (): retry with version=0x%02X",
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t4t_sm_detect_ndef (): retry with version=0x%02X",
                       p_t4t->version);
 
       if (!rw_t4t_select_application(T4T_VERSION_1_0)) {
@@ -1439,22 +1425,20 @@ static void rw_t4t_sm_detect_ndef(NFC_HDR* p_r_apdu) {
           BE_STREAM_TO_UINT8(p_t4t->cc_file.ndef_fc.read_access, p);
           BE_STREAM_TO_UINT8(p_t4t->cc_file.ndef_fc.write_access, p);
 
-#if (BT_TRACE_VERBOSE == true)
-          RW_TRACE_DEBUG0("Capability Container (CC) file");
-          RW_TRACE_DEBUG1("  CCLEN:  0x%04X", p_t4t->cc_file.cclen);
-          RW_TRACE_DEBUG1("  Version:0x%02X", p_t4t->cc_file.version);
-          RW_TRACE_DEBUG1("  MaxLe:  0x%04X", p_t4t->cc_file.max_le);
-          RW_TRACE_DEBUG1("  MaxLc:  0x%04X", p_t4t->cc_file.max_lc);
-          RW_TRACE_DEBUG0("  NDEF File Control TLV");
-          RW_TRACE_DEBUG1("    FileID:      0x%04X",
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("Capability Container (CC) file");
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("  CCLEN:  0x%04X", p_t4t->cc_file.cclen);
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("  Version:0x%02X", p_t4t->cc_file.version);
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("  MaxLe:  0x%04X", p_t4t->cc_file.max_le);
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("  MaxLc:  0x%04X", p_t4t->cc_file.max_lc);
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("  NDEF File Control TLV");
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("    FileID:      0x%04X",
                           p_t4t->cc_file.ndef_fc.file_id);
-          RW_TRACE_DEBUG1("    MaxFileSize: 0x%04X",
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("    MaxFileSize: 0x%04X",
                           p_t4t->cc_file.ndef_fc.max_file_size);
-          RW_TRACE_DEBUG1("    ReadAccess:  0x%02X",
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("    ReadAccess:  0x%02X",
                           p_t4t->cc_file.ndef_fc.read_access);
-          RW_TRACE_DEBUG1("    WriteAccess: 0x%02X",
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("    WriteAccess: 0x%02X",
                           p_t4t->cc_file.ndef_fc.write_access);
-#endif
 
           if (rw_t4t_validate_cc_file()) {
             if (!rw_t4t_select_file(p_t4t->cc_file.ndef_fc.file_id)) {
@@ -1539,12 +1523,12 @@ static void rw_t4t_sm_detect_ndef(NFC_HDR* p_r_apdu) {
 
             (*(rw_cb.p_cback))(RW_T4T_NDEF_DETECT_EVT, &rw_data);
 
-            RW_TRACE_DEBUG0(
+           DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
                 "rw_t4t_sm_detect_ndef (): Sent RW_T4T_NDEF_DETECT_EVT");
           }
         } else {
           /* NLEN should be less than max file size */
-          RW_TRACE_ERROR2(
+          LOG(ERROR) << StringPrintf(
               "rw_t4t_sm_detect_ndef (): NLEN (%d) + 2 must be <= max file "
               "size (%d)",
               nlen, p_t4t->cc_file.ndef_fc.max_file_size);
@@ -1554,7 +1538,7 @@ static void rw_t4t_sm_detect_ndef(NFC_HDR* p_r_apdu) {
         }
       } else {
         /* response payload size should be T4T_FILE_LENGTH_SIZE */
-        RW_TRACE_ERROR2(
+        LOG(ERROR) << StringPrintf(
             "rw_t4t_sm_detect_ndef (): Length (%d) of R-APDU must be %d",
             p_r_apdu->len, T4T_FILE_LENGTH_SIZE + T4T_RSP_STATUS_WORDS_SIZE);
 
@@ -1564,7 +1548,7 @@ static void rw_t4t_sm_detect_ndef(NFC_HDR* p_r_apdu) {
       break;
 
     default:
-      RW_TRACE_ERROR1("rw_t4t_sm_detect_ndef (): unknown sub_state=%d",
+      LOG(ERROR) << StringPrintf("rw_t4t_sm_detect_ndef (): unknown sub_state=%d",
                       p_t4t->sub_state);
       rw_t4t_handle_error(NFC_STATUS_FAILED, 0, 0);
       break;
@@ -1586,13 +1570,9 @@ static void rw_t4t_sm_read_ndef(NFC_HDR* p_r_apdu) {
   uint16_t status_words;
   tRW_DATA rw_data;
 
-#if (BT_TRACE_VERBOSE == true)
-  RW_TRACE_DEBUG2("rw_t4t_sm_read_ndef (): sub_state:%s (%d)",
-                  rw_t4t_get_sub_state_name(p_t4t->sub_state),
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t4t_sm_read_ndef (): sub_state:%s (%d)",
+                  rw_t4t_get_sub_state_name(p_t4t->sub_state).c_str(),
                   p_t4t->sub_state);
-#else
-  RW_TRACE_DEBUG1("rw_t4t_sm_read_ndef (): sub_state=%d", p_t4t->sub_state);
-#endif
 
   /* get status words */
   p = (uint8_t*)(p_r_apdu + 1) + p_r_apdu->offset;
@@ -1631,7 +1611,7 @@ static void rw_t4t_sm_read_ndef(NFC_HDR* p_r_apdu) {
 
             (*(rw_cb.p_cback))(RW_T4T_NDEF_READ_CPLT_EVT, &rw_data);
 
-            RW_TRACE_DEBUG0(
+           DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
                 "rw_t4t_sm_read_ndef (): Sent RW_T4T_NDEF_READ_CPLT_EVT");
           }
 
@@ -1641,7 +1621,7 @@ static void rw_t4t_sm_read_ndef(NFC_HDR* p_r_apdu) {
           p_t4t->state = RW_T4T_STATE_IDLE;
         }
       } else {
-        RW_TRACE_ERROR2(
+        LOG(ERROR) << StringPrintf(
             "rw_t4t_sm_read_ndef (): invalid payload length (%d), rw_length "
             "(%d)",
             p_r_apdu->len, p_t4t->rw_length);
@@ -1650,7 +1630,7 @@ static void rw_t4t_sm_read_ndef(NFC_HDR* p_r_apdu) {
       break;
 
     default:
-      RW_TRACE_ERROR1("rw_t4t_sm_read_ndef (): unknown sub_state = %d",
+      LOG(ERROR) << StringPrintf("rw_t4t_sm_read_ndef (): unknown sub_state = %d",
                       p_t4t->sub_state);
       rw_t4t_handle_error(NFC_STATUS_FAILED, 0, 0);
       break;
@@ -1674,13 +1654,9 @@ static void rw_t4t_sm_update_ndef(NFC_HDR* p_r_apdu) {
   uint16_t status_words;
   tRW_DATA rw_data;
 
-#if (BT_TRACE_VERBOSE == true)
-  RW_TRACE_DEBUG2("rw_t4t_sm_update_ndef (): sub_state:%s (%d)",
-                  rw_t4t_get_sub_state_name(p_t4t->sub_state),
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t4t_sm_update_ndef (): sub_state:%s (%d)",
+                  rw_t4t_get_sub_state_name(p_t4t->sub_state).c_str(),
                   p_t4t->sub_state);
-#else
-  RW_TRACE_DEBUG1("rw_t4t_sm_update_ndef (): sub_state=%d", p_t4t->sub_state);
-#endif
 
   /* Get status words */
   p = (uint8_t*)(p_r_apdu + 1) + p_r_apdu->offset;
@@ -1712,7 +1688,7 @@ static void rw_t4t_sm_update_ndef(NFC_HDR* p_r_apdu) {
           rw_data.status = NFC_STATUS_OK;
 
           (*(rw_cb.p_cback))(RW_T4T_NDEF_UPDATE_CPLT_EVT, &rw_data);
-          RW_TRACE_DEBUG0(
+         DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf(
               "rw_t4t_sm_update_ndef (): Sent RW_T4T_NDEF_UPDATE_CPLT_EVT");
         }
       }
@@ -1739,7 +1715,7 @@ static void rw_t4t_sm_update_ndef(NFC_HDR* p_r_apdu) {
       break;
 
     default:
-      RW_TRACE_ERROR1("rw_t4t_sm_update_ndef (): unknown sub_state = %d",
+      LOG(ERROR) << StringPrintf("rw_t4t_sm_update_ndef (): unknown sub_state = %d",
                       p_t4t->sub_state);
       rw_t4t_handle_error(NFC_STATUS_FAILED, 0, 0);
       break;
@@ -1761,13 +1737,9 @@ static void rw_t4t_sm_set_readonly(NFC_HDR* p_r_apdu) {
   uint16_t status_words;
   tRW_DATA rw_data;
 
-#if (BT_TRACE_VERBOSE == true)
-  RW_TRACE_DEBUG2("rw_t4t_sm_set_readonly (): sub_state:%s (%d)",
-                  rw_t4t_get_sub_state_name(p_t4t->sub_state),
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t4t_sm_set_readonly (): sub_state:%s (%d)",
+                  rw_t4t_get_sub_state_name(p_t4t->sub_state).c_str(),
                   p_t4t->sub_state);
-#else
-  RW_TRACE_DEBUG1("rw_t4t_sm_set_readonly (): sub_state=%d", p_t4t->sub_state);
-#endif
 
   /* Get status words */
   p = (uint8_t*)(p_r_apdu + 1) + p_r_apdu->offset;
@@ -1810,13 +1782,13 @@ static void rw_t4t_sm_set_readonly(NFC_HDR* p_r_apdu) {
       if (rw_cb.p_cback) {
         rw_data.status = NFC_STATUS_OK;
 
-        RW_TRACE_DEBUG0("rw_t4t_sm_set_readonly (): Sent RW_T4T_SET_TO_RO_EVT");
+       DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t4t_sm_set_readonly (): Sent RW_T4T_SET_TO_RO_EVT");
         (*(rw_cb.p_cback))(RW_T4T_SET_TO_RO_EVT, &rw_data);
       }
       break;
 
     default:
-      RW_TRACE_ERROR1("rw_t4t_sm_set_readonly (): unknown sub_state = %d",
+      LOG(ERROR) << StringPrintf("rw_t4t_sm_set_readonly (): unknown sub_state = %d",
                       p_t4t->sub_state);
       rw_t4t_handle_error(NFC_STATUS_FAILED, 0, 0);
       break;
@@ -1833,12 +1805,12 @@ static void rw_t4t_sm_set_readonly(NFC_HDR* p_r_apdu) {
 **
 *******************************************************************************/
 void rw_t4t_process_timeout(TIMER_LIST_ENT* p_tle) {
-  RW_TRACE_DEBUG1("rw_t4t_process_timeout () event=%d", p_tle->event);
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t4t_process_timeout () event=%d", p_tle->event);
 
   if (p_tle->event == NFC_TTYPE_RW_T4T_RESPONSE) {
     rw_t4t_handle_error(NFC_STATUS_TIMEOUT, 0, 0);
   } else {
-    RW_TRACE_ERROR1("rw_t4t_process_timeout () unknown event=%d", p_tle->event);
+    LOG(ERROR) << StringPrintf("rw_t4t_process_timeout () unknown event=%d", p_tle->event);
   }
 }
 
@@ -1851,10 +1823,10 @@ void rw_t4t_process_timeout(TIMER_LIST_ENT* p_tle) {
 ** Returns          none
 **
 *******************************************************************************/
-void rw_t4t_handle_isodep_nak_rsp(uint8_t status,bool is_ntf) {
+void rw_t4t_handle_isodep_nak_rsp(uint8_t status, bool is_ntf) {
   tRW_DATA rw_data;
   tRW_T4T_CB* p_t4t = &rw_cb.tcb.t4t;
-  RW_TRACE_DEBUG1("rw_t4t_handle_isodep_nak_rsp %d", status);
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t4t_handle_isodep_nak_rsp %d", status);
   if (is_ntf || (status != NFC_STATUS_OK)) {
     rw_data.status = status;
     nfc_stop_quick_timer(&p_t4t->timer);
@@ -1872,18 +1844,15 @@ void rw_t4t_handle_isodep_nak_rsp(uint8_t status,bool is_ntf) {
 ** Returns          none
 **
 *******************************************************************************/
-static void rw_t4t_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
+static void rw_t4t_data_cback(__attribute__((unused)) uint8_t conn_id, tNFC_CONN_EVT event,
                               tNFC_CONN* p_data) {
   tRW_T4T_CB* p_t4t = &rw_cb.tcb.t4t;
   NFC_HDR* p_r_apdu;
   tRW_DATA rw_data;
-  (void)conn_id;
 
-#if (BT_TRACE_VERBOSE == true)
   uint8_t begin_state = p_t4t->state;
-#endif
 
-  RW_TRACE_DEBUG1("rw_t4t_data_cback () event = 0x%X", event);
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t4t_data_cback () event = 0x%X", event);
   nfc_stop_quick_timer(&p_t4t->timer);
 
   switch (event) {
@@ -1937,28 +1906,15 @@ static void rw_t4t_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
       return;
   }
 
-#if (BT_TRACE_PROTOCOL == true)
-  if (p_t4t->state != RW_T4T_STATE_IDLE) DispRWT4Tags(p_r_apdu, true);
-#endif
-
-#if (BT_TRACE_VERBOSE == true)
-  RW_TRACE_DEBUG2("RW T4T state: <%s (%d)>",
-                  rw_t4t_get_state_name(p_t4t->state), p_t4t->state);
-#else
-  RW_TRACE_DEBUG1("RW T4T state: %d", p_t4t->state);
-#endif
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW T4T state: <%s (%d)>",
+                  rw_t4t_get_state_name(p_t4t->state).c_str(), p_t4t->state);
 
   switch (p_t4t->state) {
     case RW_T4T_STATE_IDLE:
 /* Unexpected R-APDU, it should be raw frame response */
 /* forward to upper layer without parsing */
-#if (BT_TRACE_VERBOSE == true)
-      RW_TRACE_DEBUG2("RW T4T Raw Frame: Len [0x%X] Status [%s]", p_r_apdu->len,
-                      NFC_GetStatusName(p_data->data.status));
-#else
-      RW_TRACE_DEBUG2("RW T4T Raw Frame: Len [0x%X] Status [0x%X]",
-                      p_r_apdu->len, p_data->data.status);
-#endif
+     DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW T4T Raw Frame: Len [0x%X] Status [%s]", p_r_apdu->len,
+                      NFC_GetStatusName(p_data->data.status).c_str());
       if (rw_cb.p_cback) {
         rw_data.raw_frame.status = p_data->data.status;
         rw_data.raw_frame.p_data = p_r_apdu;
@@ -2002,18 +1958,16 @@ static void rw_t4t_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
       break;
 #endif
     default:
-      RW_TRACE_ERROR1("rw_t4t_data_cback (): invalid state=%d", p_t4t->state);
+      LOG(ERROR) << StringPrintf("rw_t4t_data_cback (): invalid state=%d", p_t4t->state);
       GKI_freebuf(p_r_apdu);
       break;
   }
 
-#if (BT_TRACE_VERBOSE == true)
   if (begin_state != p_t4t->state) {
-    RW_TRACE_DEBUG2("RW T4T state changed:<%s> -> <%s>",
-                    rw_t4t_get_state_name(begin_state),
-                    rw_t4t_get_state_name(p_t4t->state));
+   DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW T4T state changed:<%s> -> <%s>",
+                    rw_t4t_get_state_name(begin_state).c_str(),
+                    rw_t4t_get_state_name(p_t4t->state).c_str());
   }
-#endif
 }
 
 /*******************************************************************************
@@ -2026,10 +1980,10 @@ static void rw_t4t_data_cback(uint8_t conn_id, tNFC_CONN_EVT event,
 **
 *******************************************************************************/
 tNFC_STATUS RW_T4tFormatNDef(void) {
-  RW_TRACE_API0("RW_T4tFormatNDef ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_T4tFormatNDef ()");
 
   if (rw_cb.tcb.t4t.state != RW_T4T_STATE_IDLE) {
-    RW_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "RW_T4tFormatNDef ():Unable to start command at state (0x%X)",
         rw_cb.tcb.t4t.state);
     return NFC_STATUS_FAILED;
@@ -2057,7 +2011,7 @@ tNFC_STATUS RW_T4tFormatNDef(void) {
 tNFC_STATUS rw_t4t_select(void) {
   tRW_T4T_CB* p_t4t = &rw_cb.tcb.t4t;
 
-  RW_TRACE_DEBUG0("rw_t4t_select ()");
+ DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("rw_t4t_select ()");
 
   NFC_SetStaticRfCback(rw_t4t_data_cback);
 
@@ -2087,10 +2041,10 @@ tNFC_STATUS rw_t4t_select(void) {
 **
 *******************************************************************************/
 tNFC_STATUS RW_T4tDetectNDef(void) {
-  RW_TRACE_API0("RW_T4tDetectNDef ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_T4tDetectNDef ()");
 
   if (rw_cb.tcb.t4t.state != RW_T4T_STATE_IDLE) {
-    RW_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "RW_T4tDetectNDef ():Unable to start command at state (0x%X)",
         rw_cb.tcb.t4t.state);
     return NFC_STATUS_FAILED;
@@ -2133,10 +2087,10 @@ tNFC_STATUS RW_T4tDetectNDef(void) {
 **
 *******************************************************************************/
 tNFC_STATUS RW_T4tReadNDef(void) {
-  RW_TRACE_API0("RW_T4tReadNDef ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_T4tReadNDef ()");
 
   if (rw_cb.tcb.t4t.state != RW_T4T_STATE_IDLE) {
-    RW_TRACE_ERROR1("RW_T4tReadNDef ():Unable to start command at state (0x%X)",
+    LOG(ERROR) << StringPrintf("RW_T4tReadNDef ():Unable to start command at state (0x%X)",
                     rw_cb.tcb.t4t.state);
     return NFC_STATUS_FAILED;
   }
@@ -2154,7 +2108,7 @@ tNFC_STATUS RW_T4tReadNDef(void) {
 
     return NFC_STATUS_OK;
   } else {
-    RW_TRACE_ERROR0("RW_T4tReadNDef ():No NDEF detected");
+    LOG(ERROR) << StringPrintf("RW_T4tReadNDef ():No NDEF detected");
     return NFC_STATUS_FAILED;
   }
 }
@@ -2177,10 +2131,10 @@ tNFC_STATUS RW_T4tReadNDef(void) {
 **
 *******************************************************************************/
 tNFC_STATUS RW_T4tUpdateNDef(uint16_t length, uint8_t* p_data) {
-  RW_TRACE_API1("RW_T4tUpdateNDef () length:%d", length);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_T4tUpdateNDef () length:%d", length);
 
   if (rw_cb.tcb.t4t.state != RW_T4T_STATE_IDLE) {
-    RW_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "RW_T4tUpdateNDef ():Unable to start command at state (0x%X)",
         rw_cb.tcb.t4t.state);
     return NFC_STATUS_FAILED;
@@ -2190,13 +2144,13 @@ tNFC_STATUS RW_T4tUpdateNDef(uint16_t length, uint8_t* p_data) {
   if (rw_cb.tcb.t4t.ndef_status & RW_T4T_NDEF_STATUS_NDEF_DETECTED) {
     /* if read-only */
     if (rw_cb.tcb.t4t.ndef_status & RW_T4T_NDEF_STATUS_NDEF_READ_ONLY) {
-      RW_TRACE_ERROR0("RW_T4tUpdateNDef ():NDEF is read-only");
+      LOG(ERROR) << StringPrintf("RW_T4tUpdateNDef ():NDEF is read-only");
       return NFC_STATUS_FAILED;
     }
 
     if (rw_cb.tcb.t4t.cc_file.ndef_fc.max_file_size <
         length + T4T_FILE_LENGTH_SIZE) {
-      RW_TRACE_ERROR2(
+      LOG(ERROR) << StringPrintf(
           "RW_T4tUpdateNDef ():data (%d bytes) plus NLEN is more than max file "
           "size (%d)",
           length, rw_cb.tcb.t4t.cc_file.ndef_fc.max_file_size);
@@ -2220,7 +2174,7 @@ tNFC_STATUS RW_T4tUpdateNDef(uint16_t length, uint8_t* p_data) {
 
     return NFC_STATUS_OK;
   } else {
-    RW_TRACE_ERROR0("RW_T4tUpdateNDef ():No NDEF detected");
+    LOG(ERROR) << StringPrintf("RW_T4tUpdateNDef ():No NDEF detected");
     return NFC_STATUS_FAILED;
   }
 }
@@ -2249,7 +2203,7 @@ tNFC_STATUS RW_T4tPresenceCheck(uint8_t option) {
   bool status;
   NFC_HDR* p_data;
 
-  RW_TRACE_API1("RW_T4tPresenceCheck () %d", option);
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_T4tPresenceCheck () %d", option);
 
   /* If RW_SelectTagType was not called (no conn_callback) return failure */
   if (!rw_cb.p_cback) {
@@ -2277,14 +2231,7 @@ tNFC_STATUS RW_T4tPresenceCheck(uint8_t option) {
           status = true;
       }
     } else if (option == RW_T4T_CHK_ISO_DEP_NAK_PRES_CHK) {
-      if (NFC_ISODEPNakPresCheck() == NFC_STATUS_OK)
-        status = true;
-    } else {
-      /* use read binary on the given channel */
-      rw_cb.tcb.t4t.channel = 0;
-      if (option <= RW_T4T_CHK_READ_BINARY_CH3) rw_cb.tcb.t4t.channel = option;
-      status = rw_t4t_read_file(0, 1, false);
-      rw_cb.tcb.t4t.channel = 0;
+      if (NFC_ISODEPNakPresCheck() == NFC_STATUS_OK) status = true;
     }
 
     if (status == true) {
@@ -2314,10 +2261,10 @@ tNFC_STATUS RW_T4tSetNDefReadOnly(void) {
   tNFC_STATUS retval = NFC_STATUS_OK;
   tRW_DATA evt_data;
 
-  RW_TRACE_API0("RW_T4tSetNDefReadOnly ()");
+  DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_T4tSetNDefReadOnly ()");
 
   if (rw_cb.tcb.t4t.state != RW_T4T_STATE_IDLE) {
-    RW_TRACE_ERROR1(
+    LOG(ERROR) << StringPrintf(
         "RW_T4tSetNDefReadOnly ():Unable to start command at state (0x%X)",
         rw_cb.tcb.t4t.state);
     return NFC_STATUS_FAILED;
@@ -2327,7 +2274,7 @@ tNFC_STATUS RW_T4tSetNDefReadOnly(void) {
   if (rw_cb.tcb.t4t.ndef_status & RW_T4T_NDEF_STATUS_NDEF_DETECTED) {
     /* if read-only */
     if (rw_cb.tcb.t4t.ndef_status & RW_T4T_NDEF_STATUS_NDEF_READ_ONLY) {
-      RW_TRACE_API0("RW_T4tSetNDefReadOnly (): NDEF is already read-only");
+      DLOG_IF(INFO, nfc_debug_enabled) << StringPrintf("RW_T4tSetNDefReadOnly (): NDEF is already read-only");
 
       evt_data.status = NFC_STATUS_OK;
       (*rw_cb.p_cback)(RW_T4T_SET_TO_RO_EVT, &evt_data);
@@ -2344,7 +2291,7 @@ tNFC_STATUS RW_T4tSetNDefReadOnly(void) {
 
     return NFC_STATUS_OK;
   } else {
-    RW_TRACE_ERROR0("RW_T4tSetNDefReadOnly ():No NDEF detected");
+    LOG(ERROR) << StringPrintf("RW_T4tSetNDefReadOnly ():No NDEF detected");
     return NFC_STATUS_FAILED;
   }
   return (retval);
@@ -2358,7 +2305,7 @@ tNFC_STATUS RW_T3BtGetPupiID(void) {
   p_c_apdu = (NFC_HDR*)GKI_getpoolbuf(NFC_RW_POOL_ID);
 
   if (!p_c_apdu) {
-    RW_TRACE_ERROR0("RW_T3BtGetPupiID (): Cannot allocate buffer");
+    LOG(ERROR) << StringPrintf("RW_T3BtGetPupiID (): Cannot allocate buffer");
     return false;
   }
 
@@ -2383,7 +2330,6 @@ tNFC_STATUS RW_T3BtGetPupiID(void) {
 }
 #endif
 
-#if (BT_TRACE_VERBOSE == true)
 /*******************************************************************************
 **
 ** Function         rw_t4t_get_state_name
@@ -2395,7 +2341,7 @@ tNFC_STATUS RW_T3BtGetPupiID(void) {
 ** Returns          pointer to the name
 **
 *******************************************************************************/
-static char* rw_t4t_get_state_name(uint8_t state) {
+static std::string rw_t4t_get_state_name(uint8_t state) {
   switch (state) {
     case RW_T4T_STATE_NOT_ACTIVATED:
       return ("NOT_ACTIVATED");
@@ -2428,7 +2374,7 @@ static char* rw_t4t_get_state_name(uint8_t state) {
 ** Returns          pointer to the name
 **
 *******************************************************************************/
-static char* rw_t4t_get_sub_state_name(uint8_t sub_state) {
+static std::string rw_t4t_get_sub_state_name(uint8_t sub_state) {
   switch (sub_state) {
     case RW_T4T_SUBSTATE_WAIT_SELECT_APP:
       return ("WAIT_SELECT_APP");
@@ -2473,4 +2419,3 @@ static char* rw_t4t_get_sub_state_name(uint8_t sub_state) {
       return ("???? UNKNOWN SUBSTATE");
   }
 }
-#endif
diff --git a/src/nfc/tags/tags_int.c b/src/nfc/tags/tags_int.cc
similarity index 97%
rename from src/nfc/tags/tags_int.c
rename to src/nfc/tags/tags_int.cc
index fe554b0..8942103 100644
--- a/src/nfc/tags/tags_int.c
+++ b/src/nfc/tags/tags_int.cc
@@ -25,10 +25,8 @@
 #include "nfc_target.h"
 #include "bt_types.h"
 
-#include "nfc_api.h"
 #include "rw_api.h"
 #include "rw_int.h"
-#include "tags_int.h"
 
 #define T1T_MAX_NUM_OPCODES 9
 #define T1T_STATIC_OPCODES 5
@@ -92,16 +90,14 @@ const uint8_t t4t_v10_ndef_tag_aid[T4T_V10_NDEF_TAG_AID_LEN] = {
 const uint8_t t4t_v20_ndef_tag_aid[T4T_V20_NDEF_TAG_AID_LEN] = {
     0xD2, 0x76, 0x00, 0x00, 0x85, 0x01, 0x01};
 
-#if (BT_TRACE_PROTOCOL == true)
 const char* const t1t_cmd_str[] = {
     "T1T_RID",  "T1T_RALL",  "T1T_READ",     "T1T_WRITE_E",  "T1T_WRITE_NE",
     "T1T_RSEG", "T1T_READ8", "T1T_WRITE_E8", "T1T_WRITE_NE8"};
 
 const char* const t2t_cmd_str[] = {"T2T_CMD_READ", "T2T_CMD_WRITE",
                                    "T2T_CMD_SEC_SEL"};
-#endif
 
-static unsigned int tags_ones32(register unsigned int x);
+static unsigned int tags_ones32(unsigned int x);
 
 /*******************************************************************************
 **
@@ -229,7 +225,6 @@ uint8_t t2t_info_to_evt(const tT2T_CMD_RSP_INFO* p_info) {
   return ((uint8_t)(p_info - t2t_cmd_rsp_infos) + RW_T2T_FIRST_EVT);
 }
 
-#if (BT_TRACE_PROTOCOL == true)
 /*******************************************************************************
 **
 ** Function         t1t_info_to_str
@@ -265,7 +260,6 @@ const char* t2t_info_to_str(const tT2T_CMD_RSP_INFO* p_info) {
   else
     return "";
 }
-#endif
 
 /*******************************************************************************
 **
@@ -294,7 +288,7 @@ int tags_pow(int x, int y) {
 ** Returns          int
 **
 *******************************************************************************/
-static unsigned int tags_ones32(register unsigned int x) {
+static unsigned int tags_ones32(unsigned int x) {
   /* 32-bit recursive reduction using SWAR...
  but first step is mapping 2-bit values
  into sum of 2 1-bit values in sneaky way
@@ -316,7 +310,7 @@ static unsigned int tags_ones32(register unsigned int x) {
 ** Returns          int
 **
 *******************************************************************************/
-unsigned int tags_log2(register unsigned int x) {
+unsigned int tags_log2(unsigned int x) {
   x |= (x >> 1);
   x |= (x >> 2);
   x |= (x >> 4);
diff --git a/src/static-lib-adapt/ProtoDispBluetoothHci.c b/src/static-lib-adapt/ProtoDispBluetoothHci.c
deleted file mode 100644
index 449a5ae..0000000
--- a/src/static-lib-adapt/ProtoDispBluetoothHci.c
+++ /dev/null
@@ -1,162 +0,0 @@
-/******************************************************************************
- *  Copyright (c) 2016, The Linux Foundation. All rights reserved.
- *  Not a Contribution.
- *
- *  Copyright (C) 2011-2012 Broadcom Corporation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at:
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-#include "_OverrideLog.h"
-#include "ProtoDispBluetoothHci.h"
-#include "nfc_target.h"
-#include <cutils/log.h>
-
-extern uint8_t* HCIDisp1(char* p_descr, uint8_t* p_data);
-extern uint32_t ScrProtocolTraceFlag;
-#define HCI_GEN_TRACE \
-  (TRACE_CTRL_GENERAL | TRACE_LAYER_HCI | TRACE_ORG_PROTO_DISP | hci_trace_type)
-static uint8_t hci_trace_type = 0;
-static char* modes_str[] = {"No sleep mode", "UART", "UART with messaging",
-                            "USB", "H4IBSS", "USB with host wake", "SDIO",
-                            "UART CS-N", "SPI", "H5", "H4DS", "",
-                            "UART with BREAK"};
-static uint8_t* p_end_hci = NULL;
-static uint8_t* HCIDisp1Ext(char* p_descr, uint8_t* p_data, char* p_ext);
-static void disp_sleepmode(uint8_t* p);
-static void disp_sleepmode_evt(uint8_t* p);
-
-///////////////////////////////////////////
-///////////////////////////////////////////
-
-uint8_t* HCIDisp1Ext(char* p_descr, uint8_t* p_data, char* p_ext) {
-    if (p_data == p_end_hci) return p_data;
-
-    char buff[200];
-
-    snprintf (buff, 200, "%40s : %u (0x%02x): %s", p_descr, *p_data, *p_data, p_ext);
-
-    ScrLog (HCI_GEN_TRACE, "%s", buff);
-    return (p_data + 1);
-}
-
-/*******************************************************************************
-**
-** Function         disp_sleepmode
-**
-** Description      Displays VSC sleep mode
-**
-** Returns          none.
-**
-*******************************************************************************/
-void disp_sleepmode(uint8_t* p) {
-  hci_trace_type = TRACE_TYPE_CMD_TX;
-  ScrLog(HCI_GEN_TRACE, "--");
-  int len = p[2];
-  ScrLog(HCI_GEN_TRACE,
-         "SEND Command to HCI.  Name: Set_Sleepmode_Param   (Hex Code: 0xfc27  "
-         "Param Len: %d)",
-         len);
-  p += 3;
-  p_end_hci = p + len;
-  p = HCIDisp1Ext("Sleep_Mode", p, (*p <= 12) ? modes_str[*p] : "");
-  p = HCIDisp1("Idle_Threshold_Host", p);
-  p = HCIDisp1("Idle_Threshold_HC", p);
-  p = HCIDisp1Ext("BT_WAKE_Active_Mode", p,
-                  (*p == 0) ? "Active Low" : ((*p == 1) ? "Active High" : ""));
-  p = HCIDisp1Ext("HOST_WAKE_Active_Mode", p,
-                  (*p == 0) ? "Active Low" : ((*p == 1) ? "Active High" : ""));
-  p = HCIDisp1("Allow_Host_Sleep_During_SCO", p);
-  p = HCIDisp1("Combine_Sleep_Mode_And_LPM", p);
-  p = HCIDisp1("Enable_Tristate_Control_Of_UART_Tx_Line", p);
-  p = HCIDisp1Ext("Active_Connection_Handling_On_Suspend", p,
-                  (*p == 0)
-                      ? "Maintain connections; sleep when timed activity allows"
-                      : ((*p == 1) ? "Sleep until resume is detected" : ""));
-  p = HCIDisp1("Resume_Timeout", p);
-  p = HCIDisp1("Enable_BREAK_To_Host", p);
-  p = HCIDisp1("Pulsed_HOST_WAKE", p);
-
-  ScrLog(HCI_GEN_TRACE, "--");
-}
-
-/*******************************************************************************
-**
-** Function         disp_sleepmode_evt
-**
-** Description      Displays HCI comand complete event for VSC sleep mode.
-**
-** Returns          none.
-**
-*******************************************************************************/
-void disp_sleepmode_evt(uint8_t* p) {
-  uint8_t len = p[1], status = p[5];
-
-  hci_trace_type = TRACE_TYPE_EVT_RX;
-  ScrLog(HCI_GEN_TRACE, "--");
-  ScrLog(HCI_GEN_TRACE,
-         "RCVD Event from HCI. Name: HCI_Command_Complete  (Hex Code: 0x0e  "
-         "Param Len: %d)",
-         len);
-
-  p = HCIDisp1("Num HCI Cmd Packets", p + 2);
-  ScrLog(HCI_GEN_TRACE, "%40s : 0xfc27  (Set_Sleepmode_Param)", "Cmd Code");
-  ScrLog(HCI_GEN_TRACE, "%40s : %d (0x%02x) %s", "Status", status, status,
-         (status == 0) ? "Success" : "");
-  ScrLog(HCI_GEN_TRACE, "--");
-}
-
-/*******************************************************************************
-**
-** Function         ProtoDispBluetoothHciCmd
-**
-** Description      Display a HCI command string
-**
-** Returns:
-**                  Nothing
-**
-*******************************************************************************/
-void ProtoDispBluetoothHciCmd(NFC_HDR* p_buf) {
-  if (!(ScrProtocolTraceFlag & SCR_PROTO_TRACE_HCI_SUMMARY)) return;
-  uint8_t* p = (uint8_t*)(p_buf + 1) + p_buf->offset;
-  if (*(p) == 0x27 && *(p + 1) == 0xfc)  // opcode sleep mode
-  {
-    disp_sleepmode(p);
-  }
-}
-
-/*******************************************************************************
-**
-** Function         ProtoDispBluetoothHciEvt
-**
-** Description      display a NCI event
-**
-** Returns:
-**                  Nothing
-**
-*******************************************************************************/
-void ProtoDispBluetoothHciEvt(NFC_HDR* pBuffer) {
-  if (!(ScrProtocolTraceFlag & SCR_PROTO_TRACE_HCI_SUMMARY)) return;
-
-  uint8_t* p = (uint8_t*)(pBuffer + 1) + pBuffer->offset;
-  if (*p == 0x0e)  // command complete
-  {
-    if (*(p + 1) == 4)  // length
-    {
-      if (*(p + 3) == 0x27 && *(p + 4) == 0xfc)  // opcode 0x27fc (sleep mode)
-      {
-        disp_sleepmode_evt(p);
-      }
-    }
-  }
-}
diff --git a/src/udrv/include/upio.h b/src/udrv/include/upio.h
deleted file mode 100644
index 06555c7..0000000
--- a/src/udrv/include/upio.h
+++ /dev/null
@@ -1,348 +0,0 @@
-/******************************************************************************
- *
- *  Copyright (C) 2001-2012 Broadcom Corporation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at:
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-/******************************************************************************
- *
- *  Definitions for UPIO driver
- *
- ******************************************************************************/
-#ifndef UPIO_H
-#define UPIO_H
-
-/* Enumeration of UPIO features                                         */
-/* Not all features enumerated here are supported by the hardware.      */
-/* Use UPIO_Feature() to determine support of a particular feature.     */
-enum {
-  /* LEDs */
-  UPIO_FEAT_LED1,
-  UPIO_FEAT_LED2,
-  UPIO_FEAT_LED3,
-  UPIO_FEAT_LED4,
-  UPIO_FEAT_LED5,
-  UPIO_FEAT_LED6,
-  UPIO_FEAT_LED7,
-  UPIO_FEAT_LED8,
-
-  /* Switches */
-  UPIO_FEAT_SWITCH1,
-  UPIO_FEAT_SWITCH2,
-  UPIO_FEAT_SWITCH3,
-  UPIO_FEAT_SWITCH4,
-  UPIO_FEAT_SWITCH5,
-  UPIO_FEAT_SWITCH6,
-  UPIO_FEAT_SWITCH7,
-  UPIO_FEAT_SWITCH8,
-  UPIO_FEAT_SWITCH9,
-  UPIO_FEAT_SWITCH10,
-  UPIO_FEAT_SWITCH11,
-  UPIO_FEAT_SWITCH12,
-  UPIO_FEAT_SWITCH13,
-  UPIO_FEAT_SWITCH14,
-  UPIO_FEAT_SWITCH15,
-  UPIO_FEAT_SWITCH16,
-
-  /* Jumpers */
-  UPIO_FEAT_JUMPER1,
-  UPIO_FEAT_JUMPER2,
-  UPIO_FEAT_JUMPER3,
-  UPIO_FEAT_JUMPER4,
-  UPIO_FEAT_JUMPER5,
-  UPIO_FEAT_JUMPER6,
-  UPIO_FEAT_JUMPER7,
-  UPIO_FEAT_JUMPER8,
-
-  /* Push buttons */
-  UPIO_FEAT_BUTTON1,
-  UPIO_FEAT_BUTTON2,
-  UPIO_FEAT_BUTTON3,
-  UPIO_FEAT_BUTTON4,
-  UPIO_FEAT_BUTTON5,
-  UPIO_FEAT_BUTTON6,
-  UPIO_FEAT_BUTTON7,
-  UPIO_FEAT_BUTTON8,
-
-  /* General purpose */
-  UPIO_FEAT_GENERAL1,
-  UPIO_FEAT_GENERAL2,
-  UPIO_FEAT_GENERAL3,
-  UPIO_FEAT_GENERAL4,
-  UPIO_FEAT_GENERAL5,
-  UPIO_FEAT_GENERAL6,
-  UPIO_FEAT_GENERAL7,
-  UPIO_FEAT_GENERAL8,
-  UPIO_FEAT_GENERAL9,
-  UPIO_FEAT_GENERAL10,
-  UPIO_FEAT_GENERAL11,
-  UPIO_FEAT_GENERAL12,
-  UPIO_FEAT_GENERAL13,
-  UPIO_FEAT_GENERAL14,
-  UPIO_FEAT_GENERAL15,
-  UPIO_FEAT_GENERAL16,
-  UPIO_FEAT_GENERAL17,
-  UPIO_FEAT_GENERAL18,
-  UPIO_FEAT_GENERAL19,
-  UPIO_FEAT_GENERAL20,
-  UPIO_FEAT_GENERAL21,
-  UPIO_FEAT_GENERAL22,
-  UPIO_FEAT_GENERAL23,
-  UPIO_FEAT_GENERAL24,
-  UPIO_FEAT_GENERAL25,
-  UPIO_FEAT_GENERAL26,
-  UPIO_FEAT_GENERAL27,
-  UPIO_FEAT_GENERAL28,
-  UPIO_FEAT_GENERAL29,
-  UPIO_FEAT_GENERAL30,
-  UPIO_FEAT_GENERAL31,
-  UPIO_FEAT_GENERAL32,
-
-  UPIO_FEAT_IN_HIGH, /* Support for input with interrupt on high signal level.
-                        */
-  UPIO_FEAT_IN_LOW,  /* Support for input with interrupt on low signal level. */
-  UPIO_FEAT_IN_RISE, /* Support for input with interrupt on rising edge. */
-  UPIO_FEAT_IN_FALL  /* Support for input with interrupt on falling. */
-
-};
-typedef uint8_t tUPIO_FEATURE;
-
-/* Enumeration of UPIO configurations */
-enum { UPIO_OUT, UPIO_IN, UPIO_IN_EDGE, UPIO_IN_LEVEL, UPIO_NONE };
-typedef uint8_t tUPIO_CONFIG;
-
-/* Enumeration of UPIO types */
-enum {
-  UPIO_LED,     /* LED */
-  UPIO_SWITCH,  /* Switch */
-  UPIO_JUMPER,  /* Jumper */
-  UPIO_BUTTON,  /* Push-button switch */
-  UPIO_GENERAL, /* General purpose I/O */
-
-  UPIO_NUMBER_OF_TYPES
-};
-typedef uint8_t tUPIO_TYPE;
-
-/* Enumeration of UPIO states */
-enum { UPIO_OFF, UPIO_ON, UPIO_TOGGLE };
-typedef uint8_t tUPIO_STATE;
-
-enum { UPIO_SW_BANK2, UPIO_SW_BANK3 };
-typedef uint8_t tUPIO_SW_BANK;
-
-/* Jumper masks */
-#define UPIO_JUMPER1 0x00000001
-#define UPIO_JUMPER2 0x00000002
-#define UPIO_JUMPER3 0x00000004
-#define UPIO_JUMPER4 0x00000008
-#define UPIO_JUMPER5 0x00000010
-#define UPIO_JUMPER6 0x00000020
-#define UPIO_JUMPER7 0x00000040
-#define UPIO_JUMPER8 0x00000080
-
-/* General purpose i/o masks */
-#define UPIO_GENERAL1 0x00000001
-#define UPIO_GENERAL2 0x00000002
-#define UPIO_GENERAL3 0x00000004
-#define UPIO_GENERAL4 0x00000008
-#define UPIO_GENERAL5 0x00000010
-#define UPIO_GENERAL6 0x00000020
-#define UPIO_GENERAL7 0x00000040
-#define UPIO_GENERAL8 0x00000080
-#define UPIO_GENERAL9 0x00000100
-#define UPIO_GENERAL10 0x00000200
-#define UPIO_GENERAL11 0x00000400
-#define UPIO_GENERAL12 0x00000800
-#define UPIO_GENERAL13 0x00001000
-#define UPIO_GENERAL14 0x00002000
-#define UPIO_GENERAL15 0x00004000
-#define UPIO_GENERAL16 0x00008000
-#define UPIO_GENERAL17 0x00010000
-#define UPIO_GENERAL18 0x00020000
-#define UPIO_GENERAL19 0x00040000
-#define UPIO_GENERAL20 0x00080000
-#define UPIO_GENERAL21 0x00100000
-#define UPIO_GENERAL22 0x00200000
-#define UPIO_GENERAL23 0x00400000
-#define UPIO_GENERAL24 0x00800000
-#define UPIO_GENERAL25 0x01000000
-#define UPIO_GENERAL26 0x02000000
-#define UPIO_GENERAL27 0x04000000
-#define UPIO_GENERAL28 0x08000000
-#define UPIO_GENERAL29 0x10000000
-#define UPIO_GENERAL30 0x20000000
-#define UPIO_GENERAL31 0x40000000
-#define UPIO_GENERAL32 0x80000000
-
-typedef uint32_t tUPIO;
-
-/* LED masks */
-#define UPIO_LED1 0x00000001
-#define UPIO_LED2 0x00000002
-#define UPIO_LED3 0x00000004
-#define UPIO_LED4 0x00000008
-#define UPIO_LED5 0x00000010
-#define UPIO_LED6 0x00000020
-#define UPIO_LED7 0x00000040
-#define UPIO_LED8 0x00000080
-
-#define UPIO_LED_ALL                                                       \
-  (UPIO_LED1 | UPIO_LED2 | UPIO_LED3 | UPIO_LED4 | UPIO_LED5 | UPIO_LED6 | \
-   UPIO_LED7 | UPIO_LED8)
-
-/* Switch masks */
-#define UPIO_SWITCH1 0x00000001
-#define UPIO_SWITCH2 0x00000002
-#define UPIO_SWITCH3 0x00000004
-#define UPIO_SWITCH4 0x00000008
-#define UPIO_SWITCH5 0x00000010
-#define UPIO_SWITCH6 0x00000020
-#define UPIO_SWITCH7 0x00000040
-#define UPIO_SWITCH8 0x00000080
-#define UPIO_SWITCH9 0x00000100
-#define UPIO_SWITCH10 0x00000200
-#define UPIO_SWITCH11 0x00000400
-#define UPIO_SWITCH12 0x00000800
-#define UPIO_SWITCH13 0x00001000
-#define UPIO_SWITCH14 0x00002000
-#define UPIO_SWITCH15 0x00004000
-#define UPIO_SWITCH16 0x00008000
-
-/* Push button masks */
-#define UPIO_BUTTON1 0x00000001
-#define UPIO_BUTTON2 0x00000002
-#define UPIO_BUTTON3 0x00000004
-#define UPIO_BUTTON4 0x00000008
-#define UPIO_BUTTON5 0x00000010
-#define UPIO_BUTTON6 0x00000020
-#define UPIO_BUTTON7 0x00000040
-#define UPIO_BUTTON8 0x00000080
-
-typedef void(tUPIO_CBACK)(tUPIO_TYPE type, tUPIO pio, tUPIO_STATE state);
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* API functions for UPIO driver */
-
-/*****************************************************************************
-**
-** Function         UPIO_Init
-**
-** Description
-**      Initialize the GPIO service.
-**      This function is typically called once upon system startup.
-**
-** Returns          nothing
-**
-*****************************************************************************/
-void UPIO_Init(void* p_cfg);
-
-/*****************************************************************************
-**
-** Function         UPIO_Set
-**
-** Description
-**      This function sets one or more GPIO devices to the given state.
-**      Multiple GPIOs of the same type can be masked together to set more
-**      than one GPIO. This function can only be used on types UPIO_LED and
-**      UPIO_GENERAL.
-**
-** Input Parameters:
-**      type    The type of device.
-**      pio     Indicates the particular GPIOs.
-**      state   The desired state.
-**
-** Output Parameter:
-**      None.
-**
-** Returns:
-**      None.
-**
-*****************************************************************************/
-void UPIO_Set(tUPIO_TYPE type, tUPIO pio, tUPIO_STATE state);
-
-/*****************************************************************************
-**
-** Function         UPIO_Read
-**
-** Description
-**      Read the state of a GPIO. This function can be used for any type of
-**      device. Parameter pio can only indicate a single GPIO; multiple GPIOs
-**      cannot be masked together.
-**
-** Input Parameters:
-**      Type:   The type of device.
-**      pio:    Indicates the particular GUPIO.
-**
-** Output Parameter:
-**      None.
-**
-** Returns:
-**      State of GPIO (UPIO_ON or UPIO_OFF).
-**
-*****************************************************************************/
-tUPIO_STATE UPIO_Read(tUPIO_TYPE type, tUPIO pio);
-
-/*****************************************************************************
-**
-** Function         UPIO_Config
-**
-** Description      - Configure GPIOs of type UPIO_GENERAL as inputs or outputs
-**                  - Configure GPIOs to be polled or interrupt driven
-**
-**                  Currently only support polled GPIOs.
-**
-** Input Parameters:
-**      type    The type of device.
-**      pio     Indicates the particular GPIOs.
-**      config
-**      cback
-**
-** Output Parameter:
-**      None.
-**
-** Returns:
-**      None.
-**
-*****************************************************************************/
-void UPIO_Config(tUPIO_TYPE type, tUPIO pio, tUPIO_CONFIG config,
-                 tUPIO_CBACK* cback);
-
-/*****************************************************************************
-**
-** Function         UPIO_Feature
-**
-** Description
-**      Checks whether a feature of the pio API is supported
-**
-** Input Parameter:
-**      feature     The feature to check
-**
-** Output Parameter:
-**      None.
-**
-** Returns:
-**      true if feature is supported, false if it is not.
-**
-*****************************************************************************/
-bool UPIO_Feature(tUPIO_FEATURE feature);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ifdef UPIO_H */
diff --git a/utils/Android.bp b/utils/Android.bp
new file mode 100755
index 0000000..aab6708
--- /dev/null
+++ b/utils/Android.bp
@@ -0,0 +1,50 @@
+cc_defaults {
+    name: "nqnfc_utils_defaults",
+    include_dirs: [
+        "system/nfc",
+    ],
+    cflags: [
+        "-Wall",
+        "-Werror",
+    ],
+    target: {
+        linux_glibc: {
+            cflags: ["-D_GNU_SOURCE"],
+        },
+        darwin: {
+            enabled: false,
+        },
+    },
+}
+
+cc_library_static {
+    name: "libnqnfcutils",
+    defaults: ["nqnfc_utils_defaults"],
+    export_include_dirs: ["include"],
+    host_supported: true,
+    srcs: [
+        "config.cc",
+        "ringbuffer.cc",
+    ],
+    shared_libs: [
+        "libbase",
+    ],
+}
+
+cc_test {
+    name: "nqnfc_test_utils",
+    defaults: ["nqnfc_utils_defaults"],
+    test_suites: ["device-tests"],
+    host_supported: true,
+    srcs: [
+        "test/config_test.cc",
+        "test/ringbuffer_test.cc",
+    ],
+    static_libs: [
+        "libnqnfcutils",
+        "libgmock",
+    ],
+    shared_libs: [
+        "libbase",
+    ],
+}
diff --git a/utils/config.cc b/utils/config.cc
new file mode 100755
index 0000000..6d566b1
--- /dev/null
+++ b/utils/config.cc
@@ -0,0 +1,190 @@
+/*
+ * Copyright 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include "config.h"
+
+#include <android-base/file.h>
+#include <android-base/logging.h>
+#include <android-base/parseint.h>
+#include <android-base/strings.h>
+
+using namespace ::std;
+using namespace ::android::base;
+
+namespace {
+
+bool parseBytesString(std::string in, std::vector<uint8_t>& out) {
+  vector<string> values = Split(in, ":");
+  if (values.size() == 0) return false;
+  for (string value : values) {
+    if (value.length() != 2) return false;
+    uint8_t tmp = 0;
+    string hexified = "0x";
+    hexified.append(value);
+    if (!ParseUint(hexified.c_str(), &tmp)) return false;
+    out.push_back(tmp);
+  }
+  return true;
+}
+
+}  // namespace
+
+ConfigValue::ConfigValue() {}
+
+ConfigValue::ConfigValue(std::string value) {
+  // Don't allow empty strings
+  CHECK(!(value.empty()));
+  type_ = STRING;
+  value_string_ = value;
+}
+
+ConfigValue::ConfigValue(unsigned value) {
+  type_ = UNSIGNED;
+  value_unsigned_ = value;
+}
+
+ConfigValue::ConfigValue(std::vector<uint8_t> value) {
+  CHECK(!(value.empty()));
+  type_ = BYTES;
+  value_bytes_ = value;
+}
+
+ConfigValue::Type ConfigValue::getType() const { return type_; }
+
+std::string ConfigValue::getString() const {
+  CHECK(type_ == STRING);
+  return value_string_;
+};
+
+unsigned ConfigValue::getUnsigned() const {
+  CHECK(type_ == UNSIGNED);
+  return value_unsigned_;
+};
+
+std::vector<uint8_t> ConfigValue::getBytes() const {
+  CHECK(type_ == BYTES);
+  return value_bytes_;
+};
+
+bool ConfigValue::parseFromString(std::string in) {
+  if (in.length() > 1 && in[0] == '"' && in[in.length() - 1] == '"') {
+    CHECK(in.length() > 2);  // Don't allow empty strings
+    type_ = STRING;
+    value_string_ = in.substr(1, in.length() - 2);
+    return true;
+  }
+
+  if (in.length() > 1 && in[0] == '{' && in[in.length() - 1] == '}') {
+    CHECK(in.length() >= 4);  // Needs at least one byte
+    type_ = BYTES;
+    return parseBytesString(in.substr(1, in.length() - 2), value_bytes_);
+  }
+
+  unsigned tmp = 0;
+  if (ParseUint(in.c_str(), &tmp)) {
+    type_ = UNSIGNED;
+    value_unsigned_ = tmp;
+    return true;
+  }
+
+  return false;
+}
+
+void ConfigFile::addConfig(const std::string& key, ConfigValue& value) {
+  CHECK(!hasKey(key));
+  values_.emplace(key, value);
+}
+
+bool ConfigFile::updateConfig(const std::string& key, ConfigValue& value) {
+  std::map<std::string, ConfigValue>::iterator it = values_.find(key);
+  if (it != values_.end() && isUpdateAllowed(key)) {
+    it->second = value;
+    return true;
+  }
+  return false;
+}
+
+bool ConfigFile::isUpdateAllowed(const std::string& key) {
+  if ((key.compare("P2P_LISTEN_TECH_MASK") == 0) ||
+      (key.compare("HOST_LISTEN_TECH_MASK") == 0) ||
+      (key.compare("UICC_LISTEN_TECH_MASK") == 0) ||
+      (key.compare("POLLING_TECH_MASK") == 0))
+    return true;
+  return false;
+}
+
+void ConfigFile::parseFromFile(const std::string& file_name) {
+  string config;
+  bool config_read = ReadFileToString(file_name, &config);
+  CHECK(config_read);
+  LOG(INFO) << "ConfigFile - Parsing file '" << file_name << "'";
+  cur_file_name_ = file_name;
+  parseFromString(config);
+}
+
+void ConfigFile::parseFromString(const std::string& config) {
+  stringstream ss(config);
+  string line;
+  while (getline(ss, line)) {
+    line = Trim(line);
+    if (line.empty()) continue;
+    if (line.at(0) == '#') continue;
+    if (line.at(0) == 0) continue;
+
+    auto search = line.find('=');
+    CHECK(search != string::npos);
+
+    string key(Trim(line.substr(0, search)));
+    string value_string(Trim(line.substr(search + 1, string::npos)));
+
+    ConfigValue value;
+    bool value_parsed = value.parseFromString(value_string);
+    CHECK(value_parsed);
+
+    if (cur_file_name_.find("nxpTransit") != std::string::npos) {
+      if (updateConfig(key, value))
+        LOG(INFO) << "ConfigFile Updated - [" << key << "] = " << value_string;
+    } else {
+      addConfig(key, value);
+      LOG(INFO) << "ConfigFile - [" << key << "] = " << value_string;
+    }
+  }
+  cur_file_name_ = "";
+}
+
+bool ConfigFile::hasKey(const std::string& key) {
+  return values_.count(key) != 0;
+}
+
+ConfigValue& ConfigFile::getValue(const std::string& key) {
+  auto search = values_.find(key);
+  CHECK(search != values_.end());
+  return search->second;
+}
+
+std::string ConfigFile::getString(const std::string& key) {
+  return getValue(key).getString();
+}
+
+unsigned ConfigFile::getUnsigned(const std::string& key) {
+  return getValue(key).getUnsigned();
+}
+
+std::vector<uint8_t> ConfigFile::getBytes(const std::string& key) {
+  return getValue(key).getBytes();
+}
+
+bool ConfigFile::isEmpty() { return values_.empty(); }
+void ConfigFile::clear() { values_.clear(); }
diff --git a/utils/include/config.h b/utils/include/config.h
new file mode 100755
index 0000000..53e5a79
--- /dev/null
+++ b/utils/include/config.h
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#include <map>
+#include <string>
+#include <vector>
+
+class ConfigValue {
+ public:
+  enum Type { UNSIGNED, STRING, BYTES };
+
+  ConfigValue();
+  ConfigValue(std::string);
+  ConfigValue(unsigned);
+  ConfigValue(std::vector<uint8_t>);
+  Type getType() const;
+  std::string getString() const;
+  unsigned getUnsigned() const;
+  std::vector<uint8_t> getBytes() const;
+
+  bool parseFromString(std::string in);
+
+ private:
+  Type type_;
+  std::string value_string_;
+  unsigned value_unsigned_;
+  std::vector<uint8_t> value_bytes_;
+};
+
+class ConfigFile {
+ public:
+  void parseFromFile(const std::string& file_name);
+  void parseFromString(const std::string& config);
+  void addConfig(const std::string& config, ConfigValue& value);
+
+  bool hasKey(const std::string& key);
+  std::string getString(const std::string& key);
+  unsigned getUnsigned(const std::string& key);
+  std::vector<uint8_t> getBytes(const std::string& key);
+
+  bool isEmpty();
+  void clear();
+
+ private:
+  ConfigValue& getValue(const std::string& key);
+  bool updateConfig(const std::string& config, ConfigValue& value);
+  bool isUpdateAllowed(const std::string& key);
+  std::string cur_file_name_ = "";
+  std::map<std::string, ConfigValue> values_;
+};
diff --git a/utils/include/ringbuffer.h b/utils/include/ringbuffer.h
new file mode 100644
index 0000000..d2c310a
--- /dev/null
+++ b/utils/include/ringbuffer.h
@@ -0,0 +1,62 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2017 Google Inc.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#pragma once
+
+#include <stdint.h>
+
+typedef struct ringbuffer_t ringbuffer_t;
+
+// NOTE:
+// None of the functions below are thread safe when it comes to accessing the
+// *rb pointer. It is *NOT* possible to insert and pop/delete at the same time.
+// Callers must protect the *rb pointer separately.
+
+// Create a ringbuffer with the specified size
+// Returns NULL if memory allocation failed. Resulting pointer must be freed
+// using |ringbuffer_free|.
+ringbuffer_t* ringbuffer_init(const size_t size);
+
+// Frees the ringbuffer structure and buffer
+// Save to call with NULL.
+void ringbuffer_free(ringbuffer_t* rb);
+
+// Returns remaining buffer size
+size_t ringbuffer_available(const ringbuffer_t* rb);
+
+// Returns size of data in buffer
+size_t ringbuffer_size(const ringbuffer_t* rb);
+
+// Attempts to insert up to |length| bytes of data at |p| into the buffer
+// Return actual number of bytes added. Can be less than |length| if buffer
+// is full.
+size_t ringbuffer_insert(ringbuffer_t* rb, const uint8_t* p, size_t length);
+
+// Peek |length| number of bytes from the ringbuffer, starting at |offset|,
+// into the buffer |p|. Return the actual number of bytes peeked. Can be less
+// than |length| if there is less than |length| data available. |offset| must
+// be non-negative.
+size_t ringbuffer_peek(const ringbuffer_t* rb, off_t offset, uint8_t* p,
+                       size_t length);
+
+// Does the same as |ringbuffer_peek|, but also advances the ring buffer head
+size_t ringbuffer_pop(ringbuffer_t* rb, uint8_t* p, size_t length);
+
+// Deletes |length| bytes from the ringbuffer starting from the head
+// Return actual number of bytes deleted.
+size_t ringbuffer_delete(ringbuffer_t* rb, size_t length);
diff --git a/utils/ringbuffer.cc b/utils/ringbuffer.cc
new file mode 100644
index 0000000..d7798fd
--- /dev/null
+++ b/utils/ringbuffer.cc
@@ -0,0 +1,116 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2017 Google Inc.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include <assert.h>
+#include <stdlib.h>
+
+#include "ringbuffer.h"
+
+struct ringbuffer_t {
+  size_t total;
+  size_t available;
+  uint8_t* base;
+  uint8_t* head;
+  uint8_t* tail;
+};
+
+ringbuffer_t* ringbuffer_init(const size_t size) {
+  ringbuffer_t* p = static_cast<ringbuffer_t*>(calloc(1, sizeof(ringbuffer_t)));
+
+  if (p == NULL) return p;
+
+  p->base = static_cast<uint8_t*>(calloc(size, sizeof(uint8_t)));
+  p->head = p->tail = p->base;
+  p->total = p->available = size;
+
+  return p;
+}
+
+void ringbuffer_free(ringbuffer_t* rb) {
+  if (rb != NULL) free(rb->base);
+  free(rb);
+}
+
+size_t ringbuffer_available(const ringbuffer_t* rb) {
+  assert(rb);
+  return rb->available;
+}
+
+size_t ringbuffer_size(const ringbuffer_t* rb) {
+  assert(rb);
+  return rb->total - rb->available;
+}
+
+size_t ringbuffer_insert(ringbuffer_t* rb, const uint8_t* p, size_t length) {
+  assert(rb);
+  assert(p);
+
+  if (length > ringbuffer_available(rb)) length = ringbuffer_available(rb);
+
+  for (size_t i = 0; i != length; ++i) {
+    *rb->tail++ = *p++;
+    if (rb->tail >= (rb->base + rb->total)) rb->tail = rb->base;
+  }
+
+  rb->available -= length;
+  return length;
+}
+
+size_t ringbuffer_delete(ringbuffer_t* rb, size_t length) {
+  assert(rb);
+
+  if (length > ringbuffer_size(rb)) length = ringbuffer_size(rb);
+
+  rb->head += length;
+  if (rb->head >= (rb->base + rb->total)) rb->head -= rb->total;
+
+  rb->available += length;
+  return length;
+}
+
+size_t ringbuffer_peek(const ringbuffer_t* rb, off_t offset, uint8_t* p,
+                       size_t length) {
+  assert(rb);
+  assert(p);
+  assert(offset >= 0);
+  assert((size_t)offset <= ringbuffer_size(rb));
+
+  uint8_t* b = ((rb->head - rb->base + offset) % rb->total) + rb->base;
+  const size_t bytes_to_copy = (offset + length > ringbuffer_size(rb))
+                                   ? ringbuffer_size(rb) - offset
+                                   : length;
+
+  for (size_t copied = 0; copied < bytes_to_copy; ++copied) {
+    *p++ = *b++;
+    if (b >= (rb->base + rb->total)) b = rb->base;
+  }
+
+  return bytes_to_copy;
+}
+
+size_t ringbuffer_pop(ringbuffer_t* rb, uint8_t* p, size_t length) {
+  assert(rb);
+  assert(p);
+
+  const size_t copied = ringbuffer_peek(rb, 0, p, length);
+  rb->head += copied;
+  if (rb->head >= (rb->base + rb->total)) rb->head -= rb->total;
+
+  rb->available += copied;
+  return copied;
+}
diff --git a/utils/test/config_test.cc b/utils/test/config_test.cc
new file mode 100755
index 0000000..b2fde71
--- /dev/null
+++ b/utils/test/config_test.cc
@@ -0,0 +1,135 @@
+/*
+ * Copyright 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include <gtest/gtest.h>
+
+#include <config.h>
+
+namespace {
+const char SIMPLE_CONFIG_FILE[] = "/data/local/tmp/test_config.conf";
+const char SIMPLE_CONFIG[] =
+    "# Simple config file test\n\
+STRING_VALUE=\"Hello World!\"\n\
+#COMMENTED_OUT_VALUE=1\n\
+NUM_VALUE=42\n\
+BYTES_VALUE={0A:0b:0C:fF:00}\n";
+
+const char INVALID_CONFIG1[] =
+    "# This is an invalid config\n\
+# Config values must contain an = sign\n\
+TEST:1";
+
+const char INVALID_CONFIG2[] =
+    "# This is an invalid config\n\
+# Byte arrays must contain at least one value\n\
+TEST={}";
+
+const char INVALID_CONFIG3[] =
+    "# This is an invalid config\n\
+# String values cannot be empty\n\
+TEST=\"\"";
+
+const char INVALID_CONFIG4[] =
+    "# This is an invalid config\n\
+# Multiple config entries with the same key\n\
+TEST=1\n\
+TEST=2";
+
+const char INVALID_CONFIG5[] =
+    "# This is an invalid config\n\
+# Byte value width incorrect\n\
+BYTES_VALUE={0A:0b:0C:1:00}\n";
+}  // namespace
+
+class ConfigTestFromFile : public ::testing::Test {
+ protected:
+  void SetUp() override {
+    FILE* fp = fopen(SIMPLE_CONFIG_FILE, "wt");
+    fwrite(SIMPLE_CONFIG, 1, sizeof(SIMPLE_CONFIG), fp);
+    fclose(fp);
+  }
+};
+
+TEST(ConfigTestFromString, test_simple_config) {
+  ConfigFile config;
+  config.parseFromString(SIMPLE_CONFIG);
+  EXPECT_FALSE(config.hasKey("UNKNOWN_VALUE"));
+  EXPECT_FALSE(config.hasKey("COMMENTED_OUT_VALUE"));
+  EXPECT_TRUE(config.hasKey("NUM_VALUE"));
+  EXPECT_TRUE(config.hasKey("STRING_VALUE"));
+  EXPECT_TRUE(config.hasKey("BYTES_VALUE"));
+}
+
+TEST(ConfigTestFromString, test_simple_values) {
+  ConfigFile config;
+  config.parseFromString(SIMPLE_CONFIG);
+  EXPECT_EQ(config.getUnsigned("NUM_VALUE"), 42u);
+  EXPECT_EQ(config.getString("STRING_VALUE"), "Hello World!");
+  auto bytes = config.getBytes("BYTES_VALUE");
+  EXPECT_EQ(bytes.size(), 5u);
+  EXPECT_EQ(bytes[0], 10);
+  EXPECT_EQ(bytes[1], 11);
+  EXPECT_EQ(bytes[2], 12);
+  EXPECT_EQ(bytes[3], 255);
+  EXPECT_EQ(bytes[4], 0);
+}
+
+TEST(ConfigTestFromString, test_invalid_configs) {
+  ConfigFile config1;
+  EXPECT_DEATH(config1.parseFromString(INVALID_CONFIG1), "");
+  ConfigFile config2;
+  EXPECT_DEATH(config2.parseFromString(INVALID_CONFIG2), "");
+  ConfigFile config3;
+  EXPECT_DEATH(config3.parseFromString(INVALID_CONFIG3), "");
+  ConfigFile config4;
+  EXPECT_DEATH(config4.parseFromString(INVALID_CONFIG4), "");
+  ConfigFile config5;
+  EXPECT_DEATH(config5.parseFromString(INVALID_CONFIG5), "");
+}
+
+TEST(ConfigTestFromString, test_clear) {
+  ConfigFile config;
+  EXPECT_FALSE(config.hasKey("NUM_VALUE"));
+  config.parseFromString(SIMPLE_CONFIG);
+  EXPECT_TRUE(config.hasKey("NUM_VALUE"));
+  EXPECT_EQ(config.getUnsigned("NUM_VALUE"), 42u);
+  config.clear();
+  EXPECT_FALSE(config.hasKey("NUM_VALUE"));
+  EXPECT_DEATH(config.getUnsigned("NUM_VALUE"), "");
+}
+
+TEST(ConfigTestFromString, test_isEmpty) {
+  ConfigFile config;
+  EXPECT_TRUE(config.isEmpty());
+  config.parseFromString(SIMPLE_CONFIG);
+  EXPECT_FALSE(config.isEmpty());
+  config.clear();
+  EXPECT_TRUE(config.isEmpty());
+}
+
+TEST_F(ConfigTestFromFile, test_file_based_config) {
+  ConfigFile config;
+  config.parseFromFile(SIMPLE_CONFIG_FILE);
+  EXPECT_FALSE(config.hasKey("UNKNOWN_VALUE"));
+  EXPECT_EQ(config.getUnsigned("NUM_VALUE"), 42u);
+  EXPECT_EQ(config.getString("STRING_VALUE"), "Hello World!");
+  auto bytes = config.getBytes("BYTES_VALUE");
+  EXPECT_EQ(bytes.size(), 5u);
+  EXPECT_EQ(bytes[0], 10);
+  EXPECT_EQ(bytes[1], 11);
+  EXPECT_EQ(bytes[2], 12);
+  EXPECT_EQ(bytes[3], 255);
+  EXPECT_EQ(bytes[4], 0);
+}
diff --git a/utils/test/ringbuffer_test.cc b/utils/test/ringbuffer_test.cc
new file mode 100644
index 0000000..bebf8a2
--- /dev/null
+++ b/utils/test/ringbuffer_test.cc
@@ -0,0 +1,138 @@
+#include <gtest/gtest.h>
+
+#include <ringbuffer.h>
+
+TEST(RingbufferTest, test_new_simple) {
+  ringbuffer_t* rb = ringbuffer_init(4096);
+  ASSERT_TRUE(rb != NULL);
+  EXPECT_EQ((size_t)4096, ringbuffer_available(rb));
+  EXPECT_EQ((size_t)0, ringbuffer_size(rb));
+  ringbuffer_free(rb);
+}
+
+TEST(RingbufferTest, test_insert_basic) {
+  ringbuffer_t* rb = ringbuffer_init(16);
+
+  uint8_t buffer[10] = {0x01, 0x02, 0x03, 0x04, 0x05,
+                        0x06, 0x07, 0x08, 0x09, 0x0A};
+  ringbuffer_insert(rb, buffer, 10);
+  EXPECT_EQ((size_t)10, ringbuffer_size(rb));
+  EXPECT_EQ((size_t)6, ringbuffer_available(rb));
+
+  uint8_t peek[10] = {0};
+  size_t peeked = ringbuffer_peek(rb, 0, peek, 10);
+  EXPECT_EQ((size_t)10, ringbuffer_size(rb));  // Ensure size doesn't change
+  EXPECT_EQ((size_t)6, ringbuffer_available(rb));
+  EXPECT_EQ((size_t)10, peeked);
+  ASSERT_TRUE(0 == memcmp(buffer, peek, peeked));
+
+  ringbuffer_free(rb);
+}
+
+TEST(RingbufferTest, test_insert_full) {
+  ringbuffer_t* rb = ringbuffer_init(5);
+
+  uint8_t aa[] = {0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA};
+  uint8_t bb[] = {0xBB, 0xBB, 0xBB, 0xBB, 0xBB};
+  uint8_t peek[5] = {0};
+
+  size_t added = ringbuffer_insert(rb, aa, 7);
+  EXPECT_EQ((size_t)5, added);
+  EXPECT_EQ((size_t)0, ringbuffer_available(rb));
+  EXPECT_EQ((size_t)5, ringbuffer_size(rb));
+
+  added = ringbuffer_insert(rb, bb, 5);
+  EXPECT_EQ((size_t)0, added);
+  EXPECT_EQ((size_t)0, ringbuffer_available(rb));
+  EXPECT_EQ((size_t)5, ringbuffer_size(rb));
+
+  size_t peeked = ringbuffer_peek(rb, 0, peek, 5);
+  EXPECT_EQ((size_t)5, peeked);
+  EXPECT_EQ((size_t)0, ringbuffer_available(rb));
+  EXPECT_EQ((size_t)5, ringbuffer_size(rb));
+
+  ASSERT_TRUE(0 == memcmp(aa, peek, peeked));
+
+  ringbuffer_free(rb);
+}
+
+TEST(RingbufferTest, test_multi_insert_delete) {
+  ringbuffer_t* rb = ringbuffer_init(16);
+  EXPECT_EQ((size_t)16, ringbuffer_available(rb));
+  EXPECT_EQ((size_t)0, ringbuffer_size(rb));
+
+  // Insert some bytes
+
+  uint8_t aa[] = {0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA};
+  size_t added = ringbuffer_insert(rb, aa, sizeof(aa));
+  EXPECT_EQ((size_t)8, added);
+  EXPECT_EQ((size_t)8, ringbuffer_available(rb));
+  EXPECT_EQ((size_t)8, ringbuffer_size(rb));
+
+  uint8_t bb[] = {0xBB, 0xBB, 0xBB, 0xBB, 0xBB};
+  ringbuffer_insert(rb, bb, sizeof(bb));
+  EXPECT_EQ((size_t)3, ringbuffer_available(rb));
+  EXPECT_EQ((size_t)13, ringbuffer_size(rb));
+
+  uint8_t content[] = {0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
+                       0xAA, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB};
+  uint8_t peek[16] = {0};
+  size_t peeked = ringbuffer_peek(rb, 0, peek, 16);
+  EXPECT_EQ((size_t)13, peeked);
+  ASSERT_TRUE(0 == memcmp(content, peek, peeked));
+
+  // Delete some bytes
+
+  ringbuffer_delete(rb, sizeof(aa));
+  EXPECT_EQ((size_t)11, ringbuffer_available(rb));
+  EXPECT_EQ((size_t)5, ringbuffer_size(rb));
+
+  // Add some more to wrap buffer
+
+  uint8_t cc[] = {0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC};
+  ringbuffer_insert(rb, cc, sizeof(cc));
+  EXPECT_EQ((size_t)2, ringbuffer_available(rb));
+  EXPECT_EQ((size_t)14, ringbuffer_size(rb));
+
+  uint8_t content2[] = {0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xCC, 0xCC};
+  peeked = ringbuffer_peek(rb, 0, peek, 7);
+  EXPECT_EQ((size_t)7, peeked);
+  ASSERT_TRUE(0 == memcmp(content2, peek, peeked));
+
+  // Pop buffer
+
+  memset(peek, 0, 16);
+  size_t popped = ringbuffer_pop(rb, peek, 7);
+  EXPECT_EQ((size_t)7, popped);
+  EXPECT_EQ((size_t)9, ringbuffer_available(rb));
+  ASSERT_TRUE(0 == memcmp(content2, peek, peeked));
+
+  // Add more again to check head motion
+
+  uint8_t dd[] = {0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD};
+  added = ringbuffer_insert(rb, dd, sizeof(dd));
+  EXPECT_EQ((size_t)8, added);
+  EXPECT_EQ((size_t)1, ringbuffer_available(rb));
+
+  // Delete everything
+
+  ringbuffer_delete(rb, 16);
+  EXPECT_EQ((size_t)16, ringbuffer_available(rb));
+  EXPECT_EQ((size_t)0, ringbuffer_size(rb));
+
+  // Add small token
+
+  uint8_t ae[] = {0xAE, 0xAE, 0xAE};
+  added = ringbuffer_insert(rb, ae, sizeof(ae));
+  EXPECT_EQ((size_t)13, ringbuffer_available(rb));
+
+  // Get everything
+
+  popped = ringbuffer_pop(rb, peek, 16);
+  EXPECT_EQ(added, popped);
+  EXPECT_EQ((size_t)16, ringbuffer_available(rb));
+  EXPECT_EQ((size_t)0, ringbuffer_size(rb));
+  ASSERT_TRUE(0 == memcmp(ae, peek, popped));
+
+  ringbuffer_free(rb);
+}
-- 
2.17.1

