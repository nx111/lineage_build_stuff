From 663bc4c34c6e1ffaaa9e5bf08c15bc883886d25a Mon Sep 17 00:00:00 2001
From: Paul Keith <javelinanddart@gmail.com>
Date: Sat, 19 Jan 2019 18:03:15 +0100
Subject: [PATCH 5/7] livedisplay: legacymm: Wire it up

Change-Id: Ic580ceb333c361444d4e009db1a34ccca8fbbbfc
---
 legacymm/Android.bp                           |  21 +--
 legacymm/ColorBalance.cpp                     |  84 ++++++++--
 legacymm/ColorBalance.h                       |  20 ++-
 legacymm/Constants.h                          |  36 ++++
 legacymm/DisplayModes.cpp                     | 153 +++++++++++++++--
 legacymm/DisplayModes.h                       |  27 ++-
 legacymm/PictureAdjustment.cpp                | 147 +++++++++++++++--
 legacymm/PictureAdjustment.h                  |  31 +++-
 legacymm/Types.h                              |  62 +++++++
 legacymm/service.cpp                          | 155 ++++++++++++++++++
 ...ineage.livedisplay@2.0-service-legacymm.rc |   4 +
 11 files changed, 668 insertions(+), 72 deletions(-)
 create mode 100644 legacymm/Constants.h
 create mode 100644 legacymm/Types.h
 create mode 100644 legacymm/service.cpp
 create mode 100644 legacymm/vendor.lineage.livedisplay@2.0-service-legacymm.rc

diff --git a/legacymm/Android.bp b/legacymm/Android.bp
index 701bb51..32ed897 100644
--- a/legacymm/Android.bp
+++ b/legacymm/Android.bp
@@ -12,27 +12,22 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-cc_library_shared {
-    // FIXME: this should only be -impl for a passthrough hal.
-    // In most cases, to convert this to a binderized implementation, you should:
-    // - change '-impl' to '-service' here and make it a cc_binary instead of a
-    //   cc_library_shared.
-    // - add a *.rc file for this module.
-    // - delete HIDL_FETCH_I* functions.
-    // - call configureRpcThreadpool and registerAsService on the instance.
-    // You may also want to append '-impl/-service' with a specific identifier like
-    // '-vendor' or '-<hardware identifier>' etc to distinguish it.
-    name: "vendor.lineage.livedisplay@2.0-impl",
+cc_binary {
+    name: "vendor.lineage.livedisplay@2.0-service-legacymm",
+    init_rc: ["vendor.lineage.livedisplay@2.0-service-legacymm.rc"],
+    defaults: ["hidl_defaults"],
     relative_install_path: "hw",
-    // FIXME: this should be 'vendor: true' for modules that will eventually be
-    // on AOSP.
     proprietary: true,
     srcs: [
         "ColorBalance.cpp",
         "DisplayModes.cpp",
         "PictureAdjustment.cpp",
+        "service.cpp",
     ],
     shared_libs: [
+        "libbase",
+        "libbinder",
+        "libdl",
         "libhidlbase",
         "libhidltransport",
         "libutils",
diff --git a/legacymm/ColorBalance.cpp b/legacymm/ColorBalance.cpp
index 62ca8c3..622d551 100644
--- a/legacymm/ColorBalance.cpp
+++ b/legacymm/ColorBalance.cpp
@@ -14,7 +14,11 @@
  * limitations under the License.
  */
 
+#include <dlfcn.h>
+
 #include "ColorBalance.h"
+#include "Constants.h"
+#include "Types.h"
 
 namespace vendor {
 namespace lineage {
@@ -22,29 +26,85 @@ namespace livedisplay {
 namespace V2_0 {
 namespace legacymm {
 
+ColorBalance::ColorBalance(void* libHandle) {
+    mLibHandle = libHandle;
+    disp_api_supported =
+        reinterpret_cast<int (*)(int32_t, int32_t)>(dlsym(mLibHandle, "disp_api_supported"));
+    disp_api_get_color_balance_range = reinterpret_cast<int (*)(int32_t, void*)>(
+        dlsym(mLibHandle, "disp_api_get_color_balance_range"));
+    disp_api_get_color_balance =
+        reinterpret_cast<int (*)(int32_t, int*)>(dlsym(mLibHandle, "disp_api_get_color_balance"));
+    disp_api_set_color_balance =
+        reinterpret_cast<int (*)(int32_t, int)>(dlsym(mLibHandle, "disp_api_set_color_balance"));
+    disp_api_get_num_display_modes = reinterpret_cast<int (*)(int32_t, int32_t, int*)>(
+        dlsym(mLibHandle, "disp_api_get_num_display_modes"));
+}
+
+bool ColorBalance::isSupported() {
+    mm_cb_range range{};
+    int count = 0;
+
+    if (disp_api_supported == nullptr || disp_api_supported(0, COLOR_BALANCE_FEATURE) == 0) {
+        return false;
+    }
+
+    if (disp_api_get_color_balance_range == nullptr ||
+        disp_api_get_color_balance_range(0, &range) != 0) {
+        return false;
+    }
+
+    if (range.max == 0 || range.min == 0) {
+        return false;
+    }
+
+    // This is how this is supposed to work, but it doesn't work quite right
+    /*
+        if (disp_api_supported(0, DISPLAY_MODES_FEATURE) != 0 &&
+            disp_api_get_num_display_modes != nullptr &&
+            disp_api_get_num_display_modes(0, 0, &count) == 0) {
+            return count > 0;
+        }
+    */
+
+    return false;
+}
+
 // Methods from ::vendor::lineage::livedisplay::V2_0::IColorBalance follow.
 Return<void> ColorBalance::getColorBalanceRange(getColorBalanceRange_cb _hidl_cb) {
-    // TODO implement
+    Range range{};
+    mm_cb_range r{};
+
+    if (disp_api_get_color_balance_range != nullptr) {
+        if (disp_api_get_color_balance_range(0, &range) == 0) {
+            range.min = r.min;
+            range.max = r.max;
+        }
+    }
+
+    _hidl_cb(range);
     return Void();
 }
 
 Return<int32_t> ColorBalance::getColorBalance() {
-    // TODO implement
-    return int32_t {};
-}
+    int value = 0;
 
-Return<bool> ColorBalance::setColorBalance(int32_t value) {
-    // TODO implement
-    return bool {};
+    if (disp_api_get_color_balance != nullptr) {
+        if (disp_api_get_color_balance(0, &value) != 0) {
+            value = 0;
+        }
+    }
+
+    return static_cast<int32_t>(value);
 }
 
+Return<bool> ColorBalance::setColorBalance(int32_t value) {
+    if (disp_api_set_color_balance != nullptr) {
+        return disp_api_set_color_balance(0, static_cast<int>(value)) == 0;
+    }
 
-// Methods from ::android::hidl::base::V1_0::IBase follow.
+    return false;
+}
 
-//IColorBalance* HIDL_FETCH_IColorBalance(const char* /* name */) {
-    //return new ColorBalance();
-//}
-//
 }  // namespace legacymm
 }  // namespace V2_0
 }  // namespace livedisplay
diff --git a/legacymm/ColorBalance.h b/legacymm/ColorBalance.h
index 7c637dc..6ffb4f7 100644
--- a/legacymm/ColorBalance.h
+++ b/legacymm/ColorBalance.h
@@ -17,9 +17,9 @@
 #ifndef VENDOR_LINEAGE_LIVEDISPLAY_V2_0_COLORBALANCE_H
 #define VENDOR_LINEAGE_LIVEDISPLAY_V2_0_COLORBALANCE_H
 
-#include <vendor/lineage/livedisplay/2.0/IColorBalance.h>
 #include <hidl/MQDescriptor.h>
 #include <hidl/Status.h>
+#include <vendor/lineage/livedisplay/2.0/IColorBalance.h>
 
 namespace vendor {
 namespace lineage {
@@ -35,19 +35,27 @@ using ::android::hardware::Return;
 using ::android::hardware::Void;
 using ::android::sp;
 
-struct ColorBalance : public IColorBalance {
+class ColorBalance : public IColorBalance {
+  public:
+    ColorBalance(void* libHandle);
+
+    bool isSupported();
+
     // Methods from ::vendor::lineage::livedisplay::V2_0::IColorBalance follow.
     Return<void> getColorBalanceRange(getColorBalanceRange_cb _hidl_cb) override;
     Return<int32_t> getColorBalance() override;
     Return<bool> setColorBalance(int32_t value) override;
 
-    // Methods from ::android::hidl::base::V1_0::IBase follow.
+  private:
+    void* mLibHandle;
 
+    int (*disp_api_supported)(int32_t, int32_t);
+    int (*disp_api_get_color_balance_range)(int32_t, void*);
+    int (*disp_api_get_color_balance)(int32_t, int*);
+    int (*disp_api_set_color_balance)(int32_t, int);
+    int (*disp_api_get_num_display_modes)(int32_t, int32_t, int*);
 };
 
-// FIXME: most likely delete, this is only for passthrough implementations
-// extern "C" IColorBalance* HIDL_FETCH_IColorBalance(const char* name);
-
 }  // namespace legacymm
 }  // namespace V2_0
 }  // namespace livedisplay
diff --git a/legacymm/Constants.h b/legacymm/Constants.h
new file mode 100644
index 0000000..61c9b60
--- /dev/null
+++ b/legacymm/Constants.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2019 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef VENDOR_LINEAGE_LIVEDISPLAY_V2_0_LEGACYMM_CONSTANTS_H
+#define VENDOR_LINEAGE_LIVEDISPLAY_V2_0_LEGACYMM_CONSTANTS_H
+
+namespace vendor {
+namespace lineage {
+namespace livedisplay {
+namespace V2_0 {
+namespace legacymm {
+
+#define COLOR_BALANCE_FEATURE 0
+#define DISPLAY_MODES_FEATURE 1
+#define PICTURE_ADJUSTMENT_FEATURE 4
+
+}  // namespace legacymm
+}  // namespace V2_0
+}  // namespace livedisplay
+}  // namespace lineage
+}  // namespace vendor
+
+#endif  // VENDOR_LINEAGE_LIVEDISPLAY_V2_0_LEGACYMM_CONSTANTS_H
diff --git a/legacymm/DisplayModes.cpp b/legacymm/DisplayModes.cpp
index 9449ceb..55a2d3f 100644
--- a/legacymm/DisplayModes.cpp
+++ b/legacymm/DisplayModes.cpp
@@ -14,7 +14,12 @@
  * limitations under the License.
  */
 
+#include <dlfcn.h>
+
+#include "Constants.h"
 #include "DisplayModes.h"
+#include "PictureAdjustment.h"
+#include "Types.h"
 
 namespace vendor {
 namespace lineage {
@@ -22,34 +27,160 @@ namespace livedisplay {
 namespace V2_0 {
 namespace legacymm {
 
+DisplayModes::DisplayModes(void* libHandle) {
+    mLibHandle = libHandle;
+    disp_api_supported =
+        reinterpret_cast<int (*)(int32_t, int32_t)>(dlsym(mLibHandle, "disp_api_supported"));
+    disp_api_get_num_display_modes = reinterpret_cast<int (*)(int32_t, int32_t, int*)>(
+        dlsym(mLibHandle, "disp_api_get_num_display_modes"));
+    disp_api_get_display_modes = reinterpret_cast<int (*)(int32_t, int32_t, void*, int)>(
+        dlsym(mLibHandle, "disp_api_get_display_modes"));
+    disp_api_get_active_display_mode = reinterpret_cast<int (*)(int32_t, int*, uint32_t*)>(
+        dlsym(mLibHandle, "disp_api_get_active_display_mode"));
+    disp_api_set_active_display_mode = reinterpret_cast<int (*)(int32_t, int)>(
+        dlsym(mLibHandle, "disp_api_set_active_display_mode"));
+    disp_api_get_default_display_mode = reinterpret_cast<int (*)(int32_t, int*)>(
+        dlsym(mLibHandle, "disp_api_get_default_display_mode"));
+    disp_api_set_default_display_mode = reinterpret_cast<int (*)(int32_t, int)>(
+        dlsym(mLibHandle, "disp_api_set_default_display_mode"));
+
+    if (isSupported()) {
+        DisplayMode mode = getDefaultDisplayModeInternal();
+        if (mode.id > 0) {
+            setDisplayMode(mode.id, false);
+        }
+    }
+}
+
+bool DisplayModes::isSupported() {
+    int count = 0;
+
+    if (disp_api_supported == nullptr || disp_api_supported(0, DISPLAY_MODES_FEATURE) == 0) {
+        return false;
+    }
+
+    if (disp_api_get_num_display_modes != nullptr) {
+        if (disp_api_get_num_display_modes(0, 0, &count) == 0) {
+            return count > 0;
+        }
+    }
+
+    return false;
+}
+
+std::vector<DisplayMode> DisplayModes::getDisplayModesInternal() {
+    std::vector<DisplayMode> modes;
+    int count = 0;
+
+    if (disp_api_get_num_display_modes == nullptr ||
+        disp_api_get_num_display_modes(0, 0, &count) != 0) {
+        return modes;
+    }
+
+    if (disp_api_get_display_modes != nullptr) {
+        mm_disp_mode* tmp = new mm_disp_mode[count];
+        for (int i = 0; i < count; i++) {
+            tmp[i].id = -1;
+            tmp[i].name = new char[128];
+            tmp[i].len = 128;
+        }
+
+        if (disp_api_get_display_modes(0, 0, tmp, count) == 0) {
+            for (int i = 0; i < count; i++) {
+                modes.push_back(DisplayMode{tmp[i].id, std::string(tmp[i].name)});
+                delete[] tmp[i].name;
+            }
+        } else {
+            for (int i = 0; i < count; i++) {
+                delete[] tmp[i].name;
+            }
+        }
+
+        delete[] tmp;
+    }
+
+    return modes;
+}
+
+DisplayMode DisplayModes::getDisplayModeById(int32_t id) {
+    std::vector<DisplayMode> modes = getDisplayModesInternal();
+
+    for (const DisplayMode& mode : modes) {
+        if (mode.id == id) {
+            return mode;
+        }
+    }
+
+    return DisplayMode{-1, ""};
+}
+
+DisplayMode DisplayModes::getCurrentDisplayModeInternal() {
+    int id = 0;
+    uint32_t mask = 0;
+
+    if (disp_api_get_active_display_mode != nullptr) {
+        if (disp_api_get_active_display_mode(0, &id, &mask) == 0 && id >= 0) {
+            return getDisplayModeById(id);
+        }
+    }
+
+    return DisplayMode{-1, ""};
+}
+
+DisplayMode DisplayModes::getDefaultDisplayModeInternal() {
+    int id = 0;
+
+    if (disp_api_get_default_display_mode != nullptr) {
+        if (disp_api_get_default_display_mode(0, &id) == 0 && id >= 0) {
+            return getDisplayModeById(id);
+        }
+    }
+
+    return DisplayMode{-1, ""};
+}
+
 // Methods from ::vendor::lineage::livedisplay::V2_0::IDisplayModes follow.
 Return<void> DisplayModes::getDisplayModes(getDisplayModes_cb _hidl_cb) {
-    // TODO implement
+    _hidl_cb(getDisplayModesInternal());
     return Void();
 }
 
 Return<void> DisplayModes::getCurrentDisplayMode(getCurrentDisplayMode_cb _hidl_cb) {
-    // TODO implement
+    _hidl_cb(getCurrentDisplayModeInternal());
     return Void();
 }
 
 Return<void> DisplayModes::getDefaultDisplayMode(getDefaultDisplayMode_cb _hidl_cb) {
-    // TODO implement
+    _hidl_cb(getDefaultDisplayModeInternal());
     return Void();
 }
 
 Return<bool> DisplayModes::setDisplayMode(int32_t modeID, bool makeDefault) {
-    // TODO implement
-    return bool {};
-}
+    DisplayMode currentMode = getCurrentDisplayModeInternal();
+
+    if (currentMode.id >= 0 && currentMode.id == modeID) {
+        return true;
+    }
 
+    DisplayMode mode = getDisplayModeById(modeID);
+    if (mode.id < 0) {
+        return false;
+    }
 
-// Methods from ::android::hidl::base::V1_0::IBase follow.
+    if (disp_api_set_active_display_mode == nullptr || disp_api_set_active_display_mode(0, modeID)) {
+        return false;
+    }
+
+    if (makeDefault && (disp_api_set_default_display_mode == nullptr ||
+                        disp_api_set_default_display_mode(0, modeID))) {
+        return false;
+    }
+
+    PictureAdjustment::updateDefaultPictureAdjustment();
+
+    return true;
+}
 
-//IDisplayModes* HIDL_FETCH_IDisplayModes(const char* /* name */) {
-    //return new DisplayModes();
-//}
-//
 }  // namespace legacymm
 }  // namespace V2_0
 }  // namespace livedisplay
diff --git a/legacymm/DisplayModes.h b/legacymm/DisplayModes.h
index c77b3ef..2e23120 100644
--- a/legacymm/DisplayModes.h
+++ b/legacymm/DisplayModes.h
@@ -17,9 +17,9 @@
 #ifndef VENDOR_LINEAGE_LIVEDISPLAY_V2_0_DISPLAYMODES_H
 #define VENDOR_LINEAGE_LIVEDISPLAY_V2_0_DISPLAYMODES_H
 
-#include <vendor/lineage/livedisplay/2.0/IDisplayModes.h>
 #include <hidl/MQDescriptor.h>
 #include <hidl/Status.h>
+#include <vendor/lineage/livedisplay/2.0/IDisplayModes.h>
 
 namespace vendor {
 namespace lineage {
@@ -35,19 +35,34 @@ using ::android::hardware::Return;
 using ::android::hardware::Void;
 using ::android::sp;
 
-struct DisplayModes : public IDisplayModes {
+class DisplayModes : public IDisplayModes {
+  public:
+    DisplayModes(void* libHandle);
+
+    bool isSupported();
+
     // Methods from ::vendor::lineage::livedisplay::V2_0::IDisplayModes follow.
     Return<void> getDisplayModes(getDisplayModes_cb _hidl_cb) override;
     Return<void> getCurrentDisplayMode(getCurrentDisplayMode_cb _hidl_cb) override;
     Return<void> getDefaultDisplayMode(getDefaultDisplayMode_cb _hidl_cb) override;
     Return<bool> setDisplayMode(int32_t modeID, bool makeDefault) override;
 
-    // Methods from ::android::hidl::base::V1_0::IBase follow.
+  private:
+    void* mLibHandle;
 
-};
+    int (*disp_api_supported)(int32_t, int32_t);
+    int (*disp_api_get_num_display_modes)(int32_t, int32_t, int*);
+    int (*disp_api_get_display_modes)(int32_t, int32_t, void*, int);
+    int (*disp_api_get_active_display_mode)(int32_t, int*, uint32_t*);
+    int (*disp_api_set_active_display_mode)(int32_t, int);
+    int (*disp_api_get_default_display_mode)(int32_t, int*);
+    int (*disp_api_set_default_display_mode)(int32_t, int);
 
-// FIXME: most likely delete, this is only for passthrough implementations
-// extern "C" IDisplayModes* HIDL_FETCH_IDisplayModes(const char* name);
+    std::vector<DisplayMode> getDisplayModesInternal();
+    DisplayMode getDisplayModeById(int32_t id);
+    DisplayMode getCurrentDisplayModeInternal();
+    DisplayMode getDefaultDisplayModeInternal();
+};
 
 }  // namespace legacymm
 }  // namespace V2_0
diff --git a/legacymm/PictureAdjustment.cpp b/legacymm/PictureAdjustment.cpp
index bd9f4ad..ee5171a 100644
--- a/legacymm/PictureAdjustment.cpp
+++ b/legacymm/PictureAdjustment.cpp
@@ -14,7 +14,11 @@
  * limitations under the License.
  */
 
+#include <dlfcn.h>
+
+#include "Constants.h"
 #include "PictureAdjustment.h"
+#include "Types.h"
 
 namespace vendor {
 namespace lineage {
@@ -22,54 +26,165 @@ namespace livedisplay {
 namespace V2_0 {
 namespace legacymm {
 
+static sp<PictureAdjustment> sInstance;
+
+PictureAdjustment::PictureAdjustment(void* libHandle) {
+    sInstance = this;
+
+    mLibHandle = libHandle;
+    disp_api_supported =
+        reinterpret_cast<int (*)(int32_t, int32_t)>(dlsym(mLibHandle, "disp_api_supported"));
+    disp_api_get_pa_range =
+        reinterpret_cast<int (*)(int32_t, void*)>(dlsym(mLibHandle, "disp_api_get_pa_range"));
+    disp_api_get_pa_config =
+        reinterpret_cast<int (*)(int32_t, void*)>(dlsym(mLibHandle, "disp_api_get_pa_config"));
+    disp_api_set_pa_config =
+        reinterpret_cast<int (*)(int32_t, void*)>(dlsym(mLibHandle, "disp_api_set_pa_config"));
+    mDefaultPictureAdjustment = HSIC{};
+}
+
+bool PictureAdjustment::isSupported() {
+    mm_pa_range r{};
+
+    if (disp_api_supported == nullptr || disp_api_supported(0, PICTURE_ADJUSTMENT_FEATURE) == 0) {
+        return false;
+    }
+
+    if (disp_api_get_pa_range == nullptr || disp_api_get_pa_range(0, &r) != 0) {
+        return false;
+    }
+
+    return r.max.hue != 0 && r.min.hue != 0 && r.max.saturation != 0.f &&
+             r.min.saturation != 0.f && r.max.intensity != 0.f && r.min.intensity != 0.f &&
+             r.max.contrast != 0.f && r.min.contrast != 0.f;
+}
+
+HSIC PictureAdjustment::getPictureAdjustmentInternal() {
+    mm_pa_config config{};
+
+    if (disp_api_get_pa_config != nullptr) {
+        if (disp_api_get_pa_config(0, &config) == 0) {
+            return HSIC{
+                static_cast<float>(config.data.hue), static_cast<float>(config.data.saturation),
+                static_cast<float>(config.data.intensity), static_cast<float>(config.data.contrast),
+                static_cast<float>(config.data.saturationThreshold)};
+        }
+    }
+
+    return HSIC{};
+}
+
+void PictureAdjustment::updateDefaultPictureAdjustment() {
+    if (sInstance != nullptr) {
+        sInstance->mDefaultPictureAdjustment = sInstance->getPictureAdjustmentInternal();
+    }
+}
+
 // Methods from ::vendor::lineage::livedisplay::V2_0::IPictureAdjustment follow.
 Return<void> PictureAdjustment::getHueRange(getHueRange_cb _hidl_cb) {
-    // TODO implement
+    FloatRange range{};
+    mm_pa_range r{};
+
+    if (disp_api_get_pa_range != nullptr) {
+        if (disp_api_get_pa_range(0, &r) == 0) {
+            range.max = r.max.hue;
+            range.min = r.min.hue;
+            range.step = 1;
+        }
+    }
+
+    _hidl_cb(range);
     return Void();
 }
 
 Return<void> PictureAdjustment::getSaturationRange(getSaturationRange_cb _hidl_cb) {
-    // TODO implement
+    FloatRange range{};
+    mm_pa_range r{};
+
+    if (disp_api_get_pa_range != nullptr) {
+        if (disp_api_get_pa_range(0, &r) == 0) {
+            range.max = r.max.saturation;
+            range.min = r.min.saturation;
+            range.step = 1;
+        }
+    }
+
+    _hidl_cb(range);
     return Void();
 }
 
 Return<void> PictureAdjustment::getIntensityRange(getIntensityRange_cb _hidl_cb) {
-    // TODO implement
+    FloatRange range{};
+    mm_pa_range r{};
+
+    if (disp_api_get_pa_range != nullptr) {
+        if (disp_api_get_pa_range(0, &r) == 0) {
+            range.max = r.max.intensity;
+            range.min = r.min.intensity;
+            range.step = 1;
+        }
+    }
+
+    _hidl_cb(range);
     return Void();
 }
 
 Return<void> PictureAdjustment::getContrastRange(getContrastRange_cb _hidl_cb) {
-    // TODO implement
+    FloatRange range{};
+    mm_pa_range r{};
+
+    if (disp_api_get_pa_range != nullptr) {
+        if (disp_api_get_pa_range(0, &r) == 0) {
+            range.max = r.max.contrast;
+            range.min = r.min.contrast;
+            range.step = 1;
+        }
+    }
+
+    _hidl_cb(range);
     return Void();
 }
 
 Return<void> PictureAdjustment::getSaturationThresholdRange(getSaturationThresholdRange_cb _hidl_cb) {
-    // TODO implement
+    FloatRange range{};
+    mm_pa_range r{};
+
+    if (disp_api_get_pa_range != nullptr) {
+        if (disp_api_get_pa_range(0, &r) == 0) {
+            range.max = r.max.saturationThreshold;
+            range.min = r.min.saturationThreshold;
+            range.step = 1;
+        }
+    }
+
+    _hidl_cb(range);
     return Void();
 }
 
 Return<void> PictureAdjustment::getPictureAdjustment(getPictureAdjustment_cb _hidl_cb) {
-    // TODO implement
+    _hidl_cb(getPictureAdjustmentInternal());
     return Void();
 }
 
 Return<void> PictureAdjustment::getDefaultPictureAdjustment(getDefaultPictureAdjustment_cb _hidl_cb) {
-    // TODO implement
+    _hidl_cb(mDefaultPictureAdjustment);
     return Void();
 }
 
-Return<bool> PictureAdjustment::setPictureAdjustment(const ::vendor::lineage::livedisplay::V2_0::HSIC& hsic) {
-    // TODO implement
-    return bool {};
-}
+Return<bool> PictureAdjustment::setPictureAdjustment(
+    const ::vendor::lineage::livedisplay::V2_0::HSIC& hsic) {
+    mm_pa_config config = {0xF,
+                           {static_cast<int>(hsic.hue), static_cast<int>(hsic.saturation),
+                            static_cast<int>(hsic.intensity), static_cast<int>(hsic.contrast),
+                            static_cast<int>(hsic.saturationThreshold)}};
 
+    if (disp_api_set_pa_config != nullptr) {
+        return disp_api_set_pa_config(0, &config) == 0;
+    }
 
-// Methods from ::android::hidl::base::V1_0::IBase follow.
+    return false;
+}
 
-//IPictureAdjustment* HIDL_FETCH_IPictureAdjustment(const char* /* name */) {
-    //return new PictureAdjustment();
-//}
-//
 }  // namespace legacymm
 }  // namespace V2_0
 }  // namespace livedisplay
diff --git a/legacymm/PictureAdjustment.h b/legacymm/PictureAdjustment.h
index 60a3b63..66ddf6c 100644
--- a/legacymm/PictureAdjustment.h
+++ b/legacymm/PictureAdjustment.h
@@ -17,9 +17,9 @@
 #ifndef VENDOR_LINEAGE_LIVEDISPLAY_V2_0_PICTUREADJUSTMENT_H
 #define VENDOR_LINEAGE_LIVEDISPLAY_V2_0_PICTUREADJUSTMENT_H
 
-#include <vendor/lineage/livedisplay/2.0/IPictureAdjustment.h>
 #include <hidl/MQDescriptor.h>
 #include <hidl/Status.h>
+#include <vendor/lineage/livedisplay/2.0/IPictureAdjustment.h>
 
 namespace vendor {
 namespace lineage {
@@ -35,8 +35,14 @@ using ::android::hardware::Return;
 using ::android::hardware::Void;
 using ::android::sp;
 
-struct PictureAdjustment : public IPictureAdjustment {
-    // Methods from ::vendor::lineage::livedisplay::V2_0::IPictureAdjustment follow.
+class PictureAdjustment : public IPictureAdjustment {
+  public:
+    PictureAdjustment(void* libHandle);
+
+    bool isSupported();
+
+    // Methods from ::vendor::lineage::livedisplay::V2_0::IPictureAdjustment
+    // follow.
     Return<void> getHueRange(getHueRange_cb _hidl_cb) override;
     Return<void> getSaturationRange(getSaturationRange_cb _hidl_cb) override;
     Return<void> getIntensityRange(getIntensityRange_cb _hidl_cb) override;
@@ -44,14 +50,23 @@ struct PictureAdjustment : public IPictureAdjustment {
     Return<void> getSaturationThresholdRange(getSaturationThresholdRange_cb _hidl_cb) override;
     Return<void> getPictureAdjustment(getPictureAdjustment_cb _hidl_cb) override;
     Return<void> getDefaultPictureAdjustment(getDefaultPictureAdjustment_cb _hidl_cb) override;
-    Return<bool> setPictureAdjustment(const ::vendor::lineage::livedisplay::V2_0::HSIC& hsic) override;
+    Return<bool> setPictureAdjustment(
+        const ::vendor::lineage::livedisplay::V2_0::HSIC& hsic) override;
 
-    // Methods from ::android::hidl::base::V1_0::IBase follow.
+    static void updateDefaultPictureAdjustment();
 
-};
+  private:
+    void* mLibHandle;
+
+    int (*disp_api_supported)(int32_t, int32_t);
+    int (*disp_api_get_pa_range)(int32_t, void*);
+    int (*disp_api_get_pa_config)(int32_t, void*);
+    int (*disp_api_set_pa_config)(int32_t, void*);
 
-// FIXME: most likely delete, this is only for passthrough implementations
-// extern "C" IPictureAdjustment* HIDL_FETCH_IPictureAdjustment(const char* name);
+    HSIC getPictureAdjustmentInternal();
+
+    HSIC mDefaultPictureAdjustment;
+};
 
 }  // namespace legacymm
 }  // namespace V2_0
diff --git a/legacymm/Types.h b/legacymm/Types.h
new file mode 100644
index 0000000..06e070a
--- /dev/null
+++ b/legacymm/Types.h
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2019 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef VENDOR_LINEAGE_LIVEDISPLAY_V2_0_LEGACYMM_TYPES_H
+#define VENDOR_LINEAGE_LIVEDISPLAY_V2_0_LEGACYMM_TYPES_H
+
+namespace vendor {
+namespace lineage {
+namespace livedisplay {
+namespace V2_0 {
+namespace legacymm {
+
+struct mm_cb_range {
+    int max;
+    int min;
+};
+
+struct mm_disp_mode {
+    int id;
+    char* name;
+    uint32_t len;
+    int32_t type;
+};
+
+struct mm_pa_data {
+    int hue;
+    int saturation;
+    int intensity;
+    int contrast;
+    int saturationThreshold;
+};
+
+struct mm_pa_config {
+    int flags;
+    struct mm_pa_data data;
+};
+
+struct mm_pa_range {
+    struct mm_pa_data max;
+    struct mm_pa_data min;
+};
+
+}  // namespace legacymm
+}  // namespace V2_0
+}  // namespace livedisplay
+}  // namespace lineage
+}  // namespace vendor
+
+#endif  // VENDOR_LINEAGE_LIVEDISPLAY_V2_0_LEGACYMM_TYPES_H
diff --git a/legacymm/service.cpp b/legacymm/service.cpp
new file mode 100644
index 0000000..76f4306
--- /dev/null
+++ b/legacymm/service.cpp
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2019 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <dlfcn.h>
+
+#define LOG_TAG "vendor.lineage.livedisplay@2.0-service-legacymm"
+
+#include <android-base/logging.h>
+#include <binder/ProcessState.h>
+#include <hidl/HidlTransportSupport.h>
+
+#include "ColorBalance.h"
+#include "DisplayModes.h"
+#include "PictureAdjustment.h"
+
+#define MM_DISP_LIB "libmm-disp-apis.so"
+
+using android::hardware::configureRpcThreadpool;
+using android::hardware::joinRpcThreadpool;
+using android::sp;
+using android::status_t;
+using android::OK;
+
+using ::vendor::lineage::livedisplay::V2_0::IColorBalance;
+using ::vendor::lineage::livedisplay::V2_0::legacymm::ColorBalance;
+using ::vendor::lineage::livedisplay::V2_0::IDisplayModes;
+using ::vendor::lineage::livedisplay::V2_0::legacymm::DisplayModes;
+using ::vendor::lineage::livedisplay::V2_0::IPictureAdjustment;
+using ::vendor::lineage::livedisplay::V2_0::legacymm::PictureAdjustment;
+
+int main() {
+    // Vendor backend
+    void* libHandle = nullptr;
+    int (*disp_api_init)(int32_t) = nullptr;
+
+    // HIDL frontend
+    sp<ColorBalance> cb;
+    sp<DisplayModes> dm;
+    sp<PictureAdjustment> pa;
+    uint8_t services = 0;
+
+    status_t status = OK;
+
+    LOG(INFO) << "LiveDisplay HAL service is starting.";
+
+    libHandle = dlopen(MM_DISP_LIB, RTLD_NOW);
+    if (libHandle == nullptr) {
+        LOG(ERROR) << "Can not get " << MM_DISP_LIB << " (" << dlerror() << ")";
+        goto shutdown;
+    }
+
+    disp_api_init = reinterpret_cast<int (*)(int32_t)>(dlsym(libHandle, "disp_api_init"));
+    if (disp_api_init == nullptr) {
+        LOG(ERROR) << "Can not get disp_api_init from " << MM_DISP_LIB << " (" << dlerror() << ")";
+        goto shutdown;
+    }
+
+    status = disp_api_init(0);
+    if (status != OK) {
+        LOG(ERROR) << "Can not initialize " << MM_DISP_LIB << " (" << status << ")";
+        goto shutdown;
+    }
+
+    cb = new ColorBalance(libHandle);
+    if (cb == nullptr) {
+        LOG(ERROR) << "Can not create an instance of LiveDisplay HAL ColorBalance Iface, exiting.";
+        goto shutdown;
+    }
+    if (cb->isSupported()) {
+        services++;
+    }
+
+    dm = new DisplayModes(libHandle);
+    if (dm == nullptr) {
+        LOG(ERROR) << "Can not create an instance of LiveDisplay HAL DisplayModes Iface, exiting.";
+        goto shutdown;
+    }
+    if (dm->isSupported()) {
+        services++;
+    }
+
+    pa = new PictureAdjustment(libHandle);
+    if (pa == nullptr) {
+        LOG(ERROR)
+            << "Can not create an instance of LiveDisplay HAL PictureAdjustment Iface, exiting.";
+        goto shutdown;
+    }
+    if (pa->isSupported()) {
+        services++;
+    }
+
+    if (services == 0) {
+        goto shutdown;
+    }
+
+    configureRpcThreadpool(services, true /*callerWillJoin*/);
+
+    if (cb->isSupported()) {
+        status = cb->registerAsService();
+        if (status != OK) {
+            LOG(ERROR) << "Could not register service for LiveDisplay HAL ColorBalance Iface ("
+                       << status << ")";
+            goto shutdown;
+        }
+    }
+
+    if (dm->isSupported()) {
+        status = dm->registerAsService();
+        if (status != OK) {
+            LOG(ERROR) << "Could not register service for LiveDisplay HAL DisplayModes Iface ("
+                       << status << ")";
+            goto shutdown;
+        }
+    }
+
+    if (pa->isSupported()) {
+        status = pa->registerAsService();
+        if (status != OK) {
+            LOG(ERROR) << "Could not register service for LiveDisplay HAL PictureAdjustment Iface ("
+                       << status << ")";
+            goto shutdown;
+        }
+    }
+
+    LOG(INFO) << "LiveDisplay HAL service is ready.";
+    joinRpcThreadpool();
+    // Should not pass this line
+
+shutdown:
+    // Cleanup what we started
+    if (disp_api_init != nullptr) {
+        disp_api_init(1);
+    }
+
+    if (libHandle != nullptr) {
+        dlclose(libHandle);
+    }
+
+    // In normal operation, we don't expect the thread pool to shutdown
+    LOG(ERROR) << "LiveDisplay HAL service is shutting down.";
+    return 1;
+}
diff --git a/legacymm/vendor.lineage.livedisplay@2.0-service-legacymm.rc b/legacymm/vendor.lineage.livedisplay@2.0-service-legacymm.rc
new file mode 100644
index 0000000..ecb6e6a
--- /dev/null
+++ b/legacymm/vendor.lineage.livedisplay@2.0-service-legacymm.rc
@@ -0,0 +1,4 @@
+service vendor.livedisplay-hal-2-0-legacymm /vendor/bin/hw/vendor.lineage.livedisplay@2.0-service-legacymm
+    class hal
+    user system
+    group system
-- 
2.17.1

