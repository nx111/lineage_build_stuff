From 5377f0a38ddd3b9c38a2a7c03a76435c503424e1 Mon Sep 17 00:00:00 2001
From: Luca Stefani <luca.stefani.ge1@gmail.com>
Date: Tue, 5 Feb 2019 09:37:10 +0100
Subject: [PATCH] Squash of
 github/lineage-16.0(30a7b181)..lineage-16.0-android-9.0.0_r31(9d6fe3b1) (DO
 NOT SUBMIT)

Amit Mahajan (6):
 - Allow REQUEST_NOT_SUPPORTED as an error for startNetworkScan
 - Allow NOT_SUPPORTED for setLinkCapacityReportingCriteria on GERAN.
 - [automerger skipped] Merge "Allow REQUEST_NOT_SUPPORTED as an error
   for startNetworkScan" into pie-vts-dev am: 00cdcb77f8  -s ours
 - [automerger skipped] Merge "Allow NOT_SUPPORTED for
   setLinkCapacityReportingCriteria on GERAN." into pie-vts-dev am:
   429da8656e  -s ours
 - Allow general errors for getImsiForApp().
 - [automerger skipped] Allow general errors for getImsiForApp(). am:
   1f3d0a68a4  -s ours

Chia-I Wu (2):
 - graphics: composer@2.2 does not require mapper@2.1
 - graphics: composer@2.2 does not require mapper@2.1 am: 0eafa742c6

Emilian Peev (4):
 - Camera: Don't hold 'mLock' when closing the camera session
 - [automerger skipped] Merge "Camera: Don't hold 'mLock' when closing
   the camera session" into pie-vts-dev am: 75ceb36b27  -s ours
 - Camera: Allow 3% ISO tolerance during ISO burst VTS
 - [automerger skipped] Merge "Camera: Allow 3% ISO tolerance during ISO
   burst VTS" into pie-vts-dev am: 391eb588cf  -s ours

Eran Messeri (2):
 - Fixing Keymaster documentation.
 - [automerger skipped] Merge "Fixing Keymaster documentation." into
   pie-vts-dev am: 33f7970672  -s ours

Kevin Rocard (12):
 - Audio VTS was testing wrong uninitialized variable due to typo
 - VTS: Do not require XML for Audio effect V2
 - [automerger skipped] Merge "Audio VTS was testing wrong uninitialized
   variable due to typo" into pie-vts-dev am: b3e86d489a  -s ours
 - [automerger skipped] Merge "VTS: Do not require XML for Audio effect
   V2" into pie-vts-dev am: 5e6dd1288e  -s ours
 - Allow getCapturePosition to return 0 frames for unprepared streams
 - [automerger skipped] Merge "Allow getCapturePosition to return 0
   frames for unprepared streams" into pie-vts-dev am: 137194ef5e  -s
   ours
 - Audio VTS: Always check for Result::isOk()
 - Merge "Audio VTS: Always check for Result::isOk()" into pie-vts-dev
   am: 2070f8b0b8
 - Audio VTS: Workaround async HIDL destructor by sleeping
 - Audio VTS: Workaround async HIDL destructor by sleeping am:
   d87a288e82
 - Audio VTS: Do not constrain implementation frameCount
 - Audio VTS: Do not constrain implementation frameCount am: 069bc45044

Luca Stefani (1):
 - Merge tag 'android-9.0.0_r31' into lineage-16.0-android-9.0.0_r31

Ng Zhi An (2):
 - Skip hal v1 check after p on low ram devices
 - Skip hal v1 check after p on low ram devices am: a0eb7e415c

Ruchi Kandoi (2):
 - Secure_element: vts: Modify openBasicChannel as per OMAPI standard
 - [automerger skipped] Secure_element: vts: Modify openBasicChannel as
   per OMAPI standard am: ecdec18c73  -s ours

Shawn Willden (5):
 - Fix attestation test.
 - Require keymaster4 attestations to contain the right version.
 - Change ImportWrappedKeyTest back to SHA1
 - [automerger skipped] Merge "Require keymaster4 attestations to
   contain the right version." into pie-vts-dev am: 516718071b  -s ours
 - [automerger skipped] Merge "Change ImportWrappedKeyTest back to SHA1"
   into pie-vts-dev am: e7300721a0  -s ours

Treehugger Robot (20):
 - Merge "Audio VTS was testing wrong uninitialized variable due to
   typo" into pie-vts-dev
 - Merge "Camera: Don't hold 'mLock' when closing the camera session"
   into pie-vts-dev
 - Merge "VTS: Do not require XML for Audio effect V2" into pie-vts-dev
 - Merge "Tolerate 1 sv status in GNSS blacklist VTS test" into
   pie-vts-dev
 - Merge changes Ia3b96e83,I80d924cc into pie-vts-dev
 - Merge "Allow REQUEST_NOT_SUPPORTED as an error for startNetworkScan"
   into pie-vts-dev
 - Merge "Allow NOT_SUPPORTED for setLinkCapacityReportingCriteria on
   GERAN." into pie-vts-dev
 - Merge "Fix missed refactor of serial" into pie-vts-dev
 - Merge "Loose startNetworkScan cases" into pie-vts-dev
 - Merge "Fixing Keymaster documentation." into pie-vts-dev
 - Merge changes Ic41afbd0,Ibe264d08 into pie-vts-dev
 - Merge "keymaster: skip SHA2 digest tests for strongbox" into
   pie-vts-dev
 - Merge "Require keymaster4 attestations to contain the right version."
   into pie-vts-dev
 - Merge "Change ImportWrappedKeyTest back to SHA1" into pie-vts-dev
 - Merge "Fix setAllowedCarrier" into pie-vts-dev
 - Merge "Set the floor value of time estimate as 2017 Jan 01 00:00:00
   GMT" into pie-vts-dev
 - Merge "Allow getCapturePosition to return 0 frames for unprepared
   streams" into pie-vts-dev
 - Merge "Camera: Allow 3% ISO tolerance during ISO burst VTS" into
   pie-vts-dev
 - Merge "Audio VTS: Always check for Result::isOk()" into pie-vts-dev
 - Merge "Allow more time to un-blacklist strongest satelite" into
   pie-vts-dev

Vishal Agarwal (2):
 - Add VTS test to verify scheduling capability
 - [automerger skipped] Add VTS test to verify scheduling capability am:
   2910e64d24  -s ours

WyattRiley (4):
 - Improve VTS GNSS 1.1 reliability.
 - [automerger skipped] Improve VTS GNSS 1.1 reliability. am: 2d86da7b28
    -s ours
 - Allow more time to un-blacklist strongest satelite
 - Merge "Allow more time to un-blacklist strongest satelite" into
   pie-vts-dev am: 23874c7ae9

Xusong Wang (2):
 - Fix logics for floating-point comparision in VTS test.
 - Fix logics for floating-point comparision in VTS test. am: 39c865b3aa

Yu-Han Yang (8):
 - Tolerate 1 sv status in GNSS blacklist VTS test
 - [automerger skipped] Merge "Tolerate 1 sv status in GNSS blacklist
   VTS test" into pie-vts-dev am: a9ad41d1ad  -s ours
 - Inject last location in InjectBestLocation VTS test
 - Delete time/position in InjectDelete instead of Delete_all
 - [automerger skipped] Inject last location in InjectBestLocation VTS
   test am: 75b0c4bba2  -s ours
 - [automerger skipped] Delete time/position in InjectDelete instead of
   Delete_all am: 66fb7a1b88  -s ours
 - Set the floor value of time estimate as 2017 Jan 01 00:00:00 GMT
 - [automerger skipped] Merge "Set the floor value of time estimate as
   2017 Jan 01 00:00:00 GMT" into pie-vts-dev am: 4e0c7c1760  -s ours

android-build-team Robot (6):
 - Snap for 5044688 from f20baa77b82a129d2fd088845e9ee167680f40c0 to
   pi-qpr2-release
 - Snap for 5045641 from f8f519f412f2744341ddc7dc2c4dec64cc115756 to
   pi-qpr2-release
 - Snap for 5053079 from b86e2855373731bb54948cee1dda9d73d3309eff to
   pi-qpr2-release
 - Snap for 5053079 from b86e2855373731bb54948cee1dda9d73d3309eff to
   pi-qpr2-release
 - Merge "Snap for 5053079 from b86e2855373731bb54948cee1dda9d73d3309eff
   to pi-qpr2-release" into pi-qpr2-release
 - Snap for 5087486 from 5ef198aa6e7bea74ad373f1ba2e561373c5ee8f7 to
   pi-qpr2-release

jiabin (2):
 - Test getActiveMicrophones API when mic is found on the device.
 - Test getActiveMicrophones API when mic is found on the device. am:
   497edcc026

nagendra modadugu (4):
 - keymaster: spec does not require that update produce output
 - keymaster: skip SHA2 digest tests for strongbox
 - [automerger skipped] Merge changes Ic41afbd0,Ibe264d08 into
   pie-vts-dev am: e101aa87a3  -s ours
 - [automerger skipped] Merge "keymaster: skip SHA2 digest tests for
   strongbox" into pie-vts-dev am: 86104dcc18  -s ours

sqian (11):
 - Add SIM_PUK2 for Icc VTS tests
 - Add REQUEST_NOT_SUPPORTED for pin and pin2 Icc VTS
 - Add setIndicationFilter response notification in 1.2 VTS
 - [automerger skipped] Add setIndicationFilter response notification in
   1.2 VTS am: 388883a3ec  -s ours
 - [automerger skipped] Merge changes Ia3b96e83,I80d924cc into
   pie-vts-dev am: 0b1461687f  -s ours
 - Fix missed refactor of serial
 - Loose startNetworkScan cases
 - [automerger skipped] Merge "Fix missed refactor of serial" into
   pie-vts-dev am: d4f9ad2c59  -s ours
 - [automerger skipped] Merge "Loose startNetworkScan cases" into
   pie-vts-dev am: 3c233d344c  -s ours
 - Fix setAllowedCarrier
 - [automerger skipped] Merge "Fix setAllowedCarrier" into pie-vts-dev
   am: 052f207b42  -s ours

Change-Id: I4a2bd1b08da4768894fd8d51cc6eb75b75e928d5

Change-Id: I1c44396d0efa25dc433d1daa78516cc215d26ce4
---
 .../functional/AudioPrimaryHidlHalTest.cpp    |   4 +-
 audio/core/4.0/vts/functional/Android.bp      |   3 +
 .../functional/AudioPrimaryHidlHalTest.cpp    | 124 +++++++++++++++---
 .../VtsHalCameraProviderV2_4TargetTest.cpp    |   8 ++
 .../vts/functional/gnss_hal_test_cases.cpp    |  77 +++++++----
 .../VtsHalGraphicsComposerV2_2TargetTest.cpp  |  12 +-
 .../vts/functional/GeneratedTestHarness.cpp   |  19 ++-
 7 files changed, 185 insertions(+), 62 deletions(-)

diff --git a/audio/core/2.0/vts/functional/AudioPrimaryHidlHalTest.cpp b/audio/core/2.0/vts/functional/AudioPrimaryHidlHalTest.cpp
index bb1d26f9..a08a2d62 100644
--- a/audio/core/2.0/vts/functional/AudioPrimaryHidlHalTest.cpp
+++ b/audio/core/2.0/vts/functional/AudioPrimaryHidlHalTest.cpp
@@ -661,8 +661,8 @@ static R extract(Return<R> ret) {
         code;                                          \
     }
 
-TEST_IO_STREAM(GetFrameCount, "Check that the stream frame count == the one it was opened with",
-               ASSERT_EQ(audioConfig.frameCount, extract(stream->getFrameCount())))
+TEST_IO_STREAM(GetFrameCount, "Check that getting stream frame count does not crash the HAL.",
+               ASSERT_TRUE(stream->getFrameCount().isOk()))
 
 TEST_IO_STREAM(GetSampleRate, "Check that the stream sample rate == the one it was opened with",
                ASSERT_EQ(audioConfig.sampleRateHz, extract(stream->getSampleRate())))
diff --git a/audio/core/4.0/vts/functional/Android.bp b/audio/core/4.0/vts/functional/Android.bp
index 22c5493d..e3b376ca 100644
--- a/audio/core/4.0/vts/functional/Android.bp
+++ b/audio/core/4.0/vts/functional/Android.bp
@@ -29,6 +29,9 @@ cc_test {
         "libicuuc_stubdata",
         "libxml2",
     ],
+    shared_libs: [
+        "libfmq",
+    ],
     header_libs: [
         "android.hardware.audio.common.util@all-versions",
     ],
diff --git a/audio/core/4.0/vts/functional/AudioPrimaryHidlHalTest.cpp b/audio/core/4.0/vts/functional/AudioPrimaryHidlHalTest.cpp
index 0f8996fc..46c228a1 100644
--- a/audio/core/4.0/vts/functional/AudioPrimaryHidlHalTest.cpp
+++ b/audio/core/4.0/vts/functional/AudioPrimaryHidlHalTest.cpp
@@ -29,6 +29,8 @@
 #include <fcntl.h>
 #include <unistd.h>
 
+#include <hwbinder/IPCThreadState.h>
+
 #include <VtsHalHidlTargetTestBase.h>
 
 #include <android-base/logging.h>
@@ -38,6 +40,8 @@
 #include <android/hardware/audio/4.0/IPrimaryDevice.h>
 #include <android/hardware/audio/4.0/types.h>
 #include <android/hardware/audio/common/4.0/types.h>
+#include <fmq/EventFlag.h>
+#include <fmq/MessageQueue.h>
 
 #include <common/all-versions/VersionUtils.h>
 
@@ -55,13 +59,17 @@ using std::vector;
 using std::list;
 
 using ::android::sp;
-using ::android::hardware::Return;
+using ::android::hardware::EventFlag;
 using ::android::hardware::hidl_bitfield;
 using ::android::hardware::hidl_enum_iterator;
 using ::android::hardware::hidl_handle;
 using ::android::hardware::hidl_string;
 using ::android::hardware::hidl_vec;
+using ::android::hardware::kSynchronizedReadWrite;
+using ::android::hardware::IPCThreadState;
+using ::android::hardware::MessageQueue;
 using ::android::hardware::MQDescriptorSync;
+using ::android::hardware::Return;
 using ::android::hardware::audio::V4_0::AudioDrain;
 using ::android::hardware::audio::V4_0::DeviceAddress;
 using ::android::hardware::audio::V4_0::IDevice;
@@ -71,6 +79,7 @@ using TtyMode = ::android::hardware::audio::V4_0::IPrimaryDevice::TtyMode;
 using ::android::hardware::audio::V4_0::IDevicesFactory;
 using ::android::hardware::audio::V4_0::IStream;
 using ::android::hardware::audio::V4_0::IStreamIn;
+using ::android::hardware::audio::V4_0::MessageQueueFlagBits;
 using ::android::hardware::audio::V4_0::TimeSpec;
 using ReadParameters = ::android::hardware::audio::V4_0::IStreamIn::ReadParameters;
 using ReadStatus = ::android::hardware::audio::V4_0::IStreamIn::ReadStatus;
@@ -164,15 +173,25 @@ TEST_F(AudioHidlTest, OpenDeviceInvalidParameter) {
 
 TEST_F(AudioHidlTest, OpenPrimaryDeviceUsingGetDevice) {
     doc::test("Calling openDevice(\"primary\") should return the primary device.");
-    Result result;
-    sp<IDevice> baseDevice;
-    ASSERT_OK(devicesFactory->openDevice("primary", returnIn(result, baseDevice)));
-    ASSERT_OK(result);
-    ASSERT_TRUE(baseDevice != nullptr);
-
-    Return<sp<IPrimaryDevice>> primaryDevice = IPrimaryDevice::castFrom(baseDevice);
-    ASSERT_TRUE(primaryDevice.isOk());
-    ASSERT_TRUE(sp<IPrimaryDevice>(primaryDevice) != nullptr);
+    {
+        Result result;
+        sp<IDevice> baseDevice;
+        ASSERT_OK(devicesFactory->openDevice("primary", returnIn(result, baseDevice)));
+        ASSERT_OK(result);
+        ASSERT_TRUE(baseDevice != nullptr);
+
+        Return<sp<IPrimaryDevice>> primaryDevice = IPrimaryDevice::castFrom(baseDevice);
+        ASSERT_TRUE(primaryDevice.isOk());
+        ASSERT_TRUE(sp<IPrimaryDevice>(primaryDevice) != nullptr);
+    }  // Destroy local IDevice proxy
+    // FIXME: there is no way to know when the remote IDevice is being destroyed
+    //        Binder does not support testing if an object is alive, thus
+    //        wait for 100ms to let the binder destruction propagates and
+    //        the remote device has the time to be destroyed.
+    //        flushCommand makes sure all local command are sent, thus should reduce
+    //        the latency between local and remote destruction.
+    IPCThreadState::self()->flushCommands();
+    usleep(100);
 }
 
 //////////////////////////////////////////////////////////////////////////////
@@ -489,7 +508,7 @@ TEST_F(AudioPrimaryHidlTest, getParameters) {
 }
 
 //////////////////////////////////////////////////////////////////////////////
-/////////////////////////////// getMicrophones ///////////////////////////////
+/////////////////////////// get(Active)Microphones ///////////////////////////
 //////////////////////////////////////////////////////////////////////////////
 
 TEST_F(AudioPrimaryHidlTest, GetMicrophonesTest) {
@@ -497,6 +516,76 @@ TEST_F(AudioPrimaryHidlTest, GetMicrophonesTest) {
     hidl_vec<MicrophoneInfo> microphones;
     ASSERT_OK(device->getMicrophones(returnIn(res, microphones)));
     ASSERT_OK(res);
+    if (microphones.size() > 0) {
+        // When there is microphone on the phone, try to open an input stream
+        // and query for the active microphones.
+        doc::test(
+            "Make sure getMicrophones always succeeds"
+            "and getActiveMicrophones always succeeds when recording from these microphones.");
+        AudioIoHandle ioHandle = (AudioIoHandle)AudioHandleConsts::AUDIO_IO_HANDLE_NONE;
+        AudioConfig config{};
+        config.channelMask = mkBitfield(AudioChannelMask::IN_MONO);
+        config.sampleRateHz = 8000;
+        config.format = AudioFormat::PCM_16_BIT;
+        auto flags = hidl_bitfield<AudioInputFlag>(AudioInputFlag::NONE);
+        const SinkMetadata initialMetadata = {{{AudioSource::MIC, 1 /* gain */}}};
+        EventFlag* efGroup;
+        for (auto microphone : microphones) {
+            if (microphone.deviceAddress.device != AudioDevice::IN_BUILTIN_MIC) {
+                continue;
+            }
+            sp<IStreamIn> stream;
+            AudioConfig suggestedConfig{};
+            ASSERT_OK(device->openInputStream(ioHandle, microphone.deviceAddress, config, flags,
+                                              initialMetadata,
+                                              returnIn(res, stream, suggestedConfig)));
+            if (res != Result::OK) {
+                ASSERT_TRUE(stream == nullptr);
+                AudioConfig suggestedConfigRetry{};
+                ASSERT_OK(device->openInputStream(ioHandle, microphone.deviceAddress,
+                                                  suggestedConfig, flags, initialMetadata,
+                                                  returnIn(res, stream, suggestedConfigRetry)));
+            }
+            ASSERT_OK(res);
+            hidl_vec<MicrophoneInfo> activeMicrophones;
+            Result readRes;
+            typedef MessageQueue<ReadParameters, kSynchronizedReadWrite> CommandMQ;
+            typedef MessageQueue<uint8_t, kSynchronizedReadWrite> DataMQ;
+            std::unique_ptr<CommandMQ> commandMQ;
+            std::unique_ptr<DataMQ> dataMQ;
+            size_t frameSize = stream->getFrameSize();
+            size_t frameCount = stream->getBufferSize() / frameSize;
+            ASSERT_OK(stream->prepareForReading(
+                frameSize, frameCount, [&](auto r, auto& c, auto& d, auto&, auto&) {
+                    readRes = r;
+                    if (readRes == Result::OK) {
+                        commandMQ.reset(new CommandMQ(c));
+                        dataMQ.reset(new DataMQ(d));
+                        if (dataMQ->isValid() && dataMQ->getEventFlagWord()) {
+                            EventFlag::createEventFlag(dataMQ->getEventFlagWord(), &efGroup);
+                        }
+                    }
+                }));
+            ASSERT_OK(readRes);
+            ReadParameters params;
+            params.command = IStreamIn::ReadCommand::READ;
+            ASSERT_TRUE(commandMQ != nullptr);
+            ASSERT_TRUE(commandMQ->isValid());
+            ASSERT_TRUE(commandMQ->write(&params));
+            efGroup->wake(static_cast<uint32_t>(MessageQueueFlagBits::NOT_FULL));
+            uint32_t efState = 0;
+            efGroup->wait(static_cast<uint32_t>(MessageQueueFlagBits::NOT_EMPTY), &efState);
+            if (efState & static_cast<uint32_t>(MessageQueueFlagBits::NOT_EMPTY)) {
+                ASSERT_OK(stream->getActiveMicrophones(returnIn(res, activeMicrophones)));
+                ASSERT_OK(res);
+                ASSERT_NE(0U, activeMicrophones.size());
+            }
+            stream->close();
+            if (efGroup) {
+                EventFlag::deleteEventFlag(&efGroup);
+            }
+        }
+    }
 }
 
 //////////////////////////////////////////////////////////////////////////////
@@ -734,8 +823,8 @@ static R extract(Return<R> ret) {
         code;                                          \
     }
 
-TEST_IO_STREAM(GetFrameCount, "Check that the stream frame count == the one it was opened with",
-               ASSERT_EQ(audioConfig.frameCount, extract(stream->getFrameCount())))
+TEST_IO_STREAM(GetFrameCount, "Check that getting stream frame count does not crash the HAL.",
+               ASSERT_TRUE(stream->getFrameCount().isOk()))
 
 TEST_IO_STREAM(GetSampleRate, "Check that the stream sample rate == the one it was opened with",
                ASSERT_EQ(audioConfig.sampleRateHz, extract(stream->getSampleRate())))
@@ -1104,14 +1193,6 @@ TEST_P(InputStreamTest, updateSinkMetadata) {
     ASSERT_OK(stream->updateSinkMetadata(initialMetadata));
 }
 
-TEST_P(InputStreamTest, getActiveMicrophones) {
-    doc::test("Getting active microphones should always succeed");
-    hidl_vec<MicrophoneInfo> microphones;
-    ASSERT_OK(device->getMicrophones(returnIn(res, microphones)));
-    ASSERT_OK(res);
-    ASSERT_TRUE(microphones.size() > 0);
-}
-
 //////////////////////////////////////////////////////////////////////////////
 ///////////////////////////////// StreamOut //////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////
@@ -1402,6 +1483,7 @@ TEST_F(AudioPrimaryHidlTest, setBtHfpVolume) {
         "Make sure setBtHfpVolume is either not supported or "
         "only succeed if volume is in [0,1]");
     auto ret = device->setBtHfpVolume(0.0);
+    ASSERT_TRUE(ret.isOk());
     if (ret == Result::NOT_SUPPORTED) {
         doc::partialTest("setBtHfpVolume is not supported");
         return;
diff --git a/camera/provider/2.4/vts/functional/VtsHalCameraProviderV2_4TargetTest.cpp b/camera/provider/2.4/vts/functional/VtsHalCameraProviderV2_4TargetTest.cpp
index 439333d9..71b78f49 100644
--- a/camera/provider/2.4/vts/functional/VtsHalCameraProviderV2_4TargetTest.cpp
+++ b/camera/provider/2.4/vts/functional/VtsHalCameraProviderV2_4TargetTest.cpp
@@ -1172,6 +1172,14 @@ TEST_F(CameraHidlTest, noHal1AfterP) {
     }
     ASSERT_GT(firstApiLevel, 0); // first_api_level must exist
 
+    // all devices with first API level == 28 and <= 1GB of RAM must set low_ram
+    // and thus be allowed to continue using HAL1
+    if ((firstApiLevel == HAL1_PHASE_OUT_API_LEVEL) &&
+        (property_get_bool("ro.config.low_ram", /*default*/ false))) {
+        ALOGI("Hal1 allowed for low ram device");
+        return;
+    }
+
     if (firstApiLevel >= HAL1_PHASE_OUT_API_LEVEL) {
         hidl_vec<hidl_string> cameraDeviceNames = getCameraDeviceNames(mProvider);
         for (const auto& name : cameraDeviceNames) {
diff --git a/gnss/1.1/vts/functional/gnss_hal_test_cases.cpp b/gnss/1.1/vts/functional/gnss_hal_test_cases.cpp
index c9f840e3..2d901f33 100644
--- a/gnss/1.1/vts/functional/gnss_hal_test_cases.cpp
+++ b/gnss/1.1/vts/functional/gnss_hal_test_cases.cpp
@@ -119,6 +119,11 @@ IGnssConfiguration::BlacklistedSource FindStrongFrequentNonGpsSource(
     struct ComparableBlacklistedSource {
         IGnssConfiguration::BlacklistedSource id;
 
+        ComparableBlacklistedSource() {
+            id.constellation = GnssConstellationType::UNKNOWN;
+            id.svid = 0;
+        }
+
         bool operator<(const ComparableBlacklistedSource& compare) const {
             return ((id.svid < compare.id.svid) || ((id.svid == compare.id.svid) &&
                                                     (id.constellation < compare.id.constellation)));
@@ -191,18 +196,21 @@ IGnssConfiguration::BlacklistedSource FindStrongFrequentNonGpsSource(
  * 3) Restart location, wait for 3 locations, ensuring they are valid, and checks corresponding
  * GnssStatus does not use those satellites.
  * 4a & b) Turns off location, and send in empty blacklist.
- * 5) Restart location, wait for 3 locations, ensuring they are valid, and checks corresponding
+ * 5a) Restart location, wait for 3 locations, ensuring they are valid, and checks corresponding
  * GnssStatus does re-use at least the previously strongest satellite
+ * 5b) Retry a few times, in case GNSS search strategy takes a while to reacquire even the
+ * formerly strongest satellite
  */
 TEST_F(GnssHalTest, BlacklistIndividualSatellites) {
     const int kLocationsToAwait = 3;
+    const int kRetriesToUnBlacklist = 10;
 
     StartAndCheckLocations(kLocationsToAwait);
 
     // Tolerate 1 less sv status to handle edge cases in reporting.
     EXPECT_GE((int)list_gnss_sv_status_.size() + 1, kLocationsToAwait);
-    ALOGD("Observed %d GnssSvStatus, while awaiting %d Locations", (int)list_gnss_sv_status_.size(),
-          kLocationsToAwait);
+    ALOGD("Observed %d GnssSvStatus, while awaiting %d Locations (%d received)",
+          (int)list_gnss_sv_status_.size(), kLocationsToAwait, location_called_count_);
 
     /*
      * Identify strongest SV seen at least kLocationsToAwait -1 times
@@ -237,13 +245,18 @@ TEST_F(GnssHalTest, BlacklistIndividualSatellites) {
     // retry and ensure satellite not used
     list_gnss_sv_status_.clear();
 
-    location_called_count_ = 0;
     StartAndCheckLocations(kLocationsToAwait);
 
+    // early exit if test is being run with insufficient signal
+    if (location_called_count_ == 0) {
+        ALOGE("0 Gnss locations received - ensure sufficient signal and retry");
+    }
+    ASSERT_TRUE(location_called_count_ > 0);
+
     // Tolerate 1 less sv status to handle edge cases in reporting.
     EXPECT_GE((int)list_gnss_sv_status_.size() + 1, kLocationsToAwait);
-    ALOGD("Observed %d GnssSvStatus, while awaiting %d Locations", (int)list_gnss_sv_status_.size(),
-          kLocationsToAwait);
+    ALOGD("Observed %d GnssSvStatus, while awaiting %d Locations (%d received)",
+          (int)list_gnss_sv_status_.size(), kLocationsToAwait, location_called_count_);
     for (const auto& gnss_sv_status : list_gnss_sv_status_) {
         for (uint32_t iSv = 0; iSv < gnss_sv_status.numSvs; iSv++) {
             const auto& gnss_sv = gnss_sv_status.gnssSvList[iSv];
@@ -260,28 +273,40 @@ TEST_F(GnssHalTest, BlacklistIndividualSatellites) {
     ASSERT_TRUE(result.isOk());
     EXPECT_TRUE(result);
 
-    StopAndClearLocations();
-    list_gnss_sv_status_.clear();
+    bool strongest_sv_is_reobserved = false;
+    // do several loops awaiting a few locations, allowing non-immediate reacquisition strategies
+    int unblacklist_loops_remaining = kRetriesToUnBlacklist;
+    while (!strongest_sv_is_reobserved && (unblacklist_loops_remaining-- > 0)) {
+        StopAndClearLocations();
+        list_gnss_sv_status_.clear();
 
-    StartAndCheckLocations(kLocationsToAwait);
+        StartAndCheckLocations(kLocationsToAwait);
 
-    // Tolerate 1 less sv status to handle edge cases in reporting.
-    EXPECT_GE((int)list_gnss_sv_status_.size() + 1, kLocationsToAwait);
-    ALOGD("Observed %d GnssSvStatus, while awaiting %d Locations", (int)list_gnss_sv_status_.size(),
-          kLocationsToAwait);
-
-    bool strongest_sv_is_reobserved = false;
-    for (const auto& gnss_sv_status : list_gnss_sv_status_) {
-        for (uint32_t iSv = 0; iSv < gnss_sv_status.numSvs; iSv++) {
-            const auto& gnss_sv = gnss_sv_status.gnssSvList[iSv];
-            if ((gnss_sv.svid == source_to_blacklist.svid) &&
-                (gnss_sv.constellation == source_to_blacklist.constellation) &&
-                (gnss_sv.svFlag & IGnssCallback::GnssSvFlags::USED_IN_FIX)) {
-                strongest_sv_is_reobserved = true;
-                break;
+        // early exit loop if test is being run with insufficient signal
+        if (location_called_count_ == 0) {
+            ALOGE("0 Gnss locations received - ensure sufficient signal and retry");
+        }
+        ASSERT_TRUE(location_called_count_ > 0);
+
+        // Tolerate 1 less sv status to handle edge cases in reporting.
+        EXPECT_GE((int)list_gnss_sv_status_.size() + 1, kLocationsToAwait);
+        ALOGD(
+            "Clear blacklist, observed %d GnssSvStatus, while awaiting %d Locations"
+            ", tries remaining %d",
+            (int)list_gnss_sv_status_.size(), kLocationsToAwait, unblacklist_loops_remaining);
+
+        for (const auto& gnss_sv_status : list_gnss_sv_status_) {
+            for (uint32_t iSv = 0; iSv < gnss_sv_status.numSvs; iSv++) {
+                const auto& gnss_sv = gnss_sv_status.gnssSvList[iSv];
+                if ((gnss_sv.svid == source_to_blacklist.svid) &&
+                    (gnss_sv.constellation == source_to_blacklist.constellation) &&
+                    (gnss_sv.svFlag & IGnssCallback::GnssSvFlags::USED_IN_FIX)) {
+                    strongest_sv_is_reobserved = true;
+                    break;
+                }
             }
+            if (strongest_sv_is_reobserved) break;
         }
-        if (strongest_sv_is_reobserved) break;
     }
     EXPECT_TRUE(strongest_sv_is_reobserved);
     StopAndClearLocations();
@@ -304,8 +329,8 @@ TEST_F(GnssHalTest, BlacklistConstellation) {
 
     // Tolerate 1 less sv status to handle edge cases in reporting.
     EXPECT_GE((int)list_gnss_sv_status_.size() + 1, kLocationsToAwait);
-    ALOGD("Observed %d GnssSvStatus, while awaiting %d Locations", (int)list_gnss_sv_status_.size(),
-          kLocationsToAwait);
+    ALOGD("Observed %d GnssSvStatus, while awaiting %d Locations (%d received)",
+          (int)list_gnss_sv_status_.size(), kLocationsToAwait, location_called_count_);
 
     // Find first non-GPS constellation to blacklist
     GnssConstellationType constellation_to_blacklist = GnssConstellationType::UNKNOWN;
diff --git a/graphics/composer/2.2/vts/functional/VtsHalGraphicsComposerV2_2TargetTest.cpp b/graphics/composer/2.2/vts/functional/VtsHalGraphicsComposerV2_2TargetTest.cpp
index 23bf5583..951e874e 100644
--- a/graphics/composer/2.2/vts/functional/VtsHalGraphicsComposerV2_2TargetTest.cpp
+++ b/graphics/composer/2.2/vts/functional/VtsHalGraphicsComposerV2_2TargetTest.cpp
@@ -18,11 +18,11 @@
 
 #include <VtsHalHidlTargetTestBase.h>
 #include <android-base/logging.h>
-#include <android/hardware/graphics/mapper/2.1/IMapper.h>
+#include <android/hardware/graphics/mapper/2.0/IMapper.h>
 #include <composer-vts/2.1/GraphicsComposerCallback.h>
 #include <composer-vts/2.1/TestCommandReader.h>
 #include <composer-vts/2.2/ComposerVts.h>
-#include <mapper-vts/2.1/MapperVts.h>
+#include <mapper-vts/2.0/MapperVts.h>
 
 namespace android {
 namespace hardware {
@@ -40,8 +40,8 @@ using android::hardware::graphics::common::V1_1::Dataspace;
 using android::hardware::graphics::common::V1_1::PixelFormat;
 using android::hardware::graphics::common::V1_1::RenderIntent;
 using android::hardware::graphics::composer::V2_2::IComposerClient;
-using android::hardware::graphics::mapper::V2_1::IMapper;
-using android::hardware::graphics::mapper::V2_1::vts::Gralloc;
+using android::hardware::graphics::mapper::V2_0::IMapper;
+using android::hardware::graphics::mapper::V2_0::vts::Gralloc;
 using GrallocError = android::hardware::graphics::mapper::V2_0::Error;
 
 // Test environment for graphics.composer
@@ -136,7 +136,7 @@ class GraphicsComposerHidlCommandTest : public GraphicsComposerHidlTest {
         info.width = 64;
         info.height = 64;
         info.layerCount = 1;
-        info.format = PixelFormat::RGBA_8888;
+        info.format = static_cast<common::V1_0::PixelFormat>(PixelFormat::RGBA_8888);
         info.usage =
             static_cast<uint64_t>(BufferUsage::CPU_WRITE_OFTEN | BufferUsage::CPU_READ_OFTEN);
 
@@ -280,7 +280,7 @@ TEST_F(GraphicsComposerHidlTest, setReadbackBuffer) {
     info.height = mComposerClient->getDisplayAttribute(mPrimaryDisplay, config,
                                                        IComposerClient::Attribute::HEIGHT);
     info.layerCount = 1;
-    info.format = pixelFormat;
+    info.format = static_cast<common::V1_0::PixelFormat>(pixelFormat);
     // BufferUsage::COMPOSER_OUTPUT is missing
     info.usage = static_cast<uint64_t>(BufferUsage::COMPOSER_OVERLAY | BufferUsage::CPU_READ_OFTEN);
 
diff --git a/neuralnetworks/1.0/vts/functional/GeneratedTestHarness.cpp b/neuralnetworks/1.0/vts/functional/GeneratedTestHarness.cpp
index 0682ab95..64495cf7 100644
--- a/neuralnetworks/1.0/vts/functional/GeneratedTestHarness.cpp
+++ b/neuralnetworks/1.0/vts/functional/GeneratedTestHarness.cpp
@@ -66,8 +66,8 @@ void copy_back(MixedTyped* dst, const std::vector<RequestArgument>& ra, char* sr
 // Top level driver for models and examples generated by test_generator.py
 // Test driver for those generated from ml/nn/runtime/test/spec
 void EvaluatePreparedModel(sp<IPreparedModel>& preparedModel, std::function<bool(int)> is_ignored,
-                           const std::vector<MixedTypedExampleType>& examples,
-                           float fpRange = 1e-5f) {
+                           const std::vector<MixedTypedExampleType>& examples, float fpAtol = 1e-5f,
+                           float fpRtol = 1e-5f) {
     const uint32_t INPUT = 0;
     const uint32_t OUTPUT = 1;
 
@@ -175,7 +175,7 @@ void EvaluatePreparedModel(sp<IPreparedModel>& preparedModel, std::function<bool
         MixedTyped filtered_test = filter(test, is_ignored);
 
         // We want "close-enough" results for float
-        compare(filtered_golden, filtered_test, fpRange);
+        compare(filtered_golden, filtered_test, fpAtol, fpRtol);
     }
 }
 
@@ -220,7 +220,8 @@ void Execute(const sp<V1_0::IDevice>& device, std::function<V1_0::Model(void)> c
     EXPECT_EQ(ErrorStatus::NONE, prepareReturnStatus);
     ASSERT_NE(nullptr, preparedModel.get());
 
-    EvaluatePreparedModel(preparedModel, is_ignored, examples);
+    float fpAtol = 1e-5f, fpRtol = 5.0f * 1.1920928955078125e-7f;
+    EvaluatePreparedModel(preparedModel, is_ignored, examples, fpAtol, fpRtol);
 }
 
 void Execute(const sp<V1_1::IDevice>& device, std::function<V1_1::Model(void)> create_model,
@@ -265,9 +266,13 @@ void Execute(const sp<V1_1::IDevice>& device, std::function<V1_1::Model(void)> c
     EXPECT_EQ(ErrorStatus::NONE, prepareReturnStatus);
     ASSERT_NE(nullptr, preparedModel.get());
 
-    // If in relaxed mode, set the error range to be 5ULP of FP16.
-    float fpRange = !model.relaxComputationFloat32toFloat16 ? 1e-5f : 5.0f * 0.0009765625f;
-    EvaluatePreparedModel(preparedModel, is_ignored, examples, fpRange);
+    // TODO: Adjust the error limit based on testing.
+    // If in relaxed mode, set the absolute tolerance to be 5ULP of FP16.
+    float fpAtol = !model.relaxComputationFloat32toFloat16 ? 1e-5f : 5.0f * 0.0009765625f;
+    // Set the relative tolerance to be 5ULP of the corresponding FP precision.
+    float fpRtol = !model.relaxComputationFloat32toFloat16 ? 5.0f * 1.1920928955078125e-7f
+                                                           : 5.0f * 0.0009765625f;
+    EvaluatePreparedModel(preparedModel, is_ignored, examples, fpAtol, fpRtol);
 }
 
 }  // namespace generated_tests
-- 
2.17.1

