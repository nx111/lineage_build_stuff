From a71e7379f2969166be38263abdb78bf836844128 Mon Sep 17 00:00:00 2001
From: Luca Stefani <luca.stefani.ge1@gmail.com>
Date: Tue, 5 Feb 2019 09:40:45 +0100
Subject: [PATCH 2/2] Squash of
 github/lineage-16.0(b1a18186b)..lineage-16.0-android-9.0.0_r31(564103425) (DO
 NOT SUBMIT)

Ajay Panicker (3):
 - Use 1/2 Device max volume when pairing with a new remote device
 - Synchronize DeviceDisconnect in VolumeManager
 - AVRCP: Don't use the queue for current metadata

Bill Yi (4):
 - Import translations. DO NOT MERGE
 - Import translations. DO NOT MERGE
 - Import translations. DO NOT MERGE
 - Import translations. DO NOT MERGE

Hansong Zhang (2):
 - Hearing Aid: Remove device from HiSyncIdMap when unbonded
 - DO NOT MERGE Hearing Aid: Use separate time for L/R in connect() and
   use whitelist

Luca Stefani (1):
 - Merge tag 'android-9.0.0_r31' into lineage-16.0-android-9.0.0_r31

Stanley Tng (2):
 - Add Feature Flag for Hearing Aid Profile
 - Change the feature flag for Hearing Aid behavior

Ted (1):
 - Clean up variables when closing BT

TreeHugger Robot (4):
 - Merge changes from topics "hearing-aid-white-list", "hearing-aid"
   into pi-dev
 - Merge "Clean up variables when closing BT" into pi-dev
 - Merge "Use 1/2 Device max volume when pairing with a new remote
   device" into pi-dev
 - Merge "Change the feature flag for Hearing Aid behavior" into pi-dev

android-build-team Robot (7):
 - Snap for 5044688 from 891ca8c8309a4b7e4c77ff84f6172f69e8102089 to
   pi-qpr2-release
 - Snap for 5073521 from 89c8bb4e0e68b157b0a1c2e6c307bcd921bf4be6 to
   pi-qpr2-release
 - Snap for 5087486 from 0a539702d5eb45a27534e2701c9369876330861e to
   pi-qpr2-release
 - Snap for 5115288 from a74e575627afed832354ec91d2205089444bcfac to
   pi-qpr2-release
 - Snap for 5130385 from f9b54878b194ca93104d686a1e91fccd2685a524 to
   pi-qpr2-release
 - Snap for 5135467 from eecff1d0d38f5df9375adce4b4d6ab340e99d2a1 to
   pi-qpr2-release
 - Merge cherrypicks of [5656146, 5653357, 5656373, 5656227, 5656421,
   5654207, 5654208, 5654209, 5654210, 5656164, 5656412, 5656413,
   5656355, 5656356, 5656357, 5655631, 5655632, 5656165, 5656166,
   5656167, 5656168, 5656376, 5656422, 5656147, 5656148, 5656149] into
   pi-qpr2-release

weichinweng (1):
 - Hearing Aid Service: Don't sent suppress noisy intent

Change-Id: I9a77274115366560c94544aeb6f3235a7382fa31

Change-Id: I8687cd1b7c30ea7e4c272480314dde6c5f07af60
---
 AndroidManifest.xml                           |  3 +-
 jni/com_android_bluetooth_hearing_aid.cpp     | 36 +++++++++++
 res/values-ca/strings.xml                     |  2 +-
 res/values-de/strings.xml                     |  2 +-
 res/values-iw/strings.xml                     |  2 +-
 res/values-mr/strings.xml                     |  2 +-
 res/values-my/strings.xml                     |  2 +-
 res/values-uz/strings.xml                     |  2 +-
 .../android/bluetooth/btservice/Config.java   |  8 +++
 .../hearingaid/HearingAidNativeInterface.java | 24 +++++++
 .../hearingaid/HearingAidService.java         | 63 +++++++++++++------
 .../hearingaid/HearingAidStateMachine.java    | 33 ++++++----
 .../newavrcp/AvrcpVolumeManager.java          | 19 +++---
 .../newavrcp/MediaPlayerWrapper.java          | 11 ----
 .../hearingaid/HearingAidServiceTest.java     | 40 ++++++++++--
 .../HearingAidStateMachineTest.java           |  6 +-
 .../newavrcp/MediaPlayerWrapperTest.java      | 22 -------
 17 files changed, 190 insertions(+), 87 deletions(-)

diff --git a/AndroidManifest.xml b/AndroidManifest.xml
index d46ede56..b24064f6 100644
--- a/AndroidManifest.xml
+++ b/AndroidManifest.xml
@@ -393,8 +393,7 @@
         </service>
         <service
             android:process="@string/process"
-            android:name = ".hearingaid.HearingAidService"
-            android:enabled="@bool/profile_supported_hearing_aid">
+            android:name = ".hearingaid.HearingAidService">
             <intent-filter>
                 <action android:name="android.bluetooth.IBluetoothHearingAid" />
             </intent-filter>
diff --git a/jni/com_android_bluetooth_hearing_aid.cpp b/jni/com_android_bluetooth_hearing_aid.cpp
index c965b1df..1602aacb 100644
--- a/jni/com_android_bluetooth_hearing_aid.cpp
+++ b/jni/com_android_bluetooth_hearing_aid.cpp
@@ -194,6 +194,40 @@ static jboolean disconnectHearingAidNative(JNIEnv* env, jobject object,
   return JNI_TRUE;
 }
 
+static jboolean addToWhiteListNative(JNIEnv* env, jobject object,
+                                     jbyteArray address) {
+  std::shared_lock<std::shared_timed_mutex> lock(interface_mutex);
+  if (!sHearingAidInterface) return JNI_FALSE;
+
+  jbyte* addr = env->GetByteArrayElements(address, nullptr);
+  if (!addr) {
+    jniThrowIOException(env, EINVAL);
+    return JNI_FALSE;
+  }
+
+  RawAddress* tmpraw = (RawAddress*)addr;
+  sHearingAidInterface->AddToWhiteList(*tmpraw);
+  env->ReleaseByteArrayElements(address, addr, 0);
+  return JNI_TRUE;
+}
+
+static jboolean removeFromWhiteListNative(JNIEnv* env, jobject object,
+                                          jbyteArray address) {
+  std::shared_lock<std::shared_timed_mutex> lock(interface_mutex);
+  if (!sHearingAidInterface) return JNI_FALSE;
+
+  jbyte* addr = env->GetByteArrayElements(address, nullptr);
+  if (!addr) {
+    jniThrowIOException(env, EINVAL);
+    return JNI_FALSE;
+  }
+
+  RawAddress* tmpraw = (RawAddress*)addr;
+  sHearingAidInterface->RemoveFromWhiteList(*tmpraw);
+  env->ReleaseByteArrayElements(address, addr, 0);
+  return JNI_TRUE;
+}
+
 static void setVolumeNative(JNIEnv* env, jclass clazz, jint volume) {
   if (!sHearingAidInterface) {
     LOG(ERROR) << __func__
@@ -209,6 +243,8 @@ static JNINativeMethod sMethods[] = {
     {"cleanupNative", "()V", (void*)cleanupNative},
     {"connectHearingAidNative", "([B)Z", (void*)connectHearingAidNative},
     {"disconnectHearingAidNative", "([B)Z", (void*)disconnectHearingAidNative},
+    {"addToWhiteListNative", "([B)Z", (void*)addToWhiteListNative},
+    {"removeFromWhiteListNative", "([B)Z", (void*)removeFromWhiteListNative},
     {"setVolumeNative", "(I)V", (void*)setVolumeNative},
 };
 
diff --git a/res/values-ca/strings.xml b/res/values-ca/strings.xml
index 0418fbca..f77534d8 100644
--- a/res/values-ca/strings.xml
+++ b/res/values-ca/strings.xml
@@ -45,7 +45,7 @@
     <string name="notification_sent" msgid="9218710861333027778">"Bluetooth: <xliff:g id="FILE">%1$s</xliff:g> enviat"</string>
     <string name="notification_sent_complete" msgid="302943281067557969">"100% complet"</string>
     <string name="notification_sent_fail" msgid="6696082233774569445">"Bluetooth: <xliff:g id="FILE">%1$s</xliff:g> no enviat"</string>
-    <string name="download_title" msgid="3353228219772092586">"Transferència del fitxer"</string>
+    <string name="download_title" msgid="3353228219772092586">"Transferència de fitxers"</string>
     <string name="download_line1" msgid="4926604799202134144">"De: \"<xliff:g id="SENDER">%1$s</xliff:g>\""</string>
     <string name="download_line2" msgid="5876973543019417712">"Fitxer: <xliff:g id="FILE">%1$s</xliff:g>"</string>
     <string name="download_line3" msgid="4384821622908676061">"Mida del fitxer: <xliff:g id="SIZE">%1$s</xliff:g>"</string>
diff --git a/res/values-de/strings.xml b/res/values-de/strings.xml
index 9107800c..7f36fce6 100644
--- a/res/values-de/strings.xml
+++ b/res/values-de/strings.xml
@@ -87,7 +87,7 @@
     <string name="bt_sm_2_1" product="nosdcard" msgid="352165168004521000">"Der USB-Speicher verfügt nicht über genügend Speicherplatz, um die Datei von \"<xliff:g id="SENDER">%1$s</xliff:g>\" zu speichern."</string>
     <string name="bt_sm_2_1" product="default" msgid="1989018443456803630">"Die SD-Karte verfügt über zu wenig Speicherplatz für die Datei von \"<xliff:g id="SENDER">%1$s</xliff:g>\"."</string>
     <string name="bt_sm_2_2" msgid="2965243265852680543">"Erforderlicher Speicherplatz: <xliff:g id="SIZE">%1$s</xliff:g>"</string>
-    <string name="ErrorTooManyRequests" msgid="8578277541472944529">"Es werden zurzeit zu viele Anfragen verarbeitet. Versuche es später erneut."</string>
+    <string name="ErrorTooManyRequests" msgid="8578277541472944529">"Es werden zurzeit zu viele Anfragen verarbeitet. Bitte versuche es später noch einmal."</string>
     <string name="status_pending" msgid="2503691772030877944">"Die Dateiübertragung wurde noch nicht gestartet."</string>
     <string name="status_running" msgid="6562808920311008696">"Dateiübertragung läuft."</string>
     <string name="status_success" msgid="239573225847565868">"Die Dateiübertragung wurde abgeschlossen."</string>
diff --git a/res/values-iw/strings.xml b/res/values-iw/strings.xml
index 8a6396a9..602b60e9 100644
--- a/res/values-iw/strings.xml
+++ b/res/values-iw/strings.xml
@@ -78,7 +78,7 @@
     <string name="not_exist_file_desc" msgid="4059531573790529229">"הקובץ לא קיים. \n"</string>
     <string name="enabling_progress_title" msgid="436157952334723406">"המתן..."</string>
     <string name="enabling_progress_content" msgid="4601542238119927904">"‏מפעיל Bluetooth…"</string>
-    <string name="bt_toast_1" msgid="972182708034353383">"הקובץ יתקבל. בדוק את ההתקדמות בחלונית \'הודעות\'."</string>
+    <string name="bt_toast_1" msgid="972182708034353383">"הקובץ יתקבל. יש לבדוק את ההתקדמות בלוח ההתראות."</string>
     <string name="bt_toast_2" msgid="8602553334099066582">"לא ניתן לקבל את הקובץ."</string>
     <string name="bt_toast_3" msgid="6707884165086862518">"הופסקה קבלת קובץ מאת \"<xliff:g id="SENDER">%1$s</xliff:g>\""</string>
     <string name="bt_toast_4" msgid="4678812947604395649">"שולח קובץ אל \"<xliff:g id="RECIPIENT">%1$s</xliff:g>\""</string>
diff --git a/res/values-mr/strings.xml b/res/values-mr/strings.xml
index ecc2a67b..d63d2308 100644
--- a/res/values-mr/strings.xml
+++ b/res/values-mr/strings.xml
@@ -124,7 +124,7 @@
     <string name="transfer_clear_dlg_title" msgid="2953444575556460386">"साफ करा"</string>
     <string name="bluetooth_map_settings_save" msgid="7635491847388074606">"सेव्ह करा"</string>
     <string name="bluetooth_map_settings_cancel" msgid="9205350798049865699">"रद्द करा"</string>
-    <string name="bluetooth_map_settings_intro" msgid="6482369468223987562">"तुम्ही ब्लूटूथद्वारे सामायिक करू इच्छित असलेली खाती निवडा. कनेक्ट करताना अद्याप तुम्ही खात्यांमधील कोणताही अॅक्सेस स्वीकारण्याची आवश्यकता आहे."</string>
+    <string name="bluetooth_map_settings_intro" msgid="6482369468223987562">"तुम्ही ब्लूटूथद्वारे शेअर करू इच्छित असलेली खाती निवडा. कनेक्ट करताना अद्याप तुम्ही खात्यांमधील कोणताही अॅक्सेस स्वीकारण्याची आवश्यकता आहे."</string>
     <string name="bluetooth_map_settings_count" msgid="4557473074937024833">"स्लॉट शिल्लक:"</string>
     <string name="bluetooth_map_settings_app_icon" msgid="7105805610929114707">"अॅप्लिकेशन आयकन"</string>
     <string name="bluetooth_map_settings_title" msgid="7420332483392851321">"ब्लूटूथ मेसेज सामायिकरण सेटिंग्ज"</string>
diff --git a/res/values-my/strings.xml b/res/values-my/strings.xml
index 4aac349c..cfdea66e 100644
--- a/res/values-my/strings.xml
+++ b/res/values-my/strings.xml
@@ -96,7 +96,7 @@
     <string name="status_canceled" msgid="6664490318773098285">"အသုံးပြုသူမှ လွှဲပြောင်းခြင်းကို ဖယ်ဖျက်ရန်"</string>
     <string name="status_file_error" msgid="3671917770630165299">"သိုလှောင်မှု အချက်"</string>
     <string name="status_no_sd_card" product="nosdcard" msgid="1112125377088421469">"USBသိုလှောင်ရာမရှိပါ"</string>
-    <string name="status_no_sd_card" product="default" msgid="5760944071743325592">"SDကဒ်မရှိပါ၊ လွှဲပြောင်းထားသော ဖိုင်များကို သိမ်းဆည်းရန် SDကဒ်ထည့်ပါ"</string>
+    <string name="status_no_sd_card" product="default" msgid="5760944071743325592">"SDကဒ်မရှိပါ၊ လွှဲပြောင်းထားသော ဖိုင်များကို သိမ်းရန် SDကဒ်ထည့်ပါ"</string>
     <string name="status_connection_error" msgid="947681831523219891">"ချိတ်ဆက်ခြင်း မအောင်မြင်ပါ"</string>
     <string name="status_protocol_error" msgid="3245444473429269539">"တောင်းခံခြင်းကို မှန်ကန်စွာကိုင်တွယ်မရပါ"</string>
     <string name="status_unknown_error" msgid="8156660554237824912">"အမည်မသိသော မှားယွင်းမှု"</string>
diff --git a/res/values-uz/strings.xml b/res/values-uz/strings.xml
index 855cab38..88535c5a 100644
--- a/res/values-uz/strings.xml
+++ b/res/values-uz/strings.xml
@@ -52,7 +52,7 @@
     <string name="download_line4" msgid="8535996869722666525"></string>
     <string name="download_line5" msgid="3069560415845295386">"Fayl qabul qilinmoqda…"</string>
     <string name="download_cancel" msgid="9177305996747500768">"To‘xtatish"</string>
-    <string name="download_ok" msgid="5000360731674466039">"Yashirish"</string>
+    <string name="download_ok" msgid="5000360731674466039">"Berkitish"</string>
     <string name="incoming_line1" msgid="2127419875681087545">"Kimdan"</string>
     <string name="incoming_line2" msgid="3348994249285315873">"Fayl nomi"</string>
     <string name="incoming_line3" msgid="7954237069667474024">"Hajmi"</string>
diff --git a/src/com/android/bluetooth/btservice/Config.java b/src/com/android/bluetooth/btservice/Config.java
index ae65863f..8a9c0a1f 100644
--- a/src/com/android/bluetooth/btservice/Config.java
+++ b/src/com/android/bluetooth/btservice/Config.java
@@ -21,6 +21,7 @@ import android.content.ContentResolver;
 import android.content.Context;
 import android.content.res.Resources;
 import android.provider.Settings;
+import android.util.FeatureFlagUtils;
 import android.util.Log;
 
 import com.android.bluetooth.R;
@@ -117,6 +118,13 @@ public class Config {
         ArrayList<Class> profiles = new ArrayList<>(PROFILE_SERVICES_AND_FLAGS.length);
         for (ProfileConfig config : PROFILE_SERVICES_AND_FLAGS) {
             boolean supported = resources.getBoolean(config.mSupported);
+
+            if (!supported && (config.mClass == HearingAidService.class) && FeatureFlagUtils
+                                .isEnabled(ctx, FeatureFlagUtils.HEARING_AID_SETTINGS)) {
+                Log.v(TAG, "Feature Flag enables support for HearingAidService");
+                supported = true;
+            }
+
             if (supported && !isProfileDisabled(ctx, config.mMask)) {
                 Log.v(TAG, "Adding " + config.mClass.getSimpleName());
                 profiles.add(config.mClass);
diff --git a/src/com/android/bluetooth/hearingaid/HearingAidNativeInterface.java b/src/com/android/bluetooth/hearingaid/HearingAidNativeInterface.java
index 26036595..e735a881 100644
--- a/src/com/android/bluetooth/hearingaid/HearingAidNativeInterface.java
+++ b/src/com/android/bluetooth/hearingaid/HearingAidNativeInterface.java
@@ -104,6 +104,28 @@ public class HearingAidNativeInterface {
         return disconnectHearingAidNative(getByteAddress(device));
     }
 
+    /**
+     * Add a hearing aid device to white list.
+     *
+     * @param device the remote device
+     * @return true on success, otherwise false.
+     */
+    @VisibleForTesting (otherwise = VisibleForTesting.PACKAGE_PRIVATE)
+    public boolean addToWhiteList(BluetoothDevice device) {
+        return addToWhiteListNative(getByteAddress(device));
+    }
+
+    /**
+     * Remove a hearing aid device from white list.
+     *
+     * @param device the remote device
+     * @return true on success, otherwise false.
+     */
+    @VisibleForTesting (otherwise = VisibleForTesting.PACKAGE_PRIVATE)
+    public boolean removeFromWhiteList(BluetoothDevice device) {
+        return removeFromWhiteListNative(getByteAddress(device));
+    }
+
     /**
      * Sets the HearingAid volume
      * @param volume
@@ -168,5 +190,7 @@ public class HearingAidNativeInterface {
     private native void cleanupNative();
     private native boolean connectHearingAidNative(byte[] address);
     private native boolean disconnectHearingAidNative(byte[] address);
+    private native boolean addToWhiteListNative(byte[] address);
+    private native boolean removeFromWhiteListNative(byte[] address);
     private native void setVolumeNative(int volume);
 }
diff --git a/src/com/android/bluetooth/hearingaid/HearingAidService.java b/src/com/android/bluetooth/hearingaid/HearingAidService.java
index bbc61baf..b30eb62a 100644
--- a/src/com/android/bluetooth/hearingaid/HearingAidService.java
+++ b/src/com/android/bluetooth/hearingaid/HearingAidService.java
@@ -56,6 +56,10 @@ public class HearingAidService extends ProfileService {
     // Upper limit of all HearingAid devices: Bonded or Connected
     private static final int MAX_HEARING_AID_STATE_MACHINES = 10;
     private static HearingAidService sHearingAidService;
+    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+    static int sConnectTimeoutForEachSideMs = 8000;
+    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+    static int sCheckWhitelistTimeoutMs = 16000;
 
     private AdapterService mAdapterService;
     private HandlerThread mStateMachinesThread;
@@ -243,14 +247,6 @@ public class HearingAidService extends ProfileService {
             }
         }
 
-        synchronized (mStateMachines) {
-            HearingAidStateMachine smConnect = getOrCreateStateMachine(device);
-            if (smConnect == null) {
-                Log.e(TAG, "Cannot connect to " + device + " : no state machine");
-            }
-            smConnect.sendMessage(HearingAidStateMachine.CONNECT);
-        }
-
         for (BluetoothDevice storedDevice : mDeviceHiSyncIdMap.keySet()) {
             if (device.equals(storedDevice)) {
                 continue;
@@ -263,14 +259,27 @@ public class HearingAidService extends ProfileService {
                         Log.e(TAG, "Ignored connect request for " + device + " : no state machine");
                         continue;
                     }
-                    sm.sendMessage(HearingAidStateMachine.CONNECT);
-                }
-                if (hiSyncId == BluetoothHearingAid.HI_SYNC_ID_INVALID
-                        && !device.equals(storedDevice)) {
-                    break;
+                    sm.sendMessage(HearingAidStateMachine.CONNECT,
+                            sConnectTimeoutForEachSideMs);
+                    sm.sendMessageDelayed(HearingAidStateMachine.CHECK_WHITELIST_CONNECTION,
+                            sCheckWhitelistTimeoutMs);
                 }
+                break;
             }
         }
+
+        synchronized (mStateMachines) {
+            HearingAidStateMachine smConnect = getOrCreateStateMachine(device);
+            if (smConnect == null) {
+                Log.e(TAG, "Cannot connect to " + device + " : no state machine");
+            } else {
+                smConnect.sendMessage(HearingAidStateMachine.CONNECT,
+                        sConnectTimeoutForEachSideMs * 2);
+                smConnect.sendMessageDelayed(HearingAidStateMachine.CHECK_WHITELIST_CONNECTION,
+                        sCheckWhitelistTimeoutMs);
+            }
+        }
+
         return true;
     }
 
@@ -405,6 +414,16 @@ public class HearingAidService extends ProfileService {
         }
     }
 
+    /**
+     * Get the HiSyncIdMap for testing
+     *
+     * @return mDeviceHiSyncIdMap
+     */
+    @VisibleForTesting
+    Map<BluetoothDevice, Long> getHiSyncIdMap() {
+        return mDeviceHiSyncIdMap;
+    }
+
     int getConnectionState(BluetoothDevice device) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
         synchronized (mStateMachines) {
@@ -608,19 +627,24 @@ public class HearingAidService extends ProfileService {
             if (DBG) {
                 Log.d(TAG, "Set Hearing Aid audio to disconnected");
             }
-            mAudioManager.setHearingAidDeviceConnectionState(mPreviousAudioDevice,
-                    BluetoothProfile.STATE_DISCONNECTED);
+            boolean suppressNoisyIntent =
+                    (getConnectionState(mPreviousAudioDevice) == BluetoothProfile.STATE_CONNECTED);
+            mAudioManager.setBluetoothHearingAidDeviceConnectionState(
+                    mPreviousAudioDevice, BluetoothProfile.STATE_DISCONNECTED,
+                    suppressNoisyIntent, 0);
             mPreviousAudioDevice = null;
         } else {
             if (DBG) {
                 Log.d(TAG, "Set Hearing Aid audio to connected");
             }
             if (mPreviousAudioDevice != null) {
-                mAudioManager.setHearingAidDeviceConnectionState(mPreviousAudioDevice,
-                        BluetoothProfile.STATE_DISCONNECTED);
+                mAudioManager.setBluetoothHearingAidDeviceConnectionState(
+                        mPreviousAudioDevice, BluetoothProfile.STATE_DISCONNECTED,
+                        true, 0);
             }
-            mAudioManager.setHearingAidDeviceConnectionState(device,
-                    BluetoothProfile.STATE_CONNECTED);
+            mAudioManager.setBluetoothHearingAidDeviceConnectionState(
+                    device, BluetoothProfile.STATE_CONNECTED,
+                    true, 0);
             mPreviousAudioDevice = device;
         }
     }
@@ -658,6 +682,7 @@ public class HearingAidService extends ProfileService {
         if (bondState != BluetoothDevice.BOND_NONE) {
             return;
         }
+        mDeviceHiSyncIdMap.remove(device);
         synchronized (mStateMachines) {
             HearingAidStateMachine sm = mStateMachines.get(device);
             if (sm == null) {
diff --git a/src/com/android/bluetooth/hearingaid/HearingAidStateMachine.java b/src/com/android/bluetooth/hearingaid/HearingAidStateMachine.java
index d02e1021..3e0d617a 100644
--- a/src/com/android/bluetooth/hearingaid/HearingAidStateMachine.java
+++ b/src/com/android/bluetooth/hearingaid/HearingAidStateMachine.java
@@ -69,13 +69,15 @@ final class HearingAidStateMachine extends StateMachine {
 
     static final int CONNECT = 1;
     static final int DISCONNECT = 2;
+    static final int CHECK_WHITELIST_CONNECTION = 3;
     @VisibleForTesting
     static final int STACK_EVENT = 101;
     private static final int CONNECT_TIMEOUT = 201;
 
-    // NOTE: the value is not "final" - it is modified in the unit tests
-    @VisibleForTesting
-    static int sConnectTimeoutMs = 30000;        // 30s
+    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+    static int sConnectTimeoutMs = 16000;
+    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)
+    static int sDisconnectTimeoutMs = 16000;
 
     private Disconnected mDisconnected;
     private Connecting mConnecting;
@@ -172,6 +174,12 @@ final class HearingAidStateMachine extends StateMachine {
                 case DISCONNECT:
                     Log.w(TAG, "Disconnected: DISCONNECT ignored: " + mDevice);
                     break;
+                case CHECK_WHITELIST_CONNECTION:
+                    if (mService.getConnectedDevices().isEmpty()) {
+                        log("No device connected, remove this device from white list");
+                        mNativeInterface.removeFromWhiteList(mDevice);
+                    }
+                    break;
                 case STACK_EVENT:
                     HearingAidStackEvent event = (HearingAidStackEvent) message.obj;
                     if (DBG) {
@@ -238,7 +246,9 @@ final class HearingAidStateMachine extends StateMachine {
         public void enter() {
             Log.i(TAG, "Enter Connecting(" + mDevice + "): "
                     + messageWhatToString(getCurrentMessage().what));
-            sendMessageDelayed(CONNECT_TIMEOUT, sConnectTimeoutMs);
+            int timeout = getCurrentMessage().arg1 != 0
+                    ? getCurrentMessage().arg1 : sConnectTimeoutMs;
+            sendMessageDelayed(CONNECT_TIMEOUT, timeout);
             mConnectionState = BluetoothProfile.STATE_CONNECTING;
             broadcastConnectionState(mConnectionState, mLastConnectionState);
         }
@@ -261,14 +271,13 @@ final class HearingAidStateMachine extends StateMachine {
                     deferMessage(message);
                     break;
                 case CONNECT_TIMEOUT:
-                    Log.w(TAG, "Connecting connection timeout: " + mDevice);
+                    Log.w(TAG, "Connecting connection timeout: " + mDevice + ". Try whitelist");
                     mNativeInterface.disconnectHearingAid(mDevice);
-                    HearingAidStackEvent disconnectEvent =
-                            new HearingAidStackEvent(
-                                    HearingAidStackEvent.EVENT_TYPE_CONNECTION_STATE_CHANGED);
-                    disconnectEvent.device = mDevice;
-                    disconnectEvent.valueInt1 = HearingAidStackEvent.CONNECTION_STATE_DISCONNECTED;
-                    sendMessage(STACK_EVENT, disconnectEvent);
+                    mNativeInterface.addToWhiteList(mDevice);
+                    transitionTo(mDisconnected);
+                    break;
+                case CHECK_WHITELIST_CONNECTION:
+                    deferMessage(message);
                     break;
                 case DISCONNECT:
                     log("Connecting: connection canceled to " + mDevice);
@@ -325,7 +334,7 @@ final class HearingAidStateMachine extends StateMachine {
         public void enter() {
             Log.i(TAG, "Enter Disconnecting(" + mDevice + "): "
                     + messageWhatToString(getCurrentMessage().what));
-            sendMessageDelayed(CONNECT_TIMEOUT, sConnectTimeoutMs);
+            sendMessageDelayed(CONNECT_TIMEOUT, sDisconnectTimeoutMs);
             mConnectionState = BluetoothProfile.STATE_DISCONNECTING;
             broadcastConnectionState(mConnectionState, mLastConnectionState);
         }
diff --git a/src/com/android/bluetooth/newavrcp/AvrcpVolumeManager.java b/src/com/android/bluetooth/newavrcp/AvrcpVolumeManager.java
index 4b87fac6..2e2ce420 100644
--- a/src/com/android/bluetooth/newavrcp/AvrcpVolumeManager.java
+++ b/src/com/android/bluetooth/newavrcp/AvrcpVolumeManager.java
@@ -36,11 +36,12 @@ class AvrcpVolumeManager extends AudioDeviceCallback {
     public static final boolean DEBUG = true;
 
     // All volumes are stored at system volume values, not AVRCP values
-    public static final String VOLUME_MAP = "bluetooth_volume_map";
-    public static final String VOLUME_BLACKLIST = "absolute_volume_blacklist";
-    public static final int AVRCP_MAX_VOL = 127;
-    public static int sDeviceMaxVolume = 0;
-    public static final int STREAM_MUSIC = AudioManager.STREAM_MUSIC;
+    private static final String VOLUME_MAP = "bluetooth_volume_map";
+    private static final String VOLUME_BLACKLIST = "absolute_volume_blacklist";
+    private static final int AVRCP_MAX_VOL = 127;
+    private static final int STREAM_MUSIC = AudioManager.STREAM_MUSIC;
+    private static int sDeviceMaxVolume = 0;
+    private static int sNewDeviceVolume = 0;
 
     Context mContext;
     AudioManager mAudioManager;
@@ -72,10 +73,9 @@ class AvrcpVolumeManager extends AudioDeviceCallback {
         mAudioManager.avrcpSupportsAbsoluteVolume(device.getAddress(), mDeviceMap.get(device));
 
         // Get the current system volume and try to get the preference volume
-        int currVolume = mAudioManager.getStreamVolume(STREAM_MUSIC);
-        int savedVolume = getVolume(device, currVolume);
+        int savedVolume = getVolume(device, sNewDeviceVolume);
 
-        d("switchVolumeDevice: currVolume=" + currVolume + " savedVolume=" + savedVolume);
+        d("switchVolumeDevice: savedVolume=" + savedVolume);
 
         // If absolute volume for the device is supported, set the volume for the device
         if (mDeviceMap.get(device)) {
@@ -91,6 +91,7 @@ class AvrcpVolumeManager extends AudioDeviceCallback {
         mAudioManager = audioManager;
         mNativeInterface = nativeInterface;
         sDeviceMaxVolume = mAudioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC);
+        sNewDeviceVolume = sDeviceMaxVolume / 2;
 
         mAudioManager.registerAudioDeviceCallback(this, null);
 
@@ -194,7 +195,7 @@ class AvrcpVolumeManager extends AudioDeviceCallback {
         mCurrentDevice = device;
     }
 
-    void deviceDisconnected(@NonNull BluetoothDevice device) {
+    synchronized void deviceDisconnected(@NonNull BluetoothDevice device) {
         d("deviceDisconnected: device=" + device);
         mDeviceMap.remove(device);
     }
diff --git a/src/com/android/bluetooth/newavrcp/MediaPlayerWrapper.java b/src/com/android/bluetooth/newavrcp/MediaPlayerWrapper.java
index d27054d4..256e7714 100644
--- a/src/com/android/bluetooth/newavrcp/MediaPlayerWrapper.java
+++ b/src/com/android/bluetooth/newavrcp/MediaPlayerWrapper.java
@@ -53,7 +53,6 @@ class MediaPlayerWrapper {
     private final Object mCallbackLock = new Object();
     private Callback mRegisteredCallback = null;
 
-
     protected MediaPlayerWrapper() {
         mCurrentData = new MediaData(null, null, null);
     }
@@ -122,16 +121,6 @@ class MediaPlayerWrapper {
     }
 
     Metadata getCurrentMetadata() {
-        // Try to use the now playing list if the information exists.
-        if (getActiveQueueID() != -1) {
-            for (Metadata data : getCurrentQueue()) {
-                if (data.mediaId.equals(Util.NOW_PLAYING_PREFIX + getActiveQueueID())) {
-                    d("getCurrentMetadata: Using playlist data: " + data.toString());
-                    return data.clone();
-                }
-            }
-        }
-
         return Util.toMetadata(getMetadata());
     }
 
diff --git a/tests/unit/src/com/android/bluetooth/hearingaid/HearingAidServiceTest.java b/tests/unit/src/com/android/bluetooth/hearingaid/HearingAidServiceTest.java
index b0a4755f..bda2c151 100644
--- a/tests/unit/src/com/android/bluetooth/hearingaid/HearingAidServiceTest.java
+++ b/tests/unit/src/com/android/bluetooth/hearingaid/HearingAidServiceTest.java
@@ -118,6 +118,8 @@ public class HearingAidServiceTest {
                 .getBondState(any(BluetoothDevice.class));
         doReturn(new ParcelUuid[]{BluetoothUuid.HearingAid}).when(mAdapterService)
                 .getRemoteUuids(any(BluetoothDevice.class));
+        HearingAidService.sConnectTimeoutForEachSideMs = 1000;
+        HearingAidService.sCheckWhitelistTimeoutMs = 2000;
     }
 
     @After
@@ -343,7 +345,8 @@ public class HearingAidServiceTest {
                 mService.getConnectionState(mLeftDevice));
 
         // Verify the connection state broadcast, and that we are in Disconnected state
-        verifyConnectionStateIntent(HearingAidStateMachine.sConnectTimeoutMs * 2, mLeftDevice,
+        verifyConnectionStateIntent(HearingAidService.sConnectTimeoutForEachSideMs * 3,
+                mLeftDevice,
                 BluetoothProfile.STATE_DISCONNECTED,
                 BluetoothProfile.STATE_CONNECTING);
         Assert.assertEquals(BluetoothProfile.STATE_DISCONNECTED,
@@ -498,8 +501,9 @@ public class HearingAidServiceTest {
         Assert.assertTrue(mService.getConnectedDevices().contains(mRightDevice));
 
         // Verify the audio is routed to Hearing Aid Profile
-        verify(mAudioManager).setHearingAidDeviceConnectionState(any(BluetoothDevice.class),
-                eq(BluetoothProfile.STATE_CONNECTED));
+        verify(mAudioManager).setBluetoothHearingAidDeviceConnectionState(
+                any(BluetoothDevice.class), eq(BluetoothProfile.STATE_CONNECTED),
+                eq(true), eq(0));
 
         // Send a disconnect request
         Assert.assertTrue("Disconnect failed", mService.disconnect(mLeftDevice));
@@ -546,8 +550,9 @@ public class HearingAidServiceTest {
         Assert.assertFalse(mService.getConnectedDevices().contains(mRightDevice));
 
         // Verify the audio is not routed to Hearing Aid Profile
-        verify(mAudioManager).setHearingAidDeviceConnectionState(any(BluetoothDevice.class),
-                eq(BluetoothProfile.STATE_DISCONNECTED));
+        verify(mAudioManager).setBluetoothHearingAidDeviceConnectionState(
+                any(BluetoothDevice.class), eq(BluetoothProfile.STATE_DISCONNECTED),
+                eq(false), eq(0));
     }
 
     /**
@@ -916,6 +921,31 @@ public class HearingAidServiceTest {
                 mService.getConnectionState(mLeftDevice));
     }
 
+    /**
+     * Test that the service can update HiSyncId from native message
+     */
+    @Test
+    public void getHiSyncIdFromNative_addToMap() {
+        getHiSyncIdFromNative();
+        Assert.assertTrue("hiSyncIdMap should contain mLeftDevice",
+                mService.getHiSyncIdMap().containsKey(mLeftDevice));
+        Assert.assertTrue("hiSyncIdMap should contain mRightDevice",
+                mService.getHiSyncIdMap().containsKey(mRightDevice));
+        Assert.assertTrue("hiSyncIdMap should contain mSingleDevice",
+                mService.getHiSyncIdMap().containsKey(mSingleDevice));
+    }
+
+    /**
+     * Test that the service removes the device from HiSyncIdMap when it's unbonded
+     */
+    @Test
+    public void deviceUnbonded_removeHiSyncId() {
+        getHiSyncIdFromNative();
+        mService.bondStateChanged(mLeftDevice, BluetoothDevice.BOND_NONE);
+        Assert.assertFalse("hiSyncIdMap shouldn't contain mLeftDevice",
+                mService.getHiSyncIdMap().containsKey(mLeftDevice));
+    }
+
     private void connectDevice(BluetoothDevice device) {
         HearingAidStackEvent connCompletedEvent;
 
diff --git a/tests/unit/src/com/android/bluetooth/hearingaid/HearingAidStateMachineTest.java b/tests/unit/src/com/android/bluetooth/hearingaid/HearingAidStateMachineTest.java
index e6d3ba2a..474861e2 100644
--- a/tests/unit/src/com/android/bluetooth/hearingaid/HearingAidStateMachineTest.java
+++ b/tests/unit/src/com/android/bluetooth/hearingaid/HearingAidStateMachineTest.java
@@ -77,7 +77,10 @@ public class HearingAidStateMachineTest {
         mHearingAidStateMachine = new HearingAidStateMachine(mTestDevice, mHearingAidService,
                 mHearingAidNativeInterface, mHandlerThread.getLooper());
         // Override the timeout value to speed up the test
-        mHearingAidStateMachine.sConnectTimeoutMs = 1000;     // 1s
+        mHearingAidStateMachine.sConnectTimeoutMs = 1000;
+        mHearingAidStateMachine.sDisconnectTimeoutMs = 1000;
+        HearingAidService.sConnectTimeoutForEachSideMs = 1000;
+        HearingAidService.sCheckWhitelistTimeoutMs = 2000;
         mHearingAidStateMachine.start();
     }
 
@@ -209,6 +212,7 @@ public class HearingAidStateMachineTest {
         // Check that we are in Disconnected state
         Assert.assertThat(mHearingAidStateMachine.getCurrentState(),
                 IsInstanceOf.instanceOf(HearingAidStateMachine.Disconnected.class));
+        verify(mHearingAidNativeInterface).addToWhiteList(eq(mTestDevice));
     }
 
     /**
diff --git a/tests/unit/src/com/android/bluetooth/newavrcp/MediaPlayerWrapperTest.java b/tests/unit/src/com/android/bluetooth/newavrcp/MediaPlayerWrapperTest.java
index cdae46b4..85ad1476 100644
--- a/tests/unit/src/com/android/bluetooth/newavrcp/MediaPlayerWrapperTest.java
+++ b/tests/unit/src/com/android/bluetooth/newavrcp/MediaPlayerWrapperTest.java
@@ -311,28 +311,6 @@ public class MediaPlayerWrapperTest {
         verify(mFailHandler, never()).onTerribleFailure(any(), any(), anyBoolean());
     }
 
-    /*
-     * This test checks whether getCurrentMetadata() returns the corresponding item from
-     * the now playing list instead of the current metadata if there is a match.
-     */
-    @Test
-    public void testCurrentSongFromQueue() {
-        // Create the wrapper object and register the looper with the timeout handler
-        TestLooperManager looperManager = new TestLooperManager(mThread.getLooper());
-
-        mTestState.setActiveQueueItemId(101);
-        doReturn(mTestState.build()).when(mMockController).getPlaybackState();
-
-        MediaPlayerWrapper wrapper =
-                MediaPlayerWrapper.wrap(mMockController, mThread.getLooper());
-        wrapper.registerCallback(mTestCbs);
-
-        // The current metadata doesn't contain track number info so check that
-        // field to see if the correct data was used.
-        Assert.assertEquals(wrapper.getCurrentMetadata().trackNum, "2");
-        Assert.assertEquals(wrapper.getCurrentMetadata().numTracks, "3");
-    }
-
     @Test
     public void testNullMetadata() {
         // Create the wrapper object and register the looper with the timeout handler
-- 
2.17.1

