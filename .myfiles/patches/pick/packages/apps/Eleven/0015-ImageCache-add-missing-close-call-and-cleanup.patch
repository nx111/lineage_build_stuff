From 5d6f6f72401db6a26bf16bbc3263ea14e8bc6682 Mon Sep 17 00:00:00 2001
From: Alexander Martinz <amartinz@shiftphones.com>
Date: Tue, 26 Feb 2019 17:31:45 +0100
Subject: [PATCH 15/20] ImageCache: add missing close call and cleanup

Change-Id: Id75ae226307c1045d2533e4f61443aee3d076c3e
Signed-off-by: Alexander Martinz <amartinz@shiftphones.com>
---
 .../lineageos/eleven/cache/ImageCache.java    | 84 ++++++-------------
 src/org/lineageos/eleven/utils/IoUtils.java   | 36 ++++++++
 2 files changed, 63 insertions(+), 57 deletions(-)
 create mode 100644 src/org/lineageos/eleven/utils/IoUtils.java

diff --git a/src/org/lineageos/eleven/cache/ImageCache.java b/src/org/lineageos/eleven/cache/ImageCache.java
index 522a021..83d2410 100644
--- a/src/org/lineageos/eleven/cache/ImageCache.java
+++ b/src/org/lineageos/eleven/cache/ImageCache.java
@@ -13,7 +13,6 @@
 
 package org.lineageos.eleven.cache;
 
-import android.annotation.SuppressLint;
 import android.app.Activity;
 import android.app.ActivityManager;
 import android.app.Fragment;
@@ -35,6 +34,7 @@ import android.util.Log;
 
 import org.lineageos.eleven.cache.disklrucache.DiskLruCache;
 import org.lineageos.eleven.utils.ElevenUtils;
+import org.lineageos.eleven.utils.IoUtils;
 
 import java.io.File;
 import java.io.FileDescriptor;
@@ -50,7 +50,6 @@ import java.util.HashSet;
  * This class holds the memory and disk bitmap caches.
  */
 public final class ImageCache {
-
     private static final String TAG = ImageCache.class.getSimpleName();
 
     /**
@@ -184,7 +183,6 @@ public final class ImageCache {
      *
      * @param context The {@link Context} to use
      */
-    @SuppressLint("NewApi")
     public void initLruCache(final Context context) {
         final ActivityManager activityManager = (ActivityManager)context
                 .getSystemService(Context.ACTIVITY_SERVICE);
@@ -195,9 +193,6 @@ public final class ImageCache {
         // Release some memory as needed
         context.registerComponentCallbacks(new ComponentCallbacks2() {
 
-            /**
-             * {@inheritDoc}
-             */
             @Override
             public void onTrimMemory(final int level) {
                 if (level >= TRIM_MEMORY_MODERATE) {
@@ -207,17 +202,11 @@ public final class ImageCache {
                 }
             }
 
-            /**
-             * {@inheritDoc}
-             */
             @Override
             public void onLowMemory() {
                 // Nothing to do
             }
 
-            /**
-             * {@inheritDoc}
-             */
             @Override
             public void onConfigurationChanged(final Configuration newConfig) {
                 // Nothing to do
@@ -234,7 +223,7 @@ public final class ImageCache {
      * @return An existing retained ImageCache object or a new one if one did
      *         not exist
      */
-    public static final ImageCache findOrCreateCache(final Activity activity) {
+    public static ImageCache findOrCreateCache(final Activity activity) {
 
         // Search for, or create an instance of the non-UI RetainFragment
         final RetainFragment retainFragment = findOrCreateRetainFragment(
@@ -259,7 +248,7 @@ public final class ImageCache {
      * @return The existing instance of the {@link Fragment} or the new instance
      *         if just created
      */
-    public static final RetainFragment findOrCreateRetainFragment(final FragmentManager fm) {
+    public static RetainFragment findOrCreateRetainFragment(final FragmentManager fm) {
         // Check to see if we have retained the worker fragment
         RetainFragment retainFragment = (RetainFragment)fm.findFragmentByTag(TAG);
 
@@ -317,23 +306,14 @@ public final class ImageCache {
                     }
                 }
             } catch (final IOException e) {
-                Log.e(TAG, "addBitmapToCache - " + e);
+                Log.e(TAG, "addBitmapToCache", e);
             } catch (final IllegalStateException e) {
                 // if the user clears the cache while we have an async task going we could try
                 // writing to the disk cache while it isn't ready. Catching here will silently
                 // fail instead
-                Log.e(TAG, "addBitmapToCache - " + e);
+                Log.e(TAG, "addBitmapToCache", e);
             } finally {
-                try {
-                    if (out != null) {
-                        out.close();
-                        out = null;
-                    }
-                } catch (final IOException e) {
-                    Log.e(TAG, "addBitmapToCache - " + e);
-                } catch (final IllegalStateException e) {
-                    Log.e(TAG, "addBitmapToCache - " + e);
-                }
+                IoUtils.closeQuietly(out);
             }
         }
     }
@@ -417,14 +397,9 @@ public final class ImageCache {
                     }
                 }
             } catch (final IOException e) {
-                Log.e(TAG, "getBitmapFromDiskCache - " + e);
+                Log.e(TAG, "getBitmapFromDiskCache", e);
             } finally {
-                try {
-                    if (inputStream != null) {
-                        inputStream.close();
-                    }
-                } catch (final IOException e) {
-                }
+                IoUtils.closeQuietly(inputStream);
             }
         }
         return null;
@@ -489,10 +464,11 @@ public final class ImageCache {
         }
         Bitmap artwork = null;
         waitUntilUnpaused();
+
+        ParcelFileDescriptor parcelFileDescriptor = null;
         try {
             final Uri uri = ContentUris.withAppendedId(mArtworkUri, albumId);
-            final ParcelFileDescriptor parcelFileDescriptor = context.getContentResolver()
-                    .openFileDescriptor(uri, "r");
+            parcelFileDescriptor = context.getContentResolver().openFileDescriptor(uri, "r");
             if (parcelFileDescriptor != null) {
                 final FileDescriptor fileDescriptor = parcelFileDescriptor.getFileDescriptor();
                 artwork = BitmapFactory.decodeFileDescriptor(fileDescriptor);
@@ -504,6 +480,8 @@ public final class ImageCache {
         } catch (final OutOfMemoryError evict) {
             // Log.e(TAG, "OutOfMemoryError - getArtworkFromFile - ", evict);
             evictAll();
+        } finally {
+            IoUtils.closeQuietly(parcelFileDescriptor);
         }
         return artwork;
     }
@@ -523,12 +501,12 @@ public final class ImageCache {
                             mDiskCache.flush();
                         }
                     } catch (final IOException e) {
-                        Log.e(TAG, "flush - " + e);
+                        Log.e(TAG, "flush", e);
                     }
                 }
                 return null;
             }
-        }, (Void[])null);
+        });
     }
 
     /**
@@ -546,13 +524,13 @@ public final class ImageCache {
                         mDiskCache = null;
                     }
                 } catch (final IOException e) {
-                    Log.e(TAG, "clearCaches - " + e);
+                    Log.e(TAG, "clearCaches", e);
                 }
                 // Clear the memory cache
                 evictAll();
                 return null;
             }
-        }, (Void[])null);
+        });
     }
 
     /**
@@ -572,12 +550,12 @@ public final class ImageCache {
                             mDiskCache = null;
                         }
                     } catch (final IOException e) {
-                        Log.e(TAG, "close - " + e);
+                        Log.e(TAG, "close", e);
                     }
                 }
                 return null;
             }
-        }, (Void[]) null);
+        });
     }
 
     /**
@@ -609,7 +587,7 @@ public final class ImageCache {
                 mDiskCache.remove(hashKeyForDisk(key));
             }
         } catch (final IOException e) {
-            Log.e(TAG, "remove - " + e);
+            Log.e(TAG, "removeFromCache(" + key + ")", e);
         }
         flush();
     }
@@ -672,7 +650,7 @@ public final class ImageCache {
      *            directory
      * @return The cache directory
      */
-    public static final File getDiskCacheDir(final Context context, final String uniqueName) {
+    public static File getDiskCacheDir(final Context context, final String uniqueName) {
         // getExternalCacheDir(context) returns null if external storage is not ready
         final String cachePath = getExternalCacheDir(context) != null
                                     ? getExternalCacheDir(context).getPath()
@@ -686,7 +664,7 @@ public final class ImageCache {
      * @return True if external storage is removable (like an SD card), false
      *         otherwise
      */
-    public static final boolean isExternalStorageRemovable() {
+    public static boolean isExternalStorageRemovable() {
         return Environment.isExternalStorageRemovable();
     }
 
@@ -696,7 +674,7 @@ public final class ImageCache {
      * @param context The {@link Context} to use
      * @return The external cache directory
      */
-    public static final File getExternalCacheDir(final Context context) {
+    public static File getExternalCacheDir(final Context context) {
         return context.getExternalCacheDir();
     }
 
@@ -706,7 +684,7 @@ public final class ImageCache {
      * @param path The path to check
      * @return The space available in bytes
      */
-    public static final long getUsableSpace(final File path) {
+    public static long getUsableSpace(final File path) {
         return path.getUsableSpace();
     }
 
@@ -716,7 +694,7 @@ public final class ImageCache {
      *
      * @param key The key used to store the file
      */
-    public static final String hashKeyForDisk(final String key) {
+    public static String hashKeyForDisk(final String key) {
         String cacheKey;
         try {
             final MessageDigest digest = MessageDigest.getInstance("MD5");
@@ -735,7 +713,7 @@ public final class ImageCache {
      * @return A {@link String} converted from the bytes of a hashable key used
      *         to store a filename on the disk, to hex digits.
      */
-    private static final String bytesToHexString(final byte[] bytes) {
+    private static String bytesToHexString(final byte[] bytes) {
         final StringBuilder builder = new StringBuilder();
         for (final byte b : bytes) {
             final String hex = Integer.toHexString(0xFF & b);
@@ -765,9 +743,6 @@ public final class ImageCache {
         public RetainFragment() {
         }
 
-        /**
-         * {@inheritDoc}
-         */
         @Override
         public void onCreate(final Bundle savedInstanceState) {
             super.onCreate(savedInstanceState);
@@ -811,18 +786,13 @@ public final class ImageCache {
         /**
          * Get the size in bytes of a bitmap.
          */
-        public static final int getBitmapSize(final Bitmap bitmap) {
+        public static int getBitmapSize(final Bitmap bitmap) {
             return bitmap.getByteCount();
         }
 
-        /**
-         * {@inheritDoc}
-         */
         @Override
         protected int sizeOf(final String paramString, final Bitmap paramBitmap) {
             return getBitmapSize(paramBitmap);
         }
-
     }
-
 }
diff --git a/src/org/lineageos/eleven/utils/IoUtils.java b/src/org/lineageos/eleven/utils/IoUtils.java
new file mode 100644
index 0000000..dc50b89
--- /dev/null
+++ b/src/org/lineageos/eleven/utils/IoUtils.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2019 The LineageOS Project
+ * Copyright (C) 2019 SHIFT GmbH
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.lineageos.eleven.utils;
+
+import android.support.annotation.Nullable;
+
+import java.io.Closeable;
+import java.net.Socket;
+
+public class IoUtils {
+    public static void closeQuietly(@Nullable final Object object) {
+        try {
+            if (object instanceof Socket) {
+                ((Socket) object).close();
+            } else if (object instanceof Closeable) {
+                ((Closeable) object).close();
+            }
+        } catch (Exception ignored) {
+            // ignored
+        }
+    }
+}
-- 
2.17.1

