From 9ccdd396ec72eac28981d99d53547910ab75687f Mon Sep 17 00:00:00 2001
From: nx111 <NX111.AimH@gmail.com>
Date: Thu, 28 Feb 2019 00:56:33 +0800
Subject: [PATCH 33/33] more debug for sync [2]

Change-Id: I9a44df4e1052cc992a4d3123fcd6655fa41c1ffb
---
 .../com/android/server/content/SyncManager.java | 17 +++++++++++++++++
 .../server/content/SyncStorageEngine.java       |  6 ++++++
 2 files changed, 23 insertions(+)

diff --git a/services/core/java/com/android/server/content/SyncManager.java b/services/core/java/com/android/server/content/SyncManager.java
index 0a640b8a76c..ce824147cdb 100644
--- a/services/core/java/com/android/server/content/SyncManager.java
+++ b/services/core/java/com/android/server/content/SyncManager.java
@@ -1643,11 +1643,17 @@ public class SyncManager {
                 .setFlags(jobFlags);
 
         if (syncOperation.isPeriodic) {
+            if (isLoggable) {
+                Slog.v(TAG, "syncOperation.isPeriodic = true");
+            }
             b.setPeriodic(syncOperation.periodMillis, syncOperation.flexMillis);
         } else {
             if (minDelay > 0) {
                 b.setMinimumLatency(minDelay);
             }
+            if (isLoggable) {
+                Slog.v(TAG, "syncOperation.isPeriodic = false");
+            }
             getSyncStorageEngine().markPending(syncOperation.target, true);
         }
 
@@ -1660,6 +1666,10 @@ public class SyncManager {
             DeviceIdleController.LocalService dic =
                     LocalServices.getService(DeviceIdleController.LocalService.class);
             if (dic != null) {
+                if (isLoggable) {
+                    Slog.v(TAG, "LocalService add PoowerSave Temp WhitelistApp");
+                }
+
                 dic.addPowerSaveTempWhitelistApp(Process.SYSTEM_UID,
                         syncOperation.owningPackage,
                         mConstants.getKeyExemptionTempWhitelistDurationInSeconds() * 1000,
@@ -1669,6 +1679,9 @@ public class SyncManager {
         }
 
         if (syncOperation.isAppStandbyExempted()) {
+            if (isLoggable) {
+                Slog.v(TAG, "syncOperation isAppStandbyExempted:true");
+            }
             final UsageStatsManagerInternal usmi = LocalServices.getService(
                     UsageStatsManagerInternal.class);
             if (usmi != null) {
@@ -1677,6 +1690,10 @@ public class SyncManager {
             }
         }
 
+        if (isLoggable) {
+            Slog.v(TAG, "scheduleAsPackage, owningPackage:" + syncOperation.owningPackage
+                + " userId:" + syncOperation.target.userId + " wakeLockName:" + syncOperation.wakeLockName());
+        }
         getJobScheduler().scheduleAsPackage(b.build(), syncOperation.owningPackage,
                 syncOperation.target.userId, syncOperation.wakeLockName());
     }
diff --git a/services/core/java/com/android/server/content/SyncStorageEngine.java b/services/core/java/com/android/server/content/SyncStorageEngine.java
index 11f07015ef1..3c44c62c5e9 100644
--- a/services/core/java/com/android/server/content/SyncStorageEngine.java
+++ b/services/core/java/com/android/server/content/SyncStorageEngine.java
@@ -629,8 +629,14 @@ public class SyncStorageEngine {
                     continue;
                 }
                 if (reports == null) {
+                    if (Log.isLoggable(TAG, Log.VERBOSE)) {
+                        Slog.v(TAG, "set reports=" + i);
+                    }
                     reports = new ArrayList<ISyncStatusObserver>(i);
                 }
+                if (Log.isLoggable(TAG, Log.VERBOSE)) {
+                    Slog.v(TAG, "reports.add BroadcastItem(" + i + ")");
+                }
                 reports.add(mChangeListeners.getBroadcastItem(i));
             }
             mChangeListeners.finishBroadcast();
-- 
2.17.1

