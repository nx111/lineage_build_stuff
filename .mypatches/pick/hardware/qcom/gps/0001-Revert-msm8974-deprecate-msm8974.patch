From 5b7092a515eff372aac51f707593f5ab1cfdb39e Mon Sep 17 00:00:00 2001
From: Chirayu Desai <chirayudesai1@gmail.com>
Date: Wed, 24 Aug 2016 20:00:41 +0530
Subject: [PATCH 01/11] Revert "msm8974: deprecate msm8974"
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This reverts commit 486ab751599b7f8b5a2f2711d22867ad54fdc79b.

Change-Id: I0c81a0457bf4b3cb7f1e2b830e38b45069199be3
Signed-off-by: D. Andrei Măceș <Andrei.Maces@alumni.nd.edu>
---
 msm8974/Android.mk                            |    5 +
 msm8974/core/Android.mk                       |   54 +
 msm8974/core/ContextBase.cpp                  |  126 +
 msm8974/core/ContextBase.h                    |   70 +
 msm8974/core/IzatProxyBase.h                  |   60 +
 msm8974/core/LBSProxyBase.h                   |   63 +
 msm8974/core/LocAdapterBase.cpp               |  139 +
 msm8974/core/LocAdapterBase.h                 |  110 +
 msm8974/core/LocAdapterProxyBase.h            |   59 +
 msm8974/core/LocApiBase.cpp                   |  506 +++
 msm8974/core/LocApiBase.h                     |  242 ++
 msm8974/core/LocDualContext.cpp               |  165 +
 msm8974/core/LocDualContext.h                 |   73 +
 msm8974/core/MsgTask.cpp                      |  147 +
 msm8974/core/MsgTask.h                        |   67 +
 msm8974/core/UlpProxyBase.h                   |   85 +
 msm8974/core/gps_extended.h                   |   92 +
 msm8974/core/gps_extended_c.h                 |  399 +++
 msm8974/core/loc_core_log.cpp                 |  251 ++
 msm8974/core/loc_core_log.h                   |   58 +
 msm8974/etc/Android.mk                        |   10 +
 msm8974/etc/gps.conf                          |  101 +
 msm8974/loc_api/Android.mk                    |   17 +
 msm8974/loc_api/NOTICE                        |   13 +
 .../loc_api/libloc_api-rpc-50001/Android.mk   |    3 +
 .../libloc_api-rpc-glue/Android.mk            |   60 +
 .../libloc_api-rpc-glue/Makefile.am           |   46 +
 .../libloc_api-rpc-glue/rpc_inc/LocApiRpc.h   |  140 +
 .../libloc_api-rpc-glue/rpc_inc/debug.h       |   69 +
 .../rpc_inc/loc_api_fixup.h                   |  226 ++
 .../libloc_api-rpc-glue/rpc_inc/loc_api_log.h |   59 +
 .../rpc_inc/loc_api_rpc_glue.h                |  123 +
 .../rpc_inc/loc_api_sync_call.h               |   90 +
 .../rpc_inc/loc_apicb_appinit.h               |   45 +
 .../libloc_api-rpc-glue/src/LocApiRpc.cpp     | 1461 ++++++++
 .../libloc_api-rpc-glue/src/loc_api_fixup.c   |   52 +
 .../libloc_api-rpc-glue/src/loc_api_log.c     |  345 ++
 .../src/loc_api_rpc_glue.c                    |  636 ++++
 .../src/loc_api_sync_call.c                   |  565 +++
 .../src/loc_apicb_appinit.c                   |   86 +
 .../libloc_api-rpc-stub/Android.mk            |   36 +
 .../libloc_api-rpc-stub/Makefile.am           |   42 +
 .../inc/loc_api_rpcgen_cb_rpc.h               |  156 +
 .../inc/loc_api_rpcgen_common_rpc.h           | 1261 +++++++
 .../inc/loc_api_rpcgen_rpc.h                  |  288 ++
 .../inc/loc_apicb_appinit.h                   |   34 +
 .../src/loc_api_rpcgen_cb_svc.c               |  327 ++
 .../src/loc_api_rpcgen_cb_xdr.c               |   60 +
 .../src/loc_api_rpcgen_clnt.c                 |  155 +
 .../src/loc_api_rpcgen_common_xdr.c           | 1775 ++++++++++
 .../src/loc_api_rpcgen_xdr.c                  |  199 ++
 .../src/loc_apicb_appinit.c                   |   74 +
 .../libloc_api-rpc-stub/xdr/loc_api.xdr       |  261 ++
 .../libloc_api-rpc-stub/xdr/loc_api_cb.xdr    |  187 +
 .../xdr/loc_api_common.xdr                    | 1021 ++++++
 msm8974/loc_api/libloc_api-rpc/Android.mk     |   61 +
 .../libloc_api-rpc/gen-1240/Makefile.xdr      |   29 +
 .../libloc_api-rpc/gen-1240/loc_api.xdr       |  172 +
 .../libloc_api-rpc/gen-1240/loc_api_cb.xdr    |   85 +
 .../libloc_api-rpc/gen-1240/loc_api_cb_svc.c  |   64 +
 .../libloc_api-rpc/gen-1240/loc_api_cb_xdr.c  |   32 +
 .../libloc_api-rpc/gen-1240/loc_api_clnt.c    |   91 +
 .../gen-1240/loc_api_common.xdr               |  906 +++++
 .../gen-1240/loc_api_common_xdr.c             | 1650 +++++++++
 .../libloc_api-rpc/gen-1240/loc_api_fixup.c   |   48 +
 .../gen-1240/loc_api_rpc_glue.c               |  339 ++
 .../libloc_api-rpc/gen-1240/loc_api_xdr.c     |  171 +
 .../libloc_api-rpc/gen-3200/Makefile.xdr      |   29 +
 .../libloc_api-rpc/gen-3200/loc_api.xdr       |  164 +
 .../libloc_api-rpc/gen-3200/loc_api_cb.xdr    |   90 +
 .../libloc_api-rpc/gen-3200/loc_api_cb_svc.c  |   64 +
 .../libloc_api-rpc/gen-3200/loc_api_cb_xdr.c  |   32 +
 .../libloc_api-rpc/gen-3200/loc_api_clnt.c    |   82 +
 .../gen-3200/loc_api_common.xdr               |  803 +++++
 .../gen-3200/loc_api_common_xdr.c             | 1441 ++++++++
 .../libloc_api-rpc/gen-3200/loc_api_fixup.c   |   48 +
 .../gen-3200/loc_api_rpc_glue.c               |  339 ++
 .../libloc_api-rpc/gen-3200/loc_api_xdr.c     |  171 +
 .../loc_api/libloc_api-rpc/inc-1240/loc_api.h |  210 ++
 .../libloc_api-rpc/inc-1240/loc_api_cb.h      |   64 +
 .../libloc_api-rpc/inc-1240/loc_api_common.h  | 1154 +++++++
 .../libloc_api-rpc/inc-1240/loc_api_fixup.h   |  188 +
 .../inc-1240/loc_apicb_appinit.h              |   34 +
 .../loc_api/libloc_api-rpc/inc-3200/loc_api.h |  198 ++
 .../libloc_api-rpc/inc-3200/loc_api_cb.h      |   64 +
 .../libloc_api-rpc/inc-3200/loc_api_common.h  | 1031 ++++++
 .../libloc_api-rpc/inc-3200/loc_api_fixup.h   |  188 +
 .../inc-3200/loc_apicb_appinit.h              |   34 +
 msm8974/loc_api/libloc_api-rpc/inc/debug.h    |   57 +
 .../libloc_api-rpc/inc/loc_api_rpc_glue.h     |  100 +
 .../libloc_api-rpc/src/loc_apicb_appinit.c    |   61 +
 msm8974/loc_api/libloc_api_50001/Android.mk   |  105 +
 .../libloc_api_50001/LocEngAdapter.cpp        |  380 +++
 .../loc_api/libloc_api_50001/LocEngAdapter.h  |  352 ++
 msm8974/loc_api/libloc_api_50001/Makefile.am  |   76 +
 msm8974/loc_api/libloc_api_50001/gps.c        |   73 +
 msm8974/loc_api/libloc_api_50001/loc.cpp      | 1184 +++++++
 msm8974/loc_api/libloc_api_50001/loc.h        |   68 +
 msm8974/loc_api/libloc_api_50001/loc_eng.cpp  | 3024 +++++++++++++++++
 msm8974/loc_api/libloc_api_50001/loc_eng.h    |  272 ++
 .../loc_api/libloc_api_50001/loc_eng_agps.cpp |  971 ++++++
 .../loc_api/libloc_api_50001/loc_eng_agps.h   |  432 +++
 .../libloc_api_50001/loc_eng_dmn_conn.cpp     |  270 ++
 .../libloc_api_50001/loc_eng_dmn_conn.h       |   59 +
 .../loc_eng_dmn_conn_glue_msg.c               |  223 ++
 .../loc_eng_dmn_conn_glue_msg.h               |   51 +
 .../loc_eng_dmn_conn_glue_pipe.c              |  214 ++
 .../loc_eng_dmn_conn_glue_pipe.h              |   50 +
 .../loc_eng_dmn_conn_handler.cpp              |  237 ++
 .../loc_eng_dmn_conn_handler.h                |  106 +
 .../loc_eng_dmn_conn_thread_helper.c          |  399 +++
 .../loc_eng_dmn_conn_thread_helper.h          |   74 +
 .../loc_api/libloc_api_50001/loc_eng_log.cpp  |   35 +
 .../loc_api/libloc_api_50001/loc_eng_log.h    |   44 +
 .../loc_api/libloc_api_50001/loc_eng_msg.h    |  313 ++
 .../loc_api/libloc_api_50001/loc_eng_ni.cpp   |  414 +++
 msm8974/loc_api/libloc_api_50001/loc_eng_ni.h |   59 +
 .../loc_api/libloc_api_50001/loc_eng_nmea.cpp |  833 +++++
 .../loc_api/libloc_api_50001/loc_eng_nmea.h   |   42 +
 .../loc_api/libloc_api_50001/loc_eng_xtra.cpp |  167 +
 .../loc_api/libloc_api_50001/loc_eng_xtra.h   |   47 +
 .../elapsed_millis_since_boot.cpp             |   46 +
 .../platform_lib_includes.h                   |   35 +
 .../platform_lib_macros.h                     |   81 +
 .../platform_lib_time.h                       |   35 +
 msm8974/utils/Android.mk                      |   61 +
 msm8974/utils/Makefile.am                     |   44 +
 msm8974/utils/linked_list.c                   |  328 ++
 msm8974/utils/linked_list.h                   |  217 ++
 msm8974/utils/loc_cfg.cpp                     |  401 +++
 msm8974/utils/loc_cfg.h                       |   91 +
 msm8974/utils/loc_log.cpp                     |  240 ++
 msm8974/utils/loc_log.h                       |   68 +
 msm8974/utils/loc_misc_utils.cpp              |  114 +
 msm8974/utils/loc_misc_utils.h                |   99 +
 msm8974/utils/loc_target.cpp                  |  241 ++
 msm8974/utils/loc_target.h                    |   75 +
 msm8974/utils/loc_timer.c                     |  186 +
 msm8974/utils/loc_timer.h                     |   63 +
 msm8974/utils/log_util.h                      |  181 +
 msm8974/utils/msg_q.c                         |  336 ++
 msm8974/utils/msg_q.h                         |  207 ++
 142 files changed, 36811 insertions(+)
 create mode 100644 msm8974/Android.mk
 create mode 100644 msm8974/core/Android.mk
 create mode 100644 msm8974/core/ContextBase.cpp
 create mode 100644 msm8974/core/ContextBase.h
 create mode 100644 msm8974/core/IzatProxyBase.h
 create mode 100644 msm8974/core/LBSProxyBase.h
 create mode 100644 msm8974/core/LocAdapterBase.cpp
 create mode 100644 msm8974/core/LocAdapterBase.h
 create mode 100644 msm8974/core/LocAdapterProxyBase.h
 create mode 100644 msm8974/core/LocApiBase.cpp
 create mode 100644 msm8974/core/LocApiBase.h
 create mode 100644 msm8974/core/LocDualContext.cpp
 create mode 100644 msm8974/core/LocDualContext.h
 create mode 100644 msm8974/core/MsgTask.cpp
 create mode 100644 msm8974/core/MsgTask.h
 create mode 100644 msm8974/core/UlpProxyBase.h
 create mode 100644 msm8974/core/gps_extended.h
 create mode 100644 msm8974/core/gps_extended_c.h
 create mode 100644 msm8974/core/loc_core_log.cpp
 create mode 100644 msm8974/core/loc_core_log.h
 create mode 100644 msm8974/etc/Android.mk
 create mode 100644 msm8974/etc/gps.conf
 create mode 100644 msm8974/loc_api/Android.mk
 create mode 100644 msm8974/loc_api/NOTICE
 create mode 100644 msm8974/loc_api/libloc_api-rpc-50001/Android.mk
 create mode 100644 msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/Android.mk
 create mode 100644 msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/Makefile.am
 create mode 100644 msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/rpc_inc/LocApiRpc.h
 create mode 100644 msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/rpc_inc/debug.h
 create mode 100644 msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/rpc_inc/loc_api_fixup.h
 create mode 100644 msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/rpc_inc/loc_api_log.h
 create mode 100644 msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/rpc_inc/loc_api_rpc_glue.h
 create mode 100644 msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/rpc_inc/loc_api_sync_call.h
 create mode 100644 msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/rpc_inc/loc_apicb_appinit.h
 create mode 100644 msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/src/LocApiRpc.cpp
 create mode 100644 msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/src/loc_api_fixup.c
 create mode 100644 msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/src/loc_api_log.c
 create mode 100644 msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/src/loc_api_rpc_glue.c
 create mode 100644 msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/src/loc_api_sync_call.c
 create mode 100644 msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/src/loc_apicb_appinit.c
 create mode 100644 msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/Android.mk
 create mode 100644 msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/Makefile.am
 create mode 100644 msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/inc/loc_api_rpcgen_cb_rpc.h
 create mode 100644 msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/inc/loc_api_rpcgen_common_rpc.h
 create mode 100644 msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/inc/loc_api_rpcgen_rpc.h
 create mode 100644 msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/inc/loc_apicb_appinit.h
 create mode 100644 msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/src/loc_api_rpcgen_cb_svc.c
 create mode 100644 msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/src/loc_api_rpcgen_cb_xdr.c
 create mode 100644 msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/src/loc_api_rpcgen_clnt.c
 create mode 100644 msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/src/loc_api_rpcgen_common_xdr.c
 create mode 100644 msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/src/loc_api_rpcgen_xdr.c
 create mode 100644 msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/src/loc_apicb_appinit.c
 create mode 100644 msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/xdr/loc_api.xdr
 create mode 100644 msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/xdr/loc_api_cb.xdr
 create mode 100644 msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/xdr/loc_api_common.xdr
 create mode 100644 msm8974/loc_api/libloc_api-rpc/Android.mk
 create mode 100644 msm8974/loc_api/libloc_api-rpc/gen-1240/Makefile.xdr
 create mode 100644 msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api.xdr
 create mode 100644 msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_cb.xdr
 create mode 100644 msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_cb_svc.c
 create mode 100644 msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_cb_xdr.c
 create mode 100644 msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_clnt.c
 create mode 100644 msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_common.xdr
 create mode 100644 msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_common_xdr.c
 create mode 100644 msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_fixup.c
 create mode 100644 msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_rpc_glue.c
 create mode 100644 msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_xdr.c
 create mode 100644 msm8974/loc_api/libloc_api-rpc/gen-3200/Makefile.xdr
 create mode 100644 msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api.xdr
 create mode 100644 msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_cb.xdr
 create mode 100644 msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_cb_svc.c
 create mode 100644 msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_cb_xdr.c
 create mode 100644 msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_clnt.c
 create mode 100644 msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_common.xdr
 create mode 100644 msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_common_xdr.c
 create mode 100644 msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_fixup.c
 create mode 100644 msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_rpc_glue.c
 create mode 100644 msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_xdr.c
 create mode 100644 msm8974/loc_api/libloc_api-rpc/inc-1240/loc_api.h
 create mode 100644 msm8974/loc_api/libloc_api-rpc/inc-1240/loc_api_cb.h
 create mode 100644 msm8974/loc_api/libloc_api-rpc/inc-1240/loc_api_common.h
 create mode 100644 msm8974/loc_api/libloc_api-rpc/inc-1240/loc_api_fixup.h
 create mode 100644 msm8974/loc_api/libloc_api-rpc/inc-1240/loc_apicb_appinit.h
 create mode 100644 msm8974/loc_api/libloc_api-rpc/inc-3200/loc_api.h
 create mode 100644 msm8974/loc_api/libloc_api-rpc/inc-3200/loc_api_cb.h
 create mode 100644 msm8974/loc_api/libloc_api-rpc/inc-3200/loc_api_common.h
 create mode 100644 msm8974/loc_api/libloc_api-rpc/inc-3200/loc_api_fixup.h
 create mode 100644 msm8974/loc_api/libloc_api-rpc/inc-3200/loc_apicb_appinit.h
 create mode 100644 msm8974/loc_api/libloc_api-rpc/inc/debug.h
 create mode 100644 msm8974/loc_api/libloc_api-rpc/inc/loc_api_rpc_glue.h
 create mode 100644 msm8974/loc_api/libloc_api-rpc/src/loc_apicb_appinit.c
 create mode 100644 msm8974/loc_api/libloc_api_50001/Android.mk
 create mode 100644 msm8974/loc_api/libloc_api_50001/LocEngAdapter.cpp
 create mode 100644 msm8974/loc_api/libloc_api_50001/LocEngAdapter.h
 create mode 100644 msm8974/loc_api/libloc_api_50001/Makefile.am
 create mode 100644 msm8974/loc_api/libloc_api_50001/gps.c
 create mode 100644 msm8974/loc_api/libloc_api_50001/loc.cpp
 create mode 100644 msm8974/loc_api/libloc_api_50001/loc.h
 create mode 100644 msm8974/loc_api/libloc_api_50001/loc_eng.cpp
 create mode 100644 msm8974/loc_api/libloc_api_50001/loc_eng.h
 create mode 100644 msm8974/loc_api/libloc_api_50001/loc_eng_agps.cpp
 create mode 100644 msm8974/loc_api/libloc_api_50001/loc_eng_agps.h
 create mode 100644 msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn.cpp
 create mode 100644 msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn.h
 create mode 100644 msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_glue_msg.c
 create mode 100644 msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_glue_msg.h
 create mode 100644 msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_glue_pipe.c
 create mode 100644 msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_glue_pipe.h
 create mode 100644 msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_handler.cpp
 create mode 100644 msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_handler.h
 create mode 100644 msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_thread_helper.c
 create mode 100644 msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_thread_helper.h
 create mode 100644 msm8974/loc_api/libloc_api_50001/loc_eng_log.cpp
 create mode 100644 msm8974/loc_api/libloc_api_50001/loc_eng_log.h
 create mode 100644 msm8974/loc_api/libloc_api_50001/loc_eng_msg.h
 create mode 100644 msm8974/loc_api/libloc_api_50001/loc_eng_ni.cpp
 create mode 100644 msm8974/loc_api/libloc_api_50001/loc_eng_ni.h
 create mode 100644 msm8974/loc_api/libloc_api_50001/loc_eng_nmea.cpp
 create mode 100644 msm8974/loc_api/libloc_api_50001/loc_eng_nmea.h
 create mode 100644 msm8974/loc_api/libloc_api_50001/loc_eng_xtra.cpp
 create mode 100644 msm8974/loc_api/libloc_api_50001/loc_eng_xtra.h
 create mode 100644 msm8974/platform_lib_abstractions/elapsed_millis_since_boot.cpp
 create mode 100644 msm8974/platform_lib_abstractions/platform_lib_includes.h
 create mode 100644 msm8974/platform_lib_abstractions/platform_lib_macros.h
 create mode 100644 msm8974/platform_lib_abstractions/platform_lib_time.h
 create mode 100644 msm8974/utils/Android.mk
 create mode 100644 msm8974/utils/Makefile.am
 create mode 100644 msm8974/utils/linked_list.c
 create mode 100644 msm8974/utils/linked_list.h
 create mode 100644 msm8974/utils/loc_cfg.cpp
 create mode 100644 msm8974/utils/loc_cfg.h
 create mode 100644 msm8974/utils/loc_log.cpp
 create mode 100644 msm8974/utils/loc_log.h
 create mode 100644 msm8974/utils/loc_misc_utils.cpp
 create mode 100644 msm8974/utils/loc_misc_utils.h
 create mode 100644 msm8974/utils/loc_target.cpp
 create mode 100644 msm8974/utils/loc_target.h
 create mode 100644 msm8974/utils/loc_timer.c
 create mode 100644 msm8974/utils/loc_timer.h
 create mode 100644 msm8974/utils/log_util.h
 create mode 100644 msm8974/utils/msg_q.c
 create mode 100644 msm8974/utils/msg_q.h

diff --git a/msm8974/Android.mk b/msm8974/Android.mk
new file mode 100644
index 0000000..e2c5a56
--- /dev/null
+++ b/msm8974/Android.mk
@@ -0,0 +1,5 @@
+ifneq ($(BOARD_VENDOR_QCOM_GPS_LOC_API_HARDWARE),)
+LOCAL_PATH := $(call my-dir)
+
+include $(call all-makefiles-under,$(LOCAL_PATH))
+endif
diff --git a/msm8974/core/Android.mk b/msm8974/core/Android.mk
new file mode 100644
index 0000000..8b5898c
--- /dev/null
+++ b/msm8974/core/Android.mk
@@ -0,0 +1,54 @@
+ifneq ($(BOARD_VENDOR_QCOM_GPS_LOC_API_HARDWARE),)
+ifneq ($(BUILD_TINY_ANDROID),true)
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := libloc_core
+LOCAL_MODULE_OWNER := qcom
+
+LOCAL_MODULE_TAGS := optional
+
+LOCAL_SHARED_LIBRARIES := \
+    libutils \
+    libcutils \
+    libgps.utils \
+    libdl
+
+LOCAL_SRC_FILES += \
+    MsgTask.cpp \
+    LocApiBase.cpp \
+    LocAdapterBase.cpp \
+    ContextBase.cpp \
+    LocDualContext.cpp \
+    loc_core_log.cpp
+
+LOCAL_CFLAGS += \
+     -fno-short-enums \
+     -D_ANDROID_ \
+     -Wno-unused-parameter
+
+LOCAL_C_INCLUDES:= \
+    $(TARGET_OUT_HEADERS)/gps.utils
+
+LOCAL_COPY_HEADERS_TO:= libloc_core/
+LOCAL_COPY_HEADERS:= \
+    MsgTask.h \
+    LocApiBase.h \
+    LocAdapterBase.h \
+    ContextBase.h \
+    LocDualContext.h \
+    LBSProxyBase.h \
+    UlpProxyBase.h \
+    gps_extended_c.h \
+    gps_extended.h \
+    loc_core_log.h \
+    LocAdapterProxyBase.h
+
+LOCAL_PRELINK_MODULE := false
+
+include $(BUILD_SHARED_LIBRARY)
+
+endif # not BUILD_TINY_ANDROID
+endif # BOARD_VENDOR_QCOM_GPS_LOC_API_HARDWARE
diff --git a/msm8974/core/ContextBase.cpp b/msm8974/core/ContextBase.cpp
new file mode 100644
index 0000000..4c05a48
--- /dev/null
+++ b/msm8974/core/ContextBase.cpp
@@ -0,0 +1,126 @@
+/* Copyright (c) 2011-2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#define LOG_NDDEBUG 0
+#define LOG_TAG "LocSvc_CtxBase"
+
+#include <dlfcn.h>
+#include <cutils/sched_policy.h>
+#include <unistd.h>
+#include <ContextBase.h>
+#include <msg_q.h>
+#include <loc_target.h>
+#include <log_util.h>
+#include <loc_log.h>
+
+namespace loc_core {
+
+LBSProxyBase* ContextBase::getLBSProxy(const char* libName)
+{
+    LBSProxyBase* proxy = NULL;
+    LOC_LOGD("%s:%d]: getLBSProxy libname: %s\n", __func__, __LINE__, libName);
+    dlerror();
+    void* lib = dlopen(libName, RTLD_NOW);
+
+    if ((void*)NULL != lib) {
+        dlerror();
+        getLBSProxy_t* getter = (getLBSProxy_t*)dlsym(lib, "getLBSProxy");
+        if (NULL != getter) {
+            proxy = (*getter)();
+        }
+        else {
+            LOC_LOGD("%s:%d]: getter is NULL. Reason: %s", __func__, __LINE__, dlerror());
+        }
+    }
+    else {
+        LOC_LOGD("%s:%d]: lib is NULL. Reason: %s", __func__, __LINE__, dlerror());
+    }
+    if (NULL == proxy) {
+        proxy = new LBSProxyBase();
+    }
+    LOC_LOGD("%s:%d]: Exiting\n", __func__, __LINE__);
+    return proxy;
+}
+
+LocApiBase* ContextBase::createLocApi(LOC_API_ADAPTER_EVENT_MASK_T exMask)
+{
+    LocApiBase* locApi = NULL;
+
+    // first if can not be MPQ
+    if (TARGET_MPQ != loc_get_target()) {
+        if (NULL == (locApi = mLBSProxy->getLocApi(mMsgTask, exMask, this))) {
+            void *handle = NULL;
+            //try to see if LocApiV02 is present
+            if((handle = dlopen("libloc_api_v02.so", RTLD_NOW)) != NULL) {
+                LOC_LOGD("%s:%d]: libloc_api_v02.so is present", __func__, __LINE__);
+                dlerror();
+                getLocApi_t* getter = (getLocApi_t*)dlsym(handle, "getLocApi");
+                if(getter != NULL) {
+                    LOC_LOGD("%s:%d]: getter is not NULL for LocApiV02", __func__, __LINE__);
+                    locApi = (*getter)(mMsgTask,exMask, this);
+                }
+                else {
+                    LOC_LOGD("%s:%d]: getter is NULL. Reason: %s", __func__, __LINE__, dlerror());
+                }
+            }
+            // only RPC is the option now
+            else {
+                LOC_LOGD("%s:%d]: libloc_api_v02.so is NOT present. Trying RPC",
+                         __func__, __LINE__);
+                handle = dlopen("libloc_api-rpc-qc.so", RTLD_NOW);
+                if (NULL != handle) {
+                    getLocApi_t* getter = (getLocApi_t*)dlsym(handle, "getLocApi");
+                    if (NULL != getter) {
+                        LOC_LOGD("%s:%d]: getter is NULL in RPC", __func__, __LINE__);
+                        locApi = (*getter)(mMsgTask, exMask, this);
+                    }
+                }
+            }
+        }
+    }
+
+    // locApi could still be NULL at this time
+    // we would then create a dummy one
+    if (NULL == locApi) {
+        locApi = new LocApiBase(mMsgTask, exMask, this);
+    }
+
+    return locApi;
+}
+
+ContextBase::ContextBase(const MsgTask* msgTask,
+                         LOC_API_ADAPTER_EVENT_MASK_T exMask,
+                         const char* libName) :
+    mLBSProxy(getLBSProxy(libName)),
+    mMsgTask(msgTask),
+    mLocApi(createLocApi(exMask)),
+    mLocApiProxy(mLocApi->getLocApiProxy())
+{
+}
+
+}
diff --git a/msm8974/core/ContextBase.h b/msm8974/core/ContextBase.h
new file mode 100644
index 0000000..2adbedd
--- /dev/null
+++ b/msm8974/core/ContextBase.h
@@ -0,0 +1,70 @@
+/* Copyright (c) 2011-2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef __LOC_CONTEXT_BASE__
+#define __LOC_CONTEXT_BASE__
+
+#include <stdbool.h>
+#include <ctype.h>
+#include <MsgTask.h>
+#include <LocApiBase.h>
+#include <LBSProxyBase.h>
+
+namespace loc_core {
+
+class LocAdapterBase;
+
+class ContextBase {
+    static LBSProxyBase* getLBSProxy(const char* libName);
+    LocApiBase* createLocApi(LOC_API_ADAPTER_EVENT_MASK_T excludedMask);
+protected:
+    const LBSProxyBase* mLBSProxy;
+    const MsgTask* mMsgTask;
+    LocApiBase* mLocApi;
+    LocApiProxyBase *mLocApiProxy;
+public:
+    ContextBase(const MsgTask* msgTask,
+                LOC_API_ADAPTER_EVENT_MASK_T exMask,
+                const char* libName);
+    inline virtual ~ContextBase() { delete mLocApi; delete mLBSProxy; }
+
+    inline const MsgTask* getMsgTask() { return mMsgTask; }
+    inline LocApiBase* getLocApi() { return mLocApi; }
+    inline LocApiProxyBase* getLocApiProxy() { return mLocApiProxy; }
+    inline bool hasAgpsExtendedCapabilities() { return mLBSProxy->hasAgpsExtendedCapabilities(); }
+    inline bool hasCPIExtendedCapabilities() { return mLBSProxy->hasCPIExtendedCapabilities(); }
+    inline void requestUlp(LocAdapterBase* adapter,
+                           unsigned long capabilities) {
+        mLBSProxy->requestUlp(adapter, capabilities);
+    }
+    inline void sendMsg(const LocMsg *msg) { getMsgTask()->sendMsg(msg); }
+};
+
+} // namespace loc_core
+
+#endif //__LOC_CONTEXT_BASE__
diff --git a/msm8974/core/IzatProxyBase.h b/msm8974/core/IzatProxyBase.h
new file mode 100644
index 0000000..e7e3d3f
--- /dev/null
+++ b/msm8974/core/IzatProxyBase.h
@@ -0,0 +1,60 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef IZAT_PROXY_BASE_H
+#define IZAT_PROXY_BASE_H
+
+#include <gps_extended.h>
+#include <MsgTask.h>
+
+namespace loc_core {
+
+class LocApiBase;
+class LocAdapterBase;
+
+class IzatProxyBase {
+    friend class ContextBase;
+    inline virtual LocApiBase*
+        getLocApi(const MsgTask* msgTask,
+                  LOC_API_ADAPTER_EVENT_MASK_T exMask) const {
+        return NULL;
+    }
+protected:
+    inline IzatProxyBase() {}
+public:
+    inline virtual ~IzatProxyBase() {}
+    inline virtual void requestUlp(LocAdapterBase* adapter,
+                                   unsigned long capabilities) const {}
+    inline virtual bool hasAgpsExt() const { return false; }
+};
+
+typedef IzatProxyBase* (getIzatProxy_t)();
+
+} // namespace loc_core
+
+#endif // IZAT_PROXY_BASE_H
diff --git a/msm8974/core/LBSProxyBase.h b/msm8974/core/LBSProxyBase.h
new file mode 100644
index 0000000..0b7dbdf
--- /dev/null
+++ b/msm8974/core/LBSProxyBase.h
@@ -0,0 +1,63 @@
+/* Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef IZAT_PROXY_BASE_H
+#define IZAT_PROXY_BASE_H
+#include <gps_extended.h>
+#include <MsgTask.h>
+
+namespace loc_core {
+
+class LocApiBase;
+class LocAdapterBase;
+class ContextBase;
+
+class LBSProxyBase {
+    friend class ContextBase;
+    inline virtual LocApiBase*
+        getLocApi(const MsgTask* msgTask,
+                  LOC_API_ADAPTER_EVENT_MASK_T exMask,
+                  ContextBase* context) const {
+        return NULL;
+    }
+protected:
+    inline LBSProxyBase() {}
+public:
+    inline virtual ~LBSProxyBase() {}
+    inline virtual void requestUlp(LocAdapterBase* adapter,
+                                   unsigned long capabilities) const {}
+    inline virtual bool hasAgpsExtendedCapabilities() const { return false; }
+    inline virtual bool hasCPIExtendedCapabilities() const { return false; }
+    virtual void injectFeatureConfig(ContextBase* context) const {}
+};
+
+typedef LBSProxyBase* (getLBSProxy_t)();
+
+} // namespace loc_core
+
+#endif // IZAT_PROXY_BASE_H
diff --git a/msm8974/core/LocAdapterBase.cpp b/msm8974/core/LocAdapterBase.cpp
new file mode 100644
index 0000000..23184df
--- /dev/null
+++ b/msm8974/core/LocAdapterBase.cpp
@@ -0,0 +1,139 @@
+/* Copyright (c) 2011-2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#define LOG_NDDEBUG 0
+#define LOG_TAG "LocSvc_LocAdapterBase"
+
+#include <dlfcn.h>
+#include <LocAdapterBase.h>
+#include <loc_target.h>
+#include <log_util.h>
+#include <LocAdapterProxyBase.h>
+
+namespace loc_core {
+
+// This is the top level class, so the constructor will
+// always gets called. Here we prepare for the default.
+// But if getLocApi(targetEnumType target) is overriden,
+// the right locApi should get created.
+LocAdapterBase::LocAdapterBase(const LOC_API_ADAPTER_EVENT_MASK_T mask,
+                               ContextBase* context, LocAdapterProxyBase *adapterProxyBase) :
+    mEvtMask(mask), mContext(context),
+    mLocApi(context->getLocApi()), mLocAdapterProxyBase(adapterProxyBase),
+    mMsgTask(context->getMsgTask())
+{
+    mLocApi->addAdapter(this);
+}
+
+void LocAdapterBase::handleEngineUpEvent()
+{
+    if (mLocAdapterProxyBase) {
+        mLocAdapterProxyBase->handleEngineUpEvent();
+    }
+}
+
+void LocAdapterBase::handleEngineDownEvent()
+{
+    if (mLocAdapterProxyBase) {
+        mLocAdapterProxyBase->handleEngineDownEvent();
+    }
+}
+
+void LocAdapterBase::
+    reportPosition(UlpLocation &location,
+                   GpsLocationExtended &locationExtended,
+                   void* locationExt,
+                   enum loc_sess_status status,
+                   LocPosTechMask loc_technology_mask)
+DEFAULT_IMPL()
+
+void LocAdapterBase::
+    reportSv(GpsSvStatus &svStatus,
+             GpsLocationExtended &locationExtended,
+             void* svExt)
+DEFAULT_IMPL()
+
+
+void LocAdapterBase::
+    reportStatus(GpsStatusValue status)
+DEFAULT_IMPL()
+
+
+void LocAdapterBase::
+    reportNmea(const char* nmea, int length)
+DEFAULT_IMPL()
+
+bool LocAdapterBase::
+    reportXtraServer(const char* url1, const char* url2,
+                     const char* url3, const int maxlength)
+DEFAULT_IMPL(false)
+
+bool LocAdapterBase::
+    requestXtraData()
+DEFAULT_IMPL(false)
+
+bool LocAdapterBase::
+    requestTime()
+DEFAULT_IMPL(false)
+
+bool LocAdapterBase::
+    requestLocation()
+DEFAULT_IMPL(false)
+
+bool LocAdapterBase::
+    requestATL(int connHandle, AGpsType agps_type)
+DEFAULT_IMPL(false)
+
+bool LocAdapterBase::
+    releaseATL(int connHandle)
+DEFAULT_IMPL(false)
+
+bool LocAdapterBase::
+    requestSuplES(int connHandle)
+DEFAULT_IMPL(false)
+
+bool LocAdapterBase::
+    reportDataCallOpened()
+DEFAULT_IMPL(false)
+
+bool LocAdapterBase::
+    reportDataCallClosed()
+DEFAULT_IMPL(false)
+
+bool LocAdapterBase::
+    requestNiNotify(GpsNiNotification &notify, const void* data)
+DEFAULT_IMPL(false)
+
+void LocAdapterBase::
+    shutdown()
+DEFAULT_IMPL()
+
+void LocAdapterBase::
+    reportGpsMeasurementData(GpsData &gpsMeasurementData)
+DEFAULT_IMPL()
+} // namespace loc_core
diff --git a/msm8974/core/LocAdapterBase.h b/msm8974/core/LocAdapterBase.h
new file mode 100644
index 0000000..e6ff26a
--- /dev/null
+++ b/msm8974/core/LocAdapterBase.h
@@ -0,0 +1,110 @@
+/* Copyright (c) 2011-2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef LOC_API_ADAPTER_BASE_H
+#define LOC_API_ADAPTER_BASE_H
+
+#include <gps_extended.h>
+#include <UlpProxyBase.h>
+#include <ContextBase.h>
+
+namespace loc_core {
+
+class LocAdapterProxyBase;
+
+class LocAdapterBase {
+protected:
+    const LOC_API_ADAPTER_EVENT_MASK_T mEvtMask;
+    ContextBase* mContext;
+    LocApiBase* mLocApi;
+    LocAdapterProxyBase* mLocAdapterProxyBase;
+    const MsgTask* mMsgTask;
+
+    inline LocAdapterBase(const MsgTask* msgTask) :
+        mEvtMask(0), mContext(NULL), mLocApi(NULL), mLocAdapterProxyBase(NULL), mMsgTask(msgTask) {}
+public:
+    inline virtual ~LocAdapterBase() { mLocApi->removeAdapter(this); }
+    LocAdapterBase(const LOC_API_ADAPTER_EVENT_MASK_T mask,
+                   ContextBase* context, LocAdapterProxyBase *adapterProxyBase = NULL);
+    inline LOC_API_ADAPTER_EVENT_MASK_T
+        checkMask(LOC_API_ADAPTER_EVENT_MASK_T mask) const {
+        return mEvtMask & mask;
+    }
+
+    inline LOC_API_ADAPTER_EVENT_MASK_T getEvtMask() const {
+        return mEvtMask;
+    }
+
+    inline void sendMsg(const LocMsg* msg) const {
+        mMsgTask->sendMsg(msg);
+    }
+
+    inline void sendMsg(const LocMsg* msg) {
+        mMsgTask->sendMsg(msg);
+    }
+
+    // This will be overridden by the individual adapters
+    // if necessary.
+    inline virtual void setUlpProxy(UlpProxyBase* ulp) {}
+    virtual void handleEngineUpEvent();
+    virtual void handleEngineDownEvent();
+    inline virtual void setPositionModeInt(LocPosMode& posMode) {}
+    virtual void startFixInt() {}
+    virtual void stopFixInt() {}
+    virtual void getZppInt() {}
+    virtual void reportPosition(UlpLocation &location,
+                                GpsLocationExtended &locationExtended,
+                                void* locationExt,
+                                enum loc_sess_status status,
+                                LocPosTechMask loc_technology_mask);
+    virtual void reportSv(GpsSvStatus &svStatus,
+                          GpsLocationExtended &locationExtended,
+                          void* svExt);
+    virtual void reportStatus(GpsStatusValue status);
+    virtual void reportNmea(const char* nmea, int length);
+    virtual bool reportXtraServer(const char* url1, const char* url2,
+                                  const char* url3, const int maxlength);
+    virtual bool requestXtraData();
+    virtual bool requestTime();
+    virtual bool requestLocation();
+    virtual bool requestATL(int connHandle, AGpsType agps_type);
+    virtual bool releaseATL(int connHandle);
+    virtual bool requestSuplES(int connHandle);
+    virtual bool reportDataCallOpened();
+    virtual bool reportDataCallClosed();
+    virtual bool requestNiNotify(GpsNiNotification &notify,
+                                 const void* data);
+    inline virtual bool isInSession() { return false; }
+    virtual void shutdown();
+    ContextBase* getContext() const { return mContext; }
+    virtual void reportGpsMeasurementData(GpsData &gpsMeasurementData);
+};
+
+} // namespace loc_core
+
+#endif //LOC_API_ADAPTER_BASE_H
diff --git a/msm8974/core/LocAdapterProxyBase.h b/msm8974/core/LocAdapterProxyBase.h
new file mode 100644
index 0000000..25af10b
--- /dev/null
+++ b/msm8974/core/LocAdapterProxyBase.h
@@ -0,0 +1,59 @@
+/* Copyright (c) 2014 The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef LOC_ADAPTER_PROXY_BASE_H
+#define LOC_ADAPTER_PROXY_BASE_H
+
+#include <ContextBase.h>
+#include <gps_extended.h>
+
+namespace loc_core {
+
+class LocAdapterProxyBase {
+private:
+    const LocAdapterBase *mLocAdapterBase;
+protected:
+    inline LocAdapterProxyBase(const LOC_API_ADAPTER_EVENT_MASK_T mask,
+                   ContextBase* context):
+                   mLocAdapterBase(new LocAdapterBase(mask, context, this)) {
+    }
+    inline virtual ~LocAdapterProxyBase() {
+        delete mLocAdapterBase;
+    }
+    ContextBase* getContext() const {
+        return mLocAdapterBase->getContext();
+    }
+public:
+    inline virtual void handleEngineUpEvent() {};
+    inline virtual void handleEngineDownEvent() {};
+};
+
+} // namespace loc_core
+
+#endif //LOC_ADAPTER_PROXY_BASE_H
diff --git a/msm8974/core/LocApiBase.cpp b/msm8974/core/LocApiBase.cpp
new file mode 100644
index 0000000..6969fe5
--- /dev/null
+++ b/msm8974/core/LocApiBase.cpp
@@ -0,0 +1,506 @@
+/* Copyright (c) 2011-2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#define LOG_NDDEBUG 0
+#define LOG_TAG "LocSvc_LocApiBase"
+
+#include <dlfcn.h>
+#include <LocApiBase.h>
+#include <LocAdapterBase.h>
+#include <log_util.h>
+#include <LocDualContext.h>
+
+namespace loc_core {
+
+#define TO_ALL_LOCADAPTERS(call) TO_ALL_ADAPTERS(mLocAdapters, (call))
+#define TO_1ST_HANDLING_LOCADAPTERS(call) TO_1ST_HANDLING_ADAPTER(mLocAdapters, (call))
+
+int hexcode(char *hexstring, int string_size,
+            const char *data, int data_size)
+{
+   int i;
+   for (i = 0; i < data_size; i++)
+   {
+      char ch = data[i];
+      if (i*2 + 3 <= string_size)
+      {
+         snprintf(&hexstring[i*2], 3, "%02X", ch);
+      }
+      else {
+         break;
+      }
+   }
+   return i;
+}
+
+int decodeAddress(char *addr_string, int string_size,
+                   const char *data, int data_size)
+{
+    const char addr_prefix = 0x91;
+    int i, idxOutput = 0;
+
+    if (!data || !addr_string) { return 0; }
+
+    if (data[0] != addr_prefix)
+    {
+        LOC_LOGW("decodeAddress: address prefix is not 0x%x but 0x%x", addr_prefix, data[0]);
+        addr_string[0] = '\0';
+        return 0; // prefix not correct
+    }
+
+    for (i = 1; i < data_size; i++)
+    {
+        unsigned char ch = data[i], low = ch & 0x0F, hi = ch >> 4;
+        if (low <= 9 && idxOutput < string_size - 1) { addr_string[idxOutput++] = low + '0'; }
+        if (hi <= 9 && idxOutput < string_size - 1) { addr_string[idxOutput++] = hi + '0'; }
+    }
+
+    addr_string[idxOutput] = '\0'; // Terminates the string
+
+    return idxOutput;
+}
+
+struct LocSsrMsg : public LocMsg {
+    LocApiBase* mLocApi;
+    inline LocSsrMsg(LocApiBase* locApi) :
+        LocMsg(), mLocApi(locApi)
+    {
+        locallog();
+    }
+    inline virtual void proc() const {
+        mLocApi->close();
+        mLocApi->open(mLocApi->getEvtMask());
+    }
+    inline void locallog() {
+        LOC_LOGV("LocSsrMsg");
+    }
+    inline virtual void log() {
+        locallog();
+    }
+};
+
+struct LocOpenMsg : public LocMsg {
+    LocApiBase* mLocApi;
+    LOC_API_ADAPTER_EVENT_MASK_T mMask;
+    inline LocOpenMsg(LocApiBase* locApi,
+                      LOC_API_ADAPTER_EVENT_MASK_T mask) :
+        LocMsg(), mLocApi(locApi), mMask(mask)
+    {
+        locallog();
+    }
+    inline virtual void proc() const {
+        mLocApi->open(mMask);
+    }
+    inline void locallog() {
+        LOC_LOGV("%s:%d]: LocOpen Mask: %x\n",
+                 __func__, __LINE__, mMask);
+    }
+    inline virtual void log() {
+        locallog();
+    }
+};
+
+LocApiBase::LocApiBase(const MsgTask* msgTask,
+                       LOC_API_ADAPTER_EVENT_MASK_T excludedMask,
+                       ContextBase* context) :
+    mExcludedMask(excludedMask), mMsgTask(msgTask), mMask(0), mContext(context)
+{
+    memset(mLocAdapters, 0, sizeof(mLocAdapters));
+}
+
+LOC_API_ADAPTER_EVENT_MASK_T LocApiBase::getEvtMask()
+{
+    LOC_API_ADAPTER_EVENT_MASK_T mask = 0;
+
+    TO_ALL_LOCADAPTERS(mask |= mLocAdapters[i]->getEvtMask());
+
+    return mask & ~mExcludedMask;
+}
+
+bool LocApiBase::isInSession()
+{
+    bool inSession = false;
+
+    for (int i = 0;
+         !inSession && i < MAX_ADAPTERS && NULL != mLocAdapters[i];
+         i++) {
+        inSession = mLocAdapters[i]->isInSession();
+    }
+
+    return inSession;
+}
+
+void LocApiBase::addAdapter(LocAdapterBase* adapter)
+{
+    for (int i = 0; i < MAX_ADAPTERS && mLocAdapters[i] != adapter; i++) {
+        if (mLocAdapters[i] == NULL) {
+            mLocAdapters[i] = adapter;
+            mMsgTask->sendMsg(new LocOpenMsg(this,
+                                             (adapter->getEvtMask())));
+            break;
+        }
+    }
+}
+
+void LocApiBase::removeAdapter(LocAdapterBase* adapter)
+{
+    for (int i = 0;
+         i < MAX_ADAPTERS && NULL != mLocAdapters[i];
+         i++) {
+        if (mLocAdapters[i] == adapter) {
+            mLocAdapters[i] = NULL;
+
+            // shift the rest of the adapters up so that the pointers
+            // in the array do not have holes.  This should be more
+            // performant, because the array maintenance is much much
+            // less frequent than event handlings, which need to linear
+            // search all the adapters
+            int j = i;
+            while (++i < MAX_ADAPTERS && mLocAdapters[i] != NULL);
+
+            // i would be MAX_ADAPTERS or point to a NULL
+            i--;
+            // i now should point to a none NULL adapter within valid
+            // range although i could be equal to j, but it won't hurt.
+            // No need to check it, as it gains nothing.
+            mLocAdapters[j] = mLocAdapters[i];
+            // this makes sure that we exit the for loop
+            mLocAdapters[i] = NULL;
+
+            // if we have an empty list of adapters
+            if (0 == i) {
+                close();
+            } else {
+                // else we need to remove the bit
+                mMsgTask->sendMsg(new LocOpenMsg(this, getEvtMask()));
+            }
+        }
+    }
+}
+
+void LocApiBase::handleEngineUpEvent()
+{
+    // This will take care of renegotiating the loc handle
+    mMsgTask->sendMsg(new LocSsrMsg(this));
+
+    LocDualContext::injectFeatureConfig(mContext);
+
+    // loop through adapters, and deliver to all adapters.
+    TO_ALL_LOCADAPTERS(mLocAdapters[i]->handleEngineUpEvent());
+}
+
+void LocApiBase::handleEngineDownEvent()
+{
+    // loop through adapters, and deliver to all adapters.
+    TO_ALL_LOCADAPTERS(mLocAdapters[i]->handleEngineDownEvent());
+}
+
+void LocApiBase::reportPosition(UlpLocation &location,
+                                GpsLocationExtended &locationExtended,
+                                void* locationExt,
+                                enum loc_sess_status status,
+                                LocPosTechMask loc_technology_mask)
+{
+    // loop through adapters, and deliver to all adapters.
+    TO_ALL_LOCADAPTERS(
+        mLocAdapters[i]->reportPosition(location,
+                                        locationExtended,
+                                        locationExt,
+                                        status,
+                                        loc_technology_mask)
+    );
+}
+
+void LocApiBase::reportSv(GpsSvStatus &svStatus,
+                  GpsLocationExtended &locationExtended,
+                  void* svExt)
+{
+    // loop through adapters, and deliver to all adapters.
+    TO_ALL_LOCADAPTERS(
+        mLocAdapters[i]->reportSv(svStatus,
+                                     locationExtended,
+                                     svExt)
+    );
+}
+
+void LocApiBase::reportStatus(GpsStatusValue status)
+{
+    // loop through adapters, and deliver to all adapters.
+    TO_ALL_LOCADAPTERS(mLocAdapters[i]->reportStatus(status));
+}
+
+void LocApiBase::reportNmea(const char* nmea, int length)
+{
+    // loop through adapters, and deliver to all adapters.
+    TO_ALL_LOCADAPTERS(mLocAdapters[i]->reportNmea(nmea, length));
+}
+
+void LocApiBase::reportXtraServer(const char* url1, const char* url2,
+                                  const char* url3, const int maxlength)
+{
+    // loop through adapters, and deliver to the first handling adapter.
+    TO_1ST_HANDLING_LOCADAPTERS(mLocAdapters[i]->reportXtraServer(url1, url2, url3, maxlength));
+
+}
+
+void LocApiBase::requestXtraData()
+{
+    // loop through adapters, and deliver to the first handling adapter.
+    TO_1ST_HANDLING_LOCADAPTERS(mLocAdapters[i]->requestXtraData());
+}
+
+void LocApiBase::requestTime()
+{
+    // loop through adapters, and deliver to the first handling adapter.
+    TO_1ST_HANDLING_LOCADAPTERS(mLocAdapters[i]->requestTime());
+}
+
+void LocApiBase::requestLocation()
+{
+    // loop through adapters, and deliver to the first handling adapter.
+    TO_1ST_HANDLING_LOCADAPTERS(mLocAdapters[i]->requestLocation());
+}
+
+void LocApiBase::requestATL(int connHandle, AGpsType agps_type)
+{
+    // loop through adapters, and deliver to the first handling adapter.
+    TO_1ST_HANDLING_LOCADAPTERS(mLocAdapters[i]->requestATL(connHandle, agps_type));
+}
+
+void LocApiBase::releaseATL(int connHandle)
+{
+    // loop through adapters, and deliver to the first handling adapter.
+    TO_1ST_HANDLING_LOCADAPTERS(mLocAdapters[i]->releaseATL(connHandle));
+}
+
+void LocApiBase::requestSuplES(int connHandle)
+{
+    // loop through adapters, and deliver to the first handling adapter.
+    TO_1ST_HANDLING_LOCADAPTERS(mLocAdapters[i]->requestSuplES(connHandle));
+}
+
+void LocApiBase::reportDataCallOpened()
+{
+    // loop through adapters, and deliver to the first handling adapter.
+    TO_1ST_HANDLING_LOCADAPTERS(mLocAdapters[i]->reportDataCallOpened());
+}
+
+void LocApiBase::reportDataCallClosed()
+{
+    // loop through adapters, and deliver to the first handling adapter.
+    TO_1ST_HANDLING_LOCADAPTERS(mLocAdapters[i]->reportDataCallClosed());
+}
+
+void LocApiBase::requestNiNotify(GpsNiNotification &notify, const void* data)
+{
+    // loop through adapters, and deliver to the first handling adapter.
+    TO_1ST_HANDLING_LOCADAPTERS(mLocAdapters[i]->requestNiNotify(notify, data));
+}
+
+void* LocApiBase :: getSibling()
+    DEFAULT_IMPL(NULL)
+
+LocApiProxyBase* LocApiBase :: getLocApiProxy()
+    DEFAULT_IMPL(NULL)
+
+void LocApiBase::reportGpsMeasurementData(GpsData &gpsMeasurementData)
+{
+    // loop through adapters, and deliver to all adapters.
+    TO_ALL_LOCADAPTERS(mLocAdapters[i]->reportGpsMeasurementData(gpsMeasurementData));
+}
+
+enum loc_api_adapter_err LocApiBase::
+   open(LOC_API_ADAPTER_EVENT_MASK_T mask)
+DEFAULT_IMPL(LOC_API_ADAPTER_ERR_SUCCESS)
+
+enum loc_api_adapter_err LocApiBase::
+    close()
+DEFAULT_IMPL(LOC_API_ADAPTER_ERR_SUCCESS)
+
+enum loc_api_adapter_err LocApiBase::
+    startFix(const LocPosMode& posMode)
+DEFAULT_IMPL(LOC_API_ADAPTER_ERR_SUCCESS)
+
+enum loc_api_adapter_err LocApiBase::
+    stopFix()
+DEFAULT_IMPL(LOC_API_ADAPTER_ERR_SUCCESS)
+
+enum loc_api_adapter_err LocApiBase::
+    deleteAidingData(GpsAidingData f)
+DEFAULT_IMPL(LOC_API_ADAPTER_ERR_SUCCESS)
+
+enum loc_api_adapter_err LocApiBase::
+    enableData(int enable)
+DEFAULT_IMPL(LOC_API_ADAPTER_ERR_SUCCESS)
+
+enum loc_api_adapter_err LocApiBase::
+    setAPN(char* apn, int len)
+DEFAULT_IMPL(LOC_API_ADAPTER_ERR_SUCCESS)
+
+enum loc_api_adapter_err LocApiBase::
+    injectPosition(double latitude, double longitude, float accuracy)
+DEFAULT_IMPL(LOC_API_ADAPTER_ERR_SUCCESS)
+
+enum loc_api_adapter_err LocApiBase::
+    setTime(GpsUtcTime time, int64_t timeReference, int uncertainty)
+DEFAULT_IMPL(LOC_API_ADAPTER_ERR_SUCCESS)
+
+enum loc_api_adapter_err LocApiBase::
+    setXtraData(char* data, int length)
+DEFAULT_IMPL(LOC_API_ADAPTER_ERR_SUCCESS)
+
+enum loc_api_adapter_err LocApiBase::
+    requestXtraServer()
+DEFAULT_IMPL(LOC_API_ADAPTER_ERR_SUCCESS)
+
+enum loc_api_adapter_err LocApiBase::
+   atlOpenStatus(int handle, int is_succ, char* apn,
+                 AGpsBearerType bear, AGpsType agpsType)
+DEFAULT_IMPL(LOC_API_ADAPTER_ERR_SUCCESS)
+
+enum loc_api_adapter_err LocApiBase::
+    atlCloseStatus(int handle, int is_succ)
+DEFAULT_IMPL(LOC_API_ADAPTER_ERR_SUCCESS)
+
+enum loc_api_adapter_err LocApiBase::
+    setPositionMode(const LocPosMode& posMode)
+DEFAULT_IMPL(LOC_API_ADAPTER_ERR_SUCCESS)
+
+enum loc_api_adapter_err LocApiBase::
+    setServer(const char* url, int len)
+DEFAULT_IMPL(LOC_API_ADAPTER_ERR_SUCCESS)
+
+enum loc_api_adapter_err LocApiBase::
+    setServer(unsigned int ip, int port,
+              LocServerType type)
+DEFAULT_IMPL(LOC_API_ADAPTER_ERR_SUCCESS)
+
+enum loc_api_adapter_err LocApiBase::
+    informNiResponse(GpsUserResponseType userResponse,
+                     const void* passThroughData)
+DEFAULT_IMPL(LOC_API_ADAPTER_ERR_SUCCESS)
+
+enum loc_api_adapter_err LocApiBase::
+    setSUPLVersion(uint32_t version)
+DEFAULT_IMPL(LOC_API_ADAPTER_ERR_SUCCESS)
+
+enum loc_api_adapter_err LocApiBase::
+    setLPPConfig(uint32_t profile)
+DEFAULT_IMPL(LOC_API_ADAPTER_ERR_SUCCESS)
+
+enum loc_api_adapter_err LocApiBase::
+    setSensorControlConfig(int sensorUsage,
+                           int sensorProvider)
+DEFAULT_IMPL(LOC_API_ADAPTER_ERR_SUCCESS)
+
+enum loc_api_adapter_err LocApiBase::
+    setSensorProperties(bool gyroBiasVarianceRandomWalk_valid,
+                        float gyroBiasVarianceRandomWalk,
+                        bool accelBiasVarianceRandomWalk_valid,
+                        float accelBiasVarianceRandomWalk,
+                        bool angleBiasVarianceRandomWalk_valid,
+                        float angleBiasVarianceRandomWalk,
+                        bool rateBiasVarianceRandomWalk_valid,
+                        float rateBiasVarianceRandomWalk,
+                        bool velocityBiasVarianceRandomWalk_valid,
+                        float velocityBiasVarianceRandomWalk)
+DEFAULT_IMPL(LOC_API_ADAPTER_ERR_SUCCESS)
+
+enum loc_api_adapter_err LocApiBase::
+    setSensorPerfControlConfig(int controlMode,
+                               int accelSamplesPerBatch,
+                               int accelBatchesPerSec,
+                               int gyroSamplesPerBatch,
+                               int gyroBatchesPerSec,
+                               int accelSamplesPerBatchHigh,
+                               int accelBatchesPerSecHigh,
+                               int gyroSamplesPerBatchHigh,
+                               int gyroBatchesPerSecHigh,
+                               int algorithmConfig)
+DEFAULT_IMPL(LOC_API_ADAPTER_ERR_SUCCESS)
+
+enum loc_api_adapter_err LocApiBase::
+    setExtPowerConfig(int isBatteryCharging)
+DEFAULT_IMPL(LOC_API_ADAPTER_ERR_SUCCESS)
+
+enum loc_api_adapter_err LocApiBase::
+    setAGLONASSProtocol(unsigned long aGlonassProtocol)
+DEFAULT_IMPL(LOC_API_ADAPTER_ERR_SUCCESS)
+
+enum loc_api_adapter_err LocApiBase::
+   getWwanZppFix(GpsLocation & zppLoc)
+DEFAULT_IMPL(LOC_API_ADAPTER_ERR_SUCCESS)
+
+enum loc_api_adapter_err LocApiBase::
+   getBestAvailableZppFix(GpsLocation & zppLoc)
+DEFAULT_IMPL(LOC_API_ADAPTER_ERR_SUCCESS)
+
+enum loc_api_adapter_err LocApiBase::
+   getBestAvailableZppFix(GpsLocation & zppLoc, LocPosTechMask & tech_mask)
+DEFAULT_IMPL(LOC_API_ADAPTER_ERR_SUCCESS)
+
+int LocApiBase::
+    initDataServiceClient()
+DEFAULT_IMPL(-1)
+
+int LocApiBase::
+    openAndStartDataCall()
+DEFAULT_IMPL(-1)
+
+void LocApiBase::
+    stopDataCall()
+DEFAULT_IMPL()
+
+void LocApiBase::
+    closeDataCall()
+DEFAULT_IMPL()
+
+int LocApiBase::
+    setGpsLock(LOC_GPS_LOCK_MASK lock)
+DEFAULT_IMPL(-1)
+
+void LocApiBase::
+    installAGpsCert(const DerEncodedCertificate* pData,
+                    size_t length,
+                    uint32_t slotBitMask)
+DEFAULT_IMPL()
+
+int LocApiBase::
+    getGpsLock()
+DEFAULT_IMPL(-1)
+
+int LocApiBase::
+    updateRegistrationMask(LOC_API_ADAPTER_EVENT_MASK_T event,
+                           loc_registration_mask_status isEnabled)
+DEFAULT_IMPL(-1)
+
+bool LocApiBase::
+    gnssConstellationConfig()
+DEFAULT_IMPL(false)
+
+} // namespace loc_core
diff --git a/msm8974/core/LocApiBase.h b/msm8974/core/LocApiBase.h
new file mode 100644
index 0000000..46950e6
--- /dev/null
+++ b/msm8974/core/LocApiBase.h
@@ -0,0 +1,242 @@
+/* Copyright (c) 2011-2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef LOC_API_BASE_H
+#define LOC_API_BASE_H
+
+#include <stddef.h>
+#include <ctype.h>
+#include <gps_extended.h>
+#include <MsgTask.h>
+#include <log_util.h>
+
+namespace loc_core {
+class ContextBase;
+
+int hexcode(char *hexstring, int string_size,
+            const char *data, int data_size);
+int decodeAddress(char *addr_string, int string_size,
+                  const char *data, int data_size);
+
+#define MAX_ADAPTERS          10
+
+#define TO_ALL_ADAPTERS(adapters, call)                                \
+    for (int i = 0; i < MAX_ADAPTERS && NULL != (adapters)[i]; i++) {  \
+        call;                                                          \
+    }
+
+#define TO_1ST_HANDLING_ADAPTER(adapters, call)                              \
+    for (int i = 0; i <MAX_ADAPTERS && NULL != (adapters)[i] && !(call); i++);
+
+class LocAdapterBase;
+struct LocSsrMsg;
+struct LocOpenMsg;
+
+class LocApiProxyBase {
+public:
+    inline LocApiProxyBase() {}
+    inline virtual ~LocApiProxyBase() {}
+    inline virtual void* getSibling2() { return NULL; }
+};
+
+class LocApiBase {
+    friend struct LocSsrMsg;
+    //LocOpenMsg calls open() which makes it necessary to declare
+    //it as a friend
+    friend struct LocOpenMsg;
+    friend class ContextBase;
+    const MsgTask* mMsgTask;
+    ContextBase *mContext;
+    LocAdapterBase* mLocAdapters[MAX_ADAPTERS];
+
+protected:
+    virtual enum loc_api_adapter_err
+        open(LOC_API_ADAPTER_EVENT_MASK_T mask);
+    virtual enum loc_api_adapter_err
+        close();
+    LOC_API_ADAPTER_EVENT_MASK_T getEvtMask();
+    LOC_API_ADAPTER_EVENT_MASK_T mMask;
+    LocApiBase(const MsgTask* msgTask,
+               LOC_API_ADAPTER_EVENT_MASK_T excludedMask,
+               ContextBase* context = NULL);
+    inline virtual ~LocApiBase() { close(); }
+    bool isInSession();
+    const LOC_API_ADAPTER_EVENT_MASK_T mExcludedMask;
+
+public:
+    inline void sendMsg(const LocMsg* msg) const {
+        mMsgTask->sendMsg(msg);
+    }
+
+    void addAdapter(LocAdapterBase* adapter);
+    void removeAdapter(LocAdapterBase* adapter);
+
+    // upward calls
+    void handleEngineUpEvent();
+    void handleEngineDownEvent();
+    void reportPosition(UlpLocation &location,
+                        GpsLocationExtended &locationExtended,
+                        void* locationExt,
+                        enum loc_sess_status status,
+                        LocPosTechMask loc_technology_mask =
+                                  LOC_POS_TECH_MASK_DEFAULT);
+    void reportSv(GpsSvStatus &svStatus,
+                  GpsLocationExtended &locationExtended,
+                  void* svExt);
+    void reportStatus(GpsStatusValue status);
+    void reportNmea(const char* nmea, int length);
+    void reportXtraServer(const char* url1, const char* url2,
+                          const char* url3, const int maxlength);
+    void requestXtraData();
+    void requestTime();
+    void requestLocation();
+    void requestATL(int connHandle, AGpsType agps_type);
+    void releaseATL(int connHandle);
+    void requestSuplES(int connHandle);
+    void reportDataCallOpened();
+    void reportDataCallClosed();
+    void requestNiNotify(GpsNiNotification &notify, const void* data);
+    void reportGpsMeasurementData(GpsData &gpsMeasurementData);
+
+    // downward calls
+    // All below functions are to be defined by adapter specific modules:
+    // RPC, QMI, etc.  The default implementation is empty.
+
+    virtual void* getSibling();
+    virtual LocApiProxyBase* getLocApiProxy();
+    virtual enum loc_api_adapter_err
+        startFix(const LocPosMode& posMode);
+    virtual enum loc_api_adapter_err
+        stopFix();
+    virtual enum loc_api_adapter_err
+        deleteAidingData(GpsAidingData f);
+    virtual enum loc_api_adapter_err
+        enableData(int enable);
+    virtual enum loc_api_adapter_err
+        setAPN(char* apn, int len);
+    virtual enum loc_api_adapter_err
+        injectPosition(double latitude, double longitude, float accuracy);
+    virtual enum loc_api_adapter_err
+        setTime(GpsUtcTime time, int64_t timeReference, int uncertainty);
+    virtual enum loc_api_adapter_err
+        setXtraData(char* data, int length);
+    virtual enum loc_api_adapter_err
+        requestXtraServer();
+    virtual enum loc_api_adapter_err
+        atlOpenStatus(int handle, int is_succ, char* apn, AGpsBearerType bear, AGpsType agpsType);
+    virtual enum loc_api_adapter_err
+        atlCloseStatus(int handle, int is_succ);
+    virtual enum loc_api_adapter_err
+        setPositionMode(const LocPosMode& posMode);
+    virtual enum loc_api_adapter_err
+        setServer(const char* url, int len);
+    virtual enum loc_api_adapter_err
+        setServer(unsigned int ip, int port,
+                  LocServerType type);
+    virtual enum loc_api_adapter_err
+        informNiResponse(GpsUserResponseType userResponse, const void* passThroughData);
+    virtual enum loc_api_adapter_err
+        setSUPLVersion(uint32_t version);
+    virtual enum loc_api_adapter_err
+        setLPPConfig(uint32_t profile);
+    virtual enum loc_api_adapter_err
+        setSensorControlConfig(int sensorUsage, int sensorProvider);
+    virtual enum loc_api_adapter_err
+        setSensorProperties(bool gyroBiasVarianceRandomWalk_valid,
+                            float gyroBiasVarianceRandomWalk,
+                            bool accelBiasVarianceRandomWalk_valid,
+                            float accelBiasVarianceRandomWalk,
+                            bool angleBiasVarianceRandomWalk_valid,
+                            float angleBiasVarianceRandomWalk,
+                            bool rateBiasVarianceRandomWalk_valid,
+                            float rateBiasVarianceRandomWalk,
+                            bool velocityBiasVarianceRandomWalk_valid,
+                            float velocityBiasVarianceRandomWalk);
+    virtual enum loc_api_adapter_err
+        setSensorPerfControlConfig(int controlMode,
+                               int accelSamplesPerBatch,
+                               int accelBatchesPerSec,
+                               int gyroSamplesPerBatch,
+                               int gyroBatchesPerSec,
+                               int accelSamplesPerBatchHigh,
+                               int accelBatchesPerSecHigh,
+                               int gyroSamplesPerBatchHigh,
+                               int gyroBatchesPerSecHigh,
+                               int algorithmConfig);
+    virtual enum loc_api_adapter_err
+        setExtPowerConfig(int isBatteryCharging);
+    virtual enum loc_api_adapter_err
+        setAGLONASSProtocol(unsigned long aGlonassProtocol);
+    virtual enum loc_api_adapter_err
+        getWwanZppFix(GpsLocation & zppLoc);
+    virtual enum loc_api_adapter_err
+        getBestAvailableZppFix(GpsLocation & zppLoc);
+    virtual enum loc_api_adapter_err
+        getBestAvailableZppFix(GpsLocation & zppLoc, LocPosTechMask & tech_mask);
+    virtual int initDataServiceClient();
+    virtual int openAndStartDataCall();
+    virtual void stopDataCall();
+    virtual void closeDataCall();
+    virtual void installAGpsCert(const DerEncodedCertificate* pData,
+                                 size_t length,
+                                 uint32_t slotBitMask);
+
+    inline virtual void setInSession(bool inSession) {}
+
+    /*Values for lock
+      1 = Do not lock any position sessions
+      2 = Lock MI position sessions
+      3 = Lock MT position sessions
+      4 = Lock all position sessions
+     */
+    virtual int setGpsLock(LOC_GPS_LOCK_MASK lock);
+    /*
+      Returns
+      Current value of GPS Lock on success
+      -1 on failure
+     */
+    virtual int getGpsLock(void);
+
+    /*
+      Update gps reporting events
+     */
+    virtual int updateRegistrationMask(LOC_API_ADAPTER_EVENT_MASK_T event,
+                                       loc_registration_mask_status isEnabled);
+    /*
+      Check if the modem support the service
+     */
+    virtual bool gnssConstellationConfig();
+};
+
+typedef LocApiBase* (getLocApi_t)(const MsgTask* msgTask,
+                                  LOC_API_ADAPTER_EVENT_MASK_T exMask,
+                                  ContextBase *context);
+
+} // namespace loc_core
+
+#endif //LOC_API_BASE_H
diff --git a/msm8974/core/LocDualContext.cpp b/msm8974/core/LocDualContext.cpp
new file mode 100644
index 0000000..41ad4f0
--- /dev/null
+++ b/msm8974/core/LocDualContext.cpp
@@ -0,0 +1,165 @@
+/* Copyright (c) 2011-2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#define LOG_NDDEBUG 0
+#define LOG_TAG "LocSvc_DualCtx"
+
+#include <cutils/sched_policy.h>
+#include <unistd.h>
+#include <LocDualContext.h>
+#include <msg_q.h>
+#include <log_util.h>
+#include <loc_log.h>
+
+namespace loc_core {
+
+// nothing exclude for foreground
+const LOC_API_ADAPTER_EVENT_MASK_T
+LocDualContext::mFgExclMask = 0;
+// excluded events for background clients
+const LOC_API_ADAPTER_EVENT_MASK_T
+LocDualContext::mBgExclMask =
+    (LOC_API_ADAPTER_BIT_PARSED_POSITION_REPORT |
+     LOC_API_ADAPTER_BIT_SATELLITE_REPORT |
+     LOC_API_ADAPTER_BIT_NMEA_1HZ_REPORT |
+     LOC_API_ADAPTER_BIT_NMEA_POSITION_REPORT |
+     LOC_API_ADAPTER_BIT_IOCTL_REPORT |
+     LOC_API_ADAPTER_BIT_STATUS_REPORT |
+     LOC_API_ADAPTER_BIT_GEOFENCE_GEN_ALERT |
+     LOC_API_ADAPTER_BIT_GNSS_MEASUREMENT);
+
+const MsgTask* LocDualContext::mMsgTask = NULL;
+ContextBase* LocDualContext::mFgContext = NULL;
+ContextBase* LocDualContext::mBgContext = NULL;
+ContextBase* LocDualContext::mInjectContext = NULL;
+// the name must be shorter than 15 chars
+const char* LocDualContext::mLocationHalName = "Loc_hal_worker";
+const char* LocDualContext::mLBSLibName = "liblbs_core.so";
+
+const MsgTask* LocDualContext::getMsgTask(MsgTask::tCreate tCreator,
+                                          const char* name)
+{
+    if (NULL == mMsgTask) {
+        mMsgTask = new MsgTask(tCreator, name);
+    }
+    return mMsgTask;
+}
+
+const MsgTask* LocDualContext::getMsgTask(MsgTask::tAssociate tAssociate,
+                                          const char* name)
+{
+    if (NULL == mMsgTask) {
+        mMsgTask = new MsgTask(tAssociate, name);
+    } else if (tAssociate) {
+        mMsgTask->associate(tAssociate);
+    }
+    return mMsgTask;
+}
+
+ContextBase* LocDualContext::getLocFgContext(MsgTask::tCreate tCreator,
+                                             const char* name)
+{
+    if (NULL == mFgContext) {
+        const MsgTask* msgTask = getMsgTask(tCreator, name);
+        mFgContext = new LocDualContext(msgTask,
+                                        mFgExclMask);
+    }
+    if(NULL == mInjectContext) {
+        mInjectContext = mFgContext;
+        injectFeatureConfig(mInjectContext);
+    }
+    return mFgContext;
+}
+
+ContextBase* LocDualContext::getLocFgContext(MsgTask::tAssociate tAssociate,
+                                        const char* name)
+{
+    if (NULL == mFgContext) {
+        const MsgTask* msgTask = getMsgTask(tAssociate, name);
+        mFgContext = new LocDualContext(msgTask,
+                                        mFgExclMask);
+    }
+    if(NULL == mInjectContext) {
+        LOC_LOGD("%s:%d]: mInjectContext is FgContext", __func__, __LINE__);
+        mInjectContext = mFgContext;
+        injectFeatureConfig(mInjectContext);
+    }
+    return mFgContext;
+
+}
+
+ContextBase* LocDualContext::getLocBgContext(MsgTask::tCreate tCreator,
+                                             const char* name)
+{
+    if (NULL == mBgContext) {
+        const MsgTask* msgTask = getMsgTask(tCreator, name);
+        mBgContext = new LocDualContext(msgTask,
+                                        mBgExclMask);
+    }
+    if(NULL == mInjectContext) {
+        LOC_LOGD("%s:%d]: mInjectContext is BgContext", __func__, __LINE__);
+        mInjectContext = mBgContext;
+        injectFeatureConfig(mInjectContext);
+    }
+    return mBgContext;
+}
+
+ContextBase* LocDualContext::getLocBgContext(MsgTask::tAssociate tAssociate,
+                                             const char* name)
+{
+    if (NULL == mBgContext) {
+        const MsgTask* msgTask = getMsgTask(tAssociate, name);
+        mBgContext = new LocDualContext(msgTask,
+                                        mBgExclMask);
+    }
+    if(NULL == mInjectContext) {
+        LOC_LOGD("%s:%d]: mInjectContext is BgContext", __func__, __LINE__);
+        mInjectContext = mBgContext;
+        injectFeatureConfig(mInjectContext);
+    }
+    return mBgContext;
+}
+
+void LocDualContext :: injectFeatureConfig(ContextBase *curContext)
+{
+    LOC_LOGD("%s:%d]: Enter", __func__, __LINE__);
+    if(curContext == mInjectContext) {
+        LOC_LOGD("%s:%d]: Calling LBSProxy (%p) to inject feature config",
+                 __func__, __LINE__, ((LocDualContext *)mInjectContext)->mLBSProxy);
+        ((LocDualContext *)mInjectContext)->mLBSProxy->injectFeatureConfig(curContext);
+    }
+    LOC_LOGD("%s:%d]: Exit", __func__, __LINE__);
+}
+
+LocDualContext::LocDualContext(const MsgTask* msgTask,
+                               LOC_API_ADAPTER_EVENT_MASK_T exMask) :
+    ContextBase(msgTask, exMask, mLBSLibName)
+{
+}
+
+}
diff --git a/msm8974/core/LocDualContext.h b/msm8974/core/LocDualContext.h
new file mode 100644
index 0000000..cdc4df3
--- /dev/null
+++ b/msm8974/core/LocDualContext.h
@@ -0,0 +1,73 @@
+/* Copyright (c) 2011-2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef __LOC_ENG_CONTEXT__
+#define __LOC_ENG_CONTEXT__
+
+#include <stdbool.h>
+#include <ctype.h>
+#include <dlfcn.h>
+#include <ContextBase.h>
+
+namespace loc_core {
+
+class LocDualContext : public ContextBase {
+    static const MsgTask* mMsgTask;
+    static ContextBase* mFgContext;
+    static ContextBase* mBgContext;
+    static ContextBase* mInjectContext;
+    static const MsgTask* getMsgTask(MsgTask::tCreate tCreator,
+                                     const char* name);
+    static const MsgTask* getMsgTask(MsgTask::tAssociate tAssociate,
+                                     const char* name);
+
+protected:
+    LocDualContext(const MsgTask* msgTask,
+                   LOC_API_ADAPTER_EVENT_MASK_T exMask);
+    inline virtual ~LocDualContext() {}
+
+public:
+    static const char* mLBSLibName;
+    static const LOC_API_ADAPTER_EVENT_MASK_T mFgExclMask;
+    static const LOC_API_ADAPTER_EVENT_MASK_T mBgExclMask;
+    static const char* mLocationHalName;
+
+    static ContextBase* getLocFgContext(MsgTask::tCreate tCreator,
+                                        const char* name);
+    static ContextBase* getLocFgContext(MsgTask::tAssociate tAssociate,
+                                        const char* name);
+    static ContextBase* getLocBgContext(MsgTask::tCreate tCreator,
+                                        const char* name);
+    static ContextBase* getLocBgContext(MsgTask::tAssociate tAssociate,
+                                        const char* name);
+    static void injectFeatureConfig(ContextBase *context);
+};
+
+}
+
+#endif //__LOC_ENG_CONTEXT__
diff --git a/msm8974/core/MsgTask.cpp b/msm8974/core/MsgTask.cpp
new file mode 100644
index 0000000..5d375aa
--- /dev/null
+++ b/msm8974/core/MsgTask.cpp
@@ -0,0 +1,147 @@
+/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#define LOG_NDDEBUG 0
+#define LOG_TAG "LocSvc_MsgTask"
+
+#include <cutils/sched_policy.h>
+#include <unistd.h>
+#include <MsgTask.h>
+#include <msg_q.h>
+#include <log_util.h>
+#include <loc_log.h>
+
+namespace loc_core {
+
+#define MAX_TASK_COMM_LEN 15
+
+static void LocMsgDestroy(void* msg) {
+    delete (LocMsg*)msg;
+}
+
+MsgTask::MsgTask(tCreate tCreator, const char* threadName) :
+    mQ(msg_q_init2()), mAssociator(NULL){
+    if (tCreator) {
+        tCreator(threadName, loopMain,
+                 (void*)new MsgTask(mQ, mAssociator));
+    } else {
+        createPThread(threadName);
+    }
+}
+
+MsgTask::MsgTask(tAssociate tAssociator, const char* threadName) :
+    mQ(msg_q_init2()), mAssociator(tAssociator){
+    createPThread(threadName);
+}
+
+inline
+MsgTask::MsgTask(const void* q, tAssociate associator) :
+    mQ(q), mAssociator(associator){
+}
+
+MsgTask::~MsgTask() {
+    msg_q_unblock((void*)mQ);
+}
+
+void MsgTask::associate(tAssociate tAssociator) const {
+    struct LocAssociateMsg : public LocMsg {
+        tAssociate mAssociator;
+        inline LocAssociateMsg(tAssociate associator) :
+            LocMsg(), mAssociator(associator) {}
+        inline virtual void proc() const {
+            if (mAssociator) {
+                LOC_LOGD("MsgTask::associate");
+                mAssociator();
+            }
+        }
+    };
+    sendMsg(new LocAssociateMsg(tAssociator));
+}
+
+void MsgTask::createPThread(const char* threadName) {
+    pthread_attr_t attr;
+    pthread_attr_init(&attr);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+
+    pthread_t tid;
+    // create the thread here, then if successful
+    // and a name is given, we set the thread name
+    if (!pthread_create(&tid, &attr, loopMain,
+                        (void*)new MsgTask(mQ, mAssociator)) &&
+        NULL != threadName) {
+        char lname[MAX_TASK_COMM_LEN+1];
+        memcpy(lname, threadName, MAX_TASK_COMM_LEN);
+        lname[MAX_TASK_COMM_LEN] = 0;
+        pthread_setname_np(tid, lname);
+    }
+}
+
+void MsgTask::sendMsg(const LocMsg* msg) const {
+    msg_q_snd((void*)mQ, (void*)msg, LocMsgDestroy);
+}
+
+void* MsgTask::loopMain(void* arg) {
+    MsgTask* copy = (MsgTask*)arg;
+
+    // make sure we do not run in background scheduling group
+    set_sched_policy(gettid(), SP_FOREGROUND);
+
+    if (NULL != copy->mAssociator) {
+        copy->mAssociator();
+    }
+
+    LocMsg* msg;
+    int cnt = 0;
+
+    while (1) {
+        LOC_LOGD("MsgTask::loop() %d listening ...\n", cnt++);
+
+        msq_q_err_type result = msg_q_rcv((void*)copy->mQ, (void **)&msg);
+
+        if (eMSG_Q_SUCCESS != result) {
+            LOC_LOGE("%s:%d] fail receiving msg: %s\n", __func__, __LINE__,
+                     loc_get_msg_q_status(result));
+            // destroy the Q and exit
+            msg_q_destroy((void**)&(copy->mQ));
+            delete copy;
+            return NULL;
+        }
+
+        msg->log();
+        // there is where each individual msg handling is invoked
+        msg->proc();
+
+        delete msg;
+    }
+
+    delete copy;
+
+    return NULL;
+}
+
+}
diff --git a/msm8974/core/MsgTask.h b/msm8974/core/MsgTask.h
new file mode 100644
index 0000000..d50bb31
--- /dev/null
+++ b/msm8974/core/MsgTask.h
@@ -0,0 +1,67 @@
+/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef __MSG_TASK__
+#define __MSG_TASK__
+
+#include <stdbool.h>
+#include <ctype.h>
+#include <string.h>
+#include <pthread.h>
+
+namespace loc_core {
+
+struct LocMsg {
+    inline LocMsg() {}
+    inline virtual ~LocMsg() {}
+    virtual void proc() const = 0;
+    inline virtual void log() const {}
+};
+
+class MsgTask {
+public:
+    typedef void* (*tStart)(void*);
+    typedef pthread_t (*tCreate)(const char* name, tStart start, void* arg);
+    typedef int (*tAssociate)();
+    MsgTask(tCreate tCreator, const char* threadName);
+    MsgTask(tAssociate tAssociator, const char* threadName);
+    ~MsgTask();
+    void sendMsg(const LocMsg* msg) const;
+    void associate(tAssociate tAssociator) const;
+
+private:
+    const void* mQ;
+    tAssociate mAssociator;
+    MsgTask(const void* q, tAssociate associator);
+    static void* loopMain(void* copy);
+    void createPThread(const char* name);
+};
+
+} // namespace loc_core
+
+#endif //__MSG_TASK__
diff --git a/msm8974/core/UlpProxyBase.h b/msm8974/core/UlpProxyBase.h
new file mode 100644
index 0000000..b9a8224
--- /dev/null
+++ b/msm8974/core/UlpProxyBase.h
@@ -0,0 +1,85 @@
+/* Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef ULP_PROXY_BASE_H
+#define ULP_PROXY_BASE_H
+
+#include <gps_extended.h>
+
+namespace loc_core {
+
+class LocAdapterBase;
+
+class UlpProxyBase {
+public:
+    LocPosMode mPosMode;
+    bool mFixSet;
+    inline UlpProxyBase() {
+        mPosMode.mode = LOC_POSITION_MODE_INVALID;
+        mFixSet = false;
+    }
+    inline virtual ~UlpProxyBase() {}
+    inline virtual bool sendStartFix() { mFixSet = true; return false; }
+    inline virtual bool sendStopFix() { mFixSet = false; return false; }
+    inline virtual bool sendFixMode(LocPosMode &params) {
+        mPosMode = params;
+        return false;
+    }
+
+    inline virtual bool reportPosition(UlpLocation &location,
+                                       GpsLocationExtended &locationExtended,
+                                       void* locationExt,
+                                       enum loc_sess_status status,
+                                       LocPosTechMask loc_technology_mask) {
+        return false;
+    }
+    inline virtual bool reportSv(GpsSvStatus &svStatus,
+                                 GpsLocationExtended &locationExtended,
+                                 void* svExt) {
+        return false;
+    }
+    inline virtual bool reportStatus(GpsStatusValue status) {
+        return false;
+    }
+    inline virtual void setAdapter(LocAdapterBase* adapter) {}
+    inline virtual void setCapabilities(unsigned long capabilities) {}
+    inline virtual bool reportBatchingSession(GpsExtBatchOptions &options,
+                                              bool active) {
+        return false;
+    }
+    inline virtual bool reportPositions(GpsExtLocation * locations,
+                                        int32_t number_of_locations,
+                                        enum loc_sess_status status,
+                                        LocPosTechMask techMask) {
+        return false;
+    }
+};
+
+} // namespace loc_core
+
+#endif // ULP_PROXY_BASE_H
diff --git a/msm8974/core/gps_extended.h b/msm8974/core/gps_extended.h
new file mode 100644
index 0000000..88b0415
--- /dev/null
+++ b/msm8974/core/gps_extended.h
@@ -0,0 +1,92 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef GPS_EXTENDED_H
+#define GPS_EXTENDED_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#include <gps_extended_c.h>
+
+struct LocPosMode
+{
+    LocPositionMode mode;
+    GpsPositionRecurrence recurrence;
+    uint32_t min_interval;
+    uint32_t preferred_accuracy;
+    uint32_t preferred_time;
+    char credentials[14];
+    char provider[8];
+    LocPosMode(LocPositionMode m, GpsPositionRecurrence recr,
+               uint32_t gap, uint32_t accu, uint32_t time,
+               const char* cred, const char* prov) :
+        mode(m), recurrence(recr),
+        min_interval(gap < MIN_POSSIBLE_FIX_INTERVAL ? MIN_POSSIBLE_FIX_INTERVAL : gap),
+        preferred_accuracy(accu), preferred_time(time) {
+        memset(credentials, 0, sizeof(credentials));
+        memset(provider, 0, sizeof(provider));
+        if (NULL != cred) {
+            memcpy(credentials, cred, sizeof(credentials)-1);
+        }
+        if (NULL != prov) {
+            memcpy(provider, prov, sizeof(provider)-1);
+        }
+    }
+
+    inline LocPosMode() :
+        mode(LOC_POSITION_MODE_MS_BASED),
+        recurrence(GPS_POSITION_RECURRENCE_PERIODIC),
+        min_interval(MIN_POSSIBLE_FIX_INTERVAL),
+        preferred_accuracy(50), preferred_time(120000) {
+        memset(credentials, 0, sizeof(credentials));
+        memset(provider, 0, sizeof(provider));
+    }
+
+    inline bool equals(const LocPosMode &anotherMode) const
+    {
+        return anotherMode.mode == mode &&
+            anotherMode.recurrence == recurrence &&
+            anotherMode.min_interval == min_interval &&
+            anotherMode.preferred_accuracy == preferred_accuracy &&
+            anotherMode.preferred_time == preferred_time &&
+            !strncmp(anotherMode.credentials, credentials, sizeof(credentials)-1) &&
+            !strncmp(anotherMode.provider, provider, sizeof(provider)-1);
+    }
+
+    void logv() const;
+};
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* GPS_EXTENDED_H */
+
diff --git a/msm8974/core/gps_extended_c.h b/msm8974/core/gps_extended_c.h
new file mode 100644
index 0000000..b62e0ea
--- /dev/null
+++ b/msm8974/core/gps_extended_c.h
@@ -0,0 +1,399 @@
+/* Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef GPS_EXTENDED_C_H
+#define GPS_EXTENDED_C_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#include <ctype.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <string.h>
+#include <hardware/gps.h>
+
+/** Location has valid source information. */
+#define LOCATION_HAS_SOURCE_INFO   0x0020
+/** GpsLocation has valid "is indoor?" flag */
+#define GPS_LOCATION_HAS_IS_INDOOR   0x0040
+/** GpsLocation has valid floor number */
+#define GPS_LOCATION_HAS_FLOOR_NUMBER   0x0080
+/** GpsLocation has valid map URL*/
+#define GPS_LOCATION_HAS_MAP_URL   0x0100
+/** GpsLocation has valid map index */
+#define GPS_LOCATION_HAS_MAP_INDEX   0x0200
+
+/** Sizes for indoor fields */
+#define GPS_LOCATION_MAP_URL_SIZE 400
+#define GPS_LOCATION_MAP_INDEX_SIZE 16
+
+/** Position source is ULP */
+#define ULP_LOCATION_IS_FROM_HYBRID   0x0001
+/** Position source is GNSS only */
+#define ULP_LOCATION_IS_FROM_GNSS     0x0002
+/** Position source is ZPP only */
+#define ULP_LOCATION_IS_FROM_ZPP      0x0004
+/** Position is from a Geofence Breach Event */
+#define ULP_LOCATION_IS_FROM_GEOFENCE 0X0008
+/** Positioin is from Hardware FLP */
+#define ULP_LOCATION_IS_FROM_HW_FLP   0x0010
+
+#define ULP_MIN_INTERVAL_INVALID 0xffffffff
+
+/*Emergency SUPL*/
+#define GPS_NI_TYPE_EMERGENCY_SUPL    4
+
+#define AGPS_CERTIFICATE_MAX_LENGTH 2000
+#define AGPS_CERTIFICATE_MAX_SLOTS 10
+
+enum loc_registration_mask_status {
+    LOC_REGISTRATION_MASK_ENABLED,
+    LOC_REGISTRATION_MASK_DISABLED
+};
+
+typedef struct {
+    /** set to sizeof(UlpLocation) */
+    size_t          size;
+    GpsLocation     gpsLocation;
+    /* Provider indicator for HYBRID or GPS */
+    uint16_t        position_source;
+    /*allows HAL to pass additional information related to the location */
+    int             rawDataSize;         /* in # of bytes */
+    void            * rawData;
+    bool            is_indoor;
+    float           floor_number;
+    char            map_url[GPS_LOCATION_MAP_URL_SIZE];
+    unsigned char   map_index[GPS_LOCATION_MAP_INDEX_SIZE];
+} UlpLocation;
+
+/** AGPS type */
+typedef int16_t AGpsExtType;
+#define AGPS_TYPE_INVALID       -1
+#define AGPS_TYPE_ANY           0
+#define AGPS_TYPE_SUPL          1
+#define AGPS_TYPE_C2K           2
+#define AGPS_TYPE_WWAN_ANY      3
+#define AGPS_TYPE_WIFI          4
+#define AGPS_TYPE_SUPL_ES       5
+
+/** SSID length */
+#define SSID_BUF_SIZE (32+1)
+
+typedef int16_t AGpsBearerType;
+#define AGPS_APN_BEARER_INVALID    -1
+#define AGPS_APN_BEARER_IPV4        0
+#define AGPS_APN_BEARER_IPV6        1
+#define AGPS_APN_BEARER_IPV4V6      2
+
+#define GPS_DELETE_ALMANAC_CORR     0x00001000
+#define GPS_DELETE_FREQ_BIAS_EST    0x00002000
+#define GPS_DELETE_EPHEMERIS_GLO    0x00004000
+#define GPS_DELETE_ALMANAC_GLO      0x00008000
+#define GPS_DELETE_SVDIR_GLO        0x00010000
+#define GPS_DELETE_SVSTEER_GLO      0x00020000
+#define GPS_DELETE_ALMANAC_CORR_GLO 0x00040000
+#define GPS_DELETE_TIME_GPS         0x00080000
+#define GPS_DELETE_TIME_GLO         0x00100000
+
+/** GPS extended callback structure. */
+typedef struct {
+    /** set to sizeof(GpsCallbacks) */
+    size_t      size;
+    gps_set_capabilities set_capabilities_cb;
+    gps_acquire_wakelock acquire_wakelock_cb;
+    gps_release_wakelock release_wakelock_cb;
+    gps_create_thread create_thread_cb;
+    gps_request_utc_time request_utc_time_cb;
+} GpsExtCallbacks;
+
+/** GPS extended batch options */
+typedef struct {
+    double max_power_allocation_mW;
+    uint32_t sources_to_use;
+    uint32_t flags;
+    int64_t period_ns;
+} GpsExtBatchOptions;
+
+/** Callback to report the xtra server url to the client.
+ *  The client should use this url when downloading xtra unless overwritten
+ *  in the gps.conf file
+ */
+typedef void (* report_xtra_server)(const char*, const char*, const char*);
+
+/** Callback structure for the XTRA interface. */
+typedef struct {
+    gps_xtra_download_request download_request_cb;
+    gps_create_thread create_thread_cb;
+    report_xtra_server report_xtra_server_cb;
+} GpsXtraExtCallbacks;
+
+/** Represents the status of AGPS. */
+typedef struct {
+    /** set to sizeof(AGpsExtStatus) */
+    size_t          size;
+
+    AGpsExtType type;
+    AGpsStatusValue status;
+    uint32_t        ipv4_addr;
+    struct sockaddr_storage addr;
+    char            ssid[SSID_BUF_SIZE];
+    char            password[SSID_BUF_SIZE];
+} AGpsExtStatus;
+
+/** Callback with AGPS status information.
+ *  Can only be called from a thread created by create_thread_cb.
+ */
+typedef void (* agps_status_extended)(AGpsExtStatus* status);
+
+/** Callback structure for the AGPS interface. */
+typedef struct {
+    agps_status_extended status_cb;
+    gps_create_thread create_thread_cb;
+} AGpsExtCallbacks;
+
+
+/** GPS NI callback structure. */
+typedef struct
+{
+    /**
+     * Sends the notification request from HAL to GPSLocationProvider.
+     */
+    gps_ni_notify_callback notify_cb;
+    gps_create_thread create_thread_cb;
+} GpsNiExtCallbacks;
+
+typedef enum loc_server_type {
+    LOC_AGPS_CDMA_PDE_SERVER,
+    LOC_AGPS_CUSTOM_PDE_SERVER,
+    LOC_AGPS_MPC_SERVER,
+    LOC_AGPS_SUPL_SERVER
+} LocServerType;
+
+typedef enum loc_position_mode_type {
+    LOC_POSITION_MODE_INVALID = -1,
+    LOC_POSITION_MODE_STANDALONE = 0,
+    LOC_POSITION_MODE_MS_BASED,
+    LOC_POSITION_MODE_MS_ASSISTED,
+    LOC_POSITION_MODE_RESERVED_1,
+    LOC_POSITION_MODE_RESERVED_2,
+    LOC_POSITION_MODE_RESERVED_3,
+    LOC_POSITION_MODE_RESERVED_4,
+    LOC_POSITION_MODE_RESERVED_5
+
+} LocPositionMode;
+
+#define MIN_POSSIBLE_FIX_INTERVAL 1000 /* msec */
+
+/** GpsLocationExtended has valid latitude and longitude. */
+#define GPS_LOCATION_EXTENDED_HAS_LAT_LONG   (1U<<0)
+/** GpsLocationExtended has valid altitude. */
+#define GPS_LOCATION_EXTENDED_HAS_ALTITUDE   (1U<<1)
+/** GpsLocationExtended has valid speed. */
+#define GPS_LOCATION_EXTENDED_HAS_SPEED      (1U<<2)
+/** GpsLocationExtended has valid bearing. */
+#define GPS_LOCATION_EXTENDED_HAS_BEARING    (1U<<4)
+/** GpsLocationExtended has valid accuracy. */
+#define GPS_LOCATION_EXTENDED_HAS_ACCURACY   (1U<<8)
+
+/** GPS extended supports geofencing */
+#define GPS_EXTENDED_CAPABILITY_GEOFENCE     0x0000001
+/** GPS extended supports batching */
+#define GPS_EXTENDED_CAPABILITY_BATCHING     0x0000002
+
+/** Flags to indicate which values are valid in a GpsLocationExtended. */
+typedef uint16_t GpsLocationExtendedFlags;
+/** GpsLocationExtended has valid pdop, hdop, vdop. */
+#define GPS_LOCATION_EXTENDED_HAS_DOP 0x0001
+/** GpsLocationExtended has valid altitude mean sea level. */
+#define GPS_LOCATION_EXTENDED_HAS_ALTITUDE_MEAN_SEA_LEVEL 0x0002
+/** UlpLocation has valid magnetic deviation. */
+#define GPS_LOCATION_EXTENDED_HAS_MAG_DEV 0x0004
+/** UlpLocation has valid mode indicator. */
+#define GPS_LOCATION_EXTENDED_HAS_MODE_IND 0x0008
+/** GpsLocationExtended has valid vertical uncertainty */
+#define GPS_LOCATION_EXTENDED_HAS_VERT_UNC 0x0010
+/** GpsLocationExtended has valid speed uncertainty */
+#define GPS_LOCATION_EXTENDED_HAS_SPEED_UNC 0x0020
+
+/** Represents gps location extended. */
+typedef struct {
+    /** set to sizeof(GpsLocationExtended) */
+    size_t          size;
+    /** Contains GpsLocationExtendedFlags bits. */
+    uint16_t        flags;
+    /** Contains the Altitude wrt mean sea level */
+    float           altitudeMeanSeaLevel;
+    /** Contains Position Dilusion of Precision. */
+    float           pdop;
+    /** Contains Horizontal Dilusion of Precision. */
+    float           hdop;
+    /** Contains Vertical Dilusion of Precision. */
+    float           vdop;
+    /** Contains Magnetic Deviation. */
+    float           magneticDeviation;
+    /** vertical uncertainty in meters */
+    float           vert_unc;
+    /** speed uncertainty in m/s */
+    float           speed_unc;
+} GpsLocationExtended;
+
+typedef struct GpsExtLocation_s {
+    size_t          size;
+    uint16_t        flags;
+    double          latitude;
+    double          longitude;
+    double          altitude;
+    float           speed;
+    float           bearing;
+    float           accuracy;
+    int64_t         timestamp;
+    uint32_t        sources_used;
+} GpsExtLocation;
+
+enum loc_sess_status {
+    LOC_SESS_SUCCESS,
+    LOC_SESS_INTERMEDIATE,
+    LOC_SESS_FAILURE
+};
+
+typedef uint32_t LocPosTechMask;
+#define LOC_POS_TECH_MASK_DEFAULT ((LocPosTechMask)0x00000000)
+#define LOC_POS_TECH_MASK_SATELLITE ((LocPosTechMask)0x00000001)
+#define LOC_POS_TECH_MASK_CELLID ((LocPosTechMask)0x00000002)
+#define LOC_POS_TECH_MASK_WIFI ((LocPosTechMask)0x00000004)
+#define LOC_POS_TECH_MASK_SENSORS ((LocPosTechMask)0x00000008)
+#define LOC_POS_TECH_MASK_REFERENCE_LOCATION ((LocPosTechMask)0x00000010)
+#define LOC_POS_TECH_MASK_INJECTED_COARSE_POSITION ((LocPosTechMask)0x00000020)
+#define LOC_POS_TECH_MASK_AFLT ((LocPosTechMask)0x00000040)
+#define LOC_POS_TECH_MASK_HYBRID ((LocPosTechMask)0x00000080)
+
+typedef enum {
+  LOC_ENG_IF_REQUEST_SENDER_ID_QUIPC = 0,
+  LOC_ENG_IF_REQUEST_SENDER_ID_MSAPM,
+  LOC_ENG_IF_REQUEST_SENDER_ID_MSAPU,
+  LOC_ENG_IF_REQUEST_SENDER_ID_GPSONE_DAEMON,
+  LOC_ENG_IF_REQUEST_SENDER_ID_MODEM,
+  LOC_ENG_IF_REQUEST_SENDER_ID_UNKNOWN
+} loc_if_req_sender_id_e_type;
+
+
+#define smaller_of(a, b) (((a) > (b)) ? (b) : (a))
+#define MAX_APN_LEN 100
+
+// This will be overridden by the individual adapters
+// if necessary.
+#define DEFAULT_IMPL(rtv)                                     \
+{                                                             \
+    LOC_LOGD("%s: default implementation invoked", __func__); \
+    return rtv;                                               \
+}
+
+enum loc_api_adapter_err {
+    LOC_API_ADAPTER_ERR_SUCCESS             = 0,
+    LOC_API_ADAPTER_ERR_GENERAL_FAILURE     = 1,
+    LOC_API_ADAPTER_ERR_UNSUPPORTED         = 2,
+    LOC_API_ADAPTER_ERR_INVALID_HANDLE      = 4,
+    LOC_API_ADAPTER_ERR_INVALID_PARAMETER   = 5,
+    LOC_API_ADAPTER_ERR_ENGINE_BUSY         = 6,
+    LOC_API_ADAPTER_ERR_PHONE_OFFLINE       = 7,
+    LOC_API_ADAPTER_ERR_TIMEOUT             = 8,
+    LOC_API_ADAPTER_ERR_SERVICE_NOT_PRESENT = 9,
+
+    LOC_API_ADAPTER_ERR_ENGINE_DOWN         = 100,
+    LOC_API_ADAPTER_ERR_FAILURE,
+    LOC_API_ADAPTER_ERR_UNKNOWN
+};
+
+enum loc_api_adapter_event_index {
+    LOC_API_ADAPTER_REPORT_POSITION = 0,               // Position report comes in loc_parsed_position_s_type
+    LOC_API_ADAPTER_REPORT_SATELLITE,                  // Satellite in view report
+    LOC_API_ADAPTER_REPORT_NMEA_1HZ,                   // NMEA report at 1HZ rate
+    LOC_API_ADAPTER_REPORT_NMEA_POSITION,              // NMEA report at position report rate
+    LOC_API_ADAPTER_REQUEST_NI_NOTIFY_VERIFY,          // NI notification/verification request
+    LOC_API_ADAPTER_REQUEST_ASSISTANCE_DATA,           // Assistance data, eg: time, predicted orbits request
+    LOC_API_ADAPTER_REQUEST_LOCATION_SERVER,           // Request for location server
+    LOC_API_ADAPTER_REPORT_IOCTL,                      // Callback report for loc_ioctl
+    LOC_API_ADAPTER_REPORT_STATUS,                     // Misc status report: eg, engine state
+    LOC_API_ADAPTER_REQUEST_WIFI,                      //
+    LOC_API_ADAPTER_SENSOR_STATUS,                     //
+    LOC_API_ADAPTER_REQUEST_TIME_SYNC,                 //
+    LOC_API_ADAPTER_REPORT_SPI,                        //
+    LOC_API_ADAPTER_REPORT_NI_GEOFENCE,                //
+    LOC_API_ADAPTER_GEOFENCE_GEN_ALERT,                //
+    LOC_API_ADAPTER_REPORT_GENFENCE_BREACH,            //
+    LOC_API_ADAPTER_PEDOMETER_CTRL,                    //
+    LOC_API_ADAPTER_MOTION_CTRL,                       //
+    LOC_API_ADAPTER_REQUEST_WIFI_AP_DATA,              // Wifi ap data
+    LOC_API_ADAPTER_BATCH_FULL,                        // Batching on full
+    LOC_API_ADAPTER_BATCHED_POSITION_REPORT,           // Batching on fix
+    LOC_API_ADAPTER_BATCHED_GENFENCE_BREACH_REPORT,    //
+    LOC_API_ADAPTER_GNSS_MEASUREMENT,                  // GNSS Measurement report
+
+    LOC_API_ADAPTER_EVENT_MAX
+};
+
+#define LOC_API_ADAPTER_BIT_PARSED_POSITION_REPORT           (1<<LOC_API_ADAPTER_REPORT_POSITION)
+#define LOC_API_ADAPTER_BIT_SATELLITE_REPORT                 (1<<LOC_API_ADAPTER_REPORT_SATELLITE)
+#define LOC_API_ADAPTER_BIT_NMEA_1HZ_REPORT                  (1<<LOC_API_ADAPTER_REPORT_NMEA_1HZ)
+#define LOC_API_ADAPTER_BIT_NMEA_POSITION_REPORT             (1<<LOC_API_ADAPTER_REPORT_NMEA_POSITION)
+#define LOC_API_ADAPTER_BIT_NI_NOTIFY_VERIFY_REQUEST         (1<<LOC_API_ADAPTER_REQUEST_NI_NOTIFY_VERIFY)
+#define LOC_API_ADAPTER_BIT_ASSISTANCE_DATA_REQUEST          (1<<LOC_API_ADAPTER_REQUEST_ASSISTANCE_DATA)
+#define LOC_API_ADAPTER_BIT_LOCATION_SERVER_REQUEST          (1<<LOC_API_ADAPTER_REQUEST_LOCATION_SERVER)
+#define LOC_API_ADAPTER_BIT_IOCTL_REPORT                     (1<<LOC_API_ADAPTER_REPORT_IOCTL)
+#define LOC_API_ADAPTER_BIT_STATUS_REPORT                    (1<<LOC_API_ADAPTER_REPORT_STATUS)
+#define LOC_API_ADAPTER_BIT_REQUEST_WIFI                     (1<<LOC_API_ADAPTER_REQUEST_WIFI)
+#define LOC_API_ADAPTER_BIT_SENSOR_STATUS                    (1<<LOC_API_ADAPTER_SENSOR_STATUS)
+#define LOC_API_ADAPTER_BIT_REQUEST_TIME_SYNC                (1<<LOC_API_ADAPTER_REQUEST_TIME_SYNC)
+#define LOC_API_ADAPTER_BIT_REPORT_SPI                       (1<<LOC_API_ADAPTER_REPORT_SPI)
+#define LOC_API_ADAPTER_BIT_REPORT_NI_GEOFENCE               (1<<LOC_API_ADAPTER_REPORT_NI_GEOFENCE)
+#define LOC_API_ADAPTER_BIT_GEOFENCE_GEN_ALERT               (1<<LOC_API_ADAPTER_GEOFENCE_GEN_ALERT)
+#define LOC_API_ADAPTER_BIT_REPORT_GENFENCE_BREACH           (1<<LOC_API_ADAPTER_REPORT_GENFENCE_BREACH)
+#define LOC_API_ADAPTER_BIT_BATCHED_GENFENCE_BREACH_REPORT   (1<<LOC_API_ADAPTER_BATCHED_GENFENCE_BREACH_REPORT)
+#define LOC_API_ADAPTER_BIT_PEDOMETER_CTRL                   (1<<LOC_API_ADAPTER_PEDOMETER_CTRL)
+#define LOC_API_ADAPTER_BIT_MOTION_CTRL                      (1<<LOC_API_ADAPTER_MOTION_CTRL)
+#define LOC_API_ADAPTER_BIT_REQUEST_WIFI_AP_DATA             (1<<LOC_API_ADAPTER_REQUEST_WIFI_AP_DATA)
+#define LOC_API_ADAPTER_BIT_BATCH_FULL                       (1<<LOC_API_ADAPTER_BATCH_FULL)
+#define LOC_API_ADAPTER_BIT_BATCHED_POSITION_REPORT          (1<<LOC_API_ADAPTER_BATCHED_POSITION_REPORT)
+#define LOC_API_ADAPTER_BIT_GNSS_MEASUREMENT                 (1<<LOC_API_ADAPTER_GNSS_MEASUREMENT)
+
+typedef unsigned int LOC_API_ADAPTER_EVENT_MASK_T;
+
+typedef uint32_t LOC_GPS_LOCK_MASK;
+#define isGpsLockNone(lock) ((lock) == 0)
+#define isGpsLockMO(lock) ((lock) & ((LOC_GPS_LOCK_MASK)1))
+#define isGpsLockMT(lock) ((lock) & ((LOC_GPS_LOCK_MASK)2))
+#define isGpsLockAll(lock) (((lock) & ((LOC_GPS_LOCK_MASK)3)) == 3)
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* GPS_EXTENDED_C_H */
+
diff --git a/msm8974/core/loc_core_log.cpp b/msm8974/core/loc_core_log.cpp
new file mode 100644
index 0000000..430f4b8
--- /dev/null
+++ b/msm8974/core/loc_core_log.cpp
@@ -0,0 +1,251 @@
+/* Copyright (c) 2011-2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#define LOG_NDDEBUG 0
+#define LOG_TAG "LocSvc_core_log"
+
+#include <loc_log.h>
+#include <log_util.h>
+#include <loc_core_log.h>
+
+void LocPosMode::logv() const
+{
+    LOC_LOGV ("Position mode: %s\n  Position recurrence: %s\n  "
+              "min interval: %d\n  preferred accuracy: %d\n  "
+              "preferred time: %d\n  credentials: %s  provider: %s",
+              loc_get_position_mode_name(mode),
+              loc_get_position_recurrence_name(recurrence),
+              min_interval,
+              preferred_accuracy,
+              preferred_time,
+              credentials,
+              provider);
+}
+
+/* GPS status names */
+static loc_name_val_s_type gps_status_name[] =
+{
+    NAME_VAL( GPS_STATUS_NONE ),
+    NAME_VAL( GPS_STATUS_SESSION_BEGIN ),
+    NAME_VAL( GPS_STATUS_SESSION_END ),
+    NAME_VAL( GPS_STATUS_ENGINE_ON ),
+    NAME_VAL( GPS_STATUS_ENGINE_OFF ),
+};
+static int gps_status_num = sizeof(gps_status_name) / sizeof(loc_name_val_s_type);
+
+/* Find Android GPS status name */
+const char* loc_get_gps_status_name(GpsStatusValue gps_status)
+{
+   return loc_get_name_from_val(gps_status_name, gps_status_num,
+         (long) gps_status);
+}
+
+
+
+static loc_name_val_s_type loc_eng_position_modes[] =
+{
+    NAME_VAL( LOC_POSITION_MODE_STANDALONE ),
+    NAME_VAL( LOC_POSITION_MODE_MS_BASED ),
+    NAME_VAL( LOC_POSITION_MODE_MS_ASSISTED ),
+    NAME_VAL( LOC_POSITION_MODE_RESERVED_1 ),
+    NAME_VAL( LOC_POSITION_MODE_RESERVED_2 ),
+    NAME_VAL( LOC_POSITION_MODE_RESERVED_3 ),
+    NAME_VAL( LOC_POSITION_MODE_RESERVED_4 ),
+    NAME_VAL( LOC_POSITION_MODE_RESERVED_5 )
+};
+static int loc_eng_position_mode_num = sizeof(loc_eng_position_modes) / sizeof(loc_name_val_s_type);
+
+const char* loc_get_position_mode_name(GpsPositionMode mode)
+{
+    return loc_get_name_from_val(loc_eng_position_modes, loc_eng_position_mode_num, (long) mode);
+}
+
+
+
+static loc_name_val_s_type loc_eng_position_recurrences[] =
+{
+    NAME_VAL( GPS_POSITION_RECURRENCE_PERIODIC ),
+    NAME_VAL( GPS_POSITION_RECURRENCE_SINGLE )
+};
+static int loc_eng_position_recurrence_num = sizeof(loc_eng_position_recurrences) / sizeof(loc_name_val_s_type);
+
+const char* loc_get_position_recurrence_name(GpsPositionRecurrence recur)
+{
+    return loc_get_name_from_val(loc_eng_position_recurrences, loc_eng_position_recurrence_num, (long) recur);
+}
+
+
+
+static loc_name_val_s_type loc_eng_aiding_data_bits[] =
+{
+    NAME_VAL( GPS_DELETE_EPHEMERIS ),
+    NAME_VAL( GPS_DELETE_ALMANAC ),
+    NAME_VAL( GPS_DELETE_POSITION ),
+    NAME_VAL( GPS_DELETE_TIME ),
+    NAME_VAL( GPS_DELETE_IONO ),
+    NAME_VAL( GPS_DELETE_UTC ),
+    NAME_VAL( GPS_DELETE_HEALTH ),
+    NAME_VAL( GPS_DELETE_SVDIR ),
+    NAME_VAL( GPS_DELETE_SVSTEER ),
+    NAME_VAL( GPS_DELETE_SADATA ),
+    NAME_VAL( GPS_DELETE_RTI ),
+    NAME_VAL( GPS_DELETE_CELLDB_INFO ),
+    NAME_VAL( GPS_DELETE_ALMANAC_CORR ),
+    NAME_VAL( GPS_DELETE_FREQ_BIAS_EST ),
+    NAME_VAL( GPS_DELETE_EPHEMERIS_GLO ),
+    NAME_VAL( GPS_DELETE_ALMANAC_GLO ),
+    NAME_VAL( GPS_DELETE_SVDIR_GLO ),
+    NAME_VAL( GPS_DELETE_SVSTEER_GLO ),
+    NAME_VAL( GPS_DELETE_ALMANAC_CORR_GLO ),
+    NAME_VAL( GPS_DELETE_TIME_GPS ),
+    NAME_VAL( GPS_DELETE_TIME_GLO )
+};
+static int loc_eng_aiding_data_bit_num = sizeof(loc_eng_aiding_data_bits) / sizeof(loc_name_val_s_type);
+
+const char* loc_get_aiding_data_mask_names(GpsAidingData data)
+{
+    return NULL;
+}
+
+
+static loc_name_val_s_type loc_eng_agps_types[] =
+{
+    NAME_VAL( AGPS_TYPE_INVALID ),
+    NAME_VAL( AGPS_TYPE_ANY ),
+    NAME_VAL( AGPS_TYPE_SUPL ),
+    NAME_VAL( AGPS_TYPE_C2K ),
+    NAME_VAL( AGPS_TYPE_WWAN_ANY )
+};
+static int loc_eng_agps_type_num = sizeof(loc_eng_agps_types) / sizeof(loc_name_val_s_type);
+
+const char* loc_get_agps_type_name(AGpsType type)
+{
+    return loc_get_name_from_val(loc_eng_agps_types, loc_eng_agps_type_num, (long) type);
+}
+
+
+static loc_name_val_s_type loc_eng_ni_types[] =
+{
+    NAME_VAL( GPS_NI_TYPE_VOICE ),
+    NAME_VAL( GPS_NI_TYPE_UMTS_SUPL ),
+    NAME_VAL( GPS_NI_TYPE_UMTS_CTRL_PLANE ),
+    NAME_VAL( GPS_NI_TYPE_EMERGENCY_SUPL )
+};
+static int loc_eng_ni_type_num = sizeof(loc_eng_ni_types) / sizeof(loc_name_val_s_type);
+
+const char* loc_get_ni_type_name(GpsNiType type)
+{
+    return loc_get_name_from_val(loc_eng_ni_types, loc_eng_ni_type_num, (long) type);
+}
+
+
+static loc_name_val_s_type loc_eng_ni_responses[] =
+{
+    NAME_VAL( GPS_NI_RESPONSE_ACCEPT ),
+    NAME_VAL( GPS_NI_RESPONSE_DENY ),
+    NAME_VAL( GPS_NI_RESPONSE_DENY )
+};
+static int loc_eng_ni_reponse_num = sizeof(loc_eng_ni_responses) / sizeof(loc_name_val_s_type);
+
+const char* loc_get_ni_response_name(GpsUserResponseType response)
+{
+    return loc_get_name_from_val(loc_eng_ni_responses, loc_eng_ni_reponse_num, (long) response);
+}
+
+
+static loc_name_val_s_type loc_eng_ni_encodings[] =
+{
+    NAME_VAL( GPS_ENC_NONE ),
+    NAME_VAL( GPS_ENC_SUPL_GSM_DEFAULT ),
+    NAME_VAL( GPS_ENC_SUPL_UTF8 ),
+    NAME_VAL( GPS_ENC_SUPL_UCS2 ),
+    NAME_VAL( GPS_ENC_UNKNOWN )
+};
+static int loc_eng_ni_encoding_num = sizeof(loc_eng_ni_encodings) / sizeof(loc_name_val_s_type);
+
+const char* loc_get_ni_encoding_name(GpsNiEncodingType encoding)
+{
+    return loc_get_name_from_val(loc_eng_ni_encodings, loc_eng_ni_encoding_num, (long) encoding);
+}
+
+static loc_name_val_s_type loc_eng_agps_bears[] =
+{
+    NAME_VAL( AGPS_APN_BEARER_INVALID ),
+    NAME_VAL( AGPS_APN_BEARER_IPV4 ),
+    NAME_VAL( AGPS_APN_BEARER_IPV6 ),
+    NAME_VAL( AGPS_APN_BEARER_IPV4V6 )
+};
+static int loc_eng_agps_bears_num = sizeof(loc_eng_agps_bears) / sizeof(loc_name_val_s_type);
+
+const char* loc_get_agps_bear_name(AGpsBearerType bearer)
+{
+    return loc_get_name_from_val(loc_eng_agps_bears, loc_eng_agps_bears_num, (long) bearer);
+}
+
+static loc_name_val_s_type loc_eng_server_types[] =
+{
+    NAME_VAL( LOC_AGPS_CDMA_PDE_SERVER ),
+    NAME_VAL( LOC_AGPS_CUSTOM_PDE_SERVER ),
+    NAME_VAL( LOC_AGPS_MPC_SERVER ),
+    NAME_VAL( LOC_AGPS_SUPL_SERVER )
+};
+static int loc_eng_server_types_num = sizeof(loc_eng_server_types) / sizeof(loc_name_val_s_type);
+
+const char* loc_get_server_type_name(LocServerType type)
+{
+    return loc_get_name_from_val(loc_eng_server_types, loc_eng_server_types_num, (long) type);
+}
+
+static loc_name_val_s_type loc_eng_position_sess_status_types[] =
+{
+    NAME_VAL( LOC_SESS_SUCCESS ),
+    NAME_VAL( LOC_SESS_INTERMEDIATE ),
+    NAME_VAL( LOC_SESS_FAILURE )
+};
+static int loc_eng_position_sess_status_num = sizeof(loc_eng_position_sess_status_types) / sizeof(loc_name_val_s_type);
+
+const char* loc_get_position_sess_status_name(enum loc_sess_status status)
+{
+    return loc_get_name_from_val(loc_eng_position_sess_status_types, loc_eng_position_sess_status_num, (long) status);
+}
+
+static loc_name_val_s_type loc_eng_agps_status_names[] =
+{
+    NAME_VAL( GPS_REQUEST_AGPS_DATA_CONN ),
+    NAME_VAL( GPS_RELEASE_AGPS_DATA_CONN ),
+    NAME_VAL( GPS_AGPS_DATA_CONNECTED ),
+    NAME_VAL( GPS_AGPS_DATA_CONN_DONE ),
+    NAME_VAL( GPS_AGPS_DATA_CONN_FAILED )
+};
+static int loc_eng_agps_status_num = sizeof(loc_eng_agps_status_names) / sizeof(loc_name_val_s_type);
+
+const char* loc_get_agps_status_name(AGpsStatusValue status)
+{
+    return loc_get_name_from_val(loc_eng_agps_status_names, loc_eng_agps_status_num, (long) status);
+}
diff --git a/msm8974/core/loc_core_log.h b/msm8974/core/loc_core_log.h
new file mode 100644
index 0000000..8a1825a
--- /dev/null
+++ b/msm8974/core/loc_core_log.h
@@ -0,0 +1,58 @@
+/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef LOC_CORE_LOG_H
+#define LOC_CORE_LOG_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include <ctype.h>
+#include <gps_extended.h>
+
+const char* loc_get_gps_status_name(GpsStatusValue gps_status);
+const char* loc_get_position_mode_name(GpsPositionMode mode);
+const char* loc_get_position_recurrence_name(GpsPositionRecurrence recur);
+const char* loc_get_aiding_data_mask_names(GpsAidingData data);
+const char* loc_get_agps_type_name(AGpsType type);
+const char* loc_get_ni_type_name(GpsNiType type);
+const char* loc_get_ni_response_name(GpsUserResponseType response);
+const char* loc_get_ni_encoding_name(GpsNiEncodingType encoding);
+const char* loc_get_agps_bear_name(AGpsBearerType bear);
+const char* loc_get_server_type_name(LocServerType type);
+const char* loc_get_position_sess_status_name(enum loc_sess_status status);
+const char* loc_get_agps_status_name(AGpsStatusValue status);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LOC_CORE_LOG_H */
diff --git a/msm8974/etc/Android.mk b/msm8974/etc/Android.mk
new file mode 100644
index 0000000..a6914a2
--- /dev/null
+++ b/msm8974/etc/Android.mk
@@ -0,0 +1,10 @@
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := gps.conf
+LOCAL_MODULE_TAGS := optional
+LOCAL_MODULE_CLASS := ETC
+LOCAL_MODULE_PATH  := $(TARGET_OUT_ETC)/
+LOCAL_SRC_FILES := gps.conf
+
+include $(BUILD_PREBUILT)
diff --git a/msm8974/etc/gps.conf b/msm8974/etc/gps.conf
new file mode 100644
index 0000000..01fee6c
--- /dev/null
+++ b/msm8974/etc/gps.conf
@@ -0,0 +1,101 @@
+#Uncommenting these urls would only enable
+#the power up auto injection and force injection(test case).
+#XTRA_SERVER_1=http://xtra1.gpsonextra.net/xtra.bin
+#XTRA_SERVER_2=http://xtra2.gpsonextra.net/xtra.bin
+#XTRA_SERVER_3=http://xtra3.gpsonextra.net/xtra.bin
+
+# Error Estimate
+# _SET = 1
+# _CLEAR = 0
+ERR_ESTIMATE=0
+
+#Test
+NTP_SERVER=time.gpsonextra.net
+#Asia
+# NTP_SERVER=asia.pool.ntp.org
+#Europe
+# NTP_SERVER=europe.pool.ntp.org
+#North America
+# NTP_SERVER=north-america.pool.ntp.org
+
+# DEBUG LEVELS: 0 - none, 1 - Error, 2 - Warning, 3 - Info
+#               4 - Debug, 5 - Verbose
+# If DEBUG_LEVEL is commented, Android's logging levels will be used
+DEBUG_LEVEL = 3
+
+# Intermediate position report, 1=enable, 0=disable
+INTERMEDIATE_POS=0
+
+# Below bit mask configures how GPS functionalities
+# should be locked when user turns off GPS on Settings
+# Set bit 0x1 if MO GPS functionalities are to be locked
+# Set bit 0x2 if NI GPS functionalities are to be locked
+# default - non is locked for backward compatibility
+#GPS_LOCK = 0
+
+# supl version 1.0
+SUPL_VER=0x10000
+
+# Emergency SUPL, 1=enable, 0=disable
+SUPL_ES=1
+
+# GPS Capabilities bit mask
+# SCHEDULING = 0x01
+# MSB = 0x02
+# MSA = 0x04
+# ON_DEMAND_TIME = 0x10
+# GEOFENCE = 0x20
+# default = ON_DEMAND_TIME | MSA | MSB | SCHEDULING | GEOFENCE
+CAPABILITIES=0x37
+
+# Accuracy threshold for intermediate positions
+# less accurate positions are ignored, 0 for passing all positions
+# ACCURACY_THRES=5000
+
+################################
+##### AGPS server settings #####
+################################
+
+# FOR SUPL SUPPORT, set the following
+# SUPL_HOST=supl.host.com or IP
+# SUPL_PORT=1234
+SUPL_HOST=supl.google.com
+SUPL_PORT=7276
+
+# FOR C2K PDE SUPPORT, set the following
+# C2K_HOST=c2k.pde.com or IP
+# C2K_PORT=1234
+
+# Bitmask of slots that are available
+# for write/install to, where 1s indicate writable,
+# and the default value is 0 where no slots
+# are writable. For example, AGPS_CERT_WRITABLE_MASK
+# of b1000001010 makes 3 slots available
+# for installation (slots 2, 4, and 10)
+# and the remaining 7 slots unwritable.
+#AGPS_CERT_WRITABLE_MASK=0
+
+####################################
+#  LTE Positioning Profile Settings
+####################################
+# 0: Enable RRLP on LTE(Default)
+# 1: Enable LPP_User_Plane on LTE
+# 2: Enable LPP_Control_Plane
+# 3: Enable both LPP_User_Plane and LPP_Control_Plane
+LPP_PROFILE = 0
+
+################################
+# EXTRA SETTINGS
+################################
+# NMEA provider (1=Modem Processor, 0=Application Processor)
+NMEA_PROVIDER=0
+# Mark if it is a SGLTE target (1=SGLTE, 0=nonSGLTE)
+SGLTE_TARGET=0
+
+##################################################
+# Select Positioning Protocol on A-GLONASS system
+##################################################
+# 0x1: RRC CPlane
+# 0x2: RRLP UPlane
+# 0x4: LLP Uplane
+A_GLONASS_POS_PROTOCOL_SELECT = 0
diff --git a/msm8974/loc_api/Android.mk b/msm8974/loc_api/Android.mk
new file mode 100644
index 0000000..743b386
--- /dev/null
+++ b/msm8974/loc_api/Android.mk
@@ -0,0 +1,17 @@
+ifneq ($(BOARD_VENDOR_QCOM_GPS_LOC_API_HARDWARE),)
+
+LOCAL_PATH := $(call my-dir)
+
+# add RPC dirs if RPC is available
+ifneq ($(TARGET_NO_RPC),true)
+
+GPS_DIR_LIST += $(LOCAL_PATH)/libloc_api-rpc-50001/
+
+endif #TARGET_NO_RPC
+
+GPS_DIR_LIST += $(LOCAL_PATH)/libloc_api_50001/
+
+#call the subfolders
+include $(addsuffix Android.mk, $(GPS_DIR_LIST))
+
+endif#BOARD_VENDOR_QCOM_GPS_LOC_API_HARDWARE
diff --git a/msm8974/loc_api/NOTICE b/msm8974/loc_api/NOTICE
new file mode 100644
index 0000000..85b5740
--- /dev/null
+++ b/msm8974/loc_api/NOTICE
@@ -0,0 +1,13 @@
+Copyright (c) 2009, QUALCOMM USA, INC.
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+         Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+
+         Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+
+         Neither the name of the QUALCOMM USA, INC.  nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/msm8974/loc_api/libloc_api-rpc-50001/Android.mk b/msm8974/loc_api/libloc_api-rpc-50001/Android.mk
new file mode 100644
index 0000000..6c5d533
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc-50001/Android.mk
@@ -0,0 +1,3 @@
+ifeq ($(BOARD_VENDOR_QCOM_GPS_LOC_API_AMSS_VERSION),50001)
+include $(call all-subdir-makefiles)
+endif
diff --git a/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/Android.mk b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/Android.mk
new file mode 100644
index 0000000..bb3d924
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/Android.mk
@@ -0,0 +1,60 @@
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+
+RPC_INC:=rpc_inc
+
+source_files:= \
+    src/loc_api_rpc_glue.c \
+    src/loc_api_sync_call.c \
+    src/loc_apicb_appinit.c \
+    src/loc_api_fixup.c \
+    src/loc_api_log.c \
+    src/LocApiRpc.cpp
+
+LOCAL_SRC_FILES:= $(source_files)
+
+LOCAL_CFLAGS:=-fno-short-enums
+LOCAL_CFLAGS+=-DDEBUG -DUSE_QCOM_AUTO_RPC -DUSE_QCOM_AUTO_RPC
+LOCAL_CFLAGS+=$(GPS_FEATURES)
+
+# for loc_api_fixup.c
+LOCAL_CFLAGS+=-DADD_XDR_FLOAT -DADD_XDR_BOOL
+
+LOCAL_SHARED_LIBRARIES:= \
+    librpc \
+    libutils \
+    libcutils \
+    libcommondefs \
+    libgps.utils \
+    libloc_core
+
+LOCAL_STATIC_LIBRARIES := \
+    libloc_api_rpcgen
+
+LOCAL_PRELINK_MODULE:= false
+
+LOCAL_C_INCLUDES:= \
+    $(LOCAL_PATH) \
+    $(LOCAL_PATH)/rpc_inc \
+    $(TARGET_OUT_HEADERS)/gps.utils \
+    $(TARGET_OUT_HEADERS)/libloc_core \
+    $(TARGET_OUT_HEADERS)/loc_api/rpcgen/inc \
+    $(TARGET_OUT_HEADERS)/libcommondefs/rpcgen/inc \
+    $(TARGET_OUT_HEADERS)/librpc \
+    $(TARGET_OUT_HEADERS)/libloc-rpc/rpc_inc \
+    $(TOP)/hardware/msm7k/librpc
+
+LOCAL_COPY_HEADERS_TO:= libloc_api-rpc-qc/$(RPC_INC)
+LOCAL_COPY_HEADERS:= \
+    $(RPC_INC)/loc_api_rpc_glue.h \
+    $(RPC_INC)/loc_api_fixup.h \
+    $(RPC_INC)/loc_api_sync_call.h \
+    $(RPC_INC)/loc_apicb_appinit.h \
+    $(RPC_INC)/LocApiRpc.h
+
+LOCAL_MODULE:= libloc_api-rpc-qc
+LOCAL_MODULE_OWNER := qcom
+
+LOCAL_MODULE_TAGS := optional
+
+include $(BUILD_SHARED_LIBRARY)
diff --git a/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/Makefile.am b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/Makefile.am
new file mode 100644
index 0000000..f5c5136
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/Makefile.am
@@ -0,0 +1,46 @@
+AM_CFLAGS = \
+   -I../../../utils \
+   -I../../../platform_lib_abstractions \
+   -I./rpc_inc \
+   -I../libloc_api-rpc-stub/inc \
+   -I../../libloc_api_50001 \
+   $(MSM7K_CFLAGS) \
+   -DUSE_QCOM_AUTO_RPC
+
+requiredlibs = \
+   ../../../utils/libgps_utils_so.la \
+   $(MSM7K_LIBS)
+
+h_sources = \
+    rpc_inc/loc_api_rpc_glue.h \
+    rpc_inc/loc_api_fixup.h \
+    rpc_inc/loc_api_sync_call.h \
+    rpc_inc/loc_apicb_appinit.h \
+
+c_sources = \
+    src/loc_api_rpc_glue.c \
+    src/loc_api_sync_call.c \
+    src/loc_apicb_appinit.c \
+    src/loc_api_fixup.c \
+    src/loc_api_log.c \
+    src/LocApiRpcAdapter.cpp \
+
+
+library_includedir = $(pkgincludedir)/libloc_api-rpc-50001/libloc_api-rpc-glue/rpc_inc
+library_include_HEADERS = $(h_sources)
+libloc_api_rpc_qc_la_SOURCES = $(c_sources) $(h_sources)
+
+if USE_GLIB
+libloc_api_rpc_qc_la_CFLAGS = -DUSE_GLIB $(AM_CFLAGS) @GLIB_CFLAGS@
+libloc_api_rpc_qc_la_LDFLAGS = -lstdc++ -lpthread @GLIB_LIBS@ -shared -version-info 1:0:0
+libloc_api_rpc_qc_la_CPPFLAGS = -DUSE_GLIB $(AM_CFLAGS) $(AM_CPPFLAGS) @GLIB_CFLAGS@
+else
+libloc_api_rpc_qc_la_CFLAGS = $(AM_CFLAGS)
+libloc_api_rpc_qc_la_LDFLAGS = -lpthread -shared -version-info 1:0:0
+libloc_api_rpc_qc_la_CPPFLAGS = $(AM_CFLAGS) $(AM_CPPFLAGS)
+endif
+
+libloc_api_rpc_qc_la_LIBADD = $(requiredlibs) -lstdc++
+
+#Create and Install Libraries
+lib_LTLIBRARIES = libloc_api_rpc_qc.la
diff --git a/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/rpc_inc/LocApiRpc.h b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/rpc_inc/LocApiRpc.h
new file mode 100644
index 0000000..01d67f4
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/rpc_inc/LocApiRpc.h
@@ -0,0 +1,140 @@
+/* Copyright (c) 2011,2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef LOC_API_RPC_H
+#define LOC_API_RPC_H
+
+#include <rpc/rpc.h>
+#include <loc_api_rpcgen_common_rpc.h>
+#include <loc_api_rpc_glue.h>
+#include <LocApiBase.h>
+#include <loc_log.h>
+
+using namespace loc_core;
+
+class LocApiRpc : public LocApiBase {
+protected:
+    // RPC communication establishment
+    rpc_loc_client_handle_type client_handle;
+
+private:
+    int dataEnableLastSet;
+    char apnLastSet[MAX_APN_LEN];
+
+    static const LOC_API_ADAPTER_EVENT_MASK_T maskAll;
+    static const rpc_loc_event_mask_type locBits[];
+    static rpc_loc_event_mask_type convertMask(LOC_API_ADAPTER_EVENT_MASK_T mask);
+    static rpc_loc_lock_e_type convertGpsLockMask(LOC_GPS_LOCK_MASK lockMask);
+    static enum loc_api_adapter_err convertErr(int rpcErr);
+    static GpsNiEncodingType convertNiEncodingType(int loc_encoding);
+    static int NIEventFillVerfiyType(GpsNiNotification &notif,
+                              rpc_loc_ni_notify_verify_e_type notif_priv);
+
+    void reportPosition(const rpc_loc_parsed_position_s_type *location_report_ptr);
+    void reportSv(const rpc_loc_gnss_info_s_type *gnss_report_ptr);
+    void reportStatus(const rpc_loc_status_event_s_type *status_report_ptr);
+    void reportNmea(const rpc_loc_nmea_report_s_type *nmea_report_ptr);
+    void ATLEvent(const rpc_loc_server_request_s_type *server_request_ptr);
+    void NIEvent(const rpc_loc_ni_event_s_type *ni_req_ptr);
+
+protected:
+    virtual enum loc_api_adapter_err
+        open(LOC_API_ADAPTER_EVENT_MASK_T mask);
+    virtual enum loc_api_adapter_err
+        close();
+
+public:
+    LocApiRpc(const MsgTask* msgTask,
+              LOC_API_ADAPTER_EVENT_MASK_T exMask);
+    ~LocApiRpc();
+
+    virtual int locEventCB(rpc_loc_client_handle_type client_handle,
+                   rpc_loc_event_mask_type loc_event,
+                   const rpc_loc_event_payload_u_type* loc_event_payload);
+
+    void locRpcGlobalCB(CLIENT* clnt, enum rpc_reset_event event);
+
+    // RPC adapter interface implementations
+    virtual enum loc_api_adapter_err
+        startFix(const LocPosMode& posMode);
+    virtual enum loc_api_adapter_err
+        stopFix();
+    virtual enum loc_api_adapter_err
+        setPositionMode(const LocPosMode& mode);
+    inline virtual enum loc_api_adapter_err
+        enableData(int enable) { return enableData(enable, false); }
+    virtual enum loc_api_adapter_err
+        enableData(int enable, boolean force);
+    virtual enum loc_api_adapter_err
+        setTime(GpsUtcTime time, int64_t timeReference, int uncertainty);
+    virtual enum loc_api_adapter_err
+        injectPosition(double latitude, double longitude, float accuracy);
+    virtual enum loc_api_adapter_err
+        deleteAidingData(GpsAidingData f);
+    virtual enum loc_api_adapter_err
+        informNiResponse(GpsUserResponseType userResponse, const void* passThroughData);
+    inline virtual enum loc_api_adapter_err
+        setAPN(char* apn, int len) { return setAPN(apn, len, false); }
+    virtual enum loc_api_adapter_err
+        setAPN(char* apn, int len, boolean force);
+    virtual enum loc_api_adapter_err
+        setServer(const char* url, int len);
+    virtual enum loc_api_adapter_err
+        setServer(unsigned int ip, int port, LocServerType type);
+    virtual enum loc_api_adapter_err
+        setXtraData(char* data, int length);
+    virtual enum loc_api_adapter_err
+        requestXtraServer();
+    virtual enum loc_api_adapter_err
+        atlOpenStatus(int handle, int is_succ, char* apn, AGpsBearerType bear, AGpsType agpsType);
+    virtual enum loc_api_adapter_err
+        atlCloseStatus(int handle, int is_succ);
+    virtual enum loc_api_adapter_err
+        setSUPLVersion(uint32_t version);
+    virtual void setInSession(bool inSession);
+
+    /*Values for lock
+      1 = Do not lock any position sessions
+      2 = Lock MI position sessions
+      3 = Lock MT position sessions
+      4 = Lock all position sessions
+    */
+    virtual int setGpsLock(LOC_GPS_LOCK_MASK lock);
+    /*
+     Returns
+     Current value of GPS Lock on success
+     -1 on failure
+     */
+    virtual int getGpsLock(void);
+};
+
+extern "C" LocApiBase* getLocApi(const MsgTask* msgTask,
+                                 LOC_API_ADAPTER_EVENT_MASK_T exMask,
+                                 ContextBase *context);
+
+#endif //LOC_API_RPC_H
diff --git a/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/rpc_inc/debug.h b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/rpc_inc/debug.h
new file mode 100644
index 0000000..49a6d0b
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/rpc_inc/debug.h
@@ -0,0 +1,69 @@
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef DEBUG_H
+#define DEBUG_H
+
+#include <stdio.h>
+
+#define LOG_TAG "LocSvc_rpc"
+#include <utils/Log.h>
+
+#define PRINT(x...) do {                                    \
+        fprintf(stdout, "%s(%d) ", __FUNCTION__, __LINE__); \
+        fprintf(stdout, ##x);                               \
+        ALOGD(x);                               \
+    } while(0)
+
+#ifdef DEBUG
+#define D PRINT
+#else
+#define D(x...) do { } while(0)
+#endif
+
+#ifdef VERBOSE
+#define V PRINT
+#else
+#define V(x...) do { } while(0)
+#endif
+
+#define E(x...) do {                                        \
+        fprintf(stderr, "%s(%d) ", __FUNCTION__, __LINE__); \
+        fprintf(stderr, ##x);                               \
+        ALOGE(x);                                            \
+    } while(0)
+
+#define FAILIF(cond, msg...) do {                                              \
+        if (__builtin_expect (cond, 0)) {                                      \
+            fprintf(stderr, "%s:%s:(%d): ", __FILE__, __FUNCTION__, __LINE__); \
+            fprintf(stderr, ##msg);                                            \
+            ALOGE(##msg);                                                       \
+        }                                                                      \
+    } while(0)
+
+#endif/*DEBUG_H*/
diff --git a/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/rpc_inc/loc_api_fixup.h b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/rpc_inc/loc_api_fixup.h
new file mode 100644
index 0000000..c483b4a
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/rpc_inc/loc_api_fixup.h
@@ -0,0 +1,226 @@
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef  LOC_API_FIXUP_H
+#define LOC_API_FIXUP_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#ifndef NULLPROC
+#define NULLPROC 0
+#endif /* NULLPROC */
+
+#ifdef ADD_XDR_FLOAT
+
+extern bool_t xdr_float (XDR *__xdrs, float *__fp);
+extern bool_t xdr_double (XDR *__xdrs, double *__dp);
+
+#endif /* ADD_XDR_FLOAT */
+
+#ifdef ADD_XDR_BOOL
+extern bool_t xdr_bool(XDR *__xdrs, int *__bp);
+#endif /* ADD_XDR_BOOL */
+
+#define RPC_LOC_API_MAJOR_VERSION_NUMBER   1
+#define RPC_LOC_API_MINOR_VERSION_NUMBER   0
+
+// Return value for loc_open in case of failure.
+#define RPC_LOC_CLIENT_HANDLE_INVALID     -1
+
+// Return value of loc api calls for loc_close, loc_start_fix, loc_stop_fix and loc_ioctl
+// These are also the status for the ioctl callback
+#define RPC_LOC_API_SUCCESS           0
+#define RPC_LOC_API_GENERAL_FAILURE   1
+#define RPC_LOC_API_UNSUPPORTED       2
+#define RPC_LOC_API_INVALID_HANDLE    4
+#define RPC_LOC_API_INVALID_PARAMETER 5
+#define RPC_LOC_API_ENGINE_BUSY       6
+#define RPC_LOC_API_PHONE_OFFLINE     7
+#define RPC_LOC_API_TIMEOUT           8
+
+// Special return value for loc api calls in case of RPC failure
+#define RPC_LOC_API_RPC_FAILURE       (-1234)
+// Special return value for modem restart incurred RPC failure
+#define RPC_LOC_API_RPC_MODEM_RESTART       (-1235)
+
+#define RPC_LOC_API_MAX_SV_COUNT                      80
+#define RPC_LOC_API_MAX_NMEA_STRING_LENGTH            1200
+
+// Maximum server address that will be used in location API
+#define RPC_LOC_API_MAX_SERVER_ADDR_LENGTH            256
+#define RPC_LOC_API_MAX_NUM_PREDICTED_ORBITS_SERVERS  3
+#define RPC_LOC_API_MAX_NUM_NTP_SERVERS               3
+
+#define RPC_LOC_EVENT_PARSED_POSITION_REPORT             0x00000001 // Position report comes in loc_parsed_position_s_type
+#define RPC_LOC_EVENT_SATELLITE_REPORT                   0x00000002 // Satellite in view report
+#define RPC_LOC_EVENT_NMEA_1HZ_REPORT                    0x00000004 // NMEA report at 1HZ rate
+#define RPC_LOC_EVENT_NMEA_POSITION_REPORT               0x00000008 // NMEA report at position report rate
+#define RPC_LOC_EVENT_NI_NOTIFY_VERIFY_REQUEST           0x00000010 // NI notification/verification request
+#define RPC_LOC_EVENT_ASSISTANCE_DATA_REQUEST            0x00000020 // Assistance data, eg: time, predicted orbits request
+#define RPC_LOC_EVENT_LOCATION_SERVER_REQUEST            0x00000040 // Request for location server
+#define RPC_LOC_EVENT_IOCTL_REPORT                       0x00000080 // Callback report for loc_ioctl
+#define RPC_LOC_EVENT_STATUS_REPORT                      0x00000100 // Misc status report: eg, engine state
+
+#define RPC_LOC_POS_VALID_SESSION_STATUS                 0x00000001
+#define RPC_LOC_POS_VALID_TIMESTAMP_CALENDAR             0x00000002
+#define RPC_LOC_POS_VALID_TIMESTAMP_UTC                  0x00000004
+#define RPC_LOC_POS_VALID_LEAP_SECONDS                   0x00000008
+#define RPC_LOC_POS_VALID_TIME_UNC                       0x00000010
+#define RPC_LOC_POS_VALID_LATITUDE                       0x00000020
+#define RPC_LOC_POS_VALID_LONGITUDE                      0x00000040
+#define RPC_LOC_POS_VALID_ALTITUDE_WRT_ELLIPSOID         0x00000080
+#define RPC_LOC_POS_VALID_ALTITUDE_WRT_MEAN_SEA_LEVEL    0x00000100
+#define RPC_LOC_POS_VALID_SPEED_HORIZONTAL               0x00000200
+#define RPC_LOC_POS_VALID_SPEED_VERTICAL                 0x00000400
+#define RPC_LOC_POS_VALID_HEADING                        0x00000800
+#define RPC_LOC_POS_VALID_HOR_UNC_CIRCULAR               0x00001000
+#define RPC_LOC_POS_VALID_HOR_UNC_ELLI_SEMI_MAJ          0x00002000
+#define RPC_LOC_POS_VALID_HOR_UNC_ELLI_SEMI_MIN          0x00004000
+#define RPC_LOC_POS_VALID_HOR_UNC_ELLI_ORIENT_AZIMUTH    0x00008000
+#define RPC_LOC_POS_VALID_VERTICAL_UNC                   0x00010000
+#define RPC_LOC_POS_VALID_SPEED_UNC                      0x00020000
+#define RPC_LOC_POS_VALID_HEADING_UNC                    0x00040000
+#define RPC_LOC_POS_VALID_CONFIDENCE_HORIZONTAL          0x00080000
+#define RPC_LOC_POS_VALID_CONFIDENCE_VERTICAL            0x00100000
+#define RPC_LOC_POS_VALID_MAGNETIC_VARIATION             0x00200000
+#define RPC_LOC_POS_VALID_TECHNOLOGY_MASK                0x00400000
+
+#define RPC_LOC_POS_TECH_SATELLITE 0x00000001
+#define RPC_LOC_POS_TECH_CELLID    0x00000002
+#define RPC_LOC_POS_TECH_WIFI      0x00000004
+
+#define RPC_LOC_SV_INFO_VALID_SYSTEM         0x00000001
+#define RPC_LOC_SV_INFO_VALID_PRN            0x00000002
+#define RPC_LOC_SV_INFO_VALID_HEALTH_STATUS  0x00000004
+#define RPC_LOC_SV_INFO_VALID_PROCESS_STATUS 0x00000008
+#define RPC_LOC_SV_INFO_VALID_HAS_EPH        0x00000010
+#define RPC_LOC_SV_INFO_VALID_HAS_ALM        0x00000020
+#define RPC_LOC_SV_INFO_VALID_ELEVATION      0x00000040
+#define RPC_LOC_SV_INFO_VALID_AZIMUTH        0x00000080
+#define RPC_LOC_SV_INFO_VALID_SNR            0x00000100
+
+#define RPC_LOC_GNSS_INFO_VALID_POS_DOP           0x00000001
+#define RPC_LOC_GNSS_INFO_VALID_HOR_DOP           0x00000002
+#define RPC_LOC_GNSS_INFO_VALID_VERT_DOP          0x00000004
+#define RPC_LOC_GNSS_INFO_VALID_ALTITUDE_ASSUMED  0x00000008
+#define RPC_LOC_GNSS_INFO_VALID_SV_COUNT          0x00000010
+#define RPC_LOC_GNSS_INFO_VALID_SV_LIST           0x00000020
+
+#define RPC_LOC_NI_MAX_REQUESTOR_ID_LENGTH          200
+#define RPC_LOC_NI_SUPL_HASH_LENGTH                 8
+#define RPC_LOC_NI_SUPL_SLP_SESSION_ID_BYTE_LENGTH  4
+#define RPC_LOC_NI_MAX_CLIENT_NAME_LENGTH           64
+#define RPC_LOC_NI_MAX_EXT_CLIENT_ADDRESS           20
+#define RPC_LOC_NI_CODEWORD_LENGTH                  20
+
+#define RPC_LOC_NI_SUPL_QOP_VALID         0x01
+#define RPC_LOC_NI_SUPL_QOP_VERACC_VALID  0x02
+#define RPC_LOC_NI_SUPL_QOP_MAXAGE_VALID  0x04
+#define RPC_LOC_NI_SUPL_QOP_DELAY_VALID   0x08
+
+#define RPC_LOC_FIX_CRIT_VALID_RECURRENCE_TYPE                  0x00000001
+#define RPC_LOC_FIX_CRIT_VALID_PREFERRED_OPERATION_MODE         0x00000002
+#define RPC_LOC_FIX_CRIT_VALID_PREFERRED_ACCURACY               0x00000004
+#define RPC_LOC_FIX_CRIT_VALID_PREFERRED_RESPONSE_TIME          0x00000008
+#define RPC_LOC_FIX_CRIT_VALID_INTERMEDIATE_POS_REPORT_ENABLED  0x00000010
+#define RPC_LOC_FIX_CRIT_VALID_NOTIFY_TYPE                      0x00000020
+#define RPC_LOC_FIX_CRIT_VALID_MIN_INTERVAL                     0x00000040
+#define RPC_LOC_FIX_CRIT_VALID_MIN_DISTANCE                     0x00000080
+#define RPC_LOC_FIX_CRIT_VALID_MIN_DIST_SAMPLE_INTERVAL         0x00000100
+
+#define RPC_LOC_ASSIST_POS_VALID_TIMESTAMP_UTC                0x00000001
+#define RPC_LOC_ASSIST_POS_VALID_LATITUDE                     0x00000002
+#define RPC_LOC_ASSIST_POS_VALID_LONGITUDE                    0x00000004
+#define RPC_LOC_ASSIST_POS_VALID_ALTITUDE_WRT_ELLIPSOID       0x00000008
+#define RPC_LOC_ASSIST_POS_VALID_ALTITUDE_WRT_MEAN_SEA_LEVEL  0x00000010
+#define RPC_LOC_ASSIST_POS_VALID_HOR_UNC_CIRCULAR             0x00000020
+#define RPC_LOC_ASSIST_POS_VALID_VERT_UNC                     0x00000040
+#define RPC_LOC_ASSIST_POS_VALID_CONFIDENCE_HORIZONTAL        0x00000080
+#define RPC_LOC_ASSIST_POS_VALID_CONFIDENCE_VERTICAL          0x00000100
+#define RPC_LOC_ASSIST_POS_VALID_TIMESTAMP_AGE                0x00000200
+
+#define RPC_LOC_ASSIST_DATA_ALL         0xFFFFFFFF
+
+#define RPC_LOC_NMEA_MASK_ALL    0xffff
+#define RPC_LOC_NMEA_MASK_GGA    0x0001
+#define RPC_LOC_NMEA_MASK_RMC    0x0002
+#define RPC_LOC_NMEA_MASK_GSV    0x0004
+#define RPC_LOC_NMEA_MASK_GSA    0x0008
+#define RPC_LOC_NMEA_MASK_VTG    0x0010
+
+/* EFS data access */
+#define RPC_LOC_EFS_MAX_PATH_LEN_BYTES  64     /* Max file name length in bytes that can be written*/
+#define RPC_LOC_EFS_MAX_FILE_LEN_BYTES  2000   /* Max file size in bytes that can be written */
+
+/* WIPER valid information flag in log report */
+#define RPC_LOC_WIPER_LOG_TIME_VALID 0x01
+#define RPC_LOC_WIPER_LOG_POS_VALID 0x02
+#define RPC_LOC_WIPER_LOG_AP_SET_VALID 0x04
+
+/* General WIPER defines */
+#define RPC_LOC_WIPER_MAC_ADDR_LENGTH  6              // Do not change this number since it affects RPC and log packet sizes
+#define RPC_LOC_WIPER_MAX_REPORTED_APS_PER_LOG_MSG 50 // Do not change this number since it affects RPC and log packet sizes
+
+/* WIPER AP Qualifier */
+#define RPC_LOC_WIPER_AP_QUALIFIER_BEING_USED 0x1  /* AP is being used by WPS */
+#define RPC_LOC_WIPER_AP_QUALIFIER_HIDDEN_SSID 0x2 /* AP does not broadcast SSID */
+#define RPC_LOC_WIPER_AP_QUALIFIER_PRIVATE 0x4     /* AP has encryption turned on */
+#define RPC_LOC_WIPER_AP_QUALIFIER_INFRASTRUCTURE_MODE 0x8     /* AP is in infrastructure mode and not in ad-hoc/unknown mode */
+
+/* flags for notification */
+#define  RPC_LOC_NI_CLIENT_NAME_PRESENT             0x0001
+#define  RPC_LOC_NI_CLIENT_EXTADDR_PRESENT          0x0002
+#define  RPC_LOC_NI_DEF_LOCATION_TYPE_PRESENT       0x0010
+#define  RPC_LOC_NI_REQUESTOR_ID_PRESENT            0x0020
+#define  RPC_LOC_NI_CODEWORD_PRESENT                0x0040
+#define  RPC_LOC_NI_SERVICE_TYPE_ID_PRESENT         0x0080
+#define  RPC_LOC_NI_ENCODING_TYPE_PRESENT           0x0100
+
+/* below are for RPC_LOC_IOCTL_SET_LBS_APN_PROFILE data */
+/* values for apn_profiles[0].srv_system_type */
+#define LOC_APN_PROFILE_SRV_SYS_CDMA  0x01
+#define LOC_APN_PROFILE_SRV_SYS_HDR   0x02
+#define LOC_APN_PROFILE_SRV_SYS_GSM   0x04
+#define LOC_APN_PROFILE_SRV_SYS_WCDMA 0x08
+#define LOC_APN_PROFILE_SRV_SYS_LTE   0x10
+#define LOC_APN_PROFILE_SRV_SYS_MAX   0x1F
+/* values for apn_profiles[0].pdp_type */
+#define LOC_APN_PROFILE_PDN_TYPE_IPV4    0x01
+#define LOC_APN_PROFILE_PDN_TYPE_IPV6    0x02
+#define LOC_APN_PROFILE_PDN_TYPE_IPV4V6  0x03
+#define LOC_APN_PROFILE_PDN_TYPE_PPP     0x04
+#define LOC_APN_PROFILE_PDN_TYPE_MAX     0x04
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LOC_API_FIXUP_H */
diff --git a/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/rpc_inc/loc_api_log.h b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/rpc_inc/loc_api_log.h
new file mode 100644
index 0000000..f037428
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/rpc_inc/loc_api_log.h
@@ -0,0 +1,59 @@
+/* Copyright (c) 2011 The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef LOC_API_LOG_H
+#define LOC_API_LOG_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include <ctype.h>
+#include "loc_api_rpcgen_common_rpc.h"
+
+extern int loc_callback_log(
+      rpc_loc_event_mask_type               loc_event,              /* event mask           */
+      const rpc_loc_event_payload_u_type*   loc_event_payload       /* payload              */
+);
+
+extern const char* loc_get_event_atl_open_name(rpc_loc_server_request_e_type loc_event_atl_open);
+extern const char* loc_get_event_name(rpc_loc_event_mask_type loc_event_mask);
+extern const char* loc_get_ioctl_type_name(rpc_loc_ioctl_e_type ioctl_type);
+extern const char* loc_get_ioctl_status_name(uint32 status);
+extern const char* loc_get_sess_status_name(rpc_loc_session_status_e_type status);
+extern const char* loc_get_engine_state_name(rpc_loc_engine_state_e_type state);
+extern const char* loc_get_fix_session_state_name(rpc_loc_fix_session_state_e_type state);
+extern const char* loc_get_rpc_reset_event_name(enum rpc_reset_event event);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LOC_API_LOG_H */
diff --git a/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/rpc_inc/loc_api_rpc_glue.h b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/rpc_inc/loc_api_rpc_glue.h
new file mode 100644
index 0000000..6df33ae
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/rpc_inc/loc_api_rpc_glue.h
@@ -0,0 +1,123 @@
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef LOC_API_RPC_GLUE_H
+#define LOC_API_RPC_GLUE_H
+
+/* Include RPC headers */
+#ifdef USE_LOCAL_RPC
+#include "rpc_inc/loc_api_common.h"
+#include "rpc_inc/loc_api.h"
+#include "rpc_inc/loc_api_cb.h"
+#endif
+
+#ifdef USE_QCOM_AUTO_RPC
+#include "loc_api_rpcgen_rpc.h"
+#include "loc_api_rpcgen_common_rpc.h"
+#include "loc_api_rpcgen_cb_rpc.h"
+#endif
+
+/* Boolean */
+/* Other data types in comdef.h are defined in rpc stubs, so fix it here */
+typedef unsigned char boolean;
+#define TRUE 1
+#define FALSE 0
+
+#include "loc_api_fixup.h"
+#include "loc_api_sync_call.h"
+#include <rpc/clnt.h>
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+extern int loc_api_glue_init(void);
+extern int loc_api_null(void);
+
+typedef int32 (loc_event_cb_f_type)(
+    void*                                 userData,
+    rpc_loc_client_handle_type            loc_handle,             /* handle of the client */
+    rpc_loc_event_mask_type               loc_event,              /* event mask           */
+    const rpc_loc_event_payload_u_type*   loc_event_payload       /* payload              */
+);
+
+typedef void (loc_reset_notif_cb_f_type)(
+    void*                                 userData,
+    CLIENT*                               clnt,
+    enum rpc_reset_event                  event
+);
+
+extern rpc_loc_client_handle_type loc_open(
+    rpc_loc_event_mask_type       event_reg_mask,
+    loc_event_cb_f_type           *event_callback,
+    loc_reset_notif_cb_f_type     *rpc_global_cb,
+    void*                         userData
+);
+
+extern int32 loc_close
+(
+      rpc_loc_client_handle_type handle
+);
+
+extern void loc_clear
+(
+      rpc_loc_client_handle_type handle
+);
+
+extern int32 loc_start_fix
+(
+      rpc_loc_client_handle_type handle
+);
+
+extern int32 loc_stop_fix
+(
+      rpc_loc_client_handle_type handle
+);
+
+extern int32 loc_ioctl
+(
+      rpc_loc_client_handle_type           handle,
+      rpc_loc_ioctl_e_type                 ioctl_type,
+      rpc_loc_ioctl_data_u_type*           ioctl_data
+);
+
+extern int loc_eng_ioctl
+(
+      rpc_loc_client_handle_type           handle,
+      rpc_loc_ioctl_e_type                 ioctl_type,
+      rpc_loc_ioctl_data_u_type*           ioctl_data_ptr,
+      uint32                               timeout_msec,
+      rpc_loc_ioctl_callback_s_type       *cb_data_ptr
+);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LOC_API_RPC_GLUE_H */
diff --git a/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/rpc_inc/loc_api_sync_call.h b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/rpc_inc/loc_api_sync_call.h
new file mode 100644
index 0000000..43208bd
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/rpc_inc/loc_api_sync_call.h
@@ -0,0 +1,90 @@
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef LOC_API_CB_SYNC_H
+#define LOC_API_CB_SYNC_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+#include "loc_api_rpc_glue.h"
+#define LOC_SYNC_CALL_SLOTS_MAX 8
+
+typedef struct {
+   pthread_mutex_t                lock;
+
+   /* Client ID */
+   rpc_loc_client_handle_type     loc_handle;
+
+   /* Callback waiting conditional variable */
+   pthread_cond_t                 loc_cb_arrived_cond;
+
+   /* Callback waiting data block, protected by loc_cb_data_mutex */
+   boolean                        in_use;
+   boolean                        signal_sent;
+   boolean                        not_available;
+   rpc_loc_event_mask_type        loc_cb_wait_event_mask;        /* event to wait for */
+   rpc_loc_ioctl_e_type           ioctl_type;                    /* ioctl to wait for */
+   rpc_loc_event_payload_u_type   loc_cb_received_payload;       /* received payload */
+   rpc_loc_event_mask_type        loc_cb_received_event_mask;    /* received event   */
+} loc_sync_call_slot_s_type;
+
+typedef struct {
+   int                            num_of_slots;
+   loc_sync_call_slot_s_type      slots[LOC_SYNC_CALL_SLOTS_MAX];
+} loc_sync_call_slot_array_s_type;
+
+/* Init function */
+void loc_api_sync_call_init();
+
+/* Destroy function */
+void loc_api_sync_call_destroy();
+
+/* Process Loc API callbacks to wake up blocked user threads */
+void loc_api_callback_process_sync_call(
+      rpc_loc_client_handle_type            loc_handle,             /* handle of the client */
+      rpc_loc_event_mask_type               loc_event,              /* event mask           */
+      const rpc_loc_event_payload_u_type*   loc_event_payload       /* payload              */
+);
+
+/* Reentrant synchronous IOCTL call, using Loc API return code */
+int loc_api_sync_ioctl
+(
+      rpc_loc_client_handle_type           handle,
+      rpc_loc_ioctl_e_type                 ioctl_type,
+      rpc_loc_ioctl_data_u_type*           ioctl_data_ptr,
+      uint32                               timeout_msec,
+      rpc_loc_ioctl_callback_s_type       *cb_data_ptr
+);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LOC_API_CB_SYNC_H */
diff --git a/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/rpc_inc/loc_apicb_appinit.h b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/rpc_inc/loc_apicb_appinit.h
new file mode 100644
index 0000000..ba41d08
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/rpc_inc/loc_apicb_appinit.h
@@ -0,0 +1,45 @@
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef LOC_APICB_APPINIT_H
+#define LOC_APICB_APPINIT_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+ /* Initialization function for callbacks */
+extern int loc_apicb_app_init();
+extern void loc_apicb_app_deinit();
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LOC_APICB_APPINIT_H */
diff --git a/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/src/LocApiRpc.cpp b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/src/LocApiRpc.cpp
new file mode 100644
index 0000000..87d6b7c
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/src/LocApiRpc.cpp
@@ -0,0 +1,1461 @@
+/* Copyright (c) 2011-2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#define LOG_NDDEBUG 0
+#define LOG_TAG "LocSvc_api_rpc"
+
+#include <unistd.h>
+#include <math.h>
+#ifndef USE_GLIB
+#include <utils/SystemClock.h>
+#endif /* USE_GLIB */
+#include <LocApiRpc.h>
+#include <LocAdapterBase.h>
+#include <loc_api_fixup.h>
+#include <loc_api_rpc_glue.h>
+#include <log_util.h>
+#include <loc_log.h>
+#include <loc_api_log.h>
+#ifdef USE_GLIB
+#include <glib.h>
+#endif
+#include <librpc.h>
+#include <platform_lib_includes.h>
+
+using namespace loc_core;
+
+#define LOC_XTRA_INJECT_DEFAULT_TIMEOUT (3100)
+#define XTRA_BLOCK_SIZE                 (3072)
+#define LOC_IOCTL_DEFAULT_TIMEOUT 1000 // 1000 milli-seconds
+#define LOC_NI_NOTIF_KEY_ADDRESS           "Address"
+
+/*===========================================================================
+FUNCTION    loc_event_cb
+
+DESCRIPTION
+   This is the callback function registered by loc_open.
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   RPC_LOC_API_SUCCESS
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static int32 loc_event_cb
+(
+    void*                                user,
+    rpc_loc_client_handle_type           client_handle,
+    rpc_loc_event_mask_type              loc_event,
+    const rpc_loc_event_payload_u_type*  loc_event_payload
+)
+{
+    MODEM_LOG_CALLFLOW(%s, loc_get_event_name(loc_event));
+    loc_callback_log(loc_event, loc_event_payload);
+    int32 ret_val = ((LocApiRpc*)user)->locEventCB(client_handle, loc_event, loc_event_payload);
+    EXIT_LOG(%d, ret_val);
+    return ret_val;
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_rpc_global_cb
+
+DESCRIPTION
+   This is the callback function registered by loc_open for RPC global events
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   RPC_LOC_API_SUCCESS
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static void loc_rpc_global_cb(void* user, CLIENT* clnt, enum rpc_reset_event event)
+{
+    MODEM_LOG_CALLFLOW(%s, loc_get_rpc_reset_event_name(event));
+    ((LocApiRpc*)user)->locRpcGlobalCB(clnt, event);
+    EXIT_LOG(%p, VOID_RET);
+}
+
+const LOC_API_ADAPTER_EVENT_MASK_T LocApiRpc::maskAll =
+    LOC_API_ADAPTER_BIT_PARSED_POSITION_REPORT |
+    LOC_API_ADAPTER_BIT_SATELLITE_REPORT |
+    LOC_API_ADAPTER_BIT_LOCATION_SERVER_REQUEST |
+    LOC_API_ADAPTER_BIT_ASSISTANCE_DATA_REQUEST |
+    LOC_API_ADAPTER_BIT_IOCTL_REPORT |
+    LOC_API_ADAPTER_BIT_STATUS_REPORT |
+    LOC_API_ADAPTER_BIT_NMEA_1HZ_REPORT |
+    LOC_API_ADAPTER_BIT_NI_NOTIFY_VERIFY_REQUEST;
+
+const rpc_loc_event_mask_type LocApiRpc::locBits[] =
+{
+    RPC_LOC_EVENT_PARSED_POSITION_REPORT,
+    RPC_LOC_EVENT_SATELLITE_REPORT,
+    RPC_LOC_EVENT_NMEA_1HZ_REPORT,
+    RPC_LOC_EVENT_NMEA_POSITION_REPORT,
+    RPC_LOC_EVENT_NI_NOTIFY_VERIFY_REQUEST,
+    RPC_LOC_EVENT_ASSISTANCE_DATA_REQUEST,
+    RPC_LOC_EVENT_LOCATION_SERVER_REQUEST,
+    RPC_LOC_EVENT_IOCTL_REPORT,
+    RPC_LOC_EVENT_STATUS_REPORT,
+    RPC_LOC_EVENT_WPS_NEEDED_REQUEST
+};
+
+// constructor
+LocApiRpc::LocApiRpc(const MsgTask* msgTask,
+                     LOC_API_ADAPTER_EVENT_MASK_T exMask,
+                     ContextBase* context) :
+    LocApiBase(msgTask, exMask, context),
+    client_handle(RPC_LOC_CLIENT_HANDLE_INVALID),
+    dataEnableLastSet(-1)
+{
+    memset(apnLastSet, 0, sizeof(apnLastSet));
+    loc_api_glue_init();
+}
+
+LocApiRpc::~LocApiRpc()
+{
+    close();
+}
+
+rpc_loc_event_mask_type
+LocApiRpc::convertMask(LOC_API_ADAPTER_EVENT_MASK_T mask)
+{
+    rpc_loc_event_mask_type newMask = 0;
+
+    for (unsigned int i = 0, bit=1; 0 != mask; i++, bit<<=1) {
+        if (mask & bit) {
+            newMask |= locBits[i];
+            mask ^= bit;
+        }
+    }
+
+    return newMask;
+}
+
+rpc_loc_lock_e_type
+LocApiRpc::convertGpsLockMask(LOC_GPS_LOCK_MASK lockMask)
+{
+    if (isGpsLockAll(lockMask))
+        return RPC_LOC_LOCK_ALL;
+    if (isGpsLockMO(lockMask))
+        return RPC_LOC_LOCK_MI;
+    if (isGpsLockMT(lockMask))
+        return RPC_LOC_LOCK_MT;
+    if (isGpsLockNone(lockMask))
+        return RPC_LOC_LOCK_NONE;
+    return (rpc_loc_lock_e_type)lockMask;
+}
+
+enum loc_api_adapter_err
+LocApiRpc::convertErr(int rpcErr)
+{
+    switch(rpcErr)
+    {
+    case RPC_LOC_API_SUCCESS:
+        return LOC_API_ADAPTER_ERR_SUCCESS;
+    case RPC_LOC_API_GENERAL_FAILURE:
+        return LOC_API_ADAPTER_ERR_GENERAL_FAILURE;
+    case RPC_LOC_API_UNSUPPORTED:
+        return LOC_API_ADAPTER_ERR_UNSUPPORTED;
+    case RPC_LOC_API_INVALID_HANDLE:
+        return LOC_API_ADAPTER_ERR_INVALID_HANDLE;
+    case RPC_LOC_API_INVALID_PARAMETER:
+        return LOC_API_ADAPTER_ERR_INVALID_PARAMETER;
+    case RPC_LOC_API_ENGINE_BUSY:
+        return LOC_API_ADAPTER_ERR_ENGINE_BUSY;
+    case RPC_LOC_API_PHONE_OFFLINE:
+        return LOC_API_ADAPTER_ERR_PHONE_OFFLINE;
+    case RPC_LOC_API_TIMEOUT:
+        return LOC_API_ADAPTER_ERR_TIMEOUT;
+    case RPC_LOC_API_RPC_MODEM_RESTART:
+        return LOC_API_ADAPTER_ERR_ENGINE_DOWN;
+    case RPC_LOC_API_RPC_FAILURE:
+        return LOC_API_ADAPTER_ERR_FAILURE;
+    default:
+        return LOC_API_ADAPTER_ERR_UNKNOWN;
+    }
+}
+
+void LocApiRpc::locRpcGlobalCB(CLIENT* clnt, enum rpc_reset_event event)
+{
+    static rpc_loc_engine_state_e_type last_state = RPC_LOC_ENGINE_STATE_MAX;
+
+    switch (event) {
+    case RPC_SUBSYSTEM_RESTART_BEGIN:
+        if (RPC_LOC_ENGINE_STATE_OFF != last_state) {
+            last_state = RPC_LOC_ENGINE_STATE_OFF;
+            handleEngineDownEvent();
+        }
+        break;
+    case RPC_SUBSYSTEM_RESTART_END:
+        if (RPC_LOC_ENGINE_STATE_ON != last_state) {
+            last_state = RPC_LOC_ENGINE_STATE_ON;
+            handleEngineUpEvent();
+        }
+        break;
+    }
+}
+
+int32 LocApiRpc::locEventCB(rpc_loc_client_handle_type client_handle,
+                     rpc_loc_event_mask_type loc_event,
+                     const rpc_loc_event_payload_u_type* loc_event_payload)
+{
+    // Parsed report
+    if (loc_event & RPC_LOC_EVENT_PARSED_POSITION_REPORT)
+    {
+        reportPosition(&loc_event_payload->rpc_loc_event_payload_u_type_u.
+                       parsed_location_report);
+    }
+
+    // Satellite report
+    if (loc_event & RPC_LOC_EVENT_SATELLITE_REPORT)
+    {
+        reportSv(&loc_event_payload->rpc_loc_event_payload_u_type_u.gnss_report);
+    }
+
+    // Status report
+    if (loc_event & RPC_LOC_EVENT_STATUS_REPORT)
+    {
+        reportStatus(&loc_event_payload->rpc_loc_event_payload_u_type_u.status_report);
+    }
+
+    // NMEA
+    if (loc_event & RPC_LOC_EVENT_NMEA_1HZ_REPORT)
+    {
+        reportNmea(&(loc_event_payload->rpc_loc_event_payload_u_type_u.nmea_report));
+    }
+    // XTRA support: supports only XTRA download
+    if (loc_event & RPC_LOC_EVENT_ASSISTANCE_DATA_REQUEST)
+    {
+        if (loc_event_payload->rpc_loc_event_payload_u_type_u.assist_data_request.event ==
+            RPC_LOC_ASSIST_DATA_PREDICTED_ORBITS_REQ)
+        {
+            requestXtraData();
+        } else if (loc_event_payload->rpc_loc_event_payload_u_type_u.assist_data_request.event ==
+                   RPC_LOC_ASSIST_DATA_TIME_REQ)
+        {
+            requestTime();
+        } else if (loc_event_payload->rpc_loc_event_payload_u_type_u.assist_data_request.event ==
+                   RPC_LOC_ASSIST_DATA_POSITION_INJECTION_REQ)
+        {
+            requestLocation();
+        }
+    }
+
+    // AGPS data request
+    if (loc_event & RPC_LOC_EVENT_LOCATION_SERVER_REQUEST)
+    {
+        ATLEvent(&loc_event_payload->rpc_loc_event_payload_u_type_u.
+                 loc_server_request);
+    }
+
+    // NI notify request
+    if (loc_event & RPC_LOC_EVENT_NI_NOTIFY_VERIFY_REQUEST)
+    {
+        NIEvent(&loc_event_payload->rpc_loc_event_payload_u_type_u.ni_request);
+    }
+
+    return RPC_LOC_API_SUCCESS;//We simply want to return sucess here as we do not want to
+    // cause any issues in RPC thread context
+}
+
+enum loc_api_adapter_err
+LocApiRpc::open(LOC_API_ADAPTER_EVENT_MASK_T mask)
+{
+    enum loc_api_adapter_err ret_val = LOC_API_ADAPTER_ERR_SUCCESS;
+
+    // RPC does not dynamically update the event mask. And in the
+    // case of RPC, all we support are positioning (gps + agps)
+    // masks anyways, so we simply mask all of them on always.
+    // After doing so the first time in a power cycle, we know there
+    // will the following if condition will never be true any more.
+    mask = maskAll;
+
+    if (mask != mMask) {
+        if (RPC_LOC_CLIENT_HANDLE_INVALID != client_handle) {
+            close();
+        }
+
+        mMask = mask;
+        // it is important to cap the mask here, because not all LocApi's
+        // can enable the same bits, e.g. foreground and bckground.
+        client_handle = loc_open(convertMask(mask),
+                                 loc_event_cb,
+                                 loc_rpc_global_cb, this);
+
+        if (client_handle < 0) {
+            mMask = 0;
+            client_handle = RPC_LOC_CLIENT_HANDLE_INVALID;
+            ret_val = LOC_API_ADAPTER_ERR_INVALID_HANDLE;
+        }
+    }
+
+    return ret_val;
+}
+
+enum loc_api_adapter_err
+LocApiRpc::close()
+{
+    if (RPC_LOC_CLIENT_HANDLE_INVALID != client_handle) {
+        loc_clear(client_handle);
+    }
+
+    loc_close(client_handle);
+    mMask = 0;
+    client_handle = RPC_LOC_CLIENT_HANDLE_INVALID;
+
+    return LOC_API_ADAPTER_ERR_SUCCESS;
+}
+
+enum loc_api_adapter_err
+LocApiRpc::startFix(const LocPosMode& posMode) {
+   LOC_LOGD("LocApiRpc::startFix() called");
+   return convertErr(
+       loc_start_fix(client_handle)
+       );
+}
+
+enum loc_api_adapter_err
+LocApiRpc::stopFix() {
+   LOC_LOGD("LocApiRpc::stopFix() called");
+   return convertErr(
+       loc_stop_fix(client_handle)
+       );
+}
+
+enum loc_api_adapter_err
+LocApiRpc::setPositionMode(const LocPosMode& posMode)
+{
+    rpc_loc_ioctl_data_u_type    ioctl_data;
+    rpc_loc_fix_criteria_s_type *fix_criteria_ptr =
+        &ioctl_data.rpc_loc_ioctl_data_u_type_u.fix_criteria;
+    rpc_loc_ioctl_e_type         ioctl_type = RPC_LOC_IOCTL_SET_FIX_CRITERIA;
+    rpc_loc_operation_mode_e_type op_mode;
+    int                          ret_val;
+    const LocPosMode* fixCriteria = &posMode;
+
+    ALOGD ("loc_eng_set_position mode, client = %d, interval = %d, mode = %d\n",
+          (int32) client_handle, fixCriteria->min_interval, fixCriteria->mode);
+
+    switch (fixCriteria->mode)
+    {
+    case LOC_POSITION_MODE_MS_BASED:
+        op_mode = RPC_LOC_OPER_MODE_MSB;
+        break;
+    case LOC_POSITION_MODE_MS_ASSISTED:
+        op_mode = RPC_LOC_OPER_MODE_MSA;
+        break;
+    case LOC_POSITION_MODE_RESERVED_1:
+        op_mode = RPC_LOC_OPER_MODE_SPEED_OPTIMAL;
+        break;
+    case LOC_POSITION_MODE_RESERVED_2:
+        op_mode = RPC_LOC_OPER_MODE_ACCURACY_OPTIMAL;
+        break;
+    case LOC_POSITION_MODE_RESERVED_3:
+        op_mode = RPC_LOC_OPER_MODE_DATA_OPTIMAL;
+        break;
+    case LOC_POSITION_MODE_RESERVED_4:
+    case LOC_POSITION_MODE_RESERVED_5:
+        op_mode = RPC_LOC_OPER_MODE_MSA;
+        fix_criteria_ptr->preferred_response_time  = 0;
+        break;
+    default:
+        op_mode = RPC_LOC_OPER_MODE_STANDALONE;
+    }
+
+    fix_criteria_ptr->valid_mask = RPC_LOC_FIX_CRIT_VALID_PREFERRED_OPERATION_MODE |
+                                   RPC_LOC_FIX_CRIT_VALID_RECURRENCE_TYPE;
+    fix_criteria_ptr->min_interval = fixCriteria->min_interval;
+    fix_criteria_ptr->preferred_operation_mode = op_mode;
+
+    fix_criteria_ptr->min_interval = fixCriteria->min_interval;
+    fix_criteria_ptr->valid_mask |= RPC_LOC_FIX_CRIT_VALID_MIN_INTERVAL;
+
+    if (fixCriteria->preferred_accuracy > 0) {
+        fix_criteria_ptr->preferred_accuracy = fixCriteria->preferred_accuracy;
+        fix_criteria_ptr->valid_mask |= RPC_LOC_FIX_CRIT_VALID_PREFERRED_ACCURACY;
+    }
+    if (fixCriteria->preferred_time > 0) {
+        fix_criteria_ptr->preferred_response_time = fixCriteria->preferred_time;
+        fix_criteria_ptr->valid_mask |= RPC_LOC_FIX_CRIT_VALID_PREFERRED_RESPONSE_TIME;
+    }
+
+    switch (fixCriteria->recurrence) {
+    case GPS_POSITION_RECURRENCE_SINGLE:
+        fix_criteria_ptr->recurrence_type = RPC_LOC_SINGLE_FIX;
+        break;
+    case GPS_POSITION_RECURRENCE_PERIODIC:
+    default:
+        fix_criteria_ptr->recurrence_type = RPC_LOC_PERIODIC_FIX;
+        break;
+    }
+    ioctl_data.disc = ioctl_type;
+
+    ret_val = loc_eng_ioctl (client_handle,
+                             ioctl_type,
+                             &ioctl_data,
+                             LOC_IOCTL_DEFAULT_TIMEOUT,
+                             NULL /* No output information is expected*/);
+
+    return convertErr(ret_val);
+}
+
+enum loc_api_adapter_err
+LocApiRpc::setTime(GpsUtcTime time, int64_t timeReference, int uncertainty)
+{
+    rpc_loc_ioctl_data_u_type        ioctl_data;
+    rpc_loc_assist_data_time_s_type *time_info_ptr;
+    rpc_loc_ioctl_e_type             ioctl_type = RPC_LOC_IOCTL_INJECT_UTC_TIME;
+    int                              ret_val;
+
+    LOC_LOGD ("loc_eng_inject_time, uncertainty = %d\n", uncertainty);
+
+    time_info_ptr = &ioctl_data.rpc_loc_ioctl_data_u_type_u.assistance_data_time;
+    time_info_ptr->time_utc = time;
+    time_info_ptr->time_utc += (int64_t)(ELAPSED_MILLIS_SINCE_BOOT_PLATFORM_LIB_ABSTRACTION - timeReference);
+    time_info_ptr->uncertainty = uncertainty; // Uncertainty in ms
+
+    ioctl_data.disc = ioctl_type;
+
+    ret_val = loc_eng_ioctl (client_handle,
+                             ioctl_type,
+                             &ioctl_data,
+                             LOC_IOCTL_DEFAULT_TIMEOUT,
+                             NULL /* No output information is expected*/);
+
+    return convertErr(ret_val);
+}
+
+enum loc_api_adapter_err
+LocApiRpc::injectPosition(double latitude, double longitude, float accuracy)
+{
+    /* IOCTL data */
+    rpc_loc_ioctl_data_u_type ioctl_data;
+    rpc_loc_assist_data_pos_s_type *assistance_data_position =
+        &ioctl_data.rpc_loc_ioctl_data_u_type_u.assistance_data_position;
+    int                          ret_val;
+
+    /************************************************
+     * Fill in latitude, longitude & accuracy
+     ************************************************/
+
+    /* This combo is required */
+    assistance_data_position->valid_mask =
+        RPC_LOC_ASSIST_POS_VALID_LATITUDE |
+        RPC_LOC_ASSIST_POS_VALID_LONGITUDE |
+        RPC_LOC_ASSIST_POS_VALID_HOR_UNC_CIRCULAR |
+        RPC_LOC_ASSIST_POS_VALID_CONFIDENCE_HORIZONTAL;
+
+    assistance_data_position->latitude = latitude;
+    assistance_data_position->longitude = longitude;
+    assistance_data_position->hor_unc_circular = accuracy; /* Meters assumed */
+    assistance_data_position->confidence_horizontal = 63;  /* 63% (1 std dev) assumed */
+
+    /* Log */
+    LOC_LOGD("Inject coarse position Lat=%lf, Lon=%lf, Acc=%.2lf\n",
+             (double) assistance_data_position->latitude,
+             (double) assistance_data_position->longitude,
+             (double) assistance_data_position->hor_unc_circular);
+
+    ret_val = loc_eng_ioctl( client_handle,
+                             RPC_LOC_IOCTL_INJECT_POSITION,
+                             &ioctl_data,
+                             LOC_IOCTL_DEFAULT_TIMEOUT,
+                             NULL /* No output information is expected*/);
+    return convertErr(ret_val);
+}
+
+enum loc_api_adapter_err
+LocApiRpc::informNiResponse(GpsUserResponseType userResponse,
+                                   const void* passThroughData)
+{
+    rpc_loc_ioctl_data_u_type data;
+    rpc_loc_ioctl_callback_s_type callback_payload;
+
+    memcpy(&data.rpc_loc_ioctl_data_u_type_u.user_verify_resp.ni_event_pass_back,
+           passThroughData, sizeof (rpc_loc_ni_event_s_type));
+
+    rpc_loc_ni_user_resp_e_type resp;
+    switch (userResponse)
+    {
+    case GPS_NI_RESPONSE_ACCEPT:
+        data.rpc_loc_ioctl_data_u_type_u.user_verify_resp.user_resp =
+            RPC_LOC_NI_LCS_NOTIFY_VERIFY_ACCEPT;
+        break;
+    case GPS_NI_RESPONSE_DENY:
+        data.rpc_loc_ioctl_data_u_type_u.user_verify_resp.user_resp =
+            RPC_LOC_NI_LCS_NOTIFY_VERIFY_DENY;
+        break;
+    case GPS_NI_RESPONSE_NORESP:
+    default:
+        data.rpc_loc_ioctl_data_u_type_u.user_verify_resp.user_resp =
+            RPC_LOC_NI_LCS_NOTIFY_VERIFY_NORESP;
+        break;
+    }
+
+    return convertErr(
+        loc_eng_ioctl(client_handle,
+                      RPC_LOC_IOCTL_INFORM_NI_USER_RESPONSE,
+                      &data,
+                      LOC_IOCTL_DEFAULT_TIMEOUT,
+                      &callback_payload)
+        );
+}
+
+enum loc_api_adapter_err
+LocApiRpc::setAPN(char* apn, int len, boolean force)
+{
+    enum loc_api_adapter_err rtv = LOC_API_ADAPTER_ERR_SUCCESS;
+    int size = sizeof(apnLastSet);
+    if (force || memcmp(apnLastSet, apn, size)) {
+        if (len < size) {
+            // size will be not larger than its original value
+            size = len + 1;
+        }
+        memcpy(apnLastSet, apn, size);
+
+        if (!isInSession()) {
+            rpc_loc_ioctl_data_u_type ioctl_data = {RPC_LOC_IOCTL_SET_LBS_APN_PROFILE, {0}};
+            ioctl_data.rpc_loc_ioctl_data_u_type_u.apn_profiles[0].srv_system_type = LOC_APN_PROFILE_SRV_SYS_MAX;
+            ioctl_data.rpc_loc_ioctl_data_u_type_u.apn_profiles[0].pdp_type = LOC_APN_PROFILE_PDN_TYPE_IPV4;
+            memcpy(&(ioctl_data.rpc_loc_ioctl_data_u_type_u.apn_profiles[0].apn_name), apn, size);
+
+            rtv = convertErr(
+                loc_eng_ioctl (client_handle,
+                               RPC_LOC_IOCTL_SET_LBS_APN_PROFILE,
+                               &ioctl_data,
+                               LOC_IOCTL_DEFAULT_TIMEOUT,
+                               NULL)
+                );
+        }
+    }
+    return rtv;
+}
+
+void LocApiRpc::setInSession(bool inSession)
+{
+    if (!inSession) {
+        enableData(dataEnableLastSet, true);
+        setAPN(apnLastSet, sizeof(apnLastSet)-1, true);
+    }
+}
+
+enum loc_api_adapter_err
+LocApiRpc::setServer(const char* url, int len)
+{
+    rpc_loc_ioctl_data_u_type         ioctl_data;
+    rpc_loc_server_info_s_type       *server_info_ptr;
+    rpc_loc_ioctl_e_type              ioctl_cmd;
+
+    ioctl_cmd = RPC_LOC_IOCTL_SET_UMTS_SLP_SERVER_ADDR;
+    ioctl_data.disc = ioctl_cmd;
+    server_info_ptr = &ioctl_data.rpc_loc_ioctl_data_u_type_u.server_addr;
+    server_info_ptr->addr_type = RPC_LOC_SERVER_ADDR_URL;
+    server_info_ptr->addr_info.disc = server_info_ptr->addr_type;
+    server_info_ptr->addr_info.rpc_loc_server_addr_u_type_u.url.length = len;
+#if (AMSS_VERSION==3200)
+    server_info_ptr->addr_info.rpc_loc_server_addr_u_type_u.url.addr.addr_val = (char*) url;
+    server_info_ptr->addr_info.rpc_loc_server_addr_u_type_u.url.addr.addr_len= len;
+#else
+    strlcpy(server_info_ptr->addr_info.rpc_loc_server_addr_u_type_u.url.addr, url,
+            sizeof server_info_ptr->addr_info.rpc_loc_server_addr_u_type_u.url.addr);
+#endif /* #if (AMSS_VERSION==3200) */
+    LOC_LOGD ("loc_eng_set_server, addr = %s\n", url);
+
+    return convertErr(
+        loc_eng_ioctl (client_handle,
+                       ioctl_cmd,
+                       &ioctl_data,
+                       LOC_IOCTL_DEFAULT_TIMEOUT,
+                       NULL /* No output information is expected*/)
+        );
+}
+
+enum loc_api_adapter_err
+LocApiRpc::setServer(unsigned int ip, int port, LocServerType type)
+{
+    rpc_loc_ioctl_data_u_type         ioctl_data;
+    rpc_loc_server_info_s_type       *server_info_ptr;
+    rpc_loc_ioctl_e_type              ioctl_cmd;
+
+    switch (type) {
+    case LOC_AGPS_MPC_SERVER:
+        ioctl_cmd = RPC_LOC_IOCTL_SET_CDMA_MPC_SERVER_ADDR;
+        break;
+    case LOC_AGPS_CUSTOM_PDE_SERVER:
+        ioctl_cmd = RPC_LOC_IOCTL_SET_CUSTOM_PDE_SERVER_ADDR;
+        break;
+    default:
+        ioctl_cmd = RPC_LOC_IOCTL_SET_CDMA_PDE_SERVER_ADDR;
+        break;
+    }
+    ioctl_data.disc = ioctl_cmd;
+    server_info_ptr = &ioctl_data.rpc_loc_ioctl_data_u_type_u.server_addr;
+    server_info_ptr->addr_type = RPC_LOC_SERVER_ADDR_IPV4;
+    server_info_ptr->addr_info.disc = server_info_ptr->addr_type;
+    server_info_ptr->addr_info.rpc_loc_server_addr_u_type_u.ipv4.addr = ip;
+    server_info_ptr->addr_info.rpc_loc_server_addr_u_type_u.ipv4.port = port;
+    LOC_LOGD ("setServer, addr = %X:%d\n", (unsigned int) ip, (unsigned int) port);
+
+    return convertErr(
+        loc_eng_ioctl (client_handle,
+                       ioctl_cmd,
+                       &ioctl_data,
+                       LOC_IOCTL_DEFAULT_TIMEOUT,
+                       NULL /* No output information is expected*/)
+        );
+}
+
+enum loc_api_adapter_err
+LocApiRpc::enableData(int enable, boolean force)
+{
+    enum loc_api_adapter_err rtv = LOC_API_ADAPTER_ERR_SUCCESS;
+    if (force || dataEnableLastSet != enable) {
+        dataEnableLastSet = enable;
+
+        if (!isInSession()) {
+            rpc_loc_ioctl_data_u_type ioctl_data = {RPC_LOC_IOCTL_SET_DATA_ENABLE, {0}};
+
+            ioctl_data.rpc_loc_ioctl_data_u_type_u.data_enable = enable;
+            rtv =  convertErr(
+                loc_eng_ioctl (client_handle,
+                               RPC_LOC_IOCTL_SET_DATA_ENABLE,
+                               &ioctl_data,
+                               LOC_IOCTL_DEFAULT_TIMEOUT,
+                               NULL)
+                );
+        }
+    }
+    return rtv;
+}
+
+enum loc_api_adapter_err
+LocApiRpc::deleteAidingData(GpsAidingData bits)
+{
+    rpc_loc_ioctl_data_u_type ioctl_data = {RPC_LOC_IOCTL_DELETE_ASSIST_DATA, {0}};
+    ioctl_data.rpc_loc_ioctl_data_u_type_u.assist_data_delete.type = bits;
+
+    return convertErr(
+        loc_eng_ioctl (client_handle,
+                       RPC_LOC_IOCTL_DELETE_ASSIST_DATA,
+                       &ioctl_data,
+                       LOC_IOCTL_DEFAULT_TIMEOUT,
+                       NULL)
+        );
+}
+
+void LocApiRpc::reportPosition(const rpc_loc_parsed_position_s_type *location_report_ptr)
+{
+    LocPosTechMask tech_Mask = LOC_POS_TECH_MASK_DEFAULT;
+
+    UlpLocation location = {0};
+    GpsLocationExtended locationExtended = {0};
+
+    location.size = sizeof(location);
+    locationExtended.size = sizeof(locationExtended);
+    if (location_report_ptr->valid_mask & RPC_LOC_POS_VALID_SESSION_STATUS)
+    {
+        // Process the position from final and intermediate reports
+        if (location_report_ptr->session_status == RPC_LOC_SESS_STATUS_SUCCESS ||
+            location_report_ptr->session_status == RPC_LOC_SESS_STATUS_IN_PROGESS)
+        {
+            // Latitude & Longitude
+            if ((location_report_ptr->valid_mask & RPC_LOC_POS_VALID_LATITUDE) &&
+                (location_report_ptr->valid_mask & RPC_LOC_POS_VALID_LONGITUDE) &&
+                (location_report_ptr->latitude != 0 ||
+                 location_report_ptr->longitude != 0))
+            {
+                location.gpsLocation.flags    |= GPS_LOCATION_HAS_LAT_LONG;
+                location.gpsLocation.latitude  = location_report_ptr->latitude;
+                location.gpsLocation.longitude = location_report_ptr->longitude;
+
+                // Time stamp (UTC)
+                if (location_report_ptr->valid_mask & RPC_LOC_POS_VALID_TIMESTAMP_UTC)
+                {
+                    location.gpsLocation.timestamp = location_report_ptr->timestamp_utc;
+                }
+
+                // Altitude
+                if (location_report_ptr->valid_mask &  RPC_LOC_POS_VALID_ALTITUDE_WRT_ELLIPSOID )
+                {
+                    location.gpsLocation.flags    |= GPS_LOCATION_HAS_ALTITUDE;
+                    location.gpsLocation.altitude = location_report_ptr->altitude_wrt_ellipsoid;
+                }
+
+                // Speed
+                if ((location_report_ptr->valid_mask & RPC_LOC_POS_VALID_SPEED_HORIZONTAL) &&
+                    (location_report_ptr->valid_mask & RPC_LOC_POS_VALID_SPEED_VERTICAL))
+                {
+                    location.gpsLocation.flags    |= GPS_LOCATION_HAS_SPEED;
+                    location.gpsLocation.speed = sqrt(location_report_ptr->speed_horizontal * location_report_ptr->speed_horizontal +
+                                          location_report_ptr->speed_vertical * location_report_ptr->speed_vertical);
+                }
+
+                // Heading
+                if (location_report_ptr->valid_mask &  RPC_LOC_POS_VALID_HEADING)
+                {
+                    location.gpsLocation.flags    |= GPS_LOCATION_HAS_BEARING;
+                    location.gpsLocation.bearing = location_report_ptr->heading;
+                }
+
+                // Uncertainty (circular)
+                if ( (location_report_ptr->valid_mask & RPC_LOC_POS_VALID_HOR_UNC_CIRCULAR) )
+                {
+                    location.gpsLocation.flags    |= GPS_LOCATION_HAS_ACCURACY;
+                    location.gpsLocation.accuracy = location_report_ptr->hor_unc_circular;
+                }
+
+                // Technology Mask
+
+                tech_Mask  |= location_report_ptr->technology_mask;
+                //Mark the location source as from GNSS
+                location.gpsLocation.flags |= LOCATION_HAS_SOURCE_INFO;
+                location.position_source = ULP_LOCATION_IS_FROM_GNSS;
+                if (location_report_ptr->valid_mask & RPC_LOC_POS_VALID_ALTITUDE_WRT_MEAN_SEA_LEVEL)
+                {
+                    locationExtended.flags |= GPS_LOCATION_EXTENDED_HAS_ALTITUDE_MEAN_SEA_LEVEL;
+                    locationExtended.altitudeMeanSeaLevel = location_report_ptr->altitude_wrt_mean_sea_level;
+                }
+
+                if (location_report_ptr->valid_mask &  RPC_LOC_POS_VALID_MAGNETIC_VARIATION )
+                {
+                    locationExtended.flags |= GPS_LOCATION_EXTENDED_HAS_MAG_DEV;
+                    locationExtended.magneticDeviation = location_report_ptr->magnetic_deviation;
+                }
+
+                if (location_report_ptr->valid_mask & RPC_LOC_POS_VALID_VERTICAL_UNC)
+                {
+                   locationExtended.flags |= GPS_LOCATION_EXTENDED_HAS_VERT_UNC;
+                   locationExtended.vert_unc = location_report_ptr->vert_unc;
+                }
+
+                if (location_report_ptr->valid_mask & RPC_LOC_POS_VALID_SPEED_UNC)
+                {
+                   locationExtended.flags |= GPS_LOCATION_EXTENDED_HAS_SPEED_UNC;
+                   locationExtended.speed_unc = location_report_ptr->speed_unc;
+                }
+
+                LOC_LOGV("reportPosition: fire callback\n");
+                enum loc_sess_status fixStatus =
+                    (location_report_ptr->session_status
+                     == RPC_LOC_SESS_STATUS_IN_PROGESS ?
+                     LOC_SESS_INTERMEDIATE : LOC_SESS_SUCCESS);
+                LocApiBase::reportPosition(location,
+                                           locationExtended,
+                                           (void*)location_report_ptr,
+                                           fixStatus,
+                                           tech_Mask);
+            }
+        }
+        else
+        {
+            LocApiBase::reportPosition(location,
+                                       locationExtended,
+                                       NULL,
+                                       LOC_SESS_FAILURE);
+            LOC_LOGV("loc_eng_report_position: ignore position report "
+                     "when session status = %d\n",
+                     location_report_ptr->session_status);
+        }
+    }
+    else
+    {
+        LOC_LOGV("loc_eng_report_position: ignore position report "
+                 "when session status is not set\n");
+    }
+}
+
+void LocApiRpc::reportSv(const rpc_loc_gnss_info_s_type *gnss_report_ptr)
+{
+    GpsSvStatus     SvStatus = {0};
+    GpsLocationExtended locationExtended = {0};
+    locationExtended.size = sizeof(locationExtended);
+    int             num_svs_max = 0;
+    const rpc_loc_sv_info_s_type *sv_info_ptr;
+
+    if (gnss_report_ptr->valid_mask & RPC_LOC_GNSS_INFO_VALID_SV_COUNT)
+    {
+        num_svs_max = gnss_report_ptr->sv_count;
+        if (num_svs_max > GPS_MAX_SVS)
+        {
+            num_svs_max = GPS_MAX_SVS;
+        }
+    }
+
+    if (gnss_report_ptr->valid_mask & RPC_LOC_GNSS_INFO_VALID_SV_LIST)
+    {
+        SvStatus.num_svs = 0;
+
+        for (int i = 0; i < num_svs_max; i++)
+        {
+            sv_info_ptr = &(gnss_report_ptr->sv_list.sv_list_val[i]);
+            if (sv_info_ptr->valid_mask & RPC_LOC_SV_INFO_VALID_SYSTEM)
+            {
+                if (sv_info_ptr->system == RPC_LOC_SV_SYSTEM_GPS)
+                {
+                    SvStatus.sv_list[SvStatus.num_svs].size = sizeof(GpsSvStatus);
+                    SvStatus.sv_list[SvStatus.num_svs].prn = sv_info_ptr->prn;
+
+                    // We only have the data field to report gps eph and alm mask
+                    if ((sv_info_ptr->valid_mask & RPC_LOC_SV_INFO_VALID_HAS_EPH) &&
+                        (sv_info_ptr->has_eph == 1))
+                    {
+                        SvStatus.ephemeris_mask |= (1 << (sv_info_ptr->prn-1));
+                    }
+
+                    if ((sv_info_ptr->valid_mask & RPC_LOC_SV_INFO_VALID_HAS_ALM) &&
+                        (sv_info_ptr->has_alm == 1))
+                    {
+                        SvStatus.almanac_mask |= (1 << (sv_info_ptr->prn-1));
+                    }
+
+                    if ((sv_info_ptr->valid_mask & RPC_LOC_SV_INFO_VALID_PROCESS_STATUS) &&
+                        (sv_info_ptr->process_status == RPC_LOC_SV_STATUS_TRACK))
+                    {
+                        SvStatus.used_in_fix_mask |= (1 << (sv_info_ptr->prn-1));
+                    }
+                }
+                // SBAS: GPS RPN: 120-151,
+                // In exteneded measurement report, we follow nmea standard, which is from 33-64.
+                else if (sv_info_ptr->system == RPC_LOC_SV_SYSTEM_SBAS)
+                {
+                    SvStatus.sv_list[SvStatus.num_svs].prn = sv_info_ptr->prn + 33 - 120;
+                }
+                // Gloness: Slot id: 1-32
+                // In extended measurement report, we follow nmea standard, which is 65-96
+                else if (sv_info_ptr->system == RPC_LOC_SV_SYSTEM_GLONASS)
+                {
+                    SvStatus.sv_list[SvStatus.num_svs].prn = sv_info_ptr->prn + (65-1);
+                }
+                // Unsupported SV system
+                else
+                {
+                    continue;
+                }
+            }
+
+            if (sv_info_ptr->valid_mask & RPC_LOC_SV_INFO_VALID_SNR)
+            {
+                SvStatus.sv_list[SvStatus.num_svs].snr = sv_info_ptr->snr;
+            }
+
+            if (sv_info_ptr->valid_mask & RPC_LOC_SV_INFO_VALID_ELEVATION)
+            {
+                SvStatus.sv_list[SvStatus.num_svs].elevation = sv_info_ptr->elevation;
+            }
+
+            if (sv_info_ptr->valid_mask & RPC_LOC_SV_INFO_VALID_AZIMUTH)
+            {
+                SvStatus.sv_list[SvStatus.num_svs].azimuth = sv_info_ptr->azimuth;
+            }
+
+            SvStatus.num_svs++;
+        }
+    }
+
+    if ((gnss_report_ptr->valid_mask & RPC_LOC_GNSS_INFO_VALID_POS_DOP) &&
+        (gnss_report_ptr->valid_mask & RPC_LOC_GNSS_INFO_VALID_HOR_DOP) &&
+        (gnss_report_ptr->valid_mask & RPC_LOC_GNSS_INFO_VALID_VERT_DOP))
+    {
+        locationExtended.flags |= GPS_LOCATION_EXTENDED_HAS_DOP;
+        locationExtended.pdop = gnss_report_ptr->position_dop;
+        locationExtended.hdop = gnss_report_ptr->horizontal_dop;
+        locationExtended.vdop = gnss_report_ptr->vertical_dop;
+    }
+
+    if (SvStatus.num_svs >= 0)
+    {
+        LocApiBase::reportSv(SvStatus,
+                             locationExtended,
+                             (void*)gnss_report_ptr);
+    }
+}
+
+void LocApiRpc::reportStatus(const rpc_loc_status_event_s_type *status_report_ptr)
+{
+
+    if (status_report_ptr->event == RPC_LOC_STATUS_EVENT_ENGINE_STATE) {
+        if (status_report_ptr->payload.rpc_loc_status_event_payload_u_type_u.engine_state == RPC_LOC_ENGINE_STATE_ON)
+        {
+            LocApiBase::reportStatus(GPS_STATUS_ENGINE_ON);
+            LocApiBase::reportStatus(GPS_STATUS_SESSION_BEGIN);
+        }
+        else if (status_report_ptr->payload.rpc_loc_status_event_payload_u_type_u.engine_state == RPC_LOC_ENGINE_STATE_OFF)
+        {
+            LocApiBase::reportStatus(GPS_STATUS_SESSION_END);
+            LocApiBase::reportStatus(GPS_STATUS_ENGINE_OFF);
+        }
+        else
+        {
+            LocApiBase::reportStatus(GPS_STATUS_NONE);
+        }
+    }
+
+}
+
+void LocApiRpc::reportNmea(const rpc_loc_nmea_report_s_type *nmea_report_ptr)
+{
+
+#if (AMSS_VERSION==3200)
+    LocApiBase::reportNmea(nmea_report_ptr->nmea_sentences.nmea_sentences_val,
+                           nmea_report_ptr->nmea_sentences.nmea_sentences_len);
+#else
+    LocApiBase::reportNmea(nmea_report_ptr->nmea_sentences,
+                           nmea_report_ptr->length);
+    LOC_LOGD("loc_eng_report_nmea: $%c%c%c\n",
+             nmea_report_ptr->nmea_sentences[3],
+             nmea_report_ptr->nmea_sentences[4],
+             nmea_report_ptr->nmea_sentences[5]);
+#endif /* #if (AMSS_VERSION==3200) */
+}
+
+enum loc_api_adapter_err
+LocApiRpc::setXtraData(char* data, int length)
+{
+    int     rpc_ret_val = RPC_LOC_API_GENERAL_FAILURE;
+    int     total_parts;
+    uint8   part;
+    uint16  part_len;
+    uint16  len_injected;
+    rpc_loc_ioctl_data_u_type            ioctl_data;
+    rpc_loc_ioctl_e_type                 ioctl_type = RPC_LOC_IOCTL_INJECT_PREDICTED_ORBITS_DATA;
+    rpc_loc_predicted_orbits_data_s_type *predicted_orbits_data_ptr;
+
+    LOC_LOGD("qct_loc_eng_inject_xtra_data, xtra size = %d, data ptr = 0x%lx\n", length, (long) data);
+
+    predicted_orbits_data_ptr = &ioctl_data.rpc_loc_ioctl_data_u_type_u.predicted_orbits_data;
+    predicted_orbits_data_ptr->format_type = RPC_LOC_PREDICTED_ORBITS_XTRA;
+    predicted_orbits_data_ptr->total_size = length;
+    total_parts = (length - 1) / XTRA_BLOCK_SIZE + 1;
+    predicted_orbits_data_ptr->total_parts = total_parts;
+
+    len_injected = 0; // O bytes injected
+    ioctl_data.disc = ioctl_type;
+
+    // XTRA injection starts with part 1
+    for (part = 1; part <= total_parts; part++)
+    {
+        predicted_orbits_data_ptr->part = part;
+        predicted_orbits_data_ptr->part_len = XTRA_BLOCK_SIZE;
+        if (XTRA_BLOCK_SIZE > (length - len_injected))
+        {
+            predicted_orbits_data_ptr->part_len = length - len_injected;
+        }
+        predicted_orbits_data_ptr->data_ptr.data_ptr_len = predicted_orbits_data_ptr->part_len;
+        predicted_orbits_data_ptr->data_ptr.data_ptr_val = data + len_injected;
+
+        LOC_LOGD("qct_loc_eng_inject_xtra_data, part %d/%d, len = %d, total = %d\n",
+                 predicted_orbits_data_ptr->part,
+                 total_parts,
+                 predicted_orbits_data_ptr->part_len,
+                 len_injected);
+
+        if (part < total_parts)
+        {
+            // No callback in this case
+            rpc_ret_val = loc_ioctl (client_handle,
+                                     ioctl_type,
+                                     &ioctl_data);
+
+            if (rpc_ret_val != RPC_LOC_API_SUCCESS)
+            {
+                LOC_LOGE("loc_ioctl for xtra error: %s\n", loc_get_ioctl_status_name(rpc_ret_val));
+                break;
+            }
+            //Add a delay of 10 ms so that repeated RPC calls dont starve the modem processor
+            usleep(10 * 1000);
+        }
+        else // part == total_parts
+        {
+            // Last part injection, will need to wait for callback
+            if (!loc_eng_ioctl(client_handle,
+                               ioctl_type,
+                               &ioctl_data,
+                               LOC_XTRA_INJECT_DEFAULT_TIMEOUT,
+                               NULL))
+            {
+                rpc_ret_val = RPC_LOC_API_GENERAL_FAILURE;
+            }
+            break; // done with injection
+        }
+
+        len_injected += predicted_orbits_data_ptr->part_len;
+        LOC_LOGD("loc_ioctl XTRA injected length: %d\n", len_injected);
+    }
+
+    return convertErr(rpc_ret_val);
+}
+
+/* Request the Xtra Server Url from the modem */
+enum loc_api_adapter_err
+LocApiRpc::requestXtraServer()
+{
+    loc_api_adapter_err           err;
+    rpc_loc_ioctl_data_u_type     data;
+    rpc_loc_ioctl_callback_s_type callback_data;
+
+    err = convertErr(loc_eng_ioctl(client_handle,
+                                   RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_SOURCE,
+                                   &data,
+                                   LOC_IOCTL_DEFAULT_TIMEOUT,
+                                   &callback_data));
+
+    if (LOC_API_ADAPTER_ERR_SUCCESS != err)
+    {
+        LOC_LOGE("RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_SOURCE failed!: err=%d\n", err);
+        return err;
+    }
+    else if (RPC_LOC_SESS_STATUS_SUCCESS != callback_data.status)
+    {
+        LOC_LOGE("RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_SOURCE failed!: status=%ld\n", callback_data.status);
+        return LOC_API_ADAPTER_ERR_GENERAL_FAILURE;
+    }
+    else if (RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_SOURCE != callback_data.type)
+    {
+        LOC_LOGE("RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_SOURCE is not the type expected! type=%d\n", callback_data.type);
+        return LOC_API_ADAPTER_ERR_GENERAL_FAILURE;
+    }
+    else if (RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_SOURCE != callback_data.data.disc)
+    {
+        LOC_LOGE("RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_SOURCE is not the disc expected! disc=%d\n", callback_data.data.disc);
+        return LOC_API_ADAPTER_ERR_GENERAL_FAILURE;
+    }
+
+    reportXtraServer(callback_data.data.rpc_loc_ioctl_callback_data_u_type_u.
+                     predicted_orbits_data_source.servers[0],
+                     callback_data.data.rpc_loc_ioctl_callback_data_u_type_u.
+                     predicted_orbits_data_source.servers[1],
+                     callback_data.data.rpc_loc_ioctl_callback_data_u_type_u.
+                     predicted_orbits_data_source.servers[2],
+                     255);
+
+    return LOC_API_ADAPTER_ERR_SUCCESS;
+}
+
+enum loc_api_adapter_err
+LocApiRpc::atlOpenStatus(int handle, int is_succ, char* apn, AGpsBearerType bearer, AGpsType agpsType)
+{
+    rpc_loc_server_open_status_e_type open_status = is_succ ? RPC_LOC_SERVER_OPEN_SUCCESS : RPC_LOC_SERVER_OPEN_FAIL;
+   rpc_loc_ioctl_data_u_type           ioctl_data;
+
+    if (AGPS_TYPE_INVALID == agpsType) {
+        rpc_loc_server_open_status_s_type  *conn_open_status_ptr =
+            &ioctl_data.rpc_loc_ioctl_data_u_type_u.conn_open_status;
+
+        // Fill in data
+        ioctl_data.disc = RPC_LOC_IOCTL_INFORM_SERVER_OPEN_STATUS;
+        conn_open_status_ptr->conn_handle = handle;
+        conn_open_status_ptr->open_status = open_status;
+#if (AMSS_VERSION==3200)
+        conn_open_status_ptr->apn_name = apn; /* requires APN */
+#else
+        if (is_succ) {
+            strlcpy(conn_open_status_ptr->apn_name, apn,
+                    sizeof conn_open_status_ptr->apn_name);
+        } else {
+            conn_open_status_ptr->apn_name[0] = 0;
+        }
+#endif /* #if (AMSS_VERSION==3200) */
+
+        LOC_LOGD("ATL RPC_LOC_IOCTL_INFORM_SERVER_OPEN_STATUS open %s, APN name = [%s]\n",
+                 log_succ_fail_string(is_succ),
+                 apn);
+    } else {
+        rpc_loc_server_multi_open_status_s_type  *conn_multi_open_status_ptr =
+            &ioctl_data.rpc_loc_ioctl_data_u_type_u.multi_conn_open_status;
+
+        // Fill in data
+        ioctl_data.disc = RPC_LOC_IOCTL_INFORM_SERVER_MULTI_OPEN_STATUS;
+        conn_multi_open_status_ptr->conn_handle = handle;
+        conn_multi_open_status_ptr->open_status = open_status;
+        if (is_succ) {
+            strlcpy(conn_multi_open_status_ptr->apn_name, apn,
+                    sizeof conn_multi_open_status_ptr->apn_name);
+        } else {
+            conn_multi_open_status_ptr->apn_name[0] = 0;
+        }
+
+        switch(bearer)
+        {
+        case AGPS_APN_BEARER_IPV4:
+            conn_multi_open_status_ptr->pdp_type = RPC_LOC_SERVER_PDP_IP;
+            break;
+        case AGPS_APN_BEARER_IPV6:
+            conn_multi_open_status_ptr->pdp_type = RPC_LOC_SERVER_PDP_IPV6;
+            break;
+        case AGPS_APN_BEARER_IPV4V6:
+            conn_multi_open_status_ptr->pdp_type = RPC_LOC_SERVER_PDP_IPV4V6;
+            break;
+        default:
+            conn_multi_open_status_ptr->pdp_type = RPC_LOC_SERVER_PDP_PPP;
+        }
+
+        LOC_LOGD("ATL RPC_LOC_IOCTL_INFORM_SERVER_MULTI_OPEN_STATUS open %s, APN name = [%s], pdp_type = %d\n",
+                 log_succ_fail_string(is_succ),
+                 apn,
+                 conn_multi_open_status_ptr->pdp_type);
+    }
+
+    // Make the IOCTL call
+    return convertErr(
+        loc_eng_ioctl(client_handle,
+                      ioctl_data.disc,
+                      &ioctl_data,
+                      LOC_IOCTL_DEFAULT_TIMEOUT,
+                      NULL)
+        );
+}
+
+enum loc_api_adapter_err
+LocApiRpc::atlCloseStatus(int handle, int is_succ)
+{
+    rpc_loc_ioctl_data_u_type           ioctl_data;
+    ioctl_data.disc = RPC_LOC_IOCTL_INFORM_SERVER_CLOSE_STATUS;
+
+    rpc_loc_server_close_status_s_type *conn_close_status_ptr =
+        &ioctl_data.rpc_loc_ioctl_data_u_type_u.conn_close_status;
+    conn_close_status_ptr->conn_handle = handle;
+    conn_close_status_ptr->close_status = is_succ ? RPC_LOC_SERVER_CLOSE_SUCCESS : RPC_LOC_SERVER_CLOSE_FAIL;
+
+    // Make the IOCTL call
+    return convertErr(
+        loc_eng_ioctl(client_handle,
+                      ioctl_data.disc,
+                      &ioctl_data,
+                      LOC_IOCTL_DEFAULT_TIMEOUT,
+                      NULL)
+        );
+}
+
+void LocApiRpc::ATLEvent(const rpc_loc_server_request_s_type *server_request_ptr)
+{
+    int connHandle;
+    AGpsType agps_type;
+
+    LOC_LOGV("RPC_LOC_EVENT_ASSISTANCE_DATA_REQUEST event %s)",
+             loc_get_event_atl_open_name(server_request_ptr->event));
+    switch (server_request_ptr->event)
+    {
+    case RPC_LOC_SERVER_REQUEST_MULTI_OPEN:
+        connHandle = server_request_ptr->payload.rpc_loc_server_request_u_type_u.multi_open_req.conn_handle;
+        if (server_request_ptr->payload.rpc_loc_server_request_u_type_u.multi_open_req.connection_type
+            == RPC_LOC_SERVER_CONNECTION_LBS) {
+            agps_type = AGPS_TYPE_SUPL;
+            LOC_LOGV("ATLEvent: event - RPC_LOC_SERVER_REQUEST_MULTI_OPEN\n            type - AGPS_TYPE_SUPL\n            handle - %d", connHandle);
+        } else {
+            agps_type = AGPS_TYPE_WWAN_ANY;
+            LOC_LOGV("ATLEvent: event - RPC_LOC_SERVER_REQUEST_MULTI_OPEN\n            type - AGPS_TYPE_WWAN_ANY\n            handle - %d", connHandle);
+        }
+        requestATL(connHandle, agps_type);
+        break;
+    case RPC_LOC_SERVER_REQUEST_OPEN:
+        connHandle = server_request_ptr->payload.rpc_loc_server_request_u_type_u.open_req.conn_handle;
+        LOC_LOGV("ATLEvent: event - RPC_LOC_SERVER_REQUEST_OPEN\n            handle - %d", connHandle);
+        requestATL(connHandle, AGPS_TYPE_INVALID);
+        break;
+    case RPC_LOC_SERVER_REQUEST_CLOSE:
+        connHandle = server_request_ptr->payload.rpc_loc_server_request_u_type_u.close_req.conn_handle;
+        LOC_LOGV("ATLEvent: event - RPC_LOC_SERVER_REQUEST_CLOSE\n            handle - %d", connHandle);
+        releaseATL(connHandle);
+        break;
+    default:
+        LOC_LOGE("ATLEvent: event type %d invalid", server_request_ptr->event);
+   }
+}
+
+void LocApiRpc::NIEvent(const rpc_loc_ni_event_s_type *ni_req)
+{
+    GpsNiNotification notif = {0};
+
+    switch (ni_req->event)
+    {
+    case RPC_LOC_NI_EVENT_VX_NOTIFY_VERIFY_REQ:
+    {
+        const rpc_loc_ni_vx_notify_verify_req_s_type *vx_req =
+            &ni_req->payload.rpc_loc_ni_event_payload_u_type_u.vx_req;
+        LOC_LOGI("VX Notification");
+        notif.ni_type = GPS_NI_TYPE_VOICE;
+        // Requestor ID
+        hexcode(notif.requestor_id, sizeof notif.requestor_id,
+                vx_req->requester_id.requester_id,
+                vx_req->requester_id.requester_id_length);
+        notif.text_encoding = 0; // No text and no encoding
+        notif.requestor_id_encoding = convertNiEncodingType(vx_req->encoding_scheme);
+        NIEventFillVerfiyType(notif, vx_req->notification_priv_type);
+    }
+        break;
+
+    case RPC_LOC_NI_EVENT_UMTS_CP_NOTIFY_VERIFY_REQ:
+    {
+        const rpc_loc_ni_umts_cp_notify_verify_req_s_type *umts_cp_req =
+            &ni_req->payload.rpc_loc_ni_event_payload_u_type_u.umts_cp_req;
+        LOC_LOGI("UMTS CP Notification\n");
+        notif.ni_type= GPS_NI_TYPE_UMTS_CTRL_PLANE;         // Stores notification text
+#if (AMSS_VERSION==3200)
+        hexcode(notif.text, sizeof notif.text,
+                umts_cp_req->notification_text.notification_text_val,
+                umts_cp_req->notification_length);
+        hexcode(notif.requestor_id, sizeof notif.requestor_id,
+                umts_cp_req->requestor_id.requestor_id_string.requestor_id_string_val,
+                umts_cp_req->requestor_id.string_len);
+#else
+        hexcode(notif.text, sizeof notif.text,
+                umts_cp_req->notification_text,
+                umts_cp_req->notification_length);
+        hexcode(notif.requestor_id, sizeof notif.requestor_id,
+                umts_cp_req->requestor_id.requestor_id_string,
+                umts_cp_req->requestor_id.string_len);
+#endif
+        notif.text_encoding = convertNiEncodingType(umts_cp_req->datacoding_scheme);
+        notif.requestor_id_encoding = notif.text_encoding;
+        NIEventFillVerfiyType(notif, umts_cp_req->notification_priv_type);
+
+        // LCS address (using extras field)
+        if (umts_cp_req->ext_client_address_data.ext_client_address_len != 0)
+        {
+            // Copy LCS Address into notif.extras in the format: Address = 012345
+            strlcat(notif.extras, LOC_NI_NOTIF_KEY_ADDRESS, sizeof notif.extras);
+            strlcat(notif.extras, " = ", sizeof notif.extras);
+            int addr_len = 0;
+            const char *address_source = NULL;
+
+#if (AMSS_VERSION==3200)
+            address_source = umts_cp_req->ext_client_address_data.ext_client_address.ext_client_address_val;
+#else
+            address_source = umts_cp_req->ext_client_address_data.ext_client_address;
+#endif /* #if (AMSS_VERSION==3200) */
+
+            char lcs_addr[32]; // Decoded LCS address for UMTS CP NI
+            addr_len = decodeAddress(lcs_addr, sizeof lcs_addr, address_source,
+                                     umts_cp_req->ext_client_address_data.ext_client_address_len);
+
+            // The address is ASCII string
+            if (addr_len)
+            {
+                strlcat(notif.extras, lcs_addr, sizeof notif.extras);
+            }
+        }
+    }
+        break;
+
+    case RPC_LOC_NI_EVENT_SUPL_NOTIFY_VERIFY_REQ:
+    {
+        const rpc_loc_ni_supl_notify_verify_req_s_type *supl_req =
+            &ni_req->payload.rpc_loc_ni_event_payload_u_type_u.supl_req;
+        LOC_LOGI("SUPL Notification\n");
+        notif.ni_type = GPS_NI_TYPE_UMTS_SUPL;
+
+        if (supl_req->flags & RPC_LOC_NI_CLIENT_NAME_PRESENT)
+        {
+#if (AMSS_VERSION==3200)
+            hexcode(notif.text, sizeof notif.text,
+                    supl_req->client_name.client_name_string.client_name_string_val,   /* buffer */
+                    supl_req->client_name.string_len                                   /* length */
+            );
+#else
+            hexcode(notif.text, sizeof notif.text,
+                            supl_req->client_name.client_name_string,   /* buffer */
+                            supl_req->client_name.string_len            /* length */
+            );
+#endif /* #if (AMSS_VERSION==3200) */
+            LOC_LOGV("SUPL NI: client_name: %s len=%d", notif.text, supl_req->client_name.string_len);
+        }
+        else {
+            LOC_LOGV("SUPL NI: client_name not present.");
+        }
+
+        // Requestor ID
+        if (supl_req->flags & RPC_LOC_NI_REQUESTOR_ID_PRESENT)
+        {
+#if (AMSS_VERSION==3200)
+            hexcode(notif.requestor_id, sizeof notif.requestor_id,
+                    supl_req->requestor_id.requestor_id_string.requestor_id_string_val,  /* buffer */
+                    supl_req->requestor_id.string_len                                    /* length */
+                );
+#else
+            hexcode(notif.requestor_id, sizeof notif.requestor_id,
+                    supl_req->requestor_id.requestor_id_string,  /* buffer */
+                    supl_req->requestor_id.string_len            /* length */
+                );
+#endif /* #if (AMSS_VERSION==3200) */
+            LOC_LOGV("SUPL NI: requestor_id: %s len=%d", notif.requestor_id, supl_req->requestor_id.string_len);
+        }
+        else {
+            LOC_LOGV("SUPL NI: requestor_id not present.");
+        }
+
+        // Encoding type
+        if (supl_req->flags & RPC_LOC_NI_ENCODING_TYPE_PRESENT)
+        {
+            notif.text_encoding = convertNiEncodingType(supl_req->datacoding_scheme);
+            notif.requestor_id_encoding = notif.text_encoding;
+        }
+        else {
+            notif.text_encoding = notif.requestor_id_encoding = GPS_ENC_UNKNOWN;
+        }
+
+        NIEventFillVerfiyType(notif, ni_req->payload.rpc_loc_ni_event_payload_u_type_u.supl_req.notification_priv_type);
+    }
+        break;
+
+    default:
+        LOC_LOGE("Unknown NI event: %x\n", (int) ni_req->event);
+        return;
+    }
+
+    // this copy will get freed in loc_eng_ni when loc_ni_respond() is called
+    rpc_loc_ni_event_s_type *copy = (rpc_loc_ni_event_s_type *)malloc(sizeof(*copy));
+    memcpy(copy, ni_req, sizeof(*copy));
+    requestNiNotify(notif, (const void*)copy);
+}
+
+int LocApiRpc::NIEventFillVerfiyType(GpsNiNotification &notif,
+                                rpc_loc_ni_notify_verify_e_type notif_priv)
+{
+   switch (notif_priv)
+   {
+   case RPC_LOC_NI_USER_NO_NOTIFY_NO_VERIFY:
+       notif.notify_flags = 0;
+       notif.default_response = GPS_NI_RESPONSE_NORESP;
+       return 1;
+   case RPC_LOC_NI_USER_NOTIFY_ONLY:
+       notif.notify_flags = GPS_NI_NEED_NOTIFY;
+       notif.default_response = GPS_NI_RESPONSE_NORESP;
+       return 1;
+   case RPC_LOC_NI_USER_NOTIFY_VERIFY_ALLOW_NO_RESP:
+       notif.notify_flags = GPS_NI_NEED_NOTIFY | GPS_NI_NEED_VERIFY;
+       notif.default_response = GPS_NI_RESPONSE_ACCEPT;
+       return 1;
+   case RPC_LOC_NI_USER_NOTIFY_VERIFY_NOT_ALLOW_NO_RESP:
+       notif.notify_flags = GPS_NI_NEED_NOTIFY | GPS_NI_NEED_VERIFY;
+       notif.default_response = GPS_NI_RESPONSE_DENY;
+       return 1;
+   case RPC_LOC_NI_USER_PRIVACY_OVERRIDE:
+       notif.notify_flags = GPS_NI_PRIVACY_OVERRIDE;
+       notif.default_response = GPS_NI_RESPONSE_NORESP;
+       return 1;
+   default:
+      return 0;
+   }
+}
+
+enum loc_api_adapter_err
+LocApiRpc::setSUPLVersion(uint32_t version)
+{
+   rpc_loc_ioctl_data_u_type ioctl_data = {RPC_LOC_IOCTL_SET_SUPL_VERSION, {0}};
+   ioctl_data.rpc_loc_ioctl_data_u_type_u.supl_version = (int)version;
+   return convertErr(
+       loc_eng_ioctl (client_handle,
+                      RPC_LOC_IOCTL_SET_SUPL_VERSION,
+                      &ioctl_data,
+                      LOC_IOCTL_DEFAULT_TIMEOUT,
+                      NULL)
+       );
+}
+
+GpsNiEncodingType LocApiRpc::convertNiEncodingType(int loc_encoding)
+{
+   switch (loc_encoding)
+   {
+   case RPC_LOC_NI_SUPL_UTF8:
+       return GPS_ENC_SUPL_UTF8;
+   case RPC_LOC_NI_SUPL_UCS2:
+       return GPS_ENC_SUPL_UCS2;
+   case RPC_LOC_NI_SUPL_GSM_DEFAULT:
+      return GPS_ENC_SUPL_GSM_DEFAULT;
+   case RPC_LOC_NI_SS_LANGUAGE_UNSPEC:
+      return GPS_ENC_SUPL_GSM_DEFAULT; // SS_LANGUAGE_UNSPEC = GSM
+   default:
+       return GPS_ENC_UNKNOWN;
+   }
+}
+
+LocApiBase* getLocApi(const MsgTask* msgTask,
+                      LOC_API_ADAPTER_EVENT_MASK_T exMask,
+                      ContextBase *context) {
+    return new LocApiRpc(msgTask, exMask, context);
+}
+
+/*Values for lock
+  1 = Do not lock any position sessions
+  2 = Lock MI position sessions
+  3 = Lock MT position sessions
+  4 = Lock all position sessions
+*/
+int LocApiRpc::setGpsLock(LOC_GPS_LOCK_MASK lockMask)
+{
+    rpc_loc_ioctl_data_u_type    ioctl_data;
+    boolean ret_val;
+    LOC_LOGD("%s:%d]: lock: %x\n", __func__, __LINE__, lockMask);
+    ioctl_data.rpc_loc_ioctl_data_u_type_u.engine_lock = convertGpsLockMask(lockMask);
+    ioctl_data.disc = RPC_LOC_IOCTL_SET_ENGINE_LOCK;
+    ret_val = loc_eng_ioctl (loc_eng_data.client_handle,
+                            RPC_LOC_IOCTL_SET_ENGINE_LOCK,
+                            &ioctl_data,
+                            LOC_IOCTL_DEFAULT_TIMEOUT,
+                            NULL /* No output information is expected*/);
+
+    LOC_LOGD("%s:%d]: ret_val: %d\n", __func__, __LINE__, (int)ret_val);
+    return (ret_val == TRUE ? 0 : -1);
+}
+
+/*
+  Returns
+  Current value of GPS lock on success
+  -1 on failure
+*/
+int LocApiRpc :: getGpsLock()
+{
+    rpc_loc_ioctl_data_u_type    ioctl_data;
+    rpc_loc_ioctl_callback_s_type callback_payload;
+    boolean ret_val;
+    int ret=0;
+    LOC_LOGD("%s:%d]: Enter\n", __func__, __LINE__);
+    ret_val = loc_eng_ioctl (loc_eng_data.client_handle,
+                            RPC_LOC_IOCTL_GET_ENGINE_LOCK,
+                            &ioctl_data,
+                            LOC_IOCTL_DEFAULT_TIMEOUT,
+                            &callback_payload);
+    if(ret_val == TRUE) {
+        ret = (int)callback_payload.data.engine_lock;
+        LOC_LOGD("%s:%d]: Lock type: %d\n", __func__, __LINE__, ret);
+    }
+    else {
+        LOC_LOGE("%s:%d]: Ioctl failed", __func__, __LINE__);
+        ret = -1;
+    }
+    LOC_LOGD("%s:%d]: Exit\n", __func__, __LINE__);
+    return ret;
+}
diff --git a/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/src/loc_api_fixup.c b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/src/loc_api_fixup.c
new file mode 100644
index 0000000..837ef11
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/src/loc_api_fixup.c
@@ -0,0 +1,52 @@
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <rpc/rpc.h>
+
+#include "loc_api_fixup.h"
+
+#ifdef ADD_XDR_FLOAT
+
+int
+xdr_float(xdrp, fp)
+        XDR *xdrp;
+        float *fp;
+{
+        return xdr_long(xdrp, (long*)fp);
+}
+
+int
+xdr_double(xdrp, dp)
+        XDR *xdrp;
+        double *dp;
+{
+                return xdr_long(xdrp, (long*)dp + 1)
+                                && xdr_long(xdrp, (long*)dp);
+}
+
+#endif /* ADD_XDR_FLOAT */
diff --git a/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/src/loc_api_log.c b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/src/loc_api_log.c
new file mode 100644
index 0000000..1c48232
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/src/loc_api_log.c
@@ -0,0 +1,345 @@
+/* Copyright (c) 2011 The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#define LOG_NDDEBUG 0
+#define LOG_TAG "LocSvc_api_rpc_glue"
+
+#include "loc_api_log.h"
+#include "loc_log.h"
+#include "log_util.h"
+#include "platform_lib_includes.h"
+#include "rpc/rpc.h"
+#include "loc_api_fixup.h"
+
+/* Event names */
+loc_name_val_s_type loc_event_name[] =
+   {
+      NAME_VAL( RPC_LOC_EVENT_PARSED_POSITION_REPORT ),
+      NAME_VAL( RPC_LOC_EVENT_SATELLITE_REPORT ),
+      NAME_VAL( RPC_LOC_EVENT_NMEA_1HZ_REPORT ),
+      NAME_VAL( RPC_LOC_EVENT_NMEA_POSITION_REPORT ),
+      NAME_VAL( RPC_LOC_EVENT_NI_NOTIFY_VERIFY_REQUEST ),
+      NAME_VAL( RPC_LOC_EVENT_ASSISTANCE_DATA_REQUEST ),
+      NAME_VAL( RPC_LOC_EVENT_LOCATION_SERVER_REQUEST ),
+      NAME_VAL( RPC_LOC_EVENT_IOCTL_REPORT ),
+      NAME_VAL( RPC_LOC_EVENT_STATUS_REPORT ),
+      NAME_VAL( RPC_LOC_EVENT_WPS_NEEDED_REQUEST ),
+   };
+int loc_event_num = sizeof loc_event_name / sizeof(loc_name_val_s_type);
+
+/* Event names */
+loc_name_val_s_type loc_event_atl_open_name[] =
+   {
+      NAME_VAL( RPC_LOC_SERVER_REQUEST_OPEN ),
+      NAME_VAL( RPC_LOC_SERVER_REQUEST_CLOSE ),
+      NAME_VAL( RPC_LOC_SERVER_REQUEST_MULTI_OPEN )
+   };
+int loc_event_atl_open_num = sizeof loc_event_atl_open_name / sizeof(loc_name_val_s_type);
+
+/* Finds the first event found in the mask */
+const char* loc_get_event_atl_open_name(rpc_loc_server_request_e_type loc_event_atl_open)
+{
+   return loc_get_name_from_val(loc_event_atl_open_name, loc_event_atl_open_num,
+         (long) loc_event_atl_open);
+}
+
+/* IOCTL Type names */
+loc_name_val_s_type loc_ioctl_type_name[] =
+   {
+      NAME_VAL( RPC_LOC_IOCTL_GET_API_VERSION ),
+      NAME_VAL( RPC_LOC_IOCTL_SET_FIX_CRITERIA ),
+      NAME_VAL( RPC_LOC_IOCTL_GET_FIX_CRITERIA ),
+      NAME_VAL( RPC_LOC_IOCTL_INFORM_NI_USER_RESPONSE ),
+      NAME_VAL( RPC_LOC_IOCTL_INJECT_PREDICTED_ORBITS_DATA ),
+      NAME_VAL( RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_VALIDITY ),
+      NAME_VAL( RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_SOURCE ),
+      NAME_VAL( RPC_LOC_IOCTL_SET_PREDICTED_ORBITS_DATA_AUTO_DOWNLOAD ),
+      NAME_VAL( RPC_LOC_IOCTL_INJECT_UTC_TIME ),
+      NAME_VAL( RPC_LOC_IOCTL_INJECT_RTC_VALUE ),
+      NAME_VAL( RPC_LOC_IOCTL_INJECT_POSITION ),
+      NAME_VAL( RPC_LOC_IOCTL_QUERY_ENGINE_STATE ),
+      NAME_VAL( RPC_LOC_IOCTL_ERROR_ESTIMATE_CONFIG),
+      NAME_VAL( RPC_LOC_IOCTL_INFORM_SERVER_MULTI_OPEN_STATUS ),
+      NAME_VAL( RPC_LOC_IOCTL_INFORM_SERVER_OPEN_STATUS ),
+      NAME_VAL( RPC_LOC_IOCTL_INFORM_SERVER_CLOSE_STATUS ),
+      NAME_VAL( RPC_LOC_IOCTL_SEND_WIPER_POSITION_REPORT ),
+      NAME_VAL( RPC_LOC_IOCTL_NOTIFY_WIPER_STATUS ),
+      NAME_VAL( RPC_LOC_IOCTL_SET_ENGINE_LOCK ),
+      NAME_VAL( RPC_LOC_IOCTL_GET_ENGINE_LOCK ),
+      NAME_VAL( RPC_LOC_IOCTL_SET_SBAS_CONFIG ),
+      NAME_VAL( RPC_LOC_IOCTL_GET_SBAS_CONFIG ),
+      NAME_VAL( RPC_LOC_IOCTL_SET_NMEA_TYPES ),
+      NAME_VAL( RPC_LOC_IOCTL_GET_NMEA_TYPES ),
+      NAME_VAL( RPC_LOC_IOCTL_SET_CDMA_PDE_SERVER_ADDR ),
+      NAME_VAL( RPC_LOC_IOCTL_GET_CDMA_PDE_SERVER_ADDR ),
+      NAME_VAL( RPC_LOC_IOCTL_SET_CDMA_MPC_SERVER_ADDR ),
+      NAME_VAL( RPC_LOC_IOCTL_GET_CDMA_MPC_SERVER_ADDR ),
+      NAME_VAL( RPC_LOC_IOCTL_SET_UMTS_SLP_SERVER_ADDR ),
+      NAME_VAL( RPC_LOC_IOCTL_GET_UMTS_SLP_SERVER_ADDR ),
+      NAME_VAL( RPC_LOC_IOCTL_SET_ON_DEMAND_LPM ),
+      NAME_VAL( RPC_LOC_IOCTL_GET_ON_DEMAND_LPM ),
+      NAME_VAL( RPC_LOC_IOCTL_SET_XTRA_T_SESSION_CONTROL ),
+      NAME_VAL( RPC_LOC_IOCTL_GET_XTRA_T_SESSION_CONTROL ),
+      NAME_VAL( RPC_LOC_IOCTL_SET_LBS_APN_PROFILE ),
+      NAME_VAL( RPC_LOC_IOCTL_GET_LBS_APN_PROFILE ),
+      NAME_VAL( RPC_LOC_IOCTL_SET_XTRA_APN_PROFILE ),
+      NAME_VAL( RPC_LOC_IOCTL_GET_XTRA_APN_PROFILE ),
+      NAME_VAL( RPC_LOC_IOCTL_SET_DATA_ENABLE ),
+      NAME_VAL( RPC_LOC_IOCTL_SET_SUPL_VERSION ),
+      NAME_VAL( RPC_LOC_IOCTL_GET_SUPL_VERSION ),
+      NAME_VAL( RPC_LOC_IOCTL_DELETE_ASSIST_DATA ),
+      NAME_VAL( RPC_LOC_IOCTL_SET_CUSTOM_PDE_SERVER_ADDR ),
+      NAME_VAL( RPC_LOC_IOCTL_GET_CUSTOM_PDE_SERVER_ADDR ),
+   };
+int loc_ioctl_type_num = sizeof loc_ioctl_type_name / sizeof(loc_name_val_s_type);
+
+/* IOCTL Status names */
+loc_name_val_s_type loc_ioctl_status_name[] =
+   {
+      NAME_VAL( RPC_LOC_API_SUCCESS ),
+      NAME_VAL( RPC_LOC_API_GENERAL_FAILURE ),
+      NAME_VAL( RPC_LOC_API_UNSUPPORTED ),
+      NAME_VAL( RPC_LOC_API_INVALID_HANDLE ),
+      NAME_VAL( RPC_LOC_API_INVALID_PARAMETER ),
+      NAME_VAL( RPC_LOC_API_ENGINE_BUSY ),
+      NAME_VAL( RPC_LOC_API_PHONE_OFFLINE ),
+      NAME_VAL( RPC_LOC_API_TIMEOUT ),
+      NAME_VAL( RPC_LOC_API_RPC_FAILURE ),
+      NAME_VAL( RPC_LOC_API_RPC_MODEM_RESTART )
+   };
+int loc_ioctl_status_num = sizeof loc_ioctl_status_name / sizeof(loc_name_val_s_type);
+
+/* Fix session status names */
+loc_name_val_s_type loc_sess_status_name[] =
+   {
+      NAME_VAL( RPC_LOC_SESS_STATUS_SUCCESS ),
+      NAME_VAL( RPC_LOC_SESS_STATUS_IN_PROGESS ),
+      NAME_VAL( RPC_LOC_SESS_STATUS_GENERAL_FAILURE ),
+      NAME_VAL( RPC_LOC_SESS_STATUS_TIMEOUT ),
+      NAME_VAL( RPC_LOC_SESS_STATUS_USER_END ),
+      NAME_VAL( RPC_LOC_SESS_STATUS_BAD_PARAMETER ),
+      NAME_VAL( RPC_LOC_SESS_STATUS_PHONE_OFFLINE ),
+      NAME_VAL( RPC_LOC_SESS_STATUS_USER_END ),
+      NAME_VAL( RPC_LOC_SESS_STATUS_ENGINE_LOCKED )
+   };
+int loc_sess_status_num = sizeof loc_sess_status_name / sizeof(loc_name_val_s_type);
+
+/* Engine state names */
+loc_name_val_s_type loc_engine_state_name[] =
+   {
+      NAME_VAL( RPC_LOC_ENGINE_STATE_ON ),
+      NAME_VAL( RPC_LOC_ENGINE_STATE_OFF )
+   };
+int loc_engine_state_num = sizeof loc_engine_state_name / sizeof(loc_name_val_s_type);
+
+/* Fix session state names */
+loc_name_val_s_type loc_fix_session_state_name[] =
+   {
+      NAME_VAL( RPC_LOC_FIX_SESSION_STATE_BEGIN ),
+      NAME_VAL( RPC_LOC_FIX_SESSION_STATE_END )
+   };
+int loc_fix_session_state_num = sizeof loc_fix_session_state_name / sizeof(loc_name_val_s_type);
+
+
+static const char* log_final_interm_string(int is_final)
+{
+   return is_final ? "final" : "intermediate";
+}
+
+/* Logs parsed report */
+static void log_parsed_report(const rpc_loc_parsed_position_s_type *parsed_report)
+{
+   rpc_loc_session_status_e_type status = parsed_report->session_status;
+   LOC_LOGD("Session status: %s   Valid mask: 0x%X\n",
+         loc_get_sess_status_name(status),
+         (uint) parsed_report->valid_mask);
+   LOC_LOGD("Latitude:  %.7f (%s)\n", parsed_report->latitude,
+         log_final_interm_string(
+               (parsed_report->valid_mask & RPC_LOC_POS_VALID_LATITUDE) &&
+               parsed_report->session_status == RPC_LOC_SESS_STATUS_SUCCESS));
+   LOC_LOGD("Longitude: %.7f\n", parsed_report->longitude);
+   LOC_LOGD("Accuracy: %.7f\n", parsed_report->hor_unc_circular);
+}
+
+/* Logs status report */
+static void log_status_report(const rpc_loc_status_event_s_type *status_event)
+{
+   rpc_loc_status_event_e_type event = status_event->event;
+   switch (event) {
+   case RPC_LOC_STATUS_EVENT_ENGINE_STATE:
+      LOC_LOGD("Engine state: %s\n",
+            loc_get_engine_state_name(
+                  status_event->payload.rpc_loc_status_event_payload_u_type_u.engine_state));
+      break;
+   case RPC_LOC_STATUS_EVENT_FIX_SESSION_STATE:
+      LOC_LOGD("Fix session state: %s\n",
+            loc_get_fix_session_state_name(
+                  status_event->payload.rpc_loc_status_event_payload_u_type_u.fix_session_state));
+      break;
+   default:
+      break;
+   }
+}
+
+/* Logs valid fields in the GNSS SV constellation report */
+static void log_satellite_report(const rpc_loc_gnss_info_s_type *gnss)
+{
+   if (gnss->valid_mask & RPC_LOC_GNSS_INFO_VALID_POS_DOP)
+   {
+      LOC_LOGV("position dop: %.3f\n", (float) gnss->position_dop);
+   }
+   if (gnss->valid_mask & RPC_LOC_GNSS_INFO_VALID_HOR_DOP)
+   {
+      LOC_LOGV("horizontal dop: %.3f\n", (float) gnss->horizontal_dop);
+   }
+   if (gnss->valid_mask & RPC_LOC_GNSS_INFO_VALID_VERT_DOP)
+   {
+      LOC_LOGV("vertical dop: %.3f\n", (float) gnss->vertical_dop);
+   }
+   if (gnss->valid_mask & RPC_LOC_GNSS_INFO_VALID_ALTITUDE_ASSUMED)
+   {
+      LOC_LOGV("altitude assumed: %d\n", (int) gnss->altitude_assumed);
+   }
+   if (gnss->valid_mask & RPC_LOC_GNSS_INFO_VALID_SV_COUNT)
+   {
+      LOC_LOGD("sv count: %d\n", (int) gnss->sv_count);
+   }
+   if (gnss->valid_mask & RPC_LOC_GNSS_INFO_VALID_SV_LIST)
+   {
+      LOC_LOGV("sv list: ");
+
+      if (gnss->sv_count)
+      {
+         LOC_LOGV("\n\tsys\tprn\thlth\tproc\teph\talm\telev\tazi\tsnr\n");
+      }
+      else {
+         LOC_LOGV("empty\n");
+      }
+
+      int i;
+      for (i = 0; i < gnss->sv_count; i++)
+      {
+         const rpc_loc_sv_info_s_type *sv = &gnss->sv_list.sv_list_val[i];
+         rpc_loc_sv_info_valid_mask_type mask = sv->valid_mask;
+         LOC_LOGV("  %d: \t%d\t%d\t%d\t%d\t%d\t%d\t%.3f\t%.3f\t%.3f\n", i,
+               CHECK_MASK(int,   sv->system,         mask, RPC_LOC_SV_INFO_VALID_SYSTEM),
+               CHECK_MASK(int,   sv->prn,            mask, RPC_LOC_SV_INFO_VALID_PRN),
+               CHECK_MASK(int,   sv->health_status,  mask, RPC_LOC_SV_INFO_VALID_HEALTH_STATUS),
+               CHECK_MASK(int,   sv->process_status, mask, RPC_LOC_SV_INFO_VALID_PROCESS_STATUS),
+               CHECK_MASK(int,   sv->has_eph,        mask, RPC_LOC_SV_INFO_VALID_HAS_EPH),
+               CHECK_MASK(int,   sv->has_alm,        mask, RPC_LOC_SV_INFO_VALID_HAS_ALM),
+               CHECK_MASK(float, sv->elevation,      mask, RPC_LOC_SV_INFO_VALID_ELEVATION),
+               CHECK_MASK(float, sv->azimuth,        mask, RPC_LOC_SV_INFO_VALID_AZIMUTH),
+               CHECK_MASK(float, sv->snr,            mask, RPC_LOC_SV_INFO_VALID_SNR)
+         );
+      }
+   }
+}
+
+/* Logs a callback event */
+int loc_callback_log(
+      rpc_loc_event_mask_type               loc_event,              /* event mask           */
+      const rpc_loc_event_payload_u_type*   loc_event_payload       /* payload              */
+)
+{
+   switch (loc_event)
+   {
+   case RPC_LOC_EVENT_SATELLITE_REPORT:
+      log_satellite_report(&loc_event_payload->
+            rpc_loc_event_payload_u_type_u.gnss_report);
+      break;
+   case RPC_LOC_EVENT_STATUS_REPORT:
+      log_status_report(&loc_event_payload->
+            rpc_loc_event_payload_u_type_u.status_report);
+      break;
+   case RPC_LOC_EVENT_PARSED_POSITION_REPORT:
+      log_parsed_report(&loc_event_payload->
+            rpc_loc_event_payload_u_type_u.parsed_location_report);
+      break;
+   default:
+      break;
+   }
+
+   return 0;
+}
+
+/* Finds the first event found in the mask */
+const char* loc_get_event_name(rpc_loc_event_mask_type loc_event_mask)
+{
+   return loc_get_name_from_mask(loc_event_name, loc_event_num,
+         (long) loc_event_mask);
+}
+
+/* Finds IOCTL type name */
+const char* loc_get_ioctl_type_name(rpc_loc_ioctl_e_type ioctl_type)
+{
+   return loc_get_name_from_val(loc_ioctl_type_name, loc_ioctl_type_num,
+         (long) ioctl_type);
+}
+
+/* Finds IOCTL status name */
+const char* loc_get_ioctl_status_name(uint32 status)
+{
+   return loc_get_name_from_val(loc_ioctl_status_name, loc_ioctl_status_num,
+         (long) status);
+}
+
+/* Finds session status name */
+const char* loc_get_sess_status_name(rpc_loc_session_status_e_type status)
+{
+   return loc_get_name_from_val(loc_sess_status_name, loc_sess_status_num,
+         (long) status);
+}
+
+/* Find engine state name */
+const char* loc_get_engine_state_name(rpc_loc_engine_state_e_type state)
+{
+   return loc_get_name_from_val(loc_engine_state_name, loc_engine_state_num,
+         (long) state);
+}
+
+/* Find engine state name */
+const char* loc_get_fix_session_state_name(rpc_loc_fix_session_state_e_type state)
+{
+   return loc_get_name_from_val(loc_fix_session_state_name, loc_fix_session_state_num,
+         (long) state);
+}
+
+/* Event names */
+loc_name_val_s_type rpc_reset_event_name[] =
+{
+    NAME_VAL( RPC_SUBSYSTEM_RESTART_BEGIN ),
+    NAME_VAL( RPC_SUBSYSTEM_RESTART_END )
+};
+int rpc_reset_event_num = sizeof rpc_reset_event_name / sizeof(loc_name_val_s_type);
+
+const char* loc_get_rpc_reset_event_name(enum rpc_reset_event event)
+{
+    return loc_get_name_from_val(rpc_reset_event_name, rpc_reset_event_num, event);
+}
diff --git a/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/src/loc_api_rpc_glue.c b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/src/loc_api_rpc_glue.c
new file mode 100644
index 0000000..e0f400c
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/src/loc_api_rpc_glue.c
@@ -0,0 +1,636 @@
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*=====================================================================
+
+                     INCLUDE FILES FOR MODULE
+
+======================================================================*/
+#include <stdio.h>
+#include <pthread.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/select.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <loc_api_log.h>
+
+#include <rpc/rpc.h>
+
+/* Include RPC headers */
+#include "rpc_inc/loc_api_rpc_glue.h"
+
+/* Callback init */
+#include "rpc_inc/loc_apicb_appinit.h"
+
+/* Logging */
+#define LOG_TAG "LocSvc_api_rpc_glue"
+#define LOG_NDDEBUG 0
+#ifndef USE_GLIB
+#include <utils/Log.h>
+#endif /* USE_GLIB */
+
+/* Logging Improvement */
+#include "log_util.h"
+#include "platform_lib_includes.h"
+/*Maximum number of Modem init*/
+#define RPC_TRY_NUM 10
+
+/*Maximum number of Modem init*/
+#define RPC_TRY_NUM 10
+
+/* Uncomment to force ALOGD messages */
+// #define ALOGD ALOGI
+
+/*=====================================================================
+     External declarations
+======================================================================*/
+
+CLIENT* loc_api_clnt = NULL;
+
+/* Callback ID and pointer */
+#define LOC_API_CB_MAX_CLIENTS 16
+typedef struct
+{
+    uint32 cb_id;                        /* same as rpc/types.h */
+    loc_event_cb_f_type *cb_func;      /* callback func */
+    loc_reset_notif_cb_f_type *rpc_cb; /* callback from RPC */
+    rpc_loc_client_handle_type handle; /* stores handle for client closing */
+    void* user;                        /* user's own data handle */
+} loc_glue_cb_entry_s_type;
+
+loc_glue_cb_entry_s_type loc_glue_callback_table[LOC_API_CB_MAX_CLIENTS];
+
+#define RPC_FUNC_VERSION_BASE(a,b) a ## b
+#define RPC_FUNC_VERSION(a,b) RPC_FUNC_VERSION_BASE(a,b)
+
+#define RPC_CALLBACK_FUNC_VERSION_BASE(a,v,b) a ## v ## b
+#define RPC_CALLBACK_FUNC_VERSION(a,v,b) RPC_CALLBACK_FUNC_VERSION_BASE(a,v,b)
+
+#define LOC_GLUE_CHECK_INIT(ret_type) \
+   if (loc_api_clnt == NULL) { EXIT_LOG_CALLFLOW(%d, RPC_LOC_API_RPC_FAILURE); return (ret_type) RPC_LOC_API_RPC_FAILURE; }
+
+#define LOC_GLUE_CHECK_RESULT(stat, ret_type) \
+  if (stat != RPC_SUCCESS) { \
+      LOC_LOGE("%s:%d] failure code %d", __func__, __LINE__, stat); \
+      return (ret_type)((stat == RPC_SUBSYSTEM_RESTART) ? \
+                        RPC_LOC_API_RPC_MODEM_RESTART : RPC_LOC_API_RPC_FAILURE); \
+  }
+
+/* Callback functions */
+/* Returns 1 if successful */
+bool_t rpc_loc_event_cb_f_type_svc(
+      rpc_loc_event_cb_f_type_args *argp,
+      rpc_loc_event_cb_f_type_rets *ret,
+      struct svc_req *req)
+{
+    // The lower word of cd_id is the index
+    int index = argp->cb_id & 0xFFFF;
+
+    /* Callback not registered, or unexpected ID (shouldn't happen) */
+    if (index >= LOC_API_CB_MAX_CLIENTS || loc_glue_callback_table[index].cb_func == NULL)
+    {
+        LOC_LOGE("Warning: No callback handler %d.\n", index);
+        ret->loc_event_cb_f_type_result = 0;
+        return 1; /* simply return */
+    }
+
+    LOC_LOGV("proc: %x  prog: %x  vers: %x\n",
+         (int) req->rq_proc,
+         (int) req->rq_prog,
+         (int) req->rq_vers);
+
+    LOC_LOGV("Callback received: %x (cb_id=%p handle=%d ret_ptr=%d)\n",
+         (int) argp->loc_event,
+               argp->cb_id,
+         (int) argp->loc_handle,
+         (int) ret);
+
+    /* Forward callback to real callback procedure */
+    rpc_loc_client_handle_type        loc_handle = argp->loc_handle;
+    rpc_loc_event_mask_type           loc_event  = argp->loc_event;
+    const rpc_loc_event_payload_u_type*  loc_event_payload =
+        (const rpc_loc_event_payload_u_type*) argp->loc_event_payload;
+
+    /* Gives control to synchronous call handler */
+    loc_api_callback_process_sync_call(loc_handle, loc_event, loc_event_payload);
+
+    int32 rc = (loc_glue_callback_table[index].cb_func)(loc_glue_callback_table[index].user,
+                                                        loc_handle, loc_event, loc_event_payload);
+
+    LOC_LOGV("cb_func=%p", loc_glue_callback_table[index].cb_func);
+
+    ret->loc_event_cb_f_type_result = rc;
+
+    return 1; /* ok */
+}
+
+int loc_apicbprog_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
+{
+   xdr_free (xdr_result, result);
+
+   /*
+    * Insert additional freeing code here, if needed
+    */
+   // LOC_LOGD("***** loc_apicbprog_freeresult\n");
+
+   return 1;
+}
+
+/*===========================================================================
+
+FUNCTION rpc_loc_event_cb_f_type_<version>_svc (MACRO)
+
+DESCRIPTION
+   Callback function for Loc API
+
+RETURN VALUE
+   1 for success
+   0 for failure
+
+===========================================================================*/
+bool_t RPC_CALLBACK_FUNC_VERSION(rpc_loc_event_cb_f_type_, RPC_LOC_EVENT_CB_F_TYPE_VERSION, _svc) (
+      rpc_loc_event_cb_f_type_args *argp,
+      rpc_loc_event_cb_f_type_rets *ret,
+      struct svc_req *req)
+{
+   return rpc_loc_event_cb_f_type_svc(argp, ret, req);
+}
+
+/*===========================================================================
+
+FUNCTION loc_apicbprog_<version>_freeresult (MACRO)
+
+DESCRIPTION
+   Free up RPC data structure
+
+RETURN VALUE
+   1 for success
+   0 for failure
+
+===========================================================================*/
+#define VERSION_CONCAT(MAJOR,MINOR) MAJOR##MINOR
+#define loc_apicb_prog_VER_freeresult(M,N) \
+int RPC_CALLBACK_FUNC_VERSION(loc_apicbprog_, VERSION_CONCAT(M,N), _freeresult) \
+(SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result) \
+{ \
+   return loc_apicbprog_freeresult(transp, xdr_result, result); \
+}
+
+/* Define all of the possible minors */
+loc_apicb_prog_VER_freeresult(RPC_LOC_API_API_MAJOR_NUM, 0001);
+loc_apicb_prog_VER_freeresult(RPC_LOC_API_API_MAJOR_NUM, 0002);
+loc_apicb_prog_VER_freeresult(RPC_LOC_API_API_MAJOR_NUM, 0003);
+loc_apicb_prog_VER_freeresult(RPC_LOC_API_API_MAJOR_NUM, 0004);
+loc_apicb_prog_VER_freeresult(RPC_LOC_API_API_MAJOR_NUM, 0005);
+loc_apicb_prog_VER_freeresult(RPC_LOC_API_API_MAJOR_NUM, 0006);
+
+/*===========================================================================
+
+FUNCTION rpc_loc_api_cb_null_<version>_svc (MACRO) [Patch for wrong RPCGEN stubs]
+
+DESCRIPTION
+   Null callback function for Loc API
+
+RETURN VALUE
+   1 for success
+
+===========================================================================*/
+#define rpc_loc_api_cb_null_VER_svc(M,N) \
+bool_t RPC_CALLBACK_FUNC_VERSION(rpc_loc_api_cb_null_, VERSION_CONCAT(M,N), _svc) ( \
+      void *a, int *b, struct svc_req *req) \
+{ \
+   return 1; \
+}
+
+/* Define all of the possible minors */
+rpc_loc_api_cb_null_VER_svc(RPC_LOC_API_API_MAJOR_NUM, 0001);
+rpc_loc_api_cb_null_VER_svc(RPC_LOC_API_API_MAJOR_NUM, 0002);
+rpc_loc_api_cb_null_VER_svc(RPC_LOC_API_API_MAJOR_NUM, 0003);
+rpc_loc_api_cb_null_VER_svc(RPC_LOC_API_API_MAJOR_NUM, 0004);
+rpc_loc_api_cb_null_VER_svc(RPC_LOC_API_API_MAJOR_NUM, 0005);
+rpc_loc_api_cb_null_VER_svc(RPC_LOC_API_API_MAJOR_NUM, 0006);
+
+static void loc_api_glue_rpc_cb(CLIENT* client, enum rpc_reset_event event)
+{
+    int i;
+    for (i = 0; i < LOC_API_CB_MAX_CLIENTS; i++) {
+        if (NULL != loc_glue_callback_table[i].rpc_cb) {
+            loc_glue_callback_table[i].rpc_cb(loc_glue_callback_table[i].user, client, event);
+        }
+    }
+}
+
+/*===========================================================================
+
+FUNCTION loc_api_glue_init
+
+DESCRIPTION
+   Initiates the RPC client
+
+RETURN VALUE
+   1 for success
+   0 for failure
+
+===========================================================================*/
+int loc_api_glue_init(void)
+{
+   if (loc_api_clnt == NULL)
+   {
+      /* Initialize data */
+      int i;
+      int pid = getpid();
+      for (i = 0; i < LOC_API_CB_MAX_CLIENTS; i++)
+      {
+          loc_glue_callback_table[i].cb_id = i | (pid << 16);
+          loc_glue_callback_table[i].cb_func = NULL;
+          loc_glue_callback_table[i].handle = -1;
+          loc_glue_callback_table[i].rpc_cb = NULL;
+          loc_glue_callback_table[i].user = NULL;
+      }
+
+      /* Print msg */
+      LOC_LOGV("Trying to create RPC client...\n");
+      loc_api_clnt = clnt_create(NULL, LOC_APIPROG, LOC_APIVERS, NULL);
+      LOC_LOGV("Created loc_api_clnt ---- %x\n", (unsigned int)loc_api_clnt);
+
+      if (loc_api_clnt == NULL)
+      {
+         LOC_LOGE("Error: cannot create RPC client.\n");
+         return 0;
+      }
+
+      /* Init RPC callbacks */
+      loc_api_sync_call_init();
+
+      int rc = loc_apicb_app_init();
+      if (rc >= 0)
+      {
+         LOC_LOGD("Loc API RPC client initialized.\n");
+         clnt_register_reset_notification_cb(loc_api_clnt, loc_api_glue_rpc_cb);
+      }
+      else {
+         LOC_LOGE("Loc API callback initialization failed.\n");
+         return 0;
+      }
+   }
+
+   return 1;
+}
+
+rpc_loc_client_handle_type loc_open (
+    rpc_loc_event_mask_type       event_reg_mask,
+    loc_event_cb_f_type           *event_callback,
+    loc_reset_notif_cb_f_type     *rpc_cb,
+    void*                         userData
+)
+{
+    int try_num = RPC_TRY_NUM;
+    ENTRY_LOG();
+    LOC_GLUE_CHECK_INIT(rpc_loc_client_handle_type);
+
+    rpc_loc_client_handle_type ret_val;
+
+    rpc_loc_open_args args;
+    args.event_reg_mask = event_reg_mask;
+
+    int i, j = LOC_API_CB_MAX_CLIENTS;
+    for (i = 0; i < LOC_API_CB_MAX_CLIENTS; i++)
+    {
+        if (loc_glue_callback_table[i].user == userData)
+        {
+            LOC_LOGW("Client already opened service (callback=%p)...\n",
+                  event_callback);
+            break;
+        } else if (j == LOC_API_CB_MAX_CLIENTS &&
+                   loc_glue_callback_table[i].user == NULL) {
+            j = i;
+        }
+    }
+
+    if (i == LOC_API_CB_MAX_CLIENTS)
+    {
+        i = j;
+    }
+
+    if (i == LOC_API_CB_MAX_CLIENTS)
+    {
+        LOC_LOGE("Too many clients opened at once...\n");
+        return RPC_LOC_CLIENT_HANDLE_INVALID;
+    }
+
+    loc_glue_callback_table[i].cb_func = event_callback;
+    loc_glue_callback_table[i].rpc_cb = rpc_cb;
+    loc_glue_callback_table[i].user = userData;
+
+    args.event_callback = loc_glue_callback_table[i].cb_id;
+    LOC_LOGV("cb_id=%d, func=0x%x", i, (unsigned int) event_callback);
+
+    rpc_loc_open_rets rets;
+    enum clnt_stat stat = RPC_SUCCESS;
+
+    EXIT_LOG_CALLFLOW(%s, "loc client open");
+
+     /*try more for rpc_loc_open_xx()*/
+
+    do
+    {
+        stat = RPC_FUNC_VERSION(rpc_loc_open_, RPC_LOC_OPEN_VERSION)(&args, &rets, loc_api_clnt);
+        ret_val = (rpc_loc_client_handle_type) rets.loc_open_result;
+        try_num--;
+
+    }while( (RPC_SUCCESS != stat||0 > ret_val) && 0 != try_num );
+
+    LOC_GLUE_CHECK_RESULT(stat, int32);
+
+    /* save the handle in the table */
+    loc_glue_callback_table[i].handle = (rpc_loc_client_handle_type) rets.loc_open_result;
+
+    return ret_val;
+
+}
+
+int32 loc_close
+(
+      rpc_loc_client_handle_type handle
+)
+{
+    ENTRY_LOG();
+    LOC_GLUE_CHECK_INIT(int32);
+
+    int32 ret_val;
+
+    rpc_loc_close_args args;
+    args.handle = handle;
+
+    rpc_loc_close_rets rets;
+    enum clnt_stat stat = RPC_SUCCESS;
+
+    EXIT_LOG_CALLFLOW(%s, "loc client close");
+    stat = RPC_FUNC_VERSION(rpc_loc_close_, RPC_LOC_CLOSE_VERSION)(&args, &rets, loc_api_clnt);
+
+    loc_clear(handle);
+
+    LOC_GLUE_CHECK_RESULT(stat, int32);
+    ret_val = (int32) rets.loc_close_result;
+
+    return ret_val;
+}
+
+void loc_clear(rpc_loc_client_handle_type handle) {
+    /* Clean the client's callback function in callback table */
+    int i;
+    for (i = 0; i < LOC_API_CB_MAX_CLIENTS; i++)
+    {
+        if (loc_glue_callback_table[i].handle == handle)
+        {
+            /* Found the client */
+            loc_glue_callback_table[i].cb_func = NULL;
+            loc_glue_callback_table[i].rpc_cb = NULL;
+            loc_glue_callback_table[i].handle = -1;
+            loc_glue_callback_table[i].user = NULL;
+            break;
+        }
+    }
+
+    if (i == LOC_API_CB_MAX_CLIENTS)
+    {
+        LOC_LOGW("Handle not found (handle=%d)...\n", (int) handle);
+    }
+}
+
+int32 loc_start_fix
+(
+      rpc_loc_client_handle_type handle
+)
+{
+    ENTRY_LOG();
+    LOC_GLUE_CHECK_INIT(int32);
+
+    int32 ret_val;
+
+    rpc_loc_start_fix_args args;
+    args.handle = handle;
+
+    rpc_loc_start_fix_rets rets;
+    enum clnt_stat stat = RPC_SUCCESS;
+
+    EXIT_LOG_CALLFLOW(%s, "loc start fix");
+    stat = RPC_FUNC_VERSION(rpc_loc_start_fix_, RPC_LOC_START_FIX_VERSION)(&args, &rets, loc_api_clnt);
+    LOC_GLUE_CHECK_RESULT(stat, int32);
+
+    ret_val = (int32) rets.loc_start_fix_result;
+
+    return ret_val;
+}
+
+int32 loc_stop_fix
+(
+      rpc_loc_client_handle_type handle
+)
+{
+    ENTRY_LOG();
+    LOC_GLUE_CHECK_INIT(int32);
+
+    int32 ret_val;
+
+    rpc_loc_stop_fix_args args;
+    args.handle = handle;
+
+    rpc_loc_stop_fix_rets rets;
+    enum clnt_stat stat = RPC_SUCCESS;
+
+    EXIT_LOG_CALLFLOW(%s, "loc stop fix");
+    stat = RPC_FUNC_VERSION(rpc_loc_stop_fix_, RPC_LOC_STOP_FIX_VERSION)(&args, &rets, loc_api_clnt);
+    LOC_GLUE_CHECK_RESULT(stat, int32);
+
+    ret_val = (int32) rets.loc_stop_fix_result;
+
+    return ret_val;
+}
+
+int32 loc_ioctl
+(
+      rpc_loc_client_handle_type           handle,
+      rpc_loc_ioctl_e_type                 ioctl_type,
+      rpc_loc_ioctl_data_u_type*           ioctl_data
+)
+{
+    ENTRY_LOG();
+    LOC_GLUE_CHECK_INIT(int32);
+
+    int32 ret_val;
+
+    rpc_loc_ioctl_args args;
+    args.handle = handle;
+    args.ioctl_data = ioctl_data;
+    args.ioctl_type = ioctl_type;
+    if (ioctl_data != NULL)
+    {
+        /* Assign ioctl union discriminator */
+        ioctl_data->disc = ioctl_type;
+
+        /* In case the user hasn't filled in other disc fields,
+           automatically fill them in here */
+        switch (ioctl_type)
+        {
+        case RPC_LOC_IOCTL_GET_API_VERSION:
+            break;
+        case RPC_LOC_IOCTL_SET_FIX_CRITERIA:
+            break;
+        case RPC_LOC_IOCTL_GET_FIX_CRITERIA:
+            break;
+        case RPC_LOC_IOCTL_INFORM_NI_USER_RESPONSE:
+            break;
+        case RPC_LOC_IOCTL_INJECT_PREDICTED_ORBITS_DATA:
+            break;
+        case RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_VALIDITY:
+            break;
+        case RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_SOURCE:
+            break;
+        case RPC_LOC_IOCTL_SET_PREDICTED_ORBITS_DATA_AUTO_DOWNLOAD:
+            break;
+        case RPC_LOC_IOCTL_INJECT_UTC_TIME:
+            break;
+        case RPC_LOC_IOCTL_INJECT_RTC_VALUE:
+            break;
+        case RPC_LOC_IOCTL_INJECT_POSITION:
+            break;
+        case RPC_LOC_IOCTL_QUERY_ENGINE_STATE:
+            break;
+        case RPC_LOC_IOCTL_INFORM_SERVER_OPEN_STATUS:
+            break;
+        case RPC_LOC_IOCTL_INFORM_SERVER_CLOSE_STATUS:
+            break;
+        case RPC_LOC_IOCTL_SET_ENGINE_LOCK:
+            break;
+        case RPC_LOC_IOCTL_GET_ENGINE_LOCK:
+            break;
+        case RPC_LOC_IOCTL_SET_SBAS_CONFIG:
+            break;
+        case RPC_LOC_IOCTL_GET_SBAS_CONFIG:
+            break;
+        case RPC_LOC_IOCTL_SET_NMEA_TYPES:
+            break;
+        case RPC_LOC_IOCTL_GET_NMEA_TYPES:
+            break;
+        case RPC_LOC_IOCTL_SET_CDMA_PDE_SERVER_ADDR:
+        case RPC_LOC_IOCTL_SET_CDMA_MPC_SERVER_ADDR:
+        case RPC_LOC_IOCTL_SET_UMTS_SLP_SERVER_ADDR:
+        case RPC_LOC_IOCTL_SET_CUSTOM_PDE_SERVER_ADDR:
+            args.ioctl_data->rpc_loc_ioctl_data_u_type_u.server_addr.addr_info.disc =
+                args.ioctl_data->rpc_loc_ioctl_data_u_type_u.server_addr.addr_type;
+            break;
+        case RPC_LOC_IOCTL_GET_CDMA_PDE_SERVER_ADDR:
+        case RPC_LOC_IOCTL_GET_CDMA_MPC_SERVER_ADDR:
+        case RPC_LOC_IOCTL_GET_UMTS_SLP_SERVER_ADDR:
+        case RPC_LOC_IOCTL_GET_CUSTOM_PDE_SERVER_ADDR:
+            break;
+        case RPC_LOC_IOCTL_SET_ON_DEMAND_LPM:
+            break;
+        case RPC_LOC_IOCTL_GET_ON_DEMAND_LPM:
+            break;
+        case RPC_LOC_IOCTL_DELETE_ASSIST_DATA:
+            break;
+        default:
+            break;
+        } /* switch */
+    } /* ioctl_data != NULL */
+
+    rpc_loc_ioctl_rets rets;
+    enum clnt_stat stat = RPC_SUCCESS;
+
+    EXIT_LOG_CALLFLOW(%s, loc_get_ioctl_type_name(ioctl_type));
+    stat = RPC_FUNC_VERSION(rpc_loc_ioctl_, RPC_LOC_IOCTL_VERSION)(&args, &rets, loc_api_clnt);
+    LOC_GLUE_CHECK_RESULT(stat, int32);
+
+    ret_val = (int32) rets.loc_ioctl_result;
+
+    return ret_val;
+}
+
+/* Returns 0 if error */
+int32 loc_api_null(void)
+{
+    LOC_GLUE_CHECK_INIT(int32);
+
+    int32 rets;
+    enum clnt_stat stat = RPC_SUCCESS;
+
+    clnt_unregister_reset_notification_cb(loc_api_clnt);
+    stat = RPC_FUNC_VERSION(rpc_loc_api_null_, RPC_LOC_API_NULL_VERSION)(NULL, &rets, loc_api_clnt);
+    LOC_GLUE_CHECK_RESULT(stat, int32);
+
+    return (int32) rets;
+}
+
+/*===========================================================================
+
+FUNCTION    loc_eng_ioctl
+
+DESCRIPTION
+   This function calls loc_ioctl and waits for the callback result before
+   returning back to the user.
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   TRUE                 if successful
+   FALSE                if failed
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_eng_ioctl
+(
+      rpc_loc_client_handle_type           handle,
+      rpc_loc_ioctl_e_type                 ioctl_type,
+      rpc_loc_ioctl_data_u_type*           ioctl_data_ptr,
+      uint32                               timeout_msec,
+      rpc_loc_ioctl_callback_s_type       *cb_data_ptr
+)
+{
+    int ret_val = RPC_LOC_API_SUCCESS;
+
+    ret_val = loc_api_sync_ioctl(handle, ioctl_type, ioctl_data_ptr, timeout_msec, cb_data_ptr);
+
+    LOC_LOGD("loc_eng_ioctl result: client = %d, ioctl_type = %s, returt %s\n",
+             (int32) handle,
+             loc_get_ioctl_type_name(ioctl_type),
+             loc_get_ioctl_status_name(ret_val) );
+
+    return ret_val;
+}
diff --git a/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/src/loc_api_sync_call.c b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/src/loc_api_sync_call.c
new file mode 100644
index 0000000..ae629d7
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/src/loc_api_sync_call.c
@@ -0,0 +1,565 @@
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdio.h>
+#include <assert.h>
+#include <errno.h>
+#include <sys/time.h>
+#include <string.h>
+#include <pthread.h>
+
+#include <rpc/rpc.h>
+#include <loc_api_rpc_glue.h>
+#include "loc_api_sync_call.h"
+
+/* Logging */
+#define LOG_TAG "LocSvc_api_rpc_glue"
+// #define LOG_NDDEBUG 0
+#ifndef USE_GLIB
+#include <utils/Log.h>
+#endif /* USE_GLIB */
+
+/***************************************************************************
+ *                 DATA FOR ASYNCHRONOUS RPC PROCESSING
+ **************************************************************************/
+loc_sync_call_slot_array_s_type loc_sync_data;
+
+pthread_mutex_t loc_sync_call_mutex = PTHREAD_MUTEX_INITIALIZER;
+boolean loc_sync_call_inited = 0;
+
+/*===========================================================================
+
+FUNCTION    loc_api_sync_call_init
+
+DESCRIPTION
+   Initialize this module
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   none
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+void loc_api_sync_call_init()
+{
+   pthread_mutex_lock(&loc_sync_call_mutex);
+   if (loc_sync_call_inited == 1) {
+       pthread_mutex_unlock(&loc_sync_call_mutex);
+       return;
+   }
+   loc_sync_call_inited = 1;
+
+   loc_sync_data.num_of_slots = LOC_SYNC_CALL_SLOTS_MAX;
+
+   int i;
+   for (i = 0; i < loc_sync_data.num_of_slots; i++)
+   {
+      loc_sync_call_slot_s_type *slot = &loc_sync_data.slots[i];
+
+      pthread_mutex_init(&slot->lock, NULL);
+      pthread_cond_init(&slot->loc_cb_arrived_cond, NULL);
+
+      slot->not_available = 0;
+      slot->in_use = 0;
+      slot->loc_handle = -1;
+      slot->loc_cb_wait_event_mask = 0;       /* event to wait   */
+      slot->loc_cb_received_event_mask = 0;   /* received event   */
+   }
+
+   pthread_mutex_unlock(&loc_sync_call_mutex);
+}
+
+/*===========================================================================
+
+FUNCTION    loc_api_sync_call_destroy
+
+DESCRIPTION
+   Initialize this module
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   none
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+void loc_api_sync_call_destroy()
+{
+   int i;
+
+   pthread_mutex_lock(&loc_sync_call_mutex);
+   if (loc_sync_call_inited == 0) {
+       pthread_mutex_unlock(&loc_sync_call_mutex);
+       return;
+   }
+   loc_sync_call_inited = 0;
+
+   for (i = 0; i < loc_sync_data.num_of_slots; i++)
+   {
+      loc_sync_call_slot_s_type *slot = &loc_sync_data.slots[i];
+
+      pthread_mutex_lock(&slot->lock);
+
+      slot->not_available = 1;
+
+      pthread_mutex_unlock(&slot->lock);
+
+      pthread_cond_destroy(&slot->loc_cb_arrived_cond);
+      pthread_mutex_destroy(&slot->lock);
+   }
+
+   pthread_mutex_unlock(&loc_sync_call_mutex);
+}
+
+/*===========================================================================
+
+FUNCTION    loc_match_callback
+
+DESCRIPTION
+   Checks if an awaited event has arrived
+
+RETURN VALUE
+   TRUE                 arrived
+   FALSE                not matching
+
+===========================================================================*/
+static boolean loc_match_callback(
+      rpc_loc_event_mask_type             wait_mask,
+      rpc_loc_ioctl_e_type                wait_ioctl,
+      rpc_loc_event_mask_type             event_mask,
+      const rpc_loc_event_payload_u_type  *callback_payload
+)
+{
+   if ((event_mask & wait_mask) == 0) return FALSE;
+
+   if (event_mask != RPC_LOC_EVENT_IOCTL_REPORT || wait_ioctl == 0 ||
+        ( (callback_payload != NULL) &&
+         callback_payload->rpc_loc_event_payload_u_type_u.ioctl_report.type == wait_ioctl) )
+      return TRUE;
+
+   return FALSE;
+}
+
+/*===========================================================================
+
+FUNCTION    loc_api_callback_process_sync_call
+
+DESCRIPTION
+   Wakes up blocked API calls to check if the needed callback has arrived
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   none
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+void loc_api_callback_process_sync_call(
+      rpc_loc_client_handle_type            loc_handle,             /* handle of the client */
+      rpc_loc_event_mask_type               loc_event,              /* event mask           */
+      const rpc_loc_event_payload_u_type*   loc_event_payload       /* payload              */
+)
+{
+   int i;
+
+   ALOGV("loc_handle = 0x%lx, loc_event = 0x%lx", loc_handle, loc_event);
+   for (i = 0; i < loc_sync_data.num_of_slots; i++)
+   {
+      loc_sync_call_slot_s_type *slot = &loc_sync_data.slots[i];
+
+      pthread_mutex_lock(&slot->lock);
+
+      if (slot->in_use &&
+          slot->signal_sent == 0 &&
+          slot->loc_handle == loc_handle &&
+          loc_match_callback(slot->loc_cb_wait_event_mask, slot->ioctl_type, loc_event, loc_event_payload))
+      {
+         memcpy(&slot->loc_cb_received_payload, loc_event_payload, sizeof (rpc_loc_event_payload_u_type));
+
+         slot->loc_cb_received_event_mask = loc_event;
+
+         ALOGV("signal slot %d in_use %d, loc_handle 0x%lx, event_mask 0x%1x, ioctl_type %d", i, slot->in_use, slot->loc_handle, (int) slot->loc_cb_wait_event_mask, (int) slot->ioctl_type);
+         pthread_cond_signal(&slot->loc_cb_arrived_cond);
+         slot->signal_sent = 1;
+
+         pthread_mutex_unlock(&slot->lock);
+         break;
+      } else {
+         /* do nothing */
+      }
+
+      pthread_mutex_unlock(&slot->lock);
+   }
+}
+
+/*===========================================================================
+
+FUNCTION    loc_lock_a_slot
+
+DESCRIPTION
+   Allocates a buffer slot for the synchronous API call
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   Select ID (>=0)     : successful
+   -1                  : buffer full
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static int loc_lock_a_slot()
+{
+   int i, select_id = -1; /* no free buffer */
+
+   for (i = 0; i < loc_sync_data.num_of_slots; i++)
+   {
+      loc_sync_call_slot_s_type *slot = &loc_sync_data.slots[i];
+      if (pthread_mutex_trylock(&slot->lock) == EBUSY)
+      {
+         ALOGV("trylock EBUSY : %d", i);
+         continue;
+      }
+
+      if (!slot->in_use && !slot->not_available)
+      {
+         select_id = i;
+         /* Return from here and leave the mutex locked.
+          * will unlock it in loc_unlock_slot()
+          */
+         break;
+      }
+      /* ALOGV("slot %d in_use = %d, not_available = %d : %d", i, slot->in_use, slot->not_available, i); */
+      pthread_mutex_unlock(&slot->lock);
+   }
+
+   return select_id;
+}
+
+/*===========================================================================
+
+FUNCTION    loc_unlock_slot
+
+DESCRIPTION
+   Unlocks a buffer slot
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   None
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static void loc_unlock_slot(int select_id)
+{
+   pthread_mutex_unlock(&loc_sync_data.slots[select_id].lock);
+}
+
+/*===========================================================================
+
+FUNCTION    loc_lock_slot
+
+DESCRIPTION
+   Locks a specific slot that was previously locked from loc_lock_a_slot
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   None
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static void loc_lock_slot(int select_id)
+{
+    pthread_mutex_lock(&loc_sync_data.slots[select_id].lock);
+}
+
+/*===========================================================================
+
+FUNCTION    loc_set_slot_in_use
+
+DESCRIPTION
+   Sets the in_use flag of slot to true or false.
+   Should be called only after the slot is locked
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   None
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static void loc_set_slot_in_use(int select_id, boolean in_use)
+{
+    loc_sync_data.slots[select_id].in_use = in_use;
+    if (in_use == 1)
+        loc_sync_data.slots[select_id].signal_sent = 0;
+}
+
+/*===========================================================================
+
+FUNCTION    loc_api_save_callback
+
+DESCRIPTION
+   Selects which callback or IOCTL event to wait for.
+
+   The event_mask specifies the event(s). If it is RPC_LOC_EVENT_IOCTL_REPORT,
+   then ioctl_type specifies the IOCTL event.
+
+   If ioctl_type is non-zero, RPC_LOC_EVENT_IOCTL_REPORT is automatically added.
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   Select ID (>=0)     : successful
+   -1                  : out of buffer
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static void loc_api_save_callback(
+      int                              select_id,            /* Selected slot */
+      rpc_loc_client_handle_type       loc_handle,           /* Client handle */
+      rpc_loc_event_mask_type          event_mask,           /* Event mask to wait for */
+      rpc_loc_ioctl_e_type             ioctl_type            /* IOCTL type to wait for */
+)
+{
+   loc_sync_call_slot_s_type *slot = &loc_sync_data.slots[select_id];
+
+   slot->loc_handle = loc_handle;
+
+   slot->loc_cb_wait_event_mask = event_mask;
+   slot->ioctl_type = ioctl_type;
+   if (ioctl_type) slot->loc_cb_wait_event_mask |= RPC_LOC_EVENT_IOCTL_REPORT;
+
+   return;
+}
+
+/*===========================================================================
+
+FUNCTION    loc_save_user_payload
+
+DESCRIPTION
+   Saves received payload into user data structures
+
+RETURN VALUE
+   None
+
+===========================================================================*/
+static void loc_save_user_payload(
+      rpc_loc_event_payload_u_type  *user_cb_payload,
+      rpc_loc_ioctl_callback_s_type *user_ioctl_buffer,
+      const rpc_loc_event_payload_u_type  *received_cb_payload
+)
+{
+   if (user_cb_payload)
+   {
+      memcpy(user_cb_payload, received_cb_payload,
+            sizeof (rpc_loc_event_payload_u_type));
+   }
+   if (user_ioctl_buffer)
+   {
+      memcpy(user_ioctl_buffer,
+            &received_cb_payload->rpc_loc_event_payload_u_type_u.ioctl_report,
+            sizeof *user_ioctl_buffer);
+   }
+}
+
+/*===========================================================================
+
+FUNCTION    loc_api_wait_callback
+
+DESCRIPTION
+   Waits for a selected callback. The wait expires in timeout_seconds seconds.
+
+   If the function is called before an existing wait has finished, it will
+   immediately return EBUSY.
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   RPC_LOC_API_SUCCESS              if successful (0)
+   RPC_LOC_API_TIMEOUT              if timed out
+   RPC_LOC_API_ENGINE_BUSY          if already in a wait
+   RPC_LOC_API_INVALID_PARAMETER    if callback is not yet selected
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static int loc_api_wait_callback(
+      int select_id,        /* ID from loc_select_callback() */
+      int timeout_seconds,  /* Timeout in this number of seconds  */
+      rpc_loc_event_payload_u_type     *callback_payload,    /* Pointer to callback payload buffer, can be NULL */
+      rpc_loc_ioctl_callback_s_type    *ioctl_payload        /* Pointer to IOCTL payload, can be NULL */
+)
+{
+   int ret_val = RPC_LOC_API_SUCCESS;  /* the return value of this function: 0 = no error */
+   int rc = 0;                         /* return code from pthread calls */
+
+   struct timespec expire_time;
+
+   loc_sync_call_slot_s_type *slot = &loc_sync_data.slots[select_id];
+
+   clock_gettime(CLOCK_REALTIME, &expire_time);
+   expire_time.tv_sec += timeout_seconds;
+
+   /* Waiting */
+   while (slot->signal_sent == 0 && rc != ETIMEDOUT) {
+       rc = pthread_cond_timedwait(&slot->loc_cb_arrived_cond,
+             &slot->lock, &expire_time);
+   }
+
+   if (rc == ETIMEDOUT)
+   {
+      ret_val = RPC_LOC_API_TIMEOUT; /* Timed out */
+      ALOGE("TIMEOUT: %d", select_id);
+   }
+   else {
+      /* Obtained the first awaited callback */
+      ret_val = RPC_LOC_API_SUCCESS;       /* Successful */
+      loc_save_user_payload(callback_payload, ioctl_payload, &slot->loc_cb_received_payload);
+   }
+
+   return ret_val;
+}
+
+/*===========================================================================
+
+FUNCTION    loc_api_sync_ioctl
+
+DESCRIPTION
+   Synchronous IOCTL call (reentrant version)
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   Loc API error code (0 = success)
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_api_sync_ioctl
+(
+      rpc_loc_client_handle_type           handle,
+      rpc_loc_ioctl_e_type                 ioctl_type,
+      rpc_loc_ioctl_data_u_type*           ioctl_data_ptr,
+      uint32                               timeout_msec,
+      rpc_loc_ioctl_callback_s_type       *cb_data_ptr
+)
+{
+   int                              rc = -1;
+   int                              select_id;
+   rpc_loc_ioctl_callback_s_type    callback_data;
+
+   select_id = loc_lock_a_slot();
+
+   if (select_id < 0 || select_id >= loc_sync_data.num_of_slots)
+   {
+      ALOGE("slot not available ioctl_type = %s",
+           loc_get_ioctl_type_name(ioctl_type));
+      return rc;
+   }
+
+   loc_set_slot_in_use(select_id, 1); // set slot in use to true
+
+   // Select the callback we are waiting for
+   loc_api_save_callback(select_id, handle, 0, ioctl_type);
+
+   loc_unlock_slot(select_id); // slot is unlocked, but in_use is still true
+
+   // we want to avoid keeping the slot locked during the loc_ioctl because the rpc
+   // framework will also lock a different mutex during this call, and typically
+   // locking two different mutexes at the same time can lead to deadlock.
+   rc =  loc_ioctl(handle, ioctl_type, ioctl_data_ptr);
+
+   loc_lock_slot(select_id);
+
+   if (rc != RPC_LOC_API_SUCCESS)
+   {
+      ALOGE("loc_ioctl failed select_id = %d, ioctl_type %s, returned %s",
+           select_id, loc_get_ioctl_type_name(ioctl_type), loc_get_ioctl_status_name(rc));
+   }
+   else {
+      ALOGV("select_id = %d, ioctl_type %d, returned RPC_LOC_API_SUCCESS",
+          select_id, ioctl_type);
+      // Wait for the callback of loc_ioctl
+      if ((rc = loc_api_wait_callback(select_id, timeout_msec / 1000, NULL, &callback_data)) != 0)
+      {
+         // Callback waiting failed
+         ALOGE("callback wait failed select_id = %d, ioctl_type %s, returned %s",
+              select_id, loc_get_ioctl_type_name(ioctl_type), loc_get_ioctl_status_name(rc));
+      }
+      else
+      {
+         if (cb_data_ptr) memcpy(cb_data_ptr, &callback_data, sizeof *cb_data_ptr);
+         if (callback_data.status != RPC_LOC_API_SUCCESS)
+         {
+            rc = callback_data.status;
+            ALOGE("callback status failed select_id = %d, ioctl_type %s, returned %s",
+                 select_id, loc_get_ioctl_type_name(ioctl_type), loc_get_ioctl_status_name(rc));
+         } else {
+            ALOGV("callback status success select_id = %d, ioctl_type %d, returned %d",
+                select_id, ioctl_type, rc);
+         }
+      } /* wait callback */
+   } /* loc_ioctl */
+
+   loc_set_slot_in_use(select_id, 0); // set slot in use to false
+   loc_unlock_slot(select_id);
+
+   return rc;
+}
+
+
diff --git a/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/src/loc_apicb_appinit.c b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/src/loc_apicb_appinit.c
new file mode 100644
index 0000000..db5b291
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-glue/src/loc_apicb_appinit.c
@@ -0,0 +1,86 @@
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "rpc/rpc.h"
+
+/* Include RPC headers */
+#ifdef USE_LOCAL_RPC
+#include "rpc_inc/loc_api_common.h"
+#include "rpc_inc/loc_api.h"
+#include "rpc_inc/loc_api_cb.h"
+#endif
+
+#ifdef USE_QCOM_AUTO_RPC
+#include "loc_api_rpcgen_rpc.h"
+#include "loc_api_rpcgen_common_rpc.h"
+#include "loc_api_rpcgen_cb_rpc.h"
+#endif
+
+#include "rpc_inc/loc_api_fixup.h"
+#include "loc_apicb_appinit.h"
+
+#define RPC_FUNC_VERSION_BASE(a,b) a ## b
+#define RPC_CB_FUNC_VERS(a,b) RPC_FUNC_VERSION_BASE(a,b)
+
+static SVCXPRT* svrPort = NULL;
+
+extern void RPC_CB_FUNC_VERS(loc_apicbprog_,LOC_APICBVERS_0001)(struct svc_req *rqstp, register SVCXPRT *transp);
+
+int loc_apicb_app_init(void)
+{
+
+  /* Register a callback server to use the loc_apicbprog_* function  */
+  if (svrPort == NULL) {
+        svrPort = svcrtr_create();
+  }
+  if (!svrPort) return -1;
+
+  xprt_register(svrPort);
+  if(svc_register(svrPort, LOC_APICBPROG, LOC_APICBVERS_0001, RPC_CB_FUNC_VERS(loc_apicbprog_,LOC_APICBVERS_0001),0))
+  {
+     return 0;
+  }
+  else
+  {
+    return -1;
+  }
+}
+
+void loc_apicb_app_deinit(void)
+{
+   if (svrPort == NULL)
+   {
+      return;
+   }
+
+   svc_unregister(svrPort, LOC_APICBPROG, LOC_APICBVERS_0001);
+   xprt_unregister(svrPort);
+   svc_destroy(svrPort);
+   svrPort = NULL;
+}
+
diff --git a/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/Android.mk b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/Android.mk
new file mode 100644
index 0000000..c0987e6
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/Android.mk
@@ -0,0 +1,36 @@
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+# functions
+LOC_RPCGEN_APIS_PATH := $(TARGET_OUT_INTERMEDIATES)/loc_api/libloc_api_rpcgen_intermediates
+LOC_RPCGEN_APIS_PATH_FL := ../../../../../$(TARGET_OUT_INTERMEDIATES)/loc_api/libloc_api_rpcgen_intermediates
+
+LOCAL_MODULE := libloc_api_rpcgen
+LOCAL_MODULE_OWNER := qcom
+
+LOCAL_SHARED_LIBRARIES := \
+    librpc \
+    libcommondefs
+
+LOCAL_SRC_FILES += \
+    src/loc_api_rpcgen_cb_xdr.c \
+    src/loc_api_rpcgen_common_xdr.c \
+    src/loc_api_rpcgen_cb_svc.c \
+    src/loc_api_rpcgen_clnt.c \
+    src/loc_api_rpcgen_xdr.c
+
+LOCAL_C_INCLUDES += hardware/msm7k/librpc
+LOCAL_C_INCLUDES += $(LOC_RPCGEN_APIS_PATH)/../../SHARED_LIBRARIES/libcommondefs_intermediates/inc
+LOCAL_C_INCLUDES += $(LOCAL_PATH)/inc
+LOCAL_C_INCLUDES += $(TARGET_OUT_HEADERS)/libcommondefs/rpcgen/inc
+
+LOCAL_COPY_HEADERS_TO := loc_api/rpcgen/inc
+LOCAL_COPY_HEADERS := inc/loc_api_rpcgen_rpc.h
+LOCAL_COPY_HEADERS += inc/loc_api_rpcgen_common_rpc.h
+LOCAL_COPY_HEADERS += inc/loc_api_rpcgen_cb_rpc.h
+LOCAL_COPY_HEADERS += inc/loc_apicb_appinit.h
+
+LOCAL_LDLIBS += -lpthread
+LOCAL_PRELINK_MODULE := false
+include $(BUILD_STATIC_LIBRARY)
diff --git a/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/Makefile.am b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/Makefile.am
new file mode 100644
index 0000000..4ac8c8a
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/Makefile.am
@@ -0,0 +1,42 @@
+AM_CFLAGS = \
+   -I../../../utils \
+   -I./inc \
+   $(MSM7K_CFLAGS)
+
+requiredlibs = \
+    ../../../utils/libgps_utils_so.la \
+    $(MSM7K_LIBS)
+
+h_sources = \
+    inc/loc_api_rpcgen_rpc.h \
+    inc/loc_api_rpcgen_common_rpc.h \
+    inc/loc_api_rpcgen_cb_rpc.h \
+    inc/loc_apicb_appinit.h
+
+c_sources = \
+    src/loc_api_rpcgen_cb_xdr.c \
+    src/loc_api_rpcgen_common_xdr.c \
+    src/loc_api_rpcgen_cb_svc.c \
+    src/loc_api_rpcgen_clnt.c \
+    src/loc_api_rpcgen_xdr.c
+
+
+
+library_includedir = $(pkgincludedir)/libloc_api-rpc-50001/libloc_api-rpc-stub/inc
+library_include_HEADERS = $(h_sources)
+libloc_api_rpcgen_la_SOURCES = $(c_sources) $(h_sources)
+
+if USE_GLIB
+libloc_api_rpcgen_la_CFLAGS = -DUSE_GLIB $(AM_CFLAGS) @GLIB_CFLAGS@
+libloc_api_rpcgen_la_LDFLAGS = -lstdc++ -lpthread @GLIB_LIBS@ -shared -version-info 1:0:0
+libloc_api_rpcgen_la_CPPFLAGS = -DUSE_GLIB $(AM_CFLAGS) $(AM_CPPFLAGS) @GLIB_CFLAGS@
+else
+libloc_api_rpcgen_la_CFLAGS = $(AM_CFLAGS)
+libloc_api_rpcgen_la_LDFLAGS = -lpthread -shared -version-info 1:0:0
+libloc_api_rpcgen_la_CPPFLAGS = $(AM_CFLAGS) $(AM_CPPFLAGS)
+endif
+
+libloc_api_rpcgen_la_LIBADD = $(requiredlibs) -lstdc++
+
+#Create and Install Libraries
+lib_LTLIBRARIES = libloc_api_rpcgen.la
diff --git a/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/inc/loc_api_rpcgen_cb_rpc.h b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/inc/loc_api_rpcgen_cb_rpc.h
new file mode 100644
index 0000000..87f2c37
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/inc/loc_api_rpcgen_cb_rpc.h
@@ -0,0 +1,156 @@
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#ifndef _LOC_API_CB_RPC_H_RPCGEN
+#define _LOC_API_CB_RPC_H_RPCGEN
+
+#include "librpc.h"
+#include "commondefs_rpcgen_rpc.h"
+#include "loc_api_rpcgen_common_rpc.h"
+
+#include <pthread.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+struct rpc_loc_event_cb_f_type_args {
+    rpc_uint32 cb_id;
+    rpc_loc_client_handle_type loc_handle;
+    rpc_loc_event_mask_type loc_event;
+    rpc_loc_event_payload_u_type *loc_event_payload;
+};
+typedef struct rpc_loc_event_cb_f_type_args rpc_loc_event_cb_f_type_args;
+
+struct rpc_loc_event_cb_f_type_rets {
+    rpc_int32 loc_event_cb_f_type_result;
+};
+typedef struct rpc_loc_event_cb_f_type_rets rpc_loc_event_cb_f_type_rets;
+#define LOC_APICBVERS 0x00050006
+
+#define LOC_APICBPROG 0x3100008C
+#define LOC_APICBVERS_0001 0x00050001
+
+#if defined(__STDC__) || defined(__cplusplus)
+#define rpc_loc_event_cb_f_type 1
+extern  enum clnt_stat rpc_loc_event_cb_f_type_0x00050001(rpc_loc_event_cb_f_type_args *, rpc_loc_event_cb_f_type_rets *, CLIENT *);
+extern  bool_t rpc_loc_event_cb_f_type_0x00050001_svc(rpc_loc_event_cb_f_type_args *, rpc_loc_event_cb_f_type_rets *, struct svc_req *);
+extern int loc_apicbprog_0x00050001_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+#define rpc_loc_event_cb_f_type 1
+extern  enum clnt_stat rpc_loc_event_cb_f_type_0x00050001();
+extern  bool_t rpc_loc_event_cb_f_type_0x00050001_svc();
+extern int loc_apicbprog_0x00050001_freeresult ();
+#endif /* K&R C */
+#define LOC_APICBVERS_0002 0x00050002
+
+#if defined(__STDC__) || defined(__cplusplus)
+#define rpc_loc_api_cb_null 0xffffff00
+extern  enum clnt_stat rpc_loc_api_cb_null_0x00050002(void *, int *, CLIENT *);
+extern  bool_t rpc_loc_api_cb_null_0x00050002_svc(void *, int *, struct svc_req *);
+extern int loc_apicbprog_0x00050002_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+#define rpc_loc_api_cb_null 0xffffff00
+extern  enum clnt_stat rpc_loc_api_cb_null_0x00050002();
+extern  bool_t rpc_loc_api_cb_null_0x00050002_svc();
+extern int loc_apicbprog_0x00050002_freeresult ();
+#endif /* K&R C */
+#define LOC_APICBVERS_0003 0x00050003
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  enum clnt_stat rpc_loc_api_cb_null_0x00050003(void *, int *, CLIENT *);
+extern  bool_t rpc_loc_api_cb_null_0x00050003_svc(void *, int *, struct svc_req *);
+extern int loc_apicbprog_0x00050003_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+extern  enum clnt_stat rpc_loc_api_cb_null_0x00050003();
+extern  bool_t rpc_loc_api_cb_null_0x00050003_svc();
+extern int loc_apicbprog_0x00050003_freeresult ();
+#endif /* K&R C */
+#define LOC_APICBVERS_0004 0x00050004
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  enum clnt_stat rpc_loc_api_cb_null_0x00050004(void *, int *, CLIENT *);
+extern  bool_t rpc_loc_api_cb_null_0x00050004_svc(void *, int *, struct svc_req *);
+extern int loc_apicbprog_0x00050004_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+extern  enum clnt_stat rpc_loc_api_cb_null_0x00050004();
+extern  bool_t rpc_loc_api_cb_null_0x00050004_svc();
+extern int loc_apicbprog_0x00050004_freeresult ();
+#endif /* K&R C */
+#define LOC_APICBVERS_0005 0x00050005
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  enum clnt_stat rpc_loc_api_cb_null_0x00050005(void *, int *, CLIENT *);
+extern  bool_t rpc_loc_api_cb_null_0x00050005_svc(void *, int *, struct svc_req *);
+extern int loc_apicbprog_0x00050005_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+extern  enum clnt_stat rpc_loc_api_cb_null_0x00050005();
+extern  bool_t rpc_loc_api_cb_null_0x00050005_svc();
+extern int loc_apicbprog_0x00050005_freeresult ();
+#endif /* K&R C */
+#define LOC_APICBVERS_0006 0x00050006
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  enum clnt_stat rpc_loc_api_cb_null_0x00050006(void *, int *, CLIENT *);
+extern  bool_t rpc_loc_api_cb_null_0x00050006_svc(void *, int *, struct svc_req *);
+extern int loc_apicbprog_0x00050006_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+extern  enum clnt_stat rpc_loc_api_cb_null_0x00050006();
+extern  bool_t rpc_loc_api_cb_null_0x00050006_svc();
+extern int loc_apicbprog_0x00050006_freeresult ();
+#endif /* K&R C */
+
+/* the xdr functions */
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  bool_t xdr_rpc_loc_event_cb_f_type_args (XDR *, rpc_loc_event_cb_f_type_args*);
+extern  bool_t xdr_rpc_loc_event_cb_f_type_rets (XDR *, rpc_loc_event_cb_f_type_rets*);
+
+#else /* K&R C */
+extern bool_t xdr_rpc_loc_event_cb_f_type_args ();
+extern bool_t xdr_rpc_loc_event_cb_f_type_rets ();
+
+#endif /* K&R C */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_LOC_API_CB_RPC_H_RPCGEN */
diff --git a/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/inc/loc_api_rpcgen_common_rpc.h b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/inc/loc_api_rpcgen_common_rpc.h
new file mode 100644
index 0000000..8107de2
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/inc/loc_api_rpcgen_common_rpc.h
@@ -0,0 +1,1261 @@
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#ifndef _LOC_API_COMMON_RPC_H_RPCGEN
+#define _LOC_API_COMMON_RPC_H_RPCGEN
+
+#include "librpc.h"
+#include "commondefs_rpcgen_rpc.h"
+
+#include <pthread.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define LOC_API_TOOLVERS 0x00040030
+#define LOC_API_FEATURES 0x00000001
+#define RPC_LOC_EVENT_STATUS_REPORT 0x00000100
+#define RPC_LOC_EVENT_ASSISTANCE_DATA_REQUEST 0x00000020
+#define RPC_LOC_EVENT_WPS_NEEDED_REQUEST 0x00000200
+#define RPC_LOC_EVENT_SATELLITE_REPORT 0x00000002
+#define RPC_LOC_EVENT_PARSED_POSITION_REPORT 0x00000001
+#define RPC_LOC_EVENT_RESERVED 0x8000000000000000
+#define RPC_LOC_EVENT_LOCATION_SERVER_REQUEST 0x00000040
+#define RPC_LOC_EVENT_NMEA_POSITION_REPORT 0x00000008
+#define RPC_LOC_EVENT_IOCTL_REPORT 0x00000080
+#define RPC_LOC_EVENT_NMEA_1HZ_REPORT 0x00000004
+#define RPC_LOC_EVENT_NI_NOTIFY_VERIFY_REQUEST 0x00000010
+#define RPC_LOC_API_CB_NULL_VERSION 0x00050002
+#define RPC_LOC_EVENT_CB_F_TYPE_VERSION 0x00050001
+#define RPC_LOC_API_API_VERSIONS_VERSION 0x00050001
+#define RPC_LOC_STOP_FIX_VERSION 0x00050001
+#define RPC_LOC_START_FIX_VERSION 0x00050001
+#define RPC_LOC_IOCTL_VERSION 0x00050001
+#define RPC_LOC_CLOSE_VERSION 0x00050001
+#define RPC_LOC_API_RPC_GLUE_CODE_INFO_REMOTE_VERSION 0x00050001
+#define RPC_LOC_OPEN_VERSION 0x00050001
+#define RPC_LOC_API_NULL_VERSION 0x00050001
+#define RPC_LOC_API_API_MAJOR_NUM 0x0005
+#define RPC_LOC_APIAPI_VERSION_IS_HASHKEY 0
+
+typedef rpc_int32 rpc_loc_client_handle_type;
+
+typedef rpc_uint64 rpc_loc_event_mask_type;
+
+typedef rpc_uint64 rpc_loc_position_valid_mask_type;
+
+typedef rpc_uint32 rpc_loc_pos_technology_mask_type;
+
+enum rpc_loc_session_status_e_type {
+    RPC_LOC_SESS_STATUS_SUCCESS = 0,
+    RPC_LOC_SESS_STATUS_IN_PROGESS = 1,
+    RPC_LOC_SESS_STATUS_GENERAL_FAILURE = 2,
+    RPC_LOC_SESS_STATUS_TIMEOUT = 3,
+    RPC_LOC_SESS_STATUS_USER_END = 4,
+    RPC_LOC_SESS_STATUS_BAD_PARAMETER = 5,
+    RPC_LOC_SESS_STATUS_PHONE_OFFLINE = 6,
+    RPC_LOC_SESS_STATUS_ENGINE_LOCKED = 7,
+    RPC_LOC_SESS_STATUS_MAX = 268435456,
+};
+typedef enum rpc_loc_session_status_e_type rpc_loc_session_status_e_type;
+
+struct rpc_loc_calendar_time_s_type {
+    rpc_uint16 year;
+    u_char month;
+    u_char day_of_week;
+    u_char day;
+    u_char hour;
+    u_char minute;
+    u_char second;
+    rpc_uint16 millisecond;
+};
+typedef struct rpc_loc_calendar_time_s_type rpc_loc_calendar_time_s_type;
+
+struct rpc_loc_parsed_position_s_type {
+    rpc_loc_position_valid_mask_type valid_mask;
+    rpc_loc_session_status_e_type session_status;
+    rpc_loc_calendar_time_s_type timestamp_calendar;
+    rpc_uint64 timestamp_utc;
+    rpc_uint8 leap_seconds;
+    float time_unc;
+    double latitude;
+    double longitude;
+    float altitude_wrt_ellipsoid;
+    float altitude_wrt_mean_sea_level;
+    float speed_horizontal;
+    float speed_vertical;
+    float heading;
+    float hor_unc_circular;
+    float hor_unc_ellipse_semi_major;
+    float hor_unc_ellipse_semi_minor;
+    float hor_unc_ellipse_orient_azimuth;
+    float vert_unc;
+    float speed_unc;
+    float heading_unc;
+    u_char confidence_horizontal;
+    u_char confidence_vertical;
+    float magnetic_deviation;
+    rpc_loc_pos_technology_mask_type technology_mask;
+};
+typedef struct rpc_loc_parsed_position_s_type rpc_loc_parsed_position_s_type;
+
+enum rpc_loc_sv_system_e_type {
+    RPC_LOC_SV_SYSTEM_GPS = 1,
+    RPC_LOC_SV_SYSTEM_GALILEO = 2,
+    RPC_LOC_SV_SYSTEM_SBAS = 3,
+    RPC_LOC_SV_SYSTEM_COMPASS = 4,
+    RPC_LOC_SV_SYSTEM_GLONASS = 5,
+    RPC_LOC_SV_SYSTEM_MAX = 268435456,
+};
+typedef enum rpc_loc_sv_system_e_type rpc_loc_sv_system_e_type;
+
+enum rpc_loc_sv_status_e_type {
+    RPC_LOC_SV_STATUS_IDLE = 1,
+    RPC_LOC_SV_STATUS_SEARCH = 2,
+    RPC_LOC_SV_STATUS_TRACK = 3,
+    RPC_LOC_SV_STATUS_MAX = 268435456,
+};
+typedef enum rpc_loc_sv_status_e_type rpc_loc_sv_status_e_type;
+
+typedef rpc_uint32 rpc_loc_sv_info_valid_mask_type;
+
+struct rpc_loc_sv_info_s_type {
+    rpc_loc_sv_info_valid_mask_type valid_mask;
+    rpc_loc_sv_system_e_type system;
+    rpc_uint8 prn;
+    rpc_uint8 health_status;
+    rpc_loc_sv_status_e_type process_status;
+    rpc_boolean has_eph;
+    rpc_boolean has_alm;
+    float elevation;
+    float azimuth;
+    float snr;
+};
+typedef struct rpc_loc_sv_info_s_type rpc_loc_sv_info_s_type;
+
+typedef rpc_uint32 rpc_loc_gnss_info_valid_mask_type;
+
+struct rpc_loc_gnss_info_s_type {
+    rpc_loc_gnss_info_valid_mask_type valid_mask;
+    float position_dop;
+    float horizontal_dop;
+    float vertical_dop;
+    rpc_boolean altitude_assumed;
+    rpc_uint16 sv_count;
+    struct {
+        u_int sv_list_len;
+        rpc_loc_sv_info_s_type *sv_list_val;
+    } sv_list;
+};
+typedef struct rpc_loc_gnss_info_s_type rpc_loc_gnss_info_s_type;
+
+struct rpc_loc_nmea_report_s_type {
+    rpc_uint16 length;
+    char nmea_sentences[200];
+};
+typedef struct rpc_loc_nmea_report_s_type rpc_loc_nmea_report_s_type;
+
+enum rpc_loc_status_event_e_type {
+    RPC_LOC_STATUS_EVENT_ENGINE_STATE = 1,
+    RPC_LOC_STATUS_EVENT_FIX_SESSION_STATE = 2,
+    RPC_LOC_STATUS_EVENT_MAX = 268435456,
+};
+typedef enum rpc_loc_status_event_e_type rpc_loc_status_event_e_type;
+
+enum rpc_loc_engine_state_e_type {
+    RPC_LOC_ENGINE_STATE_ON = 1,
+    RPC_LOC_ENGINE_STATE_OFF = 2,
+    RPC_LOC_ENGINE_STATE_MAX = 268435456,
+};
+typedef enum rpc_loc_engine_state_e_type rpc_loc_engine_state_e_type;
+
+enum rpc_loc_fix_session_state_e_type {
+    RPC_LOC_FIX_SESSION_STATE_BEGIN = 1,
+    RPC_LOC_FIX_SESSION_STATE_END = 2,
+    RPC_LOC_FIX_SESSION_STATE_MAX = 268435456,
+};
+typedef enum rpc_loc_fix_session_state_e_type rpc_loc_fix_session_state_e_type;
+
+struct rpc_loc_status_event_payload_u_type {
+    rpc_loc_status_event_e_type disc;
+    union {
+        rpc_loc_engine_state_e_type engine_state;
+        rpc_loc_fix_session_state_e_type fix_session_state;
+    } rpc_loc_status_event_payload_u_type_u;
+};
+typedef struct rpc_loc_status_event_payload_u_type rpc_loc_status_event_payload_u_type;
+
+struct rpc_loc_status_event_s_type {
+    rpc_loc_status_event_e_type event;
+    rpc_loc_status_event_payload_u_type payload;
+};
+typedef struct rpc_loc_status_event_s_type rpc_loc_status_event_s_type;
+
+enum rpc_loc_server_addr_e_type {
+    RPC_LOC_SERVER_ADDR_IPV4 = 1,
+    RPC_LOC_SERVER_ADDR_URL = 2,
+    RPC_LOC_SERVER_ADDR_IPV6 = 3,
+    RPC_LOC_SERVER_ADDR_MAX = 268435456,
+};
+typedef enum rpc_loc_server_addr_e_type rpc_loc_server_addr_e_type;
+
+struct rpc_loc_server_addr_ipv4_type {
+    rpc_uint32 addr;
+    rpc_uint16 port;
+};
+typedef struct rpc_loc_server_addr_ipv4_type rpc_loc_server_addr_ipv4_type;
+
+struct rpc_loc_server_addr_url_type {
+    rpc_uint16 length;
+    char addr[256];
+};
+typedef struct rpc_loc_server_addr_url_type rpc_loc_server_addr_url_type;
+
+struct rpc_loc_server_addr_ipv6_type {
+    rpc_uint16 addr[8];
+    rpc_uint32 port;
+};
+typedef struct rpc_loc_server_addr_ipv6_type rpc_loc_server_addr_ipv6_type;
+
+struct rpc_loc_server_addr_u_type {
+    rpc_loc_server_addr_e_type disc;
+    union {
+        rpc_loc_server_addr_ipv4_type ipv4;
+        rpc_loc_server_addr_url_type url;
+        rpc_loc_server_addr_ipv6_type ipv6;
+    } rpc_loc_server_addr_u_type_u;
+};
+typedef struct rpc_loc_server_addr_u_type rpc_loc_server_addr_u_type;
+
+struct rpc_loc_server_info_s_type {
+    rpc_loc_server_addr_e_type addr_type;
+    rpc_loc_server_addr_u_type addr_info;
+};
+typedef struct rpc_loc_server_info_s_type rpc_loc_server_info_s_type;
+
+enum rpc_loc_ni_notify_verify_e_type {
+    RPC_LOC_NI_USER_NO_NOTIFY_NO_VERIFY = 1,
+    RPC_LOC_NI_USER_NOTIFY_ONLY = 2,
+    RPC_LOC_NI_USER_NOTIFY_VERIFY_ALLOW_NO_RESP = 3,
+    RPC_LOC_NI_USER_NOTIFY_VERIFY_NOT_ALLOW_NO_RESP = 4,
+    RPC_LOC_NI_USER_PRIVACY_OVERRIDE = 5,
+    RPC_LOC_NI_USER_NOTIFY_VERITY_TYPE_MAX = 268435456,
+};
+typedef enum rpc_loc_ni_notify_verify_e_type rpc_loc_ni_notify_verify_e_type;
+
+enum rpc_loc_ni_event_e_type {
+    RPC_LOC_NI_EVENT_VX_NOTIFY_VERIFY_REQ = 1,
+    RPC_LOC_NI_EVENT_SUPL_NOTIFY_VERIFY_REQ = 2,
+    RPC_LOC_NI_EVENT_UMTS_CP_NOTIFY_VERIFY_REQ = 3,
+    RPC_LOC_NI_EVENT_VX_SERVICE_INTERACTION_REQ = 4,
+    RPC_LOC_NI_EVENT_MAX = 268435456,
+};
+typedef enum rpc_loc_ni_event_e_type rpc_loc_ni_event_e_type;
+
+enum rpc_loc_ni_datacoding_scheme_e_type {
+    RPC_LOC_NI_PRESUPL_ISO646IRV = 0,
+    RPC_LOC_NI_PRESUPL_ISO8859 = 1,
+    RPC_LOC_NI_PRESUPL_UTF8 = 2,
+    RPC_LOC_NI_PRESUPL_UTF16 = 3,
+    RPC_LOC_NI_PRESUPL_UCS2 = 4,
+    RPC_LOC_NI_PRESUPL_GSM_DEFAULT = 5,
+    RPC_LOC_NI_PRESUPL_SHIFT_JIS = 6,
+    RPC_LOC_NI_PRESUPL_JIS = 7,
+    RPC_LOC_NI_PRESUPL_EUC = 8,
+    RPC_LOC_NI_PRESUPL_GB2312 = 9,
+    RPC_LOC_NI_PRESUPL_CNS11643 = 10,
+    RPC_LOC_NI_PRESUPL_KSC1001 = 11,
+    RPC_LOC_NI_PRESUPL_ENCODING_UNKNOWN = 2147483647,
+    RPC_LOC_NI_SS_GERMAN = 12,
+    RPC_LOC_NI_SS_ENGLISH = 13,
+    RPC_LOC_NI_SS_ITALIAN = 14,
+    RPC_LOC_NI_SS_FRENCH = 15,
+    RPC_LOC_NI_SS_SPANISH = 16,
+    RPC_LOC_NI_SS_DUTCH = 17,
+    RPC_LOC_NI_SS_SWEDISH = 18,
+    RPC_LOC_NI_SS_DANISH = 19,
+    RPC_LOC_NI_SS_PORTUGUESE = 20,
+    RPC_LOC_NI_SS_FINNISH = 21,
+    RPC_LOC_NI_SS_NORWEGIAN = 22,
+    RPC_LOC_NI_SS_GREEK = 23,
+    RPC_LOC_NI_SS_TURKISH = 24,
+    RPC_LOC_NI_SS_HUNGARIAN = 25,
+    RPC_LOC_NI_SS_POLISH = 26,
+    RPC_LOC_NI_SS_LANGUAGE_UNSPEC = 27,
+    RPC_LOC_NI_SUPL_UTF8 = 28,
+    RPC_LOC_NI_SUPL_UCS2 = 29,
+    RPC_LOC_NI_SUPL_GSM_DEFAULT = 30,
+    RPC_LOC_NI_SUPL_ENCODING_UNKNOWN = 2147483647,
+};
+typedef enum rpc_loc_ni_datacoding_scheme_e_type rpc_loc_ni_datacoding_scheme_e_type;
+
+enum rpc_loc_ni_vx_requester_id_encoding_scheme_e_type {
+    RPC_LOC_NI_VX_OCTET = 0,
+    RPC_LOC_NI_VX_EXN_PROTOCOL_MSG = 1,
+    RPC_LOC_NI_VX_ASCII = 2,
+    RPC_LOC_NI_VX_IA5 = 3,
+    RPC_LOC_NI_VX_UNICODE = 4,
+    RPC_LOC_NI_VX_SHIFT_JIS = 5,
+    RPC_LOC_NI_VX_KOREAN = 6,
+    RPC_LOC_NI_VX_LATIN_HEBREW = 7,
+    RPC_LOC_NI_VX_LATIN = 8,
+    RPC_LOC_NI_VX_GSM = 9,
+    RPC_LOC_NI_VX_ENCODING_TYPE_MAX = 268435456,
+};
+typedef enum rpc_loc_ni_vx_requester_id_encoding_scheme_e_type rpc_loc_ni_vx_requester_id_encoding_scheme_e_type;
+
+enum rpc_loc_ni_vx_pos_mode_e_type {
+    RPC_LOC_VX_MS_ASSISTED_ONLY = 1,
+    RPC_LOC_VX_MS_BASED_ONLY = 2,
+    RPC_LOC_VX_MS_ASSISTED_PREF_MSBASED_ALLWD = 3,
+    RPC_LOC_VX_MS_BASED_PREF_ASSISTED_ALLWD = 4,
+    RPC_LOC_VX_POS_MODE_MAX = 268435456,
+};
+typedef enum rpc_loc_ni_vx_pos_mode_e_type rpc_loc_ni_vx_pos_mode_e_type;
+
+struct rpc_loc_ni_vx_requester_id_s_type {
+    u_char requester_id_length;
+    char requester_id[200];
+};
+typedef struct rpc_loc_ni_vx_requester_id_s_type rpc_loc_ni_vx_requester_id_s_type;
+
+struct rpc_loc_ni_vx_notify_verify_req_s_type {
+    rpc_loc_ni_notify_verify_e_type notification_priv_type;
+    u_char pos_qos_incl;
+    u_char pos_qos;
+    rpc_uint32 num_fixes;
+    rpc_uint32 tbf;
+    rpc_loc_ni_vx_pos_mode_e_type pos_mode;
+    rpc_loc_ni_vx_requester_id_encoding_scheme_e_type encoding_scheme;
+    rpc_loc_ni_vx_requester_id_s_type requester_id;
+    rpc_uint16 user_resp_timer_val;
+};
+typedef struct rpc_loc_ni_vx_notify_verify_req_s_type rpc_loc_ni_vx_notify_verify_req_s_type;
+
+enum rpc_loc_ni_supl_pos_method_e_type {
+    RPC_LOC_NI_POSMETHOD_AGPS_SETASSISTED = 1,
+    RPC_LOC_NI_POSMETHOD_AGPS_SETBASED = 2,
+    RPC_LOC_NI_POSMETHOD_AGPS_SETASSISTED_PREF = 3,
+    RPC_LOC_NI_POSMETHOD_AGPS_SETBASED_PREF = 4,
+    RPC_LOC_NI_POSMETHOD_AUTONOMOUS_GPS = 5,
+    RPC_LOC_NI_POSMETHOD_AFLT = 6,
+    RPC_LOC_NI_POSMETHOD_ECID = 7,
+    RPC_LOC_NI_POSMETHOD_EOTD = 8,
+    RPC_LOC_NI_POSMETHOD_OTDOA = 9,
+    RPC_LOC_NI_POSMETHOD_NO_POSITION = 10,
+    RPC_LOC_NI_POSMETHOD_MAX = 268435456,
+};
+typedef enum rpc_loc_ni_supl_pos_method_e_type rpc_loc_ni_supl_pos_method_e_type;
+
+struct rpc_loc_ni_supl_slp_session_id_s_type {
+    u_char presence;
+    char session_id[4];
+    rpc_loc_server_info_s_type slp_address;
+};
+typedef struct rpc_loc_ni_supl_slp_session_id_s_type rpc_loc_ni_supl_slp_session_id_s_type;
+
+struct rpc_loc_ni_requestor_id_s_type {
+    u_char data_coding_scheme;
+    char requestor_id_string[200];
+    u_char string_len;
+};
+typedef struct rpc_loc_ni_requestor_id_s_type rpc_loc_ni_requestor_id_s_type;
+
+struct rpc_loc_ni_supl_client_name_s_type {
+    u_char data_coding_scheme;
+    char client_name_string[64];
+    u_char string_len;
+};
+typedef struct rpc_loc_ni_supl_client_name_s_type rpc_loc_ni_supl_client_name_s_type;
+
+struct rpc_loc_ni_supl_qop_s_type {
+    u_char bit_mask;
+    u_char horacc;
+    u_char veracc;
+    rpc_uint16 maxLocAge;
+    u_char delay;
+};
+typedef struct rpc_loc_ni_supl_qop_s_type rpc_loc_ni_supl_qop_s_type;
+
+struct rpc_loc_ni_supl_notify_verify_req_s_type {
+    rpc_loc_ni_notify_verify_e_type notification_priv_type;
+    rpc_uint16 flags;
+    rpc_loc_ni_supl_slp_session_id_s_type supl_slp_session_id;
+    char supl_hash[8];
+    rpc_loc_ni_datacoding_scheme_e_type datacoding_scheme;
+    rpc_loc_ni_supl_pos_method_e_type pos_method;
+    rpc_loc_ni_requestor_id_s_type requestor_id;
+    rpc_loc_ni_supl_client_name_s_type client_name;
+    rpc_loc_ni_supl_qop_s_type supl_qop;
+    rpc_uint16 user_response_timer;
+};
+typedef struct rpc_loc_ni_supl_notify_verify_req_s_type rpc_loc_ni_supl_notify_verify_req_s_type;
+
+struct rpc_loc_ni_ext_client_address_s_type {
+    u_char ext_client_address_len;
+    char ext_client_address[20];
+};
+typedef struct rpc_loc_ni_ext_client_address_s_type rpc_loc_ni_ext_client_address_s_type;
+
+enum rpc_loc_ni_location_type_e_type {
+    RPC_LOC_NI_LOCATIONTYPE_CURRENT_LOCATION = 1,
+    RPC_LOC_NI_LOCATIONTYPE_CURRENT_OR_LAST_KNOWN_LOCATION = 2,
+    RPC_LOC_NI_LOCATIONTYPE_INITIAL_LOCATION = 3,
+    RPC_LOC_NI_LOCATIONTYPE_MAX = 268435456,
+};
+typedef enum rpc_loc_ni_location_type_e_type rpc_loc_ni_location_type_e_type;
+
+struct rpc_loc_ni_deferred_location_s_type {
+    u_char unused_bits;
+    u_char ms_available;
+};
+typedef struct rpc_loc_ni_deferred_location_s_type rpc_loc_ni_deferred_location_s_type;
+
+struct rpc_loc_ni_codeword_string_s_type {
+    u_char data_coding_scheme;
+    char lcs_codeword_string[20];
+    u_char string_len;
+};
+typedef struct rpc_loc_ni_codeword_string_s_type rpc_loc_ni_codeword_string_s_type;
+
+struct rpc_loc_ni_service_type_id_s_type {
+    u_char lcs_service_type_id;
+};
+typedef struct rpc_loc_ni_service_type_id_s_type rpc_loc_ni_service_type_id_s_type;
+
+struct rpc_loc_ni_umts_cp_notify_verify_req_s_type {
+    rpc_loc_ni_notify_verify_e_type notification_priv_type;
+    u_char invoke_id;
+    rpc_uint16 flags;
+    u_char notification_length;
+    char notification_text[64];
+    rpc_loc_ni_datacoding_scheme_e_type datacoding_scheme;
+    rpc_loc_ni_ext_client_address_s_type ext_client_address_data;
+    rpc_loc_ni_location_type_e_type location_type;
+    rpc_loc_ni_deferred_location_s_type deferred_location;
+    rpc_loc_ni_requestor_id_s_type requestor_id;
+    rpc_loc_ni_codeword_string_s_type codeword_string;
+    rpc_loc_ni_service_type_id_s_type service_type_id;
+    rpc_uint16 user_response_timer;
+};
+typedef struct rpc_loc_ni_umts_cp_notify_verify_req_s_type rpc_loc_ni_umts_cp_notify_verify_req_s_type;
+
+enum rpc_loc_ni_service_interaction_e_type {
+    RPC_LOC_NI_SERVICE_INTERACTION_ONGOING_NI_INCOMING_MO = 1,
+    RPC_LOC_NI_SERVICE_INTERACTION_MAX = 268435456,
+};
+typedef enum rpc_loc_ni_service_interaction_e_type rpc_loc_ni_service_interaction_e_type;
+
+struct rpc_loc_ni_vx_service_interaction_req_s_type {
+    rpc_loc_ni_vx_notify_verify_req_s_type ni_vx_req;
+    rpc_loc_ni_service_interaction_e_type service_interation_type;
+};
+typedef struct rpc_loc_ni_vx_service_interaction_req_s_type rpc_loc_ni_vx_service_interaction_req_s_type;
+
+struct rpc_loc_ni_event_payload_u_type {
+    rpc_loc_ni_event_e_type disc;
+    union {
+        rpc_loc_ni_vx_notify_verify_req_s_type vx_req;
+        rpc_loc_ni_supl_notify_verify_req_s_type supl_req;
+        rpc_loc_ni_umts_cp_notify_verify_req_s_type umts_cp_req;
+        rpc_loc_ni_vx_service_interaction_req_s_type service_interaction_req;
+    } rpc_loc_ni_event_payload_u_type_u;
+};
+typedef struct rpc_loc_ni_event_payload_u_type rpc_loc_ni_event_payload_u_type;
+
+struct rpc_loc_ni_event_s_type {
+    rpc_loc_ni_event_e_type event;
+    rpc_loc_ni_event_payload_u_type payload;
+};
+typedef struct rpc_loc_ni_event_s_type rpc_loc_ni_event_s_type;
+
+enum rpc_loc_assist_data_request_e_type {
+    RPC_LOC_ASSIST_DATA_TIME_REQ = 1,
+    RPC_LOC_ASSIST_DATA_PREDICTED_ORBITS_REQ = 2,
+    RPC_LOC_ASSIST_DATA_POSITION_INJECTION_REQ = 3,
+    RPC_LOC_ASSIST_DATA_MAX = 268435456,
+};
+typedef enum rpc_loc_assist_data_request_e_type rpc_loc_assist_data_request_e_type;
+
+typedef char *rpc_struct_loc_time_download_source_s_type_servers_ptr;
+
+typedef rpc_struct_loc_time_download_source_s_type_servers_ptr rpc_struct_loc_time_download_source_s_type_servers[3];
+
+struct rpc_loc_time_download_source_s_type {
+    rpc_uint32 delay_threshold;
+    rpc_struct_loc_time_download_source_s_type_servers servers;
+};
+typedef struct rpc_loc_time_download_source_s_type rpc_loc_time_download_source_s_type;
+
+typedef char *rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr;
+
+typedef rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr rpc_struct_loc_predicted_orbits_data_source_s_type_servers[3];
+
+struct rpc_loc_predicted_orbits_data_source_s_type {
+    rpc_uint32 max_file_size;
+    rpc_uint32 max_part_size;
+    rpc_struct_loc_predicted_orbits_data_source_s_type_servers servers;
+};
+typedef struct rpc_loc_predicted_orbits_data_source_s_type rpc_loc_predicted_orbits_data_source_s_type;
+
+struct rpc_loc_pos_inj_request_s_type {
+    rpc_uint32 flags;
+    double latitude;
+    double longitude;
+    rpc_uint32 position_uncertainty;
+    rpc_uint64 timestamp;
+};
+typedef struct rpc_loc_pos_inj_request_s_type rpc_loc_pos_inj_request_s_type;
+
+struct rpc_loc_assist_data_request_payload_u_type {
+    rpc_loc_assist_data_request_e_type disc;
+    union {
+        rpc_loc_time_download_source_s_type time_download;
+        rpc_loc_predicted_orbits_data_source_s_type data_download;
+        rpc_loc_pos_inj_request_s_type pos_injection;
+    } rpc_loc_assist_data_request_payload_u_type_u;
+};
+typedef struct rpc_loc_assist_data_request_payload_u_type rpc_loc_assist_data_request_payload_u_type;
+
+struct rpc_loc_assist_data_request_s_type {
+    rpc_loc_assist_data_request_e_type event;
+    rpc_loc_assist_data_request_payload_u_type payload;
+};
+typedef struct rpc_loc_assist_data_request_s_type rpc_loc_assist_data_request_s_type;
+
+typedef rpc_uint32 rpc_loc_server_connection_handle;
+
+enum rpc_loc_server_protocol_e_type {
+    RPC_LOC_SERVER_PROTOCOL_DEFAULT = 0,
+    RPC_LOC_SERVER_PROTOCOL_SUPL = 1,
+    RPC_LOC_SERVER_PROTOCOL_VX_MPC = 2,
+    RPC_LOC_SERVER_PROTOCOL_VX_PDE = 3,
+    RPC_LOC_SERVER_PROTOCOL_MAX = 16777216,
+};
+typedef enum rpc_loc_server_protocol_e_type rpc_loc_server_protocol_e_type;
+
+enum rpc_loc_server_connection_e_type {
+    RPC_LOC_SERVER_CONNECTION_LBS = 0,
+    RPC_LOC_SERVER_CONNECTION_WWAN_INTERNET = 0 + 1,
+    RPC_LOC_SERVER_CONNECTION_MAX = 16777216,
+};
+typedef enum rpc_loc_server_connection_e_type rpc_loc_server_connection_e_type;
+
+enum rpc_loc_server_request_e_type {
+    RPC_LOC_SERVER_REQUEST_OPEN = 1,
+    RPC_LOC_SERVER_REQUEST_CLOSE = 2,
+    RPC_LOC_SERVER_REQUEST_MULTI_OPEN = 3,
+    RPC_LOC_SERVER_REQUEST_MAX = 268435456,
+};
+typedef enum rpc_loc_server_request_e_type rpc_loc_server_request_e_type;
+
+struct rpc_loc_server_open_req_s_type {
+    rpc_loc_server_connection_handle conn_handle;
+    rpc_loc_server_protocol_e_type protocol;
+};
+typedef struct rpc_loc_server_open_req_s_type rpc_loc_server_open_req_s_type;
+
+struct rpc_loc_server_multi_open_req_s_type {
+    rpc_loc_server_connection_handle conn_handle;
+    rpc_loc_server_protocol_e_type protocol;
+    rpc_loc_server_connection_e_type connection_type;
+};
+typedef struct rpc_loc_server_multi_open_req_s_type rpc_loc_server_multi_open_req_s_type;
+
+struct rpc_loc_server_close_req_s_type {
+    rpc_loc_server_connection_handle conn_handle;
+};
+typedef struct rpc_loc_server_close_req_s_type rpc_loc_server_close_req_s_type;
+
+struct rpc_loc_server_request_u_type {
+    rpc_loc_server_request_e_type disc;
+    union {
+        rpc_loc_server_open_req_s_type open_req;
+        rpc_loc_server_close_req_s_type close_req;
+        rpc_loc_server_multi_open_req_s_type multi_open_req;
+    } rpc_loc_server_request_u_type_u;
+};
+typedef struct rpc_loc_server_request_u_type rpc_loc_server_request_u_type;
+
+struct rpc_loc_server_request_s_type {
+    rpc_loc_server_request_e_type event;
+    rpc_loc_server_request_u_type payload;
+};
+typedef struct rpc_loc_server_request_s_type rpc_loc_server_request_s_type;
+
+enum rpc_loc_qwip_request_e_type {
+    RPC_LOC_QWIP_START_PERIODIC_HI_FREQ_FIXES = 0,
+    RPC_LOC_QWIP_START_PERIODIC_KEEP_WARM = 0 + 1,
+    RPC_LOC_QWIP_STOP_PERIODIC_FIXES = 0 + 2,
+    RPC_LOC_QWIP_SUSPEND = 0 + 3,
+    RPC_LOC_QWIP_REQUEST_MAX = 268435456,
+};
+typedef enum rpc_loc_qwip_request_e_type rpc_loc_qwip_request_e_type;
+
+struct rpc_loc_qwip_request_s_type {
+    rpc_loc_qwip_request_e_type request_type;
+    rpc_uint16 tbf_ms;
+};
+typedef struct rpc_loc_qwip_request_s_type rpc_loc_qwip_request_s_type;
+
+struct rpc_loc_reserved_payload_s_type {
+    rpc_uint16 data_size;
+    struct {
+        u_int data_len;
+        char *data_val;
+    } data;
+};
+typedef struct rpc_loc_reserved_payload_s_type rpc_loc_reserved_payload_s_type;
+
+enum rpc_loc_ioctl_e_type {
+    RPC_LOC_IOCTL_GET_API_VERSION = 1,
+    RPC_LOC_IOCTL_SET_FIX_CRITERIA = 2,
+    RPC_LOC_IOCTL_GET_FIX_CRITERIA = 3,
+    RPC_LOC_IOCTL_SERVICE_START_INDEX = 400,
+    RPC_LOC_IOCTL_INFORM_NI_USER_RESPONSE = 400,
+    RPC_LOC_IOCTL_INJECT_PREDICTED_ORBITS_DATA = 401,
+    RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_VALIDITY = 402,
+    RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_SOURCE = 403,
+    RPC_LOC_IOCTL_SET_PREDICTED_ORBITS_DATA_AUTO_DOWNLOAD = 404,
+    RPC_LOC_IOCTL_INJECT_UTC_TIME = 405,
+    RPC_LOC_IOCTL_INJECT_RTC_VALUE = 406,
+    RPC_LOC_IOCTL_INJECT_POSITION = 407,
+    RPC_LOC_IOCTL_QUERY_ENGINE_STATE = 408,
+    RPC_LOC_IOCTL_INFORM_SERVER_OPEN_STATUS = 409,
+    RPC_LOC_IOCTL_INFORM_SERVER_CLOSE_STATUS = 410,
+    RPC_LOC_IOCTL_SEND_WIPER_POSITION_REPORT = 411,
+    RPC_LOC_IOCTL_NOTIFY_WIPER_STATUS = 412,
+    RPC_LOC_IOCTL_ACCESS_EFS_DATA = 413,
+    RPC_LOC_IOCTL_ERROR_ESTIMATE_CONFIG = 414,
+    RPC_LOC_IOCTL_INFORM_SERVER_MULTI_OPEN_STATUS = 415,
+    RPC_LOC_IOCTL_NV_SETTINGS_START_INDEX = 800,
+    RPC_LOC_IOCTL_SET_ENGINE_LOCK = 800,
+    RPC_LOC_IOCTL_GET_ENGINE_LOCK = 801,
+    RPC_LOC_IOCTL_SET_SBAS_CONFIG = 802,
+    RPC_LOC_IOCTL_GET_SBAS_CONFIG = 803,
+    RPC_LOC_IOCTL_SET_NMEA_TYPES = 804,
+    RPC_LOC_IOCTL_GET_NMEA_TYPES = 805,
+    RPC_LOC_IOCTL_SET_CDMA_PDE_SERVER_ADDR = 806,
+    RPC_LOC_IOCTL_GET_CDMA_PDE_SERVER_ADDR = 807,
+    RPC_LOC_IOCTL_SET_CDMA_MPC_SERVER_ADDR = 808,
+    RPC_LOC_IOCTL_GET_CDMA_MPC_SERVER_ADDR = 809,
+    RPC_LOC_IOCTL_SET_UMTS_SLP_SERVER_ADDR = 810,
+    RPC_LOC_IOCTL_GET_UMTS_SLP_SERVER_ADDR = 811,
+    RPC_LOC_IOCTL_SET_ON_DEMAND_LPM = 812,
+    RPC_LOC_IOCTL_GET_ON_DEMAND_LPM = 813,
+    RPC_LOC_IOCTL_SET_XTRA_T_SESSION_CONTROL = 814,
+    RPC_LOC_IOCTL_GET_XTRA_T_SESSION_CONTROL = 815,
+    RPC_LOC_IOCTL_SET_LBS_APN_PROFILE = 816,
+    RPC_LOC_IOCTL_GET_LBS_APN_PROFILE = 817,
+    RPC_LOC_IOCTL_SET_XTRA_APN_PROFILE = 818,
+    RPC_LOC_IOCTL_GET_XTRA_APN_PROFILE = 819,
+    RPC_LOC_IOCTL_SET_DATA_ENABLE = 820,
+    RPC_LOC_IOCTL_SET_SUPL_VERSION = 821,
+    RPC_LOC_IOCTL_GET_SUPL_VERSION = 822,
+    RPC_LOC_IOCTL_PROPRIETARY_START_INDEX = 1000,
+    RPC_LOC_IOCTL_DELETE_ASSIST_DATA = 1000,
+    RPC_LOC_IOCTL_SET_CUSTOM_PDE_SERVER_ADDR = 1001,
+    RPC_LOC_IOCTL_GET_CUSTOM_PDE_SERVER_ADDR = 1002,
+    RPC_LOC_IOCTL_RESERVED_CMD = 8000,
+    RPC_LOC_IOCTL_THIRD_PARTY_START_INDEX = 1073741824,
+};
+typedef enum rpc_loc_ioctl_e_type rpc_loc_ioctl_e_type;
+
+struct rpc_loc_api_version_s_type {
+    u_char major;
+    u_char minor;
+};
+typedef struct rpc_loc_api_version_s_type rpc_loc_api_version_s_type;
+
+enum rpc_loc_fix_recurrence_e_type {
+    RPC_LOC_PERIODIC_FIX = 1,
+    RPC_LOC_SINGLE_FIX = 2,
+    RPC_LOC_FIX_SESSION_TYPE_MAX = 268435456,
+};
+typedef enum rpc_loc_fix_recurrence_e_type rpc_loc_fix_recurrence_e_type;
+
+enum rpc_loc_operation_mode_e_type {
+    RPC_LOC_OPER_MODE_DEFAULT = 1,
+    RPC_LOC_OPER_MODE_MSB = 2,
+    RPC_LOC_OPER_MODE_MSA = 3,
+    RPC_LOC_OPER_MODE_STANDALONE = 4,
+    RPC_LOC_OPER_MODE_SPEED_OPTIMAL = 5,
+    RPC_LOC_OPER_MODE_ACCURACY_OPTIMAL = 6,
+    RPC_LOC_OPER_MODE_DATA_OPTIMAL = 7,
+    RPC_LOC_OPER_MODE_CELL_ID = 8,
+    RPC_LOC_OPER_MODE_MAX = 268435456,
+};
+typedef enum rpc_loc_operation_mode_e_type rpc_loc_operation_mode_e_type;
+
+enum rpc_loc_notify_e_type {
+    RPC_LOC_NOTIFY_ON_INTERVAL = 1,
+    RPC_LOC_NOTIFY_ON_DISTANCE = 2,
+    RPC_LOC_NOTIFY_ON_ANY = 3,
+    RPC_LOC_NOTIFY_ON_ALL = 4,
+    RPC_LOC_NOTIFY_TYPE_MAX = 268435456,
+};
+typedef enum rpc_loc_notify_e_type rpc_loc_notify_e_type;
+
+struct rpc_loc_fix_criteria_s_type {
+    rpc_uint32 valid_mask;
+    rpc_loc_fix_recurrence_e_type recurrence_type;
+    rpc_loc_operation_mode_e_type preferred_operation_mode;
+    rpc_uint32 preferred_accuracy;
+    rpc_uint32 preferred_response_time;
+    rpc_boolean intermediate_pos_report_enabled;
+    rpc_loc_notify_e_type notify_type;
+    rpc_uint32 min_interval;
+    float min_distance;
+    rpc_uint32 min_dist_sample_interval;
+};
+typedef struct rpc_loc_fix_criteria_s_type rpc_loc_fix_criteria_s_type;
+
+enum rpc_loc_ni_user_resp_e_type {
+    RPC_LOC_NI_LCS_NOTIFY_VERIFY_ACCEPT = 1,
+    RPC_LOC_NI_LCS_NOTIFY_VERIFY_DENY = 2,
+    RPC_LOC_NI_LCS_NOTIFY_VERIFY_NORESP = 3,
+    RPC_LOC_NI_LCS_NOTIFY_VERIFY_MAX = 268435456,
+};
+typedef enum rpc_loc_ni_user_resp_e_type rpc_loc_ni_user_resp_e_type;
+
+struct rpc_loc_user_verify_s_type {
+    rpc_loc_ni_user_resp_e_type user_resp;
+    rpc_loc_ni_event_s_type ni_event_pass_back;
+};
+typedef struct rpc_loc_user_verify_s_type rpc_loc_user_verify_s_type;
+
+enum rpc_loc_predicted_orbits_data_format_e_type {
+    RPC_LOC_PREDICTED_ORBITS_XTRA = 0,
+    RPC_LOC_PREDICTED_ORBITS_FORMAT_MAX = 268435456,
+};
+typedef enum rpc_loc_predicted_orbits_data_format_e_type rpc_loc_predicted_orbits_data_format_e_type;
+
+struct rpc_loc_predicted_orbits_data_s_type {
+    rpc_loc_predicted_orbits_data_format_e_type format_type;
+    rpc_uint32 total_size;
+    rpc_uint8 total_parts;
+    rpc_uint8 part;
+    rpc_uint16 part_len;
+    struct {
+        u_int data_ptr_len;
+        char *data_ptr_val;
+    } data_ptr;
+};
+typedef struct rpc_loc_predicted_orbits_data_s_type rpc_loc_predicted_orbits_data_s_type;
+
+struct rpc_loc_predicted_orbits_data_validity_report_s_type {
+    rpc_uint64 start_time_utc;
+    rpc_uint16 valid_duration_hrs;
+};
+typedef struct rpc_loc_predicted_orbits_data_validity_report_s_type rpc_loc_predicted_orbits_data_validity_report_s_type;
+
+struct rpc_loc_predicted_orbits_auto_download_config_s_type {
+    rpc_boolean enable;
+    u_char auto_check_every_hrs;
+};
+typedef struct rpc_loc_predicted_orbits_auto_download_config_s_type rpc_loc_predicted_orbits_auto_download_config_s_type;
+
+struct rpc_loc_assist_data_time_s_type {
+    rpc_uint64 time_utc;
+    rpc_uint32 uncertainty;
+};
+typedef struct rpc_loc_assist_data_time_s_type rpc_loc_assist_data_time_s_type;
+
+typedef rpc_uint64 rpc_loc_assist_pos_valid_mask_type;
+
+struct rpc_loc_assist_data_pos_s_type {
+    rpc_loc_assist_pos_valid_mask_type valid_mask;
+    rpc_uint64 timestamp_utc;
+    double latitude;
+    double longitude;
+    float altitude_wrt_ellipsoid;
+    float altitude_wrt_mean_sea_level;
+    float hor_unc_circular;
+    float vert_unc;
+    u_char confidence_horizontal;
+    u_char confidence_vertical;
+    rpc_int32 timestamp_age;
+};
+typedef struct rpc_loc_assist_data_pos_s_type rpc_loc_assist_data_pos_s_type;
+
+enum rpc_loc_server_open_status_e_type {
+    RPC_LOC_SERVER_OPEN_SUCCESS = 1,
+    RPC_LOC_SERVER_OPEN_FAIL = 2,
+    RPC_LOC_SERVER_OPEN_STATUS_MAX = 268435456,
+};
+typedef enum rpc_loc_server_open_status_e_type rpc_loc_server_open_status_e_type;
+
+enum rpc_loc_server_pdp_type_e_type {
+    RPC_LOC_SERVER_PDP_IP = 0,
+    RPC_LOC_SERVER_PDP_PPP = 0 + 1,
+    RPC_LOC_SERVER_PDP_IPV6 = 0 + 2,
+    RPC_LOC_SERVER_PDP_IPV4V6 = 0 + 3,
+    RPC_LOC_SERVER_PDP_MAX = 268435456,
+};
+typedef enum rpc_loc_server_pdp_type_e_type rpc_loc_server_pdp_type_e_type;
+
+struct rpc_loc_server_open_status_s_type {
+    rpc_loc_server_connection_handle conn_handle;
+    rpc_loc_server_open_status_e_type open_status;
+    char apn_name[100];
+};
+typedef struct rpc_loc_server_open_status_s_type rpc_loc_server_open_status_s_type;
+
+struct rpc_loc_server_multi_open_status_s_type {
+    rpc_loc_server_connection_handle conn_handle;
+    rpc_loc_server_open_status_e_type open_status;
+    rpc_loc_server_pdp_type_e_type pdp_type;
+    char apn_name[100];
+};
+typedef struct rpc_loc_server_multi_open_status_s_type rpc_loc_server_multi_open_status_s_type;
+
+enum rpc_loc_server_close_status_e_type {
+    RPC_LOC_SERVER_CLOSE_SUCCESS = 1,
+    RPC_LOC_SERVER_CLOSE_FAIL = 2,
+    RPC_LOC_SERVER_CLOSE_STATUS_MAX = 268435456,
+};
+typedef enum rpc_loc_server_close_status_e_type rpc_loc_server_close_status_e_type;
+
+struct rpc_loc_server_close_status_s_type {
+    rpc_loc_server_connection_handle conn_handle;
+    rpc_loc_server_close_status_e_type close_status;
+};
+typedef struct rpc_loc_server_close_status_s_type rpc_loc_server_close_status_s_type;
+
+struct rpc_loc_wiper_fix_time_s_type {
+    rpc_uint32 slow_clock_count;
+};
+typedef struct rpc_loc_wiper_fix_time_s_type rpc_loc_wiper_fix_time_s_type;
+
+struct rpc_loc_wiper_fix_pos_s_type {
+    rpc_int32 lat;
+    rpc_int32 lon;
+    rpc_uint16 HEPE;
+    rpc_uint8 num_of_aps_used;
+    rpc_uint8 fix_error_code;
+};
+typedef struct rpc_loc_wiper_fix_pos_s_type rpc_loc_wiper_fix_pos_s_type;
+
+struct rpc_loc_wiper_ap_info_s_type {
+    char mac_addr[6];
+    rpc_int32 rssi;
+    rpc_uint16 channel;
+    rpc_uint8 ap_qualifier;
+};
+typedef struct rpc_loc_wiper_ap_info_s_type rpc_loc_wiper_ap_info_s_type;
+
+struct rpc_loc_wiper_ap_set_s_type {
+    rpc_uint8 num_of_aps;
+    rpc_loc_wiper_ap_info_s_type ap_info[50];
+};
+typedef struct rpc_loc_wiper_ap_set_s_type rpc_loc_wiper_ap_set_s_type;
+
+struct rpc_loc_wiper_position_report_s_type {
+    rpc_uint8 wiper_valid_info_flag;
+    rpc_loc_wiper_fix_time_s_type wiper_fix_time;
+    rpc_loc_wiper_fix_pos_s_type wiper_fix_position;
+    rpc_loc_wiper_ap_set_s_type wiper_ap_set;
+};
+typedef struct rpc_loc_wiper_position_report_s_type rpc_loc_wiper_position_report_s_type;
+
+enum rpc_loc_wiper_status_e_type {
+    RPC_LOC_WIPER_STATUS_AVAILABLE = 1,
+    RPC_LOC_WIPER_STATUS_UNAVAILABLE = 2,
+    RPC_LOC_WIPER_STATUS_E_SIZE = 268435456,
+};
+typedef enum rpc_loc_wiper_status_e_type rpc_loc_wiper_status_e_type;
+
+enum rpc_loc_fs_operation_e_type {
+    RPC_LOC_FS_CREATE_WRITE_FILE = 1,
+    RPC_LOC_FS_APPEND_FILE = 2,
+    RPC_LOC_FS_DELETE_FILE = 3,
+    RPC_LOC_FS_READ_FILE = 4,
+    RPC_LOC_FS_MAX = 268435456,
+};
+typedef enum rpc_loc_fs_operation_e_type rpc_loc_fs_operation_e_type;
+
+struct rpc_loc_efs_data_s_type {
+    char filename[64];
+    rpc_loc_fs_operation_e_type operation;
+    rpc_uint32 total_size;
+    struct {
+        u_int data_ptr_len;
+        char *data_ptr_val;
+    } data_ptr;
+    rpc_uint32 part_len;
+    rpc_uint8 part;
+    rpc_uint8 total_parts;
+    rpc_uint32 reserved;
+};
+typedef struct rpc_loc_efs_data_s_type rpc_loc_efs_data_s_type;
+
+enum rpc_loc_error_estimate_config_e_type {
+    RPC_LOC_ERROR_ESTIMATE_CONFIG_SET = 1,
+    RPC_LOC_ERROR_ESTIMATE_CONFIG_CLEAR = 2,
+    RPC_LOC_ERROR_ESTIMATE_MAX = 268435456,
+};
+typedef enum rpc_loc_error_estimate_config_e_type rpc_loc_error_estimate_config_e_type;
+
+struct rpc_loc_apn_profiles_type {
+    rpc_uint32 srv_system_type;
+    rpc_uint32 pdp_type;
+    rpc_uint32 reserved;
+    char apn_name[100];
+};
+typedef struct rpc_loc_apn_profiles_type rpc_loc_apn_profiles_type;
+
+enum rpc_loc_lock_e_type {
+    RPC_LOC_LOCK_NONE = 1,
+    RPC_LOC_LOCK_MI = 2,
+    RPC_LOC_LOCK_MT = 3,
+    RPC_LOC_LOCK_ALL = 4,
+    RPC_LOC_LOCK_MAX = 268435456,
+};
+typedef enum rpc_loc_lock_e_type rpc_loc_lock_e_type;
+
+typedef rpc_uint32 rpc_loc_nmea_sentence_type;
+
+typedef rpc_uint32 rpc_loc_assist_data_type;
+
+struct rpc_loc_assist_data_delete_s_type {
+    rpc_loc_assist_data_type type;
+    rpc_uint32 reserved[8];
+};
+typedef struct rpc_loc_assist_data_delete_s_type rpc_loc_assist_data_delete_s_type;
+
+struct rpc_loc_ioctl_data_u_type {
+    rpc_loc_ioctl_e_type disc;
+    union {
+        rpc_loc_fix_criteria_s_type fix_criteria;
+        rpc_loc_user_verify_s_type user_verify_resp;
+        rpc_loc_predicted_orbits_data_s_type predicted_orbits_data;
+        rpc_loc_predicted_orbits_auto_download_config_s_type predicted_orbits_auto_download;
+        rpc_loc_assist_data_time_s_type assistance_data_time;
+        rpc_loc_assist_data_pos_s_type assistance_data_position;
+        rpc_loc_server_open_status_s_type conn_open_status;
+        rpc_loc_server_close_status_s_type conn_close_status;
+        rpc_loc_wiper_position_report_s_type wiper_pos;
+        rpc_loc_wiper_status_e_type wiper_status;
+        rpc_loc_lock_e_type engine_lock;
+        rpc_boolean sbas_mode;
+        rpc_loc_nmea_sentence_type nmea_types;
+        rpc_boolean on_demand_lpm;
+        rpc_loc_server_info_s_type server_addr;
+        rpc_loc_assist_data_delete_s_type assist_data_delete;
+        rpc_loc_efs_data_s_type efs_data;
+        rpc_loc_error_estimate_config_e_type error_estimate_config;
+        rpc_uint8 xtra_t_session_control;
+        rpc_loc_apn_profiles_type apn_profiles[6];
+        rpc_boolean data_enable;
+        rpc_uint32 supl_version;
+        rpc_loc_server_multi_open_status_s_type multi_conn_open_status;
+        rpc_loc_reserved_payload_s_type reserved;
+    } rpc_loc_ioctl_data_u_type_u;
+};
+typedef struct rpc_loc_ioctl_data_u_type rpc_loc_ioctl_data_u_type;
+
+struct rpc_loc_ioctl_callback_data_u_type {
+    rpc_loc_ioctl_e_type disc;
+    union {
+        rpc_loc_api_version_s_type api_version;
+        rpc_loc_fix_criteria_s_type fix_criteria;
+        rpc_loc_lock_e_type engine_lock;
+        rpc_boolean sbas_mode;
+        rpc_loc_nmea_sentence_type nmea_types;
+        rpc_boolean on_demand_lpm;
+        rpc_loc_server_info_s_type server_addr;
+        rpc_loc_predicted_orbits_data_source_s_type predicted_orbits_data_source;
+        rpc_loc_predicted_orbits_data_validity_report_s_type predicted_orbits_data_validity;
+        rpc_uint8 xtra_t_session_control;
+        rpc_loc_apn_profiles_type apn_profiles[6];
+        rpc_uint32 supl_version;
+    } rpc_loc_ioctl_callback_data_u_type_u;
+};
+typedef struct rpc_loc_ioctl_callback_data_u_type rpc_loc_ioctl_callback_data_u_type;
+
+struct rpc_loc_ioctl_callback_s_type {
+    rpc_loc_ioctl_e_type type;
+    rpc_int32 status;
+    rpc_loc_ioctl_callback_data_u_type data;
+};
+typedef struct rpc_loc_ioctl_callback_s_type rpc_loc_ioctl_callback_s_type;
+
+struct rpc_loc_event_payload_u_type {
+    u_quad_t disc;
+    union {
+        rpc_loc_parsed_position_s_type parsed_location_report;
+        rpc_loc_gnss_info_s_type gnss_report;
+        rpc_loc_nmea_report_s_type nmea_report;
+        rpc_loc_ni_event_s_type ni_request;
+        rpc_loc_assist_data_request_s_type assist_data_request;
+        rpc_loc_server_request_s_type loc_server_request;
+        rpc_loc_ioctl_callback_s_type ioctl_report;
+        rpc_loc_status_event_s_type status_report;
+        rpc_loc_qwip_request_s_type qwip_request;
+        rpc_loc_reserved_payload_s_type reserved;
+    } rpc_loc_event_payload_u_type_u;
+};
+typedef struct rpc_loc_event_payload_u_type rpc_loc_event_payload_u_type;
+
+/* the xdr functions */
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  bool_t xdr_rpc_loc_client_handle_type (XDR *, rpc_loc_client_handle_type*);
+extern  bool_t xdr_rpc_loc_event_mask_type (XDR *, rpc_loc_event_mask_type*);
+extern  bool_t xdr_rpc_loc_position_valid_mask_type (XDR *, rpc_loc_position_valid_mask_type*);
+extern  bool_t xdr_rpc_loc_pos_technology_mask_type (XDR *, rpc_loc_pos_technology_mask_type*);
+extern  bool_t xdr_rpc_loc_session_status_e_type (XDR *, rpc_loc_session_status_e_type*);
+extern  bool_t xdr_rpc_loc_calendar_time_s_type (XDR *, rpc_loc_calendar_time_s_type*);
+extern  bool_t xdr_rpc_loc_parsed_position_s_type (XDR *, rpc_loc_parsed_position_s_type*);
+extern  bool_t xdr_rpc_loc_sv_system_e_type (XDR *, rpc_loc_sv_system_e_type*);
+extern  bool_t xdr_rpc_loc_sv_status_e_type (XDR *, rpc_loc_sv_status_e_type*);
+extern  bool_t xdr_rpc_loc_sv_info_valid_mask_type (XDR *, rpc_loc_sv_info_valid_mask_type*);
+extern  bool_t xdr_rpc_loc_sv_info_s_type (XDR *, rpc_loc_sv_info_s_type*);
+extern  bool_t xdr_rpc_loc_gnss_info_valid_mask_type (XDR *, rpc_loc_gnss_info_valid_mask_type*);
+extern  bool_t xdr_rpc_loc_gnss_info_s_type (XDR *, rpc_loc_gnss_info_s_type*);
+extern  bool_t xdr_rpc_loc_nmea_report_s_type (XDR *, rpc_loc_nmea_report_s_type*);
+extern  bool_t xdr_rpc_loc_status_event_e_type (XDR *, rpc_loc_status_event_e_type*);
+extern  bool_t xdr_rpc_loc_engine_state_e_type (XDR *, rpc_loc_engine_state_e_type*);
+extern  bool_t xdr_rpc_loc_fix_session_state_e_type (XDR *, rpc_loc_fix_session_state_e_type*);
+extern  bool_t xdr_rpc_loc_status_event_payload_u_type (XDR *, rpc_loc_status_event_payload_u_type*);
+extern  bool_t xdr_rpc_loc_status_event_s_type (XDR *, rpc_loc_status_event_s_type*);
+extern  bool_t xdr_rpc_loc_server_addr_e_type (XDR *, rpc_loc_server_addr_e_type*);
+extern  bool_t xdr_rpc_loc_server_addr_ipv4_type (XDR *, rpc_loc_server_addr_ipv4_type*);
+extern  bool_t xdr_rpc_loc_server_addr_url_type (XDR *, rpc_loc_server_addr_url_type*);
+extern  bool_t xdr_rpc_loc_server_addr_ipv6_type (XDR *, rpc_loc_server_addr_ipv6_type*);
+extern  bool_t xdr_rpc_loc_server_addr_u_type (XDR *, rpc_loc_server_addr_u_type*);
+extern  bool_t xdr_rpc_loc_server_info_s_type (XDR *, rpc_loc_server_info_s_type*);
+extern  bool_t xdr_rpc_loc_ni_notify_verify_e_type (XDR *, rpc_loc_ni_notify_verify_e_type*);
+extern  bool_t xdr_rpc_loc_ni_event_e_type (XDR *, rpc_loc_ni_event_e_type*);
+extern  bool_t xdr_rpc_loc_ni_datacoding_scheme_e_type (XDR *, rpc_loc_ni_datacoding_scheme_e_type*);
+extern  bool_t xdr_rpc_loc_ni_vx_requester_id_encoding_scheme_e_type (XDR *, rpc_loc_ni_vx_requester_id_encoding_scheme_e_type*);
+extern  bool_t xdr_rpc_loc_ni_vx_pos_mode_e_type (XDR *, rpc_loc_ni_vx_pos_mode_e_type*);
+extern  bool_t xdr_rpc_loc_ni_vx_requester_id_s_type (XDR *, rpc_loc_ni_vx_requester_id_s_type*);
+extern  bool_t xdr_rpc_loc_ni_vx_notify_verify_req_s_type (XDR *, rpc_loc_ni_vx_notify_verify_req_s_type*);
+extern  bool_t xdr_rpc_loc_ni_supl_pos_method_e_type (XDR *, rpc_loc_ni_supl_pos_method_e_type*);
+extern  bool_t xdr_rpc_loc_ni_supl_slp_session_id_s_type (XDR *, rpc_loc_ni_supl_slp_session_id_s_type*);
+extern  bool_t xdr_rpc_loc_ni_requestor_id_s_type (XDR *, rpc_loc_ni_requestor_id_s_type*);
+extern  bool_t xdr_rpc_loc_ni_supl_client_name_s_type (XDR *, rpc_loc_ni_supl_client_name_s_type*);
+extern  bool_t xdr_rpc_loc_ni_supl_qop_s_type (XDR *, rpc_loc_ni_supl_qop_s_type*);
+extern  bool_t xdr_rpc_loc_ni_supl_notify_verify_req_s_type (XDR *, rpc_loc_ni_supl_notify_verify_req_s_type*);
+extern  bool_t xdr_rpc_loc_ni_ext_client_address_s_type (XDR *, rpc_loc_ni_ext_client_address_s_type*);
+extern  bool_t xdr_rpc_loc_ni_location_type_e_type (XDR *, rpc_loc_ni_location_type_e_type*);
+extern  bool_t xdr_rpc_loc_ni_deferred_location_s_type (XDR *, rpc_loc_ni_deferred_location_s_type*);
+extern  bool_t xdr_rpc_loc_ni_codeword_string_s_type (XDR *, rpc_loc_ni_codeword_string_s_type*);
+extern  bool_t xdr_rpc_loc_ni_service_type_id_s_type (XDR *, rpc_loc_ni_service_type_id_s_type*);
+extern  bool_t xdr_rpc_loc_ni_umts_cp_notify_verify_req_s_type (XDR *, rpc_loc_ni_umts_cp_notify_verify_req_s_type*);
+extern  bool_t xdr_rpc_loc_ni_service_interaction_e_type (XDR *, rpc_loc_ni_service_interaction_e_type*);
+extern  bool_t xdr_rpc_loc_ni_vx_service_interaction_req_s_type (XDR *, rpc_loc_ni_vx_service_interaction_req_s_type*);
+extern  bool_t xdr_rpc_loc_ni_event_payload_u_type (XDR *, rpc_loc_ni_event_payload_u_type*);
+extern  bool_t xdr_rpc_loc_ni_event_s_type (XDR *, rpc_loc_ni_event_s_type*);
+extern  bool_t xdr_rpc_loc_assist_data_request_e_type (XDR *, rpc_loc_assist_data_request_e_type*);
+extern  bool_t xdr_rpc_struct_loc_time_download_source_s_type_servers_ptr (XDR *, rpc_struct_loc_time_download_source_s_type_servers_ptr*);
+extern  bool_t xdr_rpc_struct_loc_time_download_source_s_type_servers (XDR *, rpc_struct_loc_time_download_source_s_type_servers);
+extern  bool_t xdr_rpc_loc_time_download_source_s_type (XDR *, rpc_loc_time_download_source_s_type*);
+extern  bool_t xdr_rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr (XDR *, rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr*);
+extern  bool_t xdr_rpc_struct_loc_predicted_orbits_data_source_s_type_servers (XDR *, rpc_struct_loc_predicted_orbits_data_source_s_type_servers);
+extern  bool_t xdr_rpc_loc_predicted_orbits_data_source_s_type (XDR *, rpc_loc_predicted_orbits_data_source_s_type*);
+extern  bool_t xdr_rpc_loc_pos_inj_request_s_type (XDR *, rpc_loc_pos_inj_request_s_type*);
+extern  bool_t xdr_rpc_loc_assist_data_request_payload_u_type (XDR *, rpc_loc_assist_data_request_payload_u_type*);
+extern  bool_t xdr_rpc_loc_assist_data_request_s_type (XDR *, rpc_loc_assist_data_request_s_type*);
+extern  bool_t xdr_rpc_loc_server_connection_handle (XDR *, rpc_loc_server_connection_handle*);
+extern  bool_t xdr_rpc_loc_server_protocol_e_type (XDR *, rpc_loc_server_protocol_e_type*);
+extern  bool_t xdr_rpc_loc_server_connection_e_type (XDR *, rpc_loc_server_connection_e_type*);
+extern  bool_t xdr_rpc_loc_server_request_e_type (XDR *, rpc_loc_server_request_e_type*);
+extern  bool_t xdr_rpc_loc_server_open_req_s_type (XDR *, rpc_loc_server_open_req_s_type*);
+extern  bool_t xdr_rpc_loc_server_multi_open_req_s_type (XDR *, rpc_loc_server_multi_open_req_s_type*);
+extern  bool_t xdr_rpc_loc_server_close_req_s_type (XDR *, rpc_loc_server_close_req_s_type*);
+extern  bool_t xdr_rpc_loc_server_request_u_type (XDR *, rpc_loc_server_request_u_type*);
+extern  bool_t xdr_rpc_loc_server_request_s_type (XDR *, rpc_loc_server_request_s_type*);
+extern  bool_t xdr_rpc_loc_qwip_request_e_type (XDR *, rpc_loc_qwip_request_e_type*);
+extern  bool_t xdr_rpc_loc_qwip_request_s_type (XDR *, rpc_loc_qwip_request_s_type*);
+extern  bool_t xdr_rpc_loc_reserved_payload_s_type (XDR *, rpc_loc_reserved_payload_s_type*);
+extern  bool_t xdr_rpc_loc_ioctl_e_type (XDR *, rpc_loc_ioctl_e_type*);
+extern  bool_t xdr_rpc_loc_api_version_s_type (XDR *, rpc_loc_api_version_s_type*);
+extern  bool_t xdr_rpc_loc_fix_recurrence_e_type (XDR *, rpc_loc_fix_recurrence_e_type*);
+extern  bool_t xdr_rpc_loc_operation_mode_e_type (XDR *, rpc_loc_operation_mode_e_type*);
+extern  bool_t xdr_rpc_loc_notify_e_type (XDR *, rpc_loc_notify_e_type*);
+extern  bool_t xdr_rpc_loc_fix_criteria_s_type (XDR *, rpc_loc_fix_criteria_s_type*);
+extern  bool_t xdr_rpc_loc_ni_user_resp_e_type (XDR *, rpc_loc_ni_user_resp_e_type*);
+extern  bool_t xdr_rpc_loc_user_verify_s_type (XDR *, rpc_loc_user_verify_s_type*);
+extern  bool_t xdr_rpc_loc_predicted_orbits_data_format_e_type (XDR *, rpc_loc_predicted_orbits_data_format_e_type*);
+extern  bool_t xdr_rpc_loc_predicted_orbits_data_s_type (XDR *, rpc_loc_predicted_orbits_data_s_type*);
+extern  bool_t xdr_rpc_loc_predicted_orbits_data_validity_report_s_type (XDR *, rpc_loc_predicted_orbits_data_validity_report_s_type*);
+extern  bool_t xdr_rpc_loc_predicted_orbits_auto_download_config_s_type (XDR *, rpc_loc_predicted_orbits_auto_download_config_s_type*);
+extern  bool_t xdr_rpc_loc_assist_data_time_s_type (XDR *, rpc_loc_assist_data_time_s_type*);
+extern  bool_t xdr_rpc_loc_assist_pos_valid_mask_type (XDR *, rpc_loc_assist_pos_valid_mask_type*);
+extern  bool_t xdr_rpc_loc_assist_data_pos_s_type (XDR *, rpc_loc_assist_data_pos_s_type*);
+extern  bool_t xdr_rpc_loc_server_open_status_e_type (XDR *, rpc_loc_server_open_status_e_type*);
+extern  bool_t xdr_rpc_loc_server_pdp_type_e_type (XDR *, rpc_loc_server_pdp_type_e_type*);
+extern  bool_t xdr_rpc_loc_server_open_status_s_type (XDR *, rpc_loc_server_open_status_s_type*);
+extern  bool_t xdr_rpc_loc_server_multi_open_status_s_type (XDR *, rpc_loc_server_multi_open_status_s_type*);
+extern  bool_t xdr_rpc_loc_server_close_status_e_type (XDR *, rpc_loc_server_close_status_e_type*);
+extern  bool_t xdr_rpc_loc_server_close_status_s_type (XDR *, rpc_loc_server_close_status_s_type*);
+extern  bool_t xdr_rpc_loc_wiper_fix_time_s_type (XDR *, rpc_loc_wiper_fix_time_s_type*);
+extern  bool_t xdr_rpc_loc_wiper_fix_pos_s_type (XDR *, rpc_loc_wiper_fix_pos_s_type*);
+extern  bool_t xdr_rpc_loc_wiper_ap_info_s_type (XDR *, rpc_loc_wiper_ap_info_s_type*);
+extern  bool_t xdr_rpc_loc_wiper_ap_set_s_type (XDR *, rpc_loc_wiper_ap_set_s_type*);
+extern  bool_t xdr_rpc_loc_wiper_position_report_s_type (XDR *, rpc_loc_wiper_position_report_s_type*);
+extern  bool_t xdr_rpc_loc_wiper_status_e_type (XDR *, rpc_loc_wiper_status_e_type*);
+extern  bool_t xdr_rpc_loc_fs_operation_e_type (XDR *, rpc_loc_fs_operation_e_type*);
+extern  bool_t xdr_rpc_loc_efs_data_s_type (XDR *, rpc_loc_efs_data_s_type*);
+extern  bool_t xdr_rpc_loc_error_estimate_config_e_type (XDR *, rpc_loc_error_estimate_config_e_type*);
+extern  bool_t xdr_rpc_loc_apn_profiles_type (XDR *, rpc_loc_apn_profiles_type*);
+extern  bool_t xdr_rpc_loc_lock_e_type (XDR *, rpc_loc_lock_e_type*);
+extern  bool_t xdr_rpc_loc_nmea_sentence_type (XDR *, rpc_loc_nmea_sentence_type*);
+extern  bool_t xdr_rpc_loc_assist_data_type (XDR *, rpc_loc_assist_data_type*);
+extern  bool_t xdr_rpc_loc_assist_data_delete_s_type (XDR *, rpc_loc_assist_data_delete_s_type*);
+extern  bool_t xdr_rpc_loc_ioctl_data_u_type (XDR *, rpc_loc_ioctl_data_u_type*);
+extern  bool_t xdr_rpc_loc_ioctl_callback_data_u_type (XDR *, rpc_loc_ioctl_callback_data_u_type*);
+extern  bool_t xdr_rpc_loc_ioctl_callback_s_type (XDR *, rpc_loc_ioctl_callback_s_type*);
+extern  bool_t xdr_rpc_loc_event_payload_u_type (XDR *, rpc_loc_event_payload_u_type*);
+
+#else /* K&R C */
+extern bool_t xdr_rpc_loc_client_handle_type ();
+extern bool_t xdr_rpc_loc_event_mask_type ();
+extern bool_t xdr_rpc_loc_position_valid_mask_type ();
+extern bool_t xdr_rpc_loc_pos_technology_mask_type ();
+extern bool_t xdr_rpc_loc_session_status_e_type ();
+extern bool_t xdr_rpc_loc_calendar_time_s_type ();
+extern bool_t xdr_rpc_loc_parsed_position_s_type ();
+extern bool_t xdr_rpc_loc_sv_system_e_type ();
+extern bool_t xdr_rpc_loc_sv_status_e_type ();
+extern bool_t xdr_rpc_loc_sv_info_valid_mask_type ();
+extern bool_t xdr_rpc_loc_sv_info_s_type ();
+extern bool_t xdr_rpc_loc_gnss_info_valid_mask_type ();
+extern bool_t xdr_rpc_loc_gnss_info_s_type ();
+extern bool_t xdr_rpc_loc_nmea_report_s_type ();
+extern bool_t xdr_rpc_loc_status_event_e_type ();
+extern bool_t xdr_rpc_loc_engine_state_e_type ();
+extern bool_t xdr_rpc_loc_fix_session_state_e_type ();
+extern bool_t xdr_rpc_loc_status_event_payload_u_type ();
+extern bool_t xdr_rpc_loc_status_event_s_type ();
+extern bool_t xdr_rpc_loc_server_addr_e_type ();
+extern bool_t xdr_rpc_loc_server_addr_ipv4_type ();
+extern bool_t xdr_rpc_loc_server_addr_url_type ();
+extern bool_t xdr_rpc_loc_server_addr_ipv6_type ();
+extern bool_t xdr_rpc_loc_server_addr_u_type ();
+extern bool_t xdr_rpc_loc_server_info_s_type ();
+extern bool_t xdr_rpc_loc_ni_notify_verify_e_type ();
+extern bool_t xdr_rpc_loc_ni_event_e_type ();
+extern bool_t xdr_rpc_loc_ni_datacoding_scheme_e_type ();
+extern bool_t xdr_rpc_loc_ni_vx_requester_id_encoding_scheme_e_type ();
+extern bool_t xdr_rpc_loc_ni_vx_pos_mode_e_type ();
+extern bool_t xdr_rpc_loc_ni_vx_requester_id_s_type ();
+extern bool_t xdr_rpc_loc_ni_vx_notify_verify_req_s_type ();
+extern bool_t xdr_rpc_loc_ni_supl_pos_method_e_type ();
+extern bool_t xdr_rpc_loc_ni_supl_slp_session_id_s_type ();
+extern bool_t xdr_rpc_loc_ni_requestor_id_s_type ();
+extern bool_t xdr_rpc_loc_ni_supl_client_name_s_type ();
+extern bool_t xdr_rpc_loc_ni_supl_qop_s_type ();
+extern bool_t xdr_rpc_loc_ni_supl_notify_verify_req_s_type ();
+extern bool_t xdr_rpc_loc_ni_ext_client_address_s_type ();
+extern bool_t xdr_rpc_loc_ni_location_type_e_type ();
+extern bool_t xdr_rpc_loc_ni_deferred_location_s_type ();
+extern bool_t xdr_rpc_loc_ni_codeword_string_s_type ();
+extern bool_t xdr_rpc_loc_ni_service_type_id_s_type ();
+extern bool_t xdr_rpc_loc_ni_umts_cp_notify_verify_req_s_type ();
+extern bool_t xdr_rpc_loc_ni_service_interaction_e_type ();
+extern bool_t xdr_rpc_loc_ni_vx_service_interaction_req_s_type ();
+extern bool_t xdr_rpc_loc_ni_event_payload_u_type ();
+extern bool_t xdr_rpc_loc_ni_event_s_type ();
+extern bool_t xdr_rpc_loc_assist_data_request_e_type ();
+extern bool_t xdr_rpc_struct_loc_time_download_source_s_type_servers_ptr ();
+extern bool_t xdr_rpc_struct_loc_time_download_source_s_type_servers ();
+extern bool_t xdr_rpc_loc_time_download_source_s_type ();
+extern bool_t xdr_rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr ();
+extern bool_t xdr_rpc_struct_loc_predicted_orbits_data_source_s_type_servers ();
+extern bool_t xdr_rpc_loc_predicted_orbits_data_source_s_type ();
+extern bool_t xdr_rpc_loc_pos_inj_request_s_type ();
+extern bool_t xdr_rpc_loc_assist_data_request_payload_u_type ();
+extern bool_t xdr_rpc_loc_assist_data_request_s_type ();
+extern bool_t xdr_rpc_loc_server_connection_handle ();
+extern bool_t xdr_rpc_loc_server_protocol_e_type ();
+extern bool_t xdr_rpc_loc_server_connection_e_type ();
+extern bool_t xdr_rpc_loc_server_request_e_type ();
+extern bool_t xdr_rpc_loc_server_open_req_s_type ();
+extern bool_t xdr_rpc_loc_server_multi_open_req_s_type ();
+extern bool_t xdr_rpc_loc_server_close_req_s_type ();
+extern bool_t xdr_rpc_loc_server_request_u_type ();
+extern bool_t xdr_rpc_loc_server_request_s_type ();
+extern bool_t xdr_rpc_loc_qwip_request_e_type ();
+extern bool_t xdr_rpc_loc_qwip_request_s_type ();
+extern bool_t xdr_rpc_loc_reserved_payload_s_type ();
+extern bool_t xdr_rpc_loc_ioctl_e_type ();
+extern bool_t xdr_rpc_loc_api_version_s_type ();
+extern bool_t xdr_rpc_loc_fix_recurrence_e_type ();
+extern bool_t xdr_rpc_loc_operation_mode_e_type ();
+extern bool_t xdr_rpc_loc_notify_e_type ();
+extern bool_t xdr_rpc_loc_fix_criteria_s_type ();
+extern bool_t xdr_rpc_loc_ni_user_resp_e_type ();
+extern bool_t xdr_rpc_loc_user_verify_s_type ();
+extern bool_t xdr_rpc_loc_predicted_orbits_data_format_e_type ();
+extern bool_t xdr_rpc_loc_predicted_orbits_data_s_type ();
+extern bool_t xdr_rpc_loc_predicted_orbits_data_validity_report_s_type ();
+extern bool_t xdr_rpc_loc_predicted_orbits_auto_download_config_s_type ();
+extern bool_t xdr_rpc_loc_assist_data_time_s_type ();
+extern bool_t xdr_rpc_loc_assist_pos_valid_mask_type ();
+extern bool_t xdr_rpc_loc_assist_data_pos_s_type ();
+extern bool_t xdr_rpc_loc_server_open_status_e_type ();
+extern bool_t xdr_rpc_loc_server_pdp_type_e_type ();
+extern bool_t xdr_rpc_loc_server_open_status_s_type ();
+extern bool_t xdr_rpc_loc_server_multi_open_status_s_type ();
+extern bool_t xdr_rpc_loc_server_close_status_e_type ();
+extern bool_t xdr_rpc_loc_server_close_status_s_type ();
+extern bool_t xdr_rpc_loc_wiper_fix_time_s_type ();
+extern bool_t xdr_rpc_loc_wiper_fix_pos_s_type ();
+extern bool_t xdr_rpc_loc_wiper_ap_info_s_type ();
+extern bool_t xdr_rpc_loc_wiper_ap_set_s_type ();
+extern bool_t xdr_rpc_loc_wiper_position_report_s_type ();
+extern bool_t xdr_rpc_loc_wiper_status_e_type ();
+extern bool_t xdr_rpc_loc_fs_operation_e_type ();
+extern bool_t xdr_rpc_loc_efs_data_s_type ();
+extern bool_t xdr_rpc_loc_error_estimate_config_e_type ();
+extern bool_t xdr_rpc_loc_apn_profiles_type ();
+extern bool_t xdr_rpc_loc_lock_e_type ();
+extern bool_t xdr_rpc_loc_nmea_sentence_type ();
+extern bool_t xdr_rpc_loc_assist_data_type ();
+extern bool_t xdr_rpc_loc_assist_data_delete_s_type ();
+extern bool_t xdr_rpc_loc_ioctl_data_u_type ();
+extern bool_t xdr_rpc_loc_ioctl_callback_data_u_type ();
+extern bool_t xdr_rpc_loc_ioctl_callback_s_type ();
+extern bool_t xdr_rpc_loc_event_payload_u_type ();
+
+#endif /* K&R C */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_LOC_API_COMMON_RPC_H_RPCGEN */
diff --git a/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/inc/loc_api_rpcgen_rpc.h b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/inc/loc_api_rpcgen_rpc.h
new file mode 100644
index 0000000..6138432
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/inc/loc_api_rpcgen_rpc.h
@@ -0,0 +1,288 @@
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#ifndef _LOC_API_RPC_H_RPCGEN
+#define _LOC_API_RPC_H_RPCGEN
+
+#include "librpc.h"
+#include "commondefs_rpcgen_rpc.h"
+#include "loc_api_rpcgen_common_rpc.h"
+
+#include <pthread.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+typedef struct {
+    u_int rpc_loc_api_api_versions_return_type_len;
+    rpc_uint32 *rpc_loc_api_api_versions_return_type_val;
+} rpc_loc_api_api_versions_return_type;
+
+typedef rpc_uint32 rpc_loc_event_cb_f_type;
+
+struct rpc_loc_open_args {
+    rpc_loc_event_mask_type event_reg_mask;
+    rpc_loc_event_cb_f_type event_callback;
+};
+typedef struct rpc_loc_open_args rpc_loc_open_args;
+
+struct rpc_loc_close_args {
+    rpc_loc_client_handle_type handle;
+};
+typedef struct rpc_loc_close_args rpc_loc_close_args;
+
+struct rpc_loc_start_fix_args {
+    rpc_loc_client_handle_type handle;
+};
+typedef struct rpc_loc_start_fix_args rpc_loc_start_fix_args;
+
+struct rpc_loc_stop_fix_args {
+    rpc_loc_client_handle_type handle;
+};
+typedef struct rpc_loc_stop_fix_args rpc_loc_stop_fix_args;
+
+struct rpc_loc_ioctl_args {
+    rpc_loc_client_handle_type handle;
+    rpc_loc_ioctl_e_type ioctl_type;
+    rpc_loc_ioctl_data_u_type *ioctl_data;
+};
+typedef struct rpc_loc_ioctl_args rpc_loc_ioctl_args;
+
+struct rpc_loc_api_api_version_s_args {
+    rpc_boolean len_not_null;
+};
+typedef struct rpc_loc_api_api_version_s_args rpc_loc_api_api_version_s_args;
+
+struct rpc_loc_api_rpc_glue_code_info_remote_rets {
+    rpc_uint32 toolvers;
+    rpc_uint32 features;
+    rpc_uint32 proghash;
+    rpc_uint32 cbproghash;
+};
+typedef struct rpc_loc_api_rpc_glue_code_info_remote_rets rpc_loc_api_rpc_glue_code_info_remote_rets;
+
+struct rpc_loc_open_rets {
+    rpc_loc_client_handle_type loc_open_result;
+};
+typedef struct rpc_loc_open_rets rpc_loc_open_rets;
+
+struct rpc_loc_close_rets {
+    rpc_int32 loc_close_result;
+};
+typedef struct rpc_loc_close_rets rpc_loc_close_rets;
+
+struct rpc_loc_start_fix_rets {
+    rpc_int32 loc_start_fix_result;
+};
+typedef struct rpc_loc_start_fix_rets rpc_loc_start_fix_rets;
+
+struct rpc_loc_stop_fix_rets {
+    rpc_int32 loc_stop_fix_result;
+};
+typedef struct rpc_loc_stop_fix_rets rpc_loc_stop_fix_rets;
+
+struct rpc_loc_ioctl_rets {
+    rpc_int32 loc_ioctl_result;
+};
+typedef struct rpc_loc_ioctl_rets rpc_loc_ioctl_rets;
+
+struct rpc_loc_api_api_versions_rets {
+    rpc_loc_api_api_versions_return_type loc_api_api_versions_result;
+    rpc_uint32 *len;
+};
+typedef struct rpc_loc_api_api_versions_rets rpc_loc_api_api_versions_rets;
+#define LOC_APIVERS 0x00050006
+
+#define LOC_APIPROG 0x3000008C
+#define LOC_APIVERS_0001 0x00050001
+
+#if defined(__STDC__) || defined(__cplusplus)
+#define rpc_loc_api_null 0
+extern  enum clnt_stat rpc_loc_api_null_0x00050001(void *, void *, CLIENT *);
+extern  bool_t rpc_loc_api_null_0x00050001_svc(void *, void *, struct svc_req *);
+#define rpc_loc_api_rpc_glue_code_info_remote 1
+extern  enum clnt_stat rpc_loc_api_rpc_glue_code_info_remote_0x00050001(void *, rpc_loc_api_rpc_glue_code_info_remote_rets *, CLIENT *);
+extern  bool_t rpc_loc_api_rpc_glue_code_info_remote_0x00050001_svc(void *, rpc_loc_api_rpc_glue_code_info_remote_rets *, struct svc_req *);
+#define rpc_loc_open 2
+extern  enum clnt_stat rpc_loc_open_0x00050001(rpc_loc_open_args *, rpc_loc_open_rets *, CLIENT *);
+extern  bool_t rpc_loc_open_0x00050001_svc(rpc_loc_open_args *, rpc_loc_open_rets *, struct svc_req *);
+#define rpc_loc_close 3
+extern  enum clnt_stat rpc_loc_close_0x00050001(rpc_loc_close_args *, rpc_loc_close_rets *, CLIENT *);
+extern  bool_t rpc_loc_close_0x00050001_svc(rpc_loc_close_args *, rpc_loc_close_rets *, struct svc_req *);
+#define rpc_loc_start_fix 4
+extern  enum clnt_stat rpc_loc_start_fix_0x00050001(rpc_loc_start_fix_args *, rpc_loc_start_fix_rets *, CLIENT *);
+extern  bool_t rpc_loc_start_fix_0x00050001_svc(rpc_loc_start_fix_args *, rpc_loc_start_fix_rets *, struct svc_req *);
+#define rpc_loc_stop_fix 5
+extern  enum clnt_stat rpc_loc_stop_fix_0x00050001(rpc_loc_stop_fix_args *, rpc_loc_stop_fix_rets *, CLIENT *);
+extern  bool_t rpc_loc_stop_fix_0x00050001_svc(rpc_loc_stop_fix_args *, rpc_loc_stop_fix_rets *, struct svc_req *);
+#define rpc_loc_ioctl 6
+extern  enum clnt_stat rpc_loc_ioctl_0x00050001(rpc_loc_ioctl_args *, rpc_loc_ioctl_rets *, CLIENT *);
+extern  bool_t rpc_loc_ioctl_0x00050001_svc(rpc_loc_ioctl_args *, rpc_loc_ioctl_rets *, struct svc_req *);
+#define rpc_loc_api_api_versions 0xFFFFFFFF
+extern  enum clnt_stat rpc_loc_api_api_versions_0x00050001(void *, rpc_loc_api_api_versions_rets *, CLIENT *);
+extern  bool_t rpc_loc_api_api_versions_0x00050001_svc(void *, rpc_loc_api_api_versions_rets *, struct svc_req *);
+extern int loc_apiprog_0x00050001_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+#define rpc_loc_api_null 0
+extern  enum clnt_stat rpc_loc_api_null_0x00050001();
+extern  bool_t rpc_loc_api_null_0x00050001_svc();
+#define rpc_loc_api_rpc_glue_code_info_remote 1
+extern  enum clnt_stat rpc_loc_api_rpc_glue_code_info_remote_0x00050001();
+extern  bool_t rpc_loc_api_rpc_glue_code_info_remote_0x00050001_svc();
+#define rpc_loc_open 2
+extern  enum clnt_stat rpc_loc_open_0x00050001();
+extern  bool_t rpc_loc_open_0x00050001_svc();
+#define rpc_loc_close 3
+extern  enum clnt_stat rpc_loc_close_0x00050001();
+extern  bool_t rpc_loc_close_0x00050001_svc();
+#define rpc_loc_start_fix 4
+extern  enum clnt_stat rpc_loc_start_fix_0x00050001();
+extern  bool_t rpc_loc_start_fix_0x00050001_svc();
+#define rpc_loc_stop_fix 5
+extern  enum clnt_stat rpc_loc_stop_fix_0x00050001();
+extern  bool_t rpc_loc_stop_fix_0x00050001_svc();
+#define rpc_loc_ioctl 6
+extern  enum clnt_stat rpc_loc_ioctl_0x00050001();
+extern  bool_t rpc_loc_ioctl_0x00050001_svc();
+#define rpc_loc_api_api_versions 0xFFFFFFFF
+extern  enum clnt_stat rpc_loc_api_api_versions_0x00050001();
+extern  bool_t rpc_loc_api_api_versions_0x00050001_svc();
+extern int loc_apiprog_0x00050001_freeresult ();
+#endif /* K&R C */
+#define LOC_APIVERS_0002 0x00050002
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  enum clnt_stat rpc_loc_api_null_0x00050002(void *, void *, CLIENT *);
+extern  bool_t rpc_loc_api_null_0x00050002_svc(void *, void *, struct svc_req *);
+extern int loc_apiprog_0x00050002_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+extern  enum clnt_stat rpc_loc_api_null_0x00050002();
+extern  bool_t rpc_loc_api_null_0x00050002_svc();
+extern int loc_apiprog_0x00050002_freeresult ();
+#endif /* K&R C */
+#define LOC_APIVERS_0003 0x00050003
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  enum clnt_stat rpc_loc_api_null_0x00050003(void *, void *, CLIENT *);
+extern  bool_t rpc_loc_api_null_0x00050003_svc(void *, void *, struct svc_req *);
+extern int loc_apiprog_0x00050003_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+extern  enum clnt_stat rpc_loc_api_null_0x00050003();
+extern  bool_t rpc_loc_api_null_0x00050003_svc();
+extern int loc_apiprog_0x00050003_freeresult ();
+#endif /* K&R C */
+#define LOC_APIVERS_0004 0x00050004
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  enum clnt_stat rpc_loc_api_null_0x00050004(void *, void *, CLIENT *);
+extern  bool_t rpc_loc_api_null_0x00050004_svc(void *, void *, struct svc_req *);
+extern int loc_apiprog_0x00050004_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+extern  enum clnt_stat rpc_loc_api_null_0x00050004();
+extern  bool_t rpc_loc_api_null_0x00050004_svc();
+extern int loc_apiprog_0x00050004_freeresult ();
+#endif /* K&R C */
+#define LOC_APIVERS_0005 0x00050005
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  enum clnt_stat rpc_loc_api_null_0x00050005(void *, void *, CLIENT *);
+extern  bool_t rpc_loc_api_null_0x00050005_svc(void *, void *, struct svc_req *);
+extern int loc_apiprog_0x00050005_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+extern  enum clnt_stat rpc_loc_api_null_0x00050005();
+extern  bool_t rpc_loc_api_null_0x00050005_svc();
+extern int loc_apiprog_0x00050005_freeresult ();
+#endif /* K&R C */
+#define LOC_APIVERS_0006 0x00050006
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  enum clnt_stat rpc_loc_api_null_0x00050006(void *, void *, CLIENT *);
+extern  bool_t rpc_loc_api_null_0x00050006_svc(void *, void *, struct svc_req *);
+extern int loc_apiprog_0x00050006_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+extern  enum clnt_stat rpc_loc_api_null_0x00050006();
+extern  bool_t rpc_loc_api_null_0x00050006_svc();
+extern int loc_apiprog_0x00050006_freeresult ();
+#endif /* K&R C */
+
+/* the xdr functions */
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  bool_t xdr_rpc_loc_api_api_versions_return_type (XDR *, rpc_loc_api_api_versions_return_type*);
+extern  bool_t xdr_rpc_loc_event_cb_f_type (XDR *, rpc_loc_event_cb_f_type*);
+extern  bool_t xdr_rpc_loc_open_args (XDR *, rpc_loc_open_args*);
+extern  bool_t xdr_rpc_loc_close_args (XDR *, rpc_loc_close_args*);
+extern  bool_t xdr_rpc_loc_start_fix_args (XDR *, rpc_loc_start_fix_args*);
+extern  bool_t xdr_rpc_loc_stop_fix_args (XDR *, rpc_loc_stop_fix_args*);
+extern  bool_t xdr_rpc_loc_ioctl_args (XDR *, rpc_loc_ioctl_args*);
+extern  bool_t xdr_rpc_loc_api_api_version_s_args (XDR *, rpc_loc_api_api_version_s_args*);
+extern  bool_t xdr_rpc_loc_api_rpc_glue_code_info_remote_rets (XDR *, rpc_loc_api_rpc_glue_code_info_remote_rets*);
+extern  bool_t xdr_rpc_loc_open_rets (XDR *, rpc_loc_open_rets*);
+extern  bool_t xdr_rpc_loc_close_rets (XDR *, rpc_loc_close_rets*);
+extern  bool_t xdr_rpc_loc_start_fix_rets (XDR *, rpc_loc_start_fix_rets*);
+extern  bool_t xdr_rpc_loc_stop_fix_rets (XDR *, rpc_loc_stop_fix_rets*);
+extern  bool_t xdr_rpc_loc_ioctl_rets (XDR *, rpc_loc_ioctl_rets*);
+extern  bool_t xdr_rpc_loc_api_api_versions_rets (XDR *, rpc_loc_api_api_versions_rets*);
+
+#else /* K&R C */
+extern bool_t xdr_rpc_loc_api_api_versions_return_type ();
+extern bool_t xdr_rpc_loc_event_cb_f_type ();
+extern bool_t xdr_rpc_loc_open_args ();
+extern bool_t xdr_rpc_loc_close_args ();
+extern bool_t xdr_rpc_loc_start_fix_args ();
+extern bool_t xdr_rpc_loc_stop_fix_args ();
+extern bool_t xdr_rpc_loc_ioctl_args ();
+extern bool_t xdr_rpc_loc_api_api_version_s_args ();
+extern bool_t xdr_rpc_loc_api_rpc_glue_code_info_remote_rets ();
+extern bool_t xdr_rpc_loc_open_rets ();
+extern bool_t xdr_rpc_loc_close_rets ();
+extern bool_t xdr_rpc_loc_start_fix_rets ();
+extern bool_t xdr_rpc_loc_stop_fix_rets ();
+extern bool_t xdr_rpc_loc_ioctl_rets ();
+extern bool_t xdr_rpc_loc_api_api_versions_rets ();
+
+#endif /* K&R C */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_LOC_API_RPC_H_RPCGEN */
diff --git a/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/inc/loc_apicb_appinit.h b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/inc/loc_apicb_appinit.h
new file mode 100644
index 0000000..875c4f0
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/inc/loc_apicb_appinit.h
@@ -0,0 +1,34 @@
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* Initialization function for callbacks */
+int loc_apicb_app_init();
+
+void loc_apicb_app_deinit();
+
diff --git a/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/src/loc_api_rpcgen_cb_svc.c b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/src/loc_api_rpcgen_cb_svc.c
new file mode 100644
index 0000000..2ef5852
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/src/loc_api_rpcgen_cb_svc.c
@@ -0,0 +1,327 @@
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#include "loc_api_rpcgen_cb_rpc.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <rpc/pmap_clnt.h>
+#include <string.h>
+#include <memory.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+
+#ifndef SIG_PF
+#define SIG_PF void(*)(int)
+#endif
+
+void
+loc_apicbprog_0x00050001(struct svc_req *rqstp, register SVCXPRT *transp)
+{
+    union {
+        rpc_loc_event_cb_f_type_args rpc_loc_event_cb_f_type_0x00050001_arg;
+    } argument;
+    union {
+        rpc_loc_event_cb_f_type_rets rpc_loc_event_cb_f_type_0x00050001_res;
+    } result;
+    bool_t retval;
+    xdrproc_t _xdr_argument, _xdr_result;
+    bool_t (*local)(char *, void *, struct svc_req *);
+
+    switch (rqstp->rq_proc) {
+    case NULLPROC:
+        (void) svc_sendreply (transp, (xdrproc_t) xdr_void, (char *)NULL);
+        return;
+
+    case rpc_loc_event_cb_f_type:
+        _xdr_argument = (xdrproc_t) xdr_rpc_loc_event_cb_f_type_args;
+        _xdr_result = (xdrproc_t) xdr_rpc_loc_event_cb_f_type_rets;
+        local = (bool_t (*) (char *, void *,  struct svc_req *))rpc_loc_event_cb_f_type_0x00050001_svc;
+        break;
+
+    default:
+        svcerr_noproc (transp);
+        return;
+    }
+    memset ((char *)&argument, 0, sizeof (argument));
+    if (!svc_getargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
+        svcerr_decode (transp);
+        return;
+    }
+    retval = (bool_t) (*local)((char *)&argument, (void *)&result, rqstp);
+    if (retval > 0 && !svc_sendreply(transp, (xdrproc_t) _xdr_result, (char *)&result)) {
+        svcerr_systemerr (transp);
+    }
+    if (!svc_freeargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
+        fprintf (stderr, "%s", "unable to free arguments");
+        exit (1);
+    }
+    if (!loc_apicbprog_0x00050001_freeresult (transp, _xdr_result, (caddr_t) &result))
+        fprintf (stderr, "%s", "unable to free results");
+
+    return;
+}
+
+void
+loc_apicbprog_0x00050002(struct svc_req *rqstp, register SVCXPRT *transp)
+{
+    union {
+        int fill;
+    } argument;
+    union {
+        int rpc_loc_api_cb_null_0x00050002_res;
+    } result;
+    bool_t retval;
+    xdrproc_t _xdr_argument, _xdr_result;
+    bool_t (*local)(char *, void *, struct svc_req *);
+
+    switch (rqstp->rq_proc) {
+    case NULLPROC:
+        (void) svc_sendreply (transp, (xdrproc_t) xdr_void, (char *)NULL);
+        return;
+
+    case rpc_loc_api_cb_null:
+        _xdr_argument = (xdrproc_t) xdr_void;
+        _xdr_result = (xdrproc_t) xdr_int;
+        local = (bool_t (*) (char *, void *,  struct svc_req *))rpc_loc_api_cb_null_0x00050002_svc;
+        break;
+
+    default:
+        svcerr_noproc (transp);
+        return;
+    }
+    memset ((char *)&argument, 0, sizeof (argument));
+    if (!svc_getargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
+        svcerr_decode (transp);
+        return;
+    }
+    retval = (bool_t) (*local)((char *)&argument, (void *)&result, rqstp);
+    if (retval > 0 && !svc_sendreply(transp, (xdrproc_t) _xdr_result, (char *)&result)) {
+        svcerr_systemerr (transp);
+    }
+    if (!svc_freeargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
+        fprintf (stderr, "%s", "unable to free arguments");
+        exit (1);
+    }
+    if (!loc_apicbprog_0x00050002_freeresult (transp, _xdr_result, (caddr_t) &result))
+        fprintf (stderr, "%s", "unable to free results");
+
+    return;
+}
+
+void
+loc_apicbprog_0x00050003(struct svc_req *rqstp, register SVCXPRT *transp)
+{
+    union {
+        int fill;
+    } argument;
+    union {
+        int rpc_loc_api_cb_null_0x00050003_res;
+    } result;
+    bool_t retval;
+    xdrproc_t _xdr_argument, _xdr_result;
+    bool_t (*local)(char *, void *, struct svc_req *);
+
+    switch (rqstp->rq_proc) {
+    case NULLPROC:
+        (void) svc_sendreply (transp, (xdrproc_t) xdr_void, (char *)NULL);
+        return;
+
+    case rpc_loc_api_cb_null:
+        _xdr_argument = (xdrproc_t) xdr_void;
+        _xdr_result = (xdrproc_t) xdr_int;
+        local = (bool_t (*) (char *, void *,  struct svc_req *))rpc_loc_api_cb_null_0x00050003_svc;
+        break;
+
+    default:
+        svcerr_noproc (transp);
+        return;
+    }
+    memset ((char *)&argument, 0, sizeof (argument));
+    if (!svc_getargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
+        svcerr_decode (transp);
+        return;
+    }
+    retval = (bool_t) (*local)((char *)&argument, (void *)&result, rqstp);
+    if (retval > 0 && !svc_sendreply(transp, (xdrproc_t) _xdr_result, (char *)&result)) {
+        svcerr_systemerr (transp);
+    }
+    if (!svc_freeargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
+        fprintf (stderr, "%s", "unable to free arguments");
+        exit (1);
+    }
+    if (!loc_apicbprog_0x00050003_freeresult (transp, _xdr_result, (caddr_t) &result))
+        fprintf (stderr, "%s", "unable to free results");
+
+    return;
+}
+
+void
+loc_apicbprog_0x00050004(struct svc_req *rqstp, register SVCXPRT *transp)
+{
+    union {
+        int fill;
+    } argument;
+    union {
+        int rpc_loc_api_cb_null_0x00050004_res;
+    } result;
+    bool_t retval;
+    xdrproc_t _xdr_argument, _xdr_result;
+    bool_t (*local)(char *, void *, struct svc_req *);
+
+    switch (rqstp->rq_proc) {
+    case NULLPROC:
+        (void) svc_sendreply (transp, (xdrproc_t) xdr_void, (char *)NULL);
+        return;
+
+    case rpc_loc_api_cb_null:
+        _xdr_argument = (xdrproc_t) xdr_void;
+        _xdr_result = (xdrproc_t) xdr_int;
+        local = (bool_t (*) (char *, void *,  struct svc_req *))rpc_loc_api_cb_null_0x00050004_svc;
+        break;
+
+    default:
+        svcerr_noproc (transp);
+        return;
+    }
+    memset ((char *)&argument, 0, sizeof (argument));
+    if (!svc_getargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
+        svcerr_decode (transp);
+        return;
+    }
+    retval = (bool_t) (*local)((char *)&argument, (void *)&result, rqstp);
+    if (retval > 0 && !svc_sendreply(transp, (xdrproc_t) _xdr_result, (char *)&result)) {
+        svcerr_systemerr (transp);
+    }
+    if (!svc_freeargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
+        fprintf (stderr, "%s", "unable to free arguments");
+        exit (1);
+    }
+    if (!loc_apicbprog_0x00050004_freeresult (transp, _xdr_result, (caddr_t) &result))
+        fprintf (stderr, "%s", "unable to free results");
+
+    return;
+}
+
+void
+loc_apicbprog_0x00050005(struct svc_req *rqstp, register SVCXPRT *transp)
+{
+    union {
+        int fill;
+    } argument;
+    union {
+        int rpc_loc_api_cb_null_0x00050005_res;
+    } result;
+    bool_t retval;
+    xdrproc_t _xdr_argument, _xdr_result;
+    bool_t (*local)(char *, void *, struct svc_req *);
+
+    switch (rqstp->rq_proc) {
+    case NULLPROC:
+        (void) svc_sendreply (transp, (xdrproc_t) xdr_void, (char *)NULL);
+        return;
+
+    case rpc_loc_api_cb_null:
+        _xdr_argument = (xdrproc_t) xdr_void;
+        _xdr_result = (xdrproc_t) xdr_int;
+        local = (bool_t (*) (char *, void *,  struct svc_req *))rpc_loc_api_cb_null_0x00050005_svc;
+        break;
+
+    default:
+        svcerr_noproc (transp);
+        return;
+    }
+    memset ((char *)&argument, 0, sizeof (argument));
+    if (!svc_getargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
+        svcerr_decode (transp);
+        return;
+    }
+    retval = (bool_t) (*local)((char *)&argument, (void *)&result, rqstp);
+    if (retval > 0 && !svc_sendreply(transp, (xdrproc_t) _xdr_result, (char *)&result)) {
+        svcerr_systemerr (transp);
+    }
+    if (!svc_freeargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
+        fprintf (stderr, "%s", "unable to free arguments");
+        exit (1);
+    }
+    if (!loc_apicbprog_0x00050005_freeresult (transp, _xdr_result, (caddr_t) &result))
+        fprintf (stderr, "%s", "unable to free results");
+
+    return;
+}
+
+void
+loc_apicbprog_0x00050006(struct svc_req *rqstp, register SVCXPRT *transp)
+{
+    union {
+        int fill;
+    } argument;
+    union {
+        int rpc_loc_api_cb_null_0x00050006_res;
+    } result;
+    bool_t retval;
+    xdrproc_t _xdr_argument, _xdr_result;
+    bool_t (*local)(char *, void *, struct svc_req *);
+
+    switch (rqstp->rq_proc) {
+    case NULLPROC:
+        (void) svc_sendreply (transp, (xdrproc_t) xdr_void, (char *)NULL);
+        return;
+
+    case rpc_loc_api_cb_null:
+        _xdr_argument = (xdrproc_t) xdr_void;
+        _xdr_result = (xdrproc_t) xdr_int;
+        local = (bool_t (*) (char *, void *,  struct svc_req *))rpc_loc_api_cb_null_0x00050006_svc;
+        break;
+
+    default:
+        svcerr_noproc (transp);
+        return;
+    }
+    memset ((char *)&argument, 0, sizeof (argument));
+    if (!svc_getargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
+        svcerr_decode (transp);
+        return;
+    }
+    retval = (bool_t) (*local)((char *)&argument, (void *)&result, rqstp);
+    if (retval > 0 && !svc_sendreply(transp, (xdrproc_t) _xdr_result, (char *)&result)) {
+        svcerr_systemerr (transp);
+    }
+    if (!svc_freeargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
+        fprintf (stderr, "%s", "unable to free arguments");
+        exit (1);
+    }
+    if (!loc_apicbprog_0x00050006_freeresult (transp, _xdr_result, (caddr_t) &result))
+        fprintf (stderr, "%s", "unable to free results");
+
+    return;
+}
diff --git a/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/src/loc_api_rpcgen_cb_xdr.c b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/src/loc_api_rpcgen_cb_xdr.c
new file mode 100644
index 0000000..ad171dc
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/src/loc_api_rpcgen_cb_xdr.c
@@ -0,0 +1,60 @@
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#include "loc_api_rpcgen_cb_rpc.h"
+
+bool_t
+xdr_rpc_loc_event_cb_f_type_args (XDR *xdrs, rpc_loc_event_cb_f_type_args *objp)
+{
+;
+
+     if (!xdr_rpc_uint32 (xdrs, &objp->cb_id))
+         return FALSE;
+     if (!xdr_rpc_loc_client_handle_type (xdrs, &objp->loc_handle))
+         return FALSE;
+     if (!xdr_rpc_loc_event_mask_type (xdrs, &objp->loc_event))
+         return FALSE;
+     if (!xdr_pointer (xdrs, (char **)&objp->loc_event_payload, sizeof (rpc_loc_event_payload_u_type), (xdrproc_t) xdr_rpc_loc_event_payload_u_type))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_event_cb_f_type_rets (XDR *xdrs, rpc_loc_event_cb_f_type_rets *objp)
+{
+;
+
+     if (!xdr_rpc_int32 (xdrs, &objp->loc_event_cb_f_type_result))
+         return FALSE;
+    return TRUE;
+}
diff --git a/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/src/loc_api_rpcgen_clnt.c b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/src/loc_api_rpcgen_clnt.c
new file mode 100644
index 0000000..3e39576
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/src/loc_api_rpcgen_clnt.c
@@ -0,0 +1,155 @@
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#include <memory.h> /* for memset */
+#include "loc_api_rpcgen_rpc.h"
+
+/* Default timeout can be changed using clnt_control() */
+static struct timeval TIMEOUT = { 25, 0 };
+
+enum clnt_stat
+rpc_loc_api_null_0x00050001(void *argp, void *clnt_res, CLIENT *clnt)
+{
+    return (clnt_call(clnt, rpc_loc_api_null,
+        (xdrproc_t) xdr_void, (caddr_t) argp,
+        (xdrproc_t) xdr_void, (caddr_t) clnt_res,
+        TIMEOUT));
+}
+
+enum clnt_stat
+rpc_loc_api_rpc_glue_code_info_remote_0x00050001(void *argp, rpc_loc_api_rpc_glue_code_info_remote_rets *clnt_res, CLIENT *clnt)
+{
+    return (clnt_call(clnt, rpc_loc_api_rpc_glue_code_info_remote,
+        (xdrproc_t) xdr_void, (caddr_t) argp,
+        (xdrproc_t) xdr_rpc_loc_api_rpc_glue_code_info_remote_rets, (caddr_t) clnt_res,
+        TIMEOUT));
+}
+
+enum clnt_stat
+rpc_loc_open_0x00050001(rpc_loc_open_args *argp, rpc_loc_open_rets *clnt_res, CLIENT *clnt)
+{
+    return (clnt_call(clnt, rpc_loc_open,
+        (xdrproc_t) xdr_rpc_loc_open_args, (caddr_t) argp,
+        (xdrproc_t) xdr_rpc_loc_open_rets, (caddr_t) clnt_res,
+        TIMEOUT));
+}
+
+enum clnt_stat
+rpc_loc_close_0x00050001(rpc_loc_close_args *argp, rpc_loc_close_rets *clnt_res, CLIENT *clnt)
+{
+    return (clnt_call(clnt, rpc_loc_close,
+        (xdrproc_t) xdr_rpc_loc_close_args, (caddr_t) argp,
+        (xdrproc_t) xdr_rpc_loc_close_rets, (caddr_t) clnt_res,
+        TIMEOUT));
+}
+
+enum clnt_stat
+rpc_loc_start_fix_0x00050001(rpc_loc_start_fix_args *argp, rpc_loc_start_fix_rets *clnt_res, CLIENT *clnt)
+{
+    return (clnt_call(clnt, rpc_loc_start_fix,
+        (xdrproc_t) xdr_rpc_loc_start_fix_args, (caddr_t) argp,
+        (xdrproc_t) xdr_rpc_loc_start_fix_rets, (caddr_t) clnt_res,
+        TIMEOUT));
+}
+
+enum clnt_stat
+rpc_loc_stop_fix_0x00050001(rpc_loc_stop_fix_args *argp, rpc_loc_stop_fix_rets *clnt_res, CLIENT *clnt)
+{
+    return (clnt_call(clnt, rpc_loc_stop_fix,
+        (xdrproc_t) xdr_rpc_loc_stop_fix_args, (caddr_t) argp,
+        (xdrproc_t) xdr_rpc_loc_stop_fix_rets, (caddr_t) clnt_res,
+        TIMEOUT));
+}
+
+enum clnt_stat
+rpc_loc_ioctl_0x00050001(rpc_loc_ioctl_args *argp, rpc_loc_ioctl_rets *clnt_res, CLIENT *clnt)
+{
+    return (clnt_call(clnt, rpc_loc_ioctl,
+        (xdrproc_t) xdr_rpc_loc_ioctl_args, (caddr_t) argp,
+        (xdrproc_t) xdr_rpc_loc_ioctl_rets, (caddr_t) clnt_res,
+        TIMEOUT));
+}
+
+enum clnt_stat
+rpc_loc_api_api_versions_0x00050001(void *argp, rpc_loc_api_api_versions_rets *clnt_res, CLIENT *clnt)
+{
+    return (clnt_call(clnt, rpc_loc_api_api_versions,
+        (xdrproc_t) xdr_void, (caddr_t) argp,
+        (xdrproc_t) xdr_rpc_loc_api_api_versions_rets, (caddr_t) clnt_res,
+        TIMEOUT));
+}
+
+enum clnt_stat
+rpc_loc_api_null_0x00050002(void *argp, void *clnt_res, CLIENT *clnt)
+{
+    return (clnt_call(clnt, rpc_loc_api_null,
+        (xdrproc_t) xdr_void, (caddr_t) argp,
+        (xdrproc_t) xdr_void, (caddr_t) clnt_res,
+        TIMEOUT));
+}
+
+enum clnt_stat
+rpc_loc_api_null_0x00050003(void *argp, void *clnt_res, CLIENT *clnt)
+{
+    return (clnt_call(clnt, rpc_loc_api_null,
+        (xdrproc_t) xdr_void, (caddr_t) argp,
+        (xdrproc_t) xdr_void, (caddr_t) clnt_res,
+        TIMEOUT));
+}
+
+enum clnt_stat
+rpc_loc_api_null_0x00050004(void *argp, void *clnt_res, CLIENT *clnt)
+{
+    return (clnt_call(clnt, rpc_loc_api_null,
+        (xdrproc_t) xdr_void, (caddr_t) argp,
+        (xdrproc_t) xdr_void, (caddr_t) clnt_res,
+        TIMEOUT));
+}
+
+enum clnt_stat
+rpc_loc_api_null_0x00050005(void *argp, void *clnt_res, CLIENT *clnt)
+{
+    return (clnt_call(clnt, rpc_loc_api_null,
+        (xdrproc_t) xdr_void, (caddr_t) argp,
+        (xdrproc_t) xdr_void, (caddr_t) clnt_res,
+        TIMEOUT));
+}
+
+enum clnt_stat
+rpc_loc_api_null_0x00050006(void *argp, void *clnt_res, CLIENT *clnt)
+{
+    return (clnt_call(clnt, rpc_loc_api_null,
+        (xdrproc_t) xdr_void, (caddr_t) argp,
+        (xdrproc_t) xdr_void, (caddr_t) clnt_res,
+        TIMEOUT));
+}
diff --git a/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/src/loc_api_rpcgen_common_xdr.c b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/src/loc_api_rpcgen_common_xdr.c
new file mode 100644
index 0000000..21be8f4
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/src/loc_api_rpcgen_common_xdr.c
@@ -0,0 +1,1775 @@
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#include "loc_api_rpcgen_common_rpc.h"
+
+bool_t
+xdr_rpc_loc_client_handle_type (XDR *xdrs, rpc_loc_client_handle_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_int32 (xdrs, objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_event_mask_type (XDR *xdrs, rpc_loc_event_mask_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_uint64 (xdrs, objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_position_valid_mask_type (XDR *xdrs, rpc_loc_position_valid_mask_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_uint64 (xdrs, objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_pos_technology_mask_type (XDR *xdrs, rpc_loc_pos_technology_mask_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_uint32 (xdrs, objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_session_status_e_type (XDR *xdrs, rpc_loc_session_status_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_calendar_time_s_type (XDR *xdrs, rpc_loc_calendar_time_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_uint16 (xdrs, &objp->year))
+         return FALSE;
+     if (!xdr_u_char (xdrs, &objp->month))
+         return FALSE;
+     if (!xdr_u_char (xdrs, &objp->day_of_week))
+         return FALSE;
+     if (!xdr_u_char (xdrs, &objp->day))
+         return FALSE;
+     if (!xdr_u_char (xdrs, &objp->hour))
+         return FALSE;
+     if (!xdr_u_char (xdrs, &objp->minute))
+         return FALSE;
+     if (!xdr_u_char (xdrs, &objp->second))
+         return FALSE;
+     if (!xdr_rpc_uint16 (xdrs, &objp->millisecond))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_parsed_position_s_type (XDR *xdrs, rpc_loc_parsed_position_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_loc_position_valid_mask_type (xdrs, &objp->valid_mask))
+         return FALSE;
+     if (!xdr_rpc_loc_session_status_e_type (xdrs, &objp->session_status))
+         return FALSE;
+     if (!xdr_rpc_loc_calendar_time_s_type (xdrs, &objp->timestamp_calendar))
+         return FALSE;
+     if (!xdr_rpc_uint64 (xdrs, &objp->timestamp_utc))
+         return FALSE;
+     if (!xdr_rpc_uint8 (xdrs, &objp->leap_seconds))
+         return FALSE;
+     if (!xdr_float (xdrs, &objp->time_unc))
+         return FALSE;
+     if (!xdr_double (xdrs, &objp->latitude))
+         return FALSE;
+     if (!xdr_double (xdrs, &objp->longitude))
+         return FALSE;
+     if (!xdr_float (xdrs, &objp->altitude_wrt_ellipsoid))
+         return FALSE;
+     if (!xdr_float (xdrs, &objp->altitude_wrt_mean_sea_level))
+         return FALSE;
+     if (!xdr_float (xdrs, &objp->speed_horizontal))
+         return FALSE;
+     if (!xdr_float (xdrs, &objp->speed_vertical))
+         return FALSE;
+     if (!xdr_float (xdrs, &objp->heading))
+         return FALSE;
+     if (!xdr_float (xdrs, &objp->hor_unc_circular))
+         return FALSE;
+     if (!xdr_float (xdrs, &objp->hor_unc_ellipse_semi_major))
+         return FALSE;
+     if (!xdr_float (xdrs, &objp->hor_unc_ellipse_semi_minor))
+         return FALSE;
+     if (!xdr_float (xdrs, &objp->hor_unc_ellipse_orient_azimuth))
+         return FALSE;
+     if (!xdr_float (xdrs, &objp->vert_unc))
+         return FALSE;
+     if (!xdr_float (xdrs, &objp->speed_unc))
+         return FALSE;
+     if (!xdr_float (xdrs, &objp->heading_unc))
+         return FALSE;
+     if (!xdr_u_char (xdrs, &objp->confidence_horizontal))
+         return FALSE;
+     if (!xdr_u_char (xdrs, &objp->confidence_vertical))
+         return FALSE;
+     if (!xdr_float (xdrs, &objp->magnetic_deviation))
+         return FALSE;
+     if (!xdr_rpc_loc_pos_technology_mask_type (xdrs, &objp->technology_mask))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_sv_system_e_type (XDR *xdrs, rpc_loc_sv_system_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_sv_status_e_type (XDR *xdrs, rpc_loc_sv_status_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_sv_info_valid_mask_type (XDR *xdrs, rpc_loc_sv_info_valid_mask_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_uint32 (xdrs, objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_sv_info_s_type (XDR *xdrs, rpc_loc_sv_info_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_loc_sv_info_valid_mask_type (xdrs, &objp->valid_mask))
+         return FALSE;
+     if (!xdr_rpc_loc_sv_system_e_type (xdrs, &objp->system))
+         return FALSE;
+     if (!xdr_rpc_uint8 (xdrs, &objp->prn))
+         return FALSE;
+     if (!xdr_rpc_uint8 (xdrs, &objp->health_status))
+         return FALSE;
+     if (!xdr_rpc_loc_sv_status_e_type (xdrs, &objp->process_status))
+         return FALSE;
+     if (!xdr_rpc_boolean (xdrs, &objp->has_eph))
+         return FALSE;
+     if (!xdr_rpc_boolean (xdrs, &objp->has_alm))
+         return FALSE;
+     if (!xdr_float (xdrs, &objp->elevation))
+         return FALSE;
+     if (!xdr_float (xdrs, &objp->azimuth))
+         return FALSE;
+     if (!xdr_float (xdrs, &objp->snr))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_gnss_info_valid_mask_type (XDR *xdrs, rpc_loc_gnss_info_valid_mask_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_uint32 (xdrs, objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_gnss_info_s_type (XDR *xdrs, rpc_loc_gnss_info_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_loc_gnss_info_valid_mask_type (xdrs, &objp->valid_mask))
+         return FALSE;
+     if (!xdr_float (xdrs, &objp->position_dop))
+         return FALSE;
+     if (!xdr_float (xdrs, &objp->horizontal_dop))
+         return FALSE;
+     if (!xdr_float (xdrs, &objp->vertical_dop))
+         return FALSE;
+     if (!xdr_rpc_boolean (xdrs, &objp->altitude_assumed))
+         return FALSE;
+     if (!xdr_rpc_uint16 (xdrs, &objp->sv_count))
+         return FALSE;
+     if (!xdr_array (xdrs, (char **)&objp->sv_list.sv_list_val, (u_int *) &objp->sv_list.sv_list_len, 80,
+        sizeof (rpc_loc_sv_info_s_type), (xdrproc_t) xdr_rpc_loc_sv_info_s_type))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_nmea_report_s_type (XDR *xdrs, rpc_loc_nmea_report_s_type *objp)
+{
+    register int32_t *buf;
+
+    int i;
+     if (!xdr_rpc_uint16 (xdrs, &objp->length))
+         return FALSE;
+     if (!xdr_opaque (xdrs, objp->nmea_sentences, 200))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_status_event_e_type (XDR *xdrs, rpc_loc_status_event_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_engine_state_e_type (XDR *xdrs, rpc_loc_engine_state_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_fix_session_state_e_type (XDR *xdrs, rpc_loc_fix_session_state_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_status_event_payload_u_type (XDR *xdrs, rpc_loc_status_event_payload_u_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_loc_status_event_e_type (xdrs, &objp->disc))
+         return FALSE;
+    switch (objp->disc) {
+    case RPC_LOC_STATUS_EVENT_ENGINE_STATE:
+         if (!xdr_rpc_loc_engine_state_e_type (xdrs, &objp->rpc_loc_status_event_payload_u_type_u.engine_state))
+             return FALSE;
+        break;
+    case RPC_LOC_STATUS_EVENT_FIX_SESSION_STATE:
+         if (!xdr_rpc_loc_fix_session_state_e_type (xdrs, &objp->rpc_loc_status_event_payload_u_type_u.fix_session_state))
+             return FALSE;
+        break;
+    default:
+        break;
+    }
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_status_event_s_type (XDR *xdrs, rpc_loc_status_event_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_loc_status_event_e_type (xdrs, &objp->event))
+         return FALSE;
+     if (!xdr_rpc_loc_status_event_payload_u_type (xdrs, &objp->payload))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_addr_e_type (XDR *xdrs, rpc_loc_server_addr_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_addr_ipv4_type (XDR *xdrs, rpc_loc_server_addr_ipv4_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_uint32 (xdrs, &objp->addr))
+         return FALSE;
+     if (!xdr_rpc_uint16 (xdrs, &objp->port))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_addr_url_type (XDR *xdrs, rpc_loc_server_addr_url_type *objp)
+{
+    register int32_t *buf;
+
+    int i;
+     if (!xdr_rpc_uint16 (xdrs, &objp->length))
+         return FALSE;
+     if (!xdr_opaque (xdrs, objp->addr, 256))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_addr_ipv6_type (XDR *xdrs, rpc_loc_server_addr_ipv6_type *objp)
+{
+    register int32_t *buf;
+
+    int i;
+     if (!xdr_vector (xdrs, (char *)objp->addr, 8,
+        sizeof (rpc_uint16), (xdrproc_t) xdr_rpc_uint16))
+         return FALSE;
+     if (!xdr_rpc_uint32 (xdrs, &objp->port))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_addr_u_type (XDR *xdrs, rpc_loc_server_addr_u_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_loc_server_addr_e_type (xdrs, &objp->disc))
+         return FALSE;
+    switch (objp->disc) {
+    case RPC_LOC_SERVER_ADDR_IPV4:
+         if (!xdr_rpc_loc_server_addr_ipv4_type (xdrs, &objp->rpc_loc_server_addr_u_type_u.ipv4))
+             return FALSE;
+        break;
+    case RPC_LOC_SERVER_ADDR_URL:
+         if (!xdr_rpc_loc_server_addr_url_type (xdrs, &objp->rpc_loc_server_addr_u_type_u.url))
+             return FALSE;
+        break;
+    case RPC_LOC_SERVER_ADDR_IPV6:
+         if (!xdr_rpc_loc_server_addr_ipv6_type (xdrs, &objp->rpc_loc_server_addr_u_type_u.ipv6))
+             return FALSE;
+        break;
+    default:
+        break;
+    }
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_info_s_type (XDR *xdrs, rpc_loc_server_info_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_loc_server_addr_e_type (xdrs, &objp->addr_type))
+         return FALSE;
+     if (!xdr_rpc_loc_server_addr_u_type (xdrs, &objp->addr_info))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_notify_verify_e_type (XDR *xdrs, rpc_loc_ni_notify_verify_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_event_e_type (XDR *xdrs, rpc_loc_ni_event_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_datacoding_scheme_e_type (XDR *xdrs, rpc_loc_ni_datacoding_scheme_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_vx_requester_id_encoding_scheme_e_type (XDR *xdrs, rpc_loc_ni_vx_requester_id_encoding_scheme_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_vx_pos_mode_e_type (XDR *xdrs, rpc_loc_ni_vx_pos_mode_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_vx_requester_id_s_type (XDR *xdrs, rpc_loc_ni_vx_requester_id_s_type *objp)
+{
+    register int32_t *buf;
+
+    int i;
+     if (!xdr_u_char (xdrs, &objp->requester_id_length))
+         return FALSE;
+     if (!xdr_opaque (xdrs, objp->requester_id, 200))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_vx_notify_verify_req_s_type (XDR *xdrs, rpc_loc_ni_vx_notify_verify_req_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_loc_ni_notify_verify_e_type (xdrs, &objp->notification_priv_type))
+         return FALSE;
+     if (!xdr_u_char (xdrs, &objp->pos_qos_incl))
+         return FALSE;
+     if (!xdr_u_char (xdrs, &objp->pos_qos))
+         return FALSE;
+     if (!xdr_rpc_uint32 (xdrs, &objp->num_fixes))
+         return FALSE;
+     if (!xdr_rpc_uint32 (xdrs, &objp->tbf))
+         return FALSE;
+     if (!xdr_rpc_loc_ni_vx_pos_mode_e_type (xdrs, &objp->pos_mode))
+         return FALSE;
+     if (!xdr_rpc_loc_ni_vx_requester_id_encoding_scheme_e_type (xdrs, &objp->encoding_scheme))
+         return FALSE;
+     if (!xdr_rpc_loc_ni_vx_requester_id_s_type (xdrs, &objp->requester_id))
+         return FALSE;
+     if (!xdr_rpc_uint16 (xdrs, &objp->user_resp_timer_val))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_supl_pos_method_e_type (XDR *xdrs, rpc_loc_ni_supl_pos_method_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_supl_slp_session_id_s_type (XDR *xdrs, rpc_loc_ni_supl_slp_session_id_s_type *objp)
+{
+    register int32_t *buf;
+
+    int i;
+     if (!xdr_u_char (xdrs, &objp->presence))
+         return FALSE;
+     if (!xdr_opaque (xdrs, objp->session_id, 4))
+         return FALSE;
+     if (!xdr_rpc_loc_server_info_s_type (xdrs, &objp->slp_address))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_requestor_id_s_type (XDR *xdrs, rpc_loc_ni_requestor_id_s_type *objp)
+{
+    register int32_t *buf;
+
+    int i;
+     if (!xdr_u_char (xdrs, &objp->data_coding_scheme))
+         return FALSE;
+     if (!xdr_opaque (xdrs, objp->requestor_id_string, 200))
+         return FALSE;
+     if (!xdr_u_char (xdrs, &objp->string_len))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_supl_client_name_s_type (XDR *xdrs, rpc_loc_ni_supl_client_name_s_type *objp)
+{
+    register int32_t *buf;
+
+    int i;
+     if (!xdr_u_char (xdrs, &objp->data_coding_scheme))
+         return FALSE;
+     if (!xdr_opaque (xdrs, objp->client_name_string, 64))
+         return FALSE;
+     if (!xdr_u_char (xdrs, &objp->string_len))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_supl_qop_s_type (XDR *xdrs, rpc_loc_ni_supl_qop_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_u_char (xdrs, &objp->bit_mask))
+         return FALSE;
+     if (!xdr_u_char (xdrs, &objp->horacc))
+         return FALSE;
+     if (!xdr_u_char (xdrs, &objp->veracc))
+         return FALSE;
+     if (!xdr_rpc_uint16 (xdrs, &objp->maxLocAge))
+         return FALSE;
+     if (!xdr_u_char (xdrs, &objp->delay))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_supl_notify_verify_req_s_type (XDR *xdrs, rpc_loc_ni_supl_notify_verify_req_s_type *objp)
+{
+    register int32_t *buf;
+
+    int i;
+     if (!xdr_rpc_loc_ni_notify_verify_e_type (xdrs, &objp->notification_priv_type))
+         return FALSE;
+     if (!xdr_rpc_uint16 (xdrs, &objp->flags))
+         return FALSE;
+     if (!xdr_rpc_loc_ni_supl_slp_session_id_s_type (xdrs, &objp->supl_slp_session_id))
+         return FALSE;
+     if (!xdr_opaque (xdrs, objp->supl_hash, 8))
+         return FALSE;
+     if (!xdr_rpc_loc_ni_datacoding_scheme_e_type (xdrs, &objp->datacoding_scheme))
+         return FALSE;
+     if (!xdr_rpc_loc_ni_supl_pos_method_e_type (xdrs, &objp->pos_method))
+         return FALSE;
+     if (!xdr_rpc_loc_ni_requestor_id_s_type (xdrs, &objp->requestor_id))
+         return FALSE;
+     if (!xdr_rpc_loc_ni_supl_client_name_s_type (xdrs, &objp->client_name))
+         return FALSE;
+     if (!xdr_rpc_loc_ni_supl_qop_s_type (xdrs, &objp->supl_qop))
+         return FALSE;
+     if (!xdr_rpc_uint16 (xdrs, &objp->user_response_timer))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_ext_client_address_s_type (XDR *xdrs, rpc_loc_ni_ext_client_address_s_type *objp)
+{
+    register int32_t *buf;
+
+    int i;
+     if (!xdr_u_char (xdrs, &objp->ext_client_address_len))
+         return FALSE;
+     if (!xdr_opaque (xdrs, objp->ext_client_address, 20))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_location_type_e_type (XDR *xdrs, rpc_loc_ni_location_type_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_deferred_location_s_type (XDR *xdrs, rpc_loc_ni_deferred_location_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_u_char (xdrs, &objp->unused_bits))
+         return FALSE;
+     if (!xdr_u_char (xdrs, &objp->ms_available))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_codeword_string_s_type (XDR *xdrs, rpc_loc_ni_codeword_string_s_type *objp)
+{
+    register int32_t *buf;
+
+    int i;
+     if (!xdr_u_char (xdrs, &objp->data_coding_scheme))
+         return FALSE;
+     if (!xdr_opaque (xdrs, objp->lcs_codeword_string, 20))
+         return FALSE;
+     if (!xdr_u_char (xdrs, &objp->string_len))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_service_type_id_s_type (XDR *xdrs, rpc_loc_ni_service_type_id_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_u_char (xdrs, &objp->lcs_service_type_id))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_umts_cp_notify_verify_req_s_type (XDR *xdrs, rpc_loc_ni_umts_cp_notify_verify_req_s_type *objp)
+{
+    register int32_t *buf;
+
+    int i;
+     if (!xdr_rpc_loc_ni_notify_verify_e_type (xdrs, &objp->notification_priv_type))
+         return FALSE;
+     if (!xdr_u_char (xdrs, &objp->invoke_id))
+         return FALSE;
+     if (!xdr_rpc_uint16 (xdrs, &objp->flags))
+         return FALSE;
+     if (!xdr_u_char (xdrs, &objp->notification_length))
+         return FALSE;
+     if (!xdr_opaque (xdrs, objp->notification_text, 64))
+         return FALSE;
+     if (!xdr_rpc_loc_ni_datacoding_scheme_e_type (xdrs, &objp->datacoding_scheme))
+         return FALSE;
+     if (!xdr_rpc_loc_ni_ext_client_address_s_type (xdrs, &objp->ext_client_address_data))
+         return FALSE;
+     if (!xdr_rpc_loc_ni_location_type_e_type (xdrs, &objp->location_type))
+         return FALSE;
+     if (!xdr_rpc_loc_ni_deferred_location_s_type (xdrs, &objp->deferred_location))
+         return FALSE;
+     if (!xdr_rpc_loc_ni_requestor_id_s_type (xdrs, &objp->requestor_id))
+         return FALSE;
+     if (!xdr_rpc_loc_ni_codeword_string_s_type (xdrs, &objp->codeword_string))
+         return FALSE;
+     if (!xdr_rpc_loc_ni_service_type_id_s_type (xdrs, &objp->service_type_id))
+         return FALSE;
+     if (!xdr_rpc_uint16 (xdrs, &objp->user_response_timer))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_service_interaction_e_type (XDR *xdrs, rpc_loc_ni_service_interaction_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_vx_service_interaction_req_s_type (XDR *xdrs, rpc_loc_ni_vx_service_interaction_req_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_loc_ni_vx_notify_verify_req_s_type (xdrs, &objp->ni_vx_req))
+         return FALSE;
+     if (!xdr_rpc_loc_ni_service_interaction_e_type (xdrs, &objp->service_interation_type))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_event_payload_u_type (XDR *xdrs, rpc_loc_ni_event_payload_u_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_loc_ni_event_e_type (xdrs, &objp->disc))
+         return FALSE;
+    switch (objp->disc) {
+    case RPC_LOC_NI_EVENT_VX_NOTIFY_VERIFY_REQ:
+         if (!xdr_rpc_loc_ni_vx_notify_verify_req_s_type (xdrs, &objp->rpc_loc_ni_event_payload_u_type_u.vx_req))
+             return FALSE;
+        break;
+    case RPC_LOC_NI_EVENT_SUPL_NOTIFY_VERIFY_REQ:
+         if (!xdr_rpc_loc_ni_supl_notify_verify_req_s_type (xdrs, &objp->rpc_loc_ni_event_payload_u_type_u.supl_req))
+             return FALSE;
+        break;
+    case RPC_LOC_NI_EVENT_UMTS_CP_NOTIFY_VERIFY_REQ:
+         if (!xdr_rpc_loc_ni_umts_cp_notify_verify_req_s_type (xdrs, &objp->rpc_loc_ni_event_payload_u_type_u.umts_cp_req))
+             return FALSE;
+        break;
+    case RPC_LOC_NI_EVENT_VX_SERVICE_INTERACTION_REQ:
+         if (!xdr_rpc_loc_ni_vx_service_interaction_req_s_type (xdrs, &objp->rpc_loc_ni_event_payload_u_type_u.service_interaction_req))
+             return FALSE;
+        break;
+    default:
+        break;
+    }
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_event_s_type (XDR *xdrs, rpc_loc_ni_event_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_loc_ni_event_e_type (xdrs, &objp->event))
+         return FALSE;
+     if (!xdr_rpc_loc_ni_event_payload_u_type (xdrs, &objp->payload))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_assist_data_request_e_type (XDR *xdrs, rpc_loc_assist_data_request_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_struct_loc_time_download_source_s_type_servers_ptr (XDR *xdrs, rpc_struct_loc_time_download_source_s_type_servers_ptr *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_string (xdrs, objp, 256))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_struct_loc_time_download_source_s_type_servers (XDR *xdrs, rpc_struct_loc_time_download_source_s_type_servers objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_vector (xdrs, (char *)objp, 3,
+        sizeof (rpc_struct_loc_time_download_source_s_type_servers_ptr), (xdrproc_t) xdr_rpc_struct_loc_time_download_source_s_type_servers_ptr))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_time_download_source_s_type (XDR *xdrs, rpc_loc_time_download_source_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_uint32 (xdrs, &objp->delay_threshold))
+         return FALSE;
+     if (!xdr_rpc_struct_loc_time_download_source_s_type_servers (xdrs, objp->servers))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr (XDR *xdrs, rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_string (xdrs, objp, 256))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_struct_loc_predicted_orbits_data_source_s_type_servers (XDR *xdrs, rpc_struct_loc_predicted_orbits_data_source_s_type_servers objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_vector (xdrs, (char *)objp, 3,
+        sizeof (rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr), (xdrproc_t) xdr_rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_predicted_orbits_data_source_s_type (XDR *xdrs, rpc_loc_predicted_orbits_data_source_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_uint32 (xdrs, &objp->max_file_size))
+         return FALSE;
+     if (!xdr_rpc_uint32 (xdrs, &objp->max_part_size))
+         return FALSE;
+     if (!xdr_rpc_struct_loc_predicted_orbits_data_source_s_type_servers (xdrs, objp->servers))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_pos_inj_request_s_type (XDR *xdrs, rpc_loc_pos_inj_request_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_uint32 (xdrs, &objp->flags))
+         return FALSE;
+     if (!xdr_double (xdrs, &objp->latitude))
+         return FALSE;
+     if (!xdr_double (xdrs, &objp->longitude))
+         return FALSE;
+     if (!xdr_rpc_uint32 (xdrs, &objp->position_uncertainty))
+         return FALSE;
+     if (!xdr_rpc_uint64 (xdrs, &objp->timestamp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_assist_data_request_payload_u_type (XDR *xdrs, rpc_loc_assist_data_request_payload_u_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_loc_assist_data_request_e_type (xdrs, &objp->disc))
+         return FALSE;
+    switch (objp->disc) {
+    case RPC_LOC_ASSIST_DATA_TIME_REQ:
+         if (!xdr_rpc_loc_time_download_source_s_type (xdrs, &objp->rpc_loc_assist_data_request_payload_u_type_u.time_download))
+             return FALSE;
+        break;
+    case RPC_LOC_ASSIST_DATA_PREDICTED_ORBITS_REQ:
+         if (!xdr_rpc_loc_predicted_orbits_data_source_s_type (xdrs, &objp->rpc_loc_assist_data_request_payload_u_type_u.data_download))
+             return FALSE;
+        break;
+    case RPC_LOC_ASSIST_DATA_POSITION_INJECTION_REQ:
+         if (!xdr_rpc_loc_pos_inj_request_s_type (xdrs, &objp->rpc_loc_assist_data_request_payload_u_type_u.pos_injection))
+             return FALSE;
+        break;
+    default:
+        break;
+    }
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_assist_data_request_s_type (XDR *xdrs, rpc_loc_assist_data_request_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_loc_assist_data_request_e_type (xdrs, &objp->event))
+         return FALSE;
+     if (!xdr_rpc_loc_assist_data_request_payload_u_type (xdrs, &objp->payload))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_connection_handle (XDR *xdrs, rpc_loc_server_connection_handle *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_uint32 (xdrs, objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_protocol_e_type (XDR *xdrs, rpc_loc_server_protocol_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_connection_e_type (XDR *xdrs, rpc_loc_server_connection_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_request_e_type (XDR *xdrs, rpc_loc_server_request_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_open_req_s_type (XDR *xdrs, rpc_loc_server_open_req_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_loc_server_connection_handle (xdrs, &objp->conn_handle))
+         return FALSE;
+     if (!xdr_rpc_loc_server_protocol_e_type (xdrs, &objp->protocol))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_multi_open_req_s_type (XDR *xdrs, rpc_loc_server_multi_open_req_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_loc_server_connection_handle (xdrs, &objp->conn_handle))
+         return FALSE;
+     if (!xdr_rpc_loc_server_protocol_e_type (xdrs, &objp->protocol))
+         return FALSE;
+     if (!xdr_rpc_loc_server_connection_e_type (xdrs, &objp->connection_type))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_close_req_s_type (XDR *xdrs, rpc_loc_server_close_req_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_loc_server_connection_handle (xdrs, &objp->conn_handle))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_request_u_type (XDR *xdrs, rpc_loc_server_request_u_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_loc_server_request_e_type (xdrs, &objp->disc))
+         return FALSE;
+    switch (objp->disc) {
+    case RPC_LOC_SERVER_REQUEST_OPEN:
+         if (!xdr_rpc_loc_server_open_req_s_type (xdrs, &objp->rpc_loc_server_request_u_type_u.open_req))
+             return FALSE;
+        break;
+    case RPC_LOC_SERVER_REQUEST_CLOSE:
+         if (!xdr_rpc_loc_server_close_req_s_type (xdrs, &objp->rpc_loc_server_request_u_type_u.close_req))
+             return FALSE;
+        break;
+    case RPC_LOC_SERVER_REQUEST_MULTI_OPEN:
+         if (!xdr_rpc_loc_server_multi_open_req_s_type (xdrs, &objp->rpc_loc_server_request_u_type_u.multi_open_req))
+             return FALSE;
+        break;
+    default:
+        break;
+    }
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_request_s_type (XDR *xdrs, rpc_loc_server_request_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_loc_server_request_e_type (xdrs, &objp->event))
+         return FALSE;
+     if (!xdr_rpc_loc_server_request_u_type (xdrs, &objp->payload))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_qwip_request_e_type (XDR *xdrs, rpc_loc_qwip_request_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_qwip_request_s_type (XDR *xdrs, rpc_loc_qwip_request_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_loc_qwip_request_e_type (xdrs, &objp->request_type))
+         return FALSE;
+     if (!xdr_rpc_uint16 (xdrs, &objp->tbf_ms))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_reserved_payload_s_type (XDR *xdrs, rpc_loc_reserved_payload_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_uint16 (xdrs, &objp->data_size))
+         return FALSE;
+     if (!xdr_bytes (xdrs, (char **)&objp->data.data_val, (u_int *) &objp->data.data_len, ~0))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ioctl_e_type (XDR *xdrs, rpc_loc_ioctl_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_api_version_s_type (XDR *xdrs, rpc_loc_api_version_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_u_char (xdrs, &objp->major))
+         return FALSE;
+     if (!xdr_u_char (xdrs, &objp->minor))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_fix_recurrence_e_type (XDR *xdrs, rpc_loc_fix_recurrence_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_operation_mode_e_type (XDR *xdrs, rpc_loc_operation_mode_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_notify_e_type (XDR *xdrs, rpc_loc_notify_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_fix_criteria_s_type (XDR *xdrs, rpc_loc_fix_criteria_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_uint32 (xdrs, &objp->valid_mask))
+         return FALSE;
+     if (!xdr_rpc_loc_fix_recurrence_e_type (xdrs, &objp->recurrence_type))
+         return FALSE;
+     if (!xdr_rpc_loc_operation_mode_e_type (xdrs, &objp->preferred_operation_mode))
+         return FALSE;
+     if (!xdr_rpc_uint32 (xdrs, &objp->preferred_accuracy))
+         return FALSE;
+     if (!xdr_rpc_uint32 (xdrs, &objp->preferred_response_time))
+         return FALSE;
+     if (!xdr_rpc_boolean (xdrs, &objp->intermediate_pos_report_enabled))
+         return FALSE;
+     if (!xdr_rpc_loc_notify_e_type (xdrs, &objp->notify_type))
+         return FALSE;
+     if (!xdr_rpc_uint32 (xdrs, &objp->min_interval))
+         return FALSE;
+     if (!xdr_float (xdrs, &objp->min_distance))
+         return FALSE;
+     if (!xdr_rpc_uint32 (xdrs, &objp->min_dist_sample_interval))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_user_resp_e_type (XDR *xdrs, rpc_loc_ni_user_resp_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_user_verify_s_type (XDR *xdrs, rpc_loc_user_verify_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_loc_ni_user_resp_e_type (xdrs, &objp->user_resp))
+         return FALSE;
+     if (!xdr_rpc_loc_ni_event_s_type (xdrs, &objp->ni_event_pass_back))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_predicted_orbits_data_format_e_type (XDR *xdrs, rpc_loc_predicted_orbits_data_format_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_predicted_orbits_data_s_type (XDR *xdrs, rpc_loc_predicted_orbits_data_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_loc_predicted_orbits_data_format_e_type (xdrs, &objp->format_type))
+         return FALSE;
+     if (!xdr_rpc_uint32 (xdrs, &objp->total_size))
+         return FALSE;
+     if (!xdr_rpc_uint8 (xdrs, &objp->total_parts))
+         return FALSE;
+     if (!xdr_rpc_uint8 (xdrs, &objp->part))
+         return FALSE;
+     if (!xdr_rpc_uint16 (xdrs, &objp->part_len))
+         return FALSE;
+     if (!xdr_bytes (xdrs, (char **)&objp->data_ptr.data_ptr_val, (u_int *) &objp->data_ptr.data_ptr_len, ~0))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_predicted_orbits_data_validity_report_s_type (XDR *xdrs, rpc_loc_predicted_orbits_data_validity_report_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_uint64 (xdrs, &objp->start_time_utc))
+         return FALSE;
+     if (!xdr_rpc_uint16 (xdrs, &objp->valid_duration_hrs))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_predicted_orbits_auto_download_config_s_type (XDR *xdrs, rpc_loc_predicted_orbits_auto_download_config_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_boolean (xdrs, &objp->enable))
+         return FALSE;
+     if (!xdr_u_char (xdrs, &objp->auto_check_every_hrs))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_assist_data_time_s_type (XDR *xdrs, rpc_loc_assist_data_time_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_uint64 (xdrs, &objp->time_utc))
+         return FALSE;
+     if (!xdr_rpc_uint32 (xdrs, &objp->uncertainty))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_assist_pos_valid_mask_type (XDR *xdrs, rpc_loc_assist_pos_valid_mask_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_uint64 (xdrs, objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_assist_data_pos_s_type (XDR *xdrs, rpc_loc_assist_data_pos_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_loc_assist_pos_valid_mask_type (xdrs, &objp->valid_mask))
+         return FALSE;
+     if (!xdr_rpc_uint64 (xdrs, &objp->timestamp_utc))
+         return FALSE;
+     if (!xdr_double (xdrs, &objp->latitude))
+         return FALSE;
+     if (!xdr_double (xdrs, &objp->longitude))
+         return FALSE;
+     if (!xdr_float (xdrs, &objp->altitude_wrt_ellipsoid))
+         return FALSE;
+     if (!xdr_float (xdrs, &objp->altitude_wrt_mean_sea_level))
+         return FALSE;
+     if (!xdr_float (xdrs, &objp->hor_unc_circular))
+         return FALSE;
+     if (!xdr_float (xdrs, &objp->vert_unc))
+         return FALSE;
+     if (!xdr_u_char (xdrs, &objp->confidence_horizontal))
+         return FALSE;
+     if (!xdr_u_char (xdrs, &objp->confidence_vertical))
+         return FALSE;
+     if (!xdr_rpc_int32 (xdrs, &objp->timestamp_age))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_open_status_e_type (XDR *xdrs, rpc_loc_server_open_status_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_pdp_type_e_type (XDR *xdrs, rpc_loc_server_pdp_type_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_open_status_s_type (XDR *xdrs, rpc_loc_server_open_status_s_type *objp)
+{
+    register int32_t *buf;
+
+    int i;
+     if (!xdr_rpc_loc_server_connection_handle (xdrs, &objp->conn_handle))
+         return FALSE;
+     if (!xdr_rpc_loc_server_open_status_e_type (xdrs, &objp->open_status))
+         return FALSE;
+     if (!xdr_opaque (xdrs, objp->apn_name, 100))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_multi_open_status_s_type (XDR *xdrs, rpc_loc_server_multi_open_status_s_type *objp)
+{
+    register int32_t *buf;
+
+    int i;
+     if (!xdr_rpc_loc_server_connection_handle (xdrs, &objp->conn_handle))
+         return FALSE;
+     if (!xdr_rpc_loc_server_open_status_e_type (xdrs, &objp->open_status))
+         return FALSE;
+     if (!xdr_rpc_loc_server_pdp_type_e_type (xdrs, &objp->pdp_type))
+         return FALSE;
+     if (!xdr_opaque (xdrs, objp->apn_name, 100))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_close_status_e_type (XDR *xdrs, rpc_loc_server_close_status_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_close_status_s_type (XDR *xdrs, rpc_loc_server_close_status_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_loc_server_connection_handle (xdrs, &objp->conn_handle))
+         return FALSE;
+     if (!xdr_rpc_loc_server_close_status_e_type (xdrs, &objp->close_status))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_wiper_fix_time_s_type (XDR *xdrs, rpc_loc_wiper_fix_time_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_uint32 (xdrs, &objp->slow_clock_count))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_wiper_fix_pos_s_type (XDR *xdrs, rpc_loc_wiper_fix_pos_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_int32 (xdrs, &objp->lat))
+         return FALSE;
+     if (!xdr_rpc_int32 (xdrs, &objp->lon))
+         return FALSE;
+     if (!xdr_rpc_uint16 (xdrs, &objp->HEPE))
+         return FALSE;
+     if (!xdr_rpc_uint8 (xdrs, &objp->num_of_aps_used))
+         return FALSE;
+     if (!xdr_rpc_uint8 (xdrs, &objp->fix_error_code))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_wiper_ap_info_s_type (XDR *xdrs, rpc_loc_wiper_ap_info_s_type *objp)
+{
+    register int32_t *buf;
+
+    int i;
+     if (!xdr_opaque (xdrs, objp->mac_addr, 6))
+         return FALSE;
+     if (!xdr_rpc_int32 (xdrs, &objp->rssi))
+         return FALSE;
+     if (!xdr_rpc_uint16 (xdrs, &objp->channel))
+         return FALSE;
+     if (!xdr_rpc_uint8 (xdrs, &objp->ap_qualifier))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_wiper_ap_set_s_type (XDR *xdrs, rpc_loc_wiper_ap_set_s_type *objp)
+{
+    register int32_t *buf;
+
+    int i;
+     if (!xdr_rpc_uint8 (xdrs, &objp->num_of_aps))
+         return FALSE;
+     if (!xdr_vector (xdrs, (char *)objp->ap_info, 50,
+        sizeof (rpc_loc_wiper_ap_info_s_type), (xdrproc_t) xdr_rpc_loc_wiper_ap_info_s_type))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_wiper_position_report_s_type (XDR *xdrs, rpc_loc_wiper_position_report_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_uint8 (xdrs, &objp->wiper_valid_info_flag))
+         return FALSE;
+     if (!xdr_rpc_loc_wiper_fix_time_s_type (xdrs, &objp->wiper_fix_time))
+         return FALSE;
+     if (!xdr_rpc_loc_wiper_fix_pos_s_type (xdrs, &objp->wiper_fix_position))
+         return FALSE;
+     if (!xdr_rpc_loc_wiper_ap_set_s_type (xdrs, &objp->wiper_ap_set))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_wiper_status_e_type (XDR *xdrs, rpc_loc_wiper_status_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_fs_operation_e_type (XDR *xdrs, rpc_loc_fs_operation_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_efs_data_s_type (XDR *xdrs, rpc_loc_efs_data_s_type *objp)
+{
+    register int32_t *buf;
+
+    int i;
+     if (!xdr_opaque (xdrs, objp->filename, 64))
+         return FALSE;
+     if (!xdr_rpc_loc_fs_operation_e_type (xdrs, &objp->operation))
+         return FALSE;
+     if (!xdr_rpc_uint32 (xdrs, &objp->total_size))
+         return FALSE;
+     if (!xdr_bytes (xdrs, (char **)&objp->data_ptr.data_ptr_val, (u_int *) &objp->data_ptr.data_ptr_len, ~0))
+         return FALSE;
+     if (!xdr_rpc_uint32 (xdrs, &objp->part_len))
+         return FALSE;
+     if (!xdr_rpc_uint8 (xdrs, &objp->part))
+         return FALSE;
+     if (!xdr_rpc_uint8 (xdrs, &objp->total_parts))
+         return FALSE;
+     if (!xdr_rpc_uint32 (xdrs, &objp->reserved))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_error_estimate_config_e_type (XDR *xdrs, rpc_loc_error_estimate_config_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_apn_profiles_type (XDR *xdrs, rpc_loc_apn_profiles_type *objp)
+{
+    register int32_t *buf;
+
+    int i;
+     if (!xdr_rpc_uint32 (xdrs, &objp->srv_system_type))
+         return FALSE;
+     if (!xdr_rpc_uint32 (xdrs, &objp->pdp_type))
+         return FALSE;
+     if (!xdr_rpc_uint32 (xdrs, &objp->reserved))
+         return FALSE;
+     if (!xdr_opaque (xdrs, objp->apn_name, 100))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_lock_e_type (XDR *xdrs, rpc_loc_lock_e_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_enum (xdrs, (enum_t *) objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_nmea_sentence_type (XDR *xdrs, rpc_loc_nmea_sentence_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_uint32 (xdrs, objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_assist_data_type (XDR *xdrs, rpc_loc_assist_data_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_uint32 (xdrs, objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_assist_data_delete_s_type (XDR *xdrs, rpc_loc_assist_data_delete_s_type *objp)
+{
+    register int32_t *buf;
+
+    int i;
+     if (!xdr_rpc_loc_assist_data_type (xdrs, &objp->type))
+         return FALSE;
+     if (!xdr_vector (xdrs, (char *)objp->reserved, 8,
+        sizeof (rpc_uint32), (xdrproc_t) xdr_rpc_uint32))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ioctl_data_u_type (XDR *xdrs, rpc_loc_ioctl_data_u_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_loc_ioctl_e_type (xdrs, &objp->disc))
+         return FALSE;
+    switch (objp->disc) {
+    case RPC_LOC_IOCTL_SET_FIX_CRITERIA:
+         if (!xdr_rpc_loc_fix_criteria_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.fix_criteria))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_INFORM_NI_USER_RESPONSE:
+         if (!xdr_rpc_loc_user_verify_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.user_verify_resp))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_INJECT_PREDICTED_ORBITS_DATA:
+         if (!xdr_rpc_loc_predicted_orbits_data_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.predicted_orbits_data))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_SET_PREDICTED_ORBITS_DATA_AUTO_DOWNLOAD:
+         if (!xdr_rpc_loc_predicted_orbits_auto_download_config_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.predicted_orbits_auto_download))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_INJECT_UTC_TIME:
+         if (!xdr_rpc_loc_assist_data_time_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.assistance_data_time))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_INJECT_POSITION:
+         if (!xdr_rpc_loc_assist_data_pos_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.assistance_data_position))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_INFORM_SERVER_OPEN_STATUS:
+         if (!xdr_rpc_loc_server_open_status_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.conn_open_status))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_INFORM_SERVER_CLOSE_STATUS:
+         if (!xdr_rpc_loc_server_close_status_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.conn_close_status))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_SEND_WIPER_POSITION_REPORT:
+         if (!xdr_rpc_loc_wiper_position_report_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.wiper_pos))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_NOTIFY_WIPER_STATUS:
+         if (!xdr_rpc_loc_wiper_status_e_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.wiper_status))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_SET_ENGINE_LOCK:
+         if (!xdr_rpc_loc_lock_e_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.engine_lock))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_SET_SBAS_CONFIG:
+         if (!xdr_rpc_boolean (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.sbas_mode))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_SET_NMEA_TYPES:
+         if (!xdr_rpc_loc_nmea_sentence_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.nmea_types))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_SET_ON_DEMAND_LPM:
+         if (!xdr_rpc_boolean (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.on_demand_lpm))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_SET_CDMA_PDE_SERVER_ADDR:
+    case RPC_LOC_IOCTL_SET_CDMA_MPC_SERVER_ADDR:
+    case RPC_LOC_IOCTL_SET_UMTS_SLP_SERVER_ADDR:
+    case RPC_LOC_IOCTL_SET_CUSTOM_PDE_SERVER_ADDR:
+         if (!xdr_rpc_loc_server_info_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.server_addr))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_DELETE_ASSIST_DATA:
+         if (!xdr_rpc_loc_assist_data_delete_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.assist_data_delete))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_ACCESS_EFS_DATA:
+         if (!xdr_rpc_loc_efs_data_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.efs_data))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_ERROR_ESTIMATE_CONFIG:
+         if (!xdr_rpc_loc_error_estimate_config_e_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.error_estimate_config))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_SET_XTRA_T_SESSION_CONTROL:
+         if (!xdr_rpc_uint8 (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.xtra_t_session_control))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_SET_LBS_APN_PROFILE:
+    case RPC_LOC_IOCTL_SET_XTRA_APN_PROFILE:
+         if (!xdr_vector (xdrs, (char *)objp->rpc_loc_ioctl_data_u_type_u.apn_profiles, 6,
+            sizeof (rpc_loc_apn_profiles_type), (xdrproc_t) xdr_rpc_loc_apn_profiles_type))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_SET_DATA_ENABLE:
+         if (!xdr_rpc_boolean (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.data_enable))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_SET_SUPL_VERSION:
+         if (!xdr_rpc_uint32 (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.supl_version))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_INFORM_SERVER_MULTI_OPEN_STATUS:
+         if (!xdr_rpc_loc_server_multi_open_status_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.multi_conn_open_status))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_RESERVED_CMD:
+         if (!xdr_rpc_loc_reserved_payload_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.reserved))
+             return FALSE;
+        break;
+    default:
+        break;
+    }
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ioctl_callback_data_u_type (XDR *xdrs, rpc_loc_ioctl_callback_data_u_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_loc_ioctl_e_type (xdrs, &objp->disc))
+         return FALSE;
+    switch (objp->disc) {
+    case RPC_LOC_IOCTL_GET_API_VERSION:
+         if (!xdr_rpc_loc_api_version_s_type (xdrs, &objp->rpc_loc_ioctl_callback_data_u_type_u.api_version))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_GET_FIX_CRITERIA:
+         if (!xdr_rpc_loc_fix_criteria_s_type (xdrs, &objp->rpc_loc_ioctl_callback_data_u_type_u.fix_criteria))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_GET_ENGINE_LOCK:
+         if (!xdr_rpc_loc_lock_e_type (xdrs, &objp->rpc_loc_ioctl_callback_data_u_type_u.engine_lock))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_GET_SBAS_CONFIG:
+         if (!xdr_rpc_boolean (xdrs, &objp->rpc_loc_ioctl_callback_data_u_type_u.sbas_mode))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_GET_NMEA_TYPES:
+         if (!xdr_rpc_loc_nmea_sentence_type (xdrs, &objp->rpc_loc_ioctl_callback_data_u_type_u.nmea_types))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_GET_ON_DEMAND_LPM:
+         if (!xdr_rpc_boolean (xdrs, &objp->rpc_loc_ioctl_callback_data_u_type_u.on_demand_lpm))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_GET_CDMA_PDE_SERVER_ADDR:
+    case RPC_LOC_IOCTL_GET_CDMA_MPC_SERVER_ADDR:
+    case RPC_LOC_IOCTL_GET_UMTS_SLP_SERVER_ADDR:
+    case RPC_LOC_IOCTL_GET_CUSTOM_PDE_SERVER_ADDR:
+         if (!xdr_rpc_loc_server_info_s_type (xdrs, &objp->rpc_loc_ioctl_callback_data_u_type_u.server_addr))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_SOURCE:
+         if (!xdr_rpc_loc_predicted_orbits_data_source_s_type (xdrs, &objp->rpc_loc_ioctl_callback_data_u_type_u.predicted_orbits_data_source))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_VALIDITY:
+         if (!xdr_rpc_loc_predicted_orbits_data_validity_report_s_type (xdrs, &objp->rpc_loc_ioctl_callback_data_u_type_u.predicted_orbits_data_validity))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_GET_XTRA_T_SESSION_CONTROL:
+         if (!xdr_rpc_uint8 (xdrs, &objp->rpc_loc_ioctl_callback_data_u_type_u.xtra_t_session_control))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_GET_LBS_APN_PROFILE:
+    case RPC_LOC_IOCTL_GET_XTRA_APN_PROFILE:
+         if (!xdr_vector (xdrs, (char *)objp->rpc_loc_ioctl_callback_data_u_type_u.apn_profiles, 6,
+            sizeof (rpc_loc_apn_profiles_type), (xdrproc_t) xdr_rpc_loc_apn_profiles_type))
+             return FALSE;
+        break;
+    case RPC_LOC_IOCTL_GET_SUPL_VERSION:
+         if (!xdr_rpc_uint32 (xdrs, &objp->rpc_loc_ioctl_callback_data_u_type_u.supl_version))
+             return FALSE;
+        break;
+    default:
+        break;
+    }
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ioctl_callback_s_type (XDR *xdrs, rpc_loc_ioctl_callback_s_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_rpc_loc_ioctl_e_type (xdrs, &objp->type))
+         return FALSE;
+     if (!xdr_rpc_int32 (xdrs, &objp->status))
+         return FALSE;
+     if (!xdr_rpc_loc_ioctl_callback_data_u_type (xdrs, &objp->data))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_event_payload_u_type (XDR *xdrs, rpc_loc_event_payload_u_type *objp)
+{
+    register int32_t *buf;
+
+     if (!xdr_u_quad_t (xdrs, &objp->disc))
+         return FALSE;
+    switch (objp->disc) {
+    case RPC_LOC_EVENT_PARSED_POSITION_REPORT:
+         if (!xdr_rpc_loc_parsed_position_s_type (xdrs, &objp->rpc_loc_event_payload_u_type_u.parsed_location_report))
+             return FALSE;
+        break;
+    case RPC_LOC_EVENT_SATELLITE_REPORT:
+         if (!xdr_rpc_loc_gnss_info_s_type (xdrs, &objp->rpc_loc_event_payload_u_type_u.gnss_report))
+             return FALSE;
+        break;
+    case RPC_LOC_EVENT_NMEA_POSITION_REPORT:
+    case RPC_LOC_EVENT_NMEA_1HZ_REPORT:
+         if (!xdr_rpc_loc_nmea_report_s_type (xdrs, &objp->rpc_loc_event_payload_u_type_u.nmea_report))
+             return FALSE;
+        break;
+    case RPC_LOC_EVENT_NI_NOTIFY_VERIFY_REQUEST:
+         if (!xdr_rpc_loc_ni_event_s_type (xdrs, &objp->rpc_loc_event_payload_u_type_u.ni_request))
+             return FALSE;
+        break;
+    case RPC_LOC_EVENT_ASSISTANCE_DATA_REQUEST:
+         if (!xdr_rpc_loc_assist_data_request_s_type (xdrs, &objp->rpc_loc_event_payload_u_type_u.assist_data_request))
+             return FALSE;
+        break;
+    case RPC_LOC_EVENT_LOCATION_SERVER_REQUEST:
+         if (!xdr_rpc_loc_server_request_s_type (xdrs, &objp->rpc_loc_event_payload_u_type_u.loc_server_request))
+             return FALSE;
+        break;
+    case RPC_LOC_EVENT_IOCTL_REPORT:
+         if (!xdr_rpc_loc_ioctl_callback_s_type (xdrs, &objp->rpc_loc_event_payload_u_type_u.ioctl_report))
+             return FALSE;
+        break;
+    case RPC_LOC_EVENT_STATUS_REPORT:
+         if (!xdr_rpc_loc_status_event_s_type (xdrs, &objp->rpc_loc_event_payload_u_type_u.status_report))
+             return FALSE;
+        break;
+    case RPC_LOC_EVENT_WPS_NEEDED_REQUEST:
+         if (!xdr_rpc_loc_qwip_request_s_type (xdrs, &objp->rpc_loc_event_payload_u_type_u.qwip_request))
+             return FALSE;
+        break;
+    case RPC_LOC_EVENT_RESERVED:
+         if (!xdr_rpc_loc_reserved_payload_s_type (xdrs, &objp->rpc_loc_event_payload_u_type_u.reserved))
+             return FALSE;
+        break;
+    default:
+        break;
+    }
+    return TRUE;
+}
diff --git a/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/src/loc_api_rpcgen_xdr.c b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/src/loc_api_rpcgen_xdr.c
new file mode 100644
index 0000000..a0fdcab
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/src/loc_api_rpcgen_xdr.c
@@ -0,0 +1,199 @@
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#include "loc_api_rpcgen_rpc.h"
+
+bool_t
+xdr_rpc_loc_api_api_versions_return_type (XDR *xdrs, rpc_loc_api_api_versions_return_type *objp)
+{
+;
+
+     if (!xdr_array (xdrs, (char **)&objp->rpc_loc_api_api_versions_return_type_val, (u_int *) &objp->rpc_loc_api_api_versions_return_type_len, ~0,
+        sizeof (rpc_uint32), (xdrproc_t) xdr_rpc_uint32))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_event_cb_f_type (XDR *xdrs, rpc_loc_event_cb_f_type *objp)
+{
+;
+
+     if (!xdr_rpc_uint32 (xdrs, objp))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_open_args (XDR *xdrs, rpc_loc_open_args *objp)
+{
+;
+
+     if (!xdr_rpc_loc_event_mask_type (xdrs, &objp->event_reg_mask))
+         return FALSE;
+     if (!xdr_rpc_loc_event_cb_f_type (xdrs, &objp->event_callback))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_close_args (XDR *xdrs, rpc_loc_close_args *objp)
+{
+;
+
+     if (!xdr_rpc_loc_client_handle_type (xdrs, &objp->handle))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_start_fix_args (XDR *xdrs, rpc_loc_start_fix_args *objp)
+{
+;
+
+     if (!xdr_rpc_loc_client_handle_type (xdrs, &objp->handle))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_stop_fix_args (XDR *xdrs, rpc_loc_stop_fix_args *objp)
+{
+;
+
+     if (!xdr_rpc_loc_client_handle_type (xdrs, &objp->handle))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ioctl_args (XDR *xdrs, rpc_loc_ioctl_args *objp)
+{
+;
+
+     if (!xdr_rpc_loc_client_handle_type (xdrs, &objp->handle))
+         return FALSE;
+     if (!xdr_rpc_loc_ioctl_e_type (xdrs, &objp->ioctl_type))
+         return FALSE;
+     if (!xdr_pointer (xdrs, (char **)&objp->ioctl_data, sizeof (rpc_loc_ioctl_data_u_type), (xdrproc_t) xdr_rpc_loc_ioctl_data_u_type))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_api_api_version_s_args (XDR *xdrs, rpc_loc_api_api_version_s_args *objp)
+{
+;
+
+     if (!xdr_rpc_boolean (xdrs, &objp->len_not_null))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_api_rpc_glue_code_info_remote_rets (XDR *xdrs, rpc_loc_api_rpc_glue_code_info_remote_rets *objp)
+{
+;
+
+     if (!xdr_rpc_uint32 (xdrs, &objp->toolvers))
+         return FALSE;
+     if (!xdr_rpc_uint32 (xdrs, &objp->features))
+         return FALSE;
+     if (!xdr_rpc_uint32 (xdrs, &objp->proghash))
+         return FALSE;
+     if (!xdr_rpc_uint32 (xdrs, &objp->cbproghash))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_open_rets (XDR *xdrs, rpc_loc_open_rets *objp)
+{
+;
+
+     if (!xdr_rpc_loc_client_handle_type (xdrs, &objp->loc_open_result))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_close_rets (XDR *xdrs, rpc_loc_close_rets *objp)
+{
+;
+
+     if (!xdr_rpc_int32 (xdrs, &objp->loc_close_result))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_start_fix_rets (XDR *xdrs, rpc_loc_start_fix_rets *objp)
+{
+;
+
+     if (!xdr_rpc_int32 (xdrs, &objp->loc_start_fix_result))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_stop_fix_rets (XDR *xdrs, rpc_loc_stop_fix_rets *objp)
+{
+;
+
+     if (!xdr_rpc_int32 (xdrs, &objp->loc_stop_fix_result))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ioctl_rets (XDR *xdrs, rpc_loc_ioctl_rets *objp)
+{
+;
+
+     if (!xdr_rpc_int32 (xdrs, &objp->loc_ioctl_result))
+         return FALSE;
+    return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_api_api_versions_rets (XDR *xdrs, rpc_loc_api_api_versions_rets *objp)
+{
+;
+
+     if (!xdr_rpc_loc_api_api_versions_return_type (xdrs, &objp->loc_api_api_versions_result))
+         return FALSE;
+     if (!xdr_pointer (xdrs, (char **)&objp->len, sizeof (rpc_uint32), (xdrproc_t) xdr_rpc_uint32))
+         return FALSE;
+    return TRUE;
+}
diff --git a/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/src/loc_apicb_appinit.c b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/src/loc_apicb_appinit.c
new file mode 100644
index 0000000..b469eb0
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/src/loc_apicb_appinit.c
@@ -0,0 +1,74 @@
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include "librpc.h"
+#include "loc_api_rpcgen_rpc.h"
+#include "loc_api_rpcgen_cb_rpc.h"
+
+
+#define RPC_FUNC_VERSION_BASE(a,b) a ## b
+#define RPC_CB_FUNC_VERS(a,b) RPC_FUNC_VERSION_BASE(a,b)
+
+
+static SVCXPRT* svrPort = NULL;
+
+extern void RPC_CB_FUNC_VERS(loc_apicbprog_,LOC_APICBVERS_0001)(struct svc_req *rqstp, register SVCXPRT *transp);
+
+int loc_apicb_app_init(void)
+{
+
+  /* Register a callback server to use the loc_apicbprog_0x00010001  */
+  if (svrPort == NULL) {
+        svrPort = svcrtr_create();
+  }
+  if (!svrPort) return -1;
+
+  xprt_register(svrPort);
+
+
+
+  if(svc_register(svrPort, LOC_APICBPROG,LOC_APICBVERS_0001, RPC_CB_FUNC_VERS(loc_apicbprog_,LOC_APICBVERS_0001),0))
+  {
+     return 0;
+  }
+  else
+  {
+    return -1;
+  }
+}
+void loc_apicb_app_deinit(void)
+{
+
+   if (svrPort == NULL)
+   {
+      return;
+   }
+
+
+  svc_unregister(svrPort, LOC_APICBPROG,LOC_APICBVERS_0001);
+}
diff --git a/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/xdr/loc_api.xdr b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/xdr/loc_api.xdr
new file mode 100644
index 0000000..82dca56
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/xdr/loc_api.xdr
@@ -0,0 +1,261 @@
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+/* LOC_API TOOL VERSION: 4.48 */
+/* GENERATED: TUE JUN 14 2011 */
+/*=============================================================================
+                             L O C _ A P I . X D R
+
+GENERAL DESCRIPTION
+  This is an AUTO GENERATED file that provides an xdr compatible definition of
+  the loc_api API.
+
+  ---------------------------------------------------------------------------
+
+
+  ---------------------------------------------------------------------------
+=============================================================================*/
+
+/*=============================================================================
+
+                              Edit History
+
+                             AUTO GENERATED
+
+Generated by following versions of Htorpc modules:
+Id: //source/qcom/qct/core/mproc/tools/rel/2h09/htorpc/htorpc.pl#1
+Id: //source/qcom/qct/core/mproc/tools/rel/2h09/htorpc/lib/Htorpc/Start.pm#1
+Id: //source/qcom/qct/core/mproc/tools/rel/2h09/htorpc/lib/Htorpc/Htoxdr.pm#1
+Id: //source/qcom/qct/core/mproc/tools/rel/2h09/htorpc/lib/Htorpc/XDR.pm#3
+Id: //source/qcom/qct/core/mproc/tools/rel/2h09/htorpc/lib/Htorpc/Output.pm#5
+Id: //source/qcom/qct/core/mproc/tools/rel/2h09/htorpc/lib/Htorpc/Parser.pm#1
+Id: //source/qcom/qct/core/mproc/tools/rel/2h09/htorpc/lib/Htorpc/Metacomments.pm#1
+Id: //source/qcom/qct/core/mproc/tools/rel/2h09/htorpc/lib/Htorpc/SymbolTable.pm#1
+
+loc_api Definition File(s):
+Id: //source/qcom/qct/modem/api/gps/main/latest/loc_api.h#24
+=============================================================================*/
+/*=============================================================================
+$Header$
+=============================================================================*/
+
+
+
+typedef rpc_uint32 rpc_loc_api_api_versions_return_type<>;
+
+/*
+ * Declare an rpc_uint32 type for each callback type in the API
+ */
+typedef rpc_uint32 rpc_loc_event_cb_f_type;
+
+
+
+/*
+ * These are struct declarations for the function arguments
+ */
+
+struct rpc_loc_open_args {
+  rpc_loc_event_mask_type event_reg_mask;
+  rpc_loc_event_cb_f_type event_callback;
+};
+
+struct rpc_loc_close_args {
+  rpc_loc_client_handle_type handle;
+};
+
+struct rpc_loc_start_fix_args {
+  rpc_loc_client_handle_type handle;
+};
+
+struct rpc_loc_stop_fix_args {
+  rpc_loc_client_handle_type handle;
+};
+
+struct rpc_loc_ioctl_args {
+  rpc_loc_client_handle_type handle;
+  rpc_loc_ioctl_e_type ioctl_type;
+  rpc_loc_ioctl_data_u_type *ioctl_data;
+};
+
+
+
+struct rpc_loc_api_api_version_s_args {
+  rpc_boolean len_not_null;
+};
+
+/*
+ * These are struct declarations for the function results
+ */
+
+struct rpc_loc_api_rpc_glue_code_info_remote_rets {
+  rpc_uint32 toolvers;   /* Tool version */
+  rpc_uint32 features;   /* Features turned on in the code.
+                          * 0x00000001    ONCRPC Server Cleanup Support
+                          */
+  rpc_uint32 proghash;   /* Unique hash value for the API XDR definition */
+  rpc_uint32 cbproghash; /* Unique hash value for the Callbacks' XDR definition */
+};
+
+struct rpc_loc_open_rets {
+  rpc_loc_client_handle_type loc_open_result;
+};
+
+struct rpc_loc_close_rets {
+  rpc_int32 loc_close_result;
+};
+
+struct rpc_loc_start_fix_rets {
+  rpc_int32 loc_start_fix_result;
+};
+
+struct rpc_loc_stop_fix_rets {
+  rpc_int32 loc_stop_fix_result;
+};
+
+struct rpc_loc_ioctl_rets {
+  rpc_int32 loc_ioctl_result;
+};
+
+ struct rpc_loc_api_api_versions_rets {
+  rpc_loc_api_api_versions_return_type loc_api_api_versions_result;
+  rpc_uint32 *len;
+};
+
+/*
+ * XDR definition of the LOC_API program ( vers. 0x00050006 )
+ */
+
+program LOC_APIPROG {
+  version LOC_APIVERS_0001 {
+
+	void
+		rpc_loc_api_null( void ) = 0;
+
+	rpc_loc_api_rpc_glue_code_info_remote_rets
+		rpc_loc_api_rpc_glue_code_info_remote( void ) = 1;
+
+	rpc_loc_open_rets
+		rpc_loc_open( rpc_loc_open_args ) = 2;
+
+	rpc_loc_close_rets
+		rpc_loc_close( rpc_loc_close_args ) = 3;
+
+	rpc_loc_start_fix_rets
+		rpc_loc_start_fix( rpc_loc_start_fix_args ) = 4;
+
+	rpc_loc_stop_fix_rets
+		rpc_loc_stop_fix( rpc_loc_stop_fix_args ) = 5;
+
+	rpc_loc_ioctl_rets
+		rpc_loc_ioctl( rpc_loc_ioctl_args ) = 6;
+
+	rpc_loc_api_api_versions_rets
+		rpc_loc_api_api_versions( void ) = 0xFFFFFFFF;
+
+
+
+
+  } = 0x00050001;
+
+version LOC_APIVERS_0002 {
+
+/* Following elements added in enum rpc_loc_assist_data_request_e_type in 0x00050002
+RPC_LOC_ASSIST_DATA_POSITION_INJECTION_REQ
+*/
+/* Following elements added in enum rpc_loc_ioctl_e_type in 0x00050002
+RPC_LOC_IOCTL_GET_XTRA_T_SESSION_CONTROL
+RPC_LOC_IOCTL_RESERVED_CMD
+RPC_LOC_IOCTL_SET_XTRA_T_SESSION_CONTROL
+*/
+
+	void
+	rpc_loc_api_null( void ) = 0;
+
+      } = 0x00050002;
+
+version LOC_APIVERS_0003 {
+
+/* Following elements added in enum rpc_loc_ioctl_e_type in 0x00050003
+RPC_LOC_IOCTL_SET_DATA_ENABLE
+RPC_LOC_IOCTL_SET_LBS_APN_PROFILE
+RPC_LOC_IOCTL_GET_XTRA_APN_PROFILE
+RPC_LOC_IOCTL_GET_LBS_APN_PROFILE
+RPC_LOC_IOCTL_SET_XTRA_APN_PROFILE
+*/
+
+	void
+	rpc_loc_api_null( void ) = 0;
+
+      } = 0x00050003;
+
+version LOC_APIVERS_0004 {
+
+/* Following elements added in enum rpc_loc_ioctl_e_type in 0x00050004
+RPC_LOC_IOCTL_GET_SUPL_VERSION
+RPC_LOC_IOCTL_SET_SUPL_VERSION
+*/
+
+	void
+	rpc_loc_api_null( void ) = 0;
+
+      } = 0x00050004;
+
+version LOC_APIVERS_0005 {
+
+/* Following elements added in enum rpc_loc_server_addr_e_type in 0x00050005
+RPC_LOC_SERVER_ADDR_IPV6
+*/
+/* Following elements added in enum rpc_loc_ioctl_e_type in 0x00050005
+RPC_LOC_IOCTL_ERROR_ESTIMATE_CONFIG
+*/
+
+	void
+	rpc_loc_api_null( void ) = 0;
+
+      } = 0x00050005;
+
+
+
+    version LOC_APIVERS_0006 {
+
+/* Following elements added in enum rpc_loc_ioctl_e_type in 0x00050006
+RPC_LOC_IOCTL_INFORM_SERVER_MULTI_OPEN_STATUS
+*/
+/* Following elements added in enum rpc_loc_server_request_e_type in 0x00050006
+RPC_LOC_SERVER_REQUEST_MULTI_OPEN
+*/
+
+	void
+	rpc_loc_api_null( void ) = 0;
+
+      } = 0x00050006;
+
+
+} = 0x3000008C;
+
+const LOC_APIVERS = 0x00050006;
diff --git a/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/xdr/loc_api_cb.xdr b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/xdr/loc_api_cb.xdr
new file mode 100644
index 0000000..4756c6c
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/xdr/loc_api_cb.xdr
@@ -0,0 +1,187 @@
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+/* LOC_API TOOL VERSION: 4.48 */
+/* GENERATED: TUE JUN 14 2011 */
+/*=============================================================================
+                          L O C _ A P I _ C B . X D R
+
+GENERAL DESCRIPTION
+  This is an AUTO GENERATED file that provides an xdr compatible definition of
+  an api that represents the grouping of the different callback functions the
+  loc_api API supports.
+
+  ---------------------------------------------------------------------------
+
+
+  ---------------------------------------------------------------------------
+=============================================================================*/
+
+/*=============================================================================
+
+                              Edit History
+
+                             AUTO GENERATED
+
+Generated by following versions of Htorpc modules:
+Id: //source/qcom/qct/core/mproc/tools/rel/2h09/htorpc/htorpc.pl#1
+Id: //source/qcom/qct/core/mproc/tools/rel/2h09/htorpc/lib/Htorpc/Start.pm#1
+Id: //source/qcom/qct/core/mproc/tools/rel/2h09/htorpc/lib/Htorpc/Htoxdr.pm#1
+Id: //source/qcom/qct/core/mproc/tools/rel/2h09/htorpc/lib/Htorpc/XDR.pm#3
+Id: //source/qcom/qct/core/mproc/tools/rel/2h09/htorpc/lib/Htorpc/Output.pm#5
+Id: //source/qcom/qct/core/mproc/tools/rel/2h09/htorpc/lib/Htorpc/Parser.pm#1
+Id: //source/qcom/qct/core/mproc/tools/rel/2h09/htorpc/lib/Htorpc/Metacomments.pm#1
+Id: //source/qcom/qct/core/mproc/tools/rel/2h09/htorpc/lib/Htorpc/SymbolTable.pm#1
+
+loc_api Definition File(s):
+Id: //source/qcom/qct/modem/api/gps/main/latest/loc_api.h#24
+=============================================================================*/
+/*=============================================================================
+$Header$
+=============================================================================*/
+
+
+
+
+/*
+ * These are struct declarations for the function arguments
+ */
+
+struct rpc_loc_event_cb_f_type_args {
+  rpc_uint32 cb_id;
+  rpc_loc_client_handle_type loc_handle;
+  rpc_loc_event_mask_type loc_event;
+  rpc_loc_event_payload_u_type *loc_event_payload;
+};
+
+
+
+
+
+/*
+ * These are struct declaratios for the function results
+ */
+
+struct rpc_loc_event_cb_f_type_rets {
+  rpc_int32 loc_event_cb_f_type_result;
+};
+
+
+
+/*
+ * XDR definition of the LOC_API callback program ( vers. 0x00050006 )
+ */
+
+program LOC_APICBPROG {
+  version LOC_APICBVERS_0001 {
+
+	rpc_loc_event_cb_f_type_rets
+		rpc_loc_event_cb_f_type( rpc_loc_event_cb_f_type_args ) = 1;
+
+
+
+
+  } = 0x00050001;
+
+version LOC_APICBVERS_0002 {
+
+/* Following elements added in enum rpc_loc_assist_data_request_e_type in 0x00050002
+RPC_LOC_ASSIST_DATA_POSITION_INJECTION_REQ
+*/
+/* Following elements added in enum rpc_loc_ioctl_e_type in 0x00050002
+RPC_LOC_IOCTL_GET_XTRA_T_SESSION_CONTROL
+RPC_LOC_IOCTL_RESERVED_CMD
+RPC_LOC_IOCTL_SET_XTRA_T_SESSION_CONTROL
+*/
+
+	int
+	rpc_loc_api_cb_null( void ) = 0xffffff00;
+
+      } = 0x00050002;
+
+version LOC_APICBVERS_0003 {
+
+/* Following elements added in enum rpc_loc_ioctl_e_type in 0x00050003
+RPC_LOC_IOCTL_SET_DATA_ENABLE
+RPC_LOC_IOCTL_SET_LBS_APN_PROFILE
+RPC_LOC_IOCTL_GET_XTRA_APN_PROFILE
+RPC_LOC_IOCTL_GET_LBS_APN_PROFILE
+RPC_LOC_IOCTL_SET_XTRA_APN_PROFILE
+*/
+
+	int
+	rpc_loc_api_cb_null( void ) = 0xffffff00;
+
+      } = 0x00050003;
+
+version LOC_APICBVERS_0004 {
+
+/* Following elements added in enum rpc_loc_ioctl_e_type in 0x00050004
+RPC_LOC_IOCTL_GET_SUPL_VERSION
+RPC_LOC_IOCTL_SET_SUPL_VERSION
+*/
+
+	int
+	rpc_loc_api_cb_null( void ) = 0xffffff00;
+
+      } = 0x00050004;
+
+version LOC_APICBVERS_0005 {
+
+/* Following elements added in enum rpc_loc_server_addr_e_type in 0x00050005
+RPC_LOC_SERVER_ADDR_IPV6
+*/
+/* Following elements added in enum rpc_loc_ioctl_e_type in 0x00050005
+RPC_LOC_IOCTL_ERROR_ESTIMATE_CONFIG
+*/
+
+	int
+	rpc_loc_api_cb_null( void ) = 0xffffff00;
+
+      } = 0x00050005;
+
+
+
+    version LOC_APICBVERS_0006 {
+
+/* Following elements added in enum rpc_loc_ioctl_e_type in 0x00050006
+RPC_LOC_IOCTL_INFORM_SERVER_MULTI_OPEN_STATUS
+*/
+/* Following elements added in enum rpc_loc_server_request_e_type in 0x00050006
+RPC_LOC_SERVER_REQUEST_MULTI_OPEN
+*/
+
+	int
+	rpc_loc_api_cb_null( void ) = 0xffffff00;
+
+      } = 0x00050006;
+
+
+} = 0x3100008C;
+
+const LOC_APICBVERS = 0x00050006;
diff --git a/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/xdr/loc_api_common.xdr b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/xdr/loc_api_common.xdr
new file mode 100644
index 0000000..e059c66
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc-50001/libloc_api-rpc-stub/xdr/loc_api_common.xdr
@@ -0,0 +1,1021 @@
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+/* LOC_API TOOL VERSION: 4.48 */
+/* GENERATED: TUE JUN 14 2011 */
+/*=============================================================================
+                      L O C _ A P I _ C O M M O N . X D R
+
+GENERAL DESCRIPTION
+  This is an AUTO GENERATED file that provides an xdr compatible definition of
+  an api that represents the grouping of the different callback functions the
+  loc_api API supports.
+
+  ---------------------------------------------------------------------------
+
+
+  ---------------------------------------------------------------------------
+=============================================================================*/
+
+/*=============================================================================
+
+                              Edit History
+
+                             AUTO GENERATED
+
+Generated by following versions of Htorpc modules:
+Id: //source/qcom/qct/core/mproc/tools/rel/2h09/htorpc/htorpc.pl#1
+Id: //source/qcom/qct/core/mproc/tools/rel/2h09/htorpc/lib/Htorpc/Start.pm#1
+Id: //source/qcom/qct/core/mproc/tools/rel/2h09/htorpc/lib/Htorpc/Htoxdr.pm#1
+Id: //source/qcom/qct/core/mproc/tools/rel/2h09/htorpc/lib/Htorpc/XDR.pm#3
+Id: //source/qcom/qct/core/mproc/tools/rel/2h09/htorpc/lib/Htorpc/Output.pm#5
+Id: //source/qcom/qct/core/mproc/tools/rel/2h09/htorpc/lib/Htorpc/Parser.pm#1
+Id: //source/qcom/qct/core/mproc/tools/rel/2h09/htorpc/lib/Htorpc/Metacomments.pm#1
+Id: //source/qcom/qct/core/mproc/tools/rel/2h09/htorpc/lib/Htorpc/SymbolTable.pm#1
+
+loc_api Definition File(s):
+Id: //source/qcom/qct/modem/api/gps/main/latest/loc_api.h#24
+=============================================================================*/
+/*=============================================================================
+$Header$
+=============================================================================*/
+
+
+
+const LOC_API_TOOLVERS = 0x00040030;
+const LOC_API_FEATURES = 0x00000001;
+
+const RPC_LOC_EVENT_STATUS_REPORT = 0x00000100;
+
+const RPC_LOC_EVENT_ASSISTANCE_DATA_REQUEST = 0x00000020;
+
+const RPC_LOC_EVENT_WPS_NEEDED_REQUEST = 0x00000200;
+
+const RPC_LOC_EVENT_SATELLITE_REPORT = 0x00000002;
+
+const RPC_LOC_EVENT_PARSED_POSITION_REPORT = 0x00000001;
+
+const RPC_LOC_EVENT_RESERVED = 0x8000000000000000;
+
+const RPC_LOC_EVENT_LOCATION_SERVER_REQUEST = 0x00000040;
+
+const RPC_LOC_EVENT_NMEA_POSITION_REPORT = 0x00000008;
+
+const RPC_LOC_EVENT_IOCTL_REPORT = 0x00000080;
+
+const RPC_LOC_EVENT_NMEA_1HZ_REPORT = 0x00000004;
+
+const RPC_LOC_EVENT_NI_NOTIFY_VERIFY_REQUEST = 0x00000010;
+
+const RPC_LOC_API_CB_NULL_VERSION = 0x00050002;
+const RPC_LOC_EVENT_CB_F_TYPE_VERSION = 0x00050001;
+const RPC_LOC_API_API_VERSIONS_VERSION = 0x00050001;
+const RPC_LOC_STOP_FIX_VERSION = 0x00050001;
+const RPC_LOC_START_FIX_VERSION = 0x00050001;
+const RPC_LOC_IOCTL_VERSION = 0x00050001;
+const RPC_LOC_CLOSE_VERSION = 0x00050001;
+const RPC_LOC_API_RPC_GLUE_CODE_INFO_REMOTE_VERSION = 0x00050001;
+const RPC_LOC_OPEN_VERSION = 0x00050001;
+const RPC_LOC_API_NULL_VERSION = 0x00050001;
+const RPC_LOC_API_API_MAJOR_NUM = 0x0005;
+const RPC_LOC_APIAPI_VERSION_IS_HASHKEY = 0;
+
+typedef rpc_int32 rpc_loc_client_handle_type;
+
+typedef rpc_uint64 rpc_loc_event_mask_type;
+
+typedef rpc_uint64 rpc_loc_position_valid_mask_type;
+
+typedef rpc_uint32 rpc_loc_pos_technology_mask_type;
+
+enum rpc_loc_session_status_e_type {
+  RPC_LOC_SESS_STATUS_SUCCESS = 0,
+  RPC_LOC_SESS_STATUS_IN_PROGESS = 1,
+  RPC_LOC_SESS_STATUS_GENERAL_FAILURE = 2,
+  RPC_LOC_SESS_STATUS_TIMEOUT = 3,
+  RPC_LOC_SESS_STATUS_USER_END = 4,
+  RPC_LOC_SESS_STATUS_BAD_PARAMETER = 5,
+  RPC_LOC_SESS_STATUS_PHONE_OFFLINE = 6,
+  RPC_LOC_SESS_STATUS_ENGINE_LOCKED = 7,
+  RPC_LOC_SESS_STATUS_MAX = 268435456
+};
+
+struct rpc_loc_calendar_time_s_type {
+  rpc_uint16 year;
+  unsigned char month;
+  unsigned char day_of_week;
+  unsigned char day;
+  unsigned char hour;
+  unsigned char minute;
+  unsigned char second;
+  rpc_uint16 millisecond;
+};
+
+struct rpc_loc_parsed_position_s_type {
+  rpc_loc_position_valid_mask_type valid_mask;
+  rpc_loc_session_status_e_type session_status;
+  rpc_loc_calendar_time_s_type timestamp_calendar;
+  rpc_uint64 timestamp_utc;
+  rpc_uint8 leap_seconds;
+  float time_unc;
+  double latitude;
+  double longitude;
+  float altitude_wrt_ellipsoid;
+  float altitude_wrt_mean_sea_level;
+  float speed_horizontal;
+  float speed_vertical;
+  float heading;
+  float hor_unc_circular;
+  float hor_unc_ellipse_semi_major;
+  float hor_unc_ellipse_semi_minor;
+  float hor_unc_ellipse_orient_azimuth;
+  float vert_unc;
+  float speed_unc;
+  float heading_unc;
+  unsigned char confidence_horizontal;
+  unsigned char confidence_vertical;
+  float magnetic_deviation;
+  rpc_loc_pos_technology_mask_type technology_mask;
+};
+
+enum rpc_loc_sv_system_e_type {
+  RPC_LOC_SV_SYSTEM_GPS = 1,
+  RPC_LOC_SV_SYSTEM_GALILEO = 2,
+  RPC_LOC_SV_SYSTEM_SBAS = 3,
+  RPC_LOC_SV_SYSTEM_COMPASS = 4,
+  RPC_LOC_SV_SYSTEM_GLONASS = 5,
+  RPC_LOC_SV_SYSTEM_MAX = 268435456
+};
+
+enum rpc_loc_sv_status_e_type {
+  RPC_LOC_SV_STATUS_IDLE = 1,
+  RPC_LOC_SV_STATUS_SEARCH = 2,
+  RPC_LOC_SV_STATUS_TRACK = 3,
+  RPC_LOC_SV_STATUS_MAX = 268435456
+};
+
+typedef rpc_uint32 rpc_loc_sv_info_valid_mask_type;
+
+struct rpc_loc_sv_info_s_type {
+  rpc_loc_sv_info_valid_mask_type valid_mask;
+  rpc_loc_sv_system_e_type system;
+  rpc_uint8 prn;
+  rpc_uint8 health_status;
+  rpc_loc_sv_status_e_type process_status;
+  rpc_boolean has_eph;
+  rpc_boolean has_alm;
+  float elevation;
+  float azimuth;
+  float snr;
+};
+
+typedef rpc_uint32 rpc_loc_gnss_info_valid_mask_type;
+
+struct rpc_loc_gnss_info_s_type {
+  rpc_loc_gnss_info_valid_mask_type valid_mask;
+  float position_dop;
+  float horizontal_dop;
+  float vertical_dop;
+  rpc_boolean altitude_assumed;
+  rpc_uint16 sv_count;
+    rpc_loc_sv_info_s_type sv_list<80>; /* EVAL:[LOC_API_MAX_SV_COUNT]*/
+};
+
+struct rpc_loc_nmea_report_s_type {
+  rpc_uint16 length;
+  opaque nmea_sentences[200];
+};
+
+enum rpc_loc_status_event_e_type {
+  RPC_LOC_STATUS_EVENT_ENGINE_STATE = 1,
+  RPC_LOC_STATUS_EVENT_FIX_SESSION_STATE = 2,
+  RPC_LOC_STATUS_EVENT_MAX = 268435456
+};
+
+enum rpc_loc_engine_state_e_type {
+  RPC_LOC_ENGINE_STATE_ON = 1,
+  RPC_LOC_ENGINE_STATE_OFF = 2,
+  RPC_LOC_ENGINE_STATE_MAX = 268435456
+};
+
+enum rpc_loc_fix_session_state_e_type {
+  RPC_LOC_FIX_SESSION_STATE_BEGIN = 1,
+  RPC_LOC_FIX_SESSION_STATE_END = 2,
+  RPC_LOC_FIX_SESSION_STATE_MAX = 268435456
+};
+
+union rpc_loc_status_event_payload_u_type switch (rpc_loc_status_event_e_type disc) {
+  case RPC_LOC_STATUS_EVENT_ENGINE_STATE:
+    rpc_loc_engine_state_e_type engine_state;
+  case RPC_LOC_STATUS_EVENT_FIX_SESSION_STATE:
+    rpc_loc_fix_session_state_e_type fix_session_state;
+  default:
+    void;
+};
+
+struct rpc_loc_status_event_s_type {
+  rpc_loc_status_event_e_type event;
+  rpc_loc_status_event_payload_u_type payload;
+};
+
+enum rpc_loc_server_addr_e_type {
+  RPC_LOC_SERVER_ADDR_IPV4 = 1,
+  RPC_LOC_SERVER_ADDR_URL = 2,
+  RPC_LOC_SERVER_ADDR_IPV6 = 3,
+  RPC_LOC_SERVER_ADDR_MAX = 268435456
+};
+
+struct rpc_loc_server_addr_ipv4_type {
+  rpc_uint32 addr;
+  rpc_uint16 port;
+};
+
+struct rpc_loc_server_addr_url_type {
+  rpc_uint16 length;
+  opaque addr[256];
+};
+
+struct rpc_loc_server_addr_ipv6_type {
+  rpc_uint16 addr[8];
+  rpc_uint32 port;
+};
+
+union rpc_loc_server_addr_u_type switch (rpc_loc_server_addr_e_type disc) {
+  case RPC_LOC_SERVER_ADDR_IPV4:
+    rpc_loc_server_addr_ipv4_type ipv4;
+  case RPC_LOC_SERVER_ADDR_URL:
+    rpc_loc_server_addr_url_type url;
+  case RPC_LOC_SERVER_ADDR_IPV6:
+    rpc_loc_server_addr_ipv6_type ipv6;
+  default:
+    void;
+};
+
+struct rpc_loc_server_info_s_type {
+  rpc_loc_server_addr_e_type addr_type;
+  rpc_loc_server_addr_u_type addr_info;
+};
+
+enum rpc_loc_ni_notify_verify_e_type {
+  RPC_LOC_NI_USER_NO_NOTIFY_NO_VERIFY = 1,
+  RPC_LOC_NI_USER_NOTIFY_ONLY = 2,
+  RPC_LOC_NI_USER_NOTIFY_VERIFY_ALLOW_NO_RESP = 3,
+  RPC_LOC_NI_USER_NOTIFY_VERIFY_NOT_ALLOW_NO_RESP = 4,
+  RPC_LOC_NI_USER_PRIVACY_OVERRIDE = 5,
+  RPC_LOC_NI_USER_NOTIFY_VERITY_TYPE_MAX = 268435456
+};
+
+enum rpc_loc_ni_event_e_type {
+  RPC_LOC_NI_EVENT_VX_NOTIFY_VERIFY_REQ = 1,
+  RPC_LOC_NI_EVENT_SUPL_NOTIFY_VERIFY_REQ = 2,
+  RPC_LOC_NI_EVENT_UMTS_CP_NOTIFY_VERIFY_REQ = 3,
+  RPC_LOC_NI_EVENT_VX_SERVICE_INTERACTION_REQ = 4,
+  RPC_LOC_NI_EVENT_MAX = 268435456
+};
+
+enum rpc_loc_ni_datacoding_scheme_e_type {
+  RPC_LOC_NI_PRESUPL_ISO646IRV = 0,
+  RPC_LOC_NI_PRESUPL_ISO8859 = 1,
+  RPC_LOC_NI_PRESUPL_UTF8 = 2,
+  RPC_LOC_NI_PRESUPL_UTF16 = 3,
+  RPC_LOC_NI_PRESUPL_UCS2 = 4,
+  RPC_LOC_NI_PRESUPL_GSM_DEFAULT = 5,
+  RPC_LOC_NI_PRESUPL_SHIFT_JIS = 6,
+  RPC_LOC_NI_PRESUPL_JIS = 7,
+  RPC_LOC_NI_PRESUPL_EUC = 8,
+  RPC_LOC_NI_PRESUPL_GB2312 = 9,
+  RPC_LOC_NI_PRESUPL_CNS11643 = 10,
+  RPC_LOC_NI_PRESUPL_KSC1001 = 11,
+  RPC_LOC_NI_PRESUPL_ENCODING_UNKNOWN = 2147483647,
+  RPC_LOC_NI_SS_GERMAN = 12,
+  RPC_LOC_NI_SS_ENGLISH = 13,
+  RPC_LOC_NI_SS_ITALIAN = 14,
+  RPC_LOC_NI_SS_FRENCH = 15,
+  RPC_LOC_NI_SS_SPANISH = 16,
+  RPC_LOC_NI_SS_DUTCH = 17,
+  RPC_LOC_NI_SS_SWEDISH = 18,
+  RPC_LOC_NI_SS_DANISH = 19,
+  RPC_LOC_NI_SS_PORTUGUESE = 20,
+  RPC_LOC_NI_SS_FINNISH = 21,
+  RPC_LOC_NI_SS_NORWEGIAN = 22,
+  RPC_LOC_NI_SS_GREEK = 23,
+  RPC_LOC_NI_SS_TURKISH = 24,
+  RPC_LOC_NI_SS_HUNGARIAN = 25,
+  RPC_LOC_NI_SS_POLISH = 26,
+  RPC_LOC_NI_SS_LANGUAGE_UNSPEC = 27,
+  RPC_LOC_NI_SUPL_UTF8 = 28,
+  RPC_LOC_NI_SUPL_UCS2 = 29,
+  RPC_LOC_NI_SUPL_GSM_DEFAULT = 30,
+  RPC_LOC_NI_SUPL_ENCODING_UNKNOWN = 2147483647
+};
+
+enum rpc_loc_ni_vx_requester_id_encoding_scheme_e_type {
+  RPC_LOC_NI_VX_OCTET = 0,
+  RPC_LOC_NI_VX_EXN_PROTOCOL_MSG = 1,
+  RPC_LOC_NI_VX_ASCII = 2,
+  RPC_LOC_NI_VX_IA5 = 3,
+  RPC_LOC_NI_VX_UNICODE = 4,
+  RPC_LOC_NI_VX_SHIFT_JIS = 5,
+  RPC_LOC_NI_VX_KOREAN = 6,
+  RPC_LOC_NI_VX_LATIN_HEBREW = 7,
+  RPC_LOC_NI_VX_LATIN = 8,
+  RPC_LOC_NI_VX_GSM = 9,
+  RPC_LOC_NI_VX_ENCODING_TYPE_MAX = 268435456
+};
+
+enum rpc_loc_ni_vx_pos_mode_e_type {
+  RPC_LOC_VX_MS_ASSISTED_ONLY = 1,
+  RPC_LOC_VX_MS_BASED_ONLY = 2,
+  RPC_LOC_VX_MS_ASSISTED_PREF_MSBASED_ALLWD = 3,
+  RPC_LOC_VX_MS_BASED_PREF_ASSISTED_ALLWD = 4,
+  RPC_LOC_VX_POS_MODE_MAX = 268435456
+};
+
+struct rpc_loc_ni_vx_requester_id_s_type {
+  unsigned char requester_id_length;
+  opaque requester_id[200];
+};
+
+struct rpc_loc_ni_vx_notify_verify_req_s_type {
+  rpc_loc_ni_notify_verify_e_type notification_priv_type;
+  unsigned char pos_qos_incl;
+  unsigned char pos_qos;
+  rpc_uint32 num_fixes;
+  rpc_uint32 tbf;
+  rpc_loc_ni_vx_pos_mode_e_type pos_mode;
+  rpc_loc_ni_vx_requester_id_encoding_scheme_e_type encoding_scheme;
+  rpc_loc_ni_vx_requester_id_s_type requester_id;
+  rpc_uint16 user_resp_timer_val;
+};
+
+enum rpc_loc_ni_supl_pos_method_e_type {
+  RPC_LOC_NI_POSMETHOD_AGPS_SETASSISTED = 1,
+  RPC_LOC_NI_POSMETHOD_AGPS_SETBASED = 2,
+  RPC_LOC_NI_POSMETHOD_AGPS_SETASSISTED_PREF = 3,
+  RPC_LOC_NI_POSMETHOD_AGPS_SETBASED_PREF = 4,
+  RPC_LOC_NI_POSMETHOD_AUTONOMOUS_GPS = 5,
+  RPC_LOC_NI_POSMETHOD_AFLT = 6,
+  RPC_LOC_NI_POSMETHOD_ECID = 7,
+  RPC_LOC_NI_POSMETHOD_EOTD = 8,
+  RPC_LOC_NI_POSMETHOD_OTDOA = 9,
+  RPC_LOC_NI_POSMETHOD_NO_POSITION = 10,
+  RPC_LOC_NI_POSMETHOD_MAX = 268435456
+};
+
+struct rpc_loc_ni_supl_slp_session_id_s_type {
+  unsigned char presence;
+  opaque session_id[4];
+  rpc_loc_server_info_s_type slp_address;
+};
+
+struct rpc_loc_ni_requestor_id_s_type {
+  unsigned char data_coding_scheme;
+  opaque requestor_id_string[200];
+  unsigned char string_len;
+};
+
+struct rpc_loc_ni_supl_client_name_s_type {
+  unsigned char data_coding_scheme;
+  opaque client_name_string[64];
+  unsigned char string_len;
+};
+
+struct rpc_loc_ni_supl_qop_s_type {
+  unsigned char bit_mask;
+  unsigned char horacc;
+  unsigned char veracc;
+  rpc_uint16 maxLocAge;
+  unsigned char delay;
+};
+
+struct rpc_loc_ni_supl_notify_verify_req_s_type {
+  rpc_loc_ni_notify_verify_e_type notification_priv_type;
+  rpc_uint16 flags;
+  rpc_loc_ni_supl_slp_session_id_s_type supl_slp_session_id;
+  opaque supl_hash[8];
+  rpc_loc_ni_datacoding_scheme_e_type datacoding_scheme;
+  rpc_loc_ni_supl_pos_method_e_type pos_method;
+  rpc_loc_ni_requestor_id_s_type requestor_id;
+  rpc_loc_ni_supl_client_name_s_type client_name;
+  rpc_loc_ni_supl_qop_s_type supl_qop;
+  rpc_uint16 user_response_timer;
+};
+
+struct rpc_loc_ni_ext_client_address_s_type {
+  unsigned char ext_client_address_len;
+  opaque ext_client_address[20];
+};
+
+enum rpc_loc_ni_location_type_e_type {
+  RPC_LOC_NI_LOCATIONTYPE_CURRENT_LOCATION = 1,
+  RPC_LOC_NI_LOCATIONTYPE_CURRENT_OR_LAST_KNOWN_LOCATION = 2,
+  RPC_LOC_NI_LOCATIONTYPE_INITIAL_LOCATION = 3,
+  RPC_LOC_NI_LOCATIONTYPE_MAX = 268435456
+};
+
+struct rpc_loc_ni_deferred_location_s_type {
+  unsigned char unused_bits;
+  unsigned char ms_available;
+};
+
+struct rpc_loc_ni_codeword_string_s_type {
+  unsigned char data_coding_scheme;
+  opaque lcs_codeword_string[20];
+  unsigned char string_len;
+};
+
+struct rpc_loc_ni_service_type_id_s_type {
+  unsigned char lcs_service_type_id;
+};
+
+struct rpc_loc_ni_umts_cp_notify_verify_req_s_type {
+  rpc_loc_ni_notify_verify_e_type notification_priv_type;
+  unsigned char invoke_id;
+  rpc_uint16 flags;
+  unsigned char notification_length;
+  opaque notification_text[64];
+  rpc_loc_ni_datacoding_scheme_e_type datacoding_scheme;
+  rpc_loc_ni_ext_client_address_s_type ext_client_address_data;
+  rpc_loc_ni_location_type_e_type location_type;
+  rpc_loc_ni_deferred_location_s_type deferred_location;
+  rpc_loc_ni_requestor_id_s_type requestor_id;
+  rpc_loc_ni_codeword_string_s_type codeword_string;
+  rpc_loc_ni_service_type_id_s_type service_type_id;
+  rpc_uint16 user_response_timer;
+};
+
+enum rpc_loc_ni_service_interaction_e_type {
+  RPC_LOC_NI_SERVICE_INTERACTION_ONGOING_NI_INCOMING_MO = 1,
+  RPC_LOC_NI_SERVICE_INTERACTION_MAX = 268435456
+};
+
+struct rpc_loc_ni_vx_service_interaction_req_s_type {
+  rpc_loc_ni_vx_notify_verify_req_s_type ni_vx_req;
+  rpc_loc_ni_service_interaction_e_type service_interation_type;
+};
+
+union rpc_loc_ni_event_payload_u_type switch (rpc_loc_ni_event_e_type disc) {
+  case RPC_LOC_NI_EVENT_VX_NOTIFY_VERIFY_REQ:
+    rpc_loc_ni_vx_notify_verify_req_s_type vx_req;
+  case RPC_LOC_NI_EVENT_SUPL_NOTIFY_VERIFY_REQ:
+    rpc_loc_ni_supl_notify_verify_req_s_type supl_req;
+  case RPC_LOC_NI_EVENT_UMTS_CP_NOTIFY_VERIFY_REQ:
+    rpc_loc_ni_umts_cp_notify_verify_req_s_type umts_cp_req;
+  case RPC_LOC_NI_EVENT_VX_SERVICE_INTERACTION_REQ:
+    rpc_loc_ni_vx_service_interaction_req_s_type service_interaction_req;
+  default:
+    void;
+};
+
+struct rpc_loc_ni_event_s_type {
+  rpc_loc_ni_event_e_type event;
+  rpc_loc_ni_event_payload_u_type payload;
+};
+
+enum rpc_loc_assist_data_request_e_type {
+  RPC_LOC_ASSIST_DATA_TIME_REQ = 1,
+  RPC_LOC_ASSIST_DATA_PREDICTED_ORBITS_REQ = 2,
+  RPC_LOC_ASSIST_DATA_POSITION_INJECTION_REQ = 3,
+  RPC_LOC_ASSIST_DATA_MAX = 268435456
+};
+
+typedef string rpc_struct_loc_time_download_source_s_type_servers_ptr<256>; /* EVAL:[LOC_API_MAX_SERVER_ADDR_LENGTH]*/
+
+typedef rpc_struct_loc_time_download_source_s_type_servers_ptr rpc_struct_loc_time_download_source_s_type_servers[3];
+
+struct rpc_loc_time_download_source_s_type {
+  rpc_uint32 delay_threshold;
+  rpc_struct_loc_time_download_source_s_type_servers servers;
+};
+
+typedef string rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr<LOC_API_MAX_SERVER_ADDR_LENGTH>;
+
+typedef rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr rpc_struct_loc_predicted_orbits_data_source_s_type_servers[3];
+
+struct rpc_loc_predicted_orbits_data_source_s_type {
+  rpc_uint32 max_file_size;
+  rpc_uint32 max_part_size;
+  rpc_struct_loc_predicted_orbits_data_source_s_type_servers servers;
+};
+
+struct rpc_loc_pos_inj_request_s_type {
+  rpc_uint32 flags;
+  double latitude;
+  double longitude;
+  rpc_uint32 position_uncertainty;
+  rpc_uint64 timestamp;
+};
+
+union rpc_loc_assist_data_request_payload_u_type switch (rpc_loc_assist_data_request_e_type disc) {
+  case RPC_LOC_ASSIST_DATA_TIME_REQ:
+    rpc_loc_time_download_source_s_type time_download;
+  case RPC_LOC_ASSIST_DATA_PREDICTED_ORBITS_REQ:
+    rpc_loc_predicted_orbits_data_source_s_type data_download;
+  case RPC_LOC_ASSIST_DATA_POSITION_INJECTION_REQ:
+    rpc_loc_pos_inj_request_s_type pos_injection;
+  default:
+    void;
+};
+
+struct rpc_loc_assist_data_request_s_type {
+  rpc_loc_assist_data_request_e_type event;
+  rpc_loc_assist_data_request_payload_u_type payload;
+};
+
+typedef rpc_uint32 rpc_loc_server_connection_handle;
+
+enum rpc_loc_server_protocol_e_type {
+  RPC_LOC_SERVER_PROTOCOL_DEFAULT = 0,
+  RPC_LOC_SERVER_PROTOCOL_SUPL = 1,
+  RPC_LOC_SERVER_PROTOCOL_VX_MPC = 2,
+  RPC_LOC_SERVER_PROTOCOL_VX_PDE = 3,
+  RPC_LOC_SERVER_PROTOCOL_MAX = 16777216
+};
+
+enum rpc_loc_server_connection_e_type {
+  RPC_LOC_SERVER_CONNECTION_LBS = 0,
+  RPC_LOC_SERVER_CONNECTION_WWAN_INTERNET,
+  RPC_LOC_SERVER_CONNECTION_MAX = 16777216
+};
+
+enum rpc_loc_server_request_e_type {
+  RPC_LOC_SERVER_REQUEST_OPEN = 1,
+  RPC_LOC_SERVER_REQUEST_CLOSE = 2,
+  RPC_LOC_SERVER_REQUEST_MULTI_OPEN = 3,
+  RPC_LOC_SERVER_REQUEST_MAX = 268435456
+};
+
+struct rpc_loc_server_open_req_s_type {
+  rpc_loc_server_connection_handle conn_handle;
+  rpc_loc_server_protocol_e_type protocol;
+};
+
+struct rpc_loc_server_multi_open_req_s_type {
+  rpc_loc_server_connection_handle conn_handle;
+  rpc_loc_server_protocol_e_type protocol;
+  rpc_loc_server_connection_e_type connection_type;
+};
+
+struct rpc_loc_server_close_req_s_type {
+  rpc_loc_server_connection_handle conn_handle;
+};
+
+union rpc_loc_server_request_u_type switch (rpc_loc_server_request_e_type disc) {
+  case RPC_LOC_SERVER_REQUEST_OPEN:
+    rpc_loc_server_open_req_s_type open_req;
+  case RPC_LOC_SERVER_REQUEST_CLOSE:
+    rpc_loc_server_close_req_s_type close_req;
+  case RPC_LOC_SERVER_REQUEST_MULTI_OPEN:
+    rpc_loc_server_multi_open_req_s_type multi_open_req;
+  default:
+    void;
+};
+
+struct rpc_loc_server_request_s_type {
+  rpc_loc_server_request_e_type event;
+  rpc_loc_server_request_u_type payload;
+};
+
+enum rpc_loc_qwip_request_e_type {
+  RPC_LOC_QWIP_START_PERIODIC_HI_FREQ_FIXES = 0,
+  RPC_LOC_QWIP_START_PERIODIC_KEEP_WARM,
+  RPC_LOC_QWIP_STOP_PERIODIC_FIXES,
+  RPC_LOC_QWIP_SUSPEND,
+  RPC_LOC_QWIP_REQUEST_MAX = 268435456
+};
+
+struct rpc_loc_qwip_request_s_type {
+  rpc_loc_qwip_request_e_type request_type;
+  rpc_uint16 tbf_ms;
+};
+
+struct rpc_loc_reserved_payload_s_type {
+  rpc_uint16 data_size;
+  opaque data<>;
+};
+
+enum rpc_loc_ioctl_e_type {
+  RPC_LOC_IOCTL_GET_API_VERSION = 1,
+  RPC_LOC_IOCTL_SET_FIX_CRITERIA = 2,
+  RPC_LOC_IOCTL_GET_FIX_CRITERIA = 3,
+  RPC_LOC_IOCTL_SERVICE_START_INDEX = 400,
+  RPC_LOC_IOCTL_INFORM_NI_USER_RESPONSE = 400,
+  RPC_LOC_IOCTL_INJECT_PREDICTED_ORBITS_DATA = 401,
+  RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_VALIDITY = 402,
+  RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_SOURCE = 403,
+  RPC_LOC_IOCTL_SET_PREDICTED_ORBITS_DATA_AUTO_DOWNLOAD = 404,
+  RPC_LOC_IOCTL_INJECT_UTC_TIME = 405,
+  RPC_LOC_IOCTL_INJECT_RTC_VALUE = 406,
+  RPC_LOC_IOCTL_INJECT_POSITION = 407,
+  RPC_LOC_IOCTL_QUERY_ENGINE_STATE = 408,
+  RPC_LOC_IOCTL_INFORM_SERVER_OPEN_STATUS = 409,
+  RPC_LOC_IOCTL_INFORM_SERVER_CLOSE_STATUS = 410,
+  RPC_LOC_IOCTL_SEND_WIPER_POSITION_REPORT = 411,
+  RPC_LOC_IOCTL_NOTIFY_WIPER_STATUS = 412,
+  RPC_LOC_IOCTL_ACCESS_EFS_DATA = 413,
+  RPC_LOC_IOCTL_ERROR_ESTIMATE_CONFIG = 414,
+  RPC_LOC_IOCTL_INFORM_SERVER_MULTI_OPEN_STATUS = 415,
+  RPC_LOC_IOCTL_NV_SETTINGS_START_INDEX = 800,
+  RPC_LOC_IOCTL_SET_ENGINE_LOCK = 800,
+  RPC_LOC_IOCTL_GET_ENGINE_LOCK = 801,
+  RPC_LOC_IOCTL_SET_SBAS_CONFIG = 802,
+  RPC_LOC_IOCTL_GET_SBAS_CONFIG = 803,
+  RPC_LOC_IOCTL_SET_NMEA_TYPES = 804,
+  RPC_LOC_IOCTL_GET_NMEA_TYPES = 805,
+  RPC_LOC_IOCTL_SET_CDMA_PDE_SERVER_ADDR = 806,
+  RPC_LOC_IOCTL_GET_CDMA_PDE_SERVER_ADDR = 807,
+  RPC_LOC_IOCTL_SET_CDMA_MPC_SERVER_ADDR = 808,
+  RPC_LOC_IOCTL_GET_CDMA_MPC_SERVER_ADDR = 809,
+  RPC_LOC_IOCTL_SET_UMTS_SLP_SERVER_ADDR = 810,
+  RPC_LOC_IOCTL_GET_UMTS_SLP_SERVER_ADDR = 811,
+  RPC_LOC_IOCTL_SET_ON_DEMAND_LPM = 812,
+  RPC_LOC_IOCTL_GET_ON_DEMAND_LPM = 813,
+  RPC_LOC_IOCTL_SET_XTRA_T_SESSION_CONTROL = 814,
+  RPC_LOC_IOCTL_GET_XTRA_T_SESSION_CONTROL = 815,
+  RPC_LOC_IOCTL_SET_LBS_APN_PROFILE = 816,
+  RPC_LOC_IOCTL_GET_LBS_APN_PROFILE = 817,
+  RPC_LOC_IOCTL_SET_XTRA_APN_PROFILE = 818,
+  RPC_LOC_IOCTL_GET_XTRA_APN_PROFILE = 819,
+  RPC_LOC_IOCTL_SET_DATA_ENABLE = 820,
+  RPC_LOC_IOCTL_SET_SUPL_VERSION = 821,
+  RPC_LOC_IOCTL_GET_SUPL_VERSION = 822,
+  RPC_LOC_IOCTL_PROPRIETARY_START_INDEX = 1000,
+  RPC_LOC_IOCTL_DELETE_ASSIST_DATA = 1000,
+  RPC_LOC_IOCTL_SET_CUSTOM_PDE_SERVER_ADDR = 1001,
+  RPC_LOC_IOCTL_GET_CUSTOM_PDE_SERVER_ADDR = 1002,
+  RPC_LOC_IOCTL_RESERVED_CMD = 8000,
+  RPC_LOC_IOCTL_THIRD_PARTY_START_INDEX = 1073741824
+};
+
+struct rpc_loc_api_version_s_type {
+  unsigned char major;
+  unsigned char minor;
+};
+
+enum rpc_loc_fix_recurrence_e_type {
+  RPC_LOC_PERIODIC_FIX = 1,
+  RPC_LOC_SINGLE_FIX = 2,
+  RPC_LOC_FIX_SESSION_TYPE_MAX = 268435456
+};
+
+enum rpc_loc_operation_mode_e_type {
+  RPC_LOC_OPER_MODE_DEFAULT = 1,
+  RPC_LOC_OPER_MODE_MSB = 2,
+  RPC_LOC_OPER_MODE_MSA = 3,
+  RPC_LOC_OPER_MODE_STANDALONE = 4,
+  RPC_LOC_OPER_MODE_SPEED_OPTIMAL = 5,
+  RPC_LOC_OPER_MODE_ACCURACY_OPTIMAL = 6,
+  RPC_LOC_OPER_MODE_DATA_OPTIMAL = 7,
+  RPC_LOC_OPER_MODE_CELL_ID = 8,
+  RPC_LOC_OPER_MODE_MAX = 268435456
+};
+
+enum rpc_loc_notify_e_type {
+  RPC_LOC_NOTIFY_ON_INTERVAL = 1,
+  RPC_LOC_NOTIFY_ON_DISTANCE = 2,
+  RPC_LOC_NOTIFY_ON_ANY = 3,
+  RPC_LOC_NOTIFY_ON_ALL = 4,
+  RPC_LOC_NOTIFY_TYPE_MAX = 268435456
+};
+
+struct rpc_loc_fix_criteria_s_type {
+  rpc_uint32 valid_mask;
+  rpc_loc_fix_recurrence_e_type recurrence_type;
+  rpc_loc_operation_mode_e_type preferred_operation_mode;
+  rpc_uint32 preferred_accuracy;
+  rpc_uint32 preferred_response_time;
+  rpc_boolean intermediate_pos_report_enabled;
+  rpc_loc_notify_e_type notify_type;
+  rpc_uint32 min_interval;
+  float min_distance;
+  rpc_uint32 min_dist_sample_interval;
+};
+
+enum rpc_loc_ni_user_resp_e_type {
+  RPC_LOC_NI_LCS_NOTIFY_VERIFY_ACCEPT = 1,
+  RPC_LOC_NI_LCS_NOTIFY_VERIFY_DENY = 2,
+  RPC_LOC_NI_LCS_NOTIFY_VERIFY_NORESP = 3,
+  RPC_LOC_NI_LCS_NOTIFY_VERIFY_MAX = 268435456
+};
+
+struct rpc_loc_user_verify_s_type {
+  rpc_loc_ni_user_resp_e_type user_resp;
+  rpc_loc_ni_event_s_type ni_event_pass_back;
+};
+
+enum rpc_loc_predicted_orbits_data_format_e_type {
+  RPC_LOC_PREDICTED_ORBITS_XTRA = 0,
+  RPC_LOC_PREDICTED_ORBITS_FORMAT_MAX = 268435456
+};
+
+struct rpc_loc_predicted_orbits_data_s_type {
+  rpc_loc_predicted_orbits_data_format_e_type format_type;
+  rpc_uint32 total_size;
+  rpc_uint8 total_parts;
+  rpc_uint8 part;
+  rpc_uint16 part_len;
+  opaque data_ptr<>;
+};
+
+struct rpc_loc_predicted_orbits_data_validity_report_s_type {
+  rpc_uint64 start_time_utc;
+  rpc_uint16 valid_duration_hrs;
+};
+
+struct rpc_loc_predicted_orbits_auto_download_config_s_type {
+  rpc_boolean enable;
+  unsigned char auto_check_every_hrs;
+};
+
+struct rpc_loc_assist_data_time_s_type {
+  rpc_uint64 time_utc;
+  rpc_uint32 uncertainty;
+};
+
+typedef rpc_uint64 rpc_loc_assist_pos_valid_mask_type;
+
+struct rpc_loc_assist_data_pos_s_type {
+  rpc_loc_assist_pos_valid_mask_type valid_mask;
+  rpc_uint64 timestamp_utc;
+  double latitude;
+  double longitude;
+  float altitude_wrt_ellipsoid;
+  float altitude_wrt_mean_sea_level;
+  float hor_unc_circular;
+  float vert_unc;
+  unsigned char confidence_horizontal;
+  unsigned char confidence_vertical;
+  rpc_int32 timestamp_age;
+};
+
+enum rpc_loc_server_open_status_e_type {
+  RPC_LOC_SERVER_OPEN_SUCCESS = 1,
+  RPC_LOC_SERVER_OPEN_FAIL = 2,
+  RPC_LOC_SERVER_OPEN_STATUS_MAX = 268435456
+};
+
+enum rpc_loc_server_pdp_type_e_type {
+  RPC_LOC_SERVER_PDP_IP = 0,
+  RPC_LOC_SERVER_PDP_PPP,
+  RPC_LOC_SERVER_PDP_IPV6,
+  RPC_LOC_SERVER_PDP_IPV4V6,
+  RPC_LOC_SERVER_PDP_MAX = 268435456
+};
+
+struct rpc_loc_server_open_status_s_type {
+  rpc_loc_server_connection_handle conn_handle;
+  rpc_loc_server_open_status_e_type open_status;
+  opaque apn_name[100];
+};
+
+struct rpc_loc_server_multi_open_status_s_type {
+  rpc_loc_server_connection_handle conn_handle;
+  rpc_loc_server_open_status_e_type open_status;
+  rpc_loc_server_pdp_type_e_type pdp_type;
+  opaque apn_name[100];
+};
+
+enum rpc_loc_server_close_status_e_type {
+  RPC_LOC_SERVER_CLOSE_SUCCESS = 1,
+  RPC_LOC_SERVER_CLOSE_FAIL = 2,
+  RPC_LOC_SERVER_CLOSE_STATUS_MAX = 268435456
+};
+
+struct rpc_loc_server_close_status_s_type {
+  rpc_loc_server_connection_handle conn_handle;
+  rpc_loc_server_close_status_e_type close_status;
+};
+
+struct rpc_loc_wiper_fix_time_s_type {
+  rpc_uint32 slow_clock_count;
+};
+
+struct rpc_loc_wiper_fix_pos_s_type {
+  rpc_int32 lat;
+  rpc_int32 lon;
+  rpc_uint16 HEPE;
+  rpc_uint8 num_of_aps_used;
+  rpc_uint8 fix_error_code;
+};
+
+struct rpc_loc_wiper_ap_info_s_type {
+  opaque mac_addr[6];
+  rpc_int32 rssi;
+  rpc_uint16 channel;
+  rpc_uint8 ap_qualifier;
+};
+
+struct rpc_loc_wiper_ap_set_s_type {
+  rpc_uint8 num_of_aps;
+  rpc_loc_wiper_ap_info_s_type ap_info[50];
+};
+
+struct rpc_loc_wiper_position_report_s_type {
+  rpc_uint8 wiper_valid_info_flag;
+  rpc_loc_wiper_fix_time_s_type wiper_fix_time;
+  rpc_loc_wiper_fix_pos_s_type wiper_fix_position;
+  rpc_loc_wiper_ap_set_s_type wiper_ap_set;
+};
+
+enum rpc_loc_wiper_status_e_type {
+  RPC_LOC_WIPER_STATUS_AVAILABLE = 1,
+  RPC_LOC_WIPER_STATUS_UNAVAILABLE = 2,
+  RPC_LOC_WIPER_STATUS_E_SIZE = 268435456
+};
+
+enum rpc_loc_fs_operation_e_type {
+  RPC_LOC_FS_CREATE_WRITE_FILE = 1,
+  RPC_LOC_FS_APPEND_FILE = 2,
+  RPC_LOC_FS_DELETE_FILE = 3,
+  RPC_LOC_FS_READ_FILE = 4,
+  RPC_LOC_FS_MAX = 268435456
+};
+
+struct rpc_loc_efs_data_s_type {
+  opaque filename[64];
+  rpc_loc_fs_operation_e_type operation;
+  rpc_uint32 total_size;
+  opaque data_ptr<>;
+  rpc_uint32 part_len;
+  rpc_uint8 part;
+  rpc_uint8 total_parts;
+  rpc_uint32 reserved;
+};
+
+enum rpc_loc_error_estimate_config_e_type {
+  RPC_LOC_ERROR_ESTIMATE_CONFIG_SET = 1,
+  RPC_LOC_ERROR_ESTIMATE_CONFIG_CLEAR = 2,
+  RPC_LOC_ERROR_ESTIMATE_MAX = 268435456
+};
+
+struct rpc_loc_apn_profiles_type {
+  rpc_uint32 srv_system_type;
+  rpc_uint32 pdp_type;
+  rpc_uint32 reserved;
+  opaque apn_name[100];
+};
+
+enum rpc_loc_lock_e_type {
+  RPC_LOC_LOCK_NONE = 1,
+  RPC_LOC_LOCK_MI = 2,
+  RPC_LOC_LOCK_MT = 3,
+  RPC_LOC_LOCK_ALL = 4,
+  RPC_LOC_LOCK_MAX = 268435456
+};
+
+typedef rpc_uint32 rpc_loc_nmea_sentence_type;
+
+typedef rpc_uint32 rpc_loc_assist_data_type;
+
+struct rpc_loc_assist_data_delete_s_type {
+  rpc_loc_assist_data_type type;
+  rpc_uint32 reserved[8];
+};
+
+union rpc_loc_ioctl_data_u_type switch (rpc_loc_ioctl_e_type disc) {
+  case RPC_LOC_IOCTL_SET_FIX_CRITERIA:
+    rpc_loc_fix_criteria_s_type fix_criteria;
+  case RPC_LOC_IOCTL_INFORM_NI_USER_RESPONSE:
+    rpc_loc_user_verify_s_type user_verify_resp;
+  case RPC_LOC_IOCTL_INJECT_PREDICTED_ORBITS_DATA:
+    rpc_loc_predicted_orbits_data_s_type predicted_orbits_data;
+  case RPC_LOC_IOCTL_SET_PREDICTED_ORBITS_DATA_AUTO_DOWNLOAD:
+    rpc_loc_predicted_orbits_auto_download_config_s_type predicted_orbits_auto_download;
+  case RPC_LOC_IOCTL_INJECT_UTC_TIME:
+    rpc_loc_assist_data_time_s_type assistance_data_time;
+  case RPC_LOC_IOCTL_INJECT_POSITION:
+    rpc_loc_assist_data_pos_s_type assistance_data_position;
+  case RPC_LOC_IOCTL_INFORM_SERVER_OPEN_STATUS:
+    rpc_loc_server_open_status_s_type conn_open_status;
+  case RPC_LOC_IOCTL_INFORM_SERVER_CLOSE_STATUS:
+    rpc_loc_server_close_status_s_type conn_close_status;
+  case RPC_LOC_IOCTL_SEND_WIPER_POSITION_REPORT:
+    rpc_loc_wiper_position_report_s_type wiper_pos;
+  case RPC_LOC_IOCTL_NOTIFY_WIPER_STATUS:
+    rpc_loc_wiper_status_e_type wiper_status;
+  case RPC_LOC_IOCTL_SET_ENGINE_LOCK:
+    rpc_loc_lock_e_type engine_lock;
+  case RPC_LOC_IOCTL_SET_SBAS_CONFIG:
+    rpc_boolean sbas_mode;
+  case RPC_LOC_IOCTL_SET_NMEA_TYPES:
+    rpc_loc_nmea_sentence_type nmea_types;
+  case RPC_LOC_IOCTL_SET_ON_DEMAND_LPM:
+    rpc_boolean on_demand_lpm;
+  case  RPC_LOC_IOCTL_SET_CDMA_PDE_SERVER_ADDR:
+  case  RPC_LOC_IOCTL_SET_CDMA_MPC_SERVER_ADDR:
+  case  RPC_LOC_IOCTL_SET_UMTS_SLP_SERVER_ADDR:
+  case  RPC_LOC_IOCTL_SET_CUSTOM_PDE_SERVER_ADDR:
+    rpc_loc_server_info_s_type server_addr;
+  case RPC_LOC_IOCTL_DELETE_ASSIST_DATA:
+    rpc_loc_assist_data_delete_s_type assist_data_delete;
+  case RPC_LOC_IOCTL_ACCESS_EFS_DATA:
+    rpc_loc_efs_data_s_type efs_data;
+  case RPC_LOC_IOCTL_ERROR_ESTIMATE_CONFIG:
+    rpc_loc_error_estimate_config_e_type error_estimate_config;
+  case RPC_LOC_IOCTL_SET_XTRA_T_SESSION_CONTROL:
+    rpc_uint8 xtra_t_session_control;
+  case  RPC_LOC_IOCTL_SET_LBS_APN_PROFILE:
+  case  RPC_LOC_IOCTL_SET_XTRA_APN_PROFILE:
+    rpc_loc_apn_profiles_type apn_profiles[6];
+  case RPC_LOC_IOCTL_SET_DATA_ENABLE:
+    rpc_boolean data_enable;
+  case RPC_LOC_IOCTL_SET_SUPL_VERSION:
+    rpc_uint32 supl_version;
+  case RPC_LOC_IOCTL_INFORM_SERVER_MULTI_OPEN_STATUS:
+    rpc_loc_server_multi_open_status_s_type multi_conn_open_status;
+  case RPC_LOC_IOCTL_RESERVED_CMD:
+    rpc_loc_reserved_payload_s_type reserved;
+  default:
+    void;
+};
+
+union rpc_loc_ioctl_callback_data_u_type switch (rpc_loc_ioctl_e_type disc) {
+  case RPC_LOC_IOCTL_GET_API_VERSION:
+    rpc_loc_api_version_s_type api_version;
+  case RPC_LOC_IOCTL_GET_FIX_CRITERIA:
+    rpc_loc_fix_criteria_s_type fix_criteria;
+  case RPC_LOC_IOCTL_GET_ENGINE_LOCK:
+    rpc_loc_lock_e_type engine_lock;
+  case RPC_LOC_IOCTL_GET_SBAS_CONFIG:
+    rpc_boolean sbas_mode;
+  case RPC_LOC_IOCTL_GET_NMEA_TYPES:
+    rpc_loc_nmea_sentence_type nmea_types;
+  case RPC_LOC_IOCTL_GET_ON_DEMAND_LPM:
+    rpc_boolean on_demand_lpm;
+  case  RPC_LOC_IOCTL_GET_CDMA_PDE_SERVER_ADDR:
+  case  RPC_LOC_IOCTL_GET_CDMA_MPC_SERVER_ADDR:
+  case  RPC_LOC_IOCTL_GET_UMTS_SLP_SERVER_ADDR:
+  case  RPC_LOC_IOCTL_GET_CUSTOM_PDE_SERVER_ADDR:
+    rpc_loc_server_info_s_type server_addr;
+  case RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_SOURCE:
+    rpc_loc_predicted_orbits_data_source_s_type predicted_orbits_data_source;
+  case RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_VALIDITY:
+    rpc_loc_predicted_orbits_data_validity_report_s_type predicted_orbits_data_validity;
+  case RPC_LOC_IOCTL_GET_XTRA_T_SESSION_CONTROL:
+    rpc_uint8 xtra_t_session_control;
+  case  RPC_LOC_IOCTL_GET_LBS_APN_PROFILE:
+  case  RPC_LOC_IOCTL_GET_XTRA_APN_PROFILE:
+    rpc_loc_apn_profiles_type apn_profiles[6];
+  case RPC_LOC_IOCTL_GET_SUPL_VERSION:
+    rpc_uint32 supl_version;
+  default:
+    void;
+};
+
+struct rpc_loc_ioctl_callback_s_type {
+  rpc_loc_ioctl_e_type type;
+  rpc_int32 status;
+  rpc_loc_ioctl_callback_data_u_type data;
+};
+
+union rpc_loc_event_payload_u_type switch (unsigned hyper disc) {
+  case RPC_LOC_EVENT_PARSED_POSITION_REPORT:
+    rpc_loc_parsed_position_s_type parsed_location_report;
+  case RPC_LOC_EVENT_SATELLITE_REPORT:
+    rpc_loc_gnss_info_s_type gnss_report;
+  case RPC_LOC_EVENT_NMEA_POSITION_REPORT:
+  case RPC_LOC_EVENT_NMEA_1HZ_REPORT:
+    rpc_loc_nmea_report_s_type nmea_report;
+  case RPC_LOC_EVENT_NI_NOTIFY_VERIFY_REQUEST:
+    rpc_loc_ni_event_s_type ni_request;
+  case RPC_LOC_EVENT_ASSISTANCE_DATA_REQUEST:
+    rpc_loc_assist_data_request_s_type assist_data_request;
+  case RPC_LOC_EVENT_LOCATION_SERVER_REQUEST:
+    rpc_loc_server_request_s_type loc_server_request;
+  case RPC_LOC_EVENT_IOCTL_REPORT:
+    rpc_loc_ioctl_callback_s_type ioctl_report;
+  case RPC_LOC_EVENT_STATUS_REPORT:
+    rpc_loc_status_event_s_type status_report;
+  case RPC_LOC_EVENT_WPS_NEEDED_REQUEST:
+    rpc_loc_qwip_request_s_type qwip_request;
+  case RPC_LOC_EVENT_RESERVED:
+    rpc_loc_reserved_payload_s_type reserved;
+  default:
+    void;
+};
+
diff --git a/msm8974/loc_api/libloc_api-rpc/Android.mk b/msm8974/loc_api/libloc_api-rpc/Android.mk
new file mode 100644
index 0000000..06e4694
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/Android.mk
@@ -0,0 +1,61 @@
+ifneq ($(BUILD_TINY_ANDROID),true)
+
+ifneq ($(BOARD_VENDOR_QCOM_GPS_LOC_API_AMSS_VERSION),50001)
+
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+
+AMSS_VERSION:=$(BOARD_VENDOR_QCOM_GPS_LOC_API_AMSS_VERSION)
+RPC_INC:=inc-$(AMSS_VERSION)
+
+generated_files:= \
+	gen-$(AMSS_VERSION)/loc_api_clnt.c	\
+	gen-$(AMSS_VERSION)/loc_api_cb_xdr.c	\
+	gen-$(AMSS_VERSION)/loc_api_common_xdr.c \
+	gen-$(AMSS_VERSION)/loc_api_cb_svc.c \
+	gen-$(AMSS_VERSION)/loc_api_xdr.c \
+	gen-$(AMSS_VERSION)/loc_api_fixup.c \
+	gen-$(AMSS_VERSION)/loc_api_rpc_glue.c \
+	src/loc_apicb_appinit.c
+
+LOCAL_SRC_FILES:= $(generated_files)
+
+# removed from library build since the client should implement this code.
+#	src/loc_api_cb_server.c
+
+LOCAL_CFLAGS:=-fno-short-enums
+LOCAL_CFLAGS+=-include $(RPC_INC)/loc_api_common.h
+LOCAL_CFLAGS+=-DDEBUG
+# LOCAL_CFLAGS+=-DDEBUG -DVERBOSE
+
+LOCAL_CFLAGS+=-DADD_XDR_FLOAT -DADD_XDR_BOOL
+
+LOCAL_SHARED_LIBRARIES:= librpc
+LOCAL_STATIC_LIBRARIES:= libcommondefs-rpc
+
+
+
+LOCAL_COPY_HEADERS_TO:= libloc_api-rpc/inc
+LOCAL_COPY_HEADERS:= \
+	$(RPC_INC)/loc_api_cb.h \
+	$(RPC_INC)/loc_api_common.h \
+	$(RPC_INC)/loc_api.h \
+	$(RPC_INC)/loc_api_fixup.h \
+	$(RPC_INC)/loc_apicb_appinit.h \
+	inc/debug.h \
+	inc/loc_api_rpc_glue.h
+
+LOCAL_C_INCLUDES:= \
+	$(LOCAL_PATH) \
+	$(LOCAL_PATH)/inc \
+	$(LOCAL_PATH)/$(RPC_INC) \
+	$(TARGET_OUT_HEADERS)/libcommondefs-rpc \
+	$(TARGET_OUT_HEADERS)/librpc
+
+LOCAL_MODULE:= libloc_api-rpc
+LOCAL_MODULE_OWNER := qcom
+
+include $(BUILD_STATIC_LIBRARY)
+
+endif
+endif
diff --git a/msm8974/loc_api/libloc_api-rpc/gen-1240/Makefile.xdr b/msm8974/loc_api/libloc_api-rpc/gen-1240/Makefile.xdr
new file mode 100644
index 0000000..5d9cf6c
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/gen-1240/Makefile.xdr
@@ -0,0 +1,29 @@
+CLIENTS:= loc_api
+SERVERS:= loc_api_cb
+COMMON:= loc_api_common
+RPC_INC:= inc-$(AMSS_VERSION)
+
+all: $(CLIENTS) $(SERVERS) $(COMMON) fixup
+
+$(CLIENTS) $(SERVERS) $(COMMON):: xdr = $(@:=.xdr) 
+
+$(CLIENTS) $(SERVERS) $(COMMON)::
+	rpcgen -h -M $(xdr) -o ../$(RPC_INC)/$(addsuffix .h, $@)
+	rpcgen -c -M $(xdr) -o $(addsuffix _xdr.c, $@)
+
+$(CLIENTS)::
+	rpcgen -l -M $(xdr) -o $(addsuffix _clnt.c, $@)
+
+$(SERVERS)::
+	rpcgen -m -M $(xdr) -o $(addsuffix _svc.c, $@)
+
+fixup:
+	mv ../$(RPC_INC)/loc_api_common.h ../$(RPC_INC)/loc_api_common.h.bak
+	sed ../$(RPC_INC)/loc_api_common.h.bak -e "/#include <rpc/a#include \"loc_api_fixup.h\"" > ../$(RPC_INC)/loc_api_common.h
+	rm -f ../$(RPC_INC)/loc_api_common.h.bak
+
+clean:
+	rm -f $(addsuffix _clnt.c, $(CLIENTS))
+	rm -f $(addsuffix _svc.c, $(SERVERS))
+	rm -f $(addsuffix _xdr.c, $(CLIENTS) $(SERVERS) $(COMMON))
+	rm -f $(addprefix ../$(RPC_INC)/, $(addsuffix .h, $(CLIENTS) $(SERVERS) $(COMMON)))
diff --git a/msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api.xdr b/msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api.xdr
new file mode 100644
index 0000000..a9d60aa
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api.xdr
@@ -0,0 +1,172 @@
+/* LOC_API TOOL VERSION: 4.36 */
+/*=============================================================================
+                             L O C _ A P I . X D R
+
+GENERAL DESCRIPTION
+  This is an AUTO GENERATED file that provides an xdr compatible definition of
+  the loc_api API.
+
+  ---------------------------------------------------------------------------
+  Copyright (c) 2010 QUALCOMM Incorporated.
+  All Rights Reserved. QUALCOMM Proprietary and Confidential.
+  ---------------------------------------------------------------------------
+=============================================================================*/
+
+/*=============================================================================
+
+                              Edit History
+
+                             AUTO GENERATED
+
+Generated by following versions of Htorpc modules:
+Id: //source/qcom/qct/core/mproc/tools/rel/04.01/htorpc/htorpc.pl#20 
+Id: //source/qcom/qct/core/mproc/tools/rel/04.01/htorpc/lib/Htorpc/Start.pm#3 
+Id: //source/qcom/qct/core/mproc/tools/rel/04.01/htorpc/lib/Htorpc/Htoxdr.pm#1 
+Id: //source/qcom/qct/core/mproc/tools/rel/04.01/htorpc/lib/Htorpc/XDR.pm#7 
+Id: //source/qcom/qct/core/mproc/tools/rel/04.01/htorpc/lib/Htorpc/Output.pm#29 
+Id: //source/qcom/qct/core/mproc/tools/rel/04.01/htorpc/lib/Htorpc/Parser.pm#2 
+Id: //source/qcom/qct/core/mproc/tools/rel/04.01/htorpc/lib/Htorpc/Metacomments.pm#6 
+Id: //source/qcom/qct/core/mproc/tools/rel/04.01/htorpc/lib/Htorpc/SymbolTable.pm#3  
+
+loc_api Definition File(s):
+Id: //source/qcom/qct/modem/api/gps/main/latest/loc_api.h#16
+=============================================================================*/
+/*=============================================================================
+$Header$ 
+=============================================================================*/
+
+
+
+typedef rpc_uint32 rpc_loc_api_api_versions_return_type<>;
+
+/*
+ * Declare an rpc_uint32 type for each callback type in the API
+ */
+typedef rpc_uint32 rpc_loc_event_cb_f_type;
+
+
+
+/*
+ * These are struct declarations for the function arguments
+ */
+
+struct rpc_loc_open_args {
+  rpc_loc_event_mask_type event_reg_mask;
+  rpc_loc_event_cb_f_type event_callback;
+};
+
+struct rpc_loc_close_args {
+  rpc_loc_client_handle_type handle;
+};
+
+struct rpc_loc_start_fix_args {
+  rpc_loc_client_handle_type handle;
+};
+
+struct rpc_loc_stop_fix_args {
+  rpc_loc_client_handle_type handle;
+};
+
+struct rpc_loc_ioctl_args {
+  rpc_loc_client_handle_type handle;
+  rpc_loc_ioctl_e_type ioctl_type;
+  rpc_loc_ioctl_data_u_type *ioctl_data;
+};
+
+
+
+struct rpc_loc_api_api_version_s_args {
+  rpc_boolean len_not_null;
+};
+
+/*
+ * These are struct declarations for the function results
+ */
+
+struct rpc_loc_api_rpc_glue_code_info_remote_rets {
+  rpc_uint32 toolvers;   /* Tool version */
+  rpc_uint32 features;   /* Features turned on in the code.
+                          * 0x00000001    ONCRPC Server Cleanup Support
+                          */
+  rpc_uint32 proghash;   /* Unique hash value for the API XDR definition */
+  rpc_uint32 cbproghash; /* Unique hash value for the Callbacks' XDR definition */
+};
+
+struct rpc_loc_open_rets {
+  rpc_loc_client_handle_type loc_open_result;
+};
+
+struct rpc_loc_close_rets {
+  rpc_int32 loc_close_result;
+};
+
+struct rpc_loc_start_fix_rets {
+  rpc_int32 loc_start_fix_result;
+};
+
+struct rpc_loc_stop_fix_rets {
+  rpc_int32 loc_stop_fix_result;
+};
+
+struct rpc_loc_ioctl_rets {
+  rpc_int32 loc_ioctl_result;
+};
+
+ struct rpc_loc_api_api_versions_rets {
+  rpc_loc_api_api_versions_return_type loc_api_api_versions_result;
+  rpc_uint32 *len;
+};
+
+/*
+ * XDR definition of the LOC_API program ( vers. 0x00040002 )
+ */
+
+program LOC_APIPROG {
+  version LOC_APIVERS_0001 {
+
+	void
+		rpc_loc_api_null( void ) = 0;
+
+	rpc_loc_api_rpc_glue_code_info_remote_rets
+		rpc_loc_api_rpc_glue_code_info_remote( void ) = 1;
+
+	rpc_loc_open_rets
+		rpc_loc_open( rpc_loc_open_args ) = 2;
+
+	rpc_loc_close_rets
+		rpc_loc_close( rpc_loc_close_args ) = 3;
+
+	rpc_loc_start_fix_rets
+		rpc_loc_start_fix( rpc_loc_start_fix_args ) = 4;
+
+	rpc_loc_stop_fix_rets
+		rpc_loc_stop_fix( rpc_loc_stop_fix_args ) = 5;
+
+	rpc_loc_ioctl_rets
+		rpc_loc_ioctl( rpc_loc_ioctl_args ) = 6;
+
+	rpc_loc_api_api_versions_rets
+		rpc_loc_api_api_versions( void ) = 0xFFFFFFFF;
+
+
+
+
+  } = 0x00040001;
+
+
+
+    version LOC_APIVERS_0002 {
+
+/* Following elements added in enum rpc_loc_ni_event_e_type in 0x00040002 
+RPC_LOC_NI_EVENT_VX_SERVICE_INTERACTION_REQ
+*/
+
+	void
+	rpc_loc_api_null( void ) = 0;
+
+      } = 0x00040002;
+
+
+} = 0x3000008c;
+
+const LOC_APIVERS = 0x00040002;
diff --git a/msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_cb.xdr b/msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_cb.xdr
new file mode 100644
index 0000000..1bd4e15
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_cb.xdr
@@ -0,0 +1,85 @@
+/* LOC_API TOOL VERSION: 4.36 */
+/*=============================================================================
+                          L O C _ A P I _ C B . X D R
+
+GENERAL DESCRIPTION
+  This is an AUTO GENERATED file that provides an xdr compatible definition of
+  an api that represents the grouping of the different callback functions the
+  loc_api API supports.
+
+  ---------------------------------------------------------------------------
+  Copyright (c) 2010 QUALCOMM Incorporated.
+  All Rights Reserved. QUALCOMM Proprietary and Confidential.
+  ---------------------------------------------------------------------------
+=============================================================================*/
+
+/*=============================================================================
+
+                              Edit History
+
+                             AUTO GENERATED
+
+Generated by following versions of Htorpc modules:
+Id: //source/qcom/qct/core/mproc/tools/rel/04.01/htorpc/htorpc.pl#20 
+Id: //source/qcom/qct/core/mproc/tools/rel/04.01/htorpc/lib/Htorpc/Start.pm#3 
+Id: //source/qcom/qct/core/mproc/tools/rel/04.01/htorpc/lib/Htorpc/Htoxdr.pm#1 
+Id: //source/qcom/qct/core/mproc/tools/rel/04.01/htorpc/lib/Htorpc/XDR.pm#7 
+Id: //source/qcom/qct/core/mproc/tools/rel/04.01/htorpc/lib/Htorpc/Output.pm#29 
+Id: //source/qcom/qct/core/mproc/tools/rel/04.01/htorpc/lib/Htorpc/Parser.pm#2 
+Id: //source/qcom/qct/core/mproc/tools/rel/04.01/htorpc/lib/Htorpc/Metacomments.pm#6 
+Id: //source/qcom/qct/core/mproc/tools/rel/04.01/htorpc/lib/Htorpc/SymbolTable.pm#3  
+
+loc_api Definition File(s):
+Id: //source/qcom/qct/modem/api/gps/main/latest/loc_api.h#16
+=============================================================================*/
+/*=============================================================================
+$Header$ 
+=============================================================================*/
+
+
+
+
+/*
+ * These are struct declarations for the function arguments
+ */
+
+struct rpc_loc_event_cb_f_type_args {
+  rpc_uint32 cb_id;
+  rpc_loc_client_handle_type loc_handle;
+  rpc_loc_event_mask_type loc_event;
+  rpc_loc_event_payload_u_type *loc_event_payload;
+};
+
+
+
+
+
+/*
+ * These are struct declaratios for the function results
+ */
+
+struct rpc_loc_event_cb_f_type_rets {
+  rpc_int32 loc_event_cb_f_type_result;
+};
+
+
+
+/*
+ * XDR definition of the LOC_API callback program ( vers. 0x00040002 )
+ */
+
+program LOC_APICBPROG {
+  version LOC_APICBVERS_0001 {
+
+	rpc_loc_event_cb_f_type_rets
+		rpc_loc_event_cb_f_type( rpc_loc_event_cb_f_type_args ) = 1;
+
+
+
+
+  } = 0x00040001;
+
+
+} = 0x3100008c;
+
+const LOC_APICBVERS = 0x00040002;
diff --git a/msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_cb_svc.c b/msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_cb_svc.c
new file mode 100644
index 0000000..52a0d15
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_cb_svc.c
@@ -0,0 +1,64 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#include "loc_api_cb.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <rpc/pmap_clnt.h>
+#include <string.h>
+#include <memory.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+
+#ifndef SIG_PF
+#define SIG_PF void(*)(int)
+#endif
+
+void
+loc_apicbprog_0x00040001(struct svc_req *rqstp, register SVCXPRT *transp)
+{
+	union {
+		rpc_loc_event_cb_f_type_args rpc_loc_event_cb_f_type_0x00040001_arg;
+	} argument;
+	union {
+		rpc_loc_event_cb_f_type_rets rpc_loc_event_cb_f_type_0x00040001_res;
+	} result;
+	bool_t retval;
+	xdrproc_t _xdr_argument, _xdr_result;
+	bool_t (*local)(char *, void *, struct svc_req *);
+
+	switch (rqstp->rq_proc) {
+	case NULLPROC:
+		(void) svc_sendreply (transp, (xdrproc_t) xdr_void, (char *)NULL);
+		return;
+
+	case rpc_loc_event_cb_f_type:
+		_xdr_argument = (xdrproc_t) xdr_rpc_loc_event_cb_f_type_args;
+		_xdr_result = (xdrproc_t) xdr_rpc_loc_event_cb_f_type_rets;
+		local = (bool_t (*) (char *, void *,  struct svc_req *))rpc_loc_event_cb_f_type_0x00040001_svc;
+		break;
+
+	default:
+		svcerr_noproc (transp);
+		return;
+	}
+	memset ((char *)&argument, 0, sizeof (argument));
+	if (!svc_getargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
+		svcerr_decode (transp);
+		return;
+	}
+	retval = (bool_t) (*local)((char *)&argument, (void *)&result, rqstp);
+	if (retval > 0 && !svc_sendreply(transp, (xdrproc_t) _xdr_result, (char *)&result)) {
+		svcerr_systemerr (transp);
+	}
+	if (!svc_freeargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
+		fprintf (stderr, "%s", "unable to free arguments");
+		exit (1);
+	}
+	if (!loc_apicbprog_0x00040001_freeresult (transp, _xdr_result, (caddr_t) &result))
+		fprintf (stderr, "%s", "unable to free results");
+
+	return;
+}
diff --git a/msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_cb_xdr.c b/msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_cb_xdr.c
new file mode 100644
index 0000000..1d7795e
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_cb_xdr.c
@@ -0,0 +1,32 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#include "loc_api_cb.h"
+
+bool_t
+xdr_rpc_loc_event_cb_f_type_args (XDR *xdrs, rpc_loc_event_cb_f_type_args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint32 (xdrs, &objp->cb_id))
+		 return FALSE;
+	 if (!xdr_rpc_loc_client_handle_type (xdrs, &objp->loc_handle))
+		 return FALSE;
+	 if (!xdr_rpc_loc_event_mask_type (xdrs, &objp->loc_event))
+		 return FALSE;
+	 if (!xdr_pointer (xdrs, (char **)&objp->loc_event_payload, sizeof (rpc_loc_event_payload_u_type), (xdrproc_t) xdr_rpc_loc_event_payload_u_type))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_event_cb_f_type_rets (XDR *xdrs, rpc_loc_event_cb_f_type_rets *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_int32 (xdrs, &objp->loc_event_cb_f_type_result))
+		 return FALSE;
+	return TRUE;
+}
diff --git a/msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_clnt.c b/msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_clnt.c
new file mode 100644
index 0000000..dca1e8d
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_clnt.c
@@ -0,0 +1,91 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#include <memory.h> /* for memset */
+#include "loc_api.h"
+
+/* Default timeout can be changed using clnt_control() */
+static struct timeval TIMEOUT = { 25, 0 };
+
+enum clnt_stat 
+rpc_loc_api_null_0x00040001(void *argp, void *clnt_res, CLIENT *clnt)
+{
+	return (clnt_call(clnt, rpc_loc_api_null,
+		(xdrproc_t) xdr_void, (caddr_t) argp,
+		(xdrproc_t) xdr_void, (caddr_t) clnt_res,
+		TIMEOUT));
+}
+
+enum clnt_stat 
+rpc_loc_api_rpc_glue_code_info_remote_0x00040001(void *argp, rpc_loc_api_rpc_glue_code_info_remote_rets *clnt_res, CLIENT *clnt)
+{
+	return (clnt_call(clnt, rpc_loc_api_rpc_glue_code_info_remote,
+		(xdrproc_t) xdr_void, (caddr_t) argp,
+		(xdrproc_t) xdr_rpc_loc_api_rpc_glue_code_info_remote_rets, (caddr_t) clnt_res,
+		TIMEOUT));
+}
+
+enum clnt_stat 
+rpc_loc_open_0x00040001(rpc_loc_open_args *argp, rpc_loc_open_rets *clnt_res, CLIENT *clnt)
+{
+	return (clnt_call(clnt, rpc_loc_open,
+		(xdrproc_t) xdr_rpc_loc_open_args, (caddr_t) argp,
+		(xdrproc_t) xdr_rpc_loc_open_rets, (caddr_t) clnt_res,
+		TIMEOUT));
+}
+
+enum clnt_stat 
+rpc_loc_close_0x00040001(rpc_loc_close_args *argp, rpc_loc_close_rets *clnt_res, CLIENT *clnt)
+{
+	return (clnt_call(clnt, rpc_loc_close,
+		(xdrproc_t) xdr_rpc_loc_close_args, (caddr_t) argp,
+		(xdrproc_t) xdr_rpc_loc_close_rets, (caddr_t) clnt_res,
+		TIMEOUT));
+}
+
+enum clnt_stat 
+rpc_loc_start_fix_0x00040001(rpc_loc_start_fix_args *argp, rpc_loc_start_fix_rets *clnt_res, CLIENT *clnt)
+{
+	return (clnt_call(clnt, rpc_loc_start_fix,
+		(xdrproc_t) xdr_rpc_loc_start_fix_args, (caddr_t) argp,
+		(xdrproc_t) xdr_rpc_loc_start_fix_rets, (caddr_t) clnt_res,
+		TIMEOUT));
+}
+
+enum clnt_stat 
+rpc_loc_stop_fix_0x00040001(rpc_loc_stop_fix_args *argp, rpc_loc_stop_fix_rets *clnt_res, CLIENT *clnt)
+{
+	return (clnt_call(clnt, rpc_loc_stop_fix,
+		(xdrproc_t) xdr_rpc_loc_stop_fix_args, (caddr_t) argp,
+		(xdrproc_t) xdr_rpc_loc_stop_fix_rets, (caddr_t) clnt_res,
+		TIMEOUT));
+}
+
+enum clnt_stat 
+rpc_loc_ioctl_0x00040001(rpc_loc_ioctl_args *argp, rpc_loc_ioctl_rets *clnt_res, CLIENT *clnt)
+{
+	return (clnt_call(clnt, rpc_loc_ioctl,
+		(xdrproc_t) xdr_rpc_loc_ioctl_args, (caddr_t) argp,
+		(xdrproc_t) xdr_rpc_loc_ioctl_rets, (caddr_t) clnt_res,
+		TIMEOUT));
+}
+
+enum clnt_stat 
+rpc_loc_api_api_versions_0x00040001(void *argp, rpc_loc_api_api_versions_rets *clnt_res, CLIENT *clnt)
+{
+	return (clnt_call(clnt, rpc_loc_api_api_versions,
+		(xdrproc_t) xdr_void, (caddr_t) argp,
+		(xdrproc_t) xdr_rpc_loc_api_api_versions_rets, (caddr_t) clnt_res,
+		TIMEOUT));
+}
+
+enum clnt_stat 
+rpc_loc_api_null_0x00040002(void *argp, void *clnt_res, CLIENT *clnt)
+{
+	return (clnt_call(clnt, rpc_loc_api_null,
+		(xdrproc_t) xdr_void, (caddr_t) argp,
+		(xdrproc_t) xdr_void, (caddr_t) clnt_res,
+		TIMEOUT));
+}
diff --git a/msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_common.xdr b/msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_common.xdr
new file mode 100644
index 0000000..4e01607
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_common.xdr
@@ -0,0 +1,906 @@
+/* LOC_API TOOL VERSION: 4.36 */
+/*=============================================================================
+                      L O C _ A P I _ C O M M O N . X D R
+
+GENERAL DESCRIPTION
+  This is an AUTO GENERATED file that provides an xdr compatible definition of
+  an api that represents the grouping of the different callback functions the
+  loc_api API supports.
+
+  ---------------------------------------------------------------------------
+  Copyright (c) 2010 QUALCOMM Incorporated.
+  All Rights Reserved. QUALCOMM Proprietary and Confidential.
+  ---------------------------------------------------------------------------
+=============================================================================*/
+
+/*=============================================================================
+
+                              Edit History
+
+                             AUTO GENERATED
+
+Generated by following versions of Htorpc modules:
+Id: //source/qcom/qct/core/mproc/tools/rel/04.01/htorpc/htorpc.pl#20 
+Id: //source/qcom/qct/core/mproc/tools/rel/04.01/htorpc/lib/Htorpc/Start.pm#3 
+Id: //source/qcom/qct/core/mproc/tools/rel/04.01/htorpc/lib/Htorpc/Htoxdr.pm#1 
+Id: //source/qcom/qct/core/mproc/tools/rel/04.01/htorpc/lib/Htorpc/XDR.pm#7 
+Id: //source/qcom/qct/core/mproc/tools/rel/04.01/htorpc/lib/Htorpc/Output.pm#29 
+Id: //source/qcom/qct/core/mproc/tools/rel/04.01/htorpc/lib/Htorpc/Parser.pm#2 
+Id: //source/qcom/qct/core/mproc/tools/rel/04.01/htorpc/lib/Htorpc/Metacomments.pm#6 
+Id: //source/qcom/qct/core/mproc/tools/rel/04.01/htorpc/lib/Htorpc/SymbolTable.pm#3  
+
+loc_api Definition File(s):
+Id: //source/qcom/qct/modem/api/gps/main/latest/loc_api.h#16
+=============================================================================*/
+/*=============================================================================
+$Header$ 
+=============================================================================*/
+
+
+
+const LOC_API_TOOLVERS = 0x00040024;
+const LOC_API_FEATURES = 0x00000001;
+
+const RPC_LOC_EVENT_NI_NOTIFY_VERIFY_REQUEST = 0x00000010;
+
+const RPC_LOC_EVENT_WPS_NEEDED_REQUEST = 0x00000200;
+
+const RPC_LOC_EVENT_IOCTL_REPORT = 0x00000080;
+
+const RPC_LOC_EVENT_LOCATION_SERVER_REQUEST = 0x00000040;
+
+const RPC_LOC_EVENT_RESERVED = 0x8000000000000000;
+
+const RPC_LOC_EVENT_PARSED_POSITION_REPORT = 0x00000001;
+
+const RPC_LOC_EVENT_ASSISTANCE_DATA_REQUEST = 0x00000020;
+
+const RPC_LOC_EVENT_NMEA_POSITION_REPORT = 0x00000008;
+
+const RPC_LOC_EVENT_SATELLITE_REPORT = 0x00000002;
+
+const RPC_LOC_EVENT_STATUS_REPORT = 0x00000100;
+
+const RPC_LOC_EVENT_CB_F_TYPE_VERSION = 0x00040001;
+const RPC_LOC_OPEN_VERSION = 0x00040001;
+const RPC_LOC_API_RPC_GLUE_CODE_INFO_REMOTE_VERSION = 0x00040001;
+const RPC_LOC_API_NULL_VERSION = 0x00040001;
+const RPC_LOC_STOP_FIX_VERSION = 0x00040001;
+const RPC_LOC_IOCTL_VERSION = 0x00040001;
+const RPC_LOC_START_FIX_VERSION = 0x00040001;
+const RPC_LOC_CLOSE_VERSION = 0x00040001;
+const RPC_LOC_API_API_VERSIONS_VERSION = 0x00040001;
+const RPC_LOC_API_API_MAJOR_NUM = 0x0004;
+const RPC_LOC_APIAPI_VERSION_IS_HASHKEY = 0;
+
+typedef bool rpc_boolean;
+
+typedef unsigned long rpc_uint32;
+
+typedef unsigned short rpc_uint16;
+
+typedef unsigned char rpc_uint8;
+
+typedef long rpc_int32;
+
+typedef unsigned char rpc_byte;
+
+typedef unsigned hyper rpc_uint64;
+
+typedef rpc_int32 rpc_loc_client_handle_type;
+
+typedef rpc_uint64 rpc_loc_event_mask_type;
+
+typedef rpc_uint64 rpc_loc_position_valid_mask_type;
+
+typedef rpc_uint32 rpc_loc_pos_technology_mask_type;
+
+enum rpc_loc_session_status_e_type {
+  RPC_LOC_SESS_STATUS_SUCCESS = 0,
+  RPC_LOC_SESS_STATUS_IN_PROGESS = 1,
+  RPC_LOC_SESS_STATUS_GENERAL_FAILURE = 2,
+  RPC_LOC_SESS_STATUS_TIMEOUT = 3,
+  RPC_LOC_SESS_STATUS_USER_END = 4,
+  RPC_LOC_SESS_STATUS_BAD_PARAMETER = 5,
+  RPC_LOC_SESS_STATUS_PHONE_OFFLINE = 6,
+  RPC_LOC_SESS_STATUS_ENGINE_LOCKED = 7,
+  RPC_LOC_SESS_STATUS_MAX = 268435456
+};
+
+struct rpc_loc_calendar_time_s_type {
+  rpc_uint16 year;
+  unsigned char month;
+  unsigned char day_of_week;
+  unsigned char day;
+  unsigned char hour;
+  unsigned char minute;
+  unsigned char second;
+  rpc_uint16 millisecond;
+};
+
+struct rpc_loc_parsed_position_s_type {
+  rpc_loc_position_valid_mask_type valid_mask;
+  rpc_loc_session_status_e_type session_status;
+  rpc_loc_calendar_time_s_type timestamp_calendar;
+  rpc_uint64 timestamp_utc;
+  rpc_uint8 leap_seconds;
+  float time_unc;
+  double latitude;
+  double longitude;
+  float altitude_wrt_ellipsoid;
+  float altitude_wrt_mean_sea_level;
+  float speed_horizontal;
+  float speed_vertical;
+  float heading;
+  float hor_unc_circular;
+  float hor_unc_ellipse_semi_major;
+  float hor_unc_ellipse_semi_minor;
+  float hor_unc_ellipse_orient_azimuth;
+  float vert_unc;
+  float speed_unc;
+  float heading_unc;
+  unsigned char confidence_horizontal;
+  unsigned char confidence_vertical;
+  float magnetic_deviation;
+  rpc_loc_pos_technology_mask_type technology_mask;
+};
+
+enum rpc_loc_sv_system_e_type {
+  RPC_LOC_SV_SYSTEM_GPS = 1,
+  RPC_LOC_SV_SYSTEM_GALILEO = 2,
+  RPC_LOC_SV_SYSTEM_SBAS = 3,
+  RPC_LOC_SV_SYSTEM_COMPASS = 4,
+  RPC_LOC_SV_SYSTEM_GLONASS = 5,
+  RPC_LOC_SV_SYSTEM_MAX = 268435456
+};
+
+enum rpc_loc_sv_status_e_type {
+  RPC_LOC_SV_STATUS_IDLE = 1,
+  RPC_LOC_SV_STATUS_SEARCH = 2,
+  RPC_LOC_SV_STATUS_TRACK = 3,
+  RPC_LOC_SV_STATUS_MAX = 268435456
+};
+
+typedef rpc_uint32 rpc_loc_sv_info_valid_mask_type;
+
+struct rpc_loc_sv_info_s_type {
+  rpc_loc_sv_info_valid_mask_type valid_mask;
+  rpc_loc_sv_system_e_type system;
+  rpc_uint8 prn;
+  rpc_uint8 health_status;
+  rpc_loc_sv_status_e_type process_status;
+  rpc_boolean has_eph;
+  rpc_boolean has_alm;
+  float elevation;
+  float azimuth;
+  float snr;
+};
+
+typedef rpc_uint32 rpc_loc_gnss_info_valid_mask_type;
+
+struct rpc_loc_gnss_info_s_type {
+  rpc_loc_gnss_info_valid_mask_type valid_mask;
+  float position_dop;
+  float horizontal_dop;
+  float vertical_dop;
+  rpc_boolean altitude_assumed;
+  rpc_uint16 sv_count;
+    rpc_loc_sv_info_s_type sv_list<80>; /* EVAL:[LOC_API_MAX_SV_COUNT]*/  
+};
+
+struct rpc_loc_nmea_report_s_type {
+  rpc_uint16 length;
+    opaque nmea_sentences[1200]; /* EVAL:[1200]*/  
+};
+
+enum rpc_loc_status_event_e_type {
+  RPC_LOC_STATUS_EVENT_ENGINE_STATE = 1,
+  RPC_LOC_STATUS_EVENT_FIX_SESSION_STATE = 2,
+  RPC_LOC_STATUS_EVENT_MAX = 268435456
+};
+
+enum rpc_loc_engine_state_e_type {
+  RPC_LOC_ENGINE_STATE_ON = 1,
+  RPC_LOC_ENGINE_STATE_OFF = 2,
+  RPC_LOC_ENGINE_STATE_MAX = 268435456
+};
+
+enum rpc_loc_fix_session_state_e_type {
+  RPC_LOC_FIX_SESSION_STATE_BEGIN = 1,
+  RPC_LOC_FIX_SESSION_STATE_END = 2,
+  RPC_LOC_FIX_SESSION_STATE_MAX = 268435456
+};
+
+union rpc_loc_status_event_payload_u_type switch (rpc_loc_status_event_e_type disc) {
+  case RPC_LOC_STATUS_EVENT_ENGINE_STATE:
+    rpc_loc_engine_state_e_type engine_state;
+  case RPC_LOC_STATUS_EVENT_FIX_SESSION_STATE:
+    rpc_loc_fix_session_state_e_type fix_session_state;
+  default:
+    void;
+};
+
+struct rpc_loc_status_event_s_type {
+  rpc_loc_status_event_e_type event;
+  rpc_loc_status_event_payload_u_type payload;
+};
+
+enum rpc_loc_server_addr_e_type {
+  RPC_LOC_SERVER_ADDR_IPV4 = 1,
+  RPC_LOC_SERVER_ADDR_URL = 2,
+  RPC_LOC_SERVER_ADDR_MAX = 268435456
+};
+
+struct rpc_loc_server_addr_ipv4_type {
+  rpc_uint32 addr;
+  rpc_uint16 port;
+};
+
+struct rpc_loc_server_addr_url_type {
+  rpc_uint16 length;
+    opaque addr[256]; /* EVAL:[256]*/  
+};
+
+union rpc_loc_server_addr_u_type switch (rpc_loc_server_addr_e_type disc) {
+  case RPC_LOC_SERVER_ADDR_IPV4:
+    rpc_loc_server_addr_ipv4_type ipv4;
+  case RPC_LOC_SERVER_ADDR_URL:
+    rpc_loc_server_addr_url_type url;
+  default:
+    void;
+};
+
+struct rpc_loc_server_info_s_type {
+  rpc_loc_server_addr_e_type addr_type;
+  rpc_loc_server_addr_u_type addr_info;
+};
+
+enum rpc_loc_ni_notify_verify_e_type {
+  RPC_LOC_NI_USER_NO_NOTIFY_NO_VERIFY = 1,
+  RPC_LOC_NI_USER_NOTIFY_ONLY = 2,
+  RPC_LOC_NI_USER_NOTIFY_VERIFY_ALLOW_NO_RESP = 3,
+  RPC_LOC_NI_USER_NOTIFY_VERIFY_NOT_ALLOW_NO_RESP = 4,
+  RPC_LOC_NI_USER_PRIVACY_OVERRIDE = 5,
+  RPC_LOC_NI_USER_NOTIFY_VERITY_TYPE_MAX = 268435456
+};
+
+enum rpc_loc_ni_event_e_type {
+  RPC_LOC_NI_EVENT_VX_NOTIFY_VERIFY_REQ = 1,
+  RPC_LOC_NI_EVENT_SUPL_NOTIFY_VERIFY_REQ = 2,
+  RPC_LOC_NI_EVENT_UMTS_CP_NOTIFY_VERIFY_REQ = 3,
+  RPC_LOC_NI_EVENT_VX_SERVICE_INTERACTION_REQ = 4,
+  RPC_LOC_NI_EVENT_MAX = 268435456
+};
+
+enum rpc_loc_ni_datacoding_scheme_e_type {
+  RPC_LOC_NI_PRESUPL_ISO646IRV = 0,
+  RPC_LOC_NI_PRESUPL_ISO8859 = 1,
+  RPC_LOC_NI_PRESUPL_UTF8 = 2,
+  RPC_LOC_NI_PRESUPL_UTF16 = 3,
+  RPC_LOC_NI_PRESUPL_UCS2 = 4,
+  RPC_LOC_NI_PRESUPL_GSM_DEFAULT = 5,
+  RPC_LOC_NI_PRESUPL_SHIFT_JIS = 6,
+  RPC_LOC_NI_PRESUPL_JIS = 7,
+  RPC_LOC_NI_PRESUPL_EUC = 8,
+  RPC_LOC_NI_PRESUPL_GB2312 = 9,
+  RPC_LOC_NI_PRESUPL_CNS11643 = 10,
+  RPC_LOC_NI_PRESUPL_KSC1001 = 11,
+  RPC_LOC_NI_PRESUPL_ENCODING_UNKNOWN = 2147483647,
+  RPC_LOC_NI_SS_GERMAN = 12,
+  RPC_LOC_NI_SS_ENGLISH = 13,
+  RPC_LOC_NI_SS_ITALIAN = 14,
+  RPC_LOC_NI_SS_FRENCH = 15,
+  RPC_LOC_NI_SS_SPANISH = 16,
+  RPC_LOC_NI_SS_DUTCH = 17,
+  RPC_LOC_NI_SS_SWEDISH = 18,
+  RPC_LOC_NI_SS_DANISH = 19,
+  RPC_LOC_NI_SS_PORTUGUESE = 20,
+  RPC_LOC_NI_SS_FINNISH = 21,
+  RPC_LOC_NI_SS_NORWEGIAN = 22,
+  RPC_LOC_NI_SS_GREEK = 23,
+  RPC_LOC_NI_SS_TURKISH = 24,
+  RPC_LOC_NI_SS_HUNGARIAN = 25,
+  RPC_LOC_NI_SS_POLISH = 26,
+  RPC_LOC_NI_SS_LANGUAGE_UNSPEC = 27,
+  RPC_LOC_NI_SUPL_UTF8 = 28,
+  RPC_LOC_NI_SUPL_UCS2 = 29,
+  RPC_LOC_NI_SUPL_GSM_DEFAULT = 30,
+  RPC_LOC_NI_SUPL_ENCODING_UNKNOWN = 2147483647
+};
+
+enum rpc_loc_ni_vx_requester_id_encoding_scheme_e_type {
+  RPC_LOC_NI_VX_OCTET = 0,
+  RPC_LOC_NI_VX_EXN_PROTOCOL_MSG = 1,
+  RPC_LOC_NI_VX_ASCII = 2,
+  RPC_LOC_NI_VX_IA5 = 3,
+  RPC_LOC_NI_VX_UNICODE = 4,
+  RPC_LOC_NI_VX_SHIFT_JIS = 5,
+  RPC_LOC_NI_VX_KOREAN = 6,
+  RPC_LOC_NI_VX_LATIN_HEBREW = 7,
+  RPC_LOC_NI_VX_LATIN = 8,
+  RPC_LOC_NI_VX_GSM = 9,
+  RPC_LOC_NI_VX_ENCODING_TYPE_MAX = 268435456
+};
+
+enum rpc_loc_ni_vx_pos_mode_e_type {
+  RPC_LOC_VX_MS_ASSISTED_ONLY = 1,
+  RPC_LOC_VX_MS_BASED_ONLY = 2,
+  RPC_LOC_VX_MS_ASSISTED_PREF_MSBASED_ALLWD = 3,
+  RPC_LOC_VX_MS_BASED_PREF_ASSISTED_ALLWD = 4,
+  RPC_LOC_VX_POS_MODE_MAX = 268435456
+};
+
+struct rpc_loc_ni_vx_requester_id_s_type {
+  unsigned char requester_id_length;
+    opaque requester_id[200]; /* EVAL:[200]*/  
+};
+
+struct rpc_loc_ni_vx_notify_verify_req_s_type {
+  rpc_loc_ni_notify_verify_e_type notification_priv_type;
+  unsigned char pos_qos_incl;
+  unsigned char pos_qos;
+  rpc_uint32 num_fixes;
+  rpc_uint32 tbf;
+  rpc_loc_ni_vx_pos_mode_e_type pos_mode;
+  rpc_loc_ni_vx_requester_id_encoding_scheme_e_type encoding_scheme;
+  rpc_loc_ni_vx_requester_id_s_type requester_id;
+  rpc_uint16 user_resp_timer_val;
+};
+
+enum rpc_loc_ni_supl_pos_method_e_type {
+  RPC_LOC_NI_POSMETHOD_AGPS_SETASSISTED = 1,
+  RPC_LOC_NI_POSMETHOD_AGPS_SETBASED = 2,
+  RPC_LOC_NI_POSMETHOD_AGPS_SETASSISTED_PREF = 3,
+  RPC_LOC_NI_POSMETHOD_AGPS_SETBASED_PREF = 4,
+  RPC_LOC_NI_POSMETHOD_AUTONOMOUS_GPS = 5,
+  RPC_LOC_NI_POSMETHOD_AFLT = 6,
+  RPC_LOC_NI_POSMETHOD_ECID = 7,
+  RPC_LOC_NI_POSMETHOD_EOTD = 8,
+  RPC_LOC_NI_POSMETHOD_OTDOA = 9,
+  RPC_LOC_NI_POSMETHOD_NO_POSITION = 10,
+  RPC_LOC_NI_POSMETHOD_MAX = 268435456
+};
+
+struct rpc_loc_ni_supl_slp_session_id_s_type {
+  unsigned char presence;
+    opaque session_id[4]; /* EVAL:[4]*/  
+  rpc_loc_server_info_s_type slp_address;
+};
+
+struct rpc_loc_ni_requestor_id_s_type {
+  unsigned char data_coding_scheme;
+    opaque requestor_id_string[200]; /* EVAL:[200]*/  
+  unsigned char string_len;
+};
+
+struct rpc_loc_ni_supl_client_name_s_type {
+  unsigned char data_coding_scheme;
+    opaque client_name_string[64]; /* EVAL:[64]*/  
+  unsigned char string_len;
+};
+
+struct rpc_loc_ni_supl_qop_s_type {
+  unsigned char bit_mask;
+  unsigned char horacc;
+  unsigned char veracc;
+  rpc_uint16 maxLocAge;
+  unsigned char delay;
+};
+
+struct rpc_loc_ni_supl_notify_verify_req_s_type {
+  rpc_loc_ni_notify_verify_e_type notification_priv_type;
+  rpc_uint16 flags;
+  rpc_loc_ni_supl_slp_session_id_s_type supl_slp_session_id;
+    opaque supl_hash[8]; /* EVAL:[8]*/  
+  rpc_loc_ni_datacoding_scheme_e_type datacoding_scheme;
+  rpc_loc_ni_supl_pos_method_e_type pos_method;
+  rpc_loc_ni_requestor_id_s_type requestor_id;
+  rpc_loc_ni_supl_client_name_s_type client_name;
+  rpc_loc_ni_supl_qop_s_type supl_qop;
+  rpc_uint16 user_response_timer;
+};
+
+struct rpc_loc_ni_ext_client_address_s_type {
+  unsigned char ext_client_address_len;
+    opaque ext_client_address[20]; /* EVAL:[20]*/  
+};
+
+enum rpc_loc_ni_location_type_e_type {
+  RPC_LOC_NI_LOCATIONTYPE_CURRENT_LOCATION = 1,
+  RPC_LOC_NI_LOCATIONTYPE_CURRENT_OR_LAST_KNOWN_LOCATION = 2,
+  RPC_LOC_NI_LOCATIONTYPE_INITIAL_LOCATION = 3,
+  RPC_LOC_NI_LOCATIONTYPE_MAX = 268435456
+};
+
+struct rpc_loc_ni_deferred_location_s_type {
+  unsigned char unused_bits;
+  unsigned char ms_available;
+};
+
+struct rpc_loc_ni_codeword_string_s_type {
+  unsigned char data_coding_scheme;
+    opaque lcs_codeword_string[20]; /* EVAL:[20]*/  
+  unsigned char string_len;
+};
+
+struct rpc_loc_ni_service_type_id_s_type {
+  unsigned char lcs_service_type_id;
+};
+
+struct rpc_loc_ni_umts_cp_notify_verify_req_s_type {
+  rpc_loc_ni_notify_verify_e_type notification_priv_type;
+  unsigned char invoke_id;
+  rpc_uint16 flags;
+  unsigned char notification_length;
+    opaque notification_text[64]; /* EVAL:[64]*/  
+  rpc_loc_ni_datacoding_scheme_e_type datacoding_scheme;
+  rpc_loc_ni_ext_client_address_s_type ext_client_address_data;
+  rpc_loc_ni_location_type_e_type location_type;
+  rpc_loc_ni_deferred_location_s_type deferred_location;
+  rpc_loc_ni_requestor_id_s_type requestor_id;
+  rpc_loc_ni_codeword_string_s_type codeword_string;
+  rpc_loc_ni_service_type_id_s_type service_type_id;
+  rpc_uint16 user_response_timer;
+};
+
+enum rpc_loc_ni_service_interaction_e_type {
+  RPC_LOC_NI_SERVICE_INTERACTION_ONGOING_NI_INCOMING_MO = 1,
+  RPC_LOC_NI_SERVICE_INTERACTION_MAX = 268435456
+};
+
+struct rpc_loc_ni_vx_service_interaction_req_s_type {
+  rpc_loc_ni_vx_notify_verify_req_s_type ni_vx_req;
+  rpc_loc_ni_service_interaction_e_type service_interation_type;
+};
+
+union rpc_loc_ni_event_payload_u_type switch (rpc_loc_ni_event_e_type disc) {
+  case RPC_LOC_NI_EVENT_VX_NOTIFY_VERIFY_REQ:
+    rpc_loc_ni_vx_notify_verify_req_s_type vx_req;
+  case RPC_LOC_NI_EVENT_SUPL_NOTIFY_VERIFY_REQ:
+    rpc_loc_ni_supl_notify_verify_req_s_type supl_req;
+  case RPC_LOC_NI_EVENT_UMTS_CP_NOTIFY_VERIFY_REQ:
+    rpc_loc_ni_umts_cp_notify_verify_req_s_type umts_cp_req;
+  case RPC_LOC_NI_EVENT_VX_SERVICE_INTERACTION_REQ:
+    rpc_loc_ni_vx_service_interaction_req_s_type service_interaction_req;
+  default:
+    void;
+};
+
+struct rpc_loc_ni_event_s_type {
+  rpc_loc_ni_event_e_type event;
+  rpc_loc_ni_event_payload_u_type payload;
+};
+
+enum rpc_loc_assist_data_request_e_type {
+  RPC_LOC_ASSIST_DATA_TIME_REQ = 1,
+  RPC_LOC_ASSIST_DATA_PREDICTED_ORBITS_REQ = 2,
+  RPC_LOC_ASSIST_DATA_MAX = 268435456
+};
+
+  typedef string rpc_struct_loc_time_download_source_s_type_servers_ptr<256>; /* EVAL:[LOC_API_MAX_SERVER_ADDR_LENGTH]*/  
+
+  typedef rpc_struct_loc_time_download_source_s_type_servers_ptr rpc_struct_loc_time_download_source_s_type_servers[3]; /* EVAL:[3]*/  
+
+struct rpc_loc_time_download_source_s_type {
+  rpc_uint32 delay_threshold;
+  rpc_struct_loc_time_download_source_s_type_servers servers;
+};
+
+  typedef string rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr<256>; /* EVAL:[LOC_API_MAX_SERVER_ADDR_LENGTH]*/  
+
+  typedef rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr rpc_struct_loc_predicted_orbits_data_source_s_type_servers[3]; /* EVAL:[3]*/  
+
+struct rpc_loc_predicted_orbits_data_source_s_type {
+  rpc_uint32 max_file_size;
+  rpc_uint32 max_part_size;
+  rpc_struct_loc_predicted_orbits_data_source_s_type_servers servers;
+};
+
+union rpc_loc_assist_data_request_payload_u_type switch (rpc_loc_assist_data_request_e_type disc) {
+  case RPC_LOC_ASSIST_DATA_TIME_REQ:
+    rpc_loc_time_download_source_s_type time_download;
+  case RPC_LOC_ASSIST_DATA_PREDICTED_ORBITS_REQ:
+    rpc_loc_predicted_orbits_data_source_s_type data_download;
+  default:
+    void;
+};
+
+struct rpc_loc_assist_data_request_s_type {
+  rpc_loc_assist_data_request_e_type event;
+  rpc_loc_assist_data_request_payload_u_type payload;
+};
+
+typedef rpc_uint32 rpc_loc_server_connection_handle;
+
+enum rpc_loc_server_protocol_e_type {
+  RPC_LOC_SERVER_PROTOCOL_DEFAULT = 0,
+  RPC_LOC_SERVER_PROTOCOL_SUPL = 1,
+  RPC_LOC_SERVER_PROTOCOL_VX_MPC = 2,
+  RPC_LOC_SERVER_PROTOCOL_VX_PDE = 3,
+  RPC_LOC_SERVER_PROTOCOL_MAX = 16777216
+};
+
+enum rpc_loc_server_request_e_type {
+  RPC_LOC_SERVER_REQUEST_OPEN = 1,
+  RPC_LOC_SERVER_REQUEST_CLOSE = 2,
+  RPC_LOC_SERVER_REQUEST_MAX = 268435456
+};
+
+struct rpc_loc_server_open_req_s_type {
+  rpc_loc_server_connection_handle conn_handle;
+  rpc_loc_server_protocol_e_type protocol;
+};
+
+struct rpc_loc_server_close_req_s_type {
+  rpc_loc_server_connection_handle conn_handle;
+};
+
+union rpc_loc_server_request_u_type switch (rpc_loc_server_request_e_type disc) {
+  case RPC_LOC_SERVER_REQUEST_OPEN:
+    rpc_loc_server_open_req_s_type open_req;
+  case RPC_LOC_SERVER_REQUEST_CLOSE:
+    rpc_loc_server_close_req_s_type close_req;
+  default:
+    void;
+};
+
+struct rpc_loc_server_request_s_type {
+  rpc_loc_server_request_e_type event;
+  rpc_loc_server_request_u_type payload;
+};
+
+enum rpc_loc_qwip_request_e_type {
+  RPC_LOC_QWIP_START_PERIODIC_HI_FREQ_FIXES = 0,
+  RPC_LOC_QWIP_START_PERIODIC_KEEP_WARM,
+  RPC_LOC_QWIP_STOP_PERIODIC_FIXES,
+  RPC_LOC_QWIP_SUSPEND,
+  RPC_LOC_QWIP_REQUEST_MAX = 268435456
+};
+
+struct rpc_loc_qwip_request_s_type {
+  rpc_loc_qwip_request_e_type request_type;
+  rpc_uint16 tbf_ms;
+};
+
+struct rpc_loc_reserved_payload_s_type {
+  rpc_uint16 data_size;
+  opaque data<>;
+};
+
+enum rpc_loc_ioctl_e_type {
+  RPC_LOC_IOCTL_GET_API_VERSION = 1,
+  RPC_LOC_IOCTL_SET_FIX_CRITERIA = 2,
+  RPC_LOC_IOCTL_GET_FIX_CRITERIA = 3,
+  RPC_LOC_IOCTL_SERVICE_START_INDEX = 400,
+  RPC_LOC_IOCTL_INFORM_NI_USER_RESPONSE = 400,
+  RPC_LOC_IOCTL_INJECT_PREDICTED_ORBITS_DATA = 401,
+  RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_VALIDITY = 402,
+  RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_SOURCE = 403,
+  RPC_LOC_IOCTL_SET_PREDICTED_ORBITS_DATA_AUTO_DOWNLOAD = 404,
+  RPC_LOC_IOCTL_INJECT_UTC_TIME = 405,
+  RPC_LOC_IOCTL_INJECT_RTC_VALUE = 406,
+  RPC_LOC_IOCTL_INJECT_POSITION = 407,
+  RPC_LOC_IOCTL_QUERY_ENGINE_STATE = 408,
+  RPC_LOC_IOCTL_INFORM_SERVER_OPEN_STATUS = 409,
+  RPC_LOC_IOCTL_INFORM_SERVER_CLOSE_STATUS = 410,
+  RPC_LOC_IOCTL_SEND_WIPER_POSITION_REPORT = 411,
+  RPC_LOC_IOCTL_NOTIFY_WIPER_STATUS = 412,
+  RPC_LOC_IOCTL_ACCESS_EFS_DATA = 413,
+  RPC_LOC_IOCTL_NV_SETTINGS_START_INDEX = 800,
+  RPC_LOC_IOCTL_SET_ENGINE_LOCK = 800,
+  RPC_LOC_IOCTL_GET_ENGINE_LOCK = 801,
+  RPC_LOC_IOCTL_SET_SBAS_CONFIG = 802,
+  RPC_LOC_IOCTL_GET_SBAS_CONFIG = 803,
+  RPC_LOC_IOCTL_SET_NMEA_TYPES = 804,
+  RPC_LOC_IOCTL_GET_NMEA_TYPES = 805,
+  RPC_LOC_IOCTL_SET_CDMA_PDE_SERVER_ADDR = 806,
+  RPC_LOC_IOCTL_GET_CDMA_PDE_SERVER_ADDR = 807,
+  RPC_LOC_IOCTL_SET_CDMA_MPC_SERVER_ADDR = 808,
+  RPC_LOC_IOCTL_GET_CDMA_MPC_SERVER_ADDR = 809,
+  RPC_LOC_IOCTL_SET_UMTS_SLP_SERVER_ADDR = 810,
+  RPC_LOC_IOCTL_GET_UMTS_SLP_SERVER_ADDR = 811,
+  RPC_LOC_IOCTL_SET_ON_DEMAND_LPM = 812,
+  RPC_LOC_IOCTL_GET_ON_DEMAND_LPM = 813,
+  RPC_LOC_IOCTL_PROPRIETARY_START_INDEX = 1000,
+  RPC_LOC_IOCTL_DELETE_ASSIST_DATA = 1000,
+  RPC_LOC_IOCTL_SET_CUSTOM_PDE_SERVER_ADDR = 1001,
+  RPC_LOC_IOCTL_GET_CUSTOM_PDE_SERVER_ADDR = 1002,
+  RPC_LOC_IOCTL_THIRD_PARTY_START_INDEX = 1073741824
+};
+
+struct rpc_loc_api_version_s_type {
+  unsigned char major;
+  unsigned char minor;
+};
+
+enum rpc_loc_fix_recurrence_e_type {
+  RPC_LOC_PERIODIC_FIX = 1,
+  RPC_LOC_SINGLE_FIX = 2,
+  RPC_LOC_FIX_SESSION_TYPE_MAX = 268435456
+};
+
+enum rpc_loc_operation_mode_e_type {
+  RPC_LOC_OPER_MODE_DEFAULT = 1,
+  RPC_LOC_OPER_MODE_MSB = 2,
+  RPC_LOC_OPER_MODE_MSA = 3,
+  RPC_LOC_OPER_MODE_STANDALONE = 4,
+  RPC_LOC_OPER_MODE_SPEED_OPTIMAL = 5,
+  RPC_LOC_OPER_MODE_ACCURACY_OPTIMAL = 6,
+  RPC_LOC_OPER_MODE_DATA_OPTIMAL = 7,
+  RPC_LOC_OPER_MODE_CELL_ID = 8,
+  RPC_LOC_OPER_MODE_MAX = 268435456
+};
+
+enum rpc_loc_notify_e_type {
+  RPC_LOC_NOTIFY_ON_INTERVAL = 1,
+  RPC_LOC_NOTIFY_ON_DISTANCE = 2,
+  RPC_LOC_NOTIFY_ON_ANY = 3,
+  RPC_LOC_NOTIFY_ON_ALL = 4,
+  RPC_LOC_NOTIFY_TYPE_MAX = 268435456
+};
+
+struct rpc_loc_fix_criteria_s_type {
+  rpc_uint32 valid_mask;
+  rpc_loc_fix_recurrence_e_type recurrence_type;
+  rpc_loc_operation_mode_e_type preferred_operation_mode;
+  rpc_uint32 preferred_accuracy;
+  rpc_uint32 preferred_response_time;
+  rpc_boolean intermediate_pos_report_enabled;
+  rpc_loc_notify_e_type notify_type;
+  rpc_uint32 min_interval;
+  float min_distance;
+  rpc_uint32 min_dist_sample_interval;
+};
+
+enum rpc_loc_ni_user_resp_e_type {
+  RPC_LOC_NI_LCS_NOTIFY_VERIFY_ACCEPT = 1,
+  RPC_LOC_NI_LCS_NOTIFY_VERIFY_DENY = 2,
+  RPC_LOC_NI_LCS_NOTIFY_VERIFY_NORESP = 3,
+  RPC_LOC_NI_LCS_NOTIFY_VERIFY_MAX = 268435456
+};
+
+struct rpc_loc_user_verify_s_type {
+  rpc_loc_ni_user_resp_e_type user_resp;
+  rpc_loc_ni_event_s_type ni_event_pass_back;
+};
+
+enum rpc_loc_predicted_orbits_data_format_e_type {
+  RPC_LOC_PREDICTED_ORBITS_XTRA = 0,
+  RPC_LOC_PREDICTED_ORBITS_FORMAT_MAX = 268435456
+};
+
+struct rpc_loc_predicted_orbits_data_s_type {
+  rpc_loc_predicted_orbits_data_format_e_type format_type;
+  rpc_uint32 total_size;
+  rpc_uint8 total_parts;
+  rpc_uint8 part;
+  rpc_uint16 part_len;
+  opaque data_ptr<>;
+};
+
+struct rpc_loc_predicted_orbits_data_validity_report_s_type {
+  rpc_uint64 start_time_utc;
+  rpc_uint16 valid_duration_hrs;
+};
+
+struct rpc_loc_predicted_orbits_auto_download_config_s_type {
+  rpc_boolean enable;
+  unsigned char auto_check_every_hrs;
+};
+
+struct rpc_loc_assist_data_time_s_type {
+  rpc_uint64 time_utc;
+  rpc_uint32 uncertainty;
+};
+
+typedef rpc_uint64 rpc_loc_assist_pos_valid_mask_type;
+
+struct rpc_loc_assist_data_pos_s_type {
+  rpc_loc_assist_pos_valid_mask_type valid_mask;
+  rpc_uint64 timestamp_utc;
+  double latitude;
+  double longitude;
+  float altitude_wrt_ellipsoid;
+  float altitude_wrt_mean_sea_level;
+  float hor_unc_circular;
+  float vert_unc;
+  unsigned char confidence_horizontal;
+  unsigned char confidence_vertical;
+  rpc_int32 timestamp_age;
+};
+
+enum rpc_loc_server_open_status_e_type {
+  RPC_LOC_SERVER_OPEN_SUCCESS = 1,
+  RPC_LOC_SERVER_OPEN_FAIL = 2,
+  RPC_LOC_SERVER_OPEN_STATUS_MAX = 268435456
+};
+
+struct rpc_loc_server_open_status_s_type {
+  rpc_loc_server_connection_handle conn_handle;
+  rpc_loc_server_open_status_e_type open_status;
+    opaque apn_name[100]; /* EVAL:[100]*/  
+};
+
+enum rpc_loc_server_close_status_e_type {
+  RPC_LOC_SERVER_CLOSE_SUCCESS = 1,
+  RPC_LOC_SERVER_CLOSE_FAIL = 2,
+  RPC_LOC_SERVER_CLOSE_STATUS_MAX = 268435456
+};
+
+struct rpc_loc_server_close_status_s_type {
+  rpc_loc_server_connection_handle conn_handle;
+  rpc_loc_server_close_status_e_type close_status;
+};
+
+struct rpc_loc_wiper_fix_time_s_type {
+  rpc_uint32 slow_clock_count;
+};
+
+struct rpc_loc_wiper_fix_pos_s_type {
+  rpc_int32 lat;
+  rpc_int32 lon;
+  rpc_uint16 HEPE;
+  rpc_uint8 num_of_aps_used;
+  rpc_uint8 fix_error_code;
+};
+
+struct rpc_loc_wiper_ap_info_s_type {
+    opaque mac_addr[6]; /* EVAL:[6]*/  
+  rpc_int32 rssi;
+  rpc_uint16 channel;
+  rpc_uint8 ap_qualifier;
+};
+
+struct rpc_loc_wiper_ap_set_s_type {
+  rpc_uint8 num_of_aps;
+    rpc_loc_wiper_ap_info_s_type ap_info[50]; /* EVAL:[50]*/  
+};
+
+struct rpc_loc_wiper_position_report_s_type {
+  rpc_uint8 wiper_valid_info_flag;
+  rpc_loc_wiper_fix_time_s_type wiper_fix_time;
+  rpc_loc_wiper_fix_pos_s_type wiper_fix_position;
+  rpc_loc_wiper_ap_set_s_type wiper_ap_set;
+};
+
+enum rpc_loc_wiper_status_e_type {
+  RPC_LOC_WIPER_STATUS_AVAILABLE = 1,
+  RPC_LOC_WIPER_STATUS_UNAVAILABLE = 2,
+  RPC_LOC_WIPER_STATUS_E_SIZE = 268435456
+};
+
+enum rpc_loc_fs_operation_e_type {
+  RPC_LOC_FS_CREATE_WRITE_FILE = 1,
+  RPC_LOC_FS_APPEND_FILE = 2,
+  RPC_LOC_FS_DELETE_FILE = 3,
+  RPC_LOC_FS_READ_FILE = 4,
+  RPC_LOC_FS_MAX = 268435456
+};
+
+struct rpc_loc_efs_data_s_type {
+    opaque filename[64]; /* EVAL:[64]*/  
+  rpc_loc_fs_operation_e_type operation;
+  rpc_uint32 total_size;
+  opaque data_ptr<>;
+  rpc_uint32 part_len;
+  rpc_uint8 part;
+  rpc_uint8 total_parts;
+  rpc_uint32 reserved;
+};
+
+enum rpc_loc_lock_e_type {
+  RPC_LOC_LOCK_NONE = 1,
+  RPC_LOC_LOCK_MI = 2,
+  RPC_LOC_LOCK_MT = 3,
+  RPC_LOC_LOCK_ALL = 4,
+  RPC_LOC_LOCK_MAX = 268435456
+};
+
+typedef rpc_uint32 rpc_loc_nmea_sentence_type;
+
+typedef rpc_uint32 rpc_loc_assist_data_type;
+
+struct rpc_loc_assist_data_delete_s_type {
+  rpc_loc_assist_data_type type;
+    rpc_uint32 reserved[8]; /* EVAL:[8]*/  
+};
+
+union rpc_loc_ioctl_data_u_type switch (rpc_loc_ioctl_e_type disc) {
+  case RPC_LOC_IOCTL_SET_FIX_CRITERIA:
+    rpc_loc_fix_criteria_s_type fix_criteria;
+  case RPC_LOC_IOCTL_INFORM_NI_USER_RESPONSE:
+    rpc_loc_user_verify_s_type user_verify_resp;
+  case RPC_LOC_IOCTL_INJECT_PREDICTED_ORBITS_DATA:
+    rpc_loc_predicted_orbits_data_s_type predicted_orbits_data;
+  case RPC_LOC_IOCTL_SET_PREDICTED_ORBITS_DATA_AUTO_DOWNLOAD:
+    rpc_loc_predicted_orbits_auto_download_config_s_type predicted_orbits_auto_download;
+  case RPC_LOC_IOCTL_INJECT_UTC_TIME:
+    rpc_loc_assist_data_time_s_type assistance_data_time;
+  case RPC_LOC_IOCTL_INJECT_POSITION:
+    rpc_loc_assist_data_pos_s_type assistance_data_position;
+  case RPC_LOC_IOCTL_INFORM_SERVER_OPEN_STATUS:
+    rpc_loc_server_open_status_s_type conn_open_status;
+  case RPC_LOC_IOCTL_INFORM_SERVER_CLOSE_STATUS:
+    rpc_loc_server_close_status_s_type conn_close_status;
+  case RPC_LOC_IOCTL_SEND_WIPER_POSITION_REPORT:
+    rpc_loc_wiper_position_report_s_type wiper_pos;
+  case RPC_LOC_IOCTL_NOTIFY_WIPER_STATUS:
+    rpc_loc_wiper_status_e_type wiper_status;
+  case RPC_LOC_IOCTL_SET_ENGINE_LOCK:
+    rpc_loc_lock_e_type engine_lock;
+  case RPC_LOC_IOCTL_SET_SBAS_CONFIG:
+    rpc_boolean sbas_mode;
+  case RPC_LOC_IOCTL_SET_NMEA_TYPES:
+    rpc_loc_nmea_sentence_type nmea_types;
+  case RPC_LOC_IOCTL_SET_ON_DEMAND_LPM:
+    rpc_boolean on_demand_lpm;
+  case  RPC_LOC_IOCTL_SET_CDMA_PDE_SERVER_ADDR:
+  case  RPC_LOC_IOCTL_SET_CDMA_MPC_SERVER_ADDR:
+  case  RPC_LOC_IOCTL_SET_UMTS_SLP_SERVER_ADDR:
+  case  RPC_LOC_IOCTL_SET_CUSTOM_PDE_SERVER_ADDR:
+    rpc_loc_server_info_s_type server_addr;
+  case RPC_LOC_IOCTL_DELETE_ASSIST_DATA:
+    rpc_loc_assist_data_delete_s_type assist_data_delete;
+  case RPC_LOC_IOCTL_ACCESS_EFS_DATA:
+    rpc_loc_efs_data_s_type efs_data;
+  default:
+    void;
+};
+
+union rpc_loc_ioctl_callback_data_u_type switch (rpc_loc_ioctl_e_type disc) {
+  case RPC_LOC_IOCTL_GET_API_VERSION:
+    rpc_loc_api_version_s_type api_version;
+  case RPC_LOC_IOCTL_GET_FIX_CRITERIA:
+    rpc_loc_fix_criteria_s_type fix_criteria;
+  case RPC_LOC_IOCTL_GET_ENGINE_LOCK:
+    rpc_loc_lock_e_type engine_lock;
+  case RPC_LOC_IOCTL_GET_SBAS_CONFIG:
+    rpc_boolean sbas_mode;
+  case RPC_LOC_IOCTL_GET_NMEA_TYPES:
+    rpc_loc_nmea_sentence_type nmea_types;
+  case RPC_LOC_IOCTL_GET_ON_DEMAND_LPM:
+    rpc_boolean on_demand_lpm;
+  case  RPC_LOC_IOCTL_GET_CDMA_PDE_SERVER_ADDR:
+  case  RPC_LOC_IOCTL_GET_CDMA_MPC_SERVER_ADDR:
+  case  RPC_LOC_IOCTL_GET_UMTS_SLP_SERVER_ADDR:
+  case  RPC_LOC_IOCTL_GET_CUSTOM_PDE_SERVER_ADDR:
+    rpc_loc_server_info_s_type server_addr;
+  case RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_SOURCE:
+    rpc_loc_predicted_orbits_data_source_s_type predicted_orbits_data_source;
+  case RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_VALIDITY:
+    rpc_loc_predicted_orbits_data_validity_report_s_type predicted_orbits_data_validity;
+  default:
+    void;
+};
+
+struct rpc_loc_ioctl_callback_s_type {
+  rpc_loc_ioctl_e_type type;
+  rpc_int32 status;
+  rpc_loc_ioctl_callback_data_u_type data;
+};
+
+union rpc_loc_event_payload_u_type switch (unsigned hyper disc) {
+  case RPC_LOC_EVENT_PARSED_POSITION_REPORT:
+    rpc_loc_parsed_position_s_type parsed_location_report;
+  case RPC_LOC_EVENT_SATELLITE_REPORT:
+    rpc_loc_gnss_info_s_type gnss_report;
+  case RPC_LOC_EVENT_NMEA_POSITION_REPORT:
+    rpc_loc_nmea_report_s_type nmea_report;
+  case RPC_LOC_EVENT_NI_NOTIFY_VERIFY_REQUEST:
+    rpc_loc_ni_event_s_type ni_request;
+  case RPC_LOC_EVENT_ASSISTANCE_DATA_REQUEST:
+    rpc_loc_assist_data_request_s_type assist_data_request;
+  case RPC_LOC_EVENT_LOCATION_SERVER_REQUEST:
+    rpc_loc_server_request_s_type loc_server_request;
+  case RPC_LOC_EVENT_IOCTL_REPORT:
+    rpc_loc_ioctl_callback_s_type ioctl_report;
+  case RPC_LOC_EVENT_STATUS_REPORT:
+    rpc_loc_status_event_s_type status_report;
+  case RPC_LOC_EVENT_WPS_NEEDED_REQUEST:
+    rpc_loc_qwip_request_s_type qwip_request;
+  case RPC_LOC_EVENT_RESERVED:
+    rpc_loc_reserved_payload_s_type reserved;
+  default:
+    void;
+};
+
diff --git a/msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_common_xdr.c b/msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_common_xdr.c
new file mode 100644
index 0000000..7c860bf
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_common_xdr.c
@@ -0,0 +1,1650 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#include "loc_api_common.h"
+
+bool_t
+xdr_rpc_boolean (XDR *xdrs, rpc_boolean *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_bool (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_uint32 (XDR *xdrs, rpc_uint32 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_u_long (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_uint16 (XDR *xdrs, rpc_uint16 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_u_short (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_uint8 (XDR *xdrs, rpc_uint8 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_u_char (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_int32 (XDR *xdrs, rpc_int32 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_long (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_byte (XDR *xdrs, rpc_byte *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_u_char (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_uint64 (XDR *xdrs, rpc_uint64 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_u_quad_t (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_client_handle_type (XDR *xdrs, rpc_loc_client_handle_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_int32 (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_event_mask_type (XDR *xdrs, rpc_loc_event_mask_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint64 (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_position_valid_mask_type (XDR *xdrs, rpc_loc_position_valid_mask_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint64 (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_pos_technology_mask_type (XDR *xdrs, rpc_loc_pos_technology_mask_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint32 (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_session_status_e_type (XDR *xdrs, rpc_loc_session_status_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_calendar_time_s_type (XDR *xdrs, rpc_loc_calendar_time_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint16 (xdrs, &objp->year))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->month))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->day_of_week))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->day))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->hour))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->minute))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->second))
+		 return FALSE;
+	 if (!xdr_rpc_uint16 (xdrs, &objp->millisecond))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_parsed_position_s_type (XDR *xdrs, rpc_loc_parsed_position_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_position_valid_mask_type (xdrs, &objp->valid_mask))
+		 return FALSE;
+	 if (!xdr_rpc_loc_session_status_e_type (xdrs, &objp->session_status))
+		 return FALSE;
+	 if (!xdr_rpc_loc_calendar_time_s_type (xdrs, &objp->timestamp_calendar))
+		 return FALSE;
+	 if (!xdr_rpc_uint64 (xdrs, &objp->timestamp_utc))
+		 return FALSE;
+	 if (!xdr_rpc_uint8 (xdrs, &objp->leap_seconds))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->time_unc))
+		 return FALSE;
+	 if (!xdr_double (xdrs, &objp->latitude))
+		 return FALSE;
+	 if (!xdr_double (xdrs, &objp->longitude))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->altitude_wrt_ellipsoid))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->altitude_wrt_mean_sea_level))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->speed_horizontal))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->speed_vertical))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->heading))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->hor_unc_circular))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->hor_unc_ellipse_semi_major))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->hor_unc_ellipse_semi_minor))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->hor_unc_ellipse_orient_azimuth))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->vert_unc))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->speed_unc))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->heading_unc))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->confidence_horizontal))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->confidence_vertical))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->magnetic_deviation))
+		 return FALSE;
+	 if (!xdr_rpc_loc_pos_technology_mask_type (xdrs, &objp->technology_mask))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_sv_system_e_type (XDR *xdrs, rpc_loc_sv_system_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_sv_status_e_type (XDR *xdrs, rpc_loc_sv_status_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_sv_info_valid_mask_type (XDR *xdrs, rpc_loc_sv_info_valid_mask_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint32 (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_sv_info_s_type (XDR *xdrs, rpc_loc_sv_info_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_sv_info_valid_mask_type (xdrs, &objp->valid_mask))
+		 return FALSE;
+	 if (!xdr_rpc_loc_sv_system_e_type (xdrs, &objp->system))
+		 return FALSE;
+	 if (!xdr_rpc_uint8 (xdrs, &objp->prn))
+		 return FALSE;
+	 if (!xdr_rpc_uint8 (xdrs, &objp->health_status))
+		 return FALSE;
+	 if (!xdr_rpc_loc_sv_status_e_type (xdrs, &objp->process_status))
+		 return FALSE;
+	 if (!xdr_rpc_boolean (xdrs, &objp->has_eph))
+		 return FALSE;
+	 if (!xdr_rpc_boolean (xdrs, &objp->has_alm))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->elevation))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->azimuth))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->snr))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_gnss_info_valid_mask_type (XDR *xdrs, rpc_loc_gnss_info_valid_mask_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint32 (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_gnss_info_s_type (XDR *xdrs, rpc_loc_gnss_info_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_gnss_info_valid_mask_type (xdrs, &objp->valid_mask))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->position_dop))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->horizontal_dop))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->vertical_dop))
+		 return FALSE;
+	 if (!xdr_rpc_boolean (xdrs, &objp->altitude_assumed))
+		 return FALSE;
+	 if (!xdr_rpc_uint16 (xdrs, &objp->sv_count))
+		 return FALSE;
+	 if (!xdr_array (xdrs, (char **)&objp->sv_list.sv_list_val, (u_int *) &objp->sv_list.sv_list_len, 80,
+		sizeof (rpc_loc_sv_info_s_type), (xdrproc_t) xdr_rpc_loc_sv_info_s_type))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_nmea_report_s_type (XDR *xdrs, rpc_loc_nmea_report_s_type *objp)
+{
+	register int32_t *buf;
+
+	int i;
+	 if (!xdr_rpc_uint16 (xdrs, &objp->length))
+		 return FALSE;
+	 if (!xdr_opaque (xdrs, objp->nmea_sentences, 1200))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_status_event_e_type (XDR *xdrs, rpc_loc_status_event_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_engine_state_e_type (XDR *xdrs, rpc_loc_engine_state_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_fix_session_state_e_type (XDR *xdrs, rpc_loc_fix_session_state_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_status_event_payload_u_type (XDR *xdrs, rpc_loc_status_event_payload_u_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_status_event_e_type (xdrs, &objp->disc))
+		 return FALSE;
+	switch (objp->disc) {
+	case RPC_LOC_STATUS_EVENT_ENGINE_STATE:
+		 if (!xdr_rpc_loc_engine_state_e_type (xdrs, &objp->rpc_loc_status_event_payload_u_type_u.engine_state))
+			 return FALSE;
+		break;
+	case RPC_LOC_STATUS_EVENT_FIX_SESSION_STATE:
+		 if (!xdr_rpc_loc_fix_session_state_e_type (xdrs, &objp->rpc_loc_status_event_payload_u_type_u.fix_session_state))
+			 return FALSE;
+		break;
+	default:
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_status_event_s_type (XDR *xdrs, rpc_loc_status_event_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_status_event_e_type (xdrs, &objp->event))
+		 return FALSE;
+	 if (!xdr_rpc_loc_status_event_payload_u_type (xdrs, &objp->payload))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_addr_e_type (XDR *xdrs, rpc_loc_server_addr_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_addr_ipv4_type (XDR *xdrs, rpc_loc_server_addr_ipv4_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint32 (xdrs, &objp->addr))
+		 return FALSE;
+	 if (!xdr_rpc_uint16 (xdrs, &objp->port))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_addr_url_type (XDR *xdrs, rpc_loc_server_addr_url_type *objp)
+{
+	register int32_t *buf;
+
+	int i;
+	 if (!xdr_rpc_uint16 (xdrs, &objp->length))
+		 return FALSE;
+	 if (!xdr_opaque (xdrs, objp->addr, 256))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_addr_u_type (XDR *xdrs, rpc_loc_server_addr_u_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_server_addr_e_type (xdrs, &objp->disc))
+		 return FALSE;
+	switch (objp->disc) {
+	case RPC_LOC_SERVER_ADDR_IPV4:
+		 if (!xdr_rpc_loc_server_addr_ipv4_type (xdrs, &objp->rpc_loc_server_addr_u_type_u.ipv4))
+			 return FALSE;
+		break;
+	case RPC_LOC_SERVER_ADDR_URL:
+		 if (!xdr_rpc_loc_server_addr_url_type (xdrs, &objp->rpc_loc_server_addr_u_type_u.url))
+			 return FALSE;
+		break;
+	default:
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_info_s_type (XDR *xdrs, rpc_loc_server_info_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_server_addr_e_type (xdrs, &objp->addr_type))
+		 return FALSE;
+	 if (!xdr_rpc_loc_server_addr_u_type (xdrs, &objp->addr_info))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_notify_verify_e_type (XDR *xdrs, rpc_loc_ni_notify_verify_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_event_e_type (XDR *xdrs, rpc_loc_ni_event_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_datacoding_scheme_e_type (XDR *xdrs, rpc_loc_ni_datacoding_scheme_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_vx_requester_id_encoding_scheme_e_type (XDR *xdrs, rpc_loc_ni_vx_requester_id_encoding_scheme_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_vx_pos_mode_e_type (XDR *xdrs, rpc_loc_ni_vx_pos_mode_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_vx_requester_id_s_type (XDR *xdrs, rpc_loc_ni_vx_requester_id_s_type *objp)
+{
+	register int32_t *buf;
+
+	int i;
+	 if (!xdr_u_char (xdrs, &objp->requester_id_length))
+		 return FALSE;
+	 if (!xdr_opaque (xdrs, objp->requester_id, 200))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_vx_notify_verify_req_s_type (XDR *xdrs, rpc_loc_ni_vx_notify_verify_req_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_ni_notify_verify_e_type (xdrs, &objp->notification_priv_type))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->pos_qos_incl))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->pos_qos))
+		 return FALSE;
+	 if (!xdr_rpc_uint32 (xdrs, &objp->num_fixes))
+		 return FALSE;
+	 if (!xdr_rpc_uint32 (xdrs, &objp->tbf))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_vx_pos_mode_e_type (xdrs, &objp->pos_mode))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_vx_requester_id_encoding_scheme_e_type (xdrs, &objp->encoding_scheme))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_vx_requester_id_s_type (xdrs, &objp->requester_id))
+		 return FALSE;
+	 if (!xdr_rpc_uint16 (xdrs, &objp->user_resp_timer_val))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_supl_pos_method_e_type (XDR *xdrs, rpc_loc_ni_supl_pos_method_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_supl_slp_session_id_s_type (XDR *xdrs, rpc_loc_ni_supl_slp_session_id_s_type *objp)
+{
+	register int32_t *buf;
+
+	int i;
+	 if (!xdr_u_char (xdrs, &objp->presence))
+		 return FALSE;
+	 if (!xdr_opaque (xdrs, objp->session_id, 4))
+		 return FALSE;
+	 if (!xdr_rpc_loc_server_info_s_type (xdrs, &objp->slp_address))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_requestor_id_s_type (XDR *xdrs, rpc_loc_ni_requestor_id_s_type *objp)
+{
+	register int32_t *buf;
+
+	int i;
+	 if (!xdr_u_char (xdrs, &objp->data_coding_scheme))
+		 return FALSE;
+	 if (!xdr_opaque (xdrs, objp->requestor_id_string, 200))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->string_len))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_supl_client_name_s_type (XDR *xdrs, rpc_loc_ni_supl_client_name_s_type *objp)
+{
+	register int32_t *buf;
+
+	int i;
+	 if (!xdr_u_char (xdrs, &objp->data_coding_scheme))
+		 return FALSE;
+	 if (!xdr_opaque (xdrs, objp->client_name_string, 64))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->string_len))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_supl_qop_s_type (XDR *xdrs, rpc_loc_ni_supl_qop_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_u_char (xdrs, &objp->bit_mask))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->horacc))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->veracc))
+		 return FALSE;
+	 if (!xdr_rpc_uint16 (xdrs, &objp->maxLocAge))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->delay))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_supl_notify_verify_req_s_type (XDR *xdrs, rpc_loc_ni_supl_notify_verify_req_s_type *objp)
+{
+	register int32_t *buf;
+
+	int i;
+	 if (!xdr_rpc_loc_ni_notify_verify_e_type (xdrs, &objp->notification_priv_type))
+		 return FALSE;
+	 if (!xdr_rpc_uint16 (xdrs, &objp->flags))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_supl_slp_session_id_s_type (xdrs, &objp->supl_slp_session_id))
+		 return FALSE;
+	 if (!xdr_opaque (xdrs, objp->supl_hash, 8))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_datacoding_scheme_e_type (xdrs, &objp->datacoding_scheme))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_supl_pos_method_e_type (xdrs, &objp->pos_method))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_requestor_id_s_type (xdrs, &objp->requestor_id))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_supl_client_name_s_type (xdrs, &objp->client_name))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_supl_qop_s_type (xdrs, &objp->supl_qop))
+		 return FALSE;
+	 if (!xdr_rpc_uint16 (xdrs, &objp->user_response_timer))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_ext_client_address_s_type (XDR *xdrs, rpc_loc_ni_ext_client_address_s_type *objp)
+{
+	register int32_t *buf;
+
+	int i;
+	 if (!xdr_u_char (xdrs, &objp->ext_client_address_len))
+		 return FALSE;
+	 if (!xdr_opaque (xdrs, objp->ext_client_address, 20))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_location_type_e_type (XDR *xdrs, rpc_loc_ni_location_type_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_deferred_location_s_type (XDR *xdrs, rpc_loc_ni_deferred_location_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_u_char (xdrs, &objp->unused_bits))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->ms_available))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_codeword_string_s_type (XDR *xdrs, rpc_loc_ni_codeword_string_s_type *objp)
+{
+	register int32_t *buf;
+
+	int i;
+	 if (!xdr_u_char (xdrs, &objp->data_coding_scheme))
+		 return FALSE;
+	 if (!xdr_opaque (xdrs, objp->lcs_codeword_string, 20))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->string_len))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_service_type_id_s_type (XDR *xdrs, rpc_loc_ni_service_type_id_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_u_char (xdrs, &objp->lcs_service_type_id))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_umts_cp_notify_verify_req_s_type (XDR *xdrs, rpc_loc_ni_umts_cp_notify_verify_req_s_type *objp)
+{
+	register int32_t *buf;
+
+	int i;
+	 if (!xdr_rpc_loc_ni_notify_verify_e_type (xdrs, &objp->notification_priv_type))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->invoke_id))
+		 return FALSE;
+	 if (!xdr_rpc_uint16 (xdrs, &objp->flags))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->notification_length))
+		 return FALSE;
+	 if (!xdr_opaque (xdrs, objp->notification_text, 64))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_datacoding_scheme_e_type (xdrs, &objp->datacoding_scheme))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_ext_client_address_s_type (xdrs, &objp->ext_client_address_data))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_location_type_e_type (xdrs, &objp->location_type))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_deferred_location_s_type (xdrs, &objp->deferred_location))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_requestor_id_s_type (xdrs, &objp->requestor_id))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_codeword_string_s_type (xdrs, &objp->codeword_string))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_service_type_id_s_type (xdrs, &objp->service_type_id))
+		 return FALSE;
+	 if (!xdr_rpc_uint16 (xdrs, &objp->user_response_timer))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_service_interaction_e_type (XDR *xdrs, rpc_loc_ni_service_interaction_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_vx_service_interaction_req_s_type (XDR *xdrs, rpc_loc_ni_vx_service_interaction_req_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_ni_vx_notify_verify_req_s_type (xdrs, &objp->ni_vx_req))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_service_interaction_e_type (xdrs, &objp->service_interation_type))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_event_payload_u_type (XDR *xdrs, rpc_loc_ni_event_payload_u_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_ni_event_e_type (xdrs, &objp->disc))
+		 return FALSE;
+	switch (objp->disc) {
+	case RPC_LOC_NI_EVENT_VX_NOTIFY_VERIFY_REQ:
+		 if (!xdr_rpc_loc_ni_vx_notify_verify_req_s_type (xdrs, &objp->rpc_loc_ni_event_payload_u_type_u.vx_req))
+			 return FALSE;
+		break;
+	case RPC_LOC_NI_EVENT_SUPL_NOTIFY_VERIFY_REQ:
+		 if (!xdr_rpc_loc_ni_supl_notify_verify_req_s_type (xdrs, &objp->rpc_loc_ni_event_payload_u_type_u.supl_req))
+			 return FALSE;
+		break;
+	case RPC_LOC_NI_EVENT_UMTS_CP_NOTIFY_VERIFY_REQ:
+		 if (!xdr_rpc_loc_ni_umts_cp_notify_verify_req_s_type (xdrs, &objp->rpc_loc_ni_event_payload_u_type_u.umts_cp_req))
+			 return FALSE;
+		break;
+	case RPC_LOC_NI_EVENT_VX_SERVICE_INTERACTION_REQ:
+		 if (!xdr_rpc_loc_ni_vx_service_interaction_req_s_type (xdrs, &objp->rpc_loc_ni_event_payload_u_type_u.service_interaction_req))
+			 return FALSE;
+		break;
+	default:
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_event_s_type (XDR *xdrs, rpc_loc_ni_event_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_ni_event_e_type (xdrs, &objp->event))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_event_payload_u_type (xdrs, &objp->payload))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_assist_data_request_e_type (XDR *xdrs, rpc_loc_assist_data_request_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_struct_loc_time_download_source_s_type_servers_ptr (XDR *xdrs, rpc_struct_loc_time_download_source_s_type_servers_ptr *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_string (xdrs, objp, 256))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_struct_loc_time_download_source_s_type_servers (XDR *xdrs, rpc_struct_loc_time_download_source_s_type_servers objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_vector (xdrs, (char *)objp, 3,
+		sizeof (rpc_struct_loc_time_download_source_s_type_servers_ptr), (xdrproc_t) xdr_rpc_struct_loc_time_download_source_s_type_servers_ptr))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_time_download_source_s_type (XDR *xdrs, rpc_loc_time_download_source_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint32 (xdrs, &objp->delay_threshold))
+		 return FALSE;
+	 if (!xdr_rpc_struct_loc_time_download_source_s_type_servers (xdrs, objp->servers))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr (XDR *xdrs, rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_string (xdrs, objp, 256))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_struct_loc_predicted_orbits_data_source_s_type_servers (XDR *xdrs, rpc_struct_loc_predicted_orbits_data_source_s_type_servers objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_vector (xdrs, (char *)objp, 3,
+		sizeof (rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr), (xdrproc_t) xdr_rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_predicted_orbits_data_source_s_type (XDR *xdrs, rpc_loc_predicted_orbits_data_source_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint32 (xdrs, &objp->max_file_size))
+		 return FALSE;
+	 if (!xdr_rpc_uint32 (xdrs, &objp->max_part_size))
+		 return FALSE;
+	 if (!xdr_rpc_struct_loc_predicted_orbits_data_source_s_type_servers (xdrs, objp->servers))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_assist_data_request_payload_u_type (XDR *xdrs, rpc_loc_assist_data_request_payload_u_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_assist_data_request_e_type (xdrs, &objp->disc))
+		 return FALSE;
+	switch (objp->disc) {
+	case RPC_LOC_ASSIST_DATA_TIME_REQ:
+		 if (!xdr_rpc_loc_time_download_source_s_type (xdrs, &objp->rpc_loc_assist_data_request_payload_u_type_u.time_download))
+			 return FALSE;
+		break;
+	case RPC_LOC_ASSIST_DATA_PREDICTED_ORBITS_REQ:
+		 if (!xdr_rpc_loc_predicted_orbits_data_source_s_type (xdrs, &objp->rpc_loc_assist_data_request_payload_u_type_u.data_download))
+			 return FALSE;
+		break;
+	default:
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_assist_data_request_s_type (XDR *xdrs, rpc_loc_assist_data_request_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_assist_data_request_e_type (xdrs, &objp->event))
+		 return FALSE;
+	 if (!xdr_rpc_loc_assist_data_request_payload_u_type (xdrs, &objp->payload))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_connection_handle (XDR *xdrs, rpc_loc_server_connection_handle *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint32 (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_protocol_e_type (XDR *xdrs, rpc_loc_server_protocol_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_request_e_type (XDR *xdrs, rpc_loc_server_request_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_open_req_s_type (XDR *xdrs, rpc_loc_server_open_req_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_server_connection_handle (xdrs, &objp->conn_handle))
+		 return FALSE;
+	 if (!xdr_rpc_loc_server_protocol_e_type (xdrs, &objp->protocol))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_close_req_s_type (XDR *xdrs, rpc_loc_server_close_req_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_server_connection_handle (xdrs, &objp->conn_handle))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_request_u_type (XDR *xdrs, rpc_loc_server_request_u_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_server_request_e_type (xdrs, &objp->disc))
+		 return FALSE;
+	switch (objp->disc) {
+	case RPC_LOC_SERVER_REQUEST_OPEN:
+		 if (!xdr_rpc_loc_server_open_req_s_type (xdrs, &objp->rpc_loc_server_request_u_type_u.open_req))
+			 return FALSE;
+		break;
+	case RPC_LOC_SERVER_REQUEST_CLOSE:
+		 if (!xdr_rpc_loc_server_close_req_s_type (xdrs, &objp->rpc_loc_server_request_u_type_u.close_req))
+			 return FALSE;
+		break;
+	default:
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_request_s_type (XDR *xdrs, rpc_loc_server_request_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_server_request_e_type (xdrs, &objp->event))
+		 return FALSE;
+	 if (!xdr_rpc_loc_server_request_u_type (xdrs, &objp->payload))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_qwip_request_e_type (XDR *xdrs, rpc_loc_qwip_request_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_qwip_request_s_type (XDR *xdrs, rpc_loc_qwip_request_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_qwip_request_e_type (xdrs, &objp->request_type))
+		 return FALSE;
+	 if (!xdr_rpc_uint16 (xdrs, &objp->tbf_ms))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_reserved_payload_s_type (XDR *xdrs, rpc_loc_reserved_payload_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint16 (xdrs, &objp->data_size))
+		 return FALSE;
+	 if (!xdr_bytes (xdrs, (char **)&objp->data.data_val, (u_int *) &objp->data.data_len, ~0))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ioctl_e_type (XDR *xdrs, rpc_loc_ioctl_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_api_version_s_type (XDR *xdrs, rpc_loc_api_version_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_u_char (xdrs, &objp->major))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->minor))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_fix_recurrence_e_type (XDR *xdrs, rpc_loc_fix_recurrence_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_operation_mode_e_type (XDR *xdrs, rpc_loc_operation_mode_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_notify_e_type (XDR *xdrs, rpc_loc_notify_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_fix_criteria_s_type (XDR *xdrs, rpc_loc_fix_criteria_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint32 (xdrs, &objp->valid_mask))
+		 return FALSE;
+	 if (!xdr_rpc_loc_fix_recurrence_e_type (xdrs, &objp->recurrence_type))
+		 return FALSE;
+	 if (!xdr_rpc_loc_operation_mode_e_type (xdrs, &objp->preferred_operation_mode))
+		 return FALSE;
+	 if (!xdr_rpc_uint32 (xdrs, &objp->preferred_accuracy))
+		 return FALSE;
+	 if (!xdr_rpc_uint32 (xdrs, &objp->preferred_response_time))
+		 return FALSE;
+	 if (!xdr_rpc_boolean (xdrs, &objp->intermediate_pos_report_enabled))
+		 return FALSE;
+	 if (!xdr_rpc_loc_notify_e_type (xdrs, &objp->notify_type))
+		 return FALSE;
+	 if (!xdr_rpc_uint32 (xdrs, &objp->min_interval))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->min_distance))
+		 return FALSE;
+	 if (!xdr_rpc_uint32 (xdrs, &objp->min_dist_sample_interval))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_user_resp_e_type (XDR *xdrs, rpc_loc_ni_user_resp_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_user_verify_s_type (XDR *xdrs, rpc_loc_user_verify_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_ni_user_resp_e_type (xdrs, &objp->user_resp))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_event_s_type (xdrs, &objp->ni_event_pass_back))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_predicted_orbits_data_format_e_type (XDR *xdrs, rpc_loc_predicted_orbits_data_format_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_predicted_orbits_data_s_type (XDR *xdrs, rpc_loc_predicted_orbits_data_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_predicted_orbits_data_format_e_type (xdrs, &objp->format_type))
+		 return FALSE;
+	 if (!xdr_rpc_uint32 (xdrs, &objp->total_size))
+		 return FALSE;
+	 if (!xdr_rpc_uint8 (xdrs, &objp->total_parts))
+		 return FALSE;
+	 if (!xdr_rpc_uint8 (xdrs, &objp->part))
+		 return FALSE;
+	 if (!xdr_rpc_uint16 (xdrs, &objp->part_len))
+		 return FALSE;
+	 if (!xdr_bytes (xdrs, (char **)&objp->data_ptr.data_ptr_val, (u_int *) &objp->data_ptr.data_ptr_len, ~0))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_predicted_orbits_data_validity_report_s_type (XDR *xdrs, rpc_loc_predicted_orbits_data_validity_report_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint64 (xdrs, &objp->start_time_utc))
+		 return FALSE;
+	 if (!xdr_rpc_uint16 (xdrs, &objp->valid_duration_hrs))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_predicted_orbits_auto_download_config_s_type (XDR *xdrs, rpc_loc_predicted_orbits_auto_download_config_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_boolean (xdrs, &objp->enable))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->auto_check_every_hrs))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_assist_data_time_s_type (XDR *xdrs, rpc_loc_assist_data_time_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint64 (xdrs, &objp->time_utc))
+		 return FALSE;
+	 if (!xdr_rpc_uint32 (xdrs, &objp->uncertainty))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_assist_pos_valid_mask_type (XDR *xdrs, rpc_loc_assist_pos_valid_mask_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint64 (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_assist_data_pos_s_type (XDR *xdrs, rpc_loc_assist_data_pos_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_assist_pos_valid_mask_type (xdrs, &objp->valid_mask))
+		 return FALSE;
+	 if (!xdr_rpc_uint64 (xdrs, &objp->timestamp_utc))
+		 return FALSE;
+	 if (!xdr_double (xdrs, &objp->latitude))
+		 return FALSE;
+	 if (!xdr_double (xdrs, &objp->longitude))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->altitude_wrt_ellipsoid))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->altitude_wrt_mean_sea_level))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->hor_unc_circular))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->vert_unc))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->confidence_horizontal))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->confidence_vertical))
+		 return FALSE;
+	 if (!xdr_rpc_int32 (xdrs, &objp->timestamp_age))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_open_status_e_type (XDR *xdrs, rpc_loc_server_open_status_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_open_status_s_type (XDR *xdrs, rpc_loc_server_open_status_s_type *objp)
+{
+	register int32_t *buf;
+
+	int i;
+	 if (!xdr_rpc_loc_server_connection_handle (xdrs, &objp->conn_handle))
+		 return FALSE;
+	 if (!xdr_rpc_loc_server_open_status_e_type (xdrs, &objp->open_status))
+		 return FALSE;
+	 if (!xdr_opaque (xdrs, objp->apn_name, 100))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_close_status_e_type (XDR *xdrs, rpc_loc_server_close_status_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_close_status_s_type (XDR *xdrs, rpc_loc_server_close_status_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_server_connection_handle (xdrs, &objp->conn_handle))
+		 return FALSE;
+	 if (!xdr_rpc_loc_server_close_status_e_type (xdrs, &objp->close_status))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_wiper_fix_time_s_type (XDR *xdrs, rpc_loc_wiper_fix_time_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint32 (xdrs, &objp->slow_clock_count))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_wiper_fix_pos_s_type (XDR *xdrs, rpc_loc_wiper_fix_pos_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_int32 (xdrs, &objp->lat))
+		 return FALSE;
+	 if (!xdr_rpc_int32 (xdrs, &objp->lon))
+		 return FALSE;
+	 if (!xdr_rpc_uint16 (xdrs, &objp->HEPE))
+		 return FALSE;
+	 if (!xdr_rpc_uint8 (xdrs, &objp->num_of_aps_used))
+		 return FALSE;
+	 if (!xdr_rpc_uint8 (xdrs, &objp->fix_error_code))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_wiper_ap_info_s_type (XDR *xdrs, rpc_loc_wiper_ap_info_s_type *objp)
+{
+	register int32_t *buf;
+
+	int i;
+	 if (!xdr_opaque (xdrs, objp->mac_addr, 6))
+		 return FALSE;
+	 if (!xdr_rpc_int32 (xdrs, &objp->rssi))
+		 return FALSE;
+	 if (!xdr_rpc_uint16 (xdrs, &objp->channel))
+		 return FALSE;
+	 if (!xdr_rpc_uint8 (xdrs, &objp->ap_qualifier))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_wiper_ap_set_s_type (XDR *xdrs, rpc_loc_wiper_ap_set_s_type *objp)
+{
+	register int32_t *buf;
+
+	int i;
+	 if (!xdr_rpc_uint8 (xdrs, &objp->num_of_aps))
+		 return FALSE;
+	 if (!xdr_vector (xdrs, (char *)objp->ap_info, 50,
+		sizeof (rpc_loc_wiper_ap_info_s_type), (xdrproc_t) xdr_rpc_loc_wiper_ap_info_s_type))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_wiper_position_report_s_type (XDR *xdrs, rpc_loc_wiper_position_report_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint8 (xdrs, &objp->wiper_valid_info_flag))
+		 return FALSE;
+	 if (!xdr_rpc_loc_wiper_fix_time_s_type (xdrs, &objp->wiper_fix_time))
+		 return FALSE;
+	 if (!xdr_rpc_loc_wiper_fix_pos_s_type (xdrs, &objp->wiper_fix_position))
+		 return FALSE;
+	 if (!xdr_rpc_loc_wiper_ap_set_s_type (xdrs, &objp->wiper_ap_set))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_wiper_status_e_type (XDR *xdrs, rpc_loc_wiper_status_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_fs_operation_e_type (XDR *xdrs, rpc_loc_fs_operation_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_efs_data_s_type (XDR *xdrs, rpc_loc_efs_data_s_type *objp)
+{
+	register int32_t *buf;
+
+	int i;
+	 if (!xdr_opaque (xdrs, objp->filename, 64))
+		 return FALSE;
+	 if (!xdr_rpc_loc_fs_operation_e_type (xdrs, &objp->operation))
+		 return FALSE;
+	 if (!xdr_rpc_uint32 (xdrs, &objp->total_size))
+		 return FALSE;
+	 if (!xdr_bytes (xdrs, (char **)&objp->data_ptr.data_ptr_val, (u_int *) &objp->data_ptr.data_ptr_len, ~0))
+		 return FALSE;
+	 if (!xdr_rpc_uint32 (xdrs, &objp->part_len))
+		 return FALSE;
+	 if (!xdr_rpc_uint8 (xdrs, &objp->part))
+		 return FALSE;
+	 if (!xdr_rpc_uint8 (xdrs, &objp->total_parts))
+		 return FALSE;
+	 if (!xdr_rpc_uint32 (xdrs, &objp->reserved))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_lock_e_type (XDR *xdrs, rpc_loc_lock_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_nmea_sentence_type (XDR *xdrs, rpc_loc_nmea_sentence_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint32 (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_assist_data_type (XDR *xdrs, rpc_loc_assist_data_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint32 (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_assist_data_delete_s_type (XDR *xdrs, rpc_loc_assist_data_delete_s_type *objp)
+{
+	register int32_t *buf;
+
+	int i;
+	 if (!xdr_rpc_loc_assist_data_type (xdrs, &objp->type))
+		 return FALSE;
+	 if (!xdr_vector (xdrs, (char *)objp->reserved, 8,
+		sizeof (rpc_uint32), (xdrproc_t) xdr_rpc_uint32))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ioctl_data_u_type (XDR *xdrs, rpc_loc_ioctl_data_u_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_ioctl_e_type (xdrs, &objp->disc))
+		 return FALSE;
+	switch (objp->disc) {
+	case RPC_LOC_IOCTL_SET_FIX_CRITERIA:
+		 if (!xdr_rpc_loc_fix_criteria_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.fix_criteria))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_INFORM_NI_USER_RESPONSE:
+		 if (!xdr_rpc_loc_user_verify_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.user_verify_resp))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_INJECT_PREDICTED_ORBITS_DATA:
+		 if (!xdr_rpc_loc_predicted_orbits_data_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.predicted_orbits_data))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_SET_PREDICTED_ORBITS_DATA_AUTO_DOWNLOAD:
+		 if (!xdr_rpc_loc_predicted_orbits_auto_download_config_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.predicted_orbits_auto_download))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_INJECT_UTC_TIME:
+		 if (!xdr_rpc_loc_assist_data_time_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.assistance_data_time))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_INJECT_POSITION:
+		 if (!xdr_rpc_loc_assist_data_pos_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.assistance_data_position))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_INFORM_SERVER_OPEN_STATUS:
+		 if (!xdr_rpc_loc_server_open_status_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.conn_open_status))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_INFORM_SERVER_CLOSE_STATUS:
+		 if (!xdr_rpc_loc_server_close_status_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.conn_close_status))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_SEND_WIPER_POSITION_REPORT:
+		 if (!xdr_rpc_loc_wiper_position_report_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.wiper_pos))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_NOTIFY_WIPER_STATUS:
+		 if (!xdr_rpc_loc_wiper_status_e_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.wiper_status))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_SET_ENGINE_LOCK:
+		 if (!xdr_rpc_loc_lock_e_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.engine_lock))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_SET_SBAS_CONFIG:
+		 if (!xdr_rpc_boolean (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.sbas_mode))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_SET_NMEA_TYPES:
+		 if (!xdr_rpc_loc_nmea_sentence_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.nmea_types))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_SET_ON_DEMAND_LPM:
+		 if (!xdr_rpc_boolean (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.on_demand_lpm))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_SET_CDMA_PDE_SERVER_ADDR:
+	case RPC_LOC_IOCTL_SET_CDMA_MPC_SERVER_ADDR:
+	case RPC_LOC_IOCTL_SET_UMTS_SLP_SERVER_ADDR:
+	case RPC_LOC_IOCTL_SET_CUSTOM_PDE_SERVER_ADDR:
+		 if (!xdr_rpc_loc_server_info_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.server_addr))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_DELETE_ASSIST_DATA:
+		 if (!xdr_rpc_loc_assist_data_delete_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.assist_data_delete))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_ACCESS_EFS_DATA:
+		 if (!xdr_rpc_loc_efs_data_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.efs_data))
+			 return FALSE;
+		break;
+	default:
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ioctl_callback_data_u_type (XDR *xdrs, rpc_loc_ioctl_callback_data_u_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_ioctl_e_type (xdrs, &objp->disc))
+		 return FALSE;
+	switch (objp->disc) {
+	case RPC_LOC_IOCTL_GET_API_VERSION:
+		 if (!xdr_rpc_loc_api_version_s_type (xdrs, &objp->rpc_loc_ioctl_callback_data_u_type_u.api_version))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_GET_FIX_CRITERIA:
+		 if (!xdr_rpc_loc_fix_criteria_s_type (xdrs, &objp->rpc_loc_ioctl_callback_data_u_type_u.fix_criteria))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_GET_ENGINE_LOCK:
+		 if (!xdr_rpc_loc_lock_e_type (xdrs, &objp->rpc_loc_ioctl_callback_data_u_type_u.engine_lock))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_GET_SBAS_CONFIG:
+		 if (!xdr_rpc_boolean (xdrs, &objp->rpc_loc_ioctl_callback_data_u_type_u.sbas_mode))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_GET_NMEA_TYPES:
+		 if (!xdr_rpc_loc_nmea_sentence_type (xdrs, &objp->rpc_loc_ioctl_callback_data_u_type_u.nmea_types))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_GET_ON_DEMAND_LPM:
+		 if (!xdr_rpc_boolean (xdrs, &objp->rpc_loc_ioctl_callback_data_u_type_u.on_demand_lpm))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_GET_CDMA_PDE_SERVER_ADDR:
+	case RPC_LOC_IOCTL_GET_CDMA_MPC_SERVER_ADDR:
+	case RPC_LOC_IOCTL_GET_UMTS_SLP_SERVER_ADDR:
+	case RPC_LOC_IOCTL_GET_CUSTOM_PDE_SERVER_ADDR:
+		 if (!xdr_rpc_loc_server_info_s_type (xdrs, &objp->rpc_loc_ioctl_callback_data_u_type_u.server_addr))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_SOURCE:
+		 if (!xdr_rpc_loc_predicted_orbits_data_source_s_type (xdrs, &objp->rpc_loc_ioctl_callback_data_u_type_u.predicted_orbits_data_source))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_VALIDITY:
+		 if (!xdr_rpc_loc_predicted_orbits_data_validity_report_s_type (xdrs, &objp->rpc_loc_ioctl_callback_data_u_type_u.predicted_orbits_data_validity))
+			 return FALSE;
+		break;
+	default:
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ioctl_callback_s_type (XDR *xdrs, rpc_loc_ioctl_callback_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_ioctl_e_type (xdrs, &objp->type))
+		 return FALSE;
+	 if (!xdr_rpc_int32 (xdrs, &objp->status))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ioctl_callback_data_u_type (xdrs, &objp->data))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_event_payload_u_type (XDR *xdrs, rpc_loc_event_payload_u_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_u_quad_t (xdrs, &objp->disc))
+		 return FALSE;
+	switch (objp->disc) {
+	case RPC_LOC_EVENT_PARSED_POSITION_REPORT:
+		 if (!xdr_rpc_loc_parsed_position_s_type (xdrs, &objp->rpc_loc_event_payload_u_type_u.parsed_location_report))
+			 return FALSE;
+		break;
+	case RPC_LOC_EVENT_SATELLITE_REPORT:
+		 if (!xdr_rpc_loc_gnss_info_s_type (xdrs, &objp->rpc_loc_event_payload_u_type_u.gnss_report))
+			 return FALSE;
+		break;
+	case RPC_LOC_EVENT_NMEA_POSITION_REPORT:
+		 if (!xdr_rpc_loc_nmea_report_s_type (xdrs, &objp->rpc_loc_event_payload_u_type_u.nmea_report))
+			 return FALSE;
+		break;
+	case RPC_LOC_EVENT_NI_NOTIFY_VERIFY_REQUEST:
+		 if (!xdr_rpc_loc_ni_event_s_type (xdrs, &objp->rpc_loc_event_payload_u_type_u.ni_request))
+			 return FALSE;
+		break;
+	case RPC_LOC_EVENT_ASSISTANCE_DATA_REQUEST:
+		 if (!xdr_rpc_loc_assist_data_request_s_type (xdrs, &objp->rpc_loc_event_payload_u_type_u.assist_data_request))
+			 return FALSE;
+		break;
+	case RPC_LOC_EVENT_LOCATION_SERVER_REQUEST:
+		 if (!xdr_rpc_loc_server_request_s_type (xdrs, &objp->rpc_loc_event_payload_u_type_u.loc_server_request))
+			 return FALSE;
+		break;
+	case RPC_LOC_EVENT_IOCTL_REPORT:
+		 if (!xdr_rpc_loc_ioctl_callback_s_type (xdrs, &objp->rpc_loc_event_payload_u_type_u.ioctl_report))
+			 return FALSE;
+		break;
+	case RPC_LOC_EVENT_STATUS_REPORT:
+		 if (!xdr_rpc_loc_status_event_s_type (xdrs, &objp->rpc_loc_event_payload_u_type_u.status_report))
+			 return FALSE;
+		break;
+	case RPC_LOC_EVENT_WPS_NEEDED_REQUEST:
+		 if (!xdr_rpc_loc_qwip_request_s_type (xdrs, &objp->rpc_loc_event_payload_u_type_u.qwip_request))
+			 return FALSE;
+		break;
+	case RPC_LOC_EVENT_RESERVED:
+		 if (!xdr_rpc_loc_reserved_payload_s_type (xdrs, &objp->rpc_loc_event_payload_u_type_u.reserved))
+			 return FALSE;
+		break;
+	default:
+		break;
+	}
+	return TRUE;
+}
diff --git a/msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_fixup.c b/msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_fixup.c
new file mode 100644
index 0000000..fe512f5
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_fixup.c
@@ -0,0 +1,48 @@
+/*=============================================================================
+                        L O C _ A P I _ F I X U P . C
+
+GENERAL DESCRIPTION
+  This file adds API constants that are not automatically transmitted to
+  the RPC stubs, and it also fixes other RPC-related problems.
+
+  ---------------------------------------------------------------------------
+Copyright (c) 2009, QUALCOMM USA, INC.
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+         Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 
+
+         Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. 
+
+         Neither the name of the QUALCOMM USA, INC.  nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  ---------------------------------------------------------------------------
+=============================================================================*/
+
+#include <rpc/rpc.h>
+
+#include "loc_api_fixup.h"
+
+#ifdef ADD_XDR_FLOAT
+
+int
+xdr_float(xdrp, fp)
+        XDR *xdrp; 
+        float *fp;
+{
+        return xdr_long(xdrp, (long*)fp);
+}    
+
+int  
+xdr_double(xdrp, dp)
+        XDR *xdrp;
+        double *dp; 
+{
+                return xdr_long(xdrp, (long*)dp + 1)
+                                && xdr_long(xdrp, (long*)dp);
+} 
+
+#endif /* ADD_XDR_FLOAT */
diff --git a/msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_rpc_glue.c b/msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_rpc_glue.c
new file mode 100644
index 0000000..fbaca8b
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_rpc_glue.c
@@ -0,0 +1,339 @@
+/******************************************************************************
+  @file  loc_api_rpc_glue.c
+  @brief Android Loc API glue code using rpcgen.
+
+  DESCRIPTION
+  Loc API glue code for Android
+
+  -----------------------------------------------------------------------------
+Copyright (c) 2009, QUALCOMM USA, INC.
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+         Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 
+
+         Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. 
+
+         Neither the name of the QUALCOMM USA, INC.  nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  -----------------------------------------------------------------------------
+ ******************************************************************************/
+/*=====================================================================
+                        EDIT HISTORY FOR MODULE
+
+  This section contains comments describing changes made to the module.
+  Notice that changes are listed in reverse chronological order.
+
+when       who      what, where, why 
+--------   ---      ------------------------------------------------------- 
+03/05/2009   dx       Initial version
+
+======================================================================*/ 
+/*=====================================================================
+
+                     INCLUDE FILES FOR MODULE
+
+======================================================================*/
+//#define LOG_NDDEBUG 0
+
+#include <stdio.h>
+#include <pthread.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/select.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <assert.h>
+
+#include <rpc/rpc.h>
+#include <rpc/clnt.h>
+
+/* Include RPC headers */
+#include "loc_api_rpc_glue.h"
+
+/* Callback init */
+#include "loc_apicb_appinit.h"
+
+/* Logging */
+#define LOG_TAG "lib_api_rpc_glue"
+#include <utils/Log.h>
+
+/* Comment this out to enable logging */
+#undef LOGD
+#define LOGD(...) {}
+
+/*=====================================================================
+     External declarations
+======================================================================*/
+
+CLIENT* loc_api_clnt = NULL;
+
+/* Callback ID and pointer */
+#define LOC_API_CB_ID 1 
+loc_event_cb_f_type *loc_api_saved_cb = NULL;  /* the only callback of Loc API client */
+
+#define RPC_FUNC_VERSION_BASE(a,b) a ## b
+#define RPC_FUNC_VERSION(a,b) RPC_FUNC_VERSION_BASE(a,b)
+
+#define LOC_GLUE_CHECK_INIT(ret_type) \
+   if (loc_api_clnt == NULL) { return (ret_type) RPC_LOC_API_RPC_FAILURE; }
+
+#define LOC_GLUE_CHECK_RESULT(stat, ret_type) \
+   if (stat != RPC_SUCCESS) { return (ret_type) RPC_LOC_API_RPC_FAILURE; }   
+
+/* Callback functions */
+/* Returns 1 if successful */
+bool_t rpc_loc_event_cb_f_type_0x00040001_svc(
+        rpc_loc_event_cb_f_type_args *argp,
+        rpc_loc_event_cb_f_type_rets *ret,
+        struct svc_req *req)
+{
+    /* Callback not registered, or unexpected ID (shouldn't happen) */
+    if (loc_api_saved_cb == NULL || argp->cb_id != LOC_API_CB_ID)
+    {
+        LOGD("Warning: No callback handler.\n");
+        ret->loc_event_cb_f_type_result = 0;
+        return 1; /* simply return */
+    }
+
+    LOGD("proc: %x  prog: %x  vers: %x\n",
+            (int) req->rq_proc,
+            (int) req->rq_prog,
+            (int) req->rq_vers);
+
+    LOGD("Callback received: %x (handle=%d ret_ptr=%d)\n",
+            (int) argp->loc_event,
+            (int) argp->loc_handle,
+            (int) ret);
+
+    /* Forward callback to real callback procedure */
+    rpc_loc_client_handle_type        loc_handle = argp->loc_handle;
+    rpc_loc_event_mask_type           loc_event  = argp->loc_event;
+    const rpc_loc_event_payload_u_type*  loc_event_payload =
+        (const rpc_loc_event_payload_u_type*) argp->loc_event_payload;
+
+    int32 rc = loc_api_saved_cb(loc_handle, loc_event, loc_event_payload);
+    ret->loc_event_cb_f_type_result = rc;
+
+    return 1; /* ok */
+}
+
+int loc_apicbprog_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
+{
+    xdr_free (xdr_result, result);
+
+    /*
+     * Insert additional freeing code here, if needed
+     */
+    // LOGD("***** loc_apicbprog_freeresult\n");
+
+    return 1;
+}
+
+int loc_apicbprog_0x00040001_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
+{
+    return loc_apicbprog_freeresult (transp, xdr_result, result);
+}
+
+/*===========================================================================
+
+FUNCTION loc_api_glue_init
+
+DESCRIPTION
+   Initiates the RPC client
+
+RETURN VALUE
+   1 for success
+   0 for failure
+   
+===========================================================================*/
+int loc_api_glue_init(void)
+{
+    if (loc_api_clnt == NULL)
+    {
+        /* Print msg */
+        LOGD("Trying to create RPC client...\n");
+        loc_api_clnt = clnt_create(NULL, LOC_APIPROG, LOC_APIVERS, NULL);
+        LOGD("Created loc_api_clnt ---- %x\n", (unsigned int)loc_api_clnt);
+
+        if (loc_api_clnt == NULL)
+        {
+            fprintf(stderr, "Error: cannot create RPC client.\n");
+            return 0;
+        }
+
+        /* Init RPC callbacks */
+        int rc = loc_apicb_app_init();
+        if (rc >= 0)
+        {
+            LOGD("Loc API callback initialized.\n");
+        } else {
+            fprintf(stderr, "Loc API callback initialization failed.\n");
+            return 0;
+        }
+    }
+
+    return 1;
+}
+
+rpc_loc_client_handle_type loc_open (
+        rpc_loc_event_mask_type  event_reg_mask,
+        loc_event_cb_f_type      *event_callback
+    )
+{
+    LOC_GLUE_CHECK_INIT(rpc_loc_client_handle_type);
+
+    rpc_loc_open_args args;
+    args.event_reg_mask = event_reg_mask;
+    args.event_callback = LOC_API_CB_ID;
+    loc_api_saved_cb = event_callback;
+
+    rpc_loc_open_rets rets;
+    enum clnt_stat stat = RPC_SUCCESS;
+
+    stat = RPC_FUNC_VERSION(rpc_loc_open_, /* LOC_APIVERS */ 0x00040001)(&args, &rets, loc_api_clnt);
+    LOC_GLUE_CHECK_RESULT(stat, int32);
+
+    return (rpc_loc_client_handle_type) rets.loc_open_result;
+}
+
+int32 loc_close(rpc_loc_client_handle_type handle)
+{
+    LOC_GLUE_CHECK_INIT(int32);
+
+    rpc_loc_close_args args;
+    args.handle = handle;
+
+    rpc_loc_close_rets rets;
+    enum clnt_stat stat = RPC_SUCCESS;
+
+    stat = RPC_FUNC_VERSION(rpc_loc_close_, /* LOC_APIVERS */ 0x00040001)(&args, &rets, loc_api_clnt);
+    LOC_GLUE_CHECK_RESULT(stat, int32);
+
+    return (int32) rets.loc_close_result;
+}
+
+int32 loc_start_fix(rpc_loc_client_handle_type handle)
+{
+    LOC_GLUE_CHECK_INIT(int32);
+
+    rpc_loc_start_fix_args args;
+    args.handle = handle;
+
+    rpc_loc_start_fix_rets rets;
+    enum clnt_stat stat = RPC_SUCCESS;
+
+    stat = RPC_FUNC_VERSION(rpc_loc_start_fix_, /* LOC_APIVERS */ 0x00040001)(&args, &rets, loc_api_clnt);
+    LOC_GLUE_CHECK_RESULT(stat, int32);
+
+    return (int32) rets.loc_start_fix_result;
+}
+
+int32 loc_stop_fix(rpc_loc_client_handle_type handle)
+{
+    LOC_GLUE_CHECK_INIT(int32);
+
+    rpc_loc_stop_fix_args args;
+    args.handle = handle;
+
+    rpc_loc_stop_fix_rets rets;
+    enum clnt_stat stat = RPC_SUCCESS;
+
+    stat = RPC_FUNC_VERSION(rpc_loc_stop_fix_, /* LOC_APIVERS */ 0x00040001)(&args, &rets, loc_api_clnt);
+    LOC_GLUE_CHECK_RESULT(stat, int32);
+
+    return (int32) rets.loc_stop_fix_result;
+}
+
+int32 loc_ioctl(
+    rpc_loc_client_handle_type           handle,
+    rpc_loc_ioctl_e_type                 ioctl_type,
+    rpc_loc_ioctl_data_u_type*           ioctl_data
+    )
+{
+    LOC_GLUE_CHECK_INIT(int32);
+
+    rpc_loc_ioctl_args args;
+    args.handle = handle;
+    args.ioctl_data = ioctl_data;
+    args.ioctl_type = ioctl_type;
+    if (ioctl_data != NULL)
+    {
+        /* Assign ioctl union discriminator */
+        ioctl_data->disc = ioctl_type;
+
+        /* In case the user hasn't filled in other disc fields,
+           automatically fill them in here */
+        switch (ioctl_type)
+        {
+            case RPC_LOC_IOCTL_GET_API_VERSION:
+            case RPC_LOC_IOCTL_SET_FIX_CRITERIA:
+            case RPC_LOC_IOCTL_GET_FIX_CRITERIA:
+            case RPC_LOC_IOCTL_INFORM_NI_USER_RESPONSE:
+            case RPC_LOC_IOCTL_INJECT_PREDICTED_ORBITS_DATA:
+            case RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_VALIDITY:
+            case RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_SOURCE:
+            case RPC_LOC_IOCTL_SET_PREDICTED_ORBITS_DATA_AUTO_DOWNLOAD:
+            case RPC_LOC_IOCTL_INJECT_UTC_TIME:
+            case RPC_LOC_IOCTL_INJECT_RTC_VALUE:
+            case RPC_LOC_IOCTL_INJECT_POSITION:
+            case RPC_LOC_IOCTL_QUERY_ENGINE_STATE:
+            case RPC_LOC_IOCTL_INFORM_SERVER_OPEN_STATUS:
+            case RPC_LOC_IOCTL_INFORM_SERVER_CLOSE_STATUS:
+            case RPC_LOC_IOCTL_SET_ENGINE_LOCK:
+            case RPC_LOC_IOCTL_GET_ENGINE_LOCK:
+            case RPC_LOC_IOCTL_SET_SBAS_CONFIG:
+            case RPC_LOC_IOCTL_GET_SBAS_CONFIG:
+            case RPC_LOC_IOCTL_SET_NMEA_TYPES:
+            case RPC_LOC_IOCTL_GET_NMEA_TYPES:
+                break;
+            case RPC_LOC_IOCTL_SET_CDMA_PDE_SERVER_ADDR:
+            case RPC_LOC_IOCTL_SET_CDMA_MPC_SERVER_ADDR:
+            case RPC_LOC_IOCTL_SET_UMTS_SLP_SERVER_ADDR:
+                args.ioctl_data->rpc_loc_ioctl_data_u_type_u.server_addr.addr_info.disc =
+                    args.ioctl_data->rpc_loc_ioctl_data_u_type_u.server_addr.addr_type;
+                break;
+            case RPC_LOC_IOCTL_GET_CDMA_PDE_SERVER_ADDR:
+            case RPC_LOC_IOCTL_GET_CDMA_MPC_SERVER_ADDR:
+            case RPC_LOC_IOCTL_GET_UMTS_SLP_SERVER_ADDR:
+                break;
+            case RPC_LOC_IOCTL_SET_ON_DEMAND_LPM:
+            case RPC_LOC_IOCTL_GET_ON_DEMAND_LPM:
+            case RPC_LOC_IOCTL_DELETE_ASSIST_DATA:
+            case RPC_LOC_IOCTL_SET_CUSTOM_PDE_SERVER_ADDR:
+            case RPC_LOC_IOCTL_GET_CUSTOM_PDE_SERVER_ADDR:
+            default:
+                break;
+        } /* switch */
+    } /* ioctl_data != NULL */
+
+    rpc_loc_ioctl_rets rets;
+    enum clnt_stat stat = RPC_SUCCESS;
+
+    stat = RPC_FUNC_VERSION(rpc_loc_ioctl_, /* LOC_APIVERS */ 0x00040001)(&args, &rets, loc_api_clnt);
+    LOC_GLUE_CHECK_RESULT(stat, int32);
+
+    return (int32) rets.loc_ioctl_result;
+}
+
+/* Returns 0 if error */
+int32 loc_api_null(void)
+{
+    LOC_GLUE_CHECK_INIT(int32);
+
+    int32 rets;
+    enum clnt_stat stat = RPC_SUCCESS;
+
+    stat = RPC_FUNC_VERSION(rpc_loc_api_null_, LOC_APIVERS)(NULL, &rets, loc_api_clnt);
+    LOC_GLUE_CHECK_RESULT(stat, int32);
+
+    return (int32) rets;
+}
diff --git a/msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_xdr.c b/msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_xdr.c
new file mode 100644
index 0000000..835f6b1
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/gen-1240/loc_api_xdr.c
@@ -0,0 +1,171 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#include "loc_api.h"
+
+bool_t
+xdr_rpc_loc_api_api_versions_return_type (XDR *xdrs, rpc_loc_api_api_versions_return_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_array (xdrs, (char **)&objp->rpc_loc_api_api_versions_return_type_val, (u_int *) &objp->rpc_loc_api_api_versions_return_type_len, ~0,
+		sizeof (rpc_uint32), (xdrproc_t) xdr_rpc_uint32))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_event_cb_f_type (XDR *xdrs, rpc_loc_event_cb_f_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint32 (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_open_args (XDR *xdrs, rpc_loc_open_args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_event_mask_type (xdrs, &objp->event_reg_mask))
+		 return FALSE;
+	 if (!xdr_rpc_loc_event_cb_f_type (xdrs, &objp->event_callback))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_close_args (XDR *xdrs, rpc_loc_close_args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_client_handle_type (xdrs, &objp->handle))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_start_fix_args (XDR *xdrs, rpc_loc_start_fix_args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_client_handle_type (xdrs, &objp->handle))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_stop_fix_args (XDR *xdrs, rpc_loc_stop_fix_args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_client_handle_type (xdrs, &objp->handle))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ioctl_args (XDR *xdrs, rpc_loc_ioctl_args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_client_handle_type (xdrs, &objp->handle))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ioctl_e_type (xdrs, &objp->ioctl_type))
+		 return FALSE;
+	 if (!xdr_pointer (xdrs, (char **)&objp->ioctl_data, sizeof (rpc_loc_ioctl_data_u_type), (xdrproc_t) xdr_rpc_loc_ioctl_data_u_type))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_api_api_version_s_args (XDR *xdrs, rpc_loc_api_api_version_s_args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_boolean (xdrs, &objp->len_not_null))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_api_rpc_glue_code_info_remote_rets (XDR *xdrs, rpc_loc_api_rpc_glue_code_info_remote_rets *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint32 (xdrs, &objp->toolvers))
+		 return FALSE;
+	 if (!xdr_rpc_uint32 (xdrs, &objp->features))
+		 return FALSE;
+	 if (!xdr_rpc_uint32 (xdrs, &objp->proghash))
+		 return FALSE;
+	 if (!xdr_rpc_uint32 (xdrs, &objp->cbproghash))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_open_rets (XDR *xdrs, rpc_loc_open_rets *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_client_handle_type (xdrs, &objp->loc_open_result))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_close_rets (XDR *xdrs, rpc_loc_close_rets *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_int32 (xdrs, &objp->loc_close_result))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_start_fix_rets (XDR *xdrs, rpc_loc_start_fix_rets *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_int32 (xdrs, &objp->loc_start_fix_result))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_stop_fix_rets (XDR *xdrs, rpc_loc_stop_fix_rets *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_int32 (xdrs, &objp->loc_stop_fix_result))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ioctl_rets (XDR *xdrs, rpc_loc_ioctl_rets *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_int32 (xdrs, &objp->loc_ioctl_result))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_api_api_versions_rets (XDR *xdrs, rpc_loc_api_api_versions_rets *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_api_api_versions_return_type (xdrs, &objp->loc_api_api_versions_result))
+		 return FALSE;
+	 if (!xdr_pointer (xdrs, (char **)&objp->len, sizeof (rpc_uint32), (xdrproc_t) xdr_rpc_uint32))
+		 return FALSE;
+	return TRUE;
+}
diff --git a/msm8974/loc_api/libloc_api-rpc/gen-3200/Makefile.xdr b/msm8974/loc_api/libloc_api-rpc/gen-3200/Makefile.xdr
new file mode 100644
index 0000000..5d9cf6c
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/gen-3200/Makefile.xdr
@@ -0,0 +1,29 @@
+CLIENTS:= loc_api
+SERVERS:= loc_api_cb
+COMMON:= loc_api_common
+RPC_INC:= inc-$(AMSS_VERSION)
+
+all: $(CLIENTS) $(SERVERS) $(COMMON) fixup
+
+$(CLIENTS) $(SERVERS) $(COMMON):: xdr = $(@:=.xdr) 
+
+$(CLIENTS) $(SERVERS) $(COMMON)::
+	rpcgen -h -M $(xdr) -o ../$(RPC_INC)/$(addsuffix .h, $@)
+	rpcgen -c -M $(xdr) -o $(addsuffix _xdr.c, $@)
+
+$(CLIENTS)::
+	rpcgen -l -M $(xdr) -o $(addsuffix _clnt.c, $@)
+
+$(SERVERS)::
+	rpcgen -m -M $(xdr) -o $(addsuffix _svc.c, $@)
+
+fixup:
+	mv ../$(RPC_INC)/loc_api_common.h ../$(RPC_INC)/loc_api_common.h.bak
+	sed ../$(RPC_INC)/loc_api_common.h.bak -e "/#include <rpc/a#include \"loc_api_fixup.h\"" > ../$(RPC_INC)/loc_api_common.h
+	rm -f ../$(RPC_INC)/loc_api_common.h.bak
+
+clean:
+	rm -f $(addsuffix _clnt.c, $(CLIENTS))
+	rm -f $(addsuffix _svc.c, $(SERVERS))
+	rm -f $(addsuffix _xdr.c, $(CLIENTS) $(SERVERS) $(COMMON))
+	rm -f $(addprefix ../$(RPC_INC)/, $(addsuffix .h, $(CLIENTS) $(SERVERS) $(COMMON)))
diff --git a/msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api.xdr b/msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api.xdr
new file mode 100644
index 0000000..981266b
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api.xdr
@@ -0,0 +1,164 @@
+/* LOC_API TOOL VERSION: 3.28 */
+/*=============================================================================
+                             L O C _ A P I . X D R
+
+GENERAL DESCRIPTION
+  This is an AUTO GENERATED file that provides an xdr compatible definition of
+  the loc_api API.
+
+  ---------------------------------------------------------------------------
+Copyright (c) 2009, QUALCOMM USA, INC.
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+         Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 
+
+         Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. 
+
+         Neither the name of the QUALCOMM USA, INC.  nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  ---------------------------------------------------------------------------
+=============================================================================*/
+
+/*=============================================================================
+
+                              Edit History
+
+                             AUTO GENERATED
+
+Generated by following versions of Htorpc modules:
+Id: //source/qcom/qct/core/mproc/tools/rel/03.01/htorpc/htorpc.pl#9 
+Id: //source/qcom/qct/core/mproc/tools/rel/03.01/htorpc/lib/Htorpc/Start.pm#4 
+Id: //source/qcom/qct/core/mproc/tools/rel/03.01/htorpc/lib/Htorpc/Htoxdr.pm#1 
+Id: //source/qcom/qct/core/mproc/tools/rel/03.01/htorpc/lib/Htorpc/XDR.pm#7 
+Id: //source/qcom/qct/core/mproc/tools/rel/03.01/htorpc/lib/Htorpc/Output.pm#26 
+Id: //source/qcom/qct/core/mproc/tools/rel/03.01/htorpc/lib/Htorpc/Parser.pm#3 
+Id: //source/qcom/qct/core/mproc/tools/rel/03.01/htorpc/lib/Htorpc/Metacomments.pm#2 
+Id: //source/qcom/qct/core/mproc/tools/rel/03.01/htorpc/lib/Htorpc/SymbolTable.pm#4 
+
+=============================================================================*/
+/*=============================================================================
+$Header$ 
+=============================================================================*/
+
+
+
+typedef rpc_uint32 rpc_loc_api_api_versions_return_type<>;
+
+/*
+ * Declare an rpc_uint32 type for each callback type in the API
+ */
+typedef rpc_uint32 rpc_loc_event_cb_f_type;
+
+
+
+/*
+ * These are struct declarations for the function arguments
+ */
+
+struct rpc_loc_open_args {
+  rpc_loc_event_mask_type event_reg_mask;
+  rpc_loc_event_cb_f_type event_callback;
+};
+
+struct rpc_loc_close_args {
+  rpc_loc_client_handle_type handle;
+};
+
+struct rpc_loc_start_fix_args {
+  rpc_loc_client_handle_type handle;
+};
+
+struct rpc_loc_stop_fix_args {
+  rpc_loc_client_handle_type handle;
+};
+
+struct rpc_loc_ioctl_args {
+  rpc_loc_client_handle_type handle;
+  rpc_loc_ioctl_e_type ioctl_type;
+  rpc_loc_ioctl_data_u_type *ioctl_data;
+};
+
+
+
+struct rpc_loc_api_api_version_s_args {
+  rpc_boolean len_not_null;
+};
+
+/*
+ * These are struct declarations for the function results
+ */
+
+struct rpc_loc_api_rpc_glue_code_info_remote_rets {
+  rpc_uint32 toolvers;   /* Tool version */
+  rpc_uint32 features;   /* Features turned on in the code.
+                          * 0x00000001    ONCRPC Server Cleanup Support
+                          */
+  rpc_uint32 proghash;   /* Unique hash value for the API XDR definition */
+  rpc_uint32 cbproghash; /* Unique hash value for the Callbacks' XDR definition */
+};
+
+struct rpc_loc_open_rets {
+  rpc_loc_client_handle_type loc_open_result;
+};
+
+struct rpc_loc_close_rets {
+  rpc_int32 loc_close_result;
+};
+
+struct rpc_loc_start_fix_rets {
+  rpc_int32 loc_start_fix_result;
+};
+
+struct rpc_loc_stop_fix_rets {
+  rpc_int32 loc_stop_fix_result;
+};
+
+struct rpc_loc_ioctl_rets {
+  rpc_int32 loc_ioctl_result;
+};
+
+ struct rpc_loc_api_api_versions_rets {
+  rpc_loc_api_api_versions_return_type loc_api_api_versions_result;
+  rpc_uint32 *len;
+};
+
+/*
+ * XDR definition of the LOC_API program ( vers. 0x00010001 )
+ */
+
+program LOC_APIPROG {
+  version LOC_APIVERS_0001 {
+
+    void
+      rpc_loc_api_null( void ) = 0;
+
+    rpc_loc_api_rpc_glue_code_info_remote_rets
+      rpc_loc_api_rpc_glue_code_info_remote( void ) = 1;
+
+    rpc_loc_open_rets
+      rpc_loc_open( rpc_loc_open_args ) = 2;
+
+    rpc_loc_close_rets
+      rpc_loc_close( rpc_loc_close_args ) = 3;
+
+    rpc_loc_start_fix_rets
+      rpc_loc_start_fix( rpc_loc_start_fix_args ) = 4;
+
+    rpc_loc_stop_fix_rets
+      rpc_loc_stop_fix( rpc_loc_stop_fix_args ) = 5;
+
+    rpc_loc_ioctl_rets
+      rpc_loc_ioctl( rpc_loc_ioctl_args ) = 6;
+
+      rpc_loc_api_api_versions_rets
+      rpc_loc_api_api_versions( void ) = 0xFFFFFFFF;
+
+
+  } = 0x00010001;
+} = 0x3000008c;
+
+const LOC_APIVERS = 0x00010001;
diff --git a/msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_cb.xdr b/msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_cb.xdr
new file mode 100644
index 0000000..3f53504
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_cb.xdr
@@ -0,0 +1,90 @@
+/* LOC_API TOOL VERSION: 3.28 */
+/*=============================================================================
+                          L O C _ A P I _ C B . X D R
+
+GENERAL DESCRIPTION
+  This is an AUTO GENERATED file that provides an xdr compatible definition of
+  an api that represents the grouping of the different callback functions the
+  loc_api API supports.
+
+  ---------------------------------------------------------------------------
+Copyright (c) 2009, QUALCOMM USA, INC.
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+         Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 
+
+         Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. 
+
+         Neither the name of the QUALCOMM USA, INC.  nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  ---------------------------------------------------------------------------
+=============================================================================*/
+
+/*=============================================================================
+
+                              Edit History
+
+                             AUTO GENERATED
+
+Generated by following versions of Htorpc modules:
+Id: //source/qcom/qct/core/mproc/tools/rel/03.01/htorpc/htorpc.pl#9 
+Id: //source/qcom/qct/core/mproc/tools/rel/03.01/htorpc/lib/Htorpc/Start.pm#4 
+Id: //source/qcom/qct/core/mproc/tools/rel/03.01/htorpc/lib/Htorpc/Htoxdr.pm#1 
+Id: //source/qcom/qct/core/mproc/tools/rel/03.01/htorpc/lib/Htorpc/XDR.pm#7 
+Id: //source/qcom/qct/core/mproc/tools/rel/03.01/htorpc/lib/Htorpc/Output.pm#26 
+Id: //source/qcom/qct/core/mproc/tools/rel/03.01/htorpc/lib/Htorpc/Parser.pm#3 
+Id: //source/qcom/qct/core/mproc/tools/rel/03.01/htorpc/lib/Htorpc/Metacomments.pm#2 
+Id: //source/qcom/qct/core/mproc/tools/rel/03.01/htorpc/lib/Htorpc/SymbolTable.pm#4 
+
+=============================================================================*/
+/*=============================================================================
+$Header$ 
+=============================================================================*/
+
+
+
+
+/*
+ * These are struct declarations for the function arguments
+ */
+
+struct rpc_loc_event_cb_f_type_args {
+  rpc_uint32 cb_id;
+  rpc_loc_client_handle_type loc_handle;
+  rpc_loc_event_mask_type loc_event;
+  rpc_loc_event_payload_u_type *loc_event_payload;
+};
+
+
+
+
+
+/*
+ * These are struct declaratios for the function results
+ */
+
+struct rpc_loc_event_cb_f_type_rets {
+  rpc_int32 loc_event_cb_f_type_result;
+};
+
+
+
+/*
+ * XDR definition of the LOC_API callback program ( vers. 0x00010001 )
+ */
+
+program LOC_APICBPROG {
+  version LOC_APICBVERS_0001 {
+
+    rpc_loc_event_cb_f_type_rets
+      rpc_loc_event_cb_f_type( rpc_loc_event_cb_f_type_args ) = 1;
+
+
+  } = 0x00010001;
+} = 0x3100008c;
+
+const LOC_APICBVERS = 0x00010001;
diff --git a/msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_cb_svc.c b/msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_cb_svc.c
new file mode 100644
index 0000000..b1aa199
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_cb_svc.c
@@ -0,0 +1,64 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#include "loc_api_cb.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <rpc/pmap_clnt.h>
+#include <string.h>
+#include <memory.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+
+#ifndef SIG_PF
+#define SIG_PF void(*)(int)
+#endif
+
+void
+loc_apicbprog_0x00010001(struct svc_req *rqstp, register SVCXPRT *transp)
+{
+	union {
+		rpc_loc_event_cb_f_type_args rpc_loc_event_cb_f_type_0x00010001_arg;
+	} argument;
+	union {
+		rpc_loc_event_cb_f_type_rets rpc_loc_event_cb_f_type_0x00010001_res;
+	} result;
+	bool_t retval;
+	xdrproc_t _xdr_argument, _xdr_result;
+	bool_t (*local)(char *, void *, struct svc_req *);
+
+	switch (rqstp->rq_proc) {
+	case NULLPROC:
+		(void) svc_sendreply (transp, (xdrproc_t) xdr_void, (char *)NULL);
+		return;
+
+	case rpc_loc_event_cb_f_type:
+		_xdr_argument = (xdrproc_t) xdr_rpc_loc_event_cb_f_type_args;
+		_xdr_result = (xdrproc_t) xdr_rpc_loc_event_cb_f_type_rets;
+		local = (bool_t (*) (char *, void *,  struct svc_req *))rpc_loc_event_cb_f_type_0x00010001_svc;
+		break;
+
+	default:
+		svcerr_noproc (transp);
+		return;
+	}
+	memset ((char *)&argument, 0, sizeof (argument));
+	if (!svc_getargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
+		svcerr_decode (transp);
+		return;
+	}
+	retval = (bool_t) (*local)((char *)&argument, (void *)&result, rqstp);
+	if (retval > 0 && !svc_sendreply(transp, (xdrproc_t) _xdr_result, (char *)&result)) {
+		svcerr_systemerr (transp);
+	}
+	if (!svc_freeargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
+		fprintf (stderr, "%s", "unable to free arguments");
+		exit (1);
+	}
+	if (!loc_apicbprog_0x00010001_freeresult (transp, _xdr_result, (caddr_t) &result))
+		fprintf (stderr, "%s", "unable to free results");
+
+	return;
+}
diff --git a/msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_cb_xdr.c b/msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_cb_xdr.c
new file mode 100644
index 0000000..1d7795e
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_cb_xdr.c
@@ -0,0 +1,32 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#include "loc_api_cb.h"
+
+bool_t
+xdr_rpc_loc_event_cb_f_type_args (XDR *xdrs, rpc_loc_event_cb_f_type_args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint32 (xdrs, &objp->cb_id))
+		 return FALSE;
+	 if (!xdr_rpc_loc_client_handle_type (xdrs, &objp->loc_handle))
+		 return FALSE;
+	 if (!xdr_rpc_loc_event_mask_type (xdrs, &objp->loc_event))
+		 return FALSE;
+	 if (!xdr_pointer (xdrs, (char **)&objp->loc_event_payload, sizeof (rpc_loc_event_payload_u_type), (xdrproc_t) xdr_rpc_loc_event_payload_u_type))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_event_cb_f_type_rets (XDR *xdrs, rpc_loc_event_cb_f_type_rets *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_int32 (xdrs, &objp->loc_event_cb_f_type_result))
+		 return FALSE;
+	return TRUE;
+}
diff --git a/msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_clnt.c b/msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_clnt.c
new file mode 100644
index 0000000..79814d4
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_clnt.c
@@ -0,0 +1,82 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#include <memory.h> /* for memset */
+#include "loc_api.h"
+
+/* Default timeout can be changed using clnt_control() */
+static struct timeval TIMEOUT = { 25, 0 };
+
+enum clnt_stat 
+rpc_loc_api_null_0x00010001(void *argp, void *clnt_res, CLIENT *clnt)
+{
+	return (clnt_call(clnt, rpc_loc_api_null,
+		(xdrproc_t) xdr_void, (caddr_t) argp,
+		(xdrproc_t) xdr_void, (caddr_t) clnt_res,
+		TIMEOUT));
+}
+
+enum clnt_stat 
+rpc_loc_api_rpc_glue_code_info_remote_0x00010001(void *argp, rpc_loc_api_rpc_glue_code_info_remote_rets *clnt_res, CLIENT *clnt)
+{
+	return (clnt_call(clnt, rpc_loc_api_rpc_glue_code_info_remote,
+		(xdrproc_t) xdr_void, (caddr_t) argp,
+		(xdrproc_t) xdr_rpc_loc_api_rpc_glue_code_info_remote_rets, (caddr_t) clnt_res,
+		TIMEOUT));
+}
+
+enum clnt_stat 
+rpc_loc_open_0x00010001(rpc_loc_open_args *argp, rpc_loc_open_rets *clnt_res, CLIENT *clnt)
+{
+	return (clnt_call(clnt, rpc_loc_open,
+		(xdrproc_t) xdr_rpc_loc_open_args, (caddr_t) argp,
+		(xdrproc_t) xdr_rpc_loc_open_rets, (caddr_t) clnt_res,
+		TIMEOUT));
+}
+
+enum clnt_stat 
+rpc_loc_close_0x00010001(rpc_loc_close_args *argp, rpc_loc_close_rets *clnt_res, CLIENT *clnt)
+{
+	return (clnt_call(clnt, rpc_loc_close,
+		(xdrproc_t) xdr_rpc_loc_close_args, (caddr_t) argp,
+		(xdrproc_t) xdr_rpc_loc_close_rets, (caddr_t) clnt_res,
+		TIMEOUT));
+}
+
+enum clnt_stat 
+rpc_loc_start_fix_0x00010001(rpc_loc_start_fix_args *argp, rpc_loc_start_fix_rets *clnt_res, CLIENT *clnt)
+{
+	return (clnt_call(clnt, rpc_loc_start_fix,
+		(xdrproc_t) xdr_rpc_loc_start_fix_args, (caddr_t) argp,
+		(xdrproc_t) xdr_rpc_loc_start_fix_rets, (caddr_t) clnt_res,
+		TIMEOUT));
+}
+
+enum clnt_stat 
+rpc_loc_stop_fix_0x00010001(rpc_loc_stop_fix_args *argp, rpc_loc_stop_fix_rets *clnt_res, CLIENT *clnt)
+{
+	return (clnt_call(clnt, rpc_loc_stop_fix,
+		(xdrproc_t) xdr_rpc_loc_stop_fix_args, (caddr_t) argp,
+		(xdrproc_t) xdr_rpc_loc_stop_fix_rets, (caddr_t) clnt_res,
+		TIMEOUT));
+}
+
+enum clnt_stat 
+rpc_loc_ioctl_0x00010001(rpc_loc_ioctl_args *argp, rpc_loc_ioctl_rets *clnt_res, CLIENT *clnt)
+{
+	return (clnt_call(clnt, rpc_loc_ioctl,
+		(xdrproc_t) xdr_rpc_loc_ioctl_args, (caddr_t) argp,
+		(xdrproc_t) xdr_rpc_loc_ioctl_rets, (caddr_t) clnt_res,
+		TIMEOUT));
+}
+
+enum clnt_stat 
+rpc_loc_api_api_versions_0x00010001(void *argp, rpc_loc_api_api_versions_rets *clnt_res, CLIENT *clnt)
+{
+	return (clnt_call(clnt, rpc_loc_api_api_versions,
+		(xdrproc_t) xdr_void, (caddr_t) argp,
+		(xdrproc_t) xdr_rpc_loc_api_api_versions_rets, (caddr_t) clnt_res,
+		TIMEOUT));
+}
diff --git a/msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_common.xdr b/msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_common.xdr
new file mode 100644
index 0000000..7ef6357
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_common.xdr
@@ -0,0 +1,803 @@
+/* LOC_API TOOL VERSION: 3.28 */
+/*=============================================================================
+                      L O C _ A P I _ C O M M O N . X D R
+
+GENERAL DESCRIPTION
+  This is an AUTO GENERATED file that provides an xdr compatible definition of
+  an api that represents the grouping of the different callback functions the
+  loc_api API supports.
+
+  ---------------------------------------------------------------------------
+Copyright (c) 2009, QUALCOMM USA, INC.
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+         Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 
+
+         Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. 
+
+         Neither the name of the QUALCOMM USA, INC.  nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  ---------------------------------------------------------------------------
+=============================================================================*/
+
+/*=============================================================================
+
+                              Edit History
+
+                             AUTO GENERATED
+
+Generated by following versions of Htorpc modules:
+Id: //source/qcom/qct/core/mproc/tools/rel/03.01/htorpc/htorpc.pl#9 
+Id: //source/qcom/qct/core/mproc/tools/rel/03.01/htorpc/lib/Htorpc/Start.pm#4 
+Id: //source/qcom/qct/core/mproc/tools/rel/03.01/htorpc/lib/Htorpc/Htoxdr.pm#1 
+Id: //source/qcom/qct/core/mproc/tools/rel/03.01/htorpc/lib/Htorpc/XDR.pm#7 
+Id: //source/qcom/qct/core/mproc/tools/rel/03.01/htorpc/lib/Htorpc/Output.pm#26 
+Id: //source/qcom/qct/core/mproc/tools/rel/03.01/htorpc/lib/Htorpc/Parser.pm#3 
+Id: //source/qcom/qct/core/mproc/tools/rel/03.01/htorpc/lib/Htorpc/Metacomments.pm#2 
+Id: //source/qcom/qct/core/mproc/tools/rel/03.01/htorpc/lib/Htorpc/SymbolTable.pm#4 
+
+=============================================================================*/
+/*=============================================================================
+$Header$ 
+=============================================================================*/
+
+
+
+
+const RPC_LOC_EVENT_NI_NOTIFY_VERIFY_REQUEST = 0x00000010;
+
+const RPC_LOC_EVENT_IOCTL_REPORT = 0x00000080;
+
+const RPC_LOC_EVENT_LOCATION_SERVER_REQUEST = 0x00000040;
+
+const RPC_LOC_EVENT_RESERVED = 0x8000000000000000;
+
+const RPC_LOC_EVENT_PARSED_POSITION_REPORT = 0x00000001;
+
+const RPC_LOC_EVENT_ASSISTANCE_DATA_REQUEST = 0x00000020;
+
+const RPC_LOC_EVENT_NMEA_POSITION_REPORT = 0x00000008;
+
+const RPC_LOC_EVENT_SATELLITE_REPORT = 0x00000002;
+
+const RPC_LOC_EVENT_STATUS_REPORT = 0x00000100;
+
+const RPC_LOC_OPEN_VERSION = 0x00010001;
+const RPC_LOC_CLOSE_VERSION = 0x00010001;
+const RPC_LOC_START_FIX_VERSION = 0x00010001;
+const RPC_LOC_STOP_FIX_VERSION = 0x00010001;
+const RPC_LOC_IOCTL_VERSION = 0x00010001;
+const RPC_LOC_EVENT_CB_F_TYPE_VERSION = 0x00010001;
+const RPC_LOC_APIAPI_VERSION_IS_HASHKEY = 0;
+const RPC_LOC_API_API_MAJOR_NUM = 0x0001;
+typedef bool rpc_boolean;
+typedef unsigned long rpc_uint32;
+
+typedef unsigned short rpc_uint16;
+
+typedef unsigned char rpc_uint8;
+
+typedef long rpc_int32;
+
+typedef unsigned char rpc_byte;
+
+typedef unsigned hyper rpc_uint64;
+
+typedef rpc_int32 rpc_loc_client_handle_type;
+
+typedef rpc_uint64 rpc_loc_event_mask_type;
+
+typedef rpc_uint64 rpc_loc_position_valid_mask_type;
+
+typedef rpc_uint32 rpc_loc_pos_technology_mask_type;
+
+enum rpc_loc_session_status_e_type {
+  RPC_LOC_SESS_STATUS_SUCCESS = 0,
+  RPC_LOC_SESS_STATUS_IN_PROGESS = 1,
+  RPC_LOC_SESS_STATUS_GENERAL_FAILURE = 2,
+  RPC_LOC_SESS_STATUS_TIMEOUT = 3,
+  RPC_LOC_SESS_STATUS_USER_END = 4,
+  RPC_LOC_SESS_STATUS_BAD_PARAMETER = 5,
+  RPC_LOC_SESS_STATUS_PHONE_OFFLINE = 6,
+  RPC_LOC_SESS_STATUS_ENGINE_LOCKED = 7,
+  RPC_LOC_SESS_STATUS_MAX = 268435456
+};
+
+struct rpc_loc_calendar_time_s_type {
+  rpc_uint16 year;
+  unsigned char month;
+  unsigned char day_of_week;
+  unsigned char day;
+  unsigned char hour;
+  unsigned char minute;
+  unsigned char second;
+  rpc_uint16 millisecond;
+};
+
+struct rpc_loc_parsed_position_s_type {
+  rpc_loc_position_valid_mask_type valid_mask;
+  rpc_loc_session_status_e_type session_status;
+  rpc_loc_calendar_time_s_type timestamp_calendar;
+  rpc_uint64 timestamp_utc;
+  rpc_uint8 leap_seconds;
+  float time_unc;
+  double latitude;
+  double longitude;
+  float altitude_wrt_ellipsoid;
+  float altitude_wrt_mean_sea_level;
+  float speed_horizontal;
+  float speed_vertical;
+  float heading;
+  float hor_unc_circular;
+  float hor_unc_ellipse_semi_major;
+  float hor_unc_ellipse_semi_minor;
+  float hor_unc_ellipse_orient_azimuth;
+  float vert_unc;
+  float speed_unc;
+  float heading_unc;
+  unsigned char confidence_horizontal;
+  unsigned char confidence_vertical;
+  float magnetic_deviation;
+  rpc_loc_pos_technology_mask_type technology_mask;
+};
+
+enum rpc_loc_sv_system_e_type {
+  RPC_LOC_SV_SYSTEM_GPS = 1,
+  RPC_LOC_SV_SYSTEM_GALILEO = 2,
+  RPC_LOC_SV_SYSTEM_SBAS = 3,
+  RPC_LOC_SV_SYSTEM_COMPASS = 4,
+  RPC_LOC_SV_SYSTEM_GLONASS = 5,
+  RPC_LOC_SV_SYSTEM_MAX = 268435456
+};
+
+enum rpc_loc_sv_status_e_type {
+  RPC_LOC_SV_STATUS_IDLE = 1,
+  RPC_LOC_SV_STATUS_SEARCH = 2,
+  RPC_LOC_SV_STATUS_TRACK = 3,
+  RPC_LOC_SV_STATUS_MAX = 268435456
+};
+
+typedef rpc_uint32 rpc_loc_sv_info_valid_mask_type;
+
+struct rpc_loc_sv_info_s_type {
+  rpc_loc_sv_info_valid_mask_type valid_mask;
+  rpc_loc_sv_system_e_type system;
+  rpc_uint8 prn;
+  rpc_uint8 health_status;
+  rpc_loc_sv_status_e_type process_status;
+  rpc_boolean has_eph;
+  rpc_boolean has_alm;
+  float elevation;
+  float azimuth;
+  float snr;
+};
+
+typedef rpc_uint32 rpc_loc_gnss_info_valid_mask_type;
+
+struct rpc_loc_gnss_info_s_type {
+  rpc_loc_gnss_info_valid_mask_type valid_mask;
+  float position_dop;
+  float horizontal_dop;
+  float vertical_dop;
+  rpc_boolean altitude_assumed;
+  rpc_uint16 sv_count;
+  rpc_loc_sv_info_s_type sv_list<RPC_LOC_API_MAX_SV_COUNT>;
+};
+
+struct rpc_loc_nmea_report_s_type {
+  rpc_uint16 length;
+  opaque nmea_sentences<RPC_LOC_API_MAX_NMEA_STRING_LENGTH>;
+};
+
+enum rpc_loc_status_event_e_type {
+  RPC_LOC_STATUS_EVENT_ENGINE_STATE = 1,
+  RPC_LOC_STATUS_EVENT_MAX = 268435456
+};
+
+enum rpc_loc_engine_state_e_type {
+  RPC_LOC_ENGINE_STATE_ON = 1,
+  RPC_LOC_ENGINE_STATE_OFF = 2,
+  RPC_LOC_ENGINE_STATE_MAX = 268435456
+};
+
+union rpc_loc_status_event_payload_u_type switch (rpc_loc_status_event_e_type disc) {
+  case RPC_LOC_STATUS_EVENT_ENGINE_STATE:
+    rpc_loc_engine_state_e_type engine_state;
+  default:
+    void;
+};
+
+struct rpc_loc_status_event_s_type {
+  rpc_loc_status_event_e_type event;
+  rpc_loc_status_event_payload_u_type payload;
+};
+
+enum rpc_loc_server_addr_e_type {
+  RPC_LOC_SERVER_ADDR_IPV4 = 1,
+  RPC_LOC_SERVER_ADDR_URL = 2,
+  RPC_LOC_SERVER_ADDR_MAX = 268435456
+};
+
+struct rpc_loc_server_addr_ipv4_type {
+  rpc_uint32 addr;
+  rpc_uint16 port;
+};
+
+struct rpc_loc_server_addr_url_type {
+  rpc_uint16 length;
+  opaque addr<RPC_LOC_API_MAX_SERVER_ADDR_LENGTH>;
+};
+
+union rpc_loc_server_addr_u_type switch (rpc_loc_server_addr_e_type disc) {
+  case RPC_LOC_SERVER_ADDR_IPV4:
+    rpc_loc_server_addr_ipv4_type ipv4;
+  case RPC_LOC_SERVER_ADDR_URL:
+    rpc_loc_server_addr_url_type url;
+  default:
+    void;
+};
+
+struct rpc_loc_server_info_s_type {
+  rpc_loc_server_addr_e_type addr_type;
+  rpc_loc_server_addr_u_type addr_info;
+};
+
+enum rpc_loc_ni_notify_verify_e_type {
+  RPC_LOC_NI_USER_NO_NOTIFY_NO_VERIFY = 1,
+  RPC_LOC_NI_USER_NOTIFY_ONLY = 2,
+  RPC_LOC_NI_USER_NOTIFY_VERIFY_ALLOW_NO_RESP = 3,
+  RPC_LOC_NI_USER_NOTIFY_VERIFY_NOT_ALLOW_NO_RESP = 4,
+  RPC_LOC_NI_USER_PRIVACY_OVERRIDE = 5,
+  RPC_LOC_NI_USER_NOTIFY_VERITY_TYPE_MAX = 268435456
+};
+
+enum rpc_loc_ni_event_e_type {
+  RPC_LOC_NI_EVENT_VX_NOTIFY_VERIFY_REQ = 1,
+  RPC_LOC_NI_EVENT_SUPL_NOTIFY_VERIFY_REQ = 2,
+  RPC_LOC_NI_EVENT_UMTS_CP_NOTIFY_VERIFY_REQ = 3,
+  RPC_LOC_NI_EVENT_MAX = 268435456
+};
+
+enum rpc_loc_ni_datacoding_scheme_e_type {
+  RPC_LOC_NI_PRESUPL_ISO646IRV = 0,
+  RPC_LOC_NI_PRESUPL_ISO8859 = 1,
+  RPC_LOC_NI_PRESUPL_UTF8 = 2,
+  RPC_LOC_NI_PRESUPL_UTF16 = 3,
+  RPC_LOC_NI_PRESUPL_UCS2 = 4,
+  RPC_LOC_NI_PRESUPL_GSM_DEFAULT = 5,
+  RPC_LOC_NI_PRESUPL_SHIFT_JIS = 6,
+  RPC_LOC_NI_PRESUPL_JIS = 7,
+  RPC_LOC_NI_PRESUPL_EUC = 8,
+  RPC_LOC_NI_PRESUPL_GB2312 = 9,
+  RPC_LOC_NI_PRESUPL_CNS11643 = 10,
+  RPC_LOC_NI_PRESUPL_KSC1001 = 11,
+  RPC_LOC_NI_PRESUPL_ENCODING_UNKNOWN = 2147483647,
+  RPC_LOC_NI_SS_GERMAN = 12,
+  RPC_LOC_NI_SS_ENGLISH = 13,
+  RPC_LOC_NI_SS_ITALIAN = 14,
+  RPC_LOC_NI_SS_FRENCH = 15,
+  RPC_LOC_NI_SS_SPANISH = 16,
+  RPC_LOC_NI_SS_DUTCH = 17,
+  RPC_LOC_NI_SS_SWEDISH = 18,
+  RPC_LOC_NI_SS_DANISH = 19,
+  RPC_LOC_NI_SS_PORTUGUESE = 20,
+  RPC_LOC_NI_SS_FINNISH = 21,
+  RPC_LOC_NI_SS_NORWEGIAN = 22,
+  RPC_LOC_NI_SS_GREEK = 23,
+  RPC_LOC_NI_SS_TURKISH = 24,
+  RPC_LOC_NI_SS_HUNGARIAN = 25,
+  RPC_LOC_NI_SS_POLISH = 26,
+  RPC_LOC_NI_SS_LANGUAGE_UNSPEC = 27,
+  RPC_LOC_NI_SUPL_UTF8 = 28,
+  RPC_LOC_NI_SUPL_UCS2 = 29,
+  RPC_LOC_NI_SUPL_GSM_DEFAULT = 30,
+  RPC_LOC_NI_SUPL_ENCODING_UNKNOWN = 2147483647
+};
+
+enum rpc_loc_ni_vx_requester_id_encoding_scheme_e_type {
+  RPC_LOC_NI_VX_OCTET = 0,
+  RPC_LOC_NI_VX_EXN_PROTOCOL_MSG = 1,
+  RPC_LOC_NI_VX_ASCII = 2,
+  RPC_LOC_NI_VX_IA5 = 3,
+  RPC_LOC_NI_VX_UNICODE = 4,
+  RPC_LOC_NI_VX_SHIFT_JIS = 5,
+  RPC_LOC_NI_VX_KOREAN = 6,
+  RPC_LOC_NI_VX_LATIN_HEBREW = 7,
+  RPC_LOC_NI_VX_LATIN = 8,
+  RPC_LOC_NI_VX_GSM = 9,
+  RPC_LOC_NI_VX_ENCODING_TYPE_MAX = 268435456
+};
+
+enum rpc_loc_ni_vx_pos_mode_e_type {
+  RPC_LOC_VX_MS_ASSISTED_ONLY = 1,
+  RPC_LOC_VX_MS_BASED_ONLY = 2,
+  RPC_LOC_VX_MS_ASSISTED_PREF_MSBASED_ALLWD = 3,
+  RPC_LOC_VX_MS_BASED_PREF_ASSISTED_ALLWD = 4,
+  RPC_LOC_VX_POS_MODE_MAX = 268435456
+};
+
+struct rpc_loc_ni_vx_requester_id_s_type {
+  unsigned char requester_id_length;
+  opaque requester_id[200];
+};
+
+struct rpc_loc_ni_vx_notify_verify_req_s_type {
+  rpc_loc_ni_notify_verify_e_type notification_priv_type;
+  unsigned char pos_qos_incl;
+  unsigned char pos_qos;
+  rpc_uint32 num_fixes;
+  rpc_uint32 tbf;
+  rpc_loc_ni_vx_pos_mode_e_type pos_mode;
+  rpc_loc_ni_vx_requester_id_encoding_scheme_e_type encoding_scheme;
+  rpc_loc_ni_vx_requester_id_s_type requester_id;
+  rpc_uint16 user_resp_timer_val;
+};
+
+enum rpc_loc_ni_supl_pos_method_e_type {
+  RPC_LOC_NI_POSMETHOD_AGPS_SETASSISTED = 1,
+  RPC_LOC_NI_POSMETHOD_AGPS_SETBASED = 2,
+  RPC_LOC_NI_POSMETHOD_AGPS_SETASSISTED_PREF = 3,
+  RPC_LOC_NI_POSMETHOD_AGPS_SETBASED_PREF = 4,
+  RPC_LOC_NI_POSMETHOD_AUTONOMOUS_GPS = 5,
+  RPC_LOC_NI_POSMETHOD_AFLT = 6,
+  RPC_LOC_NI_POSMETHOD_ECID = 7,
+  RPC_LOC_NI_POSMETHOD_EOTD = 8,
+  RPC_LOC_NI_POSMETHOD_OTDOA = 9,
+  RPC_LOC_NI_POSMETHOD_NO_POSITION = 10,
+  RPC_LOC_NI_POSMETHOD_MAX = 268435456
+};
+
+struct rpc_loc_ni_supl_slp_session_id_s_type {
+  unsigned char presence;
+  opaque session_id[4];
+  rpc_loc_server_info_s_type slp_address;
+};
+
+struct rpc_loc_ni_requestor_id_s_type {
+  unsigned char data_coding_scheme;
+  opaque requestor_id_string<RPC_LOC_NI_MAX_REQUESTOR_ID_LENGTH>;
+  unsigned char string_len;
+};
+
+struct rpc_loc_ni_supl_client_name_s_type {
+  unsigned char data_coding_scheme;
+  opaque client_name_string<RPC_LOC_NI_MAX_CLIENT_NAME_LENGTH>;
+  unsigned char string_len;
+};
+
+struct rpc_loc_ni_supl_qop_s_type {
+  unsigned char bit_mask;
+  unsigned char horacc;
+  unsigned char veracc;
+  unsigned char maxLocAge;
+  unsigned char delay;
+};
+
+struct rpc_loc_ni_supl_notify_verify_req_s_type {
+  rpc_loc_ni_notify_verify_e_type notification_priv_type;
+  rpc_uint16 flags;
+  rpc_loc_ni_supl_slp_session_id_s_type supl_slp_session_id;
+  opaque supl_hash[8];
+  rpc_loc_ni_datacoding_scheme_e_type datacoding_scheme;
+  rpc_loc_ni_supl_pos_method_e_type pos_method;
+  rpc_loc_ni_requestor_id_s_type requestor_id;
+  rpc_loc_ni_supl_client_name_s_type client_name;
+  rpc_loc_ni_supl_qop_s_type supl_qop;
+  rpc_uint16 user_response_timer;
+};
+
+struct rpc_loc_ni_ext_client_address_s_type {
+  unsigned char ext_client_address_len;
+  opaque ext_client_address<RPC_LOC_NI_MAX_EXT_CLIENT_ADDRESS>;
+};
+
+enum rpc_loc_ni_location_type_e_type {
+  RPC_LOC_NI_LOCATIONTYPE_CURRENT_LOCATION = 1,
+  RPC_LOC_NI_LOCATIONTYPE_CURRENT_OR_LAST_KNOWN_LOCATION = 2,
+  RPC_LOC_NI_LOCATIONTYPE_INITIAL_LOCATION = 3,
+  RPC_LOC_NI_LOCATIONTYPE_MAX = 268435456
+};
+
+struct rpc_loc_ni_deferred_location_s_type {
+  unsigned char unused_bits;
+  unsigned char ms_available;
+};
+
+struct rpc_loc_ni_codeword_string_s_type {
+  unsigned char data_coding_scheme;
+  opaque lcs_codeword_string<RPC_LOC_NI_CODEWORD_LENGTH>;
+  unsigned char string_len;
+};
+
+struct rpc_loc_ni_service_type_id_s_type {
+  unsigned char lcs_service_type_id;
+};
+
+struct rpc_loc_ni_umts_cp_notify_verify_req_s_type {
+  rpc_loc_ni_notify_verify_e_type notification_priv_type;
+  unsigned char invoke_id;
+  rpc_uint16 flags;
+  unsigned char notification_length;
+  opaque notification_text<RPC_LOC_NI_MAX_CLIENT_NAME_LENGTH>;
+  rpc_loc_ni_datacoding_scheme_e_type datacoding_scheme;
+  rpc_loc_ni_ext_client_address_s_type ext_client_address_data;
+  rpc_loc_ni_location_type_e_type location_type;
+  rpc_loc_ni_deferred_location_s_type deferred_location;
+  rpc_loc_ni_requestor_id_s_type requestor_id;
+  rpc_loc_ni_codeword_string_s_type codeword_string;
+  rpc_loc_ni_service_type_id_s_type service_type_id;
+  rpc_uint16 user_response_timer;
+};
+
+union rpc_loc_ni_event_payload_u_type switch (rpc_loc_ni_event_e_type disc) {
+  case RPC_LOC_NI_EVENT_VX_NOTIFY_VERIFY_REQ:
+    rpc_loc_ni_vx_notify_verify_req_s_type vx_req;
+  case RPC_LOC_NI_EVENT_SUPL_NOTIFY_VERIFY_REQ:
+    rpc_loc_ni_supl_notify_verify_req_s_type supl_req;
+  case RPC_LOC_NI_EVENT_UMTS_CP_NOTIFY_VERIFY_REQ:
+    rpc_loc_ni_umts_cp_notify_verify_req_s_type umts_cp_req;
+  default:
+    void;
+};
+
+struct rpc_loc_ni_event_s_type {
+  rpc_loc_ni_event_e_type event;
+  rpc_loc_ni_event_payload_u_type payload;
+};
+
+enum rpc_loc_assist_data_request_e_type {
+  RPC_LOC_ASSIST_DATA_TIME_REQ = 1,
+  RPC_LOC_ASSIST_DATA_PREDICTED_ORBITS_REQ = 2,
+  RPC_LOC_ASSIST_DATA_MAX = 268435456
+};
+
+typedef string rpc_struct_loc_time_download_source_s_type_servers_ptr<RPC_LOC_API_MAX_SERVER_ADDR_LENGTH>;
+
+typedef rpc_struct_loc_time_download_source_s_type_servers_ptr rpc_struct_loc_time_download_source_s_type_servers[3];
+
+struct rpc_loc_time_download_source_s_type {
+  rpc_uint32 delay_threshold;
+  rpc_struct_loc_time_download_source_s_type_servers servers;
+};
+
+typedef string rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr<RPC_LOC_API_MAX_SERVER_ADDR_LENGTH>;
+
+typedef rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr rpc_struct_loc_predicted_orbits_data_source_s_type_servers[3];
+
+struct rpc_loc_predicted_orbits_data_source_s_type {
+  rpc_uint32 max_file_size;
+  rpc_uint32 max_part_size;
+  rpc_struct_loc_predicted_orbits_data_source_s_type_servers servers;
+};
+
+union rpc_loc_assist_data_request_payload_u_type switch (rpc_loc_assist_data_request_e_type disc) {
+  case RPC_LOC_ASSIST_DATA_TIME_REQ:
+    rpc_loc_time_download_source_s_type time_download;
+  case RPC_LOC_ASSIST_DATA_PREDICTED_ORBITS_REQ:
+    rpc_loc_predicted_orbits_data_source_s_type data_download;
+  default:
+    void;
+};
+
+struct rpc_loc_assist_data_request_s_type {
+  rpc_loc_assist_data_request_e_type event;
+  rpc_loc_assist_data_request_payload_u_type payload;
+};
+
+typedef rpc_uint32 rpc_loc_server_connection_handle;
+
+enum rpc_loc_server_protocol_e_type {
+  RPC_LOC_SERVER_PROTOCOL_DEFAULT = 0,
+  RPC_LOC_SERVER_PROTOCOL_SUPL = 1,
+  RPC_LOC_SERVER_PROTOCOL_VX_MPC = 2,
+  RPC_LOC_SERVER_PROTOCOL_VX_PDE = 3,
+  RPC_LOC_SERVER_PROTOCOL_MAX = 16777216
+};
+
+enum rpc_loc_server_request_e_type {
+  RPC_LOC_SERVER_REQUEST_OPEN = 1,
+  RPC_LOC_SERVER_REQUEST_CLOSE = 2,
+  RPC_LOC_SERVER_REQUEST_MAX = 268435456
+};
+
+struct rpc_loc_server_open_req_s_type {
+  rpc_loc_server_connection_handle conn_handle;
+  rpc_loc_server_protocol_e_type protocol;
+};
+
+struct rpc_loc_server_close_req_s_type {
+  rpc_loc_server_connection_handle conn_handle;
+};
+
+union rpc_loc_server_request_u_type switch (rpc_loc_server_request_e_type disc) {
+  case RPC_LOC_SERVER_REQUEST_OPEN:
+    rpc_loc_server_open_req_s_type open_req;
+  case RPC_LOC_SERVER_REQUEST_CLOSE:
+    rpc_loc_server_close_req_s_type close_req;
+  default:
+    void;
+};
+
+struct rpc_loc_server_request_s_type {
+  rpc_loc_server_request_e_type event;
+  rpc_loc_server_request_u_type payload;
+};
+
+struct rpc_loc_reserved_payload_s_type {
+  rpc_uint16 data_size;
+  opaque data<>;
+};
+
+enum rpc_loc_ioctl_e_type {
+  RPC_LOC_IOCTL_GET_API_VERSION = 1,
+  RPC_LOC_IOCTL_SET_FIX_CRITERIA = 2,
+  RPC_LOC_IOCTL_GET_FIX_CRITERIA = 3,
+  RPC_LOC_IOCTL_SERVICE_START_INDEX = 400,
+  RPC_LOC_IOCTL_INFORM_NI_USER_RESPONSE = 400,
+  RPC_LOC_IOCTL_INJECT_PREDICTED_ORBITS_DATA = 401,
+  RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_VALIDITY = 402,
+  RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_SOURCE = 403,
+  RPC_LOC_IOCTL_SET_PREDICTED_ORBITS_DATA_AUTO_DOWNLOAD = 404,
+  RPC_LOC_IOCTL_INJECT_UTC_TIME = 405,
+  RPC_LOC_IOCTL_INJECT_RTC_VALUE = 406,
+  RPC_LOC_IOCTL_INJECT_POSITION = 407,
+  RPC_LOC_IOCTL_QUERY_ENGINE_STATE = 408,
+  RPC_LOC_IOCTL_INFORM_SERVER_OPEN_STATUS = 409,
+  RPC_LOC_IOCTL_INFORM_SERVER_CLOSE_STATUS = 410,
+  RPC_LOC_IOCTL_NV_SETTINGS_START_INDEX = 800,
+  RPC_LOC_IOCTL_SET_ENGINE_LOCK = 800,
+  RPC_LOC_IOCTL_GET_ENGINE_LOCK = 801,
+  RPC_LOC_IOCTL_SET_SBAS_CONFIG = 802,
+  RPC_LOC_IOCTL_GET_SBAS_CONFIG = 803,
+  RPC_LOC_IOCTL_SET_NMEA_TYPES = 804,
+  RPC_LOC_IOCTL_GET_NMEA_TYPES = 805,
+  RPC_LOC_IOCTL_SET_CDMA_PDE_SERVER_ADDR = 806,
+  RPC_LOC_IOCTL_GET_CDMA_PDE_SERVER_ADDR = 807,
+  RPC_LOC_IOCTL_SET_CDMA_MPC_SERVER_ADDR = 808,
+  RPC_LOC_IOCTL_GET_CDMA_MPC_SERVER_ADDR = 809,
+  RPC_LOC_IOCTL_SET_UMTS_SLP_SERVER_ADDR = 810,
+  RPC_LOC_IOCTL_GET_UMTS_SLP_SERVER_ADDR = 811,
+  RPC_LOC_IOCTL_SET_ON_DEMAND_LPM = 812,
+  RPC_LOC_IOCTL_GET_ON_DEMAND_LPM = 813,
+  RPC_LOC_IOCTL_PROPRIETARY_START_INDEX = 1000,
+  RPC_LOC_IOCTL_DELETE_ASSIST_DATA = 1000,
+  RPC_LOC_IOCTL_SET_CUSTOM_PDE_SERVER_ADDR = 1001,
+  RPC_LOC_IOCTL_GET_CUSTOM_PDE_SERVER_ADDR = 1002,
+  RPC_LOC_IOCTL_THIRD_PARTY_START_INDEX = 1073741824
+};
+
+struct rpc_loc_api_version_s_type {
+  unsigned char major;
+  unsigned char minor;
+};
+
+enum rpc_loc_fix_recurrence_e_type {
+  RPC_LOC_PERIODIC_FIX = 1,
+  RPC_LOC_SINGLE_FIX = 2,
+  RPC_LOC_FIX_SESSION_TYPE_MAX = 268435456
+};
+
+enum rpc_loc_operation_mode_e_type {
+  RPC_LOC_OPER_MODE_DEFAULT = 1,
+  RPC_LOC_OPER_MODE_MSB = 2,
+  RPC_LOC_OPER_MODE_MSA = 3,
+  RPC_LOC_OPER_MODE_STANDALONE = 4,
+  RPC_LOC_OPER_MODE_SPEED_OPTIMAL = 5,
+  RPC_LOC_OPER_MODE_ACCURACY_OPTIMAL = 6,
+  RPC_LOC_OPER_MODE_DATA_OPTIMAL = 7,
+  RPC_LOC_OPER_MODE_MAX = 268435456
+};
+
+enum rpc_loc_notify_e_type {
+  RPC_LOC_NOTIFY_ON_INTERVAL = 1,
+  RPC_LOC_NOTIFY_ON_DISTANCE = 2,
+  RPC_LOC_NOTIFY_ON_ANY = 3,
+  RPC_LOC_NOTIFY_ON_ALL = 4,
+  RPC_LOC_NOTIFY_TYPE_MAX = 268435456
+};
+
+struct rpc_loc_fix_criteria_s_type {
+  rpc_uint32 valid_mask;
+  rpc_loc_fix_recurrence_e_type recurrence_type;
+  rpc_loc_operation_mode_e_type preferred_operation_mode;
+  rpc_uint32 preferred_accuracy;
+  rpc_uint32 preferred_response_time;
+  rpc_boolean intermediate_pos_report_enabled;
+  rpc_loc_notify_e_type notify_type;
+  rpc_uint32 min_interval;
+  float min_distance;
+  rpc_uint32 min_dist_sample_interval;
+};
+
+enum rpc_loc_ni_user_resp_e_type {
+  RPC_LOC_NI_LCS_NOTIFY_VERIFY_ACCEPT = 1,
+  RPC_LOC_NI_LCS_NOTIFY_VERIFY_DENY = 2,
+  RPC_LOC_NI_LCS_NOTIFY_VERIFY_NORESP = 3,
+  RPC_LOC_NI_LCS_NOTIFY_VERIFY_MAX = 268435456
+};
+
+struct rpc_loc_user_verify_s_type {
+  rpc_loc_ni_user_resp_e_type user_resp;
+  rpc_loc_ni_event_s_type ni_event_pass_back;
+};
+
+enum rpc_loc_predicted_orbits_data_format_e_type {
+  RPC_LOC_PREDICTED_ORBITS_XTRA = 0,
+  RPC_LOC_PREDICTED_ORBITS_FORMAT_MAX = 268435456
+};
+
+struct rpc_loc_predicted_orbits_data_s_type {
+  rpc_loc_predicted_orbits_data_format_e_type format_type;
+  rpc_uint32 total_size;
+  rpc_uint8 total_parts;
+  rpc_uint8 part;
+  rpc_uint16 part_len;
+  opaque data_ptr<>;
+};
+
+struct rpc_loc_predicted_orbits_data_validity_report_s_type {
+  rpc_uint64 start_time_utc;
+  rpc_uint16 valid_duration_hrs;
+};
+
+struct rpc_loc_predicted_orbits_auto_download_config_s_type {
+  rpc_boolean enable;
+  unsigned char auto_check_every_hrs;
+};
+
+struct rpc_loc_assist_data_time_s_type {
+  rpc_uint64 time_utc;
+  rpc_uint32 uncertainty;
+};
+
+typedef rpc_uint64 rpc_loc_assist_pos_valid_mask_type;
+
+struct rpc_loc_assist_data_pos_s_type {
+  rpc_loc_assist_pos_valid_mask_type valid_mask;
+  rpc_uint64 timestamp_utc;
+  double latitude;
+  double longitude;
+  float altitude_wrt_ellipsoid;
+  float altitude_wrt_mean_sea_level;
+  float hor_unc_circular;
+  float vert_unc;
+  unsigned char confidence_horizontal;
+  unsigned char confidence_vertical;
+};
+
+enum rpc_loc_server_open_status_e_type {
+  RPC_LOC_SERVER_OPEN_SUCCESS = 1,
+  RPC_LOC_SERVER_OPEN_FAIL = 2,
+  RPC_LOC_SERVER_OPEN_STATUS_MAX = 268435456
+};
+
+struct rpc_loc_server_open_status_s_type {
+  rpc_loc_server_connection_handle conn_handle;
+  rpc_loc_server_open_status_e_type open_status;
+  string apn_name<>;
+};
+
+enum rpc_loc_server_close_status_e_type {
+  RPC_LOC_SERVER_CLOSE_SUCCESS = 1,
+  RPC_LOC_SERVER_CLOSE_FAIL = 2,
+  RPC_LOC_SERVER_CLOSE_STATUS_MAX = 268435456
+};
+
+struct rpc_loc_server_close_status_s_type {
+  rpc_loc_server_connection_handle conn_handle;
+  rpc_loc_server_close_status_e_type close_status;
+};
+
+enum rpc_loc_lock_e_type {
+  RPC_LOC_LOCK_NONE = 1,
+  RPC_LOC_LOCK_MI = 2,
+  RPC_LOC_LOCK_MT = 3,
+  RPC_LOC_LOCK_ALL = 4,
+  RPC_LOC_LOCK_MAX = 268435456
+};
+
+typedef rpc_uint32 rpc_loc_nmea_sentence_type;
+
+typedef rpc_uint32 rpc_loc_assist_data_type;
+
+struct rpc_loc_assist_data_delete_s_type {
+  rpc_loc_assist_data_type type;
+  rpc_uint32 reserved[8];
+};
+
+union rpc_loc_ioctl_data_u_type switch (rpc_loc_ioctl_e_type disc) {
+  case RPC_LOC_IOCTL_SET_FIX_CRITERIA:
+    rpc_loc_fix_criteria_s_type fix_criteria;
+  case RPC_LOC_IOCTL_INFORM_NI_USER_RESPONSE:
+    rpc_loc_user_verify_s_type user_verify_resp;
+  case RPC_LOC_IOCTL_INJECT_PREDICTED_ORBITS_DATA:
+    rpc_loc_predicted_orbits_data_s_type predicted_orbits_data;
+  case RPC_LOC_IOCTL_SET_PREDICTED_ORBITS_DATA_AUTO_DOWNLOAD:
+    rpc_loc_predicted_orbits_auto_download_config_s_type predicted_orbits_auto_download;
+  case RPC_LOC_IOCTL_INJECT_UTC_TIME:
+    rpc_loc_assist_data_time_s_type assistance_data_time;
+  case RPC_LOC_IOCTL_INJECT_POSITION:
+    rpc_loc_assist_data_pos_s_type assistance_data_position;
+  case RPC_LOC_IOCTL_INFORM_SERVER_OPEN_STATUS:
+    rpc_loc_server_open_status_s_type conn_open_status;
+  case RPC_LOC_IOCTL_INFORM_SERVER_CLOSE_STATUS:
+    rpc_loc_server_close_status_s_type conn_close_status;
+  case RPC_LOC_IOCTL_SET_ENGINE_LOCK:
+    rpc_loc_lock_e_type engine_lock;
+  case RPC_LOC_IOCTL_SET_SBAS_CONFIG:
+    rpc_boolean sbas_mode;
+  case RPC_LOC_IOCTL_SET_NMEA_TYPES:
+    rpc_loc_nmea_sentence_type nmea_types;
+  case RPC_LOC_IOCTL_SET_ON_DEMAND_LPM:
+    rpc_boolean on_demand_lpm;
+  case  RPC_LOC_IOCTL_SET_CDMA_PDE_SERVER_ADDR:
+  case  RPC_LOC_IOCTL_SET_CDMA_MPC_SERVER_ADDR:
+  case  RPC_LOC_IOCTL_SET_UMTS_SLP_SERVER_ADDR:
+  case  RPC_LOC_IOCTL_SET_CUSTOM_PDE_SERVER_ADDR:
+    rpc_loc_server_info_s_type server_addr;
+  case RPC_LOC_IOCTL_DELETE_ASSIST_DATA:
+    rpc_loc_assist_data_delete_s_type assist_data_delete;
+  default:
+    void;
+};
+
+union rpc_loc_ioctl_callback_data_u_type switch (rpc_loc_ioctl_e_type disc) {
+  case RPC_LOC_IOCTL_GET_API_VERSION:
+    rpc_loc_api_version_s_type api_version;
+  case RPC_LOC_IOCTL_GET_FIX_CRITERIA:
+    rpc_loc_fix_criteria_s_type fix_criteria;
+  case RPC_LOC_IOCTL_GET_ENGINE_LOCK:
+    rpc_loc_lock_e_type engine_lock;
+  case RPC_LOC_IOCTL_GET_SBAS_CONFIG:
+    rpc_boolean sbas_mode;
+  case RPC_LOC_IOCTL_GET_NMEA_TYPES:
+    rpc_loc_nmea_sentence_type nmea_types;
+  case RPC_LOC_IOCTL_GET_ON_DEMAND_LPM:
+    rpc_boolean on_demand_lpm;
+  case  RPC_LOC_IOCTL_GET_CDMA_PDE_SERVER_ADDR:
+  case  RPC_LOC_IOCTL_GET_CDMA_MPC_SERVER_ADDR:
+  case  RPC_LOC_IOCTL_GET_UMTS_SLP_SERVER_ADDR:
+    rpc_loc_server_info_s_type server_addr;
+  case RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_SOURCE:
+    rpc_loc_predicted_orbits_data_source_s_type predicted_orbits_data_source;
+  case RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_VALIDITY:
+    rpc_loc_predicted_orbits_data_validity_report_s_type predicted_orbits_data_validity;
+  default:
+    void;
+};
+
+struct rpc_loc_ioctl_callback_s_type {
+  rpc_loc_ioctl_e_type type;
+  rpc_int32 status;
+  rpc_loc_ioctl_callback_data_u_type data;
+};
+
+union rpc_loc_event_payload_u_type switch (unsigned hyper disc) {
+  case RPC_LOC_EVENT_PARSED_POSITION_REPORT:
+    rpc_loc_parsed_position_s_type parsed_location_report;
+  case RPC_LOC_EVENT_SATELLITE_REPORT:
+    rpc_loc_gnss_info_s_type gnss_report;
+  case RPC_LOC_EVENT_NMEA_POSITION_REPORT:
+    rpc_loc_nmea_report_s_type nmea_report;
+  case RPC_LOC_EVENT_NI_NOTIFY_VERIFY_REQUEST:
+    rpc_loc_ni_event_s_type ni_request;
+  case RPC_LOC_EVENT_ASSISTANCE_DATA_REQUEST:
+    rpc_loc_assist_data_request_s_type assist_data_request;
+  case RPC_LOC_EVENT_LOCATION_SERVER_REQUEST:
+    rpc_loc_server_request_s_type loc_server_request;
+  case RPC_LOC_EVENT_IOCTL_REPORT:
+    rpc_loc_ioctl_callback_s_type ioctl_report;
+  case RPC_LOC_EVENT_STATUS_REPORT:
+    rpc_loc_status_event_s_type status_report;
+  case RPC_LOC_EVENT_RESERVED:
+    rpc_loc_reserved_payload_s_type reserved;
+  default:
+    void;
+};
+
+const RPC_LOC_API_NULL_VERSION = 0x00010001;
+const RPC_LOC_API_RPC_GLUE_CODE_INFO_REMOTE_VERSION = 0x00010001;
diff --git a/msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_common_xdr.c b/msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_common_xdr.c
new file mode 100644
index 0000000..7b37b9c
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_common_xdr.c
@@ -0,0 +1,1441 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#include "loc_api_common.h"
+
+bool_t
+xdr_rpc_boolean (XDR *xdrs, rpc_boolean *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_bool (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_uint32 (XDR *xdrs, rpc_uint32 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_u_long (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_uint16 (XDR *xdrs, rpc_uint16 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_u_short (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_uint8 (XDR *xdrs, rpc_uint8 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_u_char (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_int32 (XDR *xdrs, rpc_int32 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_long (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_byte (XDR *xdrs, rpc_byte *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_u_char (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_uint64 (XDR *xdrs, rpc_uint64 *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_u_quad_t (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_client_handle_type (XDR *xdrs, rpc_loc_client_handle_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_int32 (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_event_mask_type (XDR *xdrs, rpc_loc_event_mask_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint64 (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_position_valid_mask_type (XDR *xdrs, rpc_loc_position_valid_mask_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint64 (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_pos_technology_mask_type (XDR *xdrs, rpc_loc_pos_technology_mask_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint32 (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_session_status_e_type (XDR *xdrs, rpc_loc_session_status_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_calendar_time_s_type (XDR *xdrs, rpc_loc_calendar_time_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint16 (xdrs, &objp->year))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->month))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->day_of_week))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->day))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->hour))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->minute))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->second))
+		 return FALSE;
+	 if (!xdr_rpc_uint16 (xdrs, &objp->millisecond))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_parsed_position_s_type (XDR *xdrs, rpc_loc_parsed_position_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_position_valid_mask_type (xdrs, &objp->valid_mask))
+		 return FALSE;
+	 if (!xdr_rpc_loc_session_status_e_type (xdrs, &objp->session_status))
+		 return FALSE;
+	 if (!xdr_rpc_loc_calendar_time_s_type (xdrs, &objp->timestamp_calendar))
+		 return FALSE;
+	 if (!xdr_rpc_uint64 (xdrs, &objp->timestamp_utc))
+		 return FALSE;
+	 if (!xdr_rpc_uint8 (xdrs, &objp->leap_seconds))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->time_unc))
+		 return FALSE;
+	 if (!xdr_double (xdrs, &objp->latitude))
+		 return FALSE;
+	 if (!xdr_double (xdrs, &objp->longitude))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->altitude_wrt_ellipsoid))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->altitude_wrt_mean_sea_level))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->speed_horizontal))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->speed_vertical))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->heading))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->hor_unc_circular))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->hor_unc_ellipse_semi_major))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->hor_unc_ellipse_semi_minor))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->hor_unc_ellipse_orient_azimuth))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->vert_unc))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->speed_unc))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->heading_unc))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->confidence_horizontal))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->confidence_vertical))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->magnetic_deviation))
+		 return FALSE;
+	 if (!xdr_rpc_loc_pos_technology_mask_type (xdrs, &objp->technology_mask))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_sv_system_e_type (XDR *xdrs, rpc_loc_sv_system_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_sv_status_e_type (XDR *xdrs, rpc_loc_sv_status_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_sv_info_valid_mask_type (XDR *xdrs, rpc_loc_sv_info_valid_mask_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint32 (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_sv_info_s_type (XDR *xdrs, rpc_loc_sv_info_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_sv_info_valid_mask_type (xdrs, &objp->valid_mask))
+		 return FALSE;
+	 if (!xdr_rpc_loc_sv_system_e_type (xdrs, &objp->system))
+		 return FALSE;
+	 if (!xdr_rpc_uint8 (xdrs, &objp->prn))
+		 return FALSE;
+	 if (!xdr_rpc_uint8 (xdrs, &objp->health_status))
+		 return FALSE;
+	 if (!xdr_rpc_loc_sv_status_e_type (xdrs, &objp->process_status))
+		 return FALSE;
+	 if (!xdr_rpc_boolean (xdrs, &objp->has_eph))
+		 return FALSE;
+	 if (!xdr_rpc_boolean (xdrs, &objp->has_alm))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->elevation))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->azimuth))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->snr))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_gnss_info_valid_mask_type (XDR *xdrs, rpc_loc_gnss_info_valid_mask_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint32 (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_gnss_info_s_type (XDR *xdrs, rpc_loc_gnss_info_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_gnss_info_valid_mask_type (xdrs, &objp->valid_mask))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->position_dop))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->horizontal_dop))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->vertical_dop))
+		 return FALSE;
+	 if (!xdr_rpc_boolean (xdrs, &objp->altitude_assumed))
+		 return FALSE;
+	 if (!xdr_rpc_uint16 (xdrs, &objp->sv_count))
+		 return FALSE;
+	 if (!xdr_array (xdrs, (char **)&objp->sv_list.sv_list_val, (u_int *) &objp->sv_list.sv_list_len, RPC_LOC_API_MAX_SV_COUNT,
+		sizeof (rpc_loc_sv_info_s_type), (xdrproc_t) xdr_rpc_loc_sv_info_s_type))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_nmea_report_s_type (XDR *xdrs, rpc_loc_nmea_report_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint16 (xdrs, &objp->length))
+		 return FALSE;
+	 if (!xdr_bytes (xdrs, (char **)&objp->nmea_sentences.nmea_sentences_val, (u_int *) &objp->nmea_sentences.nmea_sentences_len, RPC_LOC_API_MAX_NMEA_STRING_LENGTH))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_status_event_e_type (XDR *xdrs, rpc_loc_status_event_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_engine_state_e_type (XDR *xdrs, rpc_loc_engine_state_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_status_event_payload_u_type (XDR *xdrs, rpc_loc_status_event_payload_u_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_status_event_e_type (xdrs, &objp->disc))
+		 return FALSE;
+	switch (objp->disc) {
+	case RPC_LOC_STATUS_EVENT_ENGINE_STATE:
+		 if (!xdr_rpc_loc_engine_state_e_type (xdrs, &objp->rpc_loc_status_event_payload_u_type_u.engine_state))
+			 return FALSE;
+		break;
+	default:
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_status_event_s_type (XDR *xdrs, rpc_loc_status_event_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_status_event_e_type (xdrs, &objp->event))
+		 return FALSE;
+	 if (!xdr_rpc_loc_status_event_payload_u_type (xdrs, &objp->payload))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_addr_e_type (XDR *xdrs, rpc_loc_server_addr_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_addr_ipv4_type (XDR *xdrs, rpc_loc_server_addr_ipv4_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint32 (xdrs, &objp->addr))
+		 return FALSE;
+	 if (!xdr_rpc_uint16 (xdrs, &objp->port))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_addr_url_type (XDR *xdrs, rpc_loc_server_addr_url_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint16 (xdrs, &objp->length))
+		 return FALSE;
+	 if (!xdr_bytes (xdrs, (char **)&objp->addr.addr_val, (u_int *) &objp->addr.addr_len, RPC_LOC_API_MAX_SERVER_ADDR_LENGTH))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_addr_u_type (XDR *xdrs, rpc_loc_server_addr_u_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_server_addr_e_type (xdrs, &objp->disc))
+		 return FALSE;
+	switch (objp->disc) {
+	case RPC_LOC_SERVER_ADDR_IPV4:
+		 if (!xdr_rpc_loc_server_addr_ipv4_type (xdrs, &objp->rpc_loc_server_addr_u_type_u.ipv4))
+			 return FALSE;
+		break;
+	case RPC_LOC_SERVER_ADDR_URL:
+		 if (!xdr_rpc_loc_server_addr_url_type (xdrs, &objp->rpc_loc_server_addr_u_type_u.url))
+			 return FALSE;
+		break;
+	default:
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_info_s_type (XDR *xdrs, rpc_loc_server_info_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_server_addr_e_type (xdrs, &objp->addr_type))
+		 return FALSE;
+	 if (!xdr_rpc_loc_server_addr_u_type (xdrs, &objp->addr_info))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_notify_verify_e_type (XDR *xdrs, rpc_loc_ni_notify_verify_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_event_e_type (XDR *xdrs, rpc_loc_ni_event_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_datacoding_scheme_e_type (XDR *xdrs, rpc_loc_ni_datacoding_scheme_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_vx_requester_id_encoding_scheme_e_type (XDR *xdrs, rpc_loc_ni_vx_requester_id_encoding_scheme_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_vx_pos_mode_e_type (XDR *xdrs, rpc_loc_ni_vx_pos_mode_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_vx_requester_id_s_type (XDR *xdrs, rpc_loc_ni_vx_requester_id_s_type *objp)
+{
+	register int32_t *buf;
+
+	int i;
+	 if (!xdr_u_char (xdrs, &objp->requester_id_length))
+		 return FALSE;
+	 if (!xdr_opaque (xdrs, objp->requester_id, 200))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_vx_notify_verify_req_s_type (XDR *xdrs, rpc_loc_ni_vx_notify_verify_req_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_ni_notify_verify_e_type (xdrs, &objp->notification_priv_type))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->pos_qos_incl))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->pos_qos))
+		 return FALSE;
+	 if (!xdr_rpc_uint32 (xdrs, &objp->num_fixes))
+		 return FALSE;
+	 if (!xdr_rpc_uint32 (xdrs, &objp->tbf))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_vx_pos_mode_e_type (xdrs, &objp->pos_mode))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_vx_requester_id_encoding_scheme_e_type (xdrs, &objp->encoding_scheme))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_vx_requester_id_s_type (xdrs, &objp->requester_id))
+		 return FALSE;
+	 if (!xdr_rpc_uint16 (xdrs, &objp->user_resp_timer_val))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_supl_pos_method_e_type (XDR *xdrs, rpc_loc_ni_supl_pos_method_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_supl_slp_session_id_s_type (XDR *xdrs, rpc_loc_ni_supl_slp_session_id_s_type *objp)
+{
+	register int32_t *buf;
+
+	int i;
+	 if (!xdr_u_char (xdrs, &objp->presence))
+		 return FALSE;
+	 if (!xdr_opaque (xdrs, objp->session_id, 4))
+		 return FALSE;
+	 if (!xdr_rpc_loc_server_info_s_type (xdrs, &objp->slp_address))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_requestor_id_s_type (XDR *xdrs, rpc_loc_ni_requestor_id_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_u_char (xdrs, &objp->data_coding_scheme))
+		 return FALSE;
+	 if (!xdr_bytes (xdrs, (char **)&objp->requestor_id_string.requestor_id_string_val, (u_int *) &objp->requestor_id_string.requestor_id_string_len, RPC_LOC_NI_MAX_REQUESTOR_ID_LENGTH))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->string_len))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_supl_client_name_s_type (XDR *xdrs, rpc_loc_ni_supl_client_name_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_u_char (xdrs, &objp->data_coding_scheme))
+		 return FALSE;
+	 if (!xdr_bytes (xdrs, (char **)&objp->client_name_string.client_name_string_val, (u_int *) &objp->client_name_string.client_name_string_len, RPC_LOC_NI_MAX_CLIENT_NAME_LENGTH))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->string_len))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_supl_qop_s_type (XDR *xdrs, rpc_loc_ni_supl_qop_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_u_char (xdrs, &objp->bit_mask))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->horacc))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->veracc))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->maxLocAge))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->delay))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_supl_notify_verify_req_s_type (XDR *xdrs, rpc_loc_ni_supl_notify_verify_req_s_type *objp)
+{
+	register int32_t *buf;
+
+	int i;
+	 if (!xdr_rpc_loc_ni_notify_verify_e_type (xdrs, &objp->notification_priv_type))
+		 return FALSE;
+	 if (!xdr_rpc_uint16 (xdrs, &objp->flags))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_supl_slp_session_id_s_type (xdrs, &objp->supl_slp_session_id))
+		 return FALSE;
+	 if (!xdr_opaque (xdrs, objp->supl_hash, 8))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_datacoding_scheme_e_type (xdrs, &objp->datacoding_scheme))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_supl_pos_method_e_type (xdrs, &objp->pos_method))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_requestor_id_s_type (xdrs, &objp->requestor_id))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_supl_client_name_s_type (xdrs, &objp->client_name))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_supl_qop_s_type (xdrs, &objp->supl_qop))
+		 return FALSE;
+	 if (!xdr_rpc_uint16 (xdrs, &objp->user_response_timer))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_ext_client_address_s_type (XDR *xdrs, rpc_loc_ni_ext_client_address_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_u_char (xdrs, &objp->ext_client_address_len))
+		 return FALSE;
+	 if (!xdr_bytes (xdrs, (char **)&objp->ext_client_address.ext_client_address_val, (u_int *) &objp->ext_client_address.ext_client_address_len, RPC_LOC_NI_MAX_EXT_CLIENT_ADDRESS))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_location_type_e_type (XDR *xdrs, rpc_loc_ni_location_type_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_deferred_location_s_type (XDR *xdrs, rpc_loc_ni_deferred_location_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_u_char (xdrs, &objp->unused_bits))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->ms_available))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_codeword_string_s_type (XDR *xdrs, rpc_loc_ni_codeword_string_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_u_char (xdrs, &objp->data_coding_scheme))
+		 return FALSE;
+	 if (!xdr_bytes (xdrs, (char **)&objp->lcs_codeword_string.lcs_codeword_string_val, (u_int *) &objp->lcs_codeword_string.lcs_codeword_string_len, RPC_LOC_NI_CODEWORD_LENGTH))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->string_len))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_service_type_id_s_type (XDR *xdrs, rpc_loc_ni_service_type_id_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_u_char (xdrs, &objp->lcs_service_type_id))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_umts_cp_notify_verify_req_s_type (XDR *xdrs, rpc_loc_ni_umts_cp_notify_verify_req_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_ni_notify_verify_e_type (xdrs, &objp->notification_priv_type))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->invoke_id))
+		 return FALSE;
+	 if (!xdr_rpc_uint16 (xdrs, &objp->flags))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->notification_length))
+		 return FALSE;
+	 if (!xdr_bytes (xdrs, (char **)&objp->notification_text.notification_text_val, (u_int *) &objp->notification_text.notification_text_len, RPC_LOC_NI_MAX_CLIENT_NAME_LENGTH))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_datacoding_scheme_e_type (xdrs, &objp->datacoding_scheme))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_ext_client_address_s_type (xdrs, &objp->ext_client_address_data))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_location_type_e_type (xdrs, &objp->location_type))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_deferred_location_s_type (xdrs, &objp->deferred_location))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_requestor_id_s_type (xdrs, &objp->requestor_id))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_codeword_string_s_type (xdrs, &objp->codeword_string))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_service_type_id_s_type (xdrs, &objp->service_type_id))
+		 return FALSE;
+	 if (!xdr_rpc_uint16 (xdrs, &objp->user_response_timer))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_event_payload_u_type (XDR *xdrs, rpc_loc_ni_event_payload_u_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_ni_event_e_type (xdrs, &objp->disc))
+		 return FALSE;
+	switch (objp->disc) {
+	case RPC_LOC_NI_EVENT_VX_NOTIFY_VERIFY_REQ:
+		 if (!xdr_rpc_loc_ni_vx_notify_verify_req_s_type (xdrs, &objp->rpc_loc_ni_event_payload_u_type_u.vx_req))
+			 return FALSE;
+		break;
+	case RPC_LOC_NI_EVENT_SUPL_NOTIFY_VERIFY_REQ:
+		 if (!xdr_rpc_loc_ni_supl_notify_verify_req_s_type (xdrs, &objp->rpc_loc_ni_event_payload_u_type_u.supl_req))
+			 return FALSE;
+		break;
+	case RPC_LOC_NI_EVENT_UMTS_CP_NOTIFY_VERIFY_REQ:
+		 if (!xdr_rpc_loc_ni_umts_cp_notify_verify_req_s_type (xdrs, &objp->rpc_loc_ni_event_payload_u_type_u.umts_cp_req))
+			 return FALSE;
+		break;
+	default:
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_event_s_type (XDR *xdrs, rpc_loc_ni_event_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_ni_event_e_type (xdrs, &objp->event))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_event_payload_u_type (xdrs, &objp->payload))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_assist_data_request_e_type (XDR *xdrs, rpc_loc_assist_data_request_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_struct_loc_time_download_source_s_type_servers_ptr (XDR *xdrs, rpc_struct_loc_time_download_source_s_type_servers_ptr *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_string (xdrs, objp, RPC_LOC_API_MAX_SERVER_ADDR_LENGTH))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_struct_loc_time_download_source_s_type_servers (XDR *xdrs, rpc_struct_loc_time_download_source_s_type_servers objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_vector (xdrs, (char *)objp, 3,
+		sizeof (rpc_struct_loc_time_download_source_s_type_servers_ptr), (xdrproc_t) xdr_rpc_struct_loc_time_download_source_s_type_servers_ptr))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_time_download_source_s_type (XDR *xdrs, rpc_loc_time_download_source_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint32 (xdrs, &objp->delay_threshold))
+		 return FALSE;
+	 if (!xdr_rpc_struct_loc_time_download_source_s_type_servers (xdrs, objp->servers))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr (XDR *xdrs, rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_string (xdrs, objp, RPC_LOC_API_MAX_SERVER_ADDR_LENGTH))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_struct_loc_predicted_orbits_data_source_s_type_servers (XDR *xdrs, rpc_struct_loc_predicted_orbits_data_source_s_type_servers objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_vector (xdrs, (char *)objp, 3,
+		sizeof (rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr), (xdrproc_t) xdr_rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_predicted_orbits_data_source_s_type (XDR *xdrs, rpc_loc_predicted_orbits_data_source_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint32 (xdrs, &objp->max_file_size))
+		 return FALSE;
+	 if (!xdr_rpc_uint32 (xdrs, &objp->max_part_size))
+		 return FALSE;
+	 if (!xdr_rpc_struct_loc_predicted_orbits_data_source_s_type_servers (xdrs, objp->servers))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_assist_data_request_payload_u_type (XDR *xdrs, rpc_loc_assist_data_request_payload_u_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_assist_data_request_e_type (xdrs, &objp->disc))
+		 return FALSE;
+	switch (objp->disc) {
+	case RPC_LOC_ASSIST_DATA_TIME_REQ:
+		 if (!xdr_rpc_loc_time_download_source_s_type (xdrs, &objp->rpc_loc_assist_data_request_payload_u_type_u.time_download))
+			 return FALSE;
+		break;
+	case RPC_LOC_ASSIST_DATA_PREDICTED_ORBITS_REQ:
+		 if (!xdr_rpc_loc_predicted_orbits_data_source_s_type (xdrs, &objp->rpc_loc_assist_data_request_payload_u_type_u.data_download))
+			 return FALSE;
+		break;
+	default:
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_assist_data_request_s_type (XDR *xdrs, rpc_loc_assist_data_request_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_assist_data_request_e_type (xdrs, &objp->event))
+		 return FALSE;
+	 if (!xdr_rpc_loc_assist_data_request_payload_u_type (xdrs, &objp->payload))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_connection_handle (XDR *xdrs, rpc_loc_server_connection_handle *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint32 (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_protocol_e_type (XDR *xdrs, rpc_loc_server_protocol_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_request_e_type (XDR *xdrs, rpc_loc_server_request_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_open_req_s_type (XDR *xdrs, rpc_loc_server_open_req_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_server_connection_handle (xdrs, &objp->conn_handle))
+		 return FALSE;
+	 if (!xdr_rpc_loc_server_protocol_e_type (xdrs, &objp->protocol))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_close_req_s_type (XDR *xdrs, rpc_loc_server_close_req_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_server_connection_handle (xdrs, &objp->conn_handle))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_request_u_type (XDR *xdrs, rpc_loc_server_request_u_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_server_request_e_type (xdrs, &objp->disc))
+		 return FALSE;
+	switch (objp->disc) {
+	case RPC_LOC_SERVER_REQUEST_OPEN:
+		 if (!xdr_rpc_loc_server_open_req_s_type (xdrs, &objp->rpc_loc_server_request_u_type_u.open_req))
+			 return FALSE;
+		break;
+	case RPC_LOC_SERVER_REQUEST_CLOSE:
+		 if (!xdr_rpc_loc_server_close_req_s_type (xdrs, &objp->rpc_loc_server_request_u_type_u.close_req))
+			 return FALSE;
+		break;
+	default:
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_request_s_type (XDR *xdrs, rpc_loc_server_request_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_server_request_e_type (xdrs, &objp->event))
+		 return FALSE;
+	 if (!xdr_rpc_loc_server_request_u_type (xdrs, &objp->payload))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_reserved_payload_s_type (XDR *xdrs, rpc_loc_reserved_payload_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint16 (xdrs, &objp->data_size))
+		 return FALSE;
+	 if (!xdr_bytes (xdrs, (char **)&objp->data.data_val, (u_int *) &objp->data.data_len, ~0))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ioctl_e_type (XDR *xdrs, rpc_loc_ioctl_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_api_version_s_type (XDR *xdrs, rpc_loc_api_version_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_u_char (xdrs, &objp->major))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->minor))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_fix_recurrence_e_type (XDR *xdrs, rpc_loc_fix_recurrence_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_operation_mode_e_type (XDR *xdrs, rpc_loc_operation_mode_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_notify_e_type (XDR *xdrs, rpc_loc_notify_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_fix_criteria_s_type (XDR *xdrs, rpc_loc_fix_criteria_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint32 (xdrs, &objp->valid_mask))
+		 return FALSE;
+	 if (!xdr_rpc_loc_fix_recurrence_e_type (xdrs, &objp->recurrence_type))
+		 return FALSE;
+	 if (!xdr_rpc_loc_operation_mode_e_type (xdrs, &objp->preferred_operation_mode))
+		 return FALSE;
+	 if (!xdr_rpc_uint32 (xdrs, &objp->preferred_accuracy))
+		 return FALSE;
+	 if (!xdr_rpc_uint32 (xdrs, &objp->preferred_response_time))
+		 return FALSE;
+	 if (!xdr_rpc_boolean (xdrs, &objp->intermediate_pos_report_enabled))
+		 return FALSE;
+	 if (!xdr_rpc_loc_notify_e_type (xdrs, &objp->notify_type))
+		 return FALSE;
+	 if (!xdr_rpc_uint32 (xdrs, &objp->min_interval))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->min_distance))
+		 return FALSE;
+	 if (!xdr_rpc_uint32 (xdrs, &objp->min_dist_sample_interval))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ni_user_resp_e_type (XDR *xdrs, rpc_loc_ni_user_resp_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_user_verify_s_type (XDR *xdrs, rpc_loc_user_verify_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_ni_user_resp_e_type (xdrs, &objp->user_resp))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ni_event_s_type (xdrs, &objp->ni_event_pass_back))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_predicted_orbits_data_format_e_type (XDR *xdrs, rpc_loc_predicted_orbits_data_format_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_predicted_orbits_data_s_type (XDR *xdrs, rpc_loc_predicted_orbits_data_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_predicted_orbits_data_format_e_type (xdrs, &objp->format_type))
+		 return FALSE;
+	 if (!xdr_rpc_uint32 (xdrs, &objp->total_size))
+		 return FALSE;
+	 if (!xdr_rpc_uint8 (xdrs, &objp->total_parts))
+		 return FALSE;
+	 if (!xdr_rpc_uint8 (xdrs, &objp->part))
+		 return FALSE;
+	 if (!xdr_rpc_uint16 (xdrs, &objp->part_len))
+		 return FALSE;
+	 if (!xdr_bytes (xdrs, (char **)&objp->data_ptr.data_ptr_val, (u_int *) &objp->data_ptr.data_ptr_len, ~0))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_predicted_orbits_data_validity_report_s_type (XDR *xdrs, rpc_loc_predicted_orbits_data_validity_report_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint64 (xdrs, &objp->start_time_utc))
+		 return FALSE;
+	 if (!xdr_rpc_uint16 (xdrs, &objp->valid_duration_hrs))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_predicted_orbits_auto_download_config_s_type (XDR *xdrs, rpc_loc_predicted_orbits_auto_download_config_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_boolean (xdrs, &objp->enable))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->auto_check_every_hrs))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_assist_data_time_s_type (XDR *xdrs, rpc_loc_assist_data_time_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint64 (xdrs, &objp->time_utc))
+		 return FALSE;
+	 if (!xdr_rpc_uint32 (xdrs, &objp->uncertainty))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_assist_pos_valid_mask_type (XDR *xdrs, rpc_loc_assist_pos_valid_mask_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint64 (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_assist_data_pos_s_type (XDR *xdrs, rpc_loc_assist_data_pos_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_assist_pos_valid_mask_type (xdrs, &objp->valid_mask))
+		 return FALSE;
+	 if (!xdr_rpc_uint64 (xdrs, &objp->timestamp_utc))
+		 return FALSE;
+	 if (!xdr_double (xdrs, &objp->latitude))
+		 return FALSE;
+	 if (!xdr_double (xdrs, &objp->longitude))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->altitude_wrt_ellipsoid))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->altitude_wrt_mean_sea_level))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->hor_unc_circular))
+		 return FALSE;
+	 if (!xdr_float (xdrs, &objp->vert_unc))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->confidence_horizontal))
+		 return FALSE;
+	 if (!xdr_u_char (xdrs, &objp->confidence_vertical))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_open_status_e_type (XDR *xdrs, rpc_loc_server_open_status_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_open_status_s_type (XDR *xdrs, rpc_loc_server_open_status_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_server_connection_handle (xdrs, &objp->conn_handle))
+		 return FALSE;
+	 if (!xdr_rpc_loc_server_open_status_e_type (xdrs, &objp->open_status))
+		 return FALSE;
+	 if (!xdr_string (xdrs, &objp->apn_name, ~0))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_close_status_e_type (XDR *xdrs, rpc_loc_server_close_status_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_server_close_status_s_type (XDR *xdrs, rpc_loc_server_close_status_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_server_connection_handle (xdrs, &objp->conn_handle))
+		 return FALSE;
+	 if (!xdr_rpc_loc_server_close_status_e_type (xdrs, &objp->close_status))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_lock_e_type (XDR *xdrs, rpc_loc_lock_e_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_enum (xdrs, (enum_t *) objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_nmea_sentence_type (XDR *xdrs, rpc_loc_nmea_sentence_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint32 (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_assist_data_type (XDR *xdrs, rpc_loc_assist_data_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint32 (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_assist_data_delete_s_type (XDR *xdrs, rpc_loc_assist_data_delete_s_type *objp)
+{
+	register int32_t *buf;
+
+	int i;
+	 if (!xdr_rpc_loc_assist_data_type (xdrs, &objp->type))
+		 return FALSE;
+	 if (!xdr_vector (xdrs, (char *)objp->reserved, 8,
+		sizeof (rpc_uint32), (xdrproc_t) xdr_rpc_uint32))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ioctl_data_u_type (XDR *xdrs, rpc_loc_ioctl_data_u_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_ioctl_e_type (xdrs, &objp->disc))
+		 return FALSE;
+	switch (objp->disc) {
+	case RPC_LOC_IOCTL_SET_FIX_CRITERIA:
+		 if (!xdr_rpc_loc_fix_criteria_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.fix_criteria))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_INFORM_NI_USER_RESPONSE:
+		 if (!xdr_rpc_loc_user_verify_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.user_verify_resp))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_INJECT_PREDICTED_ORBITS_DATA:
+		 if (!xdr_rpc_loc_predicted_orbits_data_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.predicted_orbits_data))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_SET_PREDICTED_ORBITS_DATA_AUTO_DOWNLOAD:
+		 if (!xdr_rpc_loc_predicted_orbits_auto_download_config_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.predicted_orbits_auto_download))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_INJECT_UTC_TIME:
+		 if (!xdr_rpc_loc_assist_data_time_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.assistance_data_time))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_INJECT_POSITION:
+		 if (!xdr_rpc_loc_assist_data_pos_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.assistance_data_position))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_INFORM_SERVER_OPEN_STATUS:
+		 if (!xdr_rpc_loc_server_open_status_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.conn_open_status))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_INFORM_SERVER_CLOSE_STATUS:
+		 if (!xdr_rpc_loc_server_close_status_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.conn_close_status))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_SET_ENGINE_LOCK:
+		 if (!xdr_rpc_loc_lock_e_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.engine_lock))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_SET_SBAS_CONFIG:
+		 if (!xdr_rpc_boolean (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.sbas_mode))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_SET_NMEA_TYPES:
+		 if (!xdr_rpc_loc_nmea_sentence_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.nmea_types))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_SET_ON_DEMAND_LPM:
+		 if (!xdr_rpc_boolean (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.on_demand_lpm))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_SET_CDMA_PDE_SERVER_ADDR:
+	case RPC_LOC_IOCTL_SET_CDMA_MPC_SERVER_ADDR:
+	case RPC_LOC_IOCTL_SET_UMTS_SLP_SERVER_ADDR:
+	case RPC_LOC_IOCTL_SET_CUSTOM_PDE_SERVER_ADDR:
+		 if (!xdr_rpc_loc_server_info_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.server_addr))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_DELETE_ASSIST_DATA:
+		 if (!xdr_rpc_loc_assist_data_delete_s_type (xdrs, &objp->rpc_loc_ioctl_data_u_type_u.assist_data_delete))
+			 return FALSE;
+		break;
+	default:
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ioctl_callback_data_u_type (XDR *xdrs, rpc_loc_ioctl_callback_data_u_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_ioctl_e_type (xdrs, &objp->disc))
+		 return FALSE;
+	switch (objp->disc) {
+	case RPC_LOC_IOCTL_GET_API_VERSION:
+		 if (!xdr_rpc_loc_api_version_s_type (xdrs, &objp->rpc_loc_ioctl_callback_data_u_type_u.api_version))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_GET_FIX_CRITERIA:
+		 if (!xdr_rpc_loc_fix_criteria_s_type (xdrs, &objp->rpc_loc_ioctl_callback_data_u_type_u.fix_criteria))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_GET_ENGINE_LOCK:
+		 if (!xdr_rpc_loc_lock_e_type (xdrs, &objp->rpc_loc_ioctl_callback_data_u_type_u.engine_lock))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_GET_SBAS_CONFIG:
+		 if (!xdr_rpc_boolean (xdrs, &objp->rpc_loc_ioctl_callback_data_u_type_u.sbas_mode))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_GET_NMEA_TYPES:
+		 if (!xdr_rpc_loc_nmea_sentence_type (xdrs, &objp->rpc_loc_ioctl_callback_data_u_type_u.nmea_types))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_GET_ON_DEMAND_LPM:
+		 if (!xdr_rpc_boolean (xdrs, &objp->rpc_loc_ioctl_callback_data_u_type_u.on_demand_lpm))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_GET_CDMA_PDE_SERVER_ADDR:
+	case RPC_LOC_IOCTL_GET_CDMA_MPC_SERVER_ADDR:
+	case RPC_LOC_IOCTL_GET_UMTS_SLP_SERVER_ADDR:
+		 if (!xdr_rpc_loc_server_info_s_type (xdrs, &objp->rpc_loc_ioctl_callback_data_u_type_u.server_addr))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_SOURCE:
+		 if (!xdr_rpc_loc_predicted_orbits_data_source_s_type (xdrs, &objp->rpc_loc_ioctl_callback_data_u_type_u.predicted_orbits_data_source))
+			 return FALSE;
+		break;
+	case RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_VALIDITY:
+		 if (!xdr_rpc_loc_predicted_orbits_data_validity_report_s_type (xdrs, &objp->rpc_loc_ioctl_callback_data_u_type_u.predicted_orbits_data_validity))
+			 return FALSE;
+		break;
+	default:
+		break;
+	}
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ioctl_callback_s_type (XDR *xdrs, rpc_loc_ioctl_callback_s_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_ioctl_e_type (xdrs, &objp->type))
+		 return FALSE;
+	 if (!xdr_rpc_int32 (xdrs, &objp->status))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ioctl_callback_data_u_type (xdrs, &objp->data))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_event_payload_u_type (XDR *xdrs, rpc_loc_event_payload_u_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_u_quad_t (xdrs, &objp->disc))
+		 return FALSE;
+	switch (objp->disc) {
+	case RPC_LOC_EVENT_PARSED_POSITION_REPORT:
+		 if (!xdr_rpc_loc_parsed_position_s_type (xdrs, &objp->rpc_loc_event_payload_u_type_u.parsed_location_report))
+			 return FALSE;
+		break;
+	case RPC_LOC_EVENT_SATELLITE_REPORT:
+		 if (!xdr_rpc_loc_gnss_info_s_type (xdrs, &objp->rpc_loc_event_payload_u_type_u.gnss_report))
+			 return FALSE;
+		break;
+	case RPC_LOC_EVENT_NMEA_POSITION_REPORT:
+		 if (!xdr_rpc_loc_nmea_report_s_type (xdrs, &objp->rpc_loc_event_payload_u_type_u.nmea_report))
+			 return FALSE;
+		break;
+	case RPC_LOC_EVENT_NI_NOTIFY_VERIFY_REQUEST:
+		 if (!xdr_rpc_loc_ni_event_s_type (xdrs, &objp->rpc_loc_event_payload_u_type_u.ni_request))
+			 return FALSE;
+		break;
+	case RPC_LOC_EVENT_ASSISTANCE_DATA_REQUEST:
+		 if (!xdr_rpc_loc_assist_data_request_s_type (xdrs, &objp->rpc_loc_event_payload_u_type_u.assist_data_request))
+			 return FALSE;
+		break;
+	case RPC_LOC_EVENT_LOCATION_SERVER_REQUEST:
+		 if (!xdr_rpc_loc_server_request_s_type (xdrs, &objp->rpc_loc_event_payload_u_type_u.loc_server_request))
+			 return FALSE;
+		break;
+	case RPC_LOC_EVENT_IOCTL_REPORT:
+		 if (!xdr_rpc_loc_ioctl_callback_s_type (xdrs, &objp->rpc_loc_event_payload_u_type_u.ioctl_report))
+			 return FALSE;
+		break;
+	case RPC_LOC_EVENT_STATUS_REPORT:
+		 if (!xdr_rpc_loc_status_event_s_type (xdrs, &objp->rpc_loc_event_payload_u_type_u.status_report))
+			 return FALSE;
+		break;
+	case RPC_LOC_EVENT_RESERVED:
+		 if (!xdr_rpc_loc_reserved_payload_s_type (xdrs, &objp->rpc_loc_event_payload_u_type_u.reserved))
+			 return FALSE;
+		break;
+	default:
+		break;
+	}
+	return TRUE;
+}
diff --git a/msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_fixup.c b/msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_fixup.c
new file mode 100644
index 0000000..fe512f5
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_fixup.c
@@ -0,0 +1,48 @@
+/*=============================================================================
+                        L O C _ A P I _ F I X U P . C
+
+GENERAL DESCRIPTION
+  This file adds API constants that are not automatically transmitted to
+  the RPC stubs, and it also fixes other RPC-related problems.
+
+  ---------------------------------------------------------------------------
+Copyright (c) 2009, QUALCOMM USA, INC.
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+         Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 
+
+         Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. 
+
+         Neither the name of the QUALCOMM USA, INC.  nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  ---------------------------------------------------------------------------
+=============================================================================*/
+
+#include <rpc/rpc.h>
+
+#include "loc_api_fixup.h"
+
+#ifdef ADD_XDR_FLOAT
+
+int
+xdr_float(xdrp, fp)
+        XDR *xdrp; 
+        float *fp;
+{
+        return xdr_long(xdrp, (long*)fp);
+}    
+
+int  
+xdr_double(xdrp, dp)
+        XDR *xdrp;
+        double *dp; 
+{
+                return xdr_long(xdrp, (long*)dp + 1)
+                                && xdr_long(xdrp, (long*)dp);
+} 
+
+#endif /* ADD_XDR_FLOAT */
diff --git a/msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_rpc_glue.c b/msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_rpc_glue.c
new file mode 100644
index 0000000..8c17122
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_rpc_glue.c
@@ -0,0 +1,339 @@
+/******************************************************************************
+  @file  loc_api_rpc_glue.c
+  @brief Android Loc API glue code using rpcgen.
+
+  DESCRIPTION
+  Loc API glue code for Android
+
+  -----------------------------------------------------------------------------
+Copyright (c) 2009, QUALCOMM USA, INC.
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+         Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 
+
+         Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. 
+
+         Neither the name of the QUALCOMM USA, INC.  nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  -----------------------------------------------------------------------------
+ ******************************************************************************/
+/*=====================================================================
+                        EDIT HISTORY FOR MODULE
+
+  This section contains comments describing changes made to the module.
+  Notice that changes are listed in reverse chronological order.
+
+when       who      what, where, why 
+--------   ---      ------------------------------------------------------- 
+03/05/2009   dx       Initial version
+
+======================================================================*/ 
+/*=====================================================================
+
+                     INCLUDE FILES FOR MODULE
+
+======================================================================*/
+//#define LOG_NDDEBUG 0
+
+#include <stdio.h>
+#include <pthread.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/select.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <assert.h>
+
+#include <rpc/rpc.h>
+#include <rpc/clnt.h>
+
+/* Include RPC headers */
+#include "loc_api_rpc_glue.h"
+
+/* Callback init */
+#include "loc_apicb_appinit.h"
+
+/* Logging */
+#define LOG_TAG "lib_api_rpc_glue"
+#include <utils/Log.h>
+
+/* Comment this out to enable logging */
+#undef LOGD
+#define LOGD(...) {}
+
+/*=====================================================================
+     External declarations
+======================================================================*/
+
+CLIENT* loc_api_clnt = NULL;
+
+/* Callback ID and pointer */
+#define LOC_API_CB_ID 1 
+loc_event_cb_f_type *loc_api_saved_cb = NULL;  /* the only callback of Loc API client */
+
+#define RPC_FUNC_VERSION_BASE(a,b) a ## b
+#define RPC_FUNC_VERSION(a,b) RPC_FUNC_VERSION_BASE(a,b)
+
+#define LOC_GLUE_CHECK_INIT(ret_type) \
+   if (loc_api_clnt == NULL) { return (ret_type) RPC_LOC_API_RPC_FAILURE; }
+
+#define LOC_GLUE_CHECK_RESULT(stat, ret_type) \
+   if (stat != RPC_SUCCESS) { return (ret_type) RPC_LOC_API_RPC_FAILURE; }   
+
+/* Callback functions */
+/* Returns 1 if successful */
+bool_t rpc_loc_event_cb_f_type_0x00010001_svc(
+        rpc_loc_event_cb_f_type_args *argp,
+        rpc_loc_event_cb_f_type_rets *ret,
+        struct svc_req *req)
+{
+    /* Callback not registered, or unexpected ID (shouldn't happen) */
+    if (loc_api_saved_cb == NULL || argp->cb_id != LOC_API_CB_ID)
+    {
+        LOGD("Warning: No callback handler.\n");
+        ret->loc_event_cb_f_type_result = 0;
+        return 1; /* simply return */
+    }
+
+    LOGD("proc: %x  prog: %x  vers: %x\n",
+            (int) req->rq_proc,
+            (int) req->rq_prog,
+            (int) req->rq_vers);
+
+    LOGD("Callback received: %x (handle=%d ret_ptr=%d)\n",
+            (int) argp->loc_event,
+            (int) argp->loc_handle,
+            (int) ret);
+
+    /* Forward callback to real callback procedure */
+    rpc_loc_client_handle_type        loc_handle = argp->loc_handle;
+    rpc_loc_event_mask_type           loc_event  = argp->loc_event;
+    const rpc_loc_event_payload_u_type*  loc_event_payload =
+        (const rpc_loc_event_payload_u_type*) argp->loc_event_payload;
+
+    int32 rc = loc_api_saved_cb(loc_handle, loc_event, loc_event_payload);
+    ret->loc_event_cb_f_type_result = rc;
+
+    return 1; /* ok */
+}
+
+int loc_apicbprog_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
+{
+    xdr_free (xdr_result, result);
+
+    /*
+     * Insert additional freeing code here, if needed
+     */
+    // LOGD("***** loc_apicbprog_freeresult\n");
+
+    return 1;
+}
+
+int loc_apicbprog_0x00010001_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
+{
+    return loc_apicbprog_freeresult (transp, xdr_result, result);
+}
+
+/*===========================================================================
+
+FUNCTION loc_api_glue_init
+
+DESCRIPTION
+   Initiates the RPC client
+
+RETURN VALUE
+   1 for success
+   0 for failure
+   
+===========================================================================*/
+int loc_api_glue_init(void)
+{
+    if (loc_api_clnt == NULL)
+    {
+        /* Print msg */
+        LOGD("Trying to create RPC client...\n");
+        loc_api_clnt = clnt_create(NULL, LOC_APIPROG, /*LOC_APIVERS*/ 0x00010000, NULL);
+        LOGD("Created loc_api_clnt ---- %x\n", (unsigned int)loc_api_clnt);
+
+        if (loc_api_clnt == NULL)
+        {
+            fprintf(stderr, "Error: cannot create RPC client.\n");
+            return 0;
+        }
+
+        /* Init RPC callbacks */
+        int rc = loc_apicb_app_init();
+        if (rc >= 0)
+        {
+            LOGD("Loc API callback initialized.\n");
+        } else {
+            fprintf(stderr, "Loc API callback initialization failed.\n");
+            return 0;
+        }
+    }
+
+    return 1;
+}
+
+rpc_loc_client_handle_type loc_open (
+        rpc_loc_event_mask_type  event_reg_mask,
+        loc_event_cb_f_type      *event_callback
+    )
+{
+    LOC_GLUE_CHECK_INIT(rpc_loc_client_handle_type);
+
+    rpc_loc_open_args args;
+    args.event_reg_mask = event_reg_mask;
+    args.event_callback = LOC_API_CB_ID;
+    loc_api_saved_cb = event_callback;
+
+    rpc_loc_open_rets rets;
+    enum clnt_stat stat = RPC_SUCCESS;
+
+    stat = RPC_FUNC_VERSION(rpc_loc_open_, LOC_APIVERS)(&args, &rets, loc_api_clnt);
+    LOC_GLUE_CHECK_RESULT(stat, int32);
+
+    return (rpc_loc_client_handle_type) rets.loc_open_result;
+}
+
+int32 loc_close(rpc_loc_client_handle_type handle)
+{
+    LOC_GLUE_CHECK_INIT(int32);
+
+    rpc_loc_close_args args;
+    args.handle = handle;
+
+    rpc_loc_close_rets rets;
+    enum clnt_stat stat = RPC_SUCCESS;
+
+    stat = RPC_FUNC_VERSION(rpc_loc_close_, LOC_APIVERS)(&args, &rets, loc_api_clnt);
+    LOC_GLUE_CHECK_RESULT(stat, int32);
+
+    return (int32) rets.loc_close_result;
+}
+
+int32 loc_start_fix(rpc_loc_client_handle_type handle)
+{
+    LOC_GLUE_CHECK_INIT(int32);
+
+    rpc_loc_start_fix_args args;
+    args.handle = handle;
+
+    rpc_loc_start_fix_rets rets;
+    enum clnt_stat stat = RPC_SUCCESS;
+
+    stat = RPC_FUNC_VERSION(rpc_loc_start_fix_, LOC_APIVERS)(&args, &rets, loc_api_clnt);
+    LOC_GLUE_CHECK_RESULT(stat, int32);
+
+    return (int32) rets.loc_start_fix_result;
+}
+
+int32 loc_stop_fix(rpc_loc_client_handle_type handle)
+{
+    LOC_GLUE_CHECK_INIT(int32);
+
+    rpc_loc_stop_fix_args args;
+    args.handle = handle;
+
+    rpc_loc_stop_fix_rets rets;
+    enum clnt_stat stat = RPC_SUCCESS;
+
+    stat = RPC_FUNC_VERSION(rpc_loc_stop_fix_, LOC_APIVERS)(&args, &rets, loc_api_clnt);
+    LOC_GLUE_CHECK_RESULT(stat, int32);
+
+    return (int32) rets.loc_stop_fix_result;
+}
+
+int32 loc_ioctl(
+    rpc_loc_client_handle_type           handle,
+    rpc_loc_ioctl_e_type                 ioctl_type,
+    rpc_loc_ioctl_data_u_type*           ioctl_data
+    )
+{
+    LOC_GLUE_CHECK_INIT(int32);
+
+    rpc_loc_ioctl_args args;
+    args.handle = handle;
+    args.ioctl_data = ioctl_data;
+    args.ioctl_type = ioctl_type;
+    if (ioctl_data != NULL)
+    {
+        /* Assign ioctl union discriminator */
+        ioctl_data->disc = ioctl_type;
+
+        /* In case the user hasn't filled in other disc fields,
+           automatically fill them in here */
+        switch (ioctl_type)
+        {
+            case RPC_LOC_IOCTL_GET_API_VERSION:
+            case RPC_LOC_IOCTL_SET_FIX_CRITERIA:
+            case RPC_LOC_IOCTL_GET_FIX_CRITERIA:
+            case RPC_LOC_IOCTL_INFORM_NI_USER_RESPONSE:
+            case RPC_LOC_IOCTL_INJECT_PREDICTED_ORBITS_DATA:
+            case RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_VALIDITY:
+            case RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_SOURCE:
+            case RPC_LOC_IOCTL_SET_PREDICTED_ORBITS_DATA_AUTO_DOWNLOAD:
+            case RPC_LOC_IOCTL_INJECT_UTC_TIME:
+            case RPC_LOC_IOCTL_INJECT_RTC_VALUE:
+            case RPC_LOC_IOCTL_INJECT_POSITION:
+            case RPC_LOC_IOCTL_QUERY_ENGINE_STATE:
+            case RPC_LOC_IOCTL_INFORM_SERVER_OPEN_STATUS:
+            case RPC_LOC_IOCTL_INFORM_SERVER_CLOSE_STATUS:
+            case RPC_LOC_IOCTL_SET_ENGINE_LOCK:
+            case RPC_LOC_IOCTL_GET_ENGINE_LOCK:
+            case RPC_LOC_IOCTL_SET_SBAS_CONFIG:
+            case RPC_LOC_IOCTL_GET_SBAS_CONFIG:
+            case RPC_LOC_IOCTL_SET_NMEA_TYPES:
+            case RPC_LOC_IOCTL_GET_NMEA_TYPES:
+                break;
+            case RPC_LOC_IOCTL_SET_CDMA_PDE_SERVER_ADDR:
+            case RPC_LOC_IOCTL_SET_CDMA_MPC_SERVER_ADDR:
+            case RPC_LOC_IOCTL_SET_UMTS_SLP_SERVER_ADDR:
+                args.ioctl_data->rpc_loc_ioctl_data_u_type_u.server_addr.addr_info.disc =
+                    args.ioctl_data->rpc_loc_ioctl_data_u_type_u.server_addr.addr_type;
+                break;
+            case RPC_LOC_IOCTL_GET_CDMA_PDE_SERVER_ADDR:
+            case RPC_LOC_IOCTL_GET_CDMA_MPC_SERVER_ADDR:
+            case RPC_LOC_IOCTL_GET_UMTS_SLP_SERVER_ADDR:
+                break;
+            case RPC_LOC_IOCTL_SET_ON_DEMAND_LPM:
+            case RPC_LOC_IOCTL_GET_ON_DEMAND_LPM:
+            case RPC_LOC_IOCTL_DELETE_ASSIST_DATA:
+            case RPC_LOC_IOCTL_SET_CUSTOM_PDE_SERVER_ADDR:
+            case RPC_LOC_IOCTL_GET_CUSTOM_PDE_SERVER_ADDR:
+            default:
+                break;
+        } /* switch */
+    } /* ioctl_data != NULL */
+
+    rpc_loc_ioctl_rets rets;
+    enum clnt_stat stat = RPC_SUCCESS;
+
+    stat = RPC_FUNC_VERSION(rpc_loc_ioctl_, LOC_APIVERS)(&args, &rets, loc_api_clnt);
+    LOC_GLUE_CHECK_RESULT(stat, int32);
+
+    return (int32) rets.loc_ioctl_result;
+}
+
+/* Returns 0 if error */
+int32 loc_api_null(void)
+{
+    LOC_GLUE_CHECK_INIT(int32);
+
+    int32 rets;
+    enum clnt_stat stat = RPC_SUCCESS;
+
+    stat = RPC_FUNC_VERSION(rpc_loc_api_null_, LOC_APIVERS)(NULL, &rets, loc_api_clnt);
+    LOC_GLUE_CHECK_RESULT(stat, int32);
+
+    return (int32) rets;
+}
diff --git a/msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_xdr.c b/msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_xdr.c
new file mode 100644
index 0000000..835f6b1
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/gen-3200/loc_api_xdr.c
@@ -0,0 +1,171 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#include "loc_api.h"
+
+bool_t
+xdr_rpc_loc_api_api_versions_return_type (XDR *xdrs, rpc_loc_api_api_versions_return_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_array (xdrs, (char **)&objp->rpc_loc_api_api_versions_return_type_val, (u_int *) &objp->rpc_loc_api_api_versions_return_type_len, ~0,
+		sizeof (rpc_uint32), (xdrproc_t) xdr_rpc_uint32))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_event_cb_f_type (XDR *xdrs, rpc_loc_event_cb_f_type *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint32 (xdrs, objp))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_open_args (XDR *xdrs, rpc_loc_open_args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_event_mask_type (xdrs, &objp->event_reg_mask))
+		 return FALSE;
+	 if (!xdr_rpc_loc_event_cb_f_type (xdrs, &objp->event_callback))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_close_args (XDR *xdrs, rpc_loc_close_args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_client_handle_type (xdrs, &objp->handle))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_start_fix_args (XDR *xdrs, rpc_loc_start_fix_args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_client_handle_type (xdrs, &objp->handle))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_stop_fix_args (XDR *xdrs, rpc_loc_stop_fix_args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_client_handle_type (xdrs, &objp->handle))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ioctl_args (XDR *xdrs, rpc_loc_ioctl_args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_client_handle_type (xdrs, &objp->handle))
+		 return FALSE;
+	 if (!xdr_rpc_loc_ioctl_e_type (xdrs, &objp->ioctl_type))
+		 return FALSE;
+	 if (!xdr_pointer (xdrs, (char **)&objp->ioctl_data, sizeof (rpc_loc_ioctl_data_u_type), (xdrproc_t) xdr_rpc_loc_ioctl_data_u_type))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_api_api_version_s_args (XDR *xdrs, rpc_loc_api_api_version_s_args *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_boolean (xdrs, &objp->len_not_null))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_api_rpc_glue_code_info_remote_rets (XDR *xdrs, rpc_loc_api_rpc_glue_code_info_remote_rets *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_uint32 (xdrs, &objp->toolvers))
+		 return FALSE;
+	 if (!xdr_rpc_uint32 (xdrs, &objp->features))
+		 return FALSE;
+	 if (!xdr_rpc_uint32 (xdrs, &objp->proghash))
+		 return FALSE;
+	 if (!xdr_rpc_uint32 (xdrs, &objp->cbproghash))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_open_rets (XDR *xdrs, rpc_loc_open_rets *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_client_handle_type (xdrs, &objp->loc_open_result))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_close_rets (XDR *xdrs, rpc_loc_close_rets *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_int32 (xdrs, &objp->loc_close_result))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_start_fix_rets (XDR *xdrs, rpc_loc_start_fix_rets *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_int32 (xdrs, &objp->loc_start_fix_result))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_stop_fix_rets (XDR *xdrs, rpc_loc_stop_fix_rets *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_int32 (xdrs, &objp->loc_stop_fix_result))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_ioctl_rets (XDR *xdrs, rpc_loc_ioctl_rets *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_int32 (xdrs, &objp->loc_ioctl_result))
+		 return FALSE;
+	return TRUE;
+}
+
+bool_t
+xdr_rpc_loc_api_api_versions_rets (XDR *xdrs, rpc_loc_api_api_versions_rets *objp)
+{
+	register int32_t *buf;
+
+	 if (!xdr_rpc_loc_api_api_versions_return_type (xdrs, &objp->loc_api_api_versions_result))
+		 return FALSE;
+	 if (!xdr_pointer (xdrs, (char **)&objp->len, sizeof (rpc_uint32), (xdrproc_t) xdr_rpc_uint32))
+		 return FALSE;
+	return TRUE;
+}
diff --git a/msm8974/loc_api/libloc_api-rpc/inc-1240/loc_api.h b/msm8974/loc_api/libloc_api-rpc/inc-1240/loc_api.h
new file mode 100644
index 0000000..e02648c
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/inc-1240/loc_api.h
@@ -0,0 +1,210 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#ifndef _LOC_API_H_RPCGEN
+#define _LOC_API_H_RPCGEN
+
+#include <rpc/rpc.h>
+
+#include <pthread.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+typedef struct {
+	u_int rpc_loc_api_api_versions_return_type_len;
+	rpc_uint32 *rpc_loc_api_api_versions_return_type_val;
+} rpc_loc_api_api_versions_return_type;
+
+typedef rpc_uint32 rpc_loc_event_cb_f_type;
+
+struct rpc_loc_open_args {
+	rpc_loc_event_mask_type event_reg_mask;
+	rpc_loc_event_cb_f_type event_callback;
+};
+typedef struct rpc_loc_open_args rpc_loc_open_args;
+
+struct rpc_loc_close_args {
+	rpc_loc_client_handle_type handle;
+};
+typedef struct rpc_loc_close_args rpc_loc_close_args;
+
+struct rpc_loc_start_fix_args {
+	rpc_loc_client_handle_type handle;
+};
+typedef struct rpc_loc_start_fix_args rpc_loc_start_fix_args;
+
+struct rpc_loc_stop_fix_args {
+	rpc_loc_client_handle_type handle;
+};
+typedef struct rpc_loc_stop_fix_args rpc_loc_stop_fix_args;
+
+struct rpc_loc_ioctl_args {
+	rpc_loc_client_handle_type handle;
+	rpc_loc_ioctl_e_type ioctl_type;
+	rpc_loc_ioctl_data_u_type *ioctl_data;
+};
+typedef struct rpc_loc_ioctl_args rpc_loc_ioctl_args;
+
+struct rpc_loc_api_api_version_s_args {
+	rpc_boolean len_not_null;
+};
+typedef struct rpc_loc_api_api_version_s_args rpc_loc_api_api_version_s_args;
+
+struct rpc_loc_api_rpc_glue_code_info_remote_rets {
+	rpc_uint32 toolvers;
+	rpc_uint32 features;
+	rpc_uint32 proghash;
+	rpc_uint32 cbproghash;
+};
+typedef struct rpc_loc_api_rpc_glue_code_info_remote_rets rpc_loc_api_rpc_glue_code_info_remote_rets;
+
+struct rpc_loc_open_rets {
+	rpc_loc_client_handle_type loc_open_result;
+};
+typedef struct rpc_loc_open_rets rpc_loc_open_rets;
+
+struct rpc_loc_close_rets {
+	rpc_int32 loc_close_result;
+};
+typedef struct rpc_loc_close_rets rpc_loc_close_rets;
+
+struct rpc_loc_start_fix_rets {
+	rpc_int32 loc_start_fix_result;
+};
+typedef struct rpc_loc_start_fix_rets rpc_loc_start_fix_rets;
+
+struct rpc_loc_stop_fix_rets {
+	rpc_int32 loc_stop_fix_result;
+};
+typedef struct rpc_loc_stop_fix_rets rpc_loc_stop_fix_rets;
+
+struct rpc_loc_ioctl_rets {
+	rpc_int32 loc_ioctl_result;
+};
+typedef struct rpc_loc_ioctl_rets rpc_loc_ioctl_rets;
+
+struct rpc_loc_api_api_versions_rets {
+	rpc_loc_api_api_versions_return_type loc_api_api_versions_result;
+	rpc_uint32 *len;
+};
+typedef struct rpc_loc_api_api_versions_rets rpc_loc_api_api_versions_rets;
+#define LOC_APIVERS 0x00040002
+
+#define LOC_APIPROG 0x3000008c
+#define LOC_APIVERS_0001 0x00040001
+
+#if defined(__STDC__) || defined(__cplusplus)
+#define rpc_loc_api_null 0
+extern  enum clnt_stat rpc_loc_api_null_0x00040001(void *, void *, CLIENT *);
+extern  bool_t rpc_loc_api_null_0x00040001_svc(void *, void *, struct svc_req *);
+#define rpc_loc_api_rpc_glue_code_info_remote 1
+extern  enum clnt_stat rpc_loc_api_rpc_glue_code_info_remote_0x00040001(void *, rpc_loc_api_rpc_glue_code_info_remote_rets *, CLIENT *);
+extern  bool_t rpc_loc_api_rpc_glue_code_info_remote_0x00040001_svc(void *, rpc_loc_api_rpc_glue_code_info_remote_rets *, struct svc_req *);
+#define rpc_loc_open 2
+extern  enum clnt_stat rpc_loc_open_0x00040001(rpc_loc_open_args *, rpc_loc_open_rets *, CLIENT *);
+extern  bool_t rpc_loc_open_0x00040001_svc(rpc_loc_open_args *, rpc_loc_open_rets *, struct svc_req *);
+#define rpc_loc_close 3
+extern  enum clnt_stat rpc_loc_close_0x00040001(rpc_loc_close_args *, rpc_loc_close_rets *, CLIENT *);
+extern  bool_t rpc_loc_close_0x00040001_svc(rpc_loc_close_args *, rpc_loc_close_rets *, struct svc_req *);
+#define rpc_loc_start_fix 4
+extern  enum clnt_stat rpc_loc_start_fix_0x00040001(rpc_loc_start_fix_args *, rpc_loc_start_fix_rets *, CLIENT *);
+extern  bool_t rpc_loc_start_fix_0x00040001_svc(rpc_loc_start_fix_args *, rpc_loc_start_fix_rets *, struct svc_req *);
+#define rpc_loc_stop_fix 5
+extern  enum clnt_stat rpc_loc_stop_fix_0x00040001(rpc_loc_stop_fix_args *, rpc_loc_stop_fix_rets *, CLIENT *);
+extern  bool_t rpc_loc_stop_fix_0x00040001_svc(rpc_loc_stop_fix_args *, rpc_loc_stop_fix_rets *, struct svc_req *);
+#define rpc_loc_ioctl 6
+extern  enum clnt_stat rpc_loc_ioctl_0x00040001(rpc_loc_ioctl_args *, rpc_loc_ioctl_rets *, CLIENT *);
+extern  bool_t rpc_loc_ioctl_0x00040001_svc(rpc_loc_ioctl_args *, rpc_loc_ioctl_rets *, struct svc_req *);
+#define rpc_loc_api_api_versions 0xFFFFFFFF
+extern  enum clnt_stat rpc_loc_api_api_versions_0x00040001(void *, rpc_loc_api_api_versions_rets *, CLIENT *);
+extern  bool_t rpc_loc_api_api_versions_0x00040001_svc(void *, rpc_loc_api_api_versions_rets *, struct svc_req *);
+extern int loc_apiprog_0x00040001_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+#define rpc_loc_api_null 0
+extern  enum clnt_stat rpc_loc_api_null_0x00040001();
+extern  bool_t rpc_loc_api_null_0x00040001_svc();
+#define rpc_loc_api_rpc_glue_code_info_remote 1
+extern  enum clnt_stat rpc_loc_api_rpc_glue_code_info_remote_0x00040001();
+extern  bool_t rpc_loc_api_rpc_glue_code_info_remote_0x00040001_svc();
+#define rpc_loc_open 2
+extern  enum clnt_stat rpc_loc_open_0x00040001();
+extern  bool_t rpc_loc_open_0x00040001_svc();
+#define rpc_loc_close 3
+extern  enum clnt_stat rpc_loc_close_0x00040001();
+extern  bool_t rpc_loc_close_0x00040001_svc();
+#define rpc_loc_start_fix 4
+extern  enum clnt_stat rpc_loc_start_fix_0x00040001();
+extern  bool_t rpc_loc_start_fix_0x00040001_svc();
+#define rpc_loc_stop_fix 5
+extern  enum clnt_stat rpc_loc_stop_fix_0x00040001();
+extern  bool_t rpc_loc_stop_fix_0x00040001_svc();
+#define rpc_loc_ioctl 6
+extern  enum clnt_stat rpc_loc_ioctl_0x00040001();
+extern  bool_t rpc_loc_ioctl_0x00040001_svc();
+#define rpc_loc_api_api_versions 0xFFFFFFFF
+extern  enum clnt_stat rpc_loc_api_api_versions_0x00040001();
+extern  bool_t rpc_loc_api_api_versions_0x00040001_svc();
+extern int loc_apiprog_0x00040001_freeresult ();
+#endif /* K&R C */
+#define LOC_APIVERS_0002 0x00040002
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  enum clnt_stat rpc_loc_api_null_0x00040002(void *, void *, CLIENT *);
+extern  bool_t rpc_loc_api_null_0x00040002_svc(void *, void *, struct svc_req *);
+extern int loc_apiprog_0x00040002_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+extern  enum clnt_stat rpc_loc_api_null_0x00040002();
+extern  bool_t rpc_loc_api_null_0x00040002_svc();
+extern int loc_apiprog_0x00040002_freeresult ();
+#endif /* K&R C */
+
+/* the xdr functions */
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  bool_t xdr_rpc_loc_api_api_versions_return_type (XDR *, rpc_loc_api_api_versions_return_type*);
+extern  bool_t xdr_rpc_loc_event_cb_f_type (XDR *, rpc_loc_event_cb_f_type*);
+extern  bool_t xdr_rpc_loc_open_args (XDR *, rpc_loc_open_args*);
+extern  bool_t xdr_rpc_loc_close_args (XDR *, rpc_loc_close_args*);
+extern  bool_t xdr_rpc_loc_start_fix_args (XDR *, rpc_loc_start_fix_args*);
+extern  bool_t xdr_rpc_loc_stop_fix_args (XDR *, rpc_loc_stop_fix_args*);
+extern  bool_t xdr_rpc_loc_ioctl_args (XDR *, rpc_loc_ioctl_args*);
+extern  bool_t xdr_rpc_loc_api_api_version_s_args (XDR *, rpc_loc_api_api_version_s_args*);
+extern  bool_t xdr_rpc_loc_api_rpc_glue_code_info_remote_rets (XDR *, rpc_loc_api_rpc_glue_code_info_remote_rets*);
+extern  bool_t xdr_rpc_loc_open_rets (XDR *, rpc_loc_open_rets*);
+extern  bool_t xdr_rpc_loc_close_rets (XDR *, rpc_loc_close_rets*);
+extern  bool_t xdr_rpc_loc_start_fix_rets (XDR *, rpc_loc_start_fix_rets*);
+extern  bool_t xdr_rpc_loc_stop_fix_rets (XDR *, rpc_loc_stop_fix_rets*);
+extern  bool_t xdr_rpc_loc_ioctl_rets (XDR *, rpc_loc_ioctl_rets*);
+extern  bool_t xdr_rpc_loc_api_api_versions_rets (XDR *, rpc_loc_api_api_versions_rets*);
+
+#else /* K&R C */
+extern bool_t xdr_rpc_loc_api_api_versions_return_type ();
+extern bool_t xdr_rpc_loc_event_cb_f_type ();
+extern bool_t xdr_rpc_loc_open_args ();
+extern bool_t xdr_rpc_loc_close_args ();
+extern bool_t xdr_rpc_loc_start_fix_args ();
+extern bool_t xdr_rpc_loc_stop_fix_args ();
+extern bool_t xdr_rpc_loc_ioctl_args ();
+extern bool_t xdr_rpc_loc_api_api_version_s_args ();
+extern bool_t xdr_rpc_loc_api_rpc_glue_code_info_remote_rets ();
+extern bool_t xdr_rpc_loc_open_rets ();
+extern bool_t xdr_rpc_loc_close_rets ();
+extern bool_t xdr_rpc_loc_start_fix_rets ();
+extern bool_t xdr_rpc_loc_stop_fix_rets ();
+extern bool_t xdr_rpc_loc_ioctl_rets ();
+extern bool_t xdr_rpc_loc_api_api_versions_rets ();
+
+#endif /* K&R C */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_LOC_API_H_RPCGEN */
diff --git a/msm8974/loc_api/libloc_api-rpc/inc-1240/loc_api_cb.h b/msm8974/loc_api/libloc_api-rpc/inc-1240/loc_api_cb.h
new file mode 100644
index 0000000..67ac084
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/inc-1240/loc_api_cb.h
@@ -0,0 +1,64 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#ifndef _LOC_API_CB_H_RPCGEN
+#define _LOC_API_CB_H_RPCGEN
+
+#include <rpc/rpc.h>
+
+#include <pthread.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+struct rpc_loc_event_cb_f_type_args {
+	rpc_uint32 cb_id;
+	rpc_loc_client_handle_type loc_handle;
+	rpc_loc_event_mask_type loc_event;
+	rpc_loc_event_payload_u_type *loc_event_payload;
+};
+typedef struct rpc_loc_event_cb_f_type_args rpc_loc_event_cb_f_type_args;
+
+struct rpc_loc_event_cb_f_type_rets {
+	rpc_int32 loc_event_cb_f_type_result;
+};
+typedef struct rpc_loc_event_cb_f_type_rets rpc_loc_event_cb_f_type_rets;
+#define LOC_APICBVERS 0x00040002
+
+#define LOC_APICBPROG 0x3100008c
+#define LOC_APICBVERS_0001 0x00040001
+
+#if defined(__STDC__) || defined(__cplusplus)
+#define rpc_loc_event_cb_f_type 1
+extern  enum clnt_stat rpc_loc_event_cb_f_type_0x00040001(rpc_loc_event_cb_f_type_args *, rpc_loc_event_cb_f_type_rets *, CLIENT *);
+extern  bool_t rpc_loc_event_cb_f_type_0x00040001_svc(rpc_loc_event_cb_f_type_args *, rpc_loc_event_cb_f_type_rets *, struct svc_req *);
+extern int loc_apicbprog_0x00040001_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+#define rpc_loc_event_cb_f_type 1
+extern  enum clnt_stat rpc_loc_event_cb_f_type_0x00040001();
+extern  bool_t rpc_loc_event_cb_f_type_0x00040001_svc();
+extern int loc_apicbprog_0x00040001_freeresult ();
+#endif /* K&R C */
+
+/* the xdr functions */
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  bool_t xdr_rpc_loc_event_cb_f_type_args (XDR *, rpc_loc_event_cb_f_type_args*);
+extern  bool_t xdr_rpc_loc_event_cb_f_type_rets (XDR *, rpc_loc_event_cb_f_type_rets*);
+
+#else /* K&R C */
+extern bool_t xdr_rpc_loc_event_cb_f_type_args ();
+extern bool_t xdr_rpc_loc_event_cb_f_type_rets ();
+
+#endif /* K&R C */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_LOC_API_CB_H_RPCGEN */
diff --git a/msm8974/loc_api/libloc_api-rpc/inc-1240/loc_api_common.h b/msm8974/loc_api/libloc_api-rpc/inc-1240/loc_api_common.h
new file mode 100644
index 0000000..6ff3baf
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/inc-1240/loc_api_common.h
@@ -0,0 +1,1154 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#ifndef _LOC_API_COMMON_H_RPCGEN
+#define _LOC_API_COMMON_H_RPCGEN
+
+#include <rpc/rpc.h>
+#include "loc_api_fixup.h"
+
+#include <pthread.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define LOC_API_TOOLVERS 0x00040024
+#define LOC_API_FEATURES 0x00000001
+#define RPC_LOC_EVENT_NI_NOTIFY_VERIFY_REQUEST 0x00000010
+#define RPC_LOC_EVENT_WPS_NEEDED_REQUEST 0x00000200
+#define RPC_LOC_EVENT_IOCTL_REPORT 0x00000080
+#define RPC_LOC_EVENT_LOCATION_SERVER_REQUEST 0x00000040
+#define RPC_LOC_EVENT_RESERVED 0x8000000000000000
+#define RPC_LOC_EVENT_PARSED_POSITION_REPORT 0x00000001
+#define RPC_LOC_EVENT_ASSISTANCE_DATA_REQUEST 0x00000020
+#define RPC_LOC_EVENT_NMEA_POSITION_REPORT 0x00000008
+#define RPC_LOC_EVENT_SATELLITE_REPORT 0x00000002
+#define RPC_LOC_EVENT_STATUS_REPORT 0x00000100
+#define RPC_LOC_EVENT_CB_F_TYPE_VERSION 0x00040001
+#define RPC_LOC_OPEN_VERSION 0x00040001
+#define RPC_LOC_API_RPC_GLUE_CODE_INFO_REMOTE_VERSION 0x00040001
+#define RPC_LOC_API_NULL_VERSION 0x00040001
+#define RPC_LOC_STOP_FIX_VERSION 0x00040001
+#define RPC_LOC_IOCTL_VERSION 0x00040001
+#define RPC_LOC_START_FIX_VERSION 0x00040001
+#define RPC_LOC_CLOSE_VERSION 0x00040001
+#define RPC_LOC_API_API_VERSIONS_VERSION 0x00040001
+#define RPC_LOC_API_API_MAJOR_NUM 0x0004
+#define RPC_LOC_APIAPI_VERSION_IS_HASHKEY 0
+
+typedef bool_t rpc_boolean;
+
+typedef u_long rpc_uint32;
+
+typedef u_short rpc_uint16;
+
+typedef u_char rpc_uint8;
+
+typedef long rpc_int32;
+
+typedef u_char rpc_byte;
+
+typedef u_quad_t rpc_uint64;
+
+typedef rpc_int32 rpc_loc_client_handle_type;
+
+typedef rpc_uint64 rpc_loc_event_mask_type;
+
+typedef rpc_uint64 rpc_loc_position_valid_mask_type;
+
+typedef rpc_uint32 rpc_loc_pos_technology_mask_type;
+
+enum rpc_loc_session_status_e_type {
+	RPC_LOC_SESS_STATUS_SUCCESS = 0,
+	RPC_LOC_SESS_STATUS_IN_PROGESS = 1,
+	RPC_LOC_SESS_STATUS_GENERAL_FAILURE = 2,
+	RPC_LOC_SESS_STATUS_TIMEOUT = 3,
+	RPC_LOC_SESS_STATUS_USER_END = 4,
+	RPC_LOC_SESS_STATUS_BAD_PARAMETER = 5,
+	RPC_LOC_SESS_STATUS_PHONE_OFFLINE = 6,
+	RPC_LOC_SESS_STATUS_ENGINE_LOCKED = 7,
+	RPC_LOC_SESS_STATUS_MAX = 268435456,
+};
+typedef enum rpc_loc_session_status_e_type rpc_loc_session_status_e_type;
+
+struct rpc_loc_calendar_time_s_type {
+	rpc_uint16 year;
+	u_char month;
+	u_char day_of_week;
+	u_char day;
+	u_char hour;
+	u_char minute;
+	u_char second;
+	rpc_uint16 millisecond;
+};
+typedef struct rpc_loc_calendar_time_s_type rpc_loc_calendar_time_s_type;
+
+struct rpc_loc_parsed_position_s_type {
+	rpc_loc_position_valid_mask_type valid_mask;
+	rpc_loc_session_status_e_type session_status;
+	rpc_loc_calendar_time_s_type timestamp_calendar;
+	rpc_uint64 timestamp_utc;
+	rpc_uint8 leap_seconds;
+	float time_unc;
+	double latitude;
+	double longitude;
+	float altitude_wrt_ellipsoid;
+	float altitude_wrt_mean_sea_level;
+	float speed_horizontal;
+	float speed_vertical;
+	float heading;
+	float hor_unc_circular;
+	float hor_unc_ellipse_semi_major;
+	float hor_unc_ellipse_semi_minor;
+	float hor_unc_ellipse_orient_azimuth;
+	float vert_unc;
+	float speed_unc;
+	float heading_unc;
+	u_char confidence_horizontal;
+	u_char confidence_vertical;
+	float magnetic_deviation;
+	rpc_loc_pos_technology_mask_type technology_mask;
+};
+typedef struct rpc_loc_parsed_position_s_type rpc_loc_parsed_position_s_type;
+
+enum rpc_loc_sv_system_e_type {
+	RPC_LOC_SV_SYSTEM_GPS = 1,
+	RPC_LOC_SV_SYSTEM_GALILEO = 2,
+	RPC_LOC_SV_SYSTEM_SBAS = 3,
+	RPC_LOC_SV_SYSTEM_COMPASS = 4,
+	RPC_LOC_SV_SYSTEM_GLONASS = 5,
+	RPC_LOC_SV_SYSTEM_MAX = 268435456,
+};
+typedef enum rpc_loc_sv_system_e_type rpc_loc_sv_system_e_type;
+
+enum rpc_loc_sv_status_e_type {
+	RPC_LOC_SV_STATUS_IDLE = 1,
+	RPC_LOC_SV_STATUS_SEARCH = 2,
+	RPC_LOC_SV_STATUS_TRACK = 3,
+	RPC_LOC_SV_STATUS_MAX = 268435456,
+};
+typedef enum rpc_loc_sv_status_e_type rpc_loc_sv_status_e_type;
+
+typedef rpc_uint32 rpc_loc_sv_info_valid_mask_type;
+
+struct rpc_loc_sv_info_s_type {
+	rpc_loc_sv_info_valid_mask_type valid_mask;
+	rpc_loc_sv_system_e_type system;
+	rpc_uint8 prn;
+	rpc_uint8 health_status;
+	rpc_loc_sv_status_e_type process_status;
+	rpc_boolean has_eph;
+	rpc_boolean has_alm;
+	float elevation;
+	float azimuth;
+	float snr;
+};
+typedef struct rpc_loc_sv_info_s_type rpc_loc_sv_info_s_type;
+
+typedef rpc_uint32 rpc_loc_gnss_info_valid_mask_type;
+
+struct rpc_loc_gnss_info_s_type {
+	rpc_loc_gnss_info_valid_mask_type valid_mask;
+	float position_dop;
+	float horizontal_dop;
+	float vertical_dop;
+	rpc_boolean altitude_assumed;
+	rpc_uint16 sv_count;
+	struct {
+		u_int sv_list_len;
+		rpc_loc_sv_info_s_type *sv_list_val;
+	} sv_list;
+};
+typedef struct rpc_loc_gnss_info_s_type rpc_loc_gnss_info_s_type;
+
+struct rpc_loc_nmea_report_s_type {
+	rpc_uint16 length;
+	char nmea_sentences[1200];
+};
+typedef struct rpc_loc_nmea_report_s_type rpc_loc_nmea_report_s_type;
+
+enum rpc_loc_status_event_e_type {
+	RPC_LOC_STATUS_EVENT_ENGINE_STATE = 1,
+	RPC_LOC_STATUS_EVENT_FIX_SESSION_STATE = 2,
+	RPC_LOC_STATUS_EVENT_MAX = 268435456,
+};
+typedef enum rpc_loc_status_event_e_type rpc_loc_status_event_e_type;
+
+enum rpc_loc_engine_state_e_type {
+	RPC_LOC_ENGINE_STATE_ON = 1,
+	RPC_LOC_ENGINE_STATE_OFF = 2,
+	RPC_LOC_ENGINE_STATE_MAX = 268435456,
+};
+typedef enum rpc_loc_engine_state_e_type rpc_loc_engine_state_e_type;
+
+enum rpc_loc_fix_session_state_e_type {
+	RPC_LOC_FIX_SESSION_STATE_BEGIN = 1,
+	RPC_LOC_FIX_SESSION_STATE_END = 2,
+	RPC_LOC_FIX_SESSION_STATE_MAX = 268435456,
+};
+typedef enum rpc_loc_fix_session_state_e_type rpc_loc_fix_session_state_e_type;
+
+struct rpc_loc_status_event_payload_u_type {
+	rpc_loc_status_event_e_type disc;
+	union {
+		rpc_loc_engine_state_e_type engine_state;
+		rpc_loc_fix_session_state_e_type fix_session_state;
+	} rpc_loc_status_event_payload_u_type_u;
+};
+typedef struct rpc_loc_status_event_payload_u_type rpc_loc_status_event_payload_u_type;
+
+struct rpc_loc_status_event_s_type {
+	rpc_loc_status_event_e_type event;
+	rpc_loc_status_event_payload_u_type payload;
+};
+typedef struct rpc_loc_status_event_s_type rpc_loc_status_event_s_type;
+
+enum rpc_loc_server_addr_e_type {
+	RPC_LOC_SERVER_ADDR_IPV4 = 1,
+	RPC_LOC_SERVER_ADDR_URL = 2,
+	RPC_LOC_SERVER_ADDR_MAX = 268435456,
+};
+typedef enum rpc_loc_server_addr_e_type rpc_loc_server_addr_e_type;
+
+struct rpc_loc_server_addr_ipv4_type {
+	rpc_uint32 addr;
+	rpc_uint16 port;
+};
+typedef struct rpc_loc_server_addr_ipv4_type rpc_loc_server_addr_ipv4_type;
+
+struct rpc_loc_server_addr_url_type {
+	rpc_uint16 length;
+	char addr[256];
+};
+typedef struct rpc_loc_server_addr_url_type rpc_loc_server_addr_url_type;
+
+struct rpc_loc_server_addr_u_type {
+	rpc_loc_server_addr_e_type disc;
+	union {
+		rpc_loc_server_addr_ipv4_type ipv4;
+		rpc_loc_server_addr_url_type url;
+	} rpc_loc_server_addr_u_type_u;
+};
+typedef struct rpc_loc_server_addr_u_type rpc_loc_server_addr_u_type;
+
+struct rpc_loc_server_info_s_type {
+	rpc_loc_server_addr_e_type addr_type;
+	rpc_loc_server_addr_u_type addr_info;
+};
+typedef struct rpc_loc_server_info_s_type rpc_loc_server_info_s_type;
+
+enum rpc_loc_ni_notify_verify_e_type {
+	RPC_LOC_NI_USER_NO_NOTIFY_NO_VERIFY = 1,
+	RPC_LOC_NI_USER_NOTIFY_ONLY = 2,
+	RPC_LOC_NI_USER_NOTIFY_VERIFY_ALLOW_NO_RESP = 3,
+	RPC_LOC_NI_USER_NOTIFY_VERIFY_NOT_ALLOW_NO_RESP = 4,
+	RPC_LOC_NI_USER_PRIVACY_OVERRIDE = 5,
+	RPC_LOC_NI_USER_NOTIFY_VERITY_TYPE_MAX = 268435456,
+};
+typedef enum rpc_loc_ni_notify_verify_e_type rpc_loc_ni_notify_verify_e_type;
+
+enum rpc_loc_ni_event_e_type {
+	RPC_LOC_NI_EVENT_VX_NOTIFY_VERIFY_REQ = 1,
+	RPC_LOC_NI_EVENT_SUPL_NOTIFY_VERIFY_REQ = 2,
+	RPC_LOC_NI_EVENT_UMTS_CP_NOTIFY_VERIFY_REQ = 3,
+	RPC_LOC_NI_EVENT_VX_SERVICE_INTERACTION_REQ = 4,
+	RPC_LOC_NI_EVENT_MAX = 268435456,
+};
+typedef enum rpc_loc_ni_event_e_type rpc_loc_ni_event_e_type;
+
+enum rpc_loc_ni_datacoding_scheme_e_type {
+	RPC_LOC_NI_PRESUPL_ISO646IRV = 0,
+	RPC_LOC_NI_PRESUPL_ISO8859 = 1,
+	RPC_LOC_NI_PRESUPL_UTF8 = 2,
+	RPC_LOC_NI_PRESUPL_UTF16 = 3,
+	RPC_LOC_NI_PRESUPL_UCS2 = 4,
+	RPC_LOC_NI_PRESUPL_GSM_DEFAULT = 5,
+	RPC_LOC_NI_PRESUPL_SHIFT_JIS = 6,
+	RPC_LOC_NI_PRESUPL_JIS = 7,
+	RPC_LOC_NI_PRESUPL_EUC = 8,
+	RPC_LOC_NI_PRESUPL_GB2312 = 9,
+	RPC_LOC_NI_PRESUPL_CNS11643 = 10,
+	RPC_LOC_NI_PRESUPL_KSC1001 = 11,
+	RPC_LOC_NI_PRESUPL_ENCODING_UNKNOWN = 2147483647,
+	RPC_LOC_NI_SS_GERMAN = 12,
+	RPC_LOC_NI_SS_ENGLISH = 13,
+	RPC_LOC_NI_SS_ITALIAN = 14,
+	RPC_LOC_NI_SS_FRENCH = 15,
+	RPC_LOC_NI_SS_SPANISH = 16,
+	RPC_LOC_NI_SS_DUTCH = 17,
+	RPC_LOC_NI_SS_SWEDISH = 18,
+	RPC_LOC_NI_SS_DANISH = 19,
+	RPC_LOC_NI_SS_PORTUGUESE = 20,
+	RPC_LOC_NI_SS_FINNISH = 21,
+	RPC_LOC_NI_SS_NORWEGIAN = 22,
+	RPC_LOC_NI_SS_GREEK = 23,
+	RPC_LOC_NI_SS_TURKISH = 24,
+	RPC_LOC_NI_SS_HUNGARIAN = 25,
+	RPC_LOC_NI_SS_POLISH = 26,
+	RPC_LOC_NI_SS_LANGUAGE_UNSPEC = 27,
+	RPC_LOC_NI_SUPL_UTF8 = 28,
+	RPC_LOC_NI_SUPL_UCS2 = 29,
+	RPC_LOC_NI_SUPL_GSM_DEFAULT = 30,
+	RPC_LOC_NI_SUPL_ENCODING_UNKNOWN = 2147483647,
+};
+typedef enum rpc_loc_ni_datacoding_scheme_e_type rpc_loc_ni_datacoding_scheme_e_type;
+
+enum rpc_loc_ni_vx_requester_id_encoding_scheme_e_type {
+	RPC_LOC_NI_VX_OCTET = 0,
+	RPC_LOC_NI_VX_EXN_PROTOCOL_MSG = 1,
+	RPC_LOC_NI_VX_ASCII = 2,
+	RPC_LOC_NI_VX_IA5 = 3,
+	RPC_LOC_NI_VX_UNICODE = 4,
+	RPC_LOC_NI_VX_SHIFT_JIS = 5,
+	RPC_LOC_NI_VX_KOREAN = 6,
+	RPC_LOC_NI_VX_LATIN_HEBREW = 7,
+	RPC_LOC_NI_VX_LATIN = 8,
+	RPC_LOC_NI_VX_GSM = 9,
+	RPC_LOC_NI_VX_ENCODING_TYPE_MAX = 268435456,
+};
+typedef enum rpc_loc_ni_vx_requester_id_encoding_scheme_e_type rpc_loc_ni_vx_requester_id_encoding_scheme_e_type;
+
+enum rpc_loc_ni_vx_pos_mode_e_type {
+	RPC_LOC_VX_MS_ASSISTED_ONLY = 1,
+	RPC_LOC_VX_MS_BASED_ONLY = 2,
+	RPC_LOC_VX_MS_ASSISTED_PREF_MSBASED_ALLWD = 3,
+	RPC_LOC_VX_MS_BASED_PREF_ASSISTED_ALLWD = 4,
+	RPC_LOC_VX_POS_MODE_MAX = 268435456,
+};
+typedef enum rpc_loc_ni_vx_pos_mode_e_type rpc_loc_ni_vx_pos_mode_e_type;
+
+struct rpc_loc_ni_vx_requester_id_s_type {
+	u_char requester_id_length;
+	char requester_id[200];
+};
+typedef struct rpc_loc_ni_vx_requester_id_s_type rpc_loc_ni_vx_requester_id_s_type;
+
+struct rpc_loc_ni_vx_notify_verify_req_s_type {
+	rpc_loc_ni_notify_verify_e_type notification_priv_type;
+	u_char pos_qos_incl;
+	u_char pos_qos;
+	rpc_uint32 num_fixes;
+	rpc_uint32 tbf;
+	rpc_loc_ni_vx_pos_mode_e_type pos_mode;
+	rpc_loc_ni_vx_requester_id_encoding_scheme_e_type encoding_scheme;
+	rpc_loc_ni_vx_requester_id_s_type requester_id;
+	rpc_uint16 user_resp_timer_val;
+};
+typedef struct rpc_loc_ni_vx_notify_verify_req_s_type rpc_loc_ni_vx_notify_verify_req_s_type;
+
+enum rpc_loc_ni_supl_pos_method_e_type {
+	RPC_LOC_NI_POSMETHOD_AGPS_SETASSISTED = 1,
+	RPC_LOC_NI_POSMETHOD_AGPS_SETBASED = 2,
+	RPC_LOC_NI_POSMETHOD_AGPS_SETASSISTED_PREF = 3,
+	RPC_LOC_NI_POSMETHOD_AGPS_SETBASED_PREF = 4,
+	RPC_LOC_NI_POSMETHOD_AUTONOMOUS_GPS = 5,
+	RPC_LOC_NI_POSMETHOD_AFLT = 6,
+	RPC_LOC_NI_POSMETHOD_ECID = 7,
+	RPC_LOC_NI_POSMETHOD_EOTD = 8,
+	RPC_LOC_NI_POSMETHOD_OTDOA = 9,
+	RPC_LOC_NI_POSMETHOD_NO_POSITION = 10,
+	RPC_LOC_NI_POSMETHOD_MAX = 268435456,
+};
+typedef enum rpc_loc_ni_supl_pos_method_e_type rpc_loc_ni_supl_pos_method_e_type;
+
+struct rpc_loc_ni_supl_slp_session_id_s_type {
+	u_char presence;
+	char session_id[4];
+	rpc_loc_server_info_s_type slp_address;
+};
+typedef struct rpc_loc_ni_supl_slp_session_id_s_type rpc_loc_ni_supl_slp_session_id_s_type;
+
+struct rpc_loc_ni_requestor_id_s_type {
+	u_char data_coding_scheme;
+	char requestor_id_string[200];
+	u_char string_len;
+};
+typedef struct rpc_loc_ni_requestor_id_s_type rpc_loc_ni_requestor_id_s_type;
+
+struct rpc_loc_ni_supl_client_name_s_type {
+	u_char data_coding_scheme;
+	char client_name_string[64];
+	u_char string_len;
+};
+typedef struct rpc_loc_ni_supl_client_name_s_type rpc_loc_ni_supl_client_name_s_type;
+
+struct rpc_loc_ni_supl_qop_s_type {
+	u_char bit_mask;
+	u_char horacc;
+	u_char veracc;
+	rpc_uint16 maxLocAge;
+	u_char delay;
+};
+typedef struct rpc_loc_ni_supl_qop_s_type rpc_loc_ni_supl_qop_s_type;
+
+struct rpc_loc_ni_supl_notify_verify_req_s_type {
+	rpc_loc_ni_notify_verify_e_type notification_priv_type;
+	rpc_uint16 flags;
+	rpc_loc_ni_supl_slp_session_id_s_type supl_slp_session_id;
+	char supl_hash[8];
+	rpc_loc_ni_datacoding_scheme_e_type datacoding_scheme;
+	rpc_loc_ni_supl_pos_method_e_type pos_method;
+	rpc_loc_ni_requestor_id_s_type requestor_id;
+	rpc_loc_ni_supl_client_name_s_type client_name;
+	rpc_loc_ni_supl_qop_s_type supl_qop;
+	rpc_uint16 user_response_timer;
+};
+typedef struct rpc_loc_ni_supl_notify_verify_req_s_type rpc_loc_ni_supl_notify_verify_req_s_type;
+
+struct rpc_loc_ni_ext_client_address_s_type {
+	u_char ext_client_address_len;
+	char ext_client_address[20];
+};
+typedef struct rpc_loc_ni_ext_client_address_s_type rpc_loc_ni_ext_client_address_s_type;
+
+enum rpc_loc_ni_location_type_e_type {
+	RPC_LOC_NI_LOCATIONTYPE_CURRENT_LOCATION = 1,
+	RPC_LOC_NI_LOCATIONTYPE_CURRENT_OR_LAST_KNOWN_LOCATION = 2,
+	RPC_LOC_NI_LOCATIONTYPE_INITIAL_LOCATION = 3,
+	RPC_LOC_NI_LOCATIONTYPE_MAX = 268435456,
+};
+typedef enum rpc_loc_ni_location_type_e_type rpc_loc_ni_location_type_e_type;
+
+struct rpc_loc_ni_deferred_location_s_type {
+	u_char unused_bits;
+	u_char ms_available;
+};
+typedef struct rpc_loc_ni_deferred_location_s_type rpc_loc_ni_deferred_location_s_type;
+
+struct rpc_loc_ni_codeword_string_s_type {
+	u_char data_coding_scheme;
+	char lcs_codeword_string[20];
+	u_char string_len;
+};
+typedef struct rpc_loc_ni_codeword_string_s_type rpc_loc_ni_codeword_string_s_type;
+
+struct rpc_loc_ni_service_type_id_s_type {
+	u_char lcs_service_type_id;
+};
+typedef struct rpc_loc_ni_service_type_id_s_type rpc_loc_ni_service_type_id_s_type;
+
+struct rpc_loc_ni_umts_cp_notify_verify_req_s_type {
+	rpc_loc_ni_notify_verify_e_type notification_priv_type;
+	u_char invoke_id;
+	rpc_uint16 flags;
+	u_char notification_length;
+	char notification_text[64];
+	rpc_loc_ni_datacoding_scheme_e_type datacoding_scheme;
+	rpc_loc_ni_ext_client_address_s_type ext_client_address_data;
+	rpc_loc_ni_location_type_e_type location_type;
+	rpc_loc_ni_deferred_location_s_type deferred_location;
+	rpc_loc_ni_requestor_id_s_type requestor_id;
+	rpc_loc_ni_codeword_string_s_type codeword_string;
+	rpc_loc_ni_service_type_id_s_type service_type_id;
+	rpc_uint16 user_response_timer;
+};
+typedef struct rpc_loc_ni_umts_cp_notify_verify_req_s_type rpc_loc_ni_umts_cp_notify_verify_req_s_type;
+
+enum rpc_loc_ni_service_interaction_e_type {
+	RPC_LOC_NI_SERVICE_INTERACTION_ONGOING_NI_INCOMING_MO = 1,
+	RPC_LOC_NI_SERVICE_INTERACTION_MAX = 268435456,
+};
+typedef enum rpc_loc_ni_service_interaction_e_type rpc_loc_ni_service_interaction_e_type;
+
+struct rpc_loc_ni_vx_service_interaction_req_s_type {
+	rpc_loc_ni_vx_notify_verify_req_s_type ni_vx_req;
+	rpc_loc_ni_service_interaction_e_type service_interation_type;
+};
+typedef struct rpc_loc_ni_vx_service_interaction_req_s_type rpc_loc_ni_vx_service_interaction_req_s_type;
+
+struct rpc_loc_ni_event_payload_u_type {
+	rpc_loc_ni_event_e_type disc;
+	union {
+		rpc_loc_ni_vx_notify_verify_req_s_type vx_req;
+		rpc_loc_ni_supl_notify_verify_req_s_type supl_req;
+		rpc_loc_ni_umts_cp_notify_verify_req_s_type umts_cp_req;
+		rpc_loc_ni_vx_service_interaction_req_s_type service_interaction_req;
+	} rpc_loc_ni_event_payload_u_type_u;
+};
+typedef struct rpc_loc_ni_event_payload_u_type rpc_loc_ni_event_payload_u_type;
+
+struct rpc_loc_ni_event_s_type {
+	rpc_loc_ni_event_e_type event;
+	rpc_loc_ni_event_payload_u_type payload;
+};
+typedef struct rpc_loc_ni_event_s_type rpc_loc_ni_event_s_type;
+
+enum rpc_loc_assist_data_request_e_type {
+	RPC_LOC_ASSIST_DATA_TIME_REQ = 1,
+	RPC_LOC_ASSIST_DATA_PREDICTED_ORBITS_REQ = 2,
+	RPC_LOC_ASSIST_DATA_MAX = 268435456,
+};
+typedef enum rpc_loc_assist_data_request_e_type rpc_loc_assist_data_request_e_type;
+
+typedef char *rpc_struct_loc_time_download_source_s_type_servers_ptr;
+
+typedef rpc_struct_loc_time_download_source_s_type_servers_ptr rpc_struct_loc_time_download_source_s_type_servers[3];
+
+struct rpc_loc_time_download_source_s_type {
+	rpc_uint32 delay_threshold;
+	rpc_struct_loc_time_download_source_s_type_servers servers;
+};
+typedef struct rpc_loc_time_download_source_s_type rpc_loc_time_download_source_s_type;
+
+typedef char *rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr;
+
+typedef rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr rpc_struct_loc_predicted_orbits_data_source_s_type_servers[3];
+
+struct rpc_loc_predicted_orbits_data_source_s_type {
+	rpc_uint32 max_file_size;
+	rpc_uint32 max_part_size;
+	rpc_struct_loc_predicted_orbits_data_source_s_type_servers servers;
+};
+typedef struct rpc_loc_predicted_orbits_data_source_s_type rpc_loc_predicted_orbits_data_source_s_type;
+
+struct rpc_loc_assist_data_request_payload_u_type {
+	rpc_loc_assist_data_request_e_type disc;
+	union {
+		rpc_loc_time_download_source_s_type time_download;
+		rpc_loc_predicted_orbits_data_source_s_type data_download;
+	} rpc_loc_assist_data_request_payload_u_type_u;
+};
+typedef struct rpc_loc_assist_data_request_payload_u_type rpc_loc_assist_data_request_payload_u_type;
+
+struct rpc_loc_assist_data_request_s_type {
+	rpc_loc_assist_data_request_e_type event;
+	rpc_loc_assist_data_request_payload_u_type payload;
+};
+typedef struct rpc_loc_assist_data_request_s_type rpc_loc_assist_data_request_s_type;
+
+typedef rpc_uint32 rpc_loc_server_connection_handle;
+
+enum rpc_loc_server_protocol_e_type {
+	RPC_LOC_SERVER_PROTOCOL_DEFAULT = 0,
+	RPC_LOC_SERVER_PROTOCOL_SUPL = 1,
+	RPC_LOC_SERVER_PROTOCOL_VX_MPC = 2,
+	RPC_LOC_SERVER_PROTOCOL_VX_PDE = 3,
+	RPC_LOC_SERVER_PROTOCOL_MAX = 16777216,
+};
+typedef enum rpc_loc_server_protocol_e_type rpc_loc_server_protocol_e_type;
+
+enum rpc_loc_server_request_e_type {
+	RPC_LOC_SERVER_REQUEST_OPEN = 1,
+	RPC_LOC_SERVER_REQUEST_CLOSE = 2,
+	RPC_LOC_SERVER_REQUEST_MAX = 268435456,
+};
+typedef enum rpc_loc_server_request_e_type rpc_loc_server_request_e_type;
+
+struct rpc_loc_server_open_req_s_type {
+	rpc_loc_server_connection_handle conn_handle;
+	rpc_loc_server_protocol_e_type protocol;
+};
+typedef struct rpc_loc_server_open_req_s_type rpc_loc_server_open_req_s_type;
+
+struct rpc_loc_server_close_req_s_type {
+	rpc_loc_server_connection_handle conn_handle;
+};
+typedef struct rpc_loc_server_close_req_s_type rpc_loc_server_close_req_s_type;
+
+struct rpc_loc_server_request_u_type {
+	rpc_loc_server_request_e_type disc;
+	union {
+		rpc_loc_server_open_req_s_type open_req;
+		rpc_loc_server_close_req_s_type close_req;
+	} rpc_loc_server_request_u_type_u;
+};
+typedef struct rpc_loc_server_request_u_type rpc_loc_server_request_u_type;
+
+struct rpc_loc_server_request_s_type {
+	rpc_loc_server_request_e_type event;
+	rpc_loc_server_request_u_type payload;
+};
+typedef struct rpc_loc_server_request_s_type rpc_loc_server_request_s_type;
+
+enum rpc_loc_qwip_request_e_type {
+	RPC_LOC_QWIP_START_PERIODIC_HI_FREQ_FIXES = 0,
+	RPC_LOC_QWIP_START_PERIODIC_KEEP_WARM = 0 + 1,
+	RPC_LOC_QWIP_STOP_PERIODIC_FIXES = 0 + 2,
+	RPC_LOC_QWIP_SUSPEND = 0 + 3,
+	RPC_LOC_QWIP_REQUEST_MAX = 268435456,
+};
+typedef enum rpc_loc_qwip_request_e_type rpc_loc_qwip_request_e_type;
+
+struct rpc_loc_qwip_request_s_type {
+	rpc_loc_qwip_request_e_type request_type;
+	rpc_uint16 tbf_ms;
+};
+typedef struct rpc_loc_qwip_request_s_type rpc_loc_qwip_request_s_type;
+
+struct rpc_loc_reserved_payload_s_type {
+	rpc_uint16 data_size;
+	struct {
+		u_int data_len;
+		char *data_val;
+	} data;
+};
+typedef struct rpc_loc_reserved_payload_s_type rpc_loc_reserved_payload_s_type;
+
+enum rpc_loc_ioctl_e_type {
+	RPC_LOC_IOCTL_GET_API_VERSION = 1,
+	RPC_LOC_IOCTL_SET_FIX_CRITERIA = 2,
+	RPC_LOC_IOCTL_GET_FIX_CRITERIA = 3,
+	RPC_LOC_IOCTL_SERVICE_START_INDEX = 400,
+	RPC_LOC_IOCTL_INFORM_NI_USER_RESPONSE = 400,
+	RPC_LOC_IOCTL_INJECT_PREDICTED_ORBITS_DATA = 401,
+	RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_VALIDITY = 402,
+	RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_SOURCE = 403,
+	RPC_LOC_IOCTL_SET_PREDICTED_ORBITS_DATA_AUTO_DOWNLOAD = 404,
+	RPC_LOC_IOCTL_INJECT_UTC_TIME = 405,
+	RPC_LOC_IOCTL_INJECT_RTC_VALUE = 406,
+	RPC_LOC_IOCTL_INJECT_POSITION = 407,
+	RPC_LOC_IOCTL_QUERY_ENGINE_STATE = 408,
+	RPC_LOC_IOCTL_INFORM_SERVER_OPEN_STATUS = 409,
+	RPC_LOC_IOCTL_INFORM_SERVER_CLOSE_STATUS = 410,
+	RPC_LOC_IOCTL_SEND_WIPER_POSITION_REPORT = 411,
+	RPC_LOC_IOCTL_NOTIFY_WIPER_STATUS = 412,
+	RPC_LOC_IOCTL_ACCESS_EFS_DATA = 413,
+	RPC_LOC_IOCTL_NV_SETTINGS_START_INDEX = 800,
+	RPC_LOC_IOCTL_SET_ENGINE_LOCK = 800,
+	RPC_LOC_IOCTL_GET_ENGINE_LOCK = 801,
+	RPC_LOC_IOCTL_SET_SBAS_CONFIG = 802,
+	RPC_LOC_IOCTL_GET_SBAS_CONFIG = 803,
+	RPC_LOC_IOCTL_SET_NMEA_TYPES = 804,
+	RPC_LOC_IOCTL_GET_NMEA_TYPES = 805,
+	RPC_LOC_IOCTL_SET_CDMA_PDE_SERVER_ADDR = 806,
+	RPC_LOC_IOCTL_GET_CDMA_PDE_SERVER_ADDR = 807,
+	RPC_LOC_IOCTL_SET_CDMA_MPC_SERVER_ADDR = 808,
+	RPC_LOC_IOCTL_GET_CDMA_MPC_SERVER_ADDR = 809,
+	RPC_LOC_IOCTL_SET_UMTS_SLP_SERVER_ADDR = 810,
+	RPC_LOC_IOCTL_GET_UMTS_SLP_SERVER_ADDR = 811,
+	RPC_LOC_IOCTL_SET_ON_DEMAND_LPM = 812,
+	RPC_LOC_IOCTL_GET_ON_DEMAND_LPM = 813,
+	RPC_LOC_IOCTL_PROPRIETARY_START_INDEX = 1000,
+	RPC_LOC_IOCTL_DELETE_ASSIST_DATA = 1000,
+	RPC_LOC_IOCTL_SET_CUSTOM_PDE_SERVER_ADDR = 1001,
+	RPC_LOC_IOCTL_GET_CUSTOM_PDE_SERVER_ADDR = 1002,
+	RPC_LOC_IOCTL_THIRD_PARTY_START_INDEX = 1073741824,
+};
+typedef enum rpc_loc_ioctl_e_type rpc_loc_ioctl_e_type;
+
+struct rpc_loc_api_version_s_type {
+	u_char major;
+	u_char minor;
+};
+typedef struct rpc_loc_api_version_s_type rpc_loc_api_version_s_type;
+
+enum rpc_loc_fix_recurrence_e_type {
+	RPC_LOC_PERIODIC_FIX = 1,
+	RPC_LOC_SINGLE_FIX = 2,
+	RPC_LOC_FIX_SESSION_TYPE_MAX = 268435456,
+};
+typedef enum rpc_loc_fix_recurrence_e_type rpc_loc_fix_recurrence_e_type;
+
+enum rpc_loc_operation_mode_e_type {
+	RPC_LOC_OPER_MODE_DEFAULT = 1,
+	RPC_LOC_OPER_MODE_MSB = 2,
+	RPC_LOC_OPER_MODE_MSA = 3,
+	RPC_LOC_OPER_MODE_STANDALONE = 4,
+	RPC_LOC_OPER_MODE_SPEED_OPTIMAL = 5,
+	RPC_LOC_OPER_MODE_ACCURACY_OPTIMAL = 6,
+	RPC_LOC_OPER_MODE_DATA_OPTIMAL = 7,
+	RPC_LOC_OPER_MODE_CELL_ID = 8,
+	RPC_LOC_OPER_MODE_MAX = 268435456,
+};
+typedef enum rpc_loc_operation_mode_e_type rpc_loc_operation_mode_e_type;
+
+enum rpc_loc_notify_e_type {
+	RPC_LOC_NOTIFY_ON_INTERVAL = 1,
+	RPC_LOC_NOTIFY_ON_DISTANCE = 2,
+	RPC_LOC_NOTIFY_ON_ANY = 3,
+	RPC_LOC_NOTIFY_ON_ALL = 4,
+	RPC_LOC_NOTIFY_TYPE_MAX = 268435456,
+};
+typedef enum rpc_loc_notify_e_type rpc_loc_notify_e_type;
+
+struct rpc_loc_fix_criteria_s_type {
+	rpc_uint32 valid_mask;
+	rpc_loc_fix_recurrence_e_type recurrence_type;
+	rpc_loc_operation_mode_e_type preferred_operation_mode;
+	rpc_uint32 preferred_accuracy;
+	rpc_uint32 preferred_response_time;
+	rpc_boolean intermediate_pos_report_enabled;
+	rpc_loc_notify_e_type notify_type;
+	rpc_uint32 min_interval;
+	float min_distance;
+	rpc_uint32 min_dist_sample_interval;
+};
+typedef struct rpc_loc_fix_criteria_s_type rpc_loc_fix_criteria_s_type;
+
+enum rpc_loc_ni_user_resp_e_type {
+	RPC_LOC_NI_LCS_NOTIFY_VERIFY_ACCEPT = 1,
+	RPC_LOC_NI_LCS_NOTIFY_VERIFY_DENY = 2,
+	RPC_LOC_NI_LCS_NOTIFY_VERIFY_NORESP = 3,
+	RPC_LOC_NI_LCS_NOTIFY_VERIFY_MAX = 268435456,
+};
+typedef enum rpc_loc_ni_user_resp_e_type rpc_loc_ni_user_resp_e_type;
+
+struct rpc_loc_user_verify_s_type {
+	rpc_loc_ni_user_resp_e_type user_resp;
+	rpc_loc_ni_event_s_type ni_event_pass_back;
+};
+typedef struct rpc_loc_user_verify_s_type rpc_loc_user_verify_s_type;
+
+enum rpc_loc_predicted_orbits_data_format_e_type {
+	RPC_LOC_PREDICTED_ORBITS_XTRA = 0,
+	RPC_LOC_PREDICTED_ORBITS_FORMAT_MAX = 268435456,
+};
+typedef enum rpc_loc_predicted_orbits_data_format_e_type rpc_loc_predicted_orbits_data_format_e_type;
+
+struct rpc_loc_predicted_orbits_data_s_type {
+	rpc_loc_predicted_orbits_data_format_e_type format_type;
+	rpc_uint32 total_size;
+	rpc_uint8 total_parts;
+	rpc_uint8 part;
+	rpc_uint16 part_len;
+	struct {
+		u_int data_ptr_len;
+		char *data_ptr_val;
+	} data_ptr;
+};
+typedef struct rpc_loc_predicted_orbits_data_s_type rpc_loc_predicted_orbits_data_s_type;
+
+struct rpc_loc_predicted_orbits_data_validity_report_s_type {
+	rpc_uint64 start_time_utc;
+	rpc_uint16 valid_duration_hrs;
+};
+typedef struct rpc_loc_predicted_orbits_data_validity_report_s_type rpc_loc_predicted_orbits_data_validity_report_s_type;
+
+struct rpc_loc_predicted_orbits_auto_download_config_s_type {
+	rpc_boolean enable;
+	u_char auto_check_every_hrs;
+};
+typedef struct rpc_loc_predicted_orbits_auto_download_config_s_type rpc_loc_predicted_orbits_auto_download_config_s_type;
+
+struct rpc_loc_assist_data_time_s_type {
+	rpc_uint64 time_utc;
+	rpc_uint32 uncertainty;
+};
+typedef struct rpc_loc_assist_data_time_s_type rpc_loc_assist_data_time_s_type;
+
+typedef rpc_uint64 rpc_loc_assist_pos_valid_mask_type;
+
+struct rpc_loc_assist_data_pos_s_type {
+	rpc_loc_assist_pos_valid_mask_type valid_mask;
+	rpc_uint64 timestamp_utc;
+	double latitude;
+	double longitude;
+	float altitude_wrt_ellipsoid;
+	float altitude_wrt_mean_sea_level;
+	float hor_unc_circular;
+	float vert_unc;
+	u_char confidence_horizontal;
+	u_char confidence_vertical;
+	rpc_int32 timestamp_age;
+};
+typedef struct rpc_loc_assist_data_pos_s_type rpc_loc_assist_data_pos_s_type;
+
+enum rpc_loc_server_open_status_e_type {
+	RPC_LOC_SERVER_OPEN_SUCCESS = 1,
+	RPC_LOC_SERVER_OPEN_FAIL = 2,
+	RPC_LOC_SERVER_OPEN_STATUS_MAX = 268435456,
+};
+typedef enum rpc_loc_server_open_status_e_type rpc_loc_server_open_status_e_type;
+
+struct rpc_loc_server_open_status_s_type {
+	rpc_loc_server_connection_handle conn_handle;
+	rpc_loc_server_open_status_e_type open_status;
+	char apn_name[100];
+};
+typedef struct rpc_loc_server_open_status_s_type rpc_loc_server_open_status_s_type;
+
+enum rpc_loc_server_close_status_e_type {
+	RPC_LOC_SERVER_CLOSE_SUCCESS = 1,
+	RPC_LOC_SERVER_CLOSE_FAIL = 2,
+	RPC_LOC_SERVER_CLOSE_STATUS_MAX = 268435456,
+};
+typedef enum rpc_loc_server_close_status_e_type rpc_loc_server_close_status_e_type;
+
+struct rpc_loc_server_close_status_s_type {
+	rpc_loc_server_connection_handle conn_handle;
+	rpc_loc_server_close_status_e_type close_status;
+};
+typedef struct rpc_loc_server_close_status_s_type rpc_loc_server_close_status_s_type;
+
+struct rpc_loc_wiper_fix_time_s_type {
+	rpc_uint32 slow_clock_count;
+};
+typedef struct rpc_loc_wiper_fix_time_s_type rpc_loc_wiper_fix_time_s_type;
+
+struct rpc_loc_wiper_fix_pos_s_type {
+	rpc_int32 lat;
+	rpc_int32 lon;
+	rpc_uint16 HEPE;
+	rpc_uint8 num_of_aps_used;
+	rpc_uint8 fix_error_code;
+};
+typedef struct rpc_loc_wiper_fix_pos_s_type rpc_loc_wiper_fix_pos_s_type;
+
+struct rpc_loc_wiper_ap_info_s_type {
+	char mac_addr[6];
+	rpc_int32 rssi;
+	rpc_uint16 channel;
+	rpc_uint8 ap_qualifier;
+};
+typedef struct rpc_loc_wiper_ap_info_s_type rpc_loc_wiper_ap_info_s_type;
+
+struct rpc_loc_wiper_ap_set_s_type {
+	rpc_uint8 num_of_aps;
+	rpc_loc_wiper_ap_info_s_type ap_info[50];
+};
+typedef struct rpc_loc_wiper_ap_set_s_type rpc_loc_wiper_ap_set_s_type;
+
+struct rpc_loc_wiper_position_report_s_type {
+	rpc_uint8 wiper_valid_info_flag;
+	rpc_loc_wiper_fix_time_s_type wiper_fix_time;
+	rpc_loc_wiper_fix_pos_s_type wiper_fix_position;
+	rpc_loc_wiper_ap_set_s_type wiper_ap_set;
+};
+typedef struct rpc_loc_wiper_position_report_s_type rpc_loc_wiper_position_report_s_type;
+
+enum rpc_loc_wiper_status_e_type {
+	RPC_LOC_WIPER_STATUS_AVAILABLE = 1,
+	RPC_LOC_WIPER_STATUS_UNAVAILABLE = 2,
+	RPC_LOC_WIPER_STATUS_E_SIZE = 268435456,
+};
+typedef enum rpc_loc_wiper_status_e_type rpc_loc_wiper_status_e_type;
+
+enum rpc_loc_fs_operation_e_type {
+	RPC_LOC_FS_CREATE_WRITE_FILE = 1,
+	RPC_LOC_FS_APPEND_FILE = 2,
+	RPC_LOC_FS_DELETE_FILE = 3,
+	RPC_LOC_FS_READ_FILE = 4,
+	RPC_LOC_FS_MAX = 268435456,
+};
+typedef enum rpc_loc_fs_operation_e_type rpc_loc_fs_operation_e_type;
+
+struct rpc_loc_efs_data_s_type {
+	char filename[64];
+	rpc_loc_fs_operation_e_type operation;
+	rpc_uint32 total_size;
+	struct {
+		u_int data_ptr_len;
+		char *data_ptr_val;
+	} data_ptr;
+	rpc_uint32 part_len;
+	rpc_uint8 part;
+	rpc_uint8 total_parts;
+	rpc_uint32 reserved;
+};
+typedef struct rpc_loc_efs_data_s_type rpc_loc_efs_data_s_type;
+
+enum rpc_loc_lock_e_type {
+	RPC_LOC_LOCK_NONE = 1,
+	RPC_LOC_LOCK_MI = 2,
+	RPC_LOC_LOCK_MT = 3,
+	RPC_LOC_LOCK_ALL = 4,
+	RPC_LOC_LOCK_MAX = 268435456,
+};
+typedef enum rpc_loc_lock_e_type rpc_loc_lock_e_type;
+
+typedef rpc_uint32 rpc_loc_nmea_sentence_type;
+
+typedef rpc_uint32 rpc_loc_assist_data_type;
+
+struct rpc_loc_assist_data_delete_s_type {
+	rpc_loc_assist_data_type type;
+	rpc_uint32 reserved[8];
+};
+typedef struct rpc_loc_assist_data_delete_s_type rpc_loc_assist_data_delete_s_type;
+
+struct rpc_loc_ioctl_data_u_type {
+	rpc_loc_ioctl_e_type disc;
+	union {
+		rpc_loc_fix_criteria_s_type fix_criteria;
+		rpc_loc_user_verify_s_type user_verify_resp;
+		rpc_loc_predicted_orbits_data_s_type predicted_orbits_data;
+		rpc_loc_predicted_orbits_auto_download_config_s_type predicted_orbits_auto_download;
+		rpc_loc_assist_data_time_s_type assistance_data_time;
+		rpc_loc_assist_data_pos_s_type assistance_data_position;
+		rpc_loc_server_open_status_s_type conn_open_status;
+		rpc_loc_server_close_status_s_type conn_close_status;
+		rpc_loc_wiper_position_report_s_type wiper_pos;
+		rpc_loc_wiper_status_e_type wiper_status;
+		rpc_loc_lock_e_type engine_lock;
+		rpc_boolean sbas_mode;
+		rpc_loc_nmea_sentence_type nmea_types;
+		rpc_boolean on_demand_lpm;
+		rpc_loc_server_info_s_type server_addr;
+		rpc_loc_assist_data_delete_s_type assist_data_delete;
+		rpc_loc_efs_data_s_type efs_data;
+	} rpc_loc_ioctl_data_u_type_u;
+};
+typedef struct rpc_loc_ioctl_data_u_type rpc_loc_ioctl_data_u_type;
+
+struct rpc_loc_ioctl_callback_data_u_type {
+	rpc_loc_ioctl_e_type disc;
+	union {
+		rpc_loc_api_version_s_type api_version;
+		rpc_loc_fix_criteria_s_type fix_criteria;
+		rpc_loc_lock_e_type engine_lock;
+		rpc_boolean sbas_mode;
+		rpc_loc_nmea_sentence_type nmea_types;
+		rpc_boolean on_demand_lpm;
+		rpc_loc_server_info_s_type server_addr;
+		rpc_loc_predicted_orbits_data_source_s_type predicted_orbits_data_source;
+		rpc_loc_predicted_orbits_data_validity_report_s_type predicted_orbits_data_validity;
+	} rpc_loc_ioctl_callback_data_u_type_u;
+};
+typedef struct rpc_loc_ioctl_callback_data_u_type rpc_loc_ioctl_callback_data_u_type;
+
+struct rpc_loc_ioctl_callback_s_type {
+	rpc_loc_ioctl_e_type type;
+	rpc_int32 status;
+	rpc_loc_ioctl_callback_data_u_type data;
+};
+typedef struct rpc_loc_ioctl_callback_s_type rpc_loc_ioctl_callback_s_type;
+
+struct rpc_loc_event_payload_u_type {
+	u_quad_t disc;
+	union {
+		rpc_loc_parsed_position_s_type parsed_location_report;
+		rpc_loc_gnss_info_s_type gnss_report;
+		rpc_loc_nmea_report_s_type nmea_report;
+		rpc_loc_ni_event_s_type ni_request;
+		rpc_loc_assist_data_request_s_type assist_data_request;
+		rpc_loc_server_request_s_type loc_server_request;
+		rpc_loc_ioctl_callback_s_type ioctl_report;
+		rpc_loc_status_event_s_type status_report;
+		rpc_loc_qwip_request_s_type qwip_request;
+		rpc_loc_reserved_payload_s_type reserved;
+	} rpc_loc_event_payload_u_type_u;
+};
+typedef struct rpc_loc_event_payload_u_type rpc_loc_event_payload_u_type;
+
+/* the xdr functions */
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  bool_t xdr_rpc_boolean (XDR *, rpc_boolean*);
+extern  bool_t xdr_rpc_uint32 (XDR *, rpc_uint32*);
+extern  bool_t xdr_rpc_uint16 (XDR *, rpc_uint16*);
+extern  bool_t xdr_rpc_uint8 (XDR *, rpc_uint8*);
+extern  bool_t xdr_rpc_int32 (XDR *, rpc_int32*);
+extern  bool_t xdr_rpc_byte (XDR *, rpc_byte*);
+extern  bool_t xdr_rpc_uint64 (XDR *, rpc_uint64*);
+extern  bool_t xdr_rpc_loc_client_handle_type (XDR *, rpc_loc_client_handle_type*);
+extern  bool_t xdr_rpc_loc_event_mask_type (XDR *, rpc_loc_event_mask_type*);
+extern  bool_t xdr_rpc_loc_position_valid_mask_type (XDR *, rpc_loc_position_valid_mask_type*);
+extern  bool_t xdr_rpc_loc_pos_technology_mask_type (XDR *, rpc_loc_pos_technology_mask_type*);
+extern  bool_t xdr_rpc_loc_session_status_e_type (XDR *, rpc_loc_session_status_e_type*);
+extern  bool_t xdr_rpc_loc_calendar_time_s_type (XDR *, rpc_loc_calendar_time_s_type*);
+extern  bool_t xdr_rpc_loc_parsed_position_s_type (XDR *, rpc_loc_parsed_position_s_type*);
+extern  bool_t xdr_rpc_loc_sv_system_e_type (XDR *, rpc_loc_sv_system_e_type*);
+extern  bool_t xdr_rpc_loc_sv_status_e_type (XDR *, rpc_loc_sv_status_e_type*);
+extern  bool_t xdr_rpc_loc_sv_info_valid_mask_type (XDR *, rpc_loc_sv_info_valid_mask_type*);
+extern  bool_t xdr_rpc_loc_sv_info_s_type (XDR *, rpc_loc_sv_info_s_type*);
+extern  bool_t xdr_rpc_loc_gnss_info_valid_mask_type (XDR *, rpc_loc_gnss_info_valid_mask_type*);
+extern  bool_t xdr_rpc_loc_gnss_info_s_type (XDR *, rpc_loc_gnss_info_s_type*);
+extern  bool_t xdr_rpc_loc_nmea_report_s_type (XDR *, rpc_loc_nmea_report_s_type*);
+extern  bool_t xdr_rpc_loc_status_event_e_type (XDR *, rpc_loc_status_event_e_type*);
+extern  bool_t xdr_rpc_loc_engine_state_e_type (XDR *, rpc_loc_engine_state_e_type*);
+extern  bool_t xdr_rpc_loc_fix_session_state_e_type (XDR *, rpc_loc_fix_session_state_e_type*);
+extern  bool_t xdr_rpc_loc_status_event_payload_u_type (XDR *, rpc_loc_status_event_payload_u_type*);
+extern  bool_t xdr_rpc_loc_status_event_s_type (XDR *, rpc_loc_status_event_s_type*);
+extern  bool_t xdr_rpc_loc_server_addr_e_type (XDR *, rpc_loc_server_addr_e_type*);
+extern  bool_t xdr_rpc_loc_server_addr_ipv4_type (XDR *, rpc_loc_server_addr_ipv4_type*);
+extern  bool_t xdr_rpc_loc_server_addr_url_type (XDR *, rpc_loc_server_addr_url_type*);
+extern  bool_t xdr_rpc_loc_server_addr_u_type (XDR *, rpc_loc_server_addr_u_type*);
+extern  bool_t xdr_rpc_loc_server_info_s_type (XDR *, rpc_loc_server_info_s_type*);
+extern  bool_t xdr_rpc_loc_ni_notify_verify_e_type (XDR *, rpc_loc_ni_notify_verify_e_type*);
+extern  bool_t xdr_rpc_loc_ni_event_e_type (XDR *, rpc_loc_ni_event_e_type*);
+extern  bool_t xdr_rpc_loc_ni_datacoding_scheme_e_type (XDR *, rpc_loc_ni_datacoding_scheme_e_type*);
+extern  bool_t xdr_rpc_loc_ni_vx_requester_id_encoding_scheme_e_type (XDR *, rpc_loc_ni_vx_requester_id_encoding_scheme_e_type*);
+extern  bool_t xdr_rpc_loc_ni_vx_pos_mode_e_type (XDR *, rpc_loc_ni_vx_pos_mode_e_type*);
+extern  bool_t xdr_rpc_loc_ni_vx_requester_id_s_type (XDR *, rpc_loc_ni_vx_requester_id_s_type*);
+extern  bool_t xdr_rpc_loc_ni_vx_notify_verify_req_s_type (XDR *, rpc_loc_ni_vx_notify_verify_req_s_type*);
+extern  bool_t xdr_rpc_loc_ni_supl_pos_method_e_type (XDR *, rpc_loc_ni_supl_pos_method_e_type*);
+extern  bool_t xdr_rpc_loc_ni_supl_slp_session_id_s_type (XDR *, rpc_loc_ni_supl_slp_session_id_s_type*);
+extern  bool_t xdr_rpc_loc_ni_requestor_id_s_type (XDR *, rpc_loc_ni_requestor_id_s_type*);
+extern  bool_t xdr_rpc_loc_ni_supl_client_name_s_type (XDR *, rpc_loc_ni_supl_client_name_s_type*);
+extern  bool_t xdr_rpc_loc_ni_supl_qop_s_type (XDR *, rpc_loc_ni_supl_qop_s_type*);
+extern  bool_t xdr_rpc_loc_ni_supl_notify_verify_req_s_type (XDR *, rpc_loc_ni_supl_notify_verify_req_s_type*);
+extern  bool_t xdr_rpc_loc_ni_ext_client_address_s_type (XDR *, rpc_loc_ni_ext_client_address_s_type*);
+extern  bool_t xdr_rpc_loc_ni_location_type_e_type (XDR *, rpc_loc_ni_location_type_e_type*);
+extern  bool_t xdr_rpc_loc_ni_deferred_location_s_type (XDR *, rpc_loc_ni_deferred_location_s_type*);
+extern  bool_t xdr_rpc_loc_ni_codeword_string_s_type (XDR *, rpc_loc_ni_codeword_string_s_type*);
+extern  bool_t xdr_rpc_loc_ni_service_type_id_s_type (XDR *, rpc_loc_ni_service_type_id_s_type*);
+extern  bool_t xdr_rpc_loc_ni_umts_cp_notify_verify_req_s_type (XDR *, rpc_loc_ni_umts_cp_notify_verify_req_s_type*);
+extern  bool_t xdr_rpc_loc_ni_service_interaction_e_type (XDR *, rpc_loc_ni_service_interaction_e_type*);
+extern  bool_t xdr_rpc_loc_ni_vx_service_interaction_req_s_type (XDR *, rpc_loc_ni_vx_service_interaction_req_s_type*);
+extern  bool_t xdr_rpc_loc_ni_event_payload_u_type (XDR *, rpc_loc_ni_event_payload_u_type*);
+extern  bool_t xdr_rpc_loc_ni_event_s_type (XDR *, rpc_loc_ni_event_s_type*);
+extern  bool_t xdr_rpc_loc_assist_data_request_e_type (XDR *, rpc_loc_assist_data_request_e_type*);
+extern  bool_t xdr_rpc_struct_loc_time_download_source_s_type_servers_ptr (XDR *, rpc_struct_loc_time_download_source_s_type_servers_ptr*);
+extern  bool_t xdr_rpc_struct_loc_time_download_source_s_type_servers (XDR *, rpc_struct_loc_time_download_source_s_type_servers);
+extern  bool_t xdr_rpc_loc_time_download_source_s_type (XDR *, rpc_loc_time_download_source_s_type*);
+extern  bool_t xdr_rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr (XDR *, rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr*);
+extern  bool_t xdr_rpc_struct_loc_predicted_orbits_data_source_s_type_servers (XDR *, rpc_struct_loc_predicted_orbits_data_source_s_type_servers);
+extern  bool_t xdr_rpc_loc_predicted_orbits_data_source_s_type (XDR *, rpc_loc_predicted_orbits_data_source_s_type*);
+extern  bool_t xdr_rpc_loc_assist_data_request_payload_u_type (XDR *, rpc_loc_assist_data_request_payload_u_type*);
+extern  bool_t xdr_rpc_loc_assist_data_request_s_type (XDR *, rpc_loc_assist_data_request_s_type*);
+extern  bool_t xdr_rpc_loc_server_connection_handle (XDR *, rpc_loc_server_connection_handle*);
+extern  bool_t xdr_rpc_loc_server_protocol_e_type (XDR *, rpc_loc_server_protocol_e_type*);
+extern  bool_t xdr_rpc_loc_server_request_e_type (XDR *, rpc_loc_server_request_e_type*);
+extern  bool_t xdr_rpc_loc_server_open_req_s_type (XDR *, rpc_loc_server_open_req_s_type*);
+extern  bool_t xdr_rpc_loc_server_close_req_s_type (XDR *, rpc_loc_server_close_req_s_type*);
+extern  bool_t xdr_rpc_loc_server_request_u_type (XDR *, rpc_loc_server_request_u_type*);
+extern  bool_t xdr_rpc_loc_server_request_s_type (XDR *, rpc_loc_server_request_s_type*);
+extern  bool_t xdr_rpc_loc_qwip_request_e_type (XDR *, rpc_loc_qwip_request_e_type*);
+extern  bool_t xdr_rpc_loc_qwip_request_s_type (XDR *, rpc_loc_qwip_request_s_type*);
+extern  bool_t xdr_rpc_loc_reserved_payload_s_type (XDR *, rpc_loc_reserved_payload_s_type*);
+extern  bool_t xdr_rpc_loc_ioctl_e_type (XDR *, rpc_loc_ioctl_e_type*);
+extern  bool_t xdr_rpc_loc_api_version_s_type (XDR *, rpc_loc_api_version_s_type*);
+extern  bool_t xdr_rpc_loc_fix_recurrence_e_type (XDR *, rpc_loc_fix_recurrence_e_type*);
+extern  bool_t xdr_rpc_loc_operation_mode_e_type (XDR *, rpc_loc_operation_mode_e_type*);
+extern  bool_t xdr_rpc_loc_notify_e_type (XDR *, rpc_loc_notify_e_type*);
+extern  bool_t xdr_rpc_loc_fix_criteria_s_type (XDR *, rpc_loc_fix_criteria_s_type*);
+extern  bool_t xdr_rpc_loc_ni_user_resp_e_type (XDR *, rpc_loc_ni_user_resp_e_type*);
+extern  bool_t xdr_rpc_loc_user_verify_s_type (XDR *, rpc_loc_user_verify_s_type*);
+extern  bool_t xdr_rpc_loc_predicted_orbits_data_format_e_type (XDR *, rpc_loc_predicted_orbits_data_format_e_type*);
+extern  bool_t xdr_rpc_loc_predicted_orbits_data_s_type (XDR *, rpc_loc_predicted_orbits_data_s_type*);
+extern  bool_t xdr_rpc_loc_predicted_orbits_data_validity_report_s_type (XDR *, rpc_loc_predicted_orbits_data_validity_report_s_type*);
+extern  bool_t xdr_rpc_loc_predicted_orbits_auto_download_config_s_type (XDR *, rpc_loc_predicted_orbits_auto_download_config_s_type*);
+extern  bool_t xdr_rpc_loc_assist_data_time_s_type (XDR *, rpc_loc_assist_data_time_s_type*);
+extern  bool_t xdr_rpc_loc_assist_pos_valid_mask_type (XDR *, rpc_loc_assist_pos_valid_mask_type*);
+extern  bool_t xdr_rpc_loc_assist_data_pos_s_type (XDR *, rpc_loc_assist_data_pos_s_type*);
+extern  bool_t xdr_rpc_loc_server_open_status_e_type (XDR *, rpc_loc_server_open_status_e_type*);
+extern  bool_t xdr_rpc_loc_server_open_status_s_type (XDR *, rpc_loc_server_open_status_s_type*);
+extern  bool_t xdr_rpc_loc_server_close_status_e_type (XDR *, rpc_loc_server_close_status_e_type*);
+extern  bool_t xdr_rpc_loc_server_close_status_s_type (XDR *, rpc_loc_server_close_status_s_type*);
+extern  bool_t xdr_rpc_loc_wiper_fix_time_s_type (XDR *, rpc_loc_wiper_fix_time_s_type*);
+extern  bool_t xdr_rpc_loc_wiper_fix_pos_s_type (XDR *, rpc_loc_wiper_fix_pos_s_type*);
+extern  bool_t xdr_rpc_loc_wiper_ap_info_s_type (XDR *, rpc_loc_wiper_ap_info_s_type*);
+extern  bool_t xdr_rpc_loc_wiper_ap_set_s_type (XDR *, rpc_loc_wiper_ap_set_s_type*);
+extern  bool_t xdr_rpc_loc_wiper_position_report_s_type (XDR *, rpc_loc_wiper_position_report_s_type*);
+extern  bool_t xdr_rpc_loc_wiper_status_e_type (XDR *, rpc_loc_wiper_status_e_type*);
+extern  bool_t xdr_rpc_loc_fs_operation_e_type (XDR *, rpc_loc_fs_operation_e_type*);
+extern  bool_t xdr_rpc_loc_efs_data_s_type (XDR *, rpc_loc_efs_data_s_type*);
+extern  bool_t xdr_rpc_loc_lock_e_type (XDR *, rpc_loc_lock_e_type*);
+extern  bool_t xdr_rpc_loc_nmea_sentence_type (XDR *, rpc_loc_nmea_sentence_type*);
+extern  bool_t xdr_rpc_loc_assist_data_type (XDR *, rpc_loc_assist_data_type*);
+extern  bool_t xdr_rpc_loc_assist_data_delete_s_type (XDR *, rpc_loc_assist_data_delete_s_type*);
+extern  bool_t xdr_rpc_loc_ioctl_data_u_type (XDR *, rpc_loc_ioctl_data_u_type*);
+extern  bool_t xdr_rpc_loc_ioctl_callback_data_u_type (XDR *, rpc_loc_ioctl_callback_data_u_type*);
+extern  bool_t xdr_rpc_loc_ioctl_callback_s_type (XDR *, rpc_loc_ioctl_callback_s_type*);
+extern  bool_t xdr_rpc_loc_event_payload_u_type (XDR *, rpc_loc_event_payload_u_type*);
+
+#else /* K&R C */
+extern bool_t xdr_rpc_boolean ();
+extern bool_t xdr_rpc_uint32 ();
+extern bool_t xdr_rpc_uint16 ();
+extern bool_t xdr_rpc_uint8 ();
+extern bool_t xdr_rpc_int32 ();
+extern bool_t xdr_rpc_byte ();
+extern bool_t xdr_rpc_uint64 ();
+extern bool_t xdr_rpc_loc_client_handle_type ();
+extern bool_t xdr_rpc_loc_event_mask_type ();
+extern bool_t xdr_rpc_loc_position_valid_mask_type ();
+extern bool_t xdr_rpc_loc_pos_technology_mask_type ();
+extern bool_t xdr_rpc_loc_session_status_e_type ();
+extern bool_t xdr_rpc_loc_calendar_time_s_type ();
+extern bool_t xdr_rpc_loc_parsed_position_s_type ();
+extern bool_t xdr_rpc_loc_sv_system_e_type ();
+extern bool_t xdr_rpc_loc_sv_status_e_type ();
+extern bool_t xdr_rpc_loc_sv_info_valid_mask_type ();
+extern bool_t xdr_rpc_loc_sv_info_s_type ();
+extern bool_t xdr_rpc_loc_gnss_info_valid_mask_type ();
+extern bool_t xdr_rpc_loc_gnss_info_s_type ();
+extern bool_t xdr_rpc_loc_nmea_report_s_type ();
+extern bool_t xdr_rpc_loc_status_event_e_type ();
+extern bool_t xdr_rpc_loc_engine_state_e_type ();
+extern bool_t xdr_rpc_loc_fix_session_state_e_type ();
+extern bool_t xdr_rpc_loc_status_event_payload_u_type ();
+extern bool_t xdr_rpc_loc_status_event_s_type ();
+extern bool_t xdr_rpc_loc_server_addr_e_type ();
+extern bool_t xdr_rpc_loc_server_addr_ipv4_type ();
+extern bool_t xdr_rpc_loc_server_addr_url_type ();
+extern bool_t xdr_rpc_loc_server_addr_u_type ();
+extern bool_t xdr_rpc_loc_server_info_s_type ();
+extern bool_t xdr_rpc_loc_ni_notify_verify_e_type ();
+extern bool_t xdr_rpc_loc_ni_event_e_type ();
+extern bool_t xdr_rpc_loc_ni_datacoding_scheme_e_type ();
+extern bool_t xdr_rpc_loc_ni_vx_requester_id_encoding_scheme_e_type ();
+extern bool_t xdr_rpc_loc_ni_vx_pos_mode_e_type ();
+extern bool_t xdr_rpc_loc_ni_vx_requester_id_s_type ();
+extern bool_t xdr_rpc_loc_ni_vx_notify_verify_req_s_type ();
+extern bool_t xdr_rpc_loc_ni_supl_pos_method_e_type ();
+extern bool_t xdr_rpc_loc_ni_supl_slp_session_id_s_type ();
+extern bool_t xdr_rpc_loc_ni_requestor_id_s_type ();
+extern bool_t xdr_rpc_loc_ni_supl_client_name_s_type ();
+extern bool_t xdr_rpc_loc_ni_supl_qop_s_type ();
+extern bool_t xdr_rpc_loc_ni_supl_notify_verify_req_s_type ();
+extern bool_t xdr_rpc_loc_ni_ext_client_address_s_type ();
+extern bool_t xdr_rpc_loc_ni_location_type_e_type ();
+extern bool_t xdr_rpc_loc_ni_deferred_location_s_type ();
+extern bool_t xdr_rpc_loc_ni_codeword_string_s_type ();
+extern bool_t xdr_rpc_loc_ni_service_type_id_s_type ();
+extern bool_t xdr_rpc_loc_ni_umts_cp_notify_verify_req_s_type ();
+extern bool_t xdr_rpc_loc_ni_service_interaction_e_type ();
+extern bool_t xdr_rpc_loc_ni_vx_service_interaction_req_s_type ();
+extern bool_t xdr_rpc_loc_ni_event_payload_u_type ();
+extern bool_t xdr_rpc_loc_ni_event_s_type ();
+extern bool_t xdr_rpc_loc_assist_data_request_e_type ();
+extern bool_t xdr_rpc_struct_loc_time_download_source_s_type_servers_ptr ();
+extern bool_t xdr_rpc_struct_loc_time_download_source_s_type_servers ();
+extern bool_t xdr_rpc_loc_time_download_source_s_type ();
+extern bool_t xdr_rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr ();
+extern bool_t xdr_rpc_struct_loc_predicted_orbits_data_source_s_type_servers ();
+extern bool_t xdr_rpc_loc_predicted_orbits_data_source_s_type ();
+extern bool_t xdr_rpc_loc_assist_data_request_payload_u_type ();
+extern bool_t xdr_rpc_loc_assist_data_request_s_type ();
+extern bool_t xdr_rpc_loc_server_connection_handle ();
+extern bool_t xdr_rpc_loc_server_protocol_e_type ();
+extern bool_t xdr_rpc_loc_server_request_e_type ();
+extern bool_t xdr_rpc_loc_server_open_req_s_type ();
+extern bool_t xdr_rpc_loc_server_close_req_s_type ();
+extern bool_t xdr_rpc_loc_server_request_u_type ();
+extern bool_t xdr_rpc_loc_server_request_s_type ();
+extern bool_t xdr_rpc_loc_qwip_request_e_type ();
+extern bool_t xdr_rpc_loc_qwip_request_s_type ();
+extern bool_t xdr_rpc_loc_reserved_payload_s_type ();
+extern bool_t xdr_rpc_loc_ioctl_e_type ();
+extern bool_t xdr_rpc_loc_api_version_s_type ();
+extern bool_t xdr_rpc_loc_fix_recurrence_e_type ();
+extern bool_t xdr_rpc_loc_operation_mode_e_type ();
+extern bool_t xdr_rpc_loc_notify_e_type ();
+extern bool_t xdr_rpc_loc_fix_criteria_s_type ();
+extern bool_t xdr_rpc_loc_ni_user_resp_e_type ();
+extern bool_t xdr_rpc_loc_user_verify_s_type ();
+extern bool_t xdr_rpc_loc_predicted_orbits_data_format_e_type ();
+extern bool_t xdr_rpc_loc_predicted_orbits_data_s_type ();
+extern bool_t xdr_rpc_loc_predicted_orbits_data_validity_report_s_type ();
+extern bool_t xdr_rpc_loc_predicted_orbits_auto_download_config_s_type ();
+extern bool_t xdr_rpc_loc_assist_data_time_s_type ();
+extern bool_t xdr_rpc_loc_assist_pos_valid_mask_type ();
+extern bool_t xdr_rpc_loc_assist_data_pos_s_type ();
+extern bool_t xdr_rpc_loc_server_open_status_e_type ();
+extern bool_t xdr_rpc_loc_server_open_status_s_type ();
+extern bool_t xdr_rpc_loc_server_close_status_e_type ();
+extern bool_t xdr_rpc_loc_server_close_status_s_type ();
+extern bool_t xdr_rpc_loc_wiper_fix_time_s_type ();
+extern bool_t xdr_rpc_loc_wiper_fix_pos_s_type ();
+extern bool_t xdr_rpc_loc_wiper_ap_info_s_type ();
+extern bool_t xdr_rpc_loc_wiper_ap_set_s_type ();
+extern bool_t xdr_rpc_loc_wiper_position_report_s_type ();
+extern bool_t xdr_rpc_loc_wiper_status_e_type ();
+extern bool_t xdr_rpc_loc_fs_operation_e_type ();
+extern bool_t xdr_rpc_loc_efs_data_s_type ();
+extern bool_t xdr_rpc_loc_lock_e_type ();
+extern bool_t xdr_rpc_loc_nmea_sentence_type ();
+extern bool_t xdr_rpc_loc_assist_data_type ();
+extern bool_t xdr_rpc_loc_assist_data_delete_s_type ();
+extern bool_t xdr_rpc_loc_ioctl_data_u_type ();
+extern bool_t xdr_rpc_loc_ioctl_callback_data_u_type ();
+extern bool_t xdr_rpc_loc_ioctl_callback_s_type ();
+extern bool_t xdr_rpc_loc_event_payload_u_type ();
+
+#endif /* K&R C */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_LOC_API_COMMON_H_RPCGEN */
diff --git a/msm8974/loc_api/libloc_api-rpc/inc-1240/loc_api_fixup.h b/msm8974/loc_api/libloc_api-rpc/inc-1240/loc_api_fixup.h
new file mode 100644
index 0000000..e62eb36
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/inc-1240/loc_api_fixup.h
@@ -0,0 +1,188 @@
+/******************************************************************************
+  @file:  loc_api_fixup.h
+  @brief:  Loc API Android RPC amendment header
+
+  DESCRIPTION
+     Loc API Android RPC amendment header
+
+  INITIALIZATION AND SEQUENCING REQUIREMENTS
+
+  -----------------------------------------------------------------------------
+Copyright (c) 2009, QUALCOMM USA, INC.
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+         Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 
+
+         Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. 
+
+         Neither the name of the QUALCOMM USA, INC.  nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  -----------------------------------------------------------------------------
+ ******************************************************************************/
+
+#ifndef  LOC_API_FIXUP_H
+#define LOC_API_FIXUP_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#ifndef NULLPROC
+#define NULLPROC 0
+#endif /* NULLPROC */
+
+#ifdef ADD_XDR_FLOAT
+
+extern bool_t xdr_float (XDR *__xdrs, float *__fp);
+extern bool_t xdr_double (XDR *__xdrs, double *__dp);
+
+#endif /* ADD_XDR_FLOAT */
+
+#ifdef ADD_XDR_BOOL
+extern bool_t xdr_bool(XDR *__xdrs, int *__bp);
+#endif /* ADD_XDR_BOOL */
+
+#define RPC_LOC_API_MAJOR_VERSION_NUMBER   1
+#define RPC_LOC_API_MINOR_VERSION_NUMBER   0
+
+// Return value for loc_open in case of failure.
+#define RPC_LOC_CLIENT_HANDLE_INVALID     -1
+
+// Return value of loc api calls for loc_close, loc_start_fix, loc_stop_fix and loc_ioctl
+// These are also the status for the ioctl callback
+#define RPC_LOC_API_SUCCESS           0
+#define RPC_LOC_API_GENERAL_FAILURE   1
+#define RPC_LOC_API_UNSUPPORTED       2
+#define RPC_LOC_API_INVALID_HANDLE    4
+#define RPC_LOC_API_INVALID_PARAMETER 5
+#define RPC_LOC_API_ENGINE_BUSY       6
+#define RPC_LOC_API_PHONE_OFFLINE     7
+#define RPC_LOC_API_TIMEOUT           8
+
+// Special return value for loc api calls in case of RCP failure
+#define RPC_LOC_API_RPC_FAILURE       (-1234)
+
+#define RPC_LOC_API_MAX_SV_COUNT                      80
+#define RPC_LOC_API_MAX_NMEA_STRING_LENGTH            1200
+
+// Maximum server address that will be used in location API
+#define RPC_LOC_API_MAX_SERVER_ADDR_LENGTH            256
+#define RPC_LOC_API_MAX_NUM_PREDICTED_ORBITS_SERVERS  3
+#define RPC_LOC_API_MAX_NUM_NTP_SERVERS               3
+
+#define RPC_LOC_EVENT_PARSED_POSITION_REPORT             0x00000001 // Position report comes in loc_parsed_position_s_type
+#define RPC_LOC_EVENT_SATELLITE_REPORT                   0x00000002 // Satellite in view report
+#define RPC_LOC_EVENT_NMEA_1HZ_REPORT                    0x00000004 // NMEA report at 1HZ rate
+#define RPC_LOC_EVENT_NMEA_POSITION_REPORT               0x00000008 // NMEA report at position report rate
+#define RPC_LOC_EVENT_NI_NOTIFY_VERIFY_REQUEST           0x00000010 // NI notification/verification request
+#define RPC_LOC_EVENT_ASSISTANCE_DATA_REQUEST            0x00000020 // Assistance data, eg: time, predicted orbits request
+#define RPC_LOC_EVENT_LOCATION_SERVER_REQUEST            0x00000040 // Request for location server
+#define RPC_LOC_EVENT_IOCTL_REPORT                       0x00000080 // Callback report for loc_ioctl
+#define RPC_LOC_EVENT_STATUS_REPORT                      0x00000100 // Misc status report: eg, engine state
+
+
+#define RPC_LOC_POS_VALID_SESSION_STATUS                 0x00000001
+#define RPC_LOC_POS_VALID_TIMESTAMP_CALENDAR             0x00000002
+#define RPC_LOC_POS_VALID_TIMESTAMP_UTC                  0x00000004
+#define RPC_LOC_POS_VALID_LEAP_SECONDS                   0x00000008
+#define RPC_LOC_POS_VALID_TIME_UNC                       0x00000010
+#define RPC_LOC_POS_VALID_LATITUDE                       0x00000020
+#define RPC_LOC_POS_VALID_LONGITUDE                      0x00000040
+#define RPC_LOC_POS_VALID_ALTITUDE_WRT_ELLIPSOID         0x00000080
+#define RPC_LOC_POS_VALID_ALTITUDE_WRT_MEAN_SEA_LEVEL    0x00000100
+#define RPC_LOC_POS_VALID_SPEED_HORIZONTAL               0x00000200
+#define RPC_LOC_POS_VALID_SPEED_VERTICAL                 0x00000400
+#define RPC_LOC_POS_VALID_HEADING                        0x00000800
+#define RPC_LOC_POS_VALID_HOR_UNC_CIRCULAR               0x00001000
+#define RPC_LOC_POS_VALID_HOR_UNC_ELLI_SEMI_MAJ          0x00002000
+#define RPC_LOC_POS_VALID_HOR_UNC_ELLI_SEMI_MIN          0x00004000
+#define RPC_LOC_POS_VALID_HOR_UNC_ELLI_ORIENT_AZIMUTH    0x00008000
+#define RPC_LOC_POS_VALID_VERTICAL_UNC                   0x00010000
+#define RPC_LOC_POS_VALID_SPEED_UNC                      0x00020000
+#define RPC_LOC_POS_VALID_HEADING_UNC                    0x00040000
+#define RPC_LOC_POS_VALID_CONFIDENCE_HORIZONTAL          0x00080000
+#define RPC_LOC_POS_VALID_CONFIDENCE_VERTICAL            0x00100000
+#define RPC_LOC_POS_VALID_MAGNETIC_VARIATION             0x00200000
+#define RPC_LOC_POS_VALID_TECHNOLOGY_MASK                0x00400000
+
+#define RPC_LOC_POS_TECH_SATELLITE 0x00000001
+#define RPC_LOC_POS_TECH_CELLID    0x00000002
+#define RPC_LOC_POS_TECH_WIFI      0x00000004
+
+#define RPC_LOC_SV_INFO_VALID_SYSTEM         0x00000001
+#define RPC_LOC_SV_INFO_VALID_PRN            0x00000002
+#define RPC_LOC_SV_INFO_VALID_HEALTH_STATUS  0x00000004
+#define RPC_LOC_SV_INFO_VALID_PROCESS_STATUS 0x00000008
+#define RPC_LOC_SV_INFO_VALID_HAS_EPH        0x00000010
+#define RPC_LOC_SV_INFO_VALID_HAS_ALM        0x00000020
+#define RPC_LOC_SV_INFO_VALID_ELEVATION      0x00000040
+#define RPC_LOC_SV_INFO_VALID_AZIMUTH        0x00000080
+#define RPC_LOC_SV_INFO_VALID_SNR            0x00000100
+
+#define RPC_LOC_GNSS_INFO_VALID_POS_DOP           0x00000001
+#define RPC_LOC_GNSS_INFO_VALID_HOR_DOP           0x00000002
+#define RPC_LOC_GNSS_INFO_VALID_VERT_DOP          0x00000004
+#define RPC_LOC_GNSS_INFO_VALID_ALTITUDE_ASSUMED  0x00000008
+#define RPC_LOC_GNSS_INFO_VALID_SV_COUNT          0x00000010
+#define RPC_LOC_GNSS_INFO_VALID_SV_LIST           0x00000020
+
+#define RPC_LOC_NI_MAX_REQUESTOR_ID_LENGTH          200
+#define RPC_LOC_NI_SUPL_HASH_LENGTH                 8
+#define RPC_LOC_NI_SUPL_SLP_SESSION_ID_BYTE_LENGTH  4
+#define RPC_LOC_NI_MAX_CLIENT_NAME_LENGTH           64
+#define RPC_LOC_NI_MAX_EXT_CLIENT_ADDRESS           20
+#define RPC_LOC_NI_CODEWORD_LENGTH                  20
+
+#define RPC_LOC_NI_SUPL_QOP_VALID         0x01
+#define RPC_LOC_NI_SUPL_QOP_VERACC_VALID  0x02
+#define RPC_LOC_NI_SUPL_QOP_MAXAGE_VALID  0x04
+#define RPC_LOC_NI_SUPL_QOP_DELAY_VALID   0x08
+
+#define RPC_LOC_FIX_CRIT_VALID_RECURRENCE_TYPE                  0x00000001
+#define RPC_LOC_FIX_CRIT_VALID_PREFERRED_OPERATION_MODE         0x00000002
+#define RPC_LOC_FIX_CRIT_VALID_PREFERRED_ACCURACY               0x00000004
+#define RPC_LOC_FIX_CRIT_VALID_PREFERRED_RESPONSE_TIME          0x00000008
+#define RPC_LOC_FIX_CRIT_VALID_INTERMEDIATE_POS_REPORT_ENABLED  0x00000010
+#define RPC_LOC_FIX_CRIT_VALID_NOTIFY_TYPE                      0x00000020
+#define RPC_LOC_FIX_CRIT_VALID_MIN_INTERVAL                     0x00000040
+#define RPC_LOC_FIX_CRIT_VALID_MIN_DISTANCE                     0x00000080
+#define RPC_LOC_FIX_CRIT_VALID_MIN_DIST_SAMPLE_INTERVAL         0x00000100
+
+#define RPC_LOC_ASSIST_POS_VALID_TIMESTAMP_UTC                0x00000001
+#define RPC_LOC_ASSIST_POS_VALID_LATITUDE                     0x00000002
+#define RPC_LOC_ASSIST_POS_VALID_LONGITUDE                    0x00000004
+#define RPC_LOC_ASSIST_POS_VALID_ALTITUDE_WRT_ELLIPSOID       0x00000008
+#define RPC_LOC_ASSIST_POS_VALID_ALTITUDE_WRT_MEAN_SEA_LEVEL  0x00000010
+#define RPC_LOC_ASSIST_POS_VALID_HOR_UNC_CIRCULAR             0x00000020
+#define RPC_LOC_ASSIST_POS_VALID_VERT_UNC                     0x00000040
+#define RPC_LOC_ASSIST_POS_VALID_CONFIDENCE_HORIZONTAL        0x00000080
+#define RPC_LOC_ASSIST_POS_VALID_CONFIDENCE_VERTICAL          0x00000100
+
+#define RPC_LOC_ASSIST_DATA_ALL         0xFFFFFFFF
+
+#define RPC_LOC_NMEA_MASK_ALL    0xffff
+#define RPC_LOC_NMEA_MASK_GGA    0x0001
+#define RPC_LOC_NMEA_MASK_RMC    0x0002
+#define RPC_LOC_NMEA_MASK_GSV    0x0004
+#define RPC_LOC_NMEA_MASK_GSA    0x0008
+#define RPC_LOC_NMEA_MASK_VTG    0x0010
+
+/* flags for notification */
+#define  RPC_LOC_NI_CLIENT_NAME_PRESENT             0x0001
+#define  RPC_LOC_NI_CLIENT_EXTADDR_PRESENT          0x0002
+#define  RPC_LOC_NI_DEF_LOCATION_TYPE_PRESENT       0x0010
+#define  RPC_LOC_NI_REQUESTOR_ID_PRESENT            0x0020
+#define  RPC_LOC_NI_CODEWORD_PRESENT                0x0040
+#define  RPC_LOC_NI_SERVICE_TYPE_ID_PRESENT         0x0080
+#define  RPC_LOC_NI_ENCODING_TYPE_PRESENT           0x0100
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LOC_API_FIXUP_H */
diff --git a/msm8974/loc_api/libloc_api-rpc/inc-1240/loc_apicb_appinit.h b/msm8974/loc_api/libloc_api-rpc/inc-1240/loc_apicb_appinit.h
new file mode 100644
index 0000000..92d4e15
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/inc-1240/loc_apicb_appinit.h
@@ -0,0 +1,34 @@
+/* -------------------------------------------------------------------------------
+Copyright (c) 2009, QUALCOMM USA, INC.
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+         Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 
+
+         Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. 
+
+         Neither the name of the QUALCOMM USA, INC.  nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ -------------------------------------------------------------------------------
+ */ 
+
+#ifndef LOC_APICB_APPINIT_H
+#define LOC_APICB_APPINIT_H
+
+#ifdef __cplusplus 
+extern "C" 
+{ 
+#endif
+
+ /* Initialization function for callbacks */
+extern int loc_apicb_app_init(); 
+extern void loc_apicb_app_deinit(); 
+
+#ifdef __cplusplus 
+}
+#endif
+
+#endif /* LOC_APICB_APPINIT_H */
diff --git a/msm8974/loc_api/libloc_api-rpc/inc-3200/loc_api.h b/msm8974/loc_api/libloc_api-rpc/inc-3200/loc_api.h
new file mode 100644
index 0000000..8998aca
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/inc-3200/loc_api.h
@@ -0,0 +1,198 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#ifndef _LOC_API_H_RPCGEN
+#define _LOC_API_H_RPCGEN
+
+#include <rpc/rpc.h>
+
+#include <pthread.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+typedef struct {
+	u_int rpc_loc_api_api_versions_return_type_len;
+	rpc_uint32 *rpc_loc_api_api_versions_return_type_val;
+} rpc_loc_api_api_versions_return_type;
+
+typedef rpc_uint32 rpc_loc_event_cb_f_type;
+
+struct rpc_loc_open_args {
+	rpc_loc_event_mask_type event_reg_mask;
+	rpc_loc_event_cb_f_type event_callback;
+};
+typedef struct rpc_loc_open_args rpc_loc_open_args;
+
+struct rpc_loc_close_args {
+	rpc_loc_client_handle_type handle;
+};
+typedef struct rpc_loc_close_args rpc_loc_close_args;
+
+struct rpc_loc_start_fix_args {
+	rpc_loc_client_handle_type handle;
+};
+typedef struct rpc_loc_start_fix_args rpc_loc_start_fix_args;
+
+struct rpc_loc_stop_fix_args {
+	rpc_loc_client_handle_type handle;
+};
+typedef struct rpc_loc_stop_fix_args rpc_loc_stop_fix_args;
+
+struct rpc_loc_ioctl_args {
+	rpc_loc_client_handle_type handle;
+	rpc_loc_ioctl_e_type ioctl_type;
+	rpc_loc_ioctl_data_u_type *ioctl_data;
+};
+typedef struct rpc_loc_ioctl_args rpc_loc_ioctl_args;
+
+struct rpc_loc_api_api_version_s_args {
+	rpc_boolean len_not_null;
+};
+typedef struct rpc_loc_api_api_version_s_args rpc_loc_api_api_version_s_args;
+
+struct rpc_loc_api_rpc_glue_code_info_remote_rets {
+	rpc_uint32 toolvers;
+	rpc_uint32 features;
+	rpc_uint32 proghash;
+	rpc_uint32 cbproghash;
+};
+typedef struct rpc_loc_api_rpc_glue_code_info_remote_rets rpc_loc_api_rpc_glue_code_info_remote_rets;
+
+struct rpc_loc_open_rets {
+	rpc_loc_client_handle_type loc_open_result;
+};
+typedef struct rpc_loc_open_rets rpc_loc_open_rets;
+
+struct rpc_loc_close_rets {
+	rpc_int32 loc_close_result;
+};
+typedef struct rpc_loc_close_rets rpc_loc_close_rets;
+
+struct rpc_loc_start_fix_rets {
+	rpc_int32 loc_start_fix_result;
+};
+typedef struct rpc_loc_start_fix_rets rpc_loc_start_fix_rets;
+
+struct rpc_loc_stop_fix_rets {
+	rpc_int32 loc_stop_fix_result;
+};
+typedef struct rpc_loc_stop_fix_rets rpc_loc_stop_fix_rets;
+
+struct rpc_loc_ioctl_rets {
+	rpc_int32 loc_ioctl_result;
+};
+typedef struct rpc_loc_ioctl_rets rpc_loc_ioctl_rets;
+
+struct rpc_loc_api_api_versions_rets {
+	rpc_loc_api_api_versions_return_type loc_api_api_versions_result;
+	rpc_uint32 *len;
+};
+typedef struct rpc_loc_api_api_versions_rets rpc_loc_api_api_versions_rets;
+#define LOC_APIVERS 0x00010001
+
+#define LOC_APIPROG 0x3000008c
+#define LOC_APIVERS_0001 0x00010001
+
+#if defined(__STDC__) || defined(__cplusplus)
+#define rpc_loc_api_null 0
+extern  enum clnt_stat rpc_loc_api_null_0x00010001(void *, void *, CLIENT *);
+extern  bool_t rpc_loc_api_null_0x00010001_svc(void *, void *, struct svc_req *);
+#define rpc_loc_api_rpc_glue_code_info_remote 1
+extern  enum clnt_stat rpc_loc_api_rpc_glue_code_info_remote_0x00010001(void *, rpc_loc_api_rpc_glue_code_info_remote_rets *, CLIENT *);
+extern  bool_t rpc_loc_api_rpc_glue_code_info_remote_0x00010001_svc(void *, rpc_loc_api_rpc_glue_code_info_remote_rets *, struct svc_req *);
+#define rpc_loc_open 2
+extern  enum clnt_stat rpc_loc_open_0x00010001(rpc_loc_open_args *, rpc_loc_open_rets *, CLIENT *);
+extern  bool_t rpc_loc_open_0x00010001_svc(rpc_loc_open_args *, rpc_loc_open_rets *, struct svc_req *);
+#define rpc_loc_close 3
+extern  enum clnt_stat rpc_loc_close_0x00010001(rpc_loc_close_args *, rpc_loc_close_rets *, CLIENT *);
+extern  bool_t rpc_loc_close_0x00010001_svc(rpc_loc_close_args *, rpc_loc_close_rets *, struct svc_req *);
+#define rpc_loc_start_fix 4
+extern  enum clnt_stat rpc_loc_start_fix_0x00010001(rpc_loc_start_fix_args *, rpc_loc_start_fix_rets *, CLIENT *);
+extern  bool_t rpc_loc_start_fix_0x00010001_svc(rpc_loc_start_fix_args *, rpc_loc_start_fix_rets *, struct svc_req *);
+#define rpc_loc_stop_fix 5
+extern  enum clnt_stat rpc_loc_stop_fix_0x00010001(rpc_loc_stop_fix_args *, rpc_loc_stop_fix_rets *, CLIENT *);
+extern  bool_t rpc_loc_stop_fix_0x00010001_svc(rpc_loc_stop_fix_args *, rpc_loc_stop_fix_rets *, struct svc_req *);
+#define rpc_loc_ioctl 6
+extern  enum clnt_stat rpc_loc_ioctl_0x00010001(rpc_loc_ioctl_args *, rpc_loc_ioctl_rets *, CLIENT *);
+extern  bool_t rpc_loc_ioctl_0x00010001_svc(rpc_loc_ioctl_args *, rpc_loc_ioctl_rets *, struct svc_req *);
+#define rpc_loc_api_api_versions 0xFFFFFFFF
+extern  enum clnt_stat rpc_loc_api_api_versions_0x00010001(void *, rpc_loc_api_api_versions_rets *, CLIENT *);
+extern  bool_t rpc_loc_api_api_versions_0x00010001_svc(void *, rpc_loc_api_api_versions_rets *, struct svc_req *);
+extern int loc_apiprog_0x00010001_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+#define rpc_loc_api_null 0
+extern  enum clnt_stat rpc_loc_api_null_0x00010001();
+extern  bool_t rpc_loc_api_null_0x00010001_svc();
+#define rpc_loc_api_rpc_glue_code_info_remote 1
+extern  enum clnt_stat rpc_loc_api_rpc_glue_code_info_remote_0x00010001();
+extern  bool_t rpc_loc_api_rpc_glue_code_info_remote_0x00010001_svc();
+#define rpc_loc_open 2
+extern  enum clnt_stat rpc_loc_open_0x00010001();
+extern  bool_t rpc_loc_open_0x00010001_svc();
+#define rpc_loc_close 3
+extern  enum clnt_stat rpc_loc_close_0x00010001();
+extern  bool_t rpc_loc_close_0x00010001_svc();
+#define rpc_loc_start_fix 4
+extern  enum clnt_stat rpc_loc_start_fix_0x00010001();
+extern  bool_t rpc_loc_start_fix_0x00010001_svc();
+#define rpc_loc_stop_fix 5
+extern  enum clnt_stat rpc_loc_stop_fix_0x00010001();
+extern  bool_t rpc_loc_stop_fix_0x00010001_svc();
+#define rpc_loc_ioctl 6
+extern  enum clnt_stat rpc_loc_ioctl_0x00010001();
+extern  bool_t rpc_loc_ioctl_0x00010001_svc();
+#define rpc_loc_api_api_versions 0xFFFFFFFF
+extern  enum clnt_stat rpc_loc_api_api_versions_0x00010001();
+extern  bool_t rpc_loc_api_api_versions_0x00010001_svc();
+extern int loc_apiprog_0x00010001_freeresult ();
+#endif /* K&R C */
+
+/* the xdr functions */
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  bool_t xdr_rpc_loc_api_api_versions_return_type (XDR *, rpc_loc_api_api_versions_return_type*);
+extern  bool_t xdr_rpc_loc_event_cb_f_type (XDR *, rpc_loc_event_cb_f_type*);
+extern  bool_t xdr_rpc_loc_open_args (XDR *, rpc_loc_open_args*);
+extern  bool_t xdr_rpc_loc_close_args (XDR *, rpc_loc_close_args*);
+extern  bool_t xdr_rpc_loc_start_fix_args (XDR *, rpc_loc_start_fix_args*);
+extern  bool_t xdr_rpc_loc_stop_fix_args (XDR *, rpc_loc_stop_fix_args*);
+extern  bool_t xdr_rpc_loc_ioctl_args (XDR *, rpc_loc_ioctl_args*);
+extern  bool_t xdr_rpc_loc_api_api_version_s_args (XDR *, rpc_loc_api_api_version_s_args*);
+extern  bool_t xdr_rpc_loc_api_rpc_glue_code_info_remote_rets (XDR *, rpc_loc_api_rpc_glue_code_info_remote_rets*);
+extern  bool_t xdr_rpc_loc_open_rets (XDR *, rpc_loc_open_rets*);
+extern  bool_t xdr_rpc_loc_close_rets (XDR *, rpc_loc_close_rets*);
+extern  bool_t xdr_rpc_loc_start_fix_rets (XDR *, rpc_loc_start_fix_rets*);
+extern  bool_t xdr_rpc_loc_stop_fix_rets (XDR *, rpc_loc_stop_fix_rets*);
+extern  bool_t xdr_rpc_loc_ioctl_rets (XDR *, rpc_loc_ioctl_rets*);
+extern  bool_t xdr_rpc_loc_api_api_versions_rets (XDR *, rpc_loc_api_api_versions_rets*);
+
+#else /* K&R C */
+extern bool_t xdr_rpc_loc_api_api_versions_return_type ();
+extern bool_t xdr_rpc_loc_event_cb_f_type ();
+extern bool_t xdr_rpc_loc_open_args ();
+extern bool_t xdr_rpc_loc_close_args ();
+extern bool_t xdr_rpc_loc_start_fix_args ();
+extern bool_t xdr_rpc_loc_stop_fix_args ();
+extern bool_t xdr_rpc_loc_ioctl_args ();
+extern bool_t xdr_rpc_loc_api_api_version_s_args ();
+extern bool_t xdr_rpc_loc_api_rpc_glue_code_info_remote_rets ();
+extern bool_t xdr_rpc_loc_open_rets ();
+extern bool_t xdr_rpc_loc_close_rets ();
+extern bool_t xdr_rpc_loc_start_fix_rets ();
+extern bool_t xdr_rpc_loc_stop_fix_rets ();
+extern bool_t xdr_rpc_loc_ioctl_rets ();
+extern bool_t xdr_rpc_loc_api_api_versions_rets ();
+
+#endif /* K&R C */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_LOC_API_H_RPCGEN */
diff --git a/msm8974/loc_api/libloc_api-rpc/inc-3200/loc_api_cb.h b/msm8974/loc_api/libloc_api-rpc/inc-3200/loc_api_cb.h
new file mode 100644
index 0000000..4f2f8f9
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/inc-3200/loc_api_cb.h
@@ -0,0 +1,64 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#ifndef _LOC_API_CB_H_RPCGEN
+#define _LOC_API_CB_H_RPCGEN
+
+#include <rpc/rpc.h>
+
+#include <pthread.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+struct rpc_loc_event_cb_f_type_args {
+	rpc_uint32 cb_id;
+	rpc_loc_client_handle_type loc_handle;
+	rpc_loc_event_mask_type loc_event;
+	rpc_loc_event_payload_u_type *loc_event_payload;
+};
+typedef struct rpc_loc_event_cb_f_type_args rpc_loc_event_cb_f_type_args;
+
+struct rpc_loc_event_cb_f_type_rets {
+	rpc_int32 loc_event_cb_f_type_result;
+};
+typedef struct rpc_loc_event_cb_f_type_rets rpc_loc_event_cb_f_type_rets;
+#define LOC_APICBVERS 0x00010001
+
+#define LOC_APICBPROG 0x3100008c
+#define LOC_APICBVERS_0001 0x00010001
+
+#if defined(__STDC__) || defined(__cplusplus)
+#define rpc_loc_event_cb_f_type 1
+extern  enum clnt_stat rpc_loc_event_cb_f_type_0x00010001(rpc_loc_event_cb_f_type_args *, rpc_loc_event_cb_f_type_rets *, CLIENT *);
+extern  bool_t rpc_loc_event_cb_f_type_0x00010001_svc(rpc_loc_event_cb_f_type_args *, rpc_loc_event_cb_f_type_rets *, struct svc_req *);
+extern int loc_apicbprog_0x00010001_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
+
+#else /* K&R C */
+#define rpc_loc_event_cb_f_type 1
+extern  enum clnt_stat rpc_loc_event_cb_f_type_0x00010001();
+extern  bool_t rpc_loc_event_cb_f_type_0x00010001_svc();
+extern int loc_apicbprog_0x00010001_freeresult ();
+#endif /* K&R C */
+
+/* the xdr functions */
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  bool_t xdr_rpc_loc_event_cb_f_type_args (XDR *, rpc_loc_event_cb_f_type_args*);
+extern  bool_t xdr_rpc_loc_event_cb_f_type_rets (XDR *, rpc_loc_event_cb_f_type_rets*);
+
+#else /* K&R C */
+extern bool_t xdr_rpc_loc_event_cb_f_type_args ();
+extern bool_t xdr_rpc_loc_event_cb_f_type_rets ();
+
+#endif /* K&R C */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_LOC_API_CB_H_RPCGEN */
diff --git a/msm8974/loc_api/libloc_api-rpc/inc-3200/loc_api_common.h b/msm8974/loc_api/libloc_api-rpc/inc-3200/loc_api_common.h
new file mode 100644
index 0000000..04be079
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/inc-3200/loc_api_common.h
@@ -0,0 +1,1031 @@
+/*
+ * Please do not edit this file.
+ * It was generated using rpcgen.
+ */
+
+#ifndef _LOC_API_COMMON_H_RPCGEN
+#define _LOC_API_COMMON_H_RPCGEN
+
+#include <rpc/rpc.h>
+#include "loc_api_fixup.h"
+
+#include <pthread.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define RPC_LOC_EVENT_NI_NOTIFY_VERIFY_REQUEST 0x00000010
+#define RPC_LOC_EVENT_IOCTL_REPORT 0x00000080
+#define RPC_LOC_EVENT_LOCATION_SERVER_REQUEST 0x00000040
+#define RPC_LOC_EVENT_RESERVED 0x8000000000000000
+#define RPC_LOC_EVENT_PARSED_POSITION_REPORT 0x00000001
+#define RPC_LOC_EVENT_ASSISTANCE_DATA_REQUEST 0x00000020
+#define RPC_LOC_EVENT_NMEA_POSITION_REPORT 0x00000008
+#define RPC_LOC_EVENT_SATELLITE_REPORT 0x00000002
+#define RPC_LOC_EVENT_STATUS_REPORT 0x00000100
+#define RPC_LOC_OPEN_VERSION 0x00010001
+#define RPC_LOC_CLOSE_VERSION 0x00010001
+#define RPC_LOC_START_FIX_VERSION 0x00010001
+#define RPC_LOC_STOP_FIX_VERSION 0x00010001
+#define RPC_LOC_IOCTL_VERSION 0x00010001
+#define RPC_LOC_EVENT_CB_F_TYPE_VERSION 0x00010001
+#define RPC_LOC_APIAPI_VERSION_IS_HASHKEY 0
+#define RPC_LOC_API_API_MAJOR_NUM 0x0001
+
+typedef bool_t rpc_boolean;
+
+typedef u_long rpc_uint32;
+
+typedef u_short rpc_uint16;
+
+typedef u_char rpc_uint8;
+
+typedef long rpc_int32;
+
+typedef u_char rpc_byte;
+
+typedef u_quad_t rpc_uint64;
+
+typedef rpc_int32 rpc_loc_client_handle_type;
+
+typedef rpc_uint64 rpc_loc_event_mask_type;
+
+typedef rpc_uint64 rpc_loc_position_valid_mask_type;
+
+typedef rpc_uint32 rpc_loc_pos_technology_mask_type;
+
+enum rpc_loc_session_status_e_type {
+	RPC_LOC_SESS_STATUS_SUCCESS = 0,
+	RPC_LOC_SESS_STATUS_IN_PROGESS = 1,
+	RPC_LOC_SESS_STATUS_GENERAL_FAILURE = 2,
+	RPC_LOC_SESS_STATUS_TIMEOUT = 3,
+	RPC_LOC_SESS_STATUS_USER_END = 4,
+	RPC_LOC_SESS_STATUS_BAD_PARAMETER = 5,
+	RPC_LOC_SESS_STATUS_PHONE_OFFLINE = 6,
+	RPC_LOC_SESS_STATUS_ENGINE_LOCKED = 7,
+	RPC_LOC_SESS_STATUS_MAX = 268435456,
+};
+typedef enum rpc_loc_session_status_e_type rpc_loc_session_status_e_type;
+
+struct rpc_loc_calendar_time_s_type {
+	rpc_uint16 year;
+	u_char month;
+	u_char day_of_week;
+	u_char day;
+	u_char hour;
+	u_char minute;
+	u_char second;
+	rpc_uint16 millisecond;
+};
+typedef struct rpc_loc_calendar_time_s_type rpc_loc_calendar_time_s_type;
+
+struct rpc_loc_parsed_position_s_type {
+	rpc_loc_position_valid_mask_type valid_mask;
+	rpc_loc_session_status_e_type session_status;
+	rpc_loc_calendar_time_s_type timestamp_calendar;
+	rpc_uint64 timestamp_utc;
+	rpc_uint8 leap_seconds;
+	float time_unc;
+	double latitude;
+	double longitude;
+	float altitude_wrt_ellipsoid;
+	float altitude_wrt_mean_sea_level;
+	float speed_horizontal;
+	float speed_vertical;
+	float heading;
+	float hor_unc_circular;
+	float hor_unc_ellipse_semi_major;
+	float hor_unc_ellipse_semi_minor;
+	float hor_unc_ellipse_orient_azimuth;
+	float vert_unc;
+	float speed_unc;
+	float heading_unc;
+	u_char confidence_horizontal;
+	u_char confidence_vertical;
+	float magnetic_deviation;
+	rpc_loc_pos_technology_mask_type technology_mask;
+};
+typedef struct rpc_loc_parsed_position_s_type rpc_loc_parsed_position_s_type;
+
+enum rpc_loc_sv_system_e_type {
+	RPC_LOC_SV_SYSTEM_GPS = 1,
+	RPC_LOC_SV_SYSTEM_GALILEO = 2,
+	RPC_LOC_SV_SYSTEM_SBAS = 3,
+	RPC_LOC_SV_SYSTEM_COMPASS = 4,
+	RPC_LOC_SV_SYSTEM_GLONASS = 5,
+	RPC_LOC_SV_SYSTEM_MAX = 268435456,
+};
+typedef enum rpc_loc_sv_system_e_type rpc_loc_sv_system_e_type;
+
+enum rpc_loc_sv_status_e_type {
+	RPC_LOC_SV_STATUS_IDLE = 1,
+	RPC_LOC_SV_STATUS_SEARCH = 2,
+	RPC_LOC_SV_STATUS_TRACK = 3,
+	RPC_LOC_SV_STATUS_MAX = 268435456,
+};
+typedef enum rpc_loc_sv_status_e_type rpc_loc_sv_status_e_type;
+
+typedef rpc_uint32 rpc_loc_sv_info_valid_mask_type;
+
+struct rpc_loc_sv_info_s_type {
+	rpc_loc_sv_info_valid_mask_type valid_mask;
+	rpc_loc_sv_system_e_type system;
+	rpc_uint8 prn;
+	rpc_uint8 health_status;
+	rpc_loc_sv_status_e_type process_status;
+	rpc_boolean has_eph;
+	rpc_boolean has_alm;
+	float elevation;
+	float azimuth;
+	float snr;
+};
+typedef struct rpc_loc_sv_info_s_type rpc_loc_sv_info_s_type;
+
+typedef rpc_uint32 rpc_loc_gnss_info_valid_mask_type;
+
+struct rpc_loc_gnss_info_s_type {
+	rpc_loc_gnss_info_valid_mask_type valid_mask;
+	float position_dop;
+	float horizontal_dop;
+	float vertical_dop;
+	rpc_boolean altitude_assumed;
+	rpc_uint16 sv_count;
+	struct {
+		u_int sv_list_len;
+		rpc_loc_sv_info_s_type *sv_list_val;
+	} sv_list;
+};
+typedef struct rpc_loc_gnss_info_s_type rpc_loc_gnss_info_s_type;
+
+struct rpc_loc_nmea_report_s_type {
+	rpc_uint16 length;
+	struct {
+		u_int nmea_sentences_len;
+		char *nmea_sentences_val;
+	} nmea_sentences;
+};
+typedef struct rpc_loc_nmea_report_s_type rpc_loc_nmea_report_s_type;
+
+enum rpc_loc_status_event_e_type {
+	RPC_LOC_STATUS_EVENT_ENGINE_STATE = 1,
+	RPC_LOC_STATUS_EVENT_MAX = 268435456,
+};
+typedef enum rpc_loc_status_event_e_type rpc_loc_status_event_e_type;
+
+enum rpc_loc_engine_state_e_type {
+	RPC_LOC_ENGINE_STATE_ON = 1,
+	RPC_LOC_ENGINE_STATE_OFF = 2,
+	RPC_LOC_ENGINE_STATE_MAX = 268435456,
+};
+typedef enum rpc_loc_engine_state_e_type rpc_loc_engine_state_e_type;
+
+struct rpc_loc_status_event_payload_u_type {
+	rpc_loc_status_event_e_type disc;
+	union {
+		rpc_loc_engine_state_e_type engine_state;
+	} rpc_loc_status_event_payload_u_type_u;
+};
+typedef struct rpc_loc_status_event_payload_u_type rpc_loc_status_event_payload_u_type;
+
+struct rpc_loc_status_event_s_type {
+	rpc_loc_status_event_e_type event;
+	rpc_loc_status_event_payload_u_type payload;
+};
+typedef struct rpc_loc_status_event_s_type rpc_loc_status_event_s_type;
+
+enum rpc_loc_server_addr_e_type {
+	RPC_LOC_SERVER_ADDR_IPV4 = 1,
+	RPC_LOC_SERVER_ADDR_URL = 2,
+	RPC_LOC_SERVER_ADDR_MAX = 268435456,
+};
+typedef enum rpc_loc_server_addr_e_type rpc_loc_server_addr_e_type;
+
+struct rpc_loc_server_addr_ipv4_type {
+	rpc_uint32 addr;
+	rpc_uint16 port;
+};
+typedef struct rpc_loc_server_addr_ipv4_type rpc_loc_server_addr_ipv4_type;
+
+struct rpc_loc_server_addr_url_type {
+	rpc_uint16 length;
+	struct {
+		u_int addr_len;
+		char *addr_val;
+	} addr;
+};
+typedef struct rpc_loc_server_addr_url_type rpc_loc_server_addr_url_type;
+
+struct rpc_loc_server_addr_u_type {
+	rpc_loc_server_addr_e_type disc;
+	union {
+		rpc_loc_server_addr_ipv4_type ipv4;
+		rpc_loc_server_addr_url_type url;
+	} rpc_loc_server_addr_u_type_u;
+};
+typedef struct rpc_loc_server_addr_u_type rpc_loc_server_addr_u_type;
+
+struct rpc_loc_server_info_s_type {
+	rpc_loc_server_addr_e_type addr_type;
+	rpc_loc_server_addr_u_type addr_info;
+};
+typedef struct rpc_loc_server_info_s_type rpc_loc_server_info_s_type;
+
+enum rpc_loc_ni_notify_verify_e_type {
+	RPC_LOC_NI_USER_NO_NOTIFY_NO_VERIFY = 1,
+	RPC_LOC_NI_USER_NOTIFY_ONLY = 2,
+	RPC_LOC_NI_USER_NOTIFY_VERIFY_ALLOW_NO_RESP = 3,
+	RPC_LOC_NI_USER_NOTIFY_VERIFY_NOT_ALLOW_NO_RESP = 4,
+	RPC_LOC_NI_USER_PRIVACY_OVERRIDE = 5,
+	RPC_LOC_NI_USER_NOTIFY_VERITY_TYPE_MAX = 268435456,
+};
+typedef enum rpc_loc_ni_notify_verify_e_type rpc_loc_ni_notify_verify_e_type;
+
+enum rpc_loc_ni_event_e_type {
+	RPC_LOC_NI_EVENT_VX_NOTIFY_VERIFY_REQ = 1,
+	RPC_LOC_NI_EVENT_SUPL_NOTIFY_VERIFY_REQ = 2,
+	RPC_LOC_NI_EVENT_UMTS_CP_NOTIFY_VERIFY_REQ = 3,
+	RPC_LOC_NI_EVENT_MAX = 268435456,
+};
+typedef enum rpc_loc_ni_event_e_type rpc_loc_ni_event_e_type;
+
+enum rpc_loc_ni_datacoding_scheme_e_type {
+	RPC_LOC_NI_PRESUPL_ISO646IRV = 0,
+	RPC_LOC_NI_PRESUPL_ISO8859 = 1,
+	RPC_LOC_NI_PRESUPL_UTF8 = 2,
+	RPC_LOC_NI_PRESUPL_UTF16 = 3,
+	RPC_LOC_NI_PRESUPL_UCS2 = 4,
+	RPC_LOC_NI_PRESUPL_GSM_DEFAULT = 5,
+	RPC_LOC_NI_PRESUPL_SHIFT_JIS = 6,
+	RPC_LOC_NI_PRESUPL_JIS = 7,
+	RPC_LOC_NI_PRESUPL_EUC = 8,
+	RPC_LOC_NI_PRESUPL_GB2312 = 9,
+	RPC_LOC_NI_PRESUPL_CNS11643 = 10,
+	RPC_LOC_NI_PRESUPL_KSC1001 = 11,
+	RPC_LOC_NI_PRESUPL_ENCODING_UNKNOWN = 2147483647,
+	RPC_LOC_NI_SS_GERMAN = 12,
+	RPC_LOC_NI_SS_ENGLISH = 13,
+	RPC_LOC_NI_SS_ITALIAN = 14,
+	RPC_LOC_NI_SS_FRENCH = 15,
+	RPC_LOC_NI_SS_SPANISH = 16,
+	RPC_LOC_NI_SS_DUTCH = 17,
+	RPC_LOC_NI_SS_SWEDISH = 18,
+	RPC_LOC_NI_SS_DANISH = 19,
+	RPC_LOC_NI_SS_PORTUGUESE = 20,
+	RPC_LOC_NI_SS_FINNISH = 21,
+	RPC_LOC_NI_SS_NORWEGIAN = 22,
+	RPC_LOC_NI_SS_GREEK = 23,
+	RPC_LOC_NI_SS_TURKISH = 24,
+	RPC_LOC_NI_SS_HUNGARIAN = 25,
+	RPC_LOC_NI_SS_POLISH = 26,
+	RPC_LOC_NI_SS_LANGUAGE_UNSPEC = 27,
+	RPC_LOC_NI_SUPL_UTF8 = 28,
+	RPC_LOC_NI_SUPL_UCS2 = 29,
+	RPC_LOC_NI_SUPL_GSM_DEFAULT = 30,
+	RPC_LOC_NI_SUPL_ENCODING_UNKNOWN = 2147483647,
+};
+typedef enum rpc_loc_ni_datacoding_scheme_e_type rpc_loc_ni_datacoding_scheme_e_type;
+
+enum rpc_loc_ni_vx_requester_id_encoding_scheme_e_type {
+	RPC_LOC_NI_VX_OCTET = 0,
+	RPC_LOC_NI_VX_EXN_PROTOCOL_MSG = 1,
+	RPC_LOC_NI_VX_ASCII = 2,
+	RPC_LOC_NI_VX_IA5 = 3,
+	RPC_LOC_NI_VX_UNICODE = 4,
+	RPC_LOC_NI_VX_SHIFT_JIS = 5,
+	RPC_LOC_NI_VX_KOREAN = 6,
+	RPC_LOC_NI_VX_LATIN_HEBREW = 7,
+	RPC_LOC_NI_VX_LATIN = 8,
+	RPC_LOC_NI_VX_GSM = 9,
+	RPC_LOC_NI_VX_ENCODING_TYPE_MAX = 268435456,
+};
+typedef enum rpc_loc_ni_vx_requester_id_encoding_scheme_e_type rpc_loc_ni_vx_requester_id_encoding_scheme_e_type;
+
+enum rpc_loc_ni_vx_pos_mode_e_type {
+	RPC_LOC_VX_MS_ASSISTED_ONLY = 1,
+	RPC_LOC_VX_MS_BASED_ONLY = 2,
+	RPC_LOC_VX_MS_ASSISTED_PREF_MSBASED_ALLWD = 3,
+	RPC_LOC_VX_MS_BASED_PREF_ASSISTED_ALLWD = 4,
+	RPC_LOC_VX_POS_MODE_MAX = 268435456,
+};
+typedef enum rpc_loc_ni_vx_pos_mode_e_type rpc_loc_ni_vx_pos_mode_e_type;
+
+struct rpc_loc_ni_vx_requester_id_s_type {
+	u_char requester_id_length;
+	char requester_id[200];
+};
+typedef struct rpc_loc_ni_vx_requester_id_s_type rpc_loc_ni_vx_requester_id_s_type;
+
+struct rpc_loc_ni_vx_notify_verify_req_s_type {
+	rpc_loc_ni_notify_verify_e_type notification_priv_type;
+	u_char pos_qos_incl;
+	u_char pos_qos;
+	rpc_uint32 num_fixes;
+	rpc_uint32 tbf;
+	rpc_loc_ni_vx_pos_mode_e_type pos_mode;
+	rpc_loc_ni_vx_requester_id_encoding_scheme_e_type encoding_scheme;
+	rpc_loc_ni_vx_requester_id_s_type requester_id;
+	rpc_uint16 user_resp_timer_val;
+};
+typedef struct rpc_loc_ni_vx_notify_verify_req_s_type rpc_loc_ni_vx_notify_verify_req_s_type;
+
+enum rpc_loc_ni_supl_pos_method_e_type {
+	RPC_LOC_NI_POSMETHOD_AGPS_SETASSISTED = 1,
+	RPC_LOC_NI_POSMETHOD_AGPS_SETBASED = 2,
+	RPC_LOC_NI_POSMETHOD_AGPS_SETASSISTED_PREF = 3,
+	RPC_LOC_NI_POSMETHOD_AGPS_SETBASED_PREF = 4,
+	RPC_LOC_NI_POSMETHOD_AUTONOMOUS_GPS = 5,
+	RPC_LOC_NI_POSMETHOD_AFLT = 6,
+	RPC_LOC_NI_POSMETHOD_ECID = 7,
+	RPC_LOC_NI_POSMETHOD_EOTD = 8,
+	RPC_LOC_NI_POSMETHOD_OTDOA = 9,
+	RPC_LOC_NI_POSMETHOD_NO_POSITION = 10,
+	RPC_LOC_NI_POSMETHOD_MAX = 268435456,
+};
+typedef enum rpc_loc_ni_supl_pos_method_e_type rpc_loc_ni_supl_pos_method_e_type;
+
+struct rpc_loc_ni_supl_slp_session_id_s_type {
+	u_char presence;
+	char session_id[4];
+	rpc_loc_server_info_s_type slp_address;
+};
+typedef struct rpc_loc_ni_supl_slp_session_id_s_type rpc_loc_ni_supl_slp_session_id_s_type;
+
+struct rpc_loc_ni_requestor_id_s_type {
+	u_char data_coding_scheme;
+	struct {
+		u_int requestor_id_string_len;
+		char *requestor_id_string_val;
+	} requestor_id_string;
+	u_char string_len;
+};
+typedef struct rpc_loc_ni_requestor_id_s_type rpc_loc_ni_requestor_id_s_type;
+
+struct rpc_loc_ni_supl_client_name_s_type {
+	u_char data_coding_scheme;
+	struct {
+		u_int client_name_string_len;
+		char *client_name_string_val;
+	} client_name_string;
+	u_char string_len;
+};
+typedef struct rpc_loc_ni_supl_client_name_s_type rpc_loc_ni_supl_client_name_s_type;
+
+struct rpc_loc_ni_supl_qop_s_type {
+	u_char bit_mask;
+	u_char horacc;
+	u_char veracc;
+	u_char maxLocAge;
+	u_char delay;
+};
+typedef struct rpc_loc_ni_supl_qop_s_type rpc_loc_ni_supl_qop_s_type;
+
+struct rpc_loc_ni_supl_notify_verify_req_s_type {
+	rpc_loc_ni_notify_verify_e_type notification_priv_type;
+	rpc_uint16 flags;
+	rpc_loc_ni_supl_slp_session_id_s_type supl_slp_session_id;
+	char supl_hash[8];
+	rpc_loc_ni_datacoding_scheme_e_type datacoding_scheme;
+	rpc_loc_ni_supl_pos_method_e_type pos_method;
+	rpc_loc_ni_requestor_id_s_type requestor_id;
+	rpc_loc_ni_supl_client_name_s_type client_name;
+	rpc_loc_ni_supl_qop_s_type supl_qop;
+	rpc_uint16 user_response_timer;
+};
+typedef struct rpc_loc_ni_supl_notify_verify_req_s_type rpc_loc_ni_supl_notify_verify_req_s_type;
+
+struct rpc_loc_ni_ext_client_address_s_type {
+	u_char ext_client_address_len;
+	struct {
+		u_int ext_client_address_len;
+		char *ext_client_address_val;
+	} ext_client_address;
+};
+typedef struct rpc_loc_ni_ext_client_address_s_type rpc_loc_ni_ext_client_address_s_type;
+
+enum rpc_loc_ni_location_type_e_type {
+	RPC_LOC_NI_LOCATIONTYPE_CURRENT_LOCATION = 1,
+	RPC_LOC_NI_LOCATIONTYPE_CURRENT_OR_LAST_KNOWN_LOCATION = 2,
+	RPC_LOC_NI_LOCATIONTYPE_INITIAL_LOCATION = 3,
+	RPC_LOC_NI_LOCATIONTYPE_MAX = 268435456,
+};
+typedef enum rpc_loc_ni_location_type_e_type rpc_loc_ni_location_type_e_type;
+
+struct rpc_loc_ni_deferred_location_s_type {
+	u_char unused_bits;
+	u_char ms_available;
+};
+typedef struct rpc_loc_ni_deferred_location_s_type rpc_loc_ni_deferred_location_s_type;
+
+struct rpc_loc_ni_codeword_string_s_type {
+	u_char data_coding_scheme;
+	struct {
+		u_int lcs_codeword_string_len;
+		char *lcs_codeword_string_val;
+	} lcs_codeword_string;
+	u_char string_len;
+};
+typedef struct rpc_loc_ni_codeword_string_s_type rpc_loc_ni_codeword_string_s_type;
+
+struct rpc_loc_ni_service_type_id_s_type {
+	u_char lcs_service_type_id;
+};
+typedef struct rpc_loc_ni_service_type_id_s_type rpc_loc_ni_service_type_id_s_type;
+
+struct rpc_loc_ni_umts_cp_notify_verify_req_s_type {
+	rpc_loc_ni_notify_verify_e_type notification_priv_type;
+	u_char invoke_id;
+	rpc_uint16 flags;
+	u_char notification_length;
+	struct {
+		u_int notification_text_len;
+		char *notification_text_val;
+	} notification_text;
+	rpc_loc_ni_datacoding_scheme_e_type datacoding_scheme;
+	rpc_loc_ni_ext_client_address_s_type ext_client_address_data;
+	rpc_loc_ni_location_type_e_type location_type;
+	rpc_loc_ni_deferred_location_s_type deferred_location;
+	rpc_loc_ni_requestor_id_s_type requestor_id;
+	rpc_loc_ni_codeword_string_s_type codeword_string;
+	rpc_loc_ni_service_type_id_s_type service_type_id;
+	rpc_uint16 user_response_timer;
+};
+typedef struct rpc_loc_ni_umts_cp_notify_verify_req_s_type rpc_loc_ni_umts_cp_notify_verify_req_s_type;
+
+struct rpc_loc_ni_event_payload_u_type {
+	rpc_loc_ni_event_e_type disc;
+	union {
+		rpc_loc_ni_vx_notify_verify_req_s_type vx_req;
+		rpc_loc_ni_supl_notify_verify_req_s_type supl_req;
+		rpc_loc_ni_umts_cp_notify_verify_req_s_type umts_cp_req;
+	} rpc_loc_ni_event_payload_u_type_u;
+};
+typedef struct rpc_loc_ni_event_payload_u_type rpc_loc_ni_event_payload_u_type;
+
+struct rpc_loc_ni_event_s_type {
+	rpc_loc_ni_event_e_type event;
+	rpc_loc_ni_event_payload_u_type payload;
+};
+typedef struct rpc_loc_ni_event_s_type rpc_loc_ni_event_s_type;
+
+enum rpc_loc_assist_data_request_e_type {
+	RPC_LOC_ASSIST_DATA_TIME_REQ = 1,
+	RPC_LOC_ASSIST_DATA_PREDICTED_ORBITS_REQ = 2,
+	RPC_LOC_ASSIST_DATA_MAX = 268435456,
+};
+typedef enum rpc_loc_assist_data_request_e_type rpc_loc_assist_data_request_e_type;
+
+typedef char *rpc_struct_loc_time_download_source_s_type_servers_ptr;
+
+typedef rpc_struct_loc_time_download_source_s_type_servers_ptr rpc_struct_loc_time_download_source_s_type_servers[3];
+
+struct rpc_loc_time_download_source_s_type {
+	rpc_uint32 delay_threshold;
+	rpc_struct_loc_time_download_source_s_type_servers servers;
+};
+typedef struct rpc_loc_time_download_source_s_type rpc_loc_time_download_source_s_type;
+
+typedef char *rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr;
+
+typedef rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr rpc_struct_loc_predicted_orbits_data_source_s_type_servers[3];
+
+struct rpc_loc_predicted_orbits_data_source_s_type {
+	rpc_uint32 max_file_size;
+	rpc_uint32 max_part_size;
+	rpc_struct_loc_predicted_orbits_data_source_s_type_servers servers;
+};
+typedef struct rpc_loc_predicted_orbits_data_source_s_type rpc_loc_predicted_orbits_data_source_s_type;
+
+struct rpc_loc_assist_data_request_payload_u_type {
+	rpc_loc_assist_data_request_e_type disc;
+	union {
+		rpc_loc_time_download_source_s_type time_download;
+		rpc_loc_predicted_orbits_data_source_s_type data_download;
+	} rpc_loc_assist_data_request_payload_u_type_u;
+};
+typedef struct rpc_loc_assist_data_request_payload_u_type rpc_loc_assist_data_request_payload_u_type;
+
+struct rpc_loc_assist_data_request_s_type {
+	rpc_loc_assist_data_request_e_type event;
+	rpc_loc_assist_data_request_payload_u_type payload;
+};
+typedef struct rpc_loc_assist_data_request_s_type rpc_loc_assist_data_request_s_type;
+
+typedef rpc_uint32 rpc_loc_server_connection_handle;
+
+enum rpc_loc_server_protocol_e_type {
+	RPC_LOC_SERVER_PROTOCOL_DEFAULT = 0,
+	RPC_LOC_SERVER_PROTOCOL_SUPL = 1,
+	RPC_LOC_SERVER_PROTOCOL_VX_MPC = 2,
+	RPC_LOC_SERVER_PROTOCOL_VX_PDE = 3,
+	RPC_LOC_SERVER_PROTOCOL_MAX = 16777216,
+};
+typedef enum rpc_loc_server_protocol_e_type rpc_loc_server_protocol_e_type;
+
+enum rpc_loc_server_request_e_type {
+	RPC_LOC_SERVER_REQUEST_OPEN = 1,
+	RPC_LOC_SERVER_REQUEST_CLOSE = 2,
+	RPC_LOC_SERVER_REQUEST_MAX = 268435456,
+};
+typedef enum rpc_loc_server_request_e_type rpc_loc_server_request_e_type;
+
+struct rpc_loc_server_open_req_s_type {
+	rpc_loc_server_connection_handle conn_handle;
+	rpc_loc_server_protocol_e_type protocol;
+};
+typedef struct rpc_loc_server_open_req_s_type rpc_loc_server_open_req_s_type;
+
+struct rpc_loc_server_close_req_s_type {
+	rpc_loc_server_connection_handle conn_handle;
+};
+typedef struct rpc_loc_server_close_req_s_type rpc_loc_server_close_req_s_type;
+
+struct rpc_loc_server_request_u_type {
+	rpc_loc_server_request_e_type disc;
+	union {
+		rpc_loc_server_open_req_s_type open_req;
+		rpc_loc_server_close_req_s_type close_req;
+	} rpc_loc_server_request_u_type_u;
+};
+typedef struct rpc_loc_server_request_u_type rpc_loc_server_request_u_type;
+
+struct rpc_loc_server_request_s_type {
+	rpc_loc_server_request_e_type event;
+	rpc_loc_server_request_u_type payload;
+};
+typedef struct rpc_loc_server_request_s_type rpc_loc_server_request_s_type;
+
+struct rpc_loc_reserved_payload_s_type {
+	rpc_uint16 data_size;
+	struct {
+		u_int data_len;
+		char *data_val;
+	} data;
+};
+typedef struct rpc_loc_reserved_payload_s_type rpc_loc_reserved_payload_s_type;
+
+enum rpc_loc_ioctl_e_type {
+	RPC_LOC_IOCTL_GET_API_VERSION = 1,
+	RPC_LOC_IOCTL_SET_FIX_CRITERIA = 2,
+	RPC_LOC_IOCTL_GET_FIX_CRITERIA = 3,
+	RPC_LOC_IOCTL_SERVICE_START_INDEX = 400,
+	RPC_LOC_IOCTL_INFORM_NI_USER_RESPONSE = 400,
+	RPC_LOC_IOCTL_INJECT_PREDICTED_ORBITS_DATA = 401,
+	RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_VALIDITY = 402,
+	RPC_LOC_IOCTL_QUERY_PREDICTED_ORBITS_DATA_SOURCE = 403,
+	RPC_LOC_IOCTL_SET_PREDICTED_ORBITS_DATA_AUTO_DOWNLOAD = 404,
+	RPC_LOC_IOCTL_INJECT_UTC_TIME = 405,
+	RPC_LOC_IOCTL_INJECT_RTC_VALUE = 406,
+	RPC_LOC_IOCTL_INJECT_POSITION = 407,
+	RPC_LOC_IOCTL_QUERY_ENGINE_STATE = 408,
+	RPC_LOC_IOCTL_INFORM_SERVER_OPEN_STATUS = 409,
+	RPC_LOC_IOCTL_INFORM_SERVER_CLOSE_STATUS = 410,
+	RPC_LOC_IOCTL_NV_SETTINGS_START_INDEX = 800,
+	RPC_LOC_IOCTL_SET_ENGINE_LOCK = 800,
+	RPC_LOC_IOCTL_GET_ENGINE_LOCK = 801,
+	RPC_LOC_IOCTL_SET_SBAS_CONFIG = 802,
+	RPC_LOC_IOCTL_GET_SBAS_CONFIG = 803,
+	RPC_LOC_IOCTL_SET_NMEA_TYPES = 804,
+	RPC_LOC_IOCTL_GET_NMEA_TYPES = 805,
+	RPC_LOC_IOCTL_SET_CDMA_PDE_SERVER_ADDR = 806,
+	RPC_LOC_IOCTL_GET_CDMA_PDE_SERVER_ADDR = 807,
+	RPC_LOC_IOCTL_SET_CDMA_MPC_SERVER_ADDR = 808,
+	RPC_LOC_IOCTL_GET_CDMA_MPC_SERVER_ADDR = 809,
+	RPC_LOC_IOCTL_SET_UMTS_SLP_SERVER_ADDR = 810,
+	RPC_LOC_IOCTL_GET_UMTS_SLP_SERVER_ADDR = 811,
+	RPC_LOC_IOCTL_SET_ON_DEMAND_LPM = 812,
+	RPC_LOC_IOCTL_GET_ON_DEMAND_LPM = 813,
+	RPC_LOC_IOCTL_PROPRIETARY_START_INDEX = 1000,
+	RPC_LOC_IOCTL_DELETE_ASSIST_DATA = 1000,
+	RPC_LOC_IOCTL_SET_CUSTOM_PDE_SERVER_ADDR = 1001,
+	RPC_LOC_IOCTL_GET_CUSTOM_PDE_SERVER_ADDR = 1002,
+	RPC_LOC_IOCTL_THIRD_PARTY_START_INDEX = 1073741824,
+};
+typedef enum rpc_loc_ioctl_e_type rpc_loc_ioctl_e_type;
+
+struct rpc_loc_api_version_s_type {
+	u_char major;
+	u_char minor;
+};
+typedef struct rpc_loc_api_version_s_type rpc_loc_api_version_s_type;
+
+enum rpc_loc_fix_recurrence_e_type {
+	RPC_LOC_PERIODIC_FIX = 1,
+	RPC_LOC_SINGLE_FIX = 2,
+	RPC_LOC_FIX_SESSION_TYPE_MAX = 268435456,
+};
+typedef enum rpc_loc_fix_recurrence_e_type rpc_loc_fix_recurrence_e_type;
+
+enum rpc_loc_operation_mode_e_type {
+	RPC_LOC_OPER_MODE_DEFAULT = 1,
+	RPC_LOC_OPER_MODE_MSB = 2,
+	RPC_LOC_OPER_MODE_MSA = 3,
+	RPC_LOC_OPER_MODE_STANDALONE = 4,
+	RPC_LOC_OPER_MODE_SPEED_OPTIMAL = 5,
+	RPC_LOC_OPER_MODE_ACCURACY_OPTIMAL = 6,
+	RPC_LOC_OPER_MODE_DATA_OPTIMAL = 7,
+	RPC_LOC_OPER_MODE_MAX = 268435456,
+};
+typedef enum rpc_loc_operation_mode_e_type rpc_loc_operation_mode_e_type;
+
+enum rpc_loc_notify_e_type {
+	RPC_LOC_NOTIFY_ON_INTERVAL = 1,
+	RPC_LOC_NOTIFY_ON_DISTANCE = 2,
+	RPC_LOC_NOTIFY_ON_ANY = 3,
+	RPC_LOC_NOTIFY_ON_ALL = 4,
+	RPC_LOC_NOTIFY_TYPE_MAX = 268435456,
+};
+typedef enum rpc_loc_notify_e_type rpc_loc_notify_e_type;
+
+struct rpc_loc_fix_criteria_s_type {
+	rpc_uint32 valid_mask;
+	rpc_loc_fix_recurrence_e_type recurrence_type;
+	rpc_loc_operation_mode_e_type preferred_operation_mode;
+	rpc_uint32 preferred_accuracy;
+	rpc_uint32 preferred_response_time;
+	rpc_boolean intermediate_pos_report_enabled;
+	rpc_loc_notify_e_type notify_type;
+	rpc_uint32 min_interval;
+	float min_distance;
+	rpc_uint32 min_dist_sample_interval;
+};
+typedef struct rpc_loc_fix_criteria_s_type rpc_loc_fix_criteria_s_type;
+
+enum rpc_loc_ni_user_resp_e_type {
+	RPC_LOC_NI_LCS_NOTIFY_VERIFY_ACCEPT = 1,
+	RPC_LOC_NI_LCS_NOTIFY_VERIFY_DENY = 2,
+	RPC_LOC_NI_LCS_NOTIFY_VERIFY_NORESP = 3,
+	RPC_LOC_NI_LCS_NOTIFY_VERIFY_MAX = 268435456,
+};
+typedef enum rpc_loc_ni_user_resp_e_type rpc_loc_ni_user_resp_e_type;
+
+struct rpc_loc_user_verify_s_type {
+	rpc_loc_ni_user_resp_e_type user_resp;
+	rpc_loc_ni_event_s_type ni_event_pass_back;
+};
+typedef struct rpc_loc_user_verify_s_type rpc_loc_user_verify_s_type;
+
+enum rpc_loc_predicted_orbits_data_format_e_type {
+	RPC_LOC_PREDICTED_ORBITS_XTRA = 0,
+	RPC_LOC_PREDICTED_ORBITS_FORMAT_MAX = 268435456,
+};
+typedef enum rpc_loc_predicted_orbits_data_format_e_type rpc_loc_predicted_orbits_data_format_e_type;
+
+struct rpc_loc_predicted_orbits_data_s_type {
+	rpc_loc_predicted_orbits_data_format_e_type format_type;
+	rpc_uint32 total_size;
+	rpc_uint8 total_parts;
+	rpc_uint8 part;
+	rpc_uint16 part_len;
+	struct {
+		u_int data_ptr_len;
+		char *data_ptr_val;
+	} data_ptr;
+};
+typedef struct rpc_loc_predicted_orbits_data_s_type rpc_loc_predicted_orbits_data_s_type;
+
+struct rpc_loc_predicted_orbits_data_validity_report_s_type {
+	rpc_uint64 start_time_utc;
+	rpc_uint16 valid_duration_hrs;
+};
+typedef struct rpc_loc_predicted_orbits_data_validity_report_s_type rpc_loc_predicted_orbits_data_validity_report_s_type;
+
+struct rpc_loc_predicted_orbits_auto_download_config_s_type {
+	rpc_boolean enable;
+	u_char auto_check_every_hrs;
+};
+typedef struct rpc_loc_predicted_orbits_auto_download_config_s_type rpc_loc_predicted_orbits_auto_download_config_s_type;
+
+struct rpc_loc_assist_data_time_s_type {
+	rpc_uint64 time_utc;
+	rpc_uint32 uncertainty;
+};
+typedef struct rpc_loc_assist_data_time_s_type rpc_loc_assist_data_time_s_type;
+
+typedef rpc_uint64 rpc_loc_assist_pos_valid_mask_type;
+
+struct rpc_loc_assist_data_pos_s_type {
+	rpc_loc_assist_pos_valid_mask_type valid_mask;
+	rpc_uint64 timestamp_utc;
+	double latitude;
+	double longitude;
+	float altitude_wrt_ellipsoid;
+	float altitude_wrt_mean_sea_level;
+	float hor_unc_circular;
+	float vert_unc;
+	u_char confidence_horizontal;
+	u_char confidence_vertical;
+};
+typedef struct rpc_loc_assist_data_pos_s_type rpc_loc_assist_data_pos_s_type;
+
+enum rpc_loc_server_open_status_e_type {
+	RPC_LOC_SERVER_OPEN_SUCCESS = 1,
+	RPC_LOC_SERVER_OPEN_FAIL = 2,
+	RPC_LOC_SERVER_OPEN_STATUS_MAX = 268435456,
+};
+typedef enum rpc_loc_server_open_status_e_type rpc_loc_server_open_status_e_type;
+
+struct rpc_loc_server_open_status_s_type {
+	rpc_loc_server_connection_handle conn_handle;
+	rpc_loc_server_open_status_e_type open_status;
+	char *apn_name;
+};
+typedef struct rpc_loc_server_open_status_s_type rpc_loc_server_open_status_s_type;
+
+enum rpc_loc_server_close_status_e_type {
+	RPC_LOC_SERVER_CLOSE_SUCCESS = 1,
+	RPC_LOC_SERVER_CLOSE_FAIL = 2,
+	RPC_LOC_SERVER_CLOSE_STATUS_MAX = 268435456,
+};
+typedef enum rpc_loc_server_close_status_e_type rpc_loc_server_close_status_e_type;
+
+struct rpc_loc_server_close_status_s_type {
+	rpc_loc_server_connection_handle conn_handle;
+	rpc_loc_server_close_status_e_type close_status;
+};
+typedef struct rpc_loc_server_close_status_s_type rpc_loc_server_close_status_s_type;
+
+enum rpc_loc_lock_e_type {
+	RPC_LOC_LOCK_NONE = 1,
+	RPC_LOC_LOCK_MI = 2,
+	RPC_LOC_LOCK_MT = 3,
+	RPC_LOC_LOCK_ALL = 4,
+	RPC_LOC_LOCK_MAX = 268435456,
+};
+typedef enum rpc_loc_lock_e_type rpc_loc_lock_e_type;
+
+typedef rpc_uint32 rpc_loc_nmea_sentence_type;
+
+typedef rpc_uint32 rpc_loc_assist_data_type;
+
+struct rpc_loc_assist_data_delete_s_type {
+	rpc_loc_assist_data_type type;
+	rpc_uint32 reserved[8];
+};
+typedef struct rpc_loc_assist_data_delete_s_type rpc_loc_assist_data_delete_s_type;
+
+struct rpc_loc_ioctl_data_u_type {
+	rpc_loc_ioctl_e_type disc;
+	union {
+		rpc_loc_fix_criteria_s_type fix_criteria;
+		rpc_loc_user_verify_s_type user_verify_resp;
+		rpc_loc_predicted_orbits_data_s_type predicted_orbits_data;
+		rpc_loc_predicted_orbits_auto_download_config_s_type predicted_orbits_auto_download;
+		rpc_loc_assist_data_time_s_type assistance_data_time;
+		rpc_loc_assist_data_pos_s_type assistance_data_position;
+		rpc_loc_server_open_status_s_type conn_open_status;
+		rpc_loc_server_close_status_s_type conn_close_status;
+		rpc_loc_lock_e_type engine_lock;
+		rpc_boolean sbas_mode;
+		rpc_loc_nmea_sentence_type nmea_types;
+		rpc_boolean on_demand_lpm;
+		rpc_loc_server_info_s_type server_addr;
+		rpc_loc_assist_data_delete_s_type assist_data_delete;
+	} rpc_loc_ioctl_data_u_type_u;
+};
+typedef struct rpc_loc_ioctl_data_u_type rpc_loc_ioctl_data_u_type;
+
+struct rpc_loc_ioctl_callback_data_u_type {
+	rpc_loc_ioctl_e_type disc;
+	union {
+		rpc_loc_api_version_s_type api_version;
+		rpc_loc_fix_criteria_s_type fix_criteria;
+		rpc_loc_lock_e_type engine_lock;
+		rpc_boolean sbas_mode;
+		rpc_loc_nmea_sentence_type nmea_types;
+		rpc_boolean on_demand_lpm;
+		rpc_loc_server_info_s_type server_addr;
+		rpc_loc_predicted_orbits_data_source_s_type predicted_orbits_data_source;
+		rpc_loc_predicted_orbits_data_validity_report_s_type predicted_orbits_data_validity;
+	} rpc_loc_ioctl_callback_data_u_type_u;
+};
+typedef struct rpc_loc_ioctl_callback_data_u_type rpc_loc_ioctl_callback_data_u_type;
+
+struct rpc_loc_ioctl_callback_s_type {
+	rpc_loc_ioctl_e_type type;
+	rpc_int32 status;
+	rpc_loc_ioctl_callback_data_u_type data;
+};
+typedef struct rpc_loc_ioctl_callback_s_type rpc_loc_ioctl_callback_s_type;
+
+struct rpc_loc_event_payload_u_type {
+	u_quad_t disc;
+	union {
+		rpc_loc_parsed_position_s_type parsed_location_report;
+		rpc_loc_gnss_info_s_type gnss_report;
+		rpc_loc_nmea_report_s_type nmea_report;
+		rpc_loc_ni_event_s_type ni_request;
+		rpc_loc_assist_data_request_s_type assist_data_request;
+		rpc_loc_server_request_s_type loc_server_request;
+		rpc_loc_ioctl_callback_s_type ioctl_report;
+		rpc_loc_status_event_s_type status_report;
+		rpc_loc_reserved_payload_s_type reserved;
+	} rpc_loc_event_payload_u_type_u;
+};
+typedef struct rpc_loc_event_payload_u_type rpc_loc_event_payload_u_type;
+#define RPC_LOC_API_NULL_VERSION 0x00010001
+#define RPC_LOC_API_RPC_GLUE_CODE_INFO_REMOTE_VERSION 0x00010001
+
+/* the xdr functions */
+
+#if defined(__STDC__) || defined(__cplusplus)
+extern  bool_t xdr_rpc_boolean (XDR *, rpc_boolean*);
+extern  bool_t xdr_rpc_uint32 (XDR *, rpc_uint32*);
+extern  bool_t xdr_rpc_uint16 (XDR *, rpc_uint16*);
+extern  bool_t xdr_rpc_uint8 (XDR *, rpc_uint8*);
+extern  bool_t xdr_rpc_int32 (XDR *, rpc_int32*);
+extern  bool_t xdr_rpc_byte (XDR *, rpc_byte*);
+extern  bool_t xdr_rpc_uint64 (XDR *, rpc_uint64*);
+extern  bool_t xdr_rpc_loc_client_handle_type (XDR *, rpc_loc_client_handle_type*);
+extern  bool_t xdr_rpc_loc_event_mask_type (XDR *, rpc_loc_event_mask_type*);
+extern  bool_t xdr_rpc_loc_position_valid_mask_type (XDR *, rpc_loc_position_valid_mask_type*);
+extern  bool_t xdr_rpc_loc_pos_technology_mask_type (XDR *, rpc_loc_pos_technology_mask_type*);
+extern  bool_t xdr_rpc_loc_session_status_e_type (XDR *, rpc_loc_session_status_e_type*);
+extern  bool_t xdr_rpc_loc_calendar_time_s_type (XDR *, rpc_loc_calendar_time_s_type*);
+extern  bool_t xdr_rpc_loc_parsed_position_s_type (XDR *, rpc_loc_parsed_position_s_type*);
+extern  bool_t xdr_rpc_loc_sv_system_e_type (XDR *, rpc_loc_sv_system_e_type*);
+extern  bool_t xdr_rpc_loc_sv_status_e_type (XDR *, rpc_loc_sv_status_e_type*);
+extern  bool_t xdr_rpc_loc_sv_info_valid_mask_type (XDR *, rpc_loc_sv_info_valid_mask_type*);
+extern  bool_t xdr_rpc_loc_sv_info_s_type (XDR *, rpc_loc_sv_info_s_type*);
+extern  bool_t xdr_rpc_loc_gnss_info_valid_mask_type (XDR *, rpc_loc_gnss_info_valid_mask_type*);
+extern  bool_t xdr_rpc_loc_gnss_info_s_type (XDR *, rpc_loc_gnss_info_s_type*);
+extern  bool_t xdr_rpc_loc_nmea_report_s_type (XDR *, rpc_loc_nmea_report_s_type*);
+extern  bool_t xdr_rpc_loc_status_event_e_type (XDR *, rpc_loc_status_event_e_type*);
+extern  bool_t xdr_rpc_loc_engine_state_e_type (XDR *, rpc_loc_engine_state_e_type*);
+extern  bool_t xdr_rpc_loc_status_event_payload_u_type (XDR *, rpc_loc_status_event_payload_u_type*);
+extern  bool_t xdr_rpc_loc_status_event_s_type (XDR *, rpc_loc_status_event_s_type*);
+extern  bool_t xdr_rpc_loc_server_addr_e_type (XDR *, rpc_loc_server_addr_e_type*);
+extern  bool_t xdr_rpc_loc_server_addr_ipv4_type (XDR *, rpc_loc_server_addr_ipv4_type*);
+extern  bool_t xdr_rpc_loc_server_addr_url_type (XDR *, rpc_loc_server_addr_url_type*);
+extern  bool_t xdr_rpc_loc_server_addr_u_type (XDR *, rpc_loc_server_addr_u_type*);
+extern  bool_t xdr_rpc_loc_server_info_s_type (XDR *, rpc_loc_server_info_s_type*);
+extern  bool_t xdr_rpc_loc_ni_notify_verify_e_type (XDR *, rpc_loc_ni_notify_verify_e_type*);
+extern  bool_t xdr_rpc_loc_ni_event_e_type (XDR *, rpc_loc_ni_event_e_type*);
+extern  bool_t xdr_rpc_loc_ni_datacoding_scheme_e_type (XDR *, rpc_loc_ni_datacoding_scheme_e_type*);
+extern  bool_t xdr_rpc_loc_ni_vx_requester_id_encoding_scheme_e_type (XDR *, rpc_loc_ni_vx_requester_id_encoding_scheme_e_type*);
+extern  bool_t xdr_rpc_loc_ni_vx_pos_mode_e_type (XDR *, rpc_loc_ni_vx_pos_mode_e_type*);
+extern  bool_t xdr_rpc_loc_ni_vx_requester_id_s_type (XDR *, rpc_loc_ni_vx_requester_id_s_type*);
+extern  bool_t xdr_rpc_loc_ni_vx_notify_verify_req_s_type (XDR *, rpc_loc_ni_vx_notify_verify_req_s_type*);
+extern  bool_t xdr_rpc_loc_ni_supl_pos_method_e_type (XDR *, rpc_loc_ni_supl_pos_method_e_type*);
+extern  bool_t xdr_rpc_loc_ni_supl_slp_session_id_s_type (XDR *, rpc_loc_ni_supl_slp_session_id_s_type*);
+extern  bool_t xdr_rpc_loc_ni_requestor_id_s_type (XDR *, rpc_loc_ni_requestor_id_s_type*);
+extern  bool_t xdr_rpc_loc_ni_supl_client_name_s_type (XDR *, rpc_loc_ni_supl_client_name_s_type*);
+extern  bool_t xdr_rpc_loc_ni_supl_qop_s_type (XDR *, rpc_loc_ni_supl_qop_s_type*);
+extern  bool_t xdr_rpc_loc_ni_supl_notify_verify_req_s_type (XDR *, rpc_loc_ni_supl_notify_verify_req_s_type*);
+extern  bool_t xdr_rpc_loc_ni_ext_client_address_s_type (XDR *, rpc_loc_ni_ext_client_address_s_type*);
+extern  bool_t xdr_rpc_loc_ni_location_type_e_type (XDR *, rpc_loc_ni_location_type_e_type*);
+extern  bool_t xdr_rpc_loc_ni_deferred_location_s_type (XDR *, rpc_loc_ni_deferred_location_s_type*);
+extern  bool_t xdr_rpc_loc_ni_codeword_string_s_type (XDR *, rpc_loc_ni_codeword_string_s_type*);
+extern  bool_t xdr_rpc_loc_ni_service_type_id_s_type (XDR *, rpc_loc_ni_service_type_id_s_type*);
+extern  bool_t xdr_rpc_loc_ni_umts_cp_notify_verify_req_s_type (XDR *, rpc_loc_ni_umts_cp_notify_verify_req_s_type*);
+extern  bool_t xdr_rpc_loc_ni_event_payload_u_type (XDR *, rpc_loc_ni_event_payload_u_type*);
+extern  bool_t xdr_rpc_loc_ni_event_s_type (XDR *, rpc_loc_ni_event_s_type*);
+extern  bool_t xdr_rpc_loc_assist_data_request_e_type (XDR *, rpc_loc_assist_data_request_e_type*);
+extern  bool_t xdr_rpc_struct_loc_time_download_source_s_type_servers_ptr (XDR *, rpc_struct_loc_time_download_source_s_type_servers_ptr*);
+extern  bool_t xdr_rpc_struct_loc_time_download_source_s_type_servers (XDR *, rpc_struct_loc_time_download_source_s_type_servers);
+extern  bool_t xdr_rpc_loc_time_download_source_s_type (XDR *, rpc_loc_time_download_source_s_type*);
+extern  bool_t xdr_rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr (XDR *, rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr*);
+extern  bool_t xdr_rpc_struct_loc_predicted_orbits_data_source_s_type_servers (XDR *, rpc_struct_loc_predicted_orbits_data_source_s_type_servers);
+extern  bool_t xdr_rpc_loc_predicted_orbits_data_source_s_type (XDR *, rpc_loc_predicted_orbits_data_source_s_type*);
+extern  bool_t xdr_rpc_loc_assist_data_request_payload_u_type (XDR *, rpc_loc_assist_data_request_payload_u_type*);
+extern  bool_t xdr_rpc_loc_assist_data_request_s_type (XDR *, rpc_loc_assist_data_request_s_type*);
+extern  bool_t xdr_rpc_loc_server_connection_handle (XDR *, rpc_loc_server_connection_handle*);
+extern  bool_t xdr_rpc_loc_server_protocol_e_type (XDR *, rpc_loc_server_protocol_e_type*);
+extern  bool_t xdr_rpc_loc_server_request_e_type (XDR *, rpc_loc_server_request_e_type*);
+extern  bool_t xdr_rpc_loc_server_open_req_s_type (XDR *, rpc_loc_server_open_req_s_type*);
+extern  bool_t xdr_rpc_loc_server_close_req_s_type (XDR *, rpc_loc_server_close_req_s_type*);
+extern  bool_t xdr_rpc_loc_server_request_u_type (XDR *, rpc_loc_server_request_u_type*);
+extern  bool_t xdr_rpc_loc_server_request_s_type (XDR *, rpc_loc_server_request_s_type*);
+extern  bool_t xdr_rpc_loc_reserved_payload_s_type (XDR *, rpc_loc_reserved_payload_s_type*);
+extern  bool_t xdr_rpc_loc_ioctl_e_type (XDR *, rpc_loc_ioctl_e_type*);
+extern  bool_t xdr_rpc_loc_api_version_s_type (XDR *, rpc_loc_api_version_s_type*);
+extern  bool_t xdr_rpc_loc_fix_recurrence_e_type (XDR *, rpc_loc_fix_recurrence_e_type*);
+extern  bool_t xdr_rpc_loc_operation_mode_e_type (XDR *, rpc_loc_operation_mode_e_type*);
+extern  bool_t xdr_rpc_loc_notify_e_type (XDR *, rpc_loc_notify_e_type*);
+extern  bool_t xdr_rpc_loc_fix_criteria_s_type (XDR *, rpc_loc_fix_criteria_s_type*);
+extern  bool_t xdr_rpc_loc_ni_user_resp_e_type (XDR *, rpc_loc_ni_user_resp_e_type*);
+extern  bool_t xdr_rpc_loc_user_verify_s_type (XDR *, rpc_loc_user_verify_s_type*);
+extern  bool_t xdr_rpc_loc_predicted_orbits_data_format_e_type (XDR *, rpc_loc_predicted_orbits_data_format_e_type*);
+extern  bool_t xdr_rpc_loc_predicted_orbits_data_s_type (XDR *, rpc_loc_predicted_orbits_data_s_type*);
+extern  bool_t xdr_rpc_loc_predicted_orbits_data_validity_report_s_type (XDR *, rpc_loc_predicted_orbits_data_validity_report_s_type*);
+extern  bool_t xdr_rpc_loc_predicted_orbits_auto_download_config_s_type (XDR *, rpc_loc_predicted_orbits_auto_download_config_s_type*);
+extern  bool_t xdr_rpc_loc_assist_data_time_s_type (XDR *, rpc_loc_assist_data_time_s_type*);
+extern  bool_t xdr_rpc_loc_assist_pos_valid_mask_type (XDR *, rpc_loc_assist_pos_valid_mask_type*);
+extern  bool_t xdr_rpc_loc_assist_data_pos_s_type (XDR *, rpc_loc_assist_data_pos_s_type*);
+extern  bool_t xdr_rpc_loc_server_open_status_e_type (XDR *, rpc_loc_server_open_status_e_type*);
+extern  bool_t xdr_rpc_loc_server_open_status_s_type (XDR *, rpc_loc_server_open_status_s_type*);
+extern  bool_t xdr_rpc_loc_server_close_status_e_type (XDR *, rpc_loc_server_close_status_e_type*);
+extern  bool_t xdr_rpc_loc_server_close_status_s_type (XDR *, rpc_loc_server_close_status_s_type*);
+extern  bool_t xdr_rpc_loc_lock_e_type (XDR *, rpc_loc_lock_e_type*);
+extern  bool_t xdr_rpc_loc_nmea_sentence_type (XDR *, rpc_loc_nmea_sentence_type*);
+extern  bool_t xdr_rpc_loc_assist_data_type (XDR *, rpc_loc_assist_data_type*);
+extern  bool_t xdr_rpc_loc_assist_data_delete_s_type (XDR *, rpc_loc_assist_data_delete_s_type*);
+extern  bool_t xdr_rpc_loc_ioctl_data_u_type (XDR *, rpc_loc_ioctl_data_u_type*);
+extern  bool_t xdr_rpc_loc_ioctl_callback_data_u_type (XDR *, rpc_loc_ioctl_callback_data_u_type*);
+extern  bool_t xdr_rpc_loc_ioctl_callback_s_type (XDR *, rpc_loc_ioctl_callback_s_type*);
+extern  bool_t xdr_rpc_loc_event_payload_u_type (XDR *, rpc_loc_event_payload_u_type*);
+
+#else /* K&R C */
+extern bool_t xdr_rpc_boolean ();
+extern bool_t xdr_rpc_uint32 ();
+extern bool_t xdr_rpc_uint16 ();
+extern bool_t xdr_rpc_uint8 ();
+extern bool_t xdr_rpc_int32 ();
+extern bool_t xdr_rpc_byte ();
+extern bool_t xdr_rpc_uint64 ();
+extern bool_t xdr_rpc_loc_client_handle_type ();
+extern bool_t xdr_rpc_loc_event_mask_type ();
+extern bool_t xdr_rpc_loc_position_valid_mask_type ();
+extern bool_t xdr_rpc_loc_pos_technology_mask_type ();
+extern bool_t xdr_rpc_loc_session_status_e_type ();
+extern bool_t xdr_rpc_loc_calendar_time_s_type ();
+extern bool_t xdr_rpc_loc_parsed_position_s_type ();
+extern bool_t xdr_rpc_loc_sv_system_e_type ();
+extern bool_t xdr_rpc_loc_sv_status_e_type ();
+extern bool_t xdr_rpc_loc_sv_info_valid_mask_type ();
+extern bool_t xdr_rpc_loc_sv_info_s_type ();
+extern bool_t xdr_rpc_loc_gnss_info_valid_mask_type ();
+extern bool_t xdr_rpc_loc_gnss_info_s_type ();
+extern bool_t xdr_rpc_loc_nmea_report_s_type ();
+extern bool_t xdr_rpc_loc_status_event_e_type ();
+extern bool_t xdr_rpc_loc_engine_state_e_type ();
+extern bool_t xdr_rpc_loc_status_event_payload_u_type ();
+extern bool_t xdr_rpc_loc_status_event_s_type ();
+extern bool_t xdr_rpc_loc_server_addr_e_type ();
+extern bool_t xdr_rpc_loc_server_addr_ipv4_type ();
+extern bool_t xdr_rpc_loc_server_addr_url_type ();
+extern bool_t xdr_rpc_loc_server_addr_u_type ();
+extern bool_t xdr_rpc_loc_server_info_s_type ();
+extern bool_t xdr_rpc_loc_ni_notify_verify_e_type ();
+extern bool_t xdr_rpc_loc_ni_event_e_type ();
+extern bool_t xdr_rpc_loc_ni_datacoding_scheme_e_type ();
+extern bool_t xdr_rpc_loc_ni_vx_requester_id_encoding_scheme_e_type ();
+extern bool_t xdr_rpc_loc_ni_vx_pos_mode_e_type ();
+extern bool_t xdr_rpc_loc_ni_vx_requester_id_s_type ();
+extern bool_t xdr_rpc_loc_ni_vx_notify_verify_req_s_type ();
+extern bool_t xdr_rpc_loc_ni_supl_pos_method_e_type ();
+extern bool_t xdr_rpc_loc_ni_supl_slp_session_id_s_type ();
+extern bool_t xdr_rpc_loc_ni_requestor_id_s_type ();
+extern bool_t xdr_rpc_loc_ni_supl_client_name_s_type ();
+extern bool_t xdr_rpc_loc_ni_supl_qop_s_type ();
+extern bool_t xdr_rpc_loc_ni_supl_notify_verify_req_s_type ();
+extern bool_t xdr_rpc_loc_ni_ext_client_address_s_type ();
+extern bool_t xdr_rpc_loc_ni_location_type_e_type ();
+extern bool_t xdr_rpc_loc_ni_deferred_location_s_type ();
+extern bool_t xdr_rpc_loc_ni_codeword_string_s_type ();
+extern bool_t xdr_rpc_loc_ni_service_type_id_s_type ();
+extern bool_t xdr_rpc_loc_ni_umts_cp_notify_verify_req_s_type ();
+extern bool_t xdr_rpc_loc_ni_event_payload_u_type ();
+extern bool_t xdr_rpc_loc_ni_event_s_type ();
+extern bool_t xdr_rpc_loc_assist_data_request_e_type ();
+extern bool_t xdr_rpc_struct_loc_time_download_source_s_type_servers_ptr ();
+extern bool_t xdr_rpc_struct_loc_time_download_source_s_type_servers ();
+extern bool_t xdr_rpc_loc_time_download_source_s_type ();
+extern bool_t xdr_rpc_struct_loc_predicted_orbits_data_source_s_type_servers_ptr ();
+extern bool_t xdr_rpc_struct_loc_predicted_orbits_data_source_s_type_servers ();
+extern bool_t xdr_rpc_loc_predicted_orbits_data_source_s_type ();
+extern bool_t xdr_rpc_loc_assist_data_request_payload_u_type ();
+extern bool_t xdr_rpc_loc_assist_data_request_s_type ();
+extern bool_t xdr_rpc_loc_server_connection_handle ();
+extern bool_t xdr_rpc_loc_server_protocol_e_type ();
+extern bool_t xdr_rpc_loc_server_request_e_type ();
+extern bool_t xdr_rpc_loc_server_open_req_s_type ();
+extern bool_t xdr_rpc_loc_server_close_req_s_type ();
+extern bool_t xdr_rpc_loc_server_request_u_type ();
+extern bool_t xdr_rpc_loc_server_request_s_type ();
+extern bool_t xdr_rpc_loc_reserved_payload_s_type ();
+extern bool_t xdr_rpc_loc_ioctl_e_type ();
+extern bool_t xdr_rpc_loc_api_version_s_type ();
+extern bool_t xdr_rpc_loc_fix_recurrence_e_type ();
+extern bool_t xdr_rpc_loc_operation_mode_e_type ();
+extern bool_t xdr_rpc_loc_notify_e_type ();
+extern bool_t xdr_rpc_loc_fix_criteria_s_type ();
+extern bool_t xdr_rpc_loc_ni_user_resp_e_type ();
+extern bool_t xdr_rpc_loc_user_verify_s_type ();
+extern bool_t xdr_rpc_loc_predicted_orbits_data_format_e_type ();
+extern bool_t xdr_rpc_loc_predicted_orbits_data_s_type ();
+extern bool_t xdr_rpc_loc_predicted_orbits_data_validity_report_s_type ();
+extern bool_t xdr_rpc_loc_predicted_orbits_auto_download_config_s_type ();
+extern bool_t xdr_rpc_loc_assist_data_time_s_type ();
+extern bool_t xdr_rpc_loc_assist_pos_valid_mask_type ();
+extern bool_t xdr_rpc_loc_assist_data_pos_s_type ();
+extern bool_t xdr_rpc_loc_server_open_status_e_type ();
+extern bool_t xdr_rpc_loc_server_open_status_s_type ();
+extern bool_t xdr_rpc_loc_server_close_status_e_type ();
+extern bool_t xdr_rpc_loc_server_close_status_s_type ();
+extern bool_t xdr_rpc_loc_lock_e_type ();
+extern bool_t xdr_rpc_loc_nmea_sentence_type ();
+extern bool_t xdr_rpc_loc_assist_data_type ();
+extern bool_t xdr_rpc_loc_assist_data_delete_s_type ();
+extern bool_t xdr_rpc_loc_ioctl_data_u_type ();
+extern bool_t xdr_rpc_loc_ioctl_callback_data_u_type ();
+extern bool_t xdr_rpc_loc_ioctl_callback_s_type ();
+extern bool_t xdr_rpc_loc_event_payload_u_type ();
+
+#endif /* K&R C */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_LOC_API_COMMON_H_RPCGEN */
diff --git a/msm8974/loc_api/libloc_api-rpc/inc-3200/loc_api_fixup.h b/msm8974/loc_api/libloc_api-rpc/inc-3200/loc_api_fixup.h
new file mode 100644
index 0000000..e62eb36
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/inc-3200/loc_api_fixup.h
@@ -0,0 +1,188 @@
+/******************************************************************************
+  @file:  loc_api_fixup.h
+  @brief:  Loc API Android RPC amendment header
+
+  DESCRIPTION
+     Loc API Android RPC amendment header
+
+  INITIALIZATION AND SEQUENCING REQUIREMENTS
+
+  -----------------------------------------------------------------------------
+Copyright (c) 2009, QUALCOMM USA, INC.
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+         Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 
+
+         Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. 
+
+         Neither the name of the QUALCOMM USA, INC.  nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  -----------------------------------------------------------------------------
+ ******************************************************************************/
+
+#ifndef  LOC_API_FIXUP_H
+#define LOC_API_FIXUP_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#ifndef NULLPROC
+#define NULLPROC 0
+#endif /* NULLPROC */
+
+#ifdef ADD_XDR_FLOAT
+
+extern bool_t xdr_float (XDR *__xdrs, float *__fp);
+extern bool_t xdr_double (XDR *__xdrs, double *__dp);
+
+#endif /* ADD_XDR_FLOAT */
+
+#ifdef ADD_XDR_BOOL
+extern bool_t xdr_bool(XDR *__xdrs, int *__bp);
+#endif /* ADD_XDR_BOOL */
+
+#define RPC_LOC_API_MAJOR_VERSION_NUMBER   1
+#define RPC_LOC_API_MINOR_VERSION_NUMBER   0
+
+// Return value for loc_open in case of failure.
+#define RPC_LOC_CLIENT_HANDLE_INVALID     -1
+
+// Return value of loc api calls for loc_close, loc_start_fix, loc_stop_fix and loc_ioctl
+// These are also the status for the ioctl callback
+#define RPC_LOC_API_SUCCESS           0
+#define RPC_LOC_API_GENERAL_FAILURE   1
+#define RPC_LOC_API_UNSUPPORTED       2
+#define RPC_LOC_API_INVALID_HANDLE    4
+#define RPC_LOC_API_INVALID_PARAMETER 5
+#define RPC_LOC_API_ENGINE_BUSY       6
+#define RPC_LOC_API_PHONE_OFFLINE     7
+#define RPC_LOC_API_TIMEOUT           8
+
+// Special return value for loc api calls in case of RCP failure
+#define RPC_LOC_API_RPC_FAILURE       (-1234)
+
+#define RPC_LOC_API_MAX_SV_COUNT                      80
+#define RPC_LOC_API_MAX_NMEA_STRING_LENGTH            1200
+
+// Maximum server address that will be used in location API
+#define RPC_LOC_API_MAX_SERVER_ADDR_LENGTH            256
+#define RPC_LOC_API_MAX_NUM_PREDICTED_ORBITS_SERVERS  3
+#define RPC_LOC_API_MAX_NUM_NTP_SERVERS               3
+
+#define RPC_LOC_EVENT_PARSED_POSITION_REPORT             0x00000001 // Position report comes in loc_parsed_position_s_type
+#define RPC_LOC_EVENT_SATELLITE_REPORT                   0x00000002 // Satellite in view report
+#define RPC_LOC_EVENT_NMEA_1HZ_REPORT                    0x00000004 // NMEA report at 1HZ rate
+#define RPC_LOC_EVENT_NMEA_POSITION_REPORT               0x00000008 // NMEA report at position report rate
+#define RPC_LOC_EVENT_NI_NOTIFY_VERIFY_REQUEST           0x00000010 // NI notification/verification request
+#define RPC_LOC_EVENT_ASSISTANCE_DATA_REQUEST            0x00000020 // Assistance data, eg: time, predicted orbits request
+#define RPC_LOC_EVENT_LOCATION_SERVER_REQUEST            0x00000040 // Request for location server
+#define RPC_LOC_EVENT_IOCTL_REPORT                       0x00000080 // Callback report for loc_ioctl
+#define RPC_LOC_EVENT_STATUS_REPORT                      0x00000100 // Misc status report: eg, engine state
+
+
+#define RPC_LOC_POS_VALID_SESSION_STATUS                 0x00000001
+#define RPC_LOC_POS_VALID_TIMESTAMP_CALENDAR             0x00000002
+#define RPC_LOC_POS_VALID_TIMESTAMP_UTC                  0x00000004
+#define RPC_LOC_POS_VALID_LEAP_SECONDS                   0x00000008
+#define RPC_LOC_POS_VALID_TIME_UNC                       0x00000010
+#define RPC_LOC_POS_VALID_LATITUDE                       0x00000020
+#define RPC_LOC_POS_VALID_LONGITUDE                      0x00000040
+#define RPC_LOC_POS_VALID_ALTITUDE_WRT_ELLIPSOID         0x00000080
+#define RPC_LOC_POS_VALID_ALTITUDE_WRT_MEAN_SEA_LEVEL    0x00000100
+#define RPC_LOC_POS_VALID_SPEED_HORIZONTAL               0x00000200
+#define RPC_LOC_POS_VALID_SPEED_VERTICAL                 0x00000400
+#define RPC_LOC_POS_VALID_HEADING                        0x00000800
+#define RPC_LOC_POS_VALID_HOR_UNC_CIRCULAR               0x00001000
+#define RPC_LOC_POS_VALID_HOR_UNC_ELLI_SEMI_MAJ          0x00002000
+#define RPC_LOC_POS_VALID_HOR_UNC_ELLI_SEMI_MIN          0x00004000
+#define RPC_LOC_POS_VALID_HOR_UNC_ELLI_ORIENT_AZIMUTH    0x00008000
+#define RPC_LOC_POS_VALID_VERTICAL_UNC                   0x00010000
+#define RPC_LOC_POS_VALID_SPEED_UNC                      0x00020000
+#define RPC_LOC_POS_VALID_HEADING_UNC                    0x00040000
+#define RPC_LOC_POS_VALID_CONFIDENCE_HORIZONTAL          0x00080000
+#define RPC_LOC_POS_VALID_CONFIDENCE_VERTICAL            0x00100000
+#define RPC_LOC_POS_VALID_MAGNETIC_VARIATION             0x00200000
+#define RPC_LOC_POS_VALID_TECHNOLOGY_MASK                0x00400000
+
+#define RPC_LOC_POS_TECH_SATELLITE 0x00000001
+#define RPC_LOC_POS_TECH_CELLID    0x00000002
+#define RPC_LOC_POS_TECH_WIFI      0x00000004
+
+#define RPC_LOC_SV_INFO_VALID_SYSTEM         0x00000001
+#define RPC_LOC_SV_INFO_VALID_PRN            0x00000002
+#define RPC_LOC_SV_INFO_VALID_HEALTH_STATUS  0x00000004
+#define RPC_LOC_SV_INFO_VALID_PROCESS_STATUS 0x00000008
+#define RPC_LOC_SV_INFO_VALID_HAS_EPH        0x00000010
+#define RPC_LOC_SV_INFO_VALID_HAS_ALM        0x00000020
+#define RPC_LOC_SV_INFO_VALID_ELEVATION      0x00000040
+#define RPC_LOC_SV_INFO_VALID_AZIMUTH        0x00000080
+#define RPC_LOC_SV_INFO_VALID_SNR            0x00000100
+
+#define RPC_LOC_GNSS_INFO_VALID_POS_DOP           0x00000001
+#define RPC_LOC_GNSS_INFO_VALID_HOR_DOP           0x00000002
+#define RPC_LOC_GNSS_INFO_VALID_VERT_DOP          0x00000004
+#define RPC_LOC_GNSS_INFO_VALID_ALTITUDE_ASSUMED  0x00000008
+#define RPC_LOC_GNSS_INFO_VALID_SV_COUNT          0x00000010
+#define RPC_LOC_GNSS_INFO_VALID_SV_LIST           0x00000020
+
+#define RPC_LOC_NI_MAX_REQUESTOR_ID_LENGTH          200
+#define RPC_LOC_NI_SUPL_HASH_LENGTH                 8
+#define RPC_LOC_NI_SUPL_SLP_SESSION_ID_BYTE_LENGTH  4
+#define RPC_LOC_NI_MAX_CLIENT_NAME_LENGTH           64
+#define RPC_LOC_NI_MAX_EXT_CLIENT_ADDRESS           20
+#define RPC_LOC_NI_CODEWORD_LENGTH                  20
+
+#define RPC_LOC_NI_SUPL_QOP_VALID         0x01
+#define RPC_LOC_NI_SUPL_QOP_VERACC_VALID  0x02
+#define RPC_LOC_NI_SUPL_QOP_MAXAGE_VALID  0x04
+#define RPC_LOC_NI_SUPL_QOP_DELAY_VALID   0x08
+
+#define RPC_LOC_FIX_CRIT_VALID_RECURRENCE_TYPE                  0x00000001
+#define RPC_LOC_FIX_CRIT_VALID_PREFERRED_OPERATION_MODE         0x00000002
+#define RPC_LOC_FIX_CRIT_VALID_PREFERRED_ACCURACY               0x00000004
+#define RPC_LOC_FIX_CRIT_VALID_PREFERRED_RESPONSE_TIME          0x00000008
+#define RPC_LOC_FIX_CRIT_VALID_INTERMEDIATE_POS_REPORT_ENABLED  0x00000010
+#define RPC_LOC_FIX_CRIT_VALID_NOTIFY_TYPE                      0x00000020
+#define RPC_LOC_FIX_CRIT_VALID_MIN_INTERVAL                     0x00000040
+#define RPC_LOC_FIX_CRIT_VALID_MIN_DISTANCE                     0x00000080
+#define RPC_LOC_FIX_CRIT_VALID_MIN_DIST_SAMPLE_INTERVAL         0x00000100
+
+#define RPC_LOC_ASSIST_POS_VALID_TIMESTAMP_UTC                0x00000001
+#define RPC_LOC_ASSIST_POS_VALID_LATITUDE                     0x00000002
+#define RPC_LOC_ASSIST_POS_VALID_LONGITUDE                    0x00000004
+#define RPC_LOC_ASSIST_POS_VALID_ALTITUDE_WRT_ELLIPSOID       0x00000008
+#define RPC_LOC_ASSIST_POS_VALID_ALTITUDE_WRT_MEAN_SEA_LEVEL  0x00000010
+#define RPC_LOC_ASSIST_POS_VALID_HOR_UNC_CIRCULAR             0x00000020
+#define RPC_LOC_ASSIST_POS_VALID_VERT_UNC                     0x00000040
+#define RPC_LOC_ASSIST_POS_VALID_CONFIDENCE_HORIZONTAL        0x00000080
+#define RPC_LOC_ASSIST_POS_VALID_CONFIDENCE_VERTICAL          0x00000100
+
+#define RPC_LOC_ASSIST_DATA_ALL         0xFFFFFFFF
+
+#define RPC_LOC_NMEA_MASK_ALL    0xffff
+#define RPC_LOC_NMEA_MASK_GGA    0x0001
+#define RPC_LOC_NMEA_MASK_RMC    0x0002
+#define RPC_LOC_NMEA_MASK_GSV    0x0004
+#define RPC_LOC_NMEA_MASK_GSA    0x0008
+#define RPC_LOC_NMEA_MASK_VTG    0x0010
+
+/* flags for notification */
+#define  RPC_LOC_NI_CLIENT_NAME_PRESENT             0x0001
+#define  RPC_LOC_NI_CLIENT_EXTADDR_PRESENT          0x0002
+#define  RPC_LOC_NI_DEF_LOCATION_TYPE_PRESENT       0x0010
+#define  RPC_LOC_NI_REQUESTOR_ID_PRESENT            0x0020
+#define  RPC_LOC_NI_CODEWORD_PRESENT                0x0040
+#define  RPC_LOC_NI_SERVICE_TYPE_ID_PRESENT         0x0080
+#define  RPC_LOC_NI_ENCODING_TYPE_PRESENT           0x0100
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LOC_API_FIXUP_H */
diff --git a/msm8974/loc_api/libloc_api-rpc/inc-3200/loc_apicb_appinit.h b/msm8974/loc_api/libloc_api-rpc/inc-3200/loc_apicb_appinit.h
new file mode 100644
index 0000000..92d4e15
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/inc-3200/loc_apicb_appinit.h
@@ -0,0 +1,34 @@
+/* -------------------------------------------------------------------------------
+Copyright (c) 2009, QUALCOMM USA, INC.
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+         Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 
+
+         Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. 
+
+         Neither the name of the QUALCOMM USA, INC.  nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ -------------------------------------------------------------------------------
+ */ 
+
+#ifndef LOC_APICB_APPINIT_H
+#define LOC_APICB_APPINIT_H
+
+#ifdef __cplusplus 
+extern "C" 
+{ 
+#endif
+
+ /* Initialization function for callbacks */
+extern int loc_apicb_app_init(); 
+extern void loc_apicb_app_deinit(); 
+
+#ifdef __cplusplus 
+}
+#endif
+
+#endif /* LOC_APICB_APPINIT_H */
diff --git a/msm8974/loc_api/libloc_api-rpc/inc/debug.h b/msm8974/loc_api/libloc_api-rpc/inc/debug.h
new file mode 100644
index 0000000..a71b23a
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/inc/debug.h
@@ -0,0 +1,57 @@
+/*
+Copyright (c) 2009, QUALCOMM USA, INC.
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+         Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 
+
+         Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. 
+
+         Neither the name of the QUALCOMM USA, INC.  nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef DEBUG_H
+#define DEBUG_H
+
+#include <stdio.h>
+
+#define LOG_TAG "libgps-rpc"
+#include <utils/Log.h>
+
+#define PRINT(x...) do {                                    \
+        fprintf(stdout, "%s(%d) ", __FUNCTION__, __LINE__); \
+        fprintf(stdout, ##x);                               \
+        LOGD(x);                               \
+    } while(0)
+
+#ifdef DEBUG
+#define D PRINT
+#else
+#define D(x...) do { } while(0)
+#endif
+
+#ifdef VERBOSE
+#define V PRINT
+#else
+#define V(x...) do { } while(0)
+#endif
+
+#define E(x...) do {                                        \
+        fprintf(stderr, "%s(%d) ", __FUNCTION__, __LINE__); \
+        fprintf(stderr, ##x);                               \
+        LOGE(x);                                            \
+    } while(0)
+
+#define FAILIF(cond, msg...) do {                                              \
+        if (__builtin_expect (cond, 0)) {                                      \
+            fprintf(stderr, "%s:%s:(%d): ", __FILE__, __FUNCTION__, __LINE__); \
+            fprintf(stderr, ##msg);                                            \
+            LOGE(##msg);                                                       \
+        }                                                                      \
+    } while(0)
+
+#endif/*DEBUG_H*/
diff --git a/msm8974/loc_api/libloc_api-rpc/inc/loc_api_rpc_glue.h b/msm8974/loc_api/libloc_api-rpc/inc/loc_api_rpc_glue.h
new file mode 100644
index 0000000..ef972bd
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/inc/loc_api_rpc_glue.h
@@ -0,0 +1,100 @@
+/******************************************************************************
+  @file:  loc_api_rpc_glue.h
+  @brief:  Loc API Android glue code header
+
+  DESCRIPTION
+     Loc API Android glue code header
+
+  INITIALIZATION AND SEQUENCING REQUIREMENTS
+
+  -----------------------------------------------------------------------------
+Copyright (c) 2009, QUALCOMM USA, INC.
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+         Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 
+
+         Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. 
+
+         Neither the name of the QUALCOMM USA, INC.  nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  -----------------------------------------------------------------------------
+ ******************************************************************************/
+
+/*=====================================================================
+                        EDIT HISTORY FOR MODULE
+
+  This section contains comments describing changes made to the module.
+  Notice that changes are listed in reverse chronological order.
+
+when       who      what, where, why
+--------   ---      -------------------------------------------------------
+03/17/09   dx       Initial version
+
+$Id: //source/qcom/qct/modem/gps/cgps/dev/locationmiddleware/locapi/app-linux/source/test/loc_api_test/loc_api_cb_log.h#4 $
+======================================================================*/
+
+#ifndef LOC_API_RPC_GLUE_H
+#define LOC_API_RPC_GLUE_H
+
+/* Include RPC headers */
+#include "loc_api_common.h"
+#include "loc_api.h"
+#include "loc_api_cb.h"
+#include "loc_api_fixup.h"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/* Boolean */
+/* Other data types in comdef.h are defined in rpc stubs, so fix it here */
+typedef unsigned char boolean;
+#define TRUE 1
+#define FALSE 0
+
+extern int loc_api_glue_init(void);
+extern int loc_api_null(void);
+
+typedef int32 (loc_event_cb_f_type)(
+      rpc_loc_client_handle_type            loc_handle,             /* handle of the client */
+      rpc_loc_event_mask_type               loc_event,              /* event mask           */
+      const rpc_loc_event_payload_u_type*   loc_event_payload       /* payload              */
+);
+
+extern rpc_loc_client_handle_type loc_open(
+      rpc_loc_event_mask_type       event_reg_mask,
+      loc_event_cb_f_type       *event_callback
+);
+
+extern int32 loc_close
+(
+      rpc_loc_client_handle_type handle
+);
+
+extern int32 loc_start_fix
+(
+      rpc_loc_client_handle_type handle
+);
+
+extern int32 loc_stop_fix
+(
+      rpc_loc_client_handle_type handle
+);
+
+extern int32 loc_ioctl
+(
+      rpc_loc_client_handle_type           handle,
+      rpc_loc_ioctl_e_type                 ioctl_type,
+      rpc_loc_ioctl_data_u_type*           ioctl_data
+);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LOC_API_RPC_GLUE_H */
diff --git a/msm8974/loc_api/libloc_api-rpc/src/loc_apicb_appinit.c b/msm8974/loc_api/libloc_api-rpc/src/loc_apicb_appinit.c
new file mode 100644
index 0000000..7fcfd6c
--- /dev/null
+++ b/msm8974/loc_api/libloc_api-rpc/src/loc_apicb_appinit.c
@@ -0,0 +1,61 @@
+/* -------------------------------------------------------------------------------
+Copyright (c) 2009, QUALCOMM USA, INC.
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+         Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 
+
+         Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. 
+
+         Neither the name of the QUALCOMM USA, INC.  nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ -------------------------------------------------------------------------------
+ */ 
+#include "rpc/rpc.h"
+#include "loc_api_common.h"
+#include "loc_api.h"
+#include "loc_api_cb.h"
+#include "loc_api_fixup.h"
+
+#include "loc_apicb_appinit.h"
+
+#define RPC_FUNC_VERSION_BASE(a,b) a ## b
+#define RPC_CB_FUNC_VERS(a,b) RPC_FUNC_VERSION_BASE(a,b)
+
+static SVCXPRT* svrPort = NULL;
+
+extern void RPC_CB_FUNC_VERS(loc_apicbprog_,LOC_APICBVERS_0001)(struct svc_req *rqstp, register SVCXPRT *transp);
+
+int loc_apicb_app_init(void)
+{
+    /* Register a callback server to use the loc_apicbprog_* function  */
+    if (svrPort == NULL) {
+        svrPort = svcrtr_create();
+    }
+    if (!svrPort) return -1;
+
+    xprt_register(svrPort);
+    if(svc_register(svrPort, LOC_APICBPROG, LOC_APICBVERS_0001, RPC_CB_FUNC_VERS(loc_apicbprog_,LOC_APICBVERS_0001),0))
+    {
+        return 0;
+    }
+    else
+    {
+        return -1;
+    }
+}
+
+void loc_apicb_app_deinit(void)
+{
+    if (svrPort == NULL)
+    {
+        return;
+    }
+    xprt_unregister(svrPort);
+    svc_destroy(svrPort);
+    //svc_unregister(svrPort, LOC_APICBPROG, LOC_APICBVERS_0001);
+    svrPort = NULL;
+}
diff --git a/msm8974/loc_api/libloc_api_50001/Android.mk b/msm8974/loc_api/libloc_api_50001/Android.mk
new file mode 100644
index 0000000..e38befa
--- /dev/null
+++ b/msm8974/loc_api/libloc_api_50001/Android.mk
@@ -0,0 +1,105 @@
+ifneq ($(BUILD_TINY_ANDROID),true)
+#Compile this library only for builds with the latest modem image
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := libloc_eng
+LOCAL_MODULE_OWNER := qcom
+
+LOCAL_MODULE_TAGS := optional
+
+LOCAL_SHARED_LIBRARIES := \
+    libutils \
+    libcutils \
+    libdl \
+    liblog \
+    libloc_core \
+    libgps.utils
+
+LOCAL_SRC_FILES += \
+    loc_eng.cpp \
+    loc_eng_agps.cpp \
+    loc_eng_xtra.cpp \
+    loc_eng_ni.cpp \
+    loc_eng_log.cpp \
+    loc_eng_nmea.cpp \
+    LocEngAdapter.cpp
+
+LOCAL_SRC_FILES += \
+    loc_eng_dmn_conn.cpp \
+    loc_eng_dmn_conn_handler.cpp \
+    loc_eng_dmn_conn_thread_helper.c \
+    loc_eng_dmn_conn_glue_msg.c \
+    loc_eng_dmn_conn_glue_pipe.c
+
+LOCAL_CFLAGS += \
+     -fno-short-enums \
+     -D_ANDROID_ \
+     -Wno-unused-parameter
+
+LOCAL_C_INCLUDES:= \
+    $(TARGET_OUT_HEADERS)/gps.utils \
+    $(TARGET_OUT_HEADERS)/libloc_core
+
+LOCAL_COPY_HEADERS_TO:= libloc_eng/
+LOCAL_COPY_HEADERS:= \
+   LocEngAdapter.h \
+   loc.h \
+   loc_eng.h \
+   loc_eng_xtra.h \
+   loc_eng_ni.h \
+   loc_eng_agps.h \
+   loc_eng_msg.h \
+   loc_eng_log.h
+
+LOCAL_PRELINK_MODULE := false
+
+include $(BUILD_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := gps.$(BOARD_VENDOR_QCOM_GPS_LOC_API_HARDWARE)
+LOCAL_MODULE_OWNER := qcom
+
+LOCAL_MODULE_TAGS := optional
+
+## Libs
+
+LOCAL_SHARED_LIBRARIES := \
+    libutils \
+    libcutils \
+    liblog \
+    libloc_eng \
+    libloc_core \
+    libgps.utils \
+    libdl
+
+LOCAL_SRC_FILES += \
+    loc.cpp \
+    gps.c
+
+LOCAL_CFLAGS += \
+    -fno-short-enums \
+    -D_ANDROID_
+
+ifeq ($(TARGET_USES_QCOM_BSP), true)
+LOCAL_CFLAGS += -DTARGET_USES_QCOM_BSP
+endif
+
+## Includes
+LOCAL_C_INCLUDES:= \
+    $(TARGET_OUT_HEADERS)/gps.utils \
+    $(TARGET_OUT_HEADERS)/libloc_core
+
+ifneq ($(filter msm8084,$(TARGET_BOARD_PLATFORM)),)
+  LOCAL_CFLAGS += -DPLATFORM_MSM8084
+endif
+
+LOCAL_PRELINK_MODULE := false
+LOCAL_MODULE_RELATIVE_PATH := hw
+
+include $(BUILD_SHARED_LIBRARY)
+
+endif # not BUILD_TINY_ANDROID
diff --git a/msm8974/loc_api/libloc_api_50001/LocEngAdapter.cpp b/msm8974/loc_api/libloc_api_50001/LocEngAdapter.cpp
new file mode 100644
index 0000000..16a150d
--- /dev/null
+++ b/msm8974/loc_api/libloc_api_50001/LocEngAdapter.cpp
@@ -0,0 +1,380 @@
+/* Copyright (c) 2011-2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#define LOG_NDDEBUG 0
+#define LOG_TAG "LocSvc_EngAdapter"
+
+#include <LocEngAdapter.h>
+#include "loc_eng_msg.h"
+#include "loc_log.h"
+
+using namespace loc_core;
+
+LocInternalAdapter::LocInternalAdapter(LocEngAdapter* adapter) :
+    LocAdapterBase(adapter->getMsgTask()),
+    mLocEngAdapter(adapter)
+{
+}
+void LocInternalAdapter::setPositionModeInt(LocPosMode& posMode) {
+    sendMsg(new LocEngPositionMode(mLocEngAdapter, posMode));
+}
+void LocInternalAdapter::startFixInt() {
+    sendMsg(new LocEngStartFix(mLocEngAdapter));
+}
+void LocInternalAdapter::stopFixInt() {
+    sendMsg(new LocEngStopFix(mLocEngAdapter));
+}
+void LocInternalAdapter::getZppInt() {
+    sendMsg(new LocEngGetZpp(mLocEngAdapter));
+}
+
+void LocInternalAdapter::shutdown() {
+    sendMsg(new LocEngShutdown(mLocEngAdapter));
+}
+
+LocEngAdapter::LocEngAdapter(LOC_API_ADAPTER_EVENT_MASK_T mask,
+                             void* owner, ContextBase* context,
+                             MsgTask::tCreate tCreator) :
+    LocAdapterBase(mask,
+                   //Get the AFW context if VzW context has not already been intialized in
+                   //loc_ext
+                   context == NULL?
+                   LocDualContext::getLocFgContext(tCreator,
+                                                   LocDualContext::mLocationHalName)
+                   :context),
+    mOwner(owner), mInternalAdapter(new LocInternalAdapter(this)),
+    mUlp(new UlpProxyBase()), mNavigating(false),
+    mSupportsAgpsRequests(false),
+    mSupportsPositionInjection(false), mPowerVote(0)
+{
+    memset(&mFixCriteria, 0, sizeof(mFixCriteria));
+    mFixCriteria.mode = LOC_POSITION_MODE_INVALID;
+    LOC_LOGD("LocEngAdapter created");
+}
+
+inline
+LocEngAdapter::~LocEngAdapter()
+{
+    delete mInternalAdapter;
+    LOC_LOGV("LocEngAdapter deleted");
+}
+
+void LocInternalAdapter::setUlpProxy(UlpProxyBase* ulp) {
+    struct LocSetUlpProxy : public LocMsg {
+        LocAdapterBase* mAdapter;
+        UlpProxyBase* mUlp;
+        inline LocSetUlpProxy(LocAdapterBase* adapter, UlpProxyBase* ulp) :
+            LocMsg(), mAdapter(adapter), mUlp(ulp) {
+        }
+        virtual void proc() const {
+            LOC_LOGV("%s] ulp %p adapter %p", __func__,
+                     mUlp, mAdapter);
+            mAdapter->setUlpProxy(mUlp);
+        }
+    };
+
+    sendMsg(new LocSetUlpProxy(mLocEngAdapter, ulp));
+}
+
+void LocEngAdapter::setUlpProxy(UlpProxyBase* ulp)
+{
+    if (ulp == mUlp) {
+        //This takes care of the case when double initalization happens
+        //and we get the same object back for UlpProxyBase . Do nothing
+        return;
+    }
+
+    LOC_LOGV("%s] %p", __func__, ulp);
+    if (NULL == ulp) {
+        LOC_LOGE("%s:%d]: ulp pointer is NULL", __func__, __LINE__);
+        ulp = new UlpProxyBase();
+    }
+
+    if (LOC_POSITION_MODE_INVALID != mUlp->mPosMode.mode) {
+        // need to send this mode and start msg to ULP
+        ulp->sendFixMode(mUlp->mPosMode);
+    }
+
+    if(mUlp->mFixSet) {
+        ulp->sendStartFix();
+    }
+
+    delete mUlp;
+    mUlp = ulp;
+}
+
+int LocEngAdapter::setGpsLockMsg(LOC_GPS_LOCK_MASK lockMask)
+{
+    struct LocEngAdapterGpsLock : public LocMsg {
+        LocEngAdapter* mAdapter;
+        LOC_GPS_LOCK_MASK mLockMask;
+        inline LocEngAdapterGpsLock(LocEngAdapter* adapter, LOC_GPS_LOCK_MASK lockMask) :
+            LocMsg(), mAdapter(adapter), mLockMask(lockMask)
+        {
+            locallog();
+        }
+        inline virtual void proc() const {
+            mAdapter->setGpsLock(mLockMask);
+        }
+        inline  void locallog() const {
+            LOC_LOGV("LocEngAdapterGpsLock - mLockMask: %x", mLockMask);
+        }
+        inline virtual void log() const {
+            locallog();
+        }
+    };
+    sendMsg(new LocEngAdapterGpsLock(this, lockMask));
+    return 0;
+}
+
+void LocEngAdapter::requestPowerVote()
+{
+    if (getPowerVoteRight()) {
+        /* Power voting without engine lock:
+         * 101: vote down, 102-104 - vote up
+         * These codes are used not to confuse with actual engine lock
+         * functionality, that can't be used in SSR scenario, as it
+         * conflicts with initialization sequence.
+         */
+        bool powerUp = getPowerVote();
+        LOC_LOGV("LocEngAdapterVotePower - Vote Power: %d", (int)powerUp);
+        setGpsLock(powerUp ? 103 : 101);
+    }
+}
+
+void LocInternalAdapter::reportPosition(UlpLocation &location,
+                                        GpsLocationExtended &locationExtended,
+                                        void* locationExt,
+                                        enum loc_sess_status status,
+                                        LocPosTechMask loc_technology_mask)
+{
+    sendMsg(new LocEngReportPosition(mLocEngAdapter,
+                                     location,
+                                     locationExtended,
+                                     locationExt,
+                                     status,
+                                     loc_technology_mask));
+}
+
+
+void LocEngAdapter::reportPosition(UlpLocation &location,
+                                   GpsLocationExtended &locationExtended,
+                                   void* locationExt,
+                                   enum loc_sess_status status,
+                                   LocPosTechMask loc_technology_mask)
+{
+    if (! mUlp->reportPosition(location,
+                               locationExtended,
+                               locationExt,
+                               status,
+                               loc_technology_mask )) {
+        mInternalAdapter->reportPosition(location,
+                                         locationExtended,
+                                         locationExt,
+                                         status,
+                                         loc_technology_mask);
+    }
+}
+
+void LocInternalAdapter::reportSv(GpsSvStatus &svStatus,
+                                  GpsLocationExtended &locationExtended,
+                                  void* svExt){
+    sendMsg(new LocEngReportSv(mLocEngAdapter, svStatus,
+                               locationExtended, svExt));
+}
+
+void LocEngAdapter::reportSv(GpsSvStatus &svStatus,
+                             GpsLocationExtended &locationExtended,
+                             void* svExt)
+{
+
+    // We want to send SV info to ULP to help it in determining GNSS
+    // signal strength ULP will forward the SV reports to HAL without
+    // any modifications
+    if (! mUlp->reportSv(svStatus, locationExtended, svExt)) {
+        mInternalAdapter->reportSv(svStatus, locationExtended, svExt);
+    }
+}
+
+void LocEngAdapter::setInSession(bool inSession)
+{
+    mNavigating = inSession;
+    mLocApi->setInSession(inSession);
+    if (!mNavigating) {
+        mFixCriteria.mode = LOC_POSITION_MODE_INVALID;
+    }
+}
+
+void LocInternalAdapter::reportStatus(GpsStatusValue status)
+{
+    sendMsg(new LocEngReportStatus(mLocEngAdapter, status));
+}
+
+void LocEngAdapter::reportStatus(GpsStatusValue status)
+{
+    if (!mUlp->reportStatus(status)) {
+        mInternalAdapter->reportStatus(status);
+    }
+}
+
+inline
+void LocEngAdapter::reportNmea(const char* nmea, int length)
+{
+    sendMsg(new LocEngReportNmea(mOwner, nmea, length));
+}
+
+inline
+bool LocEngAdapter::reportXtraServer(const char* url1,
+                                        const char* url2,
+                                        const char* url3,
+                                        const int maxlength)
+{
+    if (mSupportsAgpsRequests) {
+        sendMsg(new LocEngReportXtraServer(mOwner, url1,
+                                           url2, url3, maxlength));
+    }
+    return mSupportsAgpsRequests;
+}
+
+inline
+bool LocEngAdapter::requestATL(int connHandle, AGpsType agps_type)
+{
+    if (mSupportsAgpsRequests) {
+        sendMsg(new LocEngRequestATL(mOwner,
+                                     connHandle, agps_type));
+    }
+    return mSupportsAgpsRequests;
+}
+
+inline
+bool LocEngAdapter::releaseATL(int connHandle)
+{
+    if (mSupportsAgpsRequests) {
+        sendMsg(new LocEngReleaseATL(mOwner, connHandle));
+    }
+    return mSupportsAgpsRequests;
+}
+
+inline
+bool LocEngAdapter::requestXtraData()
+{
+    if (mSupportsAgpsRequests) {
+        sendMsg(new LocEngRequestXtra(mOwner));
+    }
+    return mSupportsAgpsRequests;
+}
+
+inline
+bool LocEngAdapter::requestTime()
+{
+    if (mSupportsAgpsRequests) {
+        sendMsg(new LocEngRequestTime(mOwner));
+    }
+    return mSupportsAgpsRequests;
+}
+
+inline
+bool LocEngAdapter::requestNiNotify(GpsNiNotification &notif, const void* data)
+{
+    if (mSupportsAgpsRequests) {
+        notif.size = sizeof(notif);
+        notif.timeout = LOC_NI_NO_RESPONSE_TIME;
+
+        sendMsg(new LocEngRequestNi(mOwner, notif, data));
+    }
+    return mSupportsAgpsRequests;
+}
+
+inline
+bool LocEngAdapter::requestSuplES(int connHandle)
+{
+    if (mSupportsAgpsRequests)
+        sendMsg(new LocEngRequestSuplEs(mOwner, connHandle));
+    return mSupportsAgpsRequests;
+}
+
+inline
+bool LocEngAdapter::reportDataCallOpened()
+{
+    if(mSupportsAgpsRequests)
+        sendMsg(new LocEngSuplEsOpened(mOwner));
+    return mSupportsAgpsRequests;
+}
+
+inline
+bool LocEngAdapter::reportDataCallClosed()
+{
+    if(mSupportsAgpsRequests)
+        sendMsg(new LocEngSuplEsClosed(mOwner));
+    return mSupportsAgpsRequests;
+}
+
+inline
+void LocEngAdapter::handleEngineDownEvent()
+{
+    sendMsg(new LocEngDown(mOwner));
+}
+
+inline
+void LocEngAdapter::handleEngineUpEvent()
+{
+    sendMsg(new LocEngUp(mOwner));
+}
+
+void LocEngAdapter::reportGpsMeasurementData(GpsData &gpsMeasurementData)
+{
+    sendMsg(new LocEngReportGpsMeasurement(mOwner,
+                                           gpsMeasurementData));
+}
+
+/*
+  Update Registration Mask
+ */
+void LocEngAdapter::updateRegistrationMask(LOC_API_ADAPTER_EVENT_MASK_T event,
+                                           loc_registration_mask_status isEnabled)
+{
+    LOC_LOGD("entering %s", __func__);
+    int result = LOC_API_ADAPTER_ERR_FAILURE;
+    result = mLocApi->updateRegistrationMask(event, isEnabled);
+    if (result == LOC_API_ADAPTER_ERR_SUCCESS) {
+        LOC_LOGD("%s] update registration mask succeed.", __func__);
+    } else {
+        LOC_LOGE("%s] update registration mask failed.", __func__);
+    }
+}
+
+/*
+  Set Gnss Constellation Config
+ */
+bool LocEngAdapter::gnssConstellationConfig()
+{
+    LOC_LOGD("entering %s", __func__);
+    bool result = false;
+    result = mLocApi->gnssConstellationConfig();
+    return result;
+}
diff --git a/msm8974/loc_api/libloc_api_50001/LocEngAdapter.h b/msm8974/loc_api/libloc_api_50001/LocEngAdapter.h
new file mode 100644
index 0000000..fe5df3c
--- /dev/null
+++ b/msm8974/loc_api/libloc_api_50001/LocEngAdapter.h
@@ -0,0 +1,352 @@
+/* Copyright (c) 2011-2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef LOC_API_ENG_ADAPTER_H
+#define LOC_API_ENG_ADAPTER_H
+
+#include <ctype.h>
+#include <hardware/gps.h>
+#include <loc.h>
+#include <loc_eng_log.h>
+#include <log_util.h>
+#include <LocAdapterBase.h>
+#include <LocDualContext.h>
+#include <UlpProxyBase.h>
+#include <platform_lib_includes.h>
+
+#define MAX_URL_LEN 256
+
+using namespace loc_core;
+
+class LocEngAdapter;
+
+class LocInternalAdapter : public LocAdapterBase {
+    LocEngAdapter* mLocEngAdapter;
+public:
+    LocInternalAdapter(LocEngAdapter* adapter);
+
+    virtual void reportPosition(UlpLocation &location,
+                                GpsLocationExtended &locationExtended,
+                                void* locationExt,
+                                enum loc_sess_status status,
+                                LocPosTechMask loc_technology_mask);
+    virtual void reportSv(GpsSvStatus &svStatus,
+                          GpsLocationExtended &locationExtended,
+                          void* svExt);
+    virtual void reportStatus(GpsStatusValue status);
+    virtual void setPositionModeInt(LocPosMode& posMode);
+    virtual void startFixInt();
+    virtual void stopFixInt();
+    virtual void getZppInt();
+    virtual void setUlpProxy(UlpProxyBase* ulp);
+    virtual void shutdown();
+};
+
+typedef void (*loc_msg_sender)(void* loc_eng_data_p, void* msgp);
+
+class LocEngAdapter : public LocAdapterBase {
+    void* mOwner;
+    LocInternalAdapter* mInternalAdapter;
+    UlpProxyBase* mUlp;
+    LocPosMode mFixCriteria;
+    bool mNavigating;
+    // mPowerVote is encoded as
+    // mPowerVote & 0x20 -- powerVoteRight
+    // mPowerVote & 0x10 -- power On / Off
+    unsigned int mPowerVote;
+    static const unsigned int POWER_VOTE_RIGHT = 0x20;
+    static const unsigned int POWER_VOTE_VALUE = 0x10;
+
+public:
+    bool mSupportsAgpsRequests;
+    bool mSupportsPositionInjection;
+
+    LocEngAdapter(LOC_API_ADAPTER_EVENT_MASK_T mask,
+                  void* owner, ContextBase* context,
+                  MsgTask::tCreate tCreator);
+    virtual ~LocEngAdapter();
+
+    virtual void setUlpProxy(UlpProxyBase* ulp);
+    inline void requestUlp(unsigned long capabilities) {
+        mContext->requestUlp(mInternalAdapter, capabilities);
+    }
+    inline LocInternalAdapter* getInternalAdapter() { return mInternalAdapter; }
+    inline UlpProxyBase* getUlpProxy() { return mUlp; }
+    inline void* getOwner() { return mOwner; }
+    inline bool hasAgpsExtendedCapabilities() {
+        return mContext->hasAgpsExtendedCapabilities();
+    }
+    inline bool hasCPIExtendedCapabilities() {
+        return mContext->hasCPIExtendedCapabilities();
+    }
+    inline const MsgTask* getMsgTask() { return mMsgTask; }
+
+    inline enum loc_api_adapter_err
+        startFix()
+    {
+        return mLocApi->startFix(mFixCriteria);
+    }
+    inline enum loc_api_adapter_err
+        stopFix()
+    {
+        return mLocApi->stopFix();
+    }
+    inline enum loc_api_adapter_err
+        deleteAidingData(GpsAidingData f)
+    {
+        return mLocApi->deleteAidingData(f);
+    }
+    inline enum loc_api_adapter_err
+        enableData(int enable)
+    {
+        return mLocApi->enableData(enable);
+    }
+    inline enum loc_api_adapter_err
+        setAPN(char* apn, int len)
+    {
+        return mLocApi->setAPN(apn, len);
+    }
+    inline enum loc_api_adapter_err
+        injectPosition(double latitude, double longitude, float accuracy)
+    {
+        return mLocApi->injectPosition(latitude, longitude, accuracy);
+    }
+    inline enum loc_api_adapter_err
+        setTime(GpsUtcTime time, int64_t timeReference, int uncertainty)
+    {
+        return mLocApi->setTime(time, timeReference, uncertainty);
+    }
+    inline enum loc_api_adapter_err
+        setXtraData(char* data, int length)
+    {
+        return mLocApi->setXtraData(data, length);
+    }
+    inline enum loc_api_adapter_err
+        requestXtraServer()
+    {
+        return mLocApi->requestXtraServer();
+    }
+    inline enum loc_api_adapter_err
+        atlOpenStatus(int handle, int is_succ, char* apn, AGpsBearerType bearer, AGpsType agpsType)
+    {
+        return mLocApi->atlOpenStatus(handle, is_succ, apn, bearer, agpsType);
+    }
+    inline enum loc_api_adapter_err
+        atlCloseStatus(int handle, int is_succ)
+    {
+        return mLocApi->atlCloseStatus(handle, is_succ);
+    }
+    inline enum loc_api_adapter_err
+        setPositionMode(const LocPosMode *posMode)
+    {
+        if (NULL != posMode) {
+            mFixCriteria = *posMode;
+        }
+        return mLocApi->setPositionMode(mFixCriteria);
+    }
+    inline enum loc_api_adapter_err
+        setServer(const char* url, int len)
+    {
+        return mLocApi->setServer(url, len);
+    }
+    inline enum loc_api_adapter_err
+        setServer(unsigned int ip, int port,
+                  LocServerType type)
+    {
+        return mLocApi->setServer(ip, port, type);
+    }
+    inline enum loc_api_adapter_err
+        informNiResponse(GpsUserResponseType userResponse, const void* passThroughData)
+    {
+        return mLocApi->informNiResponse(userResponse, passThroughData);
+    }
+    inline enum loc_api_adapter_err
+        setSUPLVersion(uint32_t version)
+    {
+        return mLocApi->setSUPLVersion(version);
+    }
+    inline enum loc_api_adapter_err
+        setLPPConfig(uint32_t profile)
+    {
+        return mLocApi->setLPPConfig(profile);
+    }
+    inline enum loc_api_adapter_err
+        setSensorControlConfig(int sensorUsage, int sensorProvider)
+    {
+        return mLocApi->setSensorControlConfig(sensorUsage, sensorProvider);
+    }
+    inline enum loc_api_adapter_err
+        setSensorProperties(bool gyroBiasVarianceRandomWalk_valid, float gyroBiasVarianceRandomWalk,
+                            bool accelBiasVarianceRandomWalk_valid, float accelBiasVarianceRandomWalk,
+                            bool angleBiasVarianceRandomWalk_valid, float angleBiasVarianceRandomWalk,
+                            bool rateBiasVarianceRandomWalk_valid, float rateBiasVarianceRandomWalk,
+                            bool velocityBiasVarianceRandomWalk_valid, float velocityBiasVarianceRandomWalk)
+    {
+        return mLocApi->setSensorProperties(gyroBiasVarianceRandomWalk_valid, gyroBiasVarianceRandomWalk,
+                                           accelBiasVarianceRandomWalk_valid, accelBiasVarianceRandomWalk,
+                                           angleBiasVarianceRandomWalk_valid, angleBiasVarianceRandomWalk,
+                                           rateBiasVarianceRandomWalk_valid, rateBiasVarianceRandomWalk,
+                                           velocityBiasVarianceRandomWalk_valid, velocityBiasVarianceRandomWalk);
+    }
+    inline virtual enum loc_api_adapter_err
+        setSensorPerfControlConfig(int controlMode, int accelSamplesPerBatch, int accelBatchesPerSec,
+                            int gyroSamplesPerBatch, int gyroBatchesPerSec,
+                            int accelSamplesPerBatchHigh, int accelBatchesPerSecHigh,
+                            int gyroSamplesPerBatchHigh, int gyroBatchesPerSecHigh, int algorithmConfig)
+    {
+        return mLocApi->setSensorPerfControlConfig(controlMode, accelSamplesPerBatch, accelBatchesPerSec,
+                                                  gyroSamplesPerBatch, gyroBatchesPerSec,
+                                                  accelSamplesPerBatchHigh, accelBatchesPerSecHigh,
+                                                  gyroSamplesPerBatchHigh, gyroBatchesPerSecHigh,
+                                                  algorithmConfig);
+    }
+    inline virtual enum loc_api_adapter_err
+        setExtPowerConfig(int isBatteryCharging)
+    {
+        return mLocApi->setExtPowerConfig(isBatteryCharging);
+    }
+    inline virtual enum loc_api_adapter_err
+        setAGLONASSProtocol(unsigned long aGlonassProtocol)
+    {
+        return mLocApi->setAGLONASSProtocol(aGlonassProtocol);
+    }
+    inline virtual int initDataServiceClient()
+    {
+        return mLocApi->initDataServiceClient();
+    }
+    inline virtual int openAndStartDataCall()
+    {
+        return mLocApi->openAndStartDataCall();
+    }
+    inline virtual void stopDataCall()
+    {
+        mLocApi->stopDataCall();
+    }
+    inline virtual void closeDataCall()
+    {
+        mLocApi->closeDataCall();
+    }
+    inline enum loc_api_adapter_err
+        getZpp(GpsLocation &zppLoc, LocPosTechMask &tech_mask)
+    {
+        return mLocApi->getBestAvailableZppFix(zppLoc, tech_mask);
+    }
+
+    inline virtual void installAGpsCert(const DerEncodedCertificate* pData,
+                                        size_t length,
+                                        uint32_t slotBitMask)
+    {
+        mLocApi->installAGpsCert(pData, length, slotBitMask);
+    }
+
+    virtual void handleEngineDownEvent();
+    virtual void handleEngineUpEvent();
+    virtual void reportPosition(UlpLocation &location,
+                                GpsLocationExtended &locationExtended,
+                                void* locationExt,
+                                enum loc_sess_status status,
+                                LocPosTechMask loc_technology_mask);
+    virtual void reportSv(GpsSvStatus &svStatus,
+                          GpsLocationExtended &locationExtended,
+                          void* svExt);
+    virtual void reportStatus(GpsStatusValue status);
+    virtual void reportNmea(const char* nmea, int length);
+    virtual bool reportXtraServer(const char* url1, const char* url2,
+                                  const char* url3, const int maxlength);
+    virtual bool requestXtraData();
+    virtual bool requestTime();
+    virtual bool requestATL(int connHandle, AGpsType agps_type);
+    virtual bool releaseATL(int connHandle);
+    virtual bool requestNiNotify(GpsNiNotification &notify, const void* data);
+    virtual bool requestSuplES(int connHandle);
+    virtual bool reportDataCallOpened();
+    virtual bool reportDataCallClosed();
+    virtual void reportGpsMeasurementData(GpsData &gpsMeasurementData);
+
+    inline const LocPosMode& getPositionMode() const
+    {return mFixCriteria;}
+    inline virtual bool isInSession()
+    { return mNavigating; }
+    void setInSession(bool inSession);
+
+    // Permit/prohibit power voting
+    inline void setPowerVoteRight(bool powerVoteRight) {
+        mPowerVote = powerVoteRight ? (mPowerVote | POWER_VOTE_RIGHT) :
+                                      (mPowerVote & ~POWER_VOTE_RIGHT);
+    }
+    inline bool getPowerVoteRight() const {
+        return (mPowerVote & POWER_VOTE_RIGHT) != 0 ;
+    }
+    // Set the power voting up/down and do actual operation if permitted
+    inline void setPowerVote(bool powerOn) {
+        mPowerVote = powerOn ? (mPowerVote | POWER_VOTE_VALUE) :
+                               (mPowerVote & ~POWER_VOTE_VALUE);
+        requestPowerVote();
+    }
+    inline bool getPowerVote() const {
+        return (mPowerVote & POWER_VOTE_VALUE) != 0 ;
+    }
+    // Do power voting according to last settings if permitted
+    void requestPowerVote();
+
+    /*Values for lock
+      1 = Do not lock any position sessions
+      2 = Lock MI position sessions
+      3 = Lock MT position sessions
+      4 = Lock all position sessions
+    */
+    inline int setGpsLock(LOC_GPS_LOCK_MASK lock)
+    {
+        return mLocApi->setGpsLock(lock);
+    }
+
+    int setGpsLockMsg(LOC_GPS_LOCK_MASK lock);
+
+    /*
+      Returns
+      Current value of GPS lock on success
+      -1 on failure
+     */
+    inline int getGpsLock()
+    {
+        return mLocApi->getGpsLock();
+    }
+
+    /*
+      Update Registration Mask
+     */
+    void updateRegistrationMask(LOC_API_ADAPTER_EVENT_MASK_T event,
+                                loc_registration_mask_status isEnabled);
+
+    /*
+      Set Gnss Constellation Config
+     */
+    bool gnssConstellationConfig();
+};
+
+#endif //LOC_API_ENG_ADAPTER_H
diff --git a/msm8974/loc_api/libloc_api_50001/Makefile.am b/msm8974/loc_api/libloc_api_50001/Makefile.am
new file mode 100644
index 0000000..2374357
--- /dev/null
+++ b/msm8974/loc_api/libloc_api_50001/Makefile.am
@@ -0,0 +1,76 @@
+AM_CFLAGS = \
+     -I../../utils \
+     -I../../platform_lib_abstractions \
+     -fno-short-enums \
+     -DFEATURE_GNSS_BIT_API
+
+libloc_adapter_so_la_SOURCES = loc_eng_log.cpp LocEngAdapter.cpp
+
+if USE_GLIB
+libloc_adapter_so_la_CFLAGS = -DUSE_GLIB $(AM_CFLAGS) @GLIB_CFLAGS@
+libloc_adapter_so_la_LDFLAGS = -lstdc++ -lpthread @GLIB_LIBS@ -shared -version-info 1:0:0
+libloc_adapter_so_la_CPPFLAGS = -DUSE_GLIB $(AM_CFLAGS) $(AM_CPPFLAGS) @GLIB_CFLAGS@
+else
+libloc_adapter_so_la_CFLAGS = $(AM_CFLAGS)
+libloc_adapter_so_la_LDFLAGS = -lpthread -shared -version-info 1:0:0
+libloc_adapter_so_la_CPPFLAGS = $(AM_CFLAGS) $(AM_CPPFLAGS)
+endif
+libloc_adapter_so_la_LIBADD = -lstdc++ -lcutils ../../utils/libgps_utils_so.la
+
+
+libloc_eng_so_la_SOURCES = \
+    loc_eng.cpp \
+    loc_eng_agps.cpp \
+    loc_eng_xtra.cpp \
+    loc_eng_ni.cpp \
+    loc_eng_log.cpp \
+    loc_eng_dmn_conn.cpp \
+    loc_eng_dmn_conn_handler.cpp \
+    loc_eng_dmn_conn_thread_helper.c \
+    loc_eng_dmn_conn_glue_msg.c \
+    loc_eng_dmn_conn_glue_pipe.c
+
+
+if USE_GLIB
+libloc_eng_so_la_CFLAGS = -DUSE_GLIB $(AM_CFLAGS) @GLIB_CFLAGS@
+libloc_eng_so_la_LDFLAGS = -lstdc++ -lpthread @GLIB_LIBS@ -shared -version-info 1:0:0
+libloc_eng_so_la_CPPFLAGS = -DUSE_GLIB $(AM_CFLAGS) $(AM_CPPFLAGS) @GLIB_CFLAGS@
+else
+libloc_eng_so_la_CFLAGS = $(AM_CFLAGS)
+libloc_eng_so_la_LDFLAGS = -lpthread -shared -version-info 1:0:0
+libloc_eng_so_la_CPPFLAGS = $(AM_CFLAGS) $(AM_CPPFLAGS)
+endif
+
+libloc_eng_so_la_LIBADD = -lstdc++ -lcutils -ldl ../../utils/libgps_utils_so.la libloc_adapter_so.la
+
+
+libgps_default_so_la_SOURCES = \
+      loc.cpp \
+      gps.c
+
+if USE_GLIB
+libgps_default_so_la_CFLAGS = -DUSE_GLIB $(AM_CFLAGS) @GLIB_CFLAGS@
+libgps_default_so_la_LDFLAGS = -lstdc++ -lpthread @GLIB_LIBS@ -shared -version-info 1:0:0
+libgps_default_so_la_CPPFLAGS = -DUSE_GLIB $(AM_CFLAGS) $(AM_CPPFLAGS) @GLIB_CFLAGS@
+else
+libgps_default_so_la_CFLAGS = $(AM_CFLAGS)
+libgps_default_so_la_LDFLAGS = -lpthread -shared -version-info 1:0:0
+libgps_default_so_la_CPPFLAGS = $(AM_CFLAGS) $(AM_CPPFLAGS)
+endif
+
+libgps_default_so_la_LIBADD = -lstdc++ -lcutils ../../utils/libgps_utils_so.la -ldl libloc_eng_so.la
+
+library_include_HEADERS = \
+   LocEngAdapter.h \
+   loc.h \
+   loc_eng.h \
+   loc_eng_xtra.h \
+   loc_eng_ni.h \
+   loc_eng_agps.h \
+   loc_eng_msg.h \
+   loc_eng_log.h
+
+library_includedir = $(pkgincludedir)/libloc_api_50001
+
+#Create and Install libraries
+lib_LTLIBRARIES = libloc_adapter_so.la libloc_eng_so.la libgps_default_so.la
diff --git a/msm8974/loc_api/libloc_api_50001/gps.c b/msm8974/loc_api/libloc_api_50001/gps.c
new file mode 100644
index 0000000..46596aa
--- /dev/null
+++ b/msm8974/loc_api/libloc_api_50001/gps.c
@@ -0,0 +1,73 @@
+/* Copyright (c) 2011 The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <hardware/gps.h>
+
+#include <stdlib.h>
+#include <string.h>
+
+extern const GpsInterface* get_gps_interface();
+
+const GpsInterface* gps__get_gps_interface(struct gps_device_t* dev)
+{
+    return get_gps_interface();
+}
+
+static int open_gps(const struct hw_module_t* module, char const* name,
+        struct hw_device_t** device)
+{
+    struct gps_device_t *dev = (struct gps_device_t *) malloc(sizeof(struct gps_device_t));
+
+    if(dev == NULL)
+        return -1;
+
+    memset(dev, 0, sizeof(*dev));
+
+    dev->common.tag = HARDWARE_DEVICE_TAG;
+    dev->common.version = 0;
+    dev->common.module = (struct hw_module_t*)module;
+    dev->get_gps_interface = gps__get_gps_interface;
+
+    *device = (struct hw_device_t*)dev;
+    return 0;
+}
+
+static struct hw_module_methods_t gps_module_methods = {
+    .open = open_gps
+};
+
+struct hw_module_t HAL_MODULE_INFO_SYM = {
+    .tag = HARDWARE_MODULE_TAG,
+    .module_api_version = 1,
+    .hal_api_version = 0,
+    .id = GPS_HARDWARE_MODULE_ID,
+    .name = "loc_api GPS Module",
+    .author = "Qualcomm USA, Inc.",
+    .methods = &gps_module_methods,
+};
diff --git a/msm8974/loc_api/libloc_api_50001/loc.cpp b/msm8974/loc_api/libloc_api_50001/loc.cpp
new file mode 100644
index 0000000..f6630d5
--- /dev/null
+++ b/msm8974/loc_api/libloc_api_50001/loc.cpp
@@ -0,0 +1,1184 @@
+/* Copyright (c) 2011-2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#define LOG_NDDEBUG 0
+#define LOG_TAG "LocSvc_afw"
+
+#include <hardware/gps.h>
+#include <gps_extended.h>
+#include <loc_eng.h>
+#include <loc_target.h>
+#include <loc_log.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <dlfcn.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <LocDualContext.h>
+#include <cutils/properties.h>
+
+using namespace loc_core;
+
+//Globals defns
+static gps_location_callback gps_loc_cb = NULL;
+static gps_sv_status_callback gps_sv_cb = NULL;
+static agps_status_callback agps_status_cb = NULL;
+
+static void local_loc_cb(UlpLocation* location, void* locExt);
+static void local_sv_cb(GpsSvStatus* sv_status, void* svExt);
+static void loc_agps_status_cb(AGpsStatus* status);
+
+static const GpsGeofencingInterface* get_geofence_interface(void);
+
+// Function declarations for sLocEngInterface
+static int  loc_init(GpsCallbacks* callbacks);
+static int  loc_start();
+static int  loc_stop();
+static void loc_cleanup();
+static int  loc_inject_time(GpsUtcTime time, int64_t timeReference, int uncertainty);
+static int  loc_inject_location(double latitude, double longitude, float accuracy);
+static void loc_delete_aiding_data(GpsAidingData f);
+static int  loc_set_position_mode(GpsPositionMode mode, GpsPositionRecurrence recurrence,
+                                  uint32_t min_interval, uint32_t preferred_accuracy,
+                                  uint32_t preferred_time);
+static const void* loc_get_extension(const char* name);
+static void loc_close_mdm_node();
+// Defines the GpsInterface in gps.h
+static const GpsInterface sLocEngInterface =
+{
+   sizeof(GpsInterface),
+   loc_init,
+   loc_start,
+   loc_stop,
+   loc_cleanup,
+   loc_inject_time,
+   loc_inject_location,
+   loc_delete_aiding_data,
+   loc_set_position_mode,
+   loc_get_extension
+};
+
+// Function declarations for sLocEngAGpsInterface
+static void loc_agps_init(AGpsCallbacks* callbacks);
+static int  loc_agps_open(const char* apn);
+static int  loc_agps_closed();
+static int  loc_agps_open_failed();
+static int  loc_agps_set_server(AGpsType type, const char *hostname, int port);
+static int  loc_agps_open_with_apniptype( const char* apn, ApnIpType apnIpType);
+
+static const AGpsInterface sLocEngAGpsInterface =
+{
+   sizeof(AGpsInterface),
+   loc_agps_init,
+   loc_agps_open,
+   loc_agps_closed,
+   loc_agps_open_failed,
+   loc_agps_set_server,
+   loc_agps_open_with_apniptype
+};
+
+static int loc_xtra_init(GpsXtraCallbacks* callbacks);
+static int loc_xtra_inject_data(char* data, int length);
+
+static const GpsXtraInterface sLocEngXTRAInterface =
+{
+    sizeof(GpsXtraInterface),
+    loc_xtra_init,
+    loc_xtra_inject_data
+};
+
+static void loc_ni_init(GpsNiCallbacks *callbacks);
+static void loc_ni_respond(int notif_id, GpsUserResponseType user_response);
+
+static const GpsNiInterface sLocEngNiInterface =
+{
+   sizeof(GpsNiInterface),
+   loc_ni_init,
+   loc_ni_respond,
+};
+
+// For shutting down MDM in fusion devices
+static int mdm_fd = -1;
+static int loc_gps_measurement_init(GpsMeasurementCallbacks* callbacks);
+static void loc_gps_measurement_close();
+
+static const GpsMeasurementInterface sLocEngGpsMeasurementInterface =
+{
+    sizeof(GpsMeasurementInterface),
+    loc_gps_measurement_init,
+    loc_gps_measurement_close
+};
+
+static void loc_agps_ril_init( AGpsRilCallbacks* callbacks );
+static void loc_agps_ril_set_ref_location(const AGpsRefLocation *agps_reflocation, size_t sz_struct);
+static void loc_agps_ril_set_set_id(AGpsSetIDType type, const char* setid);
+static void loc_agps_ril_ni_message(uint8_t *msg, size_t len);
+static void loc_agps_ril_update_network_state(int connected, int type, int roaming, const char* extra_info);
+static void loc_agps_ril_update_network_availability(int avaiable, const char* apn);
+
+static const AGpsRilInterface sLocEngAGpsRilInterface =
+{
+   sizeof(AGpsRilInterface),
+   loc_agps_ril_init,
+   loc_agps_ril_set_ref_location,
+   loc_agps_ril_set_set_id,
+   loc_agps_ril_ni_message,
+   loc_agps_ril_update_network_state,
+   loc_agps_ril_update_network_availability
+};
+
+static int loc_agps_install_certificates(const DerEncodedCertificate* certificates,
+                                         size_t length);
+static int loc_agps_revoke_certificates(const Sha1CertificateFingerprint* fingerprints,
+                                        size_t length);
+
+static const SuplCertificateInterface sLocEngAGpsCertInterface =
+{
+    sizeof(SuplCertificateInterface),
+    loc_agps_install_certificates,
+    loc_agps_revoke_certificates
+};
+
+static void loc_configuration_update(const char* config_data, int32_t length);
+
+static const GnssConfigurationInterface sLocEngConfigInterface =
+{
+    sizeof(GnssConfigurationInterface),
+    loc_configuration_update
+};
+
+static loc_eng_data_s_type loc_afw_data;
+static int gss_fd = -1;
+
+/*===========================================================================
+FUNCTION    gps_get_hardware_interface
+
+DESCRIPTION
+   Returns the GPS hardware interaface based on LOC API
+   if GPS is enabled.
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0: success
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+const GpsInterface* gps_get_hardware_interface ()
+{
+    ENTRY_LOG_CALLFLOW();
+    const GpsInterface* ret_val;
+
+    char propBuf[PROPERTY_VALUE_MAX];
+
+    loc_eng_read_config();
+
+    // check to see if GPS should be disabled
+    property_get("gps.disable", propBuf, "");
+    if (propBuf[0] == '1')
+    {
+        LOC_LOGD("gps_get_interface returning NULL because gps.disable=1\n");
+        ret_val = NULL;
+    } else {
+        ret_val = &sLocEngInterface;
+    }
+
+    loc_eng_read_config();
+
+    EXIT_LOG(%p, ret_val);
+    return ret_val;
+}
+
+// for gps.c
+extern "C" const GpsInterface* get_gps_interface()
+{
+    unsigned int target = TARGET_DEFAULT;
+    loc_eng_read_config();
+
+    target = loc_get_target();
+    LOC_LOGD("Target name check returned %s", loc_get_target_name(target));
+
+    int gnssType = getTargetGnssType(target);
+    switch (gnssType)
+    {
+    case GNSS_GSS:
+        //APQ8064
+        gps_conf.CAPABILITIES &= ~(GPS_CAPABILITY_MSA | GPS_CAPABILITY_MSB);
+        gss_fd = open("/dev/gss", O_RDONLY);
+        if (gss_fd < 0) {
+            LOC_LOGE("GSS open failed: %s\n", strerror(errno));
+        }
+        else {
+            LOC_LOGD("GSS open success! CAPABILITIES %0lx\n",
+                     gps_conf.CAPABILITIES);
+        }
+        break;
+    case GNSS_NONE:
+        //MPQ8064
+        LOC_LOGE("No GPS HW on this target. Not returning interface.");
+        return NULL;
+    case GNSS_QCA1530:
+        // qca1530 chip is present
+        gps_conf.CAPABILITIES &= ~(GPS_CAPABILITY_MSA | GPS_CAPABILITY_MSB);
+        LOC_LOGD("qca1530 present: CAPABILITIES %0lx\n", gps_conf.CAPABILITIES);
+        break;
+    }
+    return &sLocEngInterface;
+}
+
+/*===========================================================================
+FUNCTION    loc_init
+
+DESCRIPTION
+   Initialize the location engine, this include setting up global datas
+   and registers location engien with loc api service.
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0: success
+
+SIDE EFFECTS
+   N/Ax
+
+===========================================================================*/
+static int loc_init(GpsCallbacks* callbacks)
+{
+    int retVal = -1;
+    int i = 0;
+    ENTRY_LOG();
+    LOC_API_ADAPTER_EVENT_MASK_T event;
+
+    if (NULL == callbacks) {
+        LOC_LOGE("loc_init failed. cb = NULL\n");
+        EXIT_LOG(%d, retVal);
+        return retVal;
+    }
+
+    event = LOC_API_ADAPTER_BIT_PARSED_POSITION_REPORT |
+            LOC_API_ADAPTER_BIT_SATELLITE_REPORT |
+            LOC_API_ADAPTER_BIT_LOCATION_SERVER_REQUEST |
+            LOC_API_ADAPTER_BIT_ASSISTANCE_DATA_REQUEST |
+            LOC_API_ADAPTER_BIT_IOCTL_REPORT |
+            LOC_API_ADAPTER_BIT_STATUS_REPORT |
+            LOC_API_ADAPTER_BIT_NMEA_1HZ_REPORT |
+            LOC_API_ADAPTER_BIT_NI_NOTIFY_VERIFY_REQUEST;
+
+    LocCallbacks clientCallbacks = {local_loc_cb, /* location_cb */
+                                    callbacks->status_cb, /* status_cb */
+                                    local_sv_cb, /* sv_status_cb */
+                                    callbacks->nmea_cb, /* nmea_cb */
+                                    callbacks->set_capabilities_cb, /* set_capabilities_cb */
+                                    callbacks->acquire_wakelock_cb, /* acquire_wakelock_cb */
+                                    callbacks->release_wakelock_cb, /* release_wakelock_cb */
+                                    callbacks->create_thread_cb, /* create_thread_cb */
+                                    NULL, /* location_ext_parser */
+                                    NULL, /* sv_ext_parser */
+                                    callbacks->request_utc_time_cb, /* request_utc_time_cb */
+                                    loc_close_mdm_node  /*loc_shutdown_cb*/};
+
+    gps_loc_cb = callbacks->location_cb;
+    gps_sv_cb = callbacks->sv_status_cb;
+
+    retVal = loc_eng_init(loc_afw_data, &clientCallbacks, event, NULL);
+    loc_afw_data.adapter->mSupportsAgpsRequests = !loc_afw_data.adapter->hasAgpsExtendedCapabilities();
+    loc_afw_data.adapter->mSupportsPositionInjection = !loc_afw_data.adapter->hasCPIExtendedCapabilities();
+    loc_afw_data.adapter->setGpsLockMsg(0);
+    loc_afw_data.adapter->requestUlp(gps_conf.CAPABILITIES);
+
+    if(retVal) {
+        LOC_LOGE("loc_eng_init() fail!");
+        goto err;
+    }
+
+    loc_afw_data.adapter->setPowerVoteRight(loc_get_target() == TARGET_QCA1530);
+    loc_afw_data.adapter->setPowerVote(true);
+
+    LOC_LOGD("loc_eng_init() success!");
+
+#ifdef PLATFORM_MSM8084
+    if (mdm_fd < 0) {
+        int (*open_first_external_modem)(void);
+        const char *name = "libdetectmodem.so";
+        const char *func = "open_first_external_modem";
+        const char *error;
+
+        void *lib = ::dlopen(name, RTLD_NOW);
+        error = ::dlerror();
+        if (!lib) {
+            LOC_LOGE("%s: could not find %s: %s", __func__, name, error);
+            goto err;
+        }
+
+        open_first_external_modem = NULL;
+        *(void **)(&open_first_external_modem) = ::dlsym(lib, func);
+        error = ::dlerror();
+
+        if (!open_first_external_modem) {
+            LOC_LOGE("%s: could not find symbol %s in %s: %s",
+                     __func__, func, name, error);
+        }
+        else {
+            errno = 0;
+            mdm_fd = open_first_external_modem();
+            if (mdm_fd < 0) {
+                LOC_LOGE("%s: %s failed: %s\n", __func__, func, strerror(errno));
+            }
+            else {
+                LOC_LOGD("%s: external power up modem opened successfully\n", __func__);
+            }
+        }
+        dlclose(lib);
+    } else {
+        LOC_LOGD("powerup_node has been opened before");
+    }
+#endif //PLATFORM_MSM8084
+err:
+    EXIT_LOG(%d, retVal);
+    return retVal;
+}
+
+/*===========================================================================
+FUNCTION    loc_close_mdm_node
+
+DESCRIPTION
+   closes mdm_fd which is the modem powerup node obtained in loc_init
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   None
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static void loc_close_mdm_node()
+{
+    ENTRY_LOG();
+    if (mdm_fd >= 0) {
+        LOC_LOGD("closing the powerup node");
+        close(mdm_fd);
+        mdm_fd = -1;
+        LOC_LOGD("finished closing the powerup node");
+    } else {
+        LOC_LOGD("powerup node has not been opened yet.");
+    }
+
+    EXIT_LOG(%s, VOID_RET);
+}
+
+/*===========================================================================
+FUNCTION    loc_cleanup
+
+DESCRIPTION
+   Cleans location engine. The location client handle will be released.
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   None
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static void loc_cleanup()
+{
+    ENTRY_LOG();
+
+    loc_afw_data.adapter->setPowerVote(false);
+    loc_afw_data.adapter->setGpsLockMsg(gps_conf.GPS_LOCK);
+
+    loc_eng_cleanup(loc_afw_data);
+    loc_close_mdm_node();
+    gps_loc_cb = NULL;
+    gps_sv_cb = NULL;
+
+    EXIT_LOG(%s, VOID_RET);
+}
+
+/*===========================================================================
+FUNCTION    loc_start
+
+DESCRIPTION
+   Starts the tracking session
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0: success
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static int loc_start()
+{
+    ENTRY_LOG();
+    int ret_val = loc_eng_start(loc_afw_data);
+
+    EXIT_LOG(%d, ret_val);
+    return ret_val;
+}
+
+/*===========================================================================
+FUNCTION    loc_stop
+
+DESCRIPTION
+   Stops the tracking session
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0: success
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static int loc_stop()
+{
+    ENTRY_LOG();
+    int ret_val = -1;
+    ret_val = loc_eng_stop(loc_afw_data);
+
+    EXIT_LOG(%d, ret_val);
+    return ret_val;
+}
+
+/*===========================================================================
+FUNCTION    loc_set_position_mode
+
+DESCRIPTION
+   Sets the mode and fix frequency for the tracking session.
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0: success
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static int  loc_set_position_mode(GpsPositionMode mode,
+                                  GpsPositionRecurrence recurrence,
+                                  uint32_t min_interval,
+                                  uint32_t preferred_accuracy,
+                                  uint32_t preferred_time)
+{
+    ENTRY_LOG();
+    int ret_val = -1;
+    LocPositionMode locMode;
+    switch (mode) {
+    case GPS_POSITION_MODE_MS_BASED:
+        locMode = LOC_POSITION_MODE_MS_BASED;
+        break;
+    case GPS_POSITION_MODE_MS_ASSISTED:
+        locMode = LOC_POSITION_MODE_MS_ASSISTED;
+        break;
+    default:
+        locMode = LOC_POSITION_MODE_STANDALONE;
+        break;
+    }
+
+    LocPosMode params(locMode, recurrence, min_interval,
+                      preferred_accuracy, preferred_time, NULL, NULL);
+    ret_val = loc_eng_set_position_mode(loc_afw_data, params);
+
+    EXIT_LOG(%d, ret_val);
+    return ret_val;
+}
+
+/*===========================================================================
+FUNCTION    loc_inject_time
+
+DESCRIPTION
+   This is used by Java native function to do time injection.
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static int loc_inject_time(GpsUtcTime time, int64_t timeReference, int uncertainty)
+{
+    ENTRY_LOG();
+    int ret_val = 0;
+
+    ret_val = loc_eng_inject_time(loc_afw_data, time,
+                                  timeReference, uncertainty);
+
+    EXIT_LOG(%d, ret_val);
+    return ret_val;
+}
+
+
+/*===========================================================================
+FUNCTION    loc_inject_location
+
+DESCRIPTION
+   This is used by Java native function to do location injection.
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0          : Successful
+   error code : Failure
+
+SIDE EFFECTS
+   N/A
+===========================================================================*/
+static int loc_inject_location(double latitude, double longitude, float accuracy)
+{
+    static bool initialized = false;
+    static bool enable_cpi = true;
+    ENTRY_LOG();
+
+    if (accuracy < 1000)
+    {
+      accuracy = 1000;
+    }
+
+    int ret_val = 0;
+    ret_val = loc_eng_inject_location(loc_afw_data, latitude, longitude, accuracy);
+
+    if(!initialized)
+    {
+        char value[PROPERTY_VALUE_MAX];
+        memset(value, 0, sizeof(value));
+        (void)property_get("persist.gps.qc_nlp_in_use", value, "0");
+        if(0 == strcmp(value, "1"))
+        {
+            enable_cpi = false;
+            LOC_LOGI("GPS HAL coarse position injection disabled");
+        }
+        else
+        {
+            LOC_LOGI("GPS HAL coarse position injection enabled");
+        }
+        initialized = true;
+    }
+
+    if(enable_cpi)
+    {
+      ret_val = loc_eng_inject_location(loc_afw_data, latitude, longitude, accuracy);
+    }
+    EXIT_LOG(%d, ret_val);
+    return ret_val;
+}
+
+
+/*===========================================================================
+FUNCTION    loc_delete_aiding_data
+
+DESCRIPTION
+   This is used by Java native function to delete the aiding data. The function
+   updates the global variable for the aiding data to be deleted. If the GPS
+   engine is off, the aiding data will be deleted. Otherwise, the actual action
+   will happen when gps engine is turned off.
+
+DEPENDENCIES
+   Assumes the aiding data type specified in GpsAidingData matches with
+   LOC API specification.
+
+RETURN VALUE
+   None
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static void loc_delete_aiding_data(GpsAidingData f)
+{
+    ENTRY_LOG();
+    loc_eng_delete_aiding_data(loc_afw_data, f);
+
+    EXIT_LOG(%s, VOID_RET);
+}
+
+const GpsGeofencingInterface* get_geofence_interface(void)
+{
+    ENTRY_LOG();
+    void *handle;
+    const char *error;
+    typedef const GpsGeofencingInterface* (*get_gps_geofence_interface_function) (void);
+    get_gps_geofence_interface_function get_gps_geofence_interface;
+    static const GpsGeofencingInterface* geofence_interface = NULL;
+
+    dlerror();    /* Clear any existing error */
+
+    handle = dlopen ("libgeofence.so", RTLD_NOW);
+
+    if (!handle)
+    {
+        if ((error = dlerror()) != NULL)  {
+            LOC_LOGE ("%s, dlopen for libgeofence.so failed, error = %s\n", __func__, error);
+           }
+        goto exit;
+    }
+    dlerror();    /* Clear any existing error */
+    get_gps_geofence_interface = (get_gps_geofence_interface_function)dlsym(handle, "gps_geofence_get_interface");
+    if ((error = dlerror()) != NULL)  {
+        LOC_LOGE ("%s, dlsym for get_gps_geofence_interface failed, error = %s\n", __func__, error);
+        goto exit;
+     }
+
+    geofence_interface = get_gps_geofence_interface();
+
+exit:
+    EXIT_LOG(%d, geofence_interface == NULL);
+    return geofence_interface;
+}
+/*===========================================================================
+FUNCTION    loc_get_extension
+
+DESCRIPTION
+   Get the gps extension to support XTRA.
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   The GPS extension interface.
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+const void* loc_get_extension(const char* name)
+{
+    ENTRY_LOG();
+    const void* ret_val = NULL;
+
+   LOC_LOGD("%s:%d] For Interface = %s\n",__func__, __LINE__, name);
+   if (strcmp(name, GPS_XTRA_INTERFACE) == 0)
+   {
+       ret_val = &sLocEngXTRAInterface;
+   }
+   else if (strcmp(name, AGPS_INTERFACE) == 0)
+   {
+       ret_val = &sLocEngAGpsInterface;
+   }
+   else if (strcmp(name, GPS_NI_INTERFACE) == 0)
+   {
+       ret_val = &sLocEngNiInterface;
+   }
+   else if (strcmp(name, AGPS_RIL_INTERFACE) == 0)
+   {
+       char baseband[PROPERTY_VALUE_MAX];
+       property_get("ro.baseband", baseband, "msm");
+       if (strcmp(baseband, "csfb") == 0)
+       {
+           ret_val = &sLocEngAGpsRilInterface;
+       }
+   }
+   else if (strcmp(name, GPS_GEOFENCING_INTERFACE) == 0)
+   {
+       if ((gps_conf.CAPABILITIES | GPS_CAPABILITY_GEOFENCING) == gps_conf.CAPABILITIES ){
+           ret_val = get_geofence_interface();
+       }
+   }
+   else if (strcmp(name, SUPL_CERTIFICATE_INTERFACE) == 0)
+   {
+       ret_val = &sLocEngAGpsCertInterface;
+   }
+   else if (strcmp(name, GNSS_CONFIGURATION_INTERFACE) == 0)
+   {
+       ret_val = &sLocEngConfigInterface;
+   }
+   else if (strcmp(name, GPS_MEASUREMENT_INTERFACE) == 0)
+   {
+       ret_val = &sLocEngGpsMeasurementInterface;
+   }
+   else
+   {
+      LOC_LOGE ("get_extension: Invalid interface passed in\n");
+   }
+    EXIT_LOG(%p, ret_val);
+    return ret_val;
+}
+
+/*===========================================================================
+FUNCTION    loc_agps_init
+
+DESCRIPTION
+   Initialize the AGps interface.
+
+DEPENDENCIES
+   NONE
+
+RETURN VALUE
+   0
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static void loc_agps_init(AGpsCallbacks* callbacks)
+{
+    ENTRY_LOG();
+    if (agps_status_cb == NULL) {
+        agps_status_cb = callbacks->status_cb;
+        callbacks->status_cb = loc_agps_status_cb;
+    }
+    loc_eng_agps_init(loc_afw_data, (AGpsExtCallbacks*)callbacks);
+    EXIT_LOG(%s, VOID_RET);
+}
+
+/*===========================================================================
+FUNCTION    loc_agps_open
+
+DESCRIPTION
+   This function is called when on-demand data connection opening is successful.
+It should inform ARM 9 about the data open result.
+
+DEPENDENCIES
+   NONE
+
+RETURN VALUE
+   0
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static int loc_agps_open(const char* apn)
+{
+    ENTRY_LOG();
+    AGpsType agpsType = AGPS_TYPE_SUPL;
+    AGpsBearerType bearerType = AGPS_APN_BEARER_IPV4;
+    int ret_val = loc_eng_agps_open(loc_afw_data, agpsType, apn, bearerType);
+
+    EXIT_LOG(%d, ret_val);
+    return ret_val;
+}
+
+/*===========================================================================
+FUNCTION    loc_agps_open_with_apniptype
+
+DESCRIPTION
+   This function is called when on-demand data connection opening is successful.
+It should inform ARM 9 about the data open result.
+
+DEPENDENCIES
+   NONE
+
+RETURN VALUE
+   0
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static int  loc_agps_open_with_apniptype(const char* apn, ApnIpType apnIpType)
+{
+    ENTRY_LOG();
+    AGpsType agpsType = AGPS_TYPE_SUPL;
+    AGpsBearerType bearerType;
+
+    switch (apnIpType) {
+        case APN_IP_IPV4:
+            bearerType = AGPS_APN_BEARER_IPV4;
+            break;
+        case APN_IP_IPV6:
+            bearerType = AGPS_APN_BEARER_IPV6;
+            break;
+        case APN_IP_IPV4V6:
+            bearerType = AGPS_APN_BEARER_IPV4V6;
+            break;
+        default:
+            bearerType = AGPS_APN_BEARER_INVALID;
+            break;
+    }
+
+    int ret_val = loc_eng_agps_open(loc_afw_data, agpsType, apn, bearerType);
+
+    EXIT_LOG(%d, ret_val);
+    return ret_val;
+}
+
+/*===========================================================================
+FUNCTION    loc_agps_closed
+
+DESCRIPTION
+   This function is called when on-demand data connection closing is done.
+It should inform ARM 9 about the data close result.
+
+DEPENDENCIES
+   NONE
+
+RETURN VALUE
+   0
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static int loc_agps_closed()
+{
+    ENTRY_LOG();
+    AGpsType agpsType = AGPS_TYPE_SUPL;
+    int ret_val = loc_eng_agps_closed(loc_afw_data, agpsType);
+
+    EXIT_LOG(%d, ret_val);
+    return ret_val;
+}
+
+/*===========================================================================
+FUNCTION    loc_agps_open_failed
+
+DESCRIPTION
+   This function is called when on-demand data connection opening has failed.
+It should inform ARM 9 about the data open result.
+
+DEPENDENCIES
+   NONE
+
+RETURN VALUE
+   0
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_agps_open_failed()
+{
+    ENTRY_LOG();
+    AGpsType agpsType = AGPS_TYPE_SUPL;
+    int ret_val = loc_eng_agps_open_failed(loc_afw_data, agpsType);
+
+    EXIT_LOG(%d, ret_val);
+    return ret_val;
+}
+
+/*===========================================================================
+FUNCTION    loc_agps_set_server
+
+DESCRIPTION
+   If loc_eng_set_server is called before loc_eng_init, it doesn't work. This
+   proxy buffers server settings and calls loc_eng_set_server when the client is
+   open.
+
+DEPENDENCIES
+   NONE
+
+RETURN VALUE
+   0
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static int loc_agps_set_server(AGpsType type, const char* hostname, int port)
+{
+    ENTRY_LOG();
+    LocServerType serverType;
+    switch (type) {
+    case AGPS_TYPE_SUPL:
+        serverType = LOC_AGPS_SUPL_SERVER;
+        break;
+    case AGPS_TYPE_C2K:
+        serverType = LOC_AGPS_CDMA_PDE_SERVER;
+        break;
+    default:
+        serverType = LOC_AGPS_SUPL_SERVER;
+    }
+    int ret_val = loc_eng_set_server_proxy(loc_afw_data, serverType, hostname, port);
+
+    EXIT_LOG(%d, ret_val);
+    return ret_val;
+}
+
+/*===========================================================================
+FUNCTIONf571
+    loc_xtra_init
+
+DESCRIPTION
+   Initialize XTRA module.
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0: success
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static int loc_xtra_init(GpsXtraCallbacks* callbacks)
+{
+    ENTRY_LOG();
+    GpsXtraExtCallbacks ext_callbacks;
+    ext_callbacks.download_request_cb = callbacks->download_request_cb;
+    ext_callbacks.create_thread_cb = callbacks->create_thread_cb;
+    ext_callbacks.report_xtra_server_cb = NULL;
+    int ret_val = loc_eng_xtra_init(loc_afw_data, &ext_callbacks);
+
+    EXIT_LOG(%d, ret_val);
+    return ret_val;
+}
+
+
+/*===========================================================================
+FUNCTION    loc_xtra_inject_data
+
+DESCRIPTION
+   Initialize XTRA module.
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0: success
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static int loc_xtra_inject_data(char* data, int length)
+{
+    ENTRY_LOG();
+    int ret_val = -1;
+    if( (data != NULL) && ((unsigned int)length <= XTRA_DATA_MAX_SIZE))
+        ret_val = loc_eng_xtra_inject_data(loc_afw_data, data, length);
+    else
+        LOC_LOGE("%s, Could not inject XTRA data. Buffer address: %p, length: %d",
+                __func__, data, length);
+    EXIT_LOG(%d, ret_val);
+    return ret_val;
+}
+
+/*===========================================================================
+FUNCTION    loc_gps_measurement_init
+
+DESCRIPTION
+   This function initializes the gps measurement interface
+
+DEPENDENCIES
+   NONE
+
+RETURN VALUE
+   None
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static int loc_gps_measurement_init(GpsMeasurementCallbacks* callbacks)
+{
+    ENTRY_LOG();
+    int ret_val = loc_eng_gps_measurement_init(loc_afw_data,
+                                               callbacks);
+
+    EXIT_LOG(%d, ret_val);
+    return ret_val;
+}
+
+/*===========================================================================
+FUNCTION    loc_gps_measurement_close
+
+DESCRIPTION
+   This function closes the gps measurement interface
+
+DEPENDENCIES
+   NONE
+
+RETURN VALUE
+   None
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static void loc_gps_measurement_close()
+{
+    ENTRY_LOG();
+    loc_eng_gps_measurement_close(loc_afw_data);
+
+    EXIT_LOG(%s, VOID_RET);
+}
+
+/*===========================================================================
+FUNCTION    loc_ni_init
+
+DESCRIPTION
+   This function initializes the NI interface
+
+DEPENDENCIES
+   NONE
+
+RETURN VALUE
+   None
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+void loc_ni_init(GpsNiCallbacks *callbacks)
+{
+    ENTRY_LOG();
+    loc_eng_ni_init(loc_afw_data,(GpsNiExtCallbacks*) callbacks);
+    EXIT_LOG(%s, VOID_RET);
+}
+
+/*===========================================================================
+FUNCTION    loc_ni_respond
+
+DESCRIPTION
+   This function sends an NI respond to the modem processor
+
+DEPENDENCIES
+   NONE
+
+RETURN VALUE
+   None
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+void loc_ni_respond(int notif_id, GpsUserResponseType user_response)
+{
+    ENTRY_LOG();
+    loc_eng_ni_respond(loc_afw_data, notif_id, user_response);
+    EXIT_LOG(%s, VOID_RET);
+}
+
+// Below stub functions are members of sLocEngAGpsRilInterface
+static void loc_agps_ril_init( AGpsRilCallbacks* callbacks ) {}
+static void loc_agps_ril_set_ref_location(const AGpsRefLocation *agps_reflocation, size_t sz_struct) {}
+static void loc_agps_ril_set_set_id(AGpsSetIDType type, const char* setid) {}
+static void loc_agps_ril_ni_message(uint8_t *msg, size_t len) {}
+static void loc_agps_ril_update_network_state(int connected, int type, int roaming, const char* extra_info) {}
+
+/*===========================================================================
+FUNCTION    loc_agps_ril_update_network_availability
+
+DESCRIPTION
+   Sets data call allow vs disallow flag to modem
+   This is the only member of sLocEngAGpsRilInterface implemented.
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0: success
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static void loc_agps_ril_update_network_availability(int available, const char* apn)
+{
+    ENTRY_LOG();
+    loc_eng_agps_ril_update_network_availability(loc_afw_data, available, apn);
+    EXIT_LOG(%s, VOID_RET);
+}
+
+static int loc_agps_install_certificates(const DerEncodedCertificate* certificates,
+                                         size_t length)
+{
+    ENTRY_LOG();
+    int ret_val = loc_eng_agps_install_certificates(loc_afw_data, certificates, length);
+    EXIT_LOG(%d, ret_val);
+    return ret_val;
+}
+static int loc_agps_revoke_certificates(const Sha1CertificateFingerprint* fingerprints,
+                                        size_t length)
+{
+    ENTRY_LOG();
+    LOC_LOGE("agps_revoke_certificates not supported");
+    int ret_val = AGPS_CERTIFICATE_ERROR_GENERIC;
+    EXIT_LOG(%d, ret_val);
+    return ret_val;
+}
+
+static void loc_configuration_update(const char* config_data, int32_t length)
+{
+    ENTRY_LOG();
+    loc_eng_configuration_update(loc_afw_data, config_data, length);
+    EXIT_LOG(%s, VOID_RET);
+}
+
+static void local_loc_cb(UlpLocation* location, void* locExt)
+{
+    ENTRY_LOG();
+    if (NULL != location) {
+        CALLBACK_LOG_CALLFLOW("location_cb - from", %d, location->position_source);
+
+        if (NULL != gps_loc_cb) {
+            gps_loc_cb(&location->gpsLocation);
+        }
+    }
+    EXIT_LOG(%s, VOID_RET);
+}
+
+static void local_sv_cb(GpsSvStatus* sv_status, void* svExt)
+{
+    ENTRY_LOG();
+    if (NULL != gps_sv_cb) {
+        CALLBACK_LOG_CALLFLOW("sv_status_cb -", %d, sv_status->num_svs);
+        gps_sv_cb(sv_status);
+    }
+    EXIT_LOG(%s, VOID_RET);
+}
+
+static void loc_agps_status_cb(AGpsStatus* status)
+{
+    ENTRY_LOG();
+
+    if (NULL != agps_status_cb) {
+        size_t realSize = sizeof(AGpsStatus);
+        LOC_LOGD("agps_status size=%d real-size=%d", status->size, realSize);
+        status->size = realSize;
+        agps_status_cb(status);
+    }
+    EXIT_LOG(%s, VOID_RET);
+}
+
diff --git a/msm8974/loc_api/libloc_api_50001/loc.h b/msm8974/loc_api/libloc_api_50001/loc.h
new file mode 100644
index 0000000..22fcbe0
--- /dev/null
+++ b/msm8974/loc_api/libloc_api_50001/loc.h
@@ -0,0 +1,68 @@
+/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __LOC_H__
+#define __LOC_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#include <ctype.h>
+#include <cutils/properties.h>
+#include <hardware/gps.h>
+#include <gps_extended.h>
+
+#define XTRA_DATA_MAX_SIZE 100000 /*bytes*/
+
+typedef void (*loc_location_cb_ext) (UlpLocation* location, void* locExt);
+typedef void (*loc_sv_status_cb_ext) (GpsSvStatus* sv_status, void* svExt);
+typedef void* (*loc_ext_parser)(void* data);
+typedef void (*loc_shutdown_cb) (void);
+
+typedef struct {
+    loc_location_cb_ext location_cb;
+    gps_status_callback status_cb;
+    loc_sv_status_cb_ext sv_status_cb;
+    gps_nmea_callback nmea_cb;
+    gps_set_capabilities set_capabilities_cb;
+    gps_acquire_wakelock acquire_wakelock_cb;
+    gps_release_wakelock release_wakelock_cb;
+    gps_create_thread create_thread_cb;
+    loc_ext_parser location_ext_parser;
+    loc_ext_parser sv_ext_parser;
+    gps_request_utc_time request_utc_time_cb;
+    loc_shutdown_cb shutdown_cb;
+} LocCallbacks;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif //__LOC_H__
diff --git a/msm8974/loc_api/libloc_api_50001/loc_eng.cpp b/msm8974/loc_api/libloc_api_50001/loc_eng.cpp
new file mode 100644
index 0000000..cba5ffa
--- /dev/null
+++ b/msm8974/loc_api/libloc_api_50001/loc_eng.cpp
@@ -0,0 +1,3024 @@
+/* Copyright (c) 2009-2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#define LOG_NDDEBUG 0
+#define LOG_TAG "LocSvc_eng"
+
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <dlfcn.h>
+#include <ctype.h>
+#include <math.h>
+#include <pthread.h>
+#include <arpa/inet.h>
+#include <netinet/in.h>         /* struct sockaddr_in */
+#include <sys/socket.h>
+#include <sys/time.h>
+#include <netdb.h>
+#include <time.h>
+#include <new>
+#include <LocEngAdapter.h>
+
+#include <cutils/sched_policy.h>
+#ifndef USE_GLIB
+#include <utils/SystemClock.h>
+#include <utils/Log.h>
+#endif /* USE_GLIB */
+
+#ifdef USE_GLIB
+#include <glib.h>
+#include <sys/syscall.h>
+#endif /* USE_GLIB */
+
+#include <string.h>
+
+#include <loc_eng.h>
+#include <loc_eng_ni.h>
+#include <loc_eng_dmn_conn.h>
+#include <loc_eng_dmn_conn_handler.h>
+#include <loc_eng_msg.h>
+#include <loc_eng_nmea.h>
+#include <msg_q.h>
+#include <loc.h>
+#include "log_util.h"
+#include "platform_lib_includes.h"
+#include "loc_core_log.h"
+#include "loc_eng_log.h"
+
+#define SUCCESS TRUE
+#define FAILURE FALSE
+
+#ifndef GPS_CONF_FILE
+#define GPS_CONF_FILE            "/etc/gps.conf"   //??? platform independent
+#endif
+
+#ifndef SAP_CONF_FILE
+#define SAP_CONF_FILE            "/etc/sap.conf"
+#endif
+
+#define XTRA1_GPSONEXTRA         "xtra1.gpsonextra.net"
+
+using namespace loc_core;
+
+boolean configAlreadyRead = false;
+unsigned int agpsStatus = 0;
+loc_gps_cfg_s_type gps_conf;
+loc_sap_cfg_s_type sap_conf;
+
+/* Parameter spec table */
+static loc_param_s_type gps_conf_table[] =
+{
+  {"GPS_LOCK",                       &gps_conf.GPS_LOCK,                       NULL, 'n'},
+  {"SUPL_VER",                       &gps_conf.SUPL_VER,                       NULL, 'n'},
+  {"LPP_PROFILE",                    &gps_conf.LPP_PROFILE,                    NULL, 'n'},
+  {"A_GLONASS_POS_PROTOCOL_SELECT",  &gps_conf.A_GLONASS_POS_PROTOCOL_SELECT,  NULL, 'n'},
+  {"AGPS_CERT_WRITABLE_MASK",        &gps_conf.AGPS_CERT_WRITABLE_MASK,        NULL, 'n'},
+  {"INTERMEDIATE_POS",               &gps_conf.INTERMEDIATE_POS,               NULL, 'n'},
+  {"ACCURACY_THRES",                 &gps_conf.ACCURACY_THRES,                 NULL, 'n'},
+  {"NMEA_PROVIDER",                  &gps_conf.NMEA_PROVIDER,                  NULL, 'n'},
+  {"CAPABILITIES",                   &gps_conf.CAPABILITIES,                   NULL, 'n'},
+};
+
+static loc_param_s_type sap_conf_table[] =
+{
+  {"GYRO_BIAS_RANDOM_WALK",          &sap_conf.GYRO_BIAS_RANDOM_WALK,          &sap_conf.GYRO_BIAS_RANDOM_WALK_VALID, 'f'},
+  {"ACCEL_RANDOM_WALK_SPECTRAL_DENSITY",     &sap_conf.ACCEL_RANDOM_WALK_SPECTRAL_DENSITY,    &sap_conf.ACCEL_RANDOM_WALK_SPECTRAL_DENSITY_VALID, 'f'},
+  {"ANGLE_RANDOM_WALK_SPECTRAL_DENSITY",     &sap_conf.ANGLE_RANDOM_WALK_SPECTRAL_DENSITY,    &sap_conf.ANGLE_RANDOM_WALK_SPECTRAL_DENSITY_VALID, 'f'},
+  {"RATE_RANDOM_WALK_SPECTRAL_DENSITY",      &sap_conf.RATE_RANDOM_WALK_SPECTRAL_DENSITY,     &sap_conf.RATE_RANDOM_WALK_SPECTRAL_DENSITY_VALID, 'f'},
+  {"VELOCITY_RANDOM_WALK_SPECTRAL_DENSITY",  &sap_conf.VELOCITY_RANDOM_WALK_SPECTRAL_DENSITY, &sap_conf.VELOCITY_RANDOM_WALK_SPECTRAL_DENSITY_VALID, 'f'},
+  {"SENSOR_ACCEL_BATCHES_PER_SEC",   &sap_conf.SENSOR_ACCEL_BATCHES_PER_SEC,   NULL, 'n'},
+  {"SENSOR_ACCEL_SAMPLES_PER_BATCH", &sap_conf.SENSOR_ACCEL_SAMPLES_PER_BATCH, NULL, 'n'},
+  {"SENSOR_GYRO_BATCHES_PER_SEC",    &sap_conf.SENSOR_GYRO_BATCHES_PER_SEC,    NULL, 'n'},
+  {"SENSOR_GYRO_SAMPLES_PER_BATCH",  &sap_conf.SENSOR_GYRO_SAMPLES_PER_BATCH,  NULL, 'n'},
+  {"SENSOR_ACCEL_BATCHES_PER_SEC_HIGH",   &sap_conf.SENSOR_ACCEL_BATCHES_PER_SEC_HIGH,   NULL, 'n'},
+  {"SENSOR_ACCEL_SAMPLES_PER_BATCH_HIGH", &sap_conf.SENSOR_ACCEL_SAMPLES_PER_BATCH_HIGH, NULL, 'n'},
+  {"SENSOR_GYRO_BATCHES_PER_SEC_HIGH",    &sap_conf.SENSOR_GYRO_BATCHES_PER_SEC_HIGH,    NULL, 'n'},
+  {"SENSOR_GYRO_SAMPLES_PER_BATCH_HIGH",  &sap_conf.SENSOR_GYRO_SAMPLES_PER_BATCH_HIGH,  NULL, 'n'},
+  {"SENSOR_CONTROL_MODE",            &sap_conf.SENSOR_CONTROL_MODE,            NULL, 'n'},
+  {"SENSOR_USAGE",                   &sap_conf.SENSOR_USAGE,                   NULL, 'n'},
+  {"SENSOR_ALGORITHM_CONFIG_MASK",   &sap_conf.SENSOR_ALGORITHM_CONFIG_MASK,   NULL, 'n'},
+  {"SENSOR_PROVIDER",                &sap_conf.SENSOR_PROVIDER,                NULL, 'n'},
+  {"XTRA_SERVER_1",                  &gps_conf.XTRA_SERVER_1,                  NULL, 's'},
+  {"XTRA_SERVER_2",                  &gps_conf.XTRA_SERVER_2,                  NULL, 's'},
+  {"XTRA_SERVER_3",                  &gps_conf.XTRA_SERVER_3,                  NULL, 's'}
+};
+
+static void loc_default_parameters(void)
+{
+   /* defaults */
+   gps_conf.INTERMEDIATE_POS = 0;
+   gps_conf.ACCURACY_THRES = 0;
+   gps_conf.NMEA_PROVIDER = 0;
+   gps_conf.GPS_LOCK = 0;
+   gps_conf.SUPL_VER = 0x10000;
+   gps_conf.CAPABILITIES = 0x7;
+
+   sap_conf.GYRO_BIAS_RANDOM_WALK = 0;
+   sap_conf.SENSOR_ACCEL_BATCHES_PER_SEC = 2;
+   sap_conf.SENSOR_ACCEL_SAMPLES_PER_BATCH = 5;
+   sap_conf.SENSOR_GYRO_BATCHES_PER_SEC = 2;
+   sap_conf.SENSOR_GYRO_SAMPLES_PER_BATCH = 5;
+   sap_conf.SENSOR_ACCEL_BATCHES_PER_SEC_HIGH = 4;
+   sap_conf.SENSOR_ACCEL_SAMPLES_PER_BATCH_HIGH = 25;
+   sap_conf.SENSOR_GYRO_BATCHES_PER_SEC_HIGH = 4;
+   sap_conf.SENSOR_GYRO_SAMPLES_PER_BATCH_HIGH = 25;
+   sap_conf.SENSOR_CONTROL_MODE = 0; /* AUTO */
+   sap_conf.SENSOR_USAGE = 0; /* Enabled */
+   sap_conf.SENSOR_ALGORITHM_CONFIG_MASK = 0; /* INS Disabled = FALSE*/
+
+   /* Values MUST be set by OEMs in configuration for sensor-assisted
+      navigation to work. There are NO default values */
+   sap_conf.ACCEL_RANDOM_WALK_SPECTRAL_DENSITY = 0;
+   sap_conf.ANGLE_RANDOM_WALK_SPECTRAL_DENSITY = 0;
+   sap_conf.RATE_RANDOM_WALK_SPECTRAL_DENSITY = 0;
+   sap_conf.VELOCITY_RANDOM_WALK_SPECTRAL_DENSITY = 0;
+
+   sap_conf.GYRO_BIAS_RANDOM_WALK_VALID = 0;
+   sap_conf.ACCEL_RANDOM_WALK_SPECTRAL_DENSITY_VALID = 0;
+   sap_conf.ANGLE_RANDOM_WALK_SPECTRAL_DENSITY_VALID = 0;
+   sap_conf.RATE_RANDOM_WALK_SPECTRAL_DENSITY_VALID = 0;
+   sap_conf.VELOCITY_RANDOM_WALK_SPECTRAL_DENSITY_VALID = 0;
+
+      /* LTE Positioning Profile configuration is disable by default*/
+   gps_conf.LPP_PROFILE = 0;
+
+   /*By default no positioning protocol is selected on A-GLONASS system*/
+   gps_conf.A_GLONASS_POS_PROTOCOL_SELECT = 0;
+
+   /* default provider is SSC */
+   sap_conf.SENSOR_PROVIDER = 1;
+
+   /* None of the 10 slots for agps certificates are writable by default */
+   gps_conf.AGPS_CERT_WRITABLE_MASK = 0;
+}
+
+// 2nd half of init(), singled out for
+// modem restart to use.
+static int loc_eng_reinit(loc_eng_data_s_type &loc_eng_data);
+static void loc_eng_agps_reinit(loc_eng_data_s_type &loc_eng_data);
+
+static int loc_eng_set_server(loc_eng_data_s_type &loc_eng_data,
+                              LocServerType type, const char *hostname, int port);
+// Internal functions
+static void loc_inform_gps_status(loc_eng_data_s_type &loc_eng_data,
+                                  GpsStatusValue status);
+static void loc_eng_report_status(loc_eng_data_s_type &loc_eng_data,
+                                  GpsStatusValue status);
+static void loc_eng_process_conn_request(loc_eng_data_s_type &loc_eng_data,
+                                         int connHandle, AGpsType agps_type);
+static void loc_eng_agps_close_status(loc_eng_data_s_type &loc_eng_data, int is_succ);
+static void loc_eng_handle_engine_down(loc_eng_data_s_type &loc_eng_data) ;
+static void loc_eng_handle_engine_up(loc_eng_data_s_type &loc_eng_data) ;
+
+static int loc_eng_start_handler(loc_eng_data_s_type &loc_eng_data);
+static int loc_eng_stop_handler(loc_eng_data_s_type &loc_eng_data);
+static int loc_eng_get_zpp_handler(loc_eng_data_s_type &loc_eng_data);
+static void loc_eng_handle_shutdown(loc_eng_data_s_type &loc_eng_data);
+static void deleteAidingData(loc_eng_data_s_type &logEng);
+static AgpsStateMachine*
+getAgpsStateMachine(loc_eng_data_s_type& logEng, AGpsExtType agpsType);
+static int dataCallCb(void *cb_data);
+static void update_aiding_data_for_deletion(loc_eng_data_s_type& loc_eng_data) {
+    if (loc_eng_data.engine_status != GPS_STATUS_ENGINE_ON &&
+        loc_eng_data.aiding_data_for_deletion != 0)
+    {
+        loc_eng_data.adapter->deleteAidingData(loc_eng_data.aiding_data_for_deletion);
+        loc_eng_data.aiding_data_for_deletion = 0;
+    }
+}
+
+static void* noProc(void* data)
+{
+    return NULL;
+}
+
+
+/*********************************************************************
+ * definitions of the static messages used in the file
+ *********************************************************************/
+//        case LOC_ENG_MSG_REQUEST_NI:
+LocEngRequestNi::LocEngRequestNi(void* locEng,
+                                 GpsNiNotification &notif,
+                                 const void* data) :
+    LocMsg(), mLocEng(locEng), mNotify(notif), mPayload(data) {
+    locallog();
+}
+void LocEngRequestNi::proc() const {
+    loc_eng_ni_request_handler(*((loc_eng_data_s_type*)mLocEng),
+                               &mNotify, mPayload);
+}
+void LocEngRequestNi::locallog() const
+{
+    LOC_LOGV("id: %d\n  type: %s\n  flags: %d\n  time out: %d\n  "
+             "default response: %s\n  requestor id encoding: %s\n"
+             "  text encoding: %s\n  passThroughData: %p",
+             mNotify.notification_id,
+             loc_get_ni_type_name(mNotify.ni_type),
+             mNotify.notify_flags,
+             mNotify.timeout,
+             loc_get_ni_response_name(mNotify.default_response),
+             loc_get_ni_encoding_name(mNotify.requestor_id_encoding),
+             loc_get_ni_encoding_name(mNotify.text_encoding),
+             mPayload);
+}
+inline void LocEngRequestNi::log() const {
+    locallog();
+}
+
+//        case LOC_ENG_MSG_INFORM_NI_RESPONSE:
+// in loc_eng_ni.cpp
+
+//        case LOC_ENG_MSG_START_FIX:
+LocEngStartFix::LocEngStartFix(LocEngAdapter* adapter) :
+    LocMsg(), mAdapter(adapter)
+{
+    locallog();
+}
+inline void LocEngStartFix::proc() const
+{
+    loc_eng_data_s_type* locEng = (loc_eng_data_s_type*)mAdapter->getOwner();
+    loc_eng_start_handler(*locEng);
+}
+inline void LocEngStartFix::locallog() const
+{
+    LOC_LOGV("LocEngStartFix");
+}
+inline void LocEngStartFix::log() const
+{
+    locallog();
+}
+void LocEngStartFix::send() const {
+    mAdapter->sendMsg(this);
+}
+
+//        case LOC_ENG_MSG_STOP_FIX:
+LocEngStopFix::LocEngStopFix(LocEngAdapter* adapter) :
+    LocMsg(), mAdapter(adapter)
+{
+    locallog();
+}
+inline void LocEngStopFix::proc() const
+{
+    loc_eng_data_s_type* locEng = (loc_eng_data_s_type*)mAdapter->getOwner();
+    loc_eng_stop_handler(*locEng);
+}
+inline void LocEngStopFix::locallog() const
+{
+    LOC_LOGV("LocEngStopFix");
+}
+inline void LocEngStopFix::log() const
+{
+    locallog();
+}
+void LocEngStopFix::send() const {
+    mAdapter->sendMsg(this);
+}
+
+//        case LOC_ENG_MSG_SET_POSITION_MODE:
+LocEngPositionMode::LocEngPositionMode(LocEngAdapter* adapter,
+                                       LocPosMode &mode) :
+    LocMsg(), mAdapter(adapter), mPosMode(mode)
+{
+    mPosMode.logv();
+}
+inline void LocEngPositionMode::proc() const {
+    mAdapter->setPositionMode(&mPosMode);
+}
+inline void LocEngPositionMode::log() const {
+    mPosMode.logv();
+}
+void LocEngPositionMode::send() const {
+    mAdapter->sendMsg(this);
+}
+
+LocEngGetZpp::LocEngGetZpp(LocEngAdapter* adapter) :
+    LocMsg(), mAdapter(adapter)
+{
+    locallog();
+}
+inline void LocEngGetZpp::proc() const
+{
+    loc_eng_data_s_type* locEng = (loc_eng_data_s_type*)mAdapter->getOwner();
+    loc_eng_get_zpp_handler(*locEng);
+}
+inline void LocEngGetZpp::locallog() const
+{
+    LOC_LOGV("LocEngGetZpp");
+}
+inline void LocEngGetZpp::log() const
+{
+    locallog();
+}
+void LocEngGetZpp::send() const {
+    mAdapter->sendMsg(this);
+}
+
+
+LocEngShutdown::LocEngShutdown(LocEngAdapter* adapter) :
+    LocMsg(), mAdapter(adapter)
+{
+    locallog();
+}
+inline void LocEngShutdown::proc() const
+{
+    loc_eng_data_s_type* locEng = (loc_eng_data_s_type*)mAdapter->getOwner();
+    LOC_LOGD("%s:%d]: Calling loc_eng_handle_shutdown", __func__, __LINE__);
+    loc_eng_handle_shutdown(*locEng);
+}
+inline void LocEngShutdown::locallog() const
+{
+    LOC_LOGV("LocEngShutdown");
+}
+inline void LocEngShutdown::log() const
+{
+    locallog();
+}
+
+//        case LOC_ENG_MSG_SET_TIME:
+struct LocEngSetTime : public LocMsg {
+    LocEngAdapter* mAdapter;
+    const GpsUtcTime mTime;
+    const int64_t mTimeReference;
+    const int mUncertainty;
+    inline LocEngSetTime(LocEngAdapter* adapter,
+                         GpsUtcTime t, int64_t tf, int unc) :
+        LocMsg(), mAdapter(adapter),
+        mTime(t), mTimeReference(tf), mUncertainty(unc)
+    {
+        locallog();
+    }
+    inline virtual void proc() const {
+        mAdapter->setTime(mTime, mTimeReference, mUncertainty);
+    }
+    inline void locallog() const {
+        LOC_LOGV("time: %lld\n  timeReference: %lld\n  uncertainty: %d",
+                 mTime, mTimeReference, mUncertainty);
+    }
+    inline virtual void log() const {
+        locallog();
+    }
+};
+
+ //       case LOC_ENG_MSG_INJECT_LOCATION:
+struct LocEngInjectLocation : public LocMsg {
+    LocEngAdapter* mAdapter;
+    const double mLatitude;
+    const double mLongitude;
+    const float mAccuracy;
+    inline LocEngInjectLocation(LocEngAdapter* adapter,
+                                double lat, double lon, float accur) :
+        LocMsg(), mAdapter(adapter),
+        mLatitude(lat), mLongitude(lon), mAccuracy(accur)
+    {
+        locallog();
+    }
+    inline virtual void proc() const {
+        mAdapter->injectPosition(mLatitude, mLongitude, mAccuracy);
+    }
+    inline void locallog() const {
+        LOC_LOGV("latitude: %f\n  longitude: %f\n  accuracy: %f",
+                 mLatitude, mLongitude, mAccuracy);
+    }
+    inline virtual void log() const {
+        locallog();
+    }
+};
+
+//        case LOC_ENG_MSG_SET_SERVER_IPV4:
+struct LocEngSetServerIpv4 : public LocMsg {
+    LocEngAdapter* mAdapter;
+    const unsigned int mNlAddr;
+    const int mPort;
+    const LocServerType mServerType;
+    inline LocEngSetServerIpv4(LocEngAdapter* adapter,
+                               unsigned int ip,
+                               int port,
+                               LocServerType type) :
+        LocMsg(), mAdapter(adapter),
+        mNlAddr(ip), mPort(port), mServerType(type)
+    {
+        locallog();
+    }
+    inline virtual void proc() const {
+        mAdapter->setServer(mNlAddr, mPort, mServerType);
+    }
+    inline void locallog() const {
+        LOC_LOGV("LocEngSetServerIpv4 - addr: %x, port: %d, type: %s",
+                 mNlAddr, mPort, loc_get_server_type_name(mServerType));
+    }
+    inline virtual void log() const {
+        locallog();
+    }
+};
+
+//        case LOC_ENG_MSG_SET_SERVER_URL:
+struct LocEngSetServerUrl : public LocMsg {
+    LocEngAdapter* mAdapter;
+    const int mLen;
+    char* mUrl;
+    inline LocEngSetServerUrl(LocEngAdapter* adapter,
+                              char* urlString,
+                              int url_len) :
+        LocMsg(), mAdapter(adapter),
+        mLen(url_len), mUrl(new char[mLen+1])
+    {
+        memcpy((void*)mUrl, (void*)urlString, url_len);
+        mUrl[mLen] = 0;
+        locallog();
+    }
+    inline ~LocEngSetServerUrl()
+    {
+        delete[] mUrl;
+    }
+    inline virtual void proc() const {
+        mAdapter->setServer(mUrl, mLen);
+    }
+    inline void locallog() const {
+        LOC_LOGV("LocEngSetServerUrl - url: %s", mUrl);
+    }
+    inline virtual void log() const {
+        locallog();
+    }
+};
+
+//        case LOC_ENG_MSG_A_GLONASS_PROTOCOL:
+struct LocEngAGlonassProtocol : public LocMsg {
+    LocEngAdapter* mAdapter;
+    const unsigned long mAGlonassProtocl;
+    inline LocEngAGlonassProtocol(LocEngAdapter* adapter,
+                                  unsigned long protocol) :
+        LocMsg(), mAdapter(adapter), mAGlonassProtocl(protocol)
+    {
+        locallog();
+    }
+    inline virtual void proc() const {
+        mAdapter->setAGLONASSProtocol(mAGlonassProtocl);
+    }
+    inline  void locallog() const {
+        LOC_LOGV("A-GLONASS protocol: 0x%lx", mAGlonassProtocl);
+    }
+    inline virtual void log() const {
+        locallog();
+    }
+};
+
+//        case LOC_ENG_MSG_SUPL_VERSION:
+struct LocEngSuplVer : public LocMsg {
+    LocEngAdapter* mAdapter;
+    const int mSuplVer;
+    inline LocEngSuplVer(LocEngAdapter* adapter,
+                         int suplVer) :
+        LocMsg(), mAdapter(adapter), mSuplVer(suplVer)
+    {
+        locallog();
+    }
+    inline virtual void proc() const {
+        mAdapter->setSUPLVersion(mSuplVer);
+    }
+    inline  void locallog() const {
+        LOC_LOGV("SUPL Version: %d", mSuplVer);
+    }
+    inline virtual void log() const {
+        locallog();
+    }
+};
+
+//        case LOC_ENG_MSG_LPP_CONFIG:
+struct LocEngLppConfig : public LocMsg {
+    LocEngAdapter* mAdapter;
+    const int mLppConfig;
+    inline LocEngLppConfig(LocEngAdapter* adapter,
+                           int lppConfig) :
+        LocMsg(), mAdapter(adapter), mLppConfig(lppConfig)
+    {
+        locallog();
+    }
+    inline virtual void proc() const {
+        mAdapter->setLPPConfig(mLppConfig);
+    }
+    inline void locallog() const {
+        LOC_LOGV("LocEngLppConfig - profile: %d", mLppConfig);
+    }
+    inline virtual void log() const {
+        locallog();
+    }
+};
+
+//        case LOC_ENG_MSG_SET_SENSOR_CONTROL_CONFIG:
+struct LocEngSensorControlConfig : public LocMsg {
+    LocEngAdapter* mAdapter;
+    const int mSensorsDisabled;
+    const int mSensorProvider;
+    inline LocEngSensorControlConfig(LocEngAdapter* adapter,
+                                     int sensorsDisabled, int sensorProvider) :
+        LocMsg(), mAdapter(adapter), mSensorsDisabled(sensorsDisabled),
+        mSensorProvider(sensorProvider)
+    {
+        locallog();
+    }
+    inline virtual void proc() const {
+        mAdapter->setSensorControlConfig(mSensorsDisabled, mSensorProvider);
+    }
+    inline  void locallog() const {
+        LOC_LOGV("LocEngSensorControlConfig - Sensors Disabled: %d, Sensor Provider: %d",
+                 mSensorsDisabled, mSensorProvider);
+    }
+    inline virtual void log() const {
+        locallog();
+    }
+};
+
+//        case LOC_ENG_MSG_SET_SENSOR_PROPERTIES:
+struct LocEngSensorProperties : public LocMsg {
+    LocEngAdapter* mAdapter;
+    const bool mGyroBiasVarianceRandomWalkValid;
+    const float mGyroBiasVarianceRandomWalk;
+    const bool mAccelRandomWalkValid;
+    const float mAccelRandomWalk;
+    const bool mAngleRandomWalkValid;
+    const float mAngleRandomWalk;
+    const bool mRateRandomWalkValid;
+    const float mRateRandomWalk;
+    const bool mVelocityRandomWalkValid;
+    const float mVelocityRandomWalk;
+    inline LocEngSensorProperties(LocEngAdapter* adapter,
+                                  bool gyroBiasRandomWalk_valid,
+                                  float gyroBiasRandomWalk,
+                                  bool accelRandomWalk_valid,
+                                  float accelRandomWalk,
+                                  bool angleRandomWalk_valid,
+                                  float angleRandomWalk,
+                                  bool rateRandomWalk_valid,
+                                  float rateRandomWalk,
+                                  bool velocityRandomWalk_valid,
+                                  float velocityRandomWalk) :
+        LocMsg(), mAdapter(adapter),
+        mGyroBiasVarianceRandomWalkValid(gyroBiasRandomWalk_valid),
+        mGyroBiasVarianceRandomWalk(gyroBiasRandomWalk),
+        mAccelRandomWalkValid(accelRandomWalk_valid),
+        mAccelRandomWalk(accelRandomWalk),
+        mAngleRandomWalkValid(angleRandomWalk_valid),
+        mAngleRandomWalk(angleRandomWalk),
+        mRateRandomWalkValid(rateRandomWalk_valid),
+        mRateRandomWalk(rateRandomWalk),
+        mVelocityRandomWalkValid(velocityRandomWalk_valid),
+        mVelocityRandomWalk(velocityRandomWalk)
+    {
+        locallog();
+    }
+    inline virtual void proc() const {
+        mAdapter->setSensorProperties(mGyroBiasVarianceRandomWalkValid,
+                                      mGyroBiasVarianceRandomWalk,
+                                      mAccelRandomWalkValid,
+                                      mAccelRandomWalk,
+                                      mAngleRandomWalkValid,
+                                      mAngleRandomWalk,
+                                      mRateRandomWalkValid,
+                                      mRateRandomWalk,
+                                      mVelocityRandomWalkValid,
+                                      mVelocityRandomWalk);
+    }
+    inline  void locallog() const {
+        LOC_LOGV("Sensor properties validity, Gyro Random walk: %d "
+                 "Accel Random Walk: %d "
+                 "Angle Random Walk: %d Rate Random Walk: %d "
+                 "Velocity Random Walk: %d\n"
+                 "Sensor properties, Gyro Random walk: %f "
+                 "Accel Random Walk: %f "
+                 "Angle Random Walk: %f Rate Random Walk: %f "
+                 "Velocity Random Walk: %f",
+                 mGyroBiasVarianceRandomWalkValid,
+                 mAccelRandomWalkValid,
+                 mAngleRandomWalkValid,
+                 mRateRandomWalkValid,
+                 mVelocityRandomWalkValid,
+                 mGyroBiasVarianceRandomWalk,
+                 mAccelRandomWalk,
+                 mAngleRandomWalk,
+                 mRateRandomWalk,
+                 mVelocityRandomWalk
+            );
+    }
+    inline virtual void log() const {
+        locallog();
+    }
+};
+
+//        case LOC_ENG_MSG_SET_SENSOR_PERF_CONTROL_CONFIG:
+struct LocEngSensorPerfControlConfig : public LocMsg {
+    LocEngAdapter* mAdapter;
+    const int mControlMode;
+    const int mAccelSamplesPerBatch;
+    const int mAccelBatchesPerSec;
+    const int mGyroSamplesPerBatch;
+    const int mGyroBatchesPerSec;
+    const int mAccelSamplesPerBatchHigh;
+    const int mAccelBatchesPerSecHigh;
+    const int mGyroSamplesPerBatchHigh;
+    const int mGyroBatchesPerSecHigh;
+    const int mAlgorithmConfig;
+    inline LocEngSensorPerfControlConfig(LocEngAdapter* adapter,
+                                         int controlMode,
+                                         int accelSamplesPerBatch,
+                                         int accelBatchesPerSec,
+                                         int gyroSamplesPerBatch,
+                                         int gyroBatchesPerSec,
+                                         int accelSamplesPerBatchHigh,
+                                         int accelBatchesPerSecHigh,
+                                         int gyroSamplesPerBatchHigh,
+                                         int gyroBatchesPerSecHigh,
+                                         int algorithmConfig) :
+        LocMsg(), mAdapter(adapter),
+        mControlMode(controlMode),
+        mAccelSamplesPerBatch(accelSamplesPerBatch),
+        mAccelBatchesPerSec(accelBatchesPerSec),
+        mGyroSamplesPerBatch(gyroSamplesPerBatch),
+        mGyroBatchesPerSec(gyroBatchesPerSec),
+        mAccelSamplesPerBatchHigh(accelSamplesPerBatchHigh),
+        mAccelBatchesPerSecHigh(accelBatchesPerSecHigh),
+        mGyroSamplesPerBatchHigh(gyroSamplesPerBatchHigh),
+        mGyroBatchesPerSecHigh(gyroBatchesPerSecHigh),
+        mAlgorithmConfig(algorithmConfig)
+    {
+        locallog();
+    }
+    inline virtual void proc() const {
+        mAdapter->setSensorPerfControlConfig(mControlMode,
+                                             mAccelSamplesPerBatch,
+                                             mAccelBatchesPerSec,
+                                             mGyroSamplesPerBatch,
+                                             mGyroBatchesPerSec,
+                                             mAccelSamplesPerBatchHigh,
+                                             mAccelBatchesPerSecHigh,
+                                             mGyroSamplesPerBatchHigh,
+                                             mGyroBatchesPerSecHigh,
+                                             mAlgorithmConfig);
+    }
+    inline void locallog() const {
+        LOC_LOGV("Sensor Perf Control Config (performanceControlMode)(%u) "
+                 "accel(#smp,#batches) (%u,%u) "
+                 "gyro(#smp,#batches) (%u,%u), "
+                 "accel_high(#smp,#batches) (%u,%u) "
+                 "gyro_high(#smp,#batches) (%u,%u), "
+                 "algorithmConfig(%u)\n",
+                 mControlMode,
+                 mAccelSamplesPerBatch, mAccelBatchesPerSec,
+                 mGyroSamplesPerBatch, mGyroBatchesPerSec,
+                 mAccelSamplesPerBatchHigh, mAccelBatchesPerSecHigh,
+                 mGyroSamplesPerBatchHigh, mGyroBatchesPerSecHigh,
+                 mAlgorithmConfig);
+    }
+    inline virtual void log() const {
+        locallog();
+    }
+};
+
+//        case LOC_ENG_MSG_EXT_POWER_CONFIG:
+struct LocEngExtPowerConfig : public LocMsg {
+    LocEngAdapter* mAdapter;
+    const int mIsBatteryCharging;
+    inline LocEngExtPowerConfig(LocEngAdapter* adapter,
+                                int isBatteryCharging) :
+        LocMsg(), mAdapter(adapter),
+        mIsBatteryCharging(isBatteryCharging)
+    {
+        locallog();
+    }
+    inline virtual void proc() const {
+        mAdapter->setExtPowerConfig(mIsBatteryCharging);
+    }
+    inline void locallog() const {
+        LOC_LOGV("LocEngExtPowerConfig - isBatteryCharging: %d",
+                 mIsBatteryCharging);
+    }
+    inline virtual void log() const {
+        locallog();
+    }
+};
+
+//        case LOC_ENG_MSG_REPORT_POSITION:
+LocEngReportPosition::LocEngReportPosition(LocAdapterBase* adapter,
+                                           UlpLocation &loc,
+                                           GpsLocationExtended &locExtended,
+                                           void* locExt,
+                                           enum loc_sess_status st,
+                                           LocPosTechMask technology) :
+    LocMsg(), mAdapter(adapter), mLocation(loc),
+    mLocationExtended(locExtended),
+    mLocationExt(((loc_eng_data_s_type*)
+                  ((LocEngAdapter*)
+                   (mAdapter))->getOwner())->location_ext_parser(locExt)),
+    mStatus(st), mTechMask(technology)
+{
+    locallog();
+}
+void LocEngReportPosition::proc() const {
+    LocEngAdapter* adapter = (LocEngAdapter*)mAdapter;
+    loc_eng_data_s_type* locEng = (loc_eng_data_s_type*)adapter->getOwner();
+
+    if (locEng->mute_session_state != LOC_MUTE_SESS_IN_SESSION) {
+        bool reported = false;
+        if (locEng->location_cb != NULL) {
+            if (LOC_SESS_FAILURE == mStatus) {
+                // in case we want to handle the failure case
+                locEng->location_cb(NULL, NULL);
+                reported = true;
+            }
+            // what's in the else if is... (line by line)
+            // 1. this is a final fix; and
+            //   1.1 it is a Satellite fix; or
+            //   1.2 it is a sensor fix
+            // 2. (must be intermediate fix... implicit)
+            //   2.1 we accepte intermediate; and
+            //   2.2 it is NOT the case that
+            //   2.2.1 there is inaccuracy; and
+            //   2.2.2 we care about inaccuracy; and
+            //   2.2.3 the inaccuracy exceeds our tolerance
+            else if ((LOC_SESS_SUCCESS == mStatus &&
+                      ((LOC_POS_TECH_MASK_SATELLITE |
+                        LOC_POS_TECH_MASK_SENSORS   |
+                        LOC_POS_TECH_MASK_HYBRID) &
+                       mTechMask)) ||
+                     (LOC_SESS_INTERMEDIATE == locEng->intermediateFix &&
+                      !((mLocation.gpsLocation.flags &
+                         GPS_LOCATION_HAS_ACCURACY) &&
+                        (gps_conf.ACCURACY_THRES != 0) &&
+                        (mLocation.gpsLocation.accuracy >
+                         gps_conf.ACCURACY_THRES)))) {
+                locEng->location_cb((UlpLocation*)&(mLocation),
+                                    (void*)mLocationExt);
+                reported = true;
+            }
+        }
+
+        // if we have reported this fix
+        if (reported &&
+            // and if this is a singleshot
+            GPS_POSITION_RECURRENCE_SINGLE ==
+            locEng->adapter->getPositionMode().recurrence) {
+            if (LOC_SESS_INTERMEDIATE == mStatus) {
+                // modem could be still working for a final fix,
+                // although we no longer need it.  So stopFix().
+                locEng->adapter->stopFix();
+            }
+            // turn off the session flag.
+            locEng->adapter->setInSession(false);
+        }
+
+        if (locEng->generateNmea &&
+            mLocation.position_source == ULP_LOCATION_IS_FROM_GNSS &&
+            mTechMask & (LOC_POS_TECH_MASK_SATELLITE |
+                         LOC_POS_TECH_MASK_SENSORS |
+                         LOC_POS_TECH_MASK_HYBRID))
+        {
+            unsigned char generate_nmea = reported &&
+                                          (mStatus != LOC_SESS_FAILURE);
+            loc_eng_nmea_generate_pos(locEng, mLocation, mLocationExtended,
+                                      generate_nmea);
+        }
+
+        // Free the allocated memory for rawData
+        UlpLocation* gp = (UlpLocation*)&(mLocation);
+        if (gp != NULL && gp->rawData != NULL)
+        {
+            delete (char*)gp->rawData;
+            gp->rawData = NULL;
+            gp->rawDataSize = 0;
+        }
+    }
+}
+void LocEngReportPosition::locallog() const {
+    LOC_LOGV("flags: %d\n  source: %d\n  latitude: %f\n  longitude: %f\n  "
+             "altitude: %f\n  speed: %f\n  bearing: %f\n  accuracy: %f\n  "
+             "timestamp: %lld\n  rawDataSize: %d\n  rawData: %p\n  Session"
+             " status: %d\n Technology mask: %u",
+             mLocation.gpsLocation.flags, mLocation.position_source,
+             mLocation.gpsLocation.latitude, mLocation.gpsLocation.longitude,
+             mLocation.gpsLocation.altitude, mLocation.gpsLocation.speed,
+             mLocation.gpsLocation.bearing, mLocation.gpsLocation.accuracy,
+             mLocation.gpsLocation.timestamp, mLocation.rawDataSize,
+             mLocation.rawData, mStatus, mTechMask);
+}
+void LocEngReportPosition::log() const {
+    locallog();
+}
+void LocEngReportPosition::send() const {
+    mAdapter->sendMsg(this);
+}
+
+
+//        case LOC_ENG_MSG_REPORT_SV:
+LocEngReportSv::LocEngReportSv(LocAdapterBase* adapter,
+                               GpsSvStatus &sv,
+                               GpsLocationExtended &locExtended,
+                               void* svExt) :
+    LocMsg(), mAdapter(adapter), mSvStatus(sv),
+    mLocationExtended(locExtended),
+    mSvExt(((loc_eng_data_s_type*)
+            ((LocEngAdapter*)
+             (mAdapter))->getOwner())->sv_ext_parser(svExt))
+{
+    locallog();
+}
+void LocEngReportSv::proc() const {
+    LocEngAdapter* adapter = (LocEngAdapter*)mAdapter;
+    loc_eng_data_s_type* locEng = (loc_eng_data_s_type*)adapter->getOwner();
+
+    if (locEng->mute_session_state != LOC_MUTE_SESS_IN_SESSION)
+    {
+        if (locEng->sv_status_cb != NULL) {
+            locEng->sv_status_cb((GpsSvStatus*)&(mSvStatus),
+                                 (void*)mSvExt);
+        }
+
+        if (locEng->generateNmea)
+        {
+            loc_eng_nmea_generate_sv(locEng, mSvStatus, mLocationExtended);
+        }
+    }
+}
+void LocEngReportSv::locallog() const {
+    LOC_LOGV("num sv: %d\n  ephemeris mask: %dxn  almanac mask: %x\n  "
+             "used in fix mask: %x\n      sv: prn         snr       "
+             "elevation      azimuth",
+             mSvStatus.num_svs, mSvStatus.ephemeris_mask,
+             mSvStatus.almanac_mask, mSvStatus.used_in_fix_mask);
+    for (int i = 0; i < mSvStatus.num_svs && i < GPS_MAX_SVS; i++) {
+        LOC_LOGV("   %d:   %d    %f    %f    %f\n  ",
+                 i,
+                 mSvStatus.sv_list[i].prn,
+                 mSvStatus.sv_list[i].snr,
+                 mSvStatus.sv_list[i].elevation,
+                 mSvStatus.sv_list[i].azimuth);
+    }
+}
+inline void LocEngReportSv::log() const {
+    locallog();
+}
+void LocEngReportSv::send() const {
+    mAdapter->sendMsg(this);
+}
+
+//        case LOC_ENG_MSG_REPORT_STATUS:
+LocEngReportStatus::LocEngReportStatus(LocAdapterBase* adapter,
+                                       GpsStatusValue engineStatus) :
+    LocMsg(),  mAdapter(adapter), mStatus(engineStatus)
+{
+    locallog();
+}
+inline void LocEngReportStatus::proc() const
+{
+    LocEngAdapter* adapter = (LocEngAdapter*)mAdapter;
+    loc_eng_data_s_type* locEng = (loc_eng_data_s_type*)adapter->getOwner();
+
+    loc_eng_report_status(*locEng, mStatus);
+    update_aiding_data_for_deletion(*locEng);
+}
+inline void LocEngReportStatus::locallog() const {
+    LOC_LOGV("LocEngReportStatus");
+}
+inline void LocEngReportStatus::log() const {
+    locallog();
+}
+
+//        case LOC_ENG_MSG_REPORT_NMEA:
+LocEngReportNmea::LocEngReportNmea(void* locEng,
+                                   const char* data, int len) :
+    LocMsg(), mLocEng(locEng), mNmea(new char[len]), mLen(len)
+{
+    memcpy((void*)mNmea, (void*)data, len);
+    locallog();
+}
+void LocEngReportNmea::proc() const {
+    loc_eng_data_s_type* locEng = (loc_eng_data_s_type*) mLocEng;
+
+    struct timeval tv;
+    gettimeofday(&tv, (struct timezone *) NULL);
+    int64_t now = tv.tv_sec * 1000LL + tv.tv_usec / 1000;
+    CALLBACK_LOG_CALLFLOW("nmea_cb", %d, mLen);
+
+    if (locEng->nmea_cb != NULL)
+        locEng->nmea_cb(now, mNmea, mLen);
+}
+inline void LocEngReportNmea::locallog() const {
+    LOC_LOGV("LocEngReportNmea");
+}
+inline void LocEngReportNmea::log() const {
+    locallog();
+}
+
+//        case LOC_ENG_MSG_REPORT_XTRA_SERVER:
+LocEngReportXtraServer::LocEngReportXtraServer(void* locEng,
+                                               const char *url1,
+                                               const char *url2,
+                                               const char *url3,
+                                               const int maxlength) :
+    LocMsg(), mLocEng(locEng), mMaxLen(maxlength),
+    mServers(new char[3*(mMaxLen+1)])
+{
+    char * cptr = mServers;
+    memset(mServers, 0, 3*(mMaxLen+1));
+
+    // Override modem URLs with uncommented gps.conf urls
+    if( gps_conf.XTRA_SERVER_1[0] != '\0' ) {
+        url1 = &gps_conf.XTRA_SERVER_1[0];
+    }
+    if( gps_conf.XTRA_SERVER_2[0] != '\0' ) {
+        url2 = &gps_conf.XTRA_SERVER_2[0];
+    }
+    if( gps_conf.XTRA_SERVER_3[0] != '\0' ) {
+        url3 = &gps_conf.XTRA_SERVER_3[0];
+    }
+    // copy non xtra1.gpsonextra.net URLs into the forwarding buffer.
+    if( NULL == strcasestr(url1, XTRA1_GPSONEXTRA) ) {
+        strlcpy(cptr, url1, mMaxLen + 1);
+        cptr += mMaxLen + 1;
+    }
+    if( NULL == strcasestr(url2, XTRA1_GPSONEXTRA) ) {
+        strlcpy(cptr, url2, mMaxLen + 1);
+        cptr += mMaxLen + 1;
+    }
+    if( NULL == strcasestr(url3, XTRA1_GPSONEXTRA) ) {
+        strlcpy(cptr, url3, mMaxLen + 1);
+    }
+    locallog();
+}
+void LocEngReportXtraServer::proc() const {
+    loc_eng_xtra_data_s_type* locEngXtra =
+        &(((loc_eng_data_s_type*)mLocEng)->xtra_module_data);
+
+    if (locEngXtra->report_xtra_server_cb != NULL) {
+        CALLBACK_LOG_CALLFLOW("report_xtra_server_cb", %s, mServers);
+        locEngXtra->report_xtra_server_cb(mServers,
+                                          &(mServers[mMaxLen+1]),
+                                          &(mServers[(mMaxLen+1)<<1]));
+    } else {
+        LOC_LOGE("Callback function for request xtra is NULL");
+    }
+}
+inline void LocEngReportXtraServer::locallog() const {
+    LOC_LOGV("LocEngReportXtraServers: server1: %s\n  server2: %s\n"
+             "  server3: %s\n",
+             mServers, &mServers[mMaxLen+1], &mServers[(mMaxLen+1)<<1]);
+}
+inline void LocEngReportXtraServer::log() const {
+    locallog();
+}
+
+//        case LOC_ENG_MSG_REQUEST_BIT:
+//        case LOC_ENG_MSG_RELEASE_BIT:
+LocEngReqRelBIT::LocEngReqRelBIT(void* locEng, AGpsExtType type,
+                                 int ipv4, char* ipv6, bool isReq) :
+    LocMsg(), mLocEng(locEng), mType(type), mIPv4Addr(ipv4),
+    mIPv6Addr(ipv6 ? new char[16] : NULL), mIsReq(isReq) {
+    if (NULL != ipv6)
+        memcpy(mIPv6Addr, ipv6, 16);
+    locallog();
+}
+inline LocEngReqRelBIT::~LocEngReqRelBIT() {
+    if (mIPv6Addr) {
+        delete[] mIPv6Addr;
+    }
+}
+void LocEngReqRelBIT::proc() const {
+    loc_eng_data_s_type* locEng = (loc_eng_data_s_type*)mLocEng;
+    BITSubscriber s(getAgpsStateMachine(*locEng, mType),
+                    mIPv4Addr, mIPv6Addr);
+    AgpsStateMachine* sm = (AgpsStateMachine*)s.mStateMachine;
+
+    if (mIsReq) {
+        sm->subscribeRsrc((Subscriber*)&s);
+    } else {
+        sm->unsubscribeRsrc((Subscriber*)&s);
+    }
+}
+inline void LocEngReqRelBIT::locallog() const {
+    LOC_LOGV("LocEngRequestBIT - ipv4: %d.%d.%d.%d, ipv6: %s",
+             (unsigned char)mIPv4Addr,
+             (unsigned char)(mIPv4Addr>>8),
+             (unsigned char)(mIPv4Addr>>16),
+             (unsigned char)(mIPv4Addr>>24),
+             NULL != mIPv6Addr ? mIPv6Addr : "");
+}
+inline void LocEngReqRelBIT::log() const {
+    locallog();
+}
+void LocEngReqRelBIT::send() const {
+    loc_eng_data_s_type* locEng = (loc_eng_data_s_type*)mLocEng;
+    locEng->adapter->sendMsg(this);
+}
+
+//        case LOC_ENG_MSG_RELEASE_BIT:
+struct LocEngReleaseBIT : public LocMsg {
+    const BITSubscriber mSubscriber;
+    inline LocEngReleaseBIT(const AgpsStateMachine* stateMachine,
+                            unsigned int ipv4, char* ipv6) :
+        LocMsg(),
+        mSubscriber(stateMachine, ipv4, ipv6)
+    {
+        locallog();
+    }
+    inline virtual void proc() const
+    {
+        AgpsStateMachine* sm = (AgpsStateMachine*)mSubscriber.mStateMachine;
+        sm->unsubscribeRsrc((Subscriber*)&mSubscriber);
+    }
+    inline void locallog() const {
+        LOC_LOGV("LocEngReleaseBIT - ipv4: %d.%d.%d.%d, ipv6: %s",
+                 (unsigned char)(mSubscriber.ID>>24),
+                 (unsigned char)(mSubscriber.ID>>16),
+                 (unsigned char)(mSubscriber.ID>>8),
+                 (unsigned char)mSubscriber.ID,
+                 NULL != mSubscriber.mIPv6Addr ? mSubscriber.mIPv6Addr : "");
+    }
+    virtual void log() const {
+        locallog();
+    }
+};
+
+//        LocEngSuplEsOpened
+LocEngSuplEsOpened::LocEngSuplEsOpened(void* locEng) :
+    LocMsg(), mLocEng(locEng) {
+    locallog();
+}
+void LocEngSuplEsOpened::proc() const {
+    loc_eng_data_s_type* locEng = (loc_eng_data_s_type*)mLocEng;
+    if (locEng->ds_nif) {
+        AgpsStateMachine* sm = locEng->ds_nif;
+        sm->onRsrcEvent(RSRC_GRANTED);
+    }
+}
+void LocEngSuplEsOpened::locallog() const {
+    LOC_LOGV("LocEngSuplEsOpened");
+}
+void LocEngSuplEsOpened::log() const {
+    locallog();
+}
+
+//        LocEngSuplEsClosed
+LocEngSuplEsClosed::LocEngSuplEsClosed(void* locEng) :
+    LocMsg(), mLocEng(locEng) {
+    locallog();
+}
+void LocEngSuplEsClosed::proc() const {
+    loc_eng_data_s_type* locEng = (loc_eng_data_s_type*)mLocEng;
+    if (locEng->ds_nif) {
+        AgpsStateMachine* sm = locEng->ds_nif;
+        sm->onRsrcEvent(RSRC_RELEASED);
+    }
+}
+void LocEngSuplEsClosed::locallog() const {
+    LOC_LOGV("LocEngSuplEsClosed");
+}
+void LocEngSuplEsClosed::log() const {
+    locallog();
+}
+
+
+//        case LOC_ENG_MSG_REQUEST_SUPL_ES:
+LocEngRequestSuplEs::LocEngRequestSuplEs(void* locEng, int id) :
+    LocMsg(), mLocEng(locEng), mID(id) {
+    locallog();
+}
+void LocEngRequestSuplEs::proc() const {
+    loc_eng_data_s_type* locEng = (loc_eng_data_s_type*)mLocEng;
+    if (locEng->ds_nif) {
+        AgpsStateMachine* sm = locEng->ds_nif;
+        DSSubscriber s(sm, mID);
+        sm->subscribeRsrc((Subscriber*)&s);
+    } else {
+        locEng->adapter->atlOpenStatus(mID, 0, NULL, -1, -1);
+    }
+}
+inline void LocEngRequestSuplEs::locallog() const {
+    LOC_LOGV("LocEngRequestSuplEs");
+}
+inline void LocEngRequestSuplEs::log() const {
+    locallog();
+}
+
+//        case LOC_ENG_MSG_REQUEST_ATL:
+LocEngRequestATL::LocEngRequestATL(void* locEng, int id,
+                                   AGpsExtType agps_type) :
+    LocMsg(), mLocEng(locEng), mID(id), mType(agps_type) {
+    locallog();
+}
+void LocEngRequestATL::proc() const {
+    loc_eng_data_s_type* locEng = (loc_eng_data_s_type*)mLocEng;
+    AgpsStateMachine* sm = (AgpsStateMachine*)
+                           getAgpsStateMachine(*locEng, mType);
+    if (sm) {
+        ATLSubscriber s(mID,
+                        sm,
+                        locEng->adapter,
+                        AGPS_TYPE_INVALID == mType);
+        sm->subscribeRsrc((Subscriber*)&s);
+    } else {
+        locEng->adapter->atlOpenStatus(mID, 0, NULL, -1, mType);
+    }
+}
+inline void LocEngRequestATL::locallog() const {
+    LOC_LOGV("LocEngRequestATL");
+}
+inline void LocEngRequestATL::log() const {
+    locallog();
+}
+
+//        case LOC_ENG_MSG_RELEASE_ATL:
+LocEngReleaseATL::LocEngReleaseATL(void* locEng, int id) :
+    LocMsg(), mLocEng(locEng), mID(id) {
+    locallog();
+}
+void LocEngReleaseATL::proc() const {
+    loc_eng_data_s_type* locEng = (loc_eng_data_s_type*)mLocEng;
+
+   if (locEng->agnss_nif) {
+        ATLSubscriber s1(mID, locEng->agnss_nif, locEng->adapter, false);
+        if (locEng->agnss_nif->unsubscribeRsrc((Subscriber*)&s1)) {
+            LOC_LOGD("%s:%d]: Unsubscribed from agnss_nif",
+                     __func__, __LINE__);
+            return;
+        }
+    }
+
+    if (locEng->internet_nif) {
+        ATLSubscriber s2(mID, locEng->internet_nif, locEng->adapter, false);
+        if (locEng->internet_nif->unsubscribeRsrc((Subscriber*)&s2)) {
+            LOC_LOGD("%s:%d]: Unsubscribed from internet_nif",
+                     __func__, __LINE__);
+            return;
+        }
+    }
+
+    if (locEng->ds_nif) {
+        DSSubscriber s3(locEng->ds_nif, mID);
+        if (locEng->ds_nif->unsubscribeRsrc((Subscriber*)&s3)) {
+            LOC_LOGD("%s:%d]: Unsubscribed from ds_nif",
+                     __func__, __LINE__);
+            return;
+        }
+    }
+
+    LOC_LOGW("%s:%d]: Could not release ATL. "
+             "No subscribers found\n",
+             __func__, __LINE__);
+    locEng->adapter->atlCloseStatus(mID, 0);
+}
+inline void LocEngReleaseATL::locallog() const {
+    LOC_LOGV("LocEngReleaseATL");
+}
+inline void LocEngReleaseATL::log() const {
+    locallog();
+}
+
+//        case LOC_ENG_MSG_REQUEST_WIFI:
+//        case LOC_ENG_MSG_RELEASE_WIFI:
+LocEngReqRelWifi::LocEngReqRelWifi(void* locEng, AGpsExtType type,
+                                   loc_if_req_sender_id_e_type sender_id,
+                                   char* s, char* p, bool isReq) :
+    LocMsg(), mLocEng(locEng), mType(type), mSenderId(sender_id),
+    mSSID(NULL == s ? NULL : new char[SSID_BUF_SIZE]),
+    mPassword(NULL == p ? NULL : new char[SSID_BUF_SIZE]),
+    mIsReq(isReq) {
+    if (NULL != s)
+        strlcpy(mSSID, s, SSID_BUF_SIZE);
+    if (NULL != p)
+        strlcpy(mPassword, p, SSID_BUF_SIZE);
+    locallog();
+}
+LocEngReqRelWifi::~LocEngReqRelWifi() {
+    if (NULL != mSSID) {
+        delete[] mSSID;
+    }
+    if (NULL != mPassword) {
+        delete[] mPassword;
+    }
+}
+void LocEngReqRelWifi::proc() const {
+    loc_eng_data_s_type* locEng = (loc_eng_data_s_type*)mLocEng;
+    if (locEng->wifi_nif) {
+        WIFISubscriber s(locEng->wifi_nif, mSSID, mPassword, mSenderId);
+        if (mIsReq) {
+            locEng->wifi_nif->subscribeRsrc((Subscriber*)&s);
+        } else {
+            locEng->wifi_nif->unsubscribeRsrc((Subscriber*)&s);
+        }
+    } else {
+        locEng->adapter->atlOpenStatus(mSenderId, 0, NULL, -1, mType);
+    }
+}
+inline void LocEngReqRelWifi::locallog() const {
+    LOC_LOGV("%s - senderId: %d, ssid: %s, password: %s",
+             mIsReq ? "LocEngRequestWifi" : "LocEngReleaseWifi",
+             mSenderId,
+             NULL != mSSID ? mSSID : "",
+             NULL != mPassword ? mPassword : "");
+}
+inline void LocEngReqRelWifi::log() const {
+    locallog();
+}
+void LocEngReqRelWifi::send() const {
+    loc_eng_data_s_type* locEng = (loc_eng_data_s_type*)mLocEng;
+    locEng->adapter->sendMsg(this);
+}
+
+//        case LOC_ENG_MSG_REQUEST_XTRA_DATA:
+LocEngRequestXtra::LocEngRequestXtra(void* locEng) :
+    mLocEng(locEng) {
+    locallog();
+}
+void LocEngRequestXtra::proc() const
+{
+    loc_eng_xtra_data_s_type* locEngXtra =
+        &(((loc_eng_data_s_type*)mLocEng)->xtra_module_data);
+
+    if (locEngXtra->download_request_cb != NULL) {
+        CALLBACK_LOG_CALLFLOW("download_request_cb", %p, mLocEng);
+        locEngXtra->download_request_cb();
+    } else {
+        LOC_LOGE("Callback function for request xtra is NULL");
+    }
+}
+inline void LocEngRequestXtra::locallog() const {
+    LOC_LOGV("LocEngReqXtra");
+}
+inline void LocEngRequestXtra::log() const {
+    locallog();
+}
+
+//        case LOC_ENG_MSG_REQUEST_TIME:
+LocEngRequestTime::LocEngRequestTime(void* locEng) :
+    LocMsg(), mLocEng(locEng)
+{
+    locallog();
+}
+void LocEngRequestTime::proc() const {
+    loc_eng_data_s_type* locEng = (loc_eng_data_s_type*)mLocEng;
+    if (gps_conf.CAPABILITIES & GPS_CAPABILITY_ON_DEMAND_TIME) {
+        if (locEng->request_utc_time_cb != NULL) {
+            locEng->request_utc_time_cb();
+        } else {
+            LOC_LOGE("Callback function for request time is NULL");
+        }
+    }
+}
+inline void LocEngRequestTime::locallog() const {
+    LOC_LOGV("LocEngReqTime");
+}
+inline void LocEngRequestTime::log() const {
+    locallog();
+}
+
+//        case LOC_ENG_MSG_DELETE_AIDING_DATA:
+struct LocEngDelAidData : public LocMsg {
+    loc_eng_data_s_type* mLocEng;
+    const GpsAidingData mType;
+    inline LocEngDelAidData(loc_eng_data_s_type* locEng,
+                            GpsAidingData f) :
+        LocMsg(), mLocEng(locEng), mType(f)
+    {
+        locallog();
+    }
+    inline virtual void proc() const {
+        mLocEng->aiding_data_for_deletion = mType;
+        update_aiding_data_for_deletion(*mLocEng);
+    }
+    inline void locallog() const {
+        LOC_LOGV("aiding data msak %d", mType);
+    }
+    virtual void log() const {
+        locallog();
+    }
+};
+
+//        case LOC_ENG_MSG_ENABLE_DATA:
+struct LocEngEnableData : public LocMsg {
+    LocEngAdapter* mAdapter;
+    const int mEnable;
+    char* mAPN;
+    const int mLen;
+    inline LocEngEnableData(LocEngAdapter* adapter,
+                            const char* name, int len, int enable) :
+        LocMsg(), mAdapter(adapter),
+        mEnable(enable), mAPN(NULL), mLen(len)
+    {
+        if (NULL != name) {
+            mAPN = new char[len+1];
+            memcpy((void*)mAPN, (void*)name, len);
+            mAPN[len] = 0;
+        }
+        locallog();
+    }
+    inline ~LocEngEnableData() {
+        if (NULL != mAPN) {
+            delete[] mAPN;
+        }
+    }
+    inline virtual void proc() const {
+        mAdapter->enableData(mEnable);
+        if (NULL != mAPN) {
+            mAdapter->setAPN(mAPN, mLen);
+        }
+    }
+    inline void locallog() const {
+        LOC_LOGV("apn: %s\n  enable: %d",
+                 (NULL == mAPN) ? "NULL" : mAPN, mEnable);
+    }
+    inline virtual void log() const {
+        locallog();
+    }
+};
+
+//        case LOC_ENG_MSG_INJECT_XTRA_DATA:
+// loc_eng_xtra.cpp
+
+//        case LOC_ENG_MSG_SET_CAPABILITIES:
+struct LocEngSetCapabilities : public LocMsg {
+    loc_eng_data_s_type* mLocEng;
+    inline LocEngSetCapabilities(loc_eng_data_s_type* locEng) :
+        LocMsg(), mLocEng(locEng)
+    {
+        locallog();
+    }
+    inline virtual void proc() const {
+        if (NULL != mLocEng->set_capabilities_cb) {
+            LOC_LOGV("calling set_capabilities_cb 0x%x",
+                     gps_conf.CAPABILITIES);
+            mLocEng->set_capabilities_cb(gps_conf.CAPABILITIES);
+        } else {
+            LOC_LOGV("set_capabilities_cb is NULL.\n");
+        }
+    }
+    inline void locallog() const
+    {
+        LOC_LOGV("LocEngSetCapabilities");
+    }
+    inline virtual void log() const
+    {
+        locallog();
+    }
+};
+
+//        case LOC_ENG_MSG_LOC_INIT:
+struct LocEngInit : public LocMsg {
+    loc_eng_data_s_type* mLocEng;
+    inline LocEngInit(loc_eng_data_s_type* locEng) :
+        LocMsg(), mLocEng(locEng)
+    {
+        locallog();
+    }
+    inline virtual void proc() const {
+        loc_eng_reinit(*mLocEng);
+        // set the capabilities
+        mLocEng->adapter->sendMsg(new LocEngSetCapabilities(mLocEng));
+    }
+    inline void locallog() const
+    {
+        LOC_LOGV("LocEngInit");
+    }
+    inline virtual void log() const
+    {
+        locallog();
+    }
+};
+
+//        case LOC_ENG_MSG_REQUEST_XTRA_SERVER:
+// loc_eng_xtra.cpp
+
+//        case LOC_ENG_MSG_ATL_OPEN_SUCCESS:
+struct LocEngAtlOpenSuccess : public LocMsg {
+    AgpsStateMachine* mStateMachine;
+    const int mLen;
+    char* mAPN;
+    const AGpsBearerType mBearerType;
+    inline LocEngAtlOpenSuccess(AgpsStateMachine* statemachine,
+                                const char* name,
+                                int len,
+                                AGpsBearerType btype) :
+        LocMsg(),
+        mStateMachine(statemachine), mLen(len),
+        mAPN(new char[len+1]), mBearerType(btype)
+    {
+        memcpy((void*)mAPN, (void*)name, len);
+        mAPN[len] = 0;
+        locallog();
+    }
+    inline ~LocEngAtlOpenSuccess()
+    {
+        delete[] mAPN;
+    }
+    inline virtual void proc() const {
+        mStateMachine->setBearer(mBearerType);
+        mStateMachine->setAPN(mAPN, mLen);
+        mStateMachine->onRsrcEvent(RSRC_GRANTED);
+    }
+    inline void locallog() const {
+        LOC_LOGV("LocEngAtlOpenSuccess agps type: %s\n  apn: %s\n"
+                 "  bearer type: %s",
+                 loc_get_agps_type_name(mStateMachine->getType()),
+                 mAPN,
+                 loc_get_agps_bear_name(mBearerType));
+    }
+    inline virtual void log() const {
+        locallog();
+    }
+};
+
+//        case LOC_ENG_MSG_ATL_CLOSED:
+struct LocEngAtlClosed : public LocMsg {
+    AgpsStateMachine* mStateMachine;
+    inline LocEngAtlClosed(AgpsStateMachine* statemachine) :
+        LocMsg(), mStateMachine(statemachine) {
+        locallog();
+    }
+    inline virtual void proc() const {
+        mStateMachine->onRsrcEvent(RSRC_RELEASED);
+    }
+    inline void locallog() const {
+        LOC_LOGV("LocEngAtlClosed");
+    }
+    inline virtual void log() const {
+        locallog();
+    }
+};
+
+//        case LOC_ENG_MSG_ATL_OPEN_FAILED:
+struct LocEngAtlOpenFailed : public LocMsg {
+    AgpsStateMachine* mStateMachine;
+    inline LocEngAtlOpenFailed(AgpsStateMachine* statemachine) :
+        LocMsg(), mStateMachine(statemachine) {
+        locallog();
+    }
+    inline virtual void proc() const {
+        mStateMachine->onRsrcEvent(RSRC_DENIED);
+    }
+    inline void locallog() const {
+        LOC_LOGV("LocEngAtlOpenFailed");
+    }
+    inline virtual void log() const {
+        locallog();
+    }
+};
+
+//        case LOC_ENG_MSG_ENGINE_DOWN:
+LocEngDown::LocEngDown(void* locEng) :
+    LocMsg(), mLocEng(locEng) {
+    locallog();
+}
+inline void LocEngDown::proc() const {
+    loc_eng_data_s_type* locEng = (loc_eng_data_s_type*)mLocEng;
+    loc_eng_handle_engine_down(*locEng);
+}
+inline void LocEngDown::locallog() const {
+    LOC_LOGV("LocEngDown");
+}
+inline void LocEngDown::log() const {
+    locallog();
+}
+
+//        case LOC_ENG_MSG_ENGINE_UP:
+LocEngUp::LocEngUp(void* locEng) :
+    LocMsg(), mLocEng(locEng) {
+    locallog();
+}
+inline void LocEngUp::proc() const {
+    loc_eng_data_s_type* locEng = (loc_eng_data_s_type*)mLocEng;
+    loc_eng_handle_engine_up(*locEng);
+}
+inline void LocEngUp::locallog() const {
+    LOC_LOGV("LocEngUp");
+}
+inline void LocEngUp::log() const {
+    locallog();
+}
+
+struct LocEngDataClientInit : public LocMsg {
+    loc_eng_data_s_type* mLocEng;
+    inline LocEngDataClientInit(loc_eng_data_s_type* locEng) :
+        LocMsg(), mLocEng(locEng) {
+        locallog();
+    }
+    virtual void proc() const {
+        loc_eng_data_s_type *locEng = (loc_eng_data_s_type *)mLocEng;
+        if(!locEng->adapter->initDataServiceClient()) {
+            locEng->ds_nif = new DSStateMachine(servicerTypeExt,
+                                               (void *)dataCallCb,
+                                               locEng->adapter);
+        }
+    }
+    void locallog() const {
+        LOC_LOGV("LocEngDataClientInit\n");
+    }
+    virtual void log() const {
+        locallog();
+    }
+};
+
+struct LocEngInstallAGpsCert : public LocMsg {
+    LocEngAdapter* mpAdapter;
+    const size_t mNumberOfCerts;
+    const uint32_t mSlotBitMask;
+    DerEncodedCertificate* mpData;
+    inline LocEngInstallAGpsCert(LocEngAdapter* adapter,
+                              const DerEncodedCertificate* pData,
+                              size_t numberOfCerts,
+                              uint32_t slotBitMask) :
+        LocMsg(), mpAdapter(adapter),
+        mNumberOfCerts(numberOfCerts), mSlotBitMask(slotBitMask),
+        mpData(new DerEncodedCertificate[mNumberOfCerts])
+    {
+        for (int i=0; i < mNumberOfCerts; i++) {
+            mpData[i].data = new u_char[pData[i].length];
+            if (mpData[i].data) {
+                memcpy(mpData[i].data, (void*)pData[i].data, pData[i].length);
+                mpData[i].length = pData[i].length;
+            } else {
+                LOC_LOGE("malloc failed for cert#%d", i);
+                break;
+            }
+        }
+        locallog();
+    }
+    inline ~LocEngInstallAGpsCert()
+    {
+        for (int i=0; i < mNumberOfCerts; i++) {
+            if (mpData[i].data) {
+                delete[] mpData[i].data;
+            }
+        }
+        delete[] mpData;
+    }
+    inline virtual void proc() const {
+        mpAdapter->installAGpsCert(mpData, mNumberOfCerts, mSlotBitMask);
+    }
+    inline void locallog() const {
+        LOC_LOGV("LocEngInstallAGpsCert - certs=%u mask=%u",
+                 mNumberOfCerts, mSlotBitMask);
+    }
+    inline virtual void log() const {
+        locallog();
+    }
+};
+
+struct LocEngUpdateRegistrationMask : public LocMsg {
+    loc_eng_data_s_type* mLocEng;
+    LOC_API_ADAPTER_EVENT_MASK_T mMask;
+    loc_registration_mask_status mIsEnabled;
+    inline LocEngUpdateRegistrationMask(loc_eng_data_s_type* locEng,
+                                        LOC_API_ADAPTER_EVENT_MASK_T mask,
+                                        loc_registration_mask_status isEnabled) :
+        LocMsg(), mLocEng(locEng), mMask(mask), mIsEnabled(isEnabled) {
+        locallog();
+    }
+    inline virtual void proc() const {
+        loc_eng_data_s_type *locEng = (loc_eng_data_s_type *)mLocEng;
+        locEng->adapter->updateRegistrationMask(mMask,
+                                                mIsEnabled);
+    }
+    void locallog() const {
+        LOC_LOGV("LocEngUpdateRegistrationMask\n");
+    }
+    virtual void log() const {
+        locallog();
+    }
+};
+
+struct LocEngGnssConstellationConfig : public LocMsg {
+    LocEngAdapter* mAdapter;
+    inline LocEngGnssConstellationConfig(LocEngAdapter* adapter) :
+        LocMsg(), mAdapter(adapter) {
+        locallog();
+    }
+    inline virtual void proc() const {
+        if (mAdapter->gnssConstellationConfig()) {
+            LOC_LOGV("Modem supports GNSS measurements\n");
+            gps_conf.CAPABILITIES |= GPS_CAPABILITY_MEASUREMENTS;
+        } else {
+            LOC_LOGV("Modem does not support GNSS measurements\n");
+        }
+    }
+    void locallog() const {
+        LOC_LOGV("LocEngGnssConstellationConfig\n");
+    }
+    virtual void log() const {
+        locallog();
+    }
+};
+
+//        case LOC_ENG_MSG_REPORT_GNSS_MEASUREMENT:
+LocEngReportGpsMeasurement::LocEngReportGpsMeasurement(void* locEng,
+                                                       GpsData &gpsData) :
+    LocMsg(), mLocEng(locEng), mGpsData(gpsData)
+{
+    locallog();
+}
+void LocEngReportGpsMeasurement::proc() const {
+    loc_eng_data_s_type* locEng = (loc_eng_data_s_type*) mLocEng;
+    if (locEng->mute_session_state != LOC_MUTE_SESS_IN_SESSION)
+    {
+        if (locEng->gps_measurement_cb != NULL) {
+            locEng->gps_measurement_cb((GpsData*)&(mGpsData));
+        }
+    }
+}
+void LocEngReportGpsMeasurement::locallog() const {
+    IF_LOC_LOGV {
+        LOC_LOGV("%s:%d]: Received in GPS HAL."
+                 "GNSS Measurements count: %d \n",
+                 __func__, __LINE__, mGpsData.measurement_count);
+        for (int i =0; i< mGpsData.measurement_count && i < GPS_MAX_SVS; i++) {
+                LOC_LOGV(" GNSS measurement data in GPS HAL: \n"
+                         " GPS_HAL => Measurement ID | prn | time_offset_ns | state |"
+                         " received_gps_tow_ns| c_n0_dbhz | pseudorange_rate_mps |"
+                         " pseudorange_rate_uncertainty_mps |"
+                         " accumulated_delta_range_state | flags \n"
+                         " GPS_HAL => %d | %d | %f | %d | %lld | %f | %f | %f | %d | %d \n",
+                         i,
+                         mGpsData.measurements[i].prn,
+                         mGpsData.measurements[i].time_offset_ns,
+                         mGpsData.measurements[i].state,
+                         mGpsData.measurements[i].received_gps_tow_ns,
+                         mGpsData.measurements[i].c_n0_dbhz,
+                         mGpsData.measurements[i].pseudorange_rate_mps,
+                         mGpsData.measurements[i].pseudorange_rate_uncertainty_mps,
+                         mGpsData.measurements[i].accumulated_delta_range_state,
+                         mGpsData.measurements[i].flags);
+        }
+        LOC_LOGV(" GPS_HAL => Clocks Info: type | time_ns \n"
+                 " GPS_HAL => Clocks Info: %d | %lld", mGpsData.clock.type,
+                 mGpsData.clock.time_ns);
+    }
+}
+inline void LocEngReportGpsMeasurement::log() const {
+    locallog();
+}
+
+/*********************************************************************
+* Initialization checking macros
+ *********************************************************************/
+#define STATE_CHECK(ctx, x, ret) \
+    if (!(ctx))                  \
+  {                              \
+      /* Not intialized, abort */\
+      LOC_LOGE("%s: log_eng state error: %s", __func__, x); \
+      EXIT_LOG(%s, x);                                            \
+      ret;                                                        \
+  }
+#define INIT_CHECK(ctx, ret) STATE_CHECK(ctx, "instance not initialized", ret)
+
+/*===========================================================================
+FUNCTION    loc_eng_init
+
+DESCRIPTION
+   Initialize the location engine, this include setting up global datas
+   and registers location engien with loc api service.
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0: success
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_eng_init(loc_eng_data_s_type &loc_eng_data, LocCallbacks* callbacks,
+                 LOC_API_ADAPTER_EVENT_MASK_T event, ContextBase* context)
+
+{
+    int ret_val = 0;
+
+    ENTRY_LOG_CALLFLOW();
+    if (NULL == callbacks || 0 == event) {
+        LOC_LOGE("loc_eng_init: bad parameters cb %p eMask %d", callbacks, event);
+        ret_val = -1;
+        EXIT_LOG(%d, ret_val);
+        return ret_val;
+    }
+
+    STATE_CHECK((NULL == loc_eng_data.adapter),
+                "instance already initialized", return 0);
+
+    memset(&loc_eng_data, 0, sizeof (loc_eng_data));
+
+    // Save callbacks
+    loc_eng_data.location_cb  = callbacks->location_cb;
+    loc_eng_data.sv_status_cb = callbacks->sv_status_cb;
+    loc_eng_data.status_cb    = callbacks->status_cb;
+    loc_eng_data.nmea_cb      = callbacks->nmea_cb;
+    loc_eng_data.set_capabilities_cb = callbacks->set_capabilities_cb;
+    loc_eng_data.acquire_wakelock_cb = callbacks->acquire_wakelock_cb;
+    loc_eng_data.release_wakelock_cb = callbacks->release_wakelock_cb;
+    loc_eng_data.request_utc_time_cb = callbacks->request_utc_time_cb;
+    loc_eng_data.location_ext_parser = callbacks->location_ext_parser ?
+        callbacks->location_ext_parser : noProc;
+    loc_eng_data.sv_ext_parser = callbacks->sv_ext_parser ?
+        callbacks->sv_ext_parser : noProc;
+    loc_eng_data.intermediateFix = gps_conf.INTERMEDIATE_POS;
+    loc_eng_data.shutdown_cb = callbacks->shutdown_cb;
+    // initial states taken care of by the memset above
+    // loc_eng_data.engine_status -- GPS_STATUS_NONE;
+    // loc_eng_data.fix_session_status -- GPS_STATUS_NONE;
+    // loc_eng_data.mute_session_state -- LOC_MUTE_SESS_NONE;
+
+    if ((event & LOC_API_ADAPTER_BIT_NMEA_1HZ_REPORT) && (gps_conf.NMEA_PROVIDER == NMEA_PROVIDER_AP))
+    {
+        event = event ^ LOC_API_ADAPTER_BIT_NMEA_1HZ_REPORT; // unregister for modem NMEA report
+        loc_eng_data.generateNmea = true;
+    }
+    else
+    {
+        loc_eng_data.generateNmea = false;
+    }
+
+    loc_eng_data.adapter =
+        new LocEngAdapter(event, &loc_eng_data, context,
+                          (MsgTask::tCreate)callbacks->create_thread_cb);
+
+    LOC_LOGD("loc_eng_init created client, id = %p\n",
+             loc_eng_data.adapter);
+    loc_eng_data.adapter->sendMsg(new LocEngInit(&loc_eng_data));
+
+    EXIT_LOG(%d, ret_val);
+    return ret_val;
+}
+
+static int loc_eng_reinit(loc_eng_data_s_type &loc_eng_data)
+{
+    ENTRY_LOG();
+    int ret_val = LOC_API_ADAPTER_ERR_SUCCESS;
+
+    if (LOC_API_ADAPTER_ERR_SUCCESS == ret_val) {
+        LOC_LOGD("loc_eng_reinit reinit() successful");
+
+        LocEngAdapter* adapter = loc_eng_data.adapter;
+        adapter->sendMsg(new LocEngGnssConstellationConfig(adapter));
+        adapter->sendMsg(new LocEngSuplVer(adapter, gps_conf.SUPL_VER));
+        adapter->sendMsg(new LocEngLppConfig(adapter, gps_conf.LPP_PROFILE));
+        adapter->sendMsg(new LocEngSensorControlConfig(adapter, sap_conf.SENSOR_USAGE,
+                                                       sap_conf.SENSOR_PROVIDER));
+        adapter->sendMsg(new LocEngAGlonassProtocol(adapter, gps_conf.A_GLONASS_POS_PROTOCOL_SELECT));
+
+        /* Make sure at least one of the sensor property is specified by the user in the gps.conf file. */
+        if( sap_conf.GYRO_BIAS_RANDOM_WALK_VALID ||
+            sap_conf.ACCEL_RANDOM_WALK_SPECTRAL_DENSITY_VALID ||
+            sap_conf.ANGLE_RANDOM_WALK_SPECTRAL_DENSITY_VALID ||
+            sap_conf.RATE_RANDOM_WALK_SPECTRAL_DENSITY_VALID ||
+            sap_conf.VELOCITY_RANDOM_WALK_SPECTRAL_DENSITY_VALID )
+        {
+            adapter->sendMsg(new LocEngSensorProperties(adapter,
+                                                        sap_conf.GYRO_BIAS_RANDOM_WALK_VALID,
+                                                        sap_conf.GYRO_BIAS_RANDOM_WALK,
+                                                        sap_conf.ACCEL_RANDOM_WALK_SPECTRAL_DENSITY_VALID,
+                                                        sap_conf.ACCEL_RANDOM_WALK_SPECTRAL_DENSITY,
+                                                        sap_conf.ANGLE_RANDOM_WALK_SPECTRAL_DENSITY_VALID,
+                                                        sap_conf.ANGLE_RANDOM_WALK_SPECTRAL_DENSITY,
+                                                        sap_conf.RATE_RANDOM_WALK_SPECTRAL_DENSITY_VALID,
+                                                        sap_conf.RATE_RANDOM_WALK_SPECTRAL_DENSITY,
+                                                        sap_conf.VELOCITY_RANDOM_WALK_SPECTRAL_DENSITY_VALID,
+                                                        sap_conf.VELOCITY_RANDOM_WALK_SPECTRAL_DENSITY));
+        }
+
+        adapter->sendMsg(new LocEngSensorPerfControlConfig(adapter,
+                                                           sap_conf.SENSOR_CONTROL_MODE,
+                                                           sap_conf.SENSOR_ACCEL_SAMPLES_PER_BATCH,
+                                                           sap_conf.SENSOR_ACCEL_BATCHES_PER_SEC,
+                                                           sap_conf.SENSOR_GYRO_SAMPLES_PER_BATCH,
+                                                           sap_conf.SENSOR_GYRO_BATCHES_PER_SEC,
+                                                           sap_conf.SENSOR_ACCEL_SAMPLES_PER_BATCH_HIGH,
+                                                           sap_conf.SENSOR_ACCEL_BATCHES_PER_SEC_HIGH,
+                                                           sap_conf.SENSOR_GYRO_SAMPLES_PER_BATCH_HIGH,
+                                                           sap_conf.SENSOR_GYRO_BATCHES_PER_SEC_HIGH,
+                                                           sap_conf.SENSOR_ALGORITHM_CONFIG_MASK));
+
+        adapter->sendMsg(new LocEngEnableData(adapter, NULL, 0, (agpsStatus ? 1:0)));
+    }
+
+    EXIT_LOG(%d, ret_val);
+    return ret_val;
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_cleanup
+
+DESCRIPTION
+   Cleans location engine. The location client handle will be released.
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   None
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+void loc_eng_cleanup(loc_eng_data_s_type &loc_eng_data)
+{
+    ENTRY_LOG_CALLFLOW();
+    INIT_CHECK(loc_eng_data.adapter, return);
+
+    // XTRA has no state, so we are fine with it.
+
+    // we need to check and clear NI
+#if 0
+    // we need to check and clear ATL
+    if (NULL != loc_eng_data.agnss_nif) {
+        delete loc_eng_data.agnss_nif;
+        loc_eng_data.agnss_nif = NULL;
+    }
+    if (NULL != loc_eng_data.internet_nif) {
+        delete loc_eng_data.internet_nif;
+        loc_eng_data.internet_nif = NULL;
+    }
+#endif
+    if (loc_eng_data.adapter->isInSession())
+    {
+        LOC_LOGD("loc_eng_cleanup: fix not stopped. stop it now.");
+        loc_eng_stop(loc_eng_data);
+    }
+
+#if 0 // can't afford to actually clean up, for many reason.
+
+    LOC_LOGD("loc_eng_init: client opened. close it now.");
+    delete loc_eng_data.adapter;
+    loc_eng_data.adapter = NULL;
+
+    loc_eng_dmn_conn_loc_api_server_unblock();
+    loc_eng_dmn_conn_loc_api_server_join();
+
+#endif
+
+    EXIT_LOG(%s, VOID_RET);
+}
+
+
+/*===========================================================================
+FUNCTION    loc_eng_start
+
+DESCRIPTION
+   Starts the tracking session
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0: success
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_eng_start(loc_eng_data_s_type &loc_eng_data)
+{
+   ENTRY_LOG_CALLFLOW();
+   INIT_CHECK(loc_eng_data.adapter, return -1);
+
+   if(! loc_eng_data.adapter->getUlpProxy()->sendStartFix())
+   {
+       loc_eng_data.adapter->sendMsg(new LocEngStartFix(loc_eng_data.adapter));
+   }
+
+   EXIT_LOG(%d, 0);
+   return 0;
+}
+
+static int loc_eng_start_handler(loc_eng_data_s_type &loc_eng_data)
+{
+   ENTRY_LOG();
+   int ret_val = LOC_API_ADAPTER_ERR_SUCCESS;
+
+   if (!loc_eng_data.adapter->isInSession()) {
+       ret_val = loc_eng_data.adapter->startFix();
+
+       if (ret_val == LOC_API_ADAPTER_ERR_SUCCESS ||
+           ret_val == LOC_API_ADAPTER_ERR_ENGINE_DOWN)
+       {
+           loc_eng_data.adapter->setInSession(TRUE);
+           loc_inform_gps_status(loc_eng_data, GPS_STATUS_SESSION_BEGIN);
+       }
+   }
+
+   EXIT_LOG(%d, ret_val);
+   return ret_val;
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_stop_wrapper
+
+DESCRIPTION
+   Stops the tracking session
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0: success
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_eng_stop(loc_eng_data_s_type &loc_eng_data)
+{
+    ENTRY_LOG_CALLFLOW();
+    INIT_CHECK(loc_eng_data.adapter, return -1);
+
+    if(! loc_eng_data.adapter->getUlpProxy()->sendStopFix())
+    {
+        loc_eng_data.adapter->sendMsg(new LocEngStopFix(loc_eng_data.adapter));
+    }
+
+    EXIT_LOG(%d, 0);
+    return 0;
+}
+
+static int loc_eng_stop_handler(loc_eng_data_s_type &loc_eng_data)
+{
+   ENTRY_LOG();
+   int ret_val = LOC_API_ADAPTER_ERR_SUCCESS;
+
+   if (loc_eng_data.adapter->isInSession()) {
+
+       ret_val = loc_eng_data.adapter->stopFix();
+       if (ret_val == LOC_API_ADAPTER_ERR_SUCCESS)
+       {
+           loc_inform_gps_status(loc_eng_data, GPS_STATUS_SESSION_END);
+       }
+
+       loc_eng_data.adapter->setInSession(FALSE);
+   }
+
+    EXIT_LOG(%d, ret_val);
+    return ret_val;
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_mute_one_session
+
+DESCRIPTION
+   Mutes one session
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0: Success
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+void loc_eng_mute_one_session(loc_eng_data_s_type &loc_eng_data)
+{
+    ENTRY_LOG();
+    loc_eng_data.mute_session_state = LOC_MUTE_SESS_WAIT;
+    EXIT_LOG(%s, VOID_RET);
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_set_position_mode
+
+DESCRIPTION
+   Sets the mode and fix frequency for the tracking session.
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0: success
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_eng_set_position_mode(loc_eng_data_s_type &loc_eng_data,
+                              LocPosMode &params)
+{
+    ENTRY_LOG_CALLFLOW();
+    INIT_CHECK(loc_eng_data.adapter, return -1);
+
+    int gnssType = getTargetGnssType(loc_get_target());
+
+    // The position mode for GSS/QCA1530 can only be standalone
+    bool is1530 = gnssType == GNSS_QCA1530;
+    bool isAPQ = gnssType == GNSS_GSS;
+    if ((isAPQ || is1530) && params.mode != LOC_POSITION_MODE_STANDALONE) {
+        params.mode = LOC_POSITION_MODE_STANDALONE;
+        LOC_LOGD("Position mode changed to standalone for target with GSS/qca1530.");
+    }
+
+    if(! loc_eng_data.adapter->getUlpProxy()->sendFixMode(params))
+    {
+        LocEngAdapter* adapter = loc_eng_data.adapter;
+        adapter->sendMsg(new LocEngPositionMode(adapter, params));
+    }
+
+    EXIT_LOG(%d, 0);
+    return 0;
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_inject_time
+
+DESCRIPTION
+   This is used by Java native function to do time injection.
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_eng_inject_time(loc_eng_data_s_type &loc_eng_data, GpsUtcTime time,
+                        int64_t timeReference, int uncertainty)
+{
+    ENTRY_LOG_CALLFLOW();
+    INIT_CHECK(loc_eng_data.adapter, return -1);
+    LocEngAdapter* adapter = loc_eng_data.adapter;
+
+    adapter->sendMsg(new LocEngSetTime(adapter, time, timeReference,
+                                       uncertainty));
+
+    EXIT_LOG(%d, 0);
+    return 0;
+}
+
+
+/*===========================================================================
+FUNCTION    loc_eng_inject_location
+
+DESCRIPTION
+   This is used by Java native function to do location injection.
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0          : Successful
+   error code : Failure
+
+SIDE EFFECTS
+   N/A
+===========================================================================*/
+int loc_eng_inject_location(loc_eng_data_s_type &loc_eng_data, double latitude,
+                            double longitude, float accuracy)
+{
+    ENTRY_LOG_CALLFLOW();
+    INIT_CHECK(loc_eng_data.adapter, return -1);
+    LocEngAdapter* adapter = loc_eng_data.adapter;
+    if(adapter->mSupportsPositionInjection)
+    {
+        adapter->sendMsg(new LocEngInjectLocation(adapter, latitude, longitude,
+                                                  accuracy));
+    }
+
+    EXIT_LOG(%d, 0);
+    return 0;
+}
+
+
+/*===========================================================================
+FUNCTION    loc_eng_delete_aiding_data
+
+DESCRIPTION
+   This is used by Java native function to delete the aiding data. The function
+   updates the global variable for the aiding data to be deleted. If the GPS
+   engine is off, the aiding data will be deleted. Otherwise, the actual action
+   will happen when gps engine is turned off.
+
+DEPENDENCIES
+   Assumes the aiding data type specified in GpsAidingData matches with
+   LOC API specification.
+
+RETURN VALUE
+   None
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+void loc_eng_delete_aiding_data(loc_eng_data_s_type &loc_eng_data, GpsAidingData f)
+{
+    ENTRY_LOG_CALLFLOW();
+    INIT_CHECK(loc_eng_data.adapter, return);
+
+    loc_eng_data.adapter->sendMsg(new LocEngDelAidData(&loc_eng_data, f));
+
+    EXIT_LOG(%s, VOID_RET);
+}
+
+/*===========================================================================
+
+FUNCTION    loc_inform_gps_state
+
+DESCRIPTION
+   Informs the GPS Provider about the GPS status
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   None
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static void loc_inform_gps_status(loc_eng_data_s_type &loc_eng_data, GpsStatusValue status)
+{
+    ENTRY_LOG();
+
+    if (loc_eng_data.status_cb)
+    {
+        GpsStatus gs = { sizeof(gs),status };
+        CALLBACK_LOG_CALLFLOW("status_cb", %s,
+                              loc_get_gps_status_name(gs.status));
+        loc_eng_data.status_cb(&gs);
+    }
+
+    EXIT_LOG(%s, VOID_RET);
+}
+
+static int loc_eng_get_zpp_handler(loc_eng_data_s_type &loc_eng_data)
+{
+   ENTRY_LOG();
+   int ret_val = LOC_API_ADAPTER_ERR_SUCCESS;
+   UlpLocation location;
+   LocPosTechMask tech_mask = LOC_POS_TECH_MASK_DEFAULT;
+   GpsLocationExtended locationExtended;
+   memset(&locationExtended, 0, sizeof (GpsLocationExtended));
+   locationExtended.size = sizeof(locationExtended);
+   memset(&location, 0, sizeof location);
+
+   ret_val = loc_eng_data.adapter->getZpp(location.gpsLocation, tech_mask);
+  //Mark the location source as from ZPP
+  location.gpsLocation.flags |= LOCATION_HAS_SOURCE_INFO;
+  location.position_source = ULP_LOCATION_IS_FROM_ZPP;
+
+  loc_eng_data.adapter->getUlpProxy()->reportPosition(location,
+                                     locationExtended,
+                                     NULL,
+                                     LOC_SESS_SUCCESS,
+                                     tech_mask);
+
+  EXIT_LOG(%d, ret_val);
+  return ret_val;
+}
+
+/*
+  Callback function passed to Data Services State Machine
+  This becomes part of the state machine's servicer and
+  is used to send requests to the data services client
+*/
+static int dataCallCb(void *cb_data)
+{
+    LOC_LOGD("Enter dataCallCb\n");
+    int ret=0;
+    if(cb_data != NULL) {
+        dsCbData *cbData = (dsCbData *)cb_data;
+        LocEngAdapter *locAdapter = (LocEngAdapter *)cbData->mAdapter;
+        if(cbData->action == GPS_REQUEST_AGPS_DATA_CONN) {
+            LOC_LOGD("dataCallCb GPS_REQUEST_AGPS_DATA_CONN\n");
+            ret =  locAdapter->openAndStartDataCall();
+        }
+        else if(cbData->action == GPS_RELEASE_AGPS_DATA_CONN) {
+            LOC_LOGD("dataCallCb GPS_RELEASE_AGPS_DATA_CONN\n");
+            locAdapter->stopDataCall();
+        }
+    }
+    else {
+        LOC_LOGE("NULL argument received. Failing.\n");
+        ret = -1;
+        goto err;
+    }
+
+err:
+    LOC_LOGD("Exit dataCallCb ret = %d\n", ret);
+    return ret;
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_agps_reinit
+
+DESCRIPTION
+   2nd half of loc_eng_agps_init(), singled out for modem restart to use.
+
+DEPENDENCIES
+   NONE
+
+RETURN VALUE
+   0
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static void loc_eng_agps_reinit(loc_eng_data_s_type &loc_eng_data)
+{
+    ENTRY_LOG();
+
+    // Set server addresses which came before init
+    if (loc_eng_data.supl_host_set)
+    {
+        loc_eng_set_server(loc_eng_data, LOC_AGPS_SUPL_SERVER,
+                           loc_eng_data.supl_host_buf,
+                           loc_eng_data.supl_port_buf);
+    }
+
+    if (loc_eng_data.c2k_host_set)
+    {
+        loc_eng_set_server(loc_eng_data, LOC_AGPS_CDMA_PDE_SERVER,
+                           loc_eng_data.c2k_host_buf,
+                           loc_eng_data.c2k_port_buf);
+    }
+    EXIT_LOG(%s, VOID_RET);
+}
+/*===========================================================================
+FUNCTION    loc_eng_agps_init
+
+DESCRIPTION
+   Initialize the AGps interface.
+
+DEPENDENCIES
+   NONE
+
+RETURN VALUE
+   0
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+void loc_eng_agps_init(loc_eng_data_s_type &loc_eng_data, AGpsExtCallbacks* callbacks)
+{
+    ENTRY_LOG_CALLFLOW();
+    INIT_CHECK(loc_eng_data.adapter, return);
+    STATE_CHECK((NULL == loc_eng_data.agps_status_cb),
+                "agps instance already initialized",
+                return);
+    if (callbacks == NULL) {
+        LOC_LOGE("loc_eng_agps_init: bad parameters cb %p", callbacks);
+        EXIT_LOG(%s, VOID_RET);
+        return;
+    }
+    LocEngAdapter* adapter = loc_eng_data.adapter;
+    loc_eng_data.agps_status_cb = callbacks->status_cb;
+
+    loc_eng_data.internet_nif = new AgpsStateMachine(servicerTypeAgps,
+                                                     (void *)loc_eng_data.agps_status_cb,
+                                                     AGPS_TYPE_WWAN_ANY,
+                                                     false);
+    loc_eng_data.wifi_nif = new AgpsStateMachine(servicerTypeAgps,
+                                                 (void *)loc_eng_data.agps_status_cb,
+                                                 AGPS_TYPE_WIFI,
+                                                 true);
+
+    int gnssType = getTargetGnssType(loc_get_target());
+    bool isAPQ = (gnssType == GNSS_GSS);
+    bool is1530 = (gnssType == GNSS_QCA1530);
+    if (!isAPQ && !is1530) {
+        loc_eng_data.agnss_nif = new AgpsStateMachine(servicerTypeAgps,
+                                                      (void *)loc_eng_data.agps_status_cb,
+                                                      AGPS_TYPE_SUPL,
+                                                      false);
+
+        if (adapter->mSupportsAgpsRequests) {
+            loc_eng_data.adapter->sendMsg(new LocEngDataClientInit(&loc_eng_data));
+
+            loc_eng_dmn_conn_loc_api_server_launch(callbacks->create_thread_cb,
+                                                   NULL, NULL, &loc_eng_data);
+        }
+        loc_eng_agps_reinit(loc_eng_data);
+    }
+
+    EXIT_LOG(%s, VOID_RET);
+}
+
+static void deleteAidingData(loc_eng_data_s_type &logEng) {
+    if (logEng.engine_status != GPS_STATUS_ENGINE_ON &&
+        logEng.aiding_data_for_deletion != 0) {
+        logEng.adapter->deleteAidingData(logEng.aiding_data_for_deletion);
+        logEng.aiding_data_for_deletion = 0;
+    }
+}
+
+static AgpsStateMachine*
+getAgpsStateMachine(loc_eng_data_s_type &locEng, AGpsExtType agpsType) {
+    AgpsStateMachine* stateMachine;
+    switch (agpsType) {
+    case AGPS_TYPE_WIFI: {
+        stateMachine = locEng.wifi_nif;
+        break;
+    }
+    case AGPS_TYPE_INVALID:
+    case AGPS_TYPE_SUPL: {
+        stateMachine = locEng.agnss_nif;
+        break;
+    }
+    case AGPS_TYPE_SUPL_ES: {
+        stateMachine = locEng.ds_nif;
+        break;
+    }
+    default:
+        stateMachine  = locEng.internet_nif;
+    }
+    return stateMachine;
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_agps_open
+
+DESCRIPTION
+   This function is called when on-demand data connection opening is successful.
+It should inform engine about the data open result.
+
+DEPENDENCIES
+   NONE
+
+RETURN VALUE
+   0
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_eng_agps_open(loc_eng_data_s_type &loc_eng_data, AGpsExtType agpsType,
+                     const char* apn, AGpsBearerType bearerType)
+{
+    ENTRY_LOG_CALLFLOW();
+    INIT_CHECK(loc_eng_data.adapter && loc_eng_data.agps_status_cb,
+               return -1);
+
+    if (apn == NULL)
+    {
+        LOC_LOGE("APN Name NULL\n");
+        return 0;
+    }
+
+    LOC_LOGD("loc_eng_agps_open APN name = [%s]", apn);
+
+    int apn_len = smaller_of(strlen (apn), MAX_APN_LEN);
+    AgpsStateMachine* sm = getAgpsStateMachine(loc_eng_data, agpsType);
+
+    loc_eng_data.adapter->sendMsg(
+        new LocEngAtlOpenSuccess(sm, apn, apn_len, bearerType));
+
+    EXIT_LOG(%d, 0);
+    return 0;
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_agps_closed
+
+DESCRIPTION
+   This function is called when on-demand data connection closing is done.
+It should inform engine about the data close result.
+
+DEPENDENCIES
+   NONE
+
+RETURN VALUE
+   0
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_eng_agps_closed(loc_eng_data_s_type &loc_eng_data, AGpsExtType agpsType)
+{
+    ENTRY_LOG_CALLFLOW();
+    INIT_CHECK(loc_eng_data.adapter && loc_eng_data.agps_status_cb,
+               return -1);
+
+    AgpsStateMachine* sm = getAgpsStateMachine(loc_eng_data, agpsType);
+    loc_eng_data.adapter->sendMsg(new LocEngAtlClosed(sm));
+
+    EXIT_LOG(%d, 0);
+    return 0;
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_agps_open_failed
+
+DESCRIPTION
+   This function is called when on-demand data connection opening has failed.
+It should inform engine about the data open result.
+
+DEPENDENCIES
+   NONE
+
+RETURN VALUE
+   0
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_eng_agps_open_failed(loc_eng_data_s_type &loc_eng_data, AGpsExtType agpsType)
+{
+    ENTRY_LOG_CALLFLOW();
+    INIT_CHECK(loc_eng_data.adapter && loc_eng_data.agps_status_cb,
+               return -1);
+
+    AgpsStateMachine* sm = getAgpsStateMachine(loc_eng_data, agpsType);
+    loc_eng_data.adapter->sendMsg(new LocEngAtlOpenFailed(sm));
+
+    EXIT_LOG(%d, 0);
+    return 0;
+}
+
+/*===========================================================================
+
+FUNCTION resolve_in_addr
+
+DESCRIPTION
+   Translates a hostname to in_addr struct
+
+DEPENDENCIES
+   n/a
+
+RETURN VALUE
+   TRUE if successful
+
+SIDE EFFECTS
+   n/a
+
+===========================================================================*/
+static boolean resolve_in_addr(const char *host_addr, struct in_addr *in_addr_ptr)
+{
+    ENTRY_LOG();
+    boolean ret_val = TRUE;
+
+    struct hostent             *hp;
+    hp = gethostbyname(host_addr);
+    if (hp != NULL) /* DNS OK */
+    {
+        memcpy(in_addr_ptr, hp->h_addr_list[0], hp->h_length);
+    }
+    else
+    {
+        /* Try IP representation */
+        if (inet_aton(host_addr, in_addr_ptr) == 0)
+        {
+            /* IP not valid */
+            LOC_LOGE("DNS query on '%s' failed\n", host_addr);
+            ret_val = FALSE;
+        }
+    }
+
+    EXIT_LOG(%s, loc_logger_boolStr[ret_val!=0]);
+    return ret_val;
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_set_server
+
+DESCRIPTION
+   This is used to set the default AGPS server. Server address is obtained
+   from gps.conf.
+
+DEPENDENCIES
+   NONE
+
+RETURN VALUE
+   0
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static int loc_eng_set_server(loc_eng_data_s_type &loc_eng_data,
+                              LocServerType type, const char* hostname, int port)
+{
+    ENTRY_LOG();
+    int ret = 0;
+    LocEngAdapter* adapter = loc_eng_data.adapter;
+
+    if (LOC_AGPS_SUPL_SERVER == type) {
+        char url[MAX_URL_LEN];
+        unsigned int len = 0;
+        const char nohost[] = "NONE";
+        if (hostname == NULL ||
+            strncasecmp(nohost, hostname, sizeof(nohost)) == 0) {
+            url[0] = NULL;
+        } else {
+            len = snprintf(url, sizeof(url), "%s:%u", hostname, (unsigned) port);
+        }
+
+        if (sizeof(url) > len) {
+            adapter->sendMsg(new LocEngSetServerUrl(adapter, url, len));
+        }
+    } else if (LOC_AGPS_CDMA_PDE_SERVER == type ||
+               LOC_AGPS_CUSTOM_PDE_SERVER == type ||
+               LOC_AGPS_MPC_SERVER == type) {
+        struct in_addr addr;
+        if (!resolve_in_addr(hostname, &addr))
+        {
+            LOC_LOGE("loc_eng_set_server, hostname %s cannot be resolved.\n", hostname);
+            ret = -2;
+        } else {
+            unsigned int ip = htonl(addr.s_addr);
+            adapter->sendMsg(new LocEngSetServerIpv4(adapter, ip, port, type));
+        }
+    } else {
+        LOC_LOGE("loc_eng_set_server, type %d cannot be resolved.\n", type);
+    }
+
+    EXIT_LOG(%d, ret);
+    return ret;
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_set_server_proxy
+
+DESCRIPTION
+   If loc_eng_set_server is called before loc_eng_init, it doesn't work. This
+   proxy buffers server settings and calls loc_eng_set_server when the client is
+   open.
+
+DEPENDENCIES
+   NONE
+
+RETURN VALUE
+   0
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_eng_set_server_proxy(loc_eng_data_s_type &loc_eng_data,
+                             LocServerType type,
+                             const char* hostname, int port)
+{
+    ENTRY_LOG_CALLFLOW();
+    int ret_val = 0;
+
+    LOC_LOGV("save the address, type: %d, hostname: %s, port: %d",
+             (int) type, hostname, port);
+    switch (type)
+    {
+    case LOC_AGPS_SUPL_SERVER:
+        strlcpy(loc_eng_data.supl_host_buf, hostname,
+                sizeof(loc_eng_data.supl_host_buf));
+        loc_eng_data.supl_port_buf = port;
+        loc_eng_data.supl_host_set = 1;
+        break;
+    case LOC_AGPS_CDMA_PDE_SERVER:
+        strlcpy(loc_eng_data.c2k_host_buf, hostname,
+                sizeof(loc_eng_data.c2k_host_buf));
+        loc_eng_data.c2k_port_buf = port;
+        loc_eng_data.c2k_host_set = 1;
+        break;
+    default:
+        LOC_LOGE("loc_eng_set_server_proxy, unknown server type = %d", (int) type);
+    }
+
+    if (NULL != loc_eng_data.adapter)
+    {
+        ret_val = loc_eng_set_server(loc_eng_data, type, hostname, port);
+    }
+
+    EXIT_LOG(%d, ret_val);
+    return ret_val;
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_agps_ril_update_network_availability
+
+DESCRIPTION
+   Sets data call allow vs disallow flag to modem
+   This is the only member of sLocEngAGpsRilInterface implemented.
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0: success
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+void loc_eng_agps_ril_update_network_availability(loc_eng_data_s_type &loc_eng_data,
+                                                  int available, const char* apn)
+{
+    ENTRY_LOG_CALLFLOW();
+
+    //This is to store the status of data availability over the network.
+    //If GPS is not enabled, the INIT_CHECK will fail and the modem will
+    //not be updated with the network's availability. Since the data status
+    //can change before GPS is enabled the, storing the status will enable
+    //us to inform the modem after GPS is enabled
+    agpsStatus = available;
+
+    INIT_CHECK(loc_eng_data.adapter, return);
+    if (apn != NULL)
+    {
+        LOC_LOGD("loc_eng_agps_ril_update_network_availability: APN Name = [%s]\n", apn);
+        int apn_len = smaller_of(strlen (apn), MAX_APN_LEN);
+        LocEngAdapter* adapter = loc_eng_data.adapter;
+        adapter->sendMsg(new LocEngEnableData(adapter, apn,  apn_len, available));
+    }
+    EXIT_LOG(%s, VOID_RET);
+}
+
+int loc_eng_agps_install_certificates(loc_eng_data_s_type &loc_eng_data,
+                                      const DerEncodedCertificate* certificates,
+                                      size_t numberOfCerts)
+{
+    ENTRY_LOG_CALLFLOW();
+    int ret_val = AGPS_CERTIFICATE_OPERATION_SUCCESS;
+
+    uint32_t slotBitMask = gps_conf.AGPS_CERT_WRITABLE_MASK;
+    uint32_t slotCount = 0;
+    for (uint32_t slotBitMaskCounter=slotBitMask; slotBitMaskCounter; slotCount++) {
+        slotBitMaskCounter &= slotBitMaskCounter - 1;
+    }
+    LOC_LOGD("SlotBitMask=%u SlotCount=%u NumberOfCerts=%u",
+             slotBitMask, slotCount, numberOfCerts);
+
+    LocEngAdapter* adapter = loc_eng_data.adapter;
+
+    if (numberOfCerts == 0) {
+        LOC_LOGE("No certs to install, since numberOfCerts is zero");
+        ret_val = AGPS_CERTIFICATE_OPERATION_SUCCESS;
+    } else if (!adapter) {
+        LOC_LOGE("adapter is null!");
+        ret_val = AGPS_CERTIFICATE_ERROR_GENERIC;
+    } else if (slotCount < numberOfCerts) {
+        LOC_LOGE("Not enough cert slots (%u) to install %u certs!",
+                 slotCount, numberOfCerts);
+        ret_val = AGPS_CERTIFICATE_ERROR_TOO_MANY_CERTIFICATES;
+    } else {
+        for (int i=0; i < numberOfCerts; ++i)
+        {
+            if (certificates[i].length > AGPS_CERTIFICATE_MAX_LENGTH) {
+                LOC_LOGE("cert#(%u) length of %u is too big! greater than %u",
+                        certificates[i].length, AGPS_CERTIFICATE_MAX_LENGTH);
+                ret_val = AGPS_CERTIFICATE_ERROR_GENERIC;
+                break;
+            }
+        }
+
+        if (ret_val == AGPS_CERTIFICATE_OPERATION_SUCCESS) {
+            adapter->sendMsg(new LocEngInstallAGpsCert(adapter,
+                                                       certificates,
+                                                       numberOfCerts,
+                                                       slotBitMask));
+        }
+    }
+
+    EXIT_LOG(%d, ret_val);
+    return ret_val;
+}
+
+void loc_eng_configuration_update (loc_eng_data_s_type &loc_eng_data,
+                                   const char* config_data, int32_t length)
+{
+    ENTRY_LOG_CALLFLOW();
+
+    if (config_data && length > 0) {
+        loc_gps_cfg_s_type gps_conf_tmp = gps_conf;
+        UTIL_UPDATE_CONF(config_data, length, gps_conf_table);
+        LocEngAdapter* adapter = loc_eng_data.adapter;
+
+        // it is possible that HAL is not init'ed at this time
+        if (adapter) {
+            if (gps_conf_tmp.SUPL_VER != gps_conf.SUPL_VER) {
+                adapter->sendMsg(new LocEngSuplVer(adapter, gps_conf.SUPL_VER));
+            }
+            if (gps_conf_tmp.LPP_PROFILE != gps_conf.LPP_PROFILE) {
+                adapter->sendMsg(new LocEngLppConfig(adapter, gps_conf.LPP_PROFILE));
+            }
+            if (gps_conf_tmp.A_GLONASS_POS_PROTOCOL_SELECT != gps_conf.A_GLONASS_POS_PROTOCOL_SELECT) {
+                adapter->sendMsg(new LocEngAGlonassProtocol(adapter,
+                                                            gps_conf.A_GLONASS_POS_PROTOCOL_SELECT));
+            }
+        }
+
+        gps_conf_tmp.SUPL_VER = gps_conf.SUPL_VER;
+        gps_conf_tmp.LPP_PROFILE = gps_conf.LPP_PROFILE;
+        gps_conf_tmp.A_GLONASS_POS_PROTOCOL_SELECT = gps_conf.A_GLONASS_POS_PROTOCOL_SELECT;
+        gps_conf_tmp.GPS_LOCK = gps_conf.GPS_LOCK;
+        gps_conf = gps_conf_tmp;
+    }
+
+    EXIT_LOG(%s, VOID_RET);
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_report_status
+
+DESCRIPTION
+   Reports GPS engine state to Java layer.
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   N/A
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static void loc_eng_report_status (loc_eng_data_s_type &loc_eng_data, GpsStatusValue status)
+{
+    ENTRY_LOG();
+    // Switch from WAIT to MUTE, for "engine on" or "session begin" event
+    if (status == GPS_STATUS_SESSION_BEGIN || status == GPS_STATUS_ENGINE_ON)
+    {
+        if (loc_eng_data.mute_session_state == LOC_MUTE_SESS_WAIT)
+        {
+            LOC_LOGD("loc_eng_report_status: mute_session_state changed from WAIT to IN SESSION");
+            loc_eng_data.mute_session_state = LOC_MUTE_SESS_IN_SESSION;
+        }
+    }
+
+    // Switch off MUTE session
+    if (loc_eng_data.mute_session_state == LOC_MUTE_SESS_IN_SESSION &&
+        (status == GPS_STATUS_SESSION_END || status == GPS_STATUS_ENGINE_OFF))
+    {
+        LOC_LOGD("loc_eng_report_status: mute_session_state changed from IN SESSION to NONE");
+        loc_eng_data.mute_session_state = LOC_MUTE_SESS_NONE;
+    }
+
+    // Session End is not reported during Android navigating state
+    boolean navigating = loc_eng_data.adapter->isInSession();
+    if (status != GPS_STATUS_NONE &&
+        !(status == GPS_STATUS_SESSION_END && navigating) &&
+        !(status == GPS_STATUS_SESSION_BEGIN && !navigating))
+    {
+        if (loc_eng_data.mute_session_state != LOC_MUTE_SESS_IN_SESSION)
+        {
+            // Inform GpsLocationProvider about mNavigating status
+            loc_inform_gps_status(loc_eng_data, status);
+        }
+        else {
+            LOC_LOGD("loc_eng_report_status: muting the status report.");
+        }
+    }
+
+    // Only keeps ENGINE ON/OFF in engine_status
+    if (status == GPS_STATUS_ENGINE_ON || status == GPS_STATUS_ENGINE_OFF)
+    {
+        loc_eng_data.engine_status = status;
+    }
+
+    // Only keeps SESSION BEGIN/END in fix_session_status
+    if (status == GPS_STATUS_SESSION_BEGIN || status == GPS_STATUS_SESSION_END)
+    {
+        loc_eng_data.fix_session_status = status;
+    }
+    EXIT_LOG(%s, VOID_RET);
+}
+
+/*===========================================================================
+FUNCTION loc_eng_handle_engine_down
+         loc_eng_handle_engine_up
+
+DESCRIPTION
+   Calls this function when it is detected that modem restart is happening.
+   Either we detected the modem is down or received modem up event.
+   This must be called from the deferred thread to avoid race condition.
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   None
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+void loc_eng_handle_engine_down(loc_eng_data_s_type &loc_eng_data)
+{
+    ENTRY_LOG();
+    loc_eng_ni_reset_on_engine_restart(loc_eng_data);
+    loc_eng_report_status(loc_eng_data, GPS_STATUS_ENGINE_OFF);
+    EXIT_LOG(%s, VOID_RET);
+}
+
+void loc_eng_handle_engine_up(loc_eng_data_s_type &loc_eng_data)
+{
+    ENTRY_LOG();
+    loc_eng_reinit(loc_eng_data);
+
+    loc_eng_data.adapter->requestPowerVote();
+
+    if (loc_eng_data.agps_status_cb != NULL) {
+        if (loc_eng_data.agnss_nif)
+            loc_eng_data.agnss_nif->dropAllSubscribers();
+        if (loc_eng_data.internet_nif)
+            loc_eng_data.internet_nif->dropAllSubscribers();
+
+        loc_eng_agps_reinit(loc_eng_data);
+    }
+
+    loc_eng_report_status(loc_eng_data, GPS_STATUS_ENGINE_ON);
+
+    // modem is back up.  If we crashed in the middle of navigating, we restart.
+    if (loc_eng_data.adapter->isInSession()) {
+        // This sets the copy in adapter to modem
+        loc_eng_data.adapter->setPositionMode(NULL);
+        loc_eng_data.adapter->setInSession(false);
+        loc_eng_start_handler(loc_eng_data);
+    }
+    EXIT_LOG(%s, VOID_RET);
+}
+
+#ifdef USE_GLIB
+/*===========================================================================
+FUNCTION set_sched_policy
+
+DESCRIPTION
+   Local copy of this function which bypasses android set_sched_policy
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static int set_sched_policy(int tid, SchedPolicy policy)
+{
+    return 0;
+}
+#endif /* USE_GLIB */
+
+/*===========================================================================
+FUNCTION    loc_eng_read_config
+
+DESCRIPTION
+   Initiates the reading of the gps config file stored in /etc dir
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0: success
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_eng_read_config(void)
+{
+    ENTRY_LOG_CALLFLOW();
+    if(configAlreadyRead == false)
+    {
+      // Initialize our defaults before reading of configuration file overwrites them.
+      loc_default_parameters();
+      // We only want to parse the conf file once. This is a good place to ensure that.
+      // In fact one day the conf file should go into context.
+      UTIL_READ_CONF(GPS_CONF_FILE, gps_conf_table);
+      UTIL_READ_CONF(SAP_CONF_FILE, sap_conf_table);
+      configAlreadyRead = true;
+    } else {
+      LOC_LOGV("GPS Config file has already been read\n");
+    }
+
+    EXIT_LOG(%d, 0);
+    return 0;
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_handle_shutdown
+
+DESCRIPTION
+   Calls the shutdown callback function in the loc interface to close
+   the modem node
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0: success
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+void loc_eng_handle_shutdown(loc_eng_data_s_type &locEng)
+{
+    ENTRY_LOG();
+    locEng.shutdown_cb();
+    EXIT_LOG(%d, 0);
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_gps_measurement_init
+
+DESCRIPTION
+   Initialize gps measurement module.
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   0: success
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_eng_gps_measurement_init(loc_eng_data_s_type &loc_eng_data,
+                                 GpsMeasurementCallbacks* callbacks)
+{
+    ENTRY_LOG_CALLFLOW();
+
+    STATE_CHECK((NULL == loc_eng_data.gps_measurement_cb),
+                "gps measurement already initialized",
+                return GPS_MEASUREMENT_ERROR_ALREADY_INIT);
+    STATE_CHECK((callbacks != NULL),
+                "callbacks can not be NULL",
+                return GPS_MEASUREMENT_ERROR_GENERIC);
+    STATE_CHECK(loc_eng_data.adapter,
+                "GpsInterface must be initialized first",
+                return GPS_MEASUREMENT_ERROR_GENERIC);
+
+    // updated the mask
+    LOC_API_ADAPTER_EVENT_MASK_T event = LOC_API_ADAPTER_BIT_GNSS_MEASUREMENT;
+    loc_eng_data.adapter->sendMsg(new LocEngUpdateRegistrationMask(
+                                                        &loc_eng_data,
+                                                        event,
+                                                        LOC_REGISTRATION_MASK_ENABLED));
+    // set up the callback
+    loc_eng_data.gps_measurement_cb = callbacks->measurement_callback;
+    LOC_LOGD ("%s, event masks updated successfully", __func__);
+
+    return GPS_MEASUREMENT_OPERATION_SUCCESS;
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_gps_measurement_close
+
+DESCRIPTION
+   Close gps measurement module.
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   N/A
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+void loc_eng_gps_measurement_close(loc_eng_data_s_type &loc_eng_data)
+{
+    ENTRY_LOG_CALLFLOW();
+
+    INIT_CHECK(loc_eng_data.adapter, return);
+
+    // updated the mask
+    LOC_API_ADAPTER_EVENT_MASK_T event = LOC_API_ADAPTER_BIT_GNSS_MEASUREMENT;
+    loc_eng_data.adapter->sendMsg(new LocEngUpdateRegistrationMask(
+                                                          &loc_eng_data,
+                                                          event,
+                                                          LOC_REGISTRATION_MASK_DISABLED));
+    // set up the callback
+    loc_eng_data.gps_measurement_cb = NULL;
+    EXIT_LOG(%d, 0);
+}
diff --git a/msm8974/loc_api/libloc_api_50001/loc_eng.h b/msm8974/loc_api/libloc_api_50001/loc_eng.h
new file mode 100644
index 0000000..e954953
--- /dev/null
+++ b/msm8974/loc_api/libloc_api_50001/loc_eng.h
@@ -0,0 +1,272 @@
+/* Copyright (c) 2009-2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef LOC_ENG_H
+#define LOC_ENG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+// Uncomment to keep all LOG messages (LOGD, LOGI, LOGV, etc.)
+#define MAX_NUM_ATL_CONNECTIONS  2
+
+// Define boolean type to be used by libgps on loc api module
+typedef unsigned char boolean;
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#include <loc.h>
+#include <loc_eng_xtra.h>
+#include <loc_eng_ni.h>
+#include <loc_eng_agps.h>
+#include <loc_cfg.h>
+#include <loc_log.h>
+#include <log_util.h>
+#include <loc_eng_agps.h>
+#include <LocEngAdapter.h>
+
+// The data connection minimal open time
+#define DATA_OPEN_MIN_TIME        1  /* sec */
+
+// The system sees GPS engine turns off after inactive for this period of time
+#define GPS_AUTO_OFF_TIME         2  /* secs */
+#define SUCCESS              TRUE
+#define FAILURE                 FALSE
+#define INVALID_ATL_CONNECTION_HANDLE -1
+
+#define MAX_XTRA_SERVER_URL_LENGTH 256
+
+enum loc_nmea_provider_e_type {
+    NMEA_PROVIDER_AP = 0, // Application Processor Provider of NMEA
+    NMEA_PROVIDER_MP // Modem Processor Provider of NMEA
+};
+
+enum loc_mute_session_e_type {
+   LOC_MUTE_SESS_NONE = 0,
+   LOC_MUTE_SESS_WAIT,
+   LOC_MUTE_SESS_IN_SESSION
+};
+
+// Module data
+typedef struct loc_eng_data_s
+{
+    LocEngAdapter                  *adapter;
+    loc_location_cb_ext            location_cb;
+    gps_status_callback            status_cb;
+    loc_sv_status_cb_ext           sv_status_cb;
+    agps_status_extended           agps_status_cb;
+    gps_nmea_callback              nmea_cb;
+    gps_ni_notify_callback         ni_notify_cb;
+    gps_set_capabilities           set_capabilities_cb;
+    gps_acquire_wakelock           acquire_wakelock_cb;
+    gps_release_wakelock           release_wakelock_cb;
+    gps_request_utc_time           request_utc_time_cb;
+    gps_measurement_callback       gps_measurement_cb;
+    boolean                        intermediateFix;
+    AGpsStatusValue                agps_status;
+    loc_eng_xtra_data_s_type       xtra_module_data;
+    loc_eng_ni_data_s_type         loc_eng_ni_data;
+
+    // AGPS state machines
+    AgpsStateMachine*              agnss_nif;
+    AgpsStateMachine*              internet_nif;
+    AgpsStateMachine*              wifi_nif;
+    //State machine for Data Services
+    AgpsStateMachine*              ds_nif;
+
+    // GPS engine status
+    GpsStatusValue                 engine_status;
+    GpsStatusValue                 fix_session_status;
+
+    // Aiding data information to be deleted, aiding data can only be deleted when GPS engine is off
+    GpsAidingData                  aiding_data_for_deletion;
+
+    // For muting session broadcast
+    loc_mute_session_e_type        mute_session_state;
+
+    // For nmea generation
+    boolean generateNmea;
+    uint32_t sv_used_mask;
+    float hdop;
+    float pdop;
+    float vdop;
+
+    // Address buffers, for addressing setting before init
+    int    supl_host_set;
+    char   supl_host_buf[101];
+    int    supl_port_buf;
+    int    c2k_host_set;
+    char   c2k_host_buf[101];
+    int    c2k_port_buf;
+    int    mpc_host_set;
+    char   mpc_host_buf[101];
+    int    mpc_port_buf;
+
+    loc_ext_parser location_ext_parser;
+    loc_ext_parser sv_ext_parser;
+    loc_shutdown_cb shutdown_cb;
+} loc_eng_data_s_type;
+
+/* GPS.conf support */
+/* NOTE: the implementaiton of the parser casts number
+   fields to 32 bit. To ensure all 'n' fields working,
+   they must all be 32 bit fields. */
+typedef struct loc_gps_cfg_s
+{
+    uint32_t       INTERMEDIATE_POS;
+    uint32_t       ACCURACY_THRES;
+    uint32_t       SUPL_VER;
+    uint32_t       CAPABILITIES;
+    uint32_t       LPP_PROFILE;
+    uint32_t       NMEA_PROVIDER;
+    uint32_t       GPS_LOCK;
+    uint32_t       A_GLONASS_POS_PROTOCOL_SELECT;
+    uint32_t       AGPS_CERT_WRITABLE_MASK;
+    char           XTRA_SERVER_1[MAX_XTRA_SERVER_URL_LENGTH];
+    char           XTRA_SERVER_2[MAX_XTRA_SERVER_URL_LENGTH];
+    char           XTRA_SERVER_3[MAX_XTRA_SERVER_URL_LENGTH];
+} loc_gps_cfg_s_type;
+
+/* NOTE: the implementaiton of the parser casts number
+   fields to 32 bit. To ensure all 'n' fields working,
+   they must all be 32 bit fields. */
+/* Meanwhile, *_valid fields are 8 bit fields, and 'f'
+   fields are double. Rigid as they are, it is the
+   the status quo, until the parsing mechanism is
+   change, that is. */
+typedef struct
+{
+    uint8_t        GYRO_BIAS_RANDOM_WALK_VALID;
+    double         GYRO_BIAS_RANDOM_WALK;
+    uint32_t       SENSOR_ACCEL_BATCHES_PER_SEC;
+    uint32_t       SENSOR_ACCEL_SAMPLES_PER_BATCH;
+    uint32_t       SENSOR_GYRO_BATCHES_PER_SEC;
+    uint32_t       SENSOR_GYRO_SAMPLES_PER_BATCH;
+    uint32_t       SENSOR_ACCEL_BATCHES_PER_SEC_HIGH;
+    uint32_t       SENSOR_ACCEL_SAMPLES_PER_BATCH_HIGH;
+    uint32_t       SENSOR_GYRO_BATCHES_PER_SEC_HIGH;
+    uint32_t       SENSOR_GYRO_SAMPLES_PER_BATCH_HIGH;
+    uint32_t       SENSOR_CONTROL_MODE;
+    uint32_t       SENSOR_USAGE;
+    uint32_t       SENSOR_ALGORITHM_CONFIG_MASK;
+    uint8_t        ACCEL_RANDOM_WALK_SPECTRAL_DENSITY_VALID;
+    double         ACCEL_RANDOM_WALK_SPECTRAL_DENSITY;
+    uint8_t        ANGLE_RANDOM_WALK_SPECTRAL_DENSITY_VALID;
+    double         ANGLE_RANDOM_WALK_SPECTRAL_DENSITY;
+    uint8_t        RATE_RANDOM_WALK_SPECTRAL_DENSITY_VALID;
+    double         RATE_RANDOM_WALK_SPECTRAL_DENSITY;
+    uint8_t        VELOCITY_RANDOM_WALK_SPECTRAL_DENSITY_VALID;
+    double         VELOCITY_RANDOM_WALK_SPECTRAL_DENSITY;
+    uint32_t       SENSOR_PROVIDER;
+} loc_sap_cfg_s_type;
+
+extern loc_gps_cfg_s_type gps_conf;
+extern loc_sap_cfg_s_type sap_conf;
+
+int  loc_eng_init(loc_eng_data_s_type &loc_eng_data,
+                  LocCallbacks* callbacks,
+                  LOC_API_ADAPTER_EVENT_MASK_T event,
+                  ContextBase* context);
+int  loc_eng_start(loc_eng_data_s_type &loc_eng_data);
+int  loc_eng_stop(loc_eng_data_s_type &loc_eng_data);
+void loc_eng_cleanup(loc_eng_data_s_type &loc_eng_data);
+int  loc_eng_inject_time(loc_eng_data_s_type &loc_eng_data,
+                         GpsUtcTime time, int64_t timeReference,
+                         int uncertainty);
+int  loc_eng_inject_location(loc_eng_data_s_type &loc_eng_data,
+                             double latitude, double longitude,
+                             float accuracy);
+void loc_eng_delete_aiding_data(loc_eng_data_s_type &loc_eng_data,
+                                GpsAidingData f);
+int  loc_eng_set_position_mode(loc_eng_data_s_type &loc_eng_data,
+                               LocPosMode &params);
+const void* loc_eng_get_extension(loc_eng_data_s_type &loc_eng_data,
+                                  const char* name);
+void loc_eng_agps_init(loc_eng_data_s_type &loc_eng_data,
+                       AGpsExtCallbacks* callbacks);
+int  loc_eng_agps_open(loc_eng_data_s_type &loc_eng_data, AGpsExtType agpsType,
+                      const char* apn, AGpsBearerType bearerType);
+int  loc_eng_agps_closed(loc_eng_data_s_type &loc_eng_data, AGpsExtType agpsType);
+int  loc_eng_agps_open_failed(loc_eng_data_s_type &loc_eng_data, AGpsExtType agpsType);
+
+int  loc_eng_set_server_proxy(loc_eng_data_s_type &loc_eng_data,
+                              LocServerType type, const char *hostname, int port);
+
+
+void loc_eng_agps_ril_update_network_availability(loc_eng_data_s_type &loc_eng_data,
+                                                  int avaiable, const char* apn);
+
+
+bool loc_eng_inject_raw_command(loc_eng_data_s_type &loc_eng_data,
+                                char* command, int length);
+
+
+void loc_eng_mute_one_session(loc_eng_data_s_type &loc_eng_data);
+
+int loc_eng_xtra_init (loc_eng_data_s_type &loc_eng_data,
+                       GpsXtraExtCallbacks* callbacks);
+
+int loc_eng_xtra_inject_data(loc_eng_data_s_type &loc_eng_data,
+                             char* data, int length);
+
+int loc_eng_xtra_request_server(loc_eng_data_s_type &loc_eng_data);
+
+extern void loc_eng_ni_init(loc_eng_data_s_type &loc_eng_data,
+                            GpsNiExtCallbacks *callbacks);
+extern void loc_eng_ni_respond(loc_eng_data_s_type &loc_eng_data,
+                               int notif_id, GpsUserResponseType user_response);
+extern void loc_eng_ni_request_handler(loc_eng_data_s_type &loc_eng_data,
+                                   const GpsNiNotification *notif,
+                                   const void* passThrough);
+extern void loc_eng_ni_reset_on_engine_restart(loc_eng_data_s_type &loc_eng_data);
+
+int loc_eng_read_config(void);
+
+int loc_eng_agps_install_certificates(loc_eng_data_s_type &loc_eng_data,
+                                      const DerEncodedCertificate* certificates,
+                                      size_t length);
+
+void loc_eng_configuration_update (loc_eng_data_s_type &loc_eng_data,
+                                   const char* config_data, int32_t length);
+int loc_eng_gps_measurement_init(loc_eng_data_s_type &loc_eng_data,
+                                 GpsMeasurementCallbacks* callbacks);
+void loc_eng_gps_measurement_close(loc_eng_data_s_type &loc_eng_data);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif // LOC_ENG_H
diff --git a/msm8974/loc_api/libloc_api_50001/loc_eng_agps.cpp b/msm8974/loc_api/libloc_api_50001/loc_eng_agps.cpp
new file mode 100644
index 0000000..d90d5d3
--- /dev/null
+++ b/msm8974/loc_api/libloc_api_50001/loc_eng_agps.cpp
@@ -0,0 +1,971 @@
+/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#define LOG_NDDEBUG 0
+#define LOG_TAG "LocSvc_eng"
+
+#include <loc_eng_agps.h>
+#include <loc_eng_log.h>
+#include <log_util.h>
+#include <platform_lib_includes.h>
+#include <loc_eng_dmn_conn_handler.h>
+#include <loc_eng_dmn_conn.h>
+#include <sys/time.h>
+
+//======================================================================
+// C callbacks
+//======================================================================
+
+// This is given to linked_list_add as the dealloc callback
+// data -- an instance of Subscriber
+static void deleteObj(void* data)
+{
+    delete (Subscriber*)data;
+}
+
+// This is given to linked_list_search() as the comparison callback
+// when the state manchine needs to process for particular subscriber
+// fromCaller -- caller provides this obj
+// fromList -- linked_list_search() function take this one from list
+static bool hasSubscriber(void* fromCaller, void* fromList)
+{
+    Notification* notification = (Notification*)fromCaller;
+    Subscriber* s1 = (Subscriber*)fromList;
+
+    return s1->forMe(*notification);
+}
+
+// This is gvien to linked_list_search() to notify subscriber objs
+// when the state machine needs to inform all subscribers of resource
+// status changes, e.g. when resource is GRANTED.
+// fromCaller -- caller provides this ptr to a Notification obj.
+// fromList -- linked_list_search() function take this one from list
+static bool notifySubscriber(void* fromCaller, void* fromList)
+{
+    Notification* notification = (Notification*)fromCaller;
+    Subscriber* s1 = (Subscriber*)fromList;
+
+    // we notify every subscriber indiscriminatively
+    // each subscriber decides if this notification is interesting.
+    return s1->notifyRsrcStatus(*notification) &&
+           // if we do not want to delete the subscriber from the
+           // the list, we must set this to false so this function
+           // returns false
+           notification->postNotifyDelete;
+}
+
+//======================================================================
+// Notification
+//======================================================================
+const int Notification::BROADCAST_ALL = 0x80000000;
+const int Notification::BROADCAST_ACTIVE = 0x80000001;
+const int Notification::BROADCAST_INACTIVE = 0x80000002;
+const unsigned char DSStateMachine::MAX_START_DATA_CALL_RETRIES = 4;
+const unsigned int DSStateMachine::DATA_CALL_RETRY_DELAY_MSEC = 500;
+//======================================================================
+// Subscriber:  BITSubscriber / ATLSubscriber / WIFISubscriber
+//======================================================================
+bool Subscriber::forMe(Notification &notification)
+{
+    if (NULL != notification.rcver) {
+        return equals(notification.rcver);
+    } else {
+        return Notification::BROADCAST_ALL == notification.groupID ||
+            (Notification::BROADCAST_ACTIVE == notification.groupID &&
+             !isInactive()) ||
+            (Notification::BROADCAST_INACTIVE == notification.groupID &&
+             isInactive());
+    }
+}
+bool BITSubscriber::equals(const Subscriber *s) const
+{
+    BITSubscriber* bitS = (BITSubscriber*)s;
+
+    return (ID == bitS->ID &&
+            (INADDR_NONE != (unsigned int)ID ||
+             0 == strncmp(mIPv6Addr, bitS->mIPv6Addr, sizeof(mIPv6Addr))));
+}
+
+bool BITSubscriber::notifyRsrcStatus(Notification &notification)
+{
+    bool notify = forMe(notification);
+
+    if (notify) {
+        switch(notification.rsrcStatus)
+        {
+        case RSRC_UNSUBSCRIBE:
+        case RSRC_RELEASED:
+            loc_eng_dmn_conn_loc_api_server_data_conn(
+                LOC_ENG_IF_REQUEST_SENDER_ID_GPSONE_DAEMON,
+                GPSONE_LOC_API_IF_RELEASE_SUCCESS);
+            break;
+        case RSRC_DENIED:
+            loc_eng_dmn_conn_loc_api_server_data_conn(
+                LOC_ENG_IF_REQUEST_SENDER_ID_GPSONE_DAEMON,
+                GPSONE_LOC_API_IF_FAILURE);
+            break;
+        case RSRC_GRANTED:
+            loc_eng_dmn_conn_loc_api_server_data_conn(
+                LOC_ENG_IF_REQUEST_SENDER_ID_GPSONE_DAEMON,
+                GPSONE_LOC_API_IF_REQUEST_SUCCESS);
+            break;
+        default:
+            notify = false;
+        }
+    }
+
+    return notify;
+}
+
+bool ATLSubscriber::notifyRsrcStatus(Notification &notification)
+{
+    bool notify = forMe(notification);
+
+    if (notify) {
+        switch(notification.rsrcStatus)
+        {
+        case RSRC_UNSUBSCRIBE:
+        case RSRC_RELEASED:
+            ((LocEngAdapter*)mLocAdapter)->atlCloseStatus(ID, 1);
+            break;
+        case RSRC_DENIED:
+        {
+            AGpsExtType type = mBackwardCompatibleMode ?
+                              AGPS_TYPE_INVALID : mStateMachine->getType();
+            ((LocEngAdapter*)mLocAdapter)->atlOpenStatus(ID, 0,
+                                            (char*)mStateMachine->getAPN(),
+                                            mStateMachine->getBearer(),
+                                            type);
+        }
+            break;
+        case RSRC_GRANTED:
+        {
+            AGpsExtType type = mBackwardCompatibleMode ?
+                              AGPS_TYPE_INVALID : mStateMachine->getType();
+            ((LocEngAdapter*)mLocAdapter)->atlOpenStatus(ID, 1,
+                                            (char*)mStateMachine->getAPN(),
+                                            mStateMachine->getBearer(),
+                                            type);
+        }
+            break;
+        default:
+            notify = false;
+        }
+    }
+
+    return notify;
+}
+
+bool WIFISubscriber::notifyRsrcStatus(Notification &notification)
+{
+    bool notify = forMe(notification);
+
+    if (notify) {
+        switch(notification.rsrcStatus)
+        {
+        case RSRC_UNSUBSCRIBE:
+            break;
+        case RSRC_RELEASED:
+            loc_eng_dmn_conn_loc_api_server_data_conn(
+                senderId,
+                GPSONE_LOC_API_IF_RELEASE_SUCCESS);
+            break;
+        case RSRC_DENIED:
+            loc_eng_dmn_conn_loc_api_server_data_conn(
+                senderId,
+                GPSONE_LOC_API_IF_FAILURE);
+            break;
+        case RSRC_GRANTED:
+            loc_eng_dmn_conn_loc_api_server_data_conn(
+                senderId,
+                GPSONE_LOC_API_IF_REQUEST_SUCCESS);
+            break;
+        default:
+            notify = false;
+        }
+    }
+
+    return notify;
+}
+bool DSSubscriber::notifyRsrcStatus(Notification &notification)
+{
+    bool notify = forMe(notification);
+    LOC_LOGD("DSSubscriber::notifyRsrcStatus. notify:%d \n",(int)(notify));
+    if(notify) {
+        switch(notification.rsrcStatus) {
+        case RSRC_UNSUBSCRIBE:
+        case RSRC_RELEASED:
+        case RSRC_DENIED:
+        case RSRC_GRANTED:
+            ((DSStateMachine *)mStateMachine)->informStatus(notification.rsrcStatus, ID);
+            break;
+        default:
+            notify = false;
+        }
+    }
+    return notify;
+}
+void DSSubscriber :: setInactive()
+{
+    mIsInactive = true;
+    ((DSStateMachine *)mStateMachine)->informStatus(RSRC_UNSUBSCRIBE, ID);
+}
+//======================================================================
+// AgpsState:  AgpsReleasedState / AgpsPendingState / AgpsAcquiredState
+//======================================================================
+
+// AgpsReleasedState
+class AgpsReleasedState : public AgpsState
+{
+    friend class AgpsStateMachine;
+
+    inline AgpsReleasedState(AgpsStateMachine* stateMachine) :
+        AgpsState(stateMachine)
+    { mReleasedState = this; }
+
+    inline ~AgpsReleasedState() {}
+public:
+    virtual AgpsState* onRsrcEvent(AgpsRsrcStatus event, void* data);
+    inline virtual char* whoami() {return (char*)"AgpsReleasedState";}
+};
+
+AgpsState* AgpsReleasedState::onRsrcEvent(AgpsRsrcStatus event, void* data)
+{
+    LOC_LOGD("AgpsReleasedState::onRsrcEvent; event:%d\n", (int)event);
+    if (mStateMachine->hasSubscribers()) {
+        LOC_LOGE("Error: %s subscriber list not empty!!!", whoami());
+        // I don't know how to recover from it.  I am adding this rather
+        // for debugging purpose.
+    }
+
+    AgpsState* nextState = this;
+    switch (event)
+    {
+    case RSRC_SUBSCRIBE:
+    {
+        // no notification until we get RSRC_GRANTED
+        // but we need to add subscriber to the list
+        mStateMachine->addSubscriber((Subscriber*)data);
+        // request from connecivity service for NIF
+        //The if condition is added so that if the data call setup fails
+        //for DS State Machine, we want to retry in released state.
+        //for AGps State Machine, sendRsrcRequest() will always return success
+        if(!mStateMachine->sendRsrcRequest(GPS_REQUEST_AGPS_DATA_CONN)) {
+            // move the state to PENDING
+            nextState = mPendingState;
+        }
+    }
+    break;
+
+    case RSRC_UNSUBSCRIBE:
+    {
+        // the list should really be empty, nothing to remove.
+        // but we might as well just tell the client it is
+        // unsubscribed.  False tolerance, right?
+        Subscriber* subscriber = (Subscriber*) data;
+        Notification notification(subscriber, event, false);
+        subscriber->notifyRsrcStatus(notification);
+    }
+        // break;
+    case RSRC_GRANTED:
+    case RSRC_RELEASED:
+    case RSRC_DENIED:
+    default:
+        LOC_LOGW("%s: unrecognized event %d", whoami(), event);
+        // no state change.
+        break;
+    }
+
+    LOC_LOGD("onRsrcEvent, old state %s, new state %s, event %d",
+             whoami(), nextState->whoami(), event);
+    return nextState;
+}
+
+// AgpsPendingState
+class AgpsPendingState : public AgpsState
+{
+    friend class AgpsStateMachine;
+
+    inline AgpsPendingState(AgpsStateMachine* stateMachine) :
+        AgpsState(stateMachine)
+    { mPendingState = this; }
+
+    inline ~AgpsPendingState() {}
+public:
+    virtual AgpsState* onRsrcEvent(AgpsRsrcStatus event, void* data);
+    inline virtual char* whoami() {return (char*)"AgpsPendingState";}
+};
+
+AgpsState* AgpsPendingState::onRsrcEvent(AgpsRsrcStatus event, void* data)
+{
+    AgpsState* nextState = this;;
+    LOC_LOGD("AgpsPendingState::onRsrcEvent; event:%d\n", (int)event);
+    switch (event)
+    {
+    case RSRC_SUBSCRIBE:
+    {
+        // already requested for NIF resource,
+        // do nothing until we get RSRC_GRANTED indication
+        // but we need to add subscriber to the list
+        mStateMachine->addSubscriber((Subscriber*)data);
+        // no state change.
+    }
+        break;
+
+    case RSRC_UNSUBSCRIBE:
+    {
+        Subscriber* subscriber = (Subscriber*) data;
+        if (subscriber->waitForCloseComplete()) {
+            subscriber->setInactive();
+        } else {
+            // auto notify this subscriber of the unsubscribe
+            Notification notification(subscriber, event, true);
+            mStateMachine->notifySubscribers(notification);
+        }
+
+        // now check if there is any subscribers left
+        if (!mStateMachine->hasSubscribers()) {
+            // no more subscribers, move to RELEASED state
+            nextState = mReleasedState;
+
+            // tell connecivity service we can release NIF
+            mStateMachine->sendRsrcRequest(GPS_RELEASE_AGPS_DATA_CONN);
+        } else if (!mStateMachine->hasActiveSubscribers()) {
+            // only inactive subscribers, move to RELEASING state
+            nextState = mReleasingState;
+
+            // tell connecivity service we can release NIF
+            mStateMachine->sendRsrcRequest(GPS_RELEASE_AGPS_DATA_CONN);
+        }
+    }
+    break;
+
+    case RSRC_GRANTED:
+    {
+        nextState = mAcquiredState;
+        Notification notification(Notification::BROADCAST_ACTIVE, event, false);
+        // notify all subscribers NIF resource GRANTED
+        // by setting false, we keep subscribers on the linked list
+        mStateMachine->notifySubscribers(notification);
+    }
+        break;
+
+    case RSRC_RELEASED:
+        // no state change.
+        // we are expecting either GRANTED or DENIED.  Handling RELEASED
+        // may like break our state machine in race conditions.
+        break;
+
+    case RSRC_DENIED:
+    {
+        nextState = mReleasedState;
+        Notification notification(Notification::BROADCAST_ALL, event, true);
+        // notify all subscribers NIF resource RELEASED or DENIED
+        // by setting true, we remove subscribers from the linked list
+        mStateMachine->notifySubscribers(notification);
+    }
+        break;
+
+    default:
+        LOC_LOGE("%s: unrecognized event %d", whoami(), event);
+        // no state change.
+    }
+
+    LOC_LOGD("onRsrcEvent, old state %s, new state %s, event %d",
+             whoami(), nextState->whoami(), event);
+    return nextState;
+}
+
+
+class AgpsAcquiredState : public AgpsState
+{
+    friend class AgpsStateMachine;
+
+    inline AgpsAcquiredState(AgpsStateMachine* stateMachine) :
+        AgpsState(stateMachine)
+    { mAcquiredState = this; }
+
+    inline ~AgpsAcquiredState() {}
+public:
+    virtual AgpsState* onRsrcEvent(AgpsRsrcStatus event, void* data);
+    inline virtual char* whoami() { return (char*)"AgpsAcquiredState"; }
+};
+
+
+AgpsState* AgpsAcquiredState::onRsrcEvent(AgpsRsrcStatus event, void* data)
+{
+    AgpsState* nextState = this;
+    LOC_LOGD("AgpsAcquiredState::onRsrcEvent; event:%d\n", (int)event);
+    switch (event)
+    {
+    case RSRC_SUBSCRIBE:
+    {
+        // we already have the NIF resource, simply notify subscriber
+        Subscriber* subscriber = (Subscriber*) data;
+        // we have rsrc in hand, so grant it right away
+        Notification notification(subscriber, RSRC_GRANTED, false);
+        subscriber->notifyRsrcStatus(notification);
+        // add subscriber to the list
+        mStateMachine->addSubscriber(subscriber);
+        // no state change.
+    }
+        break;
+
+    case RSRC_UNSUBSCRIBE:
+    {
+        Subscriber* subscriber = (Subscriber*) data;
+        if (subscriber->waitForCloseComplete()) {
+            subscriber->setInactive();
+        } else {
+            // auto notify this subscriber of the unsubscribe
+            Notification notification(subscriber, event, true);
+            mStateMachine->notifySubscribers(notification);
+        }
+
+        // now check if there is any subscribers left
+        if (!mStateMachine->hasSubscribers()) {
+            // no more subscribers, move to RELEASED state
+            nextState = mReleasedState;
+
+            // tell connecivity service we can release NIF
+            mStateMachine->sendRsrcRequest(GPS_RELEASE_AGPS_DATA_CONN);
+        } else if (!mStateMachine->hasActiveSubscribers()) {
+            // only inactive subscribers, move to RELEASING state
+            nextState = mReleasingState;
+
+            // tell connecivity service we can release NIF
+            mStateMachine->sendRsrcRequest(GPS_RELEASE_AGPS_DATA_CONN);
+        }
+    }
+        break;
+
+    case RSRC_GRANTED:
+        LOC_LOGW("%s: %d, RSRC_GRANTED already received", whoami(), event);
+        // no state change.
+        break;
+
+    case RSRC_RELEASED:
+    {
+        LOC_LOGW("%s: %d, a force rsrc release", whoami(), event);
+        nextState = mReleasedState;
+        Notification notification(Notification::BROADCAST_ALL, event, true);
+        // by setting true, we remove subscribers from the linked list
+        mStateMachine->notifySubscribers(notification);
+    }
+        break;
+
+    case RSRC_DENIED:
+        // no state change.
+        // we are expecting RELEASED.  Handling DENIED
+        // may like break our state machine in race conditions.
+        break;
+
+    default:
+        LOC_LOGE("%s: unrecognized event %d", whoami(), event);
+        // no state change.
+    }
+
+    LOC_LOGD("onRsrcEvent, old state %s, new state %s, event %d",
+             whoami(), nextState->whoami(), event);
+    return nextState;
+}
+
+// AgpsPendingState
+class AgpsReleasingState : public AgpsState
+{
+    friend class AgpsStateMachine;
+
+    inline AgpsReleasingState(AgpsStateMachine* stateMachine) :
+        AgpsState(stateMachine)
+    { mReleasingState = this; }
+
+    inline ~AgpsReleasingState() {}
+public:
+    virtual AgpsState* onRsrcEvent(AgpsRsrcStatus event, void* data);
+    inline virtual char* whoami() {return (char*)"AgpsReleasingState";}
+};
+
+AgpsState* AgpsReleasingState::onRsrcEvent(AgpsRsrcStatus event, void* data)
+{
+    AgpsState* nextState = this;;
+    LOC_LOGD("AgpsReleasingState::onRsrcEvent; event:%d\n", (int)event);
+
+   switch (event)
+    {
+    case RSRC_SUBSCRIBE:
+    {
+        // already requested for NIF resource,
+        // do nothing until we get RSRC_GRANTED indication
+        // but we need to add subscriber to the list
+        mStateMachine->addSubscriber((Subscriber*)data);
+        // no state change.
+    }
+        break;
+
+    case RSRC_UNSUBSCRIBE:
+    {
+        Subscriber* subscriber = (Subscriber*) data;
+        if (subscriber->waitForCloseComplete()) {
+            subscriber->setInactive();
+        } else {
+            // auto notify this subscriber of the unsubscribe
+            Notification notification(subscriber, event, true);
+            mStateMachine->notifySubscribers(notification);
+        }
+
+        // now check if there is any subscribers left
+        if (!mStateMachine->hasSubscribers()) {
+            // no more subscribers, move to RELEASED state
+            nextState = mReleasedState;
+        }
+    }
+        break;
+
+    case RSRC_DENIED:
+        // A race condition subscriber unsubscribes before AFW denies resource.
+    case RSRC_RELEASED:
+    {
+        nextState = mAcquiredState;
+        Notification notification(Notification::BROADCAST_INACTIVE, event, true);
+        // notify all subscribers that are active NIF resource RELEASE
+        // by setting false, we keep subscribers on the linked list
+        mStateMachine->notifySubscribers(notification);
+
+        if (mStateMachine->hasActiveSubscribers()) {
+            nextState = mPendingState;
+            // request from connecivity service for NIF
+            mStateMachine->sendRsrcRequest(GPS_REQUEST_AGPS_DATA_CONN);
+        } else {
+            nextState = mReleasedState;
+        }
+    }
+        break;
+
+    case RSRC_GRANTED:
+    default:
+        LOC_LOGE("%s: unrecognized event %d", whoami(), event);
+        // no state change.
+    }
+
+    LOC_LOGD("onRsrcEvent, old state %s, new state %s, event %d",
+             whoami(), nextState->whoami(), event);
+    return nextState;
+}
+//======================================================================
+//Servicer
+//======================================================================
+Servicer* Servicer :: getServicer(servicerType type, void *cb_func)
+{
+    LOC_LOGD(" Enter getServicer type:%d\n", (int)type);
+    switch(type) {
+    case servicerTypeNoCbParam:
+        return (new Servicer(cb_func));
+    case servicerTypeExt:
+        return (new ExtServicer(cb_func));
+    case servicerTypeAgps:
+        return (new AGpsServicer(cb_func));
+    default:
+        return NULL;
+    }
+}
+
+int Servicer :: requestRsrc(void *cb_data)
+{
+    callback();
+    return 0;
+}
+
+int ExtServicer :: requestRsrc(void *cb_data)
+{
+    int ret=-1;
+    LOC_LOGD("Enter ExtServicer :: requestRsrc\n");
+    ret = callbackExt(cb_data);
+    LOC_LOGD("Exit ExtServicer :: requestRsrc\n");
+    return(ret);
+}
+
+int AGpsServicer :: requestRsrc(void *cb_data)
+{
+    callbackAGps((AGpsStatus *)cb_data);
+    return 0;
+}
+
+//======================================================================
+// AgpsStateMachine
+//======================================================================
+
+AgpsStateMachine::AgpsStateMachine(servicerType servType,
+                                   void *cb_func,
+                                   AGpsExtType type,
+                                   bool enforceSingleSubscriber) :
+    mStatePtr(new AgpsReleasedState(this)),mType(type),
+    mAPN(NULL),
+    mAPNLen(0),
+    mBearer(AGPS_APN_BEARER_INVALID),
+    mEnforceSingleSubscriber(enforceSingleSubscriber),
+    mServicer(Servicer :: getServicer(servType, (void *)cb_func))
+{
+    linked_list_init(&mSubscribers);
+
+    // setting up mReleasedState
+    mStatePtr->mPendingState = new AgpsPendingState(this);
+    mStatePtr->mAcquiredState = new AgpsAcquiredState(this);
+    mStatePtr->mReleasingState = new AgpsReleasingState(this);
+
+    // setting up mAcquiredState
+    mStatePtr->mAcquiredState->mReleasedState = mStatePtr;
+    mStatePtr->mAcquiredState->mPendingState = mStatePtr->mPendingState;
+    mStatePtr->mAcquiredState->mReleasingState = mStatePtr->mReleasingState;
+
+    // setting up mPendingState
+    mStatePtr->mPendingState->mAcquiredState = mStatePtr->mAcquiredState;
+    mStatePtr->mPendingState->mReleasedState = mStatePtr;
+    mStatePtr->mPendingState->mReleasingState = mStatePtr->mReleasingState;
+
+    // setting up mReleasingState
+    mStatePtr->mReleasingState->mReleasedState = mStatePtr;
+    mStatePtr->mReleasingState->mPendingState = mStatePtr->mPendingState;
+    mStatePtr->mReleasingState->mAcquiredState = mStatePtr->mAcquiredState;
+}
+
+AgpsStateMachine::~AgpsStateMachine()
+{
+    dropAllSubscribers();
+
+    // free the 3 states.  We must read out all 3 pointers first.
+    // Otherwise we run the risk of getting pointers from already
+    // freed memory.
+    AgpsState* acquiredState = mStatePtr->mAcquiredState;
+    AgpsState* releasedState = mStatePtr->mReleasedState;
+    AgpsState* pendindState = mStatePtr->mPendingState;
+    AgpsState* releasingState = mStatePtr->mReleasingState;
+
+    delete acquiredState;
+    delete releasedState;
+    delete pendindState;
+    delete releasingState;
+    delete mServicer;
+    linked_list_destroy(&mSubscribers);
+
+    if (NULL != mAPN) {
+        delete[] mAPN;
+        mAPN = NULL;
+    }
+}
+
+void AgpsStateMachine::setAPN(const char* apn, unsigned int len)
+{
+    if (NULL != mAPN) {
+        delete mAPN;
+    }
+
+    if (NULL != apn) {
+        mAPN = new char[len+1];
+        memcpy(mAPN, apn, len);
+        mAPN[len] = NULL;
+
+        mAPNLen = len;
+    } else {
+        mAPN = NULL;
+        mAPNLen = 0;
+    }
+}
+
+void AgpsStateMachine::onRsrcEvent(AgpsRsrcStatus event)
+{
+    switch (event)
+    {
+    case RSRC_GRANTED:
+    case RSRC_RELEASED:
+    case RSRC_DENIED:
+        mStatePtr = mStatePtr->onRsrcEvent(event, NULL);
+        break;
+    default:
+        LOC_LOGW("AgpsStateMachine: unrecognized event %d", event);
+        break;
+    }
+}
+
+void AgpsStateMachine::notifySubscribers(Notification& notification) const
+{
+    if (notification.postNotifyDelete) {
+        // just any non NULL value to get started
+        Subscriber* s = (Subscriber*)~0;
+        while (NULL != s) {
+            s = NULL;
+            // if the last param sets to true, _search will delete
+            // the node from the list for us.  But the problem is
+            // once that is done, _search returns, leaving the
+            // rest of the list unprocessed.  So we need a loop.
+            linked_list_search(mSubscribers, (void**)&s, notifySubscriber,
+                               (void*)&notification, true);
+            delete s;
+        }
+    } else {
+        // no loop needed if it the last param sets to false, which
+        // mean nothing gets deleted from the list.
+        linked_list_search(mSubscribers, NULL, notifySubscriber,
+                           (void*)&notification, false);
+    }
+}
+
+void AgpsStateMachine::addSubscriber(Subscriber* subscriber) const
+{
+    Subscriber* s = NULL;
+    Notification notification((const Subscriber*)subscriber);
+    linked_list_search(mSubscribers, (void**)&s,
+                       hasSubscriber, (void*)&notification, false);
+
+    if (NULL == s) {
+        linked_list_add(mSubscribers, subscriber->clone(), deleteObj);
+    }
+}
+
+int AgpsStateMachine::sendRsrcRequest(AGpsStatusValue action) const
+{
+    Subscriber* s = NULL;
+    Notification notification(Notification::BROADCAST_ACTIVE);
+    linked_list_search(mSubscribers, (void**)&s, hasSubscriber,
+                       (void*)&notification, false);
+
+    if ((NULL == s) == (GPS_RELEASE_AGPS_DATA_CONN == action)) {
+        AGpsExtStatus nifRequest;
+        nifRequest.size = sizeof(nifRequest);
+        nifRequest.type = mType;
+        nifRequest.status = action;
+
+        if (s == NULL) {
+            nifRequest.ipv4_addr = INADDR_NONE;
+            memset(&nifRequest.addr, 0,  sizeof(nifRequest.addr));
+            nifRequest.addr.ss_family = AF_INET6;
+            nifRequest.ssid[0] = '\0';
+            nifRequest.password[0] = '\0';
+        } else {
+            s->setIPAddresses(nifRequest.addr);
+            s->setWifiInfo(nifRequest.ssid, nifRequest.password);
+        }
+
+        CALLBACK_LOG_CALLFLOW("agps_cb", %s, loc_get_agps_status_name(action));
+        mServicer->requestRsrc((void *)&nifRequest);
+    }
+    return 0;
+}
+
+void AgpsStateMachine::subscribeRsrc(Subscriber *subscriber)
+{
+  if (mEnforceSingleSubscriber && hasSubscribers()) {
+      Notification notification(Notification::BROADCAST_ALL, RSRC_DENIED, true);
+      notifySubscriber(&notification, subscriber);
+  } else {
+      mStatePtr = mStatePtr->onRsrcEvent(RSRC_SUBSCRIBE, (void*)subscriber);
+  }
+}
+
+bool AgpsStateMachine::unsubscribeRsrc(Subscriber *subscriber)
+{
+    Subscriber* s = NULL;
+    Notification notification((const Subscriber*)subscriber);
+    linked_list_search(mSubscribers, (void**)&s,
+                       hasSubscriber, (void*)&notification, false);
+
+    if (NULL != s) {
+        mStatePtr = mStatePtr->onRsrcEvent(RSRC_UNSUBSCRIBE, (void*)s);
+        return true;
+    }
+    return false;
+}
+
+bool AgpsStateMachine::hasActiveSubscribers() const
+{
+    Subscriber* s = NULL;
+    Notification notification(Notification::BROADCAST_ACTIVE);
+    linked_list_search(mSubscribers, (void**)&s,
+                       hasSubscriber, (void*)&notification, false);
+    return NULL != s;
+}
+
+//======================================================================
+// DSStateMachine
+//======================================================================
+void delay_callback(void *callbackData, int result)
+{
+    if(callbackData) {
+        DSStateMachine *DSSMInstance = (DSStateMachine *)callbackData;
+        DSSMInstance->retryCallback();
+    }
+    else {
+        LOC_LOGE(" NULL argument received. Failing.\n");
+        goto err;
+    }
+err:
+    return;
+}
+
+DSStateMachine :: DSStateMachine(servicerType type, void *cb_func,
+                                 LocEngAdapter* adapterHandle):
+    AgpsStateMachine(type, cb_func, AGPS_TYPE_INVALID,false),
+    mLocAdapter(adapterHandle)
+{
+    LOC_LOGD("%s:%d]: New DSStateMachine\n", __func__, __LINE__);
+    mRetries = 0;
+}
+
+void DSStateMachine :: retryCallback(void)
+{
+    DSSubscriber *subscriber = NULL;
+    Notification notification(Notification::BROADCAST_ACTIVE);
+    linked_list_search(mSubscribers, (void**)&subscriber, hasSubscriber,
+                       (void*)&notification, false);
+    if(subscriber)
+        mLocAdapter->requestSuplES(subscriber->ID);
+    else
+        LOC_LOGE("DSStateMachine :: retryCallback: No subscriber found." \
+                 "Cannot retry data call\n");
+    return;
+}
+
+int DSStateMachine :: sendRsrcRequest(AGpsStatusValue action) const
+{
+    DSSubscriber* s = NULL;
+    dsCbData cbData;
+    int ret=-1;
+    int connHandle=-1;
+    LOC_LOGD("Enter DSStateMachine :: sendRsrcRequest\n");
+    Notification notification(Notification::BROADCAST_ACTIVE);
+    linked_list_search(mSubscribers, (void**)&s, hasSubscriber,
+                       (void*)&notification, false);
+    if(s) {
+        connHandle = s->ID;
+        LOC_LOGD("DSStateMachine :: sendRsrcRequest - subscriber found\n");
+    }
+    else
+        LOC_LOGD("DSStateMachine :: sendRsrcRequest - No subscriber found\n");
+
+    cbData.action = action;
+    cbData.mAdapter = mLocAdapter;
+    ret = mServicer->requestRsrc((void *)&cbData);
+    //Only the request to start data call returns a success/failure
+    //The request to stop data call will always succeed
+    //Hence, the below block will only be executed when the
+    //request to start the data call fails
+    switch(ret) {
+    case LOC_API_ADAPTER_ERR_ENGINE_BUSY:
+        LOC_LOGD("DSStateMachine :: sendRsrcRequest - Failure returned: %d\n",ret);
+        ((DSStateMachine *)this)->incRetries();
+        if(mRetries > MAX_START_DATA_CALL_RETRIES) {
+            LOC_LOGE(" Failed to start Data call. Fallback to normal ATL SUPL\n");
+            informStatus(RSRC_DENIED, connHandle);
+        }
+        else {
+            if(loc_timer_start(DATA_CALL_RETRY_DELAY_MSEC, delay_callback, (void *)this)) {
+                LOC_LOGE("Error: Could not start delay thread\n");
+                ret = -1;
+                goto err;
+            }
+        }
+        break;
+    case LOC_API_ADAPTER_ERR_UNSUPPORTED:
+        LOC_LOGE("No profile found for emergency call. Fallback to normal SUPL ATL\n");
+        informStatus(RSRC_DENIED, connHandle);
+        break;
+    case LOC_API_ADAPTER_ERR_SUCCESS:
+        LOC_LOGD("%s:%d]: Request to start data call sent\n", __func__, __LINE__);
+        break;
+    case -1:
+        //One of the ways this case can be encountered is if the callback function
+        //receives a null argument, it just exits with -1 error
+        LOC_LOGE("Error: Something went wrong somewhere. Falling back to normal SUPL ATL\n");
+        informStatus(RSRC_DENIED, connHandle);
+        break;
+    default:
+        LOC_LOGE("%s:%d]: Unrecognized return value\n", __func__, __LINE__);
+    }
+err:
+    LOC_LOGD("EXIT DSStateMachine :: sendRsrcRequest; ret = %d\n", ret);
+    return ret;
+}
+
+void DSStateMachine :: onRsrcEvent(AgpsRsrcStatus event)
+{
+    void* currState = (void *)mStatePtr;
+    LOC_LOGD("Enter DSStateMachine :: onRsrcEvent. event = %d\n", (int)event);
+    switch (event)
+    {
+    case RSRC_GRANTED:
+        LOC_LOGD("DSStateMachine :: onRsrcEvent RSRC_GRANTED\n");
+        mStatePtr = mStatePtr->onRsrcEvent(event, NULL);
+        break;
+    case RSRC_RELEASED:
+        LOC_LOGD("DSStateMachine :: onRsrcEvent RSRC_RELEASED\n");
+        mStatePtr = mStatePtr->onRsrcEvent(event, NULL);
+        //To handle the case where we get a RSRC_RELEASED in
+        //pending state, we translate that to a RSRC_DENIED state
+        //since the callback from DSI is either RSRC_GRANTED or RSRC_RELEASED
+        //for when the call is connected or disconnected respectively.
+        if((void *)mStatePtr != currState)
+            break;
+        else {
+            event = RSRC_DENIED;
+            LOC_LOGE(" Switching event to RSRC_DENIED\n");
+        }
+    case RSRC_DENIED:
+        mStatePtr = mStatePtr->onRsrcEvent(event, NULL);
+        break;
+    default:
+        LOC_LOGW("AgpsStateMachine: unrecognized event %d", event);
+        break;
+    }
+    LOC_LOGD("Exit DSStateMachine :: onRsrcEvent. event = %d\n", (int)event);
+}
+
+void DSStateMachine :: informStatus(AgpsRsrcStatus status, int ID) const
+{
+    LOC_LOGD("DSStateMachine :: informStatus. Status=%d\n",(int)status);
+    switch(status) {
+    case RSRC_UNSUBSCRIBE:
+        mLocAdapter->atlCloseStatus(ID, 1);
+        break;
+    case RSRC_RELEASED:
+        mLocAdapter->closeDataCall();
+        break;
+    case RSRC_DENIED:
+        ((DSStateMachine *)this)->mRetries = 0;
+        mLocAdapter->requestATL(ID, AGPS_TYPE_SUPL);
+        break;
+    case RSRC_GRANTED:
+        mLocAdapter->atlOpenStatus(ID, 1,
+                                                     NULL,
+                                                     AGPS_APN_BEARER_INVALID,
+                                                     AGPS_TYPE_INVALID);
+        break;
+    default:
+        LOC_LOGW("DSStateMachine :: informStatus - unknown status");
+    }
+    return;
+}
diff --git a/msm8974/loc_api/libloc_api_50001/loc_eng_agps.h b/msm8974/loc_api/libloc_api_50001/loc_eng_agps.h
new file mode 100644
index 0000000..d558644
--- /dev/null
+++ b/msm8974/loc_api/libloc_api_50001/loc_eng_agps.h
@@ -0,0 +1,432 @@
+/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __LOC_ENG_AGPS_H__
+#define __LOC_ENG_AGPS_H__
+
+#include <stdbool.h>
+#include <ctype.h>
+#include <string.h>
+#include <arpa/inet.h>
+#include <hardware/gps.h>
+#include <gps_extended.h>
+#include <loc_core_log.h>
+#include <linked_list.h>
+#include <loc_timer.h>
+#include <LocEngAdapter.h>
+
+// forward declaration
+class AgpsStateMachine;
+class Subscriber;
+
+// NIF resource events
+typedef enum {
+    RSRC_SUBSCRIBE,
+    RSRC_UNSUBSCRIBE,
+    RSRC_GRANTED,
+    RSRC_RELEASED,
+    RSRC_DENIED,
+    RSRC_STATUS_MAX
+} AgpsRsrcStatus;
+
+typedef enum {
+    servicerTypeNoCbParam,
+    servicerTypeAgps,
+    servicerTypeExt
+}servicerType;
+
+//DS Callback struct
+typedef struct {
+    LocEngAdapter *mAdapter;
+    AGpsStatusValue action;
+}dsCbData;
+
+// information bundle for subscribers
+struct Notification {
+    // goes to every subscriber
+    static const int BROADCAST_ALL;
+    // goes to every ACTIVE subscriber
+    static const int BROADCAST_ACTIVE;
+    // goes to every INACTIVE subscriber
+    static const int BROADCAST_INACTIVE;
+
+    // go to a specific subscriber
+    const Subscriber* rcver;
+    // broadcast
+    const int groupID;
+    // the new resource status event
+    const AgpsRsrcStatus rsrcStatus;
+    // should the subscriber be deleted after the notification
+    const bool postNotifyDelete;
+
+    // convenient constructor
+    inline Notification(const int broadcast,
+                        const AgpsRsrcStatus status,
+                        const bool deleteAfterwards) :
+        rcver(NULL), groupID(broadcast), rsrcStatus(status),
+        postNotifyDelete(deleteAfterwards) {}
+
+    // convenient constructor
+    inline Notification(const Subscriber* subscriber,
+                        const AgpsRsrcStatus status,
+                        const bool deleteAfterwards) :
+        rcver(subscriber), groupID(-1), rsrcStatus(status),
+        postNotifyDelete(deleteAfterwards) {}
+
+    // convenient constructor
+    inline Notification(const int broadcast) :
+        rcver(NULL), groupID(broadcast), rsrcStatus(RSRC_STATUS_MAX),
+        postNotifyDelete(false) {}
+
+    // convenient constructor
+    inline Notification(const Subscriber* subscriber) :
+        rcver(subscriber), groupID(-1), rsrcStatus(RSRC_STATUS_MAX),
+        postNotifyDelete(false) {}
+};
+
+class AgpsState {
+    // allows AgpsStateMachine to access private data
+    // no class members are public.  We don't want
+    // anyone but state machine to use state.
+    friend class AgpsStateMachine;
+    friend class DSStateMachine;
+    // state transitions are done here.
+    // Each state implements its own transitions (of course).
+    inline virtual AgpsState* onRsrcEvent(AgpsRsrcStatus event, void* data) = 0;
+
+protected:
+    // handle back to state machine
+    const AgpsStateMachine* mStateMachine;
+    // each state has pointers to all 3 states
+    // one of which is to itself.
+    AgpsState* mReleasedState;
+    AgpsState* mAcquiredState;
+    AgpsState* mPendingState;
+    AgpsState* mReleasingState;
+
+    inline AgpsState(const AgpsStateMachine *stateMachine) :
+        mStateMachine(stateMachine),
+        mReleasedState(NULL),
+        mAcquiredState(NULL),
+        mPendingState(NULL),
+        mReleasingState(NULL) {}
+    virtual ~AgpsState() {}
+
+public:
+    // for logging purpose
+    inline virtual char* whoami() = 0;
+};
+
+class Servicer {
+    void (*callback)(void);
+public:
+    static Servicer* getServicer(servicerType type, void *cb_func);
+    virtual int requestRsrc(void *cb_data);
+    Servicer() {}
+    Servicer(void *cb_func)
+    { callback = (void(*)(void))(cb_func); }
+    virtual ~Servicer(){}
+    inline virtual char *whoami() {return (char*)"Servicer";}
+};
+
+class ExtServicer : public Servicer {
+    int (*callbackExt)(void *cb_data);
+public:
+    int requestRsrc(void *cb_data);
+    ExtServicer() {}
+    ExtServicer(void *cb_func)
+    { callbackExt = (int(*)(void *))(cb_func); }
+    virtual ~ExtServicer(){}
+    inline virtual char *whoami() {return (char*)"ExtServicer";}
+};
+
+class AGpsServicer : public Servicer {
+    void (*callbackAGps)(AGpsStatus* status);
+public:
+    int requestRsrc(void *cb_data);
+    AGpsServicer() {}
+    AGpsServicer(void *cb_func)
+    { callbackAGps = (void(*)(AGpsStatus *))(cb_func); }
+    virtual ~AGpsServicer(){}
+    inline virtual char *whoami() {return (char*)"AGpsServicer";}
+};
+
+class AgpsStateMachine {
+protected:
+    // a linked list of subscribers.
+    void* mSubscribers;
+    //handle to whoever provides the service
+    Servicer *mServicer;
+    // allows AgpsState to access private data
+    // each state is really internal data to the
+    // state machine, so it should be able to
+    // access anything within the state machine.
+    friend class AgpsState;
+    // pointer to the current state.
+    AgpsState* mStatePtr;
+private:
+    // NIF type: AGNSS or INTERNET.
+    const AGpsExtType mType;
+    // apn to the NIF.  Each state machine tracks
+    // resource state of a particular NIF.  For each
+    // NIF, there is also an active APN.
+    char* mAPN;
+    // for convenience, we don't do strlen each time.
+    unsigned int mAPNLen;
+    // bear
+    AGpsBearerType mBearer;
+    // ipv4 address for routing
+    bool mEnforceSingleSubscriber;
+
+public:
+    AgpsStateMachine(servicerType servType, void *cb_func,
+                     AGpsExtType type, bool enforceSingleSubscriber);
+    virtual ~AgpsStateMachine();
+
+    // self explanatory methods below
+    void setAPN(const char* apn, unsigned int len);
+    inline const char* getAPN() const { return (const char*)mAPN; }
+    inline void setBearer(AGpsBearerType bearer) { mBearer = bearer; }
+    inline AGpsBearerType getBearer() const { return mBearer; }
+    inline AGpsExtType getType() const { return (AGpsExtType)mType; }
+
+    // someone, a ATL client or BIT, is asking for NIF
+    void subscribeRsrc(Subscriber *subscriber);
+
+    // someone, a ATL client or BIT, is done with NIF
+    bool unsubscribeRsrc(Subscriber *subscriber);
+
+    // add a subscriber in the linked list, if not already there.
+    void addSubscriber(Subscriber* subscriber) const;
+
+    virtual void onRsrcEvent(AgpsRsrcStatus event);
+
+    // put the data together and send the FW
+    virtual int sendRsrcRequest(AGpsStatusValue action) const;
+
+    //if list is empty, linked_list_empty returns 1
+    //else if list is not empty, returns 0
+    //so hasSubscribers() returns 1 if list is not empty
+    //and returns 0 if list is empty
+    inline bool hasSubscribers() const
+    { return !linked_list_empty(mSubscribers); }
+
+    bool hasActiveSubscribers() const;
+
+    inline void dropAllSubscribers() const
+    { linked_list_flush(mSubscribers); }
+
+    // private. Only a state gets to call this.
+    void notifySubscribers(Notification& notification) const;
+
+};
+
+class DSStateMachine : public AgpsStateMachine {
+    static const unsigned char MAX_START_DATA_CALL_RETRIES;
+    static const unsigned int DATA_CALL_RETRY_DELAY_MSEC;
+    LocEngAdapter* mLocAdapter;
+    unsigned char mRetries;
+public:
+    DSStateMachine(servicerType type,
+                   void *cb_func,
+                   LocEngAdapter* adapterHandle);
+    int sendRsrcRequest(AGpsStatusValue action) const;
+    void onRsrcEvent(AgpsRsrcStatus event);
+    void retryCallback();
+    void informStatus(AgpsRsrcStatus status, int ID) const;
+    inline void incRetries() {mRetries++;}
+    inline virtual char *whoami() {return (char*)"DSStateMachine";}
+};
+
+// each subscriber is a AGPS client.  In the case of ATL, there could be
+// multiple clients from modem.  In the case of BIT, there is only one
+// cilent from BIT daemon.
+struct Subscriber {
+    const uint32_t ID;
+    const AgpsStateMachine* mStateMachine;
+    inline Subscriber(const int id,
+                      const AgpsStateMachine* stateMachine) :
+        ID(id), mStateMachine(stateMachine) {}
+    inline virtual ~Subscriber() {}
+
+    virtual void setIPAddresses(uint32_t &v4, char* v6) = 0;
+    virtual void setIPAddresses(struct sockaddr_storage& addr) = 0;
+    inline virtual void setWifiInfo(char* ssid, char* password)
+    { ssid[0] = 0; password[0] = 0; }
+
+    inline virtual bool equals(const Subscriber *s) const
+    { return ID == s->ID; }
+
+    // notifies a subscriber a new NIF resource status, usually
+    // either GRANTE, DENIED, or RELEASED
+    virtual bool notifyRsrcStatus(Notification &notification) = 0;
+
+    virtual bool waitForCloseComplete() { return false; }
+    virtual void setInactive() {}
+    virtual bool isInactive() { return false; }
+
+    virtual Subscriber* clone() = 0;
+    // checks if this notification is for me, i.e.
+    // either has my id, or has a broadcast id.
+    bool forMe(Notification &notification);
+};
+
+// BITSubscriber, created with requests from BIT daemon
+struct BITSubscriber : public Subscriber {
+    char mIPv6Addr[16];
+
+    inline BITSubscriber(const AgpsStateMachine* stateMachine,
+                         unsigned int ipv4, char* ipv6) :
+        Subscriber(ipv4, stateMachine)
+    {
+        if (NULL == ipv6) {
+            mIPv6Addr[0] = 0;
+        } else {
+            memcpy(mIPv6Addr, ipv6, sizeof(mIPv6Addr));
+        }
+    }
+
+    virtual bool notifyRsrcStatus(Notification &notification);
+
+    inline virtual void setIPAddresses(uint32_t &v4, char* v6)
+    { v4 = ID; memcpy(v6, mIPv6Addr, sizeof(mIPv6Addr)); }
+
+    inline virtual void setIPAddresses(struct sockaddr_storage& addr)
+    { addr.ss_family = AF_INET6;/*todo: convert mIPv6Addr into addr */ }
+
+    virtual Subscriber* clone()
+    {
+        return new BITSubscriber(mStateMachine, ID, mIPv6Addr);
+    }
+
+    virtual bool equals(const Subscriber *s) const;
+    inline virtual ~BITSubscriber(){}
+};
+
+// ATLSubscriber, created with requests from ATL
+struct ATLSubscriber : public Subscriber {
+    const LocEngAdapter* mLocAdapter;
+    const bool mBackwardCompatibleMode;
+    inline ATLSubscriber(const int id,
+                         const AgpsStateMachine* stateMachine,
+                         const LocEngAdapter* adapter,
+                         const bool compatibleMode) :
+        Subscriber(id, stateMachine), mLocAdapter(adapter),
+        mBackwardCompatibleMode(compatibleMode){}
+    virtual bool notifyRsrcStatus(Notification &notification);
+
+    inline virtual void setIPAddresses(uint32_t &v4, char* v6)
+    { v4 = INADDR_NONE; v6[0] = 0; }
+
+    inline virtual void setIPAddresses(struct sockaddr_storage& addr)
+    { memset(&addr, 0,  sizeof(addr));
+      addr.ss_family = AF_INET6; }
+
+    inline virtual Subscriber* clone()
+    {
+        return new ATLSubscriber(ID, mStateMachine, mLocAdapter,
+                                 mBackwardCompatibleMode);
+    }
+    inline virtual ~ATLSubscriber(){}
+};
+
+// WIFISubscriber, created with requests from MSAPM or QuIPC
+struct WIFISubscriber : public Subscriber {
+    char * mSSID;
+    char * mPassword;
+    loc_if_req_sender_id_e_type senderId;
+    bool mIsInactive;
+    inline WIFISubscriber(const AgpsStateMachine* stateMachine,
+                         char * ssid, char * password, loc_if_req_sender_id_e_type sender_id) :
+        Subscriber(sender_id, stateMachine),
+        mSSID(NULL == ssid ? NULL : new char[SSID_BUF_SIZE]),
+        mPassword(NULL == password ? NULL : new char[SSID_BUF_SIZE]),
+        senderId(sender_id)
+    {
+      if (NULL != mSSID)
+          strlcpy(mSSID, ssid, SSID_BUF_SIZE);
+      if (NULL != mPassword)
+          strlcpy(mPassword, password, SSID_BUF_SIZE);
+      mIsInactive = false;
+    }
+
+    virtual bool notifyRsrcStatus(Notification &notification);
+
+    inline virtual void setIPAddresses(uint32_t &v4, char* v6) {}
+
+    inline virtual void setIPAddresses(struct sockaddr_storage& addr)
+    { addr.ss_family = AF_INET6; }
+
+    inline virtual void setWifiInfo(char* ssid, char* password)
+    {
+      if (NULL != mSSID)
+          strlcpy(ssid, mSSID, SSID_BUF_SIZE);
+      else
+          ssid[0] = '\0';
+      if (NULL != mPassword)
+          strlcpy(password, mPassword, SSID_BUF_SIZE);
+      else
+          password[0] = '\0';
+    }
+
+    inline virtual bool waitForCloseComplete() { return true; }
+
+    inline virtual void setInactive() { mIsInactive = true; }
+    inline virtual bool isInactive() { return mIsInactive; }
+
+    virtual Subscriber* clone()
+    {
+        return new WIFISubscriber(mStateMachine, mSSID, mPassword, senderId);
+    }
+    inline virtual ~WIFISubscriber(){}
+};
+
+struct DSSubscriber : public Subscriber {
+    bool mIsInactive;
+    inline DSSubscriber(const AgpsStateMachine *stateMachine,
+                         const int id) :
+        Subscriber(id, stateMachine)
+    {
+        mIsInactive = false;
+    }
+    inline virtual void setIPAddresses(uint32_t &v4, char* v6) {}
+    inline virtual void setIPAddresses(struct sockaddr_storage& addr)
+    { addr.ss_family = AF_INET6; }
+    virtual Subscriber* clone()
+    {return new DSSubscriber(mStateMachine, ID);}
+    virtual bool notifyRsrcStatus(Notification &notification);
+    inline virtual bool waitForCloseComplete() { return true; }
+    virtual void setInactive();
+    inline virtual bool isInactive()
+    { return mIsInactive; }
+    inline virtual ~DSSubscriber(){}
+    inline virtual char *whoami() {return (char*)"DSSubscriber";}
+};
+
+#endif //__LOC_ENG_AGPS_H__
diff --git a/msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn.cpp b/msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn.cpp
new file mode 100644
index 0000000..c257dff
--- /dev/null
+++ b/msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn.cpp
@@ -0,0 +1,270 @@
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/stat.h>
+#include <fcntl.h>
+#include <linux/types.h>
+#include <unistd.h>
+#include <errno.h>
+#include <grp.h>
+#include <sys/stat.h>
+
+#include "log_util.h"
+#include "platform_lib_includes.h"
+#include "loc_eng_dmn_conn_glue_msg.h"
+#include "loc_eng_dmn_conn_handler.h"
+#include "loc_eng_dmn_conn.h"
+#include "loc_eng_msg.h"
+
+static int loc_api_server_msgqid;
+static int loc_api_resp_msgqid;
+static int quipc_msgqid;
+static int msapm_msgqid;
+static int msapu_msgqid;
+
+static const char * global_loc_api_q_path = GPSONE_LOC_API_Q_PATH;
+static const char * global_loc_api_resp_q_path = GPSONE_LOC_API_RESP_Q_PATH;
+static const char * global_quipc_ctrl_q_path = QUIPC_CTRL_Q_PATH;
+static const char * global_msapm_ctrl_q_path = MSAPM_CTRL_Q_PATH;
+static const char * global_msapu_ctrl_q_path = MSAPU_CTRL_Q_PATH;
+
+static int loc_api_server_proc_init(void *context)
+{
+    loc_api_server_msgqid = loc_eng_dmn_conn_glue_msgget(global_loc_api_q_path, O_RDWR);
+    //change mode/group for the global_loc_api_q_path pipe
+    int result = chmod (global_loc_api_q_path, 0660);
+    if (result != 0)
+    {
+        LOC_LOGE("failed to change mode for %s, error = %s\n", global_loc_api_q_path, strerror(errno));
+    }
+
+    struct group * gps_group = getgrnam("gps");
+    if (gps_group != NULL)
+    {
+       result = chown (global_loc_api_q_path, -1, gps_group->gr_gid);
+       if (result != 0)
+       {
+          LOC_LOGE("chown for pipe failed, pipe %s, gid = %d, result = %d, error = %s\n",
+                   global_loc_api_q_path, gps_group->gr_gid, result, strerror(errno));
+       }
+    }
+    else
+    {
+       LOC_LOGE("getgrnam for gps failed, error code = %d\n",  errno);
+    }
+
+    loc_api_resp_msgqid = loc_eng_dmn_conn_glue_msgget(global_loc_api_resp_q_path, O_RDWR);
+
+    //change mode/group for the global_loc_api_resp_q_path pipe
+    result = chmod (global_loc_api_resp_q_path, 0660);
+    if (result != 0)
+    {
+        LOC_LOGE("failed to change mode for %s, error = %s\n", global_loc_api_resp_q_path, strerror(errno));
+    }
+
+    if (gps_group != NULL)
+    {
+       result = chown (global_loc_api_resp_q_path, -1, gps_group->gr_gid);
+       if (result != 0)
+       {
+          LOC_LOGE("chown for pipe failed, pipe %s, gid = %d, result = %d, error = %s\n",
+                   global_loc_api_resp_q_path,
+                   gps_group->gr_gid, result, strerror(errno));
+       }
+    }
+
+    quipc_msgqid = loc_eng_dmn_conn_glue_msgget(global_quipc_ctrl_q_path, O_RDWR);
+    msapm_msgqid = loc_eng_dmn_conn_glue_msgget(global_msapm_ctrl_q_path , O_RDWR);
+    msapu_msgqid = loc_eng_dmn_conn_glue_msgget(global_msapu_ctrl_q_path , O_RDWR);
+
+    LOC_LOGD("%s:%d] loc_api_server_msgqid = %d\n", __func__, __LINE__, loc_api_server_msgqid);
+    return 0;
+}
+
+static int loc_api_server_proc_pre(void *context)
+{
+    return 0;
+}
+
+static int loc_api_server_proc(void *context)
+{
+    int length, sz;
+    int result = 0;
+    static int cnt = 0;
+    struct ctrl_msgbuf * p_cmsgbuf;
+    struct ctrl_msgbuf cmsg_resp;
+
+    sz = sizeof(struct ctrl_msgbuf) + 256;
+    p_cmsgbuf = (struct ctrl_msgbuf *) malloc(sz);
+
+    if (!p_cmsgbuf) {
+        LOC_LOGE("%s:%d] Out of memory\n", __func__, __LINE__);
+        return -1;
+    }
+
+    cnt ++;
+    LOC_LOGD("%s:%d] %d listening on %s...\n", __func__, __LINE__, cnt, (char *) context);
+    length = loc_eng_dmn_conn_glue_msgrcv(loc_api_server_msgqid, p_cmsgbuf, sz);
+    if (length <= 0) {
+        free(p_cmsgbuf);
+        LOC_LOGE("%s:%d] fail receiving msg from gpsone_daemon, retry later\n", __func__, __LINE__);
+        usleep(1000);
+        return -1;
+    }
+
+    LOC_LOGD("%s:%d] received ctrl_type = %d\n", __func__, __LINE__, p_cmsgbuf->ctrl_type);
+    switch(p_cmsgbuf->ctrl_type) {
+        case GPSONE_LOC_API_IF_REQUEST:
+            result = loc_eng_dmn_conn_loc_api_server_if_request_handler(p_cmsgbuf, length);
+            break;
+
+        case GPSONE_LOC_API_IF_RELEASE:
+            result = loc_eng_dmn_conn_loc_api_server_if_release_handler(p_cmsgbuf, length);
+            break;
+
+        case GPSONE_UNBLOCK:
+            LOC_LOGD("%s:%d] GPSONE_UNBLOCK\n", __func__, __LINE__);
+            break;
+
+        default:
+            LOC_LOGE("%s:%d] unsupported ctrl_type = %d\n",
+                __func__, __LINE__, p_cmsgbuf->ctrl_type);
+            break;
+    }
+
+    free(p_cmsgbuf);
+    return 0;
+}
+
+static int loc_api_server_proc_post(void *context)
+{
+    LOC_LOGD("%s:%d]\n", __func__, __LINE__);
+    loc_eng_dmn_conn_glue_msgremove( global_loc_api_q_path, loc_api_server_msgqid);
+    loc_eng_dmn_conn_glue_msgremove( global_loc_api_resp_q_path, loc_api_resp_msgqid);
+    loc_eng_dmn_conn_glue_msgremove( global_quipc_ctrl_q_path, quipc_msgqid);
+    loc_eng_dmn_conn_glue_msgremove( global_msapm_ctrl_q_path, msapm_msgqid);
+    loc_eng_dmn_conn_glue_msgremove( global_msapu_ctrl_q_path, msapu_msgqid);
+    return 0;
+}
+
+static int loc_eng_dmn_conn_unblock_proc(void)
+{
+    struct ctrl_msgbuf cmsgbuf;
+    cmsgbuf.ctrl_type = GPSONE_UNBLOCK;
+    LOC_LOGD("%s:%d]\n", __func__, __LINE__);
+    loc_eng_dmn_conn_glue_msgsnd(loc_api_server_msgqid, & cmsgbuf, sizeof(cmsgbuf));
+    return 0;
+}
+
+static struct loc_eng_dmn_conn_thelper thelper;
+
+int loc_eng_dmn_conn_loc_api_server_launch(thelper_create_thread   create_thread_cb,
+    const char * loc_api_q_path, const char * resp_q_path, void *agps_handle)
+{
+    int result;
+
+    loc_api_handle = agps_handle;
+
+    if (loc_api_q_path) global_loc_api_q_path = loc_api_q_path;
+    if (resp_q_path)    global_loc_api_resp_q_path = resp_q_path;
+
+    result = loc_eng_dmn_conn_launch_thelper( &thelper,
+        loc_api_server_proc_init,
+        loc_api_server_proc_pre,
+        loc_api_server_proc,
+        loc_api_server_proc_post,
+        create_thread_cb,
+        (char *) global_loc_api_q_path);
+    if (result != 0) {
+        LOC_LOGE("%s:%d]\n", __func__, __LINE__);
+        return -1;
+    }
+    return 0;
+}
+
+int loc_eng_dmn_conn_loc_api_server_unblock(void)
+{
+    loc_eng_dmn_conn_unblock_thelper(&thelper);
+    loc_eng_dmn_conn_unblock_proc();
+    return 0;
+}
+
+int loc_eng_dmn_conn_loc_api_server_join(void)
+{
+    loc_eng_dmn_conn_join_thelper(&thelper);
+    return 0;
+}
+
+int loc_eng_dmn_conn_loc_api_server_data_conn(int sender_id, int status) {
+  struct ctrl_msgbuf cmsgbuf;
+  LOC_LOGD("%s:%d] quipc_msgqid = %d\n", __func__, __LINE__, quipc_msgqid);
+  cmsgbuf.ctrl_type = GPSONE_LOC_API_RESPONSE;
+  cmsgbuf.cmsg.cmsg_response.result = status;
+  switch (sender_id) {
+    case LOC_ENG_IF_REQUEST_SENDER_ID_QUIPC: {
+      LOC_LOGD("%s:%d] sender_id = LOC_ENG_IF_REQUEST_SENDER_ID_QUIPC", __func__, __LINE__);
+      if (loc_eng_dmn_conn_glue_msgsnd(quipc_msgqid, & cmsgbuf, sizeof(struct ctrl_msgbuf)) < 0) {
+        LOC_LOGD("%s:%d] error! conn_glue_msgsnd failed\n", __func__, __LINE__);
+        return -1;
+      }
+      break;
+    }
+    case LOC_ENG_IF_REQUEST_SENDER_ID_MSAPM: {
+      LOC_LOGD("%s:%d] sender_id = LOC_ENG_IF_REQUEST_SENDER_ID_MSAPM", __func__, __LINE__);
+      if (loc_eng_dmn_conn_glue_msgsnd(msapm_msgqid, & cmsgbuf, sizeof(struct ctrl_msgbuf)) < 0) {
+        LOC_LOGD("%s:%d] error! conn_glue_msgsnd failed\n", __func__, __LINE__);
+        return -1;
+      }
+      break;
+    }
+    case LOC_ENG_IF_REQUEST_SENDER_ID_MSAPU: {
+      LOC_LOGD("%s:%d] sender_id = LOC_ENG_IF_REQUEST_SENDER_ID_MSAPU", __func__, __LINE__);
+      if (loc_eng_dmn_conn_glue_msgsnd(msapu_msgqid, & cmsgbuf, sizeof(struct ctrl_msgbuf)) < 0) {
+        LOC_LOGD("%s:%d] error! conn_glue_msgsnd failed\n", __func__, __LINE__);
+        return -1;
+      }
+      break;
+    }
+    case LOC_ENG_IF_REQUEST_SENDER_ID_GPSONE_DAEMON: {
+      LOC_LOGD("%s:%d] sender_id = LOC_ENG_IF_REQUEST_SENDER_ID_GPSONE_DAEMON", __func__, __LINE__);
+      if (loc_eng_dmn_conn_glue_msgsnd(loc_api_resp_msgqid, & cmsgbuf, sizeof(struct ctrl_msgbuf)) < 0) {
+        LOC_LOGD("%s:%d] error! conn_glue_msgsnd failed\n", __func__, __LINE__);
+        return -1;
+      }
+      break;
+    }
+    default: {
+      LOC_LOGD("%s:%d] invalid sender ID!", __func__, __LINE__);
+    }
+  }
+  return 0;
+}
+
diff --git a/msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn.h b/msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn.h
new file mode 100644
index 0000000..1d8c142
--- /dev/null
+++ b/msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn.h
@@ -0,0 +1,59 @@
+/* Copyright (c) 2011-2012,2014 The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef LOC_ENG_DATA_SERVER_H
+#define LOC_ENG_DATA_SERVER_H
+
+#include "loc_eng_dmn_conn_thread_helper.h"
+
+#ifdef _ANDROID_
+
+#define GPSONE_LOC_API_Q_PATH "/data/misc/location/gpsone_d/gpsone_loc_api_q"
+#define GPSONE_LOC_API_RESP_Q_PATH "/data/misc/location/gpsone_d/gpsone_loc_api_resp_q"
+#define QUIPC_CTRL_Q_PATH "/data/misc/location/gpsone_d/quipc_ctrl_q"
+#define MSAPM_CTRL_Q_PATH "/data/misc/location/gpsone_d/msapm_ctrl_q"
+#define MSAPU_CTRL_Q_PATH "/data/misc/location/gpsone_d/msapu_ctrl_q"
+
+#else
+
+#define GPSONE_LOC_API_Q_PATH "/tmp/gpsone_loc_api_q"
+#define GPSONE_LOC_API_RESP_Q_PATH "/tmp/gpsone_loc_api_resp_q"
+#define QUIPC_CTRL_Q_PATH "/tmp/quipc_ctrl_q"
+#define MSAPM_CTRL_Q_PATH "/tmp/msapm_ctrl_q"
+#define MSAPU_CTRL_Q_PATH "/tmp/msapu_ctrl_q"
+
+#endif
+
+int loc_eng_dmn_conn_loc_api_server_launch(thelper_create_thread   create_thread_cb,
+    const char * loc_api_q_path, const char * ctrl_q_path, void *agps_handle);
+int loc_eng_dmn_conn_loc_api_server_unblock(void);
+int loc_eng_dmn_conn_loc_api_server_join(void);
+int loc_eng_dmn_conn_loc_api_server_data_conn(int, int);
+
+#endif /* LOC_ENG_DATA_SERVER_H */
+
diff --git a/msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_glue_msg.c b/msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_glue_msg.c
new file mode 100644
index 0000000..a1076ff
--- /dev/null
+++ b/msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_glue_msg.c
@@ -0,0 +1,223 @@
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <linux/stat.h>
+#include <fcntl.h>
+
+#include <linux/types.h>
+
+#include "log_util.h"
+#include "platform_lib_includes.h"
+#include "loc_eng_dmn_conn_glue_msg.h"
+#include "loc_eng_dmn_conn_handler.h"
+
+/*===========================================================================
+FUNCTION    loc_eng_dmn_conn_glue_msgget
+
+DESCRIPTION
+   This function get a message queue
+
+   q_path - name path of the message queue
+   mode -
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   message queue id
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_eng_dmn_conn_glue_msgget(const char * q_path, int mode)
+{
+    int msgqid;
+    msgqid = loc_eng_dmn_conn_glue_pipeget(q_path, mode);
+    return msgqid;
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_dmn_conn_glue_msgremove
+
+DESCRIPTION
+   remove a message queue
+
+   q_path - name path of the message queue
+   msgqid - message queue id
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0: success or negative value for failure
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_eng_dmn_conn_glue_msgremove(const char * q_path, int msgqid)
+{
+    int result;
+    result = loc_eng_dmn_conn_glue_piperemove(q_path, msgqid);
+    return result;
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_dmn_conn_glue_msgsnd
+
+DESCRIPTION
+   Send a message
+
+   msgqid - message queue id
+   msgp - pointer to the message to be sent
+   msgsz - size of the message
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   number of bytes sent out or negative value for failure
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_eng_dmn_conn_glue_msgsnd(int msgqid, const void * msgp, size_t msgsz)
+{
+    int result;
+    struct ctrl_msgbuf *pmsg = (struct ctrl_msgbuf *) msgp;
+    pmsg->msgsz = msgsz;
+
+    result = loc_eng_dmn_conn_glue_pipewrite(msgqid, msgp, msgsz);
+    if (result != (int) msgsz) {
+        LOC_LOGE("%s:%d] pipe broken %d, msgsz = %d\n", __func__, __LINE__, result, (int) msgsz);
+        return -1;
+    }
+
+    return result;
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_dmn_conn_glue_msgrcv
+
+DESCRIPTION
+   receive a message
+
+   msgqid - message queue id
+   msgp - pointer to the buffer to hold the message
+   msgsz - size of the buffer
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   number of bytes received or negative value for failure
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_eng_dmn_conn_glue_msgrcv(int msgqid, void *msgp, size_t msgbufsz)
+{
+    int result;
+    struct ctrl_msgbuf *pmsg = (struct ctrl_msgbuf *) msgp;
+
+    result = loc_eng_dmn_conn_glue_piperead(msgqid, &(pmsg->msgsz), sizeof(pmsg->msgsz));
+    if (result != sizeof(pmsg->msgsz)) {
+        LOC_LOGE("%s:%d] pipe broken %d\n", __func__, __LINE__, result);
+        return -1;
+    }
+
+    if (msgbufsz < pmsg->msgsz) {
+        LOC_LOGE("%s:%d] msgbuf is too small %d < %d\n", __func__, __LINE__, (int) msgbufsz, (int) pmsg->msgsz);
+        return -1;
+    }
+
+    result = loc_eng_dmn_conn_glue_piperead(msgqid, (uint8_t *) msgp + sizeof(pmsg->msgsz), pmsg->msgsz - sizeof(pmsg->msgsz));
+    if (result != (int) (pmsg->msgsz - sizeof(pmsg->msgsz))) {
+        LOC_LOGE("%s:%d] pipe broken %d, msgsz = %d\n", __func__, __LINE__, result, (int) pmsg->msgsz);
+        return -1;
+    }
+
+    return pmsg->msgsz;
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_dmn_conn_glue_msgunblock
+
+DESCRIPTION
+   unblock a message queue
+
+   msgqid - message queue id
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0: success
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_eng_dmn_conn_glue_msgunblock(int msgqid)
+{
+    return loc_eng_dmn_conn_glue_pipeunblock(msgqid);
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_dmn_conn_glue_msgflush
+
+DESCRIPTION
+   flush out the message in a queue
+
+   msgqid - message queue id
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   number of bytes that are flushed out.
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_eng_dmn_conn_glue_msgflush(int msgqid)
+{
+    int length;
+    char buf[128];
+
+    do {
+        length = loc_eng_dmn_conn_glue_piperead(msgqid, buf, 128);
+        LOC_LOGD("%s:%d] %s\n", __func__, __LINE__, buf);
+    } while(length);
+    return length;
+}
+
diff --git a/msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_glue_msg.h b/msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_glue_msg.h
new file mode 100644
index 0000000..d685c87
--- /dev/null
+++ b/msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_glue_msg.h
@@ -0,0 +1,51 @@
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef LOC_ENG_DMN_CONN_GLUE_MSG_H
+#define LOC_ENG_DMN_CONN_GLUE_MSG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+#include <linux/types.h>
+#include "loc_eng_dmn_conn_glue_pipe.h"
+
+int loc_eng_dmn_conn_glue_msgget(const char * q_path, int mode);
+int loc_eng_dmn_conn_glue_msgremove(const char * q_path, int msgqid);
+int loc_eng_dmn_conn_glue_msgsnd(int msgqid, const void * msgp, size_t msgsz);
+int loc_eng_dmn_conn_glue_msgrcv(int msgqid, void *msgp, size_t msgsz);
+int loc_eng_dmn_conn_glue_msgflush(int msgqid);
+int loc_eng_dmn_conn_glue_msgunblock(int msgqid);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* LOC_ENG_DMN_CONN_GLUE_MSG_H */
diff --git a/msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_glue_pipe.c b/msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_glue_pipe.c
new file mode 100644
index 0000000..dffcad0
--- /dev/null
+++ b/msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_glue_pipe.c
@@ -0,0 +1,214 @@
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+
+// #include <linux/stat.h>
+#include <fcntl.h>
+// #include <linux/types.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#include "loc_eng_dmn_conn_glue_pipe.h"
+#include "log_util.h"
+#include "platform_lib_includes.h"
+/*===========================================================================
+FUNCTION    loc_eng_dmn_conn_glue_pipeget
+
+DESCRIPTION
+   create a named pipe.
+
+   pipe_name - pipe name path
+   mode - mode
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0: success or negative value for failure
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_eng_dmn_conn_glue_pipeget(const char * pipe_name, int mode)
+{
+    int fd;
+    int result;
+
+    LOC_LOGD("%s, mode = %d\n", pipe_name, mode);
+    result = mkfifo(pipe_name, 0660);
+
+    if ((result == -1) && (errno != EEXIST)) {
+        LOC_LOGE("failed: %s\n", strerror(errno));
+        return result;
+    }
+
+    // The mode in mkfifo is not honoured and does not provide the
+    // group permissions. Doing chmod to add group permissions.
+    result = chmod (pipe_name, 0660);
+    if (result != 0){
+        LOC_LOGE ("%s failed to change mode for %s, error = %s\n", __func__,
+              pipe_name, strerror(errno));
+    }
+
+    fd = open(pipe_name, mode);
+    if (fd <= 0)
+    {
+        LOC_LOGE("failed: %s\n", strerror(errno));
+    }
+    LOC_LOGD("fd = %d, %s\n", fd, pipe_name);
+    return fd;
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_dmn_conn_glue_piperemove
+
+DESCRIPTION
+   remove a pipe
+
+    pipe_name - pipe name path
+    fd - fd for the pipe
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0: success
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_eng_dmn_conn_glue_piperemove(const char * pipe_name, int fd)
+{
+    close(fd);
+    if (pipe_name) unlink(pipe_name);
+    LOC_LOGD("fd = %d, %s\n", fd, pipe_name);
+    return 0;
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_dmn_conn_glue_pipewrite
+
+DESCRIPTION
+   write to a pipe
+
+   fd - fd of a pipe
+   buf - buffer for the data to write
+   sz - size of the data in buffer
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   number of bytes written or negative value for failure
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_eng_dmn_conn_glue_pipewrite(int fd, const void * buf, size_t sz)
+{
+    int result;
+
+    result = write(fd, buf, sz);
+
+    /* @todo check for non EINTR & EAGAIN, shall not do select again, select_tut Law 7) */
+
+    /* LOC_LOGD("fd = %d, buf = 0x%lx, size = %d, result = %d\n", fd, (long) buf, (int) sz, (int) result); */
+    return result;
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_dmn_conn_glue_piperead
+
+DESCRIPTION
+   read from a pipe
+
+   fd - fd for the pipe
+   buf - buffer to hold the data read from pipe
+   sz - size of the buffer
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   number of bytes read from pipe or negative value for failure
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_eng_dmn_conn_glue_piperead(int fd, void * buf, size_t sz)
+{
+    int len;
+
+    len = read(fd, buf, sz);
+
+    /* @todo check for non EINTR & EAGAIN, shall not do select again, select_tut Law 7) */
+
+    /* LOC_LOGD("fd = %d, buf = 0x%lx, size = %d, len = %d\n", fd, (long) buf, (int) sz, len); */
+    return len;
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_dmn_conn_glue_pipeunblock
+
+DESCRIPTION
+   unblock a pipe
+
+   fd - fd for the pipe
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0 for success or negative value for failure
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_eng_dmn_conn_glue_pipeunblock(int fd)
+{
+    int result;
+    struct flock flock_v;
+    LOC_LOGD("\n");
+//    result = fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NDELAY);
+    flock_v.l_type = F_UNLCK;
+    flock_v.l_len = 32;
+    result = fcntl(fd, F_SETLK, &flock_v);
+    if (result < 0) {
+        LOC_LOGE("fcntl failure, %s\n", strerror(errno));
+    }
+
+    return result;
+}
diff --git a/msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_glue_pipe.h b/msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_glue_pipe.h
new file mode 100644
index 0000000..b2fa3a0
--- /dev/null
+++ b/msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_glue_pipe.h
@@ -0,0 +1,50 @@
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef LOC_ENG_DMN_CONN_GLUE_PIPE_H
+#define LOC_ENG_DMN_CONN_GLUE_PIPE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#include <linux/types.h>
+
+int loc_eng_dmn_conn_glue_pipeget(const char * pipe_name, int mode);
+int loc_eng_dmn_conn_glue_piperemove(const char * pipe_name, int fd);
+int loc_eng_dmn_conn_glue_pipewrite(int fd, const void * buf, size_t sz);
+int loc_eng_dmn_conn_glue_piperead(int fd, void * buf, size_t sz);
+
+int loc_eng_dmn_conn_glue_pipeflush(int fd);
+int loc_eng_dmn_conn_glue_pipeunblock(int fd);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* LOC_ENG_DMN_CONN_GLUE_PIPE_H */
diff --git a/msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_handler.cpp b/msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_handler.cpp
new file mode 100644
index 0000000..edd53f2
--- /dev/null
+++ b/msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_handler.cpp
@@ -0,0 +1,237 @@
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "log_util.h"
+#include "platform_lib_includes.h"
+#include "loc_eng_msg.h"
+#include "loc_eng_dmn_conn.h"
+#include "loc_eng_dmn_conn_handler.h"
+
+void* loc_api_handle = NULL;
+
+int loc_eng_dmn_conn_loc_api_server_if_request_handler(struct ctrl_msgbuf *pmsg, int len)
+{
+    LOC_LOGD("%s:%d]\n", __func__, __LINE__);
+#ifndef DEBUG_DMN_LOC_API
+    if (NULL == loc_api_handle) {
+        LOC_LOGE("%s:%d] NO agps data handle\n", __func__, __LINE__);
+        return 1;
+    }
+
+    if (NULL != loc_api_handle) {
+        AGpsExtType type;
+        switch (pmsg->cmsg.cmsg_if_request.type) {
+          case IF_REQUEST_TYPE_SUPL:
+          {
+            LOC_LOGD("IF_REQUEST_TYPE_SUPL");
+            type = AGPS_TYPE_SUPL;
+            break;
+          }
+          case IF_REQUEST_TYPE_WIFI:
+          {
+            LOC_LOGD("IF_REQUEST_TYPE_WIFI");
+            type = AGPS_TYPE_WIFI;
+            break;
+          }
+          case IF_REQUEST_TYPE_ANY:
+          {
+            LOC_LOGD("IF_REQUEST_TYPE_ANY");
+            type = AGPS_TYPE_ANY;
+            break;
+          }
+          default:
+          {
+            LOC_LOGD("invalid IF_REQUEST_TYPE!");
+            return -1;
+          }
+        }
+        switch (pmsg->cmsg.cmsg_if_request.sender_id) {
+          case IF_REQUEST_SENDER_ID_QUIPC:
+          {
+            LOC_LOGD("IF_REQUEST_SENDER_ID_QUIPC");
+            LocEngReqRelWifi* msg =
+                new LocEngReqRelWifi(loc_api_handle,
+                                     type,
+                                     LOC_ENG_IF_REQUEST_SENDER_ID_QUIPC,
+                                     (char*)pmsg->cmsg.cmsg_if_request.ssid,
+                                     (char*)pmsg->cmsg.cmsg_if_request.password,
+                                     true);
+            msg->send();
+            break;
+          }
+          case IF_REQUEST_SENDER_ID_MSAPM:
+          {
+            LOC_LOGD("IF_REQUEST_SENDER_ID_MSAPM");
+            LocEngReqRelWifi* msg =
+                new LocEngReqRelWifi(loc_api_handle,
+                                     type,
+                                     LOC_ENG_IF_REQUEST_SENDER_ID_MSAPM,
+                                     (char*)pmsg->cmsg.cmsg_if_request.ssid,
+                                     (char*)pmsg->cmsg.cmsg_if_request.password,
+                                     true);
+            msg->send();
+            break;
+          }
+          case IF_REQUEST_SENDER_ID_MSAPU:
+          {
+            LOC_LOGD("IF_REQUEST_SENDER_ID_MSAPU");
+            LocEngReqRelWifi* msg =
+                new LocEngReqRelWifi(loc_api_handle,
+                                     type,
+                                     LOC_ENG_IF_REQUEST_SENDER_ID_MSAPU,
+                                     (char*)pmsg->cmsg.cmsg_if_request.ssid,
+                                     (char*)pmsg->cmsg.cmsg_if_request.password,
+                                     true);
+            msg->send();
+            break;
+          }
+          case IF_REQUEST_SENDER_ID_GPSONE_DAEMON:
+          {
+            LOC_LOGD("IF_REQUEST_SENDER_ID_GPSONE_DAEMON");
+            LocEngReqRelBIT* msg =
+                new LocEngReqRelBIT(loc_api_handle,
+                                    type,
+                                    pmsg->cmsg.cmsg_if_request.ipv4_addr,
+                                    (char*)pmsg->cmsg.cmsg_if_request.ipv6_addr,
+                                    true);
+            msg->send();
+            break;
+          }
+          default:
+          {
+            LOC_LOGD("invalid IF_REQUEST_SENDER_ID!");
+            return -1;
+          }
+        }
+    }
+
+#else
+   loc_eng_dmn_conn_loc_api_server_data_conn(LOC_ENG_IF_REQUEST_SENDER_ID_GPSONE_DAEMON, GPSONE_LOC_API_IF_REQUEST_SUCCESS);
+#endif
+    return 0;
+}
+
+int loc_eng_dmn_conn_loc_api_server_if_release_handler(struct ctrl_msgbuf *pmsg, int len)
+{
+    LOC_LOGD("%s:%d]\n", __func__, __LINE__);
+#ifndef DEBUG_DMN_LOC_API
+    AGpsExtType type;
+    switch (pmsg->cmsg.cmsg_if_request.type) {
+      case IF_REQUEST_TYPE_SUPL:
+      {
+        LOC_LOGD("IF_REQUEST_TYPE_SUPL");
+        type = AGPS_TYPE_SUPL;
+        break;
+      }
+      case IF_REQUEST_TYPE_WIFI:
+      {
+        LOC_LOGD("IF_REQUEST_TYPE_WIFI");
+        type = AGPS_TYPE_WIFI;
+        break;
+      }
+      case IF_REQUEST_TYPE_ANY:
+      {
+        LOC_LOGD("IF_REQUEST_TYPE_ANY");
+        type = AGPS_TYPE_ANY;
+        break;
+      }
+      default:
+      {
+        LOC_LOGD("invalid IF_REQUEST_TYPE!");
+        return -1;
+      }
+    }
+    switch (pmsg->cmsg.cmsg_if_request.sender_id) {
+      case IF_REQUEST_SENDER_ID_QUIPC:
+      {
+        LOC_LOGD("IF_REQUEST_SENDER_ID_QUIPC");
+        LocEngReqRelWifi* msg =
+            new LocEngReqRelWifi(loc_api_handle,
+                                 type,
+                                 LOC_ENG_IF_REQUEST_SENDER_ID_QUIPC,
+                                 (char*)pmsg->cmsg.cmsg_if_request.ssid,
+                                 (char*)pmsg->cmsg.cmsg_if_request.password,
+                                 false);
+        msg->send();
+        break;
+      }
+      case IF_REQUEST_SENDER_ID_MSAPM:
+      {
+        LOC_LOGD("IF_REQUEST_SENDER_ID_MSAPM");
+        LocEngReqRelWifi* msg =
+            new LocEngReqRelWifi(loc_api_handle,
+                                 type,
+                                 LOC_ENG_IF_REQUEST_SENDER_ID_MSAPM,
+                                 (char*)pmsg->cmsg.cmsg_if_request.ssid,
+                                 (char*)pmsg->cmsg.cmsg_if_request.password,
+                                 false);
+        msg->send();
+        break;
+      }
+      case IF_REQUEST_SENDER_ID_MSAPU:
+      {
+        LOC_LOGD("IF_REQUEST_SENDER_ID_MSAPU");
+        LocEngReqRelWifi* msg =
+            new LocEngReqRelWifi(loc_api_handle,
+                                 type,
+                                 LOC_ENG_IF_REQUEST_SENDER_ID_MSAPU,
+                                 (char*)pmsg->cmsg.cmsg_if_request.ssid,
+                                 (char*)pmsg->cmsg.cmsg_if_request.password,
+                                 false);
+        msg->send();
+        break;
+      }
+      case IF_REQUEST_SENDER_ID_GPSONE_DAEMON:
+      {
+        LOC_LOGD("IF_REQUEST_SENDER_ID_GPSONE_DAEMON");
+        LocEngReqRelBIT* msg =
+            new LocEngReqRelBIT(loc_api_handle,
+                                type,
+                                pmsg->cmsg.cmsg_if_request.ipv4_addr,
+                                (char*)pmsg->cmsg.cmsg_if_request.ipv6_addr,
+                                false);
+        msg->send();
+        break;
+      }
+      default:
+      {
+        LOC_LOGD("invalid IF_REQUEST_SENDER_ID!");
+        return -1;
+      }
+    }
+#else
+   loc_eng_dmn_conn_loc_api_server_data_conn(LOC_ENG_IF_REQUEST_SENDER_ID_GPSONE_DAEMON, GPSONE_LOC_API_IF_RELEASE_SUCCESS);
+#endif
+    return 0;
+}
+
diff --git a/msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_handler.h b/msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_handler.h
new file mode 100644
index 0000000..1c0edd5
--- /dev/null
+++ b/msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_handler.h
@@ -0,0 +1,106 @@
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef LOC_ENG_DATA_SERVER_HANDLER
+#define LOC_ENG_DATA_SERVER_HANDLER
+
+#include <linux/types.h>
+#include <arpa/inet.h>
+
+//for SSID_BUF_SIZE
+#include <hardware/gps.h>
+
+#ifndef SSID_BUF_SIZE
+    #define SSID_BUF_SIZE (32+1)
+#endif
+
+enum {
+    /* 0x0 - 0xEF is reserved for daemon internal */
+    GPSONE_LOC_API_IF_REQUEST   = 0xF0,
+    GPSONE_LOC_API_IF_RELEASE,
+    GPSONE_LOC_API_RESPONSE,
+    GPSONE_UNBLOCK,
+};
+
+enum {
+    GPSONE_LOC_API_IF_REQUEST_SUCCESS = 0xF0,
+    GPSONE_LOC_API_IF_RELEASE_SUCCESS,
+    GPSONE_LOC_API_IF_FAILURE,
+};
+
+
+struct ctrl_msg_response {
+    int result;
+};
+
+struct ctrl_msg_unblock {
+    int reserved;
+};
+
+typedef enum {
+  IF_REQUEST_TYPE_SUPL = 0,
+  IF_REQUEST_TYPE_WIFI,
+  IF_REQUEST_TYPE_ANY
+} ctrl_if_req_type_e_type;
+
+typedef enum {
+  IF_REQUEST_SENDER_ID_QUIPC = 0,
+  IF_REQUEST_SENDER_ID_MSAPM,
+  IF_REQUEST_SENDER_ID_MSAPU,
+  IF_REQUEST_SENDER_ID_GPSONE_DAEMON,
+  IF_REQUEST_SENDER_ID_MODEM
+} ctrl_if_req_sender_id_e_type;
+
+struct ctrl_msg_if_request {
+    ctrl_if_req_type_e_type type;
+    ctrl_if_req_sender_id_e_type sender_id;
+    unsigned long ipv4_addr;
+    unsigned char ipv6_addr[16];
+    char ssid[SSID_BUF_SIZE];
+    char password[SSID_BUF_SIZE];
+};
+
+/* do not change this structure */
+struct ctrl_msgbuf {
+    size_t msgsz;
+    uint16_t reserved1;
+    uint32_t reserved2;
+    uint8_t ctrl_type;
+    union {
+        struct ctrl_msg_response   cmsg_response;
+        struct ctrl_msg_unblock    cmsg_unblock;
+        struct ctrl_msg_if_request cmsg_if_request;
+    } cmsg;
+};
+
+extern void* loc_api_handle;
+
+int loc_eng_dmn_conn_loc_api_server_if_request_handler(struct ctrl_msgbuf *pmsg, int len);
+int loc_eng_dmn_conn_loc_api_server_if_release_handler(struct ctrl_msgbuf *pmsg, int len);
+
+#endif /* LOC_ENG_DATA_SERVER_HANDLER */
diff --git a/msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_thread_helper.c b/msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_thread_helper.c
new file mode 100644
index 0000000..9fed9d4
--- /dev/null
+++ b/msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_thread_helper.c
@@ -0,0 +1,399 @@
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <stdio.h>
+
+#include "log_util.h"
+#include "platform_lib_includes.h"
+#include "loc_eng_dmn_conn_thread_helper.h"
+
+/*===========================================================================
+FUNCTION    thelper_signal_init
+
+DESCRIPTION
+   This function will initialize the conditional variable resources.
+
+   thelper - thelper instance
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0: success or negative value for failure
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int thelper_signal_init(struct loc_eng_dmn_conn_thelper * thelper)
+{
+    int result;
+    thelper->thread_exit  = 0;
+    thelper->thread_ready = 0;
+    result = pthread_cond_init( &thelper->thread_cond, NULL);
+    if (result) {
+        return result;
+    }
+
+    result = pthread_mutex_init(&thelper->thread_mutex, NULL);
+    if (result) {
+        pthread_cond_destroy(&thelper->thread_cond);
+    }
+    return result;
+}
+
+/*===========================================================================
+FUNCTION
+
+DESCRIPTION
+   This function will destroy the conditional variable resources
+
+    thelper - pointer to thelper instance
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0: success or negative value for failure
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int thelper_signal_destroy(struct loc_eng_dmn_conn_thelper * thelper)
+{
+    int result, ret_result = 0;
+    result = pthread_cond_destroy( &thelper->thread_cond);
+    if (result) {
+        ret_result = result;
+    }
+
+    result = pthread_mutex_destroy(&thelper->thread_mutex);
+    if (result) {
+        ret_result = result;
+    }
+
+    return ret_result;
+}
+
+/*===========================================================================
+FUNCTION    thelper_signal_wait
+
+DESCRIPTION
+   This function will be blocked on the conditional variable until thelper_signal_ready
+   is called
+
+    thelper - pointer to thelper instance
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0: success or negative value for failure
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int thelper_signal_wait(struct loc_eng_dmn_conn_thelper * thelper)
+{
+    int result = 0;
+
+    pthread_mutex_lock(&thelper->thread_mutex);
+    if (!thelper->thread_ready && !thelper->thread_exit) {
+        result = pthread_cond_wait(&thelper->thread_cond, &thelper->thread_mutex);
+    }
+
+    if (thelper->thread_exit) {
+        result = -1;
+    }
+    pthread_mutex_unlock(&thelper->thread_mutex);
+
+    return result;
+}
+
+/*===========================================================================
+FUNCTION     thelper_signal_ready
+
+DESCRIPTION
+   This function will wake up the conditional variable
+
+    thelper - pointer to thelper instance
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0: success or negative value for failure
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int thelper_signal_ready(struct loc_eng_dmn_conn_thelper * thelper)
+{
+    int result;
+
+    LOC_LOGD("%s:%d] 0x%lx\n", __func__, __LINE__, (long) thelper);
+
+    pthread_mutex_lock(&thelper->thread_mutex);
+    thelper->thread_ready = 1;
+    result = pthread_cond_signal(&thelper->thread_cond);
+    pthread_mutex_unlock(&thelper->thread_mutex);
+
+    return result;
+}
+
+/*===========================================================================
+FUNCTION     thelper_signal_block
+
+DESCRIPTION
+   This function will set the thread ready to 0 to block the thelper_signal_wait
+
+    thelper - pointer to thelper instance
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   if thread_ready is set
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int thelper_signal_block(struct loc_eng_dmn_conn_thelper * thelper)
+{
+    int result = thelper->thread_ready;
+
+    LOC_LOGD("%s:%d] 0x%lx\n", __func__, __LINE__, (long) thelper);
+
+    pthread_mutex_lock(&thelper->thread_mutex);
+    thelper->thread_ready = 0;
+    pthread_mutex_unlock(&thelper->thread_mutex);
+
+    return result;
+}
+
+/*===========================================================================
+FUNCTION    thelper_main
+
+DESCRIPTION
+   This function is the main thread. It will be launched as a child thread
+
+    data - pointer to the instance
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   NULL
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static void * thelper_main(void *data)
+{
+    int result = 0;
+    struct loc_eng_dmn_conn_thelper * thelper = (struct loc_eng_dmn_conn_thelper *) data;
+
+    if (thelper->thread_proc_init) {
+        result = thelper->thread_proc_init(thelper->thread_context);
+        if (result < 0) {
+            thelper->thread_exit = 1;
+            thelper_signal_ready(thelper);
+            LOC_LOGE("%s:%d] error: 0x%lx\n", __func__, __LINE__, (long) thelper);
+            return NULL;
+        }
+    }
+
+    thelper_signal_ready(thelper);
+
+    if (thelper->thread_proc_pre) {
+        result = thelper->thread_proc_pre(thelper->thread_context);
+        if (result < 0) {
+            thelper->thread_exit = 1;
+            LOC_LOGE("%s:%d] error: 0x%lx\n", __func__, __LINE__, (long) thelper);
+            return NULL;
+        }
+    }
+
+    do {
+        if (thelper->thread_proc) {
+            result = thelper->thread_proc(thelper->thread_context);
+            if (result < 0) {
+                thelper->thread_exit = 1;
+                LOC_LOGE("%s:%d] error: 0x%lx\n", __func__, __LINE__, (long) thelper);
+            }
+        }
+    } while (thelper->thread_exit == 0);
+
+    if (thelper->thread_proc_post) {
+        result = thelper->thread_proc_post(thelper->thread_context);
+    }
+
+    if (result != 0) {
+        LOC_LOGE("%s:%d] error: 0x%lx\n", __func__, __LINE__, (long) thelper);
+    }
+    return NULL;
+}
+
+static void thelper_main_2(void *data)
+{
+    thelper_main(data);
+    return;
+}
+
+
+/*===========================================================================
+FUNCTION    loc_eng_dmn_conn_launch_thelper
+
+DESCRIPTION
+   This function will initialize the thread context and launch the thelper_main
+
+    thelper - pointer to thelper instance
+    thread_proc_init - The initialization function pointer
+    thread_proc_pre  - The function to call before task loop and after initialization
+    thread_proc      - The task loop
+    thread_proc_post - The function to call after the task loop
+    context          - the context for the above four functions
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0: success or negative value for failure
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_eng_dmn_conn_launch_thelper(struct loc_eng_dmn_conn_thelper * thelper,
+    int (*thread_proc_init) (void * context),
+    int (*thread_proc_pre) (void * context),
+    int (*thread_proc) (void * context),
+    int (*thread_proc_post) (void * context),
+    thelper_create_thread   create_thread_cb,
+    void * context)
+{
+    int result;
+
+    thelper_signal_init(thelper);
+
+    if (context) {
+        thelper->thread_context    = context;
+    }
+
+    thelper->thread_proc_init  = thread_proc_init;
+    thelper->thread_proc_pre   = thread_proc_pre;
+    thelper->thread_proc       = thread_proc;
+    thelper->thread_proc_post  = thread_proc_post;
+
+    LOC_LOGD("%s:%d] 0x%lx call pthread_create\n", __func__, __LINE__, (long) thelper);
+    if (create_thread_cb) {
+        result = 0;
+        thelper->thread_id = create_thread_cb("loc_eng_dmn_conn",
+            thelper_main_2, (void *)thelper);
+    } else {
+        result = pthread_create(&thelper->thread_id, NULL,
+            thelper_main, (void *)thelper);
+    }
+
+    if (result != 0) {
+        LOC_LOGE("%s:%d] 0x%lx\n", __func__, __LINE__, (long) thelper);
+        return -1;
+    }
+
+    LOC_LOGD("%s:%d] 0x%lx pthread_create done\n", __func__, __LINE__, (long) thelper);
+
+    thelper_signal_wait(thelper);
+
+    LOC_LOGD("%s:%d] 0x%lx pthread ready\n", __func__, __LINE__, (long) thelper);
+    return thelper->thread_exit;
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_dmn_conn_unblock_thelper
+
+DESCRIPTION
+   This function unblocks thelper_main to release the thread
+
+    thelper - pointer to thelper instance
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0: success
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_eng_dmn_conn_unblock_thelper(struct loc_eng_dmn_conn_thelper * thelper)
+{
+    LOC_LOGD("%s:%d] 0x%lx\n", __func__, __LINE__, (long) thelper);
+    thelper->thread_exit = 1;
+    return 0;
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_dmn_conn_join_thelper
+
+    thelper - pointer to thelper instance
+
+DESCRIPTION
+   This function will wait for the thread of thelper_main to finish
+
+DEPENDENCIES
+   None
+
+RETURN VALUE
+   0: success or negative value for failure
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_eng_dmn_conn_join_thelper(struct loc_eng_dmn_conn_thelper * thelper)
+{
+    int result;
+
+    LOC_LOGD("%s:%d] 0x%lx\n", __func__, __LINE__, (long) thelper);
+    result = pthread_join(thelper->thread_id, NULL);
+    if (result != 0) {
+        LOC_LOGE("%s:%d] 0x%lx\n", __func__, __LINE__, (long) thelper);
+    }
+    LOC_LOGD("%s:%d] 0x%lx\n", __func__, __LINE__, (long) thelper);
+
+    thelper_signal_destroy(thelper);
+
+    return result;
+}
+
diff --git a/msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_thread_helper.h b/msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_thread_helper.h
new file mode 100644
index 0000000..89e598b
--- /dev/null
+++ b/msm8974/loc_api/libloc_api_50001/loc_eng_dmn_conn_thread_helper.h
@@ -0,0 +1,74 @@
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef __LOC_ENG_DMN_CONN_THREAD_HELPER_H__
+#define __LOC_ENG_DMN_CONN_THREAD_HELPER_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#include <pthread.h>
+
+struct loc_eng_dmn_conn_thelper {
+    unsigned char   thread_exit;
+    unsigned char   thread_ready;
+    pthread_cond_t  thread_cond;
+    pthread_mutex_t thread_mutex;
+    pthread_t       thread_id;
+    void *          thread_context;
+    int             (*thread_proc_init) (void * context);
+    int             (*thread_proc_pre)  (void * context);
+    int             (*thread_proc)      (void * context);
+    int             (*thread_proc_post) (void * context);
+};
+
+typedef pthread_t (* thelper_create_thread)(const char* name, void (*start)(void *), void* arg);
+int loc_eng_dmn_conn_launch_thelper(struct loc_eng_dmn_conn_thelper * thelper,
+    int (*thread_proc_init) (void * context),
+    int (*thread_proc_pre)  (void * context),
+    int (*thread_proc)      (void * context),
+    int (*thread_proc_post) (void * context),
+    thelper_create_thread   create_thread_cb,
+    void * context);
+
+int loc_eng_dmn_conn_unblock_thelper(struct loc_eng_dmn_conn_thelper * thelper);
+int loc_eng_dmn_conn_join_thelper(struct loc_eng_dmn_conn_thelper * thelper);
+
+/* if only need to use signal */
+int thelper_signal_init(struct loc_eng_dmn_conn_thelper * thelper);
+int thelper_signal_destroy(struct loc_eng_dmn_conn_thelper * thelper);
+int thelper_signal_wait(struct loc_eng_dmn_conn_thelper * thelper);
+int thelper_signal_ready(struct loc_eng_dmn_conn_thelper * thelper);
+int thelper_signal_block(struct loc_eng_dmn_conn_thelper * thelper);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __LOC_ENG_DMN_CONN_THREAD_HELPER_H__ */
diff --git a/msm8974/loc_api/libloc_api_50001/loc_eng_log.cpp b/msm8974/loc_api/libloc_api_50001/loc_eng_log.cpp
new file mode 100644
index 0000000..3a34167
--- /dev/null
+++ b/msm8974/loc_api/libloc_api_50001/loc_eng_log.cpp
@@ -0,0 +1,35 @@
+/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#define LOG_NDDEBUG 0
+#define LOG_TAG "LocSvc_eng"
+
+#include "loc_log.h"
+#include "loc_eng_log.h"
+
diff --git a/msm8974/loc_api/libloc_api_50001/loc_eng_log.h b/msm8974/loc_api/libloc_api_50001/loc_eng_log.h
new file mode 100644
index 0000000..a68bd84
--- /dev/null
+++ b/msm8974/loc_api/libloc_api_50001/loc_eng_log.h
@@ -0,0 +1,44 @@
+/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef LOC_ENG_LOG_H
+#define LOC_ENG_LOG_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include <ctype.h>
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LOC_ENG_LOG_H */
diff --git a/msm8974/loc_api/libloc_api_50001/loc_eng_msg.h b/msm8974/loc_api/libloc_api_50001/loc_eng_msg.h
new file mode 100644
index 0000000..e3c48fb
--- /dev/null
+++ b/msm8974/loc_api/libloc_api_50001/loc_eng_msg.h
@@ -0,0 +1,313 @@
+/* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef LOC_ENG_MSG_H
+#define LOC_ENG_MSG_H
+
+
+#include <hardware/gps.h>
+#include <gps_extended.h>
+#include <stdlib.h>
+#include <string.h>
+#include <log_util.h>
+#include <loc_eng_log.h>
+#include <loc_eng.h>
+#include <MsgTask.h>
+#include <LocEngAdapter.h>
+
+#ifndef SSID_BUF_SIZE
+    #define SSID_BUF_SIZE (32+1)
+#endif
+#ifdef USE_GLIB
+
+#include <glib.h>
+
+#endif /* USE_GLIB */
+#include "platform_lib_includes.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+using namespace loc_core;
+
+struct LocEngPositionMode : public LocMsg {
+    LocEngAdapter* mAdapter;
+    const LocPosMode mPosMode;
+    LocEngPositionMode(LocEngAdapter* adapter, LocPosMode &mode);
+    virtual void proc() const;
+    virtual void log() const;
+    void send() const;
+};
+
+
+struct LocEngStartFix : public LocMsg {
+    LocEngAdapter* mAdapter;
+    LocEngStartFix(LocEngAdapter* adapter);
+    virtual void proc() const;
+    void locallog() const;
+    virtual void log() const;
+    void send() const;
+};
+
+struct LocEngStopFix : public LocMsg {
+    LocEngAdapter* mAdapter;
+    LocEngStopFix(LocEngAdapter* adapter);
+    virtual void proc() const;
+    void locallog() const;
+    virtual void log() const;
+    void send() const;
+};
+
+struct LocEngReportPosition : public LocMsg {
+    LocAdapterBase* mAdapter;
+    const UlpLocation mLocation;
+    const GpsLocationExtended mLocationExtended;
+    const void* mLocationExt;
+    const enum loc_sess_status mStatus;
+    const LocPosTechMask mTechMask;
+    LocEngReportPosition(LocAdapterBase* adapter,
+                         UlpLocation &loc,
+                         GpsLocationExtended &locExtended,
+                         void* locExt,
+                         enum loc_sess_status st,
+                         LocPosTechMask technology);
+    virtual void proc() const;
+    void locallog() const;
+    virtual void log() const;
+    void send() const;
+};
+
+struct LocEngReportSv : public LocMsg {
+    LocAdapterBase* mAdapter;
+    const GpsSvStatus mSvStatus;
+    const GpsLocationExtended mLocationExtended;
+    const void* mSvExt;
+    LocEngReportSv(LocAdapterBase* adapter,
+                   GpsSvStatus &sv,
+                   GpsLocationExtended &locExtended,
+                   void* svExtended);
+    virtual void proc() const;
+    void locallog() const;
+    virtual void log() const;
+    void send() const;
+};
+
+struct LocEngReportStatus : public LocMsg {
+    LocAdapterBase* mAdapter;
+    const GpsStatusValue mStatus;
+    LocEngReportStatus(LocAdapterBase* adapter,
+                       GpsStatusValue engineStatus);
+    virtual void proc() const;
+    void locallog() const;
+    virtual void log() const;
+};
+
+struct LocEngReportNmea : public LocMsg {
+    void* mLocEng;
+    char* const mNmea;
+    const int mLen;
+    LocEngReportNmea(void* locEng,
+                     const char* data, int len);
+    inline virtual ~LocEngReportNmea()
+    {
+        delete[] mNmea;
+    }
+    virtual void proc() const;
+    void locallog() const;
+    virtual void log() const;
+};
+
+struct LocEngReportXtraServer : public LocMsg {
+    void* mLocEng;
+    int mMaxLen;
+    char *mServers;
+    LocEngReportXtraServer(void* locEng,
+                           const char *url1, const char *url2,
+                           const char *url3, const int maxlength);
+    inline virtual ~LocEngReportXtraServer()
+    {
+        delete[] mServers;
+    }
+    virtual void proc() const;
+    void locallog() const;
+    virtual void log() const;
+};
+
+struct LocEngSuplEsOpened : public LocMsg {
+    void* mLocEng;
+    LocEngSuplEsOpened(void* locEng);
+    virtual void proc() const;
+    void locallog() const;
+    virtual void log() const;
+};
+
+struct LocEngSuplEsClosed : public LocMsg {
+    void* mLocEng;
+    LocEngSuplEsClosed(void* locEng);
+    virtual void proc() const;
+    void locallog() const;
+    virtual void log() const;
+};
+
+struct LocEngRequestSuplEs : public LocMsg {
+    void* mLocEng;
+    const int mID;
+    LocEngRequestSuplEs(void* locEng, int id);
+    virtual void proc() const;
+    void locallog() const;
+    virtual void log() const;
+};
+
+struct LocEngRequestATL : public LocMsg {
+    void* mLocEng;
+    const int mID;
+    const AGpsExtType mType;
+    LocEngRequestATL(void* locEng, int id,
+                     AGpsExtType agps_type);
+    virtual void proc() const;
+    void locallog() const;
+    virtual void log() const;
+};
+
+struct LocEngReleaseATL : public LocMsg {
+    void* mLocEng;
+    const int mID;
+    LocEngReleaseATL(void* locEng, int id);
+    virtual void proc() const;
+    void locallog() const;
+    virtual void log() const;
+};
+
+struct LocEngReqRelBIT : public LocMsg {
+    void* mLocEng;
+    const AGpsExtType mType;
+    const int mIPv4Addr;
+    char* const mIPv6Addr;
+    const bool mIsReq;
+    LocEngReqRelBIT(void* instance, AGpsExtType type,
+                    int ipv4, char* ipv6, bool isReq);
+    virtual ~LocEngReqRelBIT();
+    virtual void proc() const;
+    void locallog() const;
+    virtual void log() const;
+    void send() const;
+};
+
+struct LocEngReqRelWifi : public LocMsg {
+    void* mLocEng;
+    const AGpsExtType mType;
+    const loc_if_req_sender_id_e_type mSenderId;
+    char* const mSSID;
+    char* const mPassword;
+    const bool mIsReq;
+    LocEngReqRelWifi(void* locEng, AGpsExtType type,
+                     loc_if_req_sender_id_e_type sender_id,
+                     char* s, char* p, bool isReq);
+    virtual ~LocEngReqRelWifi();
+    virtual void proc() const;
+    void locallog() const;
+    virtual void log() const;
+    void send() const;
+};
+
+struct LocEngRequestXtra : public LocMsg {
+    void* mLocEng;
+    LocEngRequestXtra(void* locEng);
+    virtual void proc() const;
+    void locallog() const;
+    virtual void log() const;
+};
+
+struct LocEngRequestTime : public LocMsg {
+    void* mLocEng;
+    LocEngRequestTime(void* locEng);
+    virtual void proc() const;
+    void locallog() const;
+    virtual void log() const;
+};
+
+struct LocEngRequestNi : public LocMsg {
+    void* mLocEng;
+    const GpsNiNotification mNotify;
+    const void *mPayload;
+    LocEngRequestNi(void* locEng,
+                    GpsNiNotification &notif,
+                    const void* data);
+    virtual void proc() const;
+    void locallog() const;
+    virtual void log() const;
+};
+
+struct LocEngDown : public LocMsg {
+    void* mLocEng;
+    LocEngDown(void* locEng);
+    virtual void proc() const;
+    void locallog() const;
+    virtual void log() const;
+};
+
+struct LocEngUp : public LocMsg {
+    void* mLocEng;
+    LocEngUp(void* locEng);
+    virtual void proc() const;
+    void locallog() const;
+    virtual void log() const;
+};
+
+struct LocEngGetZpp : public LocMsg {
+    LocEngAdapter* mAdapter;
+    LocEngGetZpp(LocEngAdapter* adapter);
+    virtual void proc() const;
+    void locallog() const;
+    virtual void log() const;
+    void send() const;
+};
+
+struct LocEngReportGpsMeasurement : public LocMsg {
+    void* mLocEng;
+    const GpsData mGpsData;
+    LocEngReportGpsMeasurement(void* locEng,
+                               GpsData &gpsData);
+    virtual void proc() const;
+    void locallog() const;
+    virtual void log() const;
+};
+
+struct LocEngShutdown : public LocMsg {
+    LocEngAdapter* mAdapter;
+    LocEngShutdown(LocEngAdapter* adapter);
+    virtual void proc() const;
+    void locallog() const;
+    virtual void log() const;
+};
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* LOC_ENG_MSG_H */
diff --git a/msm8974/loc_api/libloc_api_50001/loc_eng_ni.cpp b/msm8974/loc_api/libloc_api_50001/loc_eng_ni.cpp
new file mode 100644
index 0000000..4597b98
--- /dev/null
+++ b/msm8974/loc_api/libloc_api_50001/loc_eng_ni.cpp
@@ -0,0 +1,414 @@
+/* Copyright (c) 2009-2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#define LOG_NDDEBUG 0
+#define LOG_TAG "LocSvc_eng"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <pthread.h>
+#include <errno.h>
+#include <string.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <time.h>
+#include <MsgTask.h>
+
+#include <loc_eng.h>
+
+#include "log_util.h"
+#include "platform_lib_includes.h"
+
+using namespace loc_core;
+
+/*=============================================================================
+ *
+ *                             DATA DECLARATION
+ *
+ *============================================================================*/
+
+/*=============================================================================
+ *
+ *                             FUNCTION DECLARATIONS
+ *
+ *============================================================================*/
+static void* ni_thread_proc(void *args);
+
+struct LocEngInformNiResponse : public LocMsg {
+    LocEngAdapter* mAdapter;
+    const GpsUserResponseType mResponse;
+    const void *mPayload;
+    inline LocEngInformNiResponse(LocEngAdapter* adapter,
+                                  GpsUserResponseType resp,
+                                  const void* data) :
+        LocMsg(), mAdapter(adapter),
+        mResponse(resp), mPayload(data)
+    {
+        locallog();
+    }
+    inline ~LocEngInformNiResponse()
+    {
+        // this is a bit weird since mPayload is not
+        // allocated by this class.  But there is no better way.
+        // mPayload actually won't be NULL here.
+        free((void*)mPayload);
+    }
+    inline virtual void proc() const
+    {
+        mAdapter->informNiResponse(mResponse, mPayload);
+    }
+    inline void locallog() const
+    {
+        LOC_LOGV("LocEngInformNiResponse - "
+                 "response: %s\n  mPayload: %p",
+                 loc_get_ni_response_name(mResponse),
+                 mPayload);
+    }
+    inline virtual void log() const
+    {
+        locallog();
+    }
+};
+
+/*===========================================================================
+
+FUNCTION loc_eng_ni_request_handler
+
+DESCRIPTION
+   Displays the NI request and awaits user input. If a previous request is
+   in session, it is ignored.
+
+RETURN VALUE
+   none
+
+===========================================================================*/
+void loc_eng_ni_request_handler(loc_eng_data_s_type &loc_eng_data,
+                            const GpsNiNotification *notif,
+                            const void* passThrough)
+{
+    ENTRY_LOG();
+    char lcs_addr[32]; // Decoded LCS address for UMTS CP NI
+    loc_eng_ni_data_s_type* loc_eng_ni_data_p = &loc_eng_data.loc_eng_ni_data;
+    loc_eng_ni_session_s_type* pSession = NULL;
+
+    if (NULL == loc_eng_data.ni_notify_cb) {
+        EXIT_LOG(%s, "loc_eng_ni_init hasn't happened yet.");
+        return;
+    }
+
+    if (notif->ni_type == GPS_NI_TYPE_EMERGENCY_SUPL) {
+        if (NULL != loc_eng_ni_data_p->sessionEs.rawRequest) {
+            LOC_LOGW("loc_eng_ni_request_handler, supl es NI in progress, new supl es NI ignored, type: %d",
+                     notif->ni_type);
+            if (NULL != passThrough) {
+                free((void*)passThrough);
+            }
+        } else {
+            pSession = &loc_eng_ni_data_p->sessionEs;
+        }
+    } else {
+        if (NULL != loc_eng_ni_data_p->session.rawRequest ||
+            NULL != loc_eng_ni_data_p->sessionEs.rawRequest) {
+            LOC_LOGW("loc_eng_ni_request_handler, supl NI in progress, new supl NI ignored, type: %d",
+                     notif->ni_type);
+            if (NULL != passThrough) {
+                free((void*)passThrough);
+            }
+        } else {
+            pSession = &loc_eng_ni_data_p->session;
+        }
+    }
+
+
+    if (pSession) {
+        /* Save request */
+        pSession->rawRequest = (void*)passThrough;
+        pSession->reqID = ++loc_eng_ni_data_p->reqIDCounter;
+        pSession->adapter = loc_eng_data.adapter;
+
+        /* Fill in notification */
+        ((GpsNiNotification*)notif)->notification_id = pSession->reqID;
+
+        if (notif->notify_flags == GPS_NI_PRIVACY_OVERRIDE)
+        {
+            loc_eng_mute_one_session(loc_eng_data);
+        }
+
+        /* Log requestor ID and text for debugging */
+        LOC_LOGI("Notification: notif_type: %d, timeout: %d, default_resp: %d", notif->ni_type, notif->timeout, notif->default_response);
+        LOC_LOGI("              requestor_id: %s (encoding: %d)", notif->requestor_id, notif->requestor_id_encoding);
+        LOC_LOGI("              text: %s text (encoding: %d)", notif->text, notif->text_encoding);
+        if (notif->extras[0])
+        {
+            LOC_LOGI("              extras: %s", notif->extras);
+        }
+
+        /* For robustness, spawn a thread at this point to timeout to clear up the notification status, even though
+         * the OEM layer in java does not do so.
+         **/
+        pSession->respTimeLeft = 5 + (notif->timeout != 0 ? notif->timeout : LOC_NI_NO_RESPONSE_TIME);
+        LOC_LOGI("Automatically sends 'no response' in %d seconds (to clear status)\n", pSession->respTimeLeft);
+
+        int rc = 0;
+        rc = pthread_create(&pSession->thread, NULL, ni_thread_proc, pSession);
+        if (rc)
+        {
+            LOC_LOGE("Loc NI thread is not created.\n");
+        }
+        rc = pthread_detach(pSession->thread);
+        if (rc)
+        {
+            LOC_LOGE("Loc NI thread is not detached.\n");
+        }
+
+        CALLBACK_LOG_CALLFLOW("ni_notify_cb - id", %d, notif->notification_id);
+        loc_eng_data.ni_notify_cb((GpsNiNotification*)notif);
+    }
+    EXIT_LOG(%s, VOID_RET);
+}
+
+/*===========================================================================
+
+FUNCTION ni_thread_proc
+
+===========================================================================*/
+static void* ni_thread_proc(void *args)
+{
+    ENTRY_LOG();
+
+    loc_eng_ni_session_s_type* pSession = (loc_eng_ni_session_s_type*)args;
+    int rc = 0;          /* return code from pthread calls */
+
+    struct timeval present_time;
+    struct timespec expire_time;
+
+    LOC_LOGD("Starting Loc NI thread...\n");
+    pthread_mutex_lock(&pSession->tLock);
+    /* Calculate absolute expire time */
+    gettimeofday(&present_time, NULL);
+    expire_time.tv_sec  = present_time.tv_sec + pSession->respTimeLeft;
+    expire_time.tv_nsec = present_time.tv_usec * 1000;
+    LOC_LOGD("ni_thread_proc-Time out set for abs time %ld with delay %d sec\n",
+             (long) expire_time.tv_sec, pSession->respTimeLeft );
+
+    while (!pSession->respRecvd)
+    {
+        rc = pthread_cond_timedwait(&pSession->tCond,
+                                    &pSession->tLock,
+                                    &expire_time);
+        if (rc == ETIMEDOUT)
+        {
+            pSession->resp = GPS_NI_RESPONSE_NORESP;
+            LOC_LOGD("ni_thread_proc-Thread time out after valting for specified time. Ret Val %d\n",rc );
+            break;
+        }
+    }
+    LOC_LOGD("ni_thread_proc-Java layer has sent us a user response and return value from "
+             "pthread_cond_timedwait = %d\n",rc );
+    pSession->respRecvd = FALSE; /* Reset the user response flag for the next session*/
+
+    LOC_LOGD("pSession->resp is %d\n",pSession->resp);
+
+    // adding this check to support modem restart, in which case, we need the thread
+    // to exit without calling sending data. We made sure that rawRequest is NULL in
+    // loc_eng_ni_reset_on_engine_restart()
+    LocEngAdapter* adapter = pSession->adapter;
+    LocEngInformNiResponse *msg = NULL;
+
+    if (NULL != pSession->rawRequest) {
+        if (pSession->resp != GPS_NI_RESPONSE_IGNORE) {
+            LOC_LOGD("pSession->resp != GPS_NI_RESPONSE_IGNORE \n");
+            msg = new LocEngInformNiResponse(adapter,
+                                             pSession->resp,
+                                             pSession->rawRequest);
+        } else {
+            LOC_LOGD("this is the ignore reply for SUPL ES\n");
+            free(pSession->rawRequest);
+        }
+        pSession->rawRequest = NULL;
+    }
+    pthread_mutex_unlock(&pSession->tLock);
+
+    pSession->respTimeLeft = 0;
+    pSession->reqID = 0;
+
+    if (NULL != msg) {
+        LOC_LOGD("ni_thread_proc: adapter->sendMsg(msg)\n");
+        adapter->sendMsg(msg);
+    }
+
+    EXIT_LOG(%s, VOID_RET);
+    return NULL;
+}
+
+void loc_eng_ni_reset_on_engine_restart(loc_eng_data_s_type &loc_eng_data)
+{
+    ENTRY_LOG();
+    loc_eng_ni_data_s_type* loc_eng_ni_data_p = &loc_eng_data.loc_eng_ni_data;
+
+    if (NULL == loc_eng_data.ni_notify_cb) {
+        EXIT_LOG(%s, "loc_eng_ni_init hasn't happened yet.");
+        return;
+    }
+
+    // only if modem has requested but then died.
+    if (NULL != loc_eng_ni_data_p->sessionEs.rawRequest) {
+        free(loc_eng_ni_data_p->sessionEs.rawRequest);
+        loc_eng_ni_data_p->sessionEs.rawRequest = NULL;
+
+        pthread_mutex_lock(&loc_eng_ni_data_p->sessionEs.tLock);
+        // the goal is to wake up ni_thread_proc
+        // and let it exit.
+        loc_eng_ni_data_p->sessionEs.respRecvd = TRUE;
+        pthread_cond_signal(&loc_eng_ni_data_p->sessionEs.tCond);
+        pthread_mutex_unlock(&loc_eng_ni_data_p->sessionEs.tLock);
+    }
+
+    if (NULL != loc_eng_ni_data_p->session.rawRequest) {
+        free(loc_eng_ni_data_p->session.rawRequest);
+        loc_eng_ni_data_p->session.rawRequest = NULL;
+
+        pthread_mutex_lock(&loc_eng_ni_data_p->session.tLock);
+        // the goal is to wake up ni_thread_proc
+        // and let it exit.
+        loc_eng_ni_data_p->session.respRecvd = TRUE;
+        pthread_cond_signal(&loc_eng_ni_data_p->session.tCond);
+        pthread_mutex_unlock(&loc_eng_ni_data_p->session.tLock);
+    }
+
+    EXIT_LOG(%s, VOID_RET);
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_ni_init
+
+DESCRIPTION
+   This function initializes the NI interface
+
+DEPENDENCIES
+   NONE
+
+RETURN VALUE
+   None
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+void loc_eng_ni_init(loc_eng_data_s_type &loc_eng_data, GpsNiExtCallbacks *callbacks)
+{
+    ENTRY_LOG_CALLFLOW();
+
+    if(callbacks == NULL)
+        EXIT_LOG(%s, "loc_eng_ni_init: failed, cb is NULL");
+    else if (NULL == callbacks->notify_cb) {
+        EXIT_LOG(%s, "loc_eng_ni_init: failed, no cb.");
+    } else if (NULL != loc_eng_data.ni_notify_cb) {
+        EXIT_LOG(%s, "loc_eng_ni_init: already inited.");
+    } else {
+        loc_eng_ni_data_s_type* loc_eng_ni_data_p = &loc_eng_data.loc_eng_ni_data;
+        loc_eng_ni_data_p->sessionEs.respTimeLeft = 0;
+        loc_eng_ni_data_p->sessionEs.respRecvd = FALSE;
+        loc_eng_ni_data_p->sessionEs.rawRequest = NULL;
+        loc_eng_ni_data_p->sessionEs.reqID = 0;
+        pthread_cond_init(&loc_eng_ni_data_p->sessionEs.tCond, NULL);
+        pthread_mutex_init(&loc_eng_ni_data_p->sessionEs.tLock, NULL);
+
+        loc_eng_ni_data_p->session.respTimeLeft = 0;
+        loc_eng_ni_data_p->session.respRecvd = FALSE;
+        loc_eng_ni_data_p->session.rawRequest = NULL;
+        loc_eng_ni_data_p->session.reqID = 0;
+        pthread_cond_init(&loc_eng_ni_data_p->session.tCond, NULL);
+        pthread_mutex_init(&loc_eng_ni_data_p->session.tLock, NULL);
+
+        loc_eng_data.ni_notify_cb = callbacks->notify_cb;
+        EXIT_LOG(%s, VOID_RET);
+    }
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_ni_respond
+
+DESCRIPTION
+   This function receives user response from upper layer framework
+
+DEPENDENCIES
+   NONE
+
+RETURN VALUE
+   None
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+void loc_eng_ni_respond(loc_eng_data_s_type &loc_eng_data,
+                        int notif_id, GpsUserResponseType user_response)
+{
+    ENTRY_LOG_CALLFLOW();
+    loc_eng_ni_data_s_type* loc_eng_ni_data_p = &loc_eng_data.loc_eng_ni_data;
+    loc_eng_ni_session_s_type* pSession = NULL;
+
+    if (NULL == loc_eng_data.ni_notify_cb) {
+        EXIT_LOG(%s, "loc_eng_ni_init hasn't happened yet.");
+        return;
+    }
+
+    if (notif_id == loc_eng_ni_data_p->sessionEs.reqID &&
+        NULL != loc_eng_ni_data_p->sessionEs.rawRequest) {
+        pSession = &loc_eng_ni_data_p->sessionEs;
+        // ignore any SUPL NI non-Es session if a SUPL NI ES is accepted
+        if (user_response == GPS_NI_RESPONSE_ACCEPT &&
+            NULL != loc_eng_ni_data_p->session.rawRequest) {
+                pthread_mutex_lock(&loc_eng_ni_data_p->session.tLock);
+                loc_eng_ni_data_p->session.resp = GPS_NI_RESPONSE_IGNORE;
+                loc_eng_ni_data_p->session.respRecvd = TRUE;
+                pthread_cond_signal(&loc_eng_ni_data_p->session.tCond);
+                pthread_mutex_unlock(&loc_eng_ni_data_p->session.tLock);
+        }
+    } else if (notif_id == loc_eng_ni_data_p->session.reqID &&
+        NULL != loc_eng_ni_data_p->session.rawRequest) {
+        pSession = &loc_eng_ni_data_p->session;
+    }
+
+    if (pSession) {
+        LOC_LOGI("loc_eng_ni_respond: send user response %d for notif %d", user_response, notif_id);
+        pthread_mutex_lock(&pSession->tLock);
+        pSession->resp = user_response;
+        pSession->respRecvd = TRUE;
+        pthread_cond_signal(&pSession->tCond);
+        pthread_mutex_unlock(&pSession->tLock);
+    }
+    else {
+        LOC_LOGE("loc_eng_ni_respond: notif_id %d not an active session", notif_id);
+    }
+
+    EXIT_LOG(%s, VOID_RET);
+}
diff --git a/msm8974/loc_api/libloc_api_50001/loc_eng_ni.h b/msm8974/loc_api/libloc_api_50001/loc_eng_ni.h
new file mode 100644
index 0000000..068f5cd
--- /dev/null
+++ b/msm8974/loc_api/libloc_api_50001/loc_eng_ni.h
@@ -0,0 +1,59 @@
+/* Copyright (c) 2009,2011,2014 The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef LOC_ENG_NI_H
+#define LOC_ENG_NI_H
+
+#include <stdbool.h>
+#include <LocEngAdapter.h>
+
+#define LOC_NI_NO_RESPONSE_TIME            20                      /* secs */
+#define LOC_NI_NOTIF_KEY_ADDRESS           "Address"
+#define GPS_NI_RESPONSE_IGNORE             4
+
+typedef struct {
+    pthread_t               thread;            /* NI thread */
+    int                     respTimeLeft;       /* examine time for NI response */
+    bool                    respRecvd;   /* NI User reponse received or not from Java layer*/
+    void*                   rawRequest;
+    int                     reqID;         /* ID to check against response */
+    GpsUserResponseType     resp;
+    pthread_cond_t          tCond;
+    pthread_mutex_t         tLock;
+    LocEngAdapter*          adapter;
+} loc_eng_ni_session_s_type;
+
+typedef struct {
+    loc_eng_ni_session_s_type session;    /* SUPL NI Session */
+    loc_eng_ni_session_s_type sessionEs;  /* Emergency SUPL NI Session */
+    int reqIDCounter;
+} loc_eng_ni_data_s_type;
+
+
+#endif /* LOC_ENG_NI_H */
diff --git a/msm8974/loc_api/libloc_api_50001/loc_eng_nmea.cpp b/msm8974/loc_api/libloc_api_50001/loc_eng_nmea.cpp
new file mode 100644
index 0000000..842eda1
--- /dev/null
+++ b/msm8974/loc_api/libloc_api_50001/loc_eng_nmea.cpp
@@ -0,0 +1,833 @@
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#define LOG_NDDEBUG 0
+#define LOG_TAG "LocSvc_eng_nmea"
+#define GPS_PRN_START 1
+#define GPS_PRN_END   32
+#define GLONASS_PRN_START 65
+#define GLONASS_PRN_END   96
+#include <loc_eng.h>
+#include <loc_eng_nmea.h>
+#include <math.h>
+#include "log_util.h"
+
+/*===========================================================================
+FUNCTION    loc_eng_nmea_send
+
+DESCRIPTION
+   send out NMEA sentence
+
+DEPENDENCIES
+   NONE
+
+RETURN VALUE
+   Total length of the nmea sentence
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+void loc_eng_nmea_send(char *pNmea, int length, loc_eng_data_s_type *loc_eng_data_p)
+{
+    struct timeval tv;
+    gettimeofday(&tv, (struct timezone *) NULL);
+    int64_t now = tv.tv_sec * 1000LL + tv.tv_usec / 1000;
+    CALLBACK_LOG_CALLFLOW("nmea_cb", %p, pNmea);
+    if (loc_eng_data_p->nmea_cb != NULL)
+        loc_eng_data_p->nmea_cb(now, pNmea, length);
+    LOC_LOGD("NMEA <%s", pNmea);
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_nmea_put_checksum
+
+DESCRIPTION
+   Generate NMEA sentences generated based on position report
+
+DEPENDENCIES
+   NONE
+
+RETURN VALUE
+   Total length of the nmea sentence
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_eng_nmea_put_checksum(char *pNmea, int maxSize)
+{
+    uint8_t checksum = 0;
+    int length = 0;
+
+    pNmea++; //skip the $
+    while (*pNmea != '\0')
+    {
+        checksum ^= *pNmea++;
+        length++;
+    }
+
+    int checksumLength = snprintf(pNmea,(maxSize-length-1),"*%02X\r\n", checksum);
+    return (length + checksumLength);
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_nmea_generate_pos
+
+DESCRIPTION
+   Generate NMEA sentences generated based on position report
+
+DEPENDENCIES
+   NONE
+
+RETURN VALUE
+   0
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+void loc_eng_nmea_generate_pos(loc_eng_data_s_type *loc_eng_data_p,
+                               const UlpLocation &location,
+                               const GpsLocationExtended &locationExtended,
+                               unsigned char generate_nmea)
+{
+    ENTRY_LOG();
+
+    char sentence[NMEA_SENTENCE_MAX_LENGTH] = {0};
+    char* pMarker = sentence;
+    int lengthRemaining = sizeof(sentence);
+    int length = 0;
+
+    time_t utcTime(location.gpsLocation.timestamp/1000);
+    tm * pTm = gmtime(&utcTime);
+    int utcYear = pTm->tm_year % 100; // 2 digit year
+    int utcMonth = pTm->tm_mon + 1; // tm_mon starts at zero
+    int utcDay = pTm->tm_mday;
+    int utcHours = pTm->tm_hour;
+    int utcMinutes = pTm->tm_min;
+    int utcSeconds = pTm->tm_sec;
+
+    if (generate_nmea) {
+        // ------------------
+        // ------$GPGSA------
+        // ------------------
+
+        uint32_t svUsedCount = 0;
+        uint32_t svUsedList[32] = {0};
+        uint32_t mask = loc_eng_data_p->sv_used_mask;
+        for (uint8_t i = 1; mask > 0 && svUsedCount < 32; i++)
+        {
+            if (mask & 1)
+                svUsedList[svUsedCount++] = i;
+            mask = mask >> 1;
+        }
+        // clear the cache so they can't be used again
+        loc_eng_data_p->sv_used_mask = 0;
+
+        char fixType;
+        if (svUsedCount == 0)
+            fixType = '1'; // no fix
+        else if (svUsedCount <= 3)
+            fixType = '2'; // 2D fix
+        else
+            fixType = '3'; // 3D fix
+
+        length = snprintf(pMarker, lengthRemaining, "$GPGSA,A,%c,", fixType);
+
+        if (length < 0 || length >= lengthRemaining)
+        {
+            LOC_LOGE("NMEA Error in string formatting");
+            return;
+        }
+        pMarker += length;
+        lengthRemaining -= length;
+
+        for (uint8_t i = 0; i < 12; i++) // only the first 12 sv go in sentence
+        {
+            if (i < svUsedCount)
+                length = snprintf(pMarker, lengthRemaining, "%02d,", svUsedList[i]);
+            else
+                length = snprintf(pMarker, lengthRemaining, ",");
+
+            if (length < 0 || length >= lengthRemaining)
+            {
+                LOC_LOGE("NMEA Error in string formatting");
+                return;
+            }
+            pMarker += length;
+            lengthRemaining -= length;
+        }
+
+        if (locationExtended.flags & GPS_LOCATION_EXTENDED_HAS_DOP)
+        {   // dop is in locationExtended, (QMI)
+            length = snprintf(pMarker, lengthRemaining, "%.1f,%.1f,%.1f",
+                              locationExtended.pdop,
+                              locationExtended.hdop,
+                              locationExtended.vdop);
+        }
+        else if (loc_eng_data_p->pdop > 0 && loc_eng_data_p->hdop > 0 && loc_eng_data_p->vdop > 0)
+        {   // dop was cached from sv report (RPC)
+            length = snprintf(pMarker, lengthRemaining, "%.1f,%.1f,%.1f",
+                              loc_eng_data_p->pdop,
+                              loc_eng_data_p->hdop,
+                              loc_eng_data_p->vdop);
+        }
+        else
+        {   // no dop
+            length = snprintf(pMarker, lengthRemaining, ",,");
+        }
+
+        length = loc_eng_nmea_put_checksum(sentence, sizeof(sentence));
+        loc_eng_nmea_send(sentence, length, loc_eng_data_p);
+
+        // ------------------
+        // ------$GPVTG------
+        // ------------------
+
+        pMarker = sentence;
+        lengthRemaining = sizeof(sentence);
+
+        if (location.gpsLocation.flags & GPS_LOCATION_HAS_BEARING)
+        {
+            float magTrack = location.gpsLocation.bearing;
+            if (locationExtended.flags & GPS_LOCATION_EXTENDED_HAS_MAG_DEV)
+            {
+                float magTrack = location.gpsLocation.bearing - locationExtended.magneticDeviation;
+                if (magTrack < 0.0)
+                    magTrack += 360.0;
+                else if (magTrack > 360.0)
+                    magTrack -= 360.0;
+            }
+
+            length = snprintf(pMarker, lengthRemaining, "$GPVTG,%.1lf,T,%.1lf,M,", location.gpsLocation.bearing, magTrack);
+        }
+        else
+        {
+            length = snprintf(pMarker, lengthRemaining, "$GPVTG,,T,,M,");
+        }
+
+        if (length < 0 || length >= lengthRemaining)
+        {
+            LOC_LOGE("NMEA Error in string formatting");
+            return;
+        }
+        pMarker += length;
+        lengthRemaining -= length;
+
+        if (location.gpsLocation.flags & GPS_LOCATION_HAS_SPEED)
+        {
+            float speedKnots = location.gpsLocation.speed * (3600.0/1852.0);
+            float speedKmPerHour = location.gpsLocation.speed * 3.6;
+
+            length = snprintf(pMarker, lengthRemaining, "%.1lf,N,%.1lf,K,", speedKnots, speedKmPerHour);
+        }
+        else
+        {
+            length = snprintf(pMarker, lengthRemaining, ",N,,K,");
+        }
+
+        if (length < 0 || length >= lengthRemaining)
+        {
+            LOC_LOGE("NMEA Error in string formatting");
+            return;
+        }
+        pMarker += length;
+        lengthRemaining -= length;
+
+        if (!(location.gpsLocation.flags & GPS_LOCATION_HAS_LAT_LONG))
+            length = snprintf(pMarker, lengthRemaining, "%c", 'N'); // N means no fix
+        else if (LOC_POSITION_MODE_STANDALONE == loc_eng_data_p->adapter->getPositionMode().mode)
+            length = snprintf(pMarker, lengthRemaining, "%c", 'A'); // A means autonomous
+        else
+            length = snprintf(pMarker, lengthRemaining, "%c", 'D'); // D means differential
+
+        length = loc_eng_nmea_put_checksum(sentence, sizeof(sentence));
+        loc_eng_nmea_send(sentence, length, loc_eng_data_p);
+
+        // ------------------
+        // ------$GPRMC------
+        // ------------------
+
+        pMarker = sentence;
+        lengthRemaining = sizeof(sentence);
+
+        length = snprintf(pMarker, lengthRemaining, "$GPRMC,%02d%02d%02d,A," ,
+                          utcHours, utcMinutes, utcSeconds);
+
+        if (length < 0 || length >= lengthRemaining)
+        {
+            LOC_LOGE("NMEA Error in string formatting");
+            return;
+        }
+        pMarker += length;
+        lengthRemaining -= length;
+
+        if (location.gpsLocation.flags & GPS_LOCATION_HAS_LAT_LONG)
+        {
+            double latitude = location.gpsLocation.latitude;
+            double longitude = location.gpsLocation.longitude;
+            char latHemisphere;
+            char lonHemisphere;
+            double latMinutes;
+            double lonMinutes;
+
+            if (latitude > 0)
+            {
+                latHemisphere = 'N';
+            }
+            else
+            {
+                latHemisphere = 'S';
+                latitude *= -1.0;
+            }
+
+            if (longitude < 0)
+            {
+                lonHemisphere = 'W';
+                longitude *= -1.0;
+            }
+            else
+            {
+                lonHemisphere = 'E';
+            }
+
+            latMinutes = fmod(latitude * 60.0 , 60.0);
+            lonMinutes = fmod(longitude * 60.0 , 60.0);
+
+            length = snprintf(pMarker, lengthRemaining, "%02d%09.6lf,%c,%03d%09.6lf,%c,",
+                              (uint8_t)floor(latitude), latMinutes, latHemisphere,
+                              (uint8_t)floor(longitude),lonMinutes, lonHemisphere);
+        }
+        else
+        {
+            length = snprintf(pMarker, lengthRemaining,",,,,");
+        }
+
+        if (length < 0 || length >= lengthRemaining)
+        {
+            LOC_LOGE("NMEA Error in string formatting");
+            return;
+        }
+        pMarker += length;
+        lengthRemaining -= length;
+
+        if (location.gpsLocation.flags & GPS_LOCATION_HAS_SPEED)
+        {
+            float speedKnots = location.gpsLocation.speed * (3600.0/1852.0);
+            length = snprintf(pMarker, lengthRemaining, "%.1lf,", speedKnots);
+        }
+        else
+        {
+            length = snprintf(pMarker, lengthRemaining, ",");
+        }
+
+        if (length < 0 || length >= lengthRemaining)
+        {
+            LOC_LOGE("NMEA Error in string formatting");
+            return;
+        }
+        pMarker += length;
+        lengthRemaining -= length;
+
+        if (location.gpsLocation.flags & GPS_LOCATION_HAS_BEARING)
+        {
+            length = snprintf(pMarker, lengthRemaining, "%.1lf,", location.gpsLocation.bearing);
+        }
+        else
+        {
+            length = snprintf(pMarker, lengthRemaining, ",");
+        }
+
+        if (length < 0 || length >= lengthRemaining)
+        {
+            LOC_LOGE("NMEA Error in string formatting");
+            return;
+        }
+        pMarker += length;
+        lengthRemaining -= length;
+
+        length = snprintf(pMarker, lengthRemaining, "%2.2d%2.2d%2.2d,",
+                          utcDay, utcMonth, utcYear);
+
+        if (length < 0 || length >= lengthRemaining)
+        {
+            LOC_LOGE("NMEA Error in string formatting");
+            return;
+        }
+        pMarker += length;
+        lengthRemaining -= length;
+
+        if (locationExtended.flags & GPS_LOCATION_EXTENDED_HAS_MAG_DEV)
+        {
+            float magneticVariation = locationExtended.magneticDeviation;
+            char direction;
+            if (magneticVariation < 0.0)
+            {
+                direction = 'W';
+                magneticVariation *= -1.0;
+            }
+            else
+            {
+                direction = 'E';
+            }
+
+            length = snprintf(pMarker, lengthRemaining, "%.1lf,%c,",
+                              magneticVariation, direction);
+        }
+        else
+        {
+            length = snprintf(pMarker, lengthRemaining, ",,");
+        }
+
+        if (length < 0 || length >= lengthRemaining)
+        {
+            LOC_LOGE("NMEA Error in string formatting");
+            return;
+        }
+        pMarker += length;
+        lengthRemaining -= length;
+
+        if (!(location.gpsLocation.flags & GPS_LOCATION_HAS_LAT_LONG))
+            length = snprintf(pMarker, lengthRemaining, "%c", 'N'); // N means no fix
+        else if (LOC_POSITION_MODE_STANDALONE == loc_eng_data_p->adapter->getPositionMode().mode)
+            length = snprintf(pMarker, lengthRemaining, "%c", 'A'); // A means autonomous
+        else
+            length = snprintf(pMarker, lengthRemaining, "%c", 'D'); // D means differential
+
+        length = loc_eng_nmea_put_checksum(sentence, sizeof(sentence));
+        loc_eng_nmea_send(sentence, length, loc_eng_data_p);
+
+        // ------------------
+        // ------$GPGGA------
+        // ------------------
+
+        pMarker = sentence;
+        lengthRemaining = sizeof(sentence);
+
+        length = snprintf(pMarker, lengthRemaining, "$GPGGA,%02d%02d%02d," ,
+                          utcHours, utcMinutes, utcSeconds);
+
+        if (length < 0 || length >= lengthRemaining)
+        {
+            LOC_LOGE("NMEA Error in string formatting");
+            return;
+        }
+        pMarker += length;
+        lengthRemaining -= length;
+
+        if (location.gpsLocation.flags & GPS_LOCATION_HAS_LAT_LONG)
+        {
+            double latitude = location.gpsLocation.latitude;
+            double longitude = location.gpsLocation.longitude;
+            char latHemisphere;
+            char lonHemisphere;
+            double latMinutes;
+            double lonMinutes;
+
+            if (latitude > 0)
+            {
+                latHemisphere = 'N';
+            }
+            else
+            {
+                latHemisphere = 'S';
+                latitude *= -1.0;
+            }
+
+            if (longitude < 0)
+            {
+                lonHemisphere = 'W';
+                longitude *= -1.0;
+            }
+            else
+            {
+                lonHemisphere = 'E';
+            }
+
+            latMinutes = fmod(latitude * 60.0 , 60.0);
+            lonMinutes = fmod(longitude * 60.0 , 60.0);
+
+            length = snprintf(pMarker, lengthRemaining, "%02d%09.6lf,%c,%03d%09.6lf,%c,",
+                              (uint8_t)floor(latitude), latMinutes, latHemisphere,
+                              (uint8_t)floor(longitude),lonMinutes, lonHemisphere);
+        }
+        else
+        {
+            length = snprintf(pMarker, lengthRemaining,",,,,");
+        }
+
+        if (length < 0 || length >= lengthRemaining)
+        {
+            LOC_LOGE("NMEA Error in string formatting");
+            return;
+        }
+        pMarker += length;
+        lengthRemaining -= length;
+
+        char gpsQuality;
+        if (!(location.gpsLocation.flags & GPS_LOCATION_HAS_LAT_LONG))
+            gpsQuality = '0'; // 0 means no fix
+        else if (LOC_POSITION_MODE_STANDALONE == loc_eng_data_p->adapter->getPositionMode().mode)
+            gpsQuality = '1'; // 1 means GPS fix
+        else
+            gpsQuality = '2'; // 2 means DGPS fix
+
+        if (locationExtended.flags & GPS_LOCATION_EXTENDED_HAS_DOP)
+        {   // dop is in locationExtended, (QMI)
+            length = snprintf(pMarker, lengthRemaining, "%c,%02d,%.1f,",
+                              gpsQuality, svUsedCount, locationExtended.hdop);
+        }
+        else if (loc_eng_data_p->pdop > 0 && loc_eng_data_p->hdop > 0 && loc_eng_data_p->vdop > 0)
+        {   // dop was cached from sv report (RPC)
+            length = snprintf(pMarker, lengthRemaining, "%c,%02d,%.1f,",
+                              gpsQuality, svUsedCount, loc_eng_data_p->hdop);
+        }
+        else
+        {   // no hdop
+            length = snprintf(pMarker, lengthRemaining, "%c,%02d,,",
+                              gpsQuality, svUsedCount);
+        }
+
+        if (length < 0 || length >= lengthRemaining)
+        {
+            LOC_LOGE("NMEA Error in string formatting");
+            return;
+        }
+        pMarker += length;
+        lengthRemaining -= length;
+
+        if (locationExtended.flags & GPS_LOCATION_EXTENDED_HAS_ALTITUDE_MEAN_SEA_LEVEL)
+        {
+            length = snprintf(pMarker, lengthRemaining, "%.1lf,M,",
+                              locationExtended.altitudeMeanSeaLevel);
+        }
+        else
+        {
+            length = snprintf(pMarker, lengthRemaining,",,");
+        }
+
+        if (length < 0 || length >= lengthRemaining)
+        {
+            LOC_LOGE("NMEA Error in string formatting");
+            return;
+        }
+        pMarker += length;
+        lengthRemaining -= length;
+
+        if ((location.gpsLocation.flags & GPS_LOCATION_HAS_ALTITUDE) &&
+            (locationExtended.flags & GPS_LOCATION_EXTENDED_HAS_ALTITUDE_MEAN_SEA_LEVEL))
+        {
+            length = snprintf(pMarker, lengthRemaining, "%.1lf,M,,",
+                              location.gpsLocation.altitude - locationExtended.altitudeMeanSeaLevel);
+        }
+        else
+        {
+            length = snprintf(pMarker, lengthRemaining,",,,");
+        }
+
+        length = loc_eng_nmea_put_checksum(sentence, sizeof(sentence));
+        loc_eng_nmea_send(sentence, length, loc_eng_data_p);
+
+    }
+    //Send blank NMEA reports for non-final fixes
+    else {
+        strlcpy(sentence, "$GPGSA,A,1,,,,,,,,,,,,,,,", sizeof(sentence));
+        length = loc_eng_nmea_put_checksum(sentence, sizeof(sentence));
+        loc_eng_nmea_send(sentence, length, loc_eng_data_p);
+
+        strlcpy(sentence, "$GPVTG,,T,,M,,N,,K,N", sizeof(sentence));
+        length = loc_eng_nmea_put_checksum(sentence, sizeof(sentence));
+        loc_eng_nmea_send(sentence, length, loc_eng_data_p);
+
+        strlcpy(sentence, "$GPRMC,,V,,,,,,,,,,N", sizeof(sentence));
+        length = loc_eng_nmea_put_checksum(sentence, sizeof(sentence));
+        loc_eng_nmea_send(sentence, length, loc_eng_data_p);
+
+        strlcpy(sentence, "$GPGGA,,,,,,0,,,,,,,,", sizeof(sentence));
+        length = loc_eng_nmea_put_checksum(sentence, sizeof(sentence));
+        loc_eng_nmea_send(sentence, length, loc_eng_data_p);
+    }
+    // clear the dop cache so they can't be used again
+    loc_eng_data_p->pdop = 0;
+    loc_eng_data_p->hdop = 0;
+    loc_eng_data_p->vdop = 0;
+
+    EXIT_LOG(%d, 0);
+}
+
+
+
+/*===========================================================================
+FUNCTION    loc_eng_nmea_generate_sv
+
+DESCRIPTION
+   Generate NMEA sentences generated based on sv report
+
+DEPENDENCIES
+   NONE
+
+RETURN VALUE
+   0
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+void loc_eng_nmea_generate_sv(loc_eng_data_s_type *loc_eng_data_p,
+                              const GpsSvStatus &svStatus, const GpsLocationExtended &locationExtended)
+{
+    ENTRY_LOG();
+
+    char sentence[NMEA_SENTENCE_MAX_LENGTH] = {0};
+    char* pMarker = sentence;
+    int lengthRemaining = sizeof(sentence);
+    int length = 0;
+    int svCount = svStatus.num_svs;
+    int sentenceCount = 0;
+    int sentenceNumber = 1;
+    int svNumber = 1;
+    int gpsCount = 0;
+    int glnCount = 0;
+
+    //Count GPS SVs for saparating GPS from GLONASS and throw others
+
+    for(svNumber=1; svNumber <= svCount; svNumber++) {
+        if( (svStatus.sv_list[svNumber-1].prn >= GPS_PRN_START)&&
+            (svStatus.sv_list[svNumber-1].prn <= GPS_PRN_END) )
+        {
+            gpsCount++;
+        }
+        else if( (svStatus.sv_list[svNumber-1].prn >= GLONASS_PRN_START) &&
+                 (svStatus.sv_list[svNumber-1].prn <= GLONASS_PRN_END) )
+        {
+            glnCount++;
+        }
+    }
+
+    // ------------------
+    // ------$GPGSV------
+    // ------------------
+
+    if (gpsCount <= 0)
+    {
+        // no svs in view, so just send a blank $GPGSV sentence
+        strlcpy(sentence, "$GPGSV,1,1,0,", sizeof(sentence));
+        length = loc_eng_nmea_put_checksum(sentence, sizeof(sentence));
+        loc_eng_nmea_send(sentence, length, loc_eng_data_p);
+    }
+    else
+    {
+        svNumber = 1;
+        sentenceNumber = 1;
+        sentenceCount = gpsCount/4 + (gpsCount % 4 != 0);
+
+        while (sentenceNumber <= sentenceCount)
+        {
+            pMarker = sentence;
+            lengthRemaining = sizeof(sentence);
+
+            length = snprintf(pMarker, lengthRemaining, "$GPGSV,%d,%d,%02d",
+                          sentenceCount, sentenceNumber, gpsCount);
+
+            if (length < 0 || length >= lengthRemaining)
+            {
+                LOC_LOGE("NMEA Error in string formatting");
+                return;
+            }
+            pMarker += length;
+            lengthRemaining -= length;
+
+            for (int i=0; (svNumber <= svCount) && (i < 4);  svNumber++)
+            {
+                if( (svStatus.sv_list[svNumber-1].prn >= GPS_PRN_START) &&
+                    (svStatus.sv_list[svNumber-1].prn <= GPS_PRN_END) )
+                {
+                    length = snprintf(pMarker, lengthRemaining,",%02d,%02d,%03d,",
+                                  svStatus.sv_list[svNumber-1].prn,
+                                  (int)(0.5 + svStatus.sv_list[svNumber-1].elevation), //float to int
+                                  (int)(0.5 + svStatus.sv_list[svNumber-1].azimuth)); //float to int
+
+                    if (length < 0 || length >= lengthRemaining)
+                    {
+                        LOC_LOGE("NMEA Error in string formatting");
+                        return;
+                    }
+                    pMarker += length;
+                    lengthRemaining -= length;
+
+                    if (svStatus.sv_list[svNumber-1].snr > 0)
+                    {
+                        length = snprintf(pMarker, lengthRemaining,"%02d",
+                                         (int)(0.5 + svStatus.sv_list[svNumber-1].snr)); //float to int
+
+                        if (length < 0 || length >= lengthRemaining)
+                        {
+                            LOC_LOGE("NMEA Error in string formatting");
+                            return;
+                        }
+                        pMarker += length;
+                        lengthRemaining -= length;
+                    }
+
+                    i++;
+               }
+
+            }
+
+            length = loc_eng_nmea_put_checksum(sentence, sizeof(sentence));
+            loc_eng_nmea_send(sentence, length, loc_eng_data_p);
+            sentenceNumber++;
+
+        }  //while
+
+    } //if
+
+    // ------------------
+    // ------$GLGSV------
+    // ------------------
+
+    if (glnCount <= 0)
+    {
+        // no svs in view, so just send a blank $GLGSV sentence
+        strlcpy(sentence, "$GLGSV,1,1,0,", sizeof(sentence));
+        length = loc_eng_nmea_put_checksum(sentence, sizeof(sentence));
+        loc_eng_nmea_send(sentence, length, loc_eng_data_p);
+    }
+    else
+    {
+        svNumber = 1;
+        sentenceNumber = 1;
+        sentenceCount = glnCount/4 + (glnCount % 4 != 0);
+
+        while (sentenceNumber <= sentenceCount)
+        {
+            pMarker = sentence;
+            lengthRemaining = sizeof(sentence);
+
+            length = snprintf(pMarker, lengthRemaining, "$GLGSV,%d,%d,%02d",
+                          sentenceCount, sentenceNumber, glnCount);
+
+            if (length < 0 || length >= lengthRemaining)
+            {
+                LOC_LOGE("NMEA Error in string formatting");
+                return;
+            }
+            pMarker += length;
+            lengthRemaining -= length;
+
+            for (int i=0; (svNumber <= svCount) && (i < 4);  svNumber++)
+            {
+                if( (svStatus.sv_list[svNumber-1].prn >= GLONASS_PRN_START) &&
+                    (svStatus.sv_list[svNumber-1].prn <= GLONASS_PRN_END) )      {
+
+                    length = snprintf(pMarker, lengthRemaining,",%02d,%02d,%03d,",
+                                  svStatus.sv_list[svNumber-1].prn,
+                                  (int)(0.5 + svStatus.sv_list[svNumber-1].elevation), //float to int
+                                  (int)(0.5 + svStatus.sv_list[svNumber-1].azimuth)); //float to int
+
+                    if (length < 0 || length >= lengthRemaining)
+                    {
+                        LOC_LOGE("NMEA Error in string formatting");
+                        return;
+                    }
+                    pMarker += length;
+                    lengthRemaining -= length;
+
+                    if (svStatus.sv_list[svNumber-1].snr > 0)
+                    {
+                        length = snprintf(pMarker, lengthRemaining,"%02d",
+                                         (int)(0.5 + svStatus.sv_list[svNumber-1].snr)); //float to int
+
+                        if (length < 0 || length >= lengthRemaining)
+                        {
+                            LOC_LOGE("NMEA Error in string formatting");
+                            return;
+                        }
+                        pMarker += length;
+                        lengthRemaining -= length;
+                    }
+
+                    i++;
+               }
+
+            }
+
+            length = loc_eng_nmea_put_checksum(sentence, sizeof(sentence));
+            loc_eng_nmea_send(sentence, length, loc_eng_data_p);
+            sentenceNumber++;
+
+        }  //while
+
+    }//if
+
+    if (svStatus.used_in_fix_mask == 0)
+    {   // No sv used, so there will be no position report, so send
+        // blank NMEA sentences
+        strlcpy(sentence, "$GPGSA,A,1,,,,,,,,,,,,,,,", sizeof(sentence));
+        length = loc_eng_nmea_put_checksum(sentence, sizeof(sentence));
+        loc_eng_nmea_send(sentence, length, loc_eng_data_p);
+
+        strlcpy(sentence, "$GPVTG,,T,,M,,N,,K,N", sizeof(sentence));
+        length = loc_eng_nmea_put_checksum(sentence, sizeof(sentence));
+        loc_eng_nmea_send(sentence, length, loc_eng_data_p);
+
+        strlcpy(sentence, "$GPRMC,,V,,,,,,,,,,N", sizeof(sentence));
+        length = loc_eng_nmea_put_checksum(sentence, sizeof(sentence));
+        loc_eng_nmea_send(sentence, length, loc_eng_data_p);
+
+        strlcpy(sentence, "$GPGGA,,,,,,0,,,,,,,,", sizeof(sentence));
+        length = loc_eng_nmea_put_checksum(sentence, sizeof(sentence));
+        loc_eng_nmea_send(sentence, length, loc_eng_data_p);
+    }
+    else
+    {   // cache the used in fix mask, as it will be needed to send $GPGSA
+        // during the position report
+        loc_eng_data_p->sv_used_mask = svStatus.used_in_fix_mask;
+
+        // For RPC, the DOP are sent during sv report, so cache them
+        // now to be sent during position report.
+        // For QMI, the DOP will be in position report.
+        if (locationExtended.flags & GPS_LOCATION_EXTENDED_HAS_DOP)
+        {
+            loc_eng_data_p->pdop = locationExtended.pdop;
+            loc_eng_data_p->hdop = locationExtended.hdop;
+            loc_eng_data_p->vdop = locationExtended.vdop;
+        }
+        else
+        {
+            loc_eng_data_p->pdop = 0;
+            loc_eng_data_p->hdop = 0;
+            loc_eng_data_p->vdop = 0;
+        }
+
+    }
+
+    EXIT_LOG(%d, 0);
+}
diff --git a/msm8974/loc_api/libloc_api_50001/loc_eng_nmea.h b/msm8974/loc_api/libloc_api_50001/loc_eng_nmea.h
new file mode 100644
index 0000000..40c6dbb
--- /dev/null
+++ b/msm8974/loc_api/libloc_api_50001/loc_eng_nmea.h
@@ -0,0 +1,42 @@
+/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef LOC_ENG_NMEA_H
+#define LOC_ENG_NMEA_H
+
+#include <hardware/gps.h>
+
+#define NMEA_SENTENCE_MAX_LENGTH 200
+
+void loc_eng_nmea_send(char *pNmea, int length, loc_eng_data_s_type *loc_eng_data_p);
+int loc_eng_nmea_put_checksum(char *pNmea, int maxSize);
+void loc_eng_nmea_generate_sv(loc_eng_data_s_type *loc_eng_data_p, const GpsSvStatus &svStatus, const GpsLocationExtended &locationExtended);
+void loc_eng_nmea_generate_pos(loc_eng_data_s_type *loc_eng_data_p, const UlpLocation &location, const GpsLocationExtended &locationExtended, unsigned char generate_nmea);
+
+#endif // LOC_ENG_NMEA_H
diff --git a/msm8974/loc_api/libloc_api_50001/loc_eng_xtra.cpp b/msm8974/loc_api/libloc_api_50001/loc_eng_xtra.cpp
new file mode 100644
index 0000000..4582286
--- /dev/null
+++ b/msm8974/loc_api/libloc_api_50001/loc_eng_xtra.cpp
@@ -0,0 +1,167 @@
+/* Copyright (c) 2009-2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#define LOG_NDDEBUG 0
+#define LOG_TAG "LocSvc_eng"
+
+#include <loc_eng.h>
+#include <MsgTask.h>
+#include "log_util.h"
+#include "platform_lib_includes.h"
+
+using namespace loc_core;
+
+struct LocEngRequestXtraServer : public LocMsg {
+    LocEngAdapter* mAdapter;
+    inline LocEngRequestXtraServer(LocEngAdapter* adapter) :
+        LocMsg(), mAdapter(adapter)
+    {
+        locallog();
+    }
+    inline virtual void proc() const {
+        mAdapter->requestXtraServer();
+    }
+    inline void locallog() const {
+        LOC_LOGV("LocEngRequestXtraServer");
+    }
+    inline virtual void log() const {
+        locallog();
+    }
+};
+
+struct LocEngInjectXtraData : public LocMsg {
+    LocEngAdapter* mAdapter;
+    char* mData;
+    const int mLen;
+    inline LocEngInjectXtraData(LocEngAdapter* adapter,
+                                char* data, int len):
+        LocMsg(), mAdapter(adapter),
+        mData(new char[len]), mLen(len)
+    {
+        memcpy((void*)mData, (void*)data, len);
+        locallog();
+    }
+    inline ~LocEngInjectXtraData()
+    {
+        delete[] mData;
+    }
+    inline virtual void proc() const {
+        mAdapter->setXtraData(mData, mLen);
+    }
+    inline  void locallog() const {
+        LOC_LOGV("length: %d\n  data: %p", mLen, mData);
+    }
+    inline virtual void log() const {
+        locallog();
+    }
+};
+
+/*===========================================================================
+FUNCTION    loc_eng_xtra_init
+
+DESCRIPTION
+   Initialize XTRA module.
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   0: success
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_eng_xtra_init (loc_eng_data_s_type &loc_eng_data,
+                       GpsXtraExtCallbacks* callbacks)
+{
+    int ret_val = -1;
+    loc_eng_xtra_data_s_type *xtra_module_data_ptr;
+
+    if(callbacks == NULL) {
+        LOC_LOGE("loc_eng_xtra_init: failed, cb is NULL");
+    } else {
+        xtra_module_data_ptr = &loc_eng_data.xtra_module_data;
+        xtra_module_data_ptr->download_request_cb = callbacks->download_request_cb;
+        xtra_module_data_ptr->report_xtra_server_cb = callbacks->report_xtra_server_cb;
+
+        ret_val = 0;
+    }
+    return ret_val;
+}
+
+/*===========================================================================
+FUNCTION    loc_eng_xtra_inject_data
+
+DESCRIPTION
+   Injects XTRA file into the engine but buffers the data if engine is busy.
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   0: success
+   >0: failure
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_eng_xtra_inject_data(loc_eng_data_s_type &loc_eng_data,
+                             char* data, int length)
+{
+    LocEngAdapter* adapter = loc_eng_data.adapter;
+    adapter->sendMsg(new LocEngInjectXtraData(adapter, data, length));
+
+    return 0;
+}
+/*===========================================================================
+FUNCTION    loc_eng_xtra_request_server
+
+DESCRIPTION
+   Request the Xtra server url from the modem
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   length of server string
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int loc_eng_xtra_request_server(loc_eng_data_s_type &loc_eng_data)
+{
+    LocEngAdapter* adapter = loc_eng_data.adapter;
+    adapter->sendMsg(new LocEngRequestXtraServer(adapter));
+
+    return 0;
+
+}
diff --git a/msm8974/loc_api/libloc_api_50001/loc_eng_xtra.h b/msm8974/loc_api/libloc_api_50001/loc_eng_xtra.h
new file mode 100644
index 0000000..175f497
--- /dev/null
+++ b/msm8974/loc_api/libloc_api_50001/loc_eng_xtra.h
@@ -0,0 +1,47 @@
+/* Copyright (c) 2009,2011 The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef LOC_ENG_XTRA_H
+#define LOC_ENG_XTRA_H
+
+#include <hardware/gps.h>
+
+// Module data
+typedef struct
+{
+   // loc_eng_ioctl_cb_data_s_type   ioctl_cb_data;
+   gps_xtra_download_request      download_request_cb;
+   report_xtra_server             report_xtra_server_cb;
+
+   // XTRA data buffer
+   char                          *xtra_data_for_injection;  // NULL if no pending data
+   int                            xtra_data_len;
+} loc_eng_xtra_data_s_type;
+
+#endif // LOC_ENG_XTRA_H
diff --git a/msm8974/platform_lib_abstractions/elapsed_millis_since_boot.cpp b/msm8974/platform_lib_abstractions/elapsed_millis_since_boot.cpp
new file mode 100644
index 0000000..e8cb93a
--- /dev/null
+++ b/msm8974/platform_lib_abstractions/elapsed_millis_since_boot.cpp
@@ -0,0 +1,46 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdlib.h>
+#include <sys/time.h>
+#include "platform_lib_time.h"
+
+int64_t systemTime(int clock)
+{
+    struct timeval t;
+    t.tv_sec = t.tv_usec = 0;
+    gettimeofday(&t, NULL);
+    return t.tv_sec*1000000LL + t.tv_usec;
+}
+
+
+int64_t elapsedMillisSinceBoot()
+{
+    int64_t t_us = systemTime(0);
+    return (int64_t) t_us / 1000LL;
+}
diff --git a/msm8974/platform_lib_abstractions/platform_lib_includes.h b/msm8974/platform_lib_abstractions/platform_lib_includes.h
new file mode 100644
index 0000000..5858674
--- /dev/null
+++ b/msm8974/platform_lib_abstractions/platform_lib_includes.h
@@ -0,0 +1,35 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _PLATFORM_LIB_INCLUDES_H_
+#define _PLATFORM_LIB_INCLUDES_H_
+
+#include "platform_lib_time.h"
+#include "platform_lib_macros.h"
+
+#endif
diff --git a/msm8974/platform_lib_abstractions/platform_lib_macros.h b/msm8974/platform_lib_abstractions/platform_lib_macros.h
new file mode 100644
index 0000000..bc48dd9
--- /dev/null
+++ b/msm8974/platform_lib_abstractions/platform_lib_macros.h
@@ -0,0 +1,81 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __PLATFORM_LIB_MACROS_H__
+#define __PLATFORM_LIB_MACROS_H__
+
+#include <sys/time.h>
+
+#define TS_PRINTF(format, x...)                                \
+{                                                              \
+  struct timeval tv;                                           \
+  struct timezone tz;                                          \
+  int hh, mm, ss;                                              \
+  gettimeofday(&tv, &tz);                                      \
+  hh = tv.tv_sec/3600%24;                                      \
+  mm = (tv.tv_sec%3600)/60;                                    \
+  ss = tv.tv_sec%60;                                           \
+  fprintf(stdout,"%02d:%02d:%02d.%06ld]" format "\n", hh, mm, ss, tv.tv_usec,##x);    \
+}
+
+
+#ifdef USE_GLIB
+
+#define strlcat g_strlcat
+#define strlcpy g_strlcpy
+
+#define ALOGE(format, x...) TS_PRINTF("E/%s (%d): " format , LOG_TAG, getpid(), ##x)
+#define ALOGW(format, x...) TS_PRINTF("W/%s (%d): " format , LOG_TAG, getpid(), ##x)
+#define ALOGI(format, x...) TS_PRINTF("I/%s (%d): " format , LOG_TAG, getpid(), ##x)
+#define ALOGD(format, x...) TS_PRINTF("D/%s (%d): " format , LOG_TAG, getpid(), ##x)
+#define ALOGV(format, x...) TS_PRINTF("V/%s (%d): " format , LOG_TAG, getpid(), ##x)
+
+#define GETTID_PLATFORM_LIB_ABSTRACTION (syscall(SYS_gettid))
+
+#define LOC_EXT_CREATE_THREAD_CB_PLATFORM_LIB_ABSTRACTION createPthread
+#define ELAPSED_MILLIS_SINCE_BOOT_PLATFORM_LIB_ABSTRACTION (elapsedMillisSinceBoot())
+
+
+#else
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+pid_t gettid(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#define GETTID_PLATFORM_LIB_ABSTRACTION (gettid())
+#define LOC_EXT_CREATE_THREAD_CB_PLATFORM_LIB_ABSTRACTION android::AndroidRuntime::createJavaThread
+#define ELAPSED_MILLIS_SINCE_BOOT_PLATFORM_LIB_ABSTRACTION  (android::elapsedRealtime())
+
+#endif
+
+#endif
diff --git a/msm8974/platform_lib_abstractions/platform_lib_time.h b/msm8974/platform_lib_abstractions/platform_lib_time.h
new file mode 100644
index 0000000..ce013af
--- /dev/null
+++ b/msm8974/platform_lib_abstractions/platform_lib_time.h
@@ -0,0 +1,35 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _PLATFORM_LIB_TIME_H_
+#define _PLATFORM_LIB_TIME_H_
+
+int64_t systemTime(int clock);
+int64_t elapsedMillisSinceBoot();
+
+#endif
diff --git a/msm8974/utils/Android.mk b/msm8974/utils/Android.mk
new file mode 100644
index 0000000..f34e101
--- /dev/null
+++ b/msm8974/utils/Android.mk
@@ -0,0 +1,61 @@
+ifneq ($(BOARD_VENDOR_QCOM_GPS_LOC_API_HARDWARE),)
+ifneq ($(BUILD_TINY_ANDROID),true)
+#Compile this library only for builds with the latest modem image
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+## Libs
+LOCAL_SHARED_LIBRARIES := \
+    libutils \
+    libcutils \
+    liblog
+
+LOCAL_SRC_FILES += \
+    loc_log.cpp \
+    loc_cfg.cpp \
+    msg_q.c \
+    linked_list.c \
+    loc_target.cpp \
+    loc_timer.c \
+    ../platform_lib_abstractions/elapsed_millis_since_boot.cpp \
+    loc_misc_utils.cpp
+
+LOCAL_CFLAGS += \
+     -fno-short-enums \
+     -D_ANDROID_
+
+ifeq ($(TARGET_BUILD_VARIANT),user)
+   LOCAL_CFLAGS += -DTARGET_BUILD_VARIANT_USER
+endif
+
+LOCAL_LDFLAGS += -Wl,--export-dynamic
+
+## Includes
+LOCAL_C_INCLUDES:= \
+    $(LOCAL_PATH)/../platform_lib_abstractions
+
+LOCAL_COPY_HEADERS_TO:= gps.utils/
+LOCAL_COPY_HEADERS:= \
+   loc_log.h \
+   loc_cfg.h \
+   log_util.h \
+   linked_list.h \
+   msg_q.h \
+   loc_target.h \
+   loc_timer.h \
+   ../platform_lib_abstractions/platform_lib_includes.h \
+   ../platform_lib_abstractions/platform_lib_time.h \
+   ../platform_lib_abstractions/platform_lib_macros.h \
+   loc_misc_utils.h
+
+LOCAL_MODULE := libgps.utils
+
+LOCAL_MODULE_TAGS := optional
+
+LOCAL_PRELINK_MODULE := false
+
+include $(BUILD_SHARED_LIBRARY)
+endif # not BUILD_TINY_ANDROID
+endif # BOARD_VENDOR_QCOM_GPS_LOC_API_HARDWARE
diff --git a/msm8974/utils/Makefile.am b/msm8974/utils/Makefile.am
new file mode 100644
index 0000000..e5935f0
--- /dev/null
+++ b/msm8974/utils/Makefile.am
@@ -0,0 +1,44 @@
+AM_CFLAGS = -Wundef \
+         -MD \
+         -Wno-trigraphs \
+         -g -O0 \
+         -fno-inline \
+         -fno-short-enums \
+         -fpic \
+         -I../platform_lib_abstractions
+
+libgps_utils_so_la_h_sources = log_util.h \
+            msg_q.h \
+            linked_list.h \
+            loc_cfg.h \
+            loc_log.h \
+            ../platform_lib_abstractions/platform_lib_includes.h \
+            ../platform_lib_abstractions/platform_lib_time.h \
+            ../platform_lib_abstractions/platform_lib_macros.h
+
+libgps_utils_so_la_c_sources = linked_list.c \
+            msg_q.c \
+            loc_cfg.cpp \
+            loc_log.cpp \
+            ../platform_lib_abstractions/elapsed_millis_since_boot.cpp
+
+library_includedir = $(pkgincludedir)/utils
+
+library_include_HEADERS = $(libgps_utils_so_la_h_sources)
+
+libgps_utils_so_la_SOURCES = $(libgps_utils_so_la_c_sources)
+
+if USE_GLIB
+libgps_utils_so_la_CFLAGS = -DUSE_GLIB $(AM_CFLAGS) @GLIB_CFLAGS@
+libgps_utils_so_la_LDFLAGS = -lstdc++ -lpthread @GLIB_LIBS@ -shared -version-info 1:0:0
+libgps_utils_so_la_CPPFLAGS = -DUSE_GLIB $(AM_CFLAGS) $(AM_CPPFLAGS) @GLIB_CFLAGS@
+else
+libgps_utils_so_la_CFLAGS = $(AM_CFLAGS)
+libgps_utils_so_la_LDFLAGS = -lpthread -shared -version-info 1:0:0
+libgps_utils_so_la_CPPFLAGS = $(AM_CFLAGS) $(AM_CPPFLAGS)
+endif
+
+libgps_utils_so_la_LIBADD = -lstdc++ -lcutils
+
+#Create and Install libraries
+lib_LTLIBRARIES = libgps_utils_so.la
diff --git a/msm8974/utils/linked_list.c b/msm8974/utils/linked_list.c
new file mode 100644
index 0000000..2ef8cbc
--- /dev/null
+++ b/msm8974/utils/linked_list.c
@@ -0,0 +1,328 @@
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "linked_list.h"
+#include <stdio.h>
+#include <string.h>
+
+#define LOG_TAG "LocSvc_utils_ll"
+#include "log_util.h"
+#include "platform_lib_includes.h"
+#include <stdlib.h>
+#include <stdint.h>
+
+typedef struct list_element {
+   struct list_element* next;
+   struct list_element* prev;
+   void* data_ptr;
+   void (*dealloc_func)(void*);
+}list_element;
+
+typedef struct list_state {
+   list_element* p_head;
+   list_element* p_tail;
+} list_state;
+
+/* ----------------------- END INTERNAL FUNCTIONS ---------------------------------------- */
+
+/*===========================================================================
+
+  FUNCTION:   linked_list_init
+
+  ===========================================================================*/
+linked_list_err_type linked_list_init(void** list_data)
+{
+   if( list_data == NULL )
+   {
+      LOC_LOGE("%s: Invalid list parameter!\n", __FUNCTION__);
+      return eLINKED_LIST_INVALID_PARAMETER;
+   }
+
+   list_state* tmp_list;
+   tmp_list = (list_state*)calloc(1, sizeof(list_state));
+   if( tmp_list == NULL )
+   {
+      LOC_LOGE("%s: Unable to allocate space for list!\n", __FUNCTION__);
+      return eLINKED_LIST_FAILURE_GENERAL;
+   }
+
+   tmp_list->p_head = NULL;
+   tmp_list->p_tail = NULL;
+
+   *list_data = tmp_list;
+
+   return eLINKED_LIST_SUCCESS;
+}
+
+/*===========================================================================
+
+  FUNCTION:   linked_list_destroy
+
+  ===========================================================================*/
+linked_list_err_type linked_list_destroy(void** list_data)
+{
+   if( list_data == NULL )
+   {
+      LOC_LOGE("%s: Invalid list parameter!\n", __FUNCTION__);
+      return eLINKED_LIST_INVALID_HANDLE;
+   }
+
+   list_state* p_list = (list_state*)*list_data;
+
+   linked_list_flush(p_list);
+
+   free(*list_data);
+   *list_data = NULL;
+
+   return eLINKED_LIST_SUCCESS;
+}
+
+/*===========================================================================
+
+  FUNCTION:   linked_list_add
+
+  ===========================================================================*/
+linked_list_err_type linked_list_add(void* list_data, void *data_obj, void (*dealloc)(void*))
+{
+   LOC_LOGD("%s: Adding to list data_obj = 0x%p\n", __FUNCTION__, data_obj);
+   if( list_data == NULL )
+   {
+      LOC_LOGE("%s: Invalid list parameter!\n", __FUNCTION__);
+      return eLINKED_LIST_INVALID_HANDLE;
+   }
+
+   if( data_obj == NULL )
+   {
+      LOC_LOGE("%s: Invalid input parameter!\n", __FUNCTION__);
+      return eLINKED_LIST_INVALID_PARAMETER;
+   }
+
+   list_state* p_list = (list_state*)list_data;
+   list_element* elem = (list_element*)malloc(sizeof(list_element));
+   if( elem == NULL )
+   {
+      LOC_LOGE("%s: Memory allocation failed\n", __FUNCTION__);
+      return eLINKED_LIST_FAILURE_GENERAL;
+   }
+
+   /* Copy data to newly created element */
+   elem->data_ptr = data_obj;
+   elem->next = NULL;
+   elem->prev = NULL;
+   elem->dealloc_func = dealloc;
+
+   /* Replace head element */
+   list_element* tmp = p_list->p_head;
+   p_list->p_head = elem;
+   /* Point next to the previous head element */
+   p_list->p_head->next = tmp;
+
+   if( tmp != NULL )
+   {
+      tmp->prev = p_list->p_head;
+   }
+   else
+   {
+      p_list->p_tail = p_list->p_head;
+   }
+
+   return eLINKED_LIST_SUCCESS;
+}
+
+/*===========================================================================
+
+  FUNCTION:   linked_list_remove
+
+  ===========================================================================*/
+linked_list_err_type linked_list_remove(void* list_data, void **data_obj)
+{
+   LOC_LOGD("%s: Removing from list\n", __FUNCTION__);
+   if( list_data == NULL )
+   {
+      LOC_LOGE("%s: Invalid list parameter!\n", __FUNCTION__);
+      return eLINKED_LIST_INVALID_HANDLE;
+   }
+
+   if( data_obj == NULL )
+   {
+      LOC_LOGE("%s: Invalid input parameter!\n", __FUNCTION__);
+      return eLINKED_LIST_INVALID_PARAMETER;
+   }
+
+   list_state* p_list = (list_state*)list_data;
+   if( p_list->p_tail == NULL )
+   {
+      return eLINKED_LIST_UNAVAILABLE_RESOURCE;
+   }
+
+   list_element* tmp = p_list->p_tail;
+
+   /* Replace tail element */
+   p_list->p_tail = tmp->prev;
+
+   if( p_list->p_tail != NULL )
+   {
+      p_list->p_tail->next = NULL;
+   }
+   else
+   {
+      p_list->p_head = p_list->p_tail;
+   }
+
+   /* Copy data to output param */
+   *data_obj = tmp->data_ptr;
+
+   /* Free allocated list element */
+   free(tmp);
+
+   return eLINKED_LIST_SUCCESS;
+}
+
+/*===========================================================================
+
+  FUNCTION:   linked_list_empty
+
+  ===========================================================================*/
+int linked_list_empty(void* list_data)
+{
+   if( list_data == NULL )
+   {
+      LOC_LOGE("%s: Invalid list parameter!\n", __FUNCTION__);
+      return (int)eLINKED_LIST_INVALID_HANDLE;
+   }
+   else
+   {
+      list_state* p_list = (list_state*)list_data;
+      return p_list->p_head == NULL ? 1 : 0;
+   }
+}
+
+/*===========================================================================
+
+  FUNCTION:   linked_list_flush
+
+  ===========================================================================*/
+linked_list_err_type linked_list_flush(void* list_data)
+{
+   if( list_data == NULL )
+   {
+      LOC_LOGE("%s: Invalid list parameter!\n", __FUNCTION__);
+      return eLINKED_LIST_INVALID_HANDLE;
+   }
+
+   list_state* p_list = (list_state*)list_data;
+
+   /* Remove all dynamically allocated elements */
+   while( p_list->p_head != NULL )
+   {
+      list_element* tmp = p_list->p_head->next;
+
+      /* Free data pointer if told to do so. */
+      if( p_list->p_head->dealloc_func != NULL )
+      {
+         p_list->p_head->dealloc_func(p_list->p_head->data_ptr);
+      }
+
+      /* Free list element */
+      free(p_list->p_head);
+
+      p_list->p_head = tmp;
+   }
+
+   p_list->p_tail = NULL;
+
+   return eLINKED_LIST_SUCCESS;
+}
+
+/*===========================================================================
+
+  FUNCTION:   linked_list_search
+
+  ===========================================================================*/
+linked_list_err_type linked_list_search(void* list_data, void **data_p,
+                                        bool (*equal)(void* data_0, void* data),
+                                        void* data_0, bool rm_if_found)
+{
+   LOC_LOGD("%s: Search the list\n", __FUNCTION__);
+   if( list_data == NULL || NULL == equal )
+   {
+      LOC_LOGE("%s: Invalid list parameter! list_data %p equal %p\n",
+               __FUNCTION__, list_data, equal);
+      return eLINKED_LIST_INVALID_HANDLE;
+   }
+
+   list_state* p_list = (list_state*)list_data;
+   if( p_list->p_tail == NULL )
+   {
+      return eLINKED_LIST_UNAVAILABLE_RESOURCE;
+   }
+
+   list_element* tmp = p_list->p_head;
+
+   if (NULL != data_p) {
+     *data_p = NULL;
+   }
+
+   while (NULL != tmp) {
+     if ((*equal)(data_0, tmp->data_ptr)) {
+       if (NULL != data_p) {
+         *data_p = tmp->data_ptr;
+       }
+
+       if (rm_if_found) {
+         if (NULL == tmp->prev) {
+           p_list->p_head = tmp->next;
+         } else {
+           tmp->prev->next = tmp->next;
+         }
+
+         if (NULL == tmp->next) {
+           p_list->p_tail = tmp->prev;
+         } else {
+           tmp->next->prev = tmp->prev;
+         }
+
+         tmp->prev = tmp->next = NULL;
+
+         // dealloc data if it is not copied out && caller
+         // has given us a dealloc function pointer.
+         if (NULL == data_p && NULL != tmp->dealloc_func) {
+             tmp->dealloc_func(tmp->data_ptr);
+         }
+         free(tmp);
+       }
+
+       tmp = NULL;
+     } else {
+       tmp = tmp->next;
+     }
+   }
+
+   return eLINKED_LIST_SUCCESS;
+}
+
diff --git a/msm8974/utils/linked_list.h b/msm8974/utils/linked_list.h
new file mode 100644
index 0000000..a85f09a
--- /dev/null
+++ b/msm8974/utils/linked_list.h
@@ -0,0 +1,217 @@
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __LINKED_LIST_H__
+#define __LINKED_LIST_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#include <stdbool.h>
+#include <stdlib.h>
+
+/** Linked List Return Codes */
+typedef enum
+{
+  eLINKED_LIST_SUCCESS                             = 0,
+     /**< Request was successful. */
+  eLINKED_LIST_FAILURE_GENERAL                     = -1,
+     /**< Failed because of a general failure. */
+  eLINKED_LIST_INVALID_PARAMETER                   = -2,
+     /**< Failed because the request contained invalid parameters. */
+  eLINKED_LIST_INVALID_HANDLE                      = -3,
+     /**< Failed because an invalid handle was specified. */
+  eLINKED_LIST_UNAVAILABLE_RESOURCE                = -4,
+     /**< Failed because an there were not enough resources. */
+  eLINKED_LIST_INSUFFICIENT_BUFFER                 = -5,
+     /**< Failed because an the supplied buffer was too small. */
+}linked_list_err_type;
+
+/*===========================================================================
+FUNCTION    linked_list_init
+
+DESCRIPTION
+   Initializes internal structures for linked list.
+
+   list_data: State of list to be initialized.
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   Look at error codes above.
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+linked_list_err_type linked_list_init(void** list_data);
+
+/*===========================================================================
+FUNCTION    linked_list_destroy
+
+DESCRIPTION
+   Destroys internal structures for linked list.
+
+   p_list_data: State of list to be destroyed.
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   Look at error codes above.
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+linked_list_err_type linked_list_destroy(void** list_data);
+
+/*===========================================================================
+FUNCTION    linked_list_add
+
+DESCRIPTION
+   Adds an element to the head of the linked list. The passed in data pointer
+   is not modified or freed. Passed in data_obj is expected to live throughout
+   the use of the linked_list (i.e. data is not allocated internally)
+
+   p_list_data:  List to add data to the head of.
+   data_obj:     Pointer to data to add into list
+   dealloc:      Function used to deallocate memory for this element. Pass NULL
+                 if you do not want data deallocated during a flush operation
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   Look at error codes above.
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+linked_list_err_type linked_list_add(void* list_data, void *data_obj, void (*dealloc)(void*));
+
+/*===========================================================================
+FUNCTION    linked_list_remove
+
+DESCRIPTION
+   Retrieves data from the list tail. data_obj is the tail element from the list
+   passed in by linked_list_add.
+
+   p_list_data:  List to remove the tail from.
+   data_obj:     Pointer to data removed from list
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   Look at error codes above.
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+linked_list_err_type linked_list_remove(void* list_data, void **data_obj);
+
+/*===========================================================================
+FUNCTION    linked_list_empty
+
+DESCRIPTION
+   Tells whether the list currently contains any elements
+
+   p_list_data:  List to check if empty.
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   0/FALSE : List contains elements
+   1/TRUE  : List is Empty
+   Otherwise look at error codes above.
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+int linked_list_empty(void* list_data);
+
+/*===========================================================================
+FUNCTION    linked_list_flush
+
+DESCRIPTION
+   Removes all elements from the list and deallocates them using the provided
+   dealloc function while adding elements.
+
+   p_list_data:  List to remove all elements from.
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   Look at error codes above.
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+linked_list_err_type linked_list_flush(void* list_data);
+
+/*===========================================================================
+FUNCTION    linked_list_search
+
+DESCRIPTION
+   Searches for an element in the linked list.
+
+   p_list_data:  List handle.
+   data_p:       to be stored with the data found; NUll if no match.
+                 if data_p passed in as NULL, then no write to it.
+   equal:        Function ptr takes in a list element, and returns
+                 indication if this the one looking for.
+   data_0:       The data being compared against.
+   rm_if_found:  Should data be removed if found?
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   Look at error codes above.
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+linked_list_err_type linked_list_search(void* list_data, void **data_p,
+                                        bool (*equal)(void* data_0, void* data),
+                                        void* data_0, bool rm_if_found);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __LINKED_LIST_H__ */
diff --git a/msm8974/utils/loc_cfg.cpp b/msm8974/utils/loc_cfg.cpp
new file mode 100644
index 0000000..84782dc
--- /dev/null
+++ b/msm8974/utils/loc_cfg.cpp
@@ -0,0 +1,401 @@
+/* Copyright (c) 2011-2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#define LOG_NDDEBUG 0
+#define LOG_TAG "LocSvc_utils_cfg"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <pthread.h>
+#include <string.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <time.h>
+#include <loc_cfg.h>
+#include <log_util.h>
+#include <loc_misc_utils.h>
+#ifdef USE_GLIB
+#include <glib.h>
+#endif
+#include "platform_lib_includes.h"
+
+/*=============================================================================
+ *
+ *                          GLOBAL DATA DECLARATION
+ *
+ *============================================================================*/
+
+/* Parameter data */
+static int DEBUG_LEVEL = 0xff;
+static int TIMESTAMP = 0;
+
+/* Parameter spec table */
+static loc_param_s_type loc_param_table[] =
+{
+    {"DEBUG_LEVEL",    &DEBUG_LEVEL, NULL,    'n'},
+    {"TIMESTAMP",      &TIMESTAMP,   NULL,    'n'},
+};
+int loc_param_num = sizeof(loc_param_table) / sizeof(loc_param_s_type);
+
+typedef struct loc_param_v_type
+{
+    char* param_name;
+    char* param_str_value;
+    int param_int_value;
+    double param_double_value;
+}loc_param_v_type;
+
+/*===========================================================================
+FUNCTION loc_set_config_entry
+
+DESCRIPTION
+   Potentially sets a given configuration table entry based on the passed in
+   configuration value. This is done by using a string comparison of the
+   parameter names and those found in the configuration file.
+
+PARAMETERS:
+   config_entry: configuration entry in the table to possibly set
+   config_value: value to store in the entry if the parameter names match
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   None
+
+SIDE EFFECTS
+   N/A
+===========================================================================*/
+int loc_set_config_entry(loc_param_s_type* config_entry, loc_param_v_type* config_value)
+{
+    int ret=-1;
+    if(NULL == config_entry || NULL == config_value)
+    {
+        LOC_LOGE("%s: INVALID config entry or parameter", __FUNCTION__);
+        return ret;
+    }
+
+    if (strcmp(config_entry->param_name, config_value->param_name) == 0 &&
+        config_entry->param_ptr)
+    {
+        switch (config_entry->param_type)
+        {
+        case 's':
+            if (strcmp(config_value->param_str_value, "NULL") == 0)
+            {
+                *((char*)config_entry->param_ptr) = '\0';
+            }
+            else {
+                strlcpy((char*) config_entry->param_ptr,
+                        config_value->param_str_value,
+                        LOC_MAX_PARAM_STRING + 1);
+            }
+            /* Log INI values */
+            LOC_LOGD("%s: PARAM %s = %s", __FUNCTION__,
+                     config_entry->param_name, (char*)config_entry->param_ptr);
+
+            if(NULL != config_entry->param_set)
+            {
+                *(config_entry->param_set) = 1;
+            }
+            ret = 0;
+            break;
+        case 'n':
+            *((int *)config_entry->param_ptr) = config_value->param_int_value;
+            /* Log INI values */
+            LOC_LOGD("%s: PARAM %s = %d", __FUNCTION__,
+                     config_entry->param_name, config_value->param_int_value);
+
+            if(NULL != config_entry->param_set)
+            {
+                *(config_entry->param_set) = 1;
+            }
+            ret = 0;
+            break;
+        case 'f':
+            *((double *)config_entry->param_ptr) = config_value->param_double_value;
+            /* Log INI values */
+            LOC_LOGD("%s: PARAM %s = %f", __FUNCTION__,
+                     config_entry->param_name, config_value->param_double_value);
+
+            if(NULL != config_entry->param_set)
+            {
+                *(config_entry->param_set) = 1;
+            }
+            ret = 0;
+            break;
+        default:
+            LOC_LOGE("%s: PARAM %s parameter type must be n, f, or s",
+                     __FUNCTION__, config_entry->param_name);
+        }
+    }
+    return ret;
+}
+
+/*===========================================================================
+FUNCTION loc_fill_conf_item
+
+DESCRIPTION
+   Takes a line of configuration item and sets defined values based on
+   the passed in configuration table. This table maps strings to values to
+   set along with the type of each of these values.
+
+PARAMETERS:
+   input_buf : buffer contanis config item
+   config_table: table definition of strings to places to store information
+   table_length: length of the configuration table
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   0: Number of records in the config_table filled with input_buf
+
+SIDE EFFECTS
+   N/A
+===========================================================================*/
+int loc_fill_conf_item(char* input_buf,
+                       loc_param_s_type* config_table, uint32_t table_length)
+{
+    int ret = 0;
+
+    if (input_buf && config_table) {
+        char *lasts;
+        loc_param_v_type config_value;
+        memset(&config_value, 0, sizeof(config_value));
+
+        /* Separate variable and value */
+        config_value.param_name = strtok_r(input_buf, "=", &lasts);
+        /* skip lines that do not contain "=" */
+        if (config_value.param_name) {
+            config_value.param_str_value = strtok_r(NULL, "=", &lasts);
+
+            /* skip lines that do not contain two operands */
+            if (config_value.param_str_value) {
+                /* Trim leading and trailing spaces */
+                loc_util_trim_space(config_value.param_name);
+                loc_util_trim_space(config_value.param_str_value);
+
+                /* Parse numerical value */
+                if ((strlen(config_value.param_str_value) >=3) &&
+                    (config_value.param_str_value[0] == '0') &&
+                    (tolower(config_value.param_str_value[1]) == 'x'))
+                {
+                    /* hex */
+                    config_value.param_int_value = (int) strtol(&config_value.param_str_value[2],
+                                                                (char**) NULL, 16);
+                }
+                else {
+                    config_value.param_double_value = (double) atof(config_value.param_str_value); /* float */
+                    config_value.param_int_value = atoi(config_value.param_str_value); /* dec */
+                }
+
+                for(uint32_t i = 0; NULL != config_table && i < table_length; i++)
+                {
+                    if(!loc_set_config_entry(&config_table[i], &config_value)) {
+                        ret += 1;
+                    }
+                }
+            }
+        }
+    }
+
+    return ret;
+}
+
+/*===========================================================================
+FUNCTION loc_read_conf_r (repetitive)
+
+DESCRIPTION
+   Reads the specified configuration file and sets defined values based on
+   the passed in configuration table. This table maps strings to values to
+   set along with the type of each of these values.
+   The difference between this and loc_read_conf is that this function returns
+   the file pointer position at the end of filling a config table. Also, it
+   reads a fixed number of parameters at a time which is equal to the length
+   of the configuration table. This functionality enables the caller to
+   repeatedly call the function to read data from the same file.
+
+PARAMETERS:
+   conf_fp : file pointer
+   config_table: table definition of strings to places to store information
+   table_length: length of the configuration table
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   0: Table filled successfully
+   1: No more parameters to read
+  -1: Error filling table
+
+SIDE EFFECTS
+   N/A
+===========================================================================*/
+int loc_read_conf_r(FILE *conf_fp, loc_param_s_type* config_table, uint32_t table_length)
+{
+    int ret=0;
+
+    unsigned int num_params=table_length;
+    if(conf_fp == NULL) {
+        LOC_LOGE("%s:%d]: ERROR: File pointer is NULL\n", __func__, __LINE__);
+        ret = -1;
+        goto err;
+    }
+
+    /* Clear all validity bits */
+    for(uint32_t i = 0; NULL != config_table && i < table_length; i++)
+    {
+        if(NULL != config_table[i].param_set)
+        {
+            *(config_table[i].param_set) = 0;
+        }
+    }
+
+    char input_buf[LOC_MAX_PARAM_LINE];  /* declare a char array */
+
+    LOC_LOGD("%s:%d]: num_params: %d\n", __func__, __LINE__, num_params);
+    while(num_params)
+    {
+        if(!fgets(input_buf, LOC_MAX_PARAM_LINE, conf_fp)) {
+            LOC_LOGD("%s:%d]: fgets returned NULL\n", __func__, __LINE__);
+            break;
+        }
+
+        num_params -= loc_fill_conf_item(input_buf, config_table, table_length);
+    }
+
+err:
+    return ret;
+}
+
+/*===========================================================================
+FUNCTION loc_udpate_conf
+
+DESCRIPTION
+   Parses the passed in buffer for configuration items, and update the table
+   that is also passed in.
+
+Reads the specified configuration file and sets defined values based on
+   the passed in configuration table. This table maps strings to values to
+   set along with the type of each of these values.
+
+PARAMETERS:
+   conf_data: configuration items in bufferas a string
+   length: strlen(conf_data)
+   config_table: table definition of strings to places to store information
+   table_length: length of the configuration table
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   number of the records in the table that is updated at time of return.
+
+SIDE EFFECTS
+   N/A
+===========================================================================*/
+int loc_update_conf(const char* conf_data, int32_t length,
+                    loc_param_s_type* config_table, uint32_t table_length)
+{
+    int ret = -1;
+
+    if (conf_data && length && config_table && table_length) {
+        // make a copy, so we do not tokenize the original data
+        char* conf_copy = (char*)malloc(length+1);
+
+        if (conf_copy != NULL)
+        {
+            memcpy(conf_copy, conf_data, length);
+            // we hard NULL the end of string to be safe
+            conf_copy[length] = 0;
+
+            // start with one record off
+            uint32_t num_params = table_length - 1;
+            char* saveptr = NULL;
+            char* input_buf = strtok_r(conf_copy, "\n", &saveptr);
+            ret = 0;
+
+            LOC_LOGD("%s:%d]: num_params: %d\n", __func__, __LINE__, num_params);
+            while(num_params && input_buf) {
+                ret++;
+                num_params -= loc_fill_conf_item(input_buf, config_table, table_length);
+                input_buf = strtok_r(NULL, "\n", &saveptr);
+            }
+            free(conf_copy);
+        }
+    }
+
+    return ret;
+}
+
+/*===========================================================================
+FUNCTION loc_read_conf
+
+DESCRIPTION
+   Reads the specified configuration file and sets defined values based on
+   the passed in configuration table. This table maps strings to values to
+   set along with the type of each of these values.
+
+PARAMETERS:
+   conf_file_name: configuration file to read
+   config_table: table definition of strings to places to store information
+   table_length: length of the configuration table
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   None
+
+SIDE EFFECTS
+   N/A
+===========================================================================*/
+void loc_read_conf(const char* conf_file_name, loc_param_s_type* config_table,
+                   uint32_t table_length)
+{
+    FILE *conf_fp = NULL;
+    char input_buf[LOC_MAX_PARAM_LINE];  /* declare a char array */
+    char *lasts;
+    loc_param_v_type config_value;
+    uint32_t i;
+
+    if((conf_fp = fopen(conf_file_name, "r")) != NULL)
+    {
+        LOC_LOGD("%s: using %s", __FUNCTION__, conf_file_name);
+        if(table_length && config_table) {
+            loc_read_conf_r(conf_fp, config_table, table_length);
+            rewind(conf_fp);
+        }
+        loc_read_conf_r(conf_fp, loc_param_table, loc_param_num);
+        fclose(conf_fp);
+    }
+    /* Initialize logging mechanism with parsed data */
+    loc_logger_init(DEBUG_LEVEL, TIMESTAMP);
+}
diff --git a/msm8974/utils/loc_cfg.h b/msm8974/utils/loc_cfg.h
new file mode 100644
index 0000000..bd25e86
--- /dev/null
+++ b/msm8974/utils/loc_cfg.h
@@ -0,0 +1,91 @@
+/* Copyright (c) 2011-2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef LOC_CFG_H
+#define LOC_CFG_H
+
+#include <stdio.h>
+#include <stdint.h>
+
+#define LOC_MAX_PARAM_NAME                 48
+#define LOC_MAX_PARAM_STRING               80
+#define LOC_MAX_PARAM_LINE                 80
+
+#define UTIL_UPDATE_CONF(conf_data, len, config_table) \
+    loc_update_conf((conf_data), (len), (config_table), \
+                    sizeof(config_table) / sizeof(config_table[0]))
+
+#define UTIL_READ_CONF_DEFAULT(filename) \
+    loc_read_conf((filename), NULL, 0);
+
+#define UTIL_READ_CONF(filename, config_table) \
+    loc_read_conf((filename), (config_table), sizeof(config_table) / sizeof(config_table[0]))
+
+/*=============================================================================
+ *
+ *                        MODULE TYPE DECLARATION
+ *
+ *============================================================================*/
+typedef struct
+{
+  char                           param_name[LOC_MAX_PARAM_NAME];
+  void                          *param_ptr;
+  uint8_t                       *param_set;   /* was this value set by config file? */
+  char                           param_type;  /* 'n' for number,
+                                                 's' for string,
+                                                 'f' for float */
+} loc_param_s_type;
+
+/*=============================================================================
+ *
+ *                          MODULE EXTERNAL DATA
+ *
+ *============================================================================*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*=============================================================================
+ *
+ *                       MODULE EXPORTED FUNCTIONS
+ *
+ *============================================================================*/
+void loc_read_conf(const char* conf_file_name,
+                   loc_param_s_type* config_table,
+                   uint32_t table_length);
+int loc_read_conf_r(FILE *conf_fp, loc_param_s_type* config_table,
+                    uint32_t table_length);
+int loc_update_conf(const char* conf_data, int32_t length,
+                    loc_param_s_type* config_table, uint32_t table_length);
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LOC_CFG_H */
diff --git a/msm8974/utils/loc_log.cpp b/msm8974/utils/loc_log.cpp
new file mode 100644
index 0000000..392966e
--- /dev/null
+++ b/msm8974/utils/loc_log.cpp
@@ -0,0 +1,240 @@
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#define LOG_NDDEBUG 0
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include "loc_log.h"
+#include "msg_q.h"
+#ifdef USE_GLIB
+#include <time.h>
+#endif /* USE_GLIB  */
+#include "log_util.h"
+#include "platform_lib_includes.h"
+
+#define  BUFFER_SIZE  120
+
+// Logging Improvements
+const char *loc_logger_boolStr[]={"False","True"};
+const char VOID_RET[]   = "None";
+const char FROM_AFW[]   = "===>";
+const char TO_MODEM[]   = "--->";
+const char FROM_MODEM[] = "<---";
+const char TO_AFW[]     = "<===";
+const char EXIT_TAG[]   = "Exiting";
+const char ENTRY_TAG[]  = "Entering";
+
+/* Logging Mechanism */
+loc_logger_s_type loc_logger;
+
+/* Get names from value */
+const char* loc_get_name_from_mask(loc_name_val_s_type table[], int table_size, long mask)
+{
+   int i;
+   for (i = 0; i < table_size; i++)
+   {
+      if (table[i].val & (long) mask)
+      {
+         return table[i].name;
+      }
+   }
+   return UNKNOWN_STR;
+}
+
+/* Get names from value */
+const char* loc_get_name_from_val(loc_name_val_s_type table[], int table_size, long value)
+{
+   int i;
+   for (i = 0; i < table_size; i++)
+   {
+      if (table[i].val == (long) value)
+      {
+         return table[i].name;
+      }
+   }
+   return UNKNOWN_STR;
+}
+
+static loc_name_val_s_type loc_msg_q_status[] =
+{
+    NAME_VAL( eMSG_Q_SUCCESS ),
+    NAME_VAL( eMSG_Q_FAILURE_GENERAL ),
+    NAME_VAL( eMSG_Q_INVALID_PARAMETER ),
+    NAME_VAL( eMSG_Q_INVALID_HANDLE ),
+    NAME_VAL( eMSG_Q_UNAVAILABLE_RESOURCE ),
+    NAME_VAL( eMSG_Q_INSUFFICIENT_BUFFER )
+};
+static int loc_msg_q_status_num = sizeof(loc_msg_q_status) / sizeof(loc_name_val_s_type);
+
+/* Find msg_q status name */
+const char* loc_get_msg_q_status(int status)
+{
+   return loc_get_name_from_val(loc_msg_q_status, loc_msg_q_status_num, (long) status);
+}
+
+const char* log_succ_fail_string(int is_succ)
+{
+   return is_succ? "successful" : "failed";
+}
+
+//Target names
+loc_name_val_s_type target_name[] =
+{
+    NAME_VAL(GNSS_NONE),
+    NAME_VAL(GNSS_MSM),
+    NAME_VAL(GNSS_GSS),
+    NAME_VAL(GNSS_MDM),
+    NAME_VAL(GNSS_QCA1530),
+    NAME_VAL(GNSS_UNKNOWN)
+};
+
+static int target_name_num = sizeof(target_name)/sizeof(loc_name_val_s_type);
+
+/*===========================================================================
+
+FUNCTION loc_get_target_name
+
+DESCRIPTION
+   Returns pointer to a string that contains name of the target
+
+   XX:XX:XX.000\0
+
+RETURN VALUE
+   The target name string
+
+===========================================================================*/
+const char *loc_get_target_name(unsigned int target)
+{
+    int index = 0;
+    static char ret[BUFFER_SIZE];
+
+    index =  getTargetGnssType(target);
+    if( index >= target_name_num || index < 0)
+        index = target_name_num - 1;
+
+    if( (target & HAS_SSC) == HAS_SSC ) {
+        snprintf(ret, sizeof(ret), " %s with SSC",
+           loc_get_name_from_val(target_name, target_name_num, (long)index) );
+    }
+    else {
+       snprintf(ret, sizeof(ret), " %s  without SSC",
+           loc_get_name_from_val(target_name, target_name_num, (long)index) );
+    }
+    return ret;
+}
+
+
+/*===========================================================================
+
+FUNCTION loc_get_time
+
+DESCRIPTION
+   Logs a callback event header.
+   The pointer time_string should point to a buffer of at least 13 bytes:
+
+   XX:XX:XX.000\0
+
+RETURN VALUE
+   The time string
+
+===========================================================================*/
+char *loc_get_time(char *time_string, unsigned long buf_size)
+{
+   struct timeval now;     /* sec and usec     */
+   struct tm now_tm;       /* broken-down time */
+   char hms_string[80];    /* HH:MM:SS         */
+
+   gettimeofday(&now, NULL);
+   localtime_r(&now.tv_sec, &now_tm);
+
+   strftime(hms_string, sizeof hms_string, "%H:%M:%S", &now_tm);
+   snprintf(time_string, buf_size, "%s.%03d", hms_string, (int) (now.tv_usec / 1000));
+
+   return time_string;
+}
+
+
+/*===========================================================================
+FUNCTION loc_logger_init
+
+DESCRIPTION
+   Initializes the state of DEBUG_LEVEL and TIMESTAMP
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   None
+
+SIDE EFFECTS
+   N/A
+===========================================================================*/
+void loc_logger_init(unsigned long debug, unsigned long timestamp)
+{
+   loc_logger.DEBUG_LEVEL = debug;
+#ifdef TARGET_BUILD_VARIANT_USER
+   // force user builds to 2 or less
+   if (loc_logger.DEBUG_LEVEL > 2) {
+       loc_logger.DEBUG_LEVEL = 2;
+   }
+#endif
+   loc_logger.TIMESTAMP   = timestamp;
+}
+
+
+/*===========================================================================
+FUNCTION get_timestamp
+
+DESCRIPTION
+   Generates a timestamp using the current system time
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   Char pointer to the parameter str
+
+SIDE EFFECTS
+   N/A
+===========================================================================*/
+char * get_timestamp(char *str, unsigned long buf_size)
+{
+  struct timeval tv;
+  struct timezone tz;
+  int hh, mm, ss;
+  gettimeofday(&tv, &tz);
+  hh = tv.tv_sec/3600%24;
+  mm = (tv.tv_sec%3600)/60;
+  ss = tv.tv_sec%60;
+  snprintf(str, buf_size, "%02d:%02d:%02d.%06ld", hh, mm, ss, tv.tv_usec);
+  return str;
+}
+
diff --git a/msm8974/utils/loc_log.h b/msm8974/utils/loc_log.h
new file mode 100644
index 0000000..82dc636
--- /dev/null
+++ b/msm8974/utils/loc_log.h
@@ -0,0 +1,68 @@
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef LOC_LOG_H
+#define LOC_LOG_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include <ctype.h>
+#include "loc_target.h"
+
+typedef struct
+{
+   char                 name[128];
+   long                 val;
+} loc_name_val_s_type;
+
+#define NAME_VAL(x) {"" #x "", x }
+
+#define UNKNOWN_STR "UNKNOWN"
+
+#define CHECK_MASK(type, value, mask_var, mask) \
+   ((mask_var & mask) ? (type) value : (type) (-1))
+
+/* Get names from value */
+const char* loc_get_name_from_mask(loc_name_val_s_type table[], int table_size, long mask);
+const char* loc_get_name_from_val(loc_name_val_s_type table[], int table_size, long value);
+const char* loc_get_msg_q_status(int status);
+const char* loc_get_target_name(unsigned int target);
+
+extern const char* log_succ_fail_string(int is_succ);
+
+extern char *loc_get_time(char *time_string, unsigned long buf_size);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LOC_LOG_H */
diff --git a/msm8974/utils/loc_misc_utils.cpp b/msm8974/utils/loc_misc_utils.cpp
new file mode 100644
index 0000000..7e96313
--- /dev/null
+++ b/msm8974/utils/loc_misc_utils.cpp
@@ -0,0 +1,114 @@
+/* Copyright (c) 2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <stdio.h>
+#include <string.h>
+#include <log_util.h>
+#include <loc_misc_utils.h>
+#include <ctype.h>
+
+#define LOG_NDDEBUG 0
+#define LOG_TAG "LocSvc_misc_utils"
+
+int loc_util_split_string(char *raw_string, char **split_strings_ptr,
+                          int max_num_substrings, char delimiter)
+{
+    int raw_string_index=0;
+    int num_split_strings=0;
+    unsigned char end_string=0;
+    int raw_string_length=0;
+
+    if(!raw_string || !split_strings_ptr) {
+        LOC_LOGE("%s:%d]: NULL parameters", __func__, __LINE__);
+        num_split_strings = -1;
+        goto err;
+    }
+    LOC_LOGD("%s:%d]: raw string: %s\n", __func__, __LINE__, raw_string);
+    raw_string_length = strlen(raw_string) + 1;
+    split_strings_ptr[num_split_strings] = &raw_string[raw_string_index];
+    for(raw_string_index=0; raw_string_index < raw_string_length; raw_string_index++) {
+        if(raw_string[raw_string_index] == '\0')
+            end_string=1;
+        if((raw_string[raw_string_index] == delimiter) || end_string) {
+            raw_string[raw_string_index] = '\0';
+            LOC_LOGD("%s:%d]: split string: %s\n",
+                     __func__, __LINE__, split_strings_ptr[num_split_strings]);
+            num_split_strings++;
+            if(((raw_string_index + 1) < raw_string_length) &&
+               (num_split_strings < max_num_substrings)) {
+                split_strings_ptr[num_split_strings] = &raw_string[raw_string_index+1];
+            }
+            else {
+                break;
+            }
+        }
+        if(end_string)
+            break;
+    }
+err:
+    LOC_LOGD("%s:%d]: num_split_strings: %d\n", __func__, __LINE__, num_split_strings);
+    return num_split_strings;
+}
+
+void loc_util_trim_space(char *org_string)
+{
+    char *scan_ptr, *write_ptr;
+    char *first_nonspace = NULL, *last_nonspace = NULL;
+
+    if(org_string == NULL) {
+        LOC_LOGE("%s:%d]: NULL parameter", __func__, __LINE__);
+        goto err;
+    }
+
+    scan_ptr = write_ptr = org_string;
+
+    while (*scan_ptr) {
+        //Find the first non-space character
+        if ( !isspace(*scan_ptr) && first_nonspace == NULL) {
+            first_nonspace = scan_ptr;
+        }
+        //Once the first non-space character is found in the
+        //above check, keep shifting the characters to the left
+        //to replace the spaces
+        if (first_nonspace != NULL) {
+            *(write_ptr++) = *scan_ptr;
+            //Keep track of which was the last non-space character
+            //encountered
+            //last_nonspace will not be updated in the case where
+            //the string ends with spaces
+            if ( !isspace(*scan_ptr)) {
+                last_nonspace = write_ptr;
+            }
+        }
+        scan_ptr++;
+    }
+    //Add NULL terminator after the last non-space character
+    if (last_nonspace) { *last_nonspace = '\0'; }
+err:
+    return;
+}
diff --git a/msm8974/utils/loc_misc_utils.h b/msm8974/utils/loc_misc_utils.h
new file mode 100644
index 0000000..7d66d84
--- /dev/null
+++ b/msm8974/utils/loc_misc_utils.h
@@ -0,0 +1,99 @@
+/* Copyright (c) 2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef _LOC_MISC_UTILS_H_
+#define _LOC_MISC_UTILS_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*===========================================================================
+FUNCTION loc_split_string
+
+DESCRIPTION:
+    This function is used to split a delimiter separated string into
+    sub-strings. This function does not allocate new memory to store the split
+    strings. Instead, it places '\0' in places of delimiters and assings the
+    starting address of the substring within the raw string as the string address
+    The input raw_string no longer remains to be a collection of sub-strings
+    after this function is executed.
+    Please make a copy of the input string before calling this function if
+    necessary
+
+PARAMETERS:
+    char *raw_string: is the original string with delimiter separated substrings
+    char **split_strings_ptr: is the arraw of pointers which will hold the addresses
+                              of individual substrings
+    int max_num_substrings: is the maximum number of substrings that are expected
+                            by the caller. The array of pointers in the above parameter
+                            is usually this long
+    char delimiter: is the delimiter that separates the substrings. Examples: ' ', ';'
+
+DEPENDENCIES
+    N/A
+
+RETURN VALUE
+    int Number of split strings
+
+SIDE EFFECTS
+    The input raw_string no longer remains a delimiter separated single string.
+
+EXAMPLE
+    delimiter = ' ' //space
+    raw_string = "hello new user" //delimiter is space ' '
+    addresses  =  0123456789abcd
+    split_strings_ptr[0] = &raw_string[0]; //split_strings_ptr[0] contains "hello"
+    split_strings_ptr[1] = &raw_string[6]; //split_strings_ptr[1] contains "new"
+    split_strings_ptr[2] = &raw_string[a]; //split_strings_ptr[2] contains "user"
+
+===========================================================================*/
+int loc_util_split_string(char *raw_string, char **split_strings_ptr, int max_num_substrings,
+                     char delimiter);
+
+/*===========================================================================
+FUNCTION trim_space
+
+DESCRIPTION
+   Removes leading and trailing spaces of the string
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   None
+
+SIDE EFFECTS
+   N/A
+===========================================================================*/
+void loc_util_trim_space(char *org_string);
+#ifdef __cplusplus
+}
+#endif
+
+#endif //_LOC_MISC_UTILS_H_
diff --git a/msm8974/utils/loc_target.cpp b/msm8974/utils/loc_target.cpp
new file mode 100644
index 0000000..45bd04d
--- /dev/null
+++ b/msm8974/utils/loc_target.cpp
@@ -0,0 +1,241 @@
+/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <hardware/gps.h>
+#include <cutils/properties.h>
+#include "loc_target.h"
+#include "loc_log.h"
+#include "log_util.h"
+
+#define APQ8064_ID_1 "109"
+#define APQ8064_ID_2 "153"
+#define MPQ8064_ID_1 "130"
+#define MSM8930_ID_1 "142"
+#define MSM8930_ID_2 "116"
+#define APQ8030_ID_1 "157"
+#define APQ8074_ID_1 "184"
+
+#define LINE_LEN 100
+#define STR_LIQUID    "Liquid"
+#define STR_SURF      "Surf"
+#define STR_MTP       "MTP"
+#define STR_APQ       "apq"
+#define IS_STR_END(c) ((c) == '\0' || (c) == '\n' || (c) == '\r')
+#define LENGTH(s) (sizeof(s) - 1)
+#define GPS_CHECK_NO_ERROR 0
+#define GPS_CHECK_NO_GPS_HW 1
+/* When system server is started, it uses 20 seconds as ActivityManager
+ * timeout. After that it sends SIGSTOP signal to process.
+ */
+#define QCA1530_DETECT_TIMEOUT 15
+#define QCA1530_DETECT_PRESENT "yes"
+#define QCA1530_DETECT_PROGRESS "detect"
+
+static unsigned int gTarget = (unsigned int)-1;
+
+static int read_a_line(const char * file_path, char * line, int line_size)
+{
+    FILE *fp;
+    int result = 0;
+
+    * line = '\0';
+    fp = fopen(file_path, "r" );
+    if( fp == NULL ) {
+        LOC_LOGE("open failed: %s: %s\n", file_path, strerror(errno));
+        result = -1;
+    } else {
+        int len;
+        fgets(line, line_size, fp);
+        len = strlen(line);
+        len = len < line_size - 1? len : line_size - 1;
+        line[len] = '\0';
+        LOC_LOGD("cat %s: %s", file_path, line);
+        fclose(fp);
+    }
+    return result;
+}
+
+/*!
+ * \brief Checks if QCA1530 is avalable.
+ *
+ * Function verifies if qca1530 SoC is configured on the device. The test is
+ * based on property value. For 1530 scenario, the value shall be one of the
+ * following: "yes", "no", "detect". All other values are treated equally to
+ * "no". When the value is "detect" the system waits for SoC detection to
+ * finish before returning result.
+ *
+ * \retval true - QCA1530 is available.
+ * \retval false - QCA1530 is not available.
+ */
+static bool is_qca1530(void)
+{
+    static const char qca1530_property_name[] = "sys.qca1530";
+    bool res = false;
+    int ret, i;
+    char buf[PROPERTY_VALUE_MAX];
+
+    memset(buf, 0, sizeof(buf));
+
+    for (i = 0; i < QCA1530_DETECT_TIMEOUT; ++i)
+    {
+        ret = property_get(qca1530_property_name, buf, NULL);
+        if (ret < 0)
+        {
+            LOC_LOGV( "qca1530: property %s is not accessible, ret=%d",
+                  qca1530_property_name,
+                  ret);
+
+            break;
+        }
+
+        LOC_LOGV( "qca1530: property %s is set to %s",
+                  qca1530_property_name,
+                  buf);
+
+        if (!memcmp(buf, QCA1530_DETECT_PRESENT,
+                    sizeof(QCA1530_DETECT_PRESENT)))
+        {
+            res = true;
+            break;
+        }
+        if (!memcmp(buf, QCA1530_DETECT_PROGRESS,
+                    sizeof(QCA1530_DETECT_PROGRESS)))
+        {
+            LOC_LOGV("qca1530: SoC detection is in progress.");
+            sleep(1);
+            continue;
+        }
+        break;
+    }
+
+    LOC_LOGD("qca1530: detected=%s", res ? "true" : "false");
+    return res;
+}
+
+/*The character array passed to this function should have length
+  of atleast PROPERTY_VALUE_MAX*/
+void loc_get_target_baseband(char *baseband, int array_length)
+{
+    if(baseband && (array_length >= PROPERTY_VALUE_MAX)) {
+        property_get("ro.baseband", baseband, "");
+        LOC_LOGD("%s:%d]: Baseband: %s\n", __func__, __LINE__, baseband);
+    }
+    else {
+        LOC_LOGE("%s:%d]: NULL parameter or array length less than PROPERTY_VALUE_MAX\n",
+                 __func__, __LINE__);
+    }
+}
+
+/*The character array passed to this function should have length
+  of atleast PROPERTY_VALUE_MAX*/
+void loc_get_platform_name(char *platform_name, int array_length)
+{
+    if(platform_name && (array_length >= PROPERTY_VALUE_MAX)) {
+        property_get("ro.board.platform", platform_name, "");
+        LOC_LOGD("%s:%d]: Target name: %s\n", __func__, __LINE__, platform_name);
+    }
+    else {
+        LOC_LOGE("%s:%d]: Null parameter or array length less than PROPERTY_VALUE_MAX\n",
+                 __func__, __LINE__);
+    }
+}
+
+unsigned int loc_get_target(void)
+{
+    if (gTarget != (unsigned int)-1)
+        return gTarget;
+
+    static const char hw_platform[]      = "/sys/devices/soc0/hw_platform";
+    static const char id[]               = "/sys/devices/soc0/soc_id";
+    static const char hw_platform_dep[]  =
+        "/sys/devices/system/soc/soc0/hw_platform";
+    static const char id_dep[]           = "/sys/devices/system/soc/soc0/id";
+    static const char mdm[]              = "/dev/mdm"; // No such file or directory
+
+    char rd_hw_platform[LINE_LEN];
+    char rd_id[LINE_LEN];
+    char rd_mdm[LINE_LEN];
+    char baseband[LINE_LEN];
+
+    if (is_qca1530()) {
+        gTarget = TARGET_QCA1530;
+        goto detected;
+    }
+
+    loc_get_target_baseband(baseband, sizeof(baseband));
+
+    if (!access(hw_platform, F_OK)) {
+        read_a_line(hw_platform, rd_hw_platform, LINE_LEN);
+    } else {
+        read_a_line(hw_platform_dep, rd_hw_platform, LINE_LEN);
+    }
+    if (!access(id, F_OK)) {
+        read_a_line(id, rd_id, LINE_LEN);
+    } else {
+        read_a_line(id_dep, rd_id, LINE_LEN);
+    }
+
+    if( !memcmp(baseband, STR_APQ, LENGTH(STR_APQ)) ){
+        if( !memcmp(rd_id, MPQ8064_ID_1, LENGTH(MPQ8064_ID_1))
+            && IS_STR_END(rd_id[LENGTH(MPQ8064_ID_1)]) )
+            gTarget = TARGET_MPQ;
+        else
+            gTarget = TARGET_APQ_SA;
+    }
+    else {
+        if( (!memcmp(rd_hw_platform, STR_LIQUID, LENGTH(STR_LIQUID))
+             && IS_STR_END(rd_hw_platform[LENGTH(STR_LIQUID)])) ||
+            (!memcmp(rd_hw_platform, STR_SURF,   LENGTH(STR_SURF))
+             && IS_STR_END(rd_hw_platform[LENGTH(STR_SURF)])) ||
+            (!memcmp(rd_hw_platform, STR_MTP,   LENGTH(STR_MTP))
+             && IS_STR_END(rd_hw_platform[LENGTH(STR_MTP)]))) {
+
+            if (!read_a_line( mdm, rd_mdm, LINE_LEN))
+                gTarget = TARGET_MDM;
+        }
+        else if( (!memcmp(rd_id, MSM8930_ID_1, LENGTH(MSM8930_ID_1))
+                   && IS_STR_END(rd_id[LENGTH(MSM8930_ID_1)])) ||
+                  (!memcmp(rd_id, MSM8930_ID_2, LENGTH(MSM8930_ID_2))
+                   && IS_STR_END(rd_id[LENGTH(MSM8930_ID_2)])) )
+             gTarget = TARGET_MSM_NO_SSC;
+        else
+             gTarget = TARGET_UNKNOWN;
+    }
+
+detected:
+    LOC_LOGD("HAL: %s returned %d", __FUNCTION__, gTarget);
+    return gTarget;
+}
diff --git a/msm8974/utils/loc_target.h b/msm8974/utils/loc_target.h
new file mode 100644
index 0000000..9aa525f
--- /dev/null
+++ b/msm8974/utils/loc_target.h
@@ -0,0 +1,75 @@
+/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef LOC_TARGET_H
+#define LOC_TARGET_H
+#define TARGET_SET(gnss,ssc) ( (gnss<<1)|ssc )
+#define TARGET_DEFAULT       TARGET_SET(GNSS_MSM, HAS_SSC)
+#define TARGET_MDM           TARGET_SET(GNSS_MDM, HAS_SSC)
+#define TARGET_APQ_SA        TARGET_SET(GNSS_GSS, NO_SSC)
+#define TARGET_MPQ           TARGET_SET(GNSS_NONE,NO_SSC)
+#define TARGET_MSM_NO_SSC    TARGET_SET(GNSS_MSM, NO_SSC)
+#define TARGET_QCA1530       TARGET_SET(GNSS_QCA1530, NO_SSC)
+#define TARGET_UNKNOWN       TARGET_SET(GNSS_UNKNOWN, NO_SSC)
+#define getTargetGnssType(target)  (target>>1)
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+unsigned int loc_get_target(void);
+
+/*The character array passed to this function should have length
+  of atleast PROPERTY_VALUE_MAX*/
+void loc_get_target_baseband(char *baseband, int array_length);
+/*The character array passed to this function should have length
+  of atleast PROPERTY_VALUE_MAX*/
+void loc_get_platform_name(char *platform_name, int array_length);
+
+/* Please remember to update 'target_name' in loc_log.cpp,
+   if do any changes to this enum. */
+typedef enum {
+    GNSS_NONE = 0,
+    GNSS_MSM,
+    GNSS_GSS,
+    GNSS_MDM,
+    GNSS_QCA1530,
+    GNSS_UNKNOWN
+}GNSS_TARGET;
+
+typedef enum {
+    NO_SSC = 0,
+    HAS_SSC
+}SSC_TYPE;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*LOC_TARGET_H*/
diff --git a/msm8974/utils/loc_timer.c b/msm8974/utils/loc_timer.c
new file mode 100644
index 0000000..1e4008e
--- /dev/null
+++ b/msm8974/utils/loc_timer.c
@@ -0,0 +1,186 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include<stdio.h>
+#include<stdlib.h>
+#include<sys/time.h>
+#include "loc_timer.h"
+#include<time.h>
+#include<errno.h>
+
+enum timer_state {
+    READY = 100,
+    WAITING,
+    DONE,
+    ABORT
+};
+
+typedef struct {
+    loc_timer_callback callback_func;
+    void *user_data;
+    unsigned int time_msec;
+    pthread_cond_t timer_cond;
+    pthread_mutex_t timer_mutex;
+    enum timer_state state;
+}timer_data;
+
+static void *timer_thread(void *thread_data)
+{
+    int ret = -ETIMEDOUT;
+    struct timespec ts;
+    struct timeval tv;
+    timer_data* t = (timer_data*)thread_data;
+
+    LOC_LOGD("%s:%d]: Enter. Delay = %d\n", __func__, __LINE__, t->time_msec);
+
+    gettimeofday(&tv, NULL);
+    clock_gettime(CLOCK_REALTIME, &ts);
+    if(t->time_msec >= 1000) {
+        ts.tv_sec += t->time_msec/1000;
+        t->time_msec = t->time_msec % 1000;
+    }
+    if(t->time_msec)
+        ts.tv_nsec += t->time_msec * 1000000;
+    if(ts.tv_nsec > 999999999) {
+        LOC_LOGD("%s:%d]: Large nanosecs\n", __func__, __LINE__);
+        ts.tv_sec += 1;
+        ts.tv_nsec -= 1000000000;
+    }
+    LOC_LOGD("%s:%d]: ts.tv_sec:%d; ts.tv_nsec:%d\n"
+             "\t Current time: %d sec; %d nsec",
+             __func__, __LINE__, (int)ts.tv_sec, (int)ts.tv_nsec,
+             (int)tv.tv_sec, (int)tv.tv_usec*1000);
+
+    pthread_mutex_lock(&(t->timer_mutex));
+    if (READY == t->state) {
+        t->state = WAITING;
+        ret = pthread_cond_timedwait(&t->timer_cond, &t->timer_mutex, &ts);
+        t->state = DONE;
+    }
+    pthread_mutex_unlock(&(t->timer_mutex));
+
+    switch (ret) {
+    case ETIMEDOUT:
+        LOC_LOGV("%s:%d]: loc_timer timed out",  __func__, __LINE__);
+        break;
+    case 0:
+        LOC_LOGV("%s:%d]: loc_timer stopped",  __func__, __LINE__);
+        break;
+    case -ETIMEDOUT:
+        LOC_LOGV("%s:%d]: loc_timer cancelled",  __func__, __LINE__);
+        break;
+    default:
+        LOC_LOGE("%s:%d]: Call to pthread timedwait failed; ret=%d\n",
+                 __func__, __LINE__, ret);
+        break;
+    }
+
+    pthread_mutex_destroy(&t->timer_mutex);
+    pthread_cond_destroy(&t->timer_cond);
+
+    if(ETIMEDOUT == ret)
+        t->callback_func(t->user_data, ret);
+
+    free(t);
+    LOC_LOGD("%s:%d]: Exit\n", __func__, __LINE__);
+    return NULL;
+}
+
+void* loc_timer_start(unsigned int msec, loc_timer_callback cb_func,
+                      void* caller_data)
+{
+    timer_data *t=NULL;
+    pthread_attr_t tattr;
+    pthread_t id;
+    LOC_LOGD("%s:%d]: Enter\n", __func__, __LINE__);
+    if(cb_func == NULL || msec == 0) {
+        LOC_LOGE("%s:%d]: Error: Wrong parameters\n", __func__, __LINE__);
+        goto _err;
+    }
+    t = (timer_data *)calloc(1, sizeof(timer_data));
+    if(t == NULL) {
+        LOC_LOGE("%s:%d]: Could not allocate memory. Failing.\n",
+                 __func__, __LINE__);
+        goto _err;
+    }
+
+    if(pthread_cond_init(&(t->timer_cond), NULL)) {
+        LOC_LOGE("%s:%d]: Pthread cond init failed\n", __func__, __LINE__);
+        goto t_err;
+    }
+    if(pthread_mutex_init(&(t->timer_mutex), NULL)) {
+        LOC_LOGE("%s:%d]: Pthread mutex init failed\n", __func__, __LINE__);
+        goto cond_err;
+    }
+
+    t->callback_func = cb_func;
+    t->user_data = caller_data;
+    t->time_msec = msec;
+    t->state = READY;
+
+    if (pthread_attr_init(&tattr)) {
+        LOC_LOGE("%s:%d]: Pthread mutex init failed\n", __func__, __LINE__);
+        goto mutex_err;
+    }
+    pthread_attr_setdetachstate(&tattr, PTHREAD_CREATE_DETACHED);
+
+    if(pthread_create(&(id), &tattr, timer_thread, (void *)t)) {
+        LOC_LOGE("%s:%d]: Could not create thread\n", __func__, __LINE__);
+        goto attr_err;
+    }
+
+    LOC_LOGD("%s:%d]: Created thread with id: %d\n",
+             __func__, __LINE__, (int)id);
+    goto _err;
+
+attr_err:
+    pthread_attr_destroy(&tattr);
+mutex_err:
+    pthread_mutex_destroy(&t->timer_mutex);
+cond_err:
+    pthread_cond_destroy(&t->timer_cond);
+t_err:
+    free(t);
+_err:
+    LOC_LOGD("%s:%d]: Exit\n", __func__, __LINE__);
+    return t;
+}
+
+void loc_timer_stop(void* handle) {
+    timer_data* t = (timer_data*)handle;
+
+    if (NULL != t && (READY == t->state || WAITING == t->state)) {
+        pthread_mutex_lock(&(t->timer_mutex));
+        if (READY == t->state || WAITING == t->state) {
+            pthread_cond_signal(&t->timer_cond);
+            t->state = ABORT;
+        }
+        pthread_mutex_unlock(&(t->timer_mutex));
+    }
+}
diff --git a/msm8974/utils/loc_timer.h b/msm8974/utils/loc_timer.h
new file mode 100644
index 0000000..0034d27
--- /dev/null
+++ b/msm8974/utils/loc_timer.h
@@ -0,0 +1,63 @@
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __LOC_DELAY_H__
+#define __LOC_DELAY_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#include<pthread.h>
+#include "log_util.h"
+
+/*
+  Return values:
+  Success = 0
+  Failure = Non zero
+*/
+typedef void(*loc_timer_callback)(void *user_data, int result);
+
+
+/*
+  Returns the handle, which can be used to stop the timer
+*/
+void* loc_timer_start(unsigned int delay_msec,
+                      loc_timer_callback,
+                      void* user_data);
+
+/*
+  handle becomes invalid upon the return of the callback
+*/
+void loc_timer_stop(void* handle);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif //__LOC_DELAY_H__
diff --git a/msm8974/utils/log_util.h b/msm8974/utils/log_util.h
new file mode 100644
index 0000000..8ff6b5a
--- /dev/null
+++ b/msm8974/utils/log_util.h
@@ -0,0 +1,181 @@
+/* Copyright (c) 2011-2014 The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __LOG_UTIL_H__
+#define __LOG_UTIL_H__
+
+#ifndef USE_GLIB
+#include <utils/Log.h>
+#endif /* USE_GLIB */
+
+#ifdef USE_GLIB
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#ifndef LOG_TAG
+#define LOG_TAG "GPS_UTILS"
+
+#endif  // LOG_TAG
+
+#endif /* USE_GLIB */
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/*=============================================================================
+ *
+ *                         LOC LOGGER TYPE DECLARATION
+ *
+ *============================================================================*/
+/* LOC LOGGER */
+typedef struct loc_logger_s
+{
+  unsigned long  DEBUG_LEVEL;
+  unsigned long  TIMESTAMP;
+} loc_logger_s_type;
+
+/*=============================================================================
+ *
+ *                               EXTERNAL DATA
+ *
+ *============================================================================*/
+extern loc_logger_s_type loc_logger;
+
+// Logging Improvements
+extern const char *loc_logger_boolStr[];
+
+extern const char *boolStr[];
+extern const char VOID_RET[];
+extern const char FROM_AFW[];
+extern const char TO_MODEM[];
+extern const char FROM_MODEM[];
+extern const char TO_AFW[];
+extern const char EXIT_TAG[];
+extern const char ENTRY_TAG[];
+/*=============================================================================
+ *
+ *                        MODULE EXPORTED FUNCTIONS
+ *
+ *============================================================================*/
+extern void loc_logger_init(unsigned long debug, unsigned long timestamp);
+extern char* get_timestamp(char* str, unsigned long buf_size);
+
+#ifndef DEBUG_DMN_LOC_API
+
+/* LOGGING MACROS */
+/*loc_logger.DEBUG_LEVEL is initialized to 0xff in loc_cfg.cpp
+  if that value remains unchanged, it means gps.conf did not
+  provide a value and we default to the initial value to use
+  Android's logging levels*/
+#define IF_LOC_LOGE if((loc_logger.DEBUG_LEVEL >= 1) && (loc_logger.DEBUG_LEVEL <= 5))
+
+#define IF_LOC_LOGW if((loc_logger.DEBUG_LEVEL >= 2) && (loc_logger.DEBUG_LEVEL <= 5))
+
+#define IF_LOC_LOGI if((loc_logger.DEBUG_LEVEL >= 3) && (loc_logger.DEBUG_LEVEL <= 5))
+
+#define IF_LOC_LOGD if((loc_logger.DEBUG_LEVEL >= 4) && (loc_logger.DEBUG_LEVEL <= 5))
+
+#define IF_LOC_LOGV if((loc_logger.DEBUG_LEVEL >= 5) && (loc_logger.DEBUG_LEVEL <= 5))
+
+#define LOC_LOGE(...) \
+IF_LOC_LOGE { ALOGE("E/" __VA_ARGS__); } \
+else if (loc_logger.DEBUG_LEVEL == 0xff) { ALOGE("E/" __VA_ARGS__); }
+
+#define LOC_LOGW(...) \
+IF_LOC_LOGW { ALOGE("W/" __VA_ARGS__); }  \
+else if (loc_logger.DEBUG_LEVEL == 0xff) { ALOGW("W/" __VA_ARGS__); }
+
+#define LOC_LOGI(...) \
+IF_LOC_LOGI { ALOGE("I/" __VA_ARGS__); }   \
+else if (loc_logger.DEBUG_LEVEL == 0xff) { ALOGI("I/" __VA_ARGS__); }
+
+#define LOC_LOGD(...) \
+IF_LOC_LOGD { ALOGE("D/" __VA_ARGS__); }   \
+else if (loc_logger.DEBUG_LEVEL == 0xff) { ALOGD("D/" __VA_ARGS__); }
+
+#define LOC_LOGV(...) \
+IF_LOC_LOGV { ALOGE("V/" __VA_ARGS__); }   \
+else if (loc_logger.DEBUG_LEVEL == 0xff) { ALOGV("V/" __VA_ARGS__); }
+
+#else /* DEBUG_DMN_LOC_API */
+
+#define LOC_LOGE(...) ALOGE("E/" __VA_ARGS__)
+
+#define LOC_LOGW(...) ALOGW("W/" __VA_ARGS__)
+
+#define LOC_LOGI(...) ALOGI("I/" __VA_ARGS__)
+
+#define LOC_LOGD(...) ALOGD("D/" __VA_ARGS__)
+
+#define LOC_LOGV(...) ALOGV("V/" __VA_ARGS__)
+
+#endif /* DEBUG_DMN_LOC_API */
+
+/*=============================================================================
+ *
+ *                          LOGGING IMPROVEMENT MACROS
+ *
+ *============================================================================*/
+#define LOG_(LOC_LOG, ID, WHAT, SPEC, VAL)                                    \
+    do {                                                                      \
+        if (loc_logger.TIMESTAMP) {                                           \
+            char ts[32];                                                      \
+            LOC_LOG("[%s] %s %s line %d " #SPEC,                              \
+                     get_timestamp(ts, sizeof(ts)), ID, WHAT, __LINE__, VAL); \
+        } else {                                                              \
+            LOC_LOG("%s %s line %d " #SPEC,                                   \
+                     ID, WHAT, __LINE__, VAL);                                \
+        }                                                                     \
+    } while(0)
+
+
+#define LOG_I(ID, WHAT, SPEC, VAL) LOG_(LOC_LOGI, ID, WHAT, SPEC, VAL)
+#define LOG_V(ID, WHAT, SPEC, VAL) LOG_(LOC_LOGV, ID, WHAT, SPEC, VAL)
+
+#define ENTRY_LOG() LOG_V(ENTRY_TAG, __func__, %s, "")
+#define EXIT_LOG(SPEC, VAL) LOG_V(EXIT_TAG, __func__, SPEC, VAL)
+
+
+// Used for logging callflow from Android Framework
+#define ENTRY_LOG_CALLFLOW() LOG_I(FROM_AFW, __func__, %s, "")
+// Used for logging callflow to Modem
+#define EXIT_LOG_CALLFLOW(SPEC, VAL) LOG_I(TO_MODEM, __func__, SPEC, VAL)
+// Used for logging callflow from Modem(TO_MODEM, __func__, %s, "")
+#define MODEM_LOG_CALLFLOW(SPEC, VAL) LOG_I(FROM_MODEM, __func__, SPEC, VAL)
+// Used for logging callflow to Android Framework
+#define CALLBACK_LOG_CALLFLOW(CB, SPEC, VAL) LOG_I(TO_AFW, CB, SPEC, VAL)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __LOG_UTIL_H__
diff --git a/msm8974/utils/msg_q.c b/msm8974/utils/msg_q.c
new file mode 100644
index 0000000..2abcfb1
--- /dev/null
+++ b/msm8974/utils/msg_q.c
@@ -0,0 +1,336 @@
+/* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation, nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "msg_q.h"
+
+#define LOG_TAG "LocSvc_utils_q"
+#include "log_util.h"
+#include "platform_lib_includes.h"
+#include "linked_list.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <pthread.h>
+
+typedef struct msg_q {
+   void* msg_list;                  /* Linked list to store information */
+   pthread_cond_t  list_cond;       /* Condition variable for waiting on msg queue */
+   pthread_mutex_t list_mutex;      /* Mutex for exclusive access to message queue */
+   int unblocked;                   /* Has this message queue been unblocked? */
+} msg_q;
+
+/*===========================================================================
+FUNCTION    convert_linked_list_err_type
+
+DESCRIPTION
+   Converts from one set of enum values to another.
+
+   linked_list_val: Value to convert to msg_q_enum_type
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   Corresponding linked_list_enum_type in msg_q_enum_type
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+static msq_q_err_type convert_linked_list_err_type(linked_list_err_type linked_list_val)
+{
+   switch( linked_list_val )
+   {
+   case eLINKED_LIST_SUCCESS:
+      return eMSG_Q_SUCCESS;
+   case eLINKED_LIST_INVALID_PARAMETER:
+      return eMSG_Q_INVALID_PARAMETER;
+   case eLINKED_LIST_INVALID_HANDLE:
+      return eMSG_Q_INVALID_HANDLE;
+   case eLINKED_LIST_UNAVAILABLE_RESOURCE:
+      return eMSG_Q_UNAVAILABLE_RESOURCE;
+   case eLINKED_LIST_INSUFFICIENT_BUFFER:
+      return eMSG_Q_INSUFFICIENT_BUFFER;
+
+   case eLINKED_LIST_FAILURE_GENERAL:
+   default:
+      return eMSG_Q_FAILURE_GENERAL;
+   }
+}
+
+/* ----------------------- END INTERNAL FUNCTIONS ---------------------------------------- */
+
+/*===========================================================================
+
+  FUNCTION:   msg_q_init
+
+  ===========================================================================*/
+msq_q_err_type msg_q_init(void** msg_q_data)
+{
+   if( msg_q_data == NULL )
+   {
+      LOC_LOGE("%s: Invalid msg_q_data parameter!\n", __FUNCTION__);
+      return eMSG_Q_INVALID_PARAMETER;
+   }
+
+   msg_q* tmp_msg_q;
+   tmp_msg_q = (msg_q*)calloc(1, sizeof(msg_q));
+   if( tmp_msg_q == NULL )
+   {
+      LOC_LOGE("%s: Unable to allocate space for message queue!\n", __FUNCTION__);
+      return eMSG_Q_FAILURE_GENERAL;
+   }
+
+   if( linked_list_init(&tmp_msg_q->msg_list) != 0 )
+   {
+      LOC_LOGE("%s: Unable to initialize storage list!\n", __FUNCTION__);
+      free(tmp_msg_q);
+      return eMSG_Q_FAILURE_GENERAL;
+   }
+
+   if( pthread_mutex_init(&tmp_msg_q->list_mutex, NULL) != 0 )
+   {
+      LOC_LOGE("%s: Unable to initialize list mutex!\n", __FUNCTION__);
+      linked_list_destroy(&tmp_msg_q->msg_list);
+      free(tmp_msg_q);
+      return eMSG_Q_FAILURE_GENERAL;
+   }
+
+   if( pthread_cond_init(&tmp_msg_q->list_cond, NULL) != 0 )
+   {
+      LOC_LOGE("%s: Unable to initialize msg q cond var!\n", __FUNCTION__);
+      linked_list_destroy(&tmp_msg_q->msg_list);
+      pthread_mutex_destroy(&tmp_msg_q->list_mutex);
+      free(tmp_msg_q);
+      return eMSG_Q_FAILURE_GENERAL;
+   }
+
+   tmp_msg_q->unblocked = 0;
+
+   *msg_q_data = tmp_msg_q;
+
+   return eMSG_Q_SUCCESS;
+}
+
+/*===========================================================================
+
+  FUNCTION:   msg_q_init2
+
+  ===========================================================================*/
+const void* msg_q_init2()
+{
+  void* q = NULL;
+  if (eMSG_Q_SUCCESS != msg_q_init(&q)) {
+    q = NULL;
+  }
+  return q;
+}
+
+/*===========================================================================
+
+  FUNCTION:   msg_q_destroy
+
+  ===========================================================================*/
+msq_q_err_type msg_q_destroy(void** msg_q_data)
+{
+   if( msg_q_data == NULL )
+   {
+      LOC_LOGE("%s: Invalid msg_q_data parameter!\n", __FUNCTION__);
+      return eMSG_Q_INVALID_HANDLE;
+   }
+
+   msg_q* p_msg_q = (msg_q*)*msg_q_data;
+
+   linked_list_destroy(&p_msg_q->msg_list);
+   pthread_mutex_destroy(&p_msg_q->list_mutex);
+   pthread_cond_destroy(&p_msg_q->list_cond);
+
+   p_msg_q->unblocked = 0;
+
+   free(*msg_q_data);
+   *msg_q_data = NULL;
+
+   return eMSG_Q_SUCCESS;
+}
+
+/*===========================================================================
+
+  FUNCTION:   msg_q_snd
+
+  ===========================================================================*/
+msq_q_err_type msg_q_snd(void* msg_q_data, void* msg_obj, void (*dealloc)(void*))
+{
+   msq_q_err_type rv;
+   if( msg_q_data == NULL )
+   {
+      LOC_LOGE("%s: Invalid msg_q_data parameter!\n", __FUNCTION__);
+      return eMSG_Q_INVALID_HANDLE;
+   }
+   if( msg_obj == NULL )
+   {
+      LOC_LOGE("%s: Invalid msg_obj parameter!\n", __FUNCTION__);
+      return eMSG_Q_INVALID_PARAMETER;
+   }
+
+   msg_q* p_msg_q = (msg_q*)msg_q_data;
+
+   pthread_mutex_lock(&p_msg_q->list_mutex);
+   LOC_LOGD("%s: Sending message with handle = 0x%p\n", __FUNCTION__, msg_obj);
+
+   if( p_msg_q->unblocked )
+   {
+      LOC_LOGE("%s: Message queue has been unblocked.\n", __FUNCTION__);
+      pthread_mutex_unlock(&p_msg_q->list_mutex);
+      return eMSG_Q_UNAVAILABLE_RESOURCE;
+   }
+
+   rv = convert_linked_list_err_type(linked_list_add(p_msg_q->msg_list, msg_obj, dealloc));
+
+   /* Show data is in the message queue. */
+   pthread_cond_signal(&p_msg_q->list_cond);
+
+   pthread_mutex_unlock(&p_msg_q->list_mutex);
+
+   LOC_LOGD("%s: Finished Sending message with handle = 0x%p\n", __FUNCTION__, msg_obj);
+
+   return rv;
+}
+
+/*===========================================================================
+
+  FUNCTION:   msg_q_rcv
+
+  ===========================================================================*/
+msq_q_err_type msg_q_rcv(void* msg_q_data, void** msg_obj)
+{
+   msq_q_err_type rv;
+   if( msg_q_data == NULL )
+   {
+      LOC_LOGE("%s: Invalid msg_q_data parameter!\n", __FUNCTION__);
+      return eMSG_Q_INVALID_HANDLE;
+   }
+
+   if( msg_obj == NULL )
+   {
+      LOC_LOGE("%s: Invalid msg_obj parameter!\n", __FUNCTION__);
+      return eMSG_Q_INVALID_PARAMETER;
+   }
+
+   msg_q* p_msg_q = (msg_q*)msg_q_data;
+
+   LOC_LOGD("%s: Waiting on message\n", __FUNCTION__);
+
+   pthread_mutex_lock(&p_msg_q->list_mutex);
+
+   if( p_msg_q->unblocked )
+   {
+      LOC_LOGE("%s: Message queue has been unblocked.\n", __FUNCTION__);
+      pthread_mutex_unlock(&p_msg_q->list_mutex);
+      return eMSG_Q_UNAVAILABLE_RESOURCE;
+   }
+
+   /* Wait for data in the message queue */
+   while( linked_list_empty(p_msg_q->msg_list) && !p_msg_q->unblocked )
+   {
+      pthread_cond_wait(&p_msg_q->list_cond, &p_msg_q->list_mutex);
+   }
+
+   rv = convert_linked_list_err_type(linked_list_remove(p_msg_q->msg_list, msg_obj));
+
+   pthread_mutex_unlock(&p_msg_q->list_mutex);
+
+   LOC_LOGD("%s: Received message 0x%p rv = %d\n", __FUNCTION__, *msg_obj, rv);
+
+   return rv;
+}
+
+/*===========================================================================
+
+  FUNCTION:   msg_q_flush
+
+  ===========================================================================*/
+msq_q_err_type msg_q_flush(void* msg_q_data)
+{
+   msq_q_err_type rv;
+   if ( msg_q_data == NULL )
+   {
+      LOC_LOGE("%s: Invalid msg_q_data parameter!\n", __FUNCTION__);
+      return eMSG_Q_INVALID_HANDLE;
+   }
+
+   msg_q* p_msg_q = (msg_q*)msg_q_data;
+
+   LOC_LOGD("%s: Flushing Message Queue\n", __FUNCTION__);
+
+   pthread_mutex_lock(&p_msg_q->list_mutex);
+
+   /* Remove all elements from the list */
+   rv = convert_linked_list_err_type(linked_list_flush(p_msg_q->msg_list));
+
+   pthread_mutex_unlock(&p_msg_q->list_mutex);
+
+   LOC_LOGD("%s: Message Queue flushed\n", __FUNCTION__);
+
+   return rv;
+}
+
+/*===========================================================================
+
+  FUNCTION:   msg_q_unblock
+
+  ===========================================================================*/
+msq_q_err_type msg_q_unblock(void* msg_q_data)
+{
+   if ( msg_q_data == NULL )
+   {
+      LOC_LOGE("%s: Invalid msg_q_data parameter!\n", __FUNCTION__);
+      return eMSG_Q_INVALID_HANDLE;
+   }
+
+   msg_q* p_msg_q = (msg_q*)msg_q_data;
+   pthread_mutex_lock(&p_msg_q->list_mutex);
+
+   if( p_msg_q->unblocked )
+   {
+      LOC_LOGE("%s: Message queue has been unblocked.\n", __FUNCTION__);
+      pthread_mutex_unlock(&p_msg_q->list_mutex);
+      return eMSG_Q_UNAVAILABLE_RESOURCE;
+   }
+
+   LOC_LOGD("%s: Unblocking Message Queue\n", __FUNCTION__);
+   /* Unblocking message queue */
+   p_msg_q->unblocked = 1;
+
+   /* Allow all the waiters to wake up */
+   pthread_cond_broadcast(&p_msg_q->list_cond);
+
+   pthread_mutex_unlock(&p_msg_q->list_mutex);
+
+   LOC_LOGD("%s: Message Queue unblocked\n", __FUNCTION__);
+
+   return eMSG_Q_SUCCESS;
+}
diff --git a/msm8974/utils/msg_q.h b/msm8974/utils/msg_q.h
new file mode 100644
index 0000000..453b8ce
--- /dev/null
+++ b/msm8974/utils/msg_q.h
@@ -0,0 +1,207 @@
+/* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __MSG_Q_H__
+#define __MSG_Q_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#include <stdlib.h>
+
+/** Linked List Return Codes */
+typedef enum
+{
+  eMSG_Q_SUCCESS                             = 0,
+     /**< Request was successful. */
+  eMSG_Q_FAILURE_GENERAL                     = -1,
+     /**< Failed because of a general failure. */
+  eMSG_Q_INVALID_PARAMETER                   = -2,
+     /**< Failed because the request contained invalid parameters. */
+  eMSG_Q_INVALID_HANDLE                      = -3,
+     /**< Failed because an invalid handle was specified. */
+  eMSG_Q_UNAVAILABLE_RESOURCE                = -4,
+     /**< Failed because an there were not enough resources. */
+  eMSG_Q_INSUFFICIENT_BUFFER                 = -5,
+     /**< Failed because an the supplied buffer was too small. */
+}msq_q_err_type;
+
+/*===========================================================================
+FUNCTION    msg_q_init
+
+DESCRIPTION
+   Initializes internal structures for message queue.
+
+   msg_q_data: pointer to an opaque Q handle to be returned; NULL if fails
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   Look at error codes above.
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+msq_q_err_type msg_q_init(void** msg_q_data);
+
+/*===========================================================================
+FUNCTION    msg_q_init2
+
+DESCRIPTION
+   Initializes internal structures for message queue.
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   opaque handle to the Q created; NULL if create fails
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+const void* msg_q_init2();
+
+/*===========================================================================
+FUNCTION    msg_q_destroy
+
+DESCRIPTION
+   Releases internal structures for message queue.
+
+   msg_q_data: State of message queue to be released.
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   Look at error codes above.
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+msq_q_err_type msg_q_destroy(void** msg_q_data);
+
+/*===========================================================================
+FUNCTION    msg_q_snd
+
+DESCRIPTION
+   Sends data to the message queue. The passed in data pointer
+   is not modified or freed. Passed in msg_obj is expected to live throughout
+   the use of the msg_q (i.e. data is not allocated internally)
+
+   msg_q_data: Message Queue to add the element to.
+   msgp:       Pointer to data to add into message queue.
+   dealloc:    Function used to deallocate memory for this element. Pass NULL
+               if you do not want data deallocated during a flush operation
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   Look at error codes above.
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+msq_q_err_type msg_q_snd(void* msg_q_data, void* msg_obj, void (*dealloc)(void*));
+
+/*===========================================================================
+FUNCTION    msg_q_rcv
+
+DESCRIPTION
+   Retrieves data from the message queue. msg_obj is the oldest message received
+   and pointer is simply removed from message queue.
+
+   msg_q_data: Message Queue to copy data from into msgp.
+   msg_obj:    Pointer to space to copy msg_q contents to.
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   Look at error codes above.
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+msq_q_err_type msg_q_rcv(void* msg_q_data, void** msg_obj);
+
+/*===========================================================================
+FUNCTION    msg_q_flush
+
+DESCRIPTION
+   Function removes all elements from the message queue.
+
+   msg_q_data: Message Queue to remove elements from.
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   Look at error codes above.
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+msq_q_err_type msg_q_flush(void* msg_q_data);
+
+/*===========================================================================
+FUNCTION    msg_q_unblock
+
+DESCRIPTION
+   This function will stop use of the message queue. All waiters will wake up
+   and likely receive nothing from the queue resulting in a negative return
+   value. The message queue can no longer be used until it is destroyed
+   and initialized again after calling this function.
+
+   msg_q_data: Message queue to unblock.
+
+DEPENDENCIES
+   N/A
+
+RETURN VALUE
+   Look at error codes above.
+
+SIDE EFFECTS
+   N/A
+
+===========================================================================*/
+msq_q_err_type msg_q_unblock(void* msg_q_data);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __MSG_Q_H__ */
-- 
2.17.1

