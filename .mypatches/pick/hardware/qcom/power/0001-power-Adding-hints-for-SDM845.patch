From 2ee726184ff4bbbc6dfc4f5f34cd2a4c558a82f3 Mon Sep 17 00:00:00 2001
From: Ananth Raghavan Subramanian <sananth@codeaurora.org>
Date: Thu, 14 Sep 2017 22:34:10 -0700
Subject: [PATCH 1/2] power: Adding hints for SDM845

Porting hint implementation for video encode, sustained performance and
VR to SDM845

Change-Id: If90b8070fea33b37043cb5abb331e641f2dd695d
---
 power-845.c | 152 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 152 insertions(+)

diff --git a/power-845.c b/power-845.c
index 0307ca9..3958733 100644
--- a/power-845.c
+++ b/power-845.c
@@ -53,10 +53,162 @@
 
 static int display_fd;
 
+#define CHECK_HANDLE(x) ((x)>0)
+#define NUM_PERF_MODES  3
+
+typedef enum {
+    NORMAL_MODE       = 0,
+    SUSTAINED_MODE    = 1,
+    VR_MODE           = 2,
+    VR_SUSTAINED_MODE = (SUSTAINED_MODE|VR_MODE),
+    INVALID_MODE      = 0xFF
+} perf_mode_type_t;
+
+typedef struct perf_mode {
+    perf_mode_type_t type;
+    int perf_hint_id;
+} perf_mode_t;
+
+perf_mode_t perf_modes[NUM_PERF_MODES] = {
+    { SUSTAINED_MODE, SUSTAINED_PERF_HINT },
+    { VR_MODE, VR_MODE_HINT },
+    { VR_SUSTAINED_MODE, VR_MODE_SUSTAINED_PERF_HINT }
+};
+
+static pthread_mutex_t perf_mode_switch_lock = PTHREAD_MUTEX_INITIALIZER;
+static int current_mode = NORMAL_MODE;
+
+static inline int get_perfd_hint_id(perf_mode_type_t type) {
+    int i;
+    for (i = 0; i < NUM_PERF_MODES; i++) {
+        if (perf_modes[i].type == type) {
+            ALOGD("Hint id is 0x%x for mode 0x%x", perf_modes[i].perf_hint_id, type);
+            return perf_modes[i].perf_hint_id;
+        }
+    }
+    ALOGD("Couldn't find the hint for mode 0x%x", type);
+    return 0;
+}
+
+static int switch_mode(perf_mode_type_t mode) {
+    int hint_id = 0;
+    static int perfd_mode_handle = -1;
+
+    // release existing mode if any
+    if (CHECK_HANDLE(perfd_mode_handle)) {
+        ALOGD("Releasing handle 0x%x", perfd_mode_handle);
+        release_request(perfd_mode_handle);
+        perfd_mode_handle = -1;
+    }
+    // switch to a perf mode
+    hint_id = get_perfd_hint_id(mode);
+    if (hint_id != 0) {
+        perfd_mode_handle = perf_hint_enable(hint_id, 0);
+        if (!CHECK_HANDLE(perfd_mode_handle)) {
+            ALOGE("Failed perf_hint_interaction for mode: 0x%x", mode);
+            return -1;
+        }
+        ALOGD("Acquired handle 0x%x", perfd_mode_handle);
+    }
+    return 0;
+}
+
+static int process_perf_hint(void *data, perf_mode_type_t mode) {
+
+    pthread_mutex_lock(&perf_mode_switch_lock);
+
+    // enable
+    if (data) {
+        ALOGI("Enable request for mode: 0x%x", mode);
+        // check if mode is current mode
+        if (current_mode & mode) {
+            pthread_mutex_unlock(&perf_mode_switch_lock);
+            ALOGD("Mode 0x%x already enabled", mode);
+            return HINT_HANDLED;
+        }
+        // enable requested mode
+        if (0 != switch_mode(current_mode | mode)) {
+            pthread_mutex_unlock(&perf_mode_switch_lock);
+            ALOGE("Couldn't enable mode 0x%x", mode);
+            return HINT_NONE;
+        }
+        current_mode |= mode;
+        ALOGI("Current mode is 0x%x", current_mode);
+    // disable
+    } else {
+        ALOGI("Disable request for mode: 0x%x", mode);
+        // check if mode is enabled
+        if (!(current_mode & mode)) {
+            pthread_mutex_unlock(&perf_mode_switch_lock);
+            ALOGD("Mode 0x%x already disabled", mode);
+            return HINT_HANDLED;
+        }
+        // disable requested mode
+        if (0 != switch_mode(current_mode & ~mode)) {
+            pthread_mutex_unlock(&perf_mode_switch_lock);
+            ALOGE("Couldn't disable mode 0x%x", mode);
+            return HINT_NONE;
+        }
+        current_mode &= ~mode;
+        ALOGI("Current mode is 0x%x", current_mode);
+    }
+
+    pthread_mutex_unlock(&perf_mode_switch_lock);
+    return HINT_HANDLED;
+}
+
+static int process_video_encode_hint(void *metadata)
+{
+    char governor[80];
+    struct video_encode_metadata_t video_encode_metadata;
+    static int video_encode_handle = 0;
+
+    if (!metadata) {
+        return HINT_NONE;
+    }
+
+    if (get_scaling_governor(governor, sizeof(governor)) == -1) {
+        ALOGE("Can't obtain scaling governor.");
+        return HINT_NONE;
+    }
+
+    /* Initialize encode metadata struct fields */
+    memset(&video_encode_metadata, 0, sizeof(struct video_encode_metadata_t));
+    video_encode_metadata.state = -1;
+
+    if (parse_video_encode_metadata((char *)metadata, &video_encode_metadata) == -1) {
+        ALOGE("Error occurred while parsing metadata.");
+        return HINT_NONE;
+    }
+
+    if (video_encode_metadata.state == 1) {
+        if (is_interactive_governor(governor)) {
+            video_encode_handle = perf_hint_enable(
+                    VIDEO_ENCODE_HINT, 0);
+            return HINT_HANDLED;
+        }
+    } else if (video_encode_metadata.state == 0) {
+        if (is_interactive_governor(governor)) {
+            release_request(video_encode_handle);
+            return HINT_HANDLED;
+        }
+    }
+    return HINT_NONE;
+}
+
 int power_hint_override(power_hint_t hint, void *UNUSED(data))
 {
     int ret_val = HINT_NONE;
     switch (hint) {
+        case POWER_HINT_VIDEO_ENCODE:
+            ret_val = process_video_encode_hint(data);
+            break;
+        case POWER_HINT_SUSTAINED_PERFORMANCE:
+            ret_val = process_perf_hint(data, SUSTAINED_MODE);
+            break;
+        case POWER_HINT_VR_MODE:
+            ret_val = process_perf_hint(data, VR_MODE);
+            break;
         case POWER_HINT_INTERACTION:
             int resources[] = {
                 MIN_FREQ_LITTLE_CORE_0, 0x553
-- 
2.17.1

